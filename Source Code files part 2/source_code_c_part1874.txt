t != 0);
    if (psmwp == &gSMWP) {
        UserAssert(psmwp->bHandle == FALSE);
        acvr = (PCVR)UserAllocPool(sizeof(CVR) * cwndHint, TAG_SWP);        
    } else {
        acvr = (PCVR)UserAllocPoolWithQuota(sizeof(CVR) * cwndHint, TAG_SWP);
    }
    if (acvr == NULL) {
        return FALSE;
    }

    /*
     * Initialize psmwp related fields.
     * CVR array is initialized by _DeferWindowPos
     */

    psmwp->acvr      = acvr;
    psmwp->ccvrAlloc = cwndHint;
    psmwp->ccvr      = 0;
    return TRUE;
}

/***************************************************************************\
* InternalBeginDeferWindowPos
*
* History:
* 05/20/98  GerardoB    Created
\***************************************************************************/
PSMWP InternalBeginDeferWindowPos(
    int cwndHint)
{
    PSMWP psmwp;

    CheckCritIn();

    /*
     * If gSMWP in being used, allocate one.
     * Note that SMWP is zero init but CVR is not; _DeferWindowPos initializes it.
     */
    if (TEST_PUDF(PUDF_GSMWPINUSE) || (cwndHint > gSMWP.ccvrAlloc)) {
        psmwp = (PSMWP)UserAllocPoolWithQuotaZInit(sizeof(SMWP), TAG_SWP);
        if (psmwp == NULL) {
            return NULL;
        }
        if (!AllocateCvr(psmwp, cwndHint)) {
            UserFreePool(psmwp);
            return NULL;
        }
    } else {
        SET_PUDF(PUDF_GSMWPINUSE);
        psmwp = &gSMWP;
        RtlZeroMemory(&gSMWP, FIELD_OFFSET(SMWP, ccvrAlloc));
        UserAssert(gSMWP.ccvr == 0);
        UserAssert(gSMWP.acvr != NULL);
    }

    DBGCheckSMWP(psmwp);
    return psmwp;
}

/***************************************************************************\
* BeginDeferWindowPos (API)
*
* This must be called from the client side only. Internally we should
*  call InternalBeginDeferWindowPos to avoid going through the handle table
*  and perhaps even use the cached strucuture.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
PSMWP _BeginDeferWindowPos(
    int cwndHint)
{
    PSMWP psmwp;

    psmwp = (PSMWP)HMAllocObject(PtiCurrent(), NULL, TYPE_SETWINDOWPOS, sizeof(SMWP));
    if (psmwp == NULL) {
        return NULL;
    }

    if (cwndHint == 0) {
        cwndHint = 8;
    }

    if (!AllocateCvr(psmwp, cwndHint)) {
        HMFreeObject(psmwp);
        return NULL;
    }

    psmwp->bHandle = TRUE;
    DBGCheckSMWP(psmwp);

    return psmwp;
}

/***************************************************************************\
* PWInsertAfter
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/
PWND PWInsertAfter(
   HWND hwnd)
{
    PWND pwnd;

    /*
     * HWND_GROUPTOTOP and HWND_TOPMOST are the same thing.
     */
    switch ((ULONG_PTR)hwnd) {
    case (ULONG_PTR)HWND_TOP:
    case (ULONG_PTR)HWND_BOTTOM:
    case (ULONG_PTR)HWND_TOPMOST:
    case (ULONG_PTR)HWND_NOTOPMOST:
        return (PWND)hwnd;

    default:

        /*
         * Don't insert after a destroyed window!  It will cause the
         * window being z-ordered to become unlinked from it's siblings.
         */
        if (pwnd = RevalidateHwnd(hwnd)) {

            /*
             * Do not insert after a destroyed window. Put it at the
             * bottom of the list, if it is z-ordered at all.
             */
            if (TestWF(pwnd, WFDESTROYED) || pwnd->spwndParent == NULL)
                return NULL;

            UserAssert(_IsDescendant(pwnd->spwndParent, pwnd));
            return pwnd;
        }

        return NULL;
    }
}

HWND HWInsertAfter(
    PWND pwnd)
{
    /*
     * HWND_GROUPTOTOP and HWND_TOPMOST are the same thing.
     */
    switch ((ULONG_PTR)pwnd) {
    case (ULONG_PTR)HWND_TOP:
    case (ULONG_PTR)HWND_BOTTOM:
    case (ULONG_PTR)HWND_TOPMOST:
    case (ULONG_PTR)HWND_NOTOPMOST:
        return (HWND)pwnd;

    default:
        return HW(pwnd);
    }
}

/***************************************************************************\
* DeferWindowPos (API)
*
*
* History:
* 07-11-91 darrinm      Ported from Win 3.1 sources.
\***************************************************************************/
PSMWP _DeferWindowPos(
    PSMWP psmwp,
    PWND  pwnd,
    PWND  pwndInsertAfter,
    int   x,
    int   y,
    int   cx,
    int   cy,
    UINT  flags)
{
    PWINDOWPOS ppos;
    PCVR       pcvr;

    DBGCheckSMWP(psmwp);
    if (psmwp->ccvr + 1 > psmwp->ccvrAlloc) {
        /*
         * Make space for 4 more windows.
         */
        DWORD dwNewAlloc = psmwp->ccvrAlloc + 4;
        if (psmwp == &gSMWP) {
            UserAssert(psmwp->bHandle == FALSE);
            pcvr = (PCVR)UserReAllocPoolWithTag(psmwp->acvr,
                                                  psmwp->ccvrAlloc * sizeof(CVR),
                                                  sizeof(CVR) * dwNewAlloc,
                                                  TAG_SWP);            
        } else {
            pcvr = (PCVR)UserReAllocPoolWithQuota(psmwp->acvr,
                                                  psmwp->ccvrAlloc * sizeof(CVR),
                                                  sizeof(CVR) * dwNewAlloc,
                                                  TAG_SWP);
        }
        if (pcvr == NULL) {
            DestroySMWP(psmwp);
            return NULL;
        }

        psmwp->acvr = pcvr;
        psmwp->ccvrAlloc = dwNewAlloc;
    }

    pcvr = &psmwp->acvr[psmwp->ccvr++];
    ppos = &pcvr->pos;

    ppos->hwnd            = HWq(pwnd);
    ppos->hwndInsertAfter = (TestWF(pwnd, WFBOTTOMMOST)) ?
                                HWND_BOTTOM : HWInsertAfter(pwndInsertAfter);
    ppos->x               = x;
    ppos->y               = y;
    ppos->cx              = cx;
    ppos->cy              = cy;
    ppos->flags           = flags;

    pcvr->hrgnClip = NULL;
    pcvr->hrgnInterMonitor = NULL;

    return psmwp;
}

/***************************************************************************\
* ValidateWindowPos
*
* checks validity of SWP structure
*
* NOTE: For performance reasons, this routine is only called
*       in the DEBUG version of USER.
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL ValidateWindowPos(
    PCVR pcvr,
    PWND pwndParent)
{
    PWND pwnd;
    PWND pwndInsertAfter;
    HWND hwndInsertAfter;

    if ((pwnd = RevalidateHwnd(pcvr->pos.hwnd)) == NULL)
        return FALSE;

    /*
     * Save the pti.
     */
    pcvr->pti = GETPTI(pwnd);


    /*
     * If the SWP_NOZORDER bit is not set, validate the Insert behind window.
     */
    if (!(pcvr->pos.flags & SWP_NOZORDER)) {
        BOOL fTopLevel = (pwnd->spwndParent == PWNDDESKTOP(pwnd));
        /*
         * Do not z-order destroyed windows
         */
        if (TestWF(pwnd, WFDESTROYED))
            return FALSE;

        hwndInsertAfter = pcvr->pos.hwndInsertAfter;
        /*
         * If pwndParent is provided, we're about to link this window so we
         * need to validate LinkWindow assumptions. We have to do this since
         * we callback after determining hwndInsertAfter.
         */

        if ((hwndInsertAfter == HWND_TOPMOST) ||
            (hwndInsertAfter == HWND_NOTOPMOST)) {

            if (!fTopLevel) {
                return FALSE;
            }
        } else if (hwndInsertAfter == HWND_TOP) {
            /*
             * If pwnd is not topmost, the first child must not be topmost.
             */
            if ((pwndParent != NULL) && fTopLevel
                    && !FSwpTopmost(pwnd)
                    && (pwndParent->spwndChild != NULL)
                    && FSwpTopmost(pwndParent->spwndChild)) {

                RIPMSG2(RIP_WARNING, "ValidateWindowPos: pwnd is not SWPTopMost."
                                     " pwnd:%#p. hwndInsertAfter:%#p",
                                      pwnd, hwndInsertAfter);
                return FALSE;
            }
        } else if (hwndInsertAfter != HWND_BOTTOM) {

            /*
             * Ensure pwndInsertAfter is valid
             */
            if (((pwndInsertAfter = RevalidateHwnd(hwndInsertAfter)) == NULL) ||
                    TestWF(pwndInsertAfter, WFDESTROYED)) {

                RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING, "Invalid hwndInsertAfter (%#p)", hwndInsertAfter);

                return FALSE;
            }

            /*
             * Ensure that pwndInsertAfter is a sibling of pwnd
             */
            if (pwnd == pwndInsertAfter ||
                    pwnd->spwndParent != pwndInsertAfter->spwndParent) {
                RIPMSG2(RIP_WARNING, "hwndInsertAfter (%#p) is not a sibling "
                        "of hwnd (%#p)", hwndInsertAfter, pcvr->pos.hwnd);
                return FALSE;
            }
            /*
             * Ensure proper topmost/nontopmost insert position
             */
            if ((pwndParent != NULL) && fTopLevel) {
                if (FSwpTopmost(pwnd)) {
                    /*
                     * Check if we're trying to insert a topmost window after a non-topmost one.
                     */
                    if (!FSwpTopmost(pwndInsertAfter)) {
                        RIPMSG2(RIP_WARNING, "ValidateWindowPos: pwndInsertAfter is not SWPTopMost."
                                             " pwnd:%#p. pwndInsertAfter:%#p",
                                              pwnd, pwndInsertAfter);
                        return FALSE;
                    }
                } else {
                    /*
                     * Check if we're trying to insert a non-top most window
                     * between two top-most ones.
                     */
                    if ((pwndInsertAfter->spwndNext != NULL)
                            && FSwpTopmost(pwndInsertAfter->spwndNext)) {

                        RIPMSG2(RIP_WARNING, "ValidateWindowPos: pwndInsertAfter->spwndNext is SWPTopMost."
                                             " pwnd:%#p. pwndInsertAfter:%#p",
                                              pwnd, pwndInsertAfter);
                        return FALSE;
                    }
                }

            }

        }

        /*
         * Check that the parent hasn't changed.
         */
        if (pwndParent != NULL) {
            if (pwndParent != pwnd->spwndParent) {
                RIPMSG3(RIP_WARNING, "ValidateWindowPos: parent has changed."
                                     " pwnd:%#p. Old Parent:%#p. Current Parent:%#p",
                                      pwnd, pwndParent, pwnd->spwndParent);
                return FALSE;
            }
        }

    }

    return TRUE;
}

/***************************************************************************\
* IsStillWindowC
*
* Checks if window is valid HWNDC still, and child of proper dude.
*
* History:
\***************************************************************************/
BOOL IsStillWindowC(
    HWND hwndc)
{
    switch ((ULONG_PTR)hwndc) {
    case (ULONG_PTR)HWND_TOP:
    case (ULONG_PTR)HWND_BOTTOM:
    case (ULONG_PTR)HWND_TOPMOST:
    case (ULONG_PTR)HWND_NOTOPMOST:
        return TRUE;

    default:
        /*
         * Make sure we're going to insert after a window that's:
         *  (1) Valid
         *  (2) Peer
         */
        return (RevalidateHwnd(hwndc) != 0);
    }
}

/***************************************************************************\
* ValidateSmwp
*
* Validate the SMWP and figure out which window should get activated,
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL ValidateSmwp(
    PSMWP psmwp,
    BOOL  *pfSyncPaint)
{
    PCVR pcvr;
    PWND pwndParent;
    PWND pwndT;
    int  ccvr;

    *pfSyncPaint = TRUE;

    pwndT = RevalidateHwnd(psmwp->acvr[0].pos.hwnd);

    if (pwndT == NULL)
        return FALSE;

    pwndParent = pwndT->spwndParent;

    /*
     * Validate the passed-in WINDOWPOS structs, and find a window to activate.
     */
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        if (!ValidateWindowPos(pcvr, NULL)) {
            pcvr->pos.hwnd = NULL;
            continue;
        }

        /*
         * All windows in the pos list must have the same parent.
         * If not, yell and return FALSE.
         */
        UserAssert(IsStillWindowC(pcvr->pos.hwnd));

        UserAssert(PW(pcvr->pos.hwnd));
        if (PW(pcvr->pos.hwnd)->spwndParent != pwndParent) {
            RIPERR0(ERROR_HWNDS_HAVE_DIFF_PARENT, RIP_VERBOSE, "");
            return FALSE;
        }

        /*
         * If SWP_DEFERDRAWING is set for any of the windows, suppress
         * DoSyncPaint() call later.
         */
        if (pcvr->pos.flags & SWP_DEFERDRAWING)
            *pfSyncPaint = FALSE;
    }

    return TRUE;
}

/***************************************************************************\
* FindValidWindowPos
*
* Some of the windows in the SMWP list may be NULL at ths point (removed
* because they'll be handled by their creator's thread) so we've got to
* look for the first non-NULL window and return it.
*
* History:
* 10-Sep-1991 DarrinM    Created.
\***************************************************************************/
PWINDOWPOS FindValidWindowPos(
    PSMWP psmwp)
{
    int i;

    for (i = 0; i < psmwp->ccvr; i++) {

        if (psmwp->acvr[i].pos.hwnd != NULL)
            return &psmwp->acvr[i].pos;
    }

    return NULL;
}

/***************************************************************************\
* GetLastNonBottomMostWindow
*
* Returns the last non bottom-most window in the z-order, NULL if
* there isn't one. When figuring out whom to insert after, we want to
* skip ourself. But when figuring out if we're already in place, we don't
* want to skip ourself on enum.
*
* History:
\***************************************************************************/
PWND GetLastNonBottomMostWindow(
    PWND pwnd,
    BOOL fSkipSelf)
{
    PWND pwndT;
    PWND pwndLast = NULL;

    for (pwndT = pwnd->spwndParent->spwndChild;
         pwndT && !TestWF(pwndT, WFBOTTOMMOST);
         pwndT = pwndT->spwndNext) {

        if (!fSkipSelf || (pwnd != pwndT))
            pwndLast = pwndT;
    }

    return pwndLast;
}

/***************************************************************************\
* ValidateZorder
*
* Checks to see if the specified window is already in the specified Z order
* position, by comparing the current Z position with the specified
* pwndInsertAfter.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL ValidateZorder(
    PCVR pcvr)
{
    PWND pwnd;
    PWND pwndPrev;
    PWND pwndInsertAfter;
    BYTE bTopmost;

    /*
     * Validate just to make sure this routine doesn't do anything bogus.
     * Its caller will actually redetect and handle the error.
     */
    UserAssert(RevalidateCatHwnd(pcvr->pos.hwnd));
    pwnd = PWCat(pcvr->pos.hwnd);      // Known to be valid at this point.

    /*
     * Don't z-order a destroyed window.
     */
    if (TestWF(pwnd, WFDESTROYED)) {
        return TRUE;
    }

    UserAssert((HMPheFromObject(pwnd)->bFlags & HANDLEF_DESTROY) == 0);

    pwndInsertAfter = PWInsertAfter(pcvr->pos.hwndInsertAfter);
    if (pcvr->pos.hwndInsertAfter != NULL && pwndInsertAfter == NULL) {
        return TRUE;
    }

    if (pwndInsertAfter == PWND_BOTTOM) {
        if (TestWF(pwnd, WFBOTTOMMOST)) {
            return (pwnd->spwndNext == NULL);
        } else {
            return (pwnd == GetLastNonBottomMostWindow(pwnd, FALSE));
        }
    }

    pwndPrev = pwnd->spwndParent->spwndChild;
    if (pwndInsertAfter == PWND_TOP) {
        return pwndPrev == pwnd;
    }

    if (TestWF(pwndInsertAfter, WFDESTROYED)) {
        return TRUE;
    }

    /*
     * When we compare the state of the window, we must use
     * the EVENTUAL state of the window that is moving, but
     * the CURRENT state of the window it's inserted behind.
     *
     * Prevent nonbottommost windows from going behind the bottommost one.
     */
    if (TestWF(pwndInsertAfter, WFBOTTOMMOST)) {
        pcvr->pos.hwndInsertAfter = HWInsertAfter(GetLastNonBottomMostWindow(pwnd, TRUE));
        return FALSE;
    }

    /*
     * If we are not topmost, but pwndInsertAfter is, OR
     * if we are topmost, but pwndInsertAfter is not,
     * we need to adjust pwndInsertAfter to be the last of
     * the topmost windows.
     */
    bTopmost = TestWF(pwnd, WEFTOPMOST);

    if (TestWF(pwnd, WFTOGGLETOPMOST))
        bTopmost ^= LOBYTE(WEFTOPMOST);

    if (bTopmost != (BYTE)TestWF(pwndInsertAfter, WEFTOPMOST)) {

        pwndInsertAfter = GetLastTopMostWindow();

        /*
         * We're correctly positioned if we're already at the bottom
         */
        if (pwndInsertAfter == pwnd) {
            return TRUE;
        }

        pcvr->pos.hwndInsertAfter = HW(pwndInsertAfter);
    }

    /*
     * Look for our previous window in the list ...
     */
    if (pwndPrev != pwnd) {
        for (; pwndPrev != NULL; pwndPrev = pwndPrev->spwndNext) {
            if (pwndPrev->spwndNext == pwnd) {
                return pwndInsertAfter == pwndPrev;
            }
        }

        /*
         * NTRAID#NTBUG9-345299-2001/04/09-jasonsch
         *
         * If we get to here, pwnd is not in the sibling list.
         * REALLY BAD NEWS!
         *
         * Changing this to a warning since we seem to handle it fine
         * and there's a shell dude hitting this. Need to revisit
         * this in Blackcomb.
         */
        RIPMSG1(RIP_WARNING, "Pwnd 0x%p not found in sibling list.", pwnd);
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* xxxCalcValidRects
*
* Based on the WINDOWPOS flags in the fs parameter in each WINDOWPOS structure,
* this routine calcs the new position and size of each window, determines if
* its changing Z order, or whether its showing or hiding. Any redundant
* flags are AND'ed out of the fs parameter. If no redrawing is needed,
* SWP_NOREDRAW is OR'ed into the flags. This is called from EndDeferWindowPos.
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL xxxCalcValidRects(
    PSMWP psmwp,
    HWND  *phwndNewActive)
{
    PCVR              pcvr;
    PWND              pwnd;
    PWND              pwndParent;
    HWND              hwnd;
    HWND              hwndNewActive = NULL;
    PWINDOWPOS        ppos;
    BOOL              fNoZorder;
    BOOL              fForceNCCalcSize;
    NCCALCSIZE_PARAMS params;
    int               cxSrc;
    int               cySrc;
    int               cxDst;
    int               cyDst;
    int               cmd;
    int               ccvr;
    int               xClientOld;
    int               yClientOld;
    int               cxClientOld;
    int               cyClientOld;
    int               xWindowOld;
    int               xWindowOldLogical;
    int               yWindowOld;
    int               cxWindowOld;
    int               cyWindowOld;
    TL                tlpwndParent;
    TL                tlpwnd;
    BOOL              fSetZeroDx=FALSE;
    BOOL              fMirroredParent = FALSE;

    /*
     * Some of the windows in the SMWP list may be NULL at ths point
     * (removed because they'll be handled by their creator's thread)
     * so we've got to look for the first non-NULL window before we can
     * execute some of the tests below. FindValidWindowPos returns NULL if
     * the list has no valid windows in it.
     */
    if ((ppos = FindValidWindowPos(psmwp)) == NULL)
        return FALSE;

    UserAssert(PW(ppos->hwnd));
    pwndParent = PW(ppos->hwnd)->spwndParent;

    UserAssert(HMRevalidateCatHandle(PtoH(pwndParent)));

    ThreadLock(pwndParent, &tlpwndParent);

    fNoZorder = TRUE;

    /*
     * Go through the SMWP list, enumerating each WINDOWPOS, and compute
     * its new window and client rectangles.
     */
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        /*
         * This loop may leave the critsect during each iteration so
         * we revalidate pos.hwnd before use.
         */
        if ((hwnd = pcvr->pos.hwnd) == NULL)
            continue;

        pwnd = RevalidateHwnd(hwnd);

        if ((pwnd == NULL) || !IsStillWindowC(pcvr->pos.hwndInsertAfter)) {
            pcvr->pos.hwnd  = NULL;
            pcvr->pos.flags = SWP_NOREDRAW | SWP_NOCHANGE;
            continue;
        }

        ThreadLockAlways(pwnd, &tlpwnd);

        /*
         * Used for 3.0 compatibility. 3.0 sent the NCCALCSIZE message even if
         * the size of the window wasn't changing.
         */
        fForceNCCalcSize = FALSE;

        if (!hwndNewActive && !(pcvr->pos.flags & SWP_NOACTIVATE))
            hwndNewActive = HWq(pwnd);

        if (!(pcvr->pos.flags & SWP_NOSENDCHANGING)) {

            PWND pwndT;

            xxxSendMessage(pwnd, WM_WINDOWPOSCHANGING, 0, (LPARAM)&pcvr->pos);


            /*
             * Don't let them change pcvr->pos.hwnd. It doesn't make sense
             * plus it'll mess us up. I'm making this RIP_ERROR because we're
             * too close to RTM (7/11/96) just to make sure that we won't
             * break anyone. This should be changed to a RIP_WARNING after we
             * ship. Use LOWORD to ignore "changes" by NTVDM.
             */
#if DBG
            if (LOWORD(pcvr->pos.hwnd) != LOWORD(hwnd)) {
                RIPMSG0(RIP_ERROR,
                        "xxxCalcValidRects: Ignoring pcvr->pos.hwnd change by WM_WINDOWPOSCHANGING");
            }
#endif
            pcvr->pos.hwnd = hwnd;

            /*
             * If the window sets again 'hwndInsertAfter' to HWND_NOTOPMOST
             * or HWND_TOPMOST, we need to set this member appropriately.
             * See CheckTopmost for details.
             */
            if (pcvr->pos.hwndInsertAfter == HWND_NOTOPMOST) {
                if (TestWF(pwnd, WEFTOPMOST)) {

                    pwndT = GetLastTopMostWindow();
                    pcvr->pos.hwndInsertAfter = HW(pwndT);

                    if (pcvr->pos.hwndInsertAfter == pcvr->pos.hwnd) {
                        pwndT = _GetWindow(pwnd, GW_HWNDPREV);
                        pcvr->pos.hwndInsertAfter = HW(pwndT);
                    }
                } else {
                    pwndT = _GetWindow(pwnd, GW_HWNDPREV);
                    pcvr->pos.hwndInsertAfter = HW(pwndT);
                }
            } else if (pcvr->pos.hwndInsertAfter == HWND_TOPMOST) {
                pcvr->pos.hwndInsertAfter = HWND_TOP;
            }
        }
        /*
         * make sure the rectangle still matches the window's region
         *
         * Remember the old window rectangle in parent coordinates
         */
        xWindowOld  = pwnd->rcWindow.left;
        yWindowOld  = pwnd->rcWindow.top;

        xWindowOldLogical = xWindowOld;

        if (pwndParent != PWNDDESKTOP(pwnd)) {
            xWindowOld -= pwndParent->rcClient.left;
            yWindowOld -= pwndParent->rcClient.top;

            fMirroredParent = (TestWF(pwndParent, WEFLAYOUTRTL) && TestwndChild(pwnd));

            if (fMirroredParent) {
                xWindowOldLogical = pwndParent->rcClient.right - pwnd->rcWindow.right;
            } else {
                xWindowOldLogical = xWindowOld;
            }
        }

        cxWindowOld = pwnd->rcWindow.right - pwnd->rcWindow.left;
        cyWindowOld = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

        /*
         * Assume the client is not moving or sizing
         */
        pcvr->pos.flags |= SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE;

        if (!(pcvr->pos.flags & SWP_NOMOVE)) {

            if (pcvr->pos.x == xWindowOldLogical && pcvr->pos.y == yWindowOld) {
                pcvr->pos.flags |= SWP_NOMOVE;
                if (fMirroredParent) {
                    fSetZeroDx = TRUE;
                }
            }

            if (TestWF(pwnd, WFMINIMIZED) && IsTrayWindow(pwnd)) {
                pcvr->pos.x = WHERE_NOONE_CAN_SEE_ME;
                pcvr->pos.y = WHERE_NOONE_CAN_SEE_ME;
            }
        } else {
            pcvr->pos.x = xWindowOldLogical;
            pcvr->pos.y = yWindowOld;
        }

        if (!(pcvr->pos.flags & SWP_NOSIZE)) {

            /*
             * Don't allow an invalid window rectangle.
             * BOGUS HACK: For Norton Antivirus, they call
             * MoveWindow at WM_CREATE Time EVEN though
             * the window is minimzed, but they assume its
             * restored at WM_CREATE time.... B#11185, t-arthb
             */
            if (TestWF(pwnd, WFMINIMIZED) &&
                _GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL)) {

                pcvr->pos.cx = SYSMET(CXMINIMIZED);
                pcvr->pos.cy = SYSMET(CYMINIMIZED);

            } else {
                if (pcvr->pos.cx < 0)
                    pcvr->pos.cx = 0;

                if (pcvr->pos.cy < 0)
                    pcvr->pos.cy = 0;
            }

            if (pcvr->pos.cx == cxWindowOld && pcvr->pos.cy == cyWindowOld) {
                pcvr->pos.flags |= SWP_NOSIZE;
                if (!TestWF(pwnd, WFWIN31COMPAT))
                    fForceNCCalcSize = TRUE;
            }
        } else {
            pcvr->pos.cx = cxWindowOld;
            pcvr->pos.cy = cyWindowOld;
        }

        if (fMirroredParent) {
            UserAssert(pwndParent != PWNDDESKTOP(pwnd));
            pcvr->pos.x = (pwndParent->rcClient.right - pwndParent->rcClient.left) - pcvr->pos.x - pcvr->pos.cx;
        }

        /*
         * If showing and already visible, or hiding and already hidden,
         * turn off the appropriate bit.
         */
        if (TestWF(pwnd, WFVISIBLE)) {
            pcvr->pos.flags &= ~SWP_SHOWWINDOW;
        } else {
            pcvr->pos.flags &= ~SWP_HIDEWINDOW;

            /*
             * If hidden, and we're NOT showing, then we won't be drawing,
             * no matter what else is going on.
             */
            if (!(pcvr->pos.flags & SWP_SHOWWINDOW))
                pcvr->pos.flags |= SWP_NOREDRAW;
        }

        /*
         * Child windows inside a composited window can't use screen to
         * screen bit copy because this can move translucent bits.
         */
        if (!TestWF(pwnd, WEFCOMPOSITED) &&
                GetStyleWindow(pwnd, WEFCOMPOSITED) != NULL) {
            pcvr->pos.flags |= SWP_NOCOPYBITS;
        }

        /*
         * Muck with the zorder for bottommost windows, again
         * See comment in DeferWindowPos
         */
        if (TestWF(pwnd, WFBOTTOMMOST)) {
            pcvr->pos.flags &= ~SWP_NOZORDER;
            pcvr->pos.hwndInsertAfter = HWND_BOTTOM;
        }

        /*
         * If we're Z-ordering, we can try to remove the Z order
         * bit, as long as all previous windows in the WINDOWPOS list
         * have SWP_NOZORDER set.
         *
         * The reason we don't do this for each window individually
         * is that a window's eventual Z order depends on changes that
         * may have occured on windows earlier in the WINDOWPOS list,
         * so we can only call ValidateZorder if none of the previous
         * windows have changed.
         */
        if (fNoZorder && !(pcvr->pos.flags & SWP_NOZORDER)) {

            /*
             * If the TOPMOST bit is changing, the Z order is "changing",
             * so don't clear the bit even if it's in the right place in the
             * list.
             */
            fNoZorder = FALSE;
            if (!TestWF(pwnd, WFTOGGLETOPMOST) && ValidateZorder(pcvr)) {
                fNoZorder = TRUE;
                pcvr->pos.flags |= SWP_NOZORDER;
            }
        }

        /*
         * If no change is occuring, or if a parent is invisible,
         * we won't be redrawing.
         */
        if (!(pcvr->pos.flags & SWP_NOREDRAW)) {
            if ((pcvr->pos.flags & SWP_CHANGEMASK) == SWP_NOCHANGE ||
                    !_FChildVisible(pwnd)) {
                pcvr->pos.flags |= SWP_NOREDRAW;
            }
        }

        /*
         * BACKWARD COMPATIBILITY HACK
         *
         * In 3.0, if a window was moving but not sizing, we'd send the
         * WM_NCCALCSIZE message anyhow. Lotus Notes 2.1 depends on this
         * in order to move its "navigation bar" when the main window moves.
         */
        if (!(pcvr->pos.flags & SWP_NOMOVE) &&
            !TestWF(pwnd, WFWIN31COMPAT) &&
            (GetAppCompatFlags(NULL) & GACF_NCCALCSIZEONMOVE)) {

            fForceNCCalcSize = TRUE;
        }

        /*
         * If the window rect is sizing, or if the frame has changed,
         * send the WM_NCCALCSIZE message and deal with valid areas.
         */
        if (((pcvr->pos.flags & (SWP_NOSIZE | SWP_FRAMECHANGED)) != SWP_NOSIZE) ||
            fForceNCCalcSize) {

            WINDOWPOS pos;

            /*
             * check for full screen main app window
             */
            if (!TestWF(pwnd, WFCHILD) && !TestWF(pwnd, WEFTOOLWINDOW)) {
                xxxCheckFullScreen(pwnd, (PSIZERECT)&pcvr->pos.x);
            }

            /*
             * Set up NCCALCSIZE message parameters (in parent coords)
             * wParam = fClientOnly = TRUE
             * lParam = &params
             */
            pos = pcvr->pos;     // Make a local stack copy
            params.lppos = &pos;

            /*
             * params.rgrc[0] = rcWindowNew = New window rectangle
             * params.rgrc[1] = rcWindowOld = Old window rectangle
             * params.rgrc[2] = rcClientOld = Old client rectangle
             */
            #define rcWindowNew params.rgrc[0]
            #define rcWindowOld params.rgrc[1]
            #define rcClientOld params.rgrc[2]

            /*
             * Set up rcWindowNew in parent relative coordinates
             */
            rcWindowNew.left   = pcvr->pos.x;
            rcWindowNew.right  = rcWindowNew.left + pcvr->pos.cx;
            rcWindowNew.top    = pcvr->pos.y;
            rcWindowNew.bottom = rcWindowNew.top + pcvr->pos.cy;

            /*
             * Set up rcWindowOld in parent relative coordinates
             */
            GetRect(pwnd, &rcWindowOld, GRECT_WINDOW | GRECT_PARENTCOORDS);

            /*
             * Set up rcClientOld in parent relative coordinates
             */
            GetRect(pwnd, &rcClientOld, GRECT_CLIENT | GRECT_PARENTCOORDS);

            /*
             * Keep around a copy of the old client position
             */
            xClientOld  = rcClientOld.left;
            cxClientOld = rcClientOld.right - rcClientOld.left;
            yClientOld  = rcClientOld.top;
            cyClientOld = rcClientOld.bottom - rcClientOld.top;

            cmd = (UINT)xxxSendMessage(pwnd, WM_NCCALCSIZE, TRUE, (LPARAM)&params);

            if (!IsStillWindowC(pcvr->pos.hwndInsertAfter)) {
                ThreadUnlock(&tlpwnd);
                ThreadUnlock(&tlpwndParent);
                return FALSE;
            }

            /*
             * Upon return from NCCALCSIZE:
             *
             * params.rgrc[0] = rcClientNew = New client rect
             * params.rgrc[1] = rcValidDst  = Destination valid rectangle
             * params.rgrc[2] = rcValidSrc  = Source valid rectangle
             */
            #undef rcWindowNew
            #undef rcWindowOld
            #undef rcClientOld

            #define rcClientNew params.rgrc[0]
            #define rcValidDst  params.rgrc[1]
            #define rcValidSrc  params.rgrc[2]

            /*
             * Calculate the distance the window contents are
             * moving. If 0 or an invalid value was returned
             * from the WM_NCCALCSIZE message, assume the
             * entire client area is valid and top-left aligned.
             */
            if (cmd < WVR_MINVALID || cmd > WVR_MAXVALID) {

                /*
                 * We don't need to copy rcValidSrc to rcClientOld,
                 * because it's already stored in rgrc[2].
                 *
                 * rcValidSrc = rcClientOld
                 */
                rcValidDst = rcClientNew;

                cmd = WVR_ALIGNTOP | WVR_ALIGNLEFT;
            }

            /*
             * Calculate the distance we'll be shifting bits...
             */
            if (TestWF(pwnd, WEFLAYOUTRTL)) {
                pcvr->dxBlt = rcValidDst.right - rcValidSrc.right;
            } else {
                pcvr->dxBlt = rcValidDst.left - rcValidSrc.left;
            }
            pcvr->dyBlt = rcValidDst.top - rcValidSrc.top;

            /*
             * Calculate new client rect size and position
             */
            pcvr->xClientNew = rcClientNew.left;
            pcvr->yClientNew = rcClientNew.top;

            pcvr->cxClientNew = rcClientNew.right - rcClientNew.left;
            pcvr->cyClientNew = rcClientNew.bottom - rcClientNew.top;

            /*
             * Figure out whether the client rectangle is moving or sizing,
             * and diddle the appropriate bit if not.
             */
            if (xClientOld != rcClientNew.left || yClientOld != rcClientNew.top)
                pcvr->pos.flags &= ~SWP_NOCLIENTMOVE;

            if (cxClientOld != pcvr->cxClientNew || cyClientOld != pcvr->cyClientNew) {
                pcvr->pos.flags &= ~SWP_NOCLIENTSIZE;
            }

            /*
             * If the caller doesn't want us to save any bits, then don't.
             */
            if (pcvr->pos.flags & SWP_NOCOPYBITS) {
AllInvalid:

                /*
                 * The entire window is invalid: Set the blt rectangle
                 * to empty, to ensure nothing gets bltted.
                 */
                SetRectEmpty(&pcvr->rcBlt);
                ThreadUnlock(&tlpwnd);
                continue;
            }

            /*
             * If we are just resizing this window without moving it and its parent
             * is mirrored then no need to copy any bits (i.e. empty pcvr->rcBlt).
             */
            if (fSetZeroDx) {
                goto AllInvalid;
            }

            /*
             * If this is a transparent window, be sure to invalidate
             * everything, because only some of the window's bits are
             * blittable.
             */
            if (TestWF(pwnd, WEFTRANSPARENT))
                goto AllInvalid;

            /*
             * If both client and window did not change size, the frame didn't
             * change, and the blt rectangle moved the same distance as the
             * rectangle, then the entire window area is valid.
             */
            if (((pcvr->pos.flags &
                    (SWP_NOSIZE | SWP_NOCLIENTSIZE | SWP_FRAMECHANGED))
                    == (SWP_NOSIZE | SWP_NOCLIENTSIZE)) &&
                    pcvr->dxBlt == (pcvr->pos.x - xWindowOld) &&
                    pcvr->dyBlt == (pcvr->pos.y - yWindowOld)) {

                goto AllValid;
            }

            /*
             * Now compute the valid blt rectangle.
             *
             * Check for horz or vert client size changes
             *
             * NOTE: Assumes WVR_REDRAW == WVR_HREDRAW | WVR_VREDRAW
             */
            if (cxClientOld != pcvr->cxClientNew) {

                if ((cmd & WVR_HREDRAW) || TestCF(pwnd, CFHREDRAW))
                    goto AllInvalid;
            }

            if (cyClientOld != pcvr->cyClientNew) {

                if ((cmd & WVR_VREDRAW) || TestCF(pwnd, CFVREDRAW))
                    goto AllInvalid;
            }

            cxSrc = rcValidSrc.right - rcValidSrc.left;
            cySrc = rcValidSrc.bottom - rcValidSrc.top;

            cxDst = rcValidDst.right - rcValidDst.left;
            cyDst = rcValidDst.bottom - rcValidDst.top;

            if ((!!(cmd & WVR_ALIGNRIGHT)) ^ (!!TestWF(pwnd, WEFLAYOUTRTL)))
                rcValidDst.left += ((TestWF(pwnd, WEFLAYOUTRTL) && (cxSrc > cxDst)) ? (cxSrc-cxDst) : (cxDst - cxSrc));

            if (cmd & WVR_ALIGNBOTTOM)
                rcValidDst.top += (cyDst - cySrc);

            /*
             * Superimpose the source on the destination, and intersect
             * the rectangles. This is done by looking at the
             * extent of the rectangles, and pinning as appropriate.
             */

            if (cxSrc < cxDst)
                rcValidDst.right = rcValidDst.left + cxSrc;

            if (cySrc < cyDst)
                rcValidDst.bottom = rcValidDst.top + cySrc;

            /*
             * Finally map the blt rectangle to screen coordinates.
             */
            pcvr->rcBlt = rcValidDst;
            if (pwndParent != PWNDDESKTOP(pwnd)) {

                OffsetRect(
                        &pcvr->rcBlt,
                        pwndParent->rcClient.left,
                        pwndParent->rcClient.top);
            }
        } else {       // if !SWP_NOSIZE or SWP_FRAMECHANGED

AllValid:

            /*
             * No client size change: Blt the entire window,
             * including the frame. Offset everything by
             * the distance the window rect changed.
             */
            if (pcvr->pos.flags & SWP_NOCOPYBITS) {
                SetRectEmpty(&pcvr->rcBlt);
            } else {
                pcvr->rcBlt.left   = pcvr->pos.x;
                pcvr->rcBlt.top    = pcvr->pos.y;

                if (pwndParent != PWNDDESKTOP(pwnd)) {
                    pcvr->rcBlt.left += pwndParent->rcClient.left;
                    pcvr->rcBlt.top += pwndParent->rcClient.top;
                }

                pcvr->rcBlt.right  = pcvr->rcBlt.left + pcvr->pos.cx;
                pcvr->rcBlt.bottom = pcvr->rcBlt.top + pcvr->pos.cy;
            }

            /*
             * Offset everything by the distance the window moved.
             */
            if (TestWF(pwnd, WEFLAYOUTRTL)) {
                pcvr->dxBlt = (pcvr->pos.x + pcvr->pos.cx) - (xWindowOld + cxWindowOld);
            } else {
                pcvr->dxBlt = pcvr->pos.x - xWindowOld;
            }

            pcvr->dyBlt = pcvr->pos.y - yWindowOld;

            /*
             * If we're moving, we need to set up the client.
             */
            if (!(pcvr->pos.flags & SWP_NOMOVE)) {
                pcvr->pos.flags &= ~SWP_NOCLIENTMOVE;

                pcvr->xClientNew = pwnd->rcClient.left + pcvr->dxBlt;
                pcvr->yClientNew = pwnd->rcClient.top + pcvr->dyBlt;
                if (pwndParent != PWNDDESKTOP(pwnd)) {
                    pcvr->xClientNew -= pwndParent->rcClient.left;
                    pcvr->yClientNew -= pwndParent->rcClient.top;
                }

                pcvr->cxClientNew = pwnd->rcClient.right - pwnd->rcClient.left;
                pcvr->cyClientNew = pwnd->rcClient.bottom - pwnd->rcClient.top;
            }
        }

        ThreadUnlock(&tlpwnd);

    }   // for (... pcvr ...)

    ThreadUnlock(&tlpwndParent);
    *phwndNewActive = hwndNewActive;

    return TRUE;
}

/***************************************************************************\
* GetLastTopMostWindow
*
* Returns the last topmost window in the window list. Returns NULL if no
* topmost windows. Used so that we can fill in the pwndInsertAfter field
* in various SWP calls.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

PWND GetLastTopMostWindow(VOID)
{
    PWND     pwndT;
    PDESKTOP pdesk = PtiCurrent()->rpdesk;

    if (pdesk == NULL)
        return NULL;

    pwndT = pdesk->pDeskInfo->spwnd->spwndChild;

    if (!pwndT || !TestWF(pwndT, WEFTOPMOST))
        return NULL;

    while (pwndT->spwndNext) {

        if (!TestWF(pwndT->spwndNext, WEFTOPMOST))
            break;

        pwndT = pwndT->spwndNext;
    }

    return pwndT;
}

/***************************************************************************\
* SetWindowPos (API)
*
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxSetWindowPos(
    PWND pwnd,
    PWND pwndInsertAfter,
    int  x,
    int  y,
    int  cx,
    int  cy,
    UINT flags)
{
    PSMWP psmwp;
    BOOL  fInval = FALSE;

#if DBG
    CheckLock(pwnd);

    switch((ULONG_PTR)pwndInsertAfter) {
    case 0x0000FFFF:
    case (ULONG_PTR)HWND_TOPMOST:
    case (ULONG_PTR)HWND_NOTOPMOST:
    case (ULONG_PTR)HWND_TOP:
    case (ULONG_PTR)HWND_BOTTOM:
        break;

    default:
        CheckLock(pwndInsertAfter);
        break;
    }
#endif

    /*
     * BACKWARD COMPATIBILITY HACKS
     *
     * Hack 1: For Win 3.0 and below, SetWindowPos() must ignore the
     * move and size flags if SWP_SHOWWINDOW or SWP_HIDEWINDOW
     * is specified. KnowledgePro is one application that depends on
     * this behavior for the positioning of its MDI icons.
     *
     * Hack 2: In 3.0, if SetWindowPos() is called with SWP_SHOWWINDOW
     * and the window is already visible, then the window was
     * completely invalidated anyway. So, we do that here too.
     *
     * NOTE: The placement of the invalidation AFTER the EndDeferWindowPos()
     * call means that if the guy is Z-ordering and showing a 3.0 window,
     * it may flash, because EndDefer calls DoSyncPaint, and we invalidate
     * again after that. Could be fixed with some major hackery in EndDefer,
     * and it's probably not worth the trouble.
     */
    if (flags & (SWP_SHOWWINDOW | SWP_HIDEWINDOW)) {

        if (!TestWF(pwnd, WFWIN31COMPAT)) {

            flags |= SWP_NOMOVE | SWP_NOSIZE;
            if ((flags & SWP_SHOWWINDOW) && TestWF(pwnd, WFVISIBLE))
                fInval = TRUE;
        }
        if (flags & SWP_SHOWWINDOW) {
            SetWF(pwnd, WEFGHOSTMAKEVISIBLE);
        } else {
            ClrWF(pwnd, WEFGHOSTMAKEVISIBLE);
        }
    }

    /*
     * MULTIMONITOR HACKS
     *
     * if a app is centering or cliping a hidden owned window
     * to the primary monitor we should center the window to the owner
     *
     * this makes apps that center/position their own dialogs
     * work when the app is on a secondary monitor.
     */
    if (    !TestWF(pwnd, WFWIN50COMPAT) &&
            gpDispInfo->cMonitors > 1 &&
            !(flags & SWP_NOMOVE) &&
            !TestWF(pwnd, WFCHILD) &&
            !TestWF(pwnd, WFVISIBLE) &&
            (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION)) &&
            pwnd->spwndOwner &&
            TestWF(pwnd->spwndOwner, WFVISIBLE) &&
            !IsRectEmpty(&pwnd->spwndOwner->rcWindow)) {

        FixBogusSWP(pwnd, &x, &y, cx, cy, flags);

    }

    if (!(psmwp = InternalBeginDeferWindowPos(1)) ||
        !(psmwp = _DeferWindowPos(psmwp,
                                  pwnd,
                                  pwndInsertAfter,
                                  x,
                                  y,
                                  cx,
                                  cy,
                                  flags))) {

        return FALSE;
    }


    if (xxxEndDeferWindowPosEx(psmwp, flags & SWP_ASYNCWINDOWPOS)) {

        if (fInval) {
            xxxRedrawWindow(
                    pwnd,
                    NULL,
                    NULL,
                    RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
        }

        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
* xxxSwpActivate
*
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxSwpActivate(
    PWND pwndNewActive)
{
    PTHREADINFO pti;

    CheckLock(pwndNewActive);

    if (pwndNewActive == NULL)
        return FALSE;

    pti = PtiCurrent();

    if (TestwndChild(pwndNewActive)) {

        xxxSendMessage(pwndNewActive, WM_CHILDACTIVATE, 0, 0L);

    } else if (pti->pq->spwndActive != pwndNewActive) {

        /*
         * Remember if this window wants to be active. We are either setting
         * our own window active (most likely), or setting a window of
         * another thread active on purpose. If so that means this thread is
         * controlling this window and will probably want to set itself
         * active and foreground really soon (for example, a setup
         * program doing dde to progman). Allow this thread and the target
         * thread to do forground activates.
         *
         * Let's stop doing this for NT5 in an effort to close the number
         * of ways applications can force a foreground change. This is not
         * quite needed anyway, because:
         * -If the current thread is already in the foreground, then it doesn't need
         *  the TIF_ALLOWFOREGROUNDACTIVATE to make a foreground change.
         * -Since FRemoveForegroundActive removes this bit, the current thread
         *  will lose it anyway during the xxxActivateWindow call.
         * -But xxxActivateWindow will set it back anyway because we're activating
         *  a window from a different queue.
         * -The destination window/thread will take the foreground
         *  as a result of the xxxActivateWindow call, hence it doesn't
         *  need the bit on (if you're in the foreground, you don't need it).
         */
         #ifdef DONTDOTHISANYMORE
         if ((pti->pq == gpqForeground) && (pti != GETPTI(pwndNewActive))) {
            /*
             * Allow foreground activate on the source and dest.
             */
            pti->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxSwpActivate set TIF %#p", pti);
            GETPTI(pwndNewActive)->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxSwpActivate set TIF %#p", GETPTI(pwndNewActive));
         }
         #endif

        if (!xxxActivateWindow(pwndNewActive, AW_USE))
            return FALSE;

        /*
         * HACK ALERT: We set these bits to prevent
         * the frames from redrawing themselves in
         * the later call to DoSyncPaint().
         *
         * Prevent these captions from being repainted during
         * the DoSyncPaint(). (bobgu 6/10/87)
         */
        if (pti->pq->spwndActive != NULL)
            SetWF(pti->pq->spwndActive, WFNONCPAINT);

        if (pti->pq->spwndActivePrev != NULL)
            SetWF(pti->pq->spwndActivePrev, WFNONCPAINT);

        return TRUE;    // Indicate that we diddled these bits
    }

    return FALSE;
}

/***************************************************************************\
* xxxImeWindowPosChanged
*
* Send IME private message to update the composition window position
*
\***************************************************************************/

VOID xxxImeWindowPosChanged(
    PSMWP psmwp)
{
    PBWL    pbwl;
    PHWND   phwnd;
    PWND    pwndDesktop = _GetDesktopWindow();
    PTHREADINFO ptiCurrent = PtiCurrent();

    if (pwndDesktop == NULL) {
        return;
    }

    pbwl = BuildHwndList(pwndDesktop->spwndChild, BWL_ENUMLIST, ptiCurrent);
    if (pbwl == NULL) {
        return;
    }

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; ++phwnd) {
        PWND pwndIme = ValidateHwnd(*phwnd);

        TAGMSG1(DBGTAG_IMM, "ImePosC: pwndIme=%p", pwndIme);

        /*
         * If the thread is going away, just bail out.
         */
        if (ptiCurrent->TIF_flags & TIF_INCLEANUP) {
            break;
        }

        if (pwndIme && pwndIme->head.pti == ptiCurrent &&
                pwndIme->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {
            HWND hwnd;
            PWND pwnd;

            TAGMSG1(DBGTAG_IMM, "ImePosC: OK, pwndIme=%p is one of us.", pwndIme);

            try {
                hwnd = ProbeAndReadStructure(((PIMEWND)pwndIme)->pimeui, IMEUI).hwndIMC;
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                continue;
            }

            pwnd = RevalidateHwnd(hwnd);

            TAGMSG2(DBGTAG_IMM, "ImePosC: hwndImc=%p and its pwnd=%p", hwnd, pwnd);

            /*
             * Search upward
             */
            while (pwnd && pwnd != pwndDesktop) {
                PCVR    pcvr;
                int     ccvr;

                hwnd = HWq(pwnd);
                for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {
                    if (hwnd == pcvr->pos.hwnd) {
                        TAGMSG1(DBGTAG_IMM, "ImePosC: pwnd=%p in the SWP list.", pwnd);
                        /*
                         * Send this private message if the window's size changes
                         * or the window moves. I.e.
                         * when (flag & (SWP_NOSIZE | SWP_NOMOVE)) != (SWP_NOSIZE | SWP_NOMOVE).
                         */
                        if (~pcvr->pos.flags & (SWP_NOSIZE | SWP_NOMOVE)) {
                            TL tl;

                            TAGMSG1(DBGTAG_IMM, "ImePosC: pwnd=%p is gonna move or resize.", pwnd);

                            ThreadLockAlwaysWithPti(ptiCurrent, pwndIme, &tl);
                            xxxSendMessage(pwndIme, WM_IME_SYSTEM, IMS_WINDOWPOS, 0);
                            ThreadUnlock(&tl);
                        }
                        break;
                    }
                }

                if (ccvr >= 0) {
                    break;
                }

                pwnd = pwnd->spwndParent;
            }
        }
    }

    FreeHwndList(pbwl);
}


/***************************************************************************\
* xxxSendChangedMsgs
*
* Send WM_WINDOWPOSCHANGED messages as needed
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxSendChangedMsgs(
    PSMWP psmwp)
{
    PWND pwnd;
    PCVR pcvr;
    int  ccvr;
    TL   tlpwnd;

    /*
     * Send all the messages that need to be sent...
     */
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        if (pcvr->pos.hwnd == NULL)
            continue;

        /*
         * If the window's state didn't change, don't send the message.
         */
        if ((pcvr->pos.flags & SWP_CHANGEMASK) == SWP_NOCHANGE)
            continue;

        if ((pwnd = RevalidateHwnd(pcvr->pos.hwnd)) == NULL) {
            RIPMSG0(RIP_WARNING, "xxxSendChangedMsgs: window went away in middle");
            pcvr->pos.flags = SWP_NOREDRAW | SWP_NOCHANGE;
            pcvr->pos.hwnd  = NULL;
            continue;
        }

        if (!IsStillWindowC(pcvr->pos.hwndInsertAfter)) {
            pcvr->pos.hwnd = NULL;
            continue;
        }

        /*
         * Send the WM_WINDOWPOSCHANGED message...
         *
         * Make a frame copy of the WINDOWPOS, because the pcvr
         * info may get reused if SetWindowPos()
         * is called by the message handler: see the comments in
         * AllocSmwp().
         *
         * WM_SIZE, WM_MOVE and WM_SHOW messages are sent by the
         * DefWindowProc() WM_WINDOWPOSCHANGED message processing.
         *
         * Note: It's okay to destroy the window while processing this
         * message, since this is the last call made by the window manager
         * with the window handle before returning from SetWindowPos().
         * This also means we don't have to revalidate the pwnd.
         */
        ThreadLockAlways(pwnd, &tlpwnd);

        if (TestCF(pwnd, CFDROPSHADOW) && !(GetAppCompatFlags2ForPti(GETPTI(pwnd), VERMAX) & GACF2_NOSHADOW)) {
            if (pcvr->pos.flags & SWP_HIDEWINDOW) {
                xxxRemoveShadow(pwnd);
            } else if (pcvr->pos.flags & SWP_SHOWWINDOW) {
                BOOL fAddShadow = TRUE;
                /*
                 * We don't want to add a shadow to menus that are being slid
                 * out because they don't use AnimateWindow and do not create
                 * a window rgn to clip inside during the animation. This means
                 * that even if we keep the shadow in sync with the menu, it
                 * won't be visible because it is actually z-ordered below the
                 * menu.
                 */

                if ((GETFNID(pwnd) == FNID_MENU) && (!TestALPHA(MENUFADE)) && TestEffectUP(MENUANIMATION)) {
                    fAddShadow = FALSE;
                }

                if (fAddShadow) {
                    xxxAddShadow(pwnd);
                }
            } else {

                if (!(pcvr->pos.flags & SWP_NOSIZE) ||
                        (pcvr->pos.flags & SWP_FRAMECHANGED)) {
                    UpdateShadowShape(pwnd);
                } else if (!(pcvr->pos.flags & SWP_NOMOVE)) {
                    MoveShadow(pwnd);
                }

                if (!(pcvr->pos.flags & SWP_NOZORDER)) {
                    xxxUpdateShadowZorder(pwnd);
                }
            }
        }

        xxxSendMessage(pwnd, WM_WINDOWPOSCHANGED, 0, (LPARAM)&pcvr->pos);

        /*
         * Only send a shape change when moving/sizing/minimizing/restoring/
         * maximizing (or framechange for NetMeeting to detect SetWindowRgn)
         */
        if (!(pcvr->pos.flags & SWP_NOCLIENTMOVE) ||
            !(pcvr->pos.flags & SWP_NOCLIENTSIZE) ||
             (pcvr->pos.flags & SWP_STATECHANGE) ||
             (pcvr->pos.flags & SWP_FRAMECHANGED)) {
            xxxWindowEvent(EVENT_OBJECT_LOCATIONCHANGE, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
        }
        ThreadUnlock(&tlpwnd);
    }   // for (... pcvr ...)

    if (IS_IME_ENABLED()) {
        xxxImeWindowPosChanged(psmwp);
    }
}

/***************************************************************************\
* AsyncWindowPos
*
* This functions pulls from the passed-in SMWP all windows not owned by the
* current thread and passes them off to their owners to be handled. This
* eliminates synchronization where thread B won't get a chance to paint
* until thread A has completed painting (or at least returned from handling
* painting-related messages). Such synchronizations are bad because they
* can cause threads of unrelated process to hang each other.
*
* History:
* 09-10-91 darrinm      Created.
\***************************************************************************/
VOID AsyncWindowPos(
    PSMWP psmwp)
{
    BOOL        fFinished;
    PCVR        pcvrFirst;
    PCVR        pcvr;
    PCVR        pcvrT;
    int         ccvrRemaining;
    int         ccvr;
    int         chwnd;
    PTHREADINFO ptiT;
    PTHREADINFO ptiCurrent;
    PSMWP       psmwpNew;

    pcvrFirst = psmwp->acvr;
    ccvrRemaining = psmwp->ccvr;

    ptiCurrent = PtiCurrent();

    while (TRUE) {

        fFinished = TRUE;

        /*
         * Loop through all windows in the SMWP list searching for windows
         * owned by other threads. Return if none are found.
         */
        for (; ccvrRemaining != 0; pcvrFirst++, ccvrRemaining--) {

            if (pcvrFirst->pos.hwnd == NULL)
                continue;

            ptiT = pcvrFirst->pti;
            if (ptiT->pq != ptiCurrent->pq) {
                fFinished = FALSE;
                break;
            }
        }

        if (fFinished) {
            return;
        }

        /*
         * We've found a window of another thread. Count how many other
         * windows in the list are owned by the same thread so we can
         * allocate a CVR array for them.
         */
        chwnd = 0;

        for (pcvr = pcvrFirst, ccvr = ccvrRemaining; --ccvr >= 0; pcvr++) {

            if (pcvr->pos.hwnd == NULL)
                continue;

            if (pcvr->pti->pq == ptiT->pq)
                chwnd++;
        }

        /*
         * Allocate temp SMWP/CVR structure to be passed to the other thread.
         */
        psmwpNew = (PSMWP)UserAllocPool(sizeof(SMWP) + (sizeof(CVR) * chwnd),
                                        TAG_SWP);

        /*
         * Even if we can't allocate memory to pass the SMWP to another
         * thread we still need to remove its windows from the current list.
         */
        if (psmwpNew == NULL) {

            for (pcvr = pcvrFirst; chwnd != 0; pcvr++) {

                if (pcvr->pti->pq == ptiT->pq) {
                    pcvr->pos.hwnd = NULL;
                    chwnd--;
                }
            }

            continue;
        }

        psmwpNew->ccvr = chwnd;
        psmwpNew->acvr = (PCVR)((PBYTE)psmwpNew + sizeof(SMWP));

        for (pcvr = pcvrFirst, pcvrT = psmwpNew->acvr; chwnd != 0; pcvr++) {

            if (pcvr->pos.hwnd == NULL)
                continue;

            /*
             * Copy the appropriate CVR structs into our temp array.
             */
            if (pcvr->pti->pq == ptiT->pq) {

                *pcvrT++ = *pcvr;
                chwnd--;

                /*
                 * Remove this window from the list of windows to be handled
                 * by the current thread.
                 */
                pcvr->pos.hwnd = NULL;
            }
        }

        /*
         * This lets the other thread know it needs to do some windowposing.
         * The other thread is responsible for freeing the temp SMWP/CVR array.
         */
        if (!PostEventMessage(ptiT, ptiT->pq, QEVENT_SETWINDOWPOS, NULL, 0,
                (WPARAM)psmwpNew, (LPARAM)ptiT)) {
            // IANJA RIP only to catch what was previously a bug: psmwpNew not freed
            RIPMSG1(RIP_WARNING, "PostEventMessage swp to pti %#p failed", ptiT);
            UserFreePool(psmwpNew);
        }
    }

}

/***************************************************************************\
* xxxProcessSetWindowPosEvent
*
* This function is called from xxxProcessEvent (QUEUE.C) to respond to
* posted QEVENT_SETWINDOWPOS events which originate at the AsyncWindowPos
* function above.
*
* History:
* 10-Sep-1991 DarrinM   Created.
\***************************************************************************/

VOID xxxProcessSetWindowPosEvent(
    PSMWP psmwpT)
{
    PSMWP psmwp;

    /*
     * Create a bonafide SMWP/CVR array that xxxEndDeferWindowPos can use
     * and later free.
     */
    if ((psmwp = InternalBeginDeferWindowPos(psmwpT->ccvr)) == NULL) {
        UserFreePool(psmwpT);
        return;
    }

    /*
     * Copy the contents of the temp SMWP/CVR array into the real one.
     */
    RtlCopyMemory(psmwp->acvr, psmwpT->acvr, sizeof(CVR) * psmwpT->ccvr);
    psmwp->ccvr = psmwpT->ccvr;

    /*
     * Complete the MultWindowPos operation now that we're on the correct
     * context.
     */
    xxxEndDeferWindowPosEx(psmwp, FALSE);

    /*
     * Free the temp SMWP/CVR array.
     */
    UserFreePool(psmwpT);
}

#define SWP_BOZO ( SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE )

/***************************************************************************\
* DBGValidateSibblingZOrder
*
* History:
* 04/01/98 GerardoB Created
\***************************************************************************/
#if DBG
VOID DBGValidateSibblingZOrder(
    PWND pwndParent)
{
    PWND pwndT = pwndParent->spwndChild;
    /*
     * Check that the sibbling list looks OK right now
     * We don't really care about the z-order of message windows.
     */
    if ((pwndT != NULL) && (pwndParent != PWNDMESSAGE(pwndParent))) {
        BOOL fFoundNonTopMost = !TestWF(pwndT, WEFTOPMOST);
        while (pwndT != NULL) {
            if (TestWF(pwndT, WEFTOPMOST)) {
                UserAssert(!fFoundNonTopMost);
            } else {
                fFoundNonTopMost = TRUE;
            }
            pwndT = pwndT->spwndNext;
        }
    }
}
#else
#define DBGValidateSibblingZOrder(pwndParent)
#endif // DBG

/***************************************************************************\
* zzzChangeStates
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID zzzChangeStates(
    PWND     pwndParent,
    PSMWP    psmwp)
{
    int  ccvr;
    PCVR pcvr;
    PWND pwnd;
    TL tlpwnd;
    TL tlpwndParent;
    int czorder = 0;

    BEGINATOMICCHECK();
    ThreadLockAlways(pwndParent, &tlpwndParent);

    /*
     * Check that the sibbling list looks OK right now
     *
     * Here's the reason why this DBG code is commented out:
     * Owned windows are always expected to be on top of the owner.
     * However, an app can call SetWindowPos and insert the ownee after
     * the owner. IME somehow does this too.
     * This causes us to have A to be inserted after B and later in the
     * windowpos array, B to be inserted somewhere else. Hence, A won't be in the
     * expected position, because B will be moved after A is inserted.
     * In other words, a window in hwndInsertAfter must not appear later
     * as a hwnd to be z-ordered. Ownees below owners cause this situation.
     */
    // DBGValidateSibblingZOrder(pwndParent);


    /*
     * Now change the window states
     */
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        if (pcvr->pos.hwnd == NULL)
            continue;

        UserAssert(0 == (pcvr->pos.flags & SWP_NOTIFYALL));

        pwnd = RevalidateHwnd(pcvr->pos.hwnd);

        if ((pwnd == NULL) || !IsStillWindowC(pcvr->pos.hwndInsertAfter)) {
            RIPMSG0(RIP_WARNING, "zzzChangeStates: Window went away in middle");
            pcvr->pos.flags = SWP_NOREDRAW | SWP_NOCHANGE;
            pcvr->pos.hwnd  = NULL;
        }

#if DBG
        /*
         * This can happen when we get re-entered during a callback or mulitple
         * threads are z-ordering the same window. The tray does stuff like this.
         * We would need to keep the toggle state in the windowpos structure to
         * have each call have its own state.
         */
        if (TestWF(pwnd, WFTOGGLETOPMOST) && (pcvr->pos.flags & SWP_NOZORDER)) {
            RIPMSG0(RIP_WARNING, "zzzChangeState: WFTOGGLETOPMOST should not be set");
        }
#endif

        /*
         * Check to se if there is any state to change. If not, just
         * continue.
         */
        if ((pcvr->pos.flags & SWP_CHANGEMASK) == SWP_NOCHANGE) {
            pcvr->pos.flags |= SWP_NOREDRAW;
            continue;
        }

        /*
         * Change the window region if needed.
         *
         * Before we do anything, check to see if we're only Z-ordering.
         * If so, then check to see if we're already in the right place,
         * and if so, clear the ZORDER flag.
         *
         * We have to make this test in the state-change loop if previous
         * windows in the WINDOWPOS list were Z-ordered, since the test depends
         * on any ordering that may have happened previously.
         *
         * We don't bother to do this redundancy check if there are
         * other bits set, because the amount of time saved in that
         * case is about as much as the amount of time it takes to
         * test for redundancy.
         */
        if (((pcvr->pos.flags & SWP_CHANGEMASK) ==
             (SWP_NOCHANGE & ~SWP_NOZORDER))) {

            /*
             * If the window's Z order won't be changing, then
             * we can clear the ZORDER bit and set NOREDRAW.
             */
            if ((!TestWF(pwnd, WFTOGGLETOPMOST)) && ValidateZorder(pcvr)) {

                /*
                 * The window's already in the right place:
                 * Set SWP_NOZORDER bit, set SWP_NOREDRAW,
                 * and destroy the visrgn that we created earlier.
                 */
                pcvr->pos.flags |= SWP_NOZORDER | SWP_NOREDRAW;

                if (pcvr->hrgnVisOld) {
                    GreDeleteObject(pcvr->hrgnVisOld);
                    pcvr->hrgnVisOld = NULL;
                }
                continue;
            }
        }

        /*
         * Change the window state, as appropriate...
         */
        if ((pcvr->pos.flags &
            (SWP_NOMOVE | SWP_NOSIZE | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)) !=
            (SWP_NOMOVE | SWP_NOSIZE | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)) {

            PCARET pcaret = &PtiCurrent()->pq->caret;
            BOOL fRecreateRedirectionBitmap = FALSE;
            int dxWindow, dyWindow, xOldWindow, yOldWindow;

            if (TestWF(pwnd, WEFPREDIRECTED)) {
                int cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
                int cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

                if (cx != pcvr->pos.cx || cy != pcvr->pos.cy) {
                    fRecreateRedirectionBitmap = TRUE;
                }
            }

            /*
             * Set up the new window and client rectangles.
             */
            xOldWindow = pwnd->rcWindow.left;
            yOldWindow = pwnd->rcWindow.top;
            pwnd->rcWindow.left   = pcvr->pos.x;
            pwnd->rcWindow.top    = pcvr->pos.y;
            if (pwndParent != PWNDDESKTOP(pwnd)) {
                pwnd->rcWindow.left += pwndParent->rcClient.left;
                pwnd->rcWindow.top += pwndParent->rcClient.top;
            }
            dxWindow = pwnd->rcWindow.left - xOldWindow;
            dyWindow = pwnd->rcWindow.top - yOldWindow;

            pwnd->rcWindow.right  = pwnd->rcWindow.left + pcvr->pos.cx;
            pwnd->rcWindow.bottom = pwnd->rcWindow.top + pcvr->pos.cy;

            if (pwnd->rcWindow.right < pwnd->rcWindow.left) {
                RIPMSG1(RIP_WARNING, "SWP: cx changed for pwnd %#p", pwnd);
                pwnd->rcWindow.right = pwnd->rcWindow.left;
            }

            if (pwnd->rcWindow.bottom < pwnd->rcWindow.top) {
                RIPMSG1(RIP_WARNING, "SWP: cy changed for pwnd %#p", pwnd);
                pwnd->rcWindow.bottom = pwnd->rcWindow.top;
            }

            /*
             * If the client moved relative to its parent,
             * offset the caret by the amount that rcBlt moved
             * relative to the client rect.
             */
            if (pwnd == pcaret->spwnd) {

                /*
                 * Calculate the distance the contents of the client area
                 * is moving, in client-relative coordinates.
                 *
                 * Calculates dBlt + (old position - new position)
                 */
                int dx = pcvr->dxBlt + pwnd->rcClient.left - pcvr->xClientNew;
                int dy = pcvr->dyBlt + pwnd->rcClient.top - pcvr->yClientNew;

                if (pwndParent != PWNDDESKTOP(pwnd))
                {
                    dx -= pwndParent->rcClient.left;
                    dy -= pwndParent->rcClient.top;
                }

                if ((dx | dy) != 0) {
                    pcaret->x += dx;
                    pcaret->y += dy;
                }
            }

            /*
             * Set up the new client rect
             * coordinates provided.
             */
            pwnd->rcClient.left   = pcvr->xClientNew;
            pwnd->rcClient.top    = pcvr->yClientNew;
            if (pwndParent != PWNDDESKTOP(pwnd))
            {
                pwnd->rcClient.left += pwndParent->rcClient.left;
                pwnd->rcClient.top += pwndParent->rcClient.top;
            }

            pwnd->rcClient.right  = pwnd->rcClient.left + pcvr->cxClientNew;
            pwnd->rcClient.bottom = pwnd->rcClient.top + pcvr->cyClientNew;

            /*
             * If the window becomes smaller than the monitor, the system
             * allows it to be moved (see SetSysMenu) and so we must remove
             * the monitor region.
             */
            if (TestWF(pwnd, WFMAXFAKEREGIONAL) && IsSmallerThanScreen(pwnd)) {
                SelectWindowRgn(pwnd, NULL);
            }

            /*
             * If the layered window is resizing, try to resize the
             * redirection bitmap associated with it.
             */
            if (fRecreateRedirectionBitmap) {
                RecreateRedirectionBitmap(pwnd);
            }


            if ((dxWindow != 0) || (dyWindow != 0)) {
                if ((pwnd->hrgnClip > HRGN_FULL) && (!TestWF(pwnd, WFMAXFAKEREGIONAL))) {
#ifdef LATER
                    /*
                     * LATER: The original USER code was offsetting the window
                     * region by dxBlt and dyBlt. This had problems for using
                     * window regions when hiding and showing the menus, so
                     * dxWindow and dyWindow were added (correctly). However,
                     * we should be aware of all of the places these values
                     * don't agree to make sure that we don't introduce
                     * regressions. Unfortunately in Whistler, we were
                     * periodically getting too much spew, and didn't have time
                     * to fully track down each of these cases.
                     */


                    /*
                     * Change position of window region, if it has one
                     * and it isn't a monitor region for a maximized window
                     */
                    if ((dxWindow != pcvr->dxBlt) || (dyWindow != pcvr->dyBlt)) {
                        /*
                         * If not moving by the same amount as the PCVR indicates,
                         * give a warning. This is normal when calling xxxSetMenu(),
                         * but we need to know if it is called in other situations.
                         */
                        RIPMSG1(RIP_WARNING, "SWP: (dxWindow != dxBlt) || (dyWindow != dyBlt) for pwnd %#p", pwnd);
                    }
#endif



                    GreOffsetRgn(pwnd->hrgnClip, dxWindow, dyWindow);
                }
            }


            /*
             * Offset the absolute positions of the window's update region,
             * and the position and update regions of its children.
             */
            if ((pcvr->dxBlt | pcvr->dyBlt) != 0) {
                if (pwnd->hrgnUpdate > HRGN_FULL) {
                    GreOffsetRgn(pwnd->hrgnUpdate, pcvr->dxBlt, pcvr->dyBlt);
                }
                OffsetChildren(pwnd, pcvr->dxBlt, pcvr->dyBlt, NULL);

                /*
                 * Change the position of the sprite associated with
                 * this window.
                 */
                if (TestWF(pwnd, WEFLAYERED)) {
                    POINT ptPos = {pcvr->pos.x, pcvr->pos.y};

                    GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL,
                            &ptPos, NULL, NULL, NULL, 0, NULL, 0, NULL);
                }
            }
        }

        /*
         * Change the Z order if the flag is set. Revalidate
         * hwndInsertAfter to make sure that it is still valid
         */
        if (!(pcvr->pos.flags & SWP_NOZORDER)) {

            if (ValidateWindowPos(pcvr, pwndParent)) {

                UnlinkWindow(pwnd, pwndParent);

                LinkWindow(pwnd,
                           PWInsertAfter(pcvr->pos.hwndInsertAfter),
                           pwndParent);
                czorder++;

                /*
                 * HACK ALERT MERGE
                 *
                 * ValidateZOrder() depends on rational, consistent setting of the
                 * WEFTOPMOST bit in order for it to work properly. What this means
                 * is that we can't set or clear these bits ahead of time based on
                 * where the window is moving to: instead we have to change the bit
                 * after we've moved it. Enter the WFTOGGLETOPMOST bit: That bit
                 * is set in ZOrderByOwner() based on what the topmost bit will
                 * eventually be set to. To maintain a consistent state, we make
                 * any changes AFTER the window has been Z-ordered.
                 */
                if (TestWF(pwnd, WFTOGGLETOPMOST)) {
                    PBYTE pb;

                    ClrWF(pwnd, WFTOGGLETOPMOST);
                    pb = ((BYTE *)&pwnd->state);
                    pb[HIBYTE(WEFTOPMOST)] ^= LOBYTE(WEFTOPMOST);
                }
            } else {
                pcvr->pos.flags |= SWP_NOZORDER;
                ClrWF(pwnd, WFTOGGLETOPMOST);
            }
        }


        /*
         * Handle SWP_HIDEWINDOW and SWP_SHOWWINDOW, by clearing or setting
         * the WS_VISIBLE bit.
         */
        UserAssert(pwndParent != NULL);
        ThreadLockAlways(pwnd, &tlpwnd);
        if (pcvr->pos.flags & SWP_SHOWWINDOW) {

            /*
             * Window is showing. If this app is still in startup mode,
             * (still starting), give the the app starting cursor 5 more
             * seconds.
             */
            if (GETPTI(pwnd)->ppi->W32PF_Flags & W32PF_APPSTARTING)
                zzzCalcStartCursorHide((PW32PROCESS)GETPTI(pwnd)->ppi, 5000);

            /*
             * Set the WS_VISIBLE bit.
             */
            SetVisible(pwnd, SV_SET);

            zzzWindowEvent(EVENT_OBJECT_SHOW, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, WEF_USEPWNDTHREAD);

            if (IsTrayWindow(pwnd)) {

#ifdef HUNGAPP_GHOSTING
                if((GETFNID(pwnd) == FNID_GHOST)) {
                    if(TestWF(pwnd, WFFRAMEON)) {
                        psmwp->bShellNotify = TRUE;
                        pcvr->pos.flags |= SWP_NOTIFYACTIVATE;
                    }
                }
                else
#endif  // HUNGAPP_GHOSTING
                {
                    psmwp->bShellNotify = TRUE;
                    pcvr->pos.flags |= TestWF(pwnd, WFFRAMEON) ? SWP_NOTIFYACTIVATE|SWP_NOTIFYCREATE: SWP_NOTIFYCREATE;
                }
            } else if (TestWF(pwnd, WFFULLSCREEN)) {
                /*
                 * Wake up the tray so it can notice that there is now
                 * a fullscreen visible window. This deals with bugs
                 * 32164, 141563, and 150217.
                 */
                psmwp->bShellNotify = TRUE;
                pcvr->pos.flags |= SWP_NOTIFYFS;
            }

            /*
             * If we're redrawing, create an SPB for this window if
             * needed.
             */
            if (!(pcvr->pos.flags & SWP_NOREDRAW) ||
                    (pcvr->pos.flags & SWP_CREATESPB)) {

                /*
                 * ONLY create an SPB if this window happens to be
                 * on TOP of all others. NOTE: We could optimize this by
                 * passing in the new vis rgn to CreateSpb() so that the
                 * non-visible part of the window is automatically
                 * invalid in the SPB.
                 */
                /*
                 * Make sure this window's desktop is on top !
                 */
                if (TestCF(pwnd, CFSAVEBITS) &&
                        pwnd->head.rpdesk == grpdeskRitInput) {

                    /*
                     * If this window is the topmost VISIBLE window,
                     * then we can create an SPB.
                     */
                    PWND pwndT;
                    RECT rcT;

                    for (pwndT = pwnd->spwndParent->spwndChild ;
                         pwndT;
                         pwndT = pwndT->spwndNext) {

                        if (pwndT == pwnd) {
                            CreateSpb(pwnd, FALSE, gpDispInfo->hdcScreen);
                            break;
                        }

                        if (TestWF(pwndT, WFVISIBLE)) {

                            /*
                             * Does this window intersect the SAVEBITS
                             * window at all?  If so, bail out.
                             */
                            if (IntersectRect(&rcT,
                                              &pwnd->rcWindow,
                                              &pwndT->rcWindow)) {
                                break;
                            }
                        }
                    }
                }
            }

        } else if (pcvr->pos.flags & SWP_HIDEWINDOW) {

            /*
             * for people like MS-Access 2.0 who SetWindowPos( SWP_BOZO
             * and blow away themselves on the shell, then lets
             * just ignore their plea to be removed from the tray
             */
            if (((pcvr->pos.flags & SWP_BOZO ) != SWP_BOZO) &&
                IsTrayWindow(pwnd)
#ifdef HUNGAPP_GHOSTING
                && (GETFNID(pwnd) != FNID_GHOST)
#endif // HUNGAPP_GHOSTING
                ) {
                psmwp->bShellNotify = TRUE;
                pcvr->pos.flags |= SWP_NOTIFYDESTROY;
            }

            /*
             * Clear the WS_VISIBLE bit.
             */
            SetVisible(pwnd, SV_UNSET | SV_CLRFTRUEVIS);

            zzzWindowEvent(EVENT_OBJECT_HIDE, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
        }

        /*
         * BACKWARD COMPATIBILITY HACK
         *
         * Under 3.0, window frames were always redrawn, even if
         * SWP_NOREDRAW was specified. If we've gotten this far
         * and we're visible, and SWP_NOREDRAW was specified, set
         * the WFSENDNCPAINT bit.
         *
         * Apps such as ABC Flowcharter and 123W assume this.
         * Typical offending code is MoveWindow(pwnd, ..., FALSE);
         * followed by InvalidateRect(pwnd, NULL, TRUE);
         */
        if (TestWF(pwnd, WFVISIBLE)) {
            if ((pcvr->pos.flags & SWP_STATECHANGE) ||
                (!TestWF(pwnd, WFWIN31COMPAT) && (pcvr->pos.flags & SWP_NOREDRAW))) {

                SetWF(pwnd, WFSENDNCPAINT);
            }
        }

        /*
         * If this window has a clipping region set it now
         */
        if (pcvr->hrgnClip != NULL) {
            SelectWindowRgn(pwnd, pcvr->hrgnClip);
        }
        ThreadUnlock(&tlpwnd);
    }

    /*
     * Check that the sibbling list looks OK now that we're done
     */
  //  DBGValidateSibblingZOrder(pwndParent);

    if (czorder) {
        zzzWindowEvent(EVENT_OBJECT_REORDER, pwndParent, OBJID_CLIENT, INDEXID_CONTAINER, 0);
    }

    ThreadUnlock(&tlpwndParent);

    ENDATOMICCHECK();
}

/***************************************************************************\
* SwpCalcVisRgn
*
* This routine calculates a non-clipchildren visrgn for pwnd into hrgn.
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL SwpCalcVisRgn(
    PWND pwnd,
    HRGN hrgn)
{
    /*
     * If this window is invisible, then
     * the visrgn will be empty, so return FALSE.
     */
    if (!TestWF(pwnd, WFVISIBLE))
        return FALSE;

    /*
     * Otherwise do it the hard way...
     */
    return CalcVisRgn(&hrgn,
                      pwnd,
                      pwnd,
                      (TestWF(pwnd, WFCLIPSIBLINGS) ?
                          (DCX_CLIPSIBLINGS | DCX_WINDOW) : (DCX_WINDOW)));
}

/***************************************************************************\
* CombineOldNewVis
*
* ORs or DIFFs hrgnOldVis and hrgnNewVis, depending on crgn, and the
* RE_* bits of fsRgnEmpty. Basically, this routine handles the optimization
* where if either region is empty, the other can be copied. Returns FALSE
* if the result is empty.
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL CombineOldNewVis(
    HRGN hrgn,
    HRGN hrgnVisOld,
    HRGN hrgnVisNew,
    UINT crgn,
    UINT fsRgnEmpty)
{
    switch (fsRgnEmpty & (RE_VISOLD | RE_VISNEW)) {
    case RE_VISOLD:

        /*
         * If we're calculating old - new and old is empty, then result is
         * empty. Otherwise, result is new.
         */
        if (crgn == RGN_DIFF)
            return FALSE;

        CopyRgn(hrgn, hrgnVisNew);
        break;

    case RE_VISNEW:

        /*
         * New is empty: result will be the old.
         */
        CopyRgn(hrgn, hrgnVisOld);
        break;

    case RE_VISNEW | RE_VISOLD:

        /*
         * Both empty: so's the result.
         */
        return FALSE;

    case 0:

        /*
         * Neither are empty: do the real combine.
         */
        switch (GreCombineRgn(hrgn, hrgnVisOld, hrgnVisNew, crgn)) {
        case NULLREGION:
        case ERROR:
            return FALSE;

        default:
            break;
        }
        break;
    }

    return TRUE;
}

/***************************************************************************\
* BltValidInit
*
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int BltValidInit(
    PSMWP psmwp)
{
    int  ccvr;
    int  cIter = 0;
    PCVR pcvr;
    PWND pwnd;
    BOOL fChangeState = FALSE;

    /*
     * Before we change any window state, calculate the old visrgn
     */
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        UINT flags = pcvr->pos.flags;

        /*
         * Make sure this is initialized to NULL; we may be sticking something
         * in it, and we want to know later if we need to free that thing.
         */
        pcvr->hrgnVisOld = NULL;

        if (pcvr->pos.hwnd == NULL)
            continue;

        pwnd = RevalidateHwnd(pcvr->pos.hwnd);

        if ((pwnd == NULL) || !IsStillWindowC(pcvr->pos.hwndInsertAfter)) {
            pcvr->pos.hwnd  = NULL;
            pcvr->pos.flags = SWP_NOREDRAW | SWP_NOCHANGE;
            continue;
        }

        /*
         * Before we change any window's state, ensure that any SPBs
         * over the window's old location are invalidated if necessary.
         * This must be done because no WM_PAINT messages will be
         * sent to anyone for the covered area if the area is obscured
         * by other windows.
         */
        if (AnySpbs() && !(flags & SWP_NOREDRAW))
            SpbCheckRect(pwnd, &pwnd->rcWindow, DCX_WINDOW);

        /*
         * Count the number of passes through the loop
         */
        cIter++;

        /*
         * Remember if any SWPs need their state changed.
         */
        if ((flags & SWP_CHANGEMASK) != SWP_NOCHANGE)
            fChangeState = TRUE;

        /*
         * If we're not redrawing, no need to calculate visrgn
         */
        if (pcvr->pos.flags & SWP_NOREDRAW)
            continue;

        if (!SYSMET(SAMEDISPLAYFORMAT))
            PreventInterMonitorBlts(pcvr);

        pcvr->fsRE       = 0;
        pcvr->hrgnVisOld = CreateEmptyRgn();

        if (pcvr->hrgnVisOld == NULL ||
            !SwpCalcVisRgn(pwnd, pcvr->hrgnVisOld)) {

            pcvr->fsRE = RE_VISOLD;
        }
    }

    return (fChangeState ? cIter : 0);
}

/***************************************************************************\
* zzzBltValidBits
*
* NOTE: Although zzzBltValidBits calls 'xxxInternalInvalidate' it does not
* specify any of the flags that will cause immediate updating. This means
* that it does not actually leave the critsect and therefore is not an 'xxx'
* routine and doesn't have to bother with revalidation.
*
* This is the routine that blts the windows around on the screen, taking
* into account SPBs.
*
* Here is the basic algebra going on here:
*
* ASSUMES: - rcBlt is aligned to the DESTINATION
*          - offset() offsets from source to destination
*
* 1. hrgnSrc = offset(rcBlt) & hrgnVisOld
*
*    Source region is the blt rectangle aligned with the old visrgn,
*    intersected with the old visrgn.
*
* 2. hrgnDst = rcBlt & hrgnVisNew
*
*    Dest region is the blt rectangle intersected with the new visrgn.
*
* 3. ghrgnValid = offset(hrgnSrc) & hrgnDst
*
*    Valid area is the intersection of the destination with the source
*    superimposed on the destination.
*
* 3.1 ghrgnValid = ghrgnValid - hrgnInterMonitor
*
*    Subtract out any pieces that are moving across monitors.
*
* 4. ghrgnValid -= ghrgnValidSum
*
*    This step takes into account the possibility that another window's
*    valid bits were bltted on top of this windows valid bits. So, as we
*    blt a window's bits, we accumulate where it went, and subtract it
*    from subsequent window's valid area.
*
* 5. ghrgnInvalid = (hrgnSrc | hrgnDst) - ghrgnValid
*
* 6. ghrgnInvalid += RestoreSpb(ghrgnInvalid) (sort of)
*
*    This is the wild part, because of the grungy way that the device
*    driver SaveBits() routine works. We call RestoreSpb() with
*    a copy of ghrgnInvalid. If the SPB valid region doesn't intersect
*    ghrgnInvalid, RestoreSpb() does nothing. But if it DOES intersect,
*    it blts down the ENTIRE saved SPB bitmap, which may include area
*    of the old window position that IS NOT part of ghrgnValid!
*
*    To correct for this, ghrgnValid is adjusted by subtracting off
*    the ghrgnInvalid computed by RestoreSpb, if it modified it.
*
* 7. ghrgnInvalidSum |= ghrgnInvalid
*
*    We save up the sum of all the invalid areas, and invalidate the
*    whole schmear in one fell swoop at the end.
*
* 8. ghrgnValidSum |= ghrgnValid
*
*    We keep track of the valid areas so far, which are subtracted
*    in step 4.
*
* The actual steps occur in a slightly different order than above, and
* there are numerous optimizations that are taken advantage of (the
* most important having to do with hiding and showing, and complete
* SPB restoration).
*
* Returns TRUE if some drawing was done, FALSE otherwise.
*
* History:
* 10-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL zzzBltValidBits(
    PSMWP    psmwp)
{
    int        ccvr;
    int        cIter;
    PCVR       pcvr;
    PWND       pwnd;
    PWND       pwndParent;
    PWND       pwndT;
    PWINDOWPOS ppos;
    HRGN       hrgnInvalidate;
    UINT       fsRgnEmpty;
    UINT       fsSumEmpty;
    int        cwndShowing;
    BOOL       fSyncPaint = FALSE;
    BOOL       fInvalidateLayers = FALSE;
    HDC        hdcScreen = NULL;

    DeferWinEventNotify();
    GreLockDisplay(gpDispInfo->hDev);

    /*
     * Compute old visrgns and count total CVRs in list. A side-effect of
     * BltValidInit is that revalidates all the windows in the SMWP array.
     */


    if ((cIter = BltValidInit(psmwp)) == 0) {

CleanupAndExit:

        /*
         * Go through the cvr list and free the regions that BltValidInit()
         * created.
         */
        for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

            if (pcvr->hrgnVisOld) {
                GreDeleteObject(pcvr->hrgnVisOld);
                pcvr->hrgnVisOld = NULL;
            }
        }

        goto UnlockAndExit;
    }

    /*
     * We left the crit sect since last time we validated the smwp. Validate
     * it again, and find the first WINDOWPOS structure with a non-NULL
     * hwnd in it.
     */
    ppos = NULL;
    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        /*
         * Revalidate window and if it's invalid, NULL it out in the WINDOWPOS
         * struct.
         */
        pwnd = RevalidateHwnd(pcvr->pos.hwnd);

        if ((pwnd == NULL)              ||
            (pwnd->spwndParent == NULL) ||
            !IsStillWindowC(pcvr->pos.hwndInsertAfter)) {

            pcvr->pos.hwnd  = NULL;
            pcvr->pos.flags = SWP_NOREDRAW | SWP_NOCHANGE;
            continue;
        }

        /*
         * Remember the first WINDOWPOS structure that has a non-NULL
         * hwnd.
         */
        if (ppos == NULL)
            ppos = &pcvr->pos;
    }

    if (ppos == NULL)
        goto CleanupAndExit;

    UserAssert(PW(ppos->hwnd));
    pwndParent = PW(ppos->hwnd)->spwndParent;
    UserAssert(pwndParent);

    /*
     * Go account for any dirty DCs at this point, to ensure that:
     *      - any drawing done before we create an SPB will not
     *        later invalidate that SPB
     *      - the SPB regions reflect the true state of the screen,
     *        so that we don't validate parts of windows that are dirty.
     *
     * We must make this call before we change any window state.
     */
    if (AnySpbs())
        SpbCheck();

    /*
     * Change the window states
     */
    zzzChangeStates(pwndParent, psmwp);

    /*
     * move window bits around
     *
     * Invalidate the DCs for the siblings of this window.
     *
     * If our parent is not clipchildren, then we don't need to
     * invalidate its DCs. If it IS clipchildren, its client visrgn
     * will be changing, so we must invalidate it too.
     *
     * Note, because IDC_MOVEBLT is set, final completion of WNDOBJ
     * notification is delayed until GreClientRgnDone is called.
     * This final notification does not happen until after the
     * window move blts have completed.
     */
    zzzInvalidateDCCache(pwndParent,
                      IDC_MOVEBLT |
                      (TestWF(pwndParent, WFCLIPCHILDREN) ?
                          IDC_CLIENTONLY : IDC_CHILDRENONLY));

    /*
     * Now, do the bltting or whatever that is required.
     */
    fsSumEmpty = RE_VALIDSUM | RE_INVALIDSUM;
    hrgnInvalidate = ghrgnInvalidSum;

    /*
     * Init count of windows being shown with SWP_SHOWWINDOW
     * for our backward compatibility hack later.
     */
    cwndShowing = 0;

    for (pcvr = psmwp->acvr, ccvr = psmwp->ccvr; --ccvr >= 0; pcvr++) {

        /*
         * Decrement loop count. When cIter is 0, then
         * we're on the last pass through the loop.
         */
        cIter--;

        if (pcvr->pos.hwnd == NULL)
            continue;

        /*
         * If we're not redrawing, try the next one.
         */
        if (pcvr->pos.flags & SWP_NOREDRAW)
            continue;

        /*
         * Some drawing has been done
         */
        fSyncPaint = TRUE;

        pwnd = PW(pcvr->pos.hwnd);

        fsRgnEmpty = pcvr->fsRE;

        /*
         * Sprites should not be invalidated or cause invalidation.
         */
#ifdef REDIRECTION
        if (TestWF(pwnd, WEFLAYERED) || TestWF(pwnd, WEFEXTREDIRECTED)) {
#else // REDIRECTION
        if (TestWF(pwnd, WEFLAYERED)) {
#endif // REDIRECTION

            if (GetRedirectionBitmap(pwnd) == NULL)
                goto InvalidEmpty;

            /*
             * Sizing or showing uncovers new bits for a window, so
             * do the normal invalidation in this case. When sizing makes a
             * window smaller setting fInvalidateLayers to TRUE has the side
             * effect of allowing other layered windows to be invalidated.
             * Ideally, it should only allow invlalidating just the windows
             * that resized or showed. This would be a bunch of work, but we
             * should consider it for later.
             */
            if ((pcvr->pos.flags & SWP_NOSIZE) &&
                    (pcvr->pos.flags & (SWP_SHOWWINDOW | SWP_FRAMECHANGED)) == 0) {
                goto InvalidEmpty;
            } else {
                fInvalidateLayers = TRUE;
            }
        }

        /*
         * Calculate the new visrgn
         */
        if (!SwpCalcVisRgn(pwnd, ghrgnVisNew))
            fsRgnEmpty |= RE_VISNEW;

        /*
         * If the window is obscured by another window with an SPB,
         * we have to ensure that that SPB gets invalidated properly
         * since the app may not be getting a WM_PAINT msg or anything
         * to invalidate the bits.
         */
        if (AnySpbs())
            SpbCheckRect(pwnd, &pwnd->rcWindow, DCX_WINDOW);

        /*
         * Calculate ghrgnValid:
         *
         * ghrgnValid = OffsetRgn(rcBlt, -dxBlt, -dyBlt) & hrgnVisOld
         * ghrgnValid = ghrgnValid - ghrgnValidSum
         * OffsetRgn(ghrgnValid, dxBlt, dyBlt);
         * ghrgnValid = ghrgnValid - hrgnUpdate
         * ghrgnValid = ghrgnValid & hrgnVisNew;
         *
         * If either the old or new visrgns are empty, there
         * can be no valid bits...
         */
        if (fsRgnEmpty & (RE_VISOLD | RE_VISNEW))
            goto ValidEmpty;

        /*
         * If the entire window is already completely invalid, blow out.
         */
        if (pwnd->hrgnUpdate == HRGN_FULL)
            goto ValidEmpty;

        /*
         * If the blt rectangle is empty, there can be no valid bits.
         */
        if ((pcvr->rcBlt.right <= pcvr->rcBlt.left) ||
            (pcvr->rcBlt.bottom <= pcvr->rcBlt.top)) {

            goto ValidEmpty;
        }

        GreSetRectRgn(ghrgnSWP1,
                      pcvr->rcBlt.left - pcvr->dxBlt,
                      pcvr->rcBlt.top - pcvr->dyBlt,
                      pcvr->rcBlt.right - pcvr->dxBlt,
                      pcvr->rcBlt.bottom - pcvr->dyBlt);

        switch (IntersectRgn(ghrgnValid, ghrgnSWP1, pcvr->hrgnVisOld)) {
        case NULLREGION:
        case ERROR:
            goto ValidEmpty;
            break;
        }

        if (!(fsSumEmpty & RE_VALIDSUM)) {
            switch (SubtractRgn(ghrgnValid, ghrgnValid, ghrgnValidSum)) {
            case NULLREGION:
            case ERROR:
                goto ValidEmpty;
                break;
            }
        }

        if ((pcvr->dxBlt | pcvr->dyBlt) != 0)
            GreOffsetRgn(ghrgnValid, pcvr->dxBlt, pcvr->dyBlt);

        /*
         * Now subtract off the update regions of ourself and any
         * non-clipchildren parents...
         */
        pwndT = pwnd;

        do {

            if (pwndT->hrgnUpdate == HRGN_FULL)
                goto ValidEmpty;

            if (pwndT->hrgnUpdate != NULL) {
                switch (SubtractRgn(ghrgnValid, ghrgnValid, pwndT->hrgnUpdate)) {
                case NULLREGION:
                case ERROR:
                    goto ValidEmpty;
                    break;
                }
            }

            pwndT = pwndT->spwndParent;

        } while (pwndT && !TestWF(pwndT, WFCLIPCHILDREN));

        /*
         * Subtract out the intermonitor blt pieces.
         */
        if (pcvr->hrgnInterMonitor != NULL) {
            switch (SubtractRgn(ghrgnValid, ghrgnValid, pcvr->hrgnInterMonitor)) {
                case NULLREGION:
                case ERROR:
                    goto ValidEmpty;
            }
        }

        switch (IntersectRgn(ghrgnValid, ghrgnValid, ghrgnVisNew)) {
        case NULLREGION:
        case ERROR:

ValidEmpty:

            fsRgnEmpty |= RE_VALID;
            break;
        }

        /*
         * Before we restore the restore bits over part of our
         * image, we need to first copy any valid bits to their
         * final destination.
         */
        if (!(fsRgnEmpty & RE_VALID) && ((pcvr->dxBlt | pcvr->dyBlt) != 0)) {

            if (hdcScreen == NULL)
                hdcScreen = gpDispInfo->hdcScreen;

            GreSelectVisRgn(hdcScreen, ghrgnValid, SVR_COPYNEW);

#ifdef _WINDOWBLT_NOTIFICATION_
/*
 * Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
 * This notification will set a special flag in the SURFOBJ passed to
 * drivers when the DrvCopyBits operation is called to move a window.
 *
 * See also:
 *      ntgdi\gre\maskblt.cxx
 */
            NtGdiBitBlt(hdcScreen,
                        pcvr->rcBlt.left,
                        pcvr->rcBlt.top,
                        pcvr->rcBlt.right - pcvr->rcBlt.left,
                        pcvr->rcBlt.bottom - pcvr->rcBlt.top,
                        hdcScreen,
                        pcvr->rcBlt.left - pcvr->dxBlt,
                        pcvr->rcBlt.top - pcvr->dyBlt,
                        SRCCOPY,
                        0,
                        GBB_WINDOWBLT);
#else
            GreBitBlt(hdcScreen,
                      pcvr->rcBlt.left,
                      pcvr->rcBlt.top,
                      pcvr->rcBlt.right - pcvr->rcBlt.left,
                      pcvr->rcBlt.bottom - pcvr->rcBlt.top,
                      hdcScreen,
                      pcvr->rcBlt.left - pcvr->dxBlt,
                      pcvr->rcBlt.top - pcvr->dyBlt,
                      SRCCOPY,
                      0);
#endif
        }

        /*
         * Now take care of any SPB bit restoration we need to do.
         *
         * Calculate the region to clip the RestoreSpb() output to:
         *
         * ghrgnInvalid = hrgnVisOld - hrgnVisNew
         */
        if (TestWF(pwnd, WFHASSPB)    &&
            !(fsRgnEmpty & RE_VISOLD) &&
            CombineOldNewVis(ghrgnInvalid, pcvr->hrgnVisOld, ghrgnVisNew, RGN_DIFF, fsRgnEmpty)) {

            UINT retRSPB;

            /*
             * Perform SPB bits restore. We pass RestoreSpb() the region of
             * the part of the SPB that got uncovered by this window rearrangement.
             * It tries to restore as much of this area as it can from the SPB,
             * and returns the area that could not be restored from the SPB.
             *
             * The device driver's SaveBitmap() function does not clip at all
             * when it restores bits, which means that it might write bits
             * in an otherwise valid area. This means that the invalid area
             * returned by RestoreSpb() may actually be LARGER than the original
             * hrgnSpb passed in.
             *
             * RestoreSpb() returns TRUE if some part of ghrgnInvalid needs
             * to be invalidated.
             */
            if ((retRSPB = RestoreSpb(pwnd, ghrgnInvalid, &hdcScreen)) == RSPB_NO_INVALIDATE) {

                /*
                 * If hrgnVisNew is empty, then we know the whole invalid
                 * area is empty.
                 */
                if (fsRgnEmpty & RE_VISNEW)
                    goto InvalidEmpty;

            } else if (retRSPB == RSPB_INVALIDATE_SSB) {

                /*
                 * If RestoreSpb actually invalidated some area and we already
                 * have a ghrgnValidSum then subtract the newly invalidated area
                 * Warning this region subtract is not in the Win 3.1 code but
                 * they probably did not have the problem as severe because their
                 * drivers were limited to one level of SaveScreenBits
                 */
                if (!(fsSumEmpty & RE_VALIDSUM))
                    SubtractRgn(ghrgnValidSum, ghrgnValidSum, ghrgnInvalid);
            }

            /*
             * ghrgnInvalid += hrgnVisNew
             */
            if (!(fsRgnEmpty & RE_VISNEW))
                UnionRgn(ghrgnInvalid, ghrgnInvalid, ghrgnVisNew);

            /*
             * Some of the area we calculated as valid may have gotten
             * obliterated by the SPB restore. To ensure this isn't
             * the case, subtract off the ghrgnInvalid returned by RestoreSpb.
             */
            // LATER mikeke VALIDSUM / ghrgnValid mismatch
            if (!(fsRgnEmpty & RE_VALIDSUM)) {
                switch (SubtractRgn(ghrgnValid, ghrgnValid, ghrgnInvalid)) {
                case NULLREGION:
                case ERROR:
                    fsRgnEmpty |= RE_VALIDSUM;
                    break;
                }
            }

        } else {

            /*
             * No SPB. Simple ghrgnInvalid calculation is:
             *
             * ghrgnInvalid = hrgnVisNew + hrgnVisOld;
             */
            if (pcvr->hrgnVisOld == NULL) {

                /*
                 * If we couldn't create hrgnVisOld, then
                 * invalidate the entire parent
                 */
                SetRectRgnIndirect(ghrgnInvalid, &pwndParent->rcWindow);
            } else {

                if (!CombineOldNewVis(ghrgnInvalid,
                                      pcvr->hrgnVisOld,
                                      ghrgnVisNew,
                                      RGN_OR,
                                      fsRgnEmpty)) {

                    goto InvalidEmpty;
                }
            }
        }

        /*
         * Update ghrgnValidSum
         *
         * ghrgnValidSum += ghrgnValid
         */
        if (!(fsRgnEmpty & RE_VALID)) {

            /*
             * If the sum region is empty, then COPY instead of OR
             */
            if (fsSumEmpty & RE_VALIDSUM)
                CopyRgn(ghrgnValidSum, ghrgnValid);
            else
                UnionRgn(ghrgnValidSum, ghrgnValid, ghrgnValidSum);
            fsSumEmpty &= ~RE_VALIDSUM;
        }

        /*
         * Subtract ghrgnValidSum from ghrgnInvalid if non-empty,
         * otherwise use ghrgnValid. Note, ghrgnValid has been OR'ed
         * into ghrgnValidSum already.
         */
        if (!(fsSumEmpty & RE_VALIDSUM) || !(fsRgnEmpty & RE_VALID)) {
            switch (SubtractRgn(ghrgnInvalid, ghrgnInvalid,
                    !(fsSumEmpty & RE_VALIDSUM) ? ghrgnValidSum : ghrgnValid)) {
            case NULLREGION:
            case ERROR:
InvalidEmpty:
                fsRgnEmpty |= RE_INVALID;
                break;
            }
        }

        /*
         * If there are any SPB bits left over, it wasn't just created
         * (SWP_SHOWWINDOW), and an operation occured that invalidates
         * the spb bits, get rid of the spb. A move, size, hide, or
         * zorder operation will invalidate the bits. Note that we do this
         * outside of the SWP_NOREDRAW case in case the guy set that flag
         * when he had some SPB bits lying around.
         */
        if (TestWF(pwnd, WFHASSPB) && !(pcvr->pos.flags & SWP_SHOWWINDOW) &&
                (pcvr->pos.flags &
                (SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_HIDEWINDOW))
                != (SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER)) {

            FreeSpb(FindSpb(pwnd));
        }

        /*
         * Finally, free up hrgnVisOld.
         */
        if (pcvr->hrgnVisOld) {
            GreDeleteObject(pcvr->hrgnVisOld);
            pcvr->hrgnVisOld = NULL;
        }

        /*
         * BACKWARD COMPATIBILITY HACK
         *
         * In 3.0, a ShowWindow() NEVER invalidated any of the children.
         * It would invalidate the parent and the window being shown, but
         * no others.
         *
         * We only apply hack (a) to 3.0 apps when all the windows involved
         * are doing a SWP_SHOWWINDOW: if any aren't, then we have to make
         * sure the siblings are invalidated too. So, we count the windows
         * doing a SHOWWINDOW and compare it to the total count in the CVR.
         */
        if (!TestWF(pwnd, WFWIN31COMPAT) && (pcvr->pos.flags & SWP_SHOWWINDOW))
            cwndShowing++;

        /*
         * Update ghrgnInvalidSum:
         *
         * ghrgnInvalidSum += ghrgnInvalid
         */
        if (!(fsRgnEmpty & RE_INVALID)) {

            /*
             * BACKWARD COMPATIBILITY HACK
             *
             * In many cases including ShowWindow, CS_V/HREDRAW,
             * SWP_NOCOPYBITS, etc, 3.0 always invalidated the window with
             * (HRGN)1, regardless of how it was clipped by children, siblings,
             * or parents. Besides being more efficient, this caused child
             * windows that would otherwise not get update regions to get
             * invalidated -- see the hack notes in InternalInvalidate2.
             *
             * This is a performance hack (usually) because (HRGN)1 can save
             * a lot of region calculations in the normal case. So, we do this
             * for 3.1 apps as well as 3.0 apps.
             *
             * We detect the case as follows: invalid area not empty,
             * valid area empty, and new visrgn not empty.
             */
            if ((fsRgnEmpty & RE_VALID) && !(fsRgnEmpty & RE_VISNEW)) {

                /*
                 * With the parameters we use InternalInvalidate() does
                 * not leave the critical section
                 */
                BEGINATOMICCHECK();
                xxxInternalInvalidate(pwnd,
                                     HRGN_FULL,
                                     RDW_INVALIDATE |
                                     RDW_FRAME      |
                                     RDW_ERASE      |
                                     RDW_ALLCHILDREN);
                ENDATOMICCHECK();
            }

            /*
             * If the sum region is empty, then COPY instead of OR
             */
            if (fsSumEmpty & RE_INVALIDSUM) {

                /*
                 * HACK ALERT:
                 * If this is the last pass through the loop (cIter == 0)
                 * and ghrgnInvalidSum is currently empty,
                 * then instead of copying ghrgnInvalid to ghrgnInvalidSum,
                 * just set hrgnInvalidate to ghrgnInvalid. This saves
                 * a region copy in the single-window case.
                 */
                if (cIter == 0) {
                    hrgnInvalidate = ghrgnInvalid;
                } else {
                    CopyRgn(ghrgnInvalidSum, ghrgnInvalid);
                }

            } else {

                UnionRgn(ghrgnInvalidSum, ghrgnInvalid, ghrgnInvalidSum);
            }

            fsSumEmpty &= ~RE_INVALIDSUM;
        }
    } // for (... pcvr ...)

    /*
     * Now, invalidate as needed.
     */
    if (!(fsSumEmpty & RE_INVALIDSUM)) {

        /*
         * BACKWARD COMPATIBILITY HACK (see above)
         *
         * If all the windows involved were being shown, then
         * invalidate the parent ONLY -- don't enumerate any children.
         * (the windows involved have already been invalidated above).
         * This hack is only applied to 3.0 apps (see above).
         */

        /*
         * More hack-o-rama. On Win3.1, the desktop paint would only
         * repaint those portions inside the rect returned from GetClipBox().
         * Dialogs with spbs outside the rect returned from GetClipBox() would
         * not get their spbs invalidated until later, when you clicked on
         * them to make them active. The only dialog that wouldn't really loose
         * its bits is the control panel desktop dialog, which would restore
         * its bad bits when it went away (in certain configurations). On
         * NT, the desktop would repaint and then the dialog would go away.
         * On Win3.1, the dialog would go away and then the desktop would
         * repaint. On NT, because of preemption and little differences in
         * painting order between applications, there was an opportunity to
         * put bad bits on the screen, on Win3.1 there wasn't.
         *
         * Now... the below code that passes RDW_NOCHILDREN only gets executed
         * if the app is marked as a win3.0 app (latest CorelDraw, also wep
         * freecell demonstrates the same problem). This code would get
         * executed when a dialog got shown. So for a win3.0 app, spb would get
         * saved, the dialog would get shown, the desktop invalidated, the
         * desktop would paint, the spb would get clobbered. In short, when
         * a win3.0 app would put up a dialog, all spbs would get freed because
         * of the new (and correct) way the desktop repaints.
         *
         * So the desktop check hack will counter-act the invalidate
         * RDW_NOCHILDREN case if all windows are hiding / showing and the
         * desktop is being invalidated. Note that in the no RDW_NOCHILDREN
         * case, the invalid area gets distributed to the children first (in
         * this case, children of the desktop), so if the children cover the
         * desktop, the desktop won't get any invalid region, which is what
         * we want. - scottlu
         */

        /*
         * With the parameters we use InternalInvalidate() does not leave
         * the critical section
         */

        DWORD dwFlags = RDW_INVALIDATE | RDW_ERASE;
        if (cwndShowing == psmwp->ccvr &&
                pwndParent != PWNDDESKTOP(pwndParent)) {
            dwFlags |= RDW_NOCHILDREN;
        } else {
            dwFlags |= RDW_ALLCHILDREN;
        }
        if (fInvalidateLayers) {
            dwFlags |= RDW_INVALIDATELAYERS;
        }

        BEGINATOMICCHECK();
        xxxInternalInvalidate(pwndParent, hrgnInvalidate, dwFlags);
        ENDATOMICCHECK();
    }

    /*
     * Since zzzInvalidateDCCache was called with IDC_MOVEBLT specified,
     * we must complete the WNDOBJ notification with a call to
     * GreClientRgnDone.
     *
     * Note: in zzzInvalidateDCCache, it is necessary to call
     * GreClientRgnUpdated even if gcountPWO is 0. However,
     * GreClientRgnDone only does something if gcountPWO is non-zero,
     * so we can optimize slightly.
     */
    if (gcountPWO != 0) {
        GreClientRgnDone(GCR_WNDOBJEXISTS);
    }

UnlockAndExit:

    /*
     * If necessary, release the screen DC
     */
    if (hdcScreen != NULL) {

        /*
         * Reset the visrgn before we go...
         */
        GreSelectVisRgn(hdcScreen, NULL, SVR_DELETEOLD);

        /*
         * Make sure that the drawing we did in this DC does not affect
         * any SPBs. Clear the dirty rect.
         */
        GreGetBounds(hdcScreen, NULL, 0);     // NULL means reset
    }

    /*
     * All the dirty work is done. Ok to leave the critsects we entered
     * earlier and dispatch any deferred Window Event notifications.
     */
    GreUnlockDisplay(gpDispInfo->hDev);
    zzzEndDeferWinEventNotify();

    return fSyncPaint;
}

/***************************************************************************\
* xxxHandleWindowPosChanged
*
* DefWindowProc() HandleWindowPosChanged handler.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxHandleWindowPosChanged(
    PWND pwnd,
    PWINDOWPOS ppos)
{
    CheckLock(pwnd);

    if (!(ppos->flags & SWP_NOCLIENTMOVE)) {
        POINT   pt;
        PWND    pwndParent;

        pt.x = pwnd->rcClient.left;
        pt.y = pwnd->rcClient.top;

        pwndParent = pwnd->spwndParent;
        UserAssert(pwndParent);

        if (pwndParent != PWNDDESKTOP(pwnd)) {
            pt.x -= pwndParent->rcClient.left;
            pt.y -= pwndParent->rcClient.top;
        }

        xxxSendMessage(
                pwnd,
                WM_MOVE,
                FALSE,
                MAKELONG(pt.x, pt.y));
    }

    if ((ppos->flags & SWP_STATECHANGE) || !(ppos->flags & SWP_NOCLIENTSIZE)) {

        if (TestWF(pwnd, WFMINIMIZED))
            xxxSendSizeMessage(pwnd, SIZEICONIC);
        else if (TestWF(pwnd, WFMAXIMIZED))
            xxxSendSizeMessage(pwnd, SIZEFULLSCREEN);
        else
            xxxSendSizeMessage(pwnd, SIZENORMAL);
    }
}

/***************************************************************************\
* PWND GetRealOwner(pwnd)
*
* Returns the owner of pwnd, normalized so that it shares the same parent
* of pwnd.
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

PWND GetRealOwner(
    PWND pwnd)
{
    PWND pwndParent = pwnd->spwndParent;

    /*
     * A frame window owned by itself is "unowned"
     */
    if (pwnd != pwnd->spwndOwner && (pwnd = pwnd->spwndOwner) != NULL) {

        /*
         * The NULL test is in case the owner is higher than the
         * passed in window (e.g. your owner IS your parent)
         */
        while (pwnd != NULL && pwnd->spwndParent != pwndParent)
            pwnd = pwnd->spwndParent;
    }

    return pwnd;
}

/***************************************************************************\
*
* Starting at pwnd (or pwndParent->spwndChild if pwnd == NULL), find
* next window owned by pwndOwner
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

PWND NextOwnedWindow(
    PWND pwnd,
    PWND pwndOwner,
    PWND pwndParent)
{
    if (pwnd == NULL) {
        pwnd = pwndParent->spwndChild;
        /*
         * In xxxCreateWindowEx(), we callback the window proc while the window
         * is still not linked yet to the window tree. If it is the first child
         * of its parent, then the window spwndParent will point to the parent while
         * the parent spwndChild will still be NULL. If the window proc called ShowWindow()
         * or SetWindowPos() in response to those early callbacks, we will end up here with broken 
         * window tree. The right fix is to never call back while the window tree is in an intermediate 
         * state (i.e. linking the window to the three before any callback) but this seem scary to change
         * now because of app compat. See bug# 482192. [msadek, 10/24/2001].
         */
        if (pwnd == NULL) {
            RIPMSG1(RIP_WARNING, "Window tree structure broken at pwnd: %x", pwndParent);
            return NULL;
        }
        goto loop;
    }

    while ((pwnd = pwnd->spwndNext) != NULL) {

loop:

        /*
         * If owner of pwnd is pwndOwner, break out of here...
         */
        if (pwndOwner == GetRealOwner(pwnd))
            break;
    }

    return pwnd;
}

/***************************************************************************\
*
* Recursively enumerate owned windows starting from pwndRoot,
* to set the state of WEFTOPMOST. Doesn't actually diddle
* this bit yet: the work gets done in zzzChangeStates():
* instead we just set the WFTOGGLETOPMOST bit as appropriate.
*
* We can't diddle the state until the Z order changes are done,
* or else GetTopMostWindow() and the like will do the wrong thing.
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

VOID SetTopmost(
    PWND pwndRoot,
    BOOL fTopmost)
{
    PWND pwnd;

    /*
     * If the new state is different than the current state,
     * then set the TOGGLETOPMOST bit, so it'll get toggled
     * in ChangeStates().
     */
    UserAssert((fTopmost == TRUE) || (fTopmost == FALSE));
    if (!!TestWF(pwndRoot, WEFTOPMOST) ^ fTopmost) {
        SetWF(pwndRoot, WFTOGGLETOPMOST);
    } else {
        ClrWF(pwndRoot, WFTOGGLETOPMOST);
    }

    pwnd = NULL;
    while (pwnd = NextOwnedWindow(pwnd, pwndRoot, pwndRoot->spwndParent)) {
                  SetTopmost(pwnd, fTopmost);
    }

}

/*
 * LATER: (hiroyama) #88810
 * The IME code here broke the US regression test, so backing it up until we
 * hit the problem on NT.
 */
#ifdef LATER
/***************************************************************************\
 * IsBottomIMEWindow()
 *
 * returns TRUE if pwnd is IME window and its toplevel window is BOTTOMMOST
 *
 * Ported: 18-Apr-1997 Hiroyama     from Memphis
\***************************************************************************/
BOOL IsBottomIMEWindow(
    PWND pwnd)
{
    if (TestCF(pwnd, CFIME) ||
            (pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME])) {
        PWND pwndT2 = pwnd;
        PWND pwndTopOwner = pwnd;
        PWND pwndDesktop;

        if (grpdeskRitInput == NULL || grpdeskRitInput->pDeskInfo == NULL) {
            // Desktop is being created or not yet created
            RIPMSG1(RIP_WARNING, "IsBottomIMEWindow: Desktop is being created or not yet created. pwnd=%#p\n",
                    pwnd);
            return FALSE;
        }

        pwndDesktop = grpdeskRitInput->pDeskInfo->spwnd;

        UserAssert(pwndDesktop);

        /*
         * search the toplevel owner window of the IME window.
         */
        while (pwndT2 && (pwndT2 != pwndDesktop)) {
            pwndTopOwner = pwndT2;
            pwndT2 = pwndT2->spwndOwner;
        }
        /*
         * TRUE if the toplevel owner window of the IME window is BOTTOMMOST
         */
        return (BOOL)(TestWF(pwndTopOwner, WFBOTTOMMOST));
    }
    return FALSE;
}

/***************************************************************************\
 * ImeCheckBottomIMEWindow()
 *
 * returns TRUE if pwndT->spwndNext's owner is BOTTOMMOST
 *
 * Ported: 18-Apr-1997 Hiroyama     from Memphis
\***************************************************************************/
BOOL ImeCheckBottomIMEWindow(
    PWND pwndT)
{
    /*
     * pwnd is IME window and its toplevel window is BOTTOMMOST
     */
    PWND pwndDesktop;
    PWND pwndT2 = pwndT->spwndNext;
    PWND pwndTopOwner = pwndT2;

    UserAssert(grpdeskRipInput != NULL && grpdeskRitInput->pDeskInfo != NULL);
    pwndDesktop = grpdeskRitInput->pDeskInfo->spwnd;

    /*
     * check if toplevel owner window of pwnd->spwndNext is bottommost
     */
    while (pwndT2 && (pwndT2 != pwndDesktop)) {
        pwndTopOwner = pwndT2;
        pwndT2 = pwndT2->spwndOwner;
    }

    if (pwndTopOwner && TestWF(pwndTopOwner, WFBOTTOMMOST)) {
        /*
         * yes, pwndT is the last one whose toplevel window is *not* BOTTOMMOST
         */
        return TRUE;
    }

    return FALSE;
}
#endif  // LATER

/***************************************************************************\
* CalcForegroundInsertAfter
*
* Calculates where to zorder a window that doesn't belong to the foreground
* thread and is not topmost but wants to come to the top. This routine
* calculates what "top" means under those conditions.
*
* 14-Sep-1992 ScottLu       Created.
\***************************************************************************/

PWND CalcForegroundInsertAfter(
    PWND pwnd)
{
    PWND        pwndInsertAfter, pwndInsertAfterSave;
    PWND        pwndT;
    PTHREADINFO ptiTop;
#ifdef LATER    // see #88810
    BOOLEAN     fImeOwnerIsBottom = FALSE;
#endif

    /*
     * If we're allowing this application to make this top
     * level window foreground active, then this app may
     * not be foreground yet, but we want any windows it
     * zorders to appear on top because it is probably about
     * to activate them (this is a guess!) If this is the case,
     * let it do what it wants. A good example of this is an
     * application like toolbook that creates a window without a
     * caption, doesn't activate it, and wants that to appear on top.
     */

    if (TestWF(pwnd, WFBOTTOMMOST)) {
        pwndInsertAfter = GetLastNonBottomMostWindow(pwnd, TRUE);
    } else {
        pwndInsertAfter = GetLastTopMostWindow();
#ifdef LATER    // see #88810
        if (IS_IME_ENABLED()) {
            fImeOwnerIsBottom = IsBottomIMEWindow(pwnd);
            if (fImeOwnerIsBottom) {
                for (pwndT = pwndInsertAfter; pwndT; pwndT = pwndT->spwndNext) {
                    if (ImeCheckBottomIMEWindow(pwndT)) {
                        /*
                         * toplevel owner of pwndT->spwndNext is BOTTOMMOST
                         */
                        break;
                    }
                    pwndInsertAfter = pwndT;
                }
            }
        }
#endif  // LATER
    }


    if (!TestwndChild(pwnd)) {
//    if (hwnd->hwndParent == hwndDesktop)  -- Chicago conditional FritzS

        if ((GETPTI(pwnd)->TIF_flags & TIF_ALLOWFOREGROUNDACTIVATE) ||
                (GETPTI(pwnd)->ppi->W32PF_Flags & W32PF_ALLOWFOREGROUNDACTIVATE)) {

            return pwndInsertAfter;
        }
    }

    /*
     * If there is no foreground thread or this pwnd is of the foreground
     * thread, then let it come to the top.
     */
    if (gpqForeground == NULL)
        return pwndInsertAfter;

    if (GETPTI(pwnd)->pq == gpqForeground)
        return pwndInsertAfter;

    /*
     * This thread is not of the foreground queue, so search for a window
     * of this thread to zorder above.
     */
    pwndT = ((pwndInsertAfter == NULL) ?
            pwnd->spwndParent->spwndChild :
            pwndInsertAfter);

    /*
     * Remember the top insert after in case this first loop
     * fails to find a window
     */
    pwndInsertAfterSave = pwndInsertAfter;

    for (; pwndT != NULL; pwndT = pwndT->spwndNext) {

        /*
         * This window wants to come to the top if possible.
         * If we're passing our own window, get out of this loop:
         * by now we already have pwndInsertAfter set up to the
         * last available window to insert after.
         */
        if ((pwndT == pwnd) || TestWF(pwndT, WFBOTTOMMOST))
            break;

        /*
         * If this window isn't owned by this thread, continue.
         */
        if (GETPTI(pwndT) != GETPTI(pwnd)) {
            pwndInsertAfter = pwndT;
            continue;
        }

        /*
         * Don't want a window zordering below one of its top most windows
         * if it isn't foreground.
         */
        if (TestWF(pwndT, WEFTOPMOST)) {
            pwndInsertAfter = pwndT;
            continue;
        }

#ifdef LATER    // see #88810
        // FE_IME
        if (fImeOwnerIsBottom && ImeCheckBottomIMEWindow(pwndT)) {
            /*
             * owner of pwndT->spwndNext is BOTTOMMOST
             * so pwndT is the last one whose owner is not bottommost.
             */
            pwndInsertAfter = pwndT;
            continue;
        }
        // end FE_IME
#endif

        /*
         * Ok to change zorder of top level windows because of
         * invisible windows laying around, but not children:
         * applications would go nuts if we did this.
         */
        if (!TestwndChild(pwndT)) {
            if (!TestWF(pwndT, WFVISIBLE)) {
                pwndInsertAfter = pwndT;
                continue;
            }
        }

        break;
    }

    /*
     * If we didn't find a window in the previous loop,
     * it means that the thread has no
     * other sibling windows, so we need to put it after the
     * foreground window (foreground thread). Search for the
     * first unowned window of the foreground app to zorder
     * after.
     */
    if ((pwndT == NULL) || TestWF(pwndT, WFBOTTOMMOST)) {
        /*
         * This is our first guess in case nothing works out.
         */
        pwndInsertAfter = pwndInsertAfterSave;

        /*
         * Start below the last topmost or from the top if no
         * topmost windows.
         */
        if ((pwndT = pwndInsertAfter) == NULL)
            pwndT = pwnd->spwndParent->spwndChild;

        /*
         * ptiTop is the pti of the active window in the foreground queue!
         */
        ptiTop = NULL;
        if (gpqForeground->spwndActive != NULL)
            ptiTop = GETPTI(gpqForeground->spwndActive);

        for (; pwndT != NULL; pwndT = pwndT->spwndNext) {

            if (TestWF(pwndT, WFBOTTOMMOST))
                break;

            /*
             * If not the top most thread, continue.
             */
            if (GETPTI(pwndT) != ptiTop)
                continue;

            /*
             * Found one of the foreground thread. Remember this
             * as the next best guess. Try to find an unowned
             * visible window, which would indicate the main
             * window of the foreground thread. If owned,
             * continue.
             */
            if (pwndT->spwndOwner != NULL) {
                pwndInsertAfter = pwndT;
                continue;
            }

            /*
             * Unowned and of the foreground thread. Is it visible?
             * If not, get out of here.
             */
            if (!TestWF(pwndT, WFVISIBLE))
                continue;
#ifdef LATER    // see #88810
            // FE_IME
            if (fImeOwnerIsBottom && ImeCheckBottomIMEWindow(pwndT)) {
                continue;
            }
            // end FE_IME
#endif

            /*
             * Best possible match so far: unowned visible window
             * of the foreground thread.
             */
            pwndInsertAfter = pwndT;
        }
    }

    UserAssert(pwnd != pwndInsertAfter);

    return pwndInsertAfter;
}

/***************************************************************************\
* GetTopMostInsertAfter
*
* We don't want any one to get in front of a hard error box, except menus,
* screen savers, etc.
*
* Don't call it directly, use the GETTOPMOSTINSERTAFTER macro to avoid
* the call when there is no hard error box up (gHardErrorHandler.pti == NULL).
*
* 04-25-96 GerardoB Created
\***************************************************************************/
PWND GetTopMostInsertAfter(
    PWND pwnd)
{
    PWND pwndT;
    PTHREADINFO ptiCurrent;
    PDESKTOP pdesk;
    WORD wfnid;

    /*
     * If you hit this assertion, you're probably not using the
     * GETTOPMOSTINSERTAFTER macro to make this call.
     */
    UserAssert(gHardErrorHandler.pti != NULL);

    /*
     * pwnd: Menu and switch (ALT-TAB) windows can go on top.
     */
    wfnid = GETFNID(pwnd);
    if ((wfnid == FNID_MENU) || (wfnid == FNID_SWITCH)) {
        return NULL;
    }

    /*
     * pti: If this is the error handler thread, don't bother any longer.
     *      Screen saver can go on top too.
     */
    ptiCurrent = PtiCurrent();
    UserAssert(ptiCurrent != NULL);

    if (ptiCurrent == gHardErrorHandler.pti || (ptiCurrent->ppi->W32PF_Flags & W32PF_SCREENSAVER)) {
        return NULL;
    }

    /*
     * pdesk: Leave the logon desktop alone.
     *        Make sure the hard error box is on this desktop
     */
    pdesk = ptiCurrent->rpdesk;
    UserAssert(pdesk != NULL);
    UserAssert(pdesk->rpwinstaParent);
    UserAssert(pdesk->rpwinstaParent->pTerm);

    if ((pdesk == grpdeskLogon)
            || (pdesk != gHardErrorHandler.pti->rpdesk)) {
        return NULL;
    }

    /*
     * Walk the window list looking for the hard error box.
     * Start searching from the current desktop's first child.
     * Note that the harderror box migth not be created yet.
     */
    UserAssert(pdesk->pDeskInfo);
    UserAssert(pdesk->pDeskInfo->spwnd);

    for (pwndT = pdesk->pDeskInfo->spwnd->spwndChild;
            pwndT != NULL; pwndT = pwndT->spwndNext) {

        /*
         * Hard error boxes are always top most.
         */
        if (!TestWF(pwndT, WEFTOPMOST)) {
            break;
        }

        /*
         * If this window was created by the hard error handler thread,
         * then this is it.
         */
        if (gHardErrorHandler.pti == GETPTI(pwndT)) {
            return pwndT;
        }
    }

    return NULL;
}

/***************************************************************************\
*
* This routine maps the special HWND_* values of ppos->hwndInsertAfter,
* and returns whether or not the window's owner group should be labelled
* TOPMOST or not, or left alone.
*
* Here are the TOPMOST rules. If pwndInsertAfter is:
*
* 1. HWND_BOTTOM == (HWND)1:
*
*    The group is made non-TOPMOST.
*
* 2. HWND_TOPMOST == (HWND)-1:
*
*    hwndInsertAfter is set to HWND_TOP, and the group is made TOPMOST.
*
* 3. HWND_NOTOPMOST == (HWND)-2:
*
*    Treated same as HWND_TOP, except that the TOPMOST bit is cleared.
*    and the entire group is made non-topmost.
*    Used to make a topmost window non-topmost, but still leave it at
*    the top of the non-topmost pile.
*    The group is not changed if the window is already non-topmost.
*
* 4. HWND_TOP == (HWND)NULL:
*
*    pwndInsertAfter is set to the last TOPMOST window if pwnd
*    is not itself TOPMOST. If pwnd IS TOPMOST, then pwndInsertAfter
*    remains HWND_TOP.
*
* 5. A TOPMOST window:
*
*    If a window is being inserted among the TOPMOST windows, then
*    the group becomes topmost too, EXCEPT if it's being inserted behind
*    the bottom-most topmost window: in that case the window retains
*    its current TOPMOST bit.
*
* 6. A non-TOPMOST window:
*
*    If a window is being inserted among non-TOPMOST windows, the group is made
*    non-TOPMOST and inserted there.
*
* Whenever a group is made TOPMOST, only that window and its ownees are made
* topmost. When a group is made NOTOPMOST, the entire window is made non-topmost.
*
* This routine must NOT set SWP_NOZORDER if the topmost state is changing:
* this would prevent the topmost bits from getting toggled in ChangeStates.
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

int CheckTopmost(
    PWINDOWPOS ppos)
{
    PWND pwnd, pwndInsertAfter, pwndT;

    /*
     * BACKWARD COMPATIBILITY HACK
     *
     * If we're activating a window and Z-ordering too, we must ignore the
     * specified Z order and bring the window to the top, EXCEPT in the
     * following conditions:
     *
     * 1. The window is already active (in which case, the activation code
     *    will not be bringing the window to the top)
     *
     * 2. HWND_TOP or HWND_NOTOPMOST is specified. This allows us to
     *    activate and move to topmost or nontopmost at the same time.
     *
     * NOTE: It would have been possible to modify ActivateWindow() to
     * take a flag to prevent it from ever doing the BringWindowToTop,
     * thus allowing SetWindowPos() to properly honor pwndInsertBehind
     * AND activation, but this change was considered too late in the
     * game -- there could be problems with existing 3.1 apps, such as
     * PenWin, etc.
     */
    pwnd = PW(ppos->hwnd);
    if (!(ppos->flags & SWP_NOACTIVATE) &&
            !(ppos->flags & SWP_NOZORDER) &&
             (ppos->hwndInsertAfter != HWND_TOPMOST &&
             ppos->hwndInsertAfter != HWND_NOTOPMOST) &&
             (pwnd != GETPTI(pwnd)->pq->spwndActive)) {
        ppos->hwndInsertAfter = HWND_TOP;
    }

    /*
     * If we're not Z-ordering, don't do anything.
     */
    if (ppos->flags & SWP_NOZORDER)
        return CTM_NOCHANGE;


    if (ppos->hwndInsertAfter == HWND_BOTTOM) {

        return CTM_NOTOPMOST;

    } else if (ppos->hwndInsertAfter == HWND_NOTOPMOST) {

        /*
         * If currently topmost, move to top of non-topmost list.
         * Otherwise, no change.
         *
         * Note that we don't set SWP_NOZORDER -- we still need to
         * check the TOGGLETOPMOST bits in ChangeStates()
         */
        if (TestWF(pwnd, WEFTOPMOST)) {

            pwndT = GetLastTopMostWindow();
            ppos->hwndInsertAfter = HW(pwndT);

            if (ppos->hwndInsertAfter == ppos->hwnd) {
                pwndT = _GetWindow(pwnd, GW_HWNDPREV);
                ppos->hwndInsertAfter = HW(pwndT);
            }

        } else {

            pwndT = _GetWindow(pwnd, GW_HWNDPREV);
            ppos->hwndInsertAfter = HW(pwndT);
        }

        return CTM_NOTOPMOST;

    } else if (ppos->hwndInsertAfter == HWND_TOPMOST) {
        pwndT = GETTOPMOSTINSERTAFTER(pwnd);
        if (pwndT != NULL) {
            ppos->hwndInsertAfter = HW(pwndT);
        } else {
            ppos->hwndInsertAfter = HWND_TOP;
        }

        return CTM_TOPMOST;

    } else if (ppos->hwndInsertAfter == HWND_TOP) {
        /*
         * If we're not topmost, position ourself after
         * the last topmost window. Otherwise, make sure
         * that no one gets in front of a hard error box.
         */
        if (TestWF(pwnd, WEFTOPMOST)) {
            pwndT = GETTOPMOSTINSERTAFTER(pwnd);
            if (pwndT != NULL) {
                ppos->hwndInsertAfter = HW(pwndT);
            }
            return CTM_NOCHANGE;
        }

        /*
         * Calculate the window to zorder after for this window, taking
         * into account foreground status.
         */
        pwndInsertAfter = CalcForegroundInsertAfter(pwnd);
        ppos->hwndInsertAfter = HW(pwndInsertAfter);

        return CTM_NOCHANGE;
    }

    /*
     * If we're being inserted after the last topmost window,
     * then don't change the topmost status.
     */
    pwndT = GetLastTopMostWindow();
    if (ppos->hwndInsertAfter == HW(pwndT))
        return CTM_NOCHANGE;

    /*
     * Otherwise, if we're inserting a TOPMOST among non-TOPMOST,
     * or vice versa, change the status appropriately.
     */
    if (TestWF(PW(ppos->hwndInsertAfter), WEFTOPMOST)) {

        if (!TestWF(pwnd, WEFTOPMOST)) {
            return CTM_TOPMOST;
        }

        pwndT = GETTOPMOSTINSERTAFTER(pwnd);
        if (pwndT != NULL) {
            ppos->hwndInsertAfter = HW(pwndT);
        }

    } else {

        if (TestWF(pwnd, WEFTOPMOST))
            return CTM_NOTOPMOST;
    }

    return CTM_NOCHANGE;
}

/***************************************************************************\
* IsOwnee(pwndOwnee, pwndOwner)
*
* Returns TRUE if pwndOwnee is owned by pwndOwner
*
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

BOOL IsOwnee(
    PWND pwndOwnee,
    PWND pwndOwner)
{
    PWND pwnd;

    while (pwndOwnee != NULL) {

        /*
         * See if pwndOwnee is a child of pwndOwner...
         */
        for (pwnd = pwndOwnee; pwnd != NULL; pwnd = pwnd->spwndParent) {
            if (pwnd == pwndOwner)
                return TRUE;
        }

        /*
         * If the window doesn't own itself, then set the owner
         * to itself.
         */
        pwndOwnee = (pwndOwnee->spwndOwner != pwndOwnee ?
                pwndOwnee->spwndOwner : NULL);
    }

    return FALSE;
}

/***************************************************************************\
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

BOOL IsBehind(
    PWND pwnd,
    PWND pwndReference)
{

    /*
     * Starting at pwnd, move down until we reach the end of the window
     * list, or until we reach pwndReference. If we encounter pwndReference,
     * then pwnd is above pwndReference, so return FALSE. If we get to the
     * end of the window list, pwnd is behind, so return TRUE.
     */
    if (pwndReference == (PWND)HWND_TOP)
        return TRUE;

    if (pwndReference == (PWND)HWND_BOTTOM)
        return FALSE;

    for ( ; pwnd != NULL; pwnd = pwnd->spwndNext) {
        if (pwnd == pwndReference)
            return FALSE;
    }

    return TRUE;
}

/***************************************************************************\
*
* Add pwnd to the SMWP. pwndChange is the "real" pwnd being repositioned
* and pwndInsertAfter is the place where it's being inserted.
*
* pwndTopInsert is the window handle where the top of the owner tree should be
* inserted. The special value of (HWND)-2 is used to indicate recursion, in
* which case newly added SWPs are added to the previous element.
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

PSMWP AddSelfAndOwnees(
    PSMWP psmwp,
    PWND  pwnd,
    PWND  pwndChange,
    PWND  pwndInsertAfter,
    int   iTop)
{
    PWND pwndChgOwnee;
    PWND pwndT;
    BOOL fChgOwneeInserted;
    CVR  *pcvr;

    /*
     * The general idea here is to first add our ownees, then add ourself.
     * When we add our ownees though, we add them as appropriate based
     * on the pwndInsertAfter parameter.
     *
     * Find out if any of our ownees are on a direct path between pwndChange
     * and the root of the owner tree. If one is, then its Z order relative
     * to its owner-siblings will be changing. If none are, then
     * we want to add our ownees to the list in their current order.
     */
    pwndChgOwnee = pwndChange;
    while (pwndChgOwnee != NULL) {

        pwndT = GetRealOwner(pwndChgOwnee);

        if (pwnd == pwndT)
            break;

        pwndChgOwnee = pwndT;
    }

    /*
     * Now enumerate all other ownees, and insert them in their
     * current order.
     */
    fChgOwneeInserted = FALSE;
    pwndT = NULL;
    while ((pwndT = NextOwnedWindow(pwndT, pwnd, pwnd->spwndParent)) != NULL) {

        /*
         * If these siblings are to be reordered, compare the sibling's
         * current Z order with pwndInsertAfter.
         */
        if (pwndChgOwnee == NULL) {

            /*
             * No Z change for our ownees: just add them in their current order
             */
            psmwp = AddSelfAndOwnees(psmwp, pwndT, NULL, NULL, iTop);

        } else {

            /*
             * If we haven't already inserted the ChgOwnee, and the
             * enumerated owner-sibling is behind pwndInsertAfter, then
             * add ChgOwnee.
             */
            if (!fChgOwneeInserted && IsBehind(pwndT, pwndInsertAfter)) {

                psmwp = AddSelfAndOwnees(psmwp,
                                         pwndChgOwnee,
                                         pwndChange,
                                         pwndInsertAfter,
                                         iTop);

                if (psmwp == NULL)
                    return NULL;

                fChgOwneeInserted = TRUE;
            }

            if (pwndT != pwndChgOwnee) {

                /*
                 * Not the change ownee: add it in its current order.
                 */
                psmwp = AddSelfAndOwnees(psmwp, pwndT, NULL, NULL, iTop);
            }
        }

        if (psmwp == NULL)
            return NULL;
    }

    /*
     * If we never added the change ownee in the loop, add it now.
     */
    if ((pwndChgOwnee != NULL) && !fChgOwneeInserted) {

        psmwp = AddSelfAndOwnees(psmwp,
                                 pwndChgOwnee,
                                 pwndChange,
                                 pwndInsertAfter,
                                 iTop);

        if (psmwp == NULL)
            return NULL;
    }

    /*
     * Finally, add this window to the list.
     */
    psmwp = _DeferWindowPos(psmwp, pwnd, NULL,
            0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    if (psmwp == NULL)
        return NULL;

    /*
     * If we aren't inserting the topmost entry,
     * link this entry to the previous one.
     * The topmost entry will get set by our caller.
     */
    if (iTop != psmwp->ccvr - 1) {
        pcvr = &psmwp->acvr[psmwp->ccvr - 1];
        pcvr->pos.hwndInsertAfter = (pcvr - 1)->pos.hwnd;
    }
    return psmwp;
}

/***************************************************************************\
*
* ZOrderByOwner2 - Add the current window and all it owns to the SWP list,
* and arrange them in the new Z ordering. Called only if the Z order of the
* window is changing.
*
* History:
* 04-Mar-1992 MikeKe    From win31
\***************************************************************************/

PSMWP ZOrderByOwner2(
    PSMWP psmwp,
    int   iTop)
{
    PWND       pwndT;
    PWND       pwndOwnerRoot;
    PWND       pwndTopInsert;
    PWINDOWPOS ppos;
    PWND       pwnd;
    PWND       pwndInsertAfter;
    BOOL       fHasOwnees;

    ppos = &psmwp->acvr[iTop].pos;

    /*
     * If inside message box processing, not Z ordering,
     * or if SWP_NOOWNERZORDER specified, all done.
     */
    // LATER 04-Mar-1992 MikeKe
    // do we have a substitue for fMessageBox
    if ((ppos->flags & SWP_NOZORDER) ||
        (ppos->flags & SWP_NOOWNERZORDER)) {

        return psmwp;
    }

    pwnd = PW(ppos->hwnd);
    pwndInsertAfter = PWInsertAfter(ppos->hwndInsertAfter);

    fHasOwnees = (NextOwnedWindow(NULL, pwnd, pwnd->spwndParent) != NULL);

    /*
     * If the window isn't owned, and it doesn't own any other window,
     * do nothing.
     */
    if (!pwnd->spwndOwner && !fHasOwnees)
        return psmwp;

    /*
     * Find the unowned window to start building the tree from.
     * This is easy: just zip upwards until we find a window with no owner.
     */
    pwndOwnerRoot = pwndT = pwnd;
    while ((pwndT = GetRealOwner(pwndT)) != NULL)
        pwndOwnerRoot = pwndT;

    /*
     * We need to calculate what pwndInsertAfter should be for
     * the first (topmost) window of the SWP list.
     *
     * If pwndInsertAfter is part of the owner tree we'll be building,
     * then we want to reorder windows within the owner group, so the
     * entire group should maintain it's relative order.
     *
     * If pwndInsertAfter is part of another owner tree, then we want
     * the whole group relative to that.
     *
     * If pwndInsertAfter is HWND_BOTTOM, then we want the whole
     * group to go to the bottom, so we position it relative to
     * the bottom most window that is not part of the tree. We also
     * want to put pwnd on the bottom relative to its owner siblings.
     *
     * If pwndInsertAfter is HWND_TOP, then bring the whole group
     * to the top, as well as bringing pwnd to the top relative to its
     * owner siblings.
     *
     * Assume the topmost of group is same as topmost
     * (true for all cases except where rearranging subtree of group)
     */
    pwndTopInsert = pwndInsertAfter;
    if (pwndInsertAfter == (PWND)HWND_TOP) {

        /*
         * Bring the whole group to the top: nothing fancy to do.
         */

    } else if (pwndInsertAfter == (PWND)HWND_BOTTOM) {

        /*
         * Put the whole group on the bottom. pwndTopInsert should
         * be the bottommost window unowned by pwndOwnerRoot.
         */
        for (pwndT = pwnd->spwndParent->spwndChild;
                (pwndT != NULL) && !TestWF(pwndT, WFBOTTOMMOST); pwndT = pwndT->spwndNext) {

            /*
             * If it's not owned, then this is the bottommost so far.
             */
            if (!IsOwnee(pwndT, pwndOwnerRoot))
                pwndTopInsert = pwndT;
        }

        /*
         * If there were no other windows not in our tree,
         * then there is no Z ordering change to be done.
         */
        if (pwndTopInsert == (PWND)HWND_BOTTOM)
            ppos->flags |= SWP_NOZORDER;

    } else {

        /*
         * pwndInsertAfter is a window. Compute pwndTopInsert
         */
        if (IsOwnee(pwndInsertAfter, pwndOwnerRoot)) {

            /*
             * SPECIAL CASE: If we do not own any windows, and we're
             * being moved within our owner group in such a way that
             * we remain above our owner, then no other windows will
             * be moving with us, and we can just exit
             * without building our tree. This can save a LOT of
             * extra work, especially with the MS apps CBT tutorials,
             * which do this kind of thing a lot.
             */
            if (!fHasOwnees) {

                /*
                 * Make sure we will still be above our owner by searching
                 * for our owner starting from pwndInsertAfter. If we
                 * find our owner, then pwndInsertAfter is above it.
                 */
                for (pwndT = pwndInsertAfter; pwndT != NULL;
                        pwndT = pwndT->spwndNext) {

                    if (pwndT == pwnd->spwndOwner)
                        return psmwp;
                }
            }

            /*
             * Part of same group: Find out which window the topmost
             * of the group is currently inserted behind.
             */
            pwndTopInsert = (PWND)HWND_TOP;
            for (pwndT = pwnd->spwndParent->spwndChild; pwndT != NULL;
                    pwndT = pwndT->spwndNext) {

                if (IsOwnee(pwndT, pwndOwnerRoot))
                    break;

                pwndTopInsert = pwndT;
            }
        }
    }

    /*
     * Okay, now go recursively build the owned window list...
     */
    if (!(ppos->flags & SWP_NOZORDER)) {

        /*
         * First "delete" the last entry (the one we're sorting with)
         */
        psmwp->ccvr--;

        psmwp = AddSelfAndOwnees(psmwp,
                                 pwndOwnerRoot,
                                 pwnd,
                                 pwndInsertAfter,
                                 iTop);

        /*
         * Now set the place where the whole group is going.
         */
        if (psmwp != NULL)
            psmwp->acvr[iTop].pos.hwndInsertAfter = HW(pwndTopInsert);
    }

    return psmwp;
}

/***************************************************************************\
* TrackBackground
*
* Adjust zorder if we're crossing a TOPMOST boundary. Make sure that a
* non-topmost window in a background thread doesn't come in front of
* non-topmost windows in the foreground thread.
\***************************************************************************/

BOOL TrackBackground(WINDOWPOS *ppos, PWND pwndPrev, PWND pwnd)
{
    PWND pwndT;

    if (pwndPrev == NULL)
        return FALSE;

    /*
     * Is this window foreground? If so, let it go. For wow apps,
     * check to see if any thread of the process is foreground.
     */
    if (GETPTI(pwnd)->TIF_flags & TIF_16BIT) {

        if (gptiForeground == NULL)
            return FALSE;

        if (GETPTI(pwnd)->ppi == gptiForeground->ppi)
            return FALSE;

    } else {

        if (GETPTI(pwnd) == gptiForeground)
            return FALSE;
    }

    /*
     * Make sure the previous window is either staying or becoming
     * topmost. If not, continue: no top most boundary.
     */
    if (!FSwpTopmost(pwndPrev))
        return FALSE;

    /*
     * Is the current window already top-most? If so then don't
     * calculate a special insert after. If we don't check for
     * this, then pwnd's insert after may be calculated as what
     * pwnd already is, if pwnd is the last top most window. That
     * would cause window links to get corrupted.
     */
    if (TestWF(pwnd, WEFTOPMOST))
        return FALSE;

    /*
     * Doing this assign prevents this routine from being called
     * twice, since HW() is a conditional macro.
     */
    pwndT = CalcForegroundInsertAfter(pwnd);
    ppos->hwndInsertAfter = HW(pwndT);
    return TRUE;
}

/***************************************************************************\
* TrackZorder, TrackZorderHelper
*
* Set up hwndInsertAfter links to point to the previous window in the
* CVR array and partition them in TOPMOST and non-TOPMOST chains.
*
* 05/16/97      vadimg      created
\***************************************************************************/
VOID TrackZorderHelper(
    WINDOWPOS *ppos,
    HWND *phwnd)
{
    /*
     * phwnd (hwndTopmost or hwndRegular) have been initialized to NULL before
     * the beginning of the scan. This way the first hwndInsertAfter that
     * we process remains with the value that was previously calculated.
     */
    if (*phwnd != NULL) {

#if DBG
        if (ppos->hwndInsertAfter != *phwnd) {
            RIPMSG0(RIP_WARNING, "TrackZorder: modified hwndInsertAfter");
        }
#endif

        ppos->hwndInsertAfter = *phwnd;
    }
    *phwnd = ppos->hwnd;
}

PWND TrackZorder(
    WINDOWPOS* ppos,
    PWND pwndPrev,
    HWND *phwndTop,
    HWND *phwndReg)
{
    PWND pwnd = PW(ppos->hwnd);

    if (pwnd == NULL)
        return NULL;

    if (TrackBackground(ppos, pwndPrev, pwnd)) {
        *phwndReg = ppos->hwnd;
    } else if (FSwpTopmost(pwnd)) {
        TrackZorderHelper(ppos, phwndTop);
    } else {
        TrackZorderHelper(ppos, phwndReg);
    }

    return pwnd;
}

/***************************************************************************\
* ZOrderByOwner
*
* This routine Z-Orders windows by their owners.
*
* LATER
* This code currently assumes that all of the window handles are valid
*
* History:
* 04-Mar-1992 MikeKe      from win31
\***************************************************************************/

PSMWP ZOrderByOwner(
    PSMWP psmwp)
{
    int         i;
    PWND        pwnd;
    PWND        pwndT;
    WINDOWPOS   pos;
    PTHREADINFO ptiT;
    HRGN        hrgnClipSave;

    /*
     * Some of the windows in the SMWP list may be NULL at ths point
     * (removed because they'll be handled by their creator's thread)
     * so we've got to look for the first non-NULL window before we can
     * execute some of the tests below. FindValidWindowPos returns NULL if
     * the list has no valid windows in it.
     */
    if (FindValidWindowPos(psmwp) == NULL)
        return psmwp;

    /*
     * For each SWP in the array, move it to the end of the array
     * and generate its entire owner tree in sorted order.
     */
    for (i = psmwp->ccvr; i-- != 0; ) {

        int       iScan;
        int       iTop;
        int       code;
        WINDOWPOS *ppos;
        HWND      hwndTopmost;
        HWND      hwndRegular;

        if (psmwp->acvr[0].pos.hwnd == NULL)
            continue;

        code = CheckTopmost(&psmwp->acvr[0].pos);

        /*
         * Make a local copy for later...
         *
         * Why don't we copy all CVR fields? This seems pretty hard to maintain.
         * Perhaps because most of them haven't been used yet....
         *
         */
        pos  = psmwp->acvr[0].pos;
        ptiT = psmwp->acvr[0].pti;
        hrgnClipSave = psmwp->acvr[0].hrgnClip;

        /*
         * Move the CVR to the end (if it isn't already)
         */
        iTop = psmwp->ccvr - 1;

        if (iTop != 0) {

            RtlCopyMemory(&psmwp->acvr[0],
                          &psmwp->acvr[1],
                          iTop * sizeof(CVR));

            psmwp->acvr[iTop].pos = pos;
            psmwp->acvr[iTop].pti = ptiT;
            psmwp->acvr[iTop].hrgnClip = hrgnClipSave;
        }

        if ((psmwp = ZOrderByOwner2(psmwp, iTop)) == NULL)
            break;

        /*
         * Deal with WEFTOPMOST bits. If we're SETTING the TOPMOST bits,
         * we want to set them for this window and
         * all its owned windows -- the owners stay unchanged. If we're
         * CLEARING, though, we need to enumerate ALL the windows, since
         * they all need to lose the topmost bit when one loses it.
         *
         * Note that since a status change doesn't necessarily mean that
         * the true Z order of the windows have changed, so ZOrderByOwner2
         * may not have enumerated all of the owned and owner windows.
         * So, we enumerate them separately here.
         */
        if (code != CTM_NOCHANGE) {
            PWND pwndRoot = PW(pos.hwnd);
#if DBG
            PWND pwndOriginal = pwndRoot;
#endif

            /*
             * Make sure we're z-ordering this window, or settting topmost
             * is bad.
             */
            UserAssert(!(pos.flags & SWP_NOZORDER));

            /*
             * If we're CLEARING the topmost, then we want to enumerate
             * the owners and ownees, so start our enumeration at the root.
             */
            if (code == CTM_NOTOPMOST) {

                while (pwnd = GetRealOwner(pwndRoot))
                    pwndRoot = pwnd;
            }

#if DBG
            if ((pos.flags & SWP_NOOWNERZORDER)
                && ((pwndOriginal != pwndRoot)
                    || (NextOwnedWindow(NULL, pwndRoot, pwndRoot->spwndParent) != NULL))) {
                /*
                 * We're not doing owner z-order but pwndOriginal has an owner and/or
                 * owns some windows. The problem is, SetTopMost always affects the
                 * whole owner/ownee group. So we might end up with WFTOGGLETOPMOST
                 * windows that won't be z-ordered. It has always been like that.
                 */
                RIPMSG2(RIP_WARNING, "ZOrderByOwner: Topmost change while using SWP_NOOWNERZORDER."
                                     " pwndRoot:%p  pwndOriginal:%p",
                                     pwndRoot, pwndOriginal);
            }
#endif

            SetTopmost(pwndRoot, code == CTM_TOPMOST);
        }

        /*
         * Now scan the list forwards (from the bottom of the
         * owner tree towards the root) looking for the window
         * we were positioning originally (it may have been in
         * the middle of the owner tree somewhere). Update the
         * window pos structure stored there with the original
         * information (though the z-order info is retained from
         * the sort).
         */
        pwnd = NULL;
        hwndTopmost = hwndRegular = NULL;
        for (iScan = iTop; iScan != psmwp->ccvr; iScan++) {

            ppos = &psmwp->acvr[iScan].pos;

            if (ppos->hwnd == pos.hwnd) {
                ppos->x      = pos.x;
                ppos->y      = pos.y;
                ppos->cx     = pos.cx;
                ppos->cy     = pos.cy;
                ppos->flags ^= ((ppos->flags ^ pos.flags) & ~SWP_NOZORDER);
                psmwp->acvr[iScan].hrgnClip = hrgnClipSave;
            }

            pwndT = pwnd;
            pwnd  = TrackZorder(ppos, pwndT, &hwndTopmost, &hwndRegular);
        }
    }

    return psmwp;
}

/***************************************************************************\
* xxxEndDeferWindowPosEx
*
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
BOOL xxxEndDeferWindowPosEx(
    PSMWP psmwp,
    BOOL  fAsync)
{
    PWND        pwndNewActive;
    PWND        pwndParent;
    PWND        pwndActive;
    PWND        pwndActivePrev;
    HWND        hwndNewActive;
    PWINDOWPOS  pwp;
    BOOL        fClearBits;
    BOOL        fSyncPaint;
    UINT        cVisWindowsPrev;
    PTHREADINFO ptiCurrent = PtiCurrent();
    TL          tlpwndNewActive;
    TL          tlpwndParent;
    TL          tlcuSMWP;
    BOOL        fForegroundPrev;

    UserAssert(IsWinEventNotifyDeferredOK());

    DBGCheckSMWP(psmwp);
    if (psmwp->bHandle) {
        CheckLock(psmwp);
    }

    /*
     * Validate the window pos structures and find a window to activate.
     */
    if ((psmwp->ccvr != 0) && ValidateSmwp(psmwp, &fSyncPaint)) {

        if ((pwp = FindValidWindowPos(psmwp)) == NULL)
            goto lbFinished;

        /*
         * Make sure to stop at the mother desktop window. In Win95
         * a SetWindowPos() on a desktop window will have a NULL parent
         * window. This is not true in NT, but our mother desktop
         * window does have a NULL rpdesk, so check it too.
         */
        UserAssert(PW(pwp->hwnd));
        pwndParent = PW(pwp->hwnd)->spwndParent;
        if (pwndParent == NULL || pwndParent->head.rpdesk == NULL)
            goto lbFinished;

        /*
         * Usually all window positioning happens synchronously across threads.
         * This is because apps expect that behavior now - if it was async,
         * callers could not expect the state to be set once the api returned.
         * This is not the semantics of SetWindowPos(). The downside of this
         * synchronicity is that a SetWindowPos() on an hwnd created by another
         * thread will cause the caller to wait for that thread - even if that
         * thread is hung. That's what you get.
         *
         * We don't want task manager to hang though, no matter who else is
         * hung, so when taskman calls, it calls a special entry point for
         * tiling / cascading, which does SetWindowPos() asynchronously -
         * by posting an event in each thread's queue that makes it set its
         * own window position - that way if the thread is hung, who cares -
         * it doesn't effect taskman.
         *
         * Do async window pos positioning before zorder by owner so that
         * we retain any cross thread ownership relationships synchronously.
         */
        if (fAsync) {
            AsyncWindowPos(psmwp);
        }

        /*
         * If needed, Z order the windows by owner.
         * This may grow the SMWP, if new CVRs are added.
         */
        if (pwndParent == PWNDDESKTOP(pwndParent)) {

            if ((psmwp = ZOrderByOwner(psmwp)) == NULL) {
                return FALSE;
            }
        }

        ThreadLockAlwaysWithPti(ptiCurrent, pwndParent, &tlpwndParent);
        ThreadLockPoolCleanup(ptiCurrent, psmwp, &tlcuSMWP, DestroySMWP);

        /*
         * Calc new window positions.
         */
        if (xxxCalcValidRects(psmwp, &hwndNewActive)) {

            int i;

            pwndNewActive = RevalidateHwnd(hwndNewActive);

            ThreadLockWithPti(ptiCurrent, pwndNewActive, &tlpwndNewActive);

            cVisWindowsPrev = ptiCurrent->cVisWindows;
            fForegroundPrev = (ptiCurrent == gptiForeground);

            /*
             * The call to zzzBltValidBits will leave the critical section
             * if there are any notifications to make.
             */
            UserAssert(IsWinEventNotifyDeferredOK());
            if (!zzzBltValidBits(psmwp))
                fSyncPaint = FALSE;
            UserAssert(IsWinEventNotifyDeferredOK());

            if (psmwp->bShellNotify) {
                for (i = psmwp->ccvr; i-- != 0; ) {
                    /*
                     * Loop through the windows, looking for notifications.
                     */

                    if (0 == (psmwp->acvr[i].pos.flags & SWP_NOTIFYALL))
                        continue;

                    if (psmwp->acvr[i].pos.flags & SWP_NOTIFYCREATE) {
                          PostShellHookMessages(HSHELL_WINDOWCREATED,
                                    (LPARAM)psmwp->acvr[i].pos.hwnd);

                          xxxCallHook(HSHELL_WINDOWCREATED,
                            (WPARAM)psmwp->acvr[i].pos.hwnd,
                            (LPARAM)0,
                            WH_SHELL);
                    }

                    if (psmwp->acvr[i].pos.flags & SWP_NOTIFYDESTROY) {
                        PostShellHookMessages(HSHELL_WINDOWDESTROYED,
                                      (LPARAM)psmwp->acvr[i].pos.hwnd);

                        xxxCallHook(HSHELL_WINDOWDESTROYED,
                            (WPARAM)psmwp->acvr[i].pos.hwnd,
                            (LPARAM)0,
                            WH_SHELL);
                    }

                    if (psmwp->acvr[i].pos.flags & SWP_NOTIFYACTIVATE) {
                        PWND pwnd = RevalidateHwnd(psmwp->acvr[i].pos.hwnd);
                        if (pwnd != NULL){
                            TL tlpwnd;
                            ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
                            xxxSetTrayWindow(pwnd->head.rpdesk, pwnd, NULL);
                            ThreadUnlock(&tlpwnd);
                        }
                    }

                    if (psmwp->acvr[i].pos.flags & SWP_NOTIFYFS) {
                        xxxSetTrayWindow(ptiCurrent->rpdesk, STW_SAME, NULL);
                    }
                }
            }


            /*
             * If this process went from some windows to no windows visible
             * and it was in the foreground, then let its next activate
             * come to the foreground.
             */
            if (fForegroundPrev && cVisWindowsPrev && !ptiCurrent->cVisWindows) {

                ptiCurrent->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
                TAGMSG1(DBGTAG_FOREGROUND, "xxxEndDeferWindowPosEx set TIF %#p", ptiCurrent);

                /*
                 * Also if any apps were in the middle of starting when
                 * this happened, allow them to foreground activate again.
                 */
                RestoreForegroundActivate();
            }

            /*
             * Deal with any activation...
             */
            fClearBits = FALSE;
            if (pwndNewActive != NULL) {
                fClearBits = xxxSwpActivate(pwndNewActive);
            }

            /*
             * Now draw frames and erase backgrounds of all the windows
             * involved.
             */
            UserAssert(pwndParent);
            if (fSyncPaint) {
                xxxDoSyncPaint(pwndParent, DSP_ENUMCLIPPEDCHILDREN);
            }

            ThreadUnlock(&tlpwndNewActive);

            /*
             * If SwpActivate() set the NONCPAINT bits, clear them now.
             */
            if (fClearBits) {
                if (pwndActive = ptiCurrent->pq->spwndActive) {
                    ClrWF(pwndActive, WFNONCPAINT);
                }

                if (pwndActivePrev = ptiCurrent->pq->spwndActivePrev) {
                    ClrWF(pwndActivePrev, WFNONCPAINT);
                }
            }

            /*
             * Send WM_WINDOWPOSCHANGED messages
             */
            xxxSendChangedMsgs(psmwp);
        }

        ThreadUnlockPoolCleanup(ptiCurrent, &tlcuSMWP);
        ThreadUnlock(&tlpwndParent);
    }

lbFinished:

    /*
     * All done. Free everything up and return.
     */
    DestroySMWP(psmwp);
    return TRUE;
}


/***************************************************************************\
* IncVisWindows
* DecVisWindows
*
* These routines deal with incrementing/decrementing the visible windows
* on the thread.
*
\***************************************************************************/
#if DBG

BOOL gfVisVerify = FALSE;

VOID VerifycVisWindows(
    PWND pwnd)
{
    BOOL fShowMeTheWindows = FALSE;
    PTHREADINFO pti = GETPTI(pwnd);
    PWND pwndNext;
    UINT uVisWindows = 0;

    if (!gfVisVerify) {
        return;
    }

    /*
     * Make sure the count makes sense
     */
    if ((int)pti->cVisWindows < 0) {
        RIPMSG0(RIP_ERROR, "VerifycVisWindows: pti->cVisWindows underflow!");
        fShowMeTheWindows = TRUE;
    }

    /*
     * This window might be owned by a desktop-less service
     */
    if (pti->rpdesk == NULL || (pti->TIF_flags & TIF_SYSTEMTHREAD)) {
        return;
    }

    /*
     * Child windows don't affect cVisWindows
     */
    if (!FTopLevel(pwnd)) {
        return;
    }

ShowMeTheWindows:
    /*
     * We're going to count all the windows owned by this pti
     * that should be included in cVisWindows.
     */
    pwndNext = pti->rpdesk->pDeskInfo->spwnd;
    /*
     * If this is a top level window, start with the first child.
     * If not, it should be a desktop thread window.
     */
    if (pwndNext == pwnd->spwndParent) {
        pwndNext = pwndNext->spwndChild;
    } else if (pwndNext->spwndParent != pwnd->spwndParent) {
        RIPMSG1(RIP_WARNING, "VerifycVisWindows: Non top level window:%#p", pwnd);
        return;
    }

    if (fShowMeTheWindows) {
        RIPMSG1(RIP_WARNING, "VerifycVisWindows: Start window walk at:%#p", pwndNext);
    }

    /*
     * Count the visble-not-minimized windows owned by this pti.
     */
    while (pwndNext != NULL) {
        if (pti == GETPTI(pwndNext)) {
            if (fShowMeTheWindows) {
                RIPMSG1(RIP_WARNING, "VerifycVisWindows: pwndNext:%#p", pwndNext);
            }
            if (!TestWF(pwndNext, WFMINIMIZED)
                    && TestWF(pwndNext, WFVISIBLE)) {

                uVisWindows++;

                if (fShowMeTheWindows) {
                    RIPMSG1(RIP_WARNING, "VerifycVisWindows: Counted:%#p", pwndNext);
                }
            }
        }
        pwndNext = pwndNext->spwndNext;
    }

    /*
     * It must match.
     */
    if (pti->cVisWindows != uVisWindows) {
        RIPMSG2(RIP_WARNING, "VerifycVisWindows: pti->cVisWindows:%#lx. uVisWindows:%#lx",
                pti->cVisWindows, uVisWindows);

        /*
         * Disable going through the list and make the error into a warning.
         * There are many loopholes as to how the cVisWindow count may get
         * messed up. See bug 109807.
         */
        fShowMeTheWindows = TRUE;

        if (!fShowMeTheWindows) {
            fShowMeTheWindows = TRUE;
            uVisWindows = 0;
            goto ShowMeTheWindows;
        }
    }
}
#endif

/***************************************************************************\
* FVisCountable
*
* Desktops and top-level i.e. whose parent is the desktop) non-minimized
* windows should be counted in the per-thread visible window counts.
\***************************************************************************/
BOOL FVisCountable(
    PWND pwnd)
{
    if (!TestWF(pwnd, WFDESTROYED)) {
        if ((GETFNID(pwnd) == FNID_DESKTOP) ||
                (FTopLevel(pwnd) && !TestWF(pwnd, WFMINIMIZED))) {
            return TRUE;
        }
    }
    return FALSE;
}

/***************************************************************************\
* IncVisWindows
*
\***************************************************************************/
VOID IncVisWindows(
    PWND pwnd)
{
    if (FVisCountable(pwnd)) {
        GETPTI(pwnd)->cVisWindows++;
    }

#if DBG
    if (!ISTS()) {
        VerifycVisWindows(pwnd);
    }
#endif
}

/***************************************************************************\
* cDecVis
*
* An inline that allows debug code to decrement the vis window count
* without doing verification right away. Also alled by DecVisWindows
* to do the actual work.
\***************************************************************************/
__inline VOID cDecVis(
    PWND pwnd)
{
    UserAssert(pwnd != NULL);

    if (FVisCountable(pwnd)) {
        GETPTI(pwnd)->cVisWindows--;
    }
}

/***************************************************************************\
* DecVisWindows
*
\***************************************************************************/
VOID DecVisWindows(
    PWND pwnd)
{
    cDecVis(pwnd);

#if DBG
    if (!ISTS()) {
        VerifycVisWindows(pwnd);
    }
#endif
}

/***************************************************************************\
* SetMiminize
*
* This routine must be used to flip the WS_MIMIMIZE style bit.
* It adjusts the cVisWindows count if appropriate.
*
* 06/06/96  GerardoB Created
\***************************************************************************/
VOID SetMinimize(
    PWND pwnd,
    UINT uFlags)
{
    /*
     * Note that Dec and IncVisWindows check the WFMINIMIZED flag, so the order
     * in which we set/clear the flag and call these functions is important.
     *
     * If the window is not WFVISIBLE, cVisWindows must not change.
     */
    if (uFlags & SMIN_SET) {
        UserAssert(!TestWF(pwnd, WFMINIMIZED));
        if (TestWF(pwnd, WFVISIBLE)) {
            /*
             * Decrement the count because the window is not minimized
             * and visible, and we're about to mark it as minimized.
             */

#if DBG
            cDecVis(pwnd);
#else
            DecVisWindows(pwnd);
#endif
        }
        SetWF(pwnd, WFMINIMIZED);

#if DBG
        VerifycVisWindows(pwnd);
#endif
    } else {
        UserAssert(TestWF(pwnd, WFMINIMIZED));
        ClrWF(pwnd, WFMINIMIZED);
        if (TestWF(pwnd, WFVISIBLE)) {
            /*
             * Increment the count because the window is visible
             * and it's no longer marked as minimized.
             */
            IncVisWindows(pwnd);
        }
    }
}

/***************************************************************************\
* SetVisible
*
* This routine must be used to set or clear the WS_VISIBLE style bit.
* It also handles the setting or clearing of the WF_TRUEVIS bit.
*
* Note that we don't check if the window is already in the (in)visible
* state before setting/clearing the WFVISIBLE bit and calling
* Inc/DecVisWindows. If the window is already in the given state and
* someone calls SetVisible to change into the same state, the VisCount
* will get out of sync. This could happen, for example, if someone
* passed two SWP_SHOWWINDOW for the same hwnd CVR's in the same
* EndDeferWindowPos call. It would be ideal to do the check here, but
* most of the time the caller does the check and we don't want to
* penalize everybody just because of the weird cases.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
VOID SetVisible(
    PWND pwnd,
    UINT flags)
{
#ifdef REDIRECTION
    PDESKTOP pdesk = pwnd->head.rpdesk;
#endif // REDIRECTION

    if (flags & SV_SET) {
#if DBG
        if (TestWF(pwnd, WFINDESTROY)) {
            RIPMSG1(RIP_WARNING, "SetVisible: show INDESTROY %#p", pwnd);
        }
#endif

        if (TestWF(pwnd, WFVISIBLE)) {
            RIPMSG1(RIP_WARNING, "SetVisible: already visible %#p", pwnd);
        } else {
            SetWF(pwnd, WFVISIBLE);
            IncVisWindows(pwnd);

#ifdef REDIRECTION
            if (((pdesk != NULL && (pdesk->dwDTFlags & DF_REDIRECTED) 
                && !(GETPTI(pwnd)->ppi->dwRedirection & PF_REDIRECTIONHOST))
                || (GETPTI(pwnd)->ppi->dwRedirection & PF_REDIRECTED)) 
                &&  FTopLevel(pwnd)) {
                SetRedirectedWindow(pwnd, REDIRECT_EXTREDIRECTED);
                SetWF(pwnd, WEFEXTREDIRECTED);
            }
#endif // REDIRECTION

        }
    } else {
        if (flags & SV_CLRFTRUEVIS) {
            ClrFTrueVis(pwnd);
        }

#if DBG
        if (TestWF(pwnd, WFDESTROYED)) {
            RIPMSG1(RIP_WARNING, "SetVisible: hide DESTROYED %#p", pwnd);
        }
#endif

        if (TestWF(pwnd, WFVISIBLE)) {
            ClrWF(pwnd, WFVISIBLE);
            DecVisWindows(pwnd);

#ifdef REDIRECTION
            if (((pdesk != NULL && (pdesk->dwDTFlags & DF_REDIRECTED) 
                && !(GETPTI(pwnd)->ppi->dwRedirection & PF_REDIRECTIONHOST))
                || (GETPTI(pwnd)->ppi->dwRedirection & PF_REDIRECTED)) 
                &&  FTopLevel(pwnd)) {
                UnsetRedirectedWindow(pwnd, REDIRECT_EXTREDIRECTED);
                ClrWF(pwnd, WEFEXTREDIRECTED);
            }
#endif // REDIRECTION

        } else {
            RIPMSG1(RIP_WARNING, "SetVisible: already hidden %#p", pwnd);
        }
    }
}

/***************************************************************************\
* IsMaxedRect
*
* Determines if a window is "maximizing" to a certain area
*
* History:
\***************************************************************************/
BOOL IsMaxedRect(
    LPRECT      lprcWithin,
    PCSIZERECT  psrcMaybe)
{
    return(psrcMaybe->x <= lprcWithin->left                      &&
           psrcMaybe->y <= lprcWithin->top                       &&
           psrcMaybe->cx >= lprcWithin->right - lprcWithin->left &&
           psrcMaybe->cy >= lprcWithin->bottom - lprcWithin->top);
}

/***************************************************************************\
* xxxCheckFullScreen
*
* Sees if a window is really fullscreen or just a maximized window in
* disguise. If the latter, it will be forced to the proper maximized
* size.
*
* This is called from both CalcValidRects() and CreateWindowEx().
*
* History:
\***************************************************************************/
BOOL xxxCheckFullScreen(
    PWND        pwnd,
    PSIZERECT   psrc)
{
    BOOL            fYielded = FALSE;
    PMONITOR        pMonitor;
    PMONITOR        pMonitorPrimary;
    TL              tlpMonitor;
    RECT            rc;
    BOOL            fIsPrimary;


    CheckLock(pwnd);

    /*
     * SINCE THIS IS ONLY CALLED IN 2 PLACES, make the checks there
     * instead of the overhead of calling this function in time critical
     * places.
     *
     * If 3 or more places call it, put the child/toolwindow checks here
     */
    UserAssert(!TestWF(pwnd, WFCHILD));
    UserAssert(!TestWF(pwnd, WEFTOOLWINDOW));

    pMonitorPrimary = GetPrimaryMonitor();
    if (gpDispInfo->cMonitors == 1) {
        pMonitor = pMonitorPrimary;
    } else {
        /*
         * In multiple monitor mode, windows that take up the entire
         * virtual screen are not considered 'full screen'. 'Full screen'
         * means full single monitor only. This detection is so that any
         * docked bars--tray, office'95 tools--can get out of the way for
         * the application.
         *
         * There are only three types of windows that ought to go full
         * virtual screen. None of them need the tray et al. to get out of
         * the way:
         *      (1) Normal app windows that want a lot of space
         *          * Those guys just activate and deactivate normally.
         *      (2) Desktop windows
         *          * Shell, User desktop sit behind everything else.
         *      (3) Screen savers, demos, etc.
         *          * These guys should be WS_EX_TOPMOST to ensure they sit
         *            over everybody.
         */
        if (IsMaxedRect(&gpDispInfo->rcScreen, psrc))
            return fYielded;

        RECTFromSIZERECT(&rc, psrc);
        pMonitor = _MonitorFromRect(&rc, MONITOR_DEFAULTTOPRIMARY);
    }

    fIsPrimary = (pMonitor == pMonitorPrimary);
    ThreadLockAlways(pMonitor, &tlpMonitor);

    if (IsMaxedRect(&pMonitor->rcWork, psrc)) {
        if (TestWF(pwnd, WFMAXIMIZED)) {
            SetWF(pwnd, WFREALLYMAXIMIZABLE);

            if (gpDispInfo->cMonitors > 1) {
                /*
                 * This is for XL '95 going fullscreen when already maxed. It
                 * always uses the primary display. Let's hack them, and any
                 * other old app that tries to move its truly maximized window.
                 * They will be clipped otherwise by our fake regional stuff.
                 */
                PMONITOR pMonitorReal;

                pMonitorReal = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
                if (pMonitorReal != pMonitor && fIsPrimary) {
                    /*
                     * Transfer over the shape to the REAL monitor.
                     */
                    psrc->x += pMonitorReal->rcMonitor.left;
                    psrc->y  += pMonitorReal->rcMonitor.top;
                    psrc->cx -= (pMonitor->rcMonitor.right - pMonitor->rcMonitor.left) +
                        (pMonitorReal->rcMonitor.right - pMonitorReal->rcMonitor.left);

                    psrc->cy -= (pMonitor->rcMonitor.bottom - pMonitor->rcMonitor.top) +
                        (pMonitorReal->rcMonitor.bottom - pMonitorReal->rcMonitor.top);

                    ThreadUnlock(&tlpMonitor);
                    pMonitor = pMonitorReal;
                    fIsPrimary = FALSE;
                    ThreadLockAlways(pMonitor, &tlpMonitor);
                }
            }
        }

        if (    TestWF(pwnd, WFMAXIMIZED) &&
                TestWF(pwnd, WFMAXBOX)    &&
                (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION))) {

            if (    psrc->y + SYSMET(CYCAPTION) <= pMonitor->rcMonitor.top &&
                    psrc->y + psrc->cy >= pMonitor->rcMonitor.bottom) {

                if (!TestWF(pwnd, WFFULLSCREEN)) {
                    /*
                     * Only want to do full screen stuff on the tray
                     * monitor.
                     */
                    fYielded = xxxAddFullScreen(pwnd, pMonitor);
                }
            } else {
                int iRight;
                int iBottom;
                int dxy;

                if (TestWF(pwnd, WFFULLSCREEN)) {
                    fYielded = xxxRemoveFullScreen(pwnd, pMonitor);
                }

                /*
                 * Despite the code in GetMinMaxInfo() to fix up
                 * the max rect, we still have to hack old apps.
                 * Word '95 & XL '95 do weird things when going to/from
                 * full screen when maximized already.
                 *
                 * NOTE:  you can have more than one docked bar on a
                 * monitor. Win '95 code doesn't work right in that
                 * case.
                 */
                dxy = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
                dxy *= SYSMET(CXBORDER);

                psrc->x = pMonitor->rcWork.left - dxy;
                psrc->y = pMonitor->rcWork.top - dxy;

                dxy *= 2;
                iRight = pMonitor->rcWork.right - pMonitor->rcWork.left + dxy;
                iBottom = pMonitor->rcWork.bottom - pMonitor->rcWork.top + dxy;

                /*
                 * Let console windows maximze smaller than defaults.
                 */
                if (pwnd->pcls->atomClassName == gatomConsoleClass) {
                    psrc->cx = min(iRight, psrc->cx);
                    psrc->cy = min(iBottom, psrc->cy);
                } else {
                    psrc->cx = iRight;

                    /*
                     * B#14012 save QuickLink II that wants 4 pixels hanging off
                     * the screen for every edge except the bottom edge, which
                     * they only want to overhang by 2 pixels -- jeffbog 5/17/95
                     *
                     * BUT THIS CODE DOESN'T WORK FOR MULTIPLE MONITORS, so don't
                     * do it on secondary dudes. Else, XL '95 flakes out.
                     */
                    if (fIsPrimary && !TestWF(pwnd, WFWIN40COMPAT)) {
                        psrc->cy = min(iBottom, psrc->cy);
                    } else {
                        psrc->cy = iBottom;
                    }
                }
            }
        } else if (IsMaxedRect(&pMonitor->rcMonitor, psrc)) {
            fYielded = xxxAddFullScreen(pwnd, pMonitor);
        }
    } else {
        if (TestWF(pwnd, WFMAXIMIZED)) {
            ClrWF(pwnd, WFREALLYMAXIMIZABLE);
        }

        fYielded = xxxRemoveFullScreen(pwnd, pMonitor);
    }

    ThreadUnlock(&tlpMonitor);
    return fYielded;
}

/***************************************************************************\
* ClrFTrueVis
*
* Called when making a window invisible. This routine destroys any update
* regions that may exist, and clears the WF_TRUEVIS of all windows below
* the passed in window.
*
* History:
* 11-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
VOID ClrFTrueVis(
    PWND pwnd)
{
    /*
     * Destroy pwnd and its children's update regions.
     * We do this here to guarantee that a hidden window
     * and its children don't have update regions.
     *
     * This fixes bugs when destroying windows that have
     * update regions (SendDestroyMessages) among others
     * and allows us to simplify SetParent(). This was
     * deemed better than hacking DoPaint() and/or
     * DestroyWindow().
     *
     * We can stop recursing when we find a window that doesn't
     * have the visible bit set, because by definition it won't
     * have any update regions below it (this routine will have been called)
     */
    if (NEEDSPAINT(pwnd)) {

        DeleteMaybeSpecialRgn(pwnd->hrgnUpdate);

        ClrWF(pwnd, WFINTERNALPAINT);

        pwnd->hrgnUpdate = NULL;
        DecPaintCount(pwnd);
    }

    for (pwnd = pwnd->spwndChild; pwnd != NULL; pwnd = pwnd->spwndNext) {

        /*
         * pwnd->fs &= ~WF_TRUEVIS;
         */
        if (TestWF(pwnd, WFVISIBLE))
            ClrFTrueVis(pwnd);
    }
}

/***************************************************************************\
* OffsetChildren
*
* Offsets the window and client rects of all children of hwnd.
* Also deals with the children's update regions and SPB rects.
*
* History:
* 22-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/
VOID OffsetChildren(
    PWND   pwnd,
    int    dx,
    int    dy,
    LPRECT prcHitTest)
{
    RECT    rc;
    PWND    pwndStop;

    if (!pwnd->spwndChild)
        return;

    pwndStop = pwnd;
    pwnd = pwndStop->spwndChild;
    for (;;) {
        /*
         * Skip windows that don't intersect prcHitTest...
         */
        if (prcHitTest && !IntersectRect(&rc, prcHitTest, &pwnd->rcWindow))
            goto NextWindow;

        pwnd->rcWindow.left   += dx;
        pwnd->rcWindow.right  += dx;
        pwnd->rcWindow.top    += dy;
        pwnd->rcWindow.bottom += dy;

        pwnd->rcClient.left   += dx;
        pwnd->rcClient.right  += dx;
        pwnd->rcClient.top    += dy;
        pwnd->rcClient.bottom += dy;

        if (pwnd->hrgnUpdate > HRGN_FULL && !TestWF(pwnd, WFMAXFAKEREGIONAL)) {
            GreOffsetRgn(pwnd->hrgnUpdate, dx, dy);
        }

        /*
         * Change position of window region, if it has one
         */
        if (pwnd->hrgnClip != NULL)
            GreOffsetRgn(pwnd->hrgnClip, dx, dy);

        if (TestWF(pwnd, WFHASSPB))
            OffsetRect(&(FindSpb(pwnd))->rc, dx, dy);

#ifdef CHILD_LAYERING
        if (TestWF(pwnd, WEFLAYERED)) {
            POINT ptPos = {pwnd->rcWindow.left, pwnd->rcWindow.top};

            GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL,
                    &ptPos, NULL, NULL, NULL, 0, NULL, 0, NULL);
        }
#endif // CHILD_LAYERING

        /*
         * Recurse into the child tree if there are children.
         */
        if (pwnd->spwndChild) {
            pwnd = pwnd->spwndChild;
            continue;
        }

NextWindow:
        if (pwnd->spwndNext) {
            /*
             * Recurse to the next sibling in the list.
             */
            pwnd = pwnd->spwndNext;
        } else {
            for (;;) {
                /*
                 * We're at the end of the sibling window list.
                 * Go to the parent's next window.
                 */
                pwnd = pwnd->spwndParent;
                if (pwnd == pwndStop)
                    return;

                if (pwnd->spwndNext) {
                    pwnd = pwnd->spwndNext;
                    break;
                }
            }
        }
    }
}

/***************************************************************************\
* SetWindowRgn
*
* Parameters:
*     hwnd    --  Window handle
*     hrgn    --  Region to set into window. NULL can be accepted.
*     fRedraw --  TRUE to go through SetWindowPos() and calculate
*                 update regions correctly. If the window is visible
*                 this will usually be TRUE.
*
* Returns:
*     TRUE for success, FALSE for failure
*
* Comments:
*     This is a very simple routine to set a window region. It goes through
*     SetWindowPos() to get perfect update region calculation, and to deal
*     with other related issues like vis rgn change & dc invalidation,
*     display lock holding, spb invalidation, etc. Also since it sends
*     WM_WINDOWPOSCHANGING & WM_WINDOWPOSCHANGED, we'll be able to expand
*     SetWindowPos() in the future to take hrgns directly for efficient
*     window state change control (like setting the rect and region at
*     the same time, among others) without harming compatibility.
*
*     hrgn is in window rect coordinates (not client rect coordinates).
*     Once set, hrgn is owned by the system. A copy is not made!
*
* 30-Jul-1994 ScottLu   Created.
\***************************************************************************/

#define SWR_FLAGS_REDRAW   (SWP_NOCHANGE | SWP_FRAMECHANGED | SWP_NOACTIVATE)
#define SWR_FLAGS_NOREDRAW (SWP_NOCHANGE | SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOREDRAW)

BOOL xxxSetWindowRgn(
    PWND pwnd,
    HRGN hrgn,
    BOOL fRedraw)
{
    PSMWP psmwp;
    HRGN  hrgnClip = NULL;
    BOOL  bRet = FALSE;

    /*
     * Validate the region handle. We did this for 3.51, so
     * we better do it for later versions. Our validation will
     * make a copy of the clip-rgn and send it through to the
     * SetWIndowRgn code. Once this is set in the kernel, we
     * will return to the client and the old region will be deleted
     * there.
     *
     * If the region passed in is NULL, then we get rid of the
     * current retion. Map it to HRGN_FULL so that SetWindowPos()
     * can tell this is what the caller wants.
     */
    if (hrgn) {

        if ((hrgnClip = UserValidateCopyRgn(hrgn)) == NULL) {

#if DBG
            RIPMSG0(RIP_WARNING, "xxxSetWindowRgn: Failed to create region!");
#endif
            goto swrClean;
        }
        MirrorRegion(pwnd, hrgnClip, FALSE);
    } else {

        hrgnClip = HRGN_FULL;
    }

    /*
     * Get a psmwp, and put the region in it, correctly offset.
     * Use SWP_FRAMECHANGED with acts really as a "empty" SetWindowPos
     * that still sends WM_WINDOWPOSCHANGING and CHANGED messages.
     * SWP_NOCHANGE ensures that we don't size, move, activate, zorder.
     */
    if (psmwp = InternalBeginDeferWindowPos(1)) {

        /*
         * psmwp gets freed automatically if this routine fails.
         */
        if (psmwp = _DeferWindowPos(
                psmwp,
                pwnd,
                PWND_TOP,
                0,
                0,
                0,
                0,
                fRedraw ? SWR_FLAGS_REDRAW : SWR_FLAGS_NOREDRAW)) {

            /*
             * Do the operation. Note that hrgn is still in window coordinates.
             * SetWindowPos() will change it to screen coordinates before
             * selecting into the window.
             */
            psmwp->acvr[0].hrgnClip = hrgnClip;
            bRet = xxxEndDeferWindowPosEx(psmwp, FALSE);
        }
    }

    /*
     * If the call failed, then delete our region we created. A FALSE
     * return means it should've never made it to the xxxSelectWindowRgn
     * call, so everything should be as it was.
     */
    if (!bRet && (hrgnClip != HRGN_FULL)) {

swrClean:

        GreDeleteObject(hrgnClip);
    }

    return bRet;
}

/***************************************************************************\
* SelectWindowRgn
*
* This routine does the work of actually selecting in the window region.
*
* 30-Jul-1994 ScottLu   Created.
\***************************************************************************/
VOID SelectWindowRgn(
    PWND pwnd,
    HRGN hrgnClip)
{
    /*
     * If there is a region already there, delete it becausea new one is
     * being set. For maximized windows in multiple monitor mode, we
     * always use the monitor HRGN. We don't make a copy. This way, when 
     * the hrgn changes because of monitor config, the window's monitor
     * region automatically gets updated. Clever huh?  Also saves memory.
     */
    if (pwnd->hrgnClip != NULL) {
        if (TestWF(pwnd, WFMAXFAKEREGIONAL)) {
            ClrWF(pwnd, WFMAXFAKEREGIONAL);
        } else {
            /*
             * Do NOT select in a monitor region if the window is normally
             * regional. The MinMaximize code will always pass HRGN_MONITOR
             * to us no matter what. But when we get here, bail out and
             * don't destroy the app's region if it has one.
             */
            if (hrgnClip == HRGN_MONITOR)
                return;

            GreDeleteObject(pwnd->hrgnClip);
        }

        pwnd->hrgnClip = NULL;
    }

    /*
     * NULL or HRGN_FULL means "set to NULL". If we have a real region,
     * use it. USER needs to own it, and it needs to be in screen
     * coordinates.
     */
    if (hrgnClip > HRGN_FULL) {

        if (hrgnClip == HRGN_MONITOR) {
            PMONITOR pMonitor;

            /*
             * Use the monitor region if the window is really maxed
             * on a monitor. It's already happened by the time we get here,
             * if so. And xxxCheckFullScreen will clear the reallymaximed
             * style for a maximized window if it doesn't cover the whole
             * max area.
             */
            UserAssert(pwnd->spwndParent == PWNDDESKTOP(pwnd));

            if (!TestWF(pwnd, WFMAXIMIZED) || !TestWF(pwnd, WFREALLYMAXIMIZABLE))
                return;

            /*
             * Do nothing for windows off screen.
             */
            pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTONULL);
            if (!pMonitor)
                return;

            hrgnClip = pMonitor->hrgnMonitor;
            SetWF(pwnd, WFMAXFAKEREGIONAL);
        } else {
            if (pwnd != PWNDDESKTOP(pwnd)) {
                GreOffsetRgn(hrgnClip, pwnd->rcWindow.left, pwnd->rcWindow.top);
            }

            GreSetRegionOwner(hrgnClip, OBJECT_OWNER_PUBLIC);
        }

        pwnd->hrgnClip = hrgnClip;
    }
}


/***************************************************************************\
* TestRectBogus
*
* Returns TRUE if the window rect [x,y,cx,cy] is centered or
* clipped to the monitor or work rect [prc], FALSE otherwise.
*
* History:
* 26-Mar-1997 adams     Created.
\***************************************************************************/

#define SLOP_X 8
#define SLOP_Y 8

BOOL
TestRectBogus(RECT * prc, int x, int y, int cx, int cy)
{
    //
    //  check for a fullscreen (or offscreen) window
    //
    if (    x  <= prc->left &&
            y  <= prc->top &&
            cx >= (prc->right  - prc->left) &&
            cy >= (prc->bottom - prc->top)) {

        // rect is fullscreen
        return FALSE;
    }

    //
    //  check for the window being centered to the work area
    //  use <= for y to catch dialogs centered "high"
    //  (like the network logon dialog)
    //
    if (    abs(x - (prc->right + prc->left - cx) / 2) <= SLOP_X &&
            abs(y - (prc->bottom + prc->top - cy) / 2) <= SLOP_Y ) {

        // rect centered
        return TRUE;
    }

    //
    //  check for the window being cliped to the work area
    //
    if (    x == prc->left ||
            y == prc->top ||
            x == (prc->right - cx) ||
            y == (prc->bottom - cy)) {

        // rect is clipped
        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* IsRectBogus
*
* Returns TRUE if the window rect [x,y,cx,cy] is centered or
* clipped to the monitor or work rect of the primary monitor.
*
* History:
* 26-Mar-1997 adams     Created.
\***************************************************************************/
BOOL
IsRectBogus(
    int x,
    int y,
    int cx,
    int cy)
{
    PMONITOR pMonitorPrimary = GetPrimaryMonitor();

    return TestRectBogus(&pMonitorPrimary->rcWork, x, y, cx, cy) ||
           TestRectBogus(&pMonitorPrimary->rcMonitor, x, y, cx, cy);
}



/***************************************************************************\
* FixBogusSWP
*
* Detects if a rect is being centered or clipped to the primary monitor,
* and centers it in its owner's window if so. This prevents apps that
* are not multimon aware from having their "main" window displayed on
* one monitor but their dialogs moved to the primary monitor
* because they believe the dialog is offscreen.
*
* History:
* 26-Mar-1997 adams     Created.
\***************************************************************************/
VOID
FixBogusSWP(
    PWND pwnd,
    int * px,
    int * py,
    int cx,
    int cy,
    UINT flags)
{
    PMONITOR pMonitor;

    pMonitor = _MonitorFromWindow(pwnd->spwndOwner, MONITOR_DEFAULTTONEAREST);

    //
    // only check for a bogus SWP if the owner is not on the primary
    //
    if (pMonitor != GetPrimaryMonitor()) {
        //
        // get the current size if SWP_NOSIZE is set
        //
        if (flags & SWP_NOSIZE) {
            cx = pwnd->rcWindow.right  - pwnd->rcWindow.left;
            cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;
        }

        //
        // see if the app is trying to center or clip the window
        //
        if (IsRectBogus(*px, *py, cx, cy))
        {
            RECT rc;

#if DBG
            int oldX = *px;
            int oldY = *py;
#endif

            //
            // the app wants to center/clip the window
            // we will have to do it for them.
            //
            // get the window rect of the parent and
            // intersect that with the work area of
            // the owning monitor, then center the
            // window to this rect.
            //
            IntersectRect(&rc, &pMonitor->rcWork, &pwnd->spwndOwner->rcWindow);

            //
            // new multimonior friendly position.
            //
            *px = rc.left + (rc.right  - rc.left - cx) / 2;
            *py = rc.top  + (rc.bottom - rc.top  - cy) / 2;

            //
            // now clip to the work area.
            //
            if (*px + cx > pMonitor->rcWork.right) {
                *px = pMonitor->rcWork.right - cx;
            }

            if (*py + cy > pMonitor->rcWork.bottom) {
                *py = pMonitor->rcWork.bottom - cy;
            }

            if (*px < pMonitor->rcWork.left) {
                *px = pMonitor->rcWork.left;
            }

            if (*py < pMonitor->rcWork.top) {
                *py = pMonitor->rcWork.top;
            }

            RIPMSG0(RIP_WARNING | RIP_THERESMORE,              "SetWindowPos detected that your app is centering or clipping");
            RIPMSG0(RIP_WARNING | RIP_THERESMORE | RIP_NONAME, "a window to the primary monitor when its owner is on a different monitor.");
            RIPMSG0(RIP_WARNING | RIP_THERESMORE | RIP_NONAME, "Consider fixing your app to use the Window Manager Multimonitor APIs.");
            RIPMSG4(RIP_WARNING | RIP_NONAME,                  "SetWindowPos moved the window from (%d,%d) to (%d,%d).\n",
                                                               oldX, oldY, *px, *py);
        }
    }
}

/***************************************************************************\
* PreventInterMonitorBlts()
*
* Prevents monitor-to-monitor blts when they are different caps. This
* way we redraw the part of a window that moves to a different monitor.
* We try to blt as much as possible.
*
* We look at the source rect and what monitor owns it, and how much that
* monitor also contains of the destination rect. Then we compare that
* with the destination rect and what monitor owns that, and how much it
* contains of the source rect. The larger wins.
*
* rcBlt is in screen coordinates and is the DESTINATION.
*
* History:
* 11-11-1997    vadimg      ported from Memphis
\***************************************************************************/
VOID PreventInterMonitorBlts(
    PCVR pcvr)
{
    RECT        rcSrc;
    RECT        rcDst;
    RECT        rcSrcT;
    RECT        rcDstT;
    PMONITOR    pMonitor;

    /*
     * If the destination is empty do nothing.
     */
    if (IsRectEmpty(&pcvr->rcBlt)) {
        return;
    }

    /*
     * Get the source rect (rcBlt is the destination, dxBlt/dyBlt are the
     * distance moved from the source).
     */
    CopyOffsetRect(&rcSrc, &pcvr->rcBlt, -pcvr->dxBlt, -pcvr->dyBlt);

    /*
     * Split up the source into its monitor pieces. If the source intersects
     * a monitor, then figure out where that part will be in the destination.
     * Intersect the destination part with the same monitor. The result is
     * the amount we can blt from the source to the dest on that monitor.
     *
     * We do this for each monitor to find the biggest blt rect. We want
     * the biggest because we want to repaint as little as possible. We do
     * bail out if both the source and dest are fully contained on the same
     * monitor.
     */
    for (pMonitor = gpDispInfo->pMonitorFirst;
            pMonitor != NULL;
            pMonitor = pMonitor->pMonitorNext) {

        /*
         * We're only interested in visible monitors.
         */
        if (!(pMonitor->dwMONFlags & MONF_VISIBLE))
            continue;
        /*
         * If this monitor doesn't contain a piece of the source, we don't
         * care about it. We won't be doing a same monitor blt on it for sure.
         */
        if (!IntersectRect(&rcSrcT, &rcSrc, &pMonitor->rcMonitor))
            continue;

        /*
         * See where this rect would be in the destination.
         */
        CopyOffsetRect(&rcDst, &rcSrcT, pcvr->dxBlt, pcvr->dyBlt);

        /*
         * Intersect this rect with the same monitor rect to see what piece
         * can be safely blted on the same monitor.
         */
        IntersectRect(&rcDstT, &rcDst, &pMonitor->rcMonitor);

        /*
         * Is this piece of the source staying on this monitor?
         */
        if (EqualRect(&rcDstT, &rcDst)) {
            /*
             * This source piece is staying completely on this monitor when
             * it becomes the destination. Hence there is nothing to add
             * to our invalid sum, hrgnInterMonitor.
             */
            if (EqualRect(&rcSrcT, &rcSrc)) {
                /*
                 * The source is completely ON one monitor and moving to
                 * a location also completely ON this monitor. Great, no
                 * intermonitor blts whatsoever. We are done.
                 */
                UserAssert(pcvr->hrgnInterMonitor == NULL);
                return;
            } else {
                continue;
            }
        }

        /*
         * OK, some piece of the source is moving across monitors. Figure
         * out what it is and where that piece is in the destination. That
         * piece in the destination must be invalidated and not blted.
         */
        if (pcvr->hrgnInterMonitor == NULL) {
            pcvr->hrgnInterMonitor = CreateEmptyRgn();
        }

        /*
         * The difference between the transposed source to the dest, and the
         * real part of the dest that lies on this monitor, is the amount
         * of the source that will move across a monitor boundary. Add this
         * to our accumulated invalid region.
         * 
         * rcDst is the whole source chunk, rcDstT is the part on the same
         * monitor as the source chunk.
         */
        GreSetRectRgn(ghrgnInv2, rcDst.left, rcDst.top, rcDst.right, rcDst.bottom);
        GreSetRectRgn(ghrgnGDC, rcDstT.left, rcDstT.top, rcDstT.right, rcDstT.bottom);
        SubtractRgn(ghrgnInv2, ghrgnInv2, ghrgnGDC);
        UnionRgn(pcvr->hrgnInterMonitor, pcvr->hrgnInterMonitor, ghrgnInv2);
    }

#if DBG
    VerifyVisibleMonitorCount();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\syscmd.c ===
/**************************** Module Header ********************************\
* Module Name: syscmd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* System Command Routines
*
* History:
* 01-25-91 IanJa   Added handle revalidation
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* xxxHandleNCMouseGuys
*
* History:
* 11-09-90 DavidPe      Ported.
\***************************************************************************/

void xxxHandleNCMouseGuys(
    PWND pwnd,
    UINT message,
    int htArea,
    LPARAM lParam)
{
    UINT syscmd;
    PWND pwndT;
    TL tlpwndT;

    CheckLock(pwnd);

    syscmd = 0xFFFF;

    switch (htArea) {

    case HTCAPTION:
        switch (message) {

        case WM_NCLBUTTONDBLCLK:
            if (TestWF(pwnd, WFMINIMIZED) || TestWF(pwnd, WFMAXIMIZED)) {
                syscmd = SC_RESTORE;
            } else if (TestWF(pwnd, WFMAXBOX)) {
                syscmd = SC_MAXIMIZE;
            }
            break;

        case WM_NCLBUTTONDOWN:
            pwndT = GetTopLevelWindow(pwnd);
            ThreadLock(pwndT, &tlpwndT);
            xxxActivateWindow(pwndT, AW_USE2);
            ThreadUnlock(&tlpwndT);
            syscmd = SC_MOVE;
            break;
        }
        break;

    case HTSYSMENU:
    case HTMENU:
    case HTHSCROLL:
    case HTVSCROLL:
        if (message == WM_NCLBUTTONDOWN || message == WM_NCLBUTTONDBLCLK) {
            switch (htArea) {
            case HTSYSMENU:
                if (message == WM_NCLBUTTONDBLCLK) {
                    syscmd = SC_CLOSE;
                    break;
                }

            /*
             *** FALL THRU **
             */

            case HTMENU:
                syscmd = SC_MOUSEMENU;
                break;

            case HTHSCROLL:
                syscmd = SC_HSCROLL;
                break;

            case HTVSCROLL:
                syscmd = SC_VSCROLL;
                break;
            }
        }
        break;
    }

    switch (syscmd) {

    case SC_MINIMIZE:
    case SC_MAXIMIZE:
    case SC_CLOSE:

        /*
         * Only do double click commands on an upclick.
         * This code is very sensitive to changes from this state.
         * Eat any mouse messages.
         */

        /*
         * Bug #152: WM_NCLBUTTONUP message missing from double click.
         * This code was broken in Windows 3.x and the test for whether
         * the mouse button was down always failed, so no mouse messages
         * were ever eaten. We'll emulate this by not even doing the test.
         *
         *
         * {
         *     PQ pqCurrent;
         *     MSG msg;
         *
         *     pqCurrent = PtiCurrent()->pq;
         *     if (TestKeyStateDown(pqCurrent, VK_LBUTTON)) {
         *         xxxCapture(PtiCurrent(), pwnd, WINDOW_CAPTURE);
         *
         *         while (TestKeyStateDown(pqCurrent, VK_LBUTTON)) {
         *             if (!xxxPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
         *                     PM_REMOVE)) {
         *                 if (!xxxSleepThread(QS_MOUSE, 0, TRUE))
         *                     break;
         *             }
         *         }
         *
         *         xxxReleaseCapture();
         *
         *     }
         * }
         *
         */

        /*
         ** FALL THRU **
         */
    case SC_SIZE:
    case SC_MOVE:
        /*
         * For SysCommands on system menu, don't do if menu item is
         * disabled.
         */
        if (TestWF(pwnd, WFSYSMENU)) {
            xxxSetSysMenu(pwnd);
            if (_GetMenuState(xxxGetSysMenuHandle(pwnd), (syscmd & 0xFFF0),
                    MF_BYCOMMAND) & MFS_GRAYED) {
                return;
            }
        }
        break;
    }

    if (syscmd != 0xFFFF) {
        xxxSendMessage(pwnd, WM_SYSCOMMAND, syscmd | htArea, lParam);
    }
}

/***************************************************************************\
* StartScreenSaver
*
* History:
* 11-12-90 MikeHar  ported.
\***************************************************************************/

void StartScreenSaver(
    BOOL bOnlyIfSecure)
{
    /*
     * If a screen saver is already running or we're in the midst of powering
     * down the machine, ignore this request.
     */
    if (gppiScreenSaver != NULL || gPowerState.fInProgress)
        return;

    if (gspwndLogonNotify != NULL) {

        if( glinp.dwFlags & LINP_POWEROFF ) {

            /*
             * If the monitor is turned off.  Tell winlogon to handle the
             * screen saver in a special manner. Use the constant 2 to signal
             * this request.
             */
            _PostMessage(gspwndLogonNotify,
                    WM_LOGONNOTIFY, LOGON_INPUT_TIMEOUT, 2);
        } else {


            /*
             * Let the logon process take care of the screen saver
             */
            _PostMessage(gspwndLogonNotify,
                    WM_LOGONNOTIFY, LOGON_INPUT_TIMEOUT, bOnlyIfSecure);
        }
    }
}


/***************************************************************************\
* xxxSysCommand
*
* History:
* 11-12-90 MikeHar  ported.
* 02-07-91 DavidPe  Added Win 3.1 WH_CBT support.
\***************************************************************************/

void xxxSysCommand(
    PWND  pwnd,
    DWORD cmd,
    LPARAM lParam)
{
    UINT        htArea;
    PWND        pwndSwitch;
    PMENUSTATE  pMenuState;
    TL          tlpwnd;
    POINT       pt;
    DWORD       dw;
    PWND        pwndCapture;
    PTHREADINFO pti;

    CheckLock(pwnd);

    htArea = (UINT)(cmd & 0x0F);
    cmd -= htArea;

    /*
     * Intense hack o' death.
     */
    if (lParam == 0x00010000L)
        lParam = 0L;

    /*
     * If the system doesn't have capture (ie CLENT_CAPTURE_INTERNAL)
     * do the sys command.  Also, do the sys command for the special case
     * where the window receiving the sys command is a console window that
     * is in full screen mode.  In this case we let the sys command through.
     *
     * Also if this a SC_SCREENSAVE then we handle it anyway and
     * switching desktops will do the cancel.  SC_SCREENSAVER
     * is special so we can start the screen saver even if we are in
     * menu mode for security so NT bug 10975 Banker's Trust
     */
    pti = GETPTI(pwnd);

    /*
     * For 32bit apps (and apps on seperate queues), we need to check
     * the capture in the queue.  Otherwise, on MDI child-destruction
     * we would get the restore when they shouldn't.  This broke MSGOLF
     * who during the restore, AV'd because they assumed this wouldn't
     * happen. On 16bit shared apps, we want to check the internal
     * capture.  Otherwise, when doing 16bit drag-and-drop, we would
     * not restore the minimized window if we had a queue-capture-window.
     */

    /*
     * But... it is too broad a change to just check internal capture for all WoW apps. Some
     * apps depend on bailing out when they have capture set. (Adobe Persuasion, NT bug 68794,
     * for SC_MOVE).  So, let's restrict the hack to SC_RESTORE to keep Ole drag-and-drop working.
     * See NT bug 6109. FritzS
     */

    pwndCapture = ((pti->TIF_flags & TIF_16BIT) && (cmd == SC_RESTORE)) ? gspwndInternalCapture :
                                                 pti->pq->spwndCapture;

    if ((!pwndCapture && !TestWF(pwnd, WFDISABLED)) ||
        (pwnd == gspwndFullScreen)                  ||
        (cmd == SC_SCREENSAVE)                      ||
        (cmd == SC_MONITORPOWER)                    ||
        (cmd == SC_TASKLIST)) {

        /*
         * Perform the sys command
         */

#ifdef SYSMODALWINDOWS
        if (gspwndSysModal != NULL) {
            switch (cmd) {
            case SC_SIZE:
            case SC_MOVE:
            case SC_MINIMIZE:
            case SC_MAXIMIZE:
            case SC_NEXTWINDOW:
            case SC_PREVWINDOW:
            case SC_SCREENSAVE:
                return;
            }
        }
#endif

        /*
         * Call the CBT hook asking if it's okay to do this command.
         * If not, return from here.
         */
        if (IsHooked(PtiCurrent(), WHF_CBT) && xxxCallHook(HCBT_SYSCOMMAND,
                (DWORD)cmd, (DWORD)lParam, WH_CBT)) {
            return;
        }

        switch (cmd) {
        case SC_RESTORE:
            cmd = SW_RESTORE;
            if (TestWF(pwnd, WFMINIMIZED) || !TestWF(pwnd, WFMAXIMIZED))
                PlayEventSound(USER_SOUND_RESTOREUP);
            else
                PlayEventSound(USER_SOUND_RESTOREDOWN);
            goto MinMax;


        case SC_MINIMIZE:
            cmd = SW_MINIMIZE;

            /*
             * Are we already minimized?
             */
            if (TestWF(pwnd, WFMINIMIZED))
                break;

            PlayEventSound(USER_SOUND_MINIMIZE);

            goto MinMax;
        case SC_MAXIMIZE:
            cmd = SW_SHOWMAXIMIZED;

            /*
             * Are we already maximized?
             */
            if (TestWF(pwnd, WFMAXIMIZED))
                break;

            PlayEventSound(USER_SOUND_MAXIMIZE);
MinMax:
            xxxShowWindow(pwnd, cmd | TEST_PUDF(PUDF_ANIMATE));
            return;

        case SC_SIZE:
            {
                xxxMoveSize(pwnd, htArea, _GetMessagePos());
            }
            return;

        case SC_MOVE:
            //
            // Don't enter movesize loop unless the user is actually
            // dragging from the caption.  Otherwise, put up the system
            // menu on a minimized window.
            //

            //
            // Are we dragging with the left mouse button?
            //
            dw = _GetMessagePos();
            POINTSTOPOINT( pt, MAKEPOINTS(dw));
            if ( !htArea ||
                 xxxIsDragging(pwnd, pt, WM_LBUTTONUP)) {

                /*
                 * We are moving.  Enter move/size loop.
                 */
                {
                    xxxMoveSize(pwnd, (htArea == 0) ? WMSZ_KEYMOVE : WMSZ_MOVE, dw);
                }
            } else {

                /*
                 * Activate our window, just like we would have in
                 * MoveSize().
                 */
                xxxSetWindowPos(pwnd, PWND_TOP, 0, 0, 0, 0,
                                SWP_NOMOVE | SWP_NOSIZE);
                if (TestWF(pwnd, WFMINIMIZED)) {

                    /*
                     * Try to popup the system menu
                     */
                    xxxSendMessage(pwnd, WM_SYSCOMMAND, SC_KEYMENU,
                            (DWORD) (TestWF(pwnd, WFCHILD) ? '-' : MENUSYSMENU));
                }
            }
            return;

        case SC_CLOSE:
            xxxSendMessage(pwnd, WM_CLOSE, 0L, 0L);
            return;

        case SC_NEXTWINDOW:
        case SC_PREVWINDOW:
            xxxOldNextWindow((UINT)lParam);
            break;

        case SC_CONTEXTHELP:
            xxxHelpLoop(pwnd);
            break;

        case SC_KEYMENU:

            /*
             * A menu was selected via keyboard
             */
            pMenuState = xxxMNStartMenuState(pwnd, cmd, lParam);
            if (pMenuState != NULL) {
                UserAssert(PtiCurrent() == pMenuState->ptiMenuStateOwner);

                /*
                 * Make sure we are not fullscreen
                 */
                if (gspwndFullScreen == pwnd) {
                    PWND pwndT;
                    TL tlpwndT;

                    pwndT = _GetDesktopWindow();
                    ThreadLock(pwndT, &tlpwndT);
                    xxxMakeWindowForegroundWithState(pwndT, GDIFULLSCREEN);
                    ThreadUnlock(&tlpwndT);
                }

                pMenuState->fUnderline = TRUE;
                xxxMNKeyFilter(pMenuState->pGlobalPopupMenu, pMenuState, (UINT)lParam);
                if (!pMenuState->fModelessMenu) {
                    xxxMNEndMenuState (TRUE);
                }
            }
            /*
             * Capture must have been unlocked
             */
            UserAssert(!(PtiCurrent()->pq->QF_flags & QF_CAPTURELOCKED));
            return;

        case SC_MOUSEMENU:
        case SC_DEFAULT:

            /*
             * If the window is not foreground, eat the command to avoid
             * wasting time flashing the system menu.
             *
             * We used to check if the top level window was WFFRAMEON (so a
             * child window's system menu works like Win 3.1) but Excel's
             * (SDM) dialogs allow you to access their menus even though
             * the child and parent appear to be inactive.
             */
            if (!(GETPTI(pwnd)->pq == gpqForeground))
                return;

            /*
             * A mouse click occurred on a toplevel menu.
             */
            pMenuState = xxxMNStartMenuState(pwnd, cmd, lParam);
            if (pMenuState != NULL) {
                UserAssert(PtiCurrent() == pMenuState->ptiMenuStateOwner);
                xxxMNLoop(pMenuState->pGlobalPopupMenu, pMenuState, lParam, (cmd==SC_DEFAULT));
                if (!pMenuState->fModelessMenu) {
                    xxxMNEndMenuState (TRUE);
                }
            }
            /*
             * Capture must have been unlocked
             */
            UserAssert(!(PtiCurrent()->pq->QF_flags & QF_CAPTURELOCKED));
            return;

        case SC_VSCROLL:
        case SC_HSCROLL:
            xxxSBTrackInit(pwnd, lParam, htArea, (_GetKeyState(VK_SHIFT) < 0) ? SCROLL_DIRECT : SCROLL_NORMAL);
            return;

        case SC_TASKLIST:
//            _PostThreadMessage(gptiTasklist, WM_SYSCOMMAND, SC_TASKLIST, 0);
//            if (!FCallTray() ||
//                !CallHook(HSHELL_TASKMAN, (WPARAM) HW16(hwnd), (LPARAM) 0, WH_SHELL))

            /*
             * Winlogon will set lParam to -1 to indicate that we really want a task list,
             * not just the start menu.  We indicate this to the shell by passing a NULL
             * window ptr
             * This message is really intended for the SHELL, so give them the right
             *  to set the foreground.
             */
            if (FDoTray() && (FCallHookTray() || FPostTray(pwnd->head.rpdesk))) {
                PWND pwndTaskman = pwnd->head.rpdesk->pDeskInfo->spwndTaskman;
                if (FCallHookTray()) {
                    xxxCallHook(HSHELL_TASKMAN, (WPARAM)HWq(pwnd), (LPARAM) 0, WH_SHELL);
                }
                if ((FPostTray(pwnd->head.rpdesk)) && (pwndTaskman != NULL)) {
                    glinp.ptiLastWoken = GETPTI(pwndTaskman);
                    _PostMessage(pwndTaskman, gpsi->uiShellMsg, HSHELL_TASKMAN,
                            lParam == (ULONG)(-1) ? (LPARAM) -1 :(LPARAM)HWq(pwnd));
                }
            } else if (gptiTasklist != NULL) {
                 glinp.ptiLastWoken = gptiTasklist;
                _PostThreadMessage(gptiTasklist, WM_SYSCOMMAND, SC_TASKLIST, 0);
// LATER -- FritzS
//                HCURSOR hCursorLast;
//                static char CODESEG szTask[] = " %d %d";

//                ShowCursor(TRUE);
//                hCursorLast = SetCursor32(hCursWait, TRUE);

                // Try in the windows directory first.
//                GetWindowsDirectory(szBuff, sizeof(szBuff));
//                if (szBuff[lstrlen(szBuff) - 1] != '\\')
//                    lstrcatn(szBuff, "\\", sizeof(szBuff));
//                lstrcatn(szBuff, (LPSTR)pTaskManName, sizeof(szBuff));
//                wvsprintf(szBuff+lstrlen(szBuff), (LPSTR)szTask, (LPSTR)&lParam);

//                if (WinExec((LPSTR)szBuff, SW_SHOWNORMAL) <= 32)
//                {
//                    // If it wasn't in the windows directory then try
//                    // searching the full path.
//                    lstrcpyn(szBuff, pTaskManName, sizeof(szBuff));
//                    wvsprintf(szBuff+lstrlen(szBuff), (LPSTR)szTask, (LPSTR)&lParam);
//                    WinExec((LPSTR)szBuff, SW_SHOWNORMAL);
//                }
//
//                ShowCursor(FALSE);
//                SetCursor32(hCursorLast, TRUE);
            }

            break;

        case SC_MONITORPOWER:
            /*
             * If we're powering down the machine, or if we are switching protocol,ignore this request.
             */

            if (gPowerState.fInProgress || gfSwitchInProgress) {
                break;
            }

            switch (lParam) {
            case POWERON_PHASE:
                if (glinp.dwFlags & LINP_POWERTIMEOUTS) {
                    glinp.dwFlags &= ~LINP_POWERTIMEOUTS;
                    DrvSetMonitorPowerState(gpDispInfo->pmdev,
                                          PowerDeviceD0);
                }
                break;
            case LOWPOWER_PHASE:
                if ((glinp.dwFlags & LINP_LOWPOWER) == 0) {
                    glinp.dwFlags |= LINP_LOWPOWER;
                    DrvSetMonitorPowerState(gpDispInfo->pmdev,
                                          PowerDeviceD1);
                }
                break;
            case POWEROFF_PHASE:
                if ((glinp.dwFlags & LINP_POWEROFF) == 0) {
                    glinp.dwFlags |= LINP_POWEROFF;
                    DrvSetMonitorPowerState(gpDispInfo->pmdev,
                                          PowerDeviceD3);
                }
                break;
            default:
                break;
            }
            break;

        case SC_SCREENSAVE:
            pwndSwitch = RevalidateHwnd(ghwndSwitch);

            // Lock out screen save until we get another input message.

            if (pwndSwitch != NULL && pwnd != pwndSwitch) {
                _PostMessage(pwndSwitch, WM_SYSCOMMAND, SC_SCREENSAVE, 0L);
            } else {
                StartScreenSaver(FALSE);
            }
            break;

        case SC_HOTKEY:

            /*
             * Loword of the lparam is window to switch to
             */
            pwnd = ValidateHwnd((HWND)lParam);
            if (pwnd != NULL) {
                pwndSwitch = _GetLastActivePopup(pwnd);

                if (pwndSwitch != NULL)
                      pwnd = pwndSwitch;

                ThreadLockAlways(pwnd, &tlpwnd);
                xxxSetForegroundWindow(pwnd, FALSE);
                ThreadUnlock(&tlpwnd);

                if (TestWF(pwnd, WFMINIMIZED))
                    _PostMessage(pwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
            }
            break;
        }
    }
}

/***************************************************************************\
* _RegisterTasklist (Private API)
*
* History:
* 05-01-91  DavidPe     Created.
\***************************************************************************/

BOOL _RegisterTasklist(
    PWND pwndTasklist)
{
#ifdef LATER
    //
    // JimA - ??? Why do this?
    //
    PETHREAD Thread;

    Thread = PsGetCurrentThread();
    pRitCSRThread->ThreadHandle = Thread->ThreadHandle;
#endif

    gptiTasklist = GETPTI(pwndTasklist);
    ghwndSwitch = HWq(pwndTasklist);

    /*
     * Don't allow an app to call AttachThreadInput() on task man -
     * we want taskman to be unsynchronized at all times (so the user
     * can bring it up and kill other apps).
     */
    GETPTI(pwndTasklist)->TIF_flags |= TIF_DONTATTACHQUEUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\sprite.c ===
/****************************** Module Header ******************************\
* Module Name: sprite.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Windows Layering (Sprite) support.
*
* History:
* 12/05/97      vadimg      created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef MOUSE_IP

#define MOUSE_SONAR_RADIUS_INIT         100
#define MOUSE_SONAR_LINE_WIDTH          4
#define MOUSE_SONAR_RADIUS_DELTA        20
#define MOUSE_SONAR_RADIUS_TIMER        50
#define COLORKEY_COLOR          RGB(255, 0, 255)

void DrawSonar(HDC hdc);

#endif

#ifdef REDIRECTION

/***************************************************************************\
* UserGetRedirectionBitmap
*
\***************************************************************************/

HBITMAP UserGetRedirectionBitmap(HWND hwnd)
{
    HBITMAP hbm;
    PWND pwnd;

    EnterCrit();

    if ((pwnd = RevalidateHwnd(hwnd)) == NULL) {
        return NULL;
    }

    hbm = GetRedirectionBitmap(pwnd);

    LeaveCrit();

    return hbm;
}

/***************************************************************************\
* SetRedirectionMode
*
\***************************************************************************/

BOOL SetRedirectionMode(PBWL pbwl, PPROCESSINFO ppi)
{
    HWND *phwnd;
    PWND pwndT;
    BOOL fRet = TRUE;

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        if ((pwndT = RevalidateHwnd(*phwnd)) == NULL) {
            continue;
        }

        if (TestWF(pwndT, WFVISIBLE) && ((ppi == NULL) ||(GETPTI(pwndT)->ppi != ppi))) {
            if (SetRedirectedWindow(pwndT, REDIRECT_EXTREDIRECTED)) {
                SetWF(pwndT, WEFEXTREDIRECTED);
            } else {
                fRet = FALSE;
                break;
            }
        }
    }

    return fRet;
}

/***************************************************************************\
* UnsetRedirectionMode
*
\***************************************************************************/

VOID UnsetRedirectionMode(PBWL pbwl,  PPROCESSINFO ppi)
{
    HWND *phwnd;
    PWND pwndT;

    for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

        if ((pwndT = RevalidateHwnd(*phwnd)) == NULL) {
            continue;
        }

        if (TestWF(pwndT, WFVISIBLE) && (ppi == NULL) || (GETPTI(pwndT)->ppi !=ppi)) {
            UnsetRedirectedWindow(pwndT, REDIRECT_EXTREDIRECTED);
            ClrWF(pwndT, WEFEXTREDIRECTED);
        }
    }
}

/***************************************************************************\
* xxxSetRedirectionMode
*
\***************************************************************************/
BOOL xxxSetRedirectionMode(BOOL fEnable, PDESKTOP pDesk, PTHREADINFO pti, PPROCESSINFO ppi  )
{
    PBWL pbwl;
    PWND pwndDesktop   = pDesk->pDeskInfo->spwnd;

    pbwl = BuildHwndList(pwndDesktop->spwndChild, BWL_ENUMLIST, pti);
    
    if (pbwl == NULL) {
        return FALSE;
    }

    if (fEnable) {
        if (!SetRedirectionMode(pbwl, ppi)) {
            UnsetRedirectionMode(pbwl, ppi);
        }
    } else {
        UnsetRedirectionMode(pbwl, ppi);
    }
    FreeHwndList(pbwl);

    GreEnableDirectDrawRedirection(gpDispInfo->hDev, fEnable);
    xxxBroadcastDisplaySettingsChange(PtiCurrent()->rpdesk, FALSE);

    pwndDesktop = PtiCurrent()->rpdesk->pDeskInfo->spwnd;
    BEGINATOMICCHECK();
    xxxInternalInvalidate(pwndDesktop, HRGN_FULL, RDW_INVALIDATE |
            RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN);
    ENDATOMICCHECK();

    return TRUE;
}

/***************************************************************************\
* xxxSetProcessRedirectionMode
*
\***************************************************************************/
BOOL xxxSetProcessRedirectionMode(BOOL fEnable, PPROCESSINFO ppi)
{
    PTHREADINFO pti = ppi->ptiList;
    TL tl;
    
    while (pti != NULL)  {
        ThreadLockPti(PtiCurrent(), pti, &tl);
        if (!xxxSetRedirectionMode(fEnable, pti->rpdesk, pti, NULL)) {
            ThreadUnlockPti(PtiCurrent(), &tl);
            return FALSE;
        }
        pti = pti->ptiSibling;
        ThreadUnlockPti(PtiCurrent(), &tl);
    }
    return TRUE;
}

/***************************************************************************\
* xxxSetDesktopRedirectionMode
*
\***************************************************************************/
BOOL xxxSetDesktopRedirectionMode(BOOL fEnable, PDESKTOP pDesk, PPROCESSINFO ppi)
{
    return xxxSetRedirectionMode(fEnable, pDesk, NULL, ppi);
}

#endif // REDIRECTION

/***************************************************************************\
* IncrementRedirectedCount
*
\***************************************************************************/

VOID IncrementRedirectedCount(VOID)
{
    gnRedirectedCount++;

    if (gnRedirectedCount == 1) {
        InternalSetTimer(gTermIO.spwndDesktopOwner, IDSYS_LAYER, 100,
                xxxSystemTimerProc, TMRF_SYSTEM | TMRF_PTIWINDOW);
    }

    UserAssert(gnRedirectedCount >= 0);
}

/***************************************************************************\
* DecrementRedirectedCount
*
\***************************************************************************/

VOID DecrementRedirectedCount(VOID)
{
    gnRedirectedCount--;

    if (gnRedirectedCount == 0) {
        _KillSystemTimer(gTermIO.spwndDesktopOwner, IDSYS_LAYER);
    }

    UserAssert(gnRedirectedCount >= 0);
}

/***************************************************************************\
* CreateRedirectionBitmap
*
* 10/1/1998        vadimg      created
\***************************************************************************/

HBITMAP CreateRedirectionBitmap(PWND pwnd)
{
    HBITMAP hbm;

    UserAssert(pwnd->rcWindow.right >= pwnd->rcWindow.left);
    UserAssert(pwnd->rcWindow.bottom >= pwnd->rcWindow.top);

    /*
     * Make sure the (0,0) case doesn't fail, since the window really
     * can be sized this way.
     */
    if ((hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen,
            max(pwnd->rcWindow.right - pwnd->rcWindow.left, 1),
            max(pwnd->rcWindow.bottom - pwnd->rcWindow.top, 1) |
            CCB_NOVIDEOMEMORY)) == NULL) {
        RIPMSG0(RIP_WARNING, "CreateRedirectionBitmap: bitmap create failed");
        return NULL;
    }

    if (!GreSetBitmapOwner(hbm, OBJECT_OWNER_PUBLIC) ||
            !GreMarkUndeletableBitmap(hbm) ||
            !SetRedirectionBitmap(pwnd, hbm)) {
        RIPMSG0(RIP_WARNING, "CreateRedirectionBitmap: bitmap set failed");
        GreMarkDeletableBitmap(hbm);
        GreDeleteObject(hbm);
        return NULL;
    }

    SetWF(pwnd, WEFPREDIRECTED);

    /*
     * Force the window to redraw if we could recreate the bitmap since
     * the redirection bitmap we just allocated doesn't contain anything
     * yet.
     */
    BEGINATOMICCHECK();
    xxxInternalInvalidate(pwnd, HRGN_FULL, RDW_INVALIDATE | RDW_ERASE |
            RDW_FRAME | RDW_ALLCHILDREN);
    ENDATOMICCHECK();

    IncrementRedirectedCount();

    return hbm;
}

/***************************************************************************\
* ConvertRedirectionDCs
*
* 11/19/1998        vadimg      created
\***************************************************************************/

VOID ConvertRedirectionDCs(PWND pwnd, HBITMAP hbm)
{
    PDCE pdce;

    GreLockDisplay(gpDispInfo->hDev);

    for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

        if (pdce->DCX_flags & DCX_DESTROYTHIS)
            continue;

        if (!(pdce->DCX_flags & DCX_INUSE))
            continue;

        if (!_IsDescendant(pwnd, pdce->pwndOrg))
            continue;

        /*
         * Only normal DCs can be redirected. Redirection on monitor
         * specific DCs is not supported.
         */
        if (pdce->pMonitor != NULL)
            continue;

        SET_OR_CLEAR_FLAG(pdce->DCX_flags, DCX_REDIRECTED, (hbm != NULL));

        UserVerify(GreSelectRedirectionBitmap(pdce->hdc, hbm));

        InvalidateDce(pdce);
    }

    GreUnlockDisplay(gpDispInfo->hDev);
}

/***************************************************************************\
* UpdateRedirectedDC
*
* 11/19/1998        vadimg      created
\***************************************************************************/
VOID UpdateRedirectedDC(
    PDCE pdce)
{
    RECT rcBounds;
    PWND pwnd;
    SIZE size;
    POINT pt;
    HBITMAP hbm, hbmOld;
    PREDIRECT prdr;

    UserAssert(pdce->DCX_flags & DCX_REDIRECTED);
    
    /*
     * Check to see if any drawing has been done into this DC
     * that should be transferred to the sprite.
     */
    if (!GreGetBounds(pdce->hdc, &rcBounds, 0))
        return;

    pwnd = GetStyleWindow(pdce->pwndOrg, WEFPREDIRECTED);
    UserAssert(pwnd);
    prdr = (PREDIRECT)_GetProp(pwnd, PROP_LAYER, TRUE);

#ifdef REDIRECTION
    BEGINATOMICCHECK();
    xxxWindowEvent(EVENT_SYSTEM_REDIRECTEDPAINT, pwnd,
            MAKELONG(rcBounds.left, rcBounds.top),
            MAKELONG(rcBounds.right, rcBounds.bottom),
            WEF_ASYNC);
    ENDATOMICCHECK();
#endif // REDIRECTION

    if (TestWF(pwnd, WEFCOMPOSITED)) {

        if (TestWF(pwnd, WEFPCOMPOSITING)) {
            UnionRect(&prdr->rcUpdate, &prdr->rcUpdate, &rcBounds);
        } else {
            HRGN hrgn;
            OffsetRect(&rcBounds, pwnd->rcWindow.left, pwnd->rcWindow.top);
            hrgn = GreCreateRectRgnIndirect(&rcBounds);
            xxxInternalInvalidate(pwnd, hrgn, RDW_ALLCHILDREN | RDW_INVALIDATE |
                    RDW_ERASE | RDW_FRAME);
            GreDeleteObject(hrgn);
        }
    } else if (TestWF(pwnd, WEFLAYERED)) {
        hbm = prdr->hbm;

        hbmOld = GreSelectBitmap(ghdcMem, hbm);

        size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
        size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

        pt.x = pt.y = 0;
        GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL, NULL,
                &size, ghdcMem, &pt, 0, NULL, ULW_DEFAULT_ATTRIBUTES, &rcBounds);

        GreSelectBitmap(ghdcMem, hbmOld);
    }
}

/***************************************************************************\
* DeleteRedirectionBitmap
*
\***************************************************************************/

VOID DeleteRedirectionBitmap(HBITMAP hbm)
{
    GreMarkDeletableBitmap(hbm);
    GreDeleteObject(hbm);
    DecrementRedirectedCount();
}

/***************************************************************************\
* RemoveRedirectionBitmap
*
* 9/23/1998        vadimg      created
\***************************************************************************/

VOID RemoveRedirectionBitmap(PWND pwnd)
{
    HBITMAP hbm;

    /*
     * Delete the backing bitmap for this layered window.
     */
    if ((hbm = GetRedirectionBitmap(pwnd)) == NULL)
        return;

    UserAssert(TestWF(pwnd, WEFPREDIRECTED));
    ClrWF(pwnd, WEFPREDIRECTED);

    ConvertRedirectionDCs(pwnd, NULL);
    SetRedirectionBitmap(pwnd, NULL);
    DeleteRedirectionBitmap(hbm);
}

/***************************************************************************\
* _GetLayeredWindowAttributes
*
* 3/14/2000        jstall      created
\***************************************************************************/

BOOL _GetLayeredWindowAttributes(PWND pwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
{
    BLENDFUNCTION bf;
    UserAssertMsg0(pcrKey != NULL, "Ensure valid pointer");
    UserAssertMsg0(pbAlpha != NULL, "Ensure valid pointer");
    UserAssertMsg0(pdwFlags != NULL, "Ensure valid pointer");

    if (!TestWF(pwnd, WEFLAYERED)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "GetLayeredWindowAttributes: not a sprite %X", pwnd);
        return FALSE;
    }

    /*
     * Check that the window has a redirection bitmap and is marked as
     * layered through WS_EX_LAYERED.  If the window is layered through
     * UpdateLayeredWindow, this function should fail.
     */
    if (((GetRedirectionFlags(pwnd) & REDIRECT_LAYER) == 0) ||
        (! TestWF(pwnd, WEFLAYERED))) {

        return FALSE;
    }

    if (GreGetSpriteAttributes(gpDispInfo->hDev, PtoHq(pwnd), NULL, pcrKey, &bf, pdwFlags)) {
        *pbAlpha = bf.SourceConstantAlpha;

        return TRUE;
    }

    return FALSE;
}


/***************************************************************************\
* _SetLayeredWindowAttributes
*
* 9/24/1998        vadimg      created
\***************************************************************************/

BOOL _SetLayeredWindowAttributes(PWND pwnd, COLORREF crKey, BYTE bAlpha,
        DWORD dwFlags)
{
    BOOL bRet;
    BLENDFUNCTION blend;
    HBITMAP hbm;

    if (!TestWF(pwnd, WEFLAYERED)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "SetLayeredWindowAttributes: not a sprite %X", pwnd);
        return FALSE;
    }

    if ((hbm = GetRedirectionBitmap(pwnd)) == NULL) {
        if (!SetRedirectedWindow(pwnd, REDIRECT_LAYER)) {
            return FALSE;
        }
    }

    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = bAlpha;

    dwFlags |= ULW_NEW_ATTRIBUTES; // Notify gdi that these are new attributes

    if (hbm != NULL) {
        HBITMAP hbmOld;
        SIZE size;
        POINT ptSrc = {0,0};

        hbmOld = GreSelectBitmap(ghdcMem, hbm);

        size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
        size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

        bRet =  GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL,
            NULL, &size, ghdcMem, &ptSrc, crKey, &blend, dwFlags, NULL);

        GreSelectBitmap(ghdcMem, hbmOld);
    } else {
        bRet =  GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, NULL,
            NULL, NULL, NULL, NULL, crKey, &blend, dwFlags, NULL);
    }

    return bRet;
}

/***************************************************************************\
* RecreateRedirectionBitmap
*
* 10/1/1998        vadimg      created
\***************************************************************************/

BOOL RecreateRedirectionBitmap(PWND pwnd)
{
    HBITMAP hbm, hbmNew, hbmMem, hbmMem2;
    BITMAP bm, bmNew;
    int cx, cy;
    PDCE pdce;

    /*
     * No need to do anything if this layered window doesn't have
     * a redirection bitmap.
     */
    if ((hbm = GetRedirectionBitmap(pwnd)) == NULL)
        return FALSE;

    UserAssert(TestWF(pwnd, WEFPREDIRECTED));

    /*
     * Try to create a new redirection bitmap with the new size. If failed,
     * delete the old one and remove it from the window property list.
     */
    if ((hbmNew = CreateRedirectionBitmap(pwnd)) == NULL) {
        RemoveRedirectionBitmap(pwnd);
        return FALSE;
    }

    /*
     * Make sure that the display is locked, so that nobody can be drawing
     * into the redirection DCs while we're switching bitmaps under them.
     */
    UserAssert(GreIsDisplayLocked(gpDispInfo->hDev));

    /*
     * Get the size of the old bitmap to know how much to copy.
     */
    GreExtGetObjectW(hbm, sizeof(bm), (LPSTR)&bm);
    GreExtGetObjectW(hbmNew, sizeof(bmNew), (LPSTR)&bmNew);

    /*
     * Copy the bitmap from the old bitmap into the new one.
     */
    hbmMem = GreSelectBitmap(ghdcMem, hbm);
    hbmMem2 = GreSelectBitmap(ghdcMem2, hbmNew);

    cx = min(bm.bmWidth, bmNew.bmWidth);
    cy = min(bm.bmHeight, bmNew.bmHeight);

    GreBitBlt(ghdcMem2, 0, 0, cx, cy, ghdcMem, 0, 0, SRCCOPY | NOMIRRORBITMAP, 0);

    /*
     * Find layered DCs that are in use corresponding to this window and
     * replace the old redirection bitmap by the new one.
     */
    for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

        if (pdce->DCX_flags & DCX_DESTROYTHIS)
            continue;

        if (!(pdce->DCX_flags & DCX_REDIRECTED) || !(pdce->DCX_flags & DCX_INUSE))
            continue;

        if (!_IsDescendant(pwnd, pdce->pwndOrg))
            continue;

        UserVerify(GreSelectRedirectionBitmap(pdce->hdc, hbmNew));
    }

    GreSelectBitmap(ghdcMem, hbmMem);
    GreSelectBitmap(ghdcMem2, hbmMem2);

    /*
     * Finally, delete the old redirection bitmap.
     */
    DeleteRedirectionBitmap(hbm);

    return TRUE;
}

/***************************************************************************\
* ResetRedirectedWindows
*
\***************************************************************************/

VOID ResetRedirectedWindows(VOID)
{
    PHE phe, pheMax;
    PWND pwnd;

    GreLockDisplay(gpDispInfo->hDev);

    pheMax = &gSharedInfo.aheList[giheLast];
    for (phe = gSharedInfo.aheList; phe <= pheMax; phe++) {
        if (phe->bType != TYPE_WINDOW) {
            continue;
        }

        pwnd = (PWND)phe->phead;
        if (!TestWF(pwnd, WEFPREDIRECTED)) {
            continue;
        }

        RecreateRedirectionBitmap(pwnd);

        /*
         * Recreate the sprite so the surfaces are at the proper color depth.
         */
        if (TestWF(pwnd, WEFLAYERED)) {
            COLORREF cr;
            BLENDFUNCTION blend;
            DWORD dwFlags;

            GreGetSpriteAttributes(gpDispInfo->hDev, PtoHq(pwnd), NULL,
                    &cr, &blend, &dwFlags);

            GreDeleteSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL);

            if (GreCreateSprite(gpDispInfo->hDev, PtoHq(pwnd), &pwnd->rcWindow)) {
                _SetLayeredWindowAttributes(pwnd, cr, blend.SourceConstantAlpha,
                        dwFlags);
            } else {
                RemoveRedirectionBitmap(pwnd);
                ClrWF(pwnd, WEFLAYERED);
            }
        }
    }

    GreUnlockDisplay(gpDispInfo->hDev);
}

/***************************************************************************\
* UnsetLayeredWindow
*
* 1/30/1998   vadimg          created
\***************************************************************************/

VOID UnsetLayeredWindow(PWND pwnd)
{
    HWND hwnd = PtoHq(pwnd);

    UnsetRedirectedWindow(pwnd, REDIRECT_LAYER);

    /*
     * If the window is still visible, leave the sprite bits on the screen.
     */
    if (TestWF(pwnd, WFVISIBLE)) {
        GreUpdateSprite(gpDispInfo->hDev, hwnd, NULL, NULL, NULL, NULL,
                NULL, NULL, 0, NULL, ULW_NOREPAINT, NULL);
    }

    /*
     * Delete the sprite object.
     */
    if (!GreDeleteSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL)) {
        RIPMSG1(RIP_WARNING, "xxxSetLayeredWindow failed %X", pwnd);
    }
    ClrWF(pwnd, WEFLAYERED);

    /*
     * Make sure the window gets painted if visible.
     *
     * RAID 143578.
     * Should consider to jiggle the mouse. Remove IDC_NOMOUSE when
     * SetFMouseMoved and thus InvalidateDCCache don't leave crit.
     * This is because the hit-testing by a window may change when it
     * transitions the layering state.
     */
    if (TestWF(pwnd, WFVISIBLE)) {
        BEGINATOMICCHECK();
        zzzInvalidateDCCache(pwnd, IDC_DEFAULT | IDC_NOMOUSE);
        ENDATOMICCHECK();
    }
}

/***************************************************************************\
* xxxSetLayeredWindow
*
* 12/05/97      vadimg      wrote
\***************************************************************************/

HANDLE xxxSetLayeredWindow(PWND pwnd, BOOL fRepaintBehind)
{
    HANDLE hsprite;
    SIZE size;

    CheckLock(pwnd);

#ifndef CHILD_LAYERING
    if (!FTopLevel(pwnd)) {
        RIPMSG1(RIP_WARNING, "xxxSetLayeredWindow: not top-level %X", pwnd);
        return NULL;
    }
#endif // CHILD_LAYERING

#if DBG
    if (TestWF(pwnd, WEFLAYERED)) {
        RIPMSG1(RIP_ERROR, "xxxSetLayeredWindow: already layered %X", pwnd);
    }
#endif

    size.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
    size.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;

    hsprite = GreCreateSprite(gpDispInfo->hDev, PtoHq(pwnd), &pwnd->rcWindow);
    if (hsprite == NULL) {
        RIPMSG1(RIP_WARNING, "xxxSetLayeredWindow failed %X", pwnd);
        return NULL;
    }

    SetWF(pwnd, WEFLAYERED);
    TrackLayeredZorder(pwnd);

    /*
     * Invalidate the DC cache because changing the sprite status
     * may change the visrgn for some windows.
     *
     * RAID 143578.
     * Should jiggle the mouse. Remove IDC_NOMOUSE when
     * SetFMouseMoved and thus InvalidateDCCache don't leave crit.
     * This is because the hit-testing by a window may change when it
     * transitions the layering state.
     */
    BEGINATOMICCHECK();
    zzzInvalidateDCCache(pwnd, IDC_DEFAULT | IDC_NOMOUSE);
    ENDATOMICCHECK();

    /*
     * For the dynamic promotion to a sprite, put the proper bits into
     * the sprite itself by doing ULW with the current screen content
     * and into the background by invalidating windows behind.  There
     * might be some dirty bits if the window is partially obscured, but
     * they will be refreshed as soon as the app calls ULW on its own.
     */
    if (TestWF(pwnd, WFVISIBLE)) {
        if (fRepaintBehind) {
            POINT pt;

            pt.x = pwnd->rcWindow.left;
            pt.y = pwnd->rcWindow.top;

            _UpdateLayeredWindow(pwnd, gpDispInfo->hdcScreen, &pt, &size,
                    gpDispInfo->hdcScreen, &pt, 0, NULL, ULW_OPAQUE);
        }
    } else {
        /*
         * No need to repaint behind if the window is still invisible.
         */
        fRepaintBehind = FALSE;
    }

    /*
     * This must be done after the DC cache is invalidated, because
     * the xxxUpdateWindows call will redraw some stuff.
     */
    if (fRepaintBehind) {
        HRGN hrgn = GreCreateRectRgnIndirect(&pwnd->rcWindow);
        xxxRedrawWindow(NULL, NULL, hrgn,
                RDW_INVALIDATE | RDW_FRAME | RDW_ERASE | RDW_ALLCHILDREN);
        xxxUpdateWindows(pwnd, hrgn);
        GreDeleteObject(hrgn);
    }
    return hsprite;
}

/***************************************************************************\
* UserVisrgnFromHwnd
*
* Calculate a non-clipchildren visrgn for sprites. This function must be
* called while inside the USER critical section.
*
* 12/05/97      vadimg      wrote
\***************************************************************************/

BOOL UserVisrgnFromHwnd(HRGN *phrgn, HWND hwnd)
{
    PWND pwnd;
    DWORD dwFlags;
    RECT rcWindow;
    BOOL fRet;

    CheckCritIn();

    if ((pwnd = RevalidateHwnd(hwnd)) == NULL) {
        RIPMSG0(RIP_WARNING, "VisrgnFromHwnd: invalid hwnd");
        return FALSE;
    }

    /*
     * So that we don't have to recompute the layered window's visrgn
     * every time the layered window is moved, we compute the visrgn once
     * as if the layered window covered the entire screen.  GDI will
     * automatically intersect with this region whenever the sprite moves.
     */
    rcWindow = pwnd->rcWindow;
    pwnd->rcWindow = gpDispInfo->rcScreen;

    /*
     * Since we use DCX_WINDOW, only rcWindow needs to be faked and saved.
     * Never specify DCX_REDIRECTEDBITMAP here. See comments in CalcVisRgn().
     */
    dwFlags = DCX_WINDOW | DCX_LOCKWINDOWUPDATE;
    if (TestWF(pwnd, WFCLIPSIBLINGS))
        dwFlags |= DCX_CLIPSIBLINGS;

    fRet = CalcVisRgn(phrgn, pwnd, pwnd, dwFlags);

    pwnd->rcWindow = rcWindow;

    return fRet;
}

/***************************************************************************\
* SetRectRelative
\***************************************************************************/

void SetRectRelative(PRECT prc, int dx, int dy, int dcx, int dcy)
{
    prc->left += dx;
    prc->top += dy;
    prc->right += (dx + dcx);
    prc->bottom += (dy + dcy);
}

/***************************************************************************\
* xxxUpdateLayeredWindow
*
* 1/20/1998   vadimg          created
\***************************************************************************/

BOOL _UpdateLayeredWindow(
    PWND pwnd,
    HDC hdcDst,
    POINT *pptDst,
    SIZE *psize,
    HDC hdcSrc,
    POINT *pptSrc,
    COLORREF crKey,
    BLENDFUNCTION *pblend,
    DWORD dwFlags)
{
    int dx, dy, dcx, dcy;
    BOOL fMove = FALSE, fSize = FALSE;

    /*
     * Verify that we're called with a real layered window.
     */
    if (!TestWF(pwnd, WEFLAYERED) ||
            GetRedirectionBitmap(pwnd) != NULL) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING,
                "_UpdateLayeredWindow: can't call on window %X", pwnd);
        return FALSE;
    }

    if (!GreUpdateSprite(gpDispInfo->hDev, PtoHq(pwnd), NULL, hdcDst, pptDst,
            psize, hdcSrc, pptSrc, crKey, pblend, dwFlags, NULL)) {
        RIPMSG1(RIP_WARNING, "_UpdateLayeredWindow: !UpdateSprite %X", pwnd);
        return FALSE;
    }

    /*
     * Figure out relative adjustments in position and size.
     */
    if (pptDst != NULL) {
        dx = pptDst->x - pwnd->rcWindow.left;
        dy = pptDst->y - pwnd->rcWindow.top;
        if (dx != 0 || dy != 0) {
            fMove = TRUE;
        }
    } else {
        dx = 0;
        dy = 0;
    }
    if (psize != NULL) {
        dcx = psize->cx - (pwnd->rcWindow.right - pwnd->rcWindow.left);
        dcy = psize->cy - (pwnd->rcWindow.bottom - pwnd->rcWindow.top);
        if (dcx != 0 || dcy != 0) {
            fSize = TRUE;
        }
    } else {
        dcx = 0;
        dcy = 0;
    }

    if (fMove || fSize) {
        /*
         * Adjust the client rect position and size relative to
         * the window rect.
         */
        SetRectRelative(&pwnd->rcWindow, dx, dy, dcx, dcy);
        SetRectRelative(&pwnd->rcClient, dx, dy, dcx, dcy);

        /*
         * Since the client rect could be smaller than the window
         * rect make sure the client rect doesn't underflow!
         */
        if ((dcx < 0) && (pwnd->rcClient.left < pwnd->rcWindow.left)) {
            pwnd->rcClient.left = pwnd->rcWindow.left;
            pwnd->rcClient.right = pwnd->rcWindow.left;
        }
        if ((dcy < 0) && (pwnd->rcClient.top < pwnd->rcWindow.top)) {
            pwnd->rcClient.top = pwnd->rcWindow.top;
            pwnd->rcClient.bottom = pwnd->rcWindow.top;
        }

       /*
        * RAID 143578.
        * The shape of the layered window may have changed and thus
        * ideally we should jiggle the mouse. Currently, that would
        * make us leave the critical section which we don't want to do.
        *
        * SetFMouseMoved();
        */
    }

    return TRUE;
}

/***************************************************************************\
* DeleteFadeSprite
\***************************************************************************/

PWND DeleteFadeSprite(void)
{
    PWND pwnd = NULL;

    if (gfade.dwFlags & FADE_WINDOW) {
        if ((pwnd = RevalidateHwnd(gfade.hsprite)) != NULL) {
            if (TestWF(pwnd, WEFLAYERED)) {
                UnsetLayeredWindow(pwnd);
            }
        } else {
            RIPMSG0(RIP_WARNING, "DeleteFadeSprite: hwnd no longer valid");
        }
    } else {
        GreDeleteSprite(gpDispInfo->hDev, NULL, gfade.hsprite);
    }
    gfade.hsprite = NULL;
    return pwnd;
}

/***************************************************************************\
* UpdateFade
*
* 2/16/1998   vadimg          created
\***************************************************************************/

void UpdateFade(POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc,
        BLENDFUNCTION *pblend)
{
    PWND pwnd;

    if (gfade.dwFlags & FADE_WINDOW) {
        if ((pwnd = RevalidateHwnd(gfade.hsprite)) != NULL) {
            _UpdateLayeredWindow(pwnd, NULL, pptDst, psize, hdcSrc,
                     pptSrc, 0, pblend, ULW_ALPHA);
        }
    } else {
#ifdef MOUSE_IP
        DWORD dwShape = ULW_ALPHA;

        if (gfade.dwFlags & FADE_COLORKEY) {
            dwShape = ULW_COLORKEY;
        }
        GreUpdateSprite(gpDispInfo->hDev, NULL, gfade.hsprite, NULL,
                pptDst, psize, hdcSrc, pptSrc, gfade.crColorKey, pblend, dwShape, NULL);
#else
        GreUpdateSprite(gpDispInfo->hDev, NULL, gfade.hsprite, NULL,
                pptDst, psize, hdcSrc, pptSrc, 0, pblend, ULW_ALPHA, NULL);
#endif
    }
}

/***************************************************************************\
* CreateFade
*
* 2/5/1998   vadimg          created
\***************************************************************************/

HDC CreateFade(PWND pwnd, RECT *prc, DWORD dwTime, DWORD dwFlags)
{
    SIZE size;

    /*
     * Bail if there is a fade animation going on already.
     */
    if (gfade.hbm != NULL) {
        RIPMSG0(RIP_WARNING, "CreateFade: failed, fade not available");
        return NULL;
    }

    /*
     * Create a cached compatible DC.
     */
    if (gfade.hdc == NULL) {
        gfade.hdc = GreCreateCompatibleDC(gpDispInfo->hdcScreen);
        if (gfade.hdc == NULL) {
            return NULL;
        }
    } else {
        /*
         * Reset the hdc before reusing it.
         */
        GreSetLayout(gfade.hdc , -1, 0);
    }

    /*
     * A windowed fade must have window position and size, so
     * prc passed in is disregarded.
     */
    UserAssert((pwnd == NULL) || (prc == NULL));

    if (pwnd != NULL) {
        prc = &pwnd->rcWindow;
    }

    size.cx = prc->right - prc->left;
    size.cy = prc->bottom - prc->top;

    if (pwnd == NULL) {
        gfade.hsprite = GreCreateSprite(gpDispInfo->hDev, NULL, prc);
    } else {
        gfade.dwFlags |= FADE_WINDOW;
        gfade.hsprite = HWq(pwnd);

        BEGINATOMICCHECK();
        xxxSetLayeredWindow(pwnd, FALSE);
        ENDATOMICCHECK();
    }

    if (gfade.hsprite == NULL)
        return FALSE;

    /*
     * Create a compatible bitmap for this size animation.
     */
    gfade.hbm = GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, size.cx, size.cy);
    if (gfade.hbm == NULL) {
        DeleteFadeSprite();
        return NULL;
    }

    GreSelectBitmap(gfade.hdc, gfade.hbm);

    /*
     * Mirror the hdc if it will be used to fade a mirrored window.
     */
    if ((pwnd != NULL) && TestWF(pwnd, WEFLAYOUTRTL)) {
        GreSetLayout(gfade.hdc , -1, LAYOUT_RTL);
    }

    /*
     * Since this isn't necessarily the first animation and the hdc could
     * be set to public, make sure the owner is the current process. This
     * way this process will be able to draw into it.
     */
    GreSetDCOwner(gfade.hdc, OBJECT_OWNER_CURRENT);

    /*
     * Initialize all other fade animation data.
     */
    gfade.ptDst.x = prc->left;
    gfade.ptDst.y = prc->top;
    gfade.size.cx = size.cx;
    gfade.size.cy = size.cy;
    gfade.dwTime = dwTime;
    gfade.dwFlags |= dwFlags;
#ifdef MOUSE_IP
    if (gfade.dwFlags & FADE_COLORKEY) {
        gfade.crColorKey = COLORKEY_COLOR;
    } else {
        gfade.crColorKey = 0;
    }
#endif

    return gfade.hdc;
}

/***************************************************************************\
* ShowFade
*
* GDI says that for alpha fade-out it's more efficient to do the first
* show as opaque alpha instead of using ULW_OPAQUE.
\***************************************************************************/

#define ALPHASTART 40

void ShowFade(void)
{
    BLENDFUNCTION blend;
    POINT ptSrc;
    BOOL fShow;

    UserAssert(gfade.hdc != NULL);
    UserAssert(gfade.hbm != NULL);

    if (gfade.dwFlags & FADE_SHOWN)
        return;

    fShow = (gfade.dwFlags & FADE_SHOW);
    ptSrc.x = ptSrc.y = 0;
    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = fShow ? ALPHASTART : (255 - ALPHASTART);
    UpdateFade(&gfade.ptDst, &gfade.size, gfade.hdc, &ptSrc, &blend);

    gfade.dwFlags |= FADE_SHOWN;
}

/***************************************************************************\
* StartFade
*
* 2/5/1998   vadimg          created
\***************************************************************************/

void StartFade(void)
{
    DWORD dwTimer = 10;
    DWORD dwElapsed;

    UserAssert(gfade.hdc != NULL);
    UserAssert(gfade.hbm != NULL);

    /*
     * Set dc and bitmap to public so the desktop thread can use them.
     */
    GreSetDCOwner(gfade.hdc, OBJECT_OWNER_PUBLIC);
    GreSetBitmapOwner(gfade.hbm, OBJECT_OWNER_PUBLIC);

    /*
     * If it's not already shown, do the initial update that makes copy of
     * the source. All other updates will only need to change the alpha value.
     */
    ShowFade();

    /*
     * Get the start time for the fade animation.
     */
    dwElapsed = (gfade.dwTime * ALPHASTART + 255) / 255;
    gfade.dwStart = NtGetTickCount() - dwElapsed;

    /*
     * Set the timer in the desktop thread. This will insure that the
     * animation is smooth and won't get stuck if the current thread hangs.
     */
#ifdef MOUSE_IP
    if (gfade.dwFlags & FADE_SONAR) {
        /*
         * Sonar requires slower timer.
         */
        dwTimer = MOUSE_SONAR_RADIUS_TIMER;
    }
#endif
    InternalSetTimer(gTermIO.spwndDesktopOwner, IDSYS_FADE, dwTimer,
            xxxSystemTimerProc, TMRF_SYSTEM | TMRF_PTIWINDOW);
}

/***************************************************************************\
* StopFade
*
* 2/5/1998   vadimg          created
\***************************************************************************/

void StopFade(void)
{
    DWORD dwRop=SRCCOPY;
    PWND pwnd;

    UserAssert(gfade.hdc != NULL);
    UserAssert(gfade.hbm != NULL);

    /*
     * Stop the fade animation timer.
     */
    _KillSystemTimer(gTermIO.spwndDesktopOwner, IDSYS_FADE);

    pwnd = DeleteFadeSprite();

    /*
     * If showing and the animation isn't completed, blt the last frame.
     */
    if (!(gfade.dwFlags & FADE_COMPLETED) && (gfade.dwFlags & FADE_SHOW)) {
        int x, y;
        HDC hdc;

        /*
         * For a windowed fade, make sure we observe the current visrgn.
         */
        if (pwnd != NULL) {
            hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_CACHE);
            x = 0;
            y = 0;
        } else {
            hdc = gpDispInfo->hdcScreen;
            x = gfade.ptDst.x;
            y = gfade.ptDst.y;
        }

        /*
         * If the destination DC is RTL mirrored, then BitBlt call should mirror the
         * content, since we want the menu to preserve it text (i.e. not to
         * be flipped). [samera]
         */
        if (GreGetLayout(hdc) & LAYOUT_RTL) {
            dwRop |= NOMIRRORBITMAP;
        }
        GreBitBlt(hdc, x, y, gfade.size.cx, gfade.size.cy, gfade.hdc, 0, 0, dwRop, 0);
        _ReleaseDC(hdc);
    }

    /*
     * Clean up the animation data.
     */
    GreSelectBitmap(gfade.hdc, GreGetStockObject(PRIV_STOCK_BITMAP));
    GreSetDCOwner(gfade.hdc, OBJECT_OWNER_PUBLIC);
    GreDeleteObject(gfade.hbm);

    gfade.hbm = NULL;
    gfade.dwFlags = 0;
}

/***************************************************************************\
* AnimateFade
*
* 2/5/1998   vadimg          created
\***************************************************************************/

void AnimateFade(void)
{
    DWORD dwTimeElapsed;
    BLENDFUNCTION blend;
    BYTE bAlpha;
    BOOL fShow;

    UserAssert(gfade.hdc != NULL);
    UserAssert(gfade.hbm != NULL);

    dwTimeElapsed = NtGetTickCount() - gfade.dwStart;

    /*
     * If exceeding the allowed time, stop the animation now.
     */
    if (dwTimeElapsed > gfade.dwTime) {
        StopFade();
        return;
    }

    fShow = (gfade.dwFlags & FADE_SHOW);

    /*
     * Calculate new alpha value based on time elapsed.
     */
    if (fShow) {
        bAlpha = (BYTE)((255 * dwTimeElapsed) / gfade.dwTime);
    } else {
        bAlpha = (BYTE)(255 * (gfade.dwTime - dwTimeElapsed) / gfade.dwTime);
    }

    blend.BlendOp = AC_SRC_OVER;
    blend.BlendFlags = 0;
    blend.AlphaFormat = 0;
    blend.SourceConstantAlpha = bAlpha;

 #ifdef MOUSE_IP
    if (gfade.dwFlags & FADE_SONAR) {
        DrawSonar(gfade.hdc);
        UpdateFade(&gfade.ptDst, &gfade.size, gfade.hdc, (LPPOINT)&gZero.pt, NULL);
        giSonarRadius -= MOUSE_SONAR_RADIUS_DELTA;
    } else {
        UpdateFade(NULL, NULL, NULL, NULL, &blend);
    }

    /*
     * Check if finished animating the fade.
     */
    if ((fShow && bAlpha == 255) || (!fShow && bAlpha == 0) || ((gfade.dwFlags & FADE_SONAR) && giSonarRadius < 0)) {
        gfade.dwFlags |= FADE_COMPLETED;
        StopFade();
    }
#else
    UpdateFade(NULL, NULL, NULL, NULL, &blend);

    /*
     * Check if finished animating the fade.
     */
    if ((fShow && bAlpha == 255) || (!fShow && bAlpha == 0)) {
        gfade.dwFlags |= FADE_COMPLETED;
        StopFade();
    }
#endif
}

/***************************************************************************\
* SetRedirectedWindow
*
* 1/27/99      vadimg      wrote
\***************************************************************************/

BOOL SetRedirectedWindow(PWND pwnd, UINT uFlags)
{
    HBITMAP hbmNew = NULL;
    PREDIRECT prdr;
    PCLS pcls;

    if (!TestWF(pwnd, WEFPREDIRECTED)) {
        /*
         * Setup the window for Redirection.  This will create a new bitmap to 
         * redirect drawing into, and then converting all HDC's to that window
         * to draw into that bitmap.  The contents of the bitmap will be copied
         * to the screen in UpdateRedirectedDC().
         */

        UserAssert(GetRedirectionBitmap(pwnd) == NULL);


        /*
         * NOTE: We can only redirect windows that don't use CS_CLASSDC or 
         * CS_PARENTDC.  This is because we need to setup a new to draw into
         * that is not the screen HDC.  When we do this, we explicitely mark 
         * the DC with DCX_REDIRECTED.  
         *
         * In the case of CS_CLASSDC or CS_PARENTDC, that DC may be shared 
         * between a redirected window and a non-redirected window, causing a 
         * conflict.
         *
         * This is not a problem for CS_OWNDC, since the window has its own
         * HDC that will not be shared.  It does however require that we setup
         * redirection after this HDC is already built.  This behavior was 
         * changed in Whistler (NT 5.1).
         */

        pcls = pwnd->pcls;
        if (TestCF2(pcls, CFPARENTDC) || TestCF2(pcls, CFCLASSDC)) {
            RIPMSG0(RIP_WARNING, "Can not enable redirection on CS_PARENTDC, or CS_CLASSDC window");
            return FALSE;
        }
        
        if ((hbmNew = CreateRedirectionBitmap(pwnd)) == NULL) {
            return FALSE;
        }

        ConvertRedirectionDCs(pwnd, hbmNew);
    }

    prdr = _GetProp(pwnd, PROP_LAYER, TRUE);
    prdr->uFlags |= uFlags;

#if DBG
    prdr->pwnd = pwnd;
#endif // DBG

    return TRUE;
}

/***************************************************************************\
* UnsetRedirectedWindow
*
* 1/27/1999        vadimg      created
\***************************************************************************/

VOID UnsetRedirectedWindow(PWND pwnd, UINT uFlags)
{
    if (TestWF(pwnd, WEFPREDIRECTED)) {
        PREDIRECT prdr = _GetProp(pwnd, PROP_LAYER, TRUE);

        prdr->uFlags &= ~uFlags;

        if (prdr->uFlags != 0) {
            return;
        }
    } else {
        return;
    }

    RemoveRedirectionBitmap(pwnd);
}

#ifdef CHILD_LAYERING

/***************************************************************************\
* GetNextLayeredWindow
*
* Preorder traversal of the window tree to find the next layering window
* below in zorder than pwnd. We need this because sprites are stored in a
* linked list. Note that this algorithm is iterative which is cool!
\***************************************************************************/

PWND GetNextLayeredWindow(PWND pwnd)
{
    while (TRUE) {
        if (pwnd->spwndChild != NULL) {
            pwnd = pwnd->spwndChild;
        } else if (pwnd->spwndNext != NULL) {
            pwnd = pwnd->spwndNext;
        } else {

            do {
                pwnd = pwnd->spwndParent;

                if (pwnd == NULL) {
                    return NULL;
                }

            } while (pwnd->spwndNext == NULL);

            pwnd = pwnd->spwndNext;
        }

        if (TestWF(pwnd, WEFLAYERED)) {
            return pwnd;
        }
    }
}

#endif // CHILD_LAYERING

/***************************************************************************\
* GetStyleWindow
*
\***************************************************************************/

PWND GetStyleWindow(PWND pwnd, DWORD dwStyle)
{
    while (pwnd != NULL) {
        if (TestWF(pwnd, dwStyle))
            break;

        pwnd = pwnd->spwndParent;
    }
    return pwnd;
}

/***************************************************************************\
* TrackLayeredZorder
*
* Unlike USER, GDI stores sprites from bottom to top.
\***************************************************************************/

void TrackLayeredZorder(PWND pwnd)
{
#ifdef CHILD_LAYERING

    PWND pwndT = GetNextLayeredWindow(pwnd);

#else // CHILD_LAYERING

    PWND pwndT = pwnd->spwndNext;

    while (pwndT != NULL) {

        if (TestWF(pwndT, WEFLAYERED))
            break;

        pwndT = pwndT->spwndNext;
    }

#endif // CHILD_LAYERING

    GreZorderSprite(gpDispInfo->hDev, PtoHq(pwnd), PtoH(pwndT));
}

/***************************************************************************\
* GetRedirectionBitmap
*
\***************************************************************************/

HBITMAP GetRedirectionBitmap(PWND pwnd)
{
    PREDIRECT prdr = _GetProp(pwnd, PROP_LAYER, TRUE);

    if (prdr != NULL) {
        return prdr->hbm;
    }
    return NULL;
}

/***************************************************************************\
* SetRedirectionBitmap
*
\***************************************************************************/

BOOL SetRedirectionBitmap(PWND pwnd, HBITMAP hbm)
{
    PREDIRECT prdr;

    if (hbm == NULL) {
        prdr = (PREDIRECT)InternalRemoveProp(pwnd, PROP_LAYER, TRUE);
        if (prdr != NULL) {
            UserFreePool(prdr);
        }
    } else {
        prdr = _GetProp(pwnd, PROP_LAYER, TRUE);
        if (prdr == NULL) {
            if ((prdr = (PREDIRECT)UserAllocPool(sizeof(REDIRECT),
                    TAG_REDIRECT)) == NULL) {
                return FALSE;
            }

            if (!InternalSetProp(pwnd, PROP_LAYER, (HANDLE)prdr, PROPF_INTERNAL)) {
                UserFreePool(prdr);
                return FALSE;
            }
        } else {
            DeleteMaybeSpecialRgn(prdr->hrgnComp);
        }

        prdr->hbm = hbm;
        prdr->uFlags = 0;
        prdr->hrgnComp = NULL;
        SetRectEmpty(&prdr->rcUpdate);
    }

    return TRUE;
}


#ifdef MOUSE_IP


CONST RECT rc = { 0, 0, MOUSE_SONAR_RADIUS_INIT * 2, MOUSE_SONAR_RADIUS_INIT * 2};

void DrawSonar(HDC hdc)
{
    HBRUSH  hbrBackground;
    HBRUSH  hbrRing, hbrOld;
    HPEN    hpen, hpenOld;

    hbrBackground = GreCreateSolidBrush(COLORKEY_COLOR);
    if (hbrBackground == NULL) {
        RIPMSG0(RIP_WARNING, "DrawSonar: failed to create background brush.");
        goto return0;
    }
    FillRect(hdc, &rc, hbrBackground);

    /*
     * Pen for the edges.
     */
    hpen = GreCreatePen(PS_SOLID, 0, RGB(255, 255, 255), NULL);
    if (hpen == NULL) {
        RIPMSG0(RIP_WARNING, "DrawSonar: failed to create pen.");
        goto return1;
    }
    hpenOld = GreSelectPen(hdc, hpen);

    /*
     * Draw the ring.
     */
    hbrRing = GreCreateSolidBrush(RGB(128, 128, 128));
    if (hbrRing == NULL) {
        goto return2;
    }
    hbrOld = GreSelectBrush(hdc, hbrRing);

    NtGdiEllipse(hdc, MOUSE_SONAR_RADIUS_INIT - giSonarRadius, MOUSE_SONAR_RADIUS_INIT - giSonarRadius,
                 MOUSE_SONAR_RADIUS_INIT + giSonarRadius, MOUSE_SONAR_RADIUS_INIT + giSonarRadius);

    /*
     * Draw innter hollow area (this draws inner edge as well).
     */
    GreSelectBrush(hdc, hbrBackground);
    NtGdiEllipse(hdc, MOUSE_SONAR_RADIUS_INIT - giSonarRadius + MOUSE_SONAR_LINE_WIDTH,
                      MOUSE_SONAR_RADIUS_INIT - giSonarRadius + MOUSE_SONAR_LINE_WIDTH,
                      MOUSE_SONAR_RADIUS_INIT + giSonarRadius - MOUSE_SONAR_LINE_WIDTH,
                      MOUSE_SONAR_RADIUS_INIT + giSonarRadius - MOUSE_SONAR_LINE_WIDTH);

    /*
     * Clean up things.
     */
    GreSelectBrush(hdc, hbrOld);
    UserAssert(hbrRing);
    GreDeleteObject(hbrRing);
return2:
    GreSelectPen(hdc, hpenOld);
    if (hpen) {
        GreDeleteObject(hpen);
    }

return1:
    if (hbrBackground) {
        GreDeleteObject(hbrBackground);
    }
return0:
    ;
}

/***************************************************************************\
* SonarAction
*
\***************************************************************************/

BOOL StartSonar()
{
    HDC hdc;
    RECT rc;

    UserAssert(TestUP(MOUSESONAR));

    gptSonarCenter = gpsi->ptCursor;

    /*
     * LATER: is this the right thing?
     */
    if (gfade.dwFlags) {
        /*
         * Some other animation is going on.
         * Stop it first.
         */
        UserAssert(!TestFadeFlags(FADE_SONAR));
        StopSonar();
        UserAssert(gfade.dwFlags == 0);
    }

    rc.left = gptSonarCenter.x - MOUSE_SONAR_RADIUS_INIT;
    rc.right = gptSonarCenter.x + MOUSE_SONAR_RADIUS_INIT;
    rc.top = gptSonarCenter.y - MOUSE_SONAR_RADIUS_INIT;
    rc.bottom = gptSonarCenter.y + MOUSE_SONAR_RADIUS_INIT;

    giSonarRadius = MOUSE_SONAR_RADIUS_INIT;

    hdc = CreateFade(NULL, &rc, CMS_SONARTIMEOUT, FADE_SONAR | FADE_COLORKEY);
    if (hdc == NULL) {
        RIPMSG0(RIP_WARNING, "StartSonar: failed to create a new sonar.");
        return FALSE;
    }

    /*
     * Start sonar animation.
     */
    DrawSonar(hdc);
    StartFade();
    AnimateFade();

    return TRUE;
}

void StopSonar()
{
    UserAssert(TestUP(MOUSESONAR));

    StopFade();
    giSonarRadius = -1;
}

#endif  // MOUSE_IP

/***************************************************************************\
* GetRedirectionFlags
*
* GetRedirectionFlags returns the current redirection flags for a given
* window.
*
* 2/8/2000      JStall          created
\***************************************************************************/

UINT GetRedirectionFlags(PWND pwnd)
{
    PREDIRECT prdr = _GetProp(pwnd, PROP_LAYER, TRUE);
    if (prdr != NULL) {
        return prdr->uFlags;
    }

    return 0;
}


/***************************************************************************\
* xxxPrintWindow
*
* xxxPrintWindow uses redirection to get a complete bitmap of a window.
* If the window already has a redirection bitmap, the bits will be directly
* copied.  If the window doesn't have a redirection bitmap, it will be
* temporarily redirected, forcably redrawn, and then returned to its
* previous state.
*
* 2/8/2000      JStall          created
\***************************************************************************/

BOOL
xxxPrintWindow(PWND pwnd, HDC hdcBlt, UINT nFlags)
{
    HDC hdcSrc;
    SIZE sizeBmpPxl;
    POINT ptOffsetPxl;
    BOOL fTempRedir = FALSE;
    BOOL fSuccess = TRUE;

    CheckLock(pwnd);

    /*
     * Determine the area of the window to copy.
     */
    if ((nFlags & PW_CLIENTONLY) != 0) {
        /*
         * Only get the client area
         */
        ptOffsetPxl.x = pwnd->rcWindow.left - pwnd->rcClient.left;
        ptOffsetPxl.y = pwnd->rcWindow.top - pwnd->rcClient.top;
        sizeBmpPxl.cx = pwnd->rcClient.right - pwnd->rcClient.left;
        sizeBmpPxl.cy = pwnd->rcClient.bottom - pwnd->rcClient.top;
    } else {
        /*
         * Return the entire window
         */
        ptOffsetPxl.x = 0;
        ptOffsetPxl.y = 0;
        sizeBmpPxl.cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
        sizeBmpPxl.cy = pwnd->rcWindow.bottom - pwnd->rcWindow.top;
    }

    /*
     * Redirect the window so that we can get the bits.  Since this flag never
     * is turned on outside this function call, always safe to turn it on here.
     */
    fTempRedir = (GetRedirectionFlags(pwnd) == 0);

    if (!SetRedirectedWindow(pwnd, REDIRECT_PRINT)) {
        /*
         * Unable to redirect the window, so can't get the bits.
         */

        fSuccess = FALSE;
        goto Done;
    }

    if (fTempRedir) {
        xxxUpdateWindow(pwnd);
    }

    hdcSrc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_CACHE);
    GreBitBlt(hdcBlt, 0, 0, sizeBmpPxl.cx, sizeBmpPxl.cy,
            hdcSrc, ptOffsetPxl.x, ptOffsetPxl.y, SRCCOPY | NOMIRRORBITMAP, 0);
    _ReleaseDC(hdcSrc);

    /*
     * Cleanup
     */
    UnsetRedirectedWindow(pwnd, REDIRECT_PRINT);

Done:
    return fSuccess;
}


/***************************************************************************\
* xxxEnumTurnOffCompositing
*
* xxxEnumTurnOffCompositing() is called for each window, giving an
* opportunity to turn off WS_EX_COMPOSITED for that window.
*
* 8/21/2000     JStall          created
\***************************************************************************/

BOOL APIENTRY xxxEnumTurnOffCompositing(PWND pwnd, LPARAM lParam)
{
    CheckLock(pwnd);

    UNREFERENCED_PARAMETER(lParam);

    if (TestWF(pwnd, WEFCOMPOSITED)) {
        DWORD dwStyle = (pwnd->ExStyle & ~WS_EX_COMPOSITED) & WS_EX_ALLVALID;
        xxxSetWindowStyle(pwnd, GWL_EXSTYLE, dwStyle);
    }

    return TRUE;
}


/***************************************************************************\
* xxxTurnOffCompositing
*
* xxxTurnOffCompositing() turns off WS_EX_COMPOSITED for (optionally a
* PWND and) its children.  This is used when reparenting under
* a parent-chain that has WS_EX_COMPOSITED already turned on.  If we don't
* turn off WS_EX_COMPOSITED for the children, it takes extra bitmaps and the
* compositing will not properly work.
*
* 8/21/2000     JStall          created
\***************************************************************************/

void
xxxTurnOffCompositing(PWND pwndStart, BOOL fChild)
{
    TL tlpwnd;
    UINT nFlags = BWL_ENUMCHILDREN;

    CheckLock(pwndStart);

    /*
     * If they want to skip over the wnd itself and start with this WND's
     * child, we need to get and lock that child.  We will unlock it when
     * finished.  We also need to mark BWL_ENUMLIST so that we will enumerate
     * all of the children.
     */
    if (fChild) {
        pwndStart = pwndStart->spwndChild;
        if (pwndStart == NULL) {
            return;
        }
        nFlags |= BWL_ENUMLIST;

        ThreadLockAlways(pwndStart, &tlpwnd);
    }


    /*
     * Enumerate the windows.
     */
    xxxInternalEnumWindow(pwndStart, xxxEnumTurnOffCompositing, 0, nFlags);

    if (fChild) {
        ThreadUnlock(&tlpwnd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\taskman.c ===
/****************************** Module Header ******************************\
* Module Name: taskman.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the core functions of the input sub-system
*
* History:
* 02-27-91 MikeHar      Created.
* 02-23-92 MattFe       rewrote sleeptask
* 09-07-93 DaveHart     Per-process nonpreemptive scheduler for
*                       multiple WOW VDM support.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* WakeWowTask
*
* If needed the wowtask is woken by setting its event. It is assumed that if
* any wow task is currently scheduled that it is a waste of time to wake the
* specified wow task since rescheduling will occur when the currently
* scheduled wow task enters xxxSleepTask.
*
* History:
* ????
\***************************************************************************/
VOID
WakeWowTask(
   PTHREADINFO pti)
{
   PWOWPROCESSINFO pwpi;

   pwpi = pti->ppi->pwpi;
   if (pwpi && !pwpi->ptiScheduled) {
       KeSetEvent(pti->pEventQueueServer, EVENT_INCREMENT, FALSE);
       }
}


/***************************************************************************\
* InsertTask
*
* This function removes a task from its old location and inserts
* in the proper prioritized location
*
* Find a place for this task such that it must be inserted
* after any task with greater or equal priority and must be
* before any task with higher priorty.  The higher the priority
* the less urgent the task.
*
* History:
* 19-Nov-1993 mikeke    Created
\***************************************************************************/
VOID InsertTask(
    PPROCESSINFO ppi,
    PTDB ptdbNew)
{
    PTDB *pptdb;
    PTDB ptdb;
    int nPriority;
    PWOWPROCESSINFO pwpi = ppi->pwpi;

    CheckCritIn();

    UserAssert(pwpi != NULL);

    pptdb = &pwpi->ptdbHead;
    nPriority = ptdbNew->nPriority;

    while ((ptdb = *pptdb) != NULL) {
        /*
         * Remove it from it's old location
         */
        if (ptdb == ptdbNew) {
            *pptdb = ptdbNew->ptdbNext;

            /*
             * continue to search for the place to insert it
             */
            while ((ptdb = *pptdb) != NULL) {
                if (nPriority < ptdb->nPriority) {
                    break;
                }

                pptdb = &(ptdb->ptdbNext);
            }
            break;
        }

        /*
         * if this is the place to insert continue to search for the
         * place to delete it from
         */
        if (nPriority < ptdb->nPriority) {
            do {
                if (ptdb->ptdbNext == ptdbNew) {
                    ptdb->ptdbNext = ptdbNew->ptdbNext;
                    break;
                }
                ptdb = ptdb->ptdbNext;
            } while (ptdb != NULL);
            break;
        }

        pptdb = &(ptdb->ptdbNext);
    }

    /*
     * insert the new task
     */
    ptdbNew->ptdbNext = *pptdb;
    *pptdb = ptdbNew;
}


/***************************************************************************\
* DestroyTask()
*
* History:
* 02-27-91 MikeHar      Created.
\***************************************************************************/
VOID DestroyTask(
    PPROCESSINFO ppi,
    PTHREADINFO ptiToRemove)
{
    PTDB ptdbToRemove = ptiToRemove->ptdb;
    PTDB ptdb;
    PTDB* pptdb;
    PWOWPROCESSINFO pwpi = ppi->pwpi;

    // try to catch #150446
    CheckCritIn();
    BEGINATOMICCHECK();

    UserAssert(pwpi != NULL);

    if (ptdbToRemove != NULL) {

        if (ptdbToRemove->TDB_Flags & TDBF_SETUP) {
              /*
               * This means that the WoW app was a setup app (checked in SetAppCompatFlags).
               * If so, the shell needs to be notified so it can clean up potential problems
               * caused by bad calls to DDE, etc.   FritzS
               */
            PDESKTOPINFO pdeskinfo = GETDESKINFO(ptiToRemove);
            if (pdeskinfo->spwndShell) {
                _PostMessage(pdeskinfo->spwndShell, DTM_SETUPAPPRAN, 0, 0);
            }
        }
        /*
         * Remove the WOW per thread info
         */
        if (ptdbToRemove->pwti) {
            PWOWTHREADINFO *ppwti = &gpwtiFirst;
            while (*ppwti != ptdbToRemove->pwti && (*ppwti)->pwtiNext != NULL) {
                ppwti = &((*ppwti)->pwtiNext);
            }
            if (*ppwti == ptdbToRemove->pwti) {
                 *ppwti = ptdbToRemove->pwti->pwtiNext;
            }
            CLOSE_PSEUDO_EVENT(&ptdbToRemove->pwti->pIdleEvent);
            UserFreePool(ptdbToRemove->pwti);
        }

        gpsi->nEvents -= ptdbToRemove->nEvents;

        /*
         * remove it from any lists
         */
        pptdb = &pwpi->ptdbHead;
        while ((ptdb = *pptdb) != NULL) {
            /*
             * Remove it from it's old location
             */
            if (ptdb == ptdbToRemove) {
                *pptdb = ptdb->ptdbNext;
                UserFreePool(ptdbToRemove);
                UserAssert(ptiToRemove->ptdb == ptdbToRemove);
                ptiToRemove->ptdb = NULL;
                break;
            }
            pptdb = &(ptdb->ptdbNext);
        }
        UserAssert(ptdb == ptdbToRemove);  // #150446 check that we actually found it
    }
    ENDATOMICCHECK(); // #150446

    /*
     * If the task being destroyed is the active task, make nobody active.
     * We will go through this code path for 32-bit threads that die while
     * Win16 threads are waiting for a SendMessage reply from them.
     */
    if (pwpi->ptiScheduled == ptiToRemove) {
        pwpi->ptiScheduled = NULL;
        ExitWowCritSect(ptiToRemove, pwpi);

        /*
         * If this active task was locked, remove lock so next guy can
         * run.
         */
        pwpi->nTaskLock = 0;


        /*
         * Wake next task with events, or wowexec to run the scheduler
         */
        if (pwpi->ptdbHead != NULL) {
            PTDB ptdb;

            for (ptdb = pwpi->ptdbHead; ptdb; ptdb = ptdb->ptdbNext) {
                if (ptdb->nEvents > 0) {
                    KeSetEvent(ptdb->pti->pEventQueueServer,
                               EVENT_INCREMENT, FALSE);
                    break;
                }
            }

            if (!ptdb) {
                KeSetEvent(pwpi->pEventWowExec, EVENT_INCREMENT, FALSE);
            }
        }
    }
    UserAssert(ptiToRemove != pwpi->CSOwningThread);

}




/***************************************************************************\
* xxxSleepTask
*
* This function puts this task to sleep and wakes the next (if any)
* deserving task.
*
* BOOL   fInputIdle  - app is going idle, may do idle hooks
* HANDLE hEvent      - if nonzero, WowExec's event (client side) for
*                      virtual HW Interrupt HotPath.
* History:
* 02-27-91 MikeHar      Created.
* 02-23-91 MattFe       rewrote
* 12-17-93 Jonle        add wowexec hotpath for VirtualInterrupts
\***************************************************************************/

BOOL xxxSleepTask(
    BOOL   fInputIdle,
    HANDLE hEvent)
{
    PTDB ptdb;
    PTHREADINFO     pti;
    PPROCESSINFO    ppi;
    PWOWPROCESSINFO pwpi;
    PSMS            psms;
    NTSTATUS Status;
    int    nHandles;
    BOOLEAN bWaitedAtLeastOnce;

    /*
     * !!!
     * ClearSendMessages assumes that this function does NOT leave the
     * critical section when called with fInputIdle==FALSE and from a
     * 32bit thread!
     */

    CheckCritIn();

    pti  = PtiCurrent();
    ppi  = pti->ppi;
    pwpi = ppi->pwpi;

    /*
     *  If this task has received a message from outside of the current
     *  wow scheduler and hasn't yet replied to the message, the scheduler
     *  will deadlock because the send\receive lock counts are updated
     *  in ReplyMessage and not in receive message. Check for this
     *  condition and do the DirectedSchedukeTask that normally occurs
     *  in ReplyMessage. 16-Feb-1995 Jonle
     */
    psms = pti->psmsCurrent;
    if (psms && psms->ptiReceiver == pti &&
            psms->ptiSender && !(psms->flags & SMF_REPLY) &&
            psms->flags & (SMF_RECEIVERBUSY | SMF_RECEIVEDMESSAGE) &&
            psms->ptiSender->TIF_flags & TIF_16BIT &&
            (pwpi != psms->ptiSender->ppi->pwpi || !(pti->TIF_flags & TIF_16BIT)) ) {
        DirectedScheduleTask(psms->ptiReceiver, psms->ptiSender, FALSE, psms);
    }


    /*
     * return immediately if we are not 16 bit (don't have a pwpi)
     */
    if (!(pti->TIF_flags & TIF_16BIT)) {
        return FALSE;
    }


    /*
     *  Deschedule the current task
     */
    if (pti == pwpi->ptiScheduled) {
        ExitWowCritSect(pti, pwpi);
        if (!pwpi->nTaskLock) {
            pwpi->ptiScheduled = NULL;
            }
        }
    UserAssert(pti != pwpi->CSOwningThread);


    /*
     *  If this is wowexec calling on WowWaitForMsgAndEvent
     *  set up the WakeMask for all messages , and check for wake
     *  bits set since the last time. Reinsert wowexec, at the end
     *  of the list so other 16 bit tasks will be scheduled first.
     */
    if (pwpi->hEventWowExecClient == hEvent) {
        InsertTask(ppi, pti->ptdb);
        pti->pcti->fsWakeMask = QS_ALLINPUT | QS_EVENT;
        if (pti->pcti->fsChangeBits & pti->pcti->fsWakeMask) {
            pti->ptdb->nEvents++;
            gpsi->nEvents++;
        }
    }


    bWaitedAtLeastOnce = FALSE;

    do {

        /*
         * If nobody is Active look for the highest priority task with
         * some events pending. if MsgWaitForMultiple call don't
         * reschedule self
         */

        if (pwpi->ptiScheduled == NULL) {
rescan:
            if (pwpi->nRecvLock >= pwpi->nSendLock) {
                for (ptdb = pwpi->ptdbHead; ptdb; ptdb = ptdb->ptdbNext) {
                    if (ptdb->nEvents > 0 &&
                            !(hEvent == HEVENT_REMOVEME && ptdb->pti == pti)) {
                        pwpi->ptiScheduled = ptdb->pti;
                        break;
                    }
                }

                if (bWaitedAtLeastOnce) {
                    //
                    // If not first entry into sleep task avoid waiting
                    // more than needed, if the curr task is now scheduled.
                    //
                    if (pwpi->ptiScheduled == pti) {
                        break;
                    }

                } else {
                    //
                    // On the first entry into sleep task input is going
                    // idle if no tasks are ready to run. Call the idle
                    // hook if there is one.
                    //
                    if (fInputIdle &&
                            pwpi->ptiScheduled == NULL &&
                            IsHooked(pti, WHF_FOREGROUNDIDLE)) {

                        /*
                         * Make this the active task so that no other
                         * task will become active while we're calling
                         * the hook.
                         */
                        pwpi->ptiScheduled = pti;
                        xxxCallHook(HC_ACTION, 0, 0, WH_FOREGROUNDIDLE);

                        /*
                         * Reset state so that no tasks are active.  We
                         * then need to rescan the task list to see if
                         * a task was scheduled during the call to the
                         * hook.  Clear the input idle flag to ensure
                         * that the hook won't be called again if there
                         * are no tasks ready to run.
                         */
                        pwpi->ptiScheduled = NULL;
                        fInputIdle = FALSE;
                        goto rescan;
                    }
                }
            }


            /*
             * If there is a task ready, wake it up.
             */
            if (pwpi->ptiScheduled != NULL) {
                KeSetEvent(pwpi->ptiScheduled->pEventQueueServer,
                           EVENT_INCREMENT,
                           FALSE
                           );

            /*
             *  There is no one to wake up, but we may have to wake
             *  wowexec to service virtual hardware interrupts
             */
            } else if (ppi->W32PF_Flags & W32PF_WAKEWOWEXEC) {
                if (pwpi->hEventWowExecClient == hEvent) {
                    pwpi->ptiScheduled = pti;
                    ppi->W32PF_Flags &= ~W32PF_WAKEWOWEXEC;
                    InsertTask(ppi, pti->ptdb);
                    EnterWowCritSect(pti, pwpi);
                    UserAssert(pti == pwpi->ptiScheduled);
                    return TRUE;
                } else {
                    KeSetEvent(pwpi->pEventWowExec, EVENT_INCREMENT, FALSE);
                }
            } else if ((pti->TIF_flags & TIF_SHAREDWOW) && !bWaitedAtLeastOnce) {
                if (pwpi->hEventWowExecClient == hEvent) {
                    /*
                     * We have to call zzzWakeInputIdle only if this will
                     * awake WowExec's thread and not other thread. Bug 44060.
                     */
                    zzzWakeInputIdle(pti); // need to DeferWinEventNotify() ?? IANJA ??
                }
            }

        } else if (pwpi->nTaskLock > 0 && pwpi->ptiScheduled == pti
                   && pti->ptdb->nEvents > 0) {
             KeSetEvent(pwpi->ptiScheduled->pEventQueueServer,
                    EVENT_INCREMENT, FALSE);
        }
        /*
         *  return if we are a 32 bit thread, or if we were called by
         *  MsgWaitForMultiple to exit the wow scheduler
         */
        if (!(pti->TIF_flags & TIF_16BIT)) {
            return FALSE;
        } else if (hEvent == HEVENT_REMOVEME) {
            InsertTask(ppi, pti->ptdb);
            KeClearEvent(pti->pEventQueueServer);
            return FALSE;
        }

        if (pti->apEvent == NULL) {
            pti->apEvent = UserAllocPoolNonPaged(POLL_EVENT_CNT * sizeof(PKEVENT), TAG_EVENT);
            if (pti->apEvent == NULL)
                return FALSE;
        }

        /*
         * Wait for input to this thread.
         */
        pti->apEvent[IEV_TASK] = pti->pEventQueueServer;

        /*
         * Add the WowExec, handle for virtual hw interrupts
         */
        if (pwpi->hEventWowExecClient == hEvent) {
            pti->apEvent[IEV_WOWEXEC] = pwpi->pEventWowExec;
            nHandles = 2;
        } else {
            nHandles = 1;
        }

	if (pti->TIF_flags & TIF_MEOW) {
	    xxxClientWOWTask16SchedNotify(WOWSCHNOTIFY_WAIT, 0);
	}

        LeaveCrit();
        Status = KeWaitForMultipleObjects(nHandles,
                                          &pti->apEvent[IEV_TASK],
                                          WaitAny,
                                          WrUserRequest,
                                          UserMode,
                                          TRUE,
                                          NULL,
                                          NULL);

        EnterCrit();

        if (pti->TIF_flags & TIF_MEOW) {
	    xxxClientWOWTask16SchedNotify(WOWSCHNOTIFY_RUN, 0);
	}


        bWaitedAtLeastOnce = TRUE;

        // remember if we woke up for wowexec
        if (Status == STATUS_WAIT_1) {
            ppi->W32PF_Flags |= W32PF_WAKEWOWEXEC;
        } else if (Status == STATUS_USER_APC) {

            /*
             * An alert was received.  This should only occur when the
             * thread has been terminated.
             * ClientDeliverUserApc() delivers User-mode APCs by calling back
             * to the client and immediately returning without doing anything:
             * KeUserModeCallback will automatically deliver any pending APCs.
             */
            UserAssert(PsIsThreadTerminating(PsGetCurrentThread()));
            ClientDeliverUserApc();
        }

    } while (pwpi->ptiScheduled != pti);


    /*
     * We are the Active Task, reduce number of Events
     * Place ourselves at the far end of tasks in the same priority
     * so that next time we sleep someone else will run.
     */
    pti->ptdb->nEvents--;
    gpsi->nEvents--;
    UserAssert(gpsi->nEvents >= 0);

    InsertTask(ppi, pti->ptdb);

    ppi->W32PF_Flags &= ~W32PF_WAKEWOWEXEC;

    EnterWowCritSect(pti, pwpi);
    UserAssert(pti == pwpi->ptiScheduled);



    return FALSE;
}



/***************************************************************************\
* xxxUserYield
*
* Does exactly what Win3.1 UserYield does.
*
* History:
* 10-19-92 Scottlu      Created.
\***************************************************************************/

BOOL xxxUserYield(
    PTHREADINFO pti)
{
    PPROCESSINFO ppi = pti->ppi;

    /*
     * Deal with any pending messages. Only call it this first time if
     * this is the current running 16 bit app. In the case when starting
     * up a 16 bit app, the starter calls UserYield() to yield to the new
     * task, but at this time ppi->ptiScheduled is set to the new task.
     * Receiving messages at this point would be bad!
     */
    if (pti->TIF_flags & TIF_16BIT) {
        if (pti == ppi->pwpi->ptiScheduled) {
            xxxReceiveMessages(pti);
        }
    } else {
        xxxReceiveMessages(pti);
    }

    /*
     * If we are a 16 bit task
     * Mark our task so it comes back some time.  Also, remove it and
     * re-add it to the list so that we are the last task of our priority
     * to run.
     */
    if ((pti->TIF_flags & TIF_16BIT) && (pti->ptdb != NULL)) {
       if (pti->ptdb->nEvents == 0) {
            pti->ptdb->nEvents++;
            gpsi->nEvents++;
        }
        InsertTask(ppi, pti->ptdb);

        /*
         * Sleep.  Return right away if there are no higher priority tasks
         * in need of running.
         */
        xxxSleepTask(TRUE, NULL);

        /*
         * Deal with any that arrived since we weren't executing.
         */
        xxxReceiveMessages(pti);
    }


    return TRUE;
}


/***************************************************************************\
* DirectedScheduleTask
*
* History:
* 25-Jun-1992 mikeke    Created.
\***************************************************************************/
VOID DirectedScheduleTask(
     PTHREADINFO ptiOld,
     PTHREADINFO ptiNew,
     BOOL bSendMsg,
     PSMS psms)
{
    PWOWPROCESSINFO pwpiOld;
    PWOWPROCESSINFO pwpiNew;

    CheckCritIn();

    pwpiOld  = ptiOld->ppi->pwpi;
    pwpiNew  = ptiNew->ppi->pwpi;


    /*
     * If old task is 16 bit, reinsert the task in its wow scheduler list
     * so that it is lowest in priority. Note that ptiOld is always the
     * same as pwpiOld->ptiScheduled except when called from ReceiverDied.
     */
    if (ptiOld->TIF_flags & TIF_16BIT) {

        if (pwpiOld->ptiScheduled == ptiOld) {
            ptiOld->ptdb->nEvents++;
            gpsi->nEvents++;
            InsertTask(ptiOld->ppi, ptiOld->ptdb);
            }


        // Update the Send\Recv counts for interprocess scheduling in SleepTask

        if (pwpiOld != pwpiNew || !(ptiNew->TIF_flags & TIF_16BIT)) {
            if (bSendMsg) {
                pwpiOld->nSendLock++;
                psms->flags |= SMF_WOWSEND;
                }
            else if (pwpiOld->nRecvLock && psms->flags & SMF_WOWRECEIVE) {
                pwpiOld->nRecvLock--;
                psms->flags &= ~SMF_WOWRECEIVE;
                }
            }

        }


    /*
     *  If the new task is 16 bit, reinsert into the wow scheduler list
     *  so that it will run, if its a sendmsg raise priority of the receiver.
     *  If its a reply and the sender is waiting for this psms or the sender
     *  has a message to reply to raise priority of the sender.
     */
    if (ptiNew->TIF_flags & TIF_16BIT) {
        BOOL bRaisePriority;

        ptiNew->ptdb->nEvents++;
        gpsi->nEvents++;
        bRaisePriority = bSendMsg || psms == ptiNew->psmsSent;

        if (bRaisePriority) {
            ptiNew->ptdb->nPriority--;
            }

        InsertTask(ptiNew->ppi, ptiNew->ptdb);

        if (bRaisePriority) {
            ptiNew->ptdb->nPriority++;
            WakeWowTask(ptiNew);
            }


        // Update the Send\Recv counts for interprocess scheduling in SleepTask

        if (pwpiOld != pwpiNew || !(ptiOld->TIF_flags & TIF_16BIT)) {
            if (bSendMsg) {
                pwpiNew->nRecvLock++;
                psms->flags |= SMF_WOWRECEIVE;
                }
            else if (pwpiNew->nSendLock && psms->flags & SMF_WOWSEND) {
                pwpiNew->nSendLock--;
                psms->flags &= ~SMF_WOWSEND;
                }
            }

        }
}




/***************************************************************************\
* xxxDirectedYield
*
* History:
* 09-17-92 JimA         Created.
\***************************************************************************/
VOID xxxDirectedYield(
    DWORD dwThreadId)
{
    PTHREADINFO ptiOld;
    PTHREADINFO ptiNew;

    CheckCritIn();

    ptiOld = PtiCurrent();
    if (!(ptiOld->TIF_flags & TIF_16BIT) || !ptiOld->ppi->pwpi) {
         RIPMSG0(RIP_ERROR, "DirectedYield called from 32 bit thread!");
         return;
         }

    /*
     *  If the old task is 16 bit, reinsert the task in its wow
     *  scheduler list so that it is lowest in priority.
     */
    ptiOld->ptdb->nEvents++;
    gpsi->nEvents++;
    InsertTask(ptiOld->ppi, ptiOld->ptdb);

    /*
     * -1 supports Win 3.1 OldYield mechanics
     */
    if (dwThreadId != DY_OLDYIELD) {

        ptiNew = PtiFromThreadId(dwThreadId);
        if (ptiNew == NULL)
            return;

        if (ptiNew->TIF_flags & TIF_16BIT) {
            ptiNew->ptdb->nEvents++;
            gpsi->nEvents++;
            ptiNew->ptdb->nPriority--;
            InsertTask(ptiNew->ppi, ptiNew->ptdb);
            ptiNew->ptdb->nPriority++;
        }
    }

    xxxSleepTask(TRUE, NULL);
}


/***************************************************************************\
* CurrentTaskLock
*
* Lock the current 16 bit task into the 16 bit scheduler
*
* Parameter:
*   hlck    if NULL, lock the current 16 bit task and return a lock handle
*           if valid lock handle, unlock the current task
*
* History:
* 13-Apr-1992 jonpa      Created.
\***************************************************************************/
#if 0 /* WOW is not using this but they might some day */
DWORD CurrentTaskLock(
    DWORD hlck)
{
    PWOWPROCESSINFO pwpi = PpiCurrent()->pwpi;

    if (!pwpi)
        return 0;

    if (hlck == 0) {
        pwpi->nTaskLock++;
        return ~(DWORD)pwpi->ptiScheduled->ptdb;
    } else if ((~hlck) == (DWORD)pwpi->ptiScheduled->ptdb) {
        pwpi->nTaskLock--;
    }

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\sysmet.c ===
/****************************** Module Header ******************************\
* Module Name: sysmet.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* System metrics APIs and support routines.
*
* History:
* 24-Sep-1990 DarrinM   Generated stubs.
* 12-Feb-1991 JimA      Added access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _SwapMouseButton (API)
*
* History:
* 24-Sep-1990 DarrinM   Generated stubs.
* 25-Jan-1991 DavidPe   Did the real thing.
* 12-Feb-1991 JimA      Added access check
\***************************************************************************/

BOOL APIENTRY _SwapMouseButton(
    BOOL fSwapButtons)
{
    BOOL            fSwapOld;
    PPROCESSINFO    ppiCurrent = PpiCurrent();

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    RETURN_IF_ACCESS_DENIED(ppiCurrent->amwinsta,
                            WINSTA_READATTRIBUTES | WINSTA_WRITEATTRIBUTES,
                            FALSE);

    if (!(ppiCurrent->W32PF_Flags & W32PF_IOWINSTA)) {
        RIPERR0(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION,
                RIP_WARNING,
                "SwapMouseButton invalid on a non-interactive WindowStation.");

        return FALSE;
    }

    fSwapOld = SYSMET(SWAPBUTTON);
    SYSMET(SWAPBUTTON) = fSwapButtons;

    /*
     * Give xxxButtonEvent a hint that a mouse button event may have to be
     * left/right swapped to correspond with our current async key state.
     * Toggle the global since an even number of SwapMouseButtons has no effect.
     */
    if (fSwapButtons != fSwapOld) {
        gbMouseButtonsRecentlySwapped = !gbMouseButtonsRecentlySwapped;
    }

    /*
     * Return previous state
     */
    return fSwapOld;
}

/***************************************************************************\
* _SetDoubleClickTime (API)
*
* History:
* 24-Sep-1990 DarrinM   Generated stubs.
* 25-Jan-1991 DavidPe   Did the real thing.
* 12-Feb-1991 JimA      Added access check
* 16-May-1991 MikeKe    Changed to return BOOL
\***************************************************************************/

BOOL APIENTRY _SetDoubleClickTime(
    UINT dtTime)
{
    PWINDOWSTATION pwinsta = PpiCurrent()->rpwinsta;

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if (!CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    if (!dtTime) {
        dtTime = 500;
    } else if (dtTime > 5000) {
        dtTime = 5000;
    }

    gdtDblClk         = dtTime;
    gpsi->dtLBSearch = dtTime * 4;            // dtLBSearch   =  4  * gdtDblClk
    gpsi->dtScroll   = gpsi->dtLBSearch / 5;  // dtScroll     = 4/5 * gdtDblClk
    /*
     * This value should be set through SPI_SETMENUSHOWDELAY
     *   gdtMNDropDown     = gpsi->dtScroll;        // gdtMNDropDown = 4/5 * gdtDblClk
     */

    /*
     * Recalculate delays for tooltip windows on all desktops.
     */
    if (pwinsta != NULL) {
        PDESKTOP pdesk;
        for (pdesk = pwinsta->rpdeskList; pdesk; pdesk = pdesk->rpdeskNext) {
            InitTooltipDelay((PTOOLTIPWND)pdesk->spwndTooltip);
        }
    }

    return TRUE;
}

/***************************************************************************\
* SetSysColor()
*
* Changes the value of a system color, and updates the brush.  Tries to
* recover in case of an error.
*
* History:
\***************************************************************************/
VOID SetSysColor(
    UINT  icol,
    DWORD rgb,
    UINT  uOptions
    )
{

    gpsi->argbSystemUnmatched[icol] = rgb;

    if ((uOptions & SSCF_SETMAGICCOLORS) && gpDispInfo->fAnyPalette) {
        union {
            DWORD rgb;
            PALETTEENTRY pe;
        } peMagic;

        peMagic.rgb = rgb;

        /*
         *  when any of the 3D colors are changing, call GDI to
         *  set the apropiate "magic" color
         *
         *  the four magic colors are reserved like so
         *
         *  8       - UI color (3D shadow)
         *  9       - UI color (3D face)
         *
         *  F6      - UI color (3D hilight)
         *  F7      - UI color (desktop)
         *
         *  NOTE (3D hilight) inverts to (3D shadow)
         *       (3D face)    inverts to sys gray
         *
         */

        switch (icol)
        {
        case COLOR_3DSHADOW:
            GreSetMagicColors(gpDispInfo->hdcScreen, peMagic.pe, 8);
            break;

        case COLOR_3DFACE:
            GreSetMagicColors(gpDispInfo->hdcScreen, peMagic.pe, 9);
            break;

        case COLOR_3DHILIGHT:
            GreSetMagicColors(gpDispInfo->hdcScreen, peMagic.pe, 246);
            break;

        case COLOR_DESKTOP:
            GreSetMagicColors(gpDispInfo->hdcScreen, peMagic.pe, 247);
            break;
        }
    }

    if (uOptions & SSCF_16COLORS) {
        /*
         * Force solid colors for all elements in 16 color or less modes.
         */
        rgb = GreGetNearestColor(gpDispInfo->hdcScreen, rgb);
    } else if (uOptions & SSCF_FORCESOLIDCOLOR) {
        /*
         * Force solid colors for certain window elements.
         */
        switch (icol) {

        /*
         * These can be dithers
         */
        case COLOR_DESKTOP:
        case COLOR_ACTIVEBORDER:
        case COLOR_INACTIVEBORDER:
        case COLOR_APPWORKSPACE:
        case COLOR_INFOBK:
        case COLOR_GRADIENTACTIVECAPTION:
        case COLOR_GRADIENTINACTIVECAPTION:
            break;

        default:
            rgb = GreGetNearestColor(gpDispInfo->hdcScreen, rgb);
            break;
        }
    }

    gpsi->argbSystem[icol] = rgb;
    if (SYSHBRUSH(icol) == NULL) {
        /*
         * This is the first time we're setting up the system colors.
         * We need to create the brush
         */
        SYSHBRUSH(icol) = GreCreateSolidBrush(rgb);
        GreMarkUndeletableBrush(SYSHBRUSH(icol));
        GreSetBrushOwnerPublic(SYSHBRUSH(icol));
        GreSetBrushGlobal(SYSHBRUSH(icol));
    } else {
        GreSetSolidBrush(SYSHBRUSH(icol), rgb);
    }
}

/***************************************************************************\
* xxxSetSysColors (API)
*
*
* History:
* 12-Feb-1991 JimA      Created stub and added access check
* 22-Apr-1991 DarrinM   Ported from Win 3.1 sources.
* 16-May-1991 MikeKe    Changed to return BOOL
\***************************************************************************/
BOOL APIENTRY xxxSetSysColors(PUNICODE_STRING pProfileUserName,
    int      cicol,
    PUINT    picolor,
    COLORREF *prgb,
    UINT     uOptions
    )
{
    int      i;
    UINT     icol;
    COLORREF rgb;

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if ((uOptions & SSCF_NOTIFY) && !CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    if (GreGetDeviceCaps(gpDispInfo->hdcScreen, NUMCOLORS) <= 16) {
        uOptions |= SSCF_16COLORS;
    }

    if (uOptions & SSCF_SETMAGICCOLORS) {
        /*
         * Set the Magic colors first
         */
        for(i = 0; i < cicol; i++) {
            icol = picolor[i];
            rgb = prgb[i];
            if (    icol == COLOR_3DFACE ||
                    icol == COLOR_3DSHADOW ||
                    icol == COLOR_3DHILIGHT ||
                    icol == COLOR_DESKTOP) {

                SetSysColor(icol, rgb, uOptions);
            }
        }
    }

    for (i = 0; i < cicol; i++) {

        icol = *picolor++;
        rgb  = *prgb++;

        if (icol >= COLOR_MAX)
            continue;

        if ((uOptions & SSCF_SETMAGICCOLORS) &&
               (icol == COLOR_3DFACE ||
                icol == COLOR_3DSHADOW ||
                icol == COLOR_3DHIGHLIGHT ||
                icol == COLOR_DESKTOP)) {
            continue;
        }

        SetSysColor(icol, rgb, uOptions);
    }

    if (uOptions & SSCF_NOTIFY) {

        /*
         * Recolor all the current desktop
         */
        RecolorDeskPattern();

        /*
         * Render the system bitmaps in new colors before we broadcast
         */

        xxxSetWindowNCMetrics(pProfileUserName,NULL, FALSE, -1);


        /*
         * Notify everyone that the colors have changed.
         */
        xxxSendNotifyMessage(PWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0L);

        /*
         * Just redraw the entire screen.  Trying to just draw the parts
         * that were changed isn't worth it, since Control Panel always
         * resets every color anyway.
         *
         * Anyway, it could get messy, sending apps NCPAINT messages without
         * accumulating update regions too.
         */
        xxxRedrawScreen();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\tmswitch.c ===
/****************************** Module Header ******************************\
* Module Name: tmswitch.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 29-May-1991 DavidPe   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * COOLSWITCHTRACE is used to trace problems
 * in the CoolSwitch window
 */
#undef COOLSWITCHTRACE


#define DGF_NODRAW      1

#define ALT_F6          2
#define ALT_ESCAPE      1

#define FDIR_FORWARD    0
#define FDIR_BACKWARD   1


/*
 *  Win95 hard codes the size of the icon matrix, the size of
 *  the icons, the highlight border and the icon spacing
 */
#define CXICONSLOT      43
#define CYICONSLOT      43
#define CXICONSIZE      32
#define CYICONSIZE      32
#define MAXTASKNAMELEN  50



VOID xxxPaintIconsInSwitchWindow(PWND, PSWINFO, HDC, INT, INT, INT, BOOL, BOOL, PICON);

/***************************************************************************\
* Getpswi
*
* 04-29-96 GerardoB  Created
\***************************************************************************/
__inline PSWINFO Getpswi (PWND pwnd)
{
    UserAssert(GETFNID(pwnd) == FNID_SWITCH);
    return TestWF(pwnd, WFDESTROYED) ? NULL : ((PSWITCHWND)pwnd)->pswi;
}
/***************************************************************************\
* Setpswi
*
* 04-29-96 GerardoB  Created
\***************************************************************************/
__inline void Setpswi (PWND pwnd, PSWINFO pswi)
{
    UserAssert(GETFNID(pwnd) == FNID_SWITCH);
    ((PSWITCHWND)pwnd)->pswi = pswi;
}
/***************************************************************************\
* DSW_GetTopLevelCreatorWindow
*
*
\***************************************************************************/

PWND DSW_GetTopLevelCreatorWindow(
    PWND pwnd)
{
    UserAssert(pwnd != NULL);

    if (pwnd != NULL) {
        while (pwnd->spwndOwner)
            pwnd = pwnd->spwndOwner;
    }

    return pwnd;
}

/***************************************************************************\
* GetNextQueueWindow
*
* This routine is used to implement the Alt+Esc feature.  This feature lets
* the user switch between windows for different applications (a.k.a. "Tasks")
* currently running.  We keep track of the most recently active window in
* each task.  This routine starts with the window passed and searches for the
* next window, in the "top-level" window list, that is from a different task
* than the one passed.  We then return the most recenly active window from
* that task (or the window we found if the most recently active has been
* destroyed or is currently disabled or hidden).  This routine returns NULL
* if no other enabled, visible window for another task can be found.
*
* History:
* 30-May-1991 DavidPe   Ported from Win 3.1 sources.
\***************************************************************************/

PWND _GetNextQueueWindow(
    PWND pwnd,
    BOOL fPrev, /* 1 backward 0 forward */
    BOOL fAltEsc)
{
    PWND        pwndAltTab;
    PWND        pwndNext;
    PWND        pwndT;
    PWND        pwndDesktop;
    BOOL        bBeenHereAlready = FALSE;
    PTHREADINFO ptiAltTab;

    /*
     * HACK: We have a problem with direct-draw full apps where an alttab
     *       window is created on a queue owned other than the RIT.  This
     *       shows up by alt-tabbing away from ROIDS.EXE during fullscreen.
     *
     *       What is happening is on a ALT-TAB, from xxxSysCommand(), the
     *       thread is not a rit.  xxxSysCommand() calls xxxOldNextWindow
     *       which finds that the current-thread doesn't have a switch
     *       window, and then creates one on the current-thread-queue.
     *
     *       The hack here is to make sure the calling thread is the RIT
     *       before allowing any cool-switch creation.
     *
     *       21-Mar-1996 : Chriswil
     */
#if 0
    ptiAltTab = PtiCurrent();
#else
    ptiAltTab = gptiRit;
#endif

    /*
     * If the window we receive is Null then use the last topmost window
     */
    if (!pwnd) {
        pwnd = GetLastTopMostWindow();
        if (!pwnd) {
            return NULL;
        }
    }

    pwndAltTab = gspwndAltTab;

    pwnd = pwndNext = GetTopLevelWindow(pwnd);
    if (!pwndNext)
        return NULL;

    /*
     * Get the window's desktop
     */
    if ((pwndDesktop = pwndNext->spwndParent) == NULL) {
        pwndDesktop = grpdeskRitInput->pDeskInfo->spwnd;
        pwnd = pwndNext = pwndDesktop->spwndChild;
    }

    while (TRUE) {

        if (pwndNext == NULL)
            return NULL;

        /*
         *  Get the next window
         */
        pwndNext = _GetWindow(pwndNext, fPrev ? GW_HWNDPREV : GW_HWNDNEXT);

        if (!pwndNext) {

            pwndNext = fPrev ? _GetWindow(pwndDesktop->spwndChild, GW_HWNDLAST)
                             : pwndDesktop->spwndChild;
            /*
             * To avoid searching the child chain forever, bale out if we get
             * to the end (beginning) of the chain twice.
             * This happens if pwnd is a partially destroyed window that has
             * been unlinked from its siblings but not yet unlinked from the
             * parent. (Happens while sending WM_NCDESTROY in xxxFreeWindow)
             */
            if (bBeenHereAlready) {
                RIPMSG1(RIP_WARNING, "pwnd %#p is no longer a sibling", pwnd);
                return NULL;
            }

            bBeenHereAlready = TRUE;
        }

        /*
         *  If we have gone all the way around with no success, return NULL.
         */
        if (!pwndNext || (pwndNext == pwnd))
            return NULL;

        /*
         *  Ignore the following windows:
         *      Switch window
         *      Tool Windows
         *      NoActivate Windows
         *      Hidden windows
         *      Disabled windows
         *      Topmost windows if via Alt+Esc
         *      Bottommost windows if via Alt+Esc
         *
         *  If we're doing Alt-Esc processing, we have to skip topmost windows.
         *
         *  Because topmost windows don't really go to the back when we
         *  send them there, alt-esc would never enumerate non-topmost windows.
         *  So, although we're allowed to start enumeration at a topmost window,
         *  we only allow enumeration of non-topmost windows, so the user can
         *  enumerate his presumably more important applications.
         */
        if ((pwndNext != pwndAltTab) &&
// BradG - Win95 is missing the check for Tool Windows
            (!TestWF(pwndNext, WEFTOOLWINDOW)) &&
            (!TestWF(pwndNext, WEFNOACTIVATE)) &&
            (TestWF(pwndNext, WFVISIBLE)) &&
            ((pwndNext->spwndLastActive == NULL) || (!TestWF(pwndNext->spwndLastActive, WFDISABLED)) &&
            (!fAltEsc || (!TestWF(pwndNext, WEFTOPMOST) && !TestWF(pwndNext, WFBOTTOMMOST))))) {
            /*
             * If this window is owned, don't return it unless it is the most
             * recently active window in its owner/ownee group.
             */
            /*
             *  Hard loop to find top level owner
             */
            for (pwndT = pwndNext; pwndT->spwndOwner; pwndT = pwndT->spwndOwner)
                ;

            /*
             *  Don't return it unless it is the most recently active
             *  window in its owner/ownee group.
             */
            if (pwndNext == pwndT->spwndLastActive)
                return pwndNext;
        }
    }
}

/***************************************************************************\
*
* SwitchToThisWindow()
*
* This function was added specifically for Win386.  It is called to tell
* USER that a particular window has been switched to via Alt+Tab or
* Alt+Esc in the Win386 environment.  They call this function to maintain
* Z-ordering and consistent operation of these two functions.  This function
* must be exported, but need not be documented.
*
* The parameter fTab is TRUE if this window is to be switched to via an
* Alt/Ctl+Tab key sequence otherwise it must be FALSE.
*
* History:
* 04-Feb-1991 DarrinM   Created.
\***************************************************************************/

VOID xxxSwitchToThisWindow(
    PWND pwnd,
    BOOL fAltTab)
{
    CheckLock(pwnd);

    /*
     *  If we need to, push old window to the bottom.
     */
    if (gpqForeground && !fAltTab) {

        BOOL fPush;
        PWND pwndActive;
        TL   tlpwndActive;

        /*
         *  if ALT-ESC, and the window brought forward is the next one in the
         *  list, we must be rotating the zorder forward, so push the current
         *  window to the back
         */
        pwndActive = gpqForeground->spwndActive;
        fPush = pwndActive && _GetNextQueueWindow(pwndActive, FDIR_FORWARD, !fAltTab);
        if (fPush && !TestWF(pwndActive, WEFTOPMOST) && !TestWF(pwndActive, WFBOTTOMMOST)) {
            ThreadLock(pwndActive, &tlpwndActive);
            xxxSetWindowPos(pwndActive, PWND_BOTTOM, 0, 0, 0, 0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_ASYNCWINDOWPOS);
            ThreadUnlock(&tlpwndActive);
        }
    }

    /*
     *  Switch this new window to the foreground
     *  This window can go away during the SetForeground call if it isn't
     *  on the thread calling SwitchToThisWindow()!
     */
    xxxSetForegroundWindow(pwnd, TRUE);

    /*
     * Restore minimized windows if the Alt+Tab case
     */
    if (fAltTab && TestWF(pwnd,WFMINIMIZED)) {

        /*
         * We need to package up a special 'posted' queue message here.  This
         * ensures that this message gets processed after the asynchronous
         * activation event occurs (via SetForegroundWindow).
         */
        PostEventMessage(GETPTI(pwnd), GETPTI(pwnd)->pq,
                         QEVENT_POSTMESSAGE, pwnd, WM_SYSCOMMAND,
                         SC_RESTORE, 0 );
    }
}

/***************************************************************************\
* NextPrevTaskIndex
*
* History:
* 01-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

INT NextPrevTaskIndex(
    PSWINFO pswInfo,
    INT     iIndex,
    INT     iCount,
    BOOL    fNext)
{
    UserAssert(iCount <= pswInfo->iTotalTasks);

    if (fNext) {
        iIndex += iCount;
        if(iIndex >= pswInfo->iTotalTasks)
            iIndex -= pswInfo->iTotalTasks;
    } else {
        iIndex -= iCount;
        if(iIndex < 0)
            iIndex += pswInfo->iTotalTasks;
    }

    UserAssert((iIndex >= 0) && (iIndex < pswInfo->iTotalTasks));
    return iIndex;
}

/***************************************************************************\
* NextPrevPhwnd
*
* Given a pointer to one entry in the window list, this can return
* the pointer to the next/prev entry in a circular list fashion.
*
* History:
* 01-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

PHWND NextPrevPhwnd(
    PSWINFO pswInfo,
    PHWND   phwnd,
    BOOL    fNext)
{
    PBWL  pbwl;
    PHWND phwndStart;
    PHWND phwndLast;

    pbwl = pswInfo->pbwl;
    phwndStart = &(pbwl->rghwnd[0]);
    phwndLast = pswInfo->phwndLast;

    UserAssert(*phwndLast == (HWND)1);   // Last entry must have a 1.
    UserAssert(phwndStart < phwndLast);  // There must be atleast one entry.
    UserAssert(phwnd != phwndLast);      // Can't be passing in an invalid entry.

    if (fNext) {
        phwnd++;
        if(phwnd == phwndLast)
            phwnd = phwndStart;
    } else {
        if (phwnd == phwndStart) {
            phwnd = phwndLast - 1;  // we have atleast one valid entry.
        } else {
            phwnd--;
        }
    }

    return phwnd;
}

/***************************************************************************\
* _IsTaskWindow
*
* History:
* 01-Jun-95 BradG       Ported from Win95
\***************************************************************************/

BOOL _IsTaskWindow(
    PWND pwnd,
    PWND pwndActive)
{
    /*
     *  Following windows do not qualify to be shown in task list:
     *  Switch  Window, Hidden windows (unless they are the active
     *  window), Disabled windows, Kanji Conv windows.
     *
     *  Also, check for a combobox popup list which has the top-most
     *  style (it's spwndLastActive will be NULL).
     */
    UserAssert(pwnd != NULL);
    return( (TestWF(pwnd, WEFAPPWINDOW)
                || (!TestWF(pwnd, WEFTOOLWINDOW) && !TestWF(pwnd, WEFNOACTIVATE))) &&
            (TestWF(pwnd, WFVISIBLE) || (pwnd == pwndActive)) &&
            (!(pwnd->spwndLastActive && TestWF(pwnd->spwndLastActive, WFDISABLED))));
}

/***************************************************************************\
* RemoveNonTaskWindows()
*
* Given a list of Windows, this walks down the list and removes the
* windows that do not qualify to be shown in the Task-Switch screen.
* This also shrinks the list when it removes some entries.
* Returns the total number of "tasks" (windows) qualified and remained
* in the list. The last entry will have a 1 as usual.
* It also returns a pointer to this last entry via params. It also
* returns the index of the Currently active task via params.
*
* History:
* 01-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

INT _RemoveNonTaskWindows(
    PBWL  pbwl,
    PWND  pwndActive,
    LPINT lpiActiveTask,
    PHWND *pphwndLast)
{
    INT   iTaskCount = 0;
    PHWND phwnd;
    PWND  pwnd;
    PWND  pwndUse;
    PWND  pwndOwnee;
    PHWND phwndHole;

    *lpiActiveTask = -1;

    /*
     * Walk down the window list and do the following:
     *   1. Remove all entries that do not qualify to be shown in the task list.
     *   2. Count the total number of windows that qualify.
     *   3. Get the pointer to the entry that contains current active window.
     *   4. Get the pointer to the last dummy entry (that has 1 in it)
     */
    for (phwndHole = phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {
        pwnd = RevalidateHwnd( *phwnd );
// BradG - Win95 Assert
//         Maybe we just want to remove this window if it is gone.
//        UserAssert(pwnd != NULL);
        if (!pwnd)
            continue;

        if (_IsTaskWindow(pwnd, pwndActive)) {
            pwndUse = pwnd;

// BradG - Why is Win95 doing this?
//         We aren't making any callbacks.
//            Assert(IsWindow32(hwndUse));

            /*
             *  First let's find the task-list owner of this window
             */
            while (!TestWF(pwndUse, WEFAPPWINDOW) && pwndUse->spwndOwner) {
                pwndOwnee = pwndUse;
                pwndUse = pwndUse->spwndOwner;
                if (TestWF(pwndUse, WEFTOOLWINDOW)) {
                    /*
                     * If this is the owner of a top level property sheet,
                     *  show the property sheet.
                     */
                    if (TestWF(pwndOwnee, WEFCONTROLPARENT) && (pwndUse->spwndOwner == NULL)) {
                        pwndUse = pwnd;
                    } else {
                        pwndUse = NULL;
                    }
                    break;
                }
            }

            if (!pwndUse || !pwndUse->spwndLastActive)
                continue;

            /*
             *  walk up from the last active window 'til we find a valid task
             *  list window or until we run out of windows in the ownership
             *  chain
             */
            for (pwndUse = pwndUse->spwndLastActive; pwndUse; pwndUse = pwndUse->spwndOwner)
                if (_IsTaskWindow(pwndUse, pwndActive))
                    break;

            /*
             *  if we ran out of windows in the ownership chain then use the
             *  owned window itself -- or if we didn't run out of the ownership
             *  chain, then only include this window if it's the window in the
             *  ownership chain that we just found (VB will love us for it !)
             *  -- jeffbog -- 4/20/95 -- Win95C B#2821
             */
            if (!pwndUse || (pwndUse == pwnd)) {

                /*
                 *  Do we have any holes above this? If so, move this handle to
                 *  that hole.
                 */
                if (phwndHole < phwnd) {

                    /*
                     * Yes! There is a hole. Let us move the valid
                     * handle there.
                     */
                    *phwndHole = *phwnd;
                }

                if (pwndActive == pwnd)
                    *lpiActiveTask = iTaskCount;
                iTaskCount++;
                phwndHole++;  // Move to the next entry.
            }

            /*
             *  Else, leave it as a hole for later filling.
             */
        }
    }

    *phwndHole = (HWND)1;
    *pphwndLast = phwndHole;

    return iTaskCount;
}

/***************************************************************************\
* DrawSwitchWndHilite()
*
* This draws or erases the Hilite we draw around the icon to show which
* task we are going to switch to.
* This also updates the name on the Task title window.
*
* History:
* 01-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

VOID DrawSwitchWndHilite(
    PSWINFO pswInfo,
    HDC     hdcSwitch,
    int     iCol,
    int     iRow,
    BOOL    fShow)
{
    BOOL        fGetAndReleaseIt;
    RECT        rcTemp;
    PTHREADINFO ptiAltTab;
    /*
     * HACK: We have a problem with direct-draw full apps where an alttab
     *       window is created on a queue owned other than the RIT.  This
     *       shows up by alt-tabbing away from ROIDS.EXE during fullscreen.
     *
     *       What is happening is on a ALT-TAB, from xxxSysCommand(), the
     *       thread is not a rit.  xxxSysCommand() calls xxxOldNextWindow
     *       which finds that the current-thread doesn't have a switch
     *       window, and then creates one on the current-thread-queue.
     *
     *       The hack here is to make sure the calling thread is the RIT
     *       before allowing any cool-switch creation.
     *
     *       21-Mar-1996 : Chriswil
     */
#if 0
    ptiAltTab = PtiCurrent();
#else
    ptiAltTab = gptiRit;
#endif

    /*
     *  Draw or erase the hilite depending on "fShow".
     */
    if (fGetAndReleaseIt = (hdcSwitch == NULL))
        hdcSwitch = _GetDCEx(gspwndAltTab, NULL, DCX_USESTYLE);

    rcTemp.left   = pswInfo->ptFirstRowStart.x + iCol * CXICONSLOT;
    rcTemp.top    = pswInfo->ptFirstRowStart.y + iRow * CYICONSLOT;
    rcTemp.right  = rcTemp.left + CXICONSLOT;
    rcTemp.bottom = rcTemp.top + CYICONSLOT;

    DrawFrame(hdcSwitch,
              &rcTemp,
              2,
              DF_PATCOPY | ((fShow ? COLOR_HIGHLIGHT : COLOR_3DFACE) << 3));


    /*
     *  Update the Task title window.
     */
    if (fShow) {
        WCHAR    szText[CCHTITLEMAX];
        INT      cch;
        COLORREF clrOldText, clrOldBk;
        PWND     pwnd;
        RECT     rcRect;
        HFONT    hOldFont;
        INT      iLeft;
        ULONG_PTR dwResult = 0;

        clrOldText = GreSetTextColor(hdcSwitch, SYSRGB(BTNTEXT));
        clrOldBk   = GreSetBkColor(hdcSwitch, SYSRGB(3DFACE));
        hOldFont = GreSelectFont(hdcSwitch, gpsi->hCaptionFont);


        /*
         * Validate this window handle; This could be some app that terminated
         * in the background and the following line will GP fault in that case;
         * BOGUS: We should handle it some other better way.
         */
        pwnd = RevalidateHwnd( *(pswInfo->phwndCurrent) );
        if (pwnd) {
            /*
             *  Get the windows title (up to MAXTASKNAMELEN's worth)
             */
// BradG - We can do better than MAXTASKNAMELEN characters!
            if (pwnd->strName.Length) {
                cch = TextCopy(&pwnd->strName, szText, CCHTITLEMAX);
            } else {
                *szText = TEXT('\0');
                cch = 0;
            }

            /*
             *  Draw the text
             */
            CopyRect(&rcRect, &pswInfo->rcTaskName);
            iLeft = rcRect.left;
            FillRect(hdcSwitch, &rcRect, SYSHBR(3DFACE));
            /*
             * If an lpk is installed let it draw the text.
             */
            if (CALL_LPK(PtiCurrentShared())) {
                TL    tlpwnd;
                LPKDRAWSWITCHWND LpkDrawSwitchWnd;

                RtlInitLargeUnicodeString(&LpkDrawSwitchWnd.strName, szText, (UINT)-1);
                LpkDrawSwitchWnd.rcRect = rcRect;

                ThreadLock(pwnd, &tlpwnd);
                xxxSendMessageTimeout(pwnd, WM_LPKDRAWSWITCHWND, (WPARAM)hdcSwitch,
                        (LPARAM)&LpkDrawSwitchWnd, SMTO_ABORTIFHUNG, 100, &dwResult);
                ThreadUnlock(&tlpwnd);
            } else {
                DRAWTEXTPARAMS  dtp;

                dtp.cbSize = sizeof(dtp);
                dtp.iLeftMargin = 0;
                dtp.iRightMargin = 0;
                DrawTextEx(hdcSwitch, szText, cch, &rcRect, DT_NOPREFIX | DT_END_ELLIPSIS | DT_SINGLELINE, &dtp );
            }
        }

        GreSelectFont(hdcSwitch, hOldFont);
        GreSetBkColor(hdcSwitch, clrOldBk);
        GreSetTextColor(hdcSwitch, clrOldText);
    }

    if (fGetAndReleaseIt)
        _ReleaseDC(hdcSwitch);
}

/***************************************************************************\
* DrawIconCallBack
*
* This function is called by a Windows app returning his icon.
*
* History:
* 17-Jun-1993 mikesch       Created.
\***************************************************************************/

VOID CALLBACK DrawIconCallBack(
    HWND    hwnd,
    UINT    uMsg,
    ULONG_PTR dwData,
    LRESULT lResult)
{
    PWND pwndAltTab;

    /*
     *  dwData is the pointer to the switch window handle.
     *  If this Alt+Tab instance is still active, we need to derive this
     *  window's index in the bwl array, otherwise, we are receiving an icon
     *  for an old Alt+Tab window.
     */
    pwndAltTab = RevalidateHwnd((HWND)dwData);
    if (pwndAltTab && TestWF(pwndAltTab, WFVISIBLE)) {

        PSWINFO pswCurrent;
        PICON   pIcon;
        PHWND   phwnd;
        PWND    pwnd;
        PWND    pwndT;
        INT     iStartTaskIndex;
        TL      tlpwndAltTab;

        /*
         *  Derive this window's index in the BWL array
         */
        if ((pwnd = RevalidateHwnd(hwnd)) == NULL)
            return;

        /*
         *  Get the switch window info
         */
        pswCurrent = Getpswi(pwndAltTab);
        if (!pswCurrent)
            return;

        for (iStartTaskIndex = 0, phwnd=&(pswCurrent->pbwl->rghwnd[0]); *phwnd != (HWND)1; phwnd++, iStartTaskIndex++) {
            /*
             *  Because we list the active window in the Switch Window, the
             *  hwnd here might not be the same, so we also need to walk back
             *  to the top-level window to see if this is the right entry
             *  in the list.
             */
            for(pwndT = RevalidateHwnd(*phwnd); pwndT; pwndT = pwndT->spwndOwner) {
                if (pwnd == pwndT)
                    goto DrawIcon;
            }
        }
        return;

        /*
         *  Convert the App's HICON into a PICON, or if the App did not return
         *  an icon, use the Windows default icon.
         */
DrawIcon:
        pIcon = NULL;
        if (lResult)
            pIcon = HMValidateHandleNoRip((HCURSOR)lResult, TYPE_CURSOR);

        if (!pIcon)
            pIcon = SYSICO(WINLOGO);

        /*
         *  Paint this icon in the Alt+Tab window.
         */
        ThreadLockAlways(pwndAltTab, &tlpwndAltTab);
        xxxPaintIconsInSwitchWindow(pwndAltTab,
                                    pswCurrent,
                                    NULL,
                                    iStartTaskIndex,
                                    0,
                                    1,
                                    FALSE,
                                    FALSE,
                                    pIcon);
        ThreadUnlock(&tlpwndAltTab);
    }

    UNREFERENCED_PARAMETER(uMsg);
}

/***************************************************************************\
* TSW_CalcRowAndCol
*
* History:
* 01-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

BOOL TSW_CalcRowAndCol(
    PSWINFO pswInfo,
    INT     iTaskIndex,
    LPINT   lpiRow,
    LPINT   lpiCol)
{
    INT iDiff;
    INT iRow;

    /*
     *  Calculate how far is the given task from the first task shown
     *  on the switch window.
     */
    if ((iDiff = (iTaskIndex - pswInfo->iFirstTaskIndex)) < 0)
        iDiff += pswInfo->iTotalTasks;

    /*
     *  Calculate the Row and if this lies outside the switch window, return FALSE
     */
    if ((iRow = iDiff / pswInfo->iNoOfColumns) >= pswInfo->iNoOfRows)
        return FALSE;

    /*
     *  Return the Row and column where this task lies.
     */
    *lpiRow = iRow;
    *lpiCol = iDiff - (iRow * pswInfo->iNoOfColumns);

    return TRUE;  // This task lies within the switch window.
}

/***************************************************************************\
* xxxPaintIconsInSwitchWindow()
*
* This can simply paint the icons in the switch window or Scroll the
* whole window UP/DOWN and then paint the remaining area;
*   * If fScroll is TRUE, then the second, third and fourth params are ignored.
*   * If hIcon is passed in, then we're being called by DrawIconCallBack and
*       iStartRow parameter is ignored in this case.
*
* History:
* 02-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

VOID xxxPaintIconsInSwitchWindow(
    PWND    pwndAltTab,
    PSWINFO pswInfo,
    HDC     hdc,
    INT     iStartTaskIndex,
    INT     iStartRow,
    INT     iNoOfIcons,
    BOOL    fScroll,
    BOOL    fUp,
    PICON   pIcon)
{
    INT   cx, cy, xStart;
    PHWND phwnd;
    BOOL  fGetAndReleaseIt;
    INT   iColumnIndex = 0;
    RECT  rcScroll;
    PWND  pwnd;
    TL    tlpwnd;
    HICON hIcon;
    RECT  rcIcon;

    CheckLock(pwndAltTab);

    /*
     *  If we were not supplied a DC, get ghwndSwitch's and set a flag
     *  so we remember to release it.
     */
    if (fGetAndReleaseIt = (hdc == NULL))
        hdc = _GetDCEx(pwndAltTab, NULL, DCX_USESTYLE);

    cx = pswInfo->ptFirstRowStart.x;
    cy = pswInfo->ptFirstRowStart.y;

    if (fScroll) {

        rcScroll.left   = cx;
        rcScroll.top    = cy;
        rcScroll.right  = cx + CXICONSLOT * pswInfo->iNoOfColumns;
        rcScroll.bottom = cy + CYICONSLOT * pswInfo->iNoOfRows;

        _ScrollDC(hdc,
                  0,
                  (fUp ? -CYICONSLOT : CYICONSLOT),
                  &rcScroll,
                  &rcScroll,
                  NULL,
                  NULL);

        iStartRow = (fUp ? pswInfo->iNoOfRows - 1 : 0);
        iNoOfIcons = pswInfo->iNoOfColumns;
        iStartTaskIndex = (fUp ? NextPrevTaskIndex(pswInfo, pswInfo->iFirstTaskIndex,
                  (pswInfo->iNoOfRows - 1) * pswInfo->iNoOfColumns, TRUE) :
                   pswInfo->iFirstTaskIndex);
    }

    if (pIcon) {
        /*
         *  If pIcon is given, this is to paint just one icon during callback.
         */
// BradG - Win95 Assert
        UserAssert(iNoOfIcons == 1);

        /*
         *  Due to earlier scrolling, the row number would have changed. So,
         *  recalc the row and column from the iStartTaskIndex given.
         */
        if (!TSW_CalcRowAndCol(pswInfo, iStartTaskIndex, &iStartRow, &iColumnIndex))
            goto Cleanup;
    }

    xStart = cx += (CXICONSLOT - CXICONSIZE) / 2;
    cx += iColumnIndex * CXICONSLOT;
    cy += ((CYICONSLOT - CYICONSIZE) / 2) + iStartRow * CYICONSLOT;
    phwnd = &(pswInfo->pbwl->rghwnd[iStartTaskIndex]);

    /*
     *  Draw all the icons one by one.
     */
    while (iNoOfIcons--) {
        /*
         *  If the Alt+Key is no longer down, abort painting icons.
         */
        if ((pswInfo->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
                (!pswInfo->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0))
            goto Cleanup;

        /*
         *  Check if this window is still alive. (Some task could have
         *  terminated in the background)
         */
        if (pwnd = RevalidateHwnd(*phwnd)) {
            /*
             *  Find the window's top-level owner
             */
            pwnd = DSW_GetTopLevelCreatorWindow(pwnd);

            /*
             *  If we don't have an icon, find one
             */
            if (!pIcon) {
                /*
                 *  Try window icon
                 */
                hIcon = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), PROPF_INTERNAL);
                if (hIcon) {
                    pIcon = (PICON)HMValidateHandleNoRip(hIcon, TYPE_CURSOR);
                }

                /*
                 * If we don't have an icon yet, try the class icon
                 */
                if (!pIcon) {
                    pIcon = pwnd->pcls->spicn;
                }

                /*
                 * If we don't have an icon yet, use WM_QUERYDRAGICON to ask
                 * 3,x apps for their icon.
                 */
                if (!pIcon && !TestWF(pwnd, WFWIN40COMPAT)) {
                    /*
                     *  The callback routine will paint the icon for
                     *  us, so just leave pIcon set to NULL
                     */
                    ThreadLock(pwnd, &tlpwnd);
                    xxxSendMessageCallback(pwnd, WM_QUERYDRAGICON, 0, 0,
                            (SENDASYNCPROC)DrawIconCallBack,
                            HandleToUlong(PtoH(pwndAltTab)), FALSE);
                    ThreadUnlock(&tlpwnd);
                } else {
                    /*
                     *  If we can't find an icon, so use the Windows icon
                     */
                    if (!pIcon) {
                        pIcon = SYSICO(WINLOGO);
                    }
                }
            }
        }

        if (pIcon) {
            _DrawIconEx(hdc, cx, cy, pIcon, SYSMET(CXICON), SYSMET(CYICON),
                0, SYSHBR(3DFACE), DI_NORMAL);
        } else if (fScroll) {
            /*
             *  NOT IN WIN95
             *
             *  No icon was available, do while we are waiting for the
             *  application to paint it's icon, we need to "erase" the
             *  background in case we have scrolled the window.
             */
            rcIcon.left = cx;
            rcIcon.top = cy;
            rcIcon.right = cx + SYSMET(CXICON);
            rcIcon.bottom = cy + SYSMET(CYICON);
            FillRect(hdc, &rcIcon, SYSHBR(3DFACE));
        }

        /*
         *  Check if we are done.
         */
        if (iNoOfIcons <= 0)
            break;

        /*
         *  Reset hIcon for the next run through the loop
         */
        pIcon = NULL;

        /*
         *  Move all pointers to the next task/icon.
         */
        phwnd = NextPrevPhwnd(pswInfo, phwnd, TRUE); // Get next.

        /*
         *  Is it going to be in the same row; then adjust cx and cy.
         */
        if (++iColumnIndex >= pswInfo->iNoOfColumns) {
            iColumnIndex = 0;
            cx = xStart;        // Move to first column
            cy += CYICONSLOT;   // Move to next row.
            iStartRow++;
        } else {
            /*
             *  else, adjust cx;
             */
            cx += CXICONSLOT;
        }

        iStartTaskIndex = NextPrevTaskIndex(pswInfo, iStartTaskIndex, 1, TRUE);
    }

Cleanup:
    if (fGetAndReleaseIt)
        _ReleaseDC(hdc);
}

/***************************************************************************\
* PaintSwitchWindow
*
* History:
* 02-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

VOID xxxPaintSwitchWindow(
    PWND pwndSwitch)
{
    LPRECT  lprcRect;
    RECT    rcRgn;
    HDC     hdcSwitch;
    PSWINFO pswCurrent;
    CheckLock(pwndSwitch);

    /*
     *  If our window isn't visible, return
     */
    if (!TestWF(pwndSwitch, WFVISIBLE))
        return;

    /*
     *  Get the switch window information
     */
    pswCurrent = Getpswi(pwndSwitch);
    if (!pswCurrent)
        return;

    /*
     * Get the Switch windows DC so we can paint with it
     */
    hdcSwitch = _GetDCEx(pwndSwitch, NULL, DCX_USESTYLE );

    /*
     *  Paint the background of the Switch Screen.
     */
    if ((pswCurrent->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
            (!pswCurrent->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0))
        goto PSWExit;

    lprcRect = &(pswCurrent->rcTaskName);
    _GetClientRect(pwndSwitch, lprcRect);
    FillRect(hdcSwitch, lprcRect, SYSHBR(3DFACE));

    /*
     * Store this "caption" area back into the current switch
     * window data structure.
     */
    InflateRect(lprcRect, -(gcxCaptionFontChar << 1), -(gcyCaptionFontChar));
    lprcRect->top = lprcRect->bottom - gcyCaptionFontChar;

    /*
     *  Draw the sunken edge for showing the task names.
     */
    if ((pswCurrent->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
            (!pswCurrent->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0))
        goto PSWExit;
    CopyInflateRect(&rcRgn, lprcRect, gcxCaptionFontChar >> 1, gcyCaptionFontChar >> 1);
    DrawEdge(hdcSwitch, &rcRgn, EDGE_SUNKEN, BF_RECT);

    /*
     *  Paint the icons
     */
    if ((pswCurrent->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
            (!pswCurrent->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0))
        goto PSWExit;

    xxxPaintIconsInSwitchWindow(pwndSwitch,
                                pswCurrent,
                                hdcSwitch,
                                pswCurrent->iFirstTaskIndex,
                                0,
                                pswCurrent->iTasksShown,
                                FALSE,
                                FALSE,
                                NULL);

    /*
     *  So, just draw the hilite.
     */
    if ((pswCurrent->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
            (!pswCurrent->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0))
        goto PSWExit;

    DrawSwitchWndHilite(pswCurrent,
                        hdcSwitch,
                        pswCurrent->iCurCol,
                        pswCurrent->iCurRow,
                        TRUE);

    /*
     *  Release the switch windows DC
     */
PSWExit:
    _ReleaseDC(hdcSwitch);
}

/***************************************************************************\
* InitSwitchWndInfo()
*
* This function allocs and Initializes all the data structures
* required the build and show the tasks in the system.
* If there is insufficient mem, then this find the next window to switch
* to and returns it. In this case, we will behave as if the end user hit
* ALT+ESC. The SWitchScreen will not comeup in this case.
* If there is only one task in the whole system, then this function
* fails and returns a NULL. (No ALT+TAB processing is required).
* Otherwise, it allocs one SwitchWndInfo struc, fills it up and returns
* the window we gonna switch to.
*
* History:
* 02-Jun-95 BradG       Ported from Win95
\***************************************************************************/

PWND InitSwitchWndInfo(
    PSWINFO *   lppswInfo,
    PWND        pwndCurActive,
    BOOL        fPrev)
{
    PBWL            pbwl;
    INT             iTotalTasks;
    INT             iCols, iRows, iIconsInLastRow;
    INT             iDiff;
    PHWND           phwndLast;
    PSWINFO         pswInfo;
    INT             iIconIndex;
    INT             iCurRow, iCurCol;
    INT             cxSwitch, cySwitch;
    INT             iFirstRowIcons;
    INT             iActiveTask;
    PWND            pwnd = NULL;
    PTHREADINFO     ptiCurrent = PtiCurrent();
    PDESKTOPINFO    pdeskinfo = GETDESKINFO(ptiCurrent);
    PMONITOR        pMonitor = GetPrimaryMonitor();

    /*
     *  Initialize the list
     */
    *lppswInfo = (PSWINFO)NULL;

    /*
     *  Build the Window list of all the top level windows.
     */
#if 0
    if (!(pbwl = BuildHwndList(NULL, BWL_ENUMLIST | BWL_ALLDESKTOPS, NULL)))
        goto ReturnNextWnd;
#else
// BradG - HACK, enumerate on current desktop!
//   For the long run, we will need to enumerate all desktops
//   This will be tricky because we need to check the security of
//   each desktop, thus needing the user's security "token".
    if (!(pbwl = BuildHwndList(pdeskinfo->spwnd->spwndChild, BWL_ENUMLIST, NULL))) {
#ifdef COOLSWITCHTRACE
        DbgPrint("CoolSwitch: BuildHwndList failed (contact bradg).\n");
        UserAssert(pbwl != NULL);
#endif
        goto ReturnNextWnd;
    }
#endif

    /*
     *  Walk down the list and remove all non-task windows from the list.
     *  Replace those hwnds with 0.
     */
    if ((iTotalTasks = _RemoveNonTaskWindows(pbwl, pwndCurActive, &iActiveTask, &phwndLast)) < 2) {
        if (iTotalTasks == 1) {
            /*
             *  If we have only one window and it's in full screen mode, we will
             *  return the shell window so the can switch back to GDI mode.
             */
            pwnd = RevalidateHwnd(pbwl->rghwnd[0]);
            if (pwnd && GetFullScreen(pwnd) == FULLSCREEN && pwndCurActive == pwnd)
                pwnd = pdeskinfo->spwndShell;

        } else {
            pwnd = pdeskinfo->spwndShell;
        }
#ifdef COOLSWITCHTRACE
        DbgPrint("CoolSwitch: Not enough windows to switch.\n");
#endif
        goto FreeAndReturnNextWnd;  // If there isn't even two tasks, no switch wnd processing.
    }

    /*
     *  Allocate the Switch Info structure.  If we don't have enough
     *  memory, act as if we are doing Alt+Esc.
     */
    if (!(pswInfo = (PSWINFO)UserAllocPoolWithQuota(sizeof(SWITCHWNDINFO), TAG_ALTTAB))) {
#ifdef COOLSWITCHTRACE
        DbgPrint("CoolSwitch: UserAllocPool failed on 0x%X bytes (contact bradg).\n", sizeof(SWITCHWNDINFO));
        UserAssert(pswInfo != NULL);
#endif
        goto FreeAndReturnNextWnd;  // Unable to alloc SwitchWndInfo struct.
    }

    pswInfo->pbwl        = pbwl;
    pswInfo->phwndLast   = phwndLast;
    pswInfo->iTasksShown = pswInfo->iTotalTasks = iTotalTasks;

    /*
     *  Get the next/prev window that must become active.
     */
    iIconIndex = NextPrevTaskIndex(pswInfo, iActiveTask, 1, !fPrev);
    pswInfo->phwndCurrent = &(pbwl->rghwnd[iIconIndex]);

    iCols = min(gnFastAltTabColumns, iTotalTasks);
    iRows = iTotalTasks / iCols;  // Truncation might occur.

    iIconsInLastRow = iTotalTasks - iRows * iCols;
    iRows += (iIconsInLastRow ? 1 : 0);  // Take care of earlier truncation.

    /*
     *  Restrict the number of rows to just MAXROWSALLOWED (3)
     */
    if (iRows > gnFastAltTabRows) {
        iRows = gnFastAltTabRows;
        pswInfo->fScroll = TRUE;    // We need to scroll.
        iIconsInLastRow = iCols;
        pswInfo->iTasksShown = iCols * iRows;
    } else {
        pswInfo->fScroll = FALSE;
    }

    pswInfo->iNoOfColumns = iCols;
    pswInfo->iNoOfRows    = iRows;

    if (iIconsInLastRow == 0)
       iIconsInLastRow = pswInfo->iNoOfColumns; // Last Row is full.
    pswInfo->iIconsInLastRow = iIconsInLastRow;

    /*
     *  Find out Row and Col where the next/prev icon will lie.
     */
    if (iIconIndex >= (iRows * iCols)) {
        /*
         *  Next Icon lies outside. Bring it to the center.
         */
        iCurRow = (iRows >> 2) + 1;
        iCurCol = (iCols >> 2) + 1;
        iDiff = (iIconIndex - ((iCurRow * iCols) + iCurCol));
    } else {
        iDiff = 0;
        iCurRow = iIconIndex / iCols;
        iCurCol = iIconIndex - (iCurRow * iCols);
    }

    pswInfo->iFirstTaskIndex = iDiff;
    pswInfo->iCurRow         = iCurRow;
    pswInfo->iCurCol         = iCurCol;

    /*
     *  Calculate the Switch Window Dimensions.
     */
    cxSwitch = min(
            pMonitor->rcMonitor.right - pMonitor->rcMonitor.left,
            gnFastAltTabColumns * CXICONSLOT +
                CXICONSIZE / 2 +
                6 * gpsi->gclBorder * SYSMET(CXBORDER) +
                gcxCaptionFontChar);

    cySwitch = min(
            pMonitor->rcMonitor.bottom - pMonitor->rcMonitor.top,
            iRows * CYICONSLOT +
                CYICONSIZE +
                gcyCaptionFontChar * 2 +
                gcyCaptionFontChar / 2);

    /*
     *  Find the number of icons in first row
     */
    if (iRows == 1) {
        iFirstRowIcons = iIconsInLastRow;
    } else {
        iFirstRowIcons = iCols;
    }

    /*
     *  Center the icons based on the number of icons in first row.
     */
    pswInfo->ptFirstRowStart.x = (cxSwitch - 4*gpsi->gclBorder*SYSMET(CXBORDER) - iFirstRowIcons * CXICONSLOT) >> 1;
    pswInfo->ptFirstRowStart.y = (CYICONSIZE >> 1);

    pswInfo->cxSwitch = cxSwitch;
    pswInfo->cySwitch = cySwitch;

    *lppswInfo = pswInfo;

    return RevalidateHwnd(*(pswInfo->phwndCurrent));  // Success!


    /*
     *  When there is insufficient mem to create the reqd structures, we simply
     *  return the next window. We make the phwndInfo as NULL. So, we won't
     *  attempt to draw the switch window.
     */

FreeAndReturnNextWnd:
    FreeHwndList(pbwl);
ReturnNextWnd:
    if (pwnd)
        return(pwnd);

    return(_GetNextQueueWindow(pwndCurActive, _GetKeyState(VK_SHIFT) < 0, FALSE));
}

/***************************************************************************\
* xxxMoveSwitchWndHilite()
*
* This moves the Hilite to the next/prev icon.
* Checks if this move results in a scrolling. If it does, then
* make sure scroll occurs.
* Else, erase hilite from the current icon;
* Then draw hilite on the new Icon.
* fPrev indicates whether you want the prev task or next.
*
* History:
* 02-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

HWND xxxMoveSwitchWndHilite(
    PWND    pwndSwitch,
    PSWINFO pswInfo,
    BOOL    fPrev)
{
    INT  iCurCol, iCurRow;
    INT  iMaxColumns;
    BOOL fLastRow;
    BOOL fNeedToScroll = FALSE;
    HDC  hdc;
    HWND hwnd;

    CheckLock(pwndSwitch);
    UserAssert(IsWinEventNotifyDeferredOK());

    iCurCol = pswInfo->iCurCol;
    iCurRow = pswInfo->iCurRow;

    /*
     *  Find out the new postion (row and column) of hilite.
     */
    if (fPrev) {
        if (iCurCol > 0) {
            /*
             *  Move cursor to prev column on the same row.
             */
            iCurCol--;
        } else {
            /*
             *  Try to move to the previous row.
             */
            if (iCurRow > 0) {
                /*
                 *  Move to the last column on the previous row.
                 */
                iCurRow--;
                iCurCol = pswInfo->iNoOfColumns - 1;
            } else {
                /*
                 *  We are already at (0,0); See if we need to scroll.
                 */
                if (pswInfo->fScroll) {
                    /*
                     * Time to scroll; Scroll by one Row;
                     * Repaint the whole window.
                     */
                    fNeedToScroll = TRUE;
                    pswInfo->iFirstTaskIndex = NextPrevTaskIndex(pswInfo, pswInfo->iFirstTaskIndex,
                      pswInfo->iNoOfColumns, FALSE);
                    iCurCol = pswInfo->iNoOfColumns - 1;
                } else {
                    /*
                     *  Move the hilite to the last icon shown.
                     */
                    iCurRow = pswInfo->iNoOfRows - 1;
                    iCurCol = pswInfo->iIconsInLastRow - 1;
                }
            }
        }

    } else {
        /*
         *  !fPrev
         *  Get the number of columns in the current row.
         */
        if (fLastRow = (iCurRow == (pswInfo->iNoOfRows - 1))) // Are we at the last row?
            iMaxColumns = pswInfo->iIconsInLastRow;
        else
            iMaxColumns = pswInfo->iNoOfColumns;

        /*
         *  Are we at the last column yet?
         */
        if (iCurCol < (iMaxColumns - 1)) {
            /*
             *  No! Move to the right.
             */
            iCurCol++;
        } else {
            /*
             *  We are at the last column.
             *  If we are not at last row, then move to next row.
             */
            if (!fLastRow) {
                iCurCol = 0;
                iCurRow++;
            } else {
                /*
                 *  We are at the last row, last col;
                 *  See if we need to scroll.
                 */
                if (pswInfo->fScroll) {
                    fNeedToScroll = TRUE;
                    pswInfo->iFirstTaskIndex = NextPrevTaskIndex(pswInfo, pswInfo->iFirstTaskIndex,
                          pswInfo->iNoOfColumns, TRUE);
                    iCurCol = 0;
                } else {
                    /*
                     *  Move to the top left corner (0, 0).
                     */
                    iCurRow = iCurCol = 0;
                }
            }
        }
    }

    /*
     *  Move the phwnd to the next/prev
     */
    pswInfo->phwndCurrent = NextPrevPhwnd(pswInfo, pswInfo->phwndCurrent, !fPrev);

    /*
     *  Remove Hilite from the current location.
     */
    hdc = _GetDCEx(pwndSwitch, NULL, DCX_USESTYLE);
    DrawSwitchWndHilite(pswInfo, hdc, pswInfo->iCurCol, pswInfo->iCurRow, FALSE);

    pswInfo->iCurRow = iCurRow;
    pswInfo->iCurCol = iCurCol;
    hwnd = (*(pswInfo->phwndCurrent));

    /*
     *  Repaint if needed.
     */
    if (fNeedToScroll)
        xxxPaintIconsInSwitchWindow(pwndSwitch, pswInfo, hdc, pswInfo->iFirstTaskIndex, 0, 0, TRUE, !fPrev, NULL);

    /*
     *  Draw Hilite at the new location.
     */
    DrawSwitchWndHilite(pswInfo, hdc, iCurCol, iCurRow, TRUE);

    _ReleaseDC(hdc);


    xxxWindowEvent(EVENT_OBJECT_FOCUS, pwndSwitch, OBJID_CLIENT,
        iCurRow * pswInfo->iNoOfColumns + iCurCol + 1, WEF_USEPWNDTHREAD);

    return hwnd;
}

/***************************************************************************\
* xxxShowSwitchWindow()
*
* Show the switch Window.
* Returns: TRUE if succeeded.   FALSE, if the window was not shown because
* of the pre-mature release of ALT key. The selection has been made already.
*
* History:
* 07-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

BOOL xxxShowSwitchWindow(
        PWND        pwndAltTab)
{
    PSWINFO pswInfo;
    PMONITOR pMonitorSwitch = GetPrimaryMonitor();
    CheckLock(pwndAltTab);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     *  Get the switch window information
     */
    pswInfo = Getpswi(pwndAltTab);
    if (pswInfo == NULL) {
        return FALSE;
    }

    /*
     *  If the key is not down, don't bother to display Switch Window.
     */
    if ((pswInfo->fJournaling && _GetKeyState(VK_MENU) >= 0) ||
            (!pswInfo->fJournaling && _GetAsyncKeyState(VK_MENU) >= 0)) {
#ifdef COOLSWITCHTRACE
        DbgPrint("CoolSwitch: Not displaying window because VM_MENU is up (contact bradg).\n");
#endif
        return FALSE;
    }

    /*
     *  Bring and position the window on top.
     */
    xxxSetWindowPos(pwndAltTab, PWND_TOPMOST, 0,0,0,0,
        SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE | SWP_NOREDRAW );

    if (!TestWF(pwndAltTab, WFVISIBLE)) {
        xxxSetWindowPos(
            pwndAltTab,
            PWND_TOPMOST,
            (pMonitorSwitch->rcWork.left + pMonitorSwitch->rcWork.right - pswInfo->cxSwitch) / 2,
            (pMonitorSwitch->rcWork.top + pMonitorSwitch->rcWork.bottom - pswInfo->cySwitch) / 2,
            pswInfo->cxSwitch,
            pswInfo->cySwitch,
            SWP_SHOWWINDOW | SWP_NOACTIVATE);
    }
#ifdef COOLSWITCHTRACE
    UserAssert(TestWF(pwndAltTab, WFVISIBLE));
#endif
    xxxUpdateWindow(pwndAltTab);

    xxxWindowEvent(EVENT_SYSTEM_SWITCHSTART, pwndAltTab, OBJID_CLIENT,
            0, WEF_USEPWNDTHREAD);
    
    xxxWindowEvent(EVENT_OBJECT_FOCUS, pwndAltTab, OBJID_CLIENT,
            pswInfo->iCurRow * pswInfo->iNoOfColumns + pswInfo->iCurCol + 1,
            WEF_USEPWNDTHREAD);

    return TRUE;
}

/***************************************************************************\
* SwitchWndCleanup()
*
* Clean up all the mem allocated etc.,
*
* History:
* 07-Jun-1995 BradG     Ported from Win95
\***************************************************************************/

VOID SwitchWndCleanup(
    PSWINFO *ppswInfo)
{
    UserAssert(ppswInfo != NULL);
    UserAssert(*ppswInfo != NULL);

    /*
     *  First of all free the Window list.
     */
    if ((*ppswInfo)->pbwl)
        FreeHwndList((*ppswInfo)->pbwl);
    UserFreePool(*ppswInfo);
    *ppswInfo = NULL;
}


/***************************************************************************\
*
*  xxxSwitchWndProc()
*
\***************************************************************************/

LRESULT xxxSwitchWndProc(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam)
{
    TL          tlpwndActivate;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    VALIDATECLASSANDSIZE(pwnd, message, wParam, lParam, FNID_SWITCH, WM_CREATE);

    switch (message) {
    case WM_CREATE:
        /*
         * When the queue was created, the cursor was set to the wait cursor.
         * We want to use the normal one.
         */
        zzzSetCursor(pwnd->pcls->spcur);
        break;

    case WM_CLOSE:
        /*
         *  Hide this window without activating anyone else.
         */
        xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0, SWP_HIDEWINDOW |
                SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);

        /*
         * Get us out of Alt+Tab mode.  Since the alttab information
         * is stored in the gptiRit->pq, we will reference that insteatd
         * of the current-thread.
         */
        xxxCancelCoolSwitch();
        break;

    case WM_ERASEBKGND:
    case WM_FULLSCREEN:
        ThreadLockWithPti(ptiCurrent, pwnd, &tlpwndActivate);
        xxxPaintSwitchWindow(pwnd);
        ThreadUnlock(&tlpwndActivate);
        return 0;

    case WM_DESTROY:
        {
            /*
             *  Get the switch window info for this window
             */
            PSWINFO pswCurrent = Getpswi(pwnd);


            if (pswCurrent) {
                SwitchWndCleanup(&pswCurrent);
                Setpswi(pwnd, NULL);
            }
        }
        break;
    }

    return xxxDefWindowProc(pwnd, message, wParam, lParam);
}

/***************************************************************************\
* xxxCancelCoolSwitch
*
* This functions destroys the cool switch window and removed the INALTTAB
* mode flag from the specified queue.
*
* History:
* 18-Sep-1995 BradG     Created
\***************************************************************************/
VOID xxxCancelCoolSwitch(
    void)
{
    CheckCritIn();
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     *  Destroy the Cool Switch window
     */
    if (gspwndAltTab != NULL) {

        /*
         * Make sure that the thread calling this is the same
         * thread which created the alttab window.  Otherwise,
         * we could end up with this window floating around until
         * the calling process dies.  Remember, we can't destroy
         * windows across different threads.
         */
        if (gspwndAltTab->head.pti != PtiCurrent())
            return;

        xxxWindowEvent(EVENT_SYSTEM_SWITCHEND, gspwndAltTab, OBJID_CLIENT,
            0, WEF_USEPWNDTHREAD);
        
        xxxDestroyWindow(gspwndAltTab);

        Lock(&gspwndAltTab, NULL);
    }
}

/***************************************************************************\
* xxxNextWindow
*
* This function does the processing for the alt-tab/esc/F6 UI.
*
* History:
* 30-May-1991 DavidPe       Created.
\***************************************************************************/

VOID xxxNextWindow(
    PQ    pq,
    DWORD wParam)
{
    PWND        pwndActivateNext;
    PWND        pwndCurrentActivate, pwndCurrentTopFocus;
    int         fDir;
    TL          tlpwndActivateNext;
    TL          tlpwndCurrentActivate;
    TL          tlpwndT;
    PSWINFO     pswCurrent;
    ULONG_PTR    dwResult;
    BOOL        fNonRit = FALSE;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PTHREADINFO ptiAltTab;

    UserAssert(!IsWinEventNotifyDeferred());

    /*
     * HACK: We have a problem with direct-draw full apps where an alttab
     *       window is created on a queue owned other than the RIT.  This
     *       shows up by alt-tabbing away from ROIDS.EXE during fullscreen.
     *
     *       What is happening is on a ALT-TAB, from xxxSysCommand(), the
     *       thread is not a rit.  xxxSysCommand() calls xxxOldNextWindow
     *       which finds that the current-thread doesn't have a switch
     *       window, and then creates one on the current-thread-queue.
     *
     *       The hack here is to make sure the calling thread is the RIT
     *       before allowing any cool-switch creation.
     *
     *       21-Mar-1996 : Chriswil
     */
#if 0
    ptiAltTab = ptiCurrent;
#else
    ptiAltTab = gptiRit;
#endif

    if (pq == NULL)
        return;

    fDir = (_GetAsyncKeyState(VK_SHIFT) < 0) ? FDIR_BACKWARD : FDIR_FORWARD;

    /*
     *  NOTE: As of NT 4.0 the slow Alt+Tab functionality now officially acts
     *  like Alt+Esc with the exception that Alt+Tab will activate the window
     *  where Alt+Esc will not.
     */
    switch (wParam) {

    case VK_TAB:

        if (gspwndAltTab == NULL) {

            PWND pwndSwitch;
            TL   tlpSwitchInfo;

            /*
             *  We are entering Alt+Tab for the first time, we need to
             *  initialize the Switch Window structure and if needed
             *  create and display the Alt+Tab window.  We have two special
             *  cases: (1) The user does not want to use the Switch window,
             *  (2) The initialize switch window fails thus we will act
             *  just like slow Alt+Tab
             */

            /*
             * Since Alt+Shift is the default hotkey for keyboard layout switching,
             * Alt+Shift+Tab may cause a KL switching while AltTab window is up.
             * To prevent it, we'd better reset the global toggle key state here,
             * so that xxxScanSysQueue will not confuse when it handles keyup messages.
             */
            gLangToggleKeyState = KLT_NONE;

            /*
             * Mouse buttons sometimes get stuck down due to hardware glitches,
             * usually due to input concentrator switchboxes or faulty serial
             * mouse COM ports, so clear the global button state here just in case,
             * otherwise we may not be able to change focus with the mouse.
             * Also do this in zzzCancelJournalling (Ctr-Esc, Ctrl-Alt-Del, etc.)
             */
#if DBG
            if (gwMouseOwnerButton)
                RIPMSG1(RIP_WARNING,
                        "gwMouseOwnerButton=%x, being forcibly cleared\n",
                        gwMouseOwnerButton);
#endif
            gwMouseOwnerButton = 0;

            /*
             *  Determine the current active window.
             */
            Lock(&gspwndActivate, pq->spwndActive);
            if (gspwndActivate == NULL) {
                Lock(&gspwndActivate, grpdeskRitInput->pDeskInfo->spwnd->spwndChild);
            }

            if (!gspwndActivate) {
                return;
            }

            /*
             *  Make a local copy of gspwndActivate and lock it because xxxFreeWindow will
             *  unlock if it is the window being freed.
             */
            pwndCurrentActivate = gspwndActivate;
            ThreadLockAlwaysWithPti(ptiCurrent, pwndCurrentActivate, &tlpwndCurrentActivate);

            /*
             *   Cancel the active window's mode
             */
            xxxSendMessageTimeout(pwndCurrentActivate, WM_CANCELMODE, 0, 0, SMTO_ABORTIFHUNG, 100, &dwResult);

            /*
             *  Initialize the Switch Window data structure, if we
             *  succeed create and display the window, otherwise act
             *  like slow Alt+Tab.
             */
            pwndActivateNext = InitSwitchWndInfo(&pswCurrent, pwndCurrentActivate, fDir);
            
            ThreadLockWithPti(ptiCurrent, pwndActivateNext, &tlpwndActivateNext);

            if (pswCurrent == NULL) {
                /*
                 *  Couldn't initialize our switch window data structure, so we
                 *  will act like Alt+Esc.
                 */
                goto DoSlowAltTab;
            }

            if (pwndActivateNext == NULL) {
                SwitchWndCleanup(&pswCurrent);
                ThreadUnlock(&tlpwndActivateNext);
                ThreadUnlock(&tlpwndCurrentActivate);
                Unlock(&gspwndActivate);
                return;
            }

            ThreadLockPool(ptiCurrent, pswCurrent, &tlpSwitchInfo);
            
            /*
             * Since we are in the RIT, test the physical state of the keyboard
             */
            pswCurrent->fJournaling = FALSE;

            /*
             *  Create the Alt+Tab window
             */
            pwndSwitch =
                  xxxNVCreateWindowEx( WS_EX_TOOLWINDOW | WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME,
                      (PLARGE_STRING)SWITCHWNDCLASS, NULL,
                      WS_POPUP | WS_BORDER | WS_DISABLED,
                      0, 0, 10, 10, NULL, NULL, NULL, NULL, VER40);

            if (gspwndAltTab != NULL) {
                RIPMSG0(RIP_WARNING, "xxxNextWindow: Creating a new switch window while one already exists.");

                _PostMessage(gspwndAltTab, WM_CLOSE, 0, 0);
            }

            Lock(&gspwndAltTab, pwndSwitch);

            ThreadUnlockPool(ptiCurrent, &tlpSwitchInfo);
            
            if (gspwndAltTab == NULL) {
                /*
                 *  Could not create the cool switch window, do the Alt+Esc thing
                 */
#ifdef COOLSWITCHTRACE
                DbgPrint("CoolSwitch: Could not create window (contact bradg).\n");
                UserAssert(gspwndAltTab != NULL);
#endif
                SwitchWndCleanup(&pswCurrent);
                goto DoSlowAltTab;
            }

            /*
             *  Save the pointer to the switch window info structure
             */
            Setpswi(gspwndAltTab, pswCurrent);
            /*
             *  Set gspwndActivate so the RIT knows what window we would like
             *  it to activate.
             */
            Lock(&gspwndActivate, pwndActivateNext);

            /*
             * Make sure that our rit queue has the correct pdesk
             */
            if (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD) {
                xxxSetThreadDesktop(NULL, grpdeskRitInput); // DeferWinEventNotify() ?? IANJA ??
            }

            /*
             * If we're currently full screen tell console to switch to
             * the desktop to GDI mode; we can't do this on the RIT because
             * it can be slow.
             */
            if (gspwndFullScreen != grpdeskRitInput->pDeskInfo->spwnd) {
                ThreadLockWithPti(ptiCurrent, grpdeskRitInput->pDeskInfo->spwnd, &tlpwndT);
                xxxSendNotifyMessage(grpdeskRitInput->pDeskInfo->spwnd, WM_FULLSCREEN, GDIFULLSCREEN, (LPARAM)HW(grpdeskRitInput->pDeskInfo->spwnd));
                ThreadUnlock(&tlpwndT);
            }

            /*
             *  Show the Alt+Tab window.  If it returns FALSE this means
             *  the ALT key has been released, so there is no need to
             *  paint the icons.
             */
            ThreadLockAlwaysWithPti(ptiCurrent, gspwndAltTab, &tlpwndT);
            xxxShowSwitchWindow(gspwndAltTab);
            ThreadUnlock(&tlpwndT);

            /*
             *  Exit now because the Switch window will have been
             *  already updated.
             */
            ThreadUnlock(&tlpwndActivateNext);
            ThreadUnlock(&tlpwndCurrentActivate);

        } else {

            /*
             *  We come here to do the actual switching and/or updating of
             *  the switch window when in Alt+Tab mode.
             */
            PWND    pwndSwitch;
            TL      tlpwndSwitch;
            PSWINFO pswCurrent;
            HWND    hwndActivateNext;
            HWND    hwndStop;

            if (!(pwndSwitch = gspwndAltTab)) {

                goto DoAltEsc;

            } else {
                /*
                 *  Move the hilight rect to the next/prev task.  It is possible
                 *  that some tasks were destoryed, so we need to skip those.
                 */
                ThreadLockAlwaysWithPti(ptiCurrent, pwndSwitch, &tlpwndSwitch);
                hwndStop = NULL;
                do {
                    pswCurrent = Getpswi(pwndSwitch);
                    if (pswCurrent == NULL) {
                        ThreadUnlock(&tlpwndSwitch);                    	
                        goto DoAltEsc;
                    }
                    hwndActivateNext = xxxMoveSwitchWndHilite(pwndSwitch, pswCurrent, fDir);
                    if (!hwndStop) {
                        hwndStop = hwndActivateNext;
                    } else {
                        if (hwndStop == hwndActivateNext) {
                            pwndActivateNext = NULL;
                            break;
                        }
                    }
                    pwndActivateNext = RevalidateHwnd(hwndActivateNext);
                } while (!pwndActivateNext);
                ThreadUnlock(&tlpwndSwitch);
                Lock(&gspwndActivate, pwndActivateNext);
                if (!gspwndActivate) {
                    /*
                     *  No Window to activate, bail out of Alt+Tab mode
                     */
                    xxxCancelCoolSwitch();
                }
            }
        }
        break;

DoAltEsc:
    case VK_ESCAPE:
        /*
         *  NOTE: The RIT doesn't use gspwndActivate to activate the window when
         *        processing Alt+Esc, we just use it here as a convenient
         *        variable.  The actual activation takes place below.
         */
        pwndCurrentActivate = pq->spwndActive;
        if (pwndCurrentActivate == NULL) {
            pwndCurrentActivate = pq->ptiKeyboard->rpdesk->pDeskInfo->spwnd->spwndChild;
        }
        if (!pwndCurrentActivate)
            return;
        ThreadLockAlwaysWithPti(ptiCurrent, pwndCurrentActivate, &tlpwndCurrentActivate);

        /*
         *   Cancel the active window's mode
         */
        xxxSendMessageTimeout(pwndCurrentActivate, WM_CANCELMODE, 0, 0, SMTO_ABORTIFHUNG, 100, &dwResult);

        /*
         * Determine the next window to activate
         */
        pwndActivateNext = _GetNextQueueWindow(pwndCurrentActivate, fDir, TRUE);
        ThreadLockWithPti(ptiCurrent, pwndActivateNext, &tlpwndActivateNext);

        /*
         * If we're going forward through the windows, move the currently
         * active window to the bottom so we'll do the right thing when
         * we go backwards.
         */
        if (pwndActivateNext != pwndCurrentActivate) {
DoSlowAltTab:
            if (pwndActivateNext) {

                /*
                 * We're about to activate another window while the ALT key is down,
                 *  so let the current focus window know that it doesn't need the
                 *  menu underlines anymore
                 */
                pwndCurrentTopFocus = GetTopLevelWindow(pq->spwndFocus);
                if ((pwndCurrentTopFocus != NULL) && (pwndCurrentTopFocus->spmenu != NULL)) {
                    ClearMF(pwndCurrentTopFocus->spmenu, MFUNDERLINE);
                }

                if (fDir == FDIR_FORWARD) {
                    /*
                     * For Alt+ESC only move the window to the bottom if it's
                     * not a top most window
                     */
                    if (!TestWF(pwndCurrentActivate, WEFTOPMOST)) {
                        xxxSetWindowPos(pwndCurrentActivate, PWND_BOTTOM, 0, 0, 0, 0,
                                SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE |
                                SWP_DEFERDRAWING | SWP_NOSENDCHANGING |
                                SWP_ASYNCWINDOWPOS);
                    }
                }

                /*
                 * The ALT key is down, so this window needs menu underlines
                 */
                if (pwndActivateNext->spmenu != NULL) {
                    SetMF(pwndActivateNext->spmenu, MFUNDERLINE);
                }


                /*
                 * This little ugly hack will cause xxxSetForegroundWindow2()
                 * to send out an activation messages to a queue that is
                 * already the active queue allowing us to change the active
                 * window on that queue.
                 */
                if (gpqForeground == GETPTI(pwndActivateNext)->pq)
                    gpqForeground = NULL;

                /*
                 * Make the selected window thread the owner of the last input;
                 *  since he's next, he owns the ALT-ESC.
                 */
                glinp.ptiLastWoken = GETPTI(pwndActivateNext);

                xxxSetForegroundWindow2(pwndActivateNext, NULL,
                        (wParam == VK_TAB) ? SFW_SWITCH | SFW_ACTIVATERESTORE : SFW_SWITCH);

                /*
                 * Win3.1 calls SetWindowPos() with activate, which z-orders
                 * first regardless, then activates. Our code relies on
                 * xxxActivateThisWindow() to z-order, and it'll only do
                 * it if the window does not have the child bit set (regardless
                 * that the window is a child of the desktop).
                 *
                 * To be compatible, we'll just force z-order here if the
                 * window has the child bit set. This z-order is asynchronous,
                 * so this'll z-order after the activate event is processed.
                 * That'll allow it to come on top because it'll be foreground
                 * then. (Grammatik has a top level window with the child
                 * bit set that wants to be come the active window).
                 */
                if (wParam == VK_TAB && TestWF(pwndActivateNext, WFCHILD)) {
                    xxxSetWindowPos(pwndActivateNext, (PWND)HWND_TOP, 0, 0, 0, 0,
                            SWP_NOSIZE | SWP_NOMOVE | SWP_ASYNCWINDOWPOS);
                }
            }
        }
        ThreadUnlock(&tlpwndActivateNext);
        ThreadUnlock(&tlpwndCurrentActivate);
        break;

    case VK_F6:
        if ((pwndCurrentActivate = pq->spwndActive) == NULL)
            pwndCurrentActivate = pq->ptiKeyboard->rpdesk->pDeskInfo->spwnd->spwndChild;

        pwndActivateNext = pwndCurrentActivate;

        /*
         * HACK! console sessions are all one thread but we want them
         * to act like different threads so if its a console thread (csrss.exe)
         * then ALT-F6 does nothing just like in Win 3.1
         * Note: we never get called with wParam == VK_F6 anyway. Win NT 3.51
         * doesn't seem to either, but Windows '95 does.  BUG?? (IanJa)
         */
        if (!(GETPTI(pwndActivateNext)->TIF_flags & TIF_CSRSSTHREAD)) {
            /*
             * on a alt-f6, we want to keep the switch within the thread.
             * We may want to rethink this because this will look strange
             * when you alt-f6 on a multi-threaded app we will not rotate
             * through the windows on the different threads.  This works
             * fine on Win 3.x because it is single threaded.
             */
            do {
                pwndActivateNext = NextTopWindow(pq->ptiKeyboard, pwndActivateNext, NULL,
                        fDir ? NTW_PREVIOUS : 0);
            } while( (pwndActivateNext != NULL) &&
                    (GETPTI(pwndActivateNext) != pq->ptiKeyboard));

            if (pwndActivateNext != NULL) {

                if (pwndActivateNext != pwndCurrentActivate) {
                    /*
                     * We're about to activate another window while the ALT key is down,
                     *  so let the current focus window know that it doesn't need the
                     *  menu underlines anymore
                     */
                    pwndCurrentTopFocus = GetTopLevelWindow(pq->spwndFocus);
                    if ((pwndCurrentTopFocus != NULL) && (pwndCurrentTopFocus->spmenu != NULL)) {
                        ClearMF(pwndCurrentTopFocus->spmenu, MFUNDERLINE);
                    }
                    /*
                     * The ALT key is down, so this window needs menu underlines
                     */
                    if (pwndActivateNext->spmenu != NULL) {
                        SetMF(pwndActivateNext->spmenu, MFUNDERLINE);
                    }
                }


                ThreadLockAlwaysWithPti(ptiCurrent, pwndActivateNext, &tlpwndActivateNext);
                xxxSetWindowPos(pwndActivateNext, PWND_BOTTOM, 0, 0, 0, 0,
                        SWP_DEFERDRAWING | SWP_NOSENDCHANGING | SWP_NOCHANGE |
                        SWP_ASYNCWINDOWPOS);
                xxxSetForegroundWindow2(pwndActivateNext, NULL, SFW_SWITCH);
                ThreadUnlock(&tlpwndActivateNext);
            }
        }
        break;
    }
}

/***************************************************************************\
* xxxOldNextWindow
*
* This function does the processing for the alt-tab/esc/F6 UI.
*
* History:
* 03-17-92  DavidPe     Ported from Win 3.1 sources
\***************************************************************************/

VOID xxxOldNextWindow(
    UINT flags)
{
    MSG         msg;
    HWND        hwndSel;
    PWND        pwndNewSel;
    PWND        pwndSel;
    BOOL        fType = 0;
    BOOL        fDrawIcon;
    WORD        vk;
    TL          tlpwndT;
    TL          tlpwndSel;
    TL          tlpwndSwitch;
    PSWINFO     pswCurrent;
    PWND        pwndSwitch;
    HWND        hwndStop;
    HWND        hwndNewSel;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PTHREADINFO ptiAltTab;
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * HACK: We have a problem with direct-draw full apps where an alttab
     *       window is created on a queue owned other than the RIT.  This
     *       shows up by alt-tabbing away from ROIDS.EXE during fullscreen.
     *
     *       What is happening is on a ALT-TAB, from xxxSysCommand(), the
     *       thread is not a rit.  xxxSysCommand() calls xxxOldNextWindow
     *       which finds that the current-thread doesn't have a switch
     *       window, and then creates one on the current-thread-queue.
     *
     *       The hack here is to make sure the calling thread is the RIT
     *       before allowing any cool-switch creation.
     *
     *       21-Mar-1996 : Chriswil
     */
#if 0
    ptiAltTab = ptiCurrent;
#else
    ptiAltTab = gptiRit;
#endif

    /*
     * Don't allow entering this routine when we're already in the AltTab
     * mode. The AltTab window may have been created via xxxNextWindow.
     */
    if (gspwndAltTab != NULL)
        return;

    if ((pwndSel = ptiCurrent->pq->spwndActive) == NULL)
        return;

    ThreadLockWithPti(ptiCurrent, pwndSel, &tlpwndSel);
    xxxCapture(ptiCurrent, pwndSel, SCREEN_CAPTURE);

    vk = (WORD)flags;
    msg.wParam = (UINT)flags;

    pwndNewSel = NULL;

    if (vk == VK_TAB) {

        TL tlpSwitchInfo;

        /*
         *  Initialize the Switch window data structures
         */
        pwndNewSel = InitSwitchWndInfo(&pswCurrent,
                                       pwndSel,
                                       _GetKeyState(VK_SHIFT) < 0);

        if (pswCurrent == NULL) {
            /*
             *  We were unable to initialize the data structure used by
             *  the Switch window, so we will act like Alt+Esc.
             */
        } else {

            PWND pwndSwitch;

            /*
             * We are doing a journal playback do use _GetKeyState to
             * test the keyboard
             */
            pswCurrent->fJournaling = TRUE;

            ThreadLockPool(ptiCurrent, pswCurrent, &tlpSwitchInfo);
            
            /*
             *  Attempt to create the Switch Window
             */

            pwndSwitch =
                 xxxNVCreateWindowEx(WS_EX_TOOLWINDOW | WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME,
                                   (PLARGE_STRING)SWITCHWNDCLASS,
                                   NULL,
                                   WS_POPUP | WS_BORDER | WS_DISABLED,
                                   0,
                                   0,
                                   10,
                                   10,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   VER40);

            if (gspwndAltTab != NULL) {
                RIPMSG0(RIP_WARNING, "xxxOldNextWindow: Creating a new switch window while one already exists.");

                _PostMessage(gspwndAltTab, WM_CLOSE, 0, 0);
            }

            ThreadUnlockPool(ptiCurrent, &tlpSwitchInfo);

            Lock(&gspwndAltTab, pwndSwitch);


            if (!(pwndSwitch = gspwndAltTab)) {

                SwitchWndCleanup(&pswCurrent);

            } else {
                /*
                 *  Lock the switch window
                 */
                ThreadLockAlwaysWithPti(ptiCurrent, pwndSwitch, &tlpwndSwitch);

                /*
                 *  Save the switch window info
                 */
                Setpswi(pwndSwitch, pswCurrent);

// Don't we need to switch from full screen mode if needed?
#if 0
                /*
                 * If we're currently full screen tell console to switch to
                 * the desktop to GDI mode; we can't do this on the RIT because
                 * it can be slow.
                 */
                if (gspwndFullScreen != grpdeskRitInput->pDeskInfo->spwnd) {
                    ThreadLockWithPti(pti, grpdeskRitInput->pDeskInfo->spwnd, &tlpwndT);
                    xxxSendNotifyMessage(grpdeskRitInput->pDeskInfo->spwnd, WM_FULLSCREEN, GDIFULLSCREEN, (LONG)HW(grpdeskRitInput->pDeskInfo->spwnd));
                    ThreadUnlock(&tlpwndT);
                }
#endif

                /*
                 *  Show the switch window, this also will paint the window
                 */
                xxxShowSwitchWindow(gspwndAltTab);
                ThreadUnlock(&tlpwndSwitch);
            }
        }

    }

    if (!pwndNewSel)
        goto StartTab;

    pwndSel = pwndNewSel;

    while (TRUE) {

        hwndSel = PtoH(pwndSel);
        /*
         * Wait for a message without getting it out of the queue.
         */
        while (!xxxPeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE | PM_NOYIELD))
            xxxWaitMessage();

        if ((pwndSel = RevalidateHwnd(hwndSel)) == NULL)
            pwndSel = ptiCurrent->pq->spwndActive;

        if (_CallMsgFilter(&msg, MSGF_NEXTWINDOW)) {
            /*
             * Swallow the message if the hook processed it
             */
            xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
            continue;
        }

        /*
         * If we are doing Alt+Tab and some other key comes in (other than
         * tab, escape or shift), then bomb out of this loop and leave that
         * key in the queue.
         */
        if ((msg.message == WM_SYSKEYDOWN) && gspwndAltTab != NULL) {

            vk = (WORD)msg.wParam;

            if ((vk != VK_TAB) && (vk != VK_ESCAPE) && (vk != VK_SHIFT)) {
                pwndSel = ptiCurrent->pq->spwndActive;
                fType = 0;
                goto Exit;
            }
        }

        switch (msg.message) {

        case WM_CANCELJOURNAL:
            /*
             *  If journalling was canceled we need to exit our loop and
             *  remove the Alt+Tab window.  We don't want to remove this
             *  meesage because we want the app to know that journalling
             *  was canceled.
             */

            /* > > >  F A L L   T H R O U G H  < < < */
        case WM_HOTKEY:
            /*
             * When pressing ALT-CTL-ESC-DEL on the logon desktop
             * We eat WM_KEYUP and the queue for the wiinlogon thread will be empty so will be stuck
             * in xxxWaitMessage() forever till the user do a mouse click where we will exit the loop in the below case statement.
             * consider WM_HOTKEY as a valid exit case.
             * [msadek -- 03/17/2001, bug# 337206]
             */

            /* > > >  F A L L   T H R O U G H  < < < */             
        case WM_LBUTTONDOWN:
        case WM_LBUTTONUP:
        case WM_RBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_MBUTTONDOWN:
        case WM_MBUTTONUP:
        case WM_XBUTTONDOWN:
        case WM_XBUTTONUP:
            /*
             * If mouse message, cancel and get out of loop.
             */
            pwndSel = ptiCurrent->pq->spwndActive;
            fType = 0;
            goto Exit;

        case WM_KEYUP:
        case WM_KEYDOWN:
        case WM_SYSCHAR:
        case WM_SYSKEYUP:
        case WM_MOUSEMOVE:
            /*
             * Swallow the message
             */
            hwndSel = PtoH(pwndSel);
            xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);

            if ((pwndSel = RevalidateHwnd(hwndSel)) == NULL)
                pwndSel = ptiCurrent->pq->spwndActive;

            if (msg.message == WM_KEYUP || msg.message == WM_SYSKEYUP) {

                vk = (WORD)msg.wParam;

                /*
                 * If alt-tab up, then exit.
                 */
                if (vk == VK_MENU) {
                    /*
                     * If doing Alt+Esc, wait for up of ESC to get out.
                     */
                    if (gspwndAltTab == NULL)
                        break;

                    fType = 0;
                    goto Exit;

                } else if (vk == VK_ESCAPE || vk == VK_F6) {
                    /*
                     * Get out on up transition of ESC or F6 keys.
                     */
                    if (gspwndAltTab != NULL) {

                        pwndSel = ptiCurrent->pq->spwndActive;
                        fType = 0;

                    } else {

                        fType = ((vk == VK_ESCAPE) ? ALT_ESCAPE : ALT_F6);
                    }

                    goto Exit;
                }

            } else if (msg.message == WM_KEYDOWN) {
                /*
                 *  Exit out loop is a stray key stroke comes through.  In
                 *  particular look for VK_CONTROL.
                 */
                pwndSel = ptiCurrent->pq->spwndActive;
                fType = 0;
                goto Exit;
            }
            break;

        case WM_SYSKEYDOWN:
            vk = (WORD)msg.wParam;

            switch (vk) {

            case VK_SHIFT:
            case VK_TAB:
            case VK_ESCAPE:
            case VK_F6:

                hwndSel = PtoH(pwndSel);
                xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);

                if ((pwndSel = RevalidateHwnd(hwndSel)) == NULL)
                    pwndSel = ptiCurrent->pq->spwndActive;

                if (!(vk == VK_TAB))
                    break;
StartTab:
                if (vk == VK_ESCAPE) {
                    pwndNewSel = _GetNextQueueWindow(
                            pwndSel,
                            _GetKeyState(VK_SHIFT) < 0,
                            TRUE);

                    if (pwndNewSel == NULL)
                        break;

                    fType = ALT_ESCAPE;
                    pwndSel = pwndNewSel;

                    /*
                     * Wait until ESC goes up to activate new window.
                     */
                    break;
                }
                if (vk == VK_F6) {

                    PWND pwndFirst;
                    PWND pwndSaveSel = pwndSel;

                    /*
                     * Save the first returned window to act as a limit
                     * to the search because NextTopWindow will return NULL
                     * only if pwndSel is the only window that meets its
                     * selection criteria.
                     *
                     * This prevents a hang that can occur in winword or
                     * excel when then Alt-F4-F6 key combination is hit
                     * and unsaved changes exist.
                     */
                    pwndFirst = pwndNewSel = (PWND)NextTopWindow(ptiCurrent, pwndSel, NULL,
                            _GetKeyState(VK_SHIFT) < 0 ? NTW_PREVIOUS : 0);

                    while (TRUE) {

                        /*
                         * If pwndNewSel is NULL, pwndSel is the only candidate.
                         */
                        if (pwndNewSel == NULL)
                            break;

                        pwndSel = pwndNewSel;

                        /*
                         * If the window is on the same thread, wait until
                         * F6 goes up to activate new window.
                         */
                        if (GETPTI(pwndSel) == ptiCurrent)
                            break;

                        pwndNewSel = (PWND)NextTopWindow(ptiCurrent, pwndSel, NULL,
                                _GetKeyState(VK_SHIFT) < 0 ? NTW_PREVIOUS : 0);

                        /*
                         * If we've looped around, use the original window.
                         * Wait until F6 goes up to activate new window.
                         */
                        if (pwndNewSel == pwndFirst) {
                            pwndSel = pwndSaveSel;
                            break;
                        }
                    }
                    break;
                }

                /*
                 * Here for the Alt+Tab case
                 */
                if ((pwndSwitch = gspwndAltTab) != NULL) {
                    ThreadLockWithPti(ptiCurrent, pwndSwitch, &tlpwndSwitch);
                    hwndStop = NULL;
                    do {

                        pswCurrent = Getpswi(pwndSwitch);
                        if (pswCurrent == NULL) {
                            break;
                        }
                        hwndNewSel = xxxMoveSwitchWndHilite(
                                pwndSwitch,
                                pswCurrent,
                                _GetKeyState(VK_SHIFT) < 0);

                        if (!hwndStop) {
                            hwndStop = hwndNewSel;
                        } else {
                            if (hwndStop == hwndNewSel) {
                                pwndNewSel = NULL;
                                break;
                            }
                        }
                        pwndNewSel = RevalidateHwnd(hwndNewSel);
                    } while (!pwndNewSel);
                    ThreadUnlock(&tlpwndSwitch);
                    pwndSel = pwndNewSel;

                } else {

                    pwndNewSel = _GetNextQueueWindow(
                            pwndSel,
                            _GetKeyState(VK_SHIFT) < 0,
                            FALSE);

                    if (pwndNewSel && pwndNewSel != pwndSel) {

                        if (!TestWF(pwndSel, WEFTOPMOST)) {
                            /*
                             *  Force the old window to the bottom
                             */
                            ThreadLockWithPti(ptiCurrent, pwndSel, &tlpwndT);
                            xxxSetWindowPos(pwndSel,
                                            PWND_BOTTOM,
                                            0,
                                            0,
                                            0,
                                            0,
                                            SWP_NOMOVE             |
                                                SWP_NOSIZE         |
                                                SWP_NOACTIVATE     |
                                                SWP_DEFERDRAWING   |
                                                SWP_NOSENDCHANGING |
                                                SWP_ASYNCWINDOWPOS);
                            ThreadUnlock(&tlpwndT);
                        }

                        pwndSel = pwndNewSel; // Will be revalidated at top of loop
                    }
                }
                break;

            default:
                goto Exit;
            }
            break;

        default:
            hwndSel = PtoH(pwndSel);
            xxxPeekMessage(&msg, NULL, msg.message, msg.message, PM_REMOVE);
            xxxTranslateMessage(&msg, 0);
            xxxDispatchMessage(&msg);

            if ((pwndSel = RevalidateHwnd(hwndSel)) == NULL)
                pwndSel = ptiCurrent->pq->spwndActive;

            break;
        }
    }

Exit:
    xxxReleaseCapture();

    fDrawIcon = (gspwndAltTab != NULL);

    /*
     * If this is an Alt-Escape we also have to send the current window
     * to the bottom.
     */
    if (fType == ALT_ESCAPE) {

        PWND pwndActive;

        if (gpqForeground) {

            pwndActive = gpqForeground->spwndActive;

            if (pwndActive && (pwndActive != pwndSel)) {
                ThreadLockWithPti(ptiCurrent, pwndActive, &tlpwndT);
                xxxSetWindowPos(pwndActive,
                                PWND_BOTTOM,
                                0,
                                0,
                                0,
                                0,
                                SWP_NOMOVE             |
                                    SWP_NOSIZE         |
                                    SWP_NOACTIVATE     |
                                    SWP_DEFERDRAWING   |
                                    SWP_NOSENDCHANGING |
                                    SWP_ASYNCWINDOWPOS);
                ThreadUnlock(&tlpwndT);
            }
        }
    }

    if (pwndSel) {
        ThreadLockWithPti(ptiCurrent, pwndSel, &tlpwndT);
        xxxSetForegroundWindow(pwndSel, FALSE);

        if (TestWF(pwndSel, WFMINIMIZED)) {

            if ((fType == 0) && fDrawIcon)
                _PostMessage(pwndSel, WM_SYSCOMMAND, (UINT)SC_RESTORE, 0);

        }
        ThreadUnlock(&tlpwndT);
    }

    /*
     * destroy the alt-tab window
     */
    xxxCancelCoolSwitch();

    ThreadUnlock(&tlpwndSel);
}

/*****************************************************************************\
*
* GetAltTabInfo()   -   Active Accessibility API for OLEACC
*
* This succeeds if we are currently in alt-tab mode.
*
\*****************************************************************************/
BOOL WINAPI
_GetAltTabInfo(
    int iItem,
    PALTTABINFO pati,
    LPWSTR ccxpwszItemText,
    UINT cchItemText OPTIONAL,
    BOOL bAnsi)
{
    PSWINFO pswCurrent;

    if (!gspwndAltTab || ((pswCurrent = Getpswi(gspwndAltTab)) == NULL)) {
        RIPERR0(ERROR_NOT_FOUND, RIP_WARNING, "no Alt-Tab window");
        return FALSE;
    }

    /*
     * Fill in general information
     */
    pati->cItems = pswCurrent->iTotalTasks;
    pati->cColumns = pswCurrent->iNoOfColumns;
    pati->cRows = pswCurrent->iNoOfRows;

    pati->iColFocus = pswCurrent->iCurCol;
    pati->iRowFocus = pswCurrent->iCurRow;

    pati->cxItem = CXICONSLOT;
    pati->cyItem = CYICONSLOT;
    pati->ptStart = pswCurrent->ptFirstRowStart;

    /*
     * Fill in specific information if asked.
     */
    if (cchItemText && (iItem >= 0)) {
        PWND    pwndCur;

        pwndCur = NULL;

        try {
            if ((iItem < pswCurrent->iTotalTasks) &&
                    (pwndCur = RevalidateHwnd(pswCurrent->pbwl->rghwnd[iItem]))) {
                if (bAnsi) {
                    LPSTR ccxpszItemText = (LPSTR)ccxpwszItemText;
                    ULONG cch;
                    RtlUnicodeToMultiByteN(ccxpszItemText, cchItemText - 1,
                            &cch, pwndCur->strName.Buffer, pwndCur->strName.Length);
                    ccxpszItemText[cch] = '\0';
                } else {
                    TextCopy(&pwndCur->strName, ccxpwszItemText, cchItemText);
                }
            } else {
                // no such item
                NullTerminateString(ccxpwszItemText, bAnsi);
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\timers.c ===
/****************************** Module Header ******************************\
* Module Name: timers.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the user timer APIs and support routines.
*
* History:
* 12-Nov-1990 DarrinM   Created.
* 08-Apr-1992 DarrinM   Switched to PM/Win3-like ScanTimers model.
\***************************************************************************/

#define _TIMERS 1      // uses a LARGE_INTEGER
#include "precomp.h"
#pragma hdrstop


/*
 * Make sure that if we return a timer id that it is a WORD value. This
 * will ensure that WOW doesn't need to handle-translate return values
 * from SetTimer().
 *
 * Start with a large number so that FindTimer() doesn't find a timer we
 * calculated with a low cTimerId if the app happens to pass in NULL pwnd
 * and a low id (like 1).
 */
#define TIMERID_MAX   0x7FFF
#define TIMERID_MIN   0x100

#define ELAPSED_MAX  0x7FFFFFFF

#define SYSRIT_TIMER  (TMRF_SYSTEM | TMRF_RIT)

WORD cTimerId = TIMERID_MAX;

/***************************************************************************\
* _SetTimer (API)
*
* This API will start the specified timer.
*
* History:
* 15-Nov-1990 DavidPe   Created.
\***************************************************************************/

UINT_PTR _SetTimer(
    PWND         pwnd,
    UINT_PTR     nIDEvent,
    UINT         dwElapse,
    TIMERPROC_PWND pTimerFunc)
{
    /*
     * Prevent apps from setting a Timer with a window proc to another app
     */
    if (pwnd && (PpiCurrent() != GETPTI(pwnd)->ppi)) {

        RIPERR1(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Calling SetTimer with window of another process %lX",
                pwnd);

        return 0;
    }

    return InternalSetTimer(pwnd, nIDEvent, dwElapse, pTimerFunc, 0);
}

/***************************************************************************\
* _SetSystemTimer
*
* This API will start start a system timer which will generate WM_SYSTIMER
* messages rather than WM_TIMER
*
* History:
* 15-Nov-1990 DavidPe   Created.
* 21-Jan-1991 IanJa     Prefix '_' denotes export function (not API)
\***************************************************************************/

UINT_PTR _SetSystemTimer(
    PWND         pwnd,
    UINT_PTR     nIDEvent,
    DWORD        dwElapse,
    TIMERPROC_PWND pTimerFunc)
{
    /*
     * Prevent apps from setting a Timer with a window proc to another app
     */
    if (pwnd && PpiCurrent() != GETPTI(pwnd)->ppi) {

        RIPERR1(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Calling SetSystemTimer with window of another process %lX",
                pwnd);

        return 0;
    }

    return InternalSetTimer(pwnd, nIDEvent, dwElapse, pTimerFunc, TMRF_SYSTEM);
}

/***************************************************************************\
* FreeTimer
*
* This function does the actual unlinking and freeing of the timer structure.
* I pulled it out of FindTimer() so it could be shared with DestroyQueues-
* Timers.
* Sets *pptmr to point to the next TIMER struct (NULL if none)
*
* History:
* 15-Feb-1991 DarrinM   Pulled from FindTimer().
\***************************************************************************/

VOID FreeTimer(
    PTIMER ptmr) {

    CheckCritIn();

    /*
     * Mark it for destruction.  If it the object is locked it can't
     * be freed right now.
     */
    if (!HMMarkObjectDestroy((PVOID)ptmr))
        return;

    /*
     * If this timer was just about to be processed, decrement
     * the ready-count since we're blowing it off.
     */
    if (ptmr->flags & TMRF_READY)
        DecTimerCount(ptmr->pti);

    /*
     * Unlock the window
     */
    Unlock(&ptmr->spwnd);

    /*
     * Unlink this timer
     */
    if (ptmr->ptmrPrev) {
        ptmr->ptmrPrev->ptmrNext = ptmr->ptmrNext;
    } else {
        gptmrFirst = ptmr->ptmrNext;
    }

    if (ptmr->ptmrNext) {
        ptmr->ptmrNext->ptmrPrev = ptmr->ptmrPrev;
    }

    /*
     * Free up the TIMER structure.
     */
    HMFreeObject((PVOID)ptmr);
}


/***************************************************************************\
* FindTimer
*
* This function will find a timer that matches the parameters.  We also
* deal with killing timers here since it's easier to remove items from
* the list while we're scanning it.
*
* History:
* 15-Nov-1990 DavidPe   Created.
\***************************************************************************/

PTIMER FindTimer(
    PWND pwnd,
    UINT_PTR nID,
    UINT flags,
    BOOL fKill)
{
    PTIMER ptmr;

    ptmr = gptmrFirst;

    while (ptmr != NULL) {

        /*
         * Is this the timer we're looking for?
         */
        if ((ptmr->spwnd == pwnd) &&
            (ptmr->nID == nID)    &&
            (ptmr->flags & SYSRIT_TIMER) == (flags & SYSRIT_TIMER)) {

            /*
             * Are we being called from KillTimer()? If so, destroy the
             * timer.  return != 0 because *pptmr is gone.
             */
            if (fKill) {
                FreeTimer(ptmr);
                return (PTIMER)TRUE;
            }

            /*
             * Found the timer, break out of the loop.
             */
            break;
        }

        /*
         * No, try the next one.
         */
        ptmr = ptmr->ptmrNext;
    }

    return ptmr;
}

/***************************************************************************\
* InternalSetTimer
*
* This is the guts of SetTimer that actually gets things going.
*
* NOTE (darrinm): Technically there is a bit of latency (the time it takes
* between SetTimer's NtSetEvent and when the RIT wakes up and calls ScanTimers)
* between when SetTimer is called and when the counter starts counting down.
* This is uncool but it should be a very short amount of time because the RIT
* is high-priority.  If it becomes a problem I know how to fix it.
*
* History:
* 15-Nov-1990 DavidPe      Created.
\***************************************************************************/

UINT_PTR InternalSetTimer(
    PWND         pwnd,
    UINT_PTR     nIDEvent,
    UINT         dwElapse,
    TIMERPROC_PWND pTimerFunc,
    UINT         flags)
{
    LARGE_INTEGER liT = {1, 0};
    PTIMER        ptmr;
    PTHREADINFO   ptiCurrent;

    CheckCritIn();

    /*
     * Assert if someone tries to set a timer after InitiateWin32kCleanup
     * killed the RIT.
     */
    UserAssert(gptiRit != NULL);

    /*
     * 1.0 compatibility weirdness. Also, don't allow negative elapse times
     * because this'll cause ScanTimers() to generate negative elapse times
     * between timers.
     */
    if ((dwElapse == 0) || (dwElapse > ELAPSED_MAX))
        dwElapse = 1;

    /*
     * Attempt to first locate the timer, then create a new one
     * if one isn't found.
     */
    if ((ptmr = FindTimer(pwnd, nIDEvent, flags, FALSE)) == NULL) {

        /*
         * Not found.  Create a new one.
         */
        ptmr = (PTIMER)HMAllocObject(NULL, NULL, TYPE_TIMER, sizeof(TIMER));
        if (ptmr == NULL) {
            return 0;
        }

        ptmr->spwnd = NULL;

        if (pwnd == NULL) {

            WORD timerIdInitial = cTimerId;

            /*
             * Pick a unique, unused timer ID.
             */
            do {

                if (--cTimerId <= TIMERID_MIN)
                    cTimerId = TIMERID_MAX;

                if (cTimerId == timerIdInitial) {

                    /*
                     * Flat out of timers bud.
                     */
                    HMFreeObject(ptmr);
                    return 0;
                }

            } while (FindTimer(NULL, cTimerId, flags, FALSE) != NULL);

            ptmr->nID = (UINT)cTimerId;

        } else {
            ptmr->nID = nIDEvent;
        }

        /*
         * Link the new timer into the front of the list.
         * Handily this works even when gptmrFirst is NULL.
         */
        ptmr->ptmrNext = gptmrFirst;
        ptmr->ptmrPrev = NULL;
        if (gptmrFirst)
            gptmrFirst->ptmrPrev = ptmr;
        gptmrFirst = ptmr;

    } else {

        /*
         * If this timer was just about to be processed,
         * decrement cTimersReady since we're resetting it.
         */
        if (ptmr->flags & TMRF_READY)
            DecTimerCount(ptmr->pti);
    }

    /*
     * If pwnd is NULL, create a unique id by
     * using the timer handle.  RIT timers are 'owned' by the RIT pti
     * so they are not deleted when the creating pti dies.
     *
     * We used to record the pti as the pti of the window if one was
     * specified.  This is not what Win 3.1 does and it broke 10862
     * where some merge app was setting the timer on winword's window
     * it it still expected to get the messages not winword.
     *
     * MS Visual C NT was counting on this bug in the NT 3.1 so if
     * a thread sets a timer for a window in another thread in the
     * same process the timer goes off in the thread of the window.
     * You can see this by doing a build in msvcnt and the files being
     * compiled do not show up.
     */
    ptiCurrent = (PTHREADINFO)(W32GetCurrentThread()); /*
                                                        * This will be NULL
                                                        * for a non-GUI thread.
                                                        */

    if (pwnd == NULL) {

        if (flags & TMRF_RIT) {
            ptmr->pti = gptiRit;
        } else {
            ptmr->pti = ptiCurrent;
            UserAssert(ptiCurrent);
        }

    } else {

        /*
         * As enforced in the API wrappers.  We shouldn't get here
         * any other way for an app timer.
         *
         * Always use pti of the window when TMRF_PTIWINDOW is passed in.
         */
        if ((ptiCurrent->TIF_flags & TIF_16BIT) && !(flags & TMRF_PTIWINDOW)) {
            ptmr->pti = ptiCurrent;
            UserAssert(ptiCurrent);
        } else {
            ptmr->pti = GETPTI(pwnd);
        }
    }

    /*
     * Initialize the timer-struct.
     *
     * NOTE: The ptiOptCreator is used to identify a JOURNAL-timer.  We
     *       want to allow these timers to be destroyed when the creator
     *       thread goes away.  For other threads that create timers across
     *       threads, we do not want to destroy these timers when the
     *       creator goes away.  Currently, we're only checking for a
     *       TMRF_RIT.  However, in the future we might want to add this
     *       same check for TMRF_SYSTEM.
     */
    Lock(&(ptmr->spwnd), pwnd);

    ptmr->cmsCountdown  = ptmr->cmsRate = dwElapse;
    ptmr->flags         = flags | TMRF_INIT;
    ptmr->pfn           = pTimerFunc;
    ptmr->ptiOptCreator = (flags & TMRF_RIT ? ptiCurrent : NULL);

    /*
     * Force the RIT to scan timers.
     *
     * N.B. The following code sets the raw input thread timer to expire
     *      at the absolute time 1 which is very far into the past. This
     *      causes the timer to immediately expire before the set timer
     *      call returns.
     */
    if (ptiCurrent == gptiRit) {
        /*
         * Don't let RIT timer loop reset the master timer - we already have.
         */
        gbMasterTimerSet = TRUE;
    }

    UserAssert(gptmrMaster);
    KeSetTimer(gptmrMaster, liT, NULL);

    /*
     * Windows 3.1 returns the timer ID if non-zero, otherwise it returns 1.
     */
    return (ptmr->nID == 0 ? 1 : ptmr->nID);
}

/***************************************************************************\
* _KillTimer (API)
*
* This API will stop a timer from sending WM_TIMER messages.
*
* History:
* 15-Nov-1990 DavidPe   Created.
\***************************************************************************/

BOOL _KillTimer(
    PWND pwnd,
    UINT_PTR nIDEvent)
{
    return KillTimer2(pwnd, nIDEvent, FALSE);
}

/***************************************************************************\
* _KillSystemTimer
*
* This API will stop a system timer from sending WM_SYSTIMER messages.
*
* History:
* 15-Nov-1990 DavidPe   Created.
* 21-Jan-1991 IanJa     Prefix '_' denotes export function (not API)
\***************************************************************************/

BOOL _KillSystemTimer(
    PWND pwnd,
    UINT_PTR nIDEvent)
{
    return KillTimer2(pwnd, nIDEvent, TRUE);
}

/***************************************************************************\
* KillTimer2
*
* This is the guts of KillTimer that actually kills the timer.
*
* History:
* 15-Nov-1990 DavidPe       Created.
\***************************************************************************/

BOOL KillTimer2(
    PWND pwnd,
    UINT_PTR nIDEvent,
    BOOL fSystemTimer)
{
    /*
     * Call FindTimer() with fKill == TRUE.  This will
     * basically delete the timer.
     */
    return (FindTimer(pwnd,
                      nIDEvent,
                      (fSystemTimer ? TMRF_SYSTEM : 0),
                      TRUE) != NULL);
}

/***************************************************************************\
* DestroyQueuesTimers
*
* This function scans through all the timers and destroys any that are
* associated with the specified queue.
*
* History:
* 15-Feb-1991 DarrinM   Created.
\***************************************************************************/

VOID DestroyThreadsTimers(
    PTHREADINFO pti)
{
    PTIMER ptmr;

    ptmr = gptmrFirst;

    while (ptmr != NULL) {

        /*
         * Is this one of the timers we're looking for?  If so, destroy it.
         */
        if (ptmr->pti == pti || ptmr->ptiOptCreator == pti) {
            PTIMER ptmrNext = ptmr->ptmrNext;
            FreeTimer(ptmr);
            ptmr = ptmrNext;
        } else {
            ptmr = ptmr->ptmrNext;
        }
    }
}

/***************************************************************************\
* DestroyWindowsTimers
*
* This function scans through all the timers and destroys any that are
* associated with the specified window.
*
* History:
* 04-Jun-1991 DarrinM       Created.
\***************************************************************************/

VOID DestroyWindowsTimers(
    PWND pwnd)
{
    PTIMER ptmr;

    ptmr = gptmrFirst;

    while (ptmr != NULL) {

        /*
         * Is this one of the timers we're looking for?  If so, destroy it.
         */
        if (ptmr->spwnd == pwnd) {
            PTIMER ptmrNext = ptmr->ptmrNext;
            FreeTimer(ptmr);
            ptmr = ptmrNext;
        } else {
            ptmr = ptmr->ptmrNext;
        }
    }
}

/***************************************************************************\
* DoTimer
*
* This function gets called from xxxPeekMessage() if the QS_TIMER bit is
* set.  If this timer is okay with the filter specified the appropriate
* WM_*TIMER message will be placed in 'pmsg' and the timer will be reset.
*
* History:
* 15-Nov-1990 DavidPe   Created.
* 27-NOv-1991 DavidPe   Changed to move 'found' timers to end of list.
\***************************************************************************/

BOOL DoTimer(
    PWND pwndFilter)
{
    PTHREADINFO pti;
    PTIMER      ptmr;
    PTIMER      ptmrNext;
    PQMSG       pqmsg;

    CheckCritIn();

    pti = PtiCurrent();

    /*
     * Search for a timer that belongs to this queue.
     */
    ptmr = gptmrFirst;

    while (ptmr != NULL) {

        /*
         * Has this timer gone off and is it one we're looking for?
         */
        if ((ptmr->flags & TMRF_READY) &&
            (ptmr->pti == pti)         &&
            CheckPwndFilter(ptmr->spwnd, pwndFilter)) {

            /*
             * We found an appropriate timer. Put it in the app's queue and
             * return success.
             */
            if ((pqmsg = AllocQEntry(&pti->mlPost)) != NULL) {

                /*
                 * Store the message and set the QS_POSTMESSAGE bit so the
                 * thread knows it has a message.
                 */
                StoreQMessage(pqmsg,
                              ptmr->spwnd,
                              (UINT)((ptmr->flags & TMRF_SYSTEM) ?
                                      WM_SYSTIMER : WM_TIMER),
                              (WPARAM)ptmr->nID,
                              (LPARAM)ptmr->pfn,
                              0, 0, 0);
#ifdef REDIRECTION
                StoreQMessagePti(pqmsg, pti);
#endif // REDIRECTION
                SetWakeBit(pti, QS_POSTMESSAGE | QS_ALLPOSTMESSAGE);
            }

            /*
             * Reset this timer.
             */
            ptmr->flags &= ~TMRF_READY;
            DecTimerCount(ptmr->pti);

            /*
             * If there are other timers in the system move this timer
             * to the end of the list so other timers in for this queue
             * get a chance to go off.
             */
            ptmrNext = ptmr->ptmrNext;
            if (ptmrNext != NULL) {

                /*
                 * Remove ptmr from its place in the list.
                 */
                if (ptmr->ptmrPrev) {
                    ptmr->ptmrPrev->ptmrNext = ptmr->ptmrNext;
                } else
                    gptmrFirst = ptmr->ptmrNext;

                ptmrNext->ptmrPrev = ptmr->ptmrPrev;

                /*
                 * Move to the last TIMER of the list.
                 */
                while (ptmrNext->ptmrNext != NULL)
                    ptmrNext = ptmrNext->ptmrNext;

                /*
                 * Insert this timer at the end.
                 */
                ptmrNext->ptmrNext = ptmr;
                ptmr->ptmrPrev = ptmrNext;
                ptmr->ptmrNext     = NULL;
            }

            return TRUE;
        }

        ptmr = ptmr->ptmrNext;
    }

    return FALSE;
}

/***************************************************************************\
* DecTimerCount
*
* This routine decrements cTimersReady and clears QS_TIMER if the count
* goes down to zero.
*
* History:
* 21-Jan-1991 DavidPe   Created.
\***************************************************************************/

VOID DecTimerCount(
    PTHREADINFO pti)
{
    CheckCritIn();

    if (--pti->cTimersReady == 0)
        pti->pcti->fsWakeBits &= ~QS_TIMER;
}

/***************************************************************************\
* JournalTimer
*
*
* History:
* 04-Mar-1991 DavidPe       Created.
\***************************************************************************/

VOID JournalTimer(
    PWND  pwnd,
    UINT  message,
    UINT_PTR nID,
    LPARAM lParam)
{
    PTHREADINFO pti;

    DBG_UNREFERENCED_PARAMETER(pwnd);
    DBG_UNREFERENCED_PARAMETER(message);
    DBG_UNREFERENCED_PARAMETER(nID);

    /*
     * We've already entered the critical section.
     */
    if (pti = ((PTIMER)lParam)->ptiOptCreator)
        WakeSomeone(pti->pq, pti->pq->msgJournal, NULL);

    return;
}

/***************************************************************************\
* SetJournalTimer
*
* Sets an NT timer that goes off in 'dt' milliseconds and will wake
* up 'pti' at that time.  This is used in journal playback code to
* simulate the timing in which events were originally given to the system.
*
* History:
* 04-Mar-1991 DavidPe       Created.
\***************************************************************************/

void SetJournalTimer(
    DWORD dt,
    UINT  msgJournal)
{
    static UINT_PTR idJournal = 0;

    PtiCurrent()->pq->msgJournal = msgJournal;

    /*
     * Remember idJournal - because TMRF_ONESHOT timers stay in the timer
     * list - by remembering the idJournal, we always reuse the same timer
     * rather than creating new ones always.
     */
    idJournal = InternalSetTimer(NULL,
                                 idJournal,
                                 dt,
                                 JournalTimer,
                                 TMRF_RIT | TMRF_ONESHOT);
}

/***************************************************************************\
* StartTimers
*
* Prime the timer pump by starting the cursor restoration timer.
*
* History:
* 02-Apr-1992 DarrinM   Created.
\***************************************************************************/

UINT_PTR StartTimers(VOID)
{
    /*
     * Let GDI know that it can start settings timers on the RIT.
     */
    GreStartTimers();

    /*
     * TMRF_RIT timers are called directly from ScanTimers -- no nasty
     * thread switching for these boys.
     */
    return InternalSetTimer(NULL, 0, 1000, xxxHungAppDemon, TMRF_RIT);
}


/***************************************************************************\
* TimersProc
*
* Deal with the timers. Called from RawInputThread.
*
* History:
* 11-11-1996 CLupu   Created.
\***************************************************************************/

VOID TimersProc(
    VOID)
{
    DWORD          dmsSinceLast;
    LARGE_INTEGER  liT;
    PTIMER         ptmr;
    DWORD          cmsCur;
    DWORD          dmsNextTimer;

    /*
     * Calculate how long it was since the last time we
     * processed timers so we can subtract that much time
     * from each timer's countdown value.
     */
    EnterCrit();

    cmsCur = NtGetTickCount();
    dmsSinceLast = ComputePastTickDelta(cmsCur, gcmsLastTimer);
    gcmsLastTimer = cmsCur;

    /*
     * dmsNextTimer is the time delta before the next
     * timer should go off.  As we loop through the
     * timers below this will shrink to the smallest
     * cmsCountdown value in the list.
     */
    dmsNextTimer = ELAPSED_MAX;
    ptmr = gptmrFirst;
    gbMasterTimerSet = FALSE;
    while (ptmr != NULL) {

        /*
         * ONESHOT timers go to a WAITING state after
         * they go off. This allows us to leave them
         * in the list but keep them from going off
         * over and over.
         */
        if (ptmr->flags & TMRF_WAITING) {
            ptmr = ptmr->ptmrNext;
            continue;
        }

        /*
         * The first time we encounter a timer we don't
         * want to set it off, we just want to use it to
         * compute the shortest countdown value.
         */
        if (ptmr->flags & TMRF_INIT) {
            ptmr->flags &= ~TMRF_INIT;

        } else {
            /*
             * If this timer is going off, wake up its
             * owner.
             */
            if (ptmr->cmsCountdown > dmsSinceLast) {
                ptmr->cmsCountdown -= dmsSinceLast;
            } else {
                UserAssert(ptmr->cmsRate <= ELAPSED_MAX);
                ptmr->cmsCountdown = ptmr->cmsRate;

                /*
                 * If the timer's owner hasn't handled the
                 * last time it went off yet, throw this event
                 * away.
                 */
                if (!(ptmr->flags & TMRF_READY)) {
                    /*
                     * A ONESHOT timer goes into a WAITING state
                     * until SetTimer is called again to reset it.
                     */
                    if (ptmr->flags & TMRF_ONESHOT)
                        ptmr->flags |= TMRF_WAITING;

                    /*
                     * RIT timers have the distinction of being
                     * called directly and executing serially with
                     * with incoming timer events.
                     * NOTE: RIT timers get called while we're
                     * inside the critical section.
                     */
                    if (ptmr->flags & TMRF_RIT) {
                        TL tlTimer;

                        ThreadLock(ptmr, &tlTimer);
                        /*
                         * May set gbMasterTimerSet
                         */
                        (ptmr->pfn)(NULL,
                                    WM_SYSTIMER,
                                    ptmr->nID,
                                    (LPARAM)ptmr);

                        if (HMIsMarkDestroy(ptmr)) {
                            ptmr = ptmr->ptmrNext;
                            ThreadUnlock(&tlTimer);
                            continue;
                        }
                        ThreadUnlock(&tlTimer);

                    } else {
                        ptmr->flags |= TMRF_READY;
                        ptmr->pti->cTimersReady++;
                        SetWakeBit(ptmr->pti, QS_TIMER);
                    }
                }
            }
        }

        /*
         * Remember the shortest time left of the timers.
         */
        if (ptmr->cmsCountdown < dmsNextTimer) {
            dmsNextTimer = ptmr->cmsCountdown;
        }

        /*
         * Advance to the next timer structure.
         */
        ptmr = ptmr->ptmrNext;
    }

    if (!gbMasterTimerSet) {
        /*
         * Time in NT should be negative to specify a relative
         * time. It's also in hundred nanosecond units so multiply
         * by 10000  to get the right value from milliseconds.
         */
        liT.QuadPart = Int32x32To64(-10000, dmsNextTimer);
        KeSetTimer(gptmrMaster, liT, NULL);
    }

    LeaveCrit();
}

/***************************************************************************\
*  xxxSystemTimerProc()
*
*  11/15/96 GerardoB  Created
\***************************************************************************/
VOID xxxSystemTimerProc(PWND pwnd, UINT msg, UINT_PTR id, LPARAM lParam)
{
    CheckLock(pwnd);
    UNREFERENCED_PARAMETER(msg);
    UNREFERENCED_PARAMETER(id);
    UNREFERENCED_PARAMETER(lParam);

    switch (id) {
        case IDSYS_LAYER: {
            PDCE pdce;

            for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

                if (pdce->DCX_flags & (DCX_INVALID | DCX_DESTROYTHIS))
                    continue;

                if ((pdce->DCX_flags & DCX_REDIRECTED) && (pdce->DCX_flags & DCX_INUSE)) {
                    UpdateRedirectedDC(pdce);
                }
            }
        }
        return;

        case IDSYS_FADE:
            AnimateFade();
            return;

        case IDSYS_FLASHWND:
            xxxFlashWindow(pwnd, FLASHW_TIMERCALL, 0);
            return;

        case IDSYS_WNDTRACKING: {
            /*
             * If the active track window hasn't changed,
             *  it's time to active it.
             * spwndTrack can be NULL if it got destroyed but we haven't
             *  destroyed the timer.yet
             */
            PTHREADINFO pti = GETPTI(pwnd);
            UserAssert(TestUP(ACTIVEWINDOWTRACKING));

            if ((pti->rpdesk->spwndTrack != NULL)
                    && (pwnd == GetActiveTrackPwnd(pti->rpdesk->spwndTrack, NULL))) {

                pti->pq->QF_flags |= (QF_ACTIVEWNDTRACKING | QF_MOUSEMOVED);

#ifdef REDIRECTION
                /*
                 * Should we call the hit test hook here ?
                 */
                PushMouseMove(pti->pq, gpsi->ptCursor);
#endif // REDIRECTION

                SetWakeBit(pti, QS_MOUSEMOVE);
            }
        }
        break;

        case IDSYS_MOUSEHOVER: {
            PTHREADINFO pti = GETPTI(pwnd);
            PDESKTOP pdesk = pti->rpdesk;
            /*
             * If hover hasn't been canceled, the mouse is still on
             *  this window and the point is still on the rect, then
             *  it's hover time!
             */
            if ((pdesk->dwDTFlags & DF_TRACKMOUSEHOVER)
                    && (HWq(pwnd) == HWq(pdesk->spwndTrack)
                    && PtInRect(&pdesk->rcMouseHover, gpsi->ptCursor))) {

                UINT message;
                WPARAM wParam;
                POINT pt = gpsi->ptCursor;

                if (pdesk->htEx == HTCLIENT) {
                    message = WM_MOUSEHOVER;
                    wParam = (WPARAM)GetMouseKeyFlags(pti->pq);
                    if (TestWF(pwnd, WEFLAYOUTRTL)) {
                        pt.x = pwnd->rcClient.right - pt.x - 1;
                    } else {
                        pt.x -= pwnd->rcClient.left;
                    }
                    pt.y -= pwnd->rcClient.top;
                } else {
                    message = WM_NCMOUSEHOVER;
                    /*
                     * Map the extended hit test code to a public one.
                     */
                    wParam = (WPARAM)LOWORD(pdesk->htEx);
                    if ((wParam >= HTEXMENUFIRST) && (wParam <= HTEXMENULAST)) {
                        wParam = (WPARAM)HTMENU;
                    } else if ((wParam >= HTEXSCROLLFIRST) && (wParam <= HTEXSCROLLLAST)) {
                        wParam = (WPARAM)(HIWORD(pdesk->htEx) ? HTVSCROLL : HTHSCROLL);
                    }
                }

                _PostMessage(pwnd, message, wParam, MAKELPARAM(pt.x, pt.y));

                pdesk->dwDTFlags &= ~DF_TRACKMOUSEHOVER;
                break;
            }
        }
        return;


        default:
            RIPMSG1(RIP_ERROR, "xxxSystemTimerProc: unexpected id:%#lx", id);
            break;
    }

    /*
     * if we fell through, the timer got to go
     */
    _KillSystemTimer(pwnd, id);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\tounicod.c ===
/****************************** Module Header ******************************\
* Module Name: tounicod.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 02-08-92 GregoryW      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 *     "To a new truth there is nothing more hurtful than an old error."
 *             - Johann Wolfgang von Goethe (1749-1832)
 */

/*
 * macros used locally to make life easier
 */
#define ISCAPSLOCKON(pf) (TestKeyToggleBit(pf, VK_CAPITAL) != 0)
#define ISNUMLOCKON(pf)  (TestKeyToggleBit(pf, VK_NUMLOCK) != 0)
#define ISSHIFTDOWN(w)   (w & 0x01)
#define ISKANALOCKON(pf) (TestKeyToggleBit(pf, VK_KANA)    != 0)

WCHAR xxxClientCharToWchar(
    IN WORD CodePage,
    IN WORD wch);

/***************************************************************************\
* _ToUnicodeEx (API)
*
* This routine provides Unicode translation for the virtual key code
* passed in.
*
* History:
* 02-10-92 GregoryW    Created.
* 01-23-95 GregoryW    Expanded from _ToUnicode to _ToUnicodeEx
\***************************************************************************/
int xxxToUnicodeEx(
    UINT wVirtKey,
    UINT wScanCode,
    CONST BYTE *pbKeyState,
    LPWSTR pwszBuff,
    int cchBuff,
    UINT wKeyFlags,
    HKL hkl)
{
    int i;
    BYTE afKeyState[CBKEYSTATE];
    DWORD dwDummy;

    /*
     * pKeyState is an array of 256 bytes, each byte representing the
     * following virtual key state: 0x80 means down, 0x01 means toggled.
     * InternalToUnicode() takes an array of bits, so pKeyState needs to
     * be translated. _ToAscii only a public api and rarely gets called,
     * so this is no big deal.
     */
    for (i = 0; i < 256; i++, pbKeyState++) {
        if (*pbKeyState & 0x80) {
            SetKeyDownBit(afKeyState, i);
        } else {
            ClearKeyDownBit(afKeyState, i);
        }

        if (*pbKeyState & 0x01) {
            SetKeyToggleBit(afKeyState, i);
        } else {
            ClearKeyToggleBit(afKeyState, i);
        }
    }

    i = xxxInternalToUnicode(wVirtKey, wScanCode, afKeyState, pwszBuff, cchBuff,
            wKeyFlags, &dwDummy, hkl);


    return i;
}

int ComposeDeadKeys(
    PKL pkl,
    PDEADKEY pDeadKey,
    WCHAR wchTyped,
    WORD *pUniChar,
    INT cChar,
    BOOL bBreak)
{
   /*
    * Attempt to compose this sequence:
    */
   DWORD dwBoth;

   TAGMSG4(DBGTAG_ToUnicode | RIP_THERESMORE,
           "ComposeDeadKeys dead '%C'(%x)+base '%C'(%x)",
           pkl->wchDiacritic, pkl->wchDiacritic,
           wchTyped, wchTyped);
   TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME | RIP_THERESMORE,
           "cChar = %d, bBreak = %d", cChar, bBreak);
   UserAssert(pDeadKey);

   if (cChar < 1) {
       TAGMSG0(DBGTAG_ToUnicode | RIP_NONAME,
               "return 0 because cChar < 1");
       return 0;
   }

   /*
    * Use the layout's built-in table for dead char composition
    */
   dwBoth = MAKELONG(wchTyped, pkl->wchDiacritic);

   if (pDeadKey != NULL) {
       /*
        * Don't let character upstrokes erase the cached dead char: else
        * if this was the dead char key again (being released after the
        * AltGr is released) the dead char would be prematurely cleared.
        */
       if (!bBreak) {
           pkl->wchDiacritic = 0;
       }
       while (pDeadKey->dwBoth != 0) {
           if (pDeadKey->dwBoth == dwBoth) {
               /*
                * found a composition
                */
               if (pDeadKey->uFlags & DKF_DEAD) {
                   /*
                    * Dead again! Save the new 'dead' key
                    */
                   if (!bBreak) {
                       pkl->wchDiacritic = (WORD)pDeadKey->wchComposed;
                   }
                   TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME,
                           "return -1 with dead char '%C'(%x)",
                           pkl->wchDiacritic, pkl->wchDiacritic);
                   return -1;
               }
               *pUniChar = (WORD)pDeadKey->wchComposed;
               TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME,
                       "return 1 with char '%C'(%x)",
                       *pUniChar, *pUniChar);
               return 1;
           }
           pDeadKey++;
       }
   }
   *pUniChar++ = HIWORD(dwBoth);
   if (cChar > 1) {
       *pUniChar = LOWORD(dwBoth);
       TAGMSG4(DBGTAG_ToUnicode | RIP_NONAME,
               "return 2 with uncomposed chars '%C'(%x), '%C'(%x)",
               *(pUniChar-1), *(pUniChar-1), *pUniChar, *pUniChar);
       return 2;
   }
   TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME | RIP_THERESMORE,
           "return 1 - only one char '%C'(%x) because cChar is 1, '%C'(%x)",
           *(pUniChar-1), *(pUniChar-1));
   TAGMSG2(DBGTAG_ToUnicode | RIP_NONAME,
           "  the second char would have been '%C'(%x)",
           LOWORD(dwBoth), LOWORD(dwBoth));
   return 1;
}


/*
 * TranslateInjectedVKey
 *
 * Returns the number of characters (cch) translated.
 *
 * Note on VK_PACKET:
 * Currently, the only purpose of VK_PACKET is to inject a Unicode character
 * into the input stream, but it is intended to be extensible to include other
 * manipulations of the input stream (including the message loop so that IMEs
 * can be involved).  For example, we might send commands to the IME or other
 * parts of the system.
 * For Unicode character injection, we tried widening virtual keys to 32 bits
 * of the form nnnn00e7, where nnnn is 0x0000 - 0xFFFF (representing Unicode
 * characters 0x0000 - 0xFFFF) See KEYEVENTF_UNICODE.
 * But many apps truncate wParam to 16-bits (poorly ported from 16-bits?) and
 * several AV with these VKs (indexing into a table by WM_KEYDOWN wParam?) so
 * we have to cache the character in pti->wchInjected for TranslateMessage to
 * pick up (cf. GetMessagePos, GetMessageExtraInfo and GetMessageTime)
 */
int TranslateInjectedVKey(
    IN UINT uScanCode,
    OUT PWCHAR awchChars,
    IN UINT uiTMFlags)
{
    UserAssert(LOBYTE(uScanCode) == 0);
    if (!(uScanCode & KBDBREAK) || (uiTMFlags & TM_POSTCHARBREAKS)) {
        awchChars[0] = PtiCurrent()->wchInjected;
        return 1;
    }
    return 0;
}



enum {
    NUMPADCONV_OEMCP = 0,
    NUMPADCONV_HKLCP,
    NUMPADCONV_HEX_HKLCP,
    NUMPADCONV_HEX_UNICODE,
};

#define NUMPADSPC_INVALID   (-1)

int NumPadScanCodeToHex(UINT uScanCode, UINT uVirKey)
{
    if (uScanCode >= SCANCODE_NUMPAD_FIRST && uScanCode <= SCANCODE_NUMPAD_LAST) {
        int digit = aVkNumpad[uScanCode - SCANCODE_NUMPAD_FIRST];

        if (digit != 0xff) {
            return digit - VK_NUMPAD0;
        }
        return NUMPADSPC_INVALID;
    }

    if (gfInNumpadHexInput & NUMPAD_HEXMODE_HL) {
        //
        // Full keyboard
        //
        if (uVirKey >= L'A' && uVirKey <= L'F') {
            return uVirKey - L'A' + 0xa;
        }
        if (uVirKey >= L'0' && uVirKey <= L'9') {
            return uVirKey - L'0';
        }
    }

    return NUMPADSPC_INVALID;
}

/*
 * IsDbcsExemptionForHighAnsi
 *
 * returns TRUE if Unicode to ANSI conversion should be
 * done on CP 1252 (Latin-1).
 *
 * If this function is changed, winsrv's equivalent
 * routine should be changed too.
 */
BOOL IsDbcsExemptionForHighAnsi(
    WORD wCodePage,
    WORD wNumpadChar)
{
    UserAssert(HIBYTE(wNumpadChar) == 0);

    if (wCodePage == CP_JAPANESE && IS_JPN_1BYTE_KATAKANA(wNumpadChar)) {
        /*
         * If hkl is JAPANESE and NumpadChar is in KANA range,
         * NumpadChar should be handled by the input locale.
         */
        return FALSE;
    }
    else if (wNumpadChar >= 0x80 && wNumpadChar <= 0xff) {
        /*
         * Otherwise if NumpadChar is in High ANSI range,
         * use 1252 for conversion.
         */
        return TRUE;
    }

    /*
     * None of the above.
     * This case includes the compound Leading Byte and Trailing Byte,
     * which is larger than 0xff.
     */
    return FALSE;
}

#undef MODIFIER_FOR_ALT_NUMPAD

#define MODIFIER_FOR_ALT_NUMPAD(wModBit) \
    ((((wModBits) & ~KBDKANA) == KBDALT) || (((wModBits) & ~KBDKANA) == (KBDALT | KBDSHIFT)))


int xxxInternalToUnicode(
    IN  UINT   uVirtKey,
    IN  UINT   uScanCode,
    CONST IN PBYTE pfvk,
    OUT PWCHAR awchChars,
    IN  INT    cChar,
    IN  UINT   uiTMFlags,
    OUT PDWORD pdwKeyFlags,
    IN  HKL    hkl)
{
    WORD wModBits;
    WORD nShift;
    WCHAR *pUniChar;
    PVK_TO_WCHARS1 pVK;
    PVK_TO_WCHAR_TABLE pVKT;
    static WORD NumpadChar;
    static WORD VKLastDown;
    static BYTE ConvMode;   // 0 == NUMPADCONV_OEMCP
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    PKL pkl;
    PKBDTABLES pKbdTbl;
    PLIGATURE1 pLigature;

    *pdwKeyFlags = (uScanCode & KBDBREAK);

    if ((BYTE)uVirtKey == VK_UNKNOWN) {
        /*
         * WindowsBug 311712: this could be the case of
         * unrecognized scancode.
         */
        RIPMSG1(RIP_WARNING, "xxxInternalToUnicode: VK_UNKNOWN, vsc=%02x", uScanCode);
        return 0;
    }

    if ((hkl == NULL) && ptiCurrent->spklActive) {
        pkl = ptiCurrent->spklActive;
        pKbdTbl = pkl->spkf->pKbdTbl;
    } else {
        pkl = HKLtoPKL(ptiCurrent, hkl);
        if (!pkl) {
            return 0;
        }
        pKbdTbl = pkl->spkf->pKbdTbl;
    }
    UserAssert(pkl != NULL);
    UserAssert(pKbdTbl != NULL);

    pUniChar = awchChars;

    uScanCode &= (0xFF | KBDEXT);

    if (*pdwKeyFlags & KBDBREAK) {        // break code processing
        /*
         * Finalize number pad processing
         *
         */
        if (uVirtKey == VK_MENU) {
            if (NumpadChar) {
                if (ConvMode == NUMPADCONV_HEX_UNICODE) {
                    *pUniChar = NumpadChar;
                } else if (ConvMode == NUMPADCONV_OEMCP &&
                        (ptiCurrent->TIF_flags & TIF_CSRSSTHREAD)) {
                    /*
                     * Pass the OEM char to Console to be converted to Unicode
                     * there, since we don't know the OEM codepage it is using.
                     * Set ALTNUMPAD_BIT for console so it knows!
                     */
                    *pdwKeyFlags |= ALTNUMPAD_BIT;
                    *pUniChar = NumpadChar;
                } else {
                    /*
                     * Conversion based on OEMCP or current input language.
                     */
                    WORD wCodePage;

                    if (ConvMode == NUMPADCONV_OEMCP) {
                        // NlsOemCodePage is exported from ntoskrnl.exe.
                        extern __declspec(dllimport) USHORT NlsOemCodePage;

                        wCodePage = (WORD)NlsOemCodePage;
                    } else {
                        wCodePage = pkl->CodePage;
                    }
                    if (IS_DBCS_CODEPAGE(wCodePage)) {
                        if (NumpadChar & (WORD)~0xff) {
                            /*
                             * Might be a double byte character.
                             * Let's swab it so that NumpadChar has LB in LOBYTE,
                             * TB in HIBYTE.
                             */
                            NumpadChar = MAKEWORD(HIBYTE(NumpadChar), LOBYTE(NumpadChar));
                        } else if (IsDbcsExemptionForHighAnsi(wCodePage, NumpadChar)) {
                            /*
                             * FarEast hack:
                             * treat characters in High ANSI area as if they are
                             * the ones of Codepage 1252.
                             */
                            wCodePage = 1252;
                        }
                    } else {
                        /*
                         * Backward compatibility:
                         * Simulate the legacy modulo behavior for non-FarEast keyboard layouts.
                         */
                        NumpadChar &= 0xff;
                    }

                    *pUniChar = xxxClientCharToWchar(wCodePage, NumpadChar);
                }

                /*
                 * Clear Alt-Numpad state, the ALT key-release generates 1 character.
                 */
                VKLastDown = 0;
                ConvMode = NUMPADCONV_OEMCP;
                NumpadChar = 0;
                gfInNumpadHexInput &= ~NUMPAD_HEXMODE_HL;

                return 1;
            } else if (ConvMode != NUMPADCONV_OEMCP) {
                ConvMode = NUMPADCONV_OEMCP;
            }
        } else if (uVirtKey == VKLastDown) {
            /*
             * The most recently depressed key has now come up: we are now
             * ready to accept a new NumPad key for Alt-Numpad processing.
             */
            VKLastDown = 0;
        }
    }

    if (!(*pdwKeyFlags & KBDBREAK) || (uiTMFlags & TM_POSTCHARBREAKS)) {
        /*
         * Get the character modification bits.
         * The bit-mask (wModBits) encodes depressed modifier keys:
         * these bits are commonly KBDSHIFT, KBDALT and/or KBDCTRL
         * (representing Shift, Alt and Ctrl keys respectively)
         */
        wModBits = GetModifierBits(pKbdTbl->pCharModifiers, pfvk);

        /*
         * If the current shift state is either Alt or Alt-Shift:
         *
         *   1. If a menu is currently displayed then clear the
         *      alt bit from wModBits and proceed with normal
         *      translation.
         *
         *   2. If this is a number pad key then do alt-<numpad>
         *      calculations.
         *
         *   3. Otherwise, clear alt bit and proceed with normal
         *      translation.
         */

        /*
         * Equivalent code is in xxxKeyEvent() to check the
         * low level mode. If you change this code, you may
         * need to change xxxKeyEvent() as well.
         */
        if (!(*pdwKeyFlags & KBDBREAK) && MODIFIER_FOR_ALT_NUMPAD(wModBits)) {
            /*
             * If this is a numeric numpad key
             */
            if ((uiTMFlags & TM_INMENUMODE) == 0) {
                if (gfEnableHexNumpad && uScanCode == SCANCODE_NUMPAD_DOT) {
                    if ((gfInNumpadHexInput & NUMPAD_HEXMODE_HL) == 0) {
                        /*
                         * If the first key is '.', then we're
                         * entering hex input lang input mode.
                         */
                        ConvMode = NUMPADCONV_HEX_HKLCP;
                        /*
                         * Inidicate to the rest of the system
                         * we're in Hex Alt+Numpad mode.
                         */
                        gfInNumpadHexInput |= NUMPAD_HEXMODE_HL;
                        TAGMSG0(DBGTAG_ToUnicode, "NUMPADCONV_HEX_HKLCP");
                    } else {
                        goto ExitNumpadMode;
                    }
                } else if (gfEnableHexNumpad && uScanCode == SCANCODE_NUMPAD_PLUS) {
                    if ((gfInNumpadHexInput & NUMPAD_HEXMODE_HL) == 0) {
                        /*
                         * If the first key is '+', then we're
                         * entering hex UNICODE input mode.
                         */
                        ConvMode = NUMPADCONV_HEX_UNICODE;
                        /*
                         * Inidicate to the rest of the system
                         * we're in Hex Alt+Numpad mode.
                         */
                        gfInNumpadHexInput |= NUMPAD_HEXMODE_HL;
                        TAGMSG0(DBGTAG_ToUnicode, "NUMPADCONV_HEX_UNICODE");
                    } else {
                        goto ExitNumpadMode;
                    }
                } else {
                    int digit = NumPadScanCodeToHex(uScanCode, uVirtKey);

                    if (digit < 0) {
                        goto ExitNumpadMode;
                    }

                    /*
                     * Ignore repeats
                     */
                    if (VKLastDown == uVirtKey) {
                        return 0;
                    }

                    switch (ConvMode) {
                    case NUMPADCONV_HEX_HKLCP:
                    case NUMPADCONV_HEX_UNICODE:
                        /*
                         * Input is treated as hex number.
                         */
                        TAGMSG1(DBGTAG_ToUnicode, "->NUMPADCONV_HEX_*: old NumpadChar=%02x\n", NumpadChar);
                        NumpadChar = NumpadChar * 0x10 + digit;
                        TAGMSG1(DBGTAG_ToUnicode, "<-NUMPADCONV_HEX_*: new NumpadChar=%02x\n", NumpadChar);
                        break;
                    default:
                       /*
                        * Input is treated as decimal number.
                        */
                       NumpadChar = NumpadChar * 10 + digit;

                       /*
                        * Do Alt-Numpad0 processing
                        */
                       if (NumpadChar == 0 && digit == 0) {
                           ConvMode = NUMPADCONV_HKLCP;
                       }
                       break;
                    }
                }
                VKLastDown = (WORD)uVirtKey;
            } else {
ExitNumpadMode:
                /*
                 * Clear Alt-Numpad state and the ALT shift state.
                 */
                VKLastDown = 0;
                ConvMode = NUMPADCONV_OEMCP;
                NumpadChar = 0;
                wModBits &= ~KBDALT;
                gfInNumpadHexInput &= ~NUMPAD_HEXMODE_HL;
            }
        }

        /*
         * LShift/RSHift+Backspace -> Left-to-Right and Right-to-Left marker
         */
        if ((uVirtKey == VK_BACK) && (pKbdTbl->fLocaleFlags & KLLF_LRM_RLM)) {
            if (TestKeyDownBit(pfvk, VK_LSHIFT)) {
                *pUniChar = 0x200E; // LRM
                return 1;
            } else if (TestKeyDownBit(pfvk, VK_RSHIFT)) {
                *pUniChar = 0x200F; // RLM
                return 1;
            }
        } else if (((WORD)uVirtKey == VK_PACKET) && (LOBYTE(uScanCode) == 0)) {
            return TranslateInjectedVKey(uScanCode, awchChars, uiTMFlags);
        }

        /*
         * Scan through all the shift-state tables until a matching Virtual
         * Key is found.
         */
        for (pVKT = pKbdTbl->pVkToWcharTable; pVKT->pVkToWchars != NULL; pVKT++) {
            pVK = pVKT->pVkToWchars;
            while (pVK->VirtualKey != 0) {
                if (pVK->VirtualKey == (BYTE)uVirtKey) {
                    goto VK_Found;
                }
                pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);
            }
        }

        /*
         * Not found: virtual key is not a character.
         */
        goto ReturnBadCharacter;

VK_Found:
        /*
         * The virtual key has been found in table pVKT, at entry pVK
         */

        /*
         * If KanaLock affects this key and it is on: toggle KANA state
         * only if no other state is on. "KANALOK" attributes only exist
         * in Japanese keyboard layout, and only Japanese keyboard hardware
         * can be "KANA" lock on state.
         */
        if ((pVK->Attributes & KANALOK) && (ISKANALOCKON(pfvk))) {
            wModBits |= KBDKANA;
        } else {
            /*
             * If CapsLock affects this key and it is on: toggle SHIFT state
             * only if no other state is on.
             * (CapsLock doesn't affect SHIFT state if Ctrl or Alt are down).
             * OR
             * If CapsLockAltGr affects this key and it is on: toggle SHIFT
             * state only if both Alt & Control are down.
             * (CapsLockAltGr only affects SHIFT if AltGr is being used).
             */
            if ((pVK->Attributes & CAPLOK) && ((wModBits & ~KBDSHIFT) == 0) &&
                    ISCAPSLOCKON(pfvk)) {
                wModBits ^= KBDSHIFT;
            } else if ((pVK->Attributes & CAPLOKALTGR) &&
                    ((wModBits & (KBDALT | KBDCTRL)) == (KBDALT | KBDCTRL)) &&
                    ISCAPSLOCKON(pfvk)) {
                wModBits ^= KBDSHIFT;
            }
        }

        /*
         * If SGCAPS affects this key and CapsLock is on: use the next entry
         * in the table, but not is Ctrl or Alt are down.
         * (SGCAPS is used in Swiss-German, Czech and Czech 101 layouts)
         */
        if ((pVK->Attributes & SGCAPS) && ((wModBits & ~KBDSHIFT) == 0) &&
                ISCAPSLOCKON(pfvk)) {
            pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);
        }

        /*
         * Convert the shift-state bitmask into one of the enumerated
         * logical shift states.
         */
        nShift = GetModificationNumber(pKbdTbl->pCharModifiers, wModBits);

        if (nShift == SHFT_INVALID) {
            /*
             * An invalid combination of Shifter Keys
             */
            goto ReturnBadCharacter;

        } else if ((nShift < pVKT->nModifications) &&
                (pVK->wch[nShift] != WCH_NONE)) {
            /*
             * There is an entry in the table for this combination of
             * Shift State (nShift) and Virtual Key (uVirtKey).
             */
            if (pVK->wch[nShift] == WCH_DEAD) {
                /*
                 * It is a dead character: the next entry contains
                 * its value.
                 */
                pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);

                /*
                 * If the previous char was not dead return a dead character.
                 */
                if (pkl->wchDiacritic == 0) {
                    TAGMSG2(DBGTAG_ToUnicode,
                            "xxxInternalToUnicode: new dead char '%C'(%x), goto ReturnDeadCharacter",
                            pVK->wch[nShift], pVK->wch[nShift]);
                    goto ReturnDeadCharacter;
                }
                /*
                 * Else go to ReturnGoodCharacter which will attempt to
                 * compose this dead character with the previous dead char.
                 */
                /*
                 * N.B. NTBUG 6141
                 * If dead key is hit twice in sequence, Win95/98 gives
                 * two composed characters from dead chars...
                 */
                TAGMSG4(DBGTAG_ToUnicode,
                        "xxxInternalToUnicode: 2 dead chars '%C'(%x)+'%C'(%x)",
                        pkl->wchDiacritic, pkl->wchDiacritic,
                        pVK->wch[nShift], pVK->wch[nShift]);
                if (GetAppCompatFlags2(VER40) & GACF2_NOCHAR_DEADKEY) {
                    /*
                     * AppCompat 377217: Publisher calls TranslateMessage and ToUnicode for
                     * the same dead key when it's not expecting real characters.
                     * On NT4, this resulted like "pushing the dead key in the stack and
                     * no character is compossed", but on NT5 with fix to 6141,
                     * two dead keys compose real characters clearing the internal
                     * dead key cache. The app shouldn't call both TranslateMessage and ToUnicode
                     * for the same key stroke in the first place -- in a way the app was working on
                     * NT4 by just a thin luck.
                     * In any case, since the app has been shipped broadly and hard to fix,
                     * let's simulate the NT4 behavior here, but with just one level cache (not the
                     * stack).
                     */
                    goto ReturnDeadCharacter;
                }

                goto ReturnGoodCharacter;

            } else if (pVK->wch[nShift] == WCH_LGTR) {
                /*
                 * It is a ligature.  Look in ligature table for a match.
                 */
                if ((GET_KBD_VERSION(pKbdTbl) == 0) || ((pLigature = pKbdTbl->pLigature) == NULL)) {
                    /*
                     * Hey, where's the table?
                     */
                    xxxMessageBeep(0);
                    goto ReturnBadCharacter;
                }

                while (pLigature->VirtualKey != 0) {
                    int iLig = 0;
                    int cwchT = 0;

                    if ((pLigature->VirtualKey == pVK->VirtualKey) &&
                            (pLigature->ModificationNumber == nShift)) {
                        /*
                         * Found the ligature!
                         */
                        while ((iLig < pKbdTbl->nLgMax) && (cwchT < cChar)) {
                            if (pLigature->wch[iLig] == WCH_NONE) {
                                /*
                                 * End of ligature.
                                 */
                                return cwchT;
                            }
                            if (pkl->wchDiacritic != 0) {
                                int cComposed;
                                /*
                                 * Attempt to compose the previous deadkey with current
                                 * ligature character.  If this generates yet another
                                 * dead key, go round again without adding to pUniChar
                                 * or cwchT.
                                 */
                                cComposed = ComposeDeadKeys(
                                            pkl,
                                            pKbdTbl->pDeadKey,
                                            pLigature->wch[iLig],
                                            pUniChar + cwchT,
                                            cChar - cwchT,
                                            *pdwKeyFlags & KBDBREAK
                                            );
                                if (cComposed > 0) {
                                    cwchT += cComposed;
                                } else {
                                    RIPMSG2(RIP_ERROR, // we really don't expect this
                                            "InternalToUnicode: dead+lig(%x)->dead(%x)",
                                            pLigature->wch[0], pkl->wchDiacritic);
                                }
                            } else {
                                pUniChar[cwchT++] = pLigature->wch[iLig];
                            }
                            iLig++;
                        }
                        return cwchT;
                    }
                    /*
                     * Not a match, try the next entry.
                     */
                    pLigature = (PLIGATURE1)((PBYTE)pLigature + pKbdTbl->cbLgEntry);
                }
                /*
                 * No match found!
                 */
                xxxMessageBeep(0);
                goto ReturnBadCharacter;
            }

            /*
             * Match found: return the unshifted character
             */
            TAGMSG2(DBGTAG_ToUnicode,
                    "xxxInternalToUnicode: Match found '%C'(%x), goto ReturnGoodChar",
                    pVK->wch[nShift], pVK->wch[nShift]);
            goto ReturnGoodCharacter;

        } else if ((wModBits == KBDCTRL) || (wModBits == (KBDCTRL|KBDSHIFT)) ||
             (wModBits == (KBDKANA|KBDCTRL)) || (wModBits == (KBDKANA|KBDCTRL|KBDSHIFT))) {
            /*
             * There was no entry for this combination of Modification (nShift)
             * and Virtual Key (uVirtKey).  It may still be an ASCII control
             * character though:
             */
            if ((uVirtKey >= 'A') && (uVirtKey <= 'Z')) {
                /*
                 * If the virtual key is in the range A-Z we can convert
                 * it directly to a control character.  Otherwise, we
                 * need to search the control key conversion table for
                 * a match to the virtual key.
                 */
                *pUniChar = (WORD)(uVirtKey & 0x1f);
                return 1;
            } else if ((uVirtKey >= 0xFF61) && (uVirtKey <= 0xFF91)) {
                /*
                 * If the virtual key is in range FF61-FF91 (halfwidth
                 * katakana), we convert it to Virtual scan code with
                 * KANA modifier.
                 */
                *pUniChar = (WORD)(InternalVkKeyScanEx((WCHAR)uVirtKey,pKbdTbl) & 0x1f);
                return 1;
            }
        }
    }

ReturnBadCharacter:
    // pkl->wchDiacritic = 0;
    return 0;

ReturnDeadCharacter:
    *pUniChar = pVK->wch[nShift];

    /*
     * Save 'dead' key: overwrite an existing one.
     */
    if (!(*pdwKeyFlags & KBDBREAK)) {
        pkl->wchDiacritic = *pUniChar;
    }

    UserAssert(pKbdTbl->pDeadKey);

    /*
     * return negative count for dead characters
     */
    return -1;

ReturnGoodCharacter:
    if ((pKbdTbl->pDeadKey != NULL) && (pkl->wchDiacritic != 0)) {
        return ComposeDeadKeys(
                  pkl,
                  pKbdTbl->pDeadKey,
                  pVK->wch[nShift],
                  pUniChar,
                  cChar,
                  *pdwKeyFlags & KBDBREAK
                  );
    }
    *pUniChar = (WORD)pVK->wch[nShift];
    return 1;
}

SHORT InternalVkKeyScanEx(
    WCHAR wchChar,
    PKBDTABLES pKbdTbl)
{
    PVK_TO_WCHARS1 pVK;
    PVK_TO_WCHAR_TABLE pVKT;
    BYTE nShift;
    WORD wModBits;
    WORD wModNumCtrl, wModNumShiftCtrl;
    SHORT shRetvalCtrl = 0;
    SHORT shRetvalShiftCtrl = 0;

    if (pKbdTbl == NULL) {
        pKbdTbl = gspklBaseLayout->spkf->pKbdTbl;
    }

    /*
     * Ctrl and Shift-Control combinations are less favored, so determine
     * the values for nShift which we prefer not to use if at all possible.
     * This is for compatibility with Windows 95/98, which only returns a
     * Ctrl or Shift+Ctrl combo as a last resort. See bugs #78891 & #229141
     */
    wModNumCtrl = GetModificationNumber(pKbdTbl->pCharModifiers, KBDCTRL);
    wModNumShiftCtrl = GetModificationNumber(pKbdTbl->pCharModifiers, KBDSHIFT | KBDCTRL);

    for (pVKT = pKbdTbl->pVkToWcharTable; pVKT->pVkToWchars != NULL; pVKT++) {
        for (pVK = pVKT->pVkToWchars;
                pVK->VirtualKey != 0;
                pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize)) {
            for (nShift = 0; nShift < pVKT->nModifications; nShift++) {
                if (pVK->wch[nShift] == wchChar) {
                    /*
                     * A matching character has been found!
                     */
                    if (pVK->VirtualKey == 0xff) {
                        /*
                         * dead char: back up to previous line to get the VK.
                         */
                        pVK = (PVK_TO_WCHARS1)((PBYTE)pVK - pVKT->cbSize);
                    }

                    /*
                     * If this is the first Ctrl or the first Shift+Ctrl match,
                     * remember in case we don't find any better match.
                     * In the meantime, keep on looking.
                     */
                    if (nShift == wModNumCtrl) {
                        if (shRetvalCtrl == 0) {
                            shRetvalCtrl = (SHORT)MAKEWORD(pVK->VirtualKey, KBDCTRL);
                        }
                    } else if (nShift == wModNumShiftCtrl) {
                        if (shRetvalShiftCtrl == 0) {
                            shRetvalShiftCtrl = (SHORT)MAKEWORD(pVK->VirtualKey, KBDCTRL | KBDSHIFT);
                        }
                    } else {
                        /*
                         * this seems like a very good match!
                         */
                        goto GoodMatchFound;
                    }
                }
            }
        }
    }

    /*
     * Didn't find a good match: use whatever Ctrl/Shift+Ctrl match was found
     */
    if (shRetvalCtrl) {
        return shRetvalCtrl;
    }
    if (shRetvalShiftCtrl) {
        return shRetvalShiftCtrl;
    }

    /*
     * May be a control character not explicitly in the layout tables
     */
    if (wchChar < 0x0020) {
        /*
         * Ctrl+char -> char - 0x40
         */
        return (SHORT)MAKEWORD((wchChar + 0x40), KBDCTRL);
    }
    return -1;

GoodMatchFound:
    /*
     * Scan aModification[] to find nShift: the index will be a bitmask
     * representing the Shifter Keys that need to be pressed to produce
     * this Shift State.
     */
    for (wModBits = 0;
         wModBits <= pKbdTbl->pCharModifiers->wMaxModBits;
         wModBits++)
    {
        if (pKbdTbl->pCharModifiers->ModNumber[wModBits] == nShift) {
            if (pVK->VirtualKey == 0xff) {
                /*
                 * The previous entry contains the actual virtual key in this case.
                 */
                pVK = (PVK_TO_WCHARS1)((PBYTE)pVK - pVKT->cbSize);
            }
            return (SHORT)MAKEWORD(pVK->VirtualKey, wModBits);
        }
    }

    /*
     * huh? should never reach here! (IanJa)
     */
    UserAssertMsg1(FALSE, "InternalVkKeyScanEx error: wchChar = 0x%x", wchChar);
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\tooltips.c ===
/****************************** Module Header ******************************\
* Module Name: tooltips.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Implements system tooltips.
*
* History:
* 25-Aug-1996 vadimg    created
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define TT_XOFFSET          2
#define TT_YOFFSET          1
#define TTT_SHOW            1
#define TTT_HIDE            2
#define TTT_ANIMATE         3
#define TT_ANIMATEDELAY     20

#define TTF_POSITIVE        0x00000001

#define bitsizeof(x) (sizeof(x) * 8)

LONG GreGetBitmapBits(HBITMAP, ULONG, PBYTE, PLONG);
DWORD CalcCaptionButton(PWND pwnd, int hit, LPWORD pcmd, LPRECT prcBtn, LPWORD pbm);
int HitTestScrollBar(PWND pwnd, int ht, POINT pt);
BOOL xxxHotTrackSB(PWND pwnd, int htEx, BOOL fDraw);

__inline void ZeroTooltip(PTOOLTIPWND pttwnd)
{
    RtlZeroMemory((PBYTE)pttwnd + (sizeof(TOOLTIPWND) - sizeof(TOOLTIP)),
            sizeof(TOOLTIP));
}

/***************************************************************************\
* GetTooltipDC
*
* 2/3/1998   vadimg          created
\***************************************************************************/

HDC GetTooltipDC(PTOOLTIPWND pttwnd)
{
    HDC hdc = _GetDCEx((PWND)pttwnd, NULL, DCX_WINDOW | DCX_CACHE |
            DCX_USESTYLE);

    if (hdc == NULL)
        return NULL;

    GreSelectFont(hdc, ghStatusFont);
    return hdc;
}

/***************************************************************************\
* InitTooltipAnimation
*
* Creates memory bitmap and DC for use by system tooltips. Gets the screen
* DC used throughout.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void InitTooltipAnimation(PTOOLTIPWND pttwnd)
{
    HDC hdc = GetTooltipDC(pttwnd);

    if ((pttwnd->hdcMem = GreCreateCompatibleDC(hdc)) == NULL) {
        return;
    }
    _ReleaseDC(hdc);
    GreSetDCOwner(pttwnd->hdcMem, OBJECT_OWNER_PUBLIC);
}

/***************************************************************************\
* DestroyTooltipBitmap
*
\***************************************************************************/

void DestroyTooltipBitmap(PTOOLTIPWND pttwnd)
{
    if (pttwnd->hbmMem == NULL)
        return;

    GreSelectBitmap(pttwnd->hdcMem, GreGetStockObject(PRIV_STOCK_BITMAP));
    GreDeleteObject(pttwnd->hbmMem);
    pttwnd->hbmMem = NULL;
}

/***************************************************************************\
* CreateTooltipBitmap
*
\***************************************************************************/

BOOL CreateTooltipBitmap(PTOOLTIPWND pttwnd, UINT cx, UINT cy)
{
    HDC hdc;

    if (pttwnd->hdcMem == NULL) {
        RIPMSG0(RIP_WARNING, "CreateTooltipBitmap: pttwnd->hdcMem is NULL");
        return FALSE;
    }

    DestroyTooltipBitmap(pttwnd);

    hdc = GetTooltipDC(pttwnd);
    pttwnd->hbmMem = GreCreateCompatibleBitmap(hdc, cx, cy);
    _ReleaseDC(hdc);

    if (pttwnd->hbmMem == NULL) {
        RIPMSG0(RIP_WARNING, "CreateTooltipBitmap: hbmMem is NULL");
        return FALSE;
    }
    GreSelectBitmap(pttwnd->hdcMem, pttwnd->hbmMem);
    return TRUE;
}

/***************************************************************************\
* CleanupTooltipAnimation
*
* Deletes memory bitmap and DC for use by system tooltips. Release the
* screen DC.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void CleanupTooltipAnimation(PTOOLTIPWND pttwnd)
{
    DestroyTooltipBitmap(pttwnd);

    if (pttwnd->hdcMem != NULL) {
        GreSetDCOwner(pttwnd->hdcMem, OBJECT_OWNER_CURRENT);
        GreDeleteDC(pttwnd->hdcMem);
    }
}

/***************************************************************************\
* TooltipAnimate
*
* Perform one frame of window animation. Just a simplified version of
* the AnimateWindow API.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

BOOL TooltipAnimate(PTOOLTIPWND pttwnd)
{
    int y, yMem, yReal, ny, iy, cx, cy;
    DWORD dwElapsed;
    HDC hdc;
    BOOL fRet = FALSE;

    if (pttwnd->pstr == NULL)
        return TRUE;

    hdc = GetTooltipDC(pttwnd);
    cx = pttwnd->rcWindow.right - pttwnd->rcWindow.left;
    cy = pttwnd->rcWindow.bottom - pttwnd->rcWindow.top;
    dwElapsed = NtGetTickCount() - pttwnd->dwAnimStart;
    iy = MultDiv(cy, dwElapsed, CMS_TOOLTIP);

    if (dwElapsed > CMS_TOOLTIP || iy == cy) {
        GreBitBlt(hdc, 0, 0, cx, cy, pttwnd->hdcMem, 0, 0, SRCCOPY | NOMIRRORBITMAP, 0);
        fRet = TRUE;
        goto Cleanup;
    } else if (pttwnd->iyAnim == iy) {
        goto Cleanup;
    }

    if (pttwnd->dwFlags & TTF_POSITIVE) {
        y = 0;
        ny = 0;
    } else {
        y = cy;
        ny = -1;
    }

    yReal = y + ny * iy;
    yMem = (pttwnd->dwFlags & TTF_POSITIVE) ? cy - iy : 0;
    pttwnd->iyAnim = iy;

    GreBitBlt(hdc, 0, yReal, cx, iy, pttwnd->hdcMem, 0, yMem, SRCCOPY | NOMIRRORBITMAP, 0);

Cleanup:
    _ReleaseDC(hdc);
    return fRet;
}

/***************************************************************************\
* GetCursorHeight
*
* This is tricky. We need to get the actual cursor size from the hotspot
* down to the end. There is no API in windows to do this, CYCURSOR is
* just the metric for the size of the bitmap, the cursor starts at the top
* of the bitmap and may be smaller than the bitmap itself.
*
* 12-Sep-96 vadimg      ported from common controls
\***************************************************************************/

int GetCursorHeight(void)
{
    int iAnd, iXor, dy = 16;
    WORD wMask[128];
    ICONINFO ii;
    BITMAP bm;
    PCURSOR pcur;
    long lOffset = 0;

    if ((pcur = PtiCurrent()->pq->spcurCurrent) == NULL) {
        return dy;
    }

    if (!_InternalGetIconInfo(pcur, &ii, NULL, NULL, NULL, FALSE)) {
        return dy;
    }

    if (!GreExtGetObjectW(ii.hbmMask, sizeof(bm), (LPSTR)&bm)) {
        goto Bail;
    }

    /*
     * Use the AND mask to get the cursor height if the XOR mask is there.
     */
    if (!GreGetBitmapBits(ii.hbmMask, sizeof(wMask), (BYTE*)wMask, &lOffset)) {
        goto Bail;
    }

    iAnd = (int)(bm.bmWidth * bm.bmHeight / bitsizeof(WORD));

    if (ii.hbmColor == NULL) {
        /*
         * if no color (XOR) bitmap, then the hbmMask is a double height bitmap
         * with the cursor and the mask stacked.
         */

        iXor = iAnd - 1;
        iAnd /= 2;
    } else {
        iXor = 0;
    }

    if (iAnd >= sizeof(wMask)) {
        iAnd = sizeof(wMask) - 1;
    }

    if (iXor >= sizeof(wMask)) {
        iXor = 0;
    }

    for (iAnd--; iAnd >= 0; iAnd--) {
        if ((iXor != 0 && wMask[iXor--] != 0) || wMask[iAnd] != 0xFFFF) {
            break;
        }
    }

    /*
     * Compute the distance between the pointer's lowest point and hotspot.
     */
    dy = (iAnd + 1) * bitsizeof(WORD) / (int)bm.bmWidth - (int)ii.yHotspot;

Bail:
    if (ii.hbmColor) {
        GreDeleteObject(ii.hbmColor);
    }

    if (ii.hbmMask) {
        GreDeleteObject(ii.hbmMask);
    }

    return dy;
}

/***************************************************************************\
* TooltipGetPosition
*
* Get the tooltip position on the screen taking into account the size of
* the tooltip and the screen. The TTF_POSITIVE flag determines if positive
* or negative animation is used.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void TooltipGetPosition(PTOOLTIPWND pttwnd, SIZE *psize, POINT *ppt)
{
    PMONITOR    pMonitor;

    *ppt = gpsi->ptCursor;
    pMonitor = _MonitorFromPoint(*ppt, MONITOR_DEFAULTTONULL);
    UserAssert(pMonitor);

    if (ppt->y + psize->cy >= pMonitor->rcMonitor.bottom) {
        ppt->y = ppt->y - psize->cy;
        pttwnd->dwFlags &= ~TTF_POSITIVE;
    } else {
        ppt->y += GetCursorHeight();
        pttwnd->dwFlags |= TTF_POSITIVE;
    }

    if (ppt->x + psize->cx >= pMonitor->rcMonitor.right) {
        ppt->x = pMonitor->rcMonitor.right - psize->cx;
    }

    if (ppt->x < pMonitor->rcMonitor.left) {
        ppt->x = pMonitor->rcMonitor.left;
    }
}

/***************************************************************************\
* xxxTooltipGetSize
*
* Estimate the size of the tooltip window based on the size of the text.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void xxxTooltipGetSize(PTOOLTIPWND pttwnd, SIZE *psize)
{
    HDC hdc;

    CheckLock(pttwnd);

    hdc = GetTooltipDC(pttwnd);

    if (CALL_LPK(PtiCurrentShared())) {
        xxxClientGetTextExtentPointW(hdc, pttwnd->pstr, wcslen(pttwnd->pstr), psize);
    } else {
        GreGetTextExtentW(hdc, pttwnd->pstr, wcslen(pttwnd->pstr),
                psize, GGTE_WIN3_EXTENT);
    }

    _ReleaseDC(hdc);
    psize->cx += SYSMET(CXEDGE) + 2 * SYSMET(CXBORDER) * TT_XOFFSET;
    psize->cy += SYSMET(CYEDGE) + 2 * SYSMET(CYBORDER) * TT_YOFFSET;
}

/***************************************************************************\
* xxxTooltipRender
*
* Render the tooltip window into the provided DC.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void xxxTooltipRender(PTOOLTIPWND pttwnd, HDC hdc)
{
    COLORREF crBk;
    UINT uFlags;
    RECT rc;

    CheckLock(pttwnd);

    if (pttwnd->pstr == NULL)
        return;

    GreSelectFont(hdc, ghStatusFont);
    GreSetTextColor(hdc, gpsi->argbSystem[COLOR_INFOTEXT]);
    crBk = gpsi->argbSystem[COLOR_INFOBK];

    CopyOffsetRect(&rc, &pttwnd->rcClient, -pttwnd->rcClient.left,
           -pttwnd->rcClient.top);

    /*
     * We don't want dithered colors, so FillRect with the nearest color.
     */
    if (crBk == GreGetNearestColor(hdc, crBk)) {
        GreSetBkColor(hdc, crBk);
        uFlags = ETO_OPAQUE;
    } else {
        FillRect(hdc, &rc, SYSHBR(INFOBK));
        GreSetBkMode(hdc, TRANSPARENT);
        uFlags = ETO_CLIPPED;
    }

    if (CALL_LPK(PtiCurrentShared())) {
        xxxClientExtTextOutW(hdc, SYSMET(CXBORDER) * TT_XOFFSET,
                SYSMET(CYBORDER) * TT_YOFFSET, uFlags, &rc, pttwnd->pstr,
                wcslen(pttwnd->pstr), NULL);
    } else {
        GreExtTextOutW(hdc, SYSMET(CXBORDER) * TT_XOFFSET,
                SYSMET(CYBORDER) * TT_YOFFSET, uFlags, &rc, pttwnd->pstr,
                wcslen(pttwnd->pstr), NULL);
    }
}

/***************************************************************************\
* FindNcHitEx
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

int FindNCHitEx(PWND pwnd, int ht, POINT pt)
{
    /*
     * Bug 263057 joejo
     * It seems that pwnd->spmenu can be released and set to null,
     * without the WFMPRESENT flag being cleared. Make sure that
     * we have a good pwnd->spmenu before continuing.
     */
    if (ht == HTMENU && pwnd->spmenu && TestWF(pwnd, WFMPRESENT)) {
        PMENU spmenu = pwnd->spmenu;
        PITEM pitem;
        int nItem;

        nItem = MNItemHitTest(spmenu, pwnd, pt);
        if (nItem >= 0) {
            pitem = (PITEM)&spmenu->rgItems[nItem];
            switch ((ULONG_PTR)pitem->hbmp) {
            case (ULONG_PTR)HBMMENU_SYSTEM:
                ht = HTMDISYSMENU;
                break;
            case (ULONG_PTR)HBMMENU_MBAR_RESTORE:
                ht = HTMDIMAXBUTTON;
                break;
            case (ULONG_PTR)HBMMENU_MBAR_MINIMIZE:
            case (ULONG_PTR)HBMMENU_MBAR_MINIMIZE_D:
                ht = HTMDIMINBUTTON;
                break;
            case (ULONG_PTR)HBMMENU_MBAR_CLOSE:
            case (ULONG_PTR)HBMMENU_MBAR_CLOSE_D:
                ht = HTMDICLOSE;
                break;
            case (ULONG_PTR)HBMMENU_CALLBACK:
                ht = HTERROR;
                break;
            default:
                ht = HTMENUITEM;
                break;
            }
        }
        return MAKELONG(ht, nItem);
    } else if (ht == HTVSCROLL && TestWF(pwnd, WFVPRESENT)) {
        return MAKELONG(HitTestScrollBar(pwnd, TRUE, pt), 1);
    } else if (ht == HTHSCROLL && TestWF(pwnd, WFHPRESENT)) {
        return MAKELONG(HitTestScrollBar(pwnd, FALSE, pt), 0);
    }

    return ht;
}

/***************************************************************************\
* KillTooltipTimer
*
* Kill the timer and zero out the timer id.
\***************************************************************************/
void KillTooltipTimer (PTOOLTIPWND pttwnd)
{
    UINT uTID = pttwnd->uTID;
    if (uTID != 0) {
        pttwnd->uTID = 0;
        _KillTimer((PWND)pttwnd, uTID);
    }
}
/***************************************************************************\
* SetTooltipTimer
*
\***************************************************************************/
void SetTooltipTimer (PTOOLTIPWND pttwnd, UINT uTID, UINT uDelay)
{
    KillTooltipTimer(pttwnd);
    pttwnd->uTID = uTID;
    InternalSetTimer((PWND)pttwnd, uTID, uDelay, NULL, 0);
}
/***************************************************************************\
* xxxResetTooltip
*
* Hide the tooltip, kill the timer, and zero out most of the struct members.
\***************************************************************************/

void xxxResetTooltip(PTOOLTIPWND pttwnd)
{
    KillTooltipTimer(pttwnd);

    CheckLock(pttwnd);

    if (TestWF(pttwnd, WFVISIBLE)) {
        PWND spwndMessage;
        TL tlpwnd;

        xxxSetWindowPos((PWND)pttwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE |
                SWP_NOMOVE | SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER);

        spwndMessage = PWNDMESSAGE(pttwnd);
        ThreadLockAlways(spwndMessage, &tlpwnd);
        xxxSetParent((PWND)pttwnd, spwndMessage);
        ThreadUnlock(&tlpwnd);
    }

    ZeroTooltip(pttwnd);
    pttwnd->head.rpdesk->dwDTFlags &= ~DF_TOOLTIP;
}

/***************************************************************************\
* xxxShowTooltip
*
* Show the tooltip window.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void xxxShowTooltip(PTOOLTIPWND pttwnd)
{
    SIZE size;
    POINT pt;
    DWORD dwFlags;

    CheckLock(pttwnd);

    if (pttwnd->pstr == NULL)
        return;

    if (pttwnd->pstr == gszCAPTIONTOOLTIP) {

        PWND pwnd = PtiCurrent()->rpdesk->spwndTrack;
        /*
         * The window text might have changed in callbacks, retrieve it now
         */
        if (pwnd && TestWF(pwnd, WEFTRUNCATEDCAPTION) && pwnd->strName.Length) {
            wcsncpycch(gszCAPTIONTOOLTIP, pwnd->strName.Buffer, CAPTIONTOOLTIPLEN-1);
            gszCAPTIONTOOLTIP[CAPTIONTOOLTIPLEN-1] = 0;
        } else {
            return;
        }
    }

    xxxTooltipGetSize(pttwnd, &size);
    TooltipGetPosition(pttwnd, &size, &pt);

    dwFlags = SWP_CREATESPB | SWP_SHOWWINDOW | SWP_NOACTIVATE;
    if (TestEffectUP(TOOLTIPANIMATION)) {
        dwFlags |= SWP_NOREDRAW;
    }
    xxxSetWindowPos((PWND)pttwnd, PWND_TOP, pt.x, pt.y, size.cx, size.cy,
            dwFlags);
}

/***************************************************************************\
* xxxTooltipHandleTimer
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void xxxTooltipHandleTimer(PTOOLTIPWND pttwnd, UINT uTID)
{

    switch(uTID) {
        case TTT_SHOW: {
            /*
             * Move the tooltip window to the desktop so it can
             *  be shown. Then show it.
             */
            PWND pwndDesktop = PWNDDESKTOP(pttwnd);
            TL tlpwnd;
            ThreadLockAlways(pwndDesktop, &tlpwnd);
            xxxSetParent((PWND)pttwnd, pwndDesktop);
            ThreadUnlock(&tlpwnd);

            xxxShowTooltip(pttwnd);
            break;
        }

        case TTT_ANIMATE:
           /*
            * If animation is completed, set timer to hide
            */
           if (TooltipAnimate(pttwnd)) {
               SetTooltipTimer(pttwnd, TTT_HIDE, pttwnd->dwHideDelay);
           }
           break;

        case TTT_HIDE:
           /*
            * Hide it
            */
           xxxResetTooltip(pttwnd);
           break;
    }
}
/***************************************************************************\
* xxxTooltipWndProc
*
* The actual WndProc for the tooltip window.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

LRESULT xxxTooltipWndProc(PWND pwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    PTOOLTIPWND pttwnd;

    CheckLock(pwnd);
    VALIDATECLASSANDSIZE(pwnd, uMsg, wParam, lParam, FNID_TOOLTIP, WM_NCCREATE);
    pttwnd = (PTOOLTIPWND)pwnd;

    switch(uMsg) {
    case WM_TIMER:
        xxxTooltipHandleTimer(pttwnd, (UINT)wParam);
        break;

    case WM_PAINT:
        xxxBeginPaint(pwnd, &ps);
        xxxTooltipRender(pttwnd, ps.hdc);
        xxxEndPaint(pwnd, &ps);
        break;

    case WM_PRINTCLIENT:
        xxxTooltipRender(pttwnd, (HDC)wParam);
        break;

    case WM_ERASEBKGND:
        break;

    case WM_NCCREATE:
        InitTooltipDelay(pttwnd);
        InitTooltipAnimation(pttwnd);
        goto CallDWP;

    case WM_NCDESTROY:
        CleanupTooltipAnimation(pttwnd);
        GETPDESK(pttwnd)->dwDTFlags &= ~DF_TOOLTIP;
        goto CallDWP;

    case WM_WINDOWPOSCHANGED:
        if (((LPWINDOWPOS)lParam)->flags & SWP_SHOWWINDOW) {
            HDC hdc;
            int cx;
            int cy;

            if (!TestEffectUP(TOOLTIPANIMATION)) {
                SetTooltipTimer(pttwnd, TTT_HIDE, pttwnd->dwHideDelay);
                goto CallDWP;
            }

            hdc = NULL;
            cx = pttwnd->rcWindow.right - pttwnd->rcWindow.left;
            cy = pttwnd->rcWindow.bottom - pttwnd->rcWindow.top;

            /*
             * At this point we're sure that the window is showing and the size
             * has been changed and we're in the context of the desktop thread.
             */
            if (TestALPHA(TOOLTIPFADE)) {
                hdc = CreateFade((PWND)pttwnd, NULL, CMS_TOOLTIP,
                        FADE_SHOW | FADE_TOOLTIP);
            } else {
                if (CreateTooltipBitmap(pttwnd, cx, cy)) {
                    hdc = pttwnd->hdcMem;
                }
            }

            if (hdc == NULL) {
                SetTooltipTimer(pttwnd, TTT_HIDE, 0);
                goto CallDWP;
            }

            xxxSendMessage((PWND)pttwnd, WM_PRINT, (WPARAM)hdc,
                    PRF_CLIENT | PRF_NONCLIENT | PRF_CHILDREN | PRF_ERASEBKGND);

            /*
             * Start animation timer
             */

            if (TestFadeFlags(FADE_TOOLTIP)) {
                StartFade();
                SetTooltipTimer(pttwnd, TTT_HIDE, pttwnd->dwHideDelay);
            } else {
                pttwnd->dwAnimStart = NtGetTickCount();
                SetTooltipTimer(pttwnd, TTT_ANIMATE, TT_ANIMATEDELAY);
            }
        } else if (((LPWINDOWPOS)lParam)->flags & SWP_HIDEWINDOW) {
            if (TestFadeFlags(FADE_TOOLTIP)) {
                StopFade();
            } else {
                DestroyTooltipBitmap(pttwnd);
            }
        }
        goto CallDWP;

    default:
CallDWP:
        return xxxDefWindowProc(pwnd, uMsg, wParam, lParam);
    }

    return 0;
}

/***************************************************************************\
* IsTrackedHittest
*
* Should we be tracking this hittest code? Return the track string if yes.
* If on caption returning the window strName.Buffer could
* make the system bugcheck if there is a SetWindowText in the callback.
\***************************************************************************/
LPWSTR IsTooltipHittest(PWND pwnd, UINT ht)
{
    switch (ht) {
    case HTMINBUTTON:
        if (TestWF(pwnd, WFMINBOX)) {
            return (TestWF(pwnd, WFMINIMIZED)) ? gszRESUP : gszMIN;
        }
        break;

    case HTMAXBUTTON:
        if (TestWF(pwnd, WFMAXBOX)) {
            return (TestWF(pwnd, WFMAXIMIZED)) ? gszRESDOWN : gszMAX;
        }
        break;

    case HTCLOSE:
    case HTMDICLOSE:
        return gszSCLOSE;

/*  Commented out due to TandyT ...
    case HTSYSMENU:
    case HTMDISYSMENU:
        return gszSMENU;
*/
    case HTHELP:
        return gszHELP;

    case HTMDIMINBUTTON:
        return gszMIN;

    case HTMDIMAXBUTTON:
        return gszRESDOWN;

    case HTCAPTION:
        /*
         * We only show the caption tooltip if the window text
         * doesn't fit entirely on the caption.  We will fill
         * gszCAPTIONTOOLTIP right before showing the text
         */
        if (TestWF(pwnd, WEFTRUNCATEDCAPTION)) {
            return gszCAPTIONTOOLTIP;
        }
        break;

    default:
        break;
    }
    return NULL;
}

/***************************************************************************\
* xxxHotTrackMenu
*
* Hot-track a menu item in the menu bar.
\***************************************************************************/
BOOL xxxHotTrackMenu(PWND pwnd, UINT nItem, BOOL fDraw)
{
    PMENU pmenu = pwnd->spmenu;
    PITEM pItem;
    HDC   hdc;
    UINT  oldAlign;
    TL tlpmenu;

    CheckLock(pwnd);

    /*
     * The window may have lied about the hit-test code on
     * WM_NCHITTEST. Make sure it does indeed have a menu.
     */
    if (!TestWF(pwnd, WFMPRESENT) || pmenu == NULL)
        return FALSE;

    if (nItem >= pmenu->cItems) {
        RIPMSG0(RIP_WARNING, "xxxHotTrackMenu: menu too large");
        return FALSE;
    }

    pItem = &pmenu->rgItems[nItem];

    /*
     * Make sure we draw on the right spot
     */
    ThreadLock(pmenu, &tlpmenu);
    xxxMNRecomputeBarIfNeeded(pwnd, pmenu);
    ValidateThreadLocks(NULL, PtiCurrent()->ptl, (ULONG_PTR)&tlpmenu, TRUE);

    if (fDraw) {
        if (TestMFS(pItem, MF_GRAYED)) {
            ThreadUnlock(&tlpmenu);
            return FALSE;
        }
        SetMFS(pItem, MFS_HOTTRACK);
    } else {
        ClearMFS(pItem, MFS_HOTTRACK);
    }

    hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    GreSelectBrush(hdc, SYSHBR(MENUTEXT));
    GreSelectFont(hdc, ghMenuFont);

    oldAlign = GreGetTextAlign(hdc);
    if (pmenu->rgItems && TestMFT(pmenu->rgItems, MFT_RIGHTORDER))
        GreSetTextAlign(hdc, oldAlign | TA_RTLREADING);

    /*
     * When the item is not owner draw, xxxDrawMenuItem does not
     * call back and does not leave the critical section.
     */
    xxxDrawMenuItem(hdc, pmenu, pItem, 0);
    GreSetTextAlign(hdc, oldAlign);
    ThreadUnlock(&tlpmenu);

    _ReleaseDC(hdc);
    return TRUE;
}


/***************************************************************************\
* HotTrackCaption
*
* Hot-track a caption button.
\***************************************************************************/

#ifdef COLOR_HOTTRACKING

BOOL xxxHotTrackCaption(PWND pwnd, int ht, BOOL fDraw)
{
    DWORD dwWhere;
    int   x, y;
    WORD  bm, cmd;
    RECT  rcBtn;
    HDC   hdc;

    CheckLock(pwnd);

    if (!TestWF(pwnd, WFCPRESENT))
        return FALSE;

    dwWhere = xxxCalcCaptionButton(pwnd, ht, &cmd, &rcBtn, &bm);
    x = GET_X_LPARAM(dwWhere);
    y = GET_Y_LPARAM(dwWhere);

    if (!cmd)
        return FALSE;

    hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE | DCX_CACHE);
    BitBltSysBmp(hdc, x, y, bm + (fDraw ? DOBI_HOT : 0));
    _ReleaseDC(hdc);
    return TRUE;
}

#endif // COLOR_HOTTRACKING

/***************************************************************************\
* xxxHotTrack
*
\***************************************************************************/

BOOL xxxHotTrack(PWND pwnd, int htEx, BOOL fDraw)
{
    int ht = LOWORD(htEx);

    CheckLock(pwnd);

    switch(ht) {
#ifdef COLOR_HOTTRACKING
    case HTMINBUTTON:
    case HTMAXBUTTON:
    case HTHELP:
    case HTCLOSE:
        return xxxHotTrackCaption(pwnd, ht, fDraw);

    case HTSCROLLUP:
    case HTSCROLLDOWN:
    case HTSCROLLUPPAGE:
    case HTSCROLLDOWNPAGE:
    case HTSCROLLTHUMB:
        return xxxHotTrackSB(pwnd, htEx, fDraw);

    case HTMDIMINBUTTON:
    case HTMDIMAXBUTTON:
    case HTMDICLOSE:
#endif // COLOR_HOTTRACKING
    case HTMENUITEM:
        return xxxHotTrackMenu(pwnd, HIWORD(htEx), fDraw);

    }

    return FALSE;
}

/***************************************************************************\
* xxxCreateTooltip
*
* Call this to show a new tooltip with a new string and delay.
\***************************************************************************/

void xxxCreateTooltip(PTOOLTIPWND pttwnd, LPWSTR pstr)
{
    CheckLock(pttwnd);

    /*
     * Store new text
     */
    pttwnd->pstr = pstr;
    /*
     * If already visible, hide it and show it in new place.
     *  Otherwise, set timer to show.
     */
    if (TestWF(pttwnd, WFVISIBLE)) {
        xxxSetWindowPos((PWND)pttwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE |
                SWP_NOMOVE | SWP_HIDEWINDOW | SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSENDCHANGING);
        xxxShowTooltip(pttwnd);
    } else {
        SetTooltipTimer(pttwnd, TTT_SHOW, pttwnd->dwShowDelay);
    }
}

/***************************************************************************\
* xxxTrackMouseMove
*
* This is the entry point for the system tooltips and hot-tracking.
*
* 12-Sep-96 vadimg      created
\***************************************************************************/

void xxxTrackMouseMove(PWND pwnd, int htEx, UINT message)
{
    BOOL fNewpwndTrack;
    DWORD dwDTCancel = 0;
    TL tlpwnd;
    LPWSTR pstr;
    PDESKTOP pdesk = PtiCurrent()->rpdesk;
    PTHREADINFO ptiTrack;


#if DBG
    /*
     * Let's warn if this function gets reenterd so we can make sure
     * nothing bad will follow. This should be a rare situation.
     * Look in gptiReEntered to find out who is already here.
     */
    static UINT gcReEntered = 0;
    static PTHREADINFO gptiReEntered;
    if(gcReEntered++ != 0){
      RIPMSG2(RIP_WARNING, "Reentered xxxTrackMouseMove; previous thread was %#p, current thread is %#p", gptiReEntered, PtiCurrent());
    }
    gptiReEntered = PtiCurrent();

    CheckLock(pwnd);

    /*
     * We must be on an interactive window station.
     */
    if (pdesk->rpwinstaParent != NULL &&
            pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO) {
        RIPMSG0(RIP_ERROR, "Can't use tooltips on non-interactive winsta");
    }

     {
        static POINT pt = {0, 0};

#ifdef UNDONE
        /*
         * We might have taken a guess on the hit test (see FindNCHitEx)
         *  so if we're at the same point and same window, something
         *  might be fishy
         */
        if ((pt.x == gpsi->ptCursor.x)
                    && (pt.y == gpsi->ptCursor.y)
                    && (pdesk->spwndTrack == pwnd)) {
            RIPMSG1(RIP_WARNING, "xxxTrackMouseMove: Same point & window. %#p", pwnd);
        }
#endif

        /*
         * Something is supposed to have changed or we're wasting time
         */
        UserAssert((pt.x != gpsi->ptCursor.x)
                    || (pt.y != gpsi->ptCursor.y)
                    || (pdesk->spwndTrack != pwnd)
                    || (pdesk->htEx != htEx)
                    || (message != WM_MOUSEMOVE));
        /*
         * Remember last tracked point
         */
        pt = gpsi->ptCursor;
     }
    /*
     * pwnd is supposed to be on the current thread and queue
     */
    UserAssert(PtiCurrent() == GETPTI(pwnd));
    UserAssert(PtiCurrent()->pq == GETPTI(pwnd)->pq);
#endif

    /*
     * Have we switched windows?
     */
    fNewpwndTrack = (pdesk->spwndTrack != pwnd);
    /*
     * If no tracking is taking place, just go set the new
     *  tracking state
     */
    if (!(pdesk->dwDTFlags & DF_MOUSEMOVETRK)) {
        goto SetNewState;
    }
    /*
     * Potentially while we leave the critical section below in
     * xxxCancelMouseMoveTracking, spwndTrack could be destroyed and unlocked
     * and then we go and create the tooltip. This would mean that
     * DF_TOOLTIPACTIVE (part of DF_MOUSEMOVETRK test above) would be set,
     * but pdesk->spwndTrack would be NULL and we can AV dereferencing
     * pdesk->spwndTrack below. Prevent this by making the check here.
     */
    if (pdesk->spwndTrack == NULL) {
        goto SetNewState;
    }

    /*
     * Nuke hottracking and deactivate tooltip state, if any.
     * Do it sychronously if we're tracking on the current queue;
     *  Otherwise, post an event and let it happen later.
     */
    ptiTrack = GETPTI(pdesk->spwndTrack);
    if  (PtiCurrent()->pq == ptiTrack->pq) {
        dwDTCancel |= DF_HOTTRACKING;
    } else if (pdesk->dwDTFlags & (DF_HOTTRACKING | DF_TOOLTIPACTIVE)) {
        PostEventMessage(ptiTrack, ptiTrack->pq,
                        QEVENT_CANCELMOUSEMOVETRK,
                        pdesk->spwndTrack,
                        pdesk->dwDTFlags,
                        pdesk->htEx, DF_HOTTRACKING);
       /*
        * Paranoid assertion. If we're switching queues, we must
        *  be switching windows. Did we just go through
        *  ReattachThreads?
        */
        UserAssert(pwnd != pdesk->spwndTrack);
        pdesk->dwDTFlags &= ~(DF_HOTTRACKING | DF_TOOLTIPACTIVE);
    }
    /*
     * If we're on the client area or the user clicked,
     *  nuke the tooltip (if any).
     * Since we might want to re-show the tooltip, we don't nuke it
     *  now if we swichted windows (we'll nuke it later if needed)
     */
    if ((htEx == HTCLIENT) || (message != WM_MOUSEMOVE)) {
        dwDTCancel |= DF_TOOLTIPACTIVE;
    }
    /*
     * If we switched windows or crossed client/nonclinet boundaries,
     *  end track mouse leave/hover.
     */
    if (fNewpwndTrack || ((pdesk->htEx == HTCLIENT) ^ (htEx == HTCLIENT))) {
        dwDTCancel |= DF_TRACKMOUSEEVENT;
    }
    /*
     * Cancel whatever is active and needs to go away
     */
    ThreadLockAlways(pdesk->spwndTrack, &tlpwnd);
    xxxCancelMouseMoveTracking(pdesk->dwDTFlags,
                           pdesk->spwndTrack,
                           pdesk->htEx,
                           dwDTCancel);
    ThreadUnlock(&tlpwnd);
    pdesk->dwDTFlags &= ~dwDTCancel;



SetNewState:
    /*
     * Hottracking/tooltip on mouse move if on NC hitest and enabled
     */
    if ((htEx != HTCLIENT) && (message == WM_MOUSEMOVE) && TestEffectUP(HOTTRACKING)) {
        /*
         * Hottrack the new hit test area
         */
        if (xxxHotTrack(pwnd, htEx, TRUE)) {
            pdesk->dwDTFlags |= DF_HOTTRACKING;
        }

        /*
         * Remove/set the tool tip.
         * We always do this synchronously because it doesn't mess
         *  with pwnd's or spwnTrack's queue
         */
        if ((pstr = IsTooltipHittest(pwnd, LOWORD(htEx))) != NULL) {
            PTOOLTIPWND pttwnd = (PTOOLTIPWND)pdesk->spwndTooltip;
            ThreadLockAlways(pttwnd, &tlpwnd);
            xxxCreateTooltip(pttwnd, pstr);
            ThreadUnlock(&tlpwnd);
            pdesk->dwDTFlags |= DF_TOOLTIP;
        } else  {
            PTOOLTIPWND pttwnd = (PTOOLTIPWND)pdesk->spwndTooltip;
            ThreadLockAlways(pttwnd, &tlpwnd);
            xxxResetTooltip(pttwnd);
            ThreadUnlock(&tlpwnd);
        }
    } /* if (htEx != HTCLIENT) */


    ValidateThreadLocks(NULL, PtiCurrent()->ptl, (ULONG_PTR)&pwnd, TRUE);

    /*
     * Update new track window if needed.
     */
    if (fNewpwndTrack) {
        PWND pwndActivate;

         Lock(&pdesk->spwndTrack, pwnd);
        /*
         * Active window tracking.
         * If there is non-zero timeout, get the window we're supposed to activate
         *  and set the timer. Otherwise, set the queue flag so
         *  xxxActiveWindowTracking can do its thing.
         */
         if ((message == WM_MOUSEMOVE) && TestUP(ACTIVEWINDOWTRACKING)) {
             if (UP(ACTIVEWNDTRKTIMEOUT) != 0) {
                 pwndActivate = GetActiveTrackPwnd(pwnd, NULL);
                 if (pwndActivate != NULL) {
                     InternalSetTimer(pwndActivate, IDSYS_WNDTRACKING,
                                     UP(ACTIVEWNDTRKTIMEOUT),
                                     xxxSystemTimerProc, TMRF_SYSTEM);
                 }
             } else {
                 PtiCurrent()->pq->QF_flags |= QF_ACTIVEWNDTRACKING;
             } /* if (TestUP(ACTIVEWNDTRKZORDER)) */
         } /* if (TestUP(ACTIVEWINDOWTRACKING)) */

    }

    /*
     * Save new hit test code
     */
    pdesk->htEx = htEx;

#if DBG
    --gcReEntered;
#endif
}

/***************************************************************************\
* xxxCancelMouseMoveTracking
*
* History
* 12/07/96 GerardoB  Created
\***************************************************************************/
void xxxCancelMouseMoveTracking (DWORD dwDTFlags, PWND pwndTrack, int htEx, DWORD dwDTCancel)
{

    CheckLock(pwndTrack);
    /*
     * Hottracking
     */
    if ((dwDTFlags & DF_HOTTRACKING) && (dwDTCancel & DF_HOTTRACKING)) {
        /*
         * The current state must be owned by the current queue.
         * Otherwise, we're about to do an inter-queue cancelation.
         */
        UserAssert(PtiCurrent()->pq == GETPTI(pwndTrack)->pq);

        xxxHotTrack(pwndTrack, htEx, FALSE);
    }

    /*
     * Tooltips
     */
    if ((dwDTFlags & DF_TOOLTIPSHOWING) && (dwDTCancel & DF_TOOLTIP)) {
        PTOOLTIPWND pttwnd = (PTOOLTIPWND)PWNDTOOLTIP(pwndTrack);
        TL tlpwnd;

        ThreadLockAlways(pttwnd, &tlpwnd);
        xxxResetTooltip(pttwnd);
        ThreadUnlock(&tlpwnd);
    }

    /*
     * Mouse Leave
     */
    if ((dwDTFlags & DF_TRACKMOUSELEAVE) && (dwDTCancel & DF_TRACKMOUSELEAVE)) {
        _PostMessage(pwndTrack,
                     ((htEx == HTCLIENT) ? WM_MOUSELEAVE : WM_NCMOUSELEAVE),
                     0, 0);
    }

    /*
     * Mouse Hover
     */
    if ((dwDTFlags & DF_TRACKMOUSEHOVER) && (dwDTCancel & DF_TRACKMOUSEHOVER)) {
        _KillSystemTimer(pwndTrack, IDSYS_MOUSEHOVER);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\update.c ===
/****************************** Module Header ******************************\
* Module Name: update.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the APIs used to invalidate, validate, and force
* updating of windows.
*
* History:
* 27-Oct-1990 DarrinM   Created.
* 25-Jan-1991 IanJa     Revalidation added
* 16-Jul-1991 DarrinM   Recreated from Win 3.1 sources.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Local Constants.
 */
#define UW_ENUMCHILDREN 0x0001
#define UW_RECURSED     0x0004

#define RIR_OUTSIDE     0
#define RIR_INTERSECT   1
#define RIR_INSIDE      2

#define RDW_IGNOREUPDATEDIRTY 0x8000


/***************************************************************************\
* xxxInvalidateRect (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxInvalidateRect(
    PWND   pwnd,
    LPRECT lprcInvalid,
    BOOL   fErase)
{
    CheckLock(pwnd);

    /*
     * BACKWARD COMPATIBILITY HACK
     *
     * In Windows 3.0 and less, ValidateRect/InvalidateRect() call with
     * hwnd == NULL always INVALIDATED and ERASED the entire desktop, and
     * synchronously sent WM_ERASEBKGND and WM_NCPAINT messages before
     * returning.  The Rgn() calls did not have this behavior.
     */
    if (pwnd == NULL) {
        return xxxRedrawWindow(
                pwnd,
                NULL,
                NULL,
                RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE | RDW_ERASENOW);
    } else {
        return xxxRedrawWindow(
                pwnd,
                lprcInvalid,
                NULL,
                fErase ? RDW_INVALIDATE | RDW_ERASE : RDW_INVALIDATE);
    }
}

/***************************************************************************\
* xxxValidateRect (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxValidateRect(
    PWND   pwnd,
    LPRECT lprcValid)
{
    CheckLock(pwnd);

    /*
     * BACKWARD COMPATIBILITY HACK
     *
     * In Windows 3.0 and less, ValidateRect/InvalidateRect() call with
     * hwnd == NULL always INVALIDATED and ERASED the entire desktop, and
     * synchronously sent WM_ERASEBKGND and WM_NCPAINT messages before
     * returning.  The Rgn() calls did not have this behavior.
     */
    if (pwnd == NULL) {
        return xxxRedrawWindow(
                pwnd,
                NULL,
                NULL,
                RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE | RDW_ERASENOW);
    } else {
        return xxxRedrawWindow(pwnd, lprcValid, NULL, RDW_VALIDATE);
    }
}

/***************************************************************************\
* xxxInvalidateRgn (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxInvalidateRgn(
    PWND pwnd,
    HRGN hrgnInvalid,
    BOOL fErase)
{
    CheckLock(pwnd);

    return xxxRedrawWindow(
            pwnd,
            NULL,
            hrgnInvalid,
            fErase ? RDW_INVALIDATE | RDW_ERASE : RDW_INVALIDATE);
}

/***************************************************************************\
* xxxValidateRgn (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxValidateRgn(
    PWND pwnd,
    HRGN hrgnValid)
{
    CheckLock(pwnd);

    return xxxRedrawWindow(pwnd, NULL, hrgnValid, RDW_VALIDATE);
}

/***************************************************************************\
* SmartRectInRegion
*
* This routine is similar to RectInRegion, except that it also determines
* whether or not *lprc is completely within hrgn or not.
*
* RIR_OUTSIDE   - no intersection
* RIR_INTERSECT - *lprc intersects hrgn, but not completely inside
* RIR_INSIDE    - *lprc is completely within hrgn.
*
* LATER:
* It would be MUCH faster to put this functionality into GDI's RectInRegion
* call (a la PM's RectInRegion)
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

UINT SmartRectInRegion(
    HRGN   hrgn,
    LPRECT lprc)
{
    RECT rc;

    if (!GreRectInRegion(hrgn, lprc))
        return RIR_OUTSIDE;

    /*
     * Algorithm: if the intersection of hrgn and *lprc is the
     * same as *lprc, then *lprc is completely within hrgn.
     *
     * If the region is a rectangular one, then do it the easy way.
     */
    if (GreGetRgnBox(hrgn, &rc) == SIMPLEREGION) {

        if (!IntersectRect(&rc, &rc, lprc))
            return RIR_OUTSIDE;

        if (EqualRect(lprc, &rc))
            return RIR_INSIDE;

    } else {

        SetRectRgnIndirect(ghrgnInv2, lprc);

        switch (IntersectRgn(ghrgnInv2, ghrgnInv2, hrgn)) {

        case SIMPLEREGION:
            GreGetRgnBox(ghrgnInv2, &rc);
            if (EqualRect(lprc, &rc))
                return RIR_INSIDE;
            break;

#define RECTINREGION_BUG
#ifdef RECTINREGION_BUG

        /*
         * NOTE: RectInRegion has a BUG, where it sometimes returns TRUE
         * even if the rectangles of a region touch only on the edges
         * with no overlap.  This will result in an empty region after
         * the combination above.
         */
        case NULLREGION:
            return RIR_OUTSIDE;
            break;
#endif

        default:
            break;
        }
    }

    return RIR_INTERSECT;
}

/***************************************************************************\
* PixieHack
*
* BACKWARD COMPATIBILITY HACK
*
* In 3.0, WM_NCPAINT messages would be sent to any child window that was
* inside the bounding rectangle of a window management operation involving
* any other child, even if the intersection of that region with the child
* is empty.
*
* Some apps such as Pixie 2.3 and CA Cricket Presents rely on this to ensure
* that their tool windows stay on top of other child windows.  When the tool
* window gets a WM_NCPAINT, it brings itself to the top of the pile.
*
* Borland ObjectVision depends on getting the WM_NCPAINT after an
* invalidation of its parent window in an area that include the non-client
* area of the child.  When it recieves the WM_NCPAINT, it must get a
* clip region of HRGN_FULL, or nothing gets drawn.
*
* History:
* 02-Mar-1992 MikeKe    Ported from Win 3.1 sources.
\***************************************************************************/

VOID PixieHack(
    PWND   pwnd,
    LPRECT prcBounds)
{
    /*
     * If a child intersects the update region, and it isn't already
     * getting an NCPAINT, then make sure it gets one later.
     *
     * Don't apply this hack to top level windows.
     */
    if ((pwnd != _GetDesktopWindow()) &&
        TestWF(pwnd, WFCLIPCHILDREN)  &&
        !TestWF(pwnd, WFMINIMIZED)) {

        RECT rc;

        for (pwnd = pwnd->spwndChild; pwnd; pwnd = pwnd->spwndNext) {

            /*
             * If the window isn't already getting an NCPAINT message,
             * and it has a caption, and it's inside the bounding rect,
             * make sure it gets a WM_NCPAINT with wParam == HRGN_FULL.
             */
            if (!TestWF(pwnd, WFSENDNCPAINT)                      &&
                (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION)) &&
                IntersectRect(&rc, prcBounds, &pwnd->rcWindow)) {

                /*
                 * Sync paint count is incremented when
                 * (senderasebkgnd | sendncpaint) goes from 0 to != 0.
                 * (should make a routine out of this!)
                 */
                SetWF(pwnd, WFSENDNCPAINT);

                /*
                 * Force HRGN_FULL clip rgn.
                 */
                SetWF(pwnd, WFPIXIEHACK);
            }
        }
    }
}

/***************************************************************************\
* xxxRedrawWindow (API)
*
* Forward to xxxInvalidateWindow if the window is visible.
*
* BACKWARD COMPATIBILITY HACK
*
* In Windows 3.0 and less, ValidateRect/InvalidateRect() call with pwnd == NULL
* always INVALIDATED and ERASED all windows, and synchronously sent
* WM_ERASEBKGND and WM_NCPAINT messages before returning.  The Rgn() calls
* did not have this behavior. This case is handled in
* InvalidateRect/ValidateRect.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxRedrawWindow(
    PWND   pwnd,
    LPRECT lprcUpdate,
    HRGN   hrgnUpdate,
    DWORD  flags)
{
    CheckLock(pwnd);

    /*
     * Always map NULL to the desktop.
     */
    if (pwnd == NULL) {
        pwnd = PtiCurrent()->rpdesk->pDeskInfo->spwnd;
    }

    UserAssert(pwnd != NULL);

    if (IsVisible(pwnd)) {

        TL   tlpwnd;
        HRGN hrgn = hrgnUpdate;

        if (flags & (RDW_VALIDATE | RDW_INVALIDATE)) {

            /*
             * Create a (in)validate region in client window coordinates.
             */
            if (hrgn == NULL) {
                if (!lprcUpdate) {
                    hrgn = HRGN_FULL;
                } else {
                    hrgn = ghrgnInv0;

                    if (TestWF(pwnd, WEFLAYOUTRTL)) {
                        MirrorClientRect(pwnd, lprcUpdate);
                    }

                    if (pwnd == PWNDDESKTOP(pwnd)) {
                        SetRectRgnIndirect(hrgn, lprcUpdate);
                    } else {
                        GreSetRectRgn(
                                hrgn,
                                lprcUpdate->left + pwnd->rcClient.left,
                                lprcUpdate->top + pwnd->rcClient.top,
                                lprcUpdate->right + pwnd->rcClient.left,
                                lprcUpdate->bottom + pwnd->rcClient.top);
                    }
                }
            } else {
                /*
                 * If necessary, make a copy of the passed-in region, because
                 * we'll be trashing it...
                 */
                if (hrgn != HRGN_FULL) {
                    CopyRgn(ghrgnInv0, hrgn);
                    MirrorRegion(pwnd, ghrgnInv0, TRUE);
                    hrgn = ghrgnInv0;
                }

                if (pwnd != PWNDDESKTOP(pwnd)) {
                    GreOffsetRgn(hrgn, pwnd->rcClient.left, pwnd->rcClient.top);
                }
            }
        }

        ThreadLock(pwnd, &tlpwnd);
        xxxInternalInvalidate(pwnd, hrgn, flags | RDW_REDRAWWINDOW);
        ThreadUnlock(&tlpwnd);
    }

    return TRUE;
}

/***************************************************************************\
* InternalInvalidate2
*
* (In)validates hrgn in pwnd and in child windows of pwnd. Child windows
* also subtract their visible region from hrgnSubtract.
*
* pwnd         - The window to (in)validate.
* hrng         - The region to (in)validate.
* hrgnSubtract - The region to subtract the visible region of
*                 child windows from.
* prcParents   - Contains the intersection of pwnd's client or window rect
*                 with the client rectangles of its parents. May just be
*                 the window's client or window rect.
*
* flags        - RDW_ flags.
*
* Returns FALSE if hrgnSubtract becomes a NULLREGION, TRUE otherwise.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL InternalInvalidate2(
    PWND   pwnd,
    HRGN   hrgn,
    HRGN   hrgnSubtract,
    LPRECT prcParents,
    DWORD  flags)
{
    /*
     * NOTE: Uses ghrgnInv2
     */
    RECT  rcOurShare;
    DWORD flagsChildren;
    PWND  pwndT;

    /*
     * This routine is called recursively down the parent/child chain.
     * Remember if on the way one of the windows has a clipping region.
     * This info is used later on to optimize out a loop in the common
     * case.
     */
    if (pwnd->hrgnClip != NULL) {
        flags |= RDW_HASWINDOWRGN;
    }

    /*
     * If we recurse, make sure our children subtract themselves off.
     */
    flagsChildren = flags | RDW_SUBTRACTSELF;
    CopyRect(&rcOurShare, &pwnd->rcWindow);

    /*
     * If we're invalidating, we only want to deal with the part of
     * our window rectangle that intersects our parents.
     * This way, we don't end up validating or invalidating more than our
     * fair share. If we're completely obscured by our parents, then there is
     * nothing to do.
     *
     * We don't perform this intersection if we're validating, because there
     * are cases where a child and its update region may exist but be obscured
     * by parents, and we want to make sure validation will work in these
     * cases.  ScrollWindow() can cause this when children are offset, as can
     * various 3.0 compatibility hacks.
     */

    if (flags & RDW_INVALIDATE) {
        /*
         * Don't subtract out any sprite windows from the invalid region.
         * Behave as if it's not there.  However, always allow layered window
         * invalidation when RDW_INVALIDATELAYERS is passed in.
         */
#ifdef REDIRECTION
        if ((TestWF(pwnd, WEFLAYERED) || TestWF(pwnd, WEFEXTREDIRECTED)) &&
#else // REDIRECTION
        if ((TestWF(pwnd, WEFLAYERED)) &&
#endif // REDIRECTION
                !(flags & RDW_INVALIDATELAYERS))
            return TRUE;

        if (!IntersectRect(&rcOurShare, &rcOurShare, prcParents)) {

            /*
             * BACKWARD COMPATIBILITY HACK: If hrgn is (HRGN)1, we need to
             * invalidate ALL child windows, even if they're not visible.  This
             * is a bummer, because it'll result in all sorts of repaints that
             * aren't necessary.
             *
             * Various apps, including WordStar for Windows and WaveEdit,
             * depend on this behavior.  Here's how WaveEdit relies on this: it
             * has a CS_HDREDRAW | CS_VREDRAW window, that moves its children
             * around with MoveWindow( ..., fRedraw = FALSE).  The windows
             * not part of the new client area didn't get invalidated.
             */
            if (!TestWF(pwnd, WFWIN31COMPAT) && (hrgn == HRGN_FULL)) {

                /*
                 * For purposes of hit-testing, our share is our window
                 * rectangle.  However, we don't want to diddle the region
                 * passed to us, because by rights we're really clipped out!
                 */
                flags &= ~RDW_SUBTRACTSELF;
                flagsChildren &= ~RDW_SUBTRACTSELF;

            } else {
                return TRUE;
            }
        }

        /*
         * If our window rect doesn't intersect the valid/invalid region,
         * nothing further to do.
         */
        if (hrgn > HRGN_FULL) {

            switch (SmartRectInRegion(hrgn, &rcOurShare)) {
            case RIR_OUTSIDE:
                return TRUE;

            case RIR_INTERSECT:

                /*
                 * The update region can be within the window rect but not
                 * touch the window region; in this case we don't want this
                 * update region to be distributed to this window. If this
                 * is the case, return TRUE as if RIR_OUTSIDE.
                 *
                 * If RDW_HASWINDOWRGN is set, either this window or
                 * one of its parents has a window clipping region. This
                 * flag is just an optimization so that this loop isn't
                 * executed all the time.
                 *
                 * A future optimization may be to calculate this parent
                 * clipped region as part of recursion like prcParents is
                 * calculated. It is not super important though because this
                 * case rarely happens (a window with a region), and even
                 * more rare, a regional window that is a child of a regional
                 * window parent.
                 */
                if (flags & RDW_HASWINDOWRGN) {

                    /*
                     * Clip to the window's clipping region and parents!
                     * If we don't clip to parents, we may get a case where
                     * a child clips out some update region that was meant to
                     * go to a sibling of the parent.
                     */
                    SetRectRgnIndirect(ghrgnInv2, &rcOurShare);
                    for (pwndT = pwnd; pwndT != NULL; pwndT = pwndT->spwndParent) {

                        if (pwndT->hrgnClip != NULL) {

                            /*
                             * An error at this stage would possibly result
                             * in more being subtracted out of the clipping
                             * region that we'd like.
                             */
                            IntersectRgn(ghrgnInv2, ghrgnInv2, pwndT->hrgnClip);
                        }
                    }

                    if (IntersectRgn(ghrgnInv2, ghrgnInv2, hrgn) == NULLREGION)
                        return TRUE;
                }
                break;

            case RIR_INSIDE:
                /*
                 * If the rectangle is completely within hrgn, then we can use
                 * HRGN_FULL, which is much faster and easier to deal with.
                 *
                 * COMPAT HACK:  There are some apps (PP, MSDRAW) that depend
                 * on some weirdities of the 3.0 GetUpdateRect in order to
                 * paint properly.  Since this stuff hinges on whether the
                 * update region is 1 or a real region, we need to simulate
                 * when 3.0 would generate a HRGN(1) update region.  The
                 * following optimization was not made in 3.0, so we yank it
                 * in 3.1 for these apps.  (win31 bugs 8235,10380)
                 */
                if (!(GetAppCompatFlags(GETPTI(pwnd)) & GACF_NOHRGN1))
                    hrgn = HRGN_FULL;
                break;
            }
        }

        /*
         * While we are in the middle of compositing, no invalidation should
         * happen, or it will mess up our painting order. This is because on
         * this compositing pass we may validate some of the new invalid area
         * and the invalid area that didn't get validated will bleed through
         * on the next compositing pass. So we will remember an accumulated
         * invalid area which will really get invalidated once the compositing
         * pass is completed.
         */
        if (TestWF(pwnd, WEFPCOMPOSITING)) {
            PREDIRECT prdr = _GetProp(pwnd, PROP_LAYER, TRUE);

            if (prdr != NULL) {
                HRGN hrgnComp = prdr->hrgnComp;

                if (hrgnComp == NULL) {
                    if ((hrgnComp = CreateEmptyRgnPublic()) == NULL) {
                        hrgnComp = HRGN_FULL;
                    }
                }

                SetRectRgnIndirect(ghrgnInv2, &rcOurShare);

                if (hrgnComp != HRGN_FULL) {
                    GreCombineRgn(hrgnComp, hrgnComp, ghrgnInv2, RGN_OR);
                }

                prdr->hrgnComp = hrgnComp;

                if (SubtractRgn(hrgnSubtract, hrgnSubtract, ghrgnInv2) == NULLREGION) {
                    return FALSE;
                }

                return TRUE;
            }
        }
    }

    /*
     * If not CLIPCHILDREN, go diddle the update region BEFORE our clipped
     * children have done their thing to hrgnSubtract. Otherwise,
     * we'll diddle after we recurse.
     */
    if (!TestWF(pwnd, WFCLIPCHILDREN)) {
        InternalInvalidate3(pwnd, hrgn, flags);
    }

    /*
     * If this is a GACF_ALWAYSSENDNCPAINT app, take care of it...
     */
    if (TestWF(pwnd, WFALWAYSSENDNCPAINT))
        PixieHack(pwnd, &rcOurShare);

    /*
     * Recurse on our children if necessary.
     *
     * By default, our children are enumerated if we are not CLIPCHILDREN.
     * Don't bother with children if we're minimized.
     */
    if ((pwnd->spwndChild != NULL) &&
        !TestWF(pwnd, WFMINIMIZED) &&
        !(flags & RDW_NOCHILDREN)  &&
        ((flags & RDW_ALLCHILDREN) || !TestWF(pwnd, WFCLIPCHILDREN))) {

        RECT rcChildrenShare;
        PWND pwndChild;

        /*
         * If we're invalidating, make sure our children
         * erase and frame themselves. Also, tell children to subtract
         * themselves from hrgnSubtract.
         */
        if (flags & RDW_INVALIDATE) {
            flagsChildren |= RDW_ERASE | RDW_FRAME;
        }

        /*
         * Our children are clipped to our client rect, so reflect
         * that in the rectangle we give them.
         */
        if (IntersectRect(&rcChildrenShare, &rcOurShare, &pwnd->rcClient) ||
            (!TestWF(pwnd, WFWIN31COMPAT) && (hrgn == HRGN_FULL))) {

            for (pwndChild = pwnd->spwndChild; pwndChild != NULL;
                    pwndChild = pwndChild->spwndNext) {

                if (!TestWF(pwndChild, WFVISIBLE))
                    continue;

                if (!InternalInvalidate2(pwndChild,
                                         hrgn,
                                         hrgnSubtract,
                                         &rcChildrenShare,
                                         flagsChildren)) {

                    /*
                     * The children swallowed the region:
                     * If there are no update region related things
                     * to do then we can just return with FALSE
                     */
                    if (!(flags & (RDW_INTERNALPAINT | RDW_NOINTERNALPAINT)))
                        return FALSE;

                    /*
                     * We have to enumerate the rest of the children because
                     * one of the RDW_NO/INTERNALPAINT bits is set.  Since
                     * there's no longer any update region to worry about,
                     * strip out the update region bits from the parent
                     * and child fiags.  Also, tell the children not to
                     * bother subtracting themselves from the region.
                     */
                    flags &= ~(RDW_INVALIDATE |
                               RDW_ERASE      |
                               RDW_FRAME      |
                               RDW_VALIDATE   |
                               RDW_NOERASE    |
                               RDW_NOFRAME);

                    flagsChildren &= ~(RDW_INVALIDATE |
                                       RDW_ERASE      |
                                       RDW_FRAME      |
                                       RDW_VALIDATE   |
                                       RDW_NOERASE    |
                                       RDW_NOFRAME    |
                                       RDW_SUBTRACTSELF);
                }
            }
        }
    }

    /*
     * Go diddle the update region  (AFTER our clipped children may have
     * done their thing to hrgnSubtract)
     */
    if (TestWF(pwnd, WFCLIPCHILDREN))
        InternalInvalidate3(pwnd, hrgn, flags);

    /*
     * If we're invalidating and we're supposed to,
     * try to subtract off our window area from the region.
     *
     * This way our parent and our siblings below us will not
     * get any update region for areas that don't need one.
     */
    if (flags & RDW_SUBTRACTSELF) {

        /*
         * Subtract our visible region from the update rgn only if:
         * a) we're not a transparent window
         * b) we are clipsiblings
         * c) we're validating OR our parent is clipchildren.
         *
         * The check for validation is a backward-compatibility hack: this
         * is what 3.0 did, so this is what we do here.
         *
         * BACKWARD COMPATIBILITY HACK
         *
         * In 3.0, we subtracted this window from the update rgn if it
         * was clipsiblings, even if the parent was not clipchildren.
         * This causes a compatibility problem for Lotus Notes 3.1: it
         * has a combobox dropdown in a dialog that is a WS_CLIPSIBLING
         * sibling of the other dialog controls, which are not WS_CLIPSIBLINGs.
         * The dialog is not WS_CLIPCHILDREN.  What happens is that a listbox
         * underneath the dropdown also gets a paint msg (since we didn't
         * do this subtraction), and, since it's not CLIPSIBLINGS, it
         * obliterates the dropdown.
         *
         * This is a very obscure difference, and it's too late in the
         * project to make this change now, so we're leaving the code as is
         * and using a compatibility hack to enable the 3.0-compatible
         * behavior.  It's quite likely that this code works the way it does
         * for other compatibility reasons.  Sigh (neilk).
         */
        if (!TestWF(pwnd, WEFTRANSPARENT) &&
            TestWF(pwnd, WFCLIPSIBLINGS)  &&
            ((flags & RDW_VALIDATE) ||
                 ((pwnd->spwndParent != NULL) &&
                 (TestWF(pwnd->spwndParent, WFCLIPCHILDREN) ||
                 (GetAppCompatFlags(GETPTI(pwnd)) & GACF_SUBTRACTCLIPSIBS))))) {

            /*
             * Intersect with our visible area.
             *
             * Don't worry about errors: an error will result in more, not less
             * area being invalidated, which is okay.
             */
            SetRectRgnIndirect(ghrgnInv2, &rcOurShare);

            /*
             * If RDW_HASWINDOWRGN is set, either this window or
             * one of its parents has a window clipping region. This
             * flag is just an optimization so that this loop isn't
             * executed all the time.
             */
            if (flags & RDW_HASWINDOWRGN) {

                /*
                 * Clip to the window's clipping region and parents!
                 * If we don't clip to parents, we may get a case where
                 * a child clips out some update region that was meant to
                 * go to a sibling of the parent.
                 */
                for (pwndT = pwnd; pwndT != NULL; pwndT = pwndT->spwndParent) {

                    if (pwndT->hrgnClip != NULL) {

                        /*
                         * An error at this stage would possibly result in more
                         * being subtracted out of the clipping region that
                         * we'd like.
                         */
                        IntersectRgn(ghrgnInv2, ghrgnInv2, pwndT->hrgnClip);
                    }
                }
            }


#if 1
            /*
             * TEMP HACK!!! RE-ENABLE this code when regions work again
             */
            if (SubtractRgn(hrgnSubtract, hrgnSubtract, ghrgnInv2) == NULLREGION)
                return FALSE;
#else
            {
            DWORD iRet;

            iRet = SubtractRgn(hrgnSubtract, hrgnSubtract, ghrgnInv2);

            if (iRet == NULLREGION)
                return FALSE;

            if (iRet == SIMPLEREGION) {
                RECT rcSub;
                GreGetRgnBox(hrgnSubtract, &rcSub);
                if (rcSub.left > rcSub.right)
                    return FALSE;
            }
            }
#endif



        }
    }

    return TRUE;
}

/***************************************************************************\
* InternalInvalidate3
*
* Adds or subtracts hrgn to the windows update region and sets appropriate
* painting state flags.
*
* pwnd  - The window.
* hrng  - The region to add to the update region.
* flags - RDW_ flags.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID InternalInvalidate3(
    PWND  pwnd,
    HRGN  hrgn,
    DWORD flags)
{
    BOOL fNeededPaint;

    fNeededPaint = NEEDSPAINT(pwnd);

    if (flags & (RDW_INVALIDATE | RDW_INTERNALPAINT | RDW_ERASE | RDW_FRAME)) {

        if (flags & RDW_INTERNALPAINT)
            SetWF(pwnd, WFINTERNALPAINT);

        if (flags & RDW_INVALIDATE) {

            /*
             * Make sure that the NONCPAINT bit is cleared
             * to ensure that the caption will redraw when we update.
             */
            ClrWF(pwnd, WFNONCPAINT);

            /*
             * If another app is invalidating this window, then set the
             * UPDATEDIRTY flag.
             *
             * Solves critical section where thread A draws, then validates,
             * but thread B goes and invalidates before A validates.
             * See comments later in RDW_VALIDATE code.
             */
            if (GETPTI(pwnd) != PtiCurrent()) {

                SetWF(pwnd, WFUPDATEDIRTY);

                /*
                 * Paint order problem, see paint.c
                 */
                if (TestWF(pwnd, WFWMPAINTSENT)) {
                    SetWF(pwnd, WFDONTVALIDATE);
                }
            }

            /*
             * BACKWARD COMPATIBILITY HACK
             *
             * In 3.0, InvalidateRect(pwnd, NULL, FALSE) would always
             * clear the WFSENDERASEBKGND flag, even if it was previously
             * set from an InvalidateRect(pwnd, NULL, TRUE).  This is bogus,
             * because it can cause you to "lose" WM_ERASEBKGND messages, but
             * AttachMate Extra (and maybe other apps) depend on this behavior.
             */
            if ((hrgn == HRGN_FULL) && !TestWF(pwnd, WFWIN31COMPAT))
                ClrWF(pwnd, WFSENDERASEBKGND);

            if (flags & RDW_ERASE)
                SetWF(pwnd, WFSENDERASEBKGND);

            if ((flags & (RDW_FRAME | RDW_ERASE)) && !TestWF(pwnd, WEFTRANSPARENT))
                SetHungFlag(pwnd, WFREDRAWIFHUNG);

            if (flags & RDW_FRAME)
                SetWF(pwnd, WFSENDNCPAINT);

            /*
             * If window is already completely invalidated,
             * no need to do any further invalidation.
             */
            if (pwnd->hrgnUpdate != HRGN_FULL) {

                if (hrgn == HRGN_FULL) {
InvalidateAll:
                    DeleteMaybeSpecialRgn(pwnd->hrgnUpdate);
                    pwnd->hrgnUpdate = HRGN_FULL;

                } else {
                    if (pwnd->hrgnUpdate == NULL) {

                        if (!(pwnd->hrgnUpdate = CreateEmptyRgnPublic()))
                            goto InvalidateAll;

                        if (CopyRgn(pwnd->hrgnUpdate, hrgn) == ERROR)
                            goto InvalidateAll;

                    } else {   // pwnd->hrgnUpdate is a region

                        if (UnionRgn(pwnd->hrgnUpdate,
                                     pwnd->hrgnUpdate,
                                     hrgn) == ERROR) {

                            goto InvalidateAll;
                        }
                    }
                }
            }
        }

        if (!fNeededPaint && NEEDSPAINT(pwnd))
            IncPaintCount(pwnd);

    } else if (flags & (RDW_VALIDATE | RDW_NOINTERNALPAINT | RDW_NOERASE | RDW_NOFRAME)) {

        /*
         * Validation:
         *
         * Do not allow validation if this window has been invalidated from
         * another process - because this window may be validating just
         * after another process invalidated, thereby validating invalid
         * bits.
         *
         * Sometimes applications draw stuff, then validate what they drew.
         * If another app invalidated some area during the drawing operation,
         * then it will need another paint message.
         *
         * This wouldn't be necessary if people validated BEFORE they drew.
         */
        if (TestWF(pwnd, WFUPDATEDIRTY) && !(flags & RDW_IGNOREUPDATEDIRTY))
            return;

        if (flags & RDW_NOINTERNALPAINT)
            ClrWF(pwnd, WFINTERNALPAINT);

        if (flags & RDW_VALIDATE) {

            if (flags & RDW_NOERASE)
                ClrWF(pwnd, WFSENDERASEBKGND);

            if (flags & RDW_NOFRAME) {
                ClrWF(pwnd, WFSENDNCPAINT);
                ClrWF(pwnd, WFPIXIEHACK);
            }

            if (flags & (RDW_NOERASE | RDW_NOFRAME))
                ClearHungFlag(pwnd, WFREDRAWIFHUNG);

            if (pwnd->hrgnUpdate != NULL) {

                /*
                 * If WFSENDNCPAINT is set, then all or part of the
                 * window border still needs to be drawn.  This means
                 * that we must subtract off the client rectangle only.
                 * Convert HRGN_FULL to the client region.
                 */
                if (TestWF(pwnd, WFSENDNCPAINT) && (hrgn == HRGN_FULL)) {
                    hrgn = ghrgnInv2;
                    CalcWindowRgn(pwnd, hrgn, TRUE);
                }

                if (hrgn == HRGN_FULL) {
ValidateAll:

                    /*
                     * We're validating the entire window.  Just
                     * blow away the update region.
                     */
                    DeleteMaybeSpecialRgn(pwnd->hrgnUpdate);
                    pwnd->hrgnUpdate = (HRGN)NULL;

                    /*
                     * No need to erase the background...
                     */
                    ClrWF(pwnd, WFSENDERASEBKGND);
                    ClearHungFlag(pwnd, WFREDRAWIFHUNG);

                } else {

                    /*
                     * Subtracting some region from pwnd->hrgnUpdate.
                     * Be sure pwnd->hrgnUpdate is a real region.
                     */
                    if (pwnd->hrgnUpdate == HRGN_FULL) {

                        /*
                         * If the WFSENDNCPAINT bit is set,
                         * the update region must include the entire window
                         * area.  Otherwise it includes only the client.
                         */
                        pwnd->hrgnUpdate = CreateEmptyRgnPublic();

                        /*
                         * If the creation failed, punt by
                         * invalidating the entire window.
                         */
                        if (pwnd->hrgnUpdate == NULL)
                            goto InvalidateAll;

                        if (CalcWindowRgn(pwnd,
                                          pwnd->hrgnUpdate,
                                          !(TestWF(pwnd, WFSENDNCPAINT))) == ERROR) {

                            goto InvalidateAll;
                        }
                    }

                    /*
                     * Subtract off the region.  If we get an error,
                     * punt by invalidating everything.  If the
                     * region becomes empty, then validate everything.
                     */
                    switch (SubtractRgn(pwnd->hrgnUpdate,
                                        pwnd->hrgnUpdate,
                                        hrgn)) {
                    case ERROR:
                        goto InvalidateAll;

                    case NULLREGION:
                        goto ValidateAll;
                    }
                }
            }
        }

        if (fNeededPaint && !NEEDSPAINT(pwnd))
            DecPaintCount(pwnd);
    }
}

/***************************************************************************\
* ValidateParents
*
* This routine validates hrgn from the update regions of the parent windows
* between pwnd and its first clip children parent.
* If hrgn is NULL, then the window rect (intersected with all parents)
* is validated.
*
* This routine is called when a window is being drawn in
* UpdateWindow() so that non-CLIPCHILDREN parents
* of windows being redrawn won't draw on their valid children.
*
* Returns FALSE if fRecurse is TRUE and a non-CLIPCHILDREN parent
* has an update region; otherwise, returns TRUE.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL ValidateParents(
    PWND pwnd,
    BOOL fRecurse)
{
    RECT rcParents;
    RECT rc;
    PWND pwndParent = pwnd;
    BOOL fInit = FALSE;

    /*
     * This is checking whether we are in an in-between state, just before
     * a WM_SYNCPAINT is about to arrive.  If not, then ValidateParents()
     * needs to work like it did in Win 3.1.
     */
    while (TestWF(pwndParent, WFCHILD))
        pwndParent = pwndParent->spwndParent;

    if (!TestWF(pwndParent, WFSYNCPAINTPENDING))
        fRecurse = FALSE;

    pwndParent = pwnd;

    while ((pwndParent = pwndParent->spwndParent) != NULL) {

        /*
         * Stop when we find a clipchildren parent
         */
        if (TestWF(pwndParent, WFCLIPCHILDREN))
            break;

        /*
         * Subtract the region from this parent's update region,
         * if it has one.
         */
        if (pwndParent->hrgnUpdate != NULL) {
            if (fRecurse) {
                return FALSE;
            }
            if (!fInit) {
                fInit = TRUE;

                /*
                 * Do initial setup.  If our window rectangle is
                 * completely obscured, get out.
                 */
                rc = pwnd->rcWindow;
                if (!IntersectWithParents(pwnd, &rc))
                    break;

                SetRectRgnIndirect(ghrgnInv1, &rc);

                /*
                 * If this window has a region, make sure the piece being validated
                 * is within this region.
                 */
                if (pwnd->hrgnClip != NULL) {

                    /*
                     * If we get NULLREGION back, there is nothing to validate
                     * against parents, so break out. If ERROR gets returned,
                     * there is not much we can do: the best "wrong" thing
                     * to do is just continue and validate a little more
                     * from the parent.
                     */
                    if (!IntersectRgn(ghrgnInv1, ghrgnInv1, pwnd->hrgnClip))
                        break;
                }
            }

            /*
             * Calculate the rcParents parameter to
             * pass up to InternalInvalidate2.
             */
            rcParents = pwndParent->rcWindow;

            if (!IntersectWithParents(pwndParent, &rcParents))
                break;

            InternalInvalidate2(
                    pwndParent,
                    ghrgnInv1,
                    ghrgnInv1,
                    &rcParents,
                    RDW_VALIDATE | RDW_NOCHILDREN | RDW_IGNOREUPDATEDIRTY);
        }
    }

    return TRUE;
}

/***************************************************************************\
* xxxUpdateWindow2
*
* Sends a WM_PAINT message to the window if it needs painting,
* then sends the message to its children.
*
* Always returns TRUE.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

void xxxUpdateWindow2(
    PWND  pwnd,
    DWORD flags)
{
    TL tlpwnd;

    CheckLock(pwnd);

    if (NEEDSPAINT(pwnd)) {

        /*
         * Punch a hole in our parent's update region, if we have one.
         */
        if (pwnd->hrgnUpdate) {
            if (ValidateParents(pwnd, flags & UW_RECURSED) == FALSE) {
                return;
            }
        }

        /*
         * Now that we're sending the message, clear the
         * internal paint bit if it was previously set.
         */
        if (TestWF(pwnd, WFINTERNALPAINT)) {

            ClrWF(pwnd, WFINTERNALPAINT);

            /*
             * If there is no update region, then no further paint messages
             * are pending, so we must dec the paint count.
             */
            if (pwnd->hrgnUpdate == NULL)
                DecPaintCount(pwnd);
        }

        /*
         * Set a flag indicating that a paint message was not processed
         * (but should be).
         */
        SetWF(pwnd, WFPAINTNOTPROCESSED);

        /*
         * Clear this bit, for apps (like MicroLink) that don't call
         * BeginPaint or GetUpdateRect/Rgn (but DO call ValidateRect)
         * when handling their WM_PAINT message.
         */
        ClrWF(pwnd, WFUPDATEDIRTY);

        /*
         * BACKWARD COMPATIBILITY HACK
         *
         * Win 3.0 always sent WM_PAINTICON with wParam == TRUE for no good
         * reason, and Lotus Notes has come to depend on this.
         */
        if (!TestWF(pwnd, WFWIN40COMPAT) &&
            TestWF(pwnd, WFMINIMIZED)    &&
            (pwnd->pcls->spicn != NULL)) {

            xxxSendMessage(pwnd, WM_PAINTICON, TRUE, 0L);

        } else {

            xxxSendMessage(pwnd, WM_PAINT, 0, 0L);
        }

        /*
         * If the guy didn't call BeginPaint/EndPaint(), or GetUpdateRect/Rgn
         * with fErase == TRUE, then we have to clean up for him here.
         */
        if (TestWF(pwnd, WFPAINTNOTPROCESSED)) {

            RIPMSG0(RIP_VERBOSE,
                "App didn't call BeginPaint() or GetUpdateRect/Rgn(fErase == TRUE) in WM_PAINT");

            xxxSimpleDoSyncPaint(pwnd);
        }
    }

    /*
     * For desktop window, do not force the top level window repaint at this
     * this point.  We are calling UpdateWindow() for the desktop before
     * size/move is sent for the top level windows.
     *
     * BUG: The comment above seems a bit random.  Is there really a problem?
     *      If nothing else this has to remain this way because it is
     *      how Win 3.0 worked (neilk)
     */
    if ((flags & UW_ENUMCHILDREN) && (pwnd != PWNDDESKTOP(pwnd))) {

        /*
         * Update any children...
         */
        ThreadLockNever(&tlpwnd);
        pwnd = pwnd->spwndChild;
        while (pwnd != NULL) {

            /*
             * If there is a transparent window that needs painting,
             * skip it if another window below it needs to paint.
             */
            if (TestWF(pwnd, WEFTRANSPARENT) && NEEDSPAINT(pwnd)) {

                PWND pwndT = pwnd;

                while ((pwndT = pwndT->spwndNext) != NULL) {
                    if (NEEDSPAINT(pwndT))
                        break;
                }

                if (pwndT != NULL) {
                    pwnd = pwnd->spwndNext;
                    continue;
                }
            }

            ThreadLockExchangeAlways(pwnd, &tlpwnd);
            xxxUpdateWindow2(pwnd, flags | UW_RECURSED);
            pwnd = pwnd->spwndNext;
        }

        ThreadUnlock(&tlpwnd);
    }

    return;
}

/***************************************************************************\
* xxxInternalUpdateWindow
*
* Sends a WM_PAINT message to the window if it needs painting,
* then sends the message to its children. Won't send WM_PAINT
* if the window is transparent and has siblings that need
* painting.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

void xxxInternalUpdateWindow(
    PWND pwnd,
    DWORD flags)
{
    PWND pwndComp;

    CheckLock(pwnd);

    if ((pwndComp = GetStyleWindow(pwnd, WEFCOMPOSITED)) != NULL) {
        TL tlpwnd;
        ThreadLockAlways(pwndComp, &tlpwnd);
        xxxCompositedPaint(pwndComp);
        ThreadUnlock(&tlpwnd);
        return;
    }

    /*
     * If the passed-in window is transparent and a sibling below
     * needs repainting, don't do anything.
     */
    if (TestWF(pwnd, WEFTRANSPARENT)) {

        PWND         pwndT = pwnd;
        PTHREADINFO ptiCurrent = GETPTI(pwnd);

        while ((pwndT = pwndT->spwndNext) != NULL) {

            /*
             * Make sure sibling window belongs to same app.
             */
            if (GETPTI(pwndT) != ptiCurrent)
                continue;

            if (NEEDSPAINT(pwndT))
                return;
        }
    }

    /*
     * Enumerate pwnd and all its children, sending WM_PAINTs as needed.
     */
    xxxUpdateWindow2(pwnd, flags);
}

/***************************************************************************\
* xxxInternalInvalidate
*
* (In)validates hrgnUpdate and updates the window.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID xxxInternalInvalidate(
    PWND  pwnd,
    HRGN  hrgnUpdate,
    DWORD flags)
{
    RECT rcParents;
    HRGN hrgnSubtract;
    PWND pwndComp = NULL;
    PWND pwndSave;
    HRGN hrgnComp;

#if DBG
    if (flags & (RDW_ERASENOW | RDW_UPDATENOW)) {
        CheckLock(pwnd);
    }
#endif

    /*
     * For children of composited windows, invalidate starting from the
     * composited window itself.
     */
    if (flags & RDW_INVALIDATE) {
        if ((pwndComp = GetStyleWindow(pwnd, WEFCOMPOSITED)) != NULL) {

            if (hrgnUpdate == HRGN_FULL) {
                hrgnComp = GreCreateRectRgnIndirect(&pwnd->rcWindow);

                if (hrgnComp != NULL) {
                    hrgnUpdate = hrgnComp;
                }
            } else {
                hrgnComp = NULL;
            }

            pwndSave = pwnd;
            pwnd = pwndComp;

            flags |= RDW_ALLCHILDREN;
        }
    }

    /*
     * Allow invalidation of a layered window when someone specifically
     * invalidates it.  This will also prevent invalidation of layered
     * windows during recursive desktop invalidations.
     */
#ifdef REDIRECTION
    if (TestWF(pwnd, WEFLAYERED) || TestWF(pwnd, WEFEXTREDIRECTED)) {
#else // REDIRECTION
    if (TestWF(pwnd, WEFLAYERED)) {
#endif // REDIRECTION
        flags |= RDW_INVALIDATELAYERS;
    }

    /*
     * Ensure that hrgnSubtract is a valid region: if it's NULLREGION,
     * use the client region.
     */
    rcParents = (flags & RDW_FRAME ? pwnd->rcWindow : pwnd->rcClient);

    if (flags & (RDW_VALIDATE | RDW_INVALIDATE)) {

        hrgnSubtract = hrgnUpdate;

        if (hrgnSubtract == HRGN_FULL) {

            hrgnSubtract = ghrgnInv1;
            CalcWindowRgn(pwnd,
                          hrgnSubtract,
                          (flags & RDW_FRAME) ? FALSE : TRUE);
        }

        /*
         * Calculate the bounding rectangle of our screen real estate,
         * by intersecting with our parent rectangles.  While we're at
         * it, check the visibility of ourself and our parents.
         *
         * If we're validating we want to skip this, since there
         * are a number of cases where obscured windows may have
         * update regions to be validated -- in particular, after
         * a ScrollWindow() call where a child window was offset
         * by OffsetChildren() to a new, obscured position.  Some of
         * the 3.0 compatibility hacks also can lead to this situation.
         */
        if ((flags & RDW_INVALIDATE) && !IntersectWithParents(pwnd, &rcParents))
            return;

    } else {
        /*
         * hrgnsubtract needs to be a real region even if
         * we are not invalidating or validating.  It really doesn't
         * matter what the region is, but we set it to null so the code
         * has less degrees of freedom.
         */
        hrgnSubtract = ghrgnInv1;
        SetEmptyRgn(hrgnSubtract);
    }

    /*
     * If we're invalidating, and we're being called by the app,
     * we need to invalidate any SPBs that might be affected by
     * drawing in the client area of this window.
     * We have to do this because there is no guarantee that the
     * application will draw in an area that is invalidated
     * (e.g., if the window is completely obscured by another).
     */
    if (    (flags & (RDW_INVALIDATE | RDW_REDRAWWINDOW)) == (RDW_INVALIDATE | RDW_REDRAWWINDOW) &&
            AnySpbs()) {

        RECT rcInvalid;

        /*
         * Intersect the parent's rect with the region bounds...
         */
        GreGetRgnBox(hrgnSubtract, &rcInvalid);
        IntersectRect(&rcInvalid, &rcInvalid, &rcParents);
        SpbCheckRect(pwnd, &rcInvalid, 0);
    }

    /*
     * Now go do the recursive update region calculations...
     */
    InternalInvalidate2(pwnd, hrgnUpdate, hrgnSubtract, &rcParents, flags);

    if (pwndComp != NULL) {
        pwnd = pwndSave;

        if (hrgnComp != NULL) {
            GreDeleteObject(hrgnComp);
        }
    }

    /*
     * Finally handle any needed drawing.
     *
     * (NOTE: RDW_UPDATENOW implies RDW_ERASENOW)
     */
    if (flags & RDW_UPDATENOW) {

        xxxInternalUpdateWindow(pwnd,
                                flags & RDW_NOCHILDREN ? 0 : UW_ENUMCHILDREN);

    } else if (flags & RDW_ERASENOW) {

        UINT flagsDSP;

        if (flags & RDW_NOCHILDREN) {
            flagsDSP = 0;
        } else if (flags & RDW_ALLCHILDREN) {
            flagsDSP = DSP_ALLCHILDREN;
        } else {
            flagsDSP = DSP_ENUMCLIPPEDCHILDREN;
        }

        xxxDoSyncPaint(pwnd, flagsDSP);
    }
}

/***************************************************************************\
* UpdateWindow (API)
*
* Updates the window and all its children.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxUpdateWindow(
    PWND pwnd)
{
    CheckLock(pwnd);

    xxxInternalUpdateWindow(pwnd, UW_ENUMCHILDREN);

    /*
     * This function needs to return a value, since it is
     * called through NtUserCallHwndLock.
     */
    return TRUE;
}

/***************************************************************************\
* ExcludeUpdateRgn (API)
*
* ENTRY:    hdc - DC to exclude from
*           pwnd - window handle
*
* EXIT:     GDI region type
*
* WARNINGS: The DC is assumed to correspond to the client area of the window.
*
*           The map mode of hdc MUST be text mode (0, 0 is top left corner,
*           one pixel per unit, ascending down and to right) or things won't
*           work.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int _ExcludeUpdateRgn(
    HDC  hdc,
    PWND pwnd)
{
    POINT pt;

    if (pwnd->hrgnUpdate == NULL) {

        RECT rc;

        /*
         * Pass FALSE for fXForm since &rc isn't used.
         */
        return GreGetClipBox(hdc, &rc, FALSE);

    } else if (pwnd->hrgnUpdate == HRGN_FULL) {

        return GreIntersectClipRect(hdc, 0, 0, 0, 0);

    } else {

        /*
         * If no clip rgn exists, then subtract from a device-sized clip rgn.
         * (GetClipRgn returns clip rgn in screen coordinates).
         */
        GreGetDCOrg(hdc, &pt);
        if (GreGetRandomRgn(hdc, ghrgnInv1, 1) != 1) {
            CopyRgn(ghrgnInv1, gpDispInfo->hrgnScreen);
        } else {

            /*
             * Gets returned in dc coords - translate to screen.
             */
            GreOffsetRgn(ghrgnInv1, pt.x, pt.y);
        }

        SubtractRgn(ghrgnInv1, ghrgnInv1, pwnd->hrgnUpdate);

        /*
         * Map to dc coords before select
         */
        GreOffsetRgn(ghrgnInv1, -pt.x, -pt.y);

        return GreExtSelectClipRgn(hdc, ghrgnInv1, RGN_COPY);
    }
}

/***************************************************************************\
* GetUpdateRect (API)
*
* Returns the bounding rectangle of the update region, or an empty rectangle
* if there is no update region.  Rectangle is in client-relative coordinates.
*
* Returns TRUE if the update region is non-empty, FALSE if there is no
* update region.
*
* lprc may be NULL to query whether or not an update region exists at all
* or not.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxGetUpdateRect(
    PWND   pwnd,
    LPRECT lprc,
    BOOL   fErase)
{
    RECT rc;

    CheckLock(pwnd);

    if (fErase)
        xxxSimpleDoSyncPaint(pwnd);

    /*
     * The app is looking at the update region: okay to allow window
     * validation.
     */
    ClrWF(pwnd, WFUPDATEDIRTY);

    if (pwnd->hrgnUpdate == NULL) {

        if (lprc) {
            SetRectEmpty(lprc);
        }

        return FALSE;

    } else {

        /*
         * We must handle the case where a window has an update region,
         * but it is completely obscured by its parents.  In this case, we
         * must validate the window and all its children, and return FALSE.
         *
         * An OffsetChildren() call resulting from SetWindowPos() or
         * ScrollWindowEx() will cause this to happen.  Update regions are
         * just offset without checking their new positions to see if they
         * are obscured by the parent(s).  This is too painful to check in
         * those cases, so we instead handle it here.
         *
         * BeginPaint() handles this case correctly by returning an empty
         * rectangle, so nothing special need be done there.
         */
        if (pwnd->hrgnUpdate == HRGN_FULL) {

            rc = pwnd->rcClient;

        } else {

            switch (GreGetRgnBox(pwnd->hrgnUpdate, &rc)) {
            case ERROR:
            case NULLREGION:
                SetRectEmpty(&rc);
                break;

            case SIMPLEREGION:
            case COMPLEXREGION:
                break;
            }

            IntersectRect(&rc, &rc, &pwnd->rcClient);
        }

        if (IntersectWithParents(pwnd, &rc)) {

            if (pwnd != PWNDDESKTOP(pwnd)) {
                OffsetRect(&rc, -pwnd->rcClient.left, -pwnd->rcClient.top);
            }

            /*
             * If the window is CS_OWNDC, then we must map the returned
             * rectangle with DPtoLP, to ensure that the rectangle is
             * in the same coordinate system as the rectangle returned
             * by BeginPaint().
             *
             * BUT ONLY IF hwnd->hrgnUpdate != HRGN_FULL! For true
             * compatibility with 3.0.
             */
            if (TestCF(pwnd, CFOWNDC) &&
                (TestWF(pwnd, WFWIN31COMPAT) || pwnd->hrgnUpdate != HRGN_FULL)) {

                PDCE pdce;

                /*
                 * Look up this window's DC in the cache, and use it to
                 * map the returned rectangle.
                 */
                for (pdce = gpDispInfo->pdceFirst; pdce; pdce = pdce->pdceNext) {

                    if (pdce->pwndOrg == pwnd && !(pdce->DCX_flags & DCX_CACHE)) {
                        GreDPtoLP(pdce->hdc, (LPPOINT)&rc, 2);
                        break;
                    }
                }
            }

        } else {
           SetRectEmpty(&rc);
        }
    }

    if (lprc) {
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            MirrorClientRect(pwnd, &rc);
        }
        *lprc = rc;
    }

    /*
     * If we're in the process a dragging a full window, mark the start
     * of the application painting. This is to make sure that if the
     * application calls DefWindowProc on the WM_PAINT after painting, we
     * won't erase the newly painted areas. Visual Slick calls GetUpdateRect
     * and then DefWindowProc.
     * See other comments for xxxBeginPaint and xxxDWP_Paint.
     * 8/3/94 johannec
     *
     * NOTE: This causes other problems in vslick where some controls
     *       won't paint.  Since the app doesn't call BeginPaint/EndPaint
     *       to truly set/clear the STARTPAINT flag, we do not clear this
     *       bit. (6-27-1996 : ChrisWil).
     *
     *
     *  if (TEST_PUDF(PUDF_DRAGGINGFULLWINDOW)) {
     *      SetWF(pwnd, WFSTARTPAINT);
     *  }
     */

    return TRUE;
}

/***************************************************************************\
* GetUpdateRgn (API)
*
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int xxxGetUpdateRgn(
    PWND pwnd,
    HRGN hrgn,
    BOOL fErase)
{
    RECT rc;
    int  code;
    BOOL fNotEmpty;


    CheckLock(pwnd);

    if (fErase)
        xxxSimpleDoSyncPaint(pwnd);

    /*
     * The application is looking at the update region: okay to
     * allow validation
     */
    ClrWF(pwnd, WFUPDATEDIRTY);

    if (pwnd->hrgnUpdate == NULL)
        goto ReturnEmpty;

    rc = pwnd->rcClient;
    fNotEmpty = IntersectWithParents(pwnd, &rc);

    if (pwnd->hrgnUpdate == HRGN_FULL) {

        /*
         * Since the update region may be larger than the window
         * rectangle, intersect it with the window rectangle.
         */
        if (!fNotEmpty)
            goto ReturnEmpty;

        code = SIMPLEREGION;

        /*
         * Normalize the rectangle\region relative to the unclipped window
         */
        if (pwnd != PWNDDESKTOP(pwnd)) {
            OffsetRect(&rc, -pwnd->rcClient.left, -pwnd->rcClient.top);
        }

        SetRectRgnIndirect(hrgn, &rc);

    } else {

        SetRectRgnIndirect(ghrgnInv2, &rc);
        code = IntersectRgn(hrgn, ghrgnInv2, pwnd->hrgnUpdate);

        switch (code) {
        case NULLREGION:
        case ERROR:
            goto ReturnEmpty;

        default:
            if (pwnd != PWNDDESKTOP(pwnd)) {
                GreOffsetRgn(hrgn, -pwnd->rcClient.left, -pwnd->rcClient.top);
            }
            break;
        }
    }

    MirrorRegion(pwnd, hrgn, TRUE);

    /*
     * If we're in the process a dragging a full window, mark the start
     * of the application painting. This is to make sure that if the
     * application calls DefWindowProc on the WM_PAINT after painting, we
     * won't erase the newly painted areas.
     * See other comments for xxxBeginPaint and xxxDWP_Paint.
     * 8/3/94 johannec
     *
     * NOTE: This causes other problems in vslick where some controls
     *       won't paint.  Since the app doesn't call BeginPaint/EndPaint
     *       to truly set/clear the STARTPAINT flag, we do not clear this
     *       bit. (6-27-1996 : ChrisWil).
     *
     *  if (TEST(PUDF(PUDF_DRAGGINGFULLWINDOW)) {
     *      SetWF(pwnd, WFSTARTPAINT);
     *  }
     */

    return code;

ReturnEmpty:
    SetEmptyRgn(hrgn);
    return NULLREGION;
}

/***************************************************************************\
* IntersectWithParents
*
* This routine calculates the intersection of a rectangle with the client
* rectangles of all of pwnd's parents.  Returns FALSE if the intersection
* is empty, a window is invisible, or a parent is minimized.
*
* Stop the intesesection if the window itself or any of its parents are
* layered windows, so we always have a complete bitmap of them.
*
* History:
* 16-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL IntersectWithParents(
    PWND   pwnd,
    LPRECT lprc)
{
    if (TestWF(pwnd, WEFPREDIRECTED))
        return TRUE;

    while ((pwnd = pwnd->spwndParent) != NULL) {

        if (!TestWF(pwnd, WFVISIBLE) || TestWF(pwnd, WFMINIMIZED))
            return FALSE;

        if (!IntersectRect(lprc, lprc, &pwnd->rcClient))
            return FALSE;

        if (TestWF(pwnd, WEFPREDIRECTED))
            return TRUE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\text.c ===
/****************************** Module Header ******************************\
* Module Name: text.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the MessageBox API and related functions.
*
* History:
* 10-01-90 EricK        Created.
* 11-20-90 DarrinM      Merged in User text APIs.
* 02-07-91 DarrinM      Removed TextOut, ExtTextOut, and GetTextExtentPoint stubs.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL _TextOutW(
    HDC     hdc,
    int     x,
    int     y,
    LPCWSTR lp,
    UINT    cc);

/***************************************************************************\
* xxxPSMTextOut
*
* Outputs the text and puts and _ below the character with an &
* before it. Note that this routine isn't used for menus since menus
* have their own special one so that it is specialized and faster...
*
* NOTE: A very similar routine (UserLpkPSMTextOut) exists on the client
*       side in drawtext.c.  Any non-kernel specific changes to this
*       routine most likely need to be made in UserLpkPSMTextOut as well.
*
* History:
* 11-13-90 JimA         Ported to NT.
* 30-Nov-1992 mikeke    Client side version
* 8-Apr-1998 MCostea    Added dwFlags
\***************************************************************************/

void xxxPSMTextOut(
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR lpsz,
    int cch,
    DWORD dwFlags)
{
    int cx;
    LONG textsize, result;
    /*
     * In the kernel we have a limited amount of stack. So it should be a stack
     * variable in user mode and static in kernel mode where it is thread safe
     * since we are in the crit section.
     */
    static WCHAR achWorkBuffer[255];
    WCHAR *pchOut = achWorkBuffer;
    TEXTMETRICW textMetric;
    SIZE size;
    RECT rc;
    COLORREF color;
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    if (CALL_LPK(ptiCurrent)) {
        /*
         * A user mode LPK is installed for layout and shaping.
         * Perform callback and return.
         */
        UNICODE_STRING ustrStr;

        RtlInitUnicodeString(&ustrStr, lpsz);
        xxxClientPSMTextOut(hdc, xLeft, yTop, &ustrStr, cch, dwFlags);
        return;
    }

    if (cch > sizeof(achWorkBuffer)/sizeof(WCHAR)) {
        pchOut = (WCHAR*)UserAllocPool((cch+1) * sizeof(WCHAR), TAG_RTL);
        if (pchOut == NULL)
            return;
    }

    result = GetPrefixCount(lpsz, cch, pchOut, cch);

    if (!(dwFlags & DT_PREFIXONLY)) {
        _TextOutW(hdc, xLeft, yTop, pchOut, cch - HIWORD(result));
    }

    /*
     * Any true prefix characters to underline?
     */
    if (LOWORD(result) == 0xFFFF || dwFlags & DT_HIDEPREFIX) {
        if (pchOut != achWorkBuffer)
            UserFreePool(pchOut);
        return;
    }

    if (!_GetTextMetricsW(hdc, &textMetric)) {
        textMetric.tmOverhang = 0;
        textMetric.tmAscent = 0;
    }

    /*
     * For proportional fonts, find starting point of underline.
     */
    if (LOWORD(result) != 0) {

        /*
         * How far in does underline start (if not at 0th byte.).
         */
        GreGetTextExtentW(hdc, (LPWSTR)pchOut, LOWORD(result), &size, GGTE_WIN3_EXTENT);
        xLeft += size.cx;

        /*
         * Adjust starting point of underline if not at first char and there is
         * an overhang.  (Italics or bold fonts.)
         */
        xLeft = xLeft - textMetric.tmOverhang;
    }

    /*
     * Adjust for proportional font when setting the length of the underline and
     * height of text.
     */
    GreGetTextExtentW(hdc, (LPWSTR)(pchOut + LOWORD(result)), 1, &size, GGTE_WIN3_EXTENT);
    textsize = size.cx;

    /*
     * Find the width of the underline character.  Just subtract out the overhang
     * divided by two so that we look better with italic fonts.  This is not
     * going to effect embolded fonts since their overhang is 1.
     */
    cx = LOWORD(textsize) - textMetric.tmOverhang / 2;

    /*
     * Get height of text so that underline is at bottom.
     */
    yTop += textMetric.tmAscent + 1;

    /*
     * Draw the underline using the foreground color.
     */
    SetRect(&rc, xLeft, yTop, xLeft+cx, yTop+1);
    color = GreSetBkColor(hdc, GreGetTextColor(hdc));
    GreExtTextOutW(hdc, xLeft, yTop, ETO_OPAQUE, &rc, TEXT(""), 0, NULL);
    GreSetBkColor(hdc, color);

    if (pchOut != achWorkBuffer) {
        UserFreePool(pchOut);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\usergdi.c ===
/****************************** Module Header ******************************\
* Module Name: timers.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains GDI-callable exports from user.  No user code
* should call any of these routines.
*
* History:
* 3-Jun-1998 AndrewGo   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
*  UserSetTimer()
*
* GDI-callable routine to enable a system timer on the RIT.
*
*  6/2/98 AndrewGo  Created
\***************************************************************************/

UINT_PTR UserSetTimer(UINT dwElapse, PVOID pTimerFunc)
{
    UINT_PTR id = 0;
    PTIMER   ptmr;

    /*
     * GDI may call during ChangeDisplaySettings, in which case the
     * critical section will already be held.  GDI may also call during
     * CreateDC("Device"), in which case the critical section will not
     * already be held.
     */
    BEGIN_REENTERCRIT();

    /*
     * If the RIT hasn't been started yet, let GDI know this by returning
     * failure.  Once we've initialized the RIT, we'll let GDI know
     * that GDI can start its timers by calling GreStartTimers().
     */
    if (gptmrMaster) {
    
        id = InternalSetTimer(NULL, 0, dwElapse, (TIMERPROC_PWND) pTimerFunc, TMRF_RIT);

        /*
         * We don't want cleanup to be done on thread termination.  Rather
         * than creating a new flag and adding more code to InternalSetTimer,
         * we disable cleanup by modifying the timer directly.
         */
        if (id) {

            ptmr = FindTimer(NULL, id, TMRF_RIT, FALSE);

            UserAssert(ptmr);

            ptmr->ptiOptCreator = NULL;
        }
    }

    END_REENTERCRIT();

    return id;
}

/***************************************************************************\
*  UserKillTimer()
*
*  6/2/98 AndrewGo  Created
\***************************************************************************/

VOID UserKillTimer(UINT_PTR nID)
{
    /*
     * GDI may call during ChangeDisplaySettings, in which case the
     * critical section will already be held.  GDI may also call any
     * time its PDEV reference counts go to zero, in which case the 
     * critical section will not already be held.
     */
    BEGIN_REENTERCRIT();

    KILLRITTIMER(NULL, nID);

    END_REENTERCRIT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\validate.c ===
/****************************** Module Header ******************************\
* Module Name: validate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains functions for validating windows, menus, cursors, etc.
*
* History:
* 01-02-91 DarrinM      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * these defines are used for using the validation macros
 * StartValidateHandleMacro and EndValidateHandleMacro
 */
#define ClientSharedInfo()  (&gSharedInfo)
#define ServerInfo()  (gpsi)

#include "wow.h"

#if DBG
    CRITSTACK  gCritStack;
#endif // DBG

/*
 * Globals used only in his file.
 */
__int64   gCSTimeExclusiveWhenEntering;

/***************************************************************************\
* ValidateHwinsta
*
* Validate windowstation handle
*
* History:
* 03-29-91 JimA             Created.
* 06-20-95 JimA             Kernel-mode objects.
\***************************************************************************/

NTSTATUS ValidateHwinsta(
    HWINSTA         hwinsta,
    KPROCESSOR_MODE AccessMode,
    ACCESS_MASK     amDesired,
    PWINDOWSTATION* ppwinsta)
{
    NTSTATUS Status;

    Status = ObReferenceObjectByHandle(
            hwinsta,
            amDesired,
            *ExWindowStationObjectType,
            AccessMode,
            ppwinsta,
            NULL);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status, RIP_VERBOSE, "ValidateHwinsta failed for %#p", hwinsta);

    } else if ((*ppwinsta)->dwSessionId != gSessionId) {

        RIPNTERR3(STATUS_INVALID_HANDLE, RIP_WARNING,
                  "SessionId %d. Wrong session id %d for pwinsta %#p",
                  gSessionId, (*ppwinsta)->dwSessionId, *ppwinsta);

        ObDereferenceObject(*ppwinsta);
#if DBG
        *ppwinsta = NULL;
#endif // DBG

        return STATUS_INVALID_HANDLE;
    }

    return Status;
}

/***************************************************************************\
* ValidateHdesk
*
* Validate desktop handle
*
* History:
* 03-29-91 JimA             Created.
* 06-20-95 JimA             Kernel-mode objects.
\***************************************************************************/

NTSTATUS ValidateHdesk(
    HDESK           hdesk,
    KPROCESSOR_MODE AccessMode,
    ACCESS_MASK     amDesired,
    PDESKTOP*       ppdesk)
{
    NTSTATUS Status;

    Status = ObReferenceObjectByHandle(
            hdesk,
            amDesired,
            *ExDesktopObjectType,
            AccessMode,
            ppdesk,
            NULL);

    if (NT_SUCCESS(Status)) {

        if ((*ppdesk)->dwSessionId != gSessionId) {

            RIPNTERR3(STATUS_INVALID_HANDLE, RIP_WARNING,
                      "SessionId %d. Wrong session id %d for pdesk %#p",
                      gSessionId, (*ppdesk)->dwSessionId, *ppdesk);

            goto Error;
        }

        LogDesktop(*ppdesk, LDL_VALIDATE_HDESK, TRUE, (ULONG_PTR)PtiCurrent());

        if ((*ppdesk)->dwDTFlags & (DF_DESTROYED | DF_DESKWNDDESTROYED | DF_DYING)) {
            RIPNTERR1(STATUS_INVALID_HANDLE, RIP_WARNING,
                      "ValidateHdesk: destroyed desktop %#p",
                      *ppdesk);
Error:
            ObDereferenceObject(*ppdesk);
#if DBG
            *ppdesk = NULL;
#endif // DBG

            return STATUS_INVALID_HANDLE;
        }
    } else {
        RIPNTERR1(Status, RIP_VERBOSE, "ValidateHdesk failed for %#p", hdesk);
    }

    return Status;
}

/***************************************************************************\
* UserValidateCopyRgn
*
* Validates a region-handle.  This essentially tries to copy the region
* in order to verify the region is valid.  If hrgn isn't a valid region,
* then the combine will fail.  We return a copy of the region.
*
* History:
* 24=Jan-1996   ChrisWil    Created.
\***************************************************************************/

HRGN UserValidateCopyRgn(
    HRGN hrgn)
{
    HRGN hrgnCopy = NULL;


    if (hrgn && (GreValidateServerHandle(hrgn, RGN_TYPE))) {

        hrgnCopy = CreateEmptyRgn();

        if (CopyRgn(hrgnCopy, hrgn) == ERROR) {

            GreDeleteObject(hrgnCopy);

            hrgnCopy = NULL;
        }
    }

    return hrgnCopy;
}

/***************************************************************************\
* ValidateHmenu
*
* Validate menu handle and open it
*
* History:
* 03-29-91 JimA             Created.
\***************************************************************************/

PMENU ValidateHmenu(
    HMENU hmenu)
{
    PTHREADINFO pti = PtiCurrentShared();
    PMENU pmenuRet;

    pmenuRet = (PMENU)HMValidateHandle(hmenu, TYPE_MENU);

    if (pmenuRet != NULL &&
            ((pti->rpdesk != NULL &&  // hack so console initialization works.
            pmenuRet->head.rpdesk != pti->rpdesk))) {
        RIPERR1(ERROR_INVALID_MENU_HANDLE, RIP_WARNING, "Invalid menu handle (%#p)", hmenu);
        return NULL;
    }

    return pmenuRet;
}



/***************************************************************************\
* ValidateHmonitor
*
* Validate monitor handle and open it.
*
* History:
* 03-29-91 JimA             Created.
\***************************************************************************/

PMONITOR ValidateHmonitor(
        HMONITOR hmonitor)
{
    return (PMONITOR)HMValidateSharedHandle(hmonitor, TYPE_MONITOR);
}

/*
 * The handle validation routines should be optimized for time, not size,
 * since they get called so often.
 */
#pragma optimize("t", on)

/***************************************************************************\
* IsHandleEntrySecure
*
* Validate a user handle for a restricted process bypassing the routine to
* get the handle entry.
*
* History:
* August 22, 97   CLupu      Created.
\***************************************************************************/

BOOL IsHandleEntrySecure(
    HANDLE h,
    PHE    phe)
{
    DWORD        bCreateFlags;
    PPROCESSINFO ppiOwner;
    PPROCESSINFO ppiCurrent;
    PW32JOB      pW32Job;
    DWORD        ind;
    PULONG_PTR    pgh;

    /*
     * get the current process
     */
    ppiCurrent = PpiCurrent();

    if (ppiCurrent == NULL)
        return TRUE;

    UserAssert(ppiCurrent->pW32Job != NULL);

    UserAssert(ppiCurrent->W32PF_Flags & W32PF_RESTRICTED);

    /*
     * get the process that owns the handle
     */

    bCreateFlags = gahti[phe->bType].bObjectCreateFlags;

    ppiOwner = NULL;

    if (bCreateFlags & OCF_PROCESSOWNED) {
        ppiOwner = (PPROCESSINFO)phe->pOwner;
    } else if (bCreateFlags & OCF_THREADOWNED) {

        PTHREADINFO pti;

        pti = (PTHREADINFO)phe->pOwner;

        if (pti != NULL) {
            ppiOwner = pti->ppi;
        }
    }

    /*
     * if the owner is NULL then consider the handle secure
     */
    if (ppiOwner == NULL)
        return FALSE;


    /*
     * if the handle is owned by a process in the same job, then it's secure
     */
    if (ppiOwner->pW32Job == ppiCurrent->pW32Job)
        return TRUE;

    /*
     * the handle is not owned by the current process
     */

    pW32Job = ppiCurrent->pW32Job;

    if (pW32Job->pgh == NULL)
        return FALSE;

    pgh = pW32Job->pgh;

    UserAssert(pW32Job->ughCrt <= pW32Job->ughMax);

    for (ind = 0; ind < pW32Job->ughCrt; ind++) {
        if (*(pgh + ind) == (ULONG_PTR)h) {
            return TRUE;
        }
    }

    return FALSE;
}


/***************************************************************************\
* ValidateHandleSecure
*
* Validate a user handle for a restricted process.
*
* History:
* July 29, 97   CLupu      Created.
\***************************************************************************/

BOOL ValidateHandleSecure(
    HANDLE h)
{
    PVOID pobj;

    CheckCritInShared();

    StartValidateHandleMacro(h)
    BeginTypeValidateHandleMacro(pobj, TYPE_GENERIC)

        if (IsHandleEntrySecure(h, phe)) {
            return TRUE;
        }

    EndTypeValidateHandleMacro
    EndValidateHandleMacro

    return FALSE;
}

/***************************************************************************\
* ValidateHwnd
*
* History:
* 08-Feb-1991 mikeke
\***************************************************************************/

PWND FASTCALL ValidateHwnd(
    HWND hwnd)
{
    StartValidateHandleMacro(hwnd)

        /*
         * Now make sure the app is
         * passing the right handle
         * type for this api. If the
         * handle is TYPE_FREE, this'll
         * catch it.
         */
        if (phe->bType == TYPE_WINDOW) {

            PTHREADINFO pti = PtiCurrentShared();

            /*
             * This is called from thunks for routines in the shared critsec.
             */
            PWND pwndRet = (PWND)phe->phead;

            /*
             * This test establishes that the window belongs to the current
             * 'desktop'.. The two exceptions are for the desktop-window of
             * the current desktop, which ends up belonging to another desktop,
             * and when pti->rpdesk is NULL.  This last case happens for
             * initialization of TIF_SYSTEMTHREAD threads (ie. console windows).
             * IanJa doesn't know if we should be test TIF_CSRSSTHREAD here, but
             * JohnC thinks the whole test below is no longer required ??? LATER
             */

            if (pwndRet != NULL) {
                if (phe->bFlags & HANDLEF_DESTROY) {
                    RIPERR2(ERROR_INVALID_WINDOW_HANDLE,
                        RIP_WARNING,"ValidateHwnd, hwnd %#p, pwnd %#p already destroyed\n",
                            hwnd, pwndRet);
                    return NULL;
                }
                if (GETPTI(pwndRet) == pti ||
                       (
                        (pwndRet->head.rpdesk == pti->rpdesk ||
                         (pti->TIF_flags & TIF_SYSTEMTHREAD) ||  // | TIF_CSRSSTHREAD I think
                         GetDesktopView(pti->ppi, pwndRet->head.rpdesk) !=
                                NULL))) {

                    if (IS_THREAD_RESTRICTED(pti, JOB_OBJECT_UILIMIT_HANDLES)) {

                        /*
                         * make sure this window belongs to this process
                         */
                        if (!IsHandleEntrySecure(hwnd, phe)) {
                            RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
                                    RIP_WARNING,
                                    "ValidateHwnd: Invalid hwnd (%#p) for restricted process\n",
                                    hwnd);
                            pwndRet = NULL;
                        }
                    }
                    return pwndRet;
                }
            }
        }

    EndValidateHandleMacro

    RIPERR1(ERROR_INVALID_WINDOW_HANDLE,
            RIP_WARNING,
            "ValidateHwnd: Invalid hwnd (%#p)",
            hwnd);
    return NULL;
}

/*
 * Switch back to default optimization.
 */
#pragma optimize("", on)

/******************************Public*Routine******************************\
*
* UserCritSec routines
*
* Exposes an opaque interface to the user critical section for
* the WNDOBJ code in GRE
*
* Exposed as functions because they aren't time critical and it
* insulates GRE from rebuilding if the definitions of Enter/LeaveCrit change
*
* History:
*  Wed Sep 20 11:19:14 1995 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#if DBG
#define GetCallStack()                                          \
{                                                               \
    gCritStack.thread  = PsGetCurrentThread();                  \
    gCritStack.nFrames = RtlWalkFrameChain(gCritStack.trace,    \
                                           MAX_STACK_CALLS,     \
                                           0);                  \
}

#define FlushCallStack()                                        \
{                                                               \
    gCritStack.thread  = NULL;                                  \
    gCritStack.nFrames = 0;                                     \
}
#else
#define GetCallStack()
#define FlushCallStack()
#endif // DBG

VOID UserEnterUserCritSec(
    VOID)
{
    EnterCrit();
}

VOID UserLeaveUserCritSec(
    VOID)
{
    LeaveCrit();
}

#if DBG
VOID UserAssertUserCritSecIn(
    VOID)
{
    _AssertCritInShared();
}

VOID UserAssertUserCritSecOut(
    VOID)
{
    _AssertCritOut();
}
#endif // DBG

BOOL UserGetCurrentDesktopId(
    DWORD* pdwDesktopId)
{
    PDESKTOP pdesktop;

    CheckCritIn();

    /*
     * PtiCurrent()->rpdesk can be NULL (in the case of thread shutdown).
     */

    pdesktop = PtiCurrent()->rpdesk;

    if (pdesktop != grpdeskRitInput) {
        RIPMSG0(RIP_WARNING, "UserGetCurrentDesktopId on wrong desktop pdesk\n");
        return FALSE;
    }

    *pdwDesktopId = pdesktop->dwDesktopId;

    return TRUE;
}

#if 0

//
// Temporary arrays used to track critsec frees
//

#define ARRAY_SIZE 20
#define LEAVE_TYPE 0xf00d0000
#define ENTER_TYPE 0x0000dead

typedef struct _DEBUG_STASHCS {
    RTL_CRITICAL_SECTION Lock;
    DWORD Type;
} DEBUG_STASHCS, *PDEBUG_STASHCS;

DEBUG_STASHCS UserSrvArray[ARRAY_SIZE];

ULONG UserSrvIndex;

VOID
DumpArray(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString,
    LPDWORD IndexAddress,
    LPDWORD ArrayAddress
    )
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    DWORD History;
    int InitialIndex;
    PDEBUG_STASHCS Array;
    BOOL b;
    PRTL_CRITICAL_SECTION CriticalSection;
    CHAR Symbol[64], Symbol2[64];
    DWORD Displacement, Displacement2;
    int Position;
    LPSTR p;

    DBG_UNREFERENCED_PARAMETER(hCurrentThread);
    DBG_UNREFERENCED_PARAMETER(dwCurrentPc);

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    p = lpArgumentString;

    History = 0;

    if (*p) {
        History = EvalExpression(p);
    }
    if (History == 0 || History >= ARRAY_SIZE) {
        History = 10;
    }

    //
    // Get the Current Index and the array.
    //

    b = ReadProcessMemory(
            hCurrentProcess,
            (LPVOID)IndexAddress,
            &InitialIndex,
            sizeof(InitialIndex),
            NULL
            );
    if (!b) {
        return;
    }

    Array = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(UserSrvArray));
    if (!Array) {
        return;
    }

    b = ReadProcessMemory(
            hCurrentProcess,
            (LPVOID)ArrayAddress,
            Array,
            sizeof(UserSrvArray),
            NULL
            );
    if (!b) {
        RtlFreeHeap(RtlProcessHeap(), 0, Array);
        return;
    }

    Position = 0;
    while (History) {
        InitialIndex--;
        if (InitialIndex < 0) {
            InitialIndex = ARRAY_SIZE - 1;
        }

        if (Array[InitialIndex].Type == LEAVE_TYPE) {
            (Print)("\n(%d) LEAVING Critical Section \n", Position);
        } else {
            (Print)("\n(%d) ENTERING Critical Section \n", Position);
        }

        CriticalSection = &Array[InitialIndex].Lock;

        if (CriticalSection->LockCount == -1) {
            (Print)("\tLockCount NOT LOCKED\n");
        } else {
            (Print)("\tLockCount %ld\n", CriticalSection->LockCount);
        }
        (Print)("\tRecursionCount %ld\n", CriticalSection->RecursionCount);
        (Print)("\tOwningThread %lx\n", CriticalSection->OwningThread );
#if DBG
        (GetSymbol)(CriticalSection->OwnerBackTrace[0], Symbol, &Displacement);
        (GetSymbol)(CriticalSection->OwnerBackTrace[1], Symbol2, &Displacement2);
        (Print)("\tCalling Address %s+%lx\n", Symbol, Displacement);
        (Print)("\tCallers Caller %s+%lx\n", Symbol2, Displacement2);
#endif // DBG
        Position--;
        History--;
    }
    RtlFreeHeap(RtlProcessHeap(), 0, Array);
}


VOID
dsrv(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
{
    DumpArray(
        hCurrentProcess,
        hCurrentThread,
        dwCurrentPc,
        lpExtensionApis,
        lpArgumentString,
        &UserSrvIndex,
        (LPDWORD)&UserSrvArray[0]
        );
}

#endif // if 0

#if DBG

/***************************************************************************\
* _EnterCrit
* _LeaveCrit
*
* These are temporary routines that are used by USER.DLL until the critsect,
* validation, mapping code is moved to the server-side stubs generated by
* SMeans' Thank compiler.
*
* History:
* 01-02-91 DarrinM      Created.
\***************************************************************************/
VOID _AssertCritIn(
    VOID)
{
    UserAssert(gpresUser != NULL);
    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresUser) == TRUE);
}

VOID _AssertDeviceInfoListCritIn(
    VOID)
{
    UserAssert(gpresDeviceInfoList != NULL);
    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresDeviceInfoList) == TRUE);
}

VOID _AssertCritInShared(
    VOID)
{
    UserAssert(gpresUser != NULL);
    UserAssert( (ExIsResourceAcquiredExclusiveLite(gpresUser) == TRUE) ||
            (ExIsResourceAcquiredSharedLite(gpresUser) == TRUE));
}

VOID _AssertCritOut(
    VOID)
{
    UserAssert(gpresUser != NULL);
    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresUser) == FALSE);
}

VOID _AssertDeviceInfoListCritOut(
    VOID)
{
    UserAssert(gpresDeviceInfoList != NULL);
    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresDeviceInfoList) == FALSE);
}

/***************************************************************************\
* BeginAtomicCheck()
* EndAtomicCheck()
*
* Routine that verify we never leave the critical section and that an
* operation is truely atomic with the possiblity of other code being run
* because we left the critical section
*
\***************************************************************************/
VOID BeginAtomicCheck(
    VOID)
{
    gdwInAtomicOperation++;
}

VOID EndAtomicCheck(
    VOID)
{
    UserAssert(gdwInAtomicOperation > 0);
    gdwInAtomicOperation--;
}

VOID BeginAtomicDeviceInfoListCheck(
    VOID)
{
    gdwInAtomicDeviceInfoListOperation++;
}

VOID EndAtomicDeviceInfoListCheck(
    VOID)
{
    UserAssert(gdwInAtomicDeviceInfoListOperation > 0);
    gdwInAtomicDeviceInfoListOperation--;
}

#define INCCRITSECCOUNT (gdwCritSecUseCount++)
#define INCDEVICEINFOLISTCRITSECCOUNT (gdwDeviceInfoListCritSecUseCount++)

#else // else DBG

#define INCCRITSECCOUNT
#define INCDEVICEINFOLISTCRITSECCOUNT

#endif // endif DBG

BOOL UserIsUserCritSecIn(
    VOID)
{
    UserAssert(gpresUser != NULL);
    return ((ExIsResourceAcquiredExclusiveLite(gpresUser) == TRUE) ||
            (ExIsResourceAcquiredSharedLite(gpresUser) == TRUE));
}

#if DBG
VOID CheckDevLockOut(
    VOID)
{
    /*
     * gpDispInfo can be NULL if Win32UserInitialize fails before allocationg it.
     * hDev is initialized later in InitVideo, after the critical section has been
     *  released at least once; so we better check it too.
     */
    if ((gpDispInfo != NULL) && (gpDispInfo->hDev != NULL)) {
        UserAssert(!GreIsDisplayLocked(gpDispInfo->hDev));
    }
}
#else
#define CheckDevLockOut()
#endif

VOID EnterCrit(
    VOID)
{
    CheckCritOut();
    CheckDeviceInfoListCritOut();
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(gpresUser, TRUE);
    CheckDevLockOut();
    UserAssert(!ISATOMICCHECK());
    UserAssert(gptiCurrent == NULL);
    gptiCurrent = ((PTHREADINFO)(W32GetCurrentThread()));
    INCCRITSECCOUNT;
#if defined (USER_PERFORMANCE)
    {
        __int64 i64Frecv;
        *(LARGE_INTEGER*)(&gCSTimeExclusiveWhenEntering) = KeQueryPerformanceCounter((LARGE_INTEGER*)&i64Frecv);
        InterlockedIncrement(&gCSStatistics.cExclusive);
    }
#endif // (USER_PERFORMANCE)

    GetCallStack();
}

#if DBG
VOID EnterDeviceInfoListCrit(
    VOID)
{
    CheckDeviceInfoListCritOut();
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(gpresDeviceInfoList, TRUE);
    UserAssert(!ISATOMICDEVICEINFOLISTCHECK());
    INCDEVICEINFOLISTCRITSECCOUNT;
}
#endif // DBG

VOID EnterSharedCrit(
    VOID)
{
    KeEnterCriticalRegion();
    ExAcquireResourceSharedLite(gpresUser, TRUE);
    CheckDevLockOut();
    UserAssert(!ISATOMICCHECK());
#if defined (USER_PERFORMANCE)
    InterlockedIncrement(&gCSStatistics.cShared);
#endif // (USER_PERFORMANCE)

    INCCRITSECCOUNT;
}

VOID LeaveCrit(
    VOID)
{
    INCCRITSECCOUNT;
#if DBG
    UserAssert(!ISATOMICCHECK());
    UserAssert(IsWinEventNotifyDeferredOK());
    CheckDevLockOut();
    FlushCallStack();
    gptiCurrent = NULL;
#endif // DBG

#ifdef USER_PERFORMANCE
    /*
     * A non null gCSTimeExclusiveWhenEntering means the
     * critical section is owned exclusive
     */
    if (gCSTimeExclusiveWhenEntering) {
        __int64 i64Temp, i64Frecv;

        *(LARGE_INTEGER*)(&i64Temp) = KeQueryPerformanceCounter((LARGE_INTEGER*)&i64Frecv);
        gCSStatistics.i64TimeExclusive += i64Temp - gCSTimeExclusiveWhenEntering;
        gCSTimeExclusiveWhenEntering = 0;
    }
#endif // USER_PERFORMANCE
    ExReleaseResourceLite(gpresUser);
    KeLeaveCriticalRegion();
    CheckCritOut();
}

#if DBG
VOID _LeaveDeviceInfoListCrit(
    VOID)
{
    INCDEVICEINFOLISTCRITSECCOUNT;
    UserAssert(!ISATOMICDEVICEINFOLISTCHECK());

    ExReleaseResourceLite(gpresDeviceInfoList);
    KeLeaveCriticalRegion();
    CheckDeviceInfoListCritOut();
}
#endif // DBG

VOID ChangeAcquireResourceType(
    VOID)
{

#if DBG
    FlushCallStack();
    CheckDevLockOut();
    UserAssert(!ISATOMICCHECK());
#endif // DBG

    ExReleaseResourceLite(gpresUser);
    ExAcquireResourceExclusiveLite(gpresUser, TRUE);
    gptiCurrent = ((PTHREADINFO)(W32GetCurrentThread()));

    GetCallStack();
}


#if DBG

PTHREADINFO _ptiCrit(
    VOID)
{
    UserAssert(gpresUser);
    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresUser) == TRUE);
    UserAssert(gptiCurrent);
    UserAssert(gptiCurrent == ((PTHREADINFO)(W32GetCurrentThread())));
    UserAssert(gptiCurrent);

    return gptiCurrent;
}

PTHREADINFO _ptiCritShared(
    VOID)
{
    UserAssert(W32GetCurrentThread());
    return ((PTHREADINFO)(W32GetCurrentThread()));
}

#undef KeUserModeCallback

NTSTATUS
_KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    OUT PULONG OutputLength
    )
{

    UserAssert(ExIsResourceAcquiredExclusiveLite(gpresUser) == FALSE);

    /*
     * Added this so we can detect an erroneous user mode callback
     * with a checked win32k on top of a free system.
     */
    ASSERT(PsGetCurrentThreadPreviousMode() == UserMode);

    return KeUserModeCallback(ApiNumber, InputBuffer, InputLength,
            OutputBuffer, OutputLength);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\visrgn.c ===
/****************************** Module Header ******************************\
* Module Name: visrgn.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains User's visible region ('visrgn') manipulation
* functions.
*
* History:
* 23-Oct-1990 DarrinM   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Globals used to keep track of pwnds which
 * need to be excluded from the visrgns.
 */
#define CEXCLUDERECTSMAX 30
#define CEXCLUDEPWNDSMAX 30


BOOL  gfVisAlloc;
int   gcrcVisExclude;
int   gcrcVisExcludeMax;
PWND *gapwndVisExclude;
PWND *gapwndVisDefault;

/***************************************************************************\
* SetRectRgnIndirect
*
* Sets a rect region from a rectangle.
*
* History:
* 26-Sep-1996 adams     Created.
\***************************************************************************/

BOOL
SetRectRgnIndirect(HRGN hrgn, LPCRECT lprc)
{
    return GreSetRectRgn(hrgn, lprc->left, lprc->top, lprc->right, lprc->bottom);
}



/***************************************************************************\
* CreateEmptyRgn
*
* Creates an empty region.
*
* History:
* 24-Sep-1996 adams     Created.
\***************************************************************************/

HRGN
CreateEmptyRgn(void)
{
    return GreCreateRectRgnIndirect(PZERO(RECT));
}



/***************************************************************************\
* CreateEmptyRgnPublic
*
* Creates an empty region and make it public.
*
* History:
* 24-Sep-1996 adams     Created.
\***************************************************************************/

HRGN
CreateEmptyRgnPublic(void)
{
    HRGN hrgn;

    if (hrgn = CreateEmptyRgn()) {
        UserVerify(GreSetRegionOwner(hrgn, OBJECT_OWNER_PUBLIC));
    }

    return hrgn;
}



/***************************************************************************\
* SetEmptyRgn
*
* Sets an empty region.
*
* History:
* 26-Sep-1996 adams     Created.
\***************************************************************************/

BOOL
SetEmptyRgn(HRGN hrgn)
{
    return SetRectRgnIndirect(hrgn, PZERO(RECT));
}



/***************************************************************************\
* SetOrCreateRectRgnIndirectPublic
*
* Sets a region to a rectangle, creating it and making it public
* if it is not already there.
*
* History:
* 01-Oct-1996 adams     Created.
\***************************************************************************/

HRGN
SetOrCreateRectRgnIndirectPublic(HRGN * phrgn, LPCRECT lprc)
{
    if (*phrgn) {
        UserVerify(SetRectRgnIndirect(*phrgn, lprc));
    } else if (*phrgn = GreCreateRectRgnIndirect((LPRECT) lprc)) {
        UserVerify(GreSetRegionOwner(*phrgn, OBJECT_OWNER_PUBLIC));
    }

    return *phrgn;
}


/***************************************************************************\
* ResizeVisExcludeMemory
*
*   This routine is used to resize the vis-rgn memory buffer if the count
*   is exceeded.
*
*
* History:
* 22-Oct-1994 ChrisWil  Created
* 27-Feb-1997 adams     Removed call to UserReallocPool, since the pool
*                       allocator doesn't support realloc.
\***************************************************************************/

BOOL ResizeVisExcludeMemory(VOID)
{
    int     crcNew;
    PWND    apwndNew;

    /*
     * Note (adams): a previous version of the code called UserReallocPool
     * if memory had already been allocated. Unfortunately, UserReallocPool
     * just has to allocate more memory and copy the contents, since Rtl
     * doesn't have a realloc function. If Rtl later gains a Realloc function,
     * this code should be changed to the previous version.
     */

    crcNew = gcrcVisExcludeMax + CEXCLUDEPWNDSMAX;
    apwndNew = (PWND)UserAllocPool(
            crcNew * sizeof(PWND), TAG_VISRGN);

    if (!apwndNew)
        return FALSE;

    UserAssert(gcrcVisExcludeMax == gcrcVisExclude);
    RtlCopyMemory(apwndNew, gapwndVisExclude, gcrcVisExcludeMax * sizeof(PWND));
    if (gfVisAlloc) {
        UserFreePool(gapwndVisExclude);
    } else {
        gfVisAlloc = TRUE;
    }

    gcrcVisExcludeMax = crcNew;
    gapwndVisExclude = (PWND *)apwndNew;
    return TRUE;
}



/***************************************************************************\
* ExcludeWindowRects
*   This routine checks to see if the pwnd needs to be added to the list
*   of excluded-clip-rects.  If so, it appends the pwnd to the array.  They
*   do not need to be sorted, since GreSubtractRgnRectList() sorts them
*   internally.
*
*
* History:
* 05-Nov-1992 DavidPe   Created.
* 21-Oct-1994 ChrisWil  Removed pwnd->pwndNextYX.  No longer sorts pwnds.
\***************************************************************************/

#define CheckIntersectRect(prc1, prc2)        \
    (   prc1->left < prc2->right              \
     && prc2->left < prc1->right              \
     && prc1->top < prc2->bottom              \
     && prc2->top < prc1->bottom)

#define EmptyRect(prc)                        \
    (   prc->left >= prc->right               \
     || prc->top >= prc->bottom)

BOOL ExcludeWindowRects(
    PWND   pwnd    ,
    PWND   pwndStop,
    LPRECT lprcIntersect)
{
    PRECT prc;

#if DBG
    if (pwnd != NULL && pwndStop != NULL &&
            pwnd->spwndParent != pwndStop->spwndParent) {
        RIPMSG0(RIP_ERROR, "ExcludeWindowRects: bad windows passed in");
    }
#endif

    while ((pwnd != NULL) && (pwnd != pwndStop)) {
        UserAssert(pwnd);
        prc = &pwnd->rcWindow;
        if (       TestWF(pwnd, WFVISIBLE)
#ifdef REDIRECTION
                && (TestWF(pwnd, WEFEXTREDIRECTED) == 0)
#endif // REDIRECTION
                && (TestWF(pwnd, WEFLAYERED) == 0)
                && (TestWF(pwnd, WEFTRANSPARENT) == 0)
                && CheckIntersectRect(lprcIntersect, prc)
                && !EmptyRect(prc)) {

            UserAssert(gcrcVisExclude <= gcrcVisExcludeMax);
            if (gcrcVisExclude == gcrcVisExcludeMax) {
                if (!ResizeVisExcludeMemory()) {
                    return FALSE;
                }
            }

            gapwndVisExclude[gcrcVisExclude++] = pwnd;
        }

        pwnd = pwnd->spwndNext;
    }

    return TRUE;
}



/***************************************************************************\
* CalcWindowVisRgn
*
*   This routine performs the work of calculating the VisRgn for a window.
*
*
* History:
* 02-Nov-1992 DavidPe   Created.
* 21-Oct-1992 ChrisWil  Removed pwnd->pwndNextYX.  No longer sorts pwnds.
\***************************************************************************/

BOOL CalcWindowVisRgn(
    PWND  pwnd,
    HRGN  *phrgn,
    DWORD flags)
{
    RECT rcWindow;
    PWND pwndParent;
    PWND pwndRoot;
    PWND pwndLoop;
    BOOL fClipSiblings;
    BOOL fRgnParent = FALSE;
    BOOL fResult;
    PWND apwndVisDefault[CEXCLUDEPWNDSMAX];


    /*
     * First get the initial window rectangle which will be used for
     * the basis of exclusion calculations.
     */
    rcWindow = (flags & DCX_WINDOW ? pwnd->rcWindow : pwnd->rcClient);

    /*
     * Get the parent of this window.  We start at the parent and backtrack
     * through the window-parent-list until we reach the end of the parent-
     * list.  This will give us the intersect-rectangle which is used as
     * the basis for checking intersection of the exclusion rects.
     */
    pwndRoot   = pwnd->head.rpdesk->pDeskInfo->spwnd->spwndParent;
    pwndParent = pwnd->spwndParent;

    /*
     * The parent can be NULL in the case when pwnd == pwndRoot. In other
     * cases we should figure why the parent is NULL.
     */
    if (pwndParent == NULL) {
#if DBG
        if (pwnd != pwndRoot) {
            RIPMSG0(RIP_ERROR, "CalcWindowVisRgn: pwndParent is NULL");
        }
#endif
        goto NullRegion;
    }

    while (pwndParent != pwndRoot) {

        /*
         * Don't clip layered DCs to the desktop. The surface of the layered
         * DC is the size of the window and we always want to have the image
         * of the entire window in that surface.
         */
        if ((flags & DCX_REDIRECTED) && (GETFNID(pwndParent) == FNID_DESKTOP))
            break;

        /*
         * Remember if any of the parents have a window region.
         */
        if (pwndParent->hrgnClip != NULL)
            fRgnParent = TRUE;

        /*
         * Intersect the parent's client rectangle with the window rectangle.
         */
        if (!IntersectRect(&rcWindow, &rcWindow, &pwndParent->rcClient))
            goto NullRegion;

        pwndParent = pwndParent->spwndParent;
    }

    /*
     * Initialize the VisRgn memory-buffer.  This is
     * used to hold the pwnd's.
     */
    gapwndVisDefault  = apwndVisDefault;
    gapwndVisExclude  = gapwndVisDefault;
    gcrcVisExcludeMax = ARRAY_SIZE(apwndVisDefault);
    gcrcVisExclude    = 0;

    /*
     * Build the list of exclude-rects.
     */
    fClipSiblings = (BOOL)(flags & DCX_CLIPSIBLINGS);
    pwndParent    = pwnd->spwndParent;
    pwndLoop      = pwnd;

    while (pwndParent != pwndRoot) {
        /*
         * If we reach a redirected window, we can stop excluding any
         * siblings any siblings of any parents.
         */
        if ((flags & DCX_REDIRECTED) && TestWF(pwndLoop, WEFPREDIRECTED)) {
            break;
        }

        /*
         * Exclude any siblings if necessary.
         */
        if (fClipSiblings && (pwndParent->spwndChild != pwndLoop)) {

            if (!ExcludeWindowRects(pwndParent->spwndChild,
                                    pwndLoop,
                                    &rcWindow)) {

                goto NullRegion;
            }
        }


        /*
         * Set this flag for next time through the loop...
         */
        fClipSiblings = TestWF(pwndParent, WFCLIPSIBLINGS);

        pwndLoop      = pwndParent;
        pwndParent    = pwndLoop->spwndParent;
    }

    if ((flags & DCX_CLIPCHILDREN) && (pwnd->spwndChild != NULL)) {

        if (!ExcludeWindowRects(pwnd->spwndChild, NULL, &rcWindow)) {
            goto NullRegion;
        }
    }

    /*
     * If there are rectangles to exclude call GDI to create
     * a region excluding them from the window rectangle.  If
     * not simply call GreSetRectRgn().
     */
    if (gcrcVisExclude > 0) {

        RECT  arcVisRects[CEXCLUDERECTSMAX];
        PRECT arcExclude;
        int   i;
        int   ircVisExclude  = 0;
        int   irgnVisExclude = 0;

        /*
         * If we need to exclude more rectangles than fit in
         * the pre-allocated buffer, obviously we have to
         * allocate one that's big enough.
         */

        if (gcrcVisExclude <= CEXCLUDERECTSMAX) {
            arcExclude = arcVisRects;
        } else {
            arcExclude = (PRECT)UserAllocPoolWithQuota(
                    sizeof(RECT) * gcrcVisExclude, TAG_VISRGN);

            if (!arcExclude)
                goto NullRegion;
        }

        /*
         * Now run through the list and put the
         * window rectangles into the array for the call
         * to CombineRgnRectList().
         */
        for (i = 0; i < gcrcVisExclude; i++) {

            /*
             * If the window has a clip-rgn associated with
             * it, then re-use gpwneExcludeList[] entries for
             * storing them.
             */
            if (gapwndVisExclude[i]->hrgnClip != NULL) {

                gapwndVisExclude[irgnVisExclude++] = gapwndVisExclude[i];
                continue;
            }

            /*
             * This window doesn't have a clipping region; remember its
             * rect for clipping purposes.
             */
            arcExclude[ircVisExclude++] = gapwndVisExclude[i]->rcWindow;
        }

        if (*phrgn == NULL)
            *phrgn = CreateEmptyRgn();

        if (ircVisExclude != 0) {
            GreSubtractRgnRectList(*phrgn,
                                   &rcWindow,
                                   arcExclude,
                                   ircVisExclude);
        } else {
            SetRectRgnIndirect(*phrgn, &rcWindow);
        }

        for (i = 0; i < irgnVisExclude; i++) {

            SetRectRgnIndirect(ghrgnInv2, &gapwndVisExclude[i]->rcWindow);
            IntersectRgn(ghrgnInv2, ghrgnInv2, gapwndVisExclude[i]->hrgnClip);

            if (SubtractRgn(*phrgn, *phrgn, ghrgnInv2) == NULLREGION)
                break;
        }

        if (arcExclude != arcVisRects) {
            UserFreePool((HLOCAL)arcExclude);
        }

    } else {

        /*
         * If the window was somehow destroyed, then we will return
         * a null-region.  Emptying the rect will accomplish this.
         */
        if (TestWF(pwnd, WFDESTROYED)) {
            SetRectEmpty(&rcWindow);
        }

        /*
         * If there weren't any rectangles to exclude, simply call
         * GreSetRectRgn() with the window rectangle.
         */
        SetOrCreateRectRgnIndirectPublic(phrgn, &rcWindow);
    }

    /*
     * Clip out this window's window region
     */
    if (pwnd->hrgnClip != NULL) {
        IntersectRgn(*phrgn, *phrgn, pwnd->hrgnClip);
    }

    /*
     * Clip out parent's window regions, if there are any.
     */
    if (fRgnParent) {

        PWND pwndT;

        for (pwndT = pwnd->spwndParent;
                pwndT != pwndRoot;
                pwndT = pwndT->spwndParent) {

            if (pwndT->hrgnClip != NULL) {

                if (IntersectRgn(*phrgn, *phrgn, pwndT->hrgnClip) == NULLREGION)
                    break;
            }
        }
    }

    fResult = TRUE;
    // fall-through

Cleanup:
    if (gfVisAlloc) {
        UserFreePool((HLOCAL)gapwndVisExclude);
        gfVisAlloc = FALSE;
    }

    return fResult;

NullRegion:
    SetOrCreateRectRgnIndirectPublic(phrgn, PZERO(RECT));
    fResult = FALSE;
    goto Cleanup;
}

/***************************************************************************\
* CalcVisRgn
*
* Will return FALSE if the pwndOrg is not visible, TRUE otherwise.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL CalcVisRgn(
    HRGN  *phrgn,
    PWND  pwndOrg,
    PWND  pwndClip,
    DWORD flags)
{
    PDESKTOP    pdesk;

    UserAssert(pwndOrg != NULL);

    /*
     * If the window's not visible or is not an active desktop,
     * or if the clip window is in the process of being destroyed,
     * the visrgn is empty.
     */
    pdesk = pwndOrg->head.rpdesk;
    
    UserAssert(pdesk);
    
    /*
     * Make sure this happens in the IO windowstation
     */
#if DBG
    if (grpdeskRitInput != NULL) {
        UserAssert(pdesk->rpwinstaParent == grpdeskRitInput->rpwinstaParent ||
                   !IsVisible(pwndOrg));
    }
#endif // DBG
    /*
     * For redirected windows, if it is on the non I/O desktop, we still need
     * to pass the application a non empty region in order to update the bitmap
     * Otherwise, the bitmap will never got the chance to be updated and we will end up
     * rendering a black window region (for the case of layered windows) by the time
     * we switch to this desktop. (see bug# 287315). Note that this will not render the window on the screen 
     * because the call to CalcVisRgn from UserVisrgnFromHwnd() should never specify 
     * DCX_REDIRECTEDBITMAP.
     */
#if DBG
   if (!TestWF(pwndOrg, WEFPREDIRECTED)) {
       UserAssert(!(flags & DCX_REDIRECTEDBITMAP));
   }
#endif 
    if (!IsVisible(pwndOrg) || 
        ((pdesk != grpdeskRitInput) && !(flags & DCX_REDIRECTEDBITMAP))) {
        goto EmptyRgn;
    }

    /*
     * If LockWindowUpdate() has been called, and this window is a child
     * of the lock window, always return an empty visrgn.
     */
    if ((gspwndLockUpdate != NULL)     &&
        !(flags & DCX_LOCKWINDOWUPDATE)         &&
        _IsDescendant(gspwndLockUpdate, pwndOrg)) {

        goto EmptyRgn;
    }

    /*
     * Now go compute the visrgn for pwndClip.
     */
    return CalcWindowVisRgn(pwndClip, phrgn, flags);

EmptyRgn:
    SetOrCreateRectRgnIndirectPublic(phrgn, PZERO(RECT));
    return FALSE;
}

/***************************************************************************\
* CalcWindowRgn
*
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

int CalcWindowRgn(
    PWND pwnd,
    HRGN hrgn,
    BOOL fClient)
{
    SetRectRgnIndirect(hrgn, (fClient) ? &pwnd->rcClient : &pwnd->rcWindow);

    /*
     * If the window has a region, then intersect the rectangle region with
     * that. If this is low on memory, it'll propagate ERROR back.
     */
    if (pwnd->hrgnClip != NULL) {
        return IntersectRgn(hrgn, hrgn, pwnd->hrgnClip);
    }

    return SIMPLEREGION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\winable.c ===
/**************************** Module Header ********************************\
* Module Name: winable.c
*
* This has the stuff for WinEvents:
*     NotifyWinEvent
*     _SetWinEventHook
*     UnhookWinEventHook
*
* All other additions to USER for Active Accessibility are in WINABLE2.C
* and its helper ASM file, ABLEASM.ASM.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* Based on snapshot taken from:
*  \\trango\slmro\proj\win\src\CORE\access\user_40\user32 on 8/29/96
* 08-30-96 IanJa  Ported from Windows '95
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#if DBG
int gnNotifies = 0;
#define DBGVERIFYEVENTHOOK(peh)                                              \
        HMValidateCatHandleNoSecure(PtoH(peh), TYPE_WINEVENTHOOK);           \
        UserAssertMsg1((IsValidTag(peh, TAG_WINEVENT)), "event hook %#p: bad tag", peh); \
        UserAssertMsg1((peh->eventMin <= peh->eventMax), "event hook %#p: bad range", peh)
#define DBGVERIFYNOTIFY(pNotify)                                  \
        UserAssert(pNotify->spEventHook != NULL);                 \
        UserAssert(pNotify->spEventHook->fSync || (pNotify->dwWEFlags & WEF_ASYNC))
#else
#define DBGVERIFYEVENTHOOK(peh)
#define DBGVERIFYNOTIFY(pNotify)
#endif

/*
 * Pending Event Notifications (sync and async)
 */

static NOTIFY   notifyCache;
static BOOL     fNotifyCacheInUse = FALSE;


/*
 * Local to this module
 */
WINEVENTPROC xxxGetEventProc(PEVENTHOOK pEventOrg);
PNOTIFY CreateNotify(PEVENTHOOK peh, DWORD event, PWND pwnd, LONG idObject,
        LONG idChild, PTHREADINFO ptiEvent, DWORD dwTime);


/*****************************************************************************\
*
*  xxxProcessNotifyWinEvent()
*
*  Posts or Sends a WinEvent notification.
*  Post: uses PostEventMesage - does not leave the critical section.
*  Send: makes a callback to user-mode - does leave the critical section.
*
*  If this is a system thread (RIT, Desktop or Console) then synchronously
*  hooked (WINEVENT_INCONTEXT) events are forced to be asynchronous.
*
*  We return the next win event hook in the list.
*
\*****************************************************************************/
PEVENTHOOK
xxxProcessNotifyWinEvent(PNOTIFY pNotify)
{
    WINEVENTPROC   pfn;
    PEVENTHOOK     pEventHook;
    TL             tlpEventHook;
    PTHREADINFO    ptiCurrent = PtiCurrent();

    pEventHook = pNotify->spEventHook;
    DBGVERIFYEVENTHOOK(pEventHook);
    UserAssert(pEventHook->head.cLockObj);

    if (((pNotify->dwWEFlags & (WEF_ASYNC | WEF_POSTED)) == WEF_ASYNC)
        ||
        (ptiCurrent->TIF_flags & (TIF_SYSTEMTHREAD | TIF_CSRSSTHREAD | TIF_INCLEANUP))

        ||
        (!RtlEqualLuid(&GETPTI(pEventHook)->ppi->luidSession, &ptiCurrent->ppi->luidSession) &&
         !(ptiCurrent->TIF_flags & TIF_ALLOWOTHERACCOUNTHOOK))

        ||
        (GETPTI(pEventHook)->ppi != ptiCurrent->ppi &&
         IsRestricted(GETPTI(pEventHook)->pEThread))

#if defined(_WIN64)
        ||
        ((GETPTI(pEventHook)->TIF_flags & TIF_WOW64) != (ptiCurrent->TIF_flags & TIF_WOW64))
#endif
        ) {
        /*
         * POST
         *
         * WinEvent Hook set without WINEVENT_INCONTEXT flag are posted;
         * Events from system threads are posted because there is no user-mode
         *    part to callback to;
         * Console is not permitted to load DLLs, so we must post back to the
         *    hooking application;
         * DLLs can not be loaded cross bit type(32bit to 64bit) on 64bit NT
         *    so we must post(It may be usefull to let the app be aware and
         *    even supply both a 32bit and a 64bit DLL that are aware of each other);
         * Threads in cleanup can't get called back, so turn their
         *    notifications into async ones. (Better late than never).
         *
         * If forcing these events ASYNC is unacceptable, we might consider
         * doing system/console SYNC events like low-level hooks (sync with
         * timeout: but may have to post it if the timeout expires) - IanJa
         */
        PQ  pqReceiver = GETPTI(pEventHook)->pq;
        PEVENTHOOK pEventHookNext = pEventHook->pehNext;

        BEGINATOMICCHECK();

        DBGVERIFYNOTIFY(pNotify);
        pNotify->dwWEFlags |= WEF_POSTED | WEF_ASYNC;
        if (!pqReceiver || (GETPTI(pEventHook) == gptiRit) ||
                pEventHook->fDestroyed ||
                !PostEventMessage(GETPTI(pEventHook), pqReceiver,
                                  QEVENT_NOTIFYWINEVENT,
                                  NULL, 0, 0, (LPARAM)pNotify)) {
            /*
             * If the receiver doesn't have a queue or the
             * post failed (low memory), cleanup what we just
             * created.
             * Note: destroying the notification may destroy pEventHook too.
             */
            RIPMSG2(RIP_WARNING, "failed to post NOTIFY at %#p, time %lx\n",
                      pNotify, pNotify->dwEventTime);
            DestroyNotify(pNotify);
        }

        ENDATOMICCHECK();

        if (pEventHookNext) {
            DBGVERIFYEVENTHOOK(pEventHookNext);
        }
        return pEventHookNext;
    }

    /*
     * Don't call back if the hook has been destroyed (unhooked).
     */
    if (pEventHook->fDestroyed) {
        /*
         * Save the next hook since DestroyNotify may cause pEventHook to
         * be freed by unlocking it.
         */
        pEventHook = pEventHook->pehNext;
        DestroyNotify(pNotify);
        return pEventHook;
    }

    /*
     * CALLBACK
     *
     * This leaves the critical section.
     * We return the next Event Hook in the list so that the caller doesn't
     * have to lock pEventHook.
     */
    UserAssert((pNotify->dwWEFlags & WEF_DEFERNOTIFY) == 0);

    ThreadLockAlways(pEventHook, &tlpEventHook);

    UserAssertMsg1(pNotify->ptiReceiver == NULL,
         "pNotify %#p is already in callback!  Reentrant?", pNotify);
    pNotify->ptiReceiver = ptiCurrent;

    if (!pEventHook->fSync) {
        UserAssert(pEventHook->ihmod == -1);
        pfn = (WINEVENTPROC)pEventHook->offPfn;
    } else {
        pfn = xxxGetEventProc(pEventHook);
    }
    if (pfn) {
        xxxClientCallWinEventProc(pfn, pEventHook, pNotify);
        DBGVERIFYNOTIFY(pNotify);
        DBGVERIFYEVENTHOOK(pEventHook);
        UserAssert(pEventHook->head.cLockObj);
    }

    pNotify->ptiReceiver = NULL;

    /*
     * Save the next item in the list, ThreadUnlock() may destroy pEventHook.
     * DestroyNotify() may also kill the event if it is a zombie (destroyed
     * but being used, waiting for use count to go to 0 before being freed).
     */
    pEventHook = pEventHook->pehNext;
    ThreadUnlock(&tlpEventHook);

    /*
     * We are done with the notification.  Kill it.
     *
     * NOTE that DestroyNotify does not yield, which is why we can hang on
     * to the pehNext field above around this call.
     *
     * NOTE ALSO that DestroyNotify will kill the event it references if the
     * ref count goes down to zero and it was zombied earlier.
     */
    DestroyNotify(pNotify);

    return pEventHook;
}


/****************************************************************************\
* xxxFlushDeferredWindowEvents()
*
* Process notifications that were queued up during DeferWinEventNotify()
\****************************************************************************/
VOID
xxxFlushDeferredWindowEvents()
{
    PNOTIFY pNotify;
    DWORD idCurrentThread = W32GetCurrentTID();

    if (idCurrentThread == 0) {
        RIPMSG0(RIP_ERROR, "processing deferred notifications before we have a pti!");
        // return;
    }

    UserAssert(IsWinEventNotifyDeferredOK());

    pNotify = gpPendingNotifies;
    while (pNotify) {
        if (((pNotify->dwWEFlags & WEF_DEFERNOTIFY) == 0) ||
                (pNotify->idSenderThread != idCurrentThread)) {
            // UserAssert(pNotify->idSenderThread == idCurrentThread); // just testing!
            pNotify = pNotify->pNotifyNext;
        } else {
            /*
             * Clear WEF_DEFERNOTIFY so that if we recurse in the callback
             * we won't try to send this notification again.
             */
            pNotify->dwWEFlags &= ~WEF_DEFERNOTIFY;
#if DBG
            gnDeferredWinEvents--;
#endif
            /*
             * We shouldn't have deferred ASYNC notifications: we should have
             * posted them immediately.
             */
            UserAssert((pNotify->dwWEFlags & WEF_ASYNC) == 0);
            xxxProcessNotifyWinEvent(pNotify);
            /*
             * Start again at the head of the list, in case it munged during
             * the callback.
             */
            pNotify = gpPendingNotifies;
        }
    }
}


/*****************************************************************************\
*
* xxxWindowEvent
*
* Send, Post or Defer a Win Event notification, depending on what Win Event
* hooks are installed and what the context of the caller is.
*
* The caller should test FWINABLE() and only call xxxWindowEvent if it is TRUE,
* that way only costs a few clocks if no Win Event hooks are set.
*
* Caller shouldn't lock pwnd, because xxxWindowEvent() will do it.
*
\*****************************************************************************/
VOID
xxxWindowEvent(
    DWORD   event,
    PWND    pwnd,
    LONG    idObject,
    LONG    idChild,
    DWORD   dwFlags)
{
    PEVENTHOOK peh;
    PEVENTHOOK pehNext;
    PTHREADINFO ptiCurrent, ptiEvent;
    DWORD   dwTime;
    PPROCESSINFO ppiEvent;
    DWORD idEventThread;
    HANDLE hEventProcess;
    PNOTIFY pNotify;
    TL tlpwnd;
    TL tlpti;

    /*
     * Do not bother with CheckLock(pwnd) - we ThreadLock it below.
     */
    if (!FEVENTHOOKED(event)) {
        return;
    }

    /*
     * This thread is in startup, and has not yet had it's pti set up
     * This is pretty rare, but sometimes encountered in stress.
     * Test gptiCurrent to avoid the UserAssert(gptiCurrent) in PtiCurrent()
     */
    if (gptiCurrent == NULL) {
        RIPMSG3(RIP_WARNING, "Ignore WinEvent %lx %#p %lx... no PtiCurrent yet",
                event, pwnd, idObject);
        return;
    }
    ptiCurrent = PtiCurrent();

    /*
     * Don't bother with destroyed windows
     */
    if (pwnd && TestWF(pwnd, WFDESTROYED)) {
        RIPMSG3(RIP_WARNING,
                "Ignore WinEvent %lx %#p %lx... pwnd already destroyed",
                event, pwnd, idObject);
        return;
    }

    /*
     * Under some special circumstances we have to defer
     */
    if (ptiCurrent->TIF_flags & (TIF_DISABLEHOOKS | TIF_INCLEANUP)) {
        dwFlags |= WEF_DEFERNOTIFY;
    }

    /*
     * Determine process and thread issuing the event notification
     */
    if ((dwFlags & WEF_USEPWNDTHREAD) && pwnd) {
        ptiEvent = GETPTI(pwnd);
    } else {
        ptiEvent = ptiCurrent;
    }
    idEventThread = TIDq(ptiEvent);
    ppiEvent = ptiEvent->ppi;
    hEventProcess = PsGetThreadProcessId(ptiEvent->pEThread);

    dwTime = NtGetTickCount();

    ThreadLockWithPti(ptiCurrent, pwnd, &tlpwnd);
    ThreadLockPti(ptiCurrent, ptiEvent, &tlpti);

    /*
     * If we're not deferring the current notification process any pending
     * deferred notifications before proceeding with the current notification
     */
    if (!(dwFlags & WEF_DEFERNOTIFY)) {
        xxxFlushDeferredWindowEvents();
    }

    for (peh = gpWinEventHooks; peh; peh = pehNext) {
        DBGVERIFYEVENTHOOK(peh);
        pehNext = peh->pehNext;

        //
        // Is event in the right range?  And is it for this process/thread?
        // Note that we skip destroyed events.  They will be freed any
        // second now, it's just that yielding may have caused reentrancy.
        //
        // If the caller said to ignore events on his own thread, make sure
        // we skip them.
        //
        if (!peh->fDestroyed                &&
            (peh->eventMin <= event)        &&
            (event <= peh->eventMax)        &&
            (!peh->hEventProcess || (peh->hEventProcess == hEventProcess)) &&
            (!peh->fIgnoreOwnProcess || (ppiEvent != GETPTI(peh)->ppi)) &&
            (!peh->idEventThread || (peh->idEventThread == idEventThread))  &&
            (!peh->fIgnoreOwnThread || (ptiEvent != GETPTI(peh))) &&
            // temp fix from SP3 - best to architect events on a per-desktop
            // basis, with a separate pWinEventHook list per desktop. (IanJa)
            (peh->head.pti->rpdesk == ptiCurrent->rpdesk))
        {
            /*
             * Don't create new notifications for zombie event hooks.
             * When an event is destroyed, it stays as a zombie until the in-use
             * count goes to zero (all it's async and deferred notifies gone)
             */
            if (HMIsMarkDestroy(peh)) {
                break;
            }

            UserAssert(peh->fDestroyed == 0);

            if ((pNotify = CreateNotify(peh, event, pwnd, idObject,
                    idChild, ptiEvent, dwTime)) == NULL) {
                break;
            }
            pNotify->dwWEFlags |= dwFlags;

            /*
             * If it's async, don't defer it: post it straight away.
             */
            if (pNotify->dwWEFlags & WEF_ASYNC) {
                pNotify->dwWEFlags &= ~WEF_DEFERNOTIFY;
            }

            if (pNotify->dwWEFlags & WEF_DEFERNOTIFY) {
#if DBG
                gnDeferredWinEvents++;
#endif
                DBGVERIFYNOTIFY(pNotify);
            } else {
                pehNext = xxxProcessNotifyWinEvent(pNotify);
            }
        }
    }

    ThreadUnlockPti(ptiCurrent, &tlpti);
    ThreadUnlock(&tlpwnd);
}

/****************************************************************************\
*
* CreateNotify()
*
* Gets a pointer to a NOTIFY struct that we can then propagate to our
* event window via Send/PostMessage.  We have to do this since we want to
* (pass on a lot more data then can be packed in the parameters.
*
*  We have one cached struct so we avoid lots of allocs and frees in the
*  most common case of just one outstanding notification.
\****************************************************************************/
PNOTIFY
CreateNotify(PEVENTHOOK pEvent, DWORD event, PWND pwnd, LONG idObject,
    LONG idChild, PTHREADINFO ptiSender, DWORD dwTime)
{
    PNOTIFY pNotify;
    UserAssert(pEvent != NULL);

    //
    // Get a pointer.  From cache if available.
    // IanJa - change this to allocate from zone a la AllocQEntry??
    //
    if (!fNotifyCacheInUse) {
        fNotifyCacheInUse = TRUE;
        pNotify = &notifyCache;
#if DBG
        //
        // Make sure we aren't forgetting to set any fields.
        //
        // DebugFillBuffer(pNotify, sizeof(NOTIFY));
#endif
    } else {
        pNotify = (PNOTIFY)UserAllocPool(sizeof(NOTIFY), TAG_NOTIFY);
        if (!pNotify)
            return NULL;
    }


    /*
     * Fill in the notify block.
     */
    pNotify->spEventHook = NULL;
    Lock(&pNotify->spEventHook, pEvent);
    pNotify->hwnd = HW(pwnd);
    pNotify->event = event;
    pNotify->idObject = idObject;
    pNotify->idChild = idChild;
    pNotify->idSenderThread = TIDq(ptiSender);
    UserAssert(pNotify->idSenderThread != 0);
    pNotify->dwEventTime = dwTime;
    pNotify->dwWEFlags = pEvent->fSync ? 0 : WEF_ASYNC;
    pNotify->pNotifyNext = NULL;
    pNotify->ptiReceiver = NULL;
#if DBG
    gnNotifies++;
#endif

    /*
     * The order of non-deferred notifications doesn't matter; they are here
     * simply for cleanup/in-use tracking. However, deferred notifications must
     * be ordered with most recent at the end, so just order them all that way.
     */
    if (gpPendingNotifies) {
        UserAssert(gpLastPendingNotify);
        UserAssert(gpLastPendingNotify->pNotifyNext == NULL);
        gpLastPendingNotify->pNotifyNext = pNotify;
    } else {
        gpPendingNotifies = pNotify;
    }
    gpLastPendingNotify = pNotify;

    return pNotify;
}


/****************************************************************************\
*
*  RemoveNotify()
*
*  NOTE:  This does NOT yield.
\****************************************************************************/
VOID
RemoveNotify(PNOTIFY *ppNotify)
{
    PNOTIFY pNotifyRemove;

    pNotifyRemove = *ppNotify;

    /*
     * First, get it out of the pending list.
     */
    *ppNotify = pNotifyRemove->pNotifyNext;

#if DBG
    if (pNotifyRemove->dwWEFlags & WEF_DEFERNOTIFY) {
        UserAssert(gnDeferredWinEvents > 0);
        gnDeferredWinEvents--;
    }
#endif
    if (*ppNotify == NULL) {
        /*
         * Removing last notify, so fix up gpLastPendingNotify:
         * If list now empty, there is no last item.
         */
        if (gpPendingNotifies == NULL) {
            gpLastPendingNotify = NULL;
        } else {
            gpLastPendingNotify = CONTAINING_RECORD(ppNotify, NOTIFY, pNotifyNext);
        }
    }
    UserAssert((gpPendingNotifies == 0) || (gpPendingNotifies > (PNOTIFY)100));

    DBGVERIFYEVENTHOOK(pNotifyRemove->spEventHook);

    /*
     * This may cause the win event hook to be freed.
     */
    Unlock(&pNotifyRemove->spEventHook);

    //
    // Now free it.  Either put it back in the cache if it is the cache,
    // or really free it otherwise.
    //
    if (pNotifyRemove == &notifyCache) {
        UserAssert(fNotifyCacheInUse);
        fNotifyCacheInUse = FALSE;
    } else {
        UserFreePool(pNotifyRemove);
    }
#if DBG
    UserAssert(gnNotifies > 0);
    gnNotifies--;
#endif
}


/*****************************************************************************\
*
* DestroyNotify()
*
* NOTE:  This does NOT yield.
*
* This gets the notification out of our pending list and frees the local
* memory it uses.
*
* This function is called
* (1) NORMALLY:   After returning from calling the notify proc
* (2) CLEANUP:    When a thread goes away, we cleanup async notifies it
*     hasn't received, and sync notifies it was in the middle of trying
*     to call (i.e. the event proc faulted).
*
\*****************************************************************************/
VOID
DestroyNotify(PNOTIFY pNotifyDestroy)
{
    PNOTIFY  *ppNotify;
    PNOTIFY  pNotifyT;

    DBGVERIFYNOTIFY(pNotifyDestroy);

    /*
     * Either this notify isn't currently in the process of calling back
     * (which means ptiReceiver is NULL) or the thread destroying it
     * must be the one that was calling back (which means this thread
     * was destroyed during the callback and is cleaning up).
     */
    UserAssert((pNotifyDestroy->ptiReceiver == NULL) ||
            (pNotifyDestroy->ptiReceiver == PtiCurrent()));

    ppNotify = &gpPendingNotifies;
    while (pNotifyT = *ppNotify) {
        if (pNotifyT == pNotifyDestroy) {
            RemoveNotify(ppNotify);
            return;
        } else {
            ppNotify = &pNotifyT->pNotifyNext;
        }
    }
    RIPMSG1(RIP_ERROR, "DestroyNotify %#p - not found", pNotifyDestroy);
}



/***************************************************************************\
* FreeThreadsWinEvents
*
* During 'exit-list' processing this function is called to free any WinEvent
* notifications and WinEvent hooks created by the current thread.
*
* Notifications that remain may be:
*  o  Posted notifications (async)
*  o  Notifications in xxxClientCallWinEventProc (sync)
*  o  Deferred notifications (should be sync only)
* Destroy the sync notifications, because we cannot do callbacks
* while in thread cleanup.
* Leave the posted (async) notifications alone: they're on their way already.
*
* History:
* 11-11-96 IanJa         Created.
\***************************************************************************/

VOID
FreeThreadsWinEvents(PTHREADINFO pti)
{
    PEVENTHOOK peh, pehNext;
    PNOTIFY pn, pnNext;
    DWORD idCurrentThread = W32GetCurrentTID();

    /*
     * Loop through all the notifications
     */
    for (pn = gpPendingNotifies; pn; pn = pnNext) {
        pnNext = pn->pNotifyNext;

        /*
         * Only destroy sync notifications that belong to this thread
         * and are not currently calling back i.e. ptiReceiver must be NULL.
         * Otherwise, when we come back from the callback in
         * xxxProcessNotifyWinEvent we will operate on a freed notify.
         * Also destroy the notification if the receiver is going away
         * or else it gets leaked as long as the sender is alive.
         */
        if ((pn->idSenderThread == idCurrentThread &&
                pn->ptiReceiver == NULL) || (pn->ptiReceiver == pti)) {
            if ((pn->dwWEFlags & WEF_ASYNC) == 0) {
                UserAssert((pn->dwWEFlags & WEF_POSTED) == 0);
                DestroyNotify(pn);
            }
        }
    }

    peh = gpWinEventHooks;
    while (peh) {
        pehNext = peh->pehNext;
        if (GETPTI(peh) == pti) {
            DestroyEventHook(peh);
        }
        peh = pehNext;
    }
    // Async notification not yet processed may still be posted in a queue,
    // pending being read and processed (gnNotifies > 0), although the
    // originating hook has now been unhooked (maybe gpWinEventHooks == NULL)
    // so the following assert is no good:
    // UserAssert(gpWinEventHooks || (!gpWinEventHooks && !gnNotifies));
}


// --------------------------------------------------------------------------
//
//  _SetWinEventHook()
//
//  This installs a win event hook.
//
//
// If hEventProcess set but idEventThread = 0, hook all threads in process.
// If idEventThread set but hEventProcess = NULL, hook single thread only.
// If neither are set, hook everything.
// If both are set ??
//
// --------------------------------------------------------------------------
PEVENTHOOK
_SetWinEventHook(
    DWORD           eventMin,
    DWORD           eventMax,
    HMODULE         hmodWinEventProc,
    PUNICODE_STRING pstrLib,
    WINEVENTPROC    pfnWinEventProc,
    HANDLE          hEventProcess,
    DWORD           idEventThread,
    DWORD           dwFlags)
{
    PEVENTHOOK pEventNew;
    PTHREADINFO ptiCurrent;

    int ihmod;

    ptiCurrent = PtiCurrent();

    //
    // If exiting, fail the call.
    //
    if (ptiCurrent->TIF_flags & TIF_INCLEANUP) {
        RIPMSG1(RIP_ERROR, "SetWinEventHook: Fail call - thread %#p in cleanup", ptiCurrent);
        return NULL;
    }

    /*
     * Check to see if filter proc is valid.
     */
    if (pfnWinEventProc == NULL) {
        RIPERR0(ERROR_INVALID_FILTER_PROC, RIP_VERBOSE, "pfnWinEventProc == NULL");
        return NULL;
    }

    if (eventMin > eventMax) {
        RIPERR0(ERROR_INVALID_HOOK_FILTER, RIP_VERBOSE, "eventMin > eventMax");
        return NULL;
    }

    if (dwFlags & WINEVENT_INCONTEXT) {
        /*
         * WinEventProc to be called in context of hooked thread, so needs a DLL
         */
        if (hmodWinEventProc == NULL) {
            RIPERR0(ERROR_HOOK_NEEDS_HMOD, RIP_VERBOSE, "");
            return NULL;
        } else if (pstrLib == NULL) {
            /*
             * If we got an hmod, we should get a DLL name too!
             */
            RIPERR1(ERROR_DLL_NOT_FOUND, RIP_ERROR,
                    "hmod %#p, but no lib name", hmodWinEventProc);
            return NULL;
        }
        ihmod = GetHmodTableIndex(pstrLib);
        if (ihmod == -1) {
            RIPERR0(ERROR_MOD_NOT_FOUND, RIP_VERBOSE, "");
            return NULL;
        }
    } else {
        ihmod = -1;            // means no DLL is required
        hmodWinEventProc = 0;
    }

    /*
     * Check the thread id, check it is a GUI thread.
     */
    if (idEventThread != 0) {
        PTHREADINFO ptiT;

        ptiT = PtiFromThreadId(idEventThread);
        if ((ptiT == NULL) ||
                !(ptiT->TIF_flags & TIF_GUITHREADINITIALIZED)) {
            RIPERR1(ERROR_INVALID_THREAD_ID, RIP_VERBOSE, "pti %#p", ptiT);
            return NULL;
        }
    }

    //
    // Create the window for async events first.  Creating it might yield,
    // so we want to do this before we've touched our event array.
    //
    // NOTE that USER itself will not pass on window creation/destruction
    // notifications for
    //      * IME windows
    //      * OLE windows
    //      * RPC windows
    //      * Event windows
    //

    //
    // Get a new event.
    //
    pEventNew = (PEVENTHOOK)HMAllocObject(ptiCurrent, NULL,
            TYPE_WINEVENTHOOK, sizeof(EVENTHOOK));
    if (!pEventNew)
        return NULL;

    //
    // Fill in the new event.
    //
    pEventNew->eventMin = (UINT)eventMin;
    pEventNew->eventMax = (UINT)eventMax;

    // pEventNew->f32Bit = ((dwFlags & WINEVENT_32BITCALLER) != 0);
    pEventNew->fIgnoreOwnThread = ((dwFlags & WINEVENT_SKIPOWNTHREAD) != 0);
    pEventNew->fIgnoreOwnProcess = ((dwFlags & WINEVENT_SKIPOWNPROCESS) != 0);
    pEventNew->fDestroyed = FALSE;
    pEventNew->fSync = ((dwFlags & WINEVENT_INCONTEXT) != 0);

    pEventNew->hEventProcess = hEventProcess;
    pEventNew->idEventThread = idEventThread;
    // pEventNew->cInUse = 0;

    pEventNew->ihmod = ihmod;

    /*
     * Add a dependency on this module - meaning, increment a count
     * that simply counts the number of hooks set into this module.
     */
    if (pEventNew->ihmod >= 0) {
        AddHmodDependency(pEventNew->ihmod);
    }

    /*
     * If pfnWinEventProc is in caller's process and no DLL is involved,
     * then pEventNew->offPfn is the actual address.
     */
    pEventNew->offPfn = ((ULONG_PTR)pfnWinEventProc) - ((ULONG_PTR)hmodWinEventProc);

    //
    //
    // Link our event into the master list.
    //
    // Note that we count on USER to not generate any events when installing
    // our hook.  The caller can't handle it yet since he hasn't got back
    // his event handle from this call.
    //
    pEventNew->pehNext = gpWinEventHooks;
    gpWinEventHooks = pEventNew;

    /*
     * Update the flags that indicate what event hooks are installed.  These
     * flags are accessable from user mode without a kernel transition since
     * they are in shared memory.
     */
    SET_FLAG(gpsi->dwInstalledEventHooks, CategoryMaskFromEventRange(eventMin, eventMax));

    return pEventNew;
}

/****************************************************************************\
*  UnhookWinEvent()
*
*  Unhooks a win event hook.  We of course sanity check that this thread is
*  the one which installed the hook.  We have to:  We are going to destroy
*  the IPC window and that must be in context.
*
\****************************************************************************/
BOOL
_UnhookWinEvent(PEVENTHOOK pEventUnhook)
{
    DBGVERIFYEVENTHOOK(pEventUnhook);

    if (HMIsMarkDestroy(pEventUnhook) || (GETPTI(pEventUnhook) != PtiCurrent())) {
        //
        // We do this to avoid someone calling UnhookWinEvent() the first
        // time, then somehow getting control again and calling it a second
        // time before we've managed to free up the event since someone was
        // in the middle of using it at the first UWE call.
        //

        RIPERR0(ERROR_INVALID_HANDLE, RIP_WARNING, "_UnhookWinEvent: Invalid event hook");
        return FALSE;
    }

    //
    // Purge this baby if all notifications are done.
    //      * if there are SYNC ones pending, the caller will clean this up
    //          upon the return from calling the event
    //      * if there are ASYNC ones pending, the receiver will not call
    //          the event and clean it up when he gets it.
    //

    //
    // NOTE that DestroyEventHook() does not yield!
    //
    DestroyEventHook(pEventUnhook);

    return TRUE;
}




/*****************************************************************************\
*
* DestroyEventHook()
*
* NOTE that this does NOT yield
*
* Destroys an event when the ref count has gone down to zero.  It may
* happen
*     * in the event generator's context, after returning from a callback
*         and the ref count dropped to zero, if sync
*     * in the event installer's context, after returning from a callback
*         and the ref count dropped to zero if async
*     * in the event installer's context, if on _UnhookWinEvent() the event
*         was not in use at all
*
\*****************************************************************************/
VOID
DestroyEventHook(PEVENTHOOK pEventDestroy)
{
    PEVENTHOOK *ppEvent;
    PEVENTHOOK pEventT;
    DWORD dwCategoryMask = 0;

    DBGVERIFYEVENTHOOK(pEventDestroy);
    UserAssert(gpWinEventHooks);

    /*
     * Mark this event as destroyed, but don't remove it from the event list
     * until its lock count goes to 0 - we may be traversing the list
     * within xxxWindowEvent, so we mustn't break the link to the next hook.
     */
    pEventDestroy->fDestroyed = TRUE;

    /*
     * If the object is locked, mark it for destroy but don't free it yet.
     */
    if (!HMMarkObjectDestroy(pEventDestroy))
        return;

    /*
     * Remove this from our event list.
     */
    for (ppEvent = &gpWinEventHooks; pEventT = *ppEvent; ppEvent = &pEventT->pehNext) {
        if (pEventT == pEventDestroy) {
            *ppEvent = pEventDestroy->pehNext;
            break;
        }
    }
    UserAssert(pEventT);

    /*
     * Update the flags that indicate what event hooks are installed.  These
     * flags are accessable from user mode without a kernel transition since
     * they are in shared memory.  Note that a user could check the shared
     * memory at any time, so they may get a false-positive during this
     * processing.  A false-positive would mean that we claim there is a
     * listener, when there really isn't.  We never want the user to get
     * a false negative - meaning that we claim there aren't any listeners
     * but there really is.  That could mean bad things for accessability.
     */
    for (pEventT = gpWinEventHooks; pEventT != NULL; pEventT = pEventT->pehNext) {
        SET_FLAG(dwCategoryMask, CategoryMaskFromEventRange(pEventT->eventMin, pEventT->eventMax));
    }
    gpsi->dwInstalledEventHooks = dwCategoryMask;

    /*
     * Make sure each hooked thread will unload the hook proc DLL
     */
    if (pEventDestroy->ihmod >= 0) {
        RemoveHmodDependency(pEventDestroy->ihmod);
    }

    /*
     * Free this pointer.
     */
    HMFreeObject(pEventDestroy);

    return;
}

/***************************************************************************\
*
* xxxGetEventProc()
*
* For sync events, this gets the address to call.  If 16-bits, then just
* return the installed address.  If 32-bits, we need to load the library
* if not in the same process as the installer.
\***************************************************************************/
WINEVENTPROC
xxxGetEventProc(PEVENTHOOK pEventOrg) {
    PTHREADINFO ptiCurrent;

    UserAssert(pEventOrg);
    UserAssert(pEventOrg->fSync);
    UserAssert(pEventOrg->ihmod >= 0);
    UserAssert(pEventOrg->offPfn != 0);

    CheckLock(pEventOrg);

    /*
     * Make sure the hook is still around before we
     * try and call it.
     */
    if (HMIsMarkDestroy(pEventOrg)) {
        return NULL;
    }

    ptiCurrent = PtiCurrent();

    /*
     * Make sure the DLL for this hook, if any, has been loaded
     * for the current process.
     */
    if ((pEventOrg->ihmod != -1) &&
            (TESTHMODLOADED(ptiCurrent, pEventOrg->ihmod) == 0)) {

        /*
         * Try loading the library, since it isn't loaded in this processes
         * context.  The hook is alrerady locked, so it won't go away while
         * we're loading this library.
         */
        if (xxxLoadHmodIndex(pEventOrg->ihmod) == NULL) {
            return NULL;
        }
    }

    /*
     * While we're still inside the critical section make sure the
     * hook hasn't been 'freed'.  If so just return NULL.
     * IanJa - since WinEvent has already been called, you might think that we
     * should pass the event on, but the hooker may not be expecting this after
     * having cancelled the hook!  In any case, seems we may have two ways
     * of detecting that this hook has been removed:
     */

    /*
     * Make sure the hook is still around before we
     * try and call it.
     */
    if (HMIsMarkDestroy(pEventOrg)) {
        return NULL;
    }

    return (WINEVENTPROC)PFNHOOK(pEventOrg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\winloop2.c ===
/*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*/

#include "precomp.h"
#pragma hdrstop

// ----------------------------------------------------------------------------
//
//  IsVSlick() -
//
//  TRUE if window is positioned at +100,+100 from bottom right of screen --
//  probably VSlick -- which has two Tray Windows, one is unowned but off the
//  screen....we want the owned one since its on the screen
//
// ----------------------------------------------------------------------------
BOOL IsVSlick(PWND pwnd)
{
    if (gpDispInfo->cMonitors == 1 &&
        ((unsigned) pwnd->rcWindow.left > (unsigned) gpDispInfo->rcScreen.right ) &&
        ((unsigned) pwnd->rcWindow.top  > (unsigned) gpDispInfo->rcScreen.bottom) &&
        (pwnd->rcWindow.top == (gpDispInfo->rcScreen.bottom+100)) &&
        (pwnd->rcWindow.left == (gpDispInfo->rcScreen.right+100)))
    {
        // MUST BE THE ONE AND ONLY V-SLICK
        return(TRUE);
    }

    return(FALSE);
}

// ----------------------------------------------------------------------------
//
//  Is31TrayWindow() -
//
//  extra grilling required for 3.1 and earlier apps before letting 'em in the
//  tray -- trust me, you DON'T want to change this code. -- JEFFBOG 11/10/94
//
// ----------------------------------------------------------------------------
BOOL Is31TrayWindow(PWND pwnd)
{
    PWND pwnd2;

    if (!(pwnd2 = pwnd->spwndOwner))
        return (!IsVSlick(pwnd)); // unowned -- do we want you?

    if (TestWF(pwnd2, WEFTOOLWINDOW))
        return(FALSE); // owned by a tool window -- we don't want

    return((FHas31TrayStyles(pwnd2) ? (IsVSlick(pwnd2)) : TRUE));
}


// ----------------------------------------------------------------------------
//
//  IsTrayWindow() -
//
//  TRUE if the window passes all the necessary checks -- making it a window
//  that should appear in the tray.
//
// ----------------------------------------------------------------------------
BOOL IsTrayWindow(PWND pwnd)
{
    if ((pwnd==NULL) || !(FDoTray() && (FCallHookTray() || FPostTray(pwnd->head.rpdesk))) ||
            !FTopLevel(pwnd))
        return(FALSE);

    // Check for WS_EX_APPWINDOW or WS_EX_TOOLWINDOW "overriding" bits
    if (TestWF(pwnd, WEFAPPWINDOW))
        return(TRUE);

    if (TestWF(pwnd, WEFTOOLWINDOW))
        return(FALSE);

    if (TestWF(pwnd, WEFNOACTIVATE)) {
        return FALSE;
    }

    if (TestWF(pwnd, WFWIN40COMPAT)) {
        if (pwnd->spwndOwner == NULL)
            return(TRUE);
        if (TestWF(pwnd->spwndOwner, WFWIN40COMPAT))
            return(FALSE);
        // if this window is owned by a 3.1 window, check it like a 3.1 window
    }

    if (!FHas31TrayStyles(pwnd))
        return(FALSE);

    return(Is31TrayWindow(pwnd));
}

/***************************************************************************\
* xxxSetTrayWindow
*
* History:
* 11-Dec-1996 adams     Created.
\***************************************************************************/

void xxxSetTrayWindow(PDESKTOP pdesk, PWND pwnd, PMONITOR pMonitor)
{
    HWND hwnd;

    CheckLock(pMonitor);

    if (pwnd == STW_SAME) {
        pwnd = pdesk->spwndTray;
        hwnd = PtoH(pwnd);
    } else {
        CheckLock(pwnd);
        hwnd = PtoH(pwnd);
        Lock(&(pdesk->spwndTray), pwnd);
    }

    if (!pMonitor) {
        if (pwnd) {
            pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
        } else {
            pMonitor = GetPrimaryMonitor();
        }
    }

    if ( FPostTray(pdesk)) {
        PostShellHookMessages(
                pMonitor->cFullScreen ?
                        HSHELL_RUDEAPPACTIVATED : HSHELL_WINDOWACTIVATED,
                (LPARAM) hwnd);
    }

    if ( FCallHookTray() ) {
        xxxCallHook(
                HSHELL_WINDOWACTIVATED,
                (WPARAM) hwnd,
                (pMonitor->cFullScreen ? 1 : 0),
                WH_SHELL);
    }
}



/***************************************************************************\
* xxxAddFullScreen
*
* Adds an app to the fullscreen list and moves the tray if it is
* the first fullscreen app.
*
* History:
* 27-Feb-1997 adams     Commented.
\***************************************************************************/

BOOL xxxAddFullScreen(PWND pwnd, PMONITOR pMonitor)
{
    BOOL    fYielded;

    PDESKTOP pdesk = pwnd->head.rpdesk;

    CheckLock(pwnd);
    CheckLock(pMonitor);

    if (pdesk == NULL)
        return FALSE;

    fYielded = FALSE;
    if (!TestWF(pwnd, WFFULLSCREEN) && FCallTray(pdesk))
    {
        SetWF(pwnd, WFFULLSCREEN);

        if (pMonitor->cFullScreen++ == 0) {
            xxxSetTrayWindow(pdesk, STW_SAME, pMonitor);
            fYielded = TRUE;
        }

        pwnd = pwnd->spwndOwner;
        if (    pwnd &&
                !TestWF(pwnd, WFCHILD) &&
                pwnd->rcWindow.right == 0 &&
                pwnd->rcWindow.left == 0 &&
                !TestWF(pwnd, WFVISIBLE)) {

            TL tlpwnd;
            ThreadLock(pwnd, &tlpwnd);
            if (xxxAddFullScreen(pwnd, pMonitor)) {
                fYielded = TRUE;
            }

            ThreadUnlock(&tlpwnd);
        }
    }

    return fYielded;
}



/***************************************************************************\
* xxxRemoveFullScreen
*
* Adds an app to the fullscreen list and moves the tray if there
* are no more fullscreen apps.
*
* History:
* 27-Feb-1997 adams     Commented.
\***************************************************************************/

BOOL xxxRemoveFullScreen(PWND pwnd, PMONITOR pMonitor)
{
    PDESKTOP pdesk = pwnd->head.rpdesk;
    BOOL    fYielded;

    CheckLock(pwnd);
    CheckLock(pMonitor);

    if (pdesk == NULL)
        return FALSE;

    fYielded = FALSE;
    if (TestWF(pwnd, WFFULLSCREEN) && FCallTray(pdesk)) {
        ClrWF(pwnd, WFFULLSCREEN);

        if (--pMonitor->cFullScreen == 0) {
            xxxSetTrayWindow(pdesk, STW_SAME, pMonitor);
            fYielded = TRUE;
        }

        /*
         * (adams): Remove this assertion temporarily while I work on
         * a fix for the problem.
         *
         * UserAssert(pMonitor->cFullScreen >= 0);
         */
    }

    return fYielded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\winhtky.c ===
/****************************** Module Header ******************************\
* Module Name: whotkeys.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the core functions of 3.1 window hotkey processing.
*
* History:
* 16-Apr-1992 JimA      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* HotKeyToWindow
*
* Scans the hotkey table and returns the pwnd corresponding to the
* given hot key.  Returns NULL if no such hot key in the list.  Looks at the
* current key state array.
*
* History:
* 04-15-92 JimA         Ported from Win3.1 sources.
\***************************************************************************/

PWND HotKeyToWindow(
    DWORD key)
{
    PHOTKEYSTRUCT phk;
    int ckeys;

    ckeys = gcHotKey;

    if (ckeys == 0)
        return 0;

    phk = gpHotKeyList;

    while (ckeys) {
        if (phk->key == key)
            return TestWF(phk->spwnd, WFVISIBLE) ? phk->spwnd : NULL;
        phk++;
        ckeys--;
    }

    return 0;
}


/***************************************************************************\
* HotKeyHelper
*
* Scans the hot key list and returns a pointer to the entry for the
* window.
*
* History:
* 04-15-92 JimA         Ported from Win3.1 sources.
\***************************************************************************/

PHOTKEYSTRUCT HotKeyHelper(
    PWND pwnd)
{
    PHOTKEYSTRUCT phk;
    int count;

    count = gcHotKey;

    if (gpHotKeyList == NULL)
        return 0;

    phk = gpHotKeyList;

    while (count) {
        if (phk->spwnd == pwnd)
            return phk;
        phk++;
        count--;
    }

    return 0;
}


/***************************************************************************\
* DWP_SetHotKey
*
* Set the hot key for this window.  Replace existing hot key, or if new
* key is NULL, delete the entry.  Return 2 if key already existed and
* was replaced, 1 if key did not exist and was set, 0 for
* failure, and -1 for invalid hot key.
*
* History:
* 15-Apr-1992 JimA      Ported from Win3.1 sources.
\***************************************************************************/

UINT DWP_SetHotKey(
    PWND  pwnd,
    DWORD dwKey)
{
    PHOTKEYSTRUCT phk;
    BOOL          fKeyExists = FALSE;
    PWND          pwndTemp;

    /*
     * Filter out invalid hotkeys
     */
    if (LOBYTE(dwKey) == VK_ESCAPE ||
        LOBYTE(dwKey) == VK_SPACE ||
        LOBYTE(dwKey) == VK_TAB ||
        LOBYTE(dwKey) == VK_PACKET) {

        return (UINT)-1;
    }

    /*
     * Don't allow hotkeys for children
     */
    if (TestWF(pwnd, WFCHILD))
        return 0;

    /*
     * Check if the hot key exists and is assigned to a different pwnd
     */
    if (dwKey != 0) {

        pwndTemp = HotKeyToWindow(dwKey);

        if ((pwndTemp != NULL) && (pwndTemp != pwnd))
            fKeyExists = TRUE;
    }

    /*
     * Get the hotkey assigned to the window, if any
     */
    if ((phk = HotKeyHelper(pwnd)) == NULL) {

        /*
         * Window doesn't exist in the hotkey list and key is being set
         * to zero, so just return.
         */
        if (dwKey == 0)
            return 1;

        /*
         * Allocate and point to a spot for the new hotkey
         */
        if (gcHotKey >= gcHotKeyAlloc) {

            if (gcHotKeyAlloc) {

                phk = (PHOTKEYSTRUCT)UserReAllocPool(
                        (HANDLE)gpHotKeyList,
                        gcHotKeyAlloc * sizeof(HOTKEYSTRUCT),
                        (gcHotKey + 1) * sizeof(HOTKEYSTRUCT), TAG_HOTKEY);

                if (phk != NULL) {

                    gpHotKeyList = phk;
                    phk = &gpHotKeyList[gcHotKey++];
                    gcHotKeyAlloc = gcHotKey;

                } else {

                    return 0;
                }

            } else {

                UserAssert(gpHotKeyList == NULL);
                UserAssert(gcHotKey == 0);

                phk = (PHOTKEYSTRUCT)UserAllocPool(sizeof(HOTKEYSTRUCT),
                                                   TAG_HOTKEY);

                if (phk != NULL) {

                    gpHotKeyList = phk;
                    gcHotKey = 1;
                    gcHotKeyAlloc = 1;

                } else {

                    return 0;
                }
            }

        } else {
            phk = &gpHotKeyList[gcHotKey++];
        }
    }

    if (dwKey == 0) {

        /*
         * The hotkey for this window is being deleted. Copy the last item
         * on the list on top of the one being deleted.
         */
        if (--gcHotKey) {

            Lock(&phk->spwnd, gpHotKeyList[gcHotKey].spwnd);
            Unlock(&gpHotKeyList[gcHotKey].spwnd);

            phk->key = gpHotKeyList[gcHotKey].key;
            phk = (PHOTKEYSTRUCT)UserReAllocPool((HANDLE)gpHotKeyList,
                gcHotKeyAlloc * sizeof(HOTKEYSTRUCT),
                gcHotKey * sizeof(HOTKEYSTRUCT), TAG_HOTKEY);

            if (phk != NULL) {
                gpHotKeyList = phk;
                gcHotKeyAlloc = gcHotKey;
            }

        } else {

            Unlock(&gpHotKeyList[gcHotKey].spwnd);
            UserFreePool((HANDLE)gpHotKeyList);
            gpHotKeyList = NULL;
            gcHotKeyAlloc = 0;
        }

    } else {

        /*
         * Add the window and key to the list
         */
        phk->spwnd = NULL;
        Lock(&phk->spwnd, pwnd);
        phk->key = dwKey;
    }

    return fKeyExists ? 2 : 1;
}

/***************************************************************************\
* DWP_GetHotKey
*
*
* History:
* 15-Apr-1992 JimA      Created.
\***************************************************************************/

UINT DWP_GetHotKey(
    PWND pwnd)
{
    PHOTKEYSTRUCT phk;

    if ((phk = HotKeyHelper(pwnd)) == NULL)
        return 0;

    return phk->key;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\userk.h ===
/****************************** Module Header ******************************\
* Module Name: userk.h
*
* Copyright (c) 1985 - 2001, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used exclusively by the User
* kernel-mode code.
*
* History:
* 04-28-91 DarrinM      Created from PROTO.H, MACRO.H, and STRTABLE.H
* 01-25-95 JimA         Prepped for kernel-mode
\***************************************************************************/

#ifndef _USERK_
#define _USERK_

#ifndef _WINBASE_
#include <wbasek.h>
#endif // _WINBASE_

#include <csrmsg.h>
#include <heap.h>

/*
 * BltColor() flags.
 */
#define BC_INVERT             0x00000001
#define BC_NOMIRROR           0x00000002

#define MIRRORED_HDC(hdc)     (GreGetLayout(hdc) & LAYOUT_RTL)

#define OEMRESOURCE 1

#define CCACHEDCAPTIONS 5

#define RIT_PROCESSINPUT  0x01
#define RIT_STOPINPUT     0x02

#define GETMOUSETRAILS()        (IsRemoteConnection() ? 0 : gMouseTrails)
#define MOUSE_TRAILS_FREQ       50

#include <winnls.h>
#include <wincon.h>

#include <winuser.h>
#include <winuserp.h>
#include <wowuserp.h>
#include "ntddvdeo.h"

#ifdef GENERIC_INPUT
#include <hidpddi.h>
#include <hidpi.h>
#include <hidclass.h>
#endif

#include <user.h>

PTHREADINFO _ptiCrit(VOID);
PTHREADINFO _ptiCritShared(VOID);

#if DBG
    #define PtiCurrent()  _ptiCrit()
    #define PtiCurrentShared() _ptiCritShared()
#else // DBG
    #define PtiCurrent()  (gptiCurrent)
    #define PtiCurrentShared() ((PTHREADINFO)(W32GetCurrentThread()))
#endif // DBG

extern HANDLE CsrApiPort;

#if DEBUGTAGS
    void CheckPtiSysPeek(int where, PQ pq, ULONG_PTR newIdSysPeek);
    void CheckSysLock(int where, PQ pq, PTHREADINFO pti);
#else // DEBUGTAGS
    #define CheckPtiSysPeek(where, pq, newIdSysPeek)
    #define CheckSysLock(where, pq, pti)
#endif // DEBUGTAGS

/*
 * ShutdownProcessRoutine return values
 */
#define SHUTDOWN_KNOWN_PROCESS   1
#define SHUTDOWN_UNKNOWN_PROCESS 2
#define SHUTDOWN_CANCEL          3

/*
 * Macros to get address of current thread and process information.
 */

#define PpiCurrent() \
    ((PPROCESSINFO)(W32GetCurrentProcess()))

#define PtiFromThread(Thread) ((PTHREADINFO)(PsGetThreadWin32Thread(Thread)))

#if DBG
    #define GetNestedCallsCounter() (PtiCurrentShared()->cNestedCalls)
#else // DBG
    #define GetNestedCallsCounter()
#endif // DBG

#define PpiFromProcess(Process)                                           \
        ((PPROCESSINFO)(PsGetProcessWin32Process(Process)))

#define GetCurrentProcessId() PsGetCurrentProcessId()

#define ISCSRSS() (PsGetCurrentProcess() == gpepCSRSS)

BOOL CSTPush(UINT uThreadID, PVOID pParam, HANDLE UniqueProcessId, BOOL bRemoteThreadStack);

void CSTCleanupStack(BOOL bRemoteThreadStack);

__inline BOOL InitCreateSystemThreadsMsg(PUSER_API_MSG pMsg, UINT ThreadID, PVOID pVoid, HANDLE UniqueProcessId, BOOL bRemoteThread)
{
    UserAssert(CsrApiPort != NULL);
    if (!CSTPush(ThreadID, pVoid, UniqueProcessId, bRemoteThread)) {
        return FALSE;
    }
    pMsg->h.u1.s1.DataLength  = (USHORT) (sizeof(USER_API_MSG) - sizeof( PORT_MESSAGE ));
    pMsg->h.u1.s1.TotalLength = (USHORT) (sizeof(USER_API_MSG));
    pMsg->h.u2.ZeroInit = 0;
    pMsg->CaptureBuffer = NULL;
    pMsg->ApiNumber = CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX, UserpCreateSystemThreads);
    pMsg->u.CreateSystemThreads.bRemoteThread = bRemoteThread;
    return TRUE;
}

NTSTATUS OpenEffectiveToken(
    PHANDLE phToken);

NTSTATUS GetProcessLuid(
    PETHREAD Thread OPTIONAL,
    PLUID LuidProcess);

BOOLEAN IsRestricted(
    PETHREAD Thread);

NTSTATUS CreateSystemThread(
    PKSTART_ROUTINE lpThreadAddress,
    PVOID pvContext,
    PHANDLE phThread);

NTSTATUS InitSystemThread(
    PUNICODE_STRING pstrThreadName);

#define INITCLIENTINFO(pti)                                     \
{                                                               \
    pti->pClientInfo->dwExpWinVer = pti->dwExpWinVer;           \
    pti->pClientInfo->dwTIFlags   = pti->TIF_flags;             \
                                                                \
    if (pti->spklActive) {                                      \
        pti->pClientInfo->CodePage = pti->spklActive->CodePage; \
        pti->pClientInfo->hKL = pti->spklActive->hkl;           \
    } else {                                                    \
        pti->pClientInfo->CodePage = CP_ACP;                    \
        pti->pClientInfo->hKL = 0;                              \
    }                                                           \
                                                                \
}

PKEVENT CreateKernelEvent(
    IN EVENT_TYPE Type,
    IN BOOLEAN State);

NTSTATUS ProtectHandle(
    IN HANDLE       Handle,
    IN POBJECT_TYPE pObjectType,
    IN BOOLEAN      Protect);

__inline VOID FreeKernelEvent(PVOID* pp)
{
    UserFreePool(*pp);
    *pp = NULL;
}


extern BOOL  gfSwitchInProgress;
extern PKEVENT gpevtVideoportCallout;

__inline VOID SetConsoleSwitchInProgress(BOOL fSwitchInProgress)
{
    gfSwitchInProgress = fSwitchInProgress;
    if (fSwitchInProgress) {
        KeResetEvent(gpevtVideoportCallout);
    } else {
        KeSetEvent(gpevtVideoportCallout, EVENT_INCREMENT, FALSE);
    }
}

/*
 * Object types exported from the kernel.
 */
extern POBJECT_TYPE *ExWindowStationObjectType;
extern POBJECT_TYPE *ExDesktopObjectType;
extern POBJECT_TYPE *ExEventObjectType;
extern POBJECT_TYPE *IoDriverObjectType;

#ifndef DWORD_ALIGN
#define DWORD_ALIGN(x) ((x+3)&~3)
#endif // !DWORD_ALIGN

/*
 * Private probing macros
 */

#if defined(_X86_)
#define DATAALIGN sizeof(BYTE)
#define CHARALIGN sizeof(BYTE)
#else
#define DATAALIGN sizeof(DWORD)
#define CHARALIGN sizeof(WCHAR)
#endif

#define ProbeForReadBuffer(Address, Count, Alignment) {                     \
    if ((ULONG)(Count) > (ULONG)(MAXULONG / sizeof(*(Address)))) {          \
        ExRaiseAccessViolation();                                           \
    }                                                                       \
    ProbeForRead(Address, (ULONG)(Count) * sizeof(*(Address)), Alignment);  \
}

#define ProbeForWriteBuffer(Address, Count, Alignment) {                    \
    if ((ULONG)(Count) > (ULONG)(MAXULONG / sizeof(*(Address)))) {          \
        ExRaiseAccessViolation();                                           \
    }                                                                       \
    ProbeForWrite(Address, (ULONG)(Count) * sizeof(*(Address)), Alignment); \
}

#define ProbeAndReadSize(Address)                         \
    (((Address) >= (SIZE * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile SIZE * const)MM_USER_PROBE_ADDRESS) : (*(volatile SIZE *)(Address)))


#define ProbeAndReadBlendfunction(Address)                         \
    (((Address) >= (BLENDFUNCTION * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile BLENDFUNCTION * const)MM_USER_PROBE_ADDRESS) : (*(volatile BLENDFUNCTION *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadPoint(
//     IN PPOINT Address
//     )
//
//--

#define ProbePoint(Address)                                \
    (((Address) >= (POINT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DWORD * const)MM_USER_PROBE_ADDRESS) : (*(volatile DWORD *)(Address)))

#define ProbeAndReadPoint(Address)                         \
    (((Address) >= (POINT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile POINT * const)MM_USER_PROBE_ADDRESS) : (*(volatile POINT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadRect(
//     IN PRECT Address
//     )
//
//--

#define ProbeRect(Address)                                \
    (((Address) >= (RECT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DWORD * const)MM_USER_PROBE_ADDRESS) : (*(volatile DWORD *)(Address)))

#define ProbeAndReadRect(Address)                         \
    (((Address) >= (RECT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile RECT * const)MM_USER_PROBE_ADDRESS) : (*(volatile RECT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadMessage(
//     IN PMSG Address
//     )
//
//--

#define ProbeMessage(Address)                            \
    (((Address) >= (MSG * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DWORD * const)MM_USER_PROBE_ADDRESS) : (*(volatile DWORD *)(Address)))

#define ProbeAndReadMessage(Address)                     \
    (((Address) >= (MSG * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MSG * const)MM_USER_PROBE_ADDRESS) : (*(volatile MSG *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadLargeString(
//     IN PLARGE_STRING Address
//     )
//
//--

#define ProbeAndReadLargeString(Address)                          \
    (((Address) >= (LARGE_STRING * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile LARGE_STRING * const)MM_USER_PROBE_ADDRESS) : (*(volatile LARGE_STRING *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadWindowPlacement(
//     IN PWINDOWPLACEMENT Address
//     )
//
//--

#define ProbeAndReadWindowPlacement(Address)                         \
    (((Address) >= (WINDOWPLACEMENT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile WINDOWPLACEMENT * const)MM_USER_PROBE_ADDRESS) : (*(volatile WINDOWPLACEMENT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadMenuItem(
//     IN PMENUITEMINFO Address
//     )
//
//--

#define ProbeAndReadMenuItem(Address)                             \
    (((Address) >= (MENUITEMINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MENUITEMINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile MENUITEMINFO *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadMenuInfo(
//     IN PMENUINFO Address
//     )
//
//--

#define ProbeAndReadMenuInfo(Address)                             \
    (((Address) >= (MENUINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MENUINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile MENUINFO *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadScrollInfo(
//     IN PSCROLLINFO Address
//     )
//
//--

#define ProbeAndReadScrollInfo(Address)                         \
    (((Address) >= (SCROLLINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile SCROLLINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile SCROLLINFO *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadPopupParams(
//     IN PTPMPARAMS Address
//     )
//
//--

#define ProbeAndReadPopupParams(Address)                       \
    (((Address) >= (TPMPARAMS * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile TPMPARAMS * const)MM_USER_PROBE_ADDRESS) : (*(volatile TPMPARAMS *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadPaintStruct(
//     IN PPAINTSTRUCT Address
//     )
//
//--

#define ProbeAndReadPaintStruct(Address)                         \
    (((Address) >= (PAINTSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile PAINTSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile PAINTSTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCreateStruct(
//     IN PCREATESTRUCTW Address
//     )
//
//--

#define ProbeAndReadCreateStruct(Address)                          \
    (((Address) >= (CREATESTRUCTW * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CREATESTRUCTW * const)MM_USER_PROBE_ADDRESS) : (*(volatile CREATESTRUCTW *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadMDICreateStruct(
//     IN PMDICREATESTRUCT Address
//     )
//
//--

#define ProbeAndReadMDICreateStruct(Address)                         \
    (((Address) >= (MDICREATESTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MDICREATESTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile MDICREATESTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCopyDataStruct(
//     IN PCOPYDATASTRUCT Address
//     )
//
//--

#define ProbeAndReadCopyDataStruct(Address)                         \
    (((Address) >= (COPYDATASTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile COPYDATASTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile COPYDATASTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCompareItemStruct(
//     IN PCOMPAREITEMSTRUCT Address
//     )
//
//--

#define ProbeAndReadCompareItemStruct(Address)                         \
    (((Address) >= (COMPAREITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile COMPAREITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile COMPAREITEMSTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadDeleteItemStruct(
//     IN PDELETEITEMSTRUCT Address
//     )
//
//--

#define ProbeAndReadDeleteItemStruct(Address)                         \
    (((Address) >= (DELETEITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DELETEITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile DELETEITEMSTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadHelp(
//     IN PHLP Address
//     )
//
//--

#define ProbeAndReadHelp(Address)                        \
    (((Address) >= (HLP * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile HLP * const)MM_USER_PROBE_ADDRESS) : (*(volatile HLP *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadHelpInfo(
//     IN PHELPINFO Address
//     )
//
//--

#define ProbeAndReadHelpInfo(Address)                         \
    (((Address) >= (HELPINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile HELPINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile HELPINFO *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadDrawItemStruct(
//     IN PDRAWITEMSTRUCT Address
//     )
//
//--

#define ProbeAndReadDrawItemStruct(Address)                         \
    (((Address) >= (DRAWITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DRAWITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile DRAWITEMSTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadHookInfo(
//     IN PDEBUGHOOKINFO Address
//     )
//
//--

#define ProbeAndReadHookInfo(Address)                              \
    (((Address) >= (DEBUGHOOKINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile DEBUGHOOKINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile DEBUGHOOKINFO *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCBTActivateStruct(
//     IN PCBTACTIVATESTRUCT Address
//     )
//
//--

#define ProbeAndReadCBTActivateStruct(Address)                         \
    (((Address) >= (CBTACTIVATESTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CBTACTIVATESTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile CBTACTIVATESTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadKbdHook(
//     IN PKBDHOOKSTRUCT Address
//     )
//
//--

#define ProbeAndReadKbdHook(Address)                               \
    (((Address) >= (KBDLLHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile KBDLLHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile KBDLLHOOKSTRUCT *)(Address)))
//++
//
// BOOLEAN
// ProbeAndReadMsllHook(
//     IN PMSLLHOOKSTRUCT Address
//     )
//
//--

#define ProbeAndReadMsllHook(Address)                               \
    (((Address) >= (MSLLHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MSLLHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile MSLLHOOKSTRUCT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadMouseHook(
//     IN PMOUSEHOOKSTRUCTEX Address
//     )
//
//--

#define ProbeAndReadMouseHook(Address)                               \
    (((Address) >= (MOUSEHOOKSTRUCTEX * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MOUSEHOOKSTRUCTEX * const)MM_USER_PROBE_ADDRESS) : (*(volatile MOUSEHOOKSTRUCTEX *)(Address)))


#ifdef REDIRECTION

//++
//
// BOOLEAN
// ProbeAndReadHTHook(
//     IN PHTHOOKSTRUCT Address
//     )
//
//--

#define ProbeAndReadHTHook(Address)                               \
    (((Address) >= (HTHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile HTHOOKSTRUCT * const)MM_USER_PROBE_ADDRESS) : (*(volatile HTHOOKSTRUCT *)(Address)))

#endif // REDIRECTION

//++
//
// BOOLEAN
// ProbeAndReadCBTCreateStruct(
//     IN PCBT_CREATEWND Address
//     )
//
//--

#define ProbeAndReadCBTCreateStruct(Address)                       \
    (((Address) >= (CBT_CREATEWND * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CBT_CREATEWND * const)MM_USER_PROBE_ADDRESS) : (*(volatile CBT_CREATEWND *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadTrackMouseEvent(
//     IN LPTRACKMOUSEEVENT Address
//     )
//
//--

#define ProbeAndReadTrackMouseEvent(Address) \
    (((Address) >= (TRACKMOUSEEVENT * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile TRACKMOUSEEVENT * const)MM_USER_PROBE_ADDRESS) : (*(volatile TRACKMOUSEEVENT *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadWindowPos(
//     IN PWINDOWPOS Address
//     )
//
//--

#define ProbeAndReadWindowPos(Address) \
    (((Address) >= (WINDOWPOS * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile WINDOWPOS * const)MM_USER_PROBE_ADDRESS) : (*(volatile WINDOWPOS *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCursorFind(
//     IN PCURSORFIND Address
//     )
//
//--

#define ProbeAndReadCursorFind(Address) \
    (((Address) >= (CURSORFIND * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CURSORFIND * const)MM_USER_PROBE_ADDRESS) : (*(volatile CURSORFIND *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadSetClipBData(
//     IN PSETCLIPBDATA Address
//     )
//
//--

#define ProbeAndReadSetClipBData(Address) \
    (((Address) >= (SETCLIPBDATA * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile SETCLIPBDATA * const)MM_USER_PROBE_ADDRESS) : (*(volatile SETCLIPBDATA *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadBroadcastSystemMsgParams(
//     IN LPBROADCASTSYSTEMMSGPARAMS Address
//     )
//
//--

#define ProbeAndReadBroadcastSystemMsgParams(Address) \
    (((Address) >= (BROADCASTSYSTEMMSGPARAMS * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile BROADCASTSYSTEMMSGPARAMS * const)MM_USER_PROBE_ADDRESS) : (*(volatile BROADCASTSYSTEMMSGPARAMS *)(Address)))

//++
//
// BOOLEAN
// ProbeAndReadCursorData(
//     IN PCURSORDATA Address
//     )
//
//--

#define ProbeAndReadCursorData(Address) \
    (((Address) >= (CURSORDATA * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile CURSORDATA * const)MM_USER_PROBE_ADDRESS) : (*(volatile CURSORDATA *)(Address)))

//++
//
// BOOLEAN
// ProbeForReadUnicodeStringBuffer(
//     IN UNICODE_STRING String
//     )
//
//--

#if defined(_X86_)
#define ProbeForReadUnicodeStringBuffer(String)                                                          \
    if (((ULONG_PTR)((String).Buffer) & (sizeof(BYTE) - 1)) != 0) {                                   \
        ExRaiseDatatypeMisalignment();                                                            \
    } else if ((((ULONG_PTR)((String).Buffer) + ((String).Length) + sizeof(UNICODE_NULL)) < (ULONG_PTR)((String).Buffer)) ||     \
               (((ULONG_PTR)((String).Buffer) + ((String).Length) + sizeof(UNICODE_NULL)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) { \
        ExRaiseAccessViolation();                                                                 \
    } else if (((String).Length) > ((String).MaximumLength)) {                                    \
        ExRaiseAccessViolation();                                                                 \
    }
#else
#define ProbeForReadUnicodeStringBuffer(String)                                                          \
    if (((ULONG_PTR)((String).Buffer) & (sizeof(WCHAR) - 1)) != 0) {                                  \
        ExRaiseDatatypeMisalignment();                                                            \
    } else if ((((ULONG_PTR)((String).Buffer) + ((String).Length) + sizeof(UNICODE_NULL)) < (ULONG_PTR)((String).Buffer)) ||     \
               (((ULONG_PTR)((String).Buffer) + ((String).Length) + sizeof(UNICODE_NULL)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) { \
        ExRaiseAccessViolation();                                                                 \
    } else if (((String).Length) > ((String).MaximumLength)) {                                    \
        ExRaiseAccessViolation();                                                                 \
    }
#endif

#if defined(_X86_)
#define ProbeForReadUnicodeStringFullBuffer(String)                                                          \
    if (((ULONG_PTR)((String).Buffer) & (sizeof(BYTE) - 1)) != 0) {                                   \
        ExRaiseDatatypeMisalignment();                                                            \
    } else if ((((ULONG_PTR)((String).Buffer) + ((String).MaximumLength)) < (ULONG_PTR)((String).Buffer)) ||     \
               (((ULONG_PTR)((String).Buffer) + ((String).MaximumLength)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) { \
        ExRaiseAccessViolation();                                                                 \
    } else if (((String).Length) > ((String).MaximumLength)) {                                    \
        ExRaiseAccessViolation();                                                                 \
    }
#else
#define ProbeForReadUnicodeStringFullBuffer(String)                                                          \
    if (((ULONG_PTR)((String).Buffer) & (sizeof(WCHAR) - 1)) != 0) {                                  \
        ExRaiseDatatypeMisalignment();                                                            \
    } else if ((((ULONG_PTR)((String).Buffer) + ((String).MaximumLength)) < (ULONG_PTR)((String).Buffer)) ||     \
               (((ULONG_PTR)((String).Buffer) + ((String).MaximumLength)) > (ULONG_PTR)MM_USER_PROBE_ADDRESS)) { \
        ExRaiseAccessViolation();                                                                 \
    } else if (((String).Length) > ((String).MaximumLength)) {                                    \
        ExRaiseAccessViolation();                                                                 \
    }
#endif

//++
//
// BOOLEAN
// ProbeForReadUnicodeStringBufferOrId(
//     IN UNICODE_STRING String
//     )
//
//--

#define ProbeForReadUnicodeStringBufferOrId(String) \
    if (IS_PTR((String).Buffer)) {           \
        ProbeForReadUnicodeStringBuffer(String);    \
    }

    //++
    //
    // BOOLEAN
    // ProbeAndReadCandidateForm(
    //     IN PCANDIDATEFORM Address
    //     )
    //
    //--

    #define ProbeAndReadCandidateForm(Address) \
        (((Address) >= (CANDIDATEFORM * const)MM_USER_PROBE_ADDRESS) ? \
            (*(volatile CANDIDATEFORM * const)MM_USER_PROBE_ADDRESS) : (*(volatile CANDIDATEFORM *)(Address)))

    //++
    //
    // BOOLEAN
    // ProbeAndReadCompositionForm(
    //     IN PCANDIDATEFORM Address
    //     )
    //
    //--

    #define ProbeAndReadCompositionForm(Address) \
        (((Address) >= (COMPOSITIONFORM * const)MM_USER_PROBE_ADDRESS) ? \
            (*(volatile COMPOSITIONFORM * const)MM_USER_PROBE_ADDRESS) : (*(volatile COMPOSITIONFORM *)(Address)))

    //++
    //
    // BOOLEAN
    // ProbeAndReadLogFontW(
    //     IN PLOGFONTA Address
    //     )
    //
    //--

    #define ProbeAndReadLogFontW(Address) \
        (((Address) >= (LOGFONTW * const)MM_USER_PROBE_ADDRESS) ? \
            (*(volatile LOGFONTW * const)MM_USER_PROBE_ADDRESS) : (*(volatile LOGFONTW *)(Address)))


//++
//
// VOID
// ProbeForWritePoint(
//     IN PPOINT Address
//     )
//
//--

#define ProbeForWritePoint(Address) {                                        \
    if ((Address) >= (POINT * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile POINT *)(Address) = *(volatile POINT *)(Address);             \
}

//++
//
// VOID
// ProbeForWriteRect(
//     IN PRECT Address
//     )
//
//--

#define ProbeForWriteRect(Address) {                                         \
    if ((Address) >= (RECT * const)MM_USER_PROBE_ADDRESS) {                  \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile RECT *)(Address) = *(volatile RECT *)(Address);               \
}

//++
//
// VOID
// ProbeForWriteMessage(
//     IN PMSG Address
//     )
//
//--

#define ProbeForWriteMessage(Address) {                                      \
    if ((Address) >= (MSG * const)MM_USER_PROBE_ADDRESS) {                   \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile MSG *)(Address) = *(volatile MSG *)(Address);                 \
}

//++
//
// VOID
// ProbeForWritePaintStruct(
//     IN PPAINTSTRUCT Address
//     )
//
//--

#define ProbeForWritePaintStruct(Address) {                                  \
    if ((Address) >= (PAINTSTRUCT * const)MM_USER_PROBE_ADDRESS) {           \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile PAINTSTRUCT *)(Address) = *(volatile PAINTSTRUCT *)(Address); \
}

//++
//
// VOID
// ProbeForWriteDropStruct(
//     IN PDROPSTRUCT Address
//     )
//
//--

#define ProbeForWriteDropStruct(Address) {                                   \
    if ((Address) >= (DROPSTRUCT * const)MM_USER_PROBE_ADDRESS) {            \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile DROPSTRUCT *)(Address) = *(volatile DROPSTRUCT *)(Address);   \
}

//++
//
// VOID
// ProbeForWriteScrollInfo(
//     IN PSCROLLINFO Address
//     )
//
//--

#define ProbeForWriteScrollInfo(Address) {                                   \
    if ((Address) >= (SCROLLINFO * const)MM_USER_PROBE_ADDRESS) {            \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile SCROLLINFO *)(Address) = *(volatile SCROLLINFO *)(Address);   \
}

//++
//
// VOID
// ProbeForWriteStyleStruct(
//     IN PSTYLESTRUCT Address
//     )
//
//--

#define ProbeForWriteStyleStruct(Address) {                                  \
    if ((Address) >= (STYLESTRUCT * const)MM_USER_PROBE_ADDRESS) {           \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile STYLESTRUCT *)(Address) = *(volatile STYLESTRUCT *)(Address); \
}

//++
//
// VOID
// ProbeForWriteMeasureItemStruct(
//     IN PMEASUREITEMSTRUCT Address
//     )
//
//--

#define ProbeForWriteMeasureItemStruct(Address) {                                       \
    if ((Address) >= (MEASUREITEMSTRUCT * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                             \
    }                                                                                   \
                                                                                        \
    *(volatile MEASUREITEMSTRUCT *)(Address) = *(volatile MEASUREITEMSTRUCT *)(Address);\
}

//++
//
// VOID
// ProbeForWriteCreateStruct(
//     IN PCREATESTRUCTW Address
//     )
//
//--

#define ProbeForWriteCreateStruct(Address) {                                    \
    if ((Address) >= (CREATESTRUCTW * const)MM_USER_PROBE_ADDRESS) {            \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                     \
    }                                                                           \
                                                                                \
    *(volatile CREATESTRUCTW *)(Address) = *(volatile CREATESTRUCTW *)(Address);\
}

//++
//
// VOID
// ProbeForWriteEvent(
//     IN PEVENTMSGMSG Address
//     )
//
//--

#define ProbeForWriteEvent(Address) {                                        \
    if ((Address) >= (EVENTMSG * const)MM_USER_PROBE_ADDRESS) {              \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile EVENTMSG *)(Address) = *(volatile EVENTMSG *)(Address);       \
}

//++
//
// VOID
// ProbeForWriteWindowPlacement(
//     IN PWINDOWPLACEMENT Address
//     )
//
//--

#define ProbeForWriteWindowPlacement(Address) {                                     \
    if ((Address) >= (WINDOWPLACEMENT * const)MM_USER_PROBE_ADDRESS) {              \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile WINDOWPLACEMENT *)(Address) = *(volatile WINDOWPLACEMENT *)(Address);\
}

//++
//
// VOID
// ProbeForWriteGetClipData(
//     IN PGETCLIPBDATA Address
//     )
//
//--

#define ProbeForWriteGetClipData(Address) {                                   \
    if ((Address) >= (GETCLIPBDATA * const)MM_USER_PROBE_ADDRESS) {           \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                   \
    }                                                                         \
                                                                              \
    *(volatile GETCLIPBDATA *)(Address) = *(volatile GETCLIPBDATA *)(Address);\
}

//++
//
// VOUD
// ProbeForWriteBroadcastSystemMsgParams(
//     IN LPBROADCASTSYSTEMMSGPARAMS Address
//     )
//
//--

#define ProbeForWriteBroadcastSystemMsgParams(Address) {                                                \
    if ((Address) >= (BROADCASTSYSTEMMSGPARAMS * const)MM_USER_PROBE_ADDRESS) {                         \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                                             \
    }                                                                                                   \
                                                                                                        \
    *(volatile BROADCASTSYSTEMMSGPARAMS *)(Address) = *(volatile BROADCASTSYSTEMMSGPARAMS *)(Address);  \
}

//++
//
// VOID
// ProbeForWriteMDINextMenu(
//     IN PMDINEXTMENU Address
//     )
//
//--

#define ProbeForWriteMDINextMenu(Address) {                                  \
    if ((Address) >= (MDINEXTMENU * const)MM_USER_PROBE_ADDRESS) {           \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                  \
    }                                                                        \
                                                                             \
    *(volatile MDINEXTMENU *)(Address) = *(volatile MDINEXTMENU *)(Address); \
}

//++
//
// VOID
// ProbeForWritePoint5(
//     IN PPOINT5 Address
//     )
//
//--

#define ProbeForWritePoint5(Address) {                                     \
    if ((Address) >= (POINT5 * const)MM_USER_PROBE_ADDRESS) {              \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile POINT5 *)(Address) = *(volatile POINT5 *)(Address);\
}

//++
//
// VOID
// ProbeForWriteNCCalcSize(
//     IN PNCCALCSIZE_PARAMS Address
//     )
//
//--

#define ProbeForWriteNCCalcSize(Address) {                                     \
    if ((Address) >= (NCCALCSIZE_PARAMS * const)MM_USER_PROBE_ADDRESS) {              \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile NCCALCSIZE_PARAMS *)(Address) = *(volatile NCCALCSIZE_PARAMS *)(Address);\
}

//++
//
// VOID
// ProbeForWriteWindowPos(
//     IN PWINDOWPOS Address
//     )
//
//--

#define ProbeForWriteWindowPos(Address) {                                     \
    if ((Address) >= (WINDOWPOS * const)MM_USER_PROBE_ADDRESS) {              \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile WINDOWPOS *)(Address) = *(volatile WINDOWPOS *)(Address);\
}

#define ProbeForWriteComboBoxInfo(Address) {                                        \
    if ((Address) >= (COMBOBOXINFO * const)MM_USER_PROBE_ADDRESS) {                 \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile COMBOBOXINFO *)(Address) = *(volatile COMBOBOXINFO *)(Address);      \
}

#define ProbeForWriteScrollBarInfo(Address) {                                       \
    if ((Address) >= (SCROLLBARINFO * const)MM_USER_PROBE_ADDRESS) {                \
        *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
    }                                                                               \
                                                                                    \
    *(volatile SCROLLBARINFO *)(Address) = *(volatile SCROLLBARINFO *)(Address);    \
}


    //++
    //
    // VOID
    // ProbeForWriteCandidateForm(
    //     IN PCANDIDATEFORM Address
    //     )
    //
    //--

    #define ProbeForWriteCandidateForm(Address) {                                     \
        if ((Address) >= (CANDIDATEFORM * const)MM_USER_PROBE_ADDRESS) {              \
            *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                       \
        }                                                                             \
                                                                                      \
        *(volatile CANDIDATEFORM *)(Address) = *(volatile CANDIDATEFORM *)(Address);  \
    }

    //++
    //
    // VOID
    // ProbeForWriteCompositionForm(
    //     IN PCOMPOSITIONFORM Address
    //     )
    //
    //--

    #define ProbeForWriteCompositionForm(Address) {                                     \
        if ((Address) >= (COMPOSITIONFORM * const)MM_USER_PROBE_ADDRESS) {              \
            *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                         \
        }                                                                               \
                                                                                        \
        *(volatile COMPOSITIONFORM *)(Address) = *(volatile COMPOSITIONFORM *)(Address);\
    }

    //++
    //
    // VOID
    // ProbeForWriteLogFontW(
    //     IN PLOGFONTW Address
    //     )
    //
    //--

    #define ProbeForWriteLogFontW(Address) {                                   \
        if ((Address) >= (LOGFONTW * const)MM_USER_PROBE_ADDRESS) {            \
            *(volatile ULONG * const)MM_USER_PROBE_ADDRESS = 0;                \
        }                                                                      \
                                                                               \
        *(volatile LOGFONTW *)(Address) = *(volatile LOGFONTW *)(Address);     \
    }

//++
//
// VOID
// ProbeForWriteReconvertString(IN PRECONVERTSTRING Address)
//
//--

#define ProbeForWriteReconvertString(Address) { \
    if ((Address) >= (RECONVERTSTRING* const)MM_USER_PROBE_ADDRESS) {           \
        *(volatile ULONG* const)MM_USER_PROBE_ADDRESS = 0;                      \
    }                                                                           \
                                                                                \
    *(volatile RECONVERTSTRING*)(Address) = *(volatile RECONVERTSTRING*)(Address); \
    *((volatile BYTE*)(Address) + (Address)->dwSize) = *((volatile BYTE*)(Address) + (Address)->dwSize); \
}

#define ProbeForReadReconvertString(pReconv) \
    ProbeForRead((pReconv), (pReconv)->dwSize, 1)


//++
//
// VOID
// ProbeForWriteImeCharPosition(IN LPPrivateIMECHARPOSITION Address)
//
//--

#define ProbeForWriteImeCharPosition(Address) { \
    if ((Address) >= (PrivateIMECHARPOSITION* const)MM_USER_PROBE_ADDRESS) {    \
        *(volatile ULONG* const)MM_USER_PROBE_ADDRESS = 0;                      \
    }                                                                           \
                                                                                \
    *(volatile PrivateIMECHARPOSITION*)(Address) = *(volatile PrivateIMECHARPOSITION*)(Address); \
}



//++
//
// VOID
// ProbeAndReadMenuGetObjectInfo(
//     IN PMENUGETOBJECTINFO Address
//     )
//
//--

#define ProbeAndReadMenuGetObjectInfo(Address) \
    (((Address) >= (MENUGETOBJECTINFO * const)MM_USER_PROBE_ADDRESS) ? \
        (*(volatile MENUGETOBJECTINFO * const)MM_USER_PROBE_ADDRESS) : (*(volatile MENUGETOBJECTINFO *)(Address)))


/*
 * This macro makes sure an object is thread locked. DEBUG only.
 */
#if DBG
    VOID CheckLock(PVOID pobj);
#else // DBG
    #define CheckLock(p)
#endif // DBG

/*
 * Debug macros
 */
#if DBG

    #define TRACE_INIT(str)    { if (TraceInitialization > 0) {  KdPrint(str); }}
    #define TRACE_SWITCH(str)  { if (TraceFullscreenSwitch > 0)  {  KdPrint(str); }}

    extern PCSZ apszSimpleCallNames[];

    #define TRACE(s)            TAGMSG2(DBGTAG_StubReturn, "%s, retval = %x", (s), retval)
    #define TRACEVOID(s)        TAGMSG1(DBGTAG_StubReturn, "%s", (s))

    #define TRACETHUNK(t)                                                       \
                TAGMSG3(DBGTAG_StubThunk,                                       \
                        "Thunk %s, %s(%s)",                                     \
                        (t),                                                    \
                        (xpfnProc >= FNID_START && xpfnProc <= FNID_END ?       \
                                gapszFNID[xpfnProc - FNID_START] : "Unknown"),  \
                        (msg >= WM_USER ? "WM_USER" : gapszMessage[msg]))

    #define TRACECALLBACK(s)    TAGMSG2(DBGTAG_StubCallback, "%s, retval = %x", (s), retval)

    #define TRACECALLBACKMSG(s)                                                         \
                TAGMSG4(DBGTAG_StubCallback,                                            \
                        "Callback %s, %s(%s), retval = %x",                             \
                        (s),                                                            \
                        (xpfnProc >= (PROC)FNID_START && xpfnProc <= (PROC)FNID_END ?   \
                            gapszFNID[(ULONG_PTR)xpfnProc - FNID_START] : "Unknown"),    \
                        (msg >= WM_USER ? "WM_USER" : gapszMessage[msg]),               \
                        retval)
#else // DBG

    #define TRACE_INIT(str) {}
    #define TRACE_SWITCH(str) {}
    #define TRACE(s)
    #define TRACEVOID(s)
    #define TRACETHUNK(t)
    #define TRACECALLBACK(t)
    #define TRACECALLBACKMSG(t)

#endif // DBG

/*
 * Statistics for performance counter
 */

typedef struct tagPERFINFO {
    LONG               lCount;
    LONG               lMaxCount;
    LONG               lTotalCount;
    SIZE_T             lSize;
} PERFHANDLEINFO, *PPERFHANDLEINFO;

typedef struct _HANDLEPAGE {
    ULONG_PTR iheLimit;    /* first handle index past the end of the page */
    ULONG_PTR iheFreeEven; /* first even free handle in the page -- window objects */
    ULONG_PTR iheFreeOdd;  /* first even odd handle in the page */
} HANDLEPAGE, *PHANDLEPAGE;


#if DBG
VOID  HMCleanUpHandleTable(VOID);
DWORD DbgDumpHandleTable(VOID);
#endif

BOOL     HMInitHandleTable(PVOID pBase);
PVOID    HMAllocObject(PTHREADINFO pti, PDESKTOP pdesk, BYTE btype, DWORD size);
BOOL     HMFreeObject(PVOID pobj);
BOOL     HMMarkObjectDestroy(PVOID pobj);
BOOL     HMDestroyObject(PVOID pobj);
PVOID FASTCALL HMAssignmentLock(PVOID *ppobj, PVOID pobj);
PVOID FASTCALL HMAssignmentUnlock(PVOID *ppobj);
NTSTATUS HMGetStats(HANDLE hProcess, int iPidType, PVOID pResults, UINT cjResultSize);
HANDLE   KernelPtoH(PVOID pObj);
void     HMDestroyUnlockedObject(PHE phe);

void     HMCleanupGrantedHandle(HANDLE h);

/*
 * Validation, handle mapping, etc.
 */
#define RevalidateHwnd(hwnd)   HMValidateHandleNoSecure(hwnd, TYPE_WINDOW)
#define RevalidateCatHwnd(hwnd)   HMValidateCatHandleNoSecure(hwnd, TYPE_WINDOW)

#define HtoPq(h)    ((PVOID)HMObjectFromHandle(h))
#define HtoPqCat(h)    ((PVOID)HMCatObjectFromHandle(h))
#define HtoP(h)     ((PVOID)HMObjectFromHandle(h))
#define HtoPCat(h)     ((PVOID)HMCatObjectFromHandle(h))
#define PW(hwnd)    ((PWND)HtoP(hwnd))
#define PWCat(hwnd)    ((PWND)HtoPCat(hwnd))
#define TID(pti)    HandleToUlong((pti) == NULL ? NULL : (PsGetThreadId((pti)->pEThread)))
#define TIDq(pti)   HandleToUlong(PsGetThreadId((pti)->pEThread))

/*
 * Assignment lock macro -> used for locking objects embedded in structures
 * and globals. Threadlocks used for locking objects across callbacks.
 */
#define Lock(ppobj, pobj) HMAssignmentLock((PVOID *)ppobj, (PVOID)pobj)
#define Unlock(ppobj)     HMAssignmentUnlock((PVOID *)ppobj)

PVOID HMUnlockObjectInternal(PVOID pobj);

#define HMUnlockObject(pobj) \
    ( (--((PHEAD)pobj)->cLockObj == 0) ? HMUnlockObjectInternal(pobj) : pobj )

VOID HMChangeOwnerThread(PVOID pobj, PTHREADINFO pti);
VOID HMChangeOwnerPheProcess(PHE phe, PTHREADINFO pti);
#define HMChangeOwnerProcess(pobj, pti) HMChangeOwnerPheProcess(HMPheFromObject(pobj), pti)

#if DBG
    VOID  HMLockObject(PVOID pobj);
    BOOL  HMRelocateLockRecord(PVOID ppobjOld, LONG_PTR cbDelta);
#else // DBG
    #define HMLockObject(p)     (((PHEAD)p)->cLockObj++)
#endif // DBG

#if DBG
    VOID ThreadLock(PVOID pobj, PTL ptl);
#else // DBG
    #define ThreadLock(_pobj_, _ptl_)          \
    {                                          \
        PTHREADINFO _pti_;                     \
        PVOID __pobj_ = (_pobj_);              \
                                               \
        _pti_ = PtiCurrent();                  \
        (_ptl_)->next = _pti_->ptl;            \
        _pti_->ptl = (_ptl_);                  \
        (_ptl_)->pobj = __pobj_;              \
        if (__pobj_ != NULL) {                \
            HMLockObject(__pobj_);            \
        }                                      \
    }
#endif // DBG

#if DBG
    #define ThreadLockAlways(_pobj_, _ptl_)    \
    {                                          \
        PVOID __pobj_ = (_pobj_);              \
        UserAssert(__pobj_ != NULL);          \
        ThreadLock(__pobj_, _ptl_);             \
    }
#else // DBG
    #define ThreadLockAlways(_pobj_, _ptl_)    \
    {                                          \
        PTHREADINFO _pti_;                     \
        PVOID __pobj_ = (_pobj_);              \
                                               \
        _pti_ = PtiCurrent();                  \
        (_ptl_)->next = _pti_->ptl;            \
        _pti_->ptl = (_ptl_);                  \
        (_ptl_)->pobj = __pobj_;              \
        HMLockObject(__pobj_);                \
    }
#endif // DBG

#if DBG
    #define ThreadLockNever(_ptl_)             \
    {                                          \
        ThreadLock(NULL, _ptl_);               \
    }
#else // DBG
    #define ThreadLockNever(_ptl_)             \
    {                                          \
        PTHREADINFO _pti_;                     \
                                               \
        _pti_ = PtiCurrent();                  \
        (_ptl_)->next = _pti_->ptl;            \
        _pti_->ptl = (_ptl_);                  \
        (_ptl_)->pobj = NULL;                  \
    }
#endif // DBG

#if DBG
    #define ThreadLockAlwaysWithPti(_pti_, _pobj_, _ptl_)  \
    {                                          \
        PVOID __pobj_ = (_pobj_);              \
        UserAssert(_pti_ == PtiCurrentShared());     \
        UserAssert(__pobj_ != NULL);          \
        ThreadLock(__pobj_, _ptl_);             \
    }
#else // DBG
    #define ThreadLockAlwaysWithPti(_pti_, _pobj_, _ptl_)  \
    {                                          \
        PVOID __pobj_ = (_pobj_);              \
        (_ptl_)->next = _pti_->ptl;            \
        _pti_->ptl = (_ptl_);                  \
        (_ptl_)->pobj = __pobj_;              \
        HMLockObject(__pobj_);                \
    }
#endif // DBG

#if DBG
    #define ThreadLockNeverWithPti(_pti_, _ptl_)    \
    {                                               \
        UserAssert(_pti_ == PtiCurrentShared());    \
        ThreadLock(NULL, _ptl_);                    \
    }
#else // DBG
    #define ThreadLockNeverWithPti(_pti_, _ptl_)    \
    {                                               \
        (_ptl_)->next = _pti_->ptl;                 \
        _pti_->ptl = (_ptl_);                       \
        (_ptl_)->pobj = NULL;                       \
    }
#endif // DBG

#if DBG
    #define ThreadLockWithPti(_pti_, _pobj_, _ptl_) \
    {                                               \
        PVOID __pobj_ = (_pobj_);              \
        UserAssert(_pti_ == PtiCurrentShared());    \
        ThreadLock(__pobj_, _ptl_);                  \
    }
#else // DBG
    #define ThreadLockWithPti(_pti_, _pobj_, _ptl_) \
    {                                               \
        PVOID __pobj_ = (_pobj_);              \
        (_ptl_)->next = _pti_->ptl;                 \
        _pti_->ptl = (_ptl_);                       \
        (_ptl_)->pobj = __pobj_;                   \
        if (__pobj_ != NULL) {                     \
            HMLockObject(__pobj_);                 \
        }                                           \
    }
#endif // DBG

#if DBG
    PVOID ThreadLockExchange(PVOID pobj, PTL ptl);
#else // DBG
    __inline PVOID ThreadLockExchange(PVOID pobj, PTL ptl)
    {
        PVOID   pobjOld;

        pobjOld = ptl->pobj;
        ptl->pobj = pobj;
        if (pobj) {
            HMLockObject(pobj);
        }

        if (pobjOld) {
            pobjOld = HMUnlockObject((PHEAD)pobjOld);
        }

        return pobjOld;
    }
#endif // DBG

#if DBG
    #define ThreadLockExchangeAlways(_pobj_, _ptl_)    \
    {                                                  \
        PVOID __pobj_ = (_pobj_);              \
        UserAssert(__pobj_ != NULL);                  \
        ThreadLockExchange(__pobj_, _ptl_);             \
    }
#else // DBG
    __inline PVOID ThreadLockExchangeAlways(PVOID pobj, PTL ptl)
    {
        PVOID   pobjOld;

        pobjOld = ptl->pobj;
        ptl->pobj = pobj;
        HMLockObject(pobj);
        if (pobjOld) {
            pobjOld = HMUnlockObject((PHEAD)pobjOld);
        }

        return pobjOld;
    }
#endif // DBG

#if DBG
    PVOID ThreadUnlock1(PTL ptl);
    #define ThreadUnlock(ptl) ThreadUnlock1(ptl)
#else // DBG
    PVOID ThreadUnlock1(VOID);
    #define ThreadUnlock(ptl) ThreadUnlock1()
#endif // DBG

/*
 * Define this only if you want to track down lock/unlock mismatches
 * for desktop objects.
 */
#if DBG
// #define LOGDESKTOPLOCKS
#endif // DBG

#ifdef LOGDESKTOPLOCKS

/*
 * this is the structure used by the desktop logging stuff
 */
typedef struct tagLogD {
    WORD   tag;         // tag
    WORD   type;        // lock | unlock
    ULONG_PTR extra;    // extra information to identify the lock/unlock
    PVOID  trace[6];    // stack trace
} LogD, *PLogD;

/*
 * Tags for LOCK/UNLOCK REFERENCE/DEREFERENCE calls for
 * desktop objects
 */

#define LDU_CLS_DESKPARENT1                 1
#define LDL_CLS_DESKPARENT1                 2

#define LDU_CLS_DESKPARENT2                 3
#define LDL_CLS_DESKPARENT2                 5

#define LDU_FN_DESTROYCLASS                 6
#define LDL_FN_DESTROYCLASS                 7

#define LDU_FN_DESTROYMENU                  8
#define LDL_FN_DESTROYMENU                  9

#define LDU_FN_DESTROYTHREADINFO            10
#define LDL_FN_DESTROYTHREADINFO            11

#define LDU_FN_DESTROYWINDOWSTATION         12
#define LDL_FN_DESTROYWINDOWSTATION         13

#define LDU_DESKDISCONNECT                  14
#define LDL_DESKDISCONNECT                  15

#define LDU_DESK_DESKNEXT                   16
#define LDL_DESK_DESKNEXT1                  17

#define LDU_OBJ_DESK                        18
#define LDL_OBJ_DESK                        19
#define LDL_MOTHERDESK_DESK1                20

#define LDL_PTI_DESK                        21
#define LDL_DT_DESK                         23

#define LDU_PTI_DESK                        24

#define LDU_PPI_DESKSTARTUP1                26
#define LDU_PPI_DESKSTARTUP2                27
#define LDU_PPI_DESKSTARTUP3                28
#define LDL_PPI_DESKSTARTUP1                29
#define LDL_PPI_DESKSTARTUP2                30

#define LDU_DESKLOGON                       31
#define LDL_DESKLOGON                       32

#define LDUT_FN_FREEWINDOW                  33
#define LDLT_FN_FREEWINDOW                  34

#define LDUT_FN_DESKTOPTHREAD_DESK          35
#define LDLT_FN_DESKTOPTHREAD_DESK          36

#define LDUT_FN_DESKTOPTHREAD_DESKTEMP      37
#define LDLT_FN_DESKTOPTHREAD_DESKTEMP      38

#define LDUT_FN_SETDESKTOP                  39
#define LDLT_FN_SETDESKTOP                  40

#define LDUT_FN_NTUSERSWITCHDESKTOP         41
#define LDLT_FN_NTUSERSWITCHDESKTOP         42

#define LDUT_FN_SENDMESSAGEBSM1             43
#define LDUT_FN_SENDMESSAGEBSM2             44
#define LDLT_FN_SENDMESSAGEBSM              45

#define LDUT_FN_SYSTEMBROADCASTMESSAGE      46
#define LDLT_FN_SYSTEMBROADCASTMESSAGE      47

#define LDUT_FN_CTXREDRAWSCREEN             48
#define LDLT_FN_CTXREDRAWSCREEN             49

#define LDUT_FN_CTXDISABLESCREEN            50
#define LDLT_FN_CTXDISABLESCREEN            51

#define LD_DEREF_FN_CREATEDESKTOP1          52
#define LD_DEREF_FN_CREATEDESKTOP2          53
#define LD_DEREF_FN_CREATEDESKTOP3          54
#define LD_REF_FN_CREATEDESKTOP             55

#define LD_DEREF_FN_OPENDESKTOP             56
#define LD_REF_FN_OPENDESKTOP               57

#define LD_DEREF_FN_SETDESKTOP              58
#define LD_REF_FN_SETDESKTOP                59

#define LD_DEREF_FN_GETTHREADDESKTOP        60
#define LD_REF_FN_GETTHREADDESKTOP          61

#define LD_DEREF_FN_CLOSEDESKTOP1           62
#define LD_DEREF_FN_CLOSEDESKTOP2           63
#define LD_REF_FN_CLOSEDESKTOP              64

#define LD_DEREF_FN_RESOLVEDESKTOP          65
#define LD_REF_FN_RESOLVEDESKTOP            66

#define LD_DEREF_VALIDATE_HDESK1            67
#define LD_DEREF_VALIDATE_HDESK2            68
#define LD_DEREF_VALIDATE_HDESK3            69
#define LD_DEREF_VALIDATE_HDESK4            70
#define LDL_VALIDATE_HDESK                  71

#define LDUT_FN_CREATETHREADINFO1           72
#define LDUT_FN_CREATETHREADINFO2           73
#define LDLT_FN_CREATETHREADINFO            74

#define LD_DEREF_FN_SETCSRSSTHREADDESKTOP1  75
#define LD_DEREF_FN_SETCSRSSTHREADDESKTOP2  76
#define LD_REF_FN_SETCSRSSTHREADDESKTOP     77

#define LD_DEREF_FN_CONSOLECONTROL1         78
#define LD_REF_FN_CONSOLECONTROL1           79

#define LD_DEREF_FN_CONSOLECONTROL2         80
#define LD_REF_FN_CONSOLECONTROL2           81

#define LD_DEREF_FN_GETUSEROBJECTINFORMATION 82
#define LD_REF_FN_GETUSEROBJECTINFORMATION   83

#define LD_DEREF_FN_SETUSEROBJECTINFORMATION 84
#define LD_REF_FN_SETUSEROBJECTINFORMATION   85

#define LD_DEREF_FN_CREATEWINDOWSTATION     86
#define LD_REF_FN_CREATEWINDOWSTATION       87

#define LDL_TERM_DESKDESTROY1               88
#define LDL_TERM_DESKDESTROY2               89

#define LDL_MOTHERDESK_DESK2                92

#define LDL_WINSTA_DESKLIST2                93
#define LDL_WINSTA_DESKLIST1                94

#define LDL_DESKRITINPUT                    95
#define LDU_DESKRITINPUT                    96

#define LD_DEREF_FN_2CREATEDESKTOP          97

#define LDL_DESK_DESKNEXT2                  98

#define LDL_DESKSHOULDBEFOREGROUND1         99
#define LDL_DESKSHOULDBEFOREGROUND2         100
#define LDL_DESKSHOULDBEFOREGROUND3         101

#define LDL_HOOK_DESK                       102
#define LDU_HOOK_DESK                       103

#define LDU_DESKSHOULDBEFOREGROUND          105

#define LDU_MOTHERDESK_DESK                 106

void LogDesktop(PDESKTOP pdesk, DWORD tag, BOOL bLock, ULONG_PTR extra);

#else
    #define LogDesktop(pdesk, tag, bLock, extra)
#endif // LOGDESKTOPLOCKS

/*
 * Routines for referencing and assigning kernel objects.
 */
#ifdef LOGDESKTOPLOCKS
    VOID LockObjectAssignment(PVOID*, PVOID, DWORD, ULONG_PTR);
    VOID UnlockObjectAssignment(PVOID*, DWORD, ULONG_PTR);
#else
    VOID LockObjectAssignment(PVOID*, PVOID);
    VOID UnlockObjectAssignment(PVOID*);
#endif

VOID UserDereferenceObject(PVOID pobj);

#define ThreadLockObject(pobj, ptl)                                                 \
{                                                                                   \
    UserAssert(!(PpiCurrent()->W32PF_Flags & W32PF_TERMINATED));                    \
    UserAssert(pobj == NULL || OBJECT_TO_OBJECT_HEADER(pobj)->PointerCount != 0);   \
    PushW32ThreadLock(pobj, ptl, UserDereferenceObject);                            \
    if (pobj != NULL) {                                                             \
        ObReferenceObject(pobj);                                                    \
    }                                                                               \
}

#define ThreadLockExchangeObject(pobj, ptl)                                         \
{                                                                                   \
    UserAssert(!(PpiCurrent()->W32PF_Flags & W32PF_TERMINATED));                    \
    UserAssert(pobj == NULL || OBJECT_TO_OBJECT_HEADER(pobj)->PointerCount != 0);   \
    if (pobj != NULL) {                                                             \
        ObReferenceObject(pobj);                                                    \
    }                                                                               \
    ExchangeW32ThreadLock(pobj, ptl);                                               \
}

#define ThreadUnlockObject(ptl)                                                     \
{                                                                                   \
    PopAndFreeW32ThreadLock(ptl);                                                   \
}                                                                                   \

#ifdef LOGDESKTOPLOCKS

    #define UnlockWinSta(ppwinsta) \
            UnlockObjectAssignment(ppwinsta, 0, 0)

    #define LockWinSta(ppwinsta, pwinsta) \
    {                                                                                           \
        if (pwinsta != NULL)                                                                    \
        {                                                                                       \
            UserAssert(OBJECT_TO_OBJECT_HEADER(pwinsta)->Type == *ExWindowStationObjectType);   \
        }                                                                                       \
        LockObjectAssignment(ppwinsta, pwinsta, 0, 0);                                                \
    }

    #define LockDesktop(ppdesk, pdesk, tag, extra) \
    {                                                                                           \
        if (pdesk != NULL)                                                                      \
        {                                                                                       \
            UserAssert(OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);           \
        }                                                                                       \
        LockObjectAssignment(ppdesk, pdesk, tag, extra);                                        \
    }

    #define UnlockDesktop(ppdesk, tag, extra) \
            UnlockObjectAssignment(ppdesk, tag, extra)

    #define ThreadLockDesktop(pti, pdesk, ptl, tag) \
    {                                                                                           \
        UserAssert(pdesk == NULL || OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);\
        ThreadLockObject(pdesk, ptl);                                                           \
        LogDesktop(pdesk, tag, TRUE, (ULONG_PTR)PtiCurrent());                                      \
    }

    #define ThreadLockExchangeDesktop(pti, pdesk, ptl, tag) \
    {                                                                                           \
        UserAssert(pdesk == NULL || OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);\
        ThreadLockExchangeObject(pdesk, ptl);                                                   \
        LogDesktop(pdesk, tag, TRUE, (ULONG_PTR)PtiCurrent());                                  \
    }

    #define ThreadUnlockDesktop(pti, ptl, tag)                                                  \
    {                                                                                           \
        LogDesktop((PDESKTOP)(((PTL)ptl)->pobj), tag, FALSE, (ULONG_PTR)PtiCurrent());                \
        ThreadUnlockObject(ptl);                                                                \
    }

#else

    #define UnlockWinSta(ppwinsta) \
            UnlockObjectAssignment(ppwinsta)

    #define LockWinSta(ppwinsta, pwinsta) \
    {                                                                                           \
        if (pwinsta != NULL)                                                                    \
        {                                                                                       \
            UserAssert(OBJECT_TO_OBJECT_HEADER(pwinsta)->Type == *ExWindowStationObjectType);   \
        }                                                                                       \
        LockObjectAssignment(ppwinsta, pwinsta);                                                \
    }

    #define LockDesktop(ppdesk, pdesk, tag, extra) \
    {                                                                                           \
        if (pdesk != NULL)                                                                      \
        {                                                                                       \
            UserAssert(OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);           \
        }                                                                                       \
        LockObjectAssignment(ppdesk, pdesk);                                                    \
    }

    #define UnlockDesktop(ppdesk, tag, extra) \
            UnlockObjectAssignment(ppdesk)

    #define ThreadLockDesktop(pti, pdesk, ptl, tag) \
    {                                                                                           \
        UserAssert(pdesk == NULL || OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);\
        ThreadLockObject(pdesk, ptl);                                                           \
    }

    #define ThreadLockExchangeDesktop(pti, pdesk, ptl, tag) \
    {                                                                                           \
        UserAssert(pdesk == NULL || OBJECT_TO_OBJECT_HEADER(pdesk)->Type == *ExDesktopObjectType);\
        ThreadLockExchangeObject(pdesk, ptl);                                                   \
    }

    #define ThreadUnlockDesktop(pti, ptl, tag) ThreadUnlockObject(ptl)

#endif // LOGDESKTOPLOCKS

#define ThreadLockWinSta(pti, pwinsta, ptl) \
{                                                                                           \
    UserAssert(pwinsta == NULL || OBJECT_TO_OBJECT_HEADER(pwinsta)->Type == *ExWindowStationObjectType);\
    ThreadLockObject(pwinsta, ptl);                                                         \
}

#define ThreadLockExchangeWinSta(pti, pwinsta, ptl) \
{                                                                                           \
    UserAssert(pwinsta == NULL || OBJECT_TO_OBJECT_HEADER(pwinsta)->Type == *ExWindowStationObjectType);\
    ThreadLockExchangeObject(pwinsta, ptl);                                                 \
}

#define _ThreadLockPti(pti, pobj, ptl) LockW32Thread((PW32THREAD)pobj, ptl)
#if DBG
#define ThreadLockPti(pti, pobj, ptl) \
{ \
    if ((pobj != NULL) \
            && (pobj->TIF_flags & TIF_INCLEANUP) \
            && (pobj != PtiCurrent())) { \
        RIPMSG1(RIP_ERROR, "ThreadLockPti: dead thread %#p", pobj); \
    } \
    _ThreadLockPti(pti, pobj, ptl); \
}
#else
#define ThreadLockPti(pti, pobj, ptl) \
{ \
    _ThreadLockPti(pti, pobj, ptl); \
}
#endif

#define ThreadLockExchangePti(pobj, ptl) LockExchangeW32Thread((PW32THREAD)pobj, ptl)

#define ThreadUnlockWinSta(pti, ptl) ThreadUnlockObject(ptl)
#define ThreadUnlockPti(pti, ptl) UnlockW32Thread(ptl)

/*
 * Macros for locking pool allocations
 */
#define ThreadLockPool(_pti_, _ppool_, _ptl_)  \
        PushW32ThreadLock(_ppool_, _ptl_, UserFreePool)

#define ThreadUnlockPool(_pti_, _ptl_)  \
        PopW32ThreadLock(_ptl_)

#define ThreadUnlockAndFreePool(_pti_, _ptl_)  \
        PopAndFreeAlwaysW32ThreadLock(_ptl_)

#define ThreadLockPoolCleanup(_pti_, _ppool_, _ptl_, _pfn_)  \
        PushW32ThreadLock(_ppool_, _ptl_, _pfn_)

#define ThreadUnlockPoolCleanup(_pti_, _ptl_)  \
        PopW32ThreadLock(_ptl_)

#define ThreadUnlockAndCleanupPool(_pti_, _ptl_)  \
        PopAndFreeAlwaysW32ThreadLock(_ptl_)

#define ThreadLockDesktopHandle(_pti, _ptl_, _hdesk_)   \
        PushW32ThreadLock(_hdesk_, _ptl_, CloseProtectedHandle)

#define ThreadUnlockDesktopHandle(_ptl_)   \
        PopAndFreeAlwaysW32ThreadLock(_ptl_)

void CleanupDecSFWLockCount(PVOID pIgnore);
#define ThreadLockSFWLockCount(_ptl_) \
        { \
            IncSFWLockCount(); \
            /* Pass a fake pObj or the cleanup function won't be called */ \
            PushW32ThreadLock(&guSFWLockCount, _ptl_, CleanupDecSFWLockCount); \
        }

#define ThreadUnlockSFWLockCount(_ptl_) \
    { \
        DecSFWLockCount(); \
        PopW32ThreadLock(_ptl_); \
    }

/*
 * special handle that signifies we have a rle bitmap for the wallpaper
 */
#define HBITMAP_RLE ((HBITMAP)0xffffffff)

typedef struct tagWPINFO {
    int xsize, ysize;
    PBITMAPINFO pbmi;
    PBYTE pdata;
    PBYTE pbmfh;
} WPINFO;

/*
 * Defines used by GetMouseMovePointsEx API
 */

#define MAX_MOUSEPOINTS 64

#define PREVPOINT(i)    \
    ((i == 0) ? (MAX_MOUSEPOINTS - 1) : ((i - 1) % MAX_MOUSEPOINTS))

#define NEXTPOINT(i)    \
    ((i + 1) % MAX_MOUSEPOINTS)

#define NEXTPOINTCOUNT(c)           \
    {                               \
        if (c < MAX_MOUSEPOINTS)    \
            c++;                    \
    }

#define SAVEPOINT(xc, yc, _resX, _resY, t, e)                            \
{                                                                        \
    /*                                                                   \
     * (xc, yc) is the point and (resX, resY) is the resolution          \
     */                                                                  \
    gaptMouse[gptInd].x           = MAKELONG(LOWORD(xc), LOWORD(_resX)); \
    gaptMouse[gptInd].y           = MAKELONG(LOWORD(yc), LOWORD(_resY)); \
    gaptMouse[gptInd].time        = t;                                   \
    gaptMouse[gptInd].dwExtraInfo = e;                                   \
                                                                         \
    gptInd = NEXTPOINT(gptInd);                                          \
}


/*
 * Structure used for getting the stack traces for user critical section
 */

#define MAX_STACK_CALLS 8

typedef struct tagCRITSTACK {
struct tagCRITSTACK* pNext;
    PETHREAD         thread;
    int              nFrames;
    PVOID            trace[MAX_STACK_CALLS];
} CRITSTACK, *PCRITSTACK;


/*
 * Macros for User Server and Raw Input Thread critical sections.
 */
#if DBG
    #define KeUserModeCallback(api, pIn, cb, pOut, pcb)    _KeUserModeCallback(api, pIn, cb, pOut, pcb);
    #define CheckCritIn()                _AssertCritIn()
    #define CheckDeviceInfoListCritIn()  _AssertDeviceInfoListCritIn()
    #define CheckCritInShared()          _AssertCritInShared()
    #define CheckCritOut()               _AssertCritOut()
    #define CheckDeviceInfoListCritOut() _AssertDeviceInfoListCritOut()

    void    BeginAtomicCheck();
    void    BeginAtomicDeviceInfoListCheck();
    void    EndAtomicCheck();
    void    EndAtomicDeviceInfoListCheck();
    #define BEGINATOMICCHECK()     BeginAtomicCheck();                              \
                                    { DWORD dwCritSecUseSave = gdwCritSecUseCount;

    #define ENDATOMICCHECK()        UserAssert(dwCritSecUseSave == gdwCritSecUseCount);  \
                                    } EndAtomicCheck();
    #define BEGINATOMICDEVICEINFOLISTCHECK() \
            BeginAtomicDeviceInfoListCheck(); \
            { DWORD dwDeviceInfoListCritSecUseSave = gdwDeviceInfoListCritSecUseCount;

    #define ENDATOMICDEVICEINFOLISTCHECK() \
            UserAssert(dwDeviceInfoListCritSecUseSave == gdwDeviceInfoListCritSecUseCount);  \
            } EndAtomicDeviceInfoListCheck();

    // Use this to jump/return out of scope of dwCritSecUseSave (eg: error handling)
    #define EXITATOMICCHECK()       UserAssert(dwCritSecUseSave == gdwCritSecUseCount);  \
                                    EndAtomicCheck();
    #define ISATOMICCHECK()         (gdwInAtomicOperation != 0)
    #define ISATOMICDEVICEINFOLISTCHECK() (gdwInAtomicDeviceInfoListOperation != 0)

#else // DBG
    #define CheckCritIn()
    #define CheckDeviceInfoListCritIn()
    #define CheckCritInShared()
    #define CheckCritOut()
    #define CheckDeviceInfoListCritOut()
    #define BEGINATOMICCHECK()
    #define BEGINATOMICDEVICEINFOLISTCHECK()
    #define BeginAtomicCheck()
    #define BeginAtomicDeviceInfoListCheck()
    #define ENDATOMICCHECK()
    #define ENDATOMICDEVICEINFOLISTCHECK()
    #define EndAtomicCheck()
    #define EndAtomicDeviceInfoListCheck()
    #define EXITATOMICCHECK()
    #define ISATOMICCHECK()
    #define ISATOMICDEVICEINFOLISTCHECK()
#endif // DBG


#define DIAGNOSE_IO 1
#ifdef DIAGNOSE_IO
ULONG MonotonicTick();
#define LOGTIME(gt) gt = MonotonicTick();
#else
#define LOGTIME(gt)
#endif

/*
 * #defines used for mouse/keyboard read buffer
 */
#define MAXIMUM_ITEMS_READ      10
#define NELEM_BUTTONQUEUE       16

/*
 * Number of times to retry reading a device after a read attempt fails
 */
#define MAXIMUM_READ_RETRIES 5

typedef struct tagGENERIC_DEVICE_INFO {
#ifdef GENERIC_INPUT
    HEAD                 head;
#endif
    struct tagDEVICEINFO *pNext;
    BYTE                 type;
    BYTE                 bFlags;
    USHORT               usActions;
    BYTE                 nRetryRead;
    UNICODE_STRING       ustrName;
    HANDLE               handle;
    PVOID                NotificationEntry;
    PKEVENT              pkeHidChangeCompleted; // wake RequestDeviceChange()
    IO_STATUS_BLOCK      iosb;
    NTSTATUS             ReadStatus;

#ifdef DIAGNOSE_IO
    HANDLE               OpenerProcess;
    NTSTATUS             OpenStatus;
    NTSTATUS             AttrStatus;
    ULONG                timeStartRead;     // tick before ZwReadFile
    ULONG                timeEndRead;       // tick after ZwReadFile
    int                  nReadsOutstanding; // ZwReadFile ++, consume data --
#endif
} GENERIC_DEVICE_INFO, *PGENERIC_DEVICE_INFO;

// valuse for GENERIC_DEVICE_INFO.type
#define DEVICE_TYPE_MOUSE    0
#define DEVICE_TYPE_KEYBOARD 1
#ifdef GENERIC_INPUT
#define DEVICE_TYPE_HID      2
#define DEVICE_TYPE_MAX      2
#else
#define DEVICE_TYPE_MAX      1
#endif

// values for GENERIC_DEVICE_INFO.usActions and SignalDeviceChange()
#define GDIAF_ARRIVED         (USHORT)0x0001 // open & start reading
#define GDIAF_QUERYREMOVE     (USHORT)0x0002 // close the device
#define GDIAF_REMOVECANCELLED (USHORT)0x0004 // reopen the device
#define GDIAF_DEPARTED        (USHORT)0x0008 // close and free the device
#define GDIAF_IME_STATUS      (USHORT)0x0010 // ???
#define GDIAF_REFRESH_MOUSE   (USHORT)0x0020 // ???
#define GDIAF_FREEME          (USHORT)0x0080 // Request to Free the DeviceInfo
#define GDIAF_PNPWAITING      (USHORT)0x0100 // a PnP thread is waiting
#define GDIAF_RETRYREAD       (USHORT)0x0200 // Retry the read
#define GDIAF_RECONNECT       (USHORT)0x0400 // The session reconnected
#ifdef GENERIC_INPUT
#define GDIAF_STARTREAD       (USHORT)0x0800 // The device needs to be started
#define GDIAF_STOPREAD        (USHORT)0x1000 // The device needs to be stopped
#endif

// values for GENERIC_DEVICE_INFO.bFlags;
#define GDIF_NOTPNP         0x01 // Not a PnP device (eg: PS/2)
#define GDIF_READING        0x02 // Read may be pending (don't free DeviceInfo).
#if DIAGNOSE_IO
#define GDIF_READERMUSTFREE 0x04 // "Free Device" while read pending
#define GDIF_PNPMUSTFREE    0x08 // "Free Device" while PnP notification pending
#endif
#define GDIF_DBGREAD        0x10 // Verbose dbg output about this device

typedef struct tagMOUSE_DEVICE_INFO {    // DEVICE_TYPE_MOUSE
    MOUSE_ATTRIBUTES     Attr;
    MOUSE_INPUT_DATA     Data[MAXIMUM_ITEMS_READ];
} MOUSE_DEVICE_INFO, *PMOUSE_DEVICE_INFO;

#ifdef GENERIC_INPUT
#define INVALID_UNIT_ID     ((USHORT)0xffff)
#define INJECTED_UNIT_ID    ((USHORT)0xfffe)
#endif


typedef struct tagKEYBOARD_DEVICE_INFO { // DEVICE_TYPE_KEYBOARD
    KEYBOARD_ATTRIBUTES  Attr;
    KEYBOARD_ID_EX IdEx;
    KEYBOARD_INPUT_DATA  Data[MAXIMUM_ITEMS_READ];
} KEYBOARD_DEVICE_INFO, *PKEYBOARD_DEVICE_INFO;

#define GET_KEYBOARD_DEVINFO_ID(pDeviceInfo)        ((pDeviceInfo)->keyboard.IdEx)
#define GET_KEYBOARD_DEVINFO_TYPE(pDeviceInfo)      ((pDeviceInfo)->keyboard.IdEx.Type)
#define GET_KEYBOARD_DEVINFO_SUBTYPE(pDeviceInfo)   ((pDeviceInfo)->keyboard.IdEx.Subtype)


#ifdef GENERIC_INPUT
/*
 * HID Descriptor
 * allocated as a handle, type == TAG_HIDDESC
 */
typedef struct tagHIDDESC {
    IO_STATUS_BLOCK iob;

    PVOID pPreparsedData;   // the size is in hidCollectionInfo.DescriptorSize
    PVOID pInputBuffer;     // the size is in hidpCaps.

    HIDP_CAPS hidpCaps;
    HID_COLLECTION_INFORMATION hidCollectionInfo;
} HIDDESC, *PHIDDESC;

/*
 * HID Top Level Collection Information
 */
typedef struct tagHID_TLC_INFO {
    LIST_ENTRY link;
    // Toplevel collection
    USHORT usUsagePage;
    USHORT usUsage;
    /*
     * Reference counters
     */
    UINT cDevices;              // # of devices currently attached
    UINT cDirectRequest;        // Reference count of direct request to this device type (# of processes)
    UINT cUsagePageRequest;     // Reference count of UsagePage only request
    UINT cExcludeRequest;       // Reference count of Exclude request
    UINT cExcludeOrphaned;      // Orphaned count of Exclude request
#if defined(GI_SINK) && defined(LATER)
    UINT cSinkable;             // LATER...
#endif
} HID_TLC_INFO, *PHID_TLC_INFO;

/*
 * HID global PageOnly request
 */
typedef struct tagHID_PAGEONLY_REQUEST {
    LIST_ENTRY link;
    USHORT usUsagePage;
    UINT cRefCount;
#if defined(GI_SINK) && defined(LATER)
    UINT cSinkable;
#endif
} HID_PAGEONLY_REQUEST, *PHID_PAGEONLY_REQUEST;

/*
 * Global HID Request
 */
typedef struct tagHID_REQUEST_TABLE {
    /*
     * HID_TLC_INFO
     */
    LIST_ENTRY TLCInfoList;
    /*
     * HID_PAGEONLY_REQUEST
     */
    LIST_ENTRY UsagePageList;

#ifdef GI_SINK
    /*
     * PROCESS_HID_TABLE
     */
    LIST_ENTRY ProcessRequestList;
#endif
} HID_REQUEST_TABLE, *PHID_REQUEST_TABLE;

extern HID_REQUEST_TABLE gHidRequestTable;
extern int gnHidProcess;

/*
 * Per process hid device request list
 */
typedef struct tagPROCESS_HID_REQUEST {
    LIST_ENTRY link;
    // Toplevel collection
    USHORT usUsagePage;
    USHORT usUsage;
#ifdef GI_SINK
    BOOL fSinkable : 1;
#endif
    BOOL fExclusiveOrphaned : 1;
    union {
        PHID_TLC_INFO    pTLCInfo;
        PHID_PAGEONLY_REQUEST   pPORequest;
        LPVOID                  ptr;
    };
    PWND spwndTarget;
} PROCESS_HID_REQUEST, *PPROCESS_HID_REQUEST;

/*
 * Per-process HID request table
 */
typedef struct tagPROCESS_HID_TABLE {
    /*
     * Link to the next process HID table.
     */
    LIST_ENTRY link;

    /*
     * Those LIST_ENTRYs point PROCESS_HID_REQUEST
     */
    LIST_ENTRY InclusionList;
    LIST_ENTRY UsagePageList;
    LIST_ENTRY ExclusionList;

    /*
     * Target windows for the legacy devices
     */
    PWND spwndTargetMouse;
    PWND spwndTargetKbd;

#ifdef GI_SINK
    /*
     * Number of Sinks in this process.
     * N.b. this does not include the legacy device sinks to
     * save clocks walking through the list, if sink requests
     * are only for the legacy devices.
     */
    int nSinks;
#endif

    /*
     * Cache of the last matching request.
     */
    PPROCESS_HID_REQUEST pLastRequest;
    USAGE UsagePageLast;
    USAGE UsageLast;

    /*
     *  Legacy Mode flags
     */
    BOOL fRawMouse : 1;
    BOOL fNoLegacyMouse : 1;
#ifdef GI_SINK
    BOOL fRawMouseSink : 1;
#endif
    BOOL fRawKeyboard : 1;
    BOOL fNoLegacyKeyboard : 1;
#ifdef GI_SINK
    BOOL fRawKeyboardSink : 1;
#endif
    BOOL fCaptureMouse : 1;     // "Own" a mouse...
    BOOL fNoHotKeys : 1;
    BOOL fAppKeys: 1;
} PROCESS_HID_TABLE, *PPROCESS_HID_TABLE;

#define TestRawInputMode(pti, mode) \
    ((pti) && (pti)->ppi && (pti)->ppi->pHidTable && (pti)->ppi->pHidTable->f##mode)

#define TestRawInputModeNoCheck(pti, mode) \
    ((pti)->ppi->pHidTable->f##mode)

#ifdef GI_SINK
typedef struct tagHID_COUNTERS {
    DWORD cKbdSinks;
    DWORD cMouseSinks;
    DWORD cHidSinks;
} HID_COUNTERS;

extern HID_COUNTERS gHidCounters;

#define IsKeyboardSinkPresent() (gHidCounters.cKbdSinks > 0)
#define IsMouseSinkPresent()    (gHidCounters.cMouseSinks > 0)
#endif


#define HID_INCLUDE     0x01
#define HID_PAGEONLY    0x02
#define HID_EXCLUDE     0x03

/*
 * HID Device info
 */
typedef struct tagHID_DEVICE_INFO {
    PHIDDESC pHidDesc;
    PHID_TLC_INFO pTLCInfo;
} HID_DEVICE_INFO, *PHID_DEVICE_INFO;

#endif  // GENERIC_INPUT

typedef struct tagDEVICEINFO {
    GENERIC_DEVICE_INFO;
    union {
        MOUSE_DEVICE_INFO    mouse;
        KEYBOARD_DEVICE_INFO keyboard;
#ifdef GENERIC_INPUT
        HID_DEVICE_INFO hid;
#endif
    };
} DEVICEINFO, *PDEVICEINFO;

typedef struct tagDEVICE_TEMPLATE {
    SIZE_T cbDeviceInfo;        // bytes to allocate for DEVICEINFO
    const GUID *pClassGUID;     // GUID of the class
    UINT   uiRegistrySection;   // Parameters for class (HKLM\SYSTEM\CurrentControlSet\Services\*\Parameters)
    LPWSTR pwszClassName;       // Class name (eg: L"mouclass")
    LPWSTR pwszDefDevName;      // Default Device Name
    LPWSTR pwszLegacyDevName;   // Legacy Device Name (eg: "PointerClassLegacy0")
    ULONG  IOCTL_Attr;          // IOCTL_*_QUERY_ATTRIBUTES
    UINT   offAttr;             // offset of *_ATTRIBUTES struct within DEVICEINFO
    ULONG  cbAttr;              // sizeof *_ATTRIBUTES struct
    UINT   offData;             // offset of *_INPUT_DATA buffer within DEVICEINFO
    ULONG  cbData;              // sizeof *_INPUT_DATA buffer
    VOID   (*DeviceRead)(PDEVICEINFO); // routine to read the device
    PKEVENT pkeHidChange;       // event to signal changes to this sort of device

#ifdef GENERIC_INPUT
    DWORD dwFlags;              // Flags...
#endif
} DEVICE_TEMPLATE, *PDEVICE_TEMPLATE;


#ifdef GENERIC_INPUT
#define DT_HID          0x00000001
#endif

extern DEVICE_TEMPLATE aDeviceTemplate[]; // in pnp.c

typedef struct tagMOUSEEVENT {
    USHORT  ButtonFlags;
    USHORT  ButtonData;
    ULONG_PTR ExtraInfo;
    POINT   ptPointer;
    LONG    time;
    BOOL    bInjected;
#ifdef GENERIC_INPUT
    HANDLE  hDevice;

    /*
     * The raw mouse information comes here.
     */
    MOUSE_INPUT_DATA rawData;
#endif
} MOUSEEVENT, *PMOUSEEVENT;


#ifdef GENERIC_INPUT
/*
 * RawInput
 */
typedef struct tagHIDDATA {
    THROBJHEAD head;
    PWND spwndTarget;
    RAWINPUT rid;   // raw input data, variable length
                    // rid needs to be the last member in HIDDATA
} HIDDATA, *PHIDDATA;

/*
 * Global request list manipulation.
 */
void InitializeHidRequestList();
void CleanupHidRequestList();

/*
 * DeviceType request
 */
VOID FreeHidTLCInfo(
    PHID_TLC_INFO pHidRequest);

/*
 * HID specific device info
 */
PHIDDESC xxxHidCreateDeviceInfo(PDEVICEINFO pDeviceInfo);

/*
 * HID specific information (managed by HM),
 * linked from DEVICEINFO
 */
/* N.b. AllocateHidDesc is only called within hidevice.c */
void FreeHidDesc(PHIDDESC);

/*
 * The handle in WM_INPUT
 */
PHIDDATA AllocateHidData(HANDLE hDevice, DWORD dwType, DWORD dwSize, WPARAM wParam, PWND pwnd);
void FreeHidData(PHIDDATA pData);

#ifdef GI_SINK
#define GI_SINK_PARAM(x)    ,x
#else
#define GI_SINK_PARAM(x)
#endif

void FreeHidProcessRequest(
    PPROCESS_HID_REQUEST pHid,
    DWORD dwFlags,
    PPROCESS_HID_TABLE pHidTable);


/*
 * HID specific read call back (called from InputApc)
 */
VOID ProcessHidInput(PDEVICEINFO pDeviceInfo);

/*
 * API helper
 */
BOOL _RegisterRawInputDevices(PCRAWINPUTDEVICE, UINT uiNumDevices);
UINT _GetRegisteredRawInputDevices(PRAWINPUTDEVICE, PUINT puiNumDevices);

/*
 * UserCriticalSection...
 */
#define BESURE_IN_USERCRIT(cond) \
    { \
        BOOLEAN fHasToLeaveUserCrit = FALSE; \
        if ((cond) && !ExIsResourceAcquiredExclusiveLite(gpresUser)) { \
            CheckDeviceInfoListCritOut(); \
            fHasToLeaveUserCrit = TRUE; \
            EnterCrit(); \
            TAGMSG0(DBGTAG_PNP, "BESURE_IN_USERCRIT: entering the user crit"); \
        }

#define END_IN_USERCRIT() \
        if (fHasToLeaveUserCrit) { \
            CheckDeviceInfoListCritOut(); \
            TAGMSG0(DBGTAG_PNP, "END_IN_USERCRIT: leaving the user crit"); \
            LeaveCrit(); \
        }\
    }

/*
 * Acquire input device lock while making sure there is no pending PnP callout
 * rewuesting to process a device change.
 */
#define PNP_SAFE_DEVICECRIT_IN() \
{\
    CheckCritIn();\
    CheckDeviceInfoListCritIn();\
    while (TRUE) {\
        if (gbPnPWaiting) {\
            LeaveDeviceInfoListCrit();\
            LeaveCrit(); \
            Status = KeWaitForSingleObject(gpEventPnPWainting, Executive, KernelMode, FALSE, NULL); \
            EnterCrit();\
            EnterDeviceInfoListCrit();\
            UserAssert(Status == STATUS_SUCCESS);\
            continue;\
        }else {  \
            break; \
        } \
    }  \
}


/*
 * Check if this device type is active to read
 */
__inline DWORD HidValidExclusive(PHID_TLC_INFO pTLCInfo)
{
    UserAssert(pTLCInfo);
    UserAssert(pTLCInfo->cExcludeRequest >= pTLCInfo->cExcludeOrphaned);
    return pTLCInfo->cExcludeRequest - pTLCInfo->cExcludeOrphaned;
}

__inline BOOL HidTLCActive(PHID_TLC_INFO pTLCInfo)
{
    UserAssert(pTLCInfo);
    return pTLCInfo->cDirectRequest > 0 || pTLCInfo->cUsagePageRequest > HidValidExclusive(pTLCInfo);
}

/*
 * Allocate and free process device type request table.
 */
PPROCESS_HID_TABLE AllocateProcessHidTable(void);
void FreeProcessHidTable(PPROCESS_HID_TABLE pHidTable);

void DestroyProcessHidRequests(PPROCESSINFO ppi);
void DestroyThreadHidObjects(PTHREADINFO pti);

#if DBG
void CheckupHidLeak(void);
#endif

#endif  // GENERIC_INPUT


VOID ProcessKeyboardInput(PDEVICEINFO pDeviceInfo);
VOID ProcessMouseInput(PDEVICEINFO pDeviceInfo);
VOID RequestDeviceChange(
    PDEVICEINFO pDeviceInfo,
    USHORT usAction,
    BOOL fInDeviceInfoListCrit);

VOID RetryReadInput();

VOID NTAPI InputApc(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG Reserved);

ULONG GetDeviceChangeInfo(VOID);
VOID InitializeMediaChange(HANDLE);
VOID CleanupMediaChange(VOID);

/*
 * Hard error information
 */
typedef struct tagHARDERRORHANDLER {
    PTHREADINFO pti;
    PQ pqAttach;
} HARDERRORHANDLER, *PHARDERRORHANDLER;

/*
 * Terminal Structure.
 *
 *   This structure is only viewable from the kernel.
 */

#define TEST_GTERMF(f)               TEST_FLAG(gdwGTERMFlags, f)
#define TEST_BOOL_GTERMF(f)          TEST_BOOL_FLAG(gdwGTERMFlags, f)
#define SET_GTERMF(f)                SET_FLAG(gdwGTERMFlags, f)
#define CLEAR_GTERMF(f)              CLEAR_FLAG(gdwGTERMFlags, f)
#define SET_OR_CLEAR_GTERMF(f, fSet) SET_OR_CLEAR_FLAG(gdwGTERMFlags, f, fSet)
#define TOGGLE_GTERMF(f)             TOGGLE_FLAG(gdwGTERMFlags, f)

#define GTERMF_MOUSE        0x00000001


#define TERMF_INITIALIZED       0x00000001
#define TERMF_NOIO              0x00000002
#define TERMF_STOPINPUT         0x00000004
#define TERMF_DTINITSUCCESS     0x00000008
#define TERMF_DTINITFAILED      0x00000010
#define TERMF_DTDESTROYED       0x00000020

typedef struct tagTERMINAL {

    DWORD               dwTERMF_Flags;      // terminal flags

    /*
     * System Information
     */
    PWND                spwndDesktopOwner;  // mother desktop


    PTHREADINFO         ptiDesktop;
#ifdef BUG365290
    PTHREADINFO         ptiDesktopTemp;
#endif //BUG365290
    PQ                  pqDesktop;

    PKEVENT             pEventTermInit;
    PKEVENT             pEventDestroyDesktop;   // Used for destroying desktops

    PDESKTOP            rpdeskDestroy;          // Desktop destroy list.

    PKEVENT             pEventInputReady;   // input ready event. This is created in
                                            // CreateTerminal. RIT and the desktop thread
                                            // will wait for it. It will be set when the
                                            // first desktop in that terminal will be created.
    PKEVENT             pEventDTExit;

} TERMINAL, *PTERMINAL;

/*
 * Pool allocation tags and macros
 */

/*
 * Define tags. To add tags, add them to ntuser\kernel\ptag.lst
 */
#define DEFINE_POOLTAG(value, index) value

#define DECLARE_POOLTAG(name, value, index)

#include "ptag.h"

NTSTATUS UserCommitDesktopMemory(
    PVOID  pBase,
    PVOID *ppCommit,
    PSIZE_T pCommitSize);

NTSTATUS UserCommitSharedMemory(
    PVOID  pBase,
    PVOID *ppCommit,
    PSIZE_T pCommitSize);

PWIN32HEAP UserCreateHeap(
    HANDLE                   hSection,
    ULONG                    ulViewOffset,
    PVOID                    pvBaseAddress,
    DWORD                    dwSize,
    PRTL_HEAP_COMMIT_ROUTINE pfnCommit);

#define IsValidTag(p, tag)      TRUE

#define RECORD_STACK_TRACE_SIZE 6

/*
 * Pool allocation flags
 */

#define POOL_HEAVY_ALLOCS       0x00000001  // use HeavyAllocPool
#define POOL_CAPTURE_STACK      0x00000002  // stack traces are captured
#define POOL_FAIL_ALLOCS        0x00000004  // fail pool allocations
#define POOL_FAIL_BY_INDEX      0x00000008  // fail allocations by index
#define POOL_TAIL_CHECK         0x00000010  // append tail string
#define POOL_KEEP_FREE_RECORD   0x00000020  // keep a list with last x frees
#define POOL_KEEP_FAIL_RECORD   0x00000040  // keep a list with last x failed allocations
#define POOL_BREAK_FOR_LEAKS    0x00000080  // break on pool leaks (remote sessions)

typedef struct tagWin32AllocStats {
    SIZE_T dwMaxMem;             // max pool memory allocated
    SIZE_T dwCrtMem;             // current pool memory used
    DWORD  dwMaxAlloc;           // max number of pool allocations made
    DWORD  dwCrtAlloc;           // current pool allocations

    PWin32PoolHead pHead;        // pointer to the link list with the allocations

} Win32AllocStats, *PWin32AllocStats;

typedef struct tagPOOLRECORD {
    PVOID   ExtraData;           // the tag
    SIZE_T  size;
    PVOID   trace[RECORD_STACK_TRACE_SIZE];
} POOLRECORD, *PPOOLRECORD;

#ifdef POOL_INSTR_API

    BOOL _Win32PoolAllocationStats(
        LPDWORD  parrTags,
        SIZE_T   tagsCount,
        SIZE_T*  lpdwMaxMem,
        SIZE_T*  lpdwCrtMem,
        LPDWORD  lpdwMaxAlloc,
        LPDWORD  lpdwCrtAlloc);

#endif // POOL_INSTR_API

#ifdef POOL_INSTR

    void CleanupPoolAllocations(void);
    NTSTATUS InitPoolLimitations();
    void CleanUpPoolLimitations();
#else
    #define CleanupPoolAllocations()
    #define InitPoolLimitations()   STATUS_SUCCESS
    #define CleanUpPoolLimitations()

#endif // POOL_INSTR

#ifndef TRACE_MAP_VIEWS
    #define InitSectionTrace()      STATUS_SUCCESS
    #define CleanUpSections()
#else
    NTSTATUS InitSectionTrace(VOID);
    void CleanUpSections(void);
#endif // TRACE_MAP_VIEWS

extern PWIN32HEAP gpvSharedAlloc;

__inline PVOID
SharedAlloc(ULONG cb)
{
    return Win32HeapAlloc(gpvSharedAlloc, cb, 0, 0);
}

__inline BOOL
SharedFree(PVOID pv)
{
    return Win32HeapFree(gpvSharedAlloc, pv);
}

NTSTATUS CommitReadOnlyMemory(HANDLE hSection, PSIZE_T pulCommit,
                              DWORD dwCommitOffset, int* pdCommit);

/*
 * Height and Width of the desktop pattern bitmap.
 */
#define CXYDESKPATTERN      8

/*
 * LATER: these things are not defined yet
 */
#define CheckHwnd(x)        TRUE
#define CheckHwndNull(x)    TRUE

/***************************************************************************\
* Typedefs and Macros
*
* Here are defined all types and macros that are shared across the User's
* server-side code modules. Types and macros that are unique to a single
* module should be defined at the head of that module, not in this file.
*
\***************************************************************************/


// Window Proc Window Validation macro

#define VALIDATECLASSANDSIZE(pwnd, message, wParam, lParam, inFNID, initmessage)          \
    if ((pwnd)->fnid != (inFNID)) {                                                       \
        switch ((pwnd)->fnid) {                                                           \
        DWORD cb;                                                                         \
        case 0:                                                                           \
                                                                                          \
            if ((cb = pwnd->cbwndExtra + sizeof(WND)) < (DWORD)(CBFNID(inFNID))) {        \
                RIPMSG3(RIP_WARNING,                                                      \
                       "(%#p %lX) needs at least (%ld) window words for this proc",       \
                        pwnd, cb - sizeof(WND),                                           \
                        (DWORD)(CBFNID(inFNID)) - sizeof(WND));                           \
                return 0;                                                                 \
            }                                                                             \
            /*                                                                            \
             * If this is not the initialization message, we cannot set the fnid;         \
             *  otherwise, we'll probably fault working on this pwnd's private            \
             *  uninitialized data                                                        \
             */                                                                           \
            if ((message) != (initmessage)) {                                             \
                if (((message) != WM_NCCREATE) && ((message) != WM_NCCALCSIZE)  && ((message) != WM_GETMINMAXINFO)) {         \
                    RIPMSG3(RIP_WARNING,                                                  \
                        "Default processing message %#lx for pwnd %#p. fnid %#lx not set",\
                        (message), (pwnd), (DWORD)(inFNID));                              \
                }                                                                         \
                return xxxDefWindowProc((pwnd), (message), (wParam), (lParam));           \
            }                                                                             \
                                                                                          \
            /*                                                                            \
             * Remember what window class this window belongs to. Can't use              \
             * the real class because any app can call CallWindowProc()                   \
             * directly no matter what the class is!                                      \
             */                                                                           \
            (pwnd)->fnid = (WORD)(inFNID);                                                \
            break;                                                                        \
                                                                                          \
        default:                                                                          \
            RIPMSG3(RIP_WARNING, "Window (%#p) not of correct class; fnid = %lX not %lX", \
                    (pwnd), (DWORD)((pwnd)->fnid), (DWORD)(inFNID));                      \
                                                                                          \
            /* Fall through */                                                            \
                                                                                          \
        case (inFNID | FNID_CLEANEDUP_BIT):                                               \
        case (inFNID | FNID_DELETED_BIT):                                                 \
        case (inFNID | FNID_STATUS_BITS):                                                 \
            return 0;                                                                     \
        }                                                                                 \
    }

/*
 * Handy Region helper macros
 */
#define CopyRgn(hrgnDst, hrgnSrc) \
            GreCombineRgn(hrgnDst, hrgnSrc, NULL, RGN_COPY)
#define IntersectRgn(hrgnResult, hrgnA, hrgnB) \
            GreCombineRgn(hrgnResult, hrgnA, hrgnB, RGN_AND)
#define SubtractRgn(hrgnResult, hrgnA, hrgnB) \
            GreCombineRgn(hrgnResult, hrgnA, hrgnB, RGN_DIFF)
#define UnionRgn(hrgnResult, hrgnA, hrgnB) \
            GreCombineRgn(hrgnResult, hrgnA, hrgnB, RGN_OR)
#define XorRgn(hrgnResult, hrgnA, hrgnB) \
            GreCombineRgn(hrgnResult, hrgnA, hrgnB, RGN_XOR)

void DeleteMaybeSpecialRgn(HRGN hrgn);

BOOL zzzInvalidateDCCache(PWND pwndInvalid, DWORD flags);

#define IDC_DEFAULT         0x0001
#define IDC_CHILDRENONLY    0x0002
#define IDC_CLIENTONLY      0x0004
#define IDC_MOVEBLT         0x0008
#define IDC_NOMOUSE         0x0010

/*
 * RestoreSpb return Flags
 */

#define RSPB_NO_INVALIDATE      0   // nothing invalidated by restore
#define RSPB_INVALIDATE         1   // restore invalidate some area
#define RSPB_INVALIDATE_SSB     2   // restore called SaveScreenBits which invalidated

// Calls Proc directly without doing any messages translation

#define SCMS_FLAGS_ANSI         0x0001
#define SCMS_FLAGS_INONLY       0x0002      // Message should be one way (hooks)

#define CallClientProcA(pwnd, msg, wParam, lParam, xpfn) \
            SfnDWORD(pwnd, msg, wParam, lParam, xpfn,          \
                ((PROC)(gpsi->apfnClientW.pfnDispatchMessage)), TRUE, NULL)
#define CallClientProcW(pwnd, msg, wParam, lParam, xpfn) \
            SfnDWORD(pwnd, msg, wParam, lParam, xpfn,          \
                ((PROC)(gpsi->apfnClientW.pfnDispatchMessage)), TRUE, NULL)
#define CallClientWorkerProc(pwnd, msg, wParam, lParam, xpfn) \
            SfnDWORD(pwnd, msg, wParam, lParam, 0, xpfn, TRUE, NULL)
#define ScSendMessageSMS(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms) \
        (((msg) & ~MSGFLAG_MASK) >= WM_USER) ? \
        SfnDWORD(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms) : \
        gapfnScSendMessage[MessageTable[msg & 0xffff].iFunction](pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, psms)
#define ScSendMessage(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags) \
        ScSendMessageSMS(pwnd, msg, wParam, lParam, xParam, xpfn, dwSCMSFlags, NULL)

/*
 * Server-side routines for loading cursors/icons/strings/menus from server.
 */
#define SERVERSTRINGMAXSIZE  40
void RtlInitUnicodeStringOrId(PUNICODE_STRING pstrName, LPWSTR lpstrName);
int RtlLoadStringOrError(UINT, LPTSTR, int, WORD);
#define ServerLoadString(hmod, id, p, cch)\
        RtlLoadStringOrError(id, p, cch, 0)
#define ServerLoadStringEx(hmod, id, p, cch, wLang)\
        RtlLoadStringOrError(id, p, cch, wLang)

/*
 * Callback routines for loading resources from client.
 */
HANDLE xxxClientLoadImage(
    PUNICODE_STRING pstrName,
    ATOM atomModName,
    WORD wImageType,
    int cxSize,
    int cySize,
    UINT LR_flags,
    BOOL fWallpaper);

HANDLE xxxClientCopyImage(
    IN HANDLE          hImage,
    IN UINT            uImageType,
    IN int             cxDesired,
    IN int             cyDesired,
    IN UINT            LR_flags);

PMENU xxxClientLoadMenu(
    HANDLE hmod,
    PUNICODE_STRING pstrName);

int xxxClientAddFontResourceW(PUNICODE_STRING, DWORD, DESIGNVECTOR*);

VOID ClientFontSweep(VOID);
VOID ClientLoadLocalT1Fonts();
VOID ClientLoadRemoteT1Fonts();

/*
 * Server-side routine for thread initialization.
 */
NTSTATUS InitializeClientPfnArrays(
    CONST PFNCLIENT *ppfnClientA,
    CONST PFNCLIENT *ppfnClientW,
    CONST PFNCLIENTWORKER *ppfnClientWorker,
    HANDLE hModUser);

//VOID _SetDebugErrorLevel(DWORD);
VOID _SetRipFlags(DWORD, DWORD);
VOID _SetDbgTag(int, DWORD);


/*
 * xxxActivateWindow() commands
 */
#define AW_USE       1
#define AW_TRY       2
#define AW_SKIP      3
#define AW_TRY2      4
#define AW_SKIP2     5      /* used internally in xxxActivateWindow() */
#define AW_USE2      6      /* nc mouse activation added by craigc */

/*
 * Structure for WM_ACTIVATEAPP EnumWindows() callback.
 */
typedef struct tagAAS {
    PTHREADINFO ptiNotify;
    DWORD tidActDeact;
    UINT fActivating  : 1;
    UINT fQueueNotify : 1;
} AAS;

/*
 * Declaration for EnumWindows() callback function.
 */
BOOL xxxActivateApp(PWND pwnd, AAS *paas);

#define GETDESKINFO(pti)  ((pti)->pDeskInfo)

#define SET_TIME_LAST_READ(pti)     ((pti)->pcti->timeLastRead = NtGetTickCount())
#define GET_TIME_LAST_READ(pti)     ((pti)->pcti->timeLastRead)


/*
 * General purpose helper macros
 */
#define abs(A)      (((A) < 0)? -(A) : (A))

#define N_ELEM(a)     (sizeof(a)/sizeof(a[0]))
#define LAST_ELEM(a)  ( (a) [ N_ELEM(a) - 1 ] )
#define PLAST_ELEM(a) (&LAST_ELEM(a))


/*
 * General purpose access check macro
 */
#define RETURN_IF_ACCESS_DENIED(amGranted, amRequested, r) \
        if (!CheckGrantedAccess((amGranted), (amRequested))) return r

/*
 * Lock record structure for tracking locks (debug only)
 */

#define LOCKRECORD_STACK    8
#define LOCKRECORD_MARKDESTROY  IntToPtr( 0xFFFFFFFF )

typedef struct _LOCKRECORD {
    PLR    plrNext;
    DWORD  cLockObj;
    PVOID  ppobj;
    PVOID  trace[LOCKRECORD_STACK];
} LOCKRECORD;

/*
 * We limit recursion until we have only this much stack left.
 * We have to leave room for kernel interupts
 */
#define KERNEL_STACK_MINIMUM_RESERVE  (4*1024)

/*
 * And this much of Back storing in IA64
 */
#if defined(_IA64_)
#define KERNEL_BSTORE_MINIMUM_RESERVE (4*1024)
#define GET_CURRENT_BSTORE() ((ULONG_PTR)PsGetCurrentThreadStackBase() + KERNEL_LARGE_BSTORE_SIZE - __getReg(CV_IA64_RsBSP))
#endif // _IA64_

#if DBG
#if defined(_IA64_)
#define GET_USED_BSTORE_SIZE()  (__getReg(CV_IA64_RsBSP) - (ULONG_PTR)PsGetCurrentThreadStackBase())
#define ASSERT_BSTORE()  UserAssert(GET_CURRENT_BSTORE() > KERNEL_BSTORE_MINIMUM_RESERVE)
#else // _IA64_
#define ASSERT_BSTORE()
#endif // _IA64_

#define ASSERT_STACK() \
    UserAssert(IoGetRemainingStackSize() > KERNEL_STACK_MINIMUM_RESERVE); \
    ASSERT_BSTORE()

__inline ULONG_PTR GET_USED_STACK_SIZE(
    VOID)
{
    ULONG_PTR uLocVer;
    return ((ULONG_PTR)PsGetCurrentThreadStackBase() - (ULONG_PTR)&uLocVer);
}
#endif // DBG

/*
 * The following is a LOCK structure. This structure is recorded for
 * each threadlock so unlocks can occur at cleanup time.
 */
typedef struct _LOCK {
    PTHREADINFO pti;
    PVOID pobj;
    PTL ptl;
#if DBG
    PVOID pfn;                      // for debugging purposes only
    int ilNext;                     // for debugging purposes only
    int iilPrev;                    // for debugging purposes only
#endif // DBG
} LOCK, *PLOCK;

#define NEEDSSYNCPAINT(pwnd) TestWF(pwnd, WFSENDERASEBKGND | WFSENDNCPAINT)

typedef struct tagCVR       // cvr
{
    WINDOWPOS   pos;        // MUST be first field of CVR!
    int         xClientNew; // New client rectangle
    int         yClientNew;
    int         cxClientNew;
    int         cyClientNew;
    RECT        rcBlt;
    int         dxBlt;      // Distance blt rectangle is moving
    int         dyBlt;
    UINT        fsRE;       // RE_ flags: whether hrgnVisOld is empty or not
    HRGN        hrgnVisOld; // Previous visrgn
    PTHREADINFO pti;        // The thread this SWP should be processed on
    HRGN        hrgnClip;   // Window clipping region
    HRGN        hrgnInterMonitor;  // multimon support
} CVR, *PCVR;

/*
 * CalcValidRects() "Region Empty" flag values
 * A set bit indicates the corresponding region is empty.
 */
#define RE_VISNEW       0x0001  // CVR "Region Empty" flag values
#define RE_VISOLD       0x0002  // A set bit indicates the
#define RE_VALID        0x0004  // corresponding region is empty.
#define RE_INVALID      0x0008
#define RE_SPB          0x0010
#define RE_VALIDSUM     0x0020
#define RE_INVALIDSUM   0x0040

typedef struct tagSMWP {    // smwp
    HEAD           head;
    UINT           bShellNotify:1; // The acvr list contains shell notify flags
    UINT           bHandle:1;   // This is an HM object allocation -- See -BeginDeferWindowPos
    /*
     * All fields AFTER ccvr are preserved when reusing the global SMWP structure.
     */
    int            ccvr;        // Number of CVRs in the SWMP
    int            ccvrAlloc;   // Number of actual CVRs allocated in the SMWP
    PCVR           acvr;        // Pointer to array of CVR structures
} SMWP, *PSMWP;

void DestroySMWP(PSMWP psmwp);

/*
 * Clipboard data object definition
 */
typedef struct tagCLIPDATA {
    HEAD    head;
    DWORD   cbData;
    BYTE    abData[0];
} CLIPDATA, *PCLIPDATA;

/*
 * Private User Startupinfo
 */
typedef struct tagUSERSTARTUPINFO {
    DWORD   cb;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
} USERSTARTUPINFO, *PUSERSTARTUPINFO;

/*
 * TLBLOCK structure for multiple threads locking.
 */
#define THREADS_PER_TLBLOCK 16

typedef struct tagTLBLOCK {
    struct      tagTLBLOCK *ptlBlockPrev;
    struct {
        PTHREADINFO pti;
        TL          tlpti;
        DWORD       dwFlags;
#if DBG
        DWORD       dwUnlockedCount;
#endif
    } list[THREADS_PER_TLBLOCK];
} TLBLOCK, *PTLBLOCK;

/*
 * Keyboard File object
 */
typedef struct tagKBDFILE {
    HEAD               head;
    struct tagKBDFILE *pkfNext;   // next keyboard file
    HANDLE             hBase;     // base address of data
    PKBDTABLES         pKbdTbl;   // pointer to kbd layout data.
    ULONG              Size;      // Size of pKbdTbl
    PKBDNLSTABLES      pKbdNlsTbl; // pointer to kbd nls layout data.
    WCHAR              awchDllName[32];
#ifdef LATER
    LANGID             langId;    // Default language ID of this layout
#endif
} KBDFILE, *PKBDFILE;

/*
 * Keyboard Layout object
 */
typedef struct tagKL {   /* kl */
    HEAD          head;
    struct tagKL *pklNext;     // next in layout cycle
    struct tagKL *pklPrev;     // prev in layout cycle
    DWORD         dwKL_Flags;  // KL_* flags
    HKL           hkl;         // (Layout ID | Base Language ID)
    KBDFILE      *spkf;        // Keyboard Layout File
    KBDFILE      *spkfPrimary; // Primary keyboard layout file
    DWORD         dwFontSigs;  // mask of FS_xxx bits - fonts that layout is good for
    UINT          iBaseCharset;// Charset value (Win95 compat) eg: ANSI_CHARSET
    WORD          CodePage;    // Windows Codepage of kbd layout, eg: 1252, 1250
    WCHAR         wchDiacritic;// Dead key saved here until next keystroke
    PIMEINFOEX    piiex;       // Extended information for IME based layout
    UINT          uNumTbl;     // number of tables in pKbdTbl
    PKBDFILE     *pspkfExtra;  // extra layout file in this
    DWORD         dwLastKbdType;
    DWORD         dwLastKbdSubType;
    DWORD         dwKLID;      // base keyboard layout ID
} KL, *PKL;

/*
 * Flag values for KL dwFlags
 */
#define KL_UNLOADED 0x20000000
#define KL_RESET    0x40000000


PKL HKLtoPKL(PTHREADINFO pti, HKL hkl);

typedef struct tagKBDLANGTOGGLE
{
    BYTE bVkey;
    BYTE bScan;
    int  iBitPosition;
} KBDLANGTOGGLE;

/*
 * These constants are derived from combinations of
 * iBitPosition (refer to the LangToggle array defined
 * in globals.c).
 */

/*
 * This bit is used for both control and alt keys
 */
#define KLT_ALT              1

/*
 * This bit is used for the left shift key
 */
#define KLT_LEFTSHIFT        2

/*
 * This combination denotes ctrl/alt and the left shift key
 */
#define KLT_ALTLEFTSHIFT     3

/*
 * This bit is used for the right shift key
 */
#define KLT_RIGHTSHIFT       4

/*
 * This combination denotes ctrl/alt and the right shift key
 */
#define KLT_ALTRIGHTSHIFT    5

/*
 * This combination denotes ctrl/alt and both the shift keys
 */
#define KLT_ALTBOTHSHIFTS    7

/*
 * This value is used to mark invalid toggle key sequence
 */
#define KLT_NONE             8


/*
 * Key Event (KE) structure
 * Stores a Virtual Key event
 */
typedef struct tagKE {
    union {
        BYTE bScanCode;    // Virtual Scan Code (Set 1)
        WCHAR wchInjected; // Unicode char from SendInput()
    };
    USHORT usFlaggedVk;    // Vk | Flags
    DWORD  dwTime;         // time in milliseconds
#ifdef GENERIC_INPUT
    HANDLE hDevice;
    KEYBOARD_INPUT_DATA data;
#endif
} KE, *PKE;

/*
 * Misc. keyboard stuff moved from oak/inc/kbd.h
 */
typedef BOOL (* KEPROC)(PKE pKe);
typedef BOOL (* NLSKEPROC)(PKE pKe, ULONG_PTR dwExtraInfo, ULONG dwParam);
typedef BOOL (* NLSVKFPROC)(PVK_F pVkToF, PKE pKe, ULONG_PTR dwExtraInfo);

/*
 * OEM-specific special processing (keystroke simulators and filters)
 */
extern KEPROC aKEProcOEM[];


/*
 * Key message lParam bits
 */
#define EXTENDED_BIT   0x01000000
#define DONTCARE_BIT   0x02000000
#define FAKE_KEYSTROKE 0x02000000
#define ALTNUMPAD_BIT  0x04000000 // copied from windows\inc\wincon.w

/*
 * For handy diacritics
 */
#define IDS_FROM_SCANCODE(prefix, base) \
        (0xc000 + ((0x ## prefix) >= 0xE0 ? 0x100 : 0) + (0x ## base))

//
// NLS Keyboard functions
//
VOID NlsKbdInitializePerSystem(VOID);
VOID NlsKbdSendIMENotification(DWORD dwImeOpen, DWORD dwImeConversion);

/*
 * Desktop flags
 */
#define DF_DYING            0x80000000
#define DF_DESKWNDDESTROYED 0x40000000
#define DF_DESTROYED        0x20000000
#define DF_HOTTRACKING      0x10000000
#define DF_TOOLTIPSHOWING   0x08000000
#define DF_TOOLTIPACTIVE    0x04000000
#define DF_TOOLTIP          (DF_TOOLTIPACTIVE | DF_TOOLTIPSHOWING)
#define DF_TRACKMOUSELEAVE  0x02000000
#define DF_TRACKMOUSEHOVER  0x01000000
#define DF_TRACKMOUSEEVENT  (DF_TRACKMOUSELEAVE | DF_TRACKMOUSEHOVER)
#define DF_MOUSEMOVETRK     (DF_HOTTRACKING | DF_TOOLTIPACTIVE | DF_TRACKMOUSELEAVE | DF_TRACKMOUSEHOVER)
#define DF_MENUINUSE        0x00800000
#define DF_NEWDISPLAYSETTINGS 0x00400000
#define DF_DESKCREATED      0x00200000
#define DF_REDIRECTED       0x00100000
#ifdef BUG365290
#define DF_QUITUNLOCK       0x00080000
#define DF_NOTRITUNLOCK     0x00040000
#define DF_ZOMBIE           0x00020000
#define DF_ACTIVEONDESTROY  0X00010000
#define DF_DTNONEWDESKTOP   0x00008000
#define DF_SKIPSWITCHDESKTOP 0x00004000
#endif //BUG365290


#define CAPTIONTOOLTIPLEN   100

/*
 * Used to identify desktops uniquely for GDI
 */

#define GW_DESKTOP_ID 1

// #define DESKTOP_ALLOC_TRACE
#define DESKTOP_ALLOC_TRACE_SIZE    6

#if DBG
    typedef struct tagDbgAllocHead {
        DWORD    mark;
        DWORD    tag;
        PDESKTOP pdesk;
        SIZE_T   size;                  // the size of the allocation (doesn't include
                                        // this structure

        struct tagDbgAllocHead* pPrev;  // pointer to the previous allocation of this tag
        struct tagDbgAllocHead* pNext;  // pointer to the next allocation of this tag

#ifdef DESKTOP_ALLOC_TRACE
        PVOID  trace[DESKTOP_ALLOC_TRACE_SIZE];
#endif // DESKTOP_ALLOC_TRACE

    } DbgAllocHead, *PDbgAllocHead;
#endif // DBG

#define DTAG_CLASS              0x0001
#define DTAG_DESKTOPINFO        0x0002
#define DTAG_CLIENTTHREADINFO   0x0003
#define DTAG_TEXT               0x0004
#define DTAG_HANDTABL           0x0005
#define DTAG_SBINFO             0x0006
#define DTAG_MENUITEM           0x0007
#define DTAG_MENUTEXT           0x0008
#define DTAG_IMETEXT            0x0009
#define DTAG_PROPLIST           0x000A

/*
 * Desktop Structure.
 *
 *   This structure is only viewable from the kernel. If any desktop
 *   information is needed in the client, then they should reference off
 *   the pDeskInfo field (i.e. pti->pDeskInfo).
 */
typedef struct tagDESKTOP {

    DWORD                   dwSessionId;       // Terminal Server SessionId. This has to be first field in the structure
    PDESKTOPINFO            pDeskInfo;         // Desktop information
    PDISPLAYINFO            pDispInfo;         //

    PDESKTOP                 rpdeskNext;       // Next desktop in list
    PWINDOWSTATION           rpwinstaParent;   // Windowstation owner

    DWORD                   dwDTFlags;         // Desktop flags
    ULONG                   dwDesktopId;       // Needed by GDI to tag display devices

    PWND                     spwndMenu;        //
    PMENU                    spmenuSys;        //
    PMENU                    spmenuDialogSys;  //
    PMENU                    spmenuHScroll;
    PMENU                    spmenuVScroll;
    PWND                     spwndForeground;  //
    PWND                     spwndTray;
    PWND                     spwndMessage;
    PWND                     spwndTooltip;

    HANDLE                  hsectionDesktop;   //
    PWIN32HEAP              pheapDesktop;      //
    DWORD                   dwConsoleThreadId; //
    DWORD                   dwConsoleIMEThreadId;
    CONSOLE_CARET_INFO      cciConsole;
    LIST_ENTRY              PtiList;           //

    PWND                    spwndTrack;        // xxxTrackMouseMove data
    int                     htEx;
    RECT                    rcMouseHover;
    DWORD                   dwMouseHoverTime;


#ifdef LOGDESKTOPLOCKS
    int                     nLockCount;
    int                     nLogMax;
    int                     nLogCrt;
    PLogD                   pLog;
#endif // LOGDESKTOPLOCKS

} DESKTOP;

typedef struct tagDESKWND {
    WND   wnd;
    DWORD idProcess;
    DWORD idThread;
} DESKWND, *PDESKWND;

PVOID DesktopAlloc(PDESKTOP pdesk, UINT uSize,DWORD tag);

#define DesktopAllocAlways(pdesk, uSize, tag)   \
            Win32HeapAlloc(pdesk->pheapDesktop, uSize, tag, 0)

#define DesktopFree(pdesk, p)   Win32HeapFree(pdesk->pheapDesktop, p)

/*
 * Windowstation structure
 */
#define WSF_SWITCHLOCK          0x0001
#define WSF_OPENLOCK            0x0002
#define WSF_NOIO                0x0004
#define WSF_SHUTDOWN            0x0008
#define WSF_DYING               0x0010
#define WSF_REALSHUTDOWN        0x0020

typedef struct tagWINDOWSTATION {
    /*
     * Terminal Server SessionId. This has to be first field in the structure.
     */
    DWORD                dwSessionId;
    PWINDOWSTATION       rpwinstaNext;
    PDESKTOP             rpdeskList;

    PTERMINAL            pTerm;

    DWORD                dwWSF_Flags;
    struct tagKL         *spklList;

    /*
     * Clipboard variables
     */
    PTHREADINFO          ptiClipLock;
    PTHREADINFO          ptiDrawingClipboard;
    PWND                 spwndClipOpen;
    PWND                 spwndClipViewer;
    PWND                 spwndClipOwner;
    struct tagCLIP       *pClipBase;
    int                  cNumClipFormats;
    UINT                 iClipSerialNumber;
    UINT                 iClipSequenceNumber;
    UINT                 fClipboardChanged : 1;
    UINT                 fInDelayedRendering : 1;

    /*
     * Global Atom table
     */
    PVOID                pGlobalAtomTable;

    LUID                 luidEndSession;
    LUID                 luidUser;
    PSID                 psidUser;
    PQ                   pqDesktop;

    /*
     * Pointer to the currently active desktop for the window station.
     */
#if DBG
    PDESKTOP             pdeskCurrent;
#endif // DBG

} WINDOWSTATION;

typedef struct tagCAPTIONCACHE {
    PCURSOR         spcursor;
    POEMBITMAPINFO  pOem;
#if DBG
    HICON           hico;
#endif // DBG
} CAPTIONCACHE;

/*
 * Configurable icon and cursor stuff
 */
    typedef struct tagSYSCFGICO
    {
        WORD    Id;     // configurable id (OIC_ or OCR_ value)
        WORD    StrId;  // String ID for registry key name
        PCURSOR spcur;  // perminant cursor/icon pointer
    } SYSCFGICO;

    #define SYSICO(name) (gasysico[OIC_##name##_DEFAULT - OIC_FIRST_DEFAULT].spcur)
    #define SYSCUR(name) (gasyscur[OCR_##name##_DEFAULT - OCR_FIRST_DEFAULT].spcur)


/*
 * Accelerator Table structure
 */
typedef struct tagACCELTABLE {
    PROCOBJHEAD head;
    UINT        cAccel;
    ACCEL       accel[1];
} ACCELTABLE, *LPACCELTABLE;

/*
 * Besides the desktop window used by the current thread, we also
 * need to get the desktop window of a window and the input desktop
 * window.
 */
#define PWNDDESKTOP(p)      ((p)->head.rpdesk->pDeskInfo->spwnd)
#define PWNDMESSAGE(p)      ((p)->head.rpdesk->spwndMessage)
#define PWNDTOOLTIP(p)      ((p)->head.rpdesk->spwndTooltip)

/*
 * During window destruction, even a locked window can have a
 * NULL parent so use this macro where a NULL parent is a problem.
 */
#define PWNDPARENT(p) (p->spwndParent ? p->spwndParent : PWNDDESKTOP(p))

#define ISAMENU(pwwnd)       \
        (GETFNID(pwnd) == FNID_MENU)


/* NEW MENU STUFF */
typedef struct tagPOPUPMENU
{

  DWORD  fIsMenuBar:1;       /* This is a hacked struct which refers to the
                              * menu bar associated with a app. Only true if
                              * in the root ppopupMenuStruct.
                              */
  DWORD  fHasMenuBar:1;      /* This popup is part of a series which has a
                              * menu bar (either a sys menu or top level menu
                              * bar)
                              */
  DWORD  fIsSysMenu:1;    /* The system menu is here. */
  DWORD  fIsTrackPopup:1;    /* Is TrackPopup popup menu */
  DWORD  fDroppedLeft:1;
  DWORD  fHierarchyDropped:1;/* If true, a submenu has been dropped off this popup */
  DWORD  fRightButton:1;     /* Allow right button in menu */
  DWORD  fToggle:1;          /* If TRUE, button up cancels the popup */
  DWORD  fSynchronous:1;     /* For synchronous return value of cmd chosen */
  DWORD  fFirstClick:1;      /* Keep track if this was the first click on the
                              * top level menu bar item. If the user down/up
                              * clicks on a top level menu bar item twice, we
                              * want to cancel menu mode.
                              */
  DWORD  fDropNextPopup:1;   /* Should we drop hierarchy of next menu item w/ popup? */
  DWORD  fNoNotify:1;        /* Don't send WM_ msgs to owner, except WM_COMMAND  */
  DWORD  fAboutToHide:1;     // Same purpose as fHideTimer?
  DWORD  fShowTimer:1;       // TRUE if the IDSYS_MNSHOW timer is set
  DWORD  fHideTimer:1;       // TRUE if the IDSYS_MNHIDE timer is set

  DWORD  fDestroyed:1;       /* Set when the owner menu window has been destroyed
                              *  so the popup can be freed once it's no longer needed
                              * Also set in root popupmenu when menu mode must end
                              */

  DWORD  fDelayedFree:1;    /* Avoid freeing the popup when the owner menu
                             *  window is destroyed.
                             * If set, it must be a root popupmenu or must
                             *  be linked in ppmDelayedFree
                             * This is eventually set for all hierarchical popups
                             */

  DWORD  fFlushDelayedFree:1; /* Used in root popupmenus only.
                               * Set when a hierarchical popup marked as fDelayedFree
                               *  has been destroyed.
                               */


  DWORD  fFreed:1;           /* Popup has been freed. Used for debug only */

  DWORD  fInCancel:1;        /* Popup has been passed to xxxMNCancel */

  DWORD  fTrackMouseEvent:1; /* TrackMouseEvent has been called */
  DWORD  fSendUninit:1;      /* Send WM_UNINITMENUPOPUP */
  DWORD  fRtoL:1;            /* For going backwards with the keys */
  DWORD  fDesktopMenu:1;     /* Set if this popup belons to the pdesk->spwndMenu window */
  DWORD  iDropDir:5;         /* Animation direction */


  PWND           spwndNotify;
                        /* Window who gets the notification messages. If this
                         * is a window with a menu bar, then this is the same
                         * as hwndPopupMenu.
                         */
  PWND           spwndPopupMenu;
                        /* The window associated with this ppopupMenu struct.
                         * If this is a top level menubar, then hwndPopupMenu
                         * is the window the menu bar. ie. it isn't really a
                         * popup menu window.
                         */
  PWND           spwndNextPopup;
                        /* The next popup in the hierarchy. Null if the last
                         * in chain
                         */
  PWND           spwndPrevPopup;
                        /* The previous popup in the hierarchy. NULL if at top
                         */
  PMENU          spmenu;/* The PMENU displayed in this window
                         */
  PMENU          spmenuAlternate;
                        /* Alternate PMENU. If the system menu is displayed,
                         * and a menubar menu exists, this will contain the
                         * menubar menu. If menubar menu is displayed, this
                         * will contain the system menu. Use only on top level
                         * ppopupMenu structs so that we can handle windows
                         * with both a system menu and a menu bar menu. Only
                         * used in the root ppopupMenuStruct.
                         */

  PWND           spwndActivePopup; /* This is the popup the mouse/"keyboard focus" is on */

  PPOPUPMENU     ppopupmenuRoot;

  PPOPUPMENU     ppmDelayedFree;       /* List of hierarchical popups marked
                                        *  as fDelayedFree.
                                        */

  UINT   posSelectedItem;  /* Position of the selected item in this menu
                            */
  UINT   posDropped;

} POPUPMENU;

typedef struct tagMENUWND {
    WND wnd;
    PPOPUPMENU ppopupmenu;
} MENUWND, *PMENUWND;

/*
 * CheckPoint structure
 */
typedef struct tagCHECKPOINT {
    RECT rcNormal;
    POINT ptMin;
    POINT ptMax;
    DWORD fDragged:1;
    DWORD fWasMaximizedBeforeMinimized:1;
    DWORD fWasMinimizedBeforeMaximized:1;
    DWORD fMinInitialized:1;
    DWORD fMaxInitialized:1;
} CHECKPOINT, *PCHECKPOINT;

typedef struct tagCLIP {
    UINT    fmt;
    HANDLE  hData;
    BOOL    fGlobalHandle;
} CLIP, *PCLIP;

/*
 * DDEML instance structure
 */
typedef struct tagSVR_INSTANCE_INFO {
    THROBJHEAD head;
    struct tagSVR_INSTANCE_INFO *next;
    struct tagSVR_INSTANCE_INFO *nextInThisThread;
    DWORD afCmd;
    PWND spwndEvent;
    PVOID pcii;
} SVR_INSTANCE_INFO, *PSVR_INSTANCE_INFO;

typedef struct tagPUBOBJ {
    struct tagPUBOBJ *next;
    HANDLE hObj;
    int count;
    W32PID pid;
} PUBOBJ, *PPUBOBJ;

/*
 * Defines for Menu focus
 */
#define FREEHOLD    0
#define MOUSEHOLD  -1 /* Mouse button held down and dragging */
#define KEYBDHOLD   1

/*
 * Structure definition for messages as they exist on a Q. Same as MSG
 * structure except for the link-pointer and flags at the end.
 */
typedef struct tagQMSG {
    PQMSG           pqmsgNext;
    PQMSG           pqmsgPrev;
    MSG             msg;
    LONG_PTR        ExtraInfo;
    DWORD           dwQEvent;
    PTHREADINFO     pti;
} QMSG;

/*
 * dwQEvent values for QMSG structure.
 */
#define QEVENT_SHOWWINDOW           0x0001
#define QEVENT_CANCELMODE           0x0002
#define QEVENT_SETWINDOWPOS         0x0003
#define QEVENT_UPDATEKEYSTATE       0x0004
#define QEVENT_DEACTIVATE           0x0005
#define QEVENT_ACTIVATE             0x0006
#define QEVENT_POSTMESSAGE          0x0007  // Chicago
#define QEVENT_EXECSHELL            0x0008  // Chicago
#define QEVENT_CANCELMENU           0x0009  // Chicago
#define QEVENT_DESTROYWINDOW        0x000A
#define QEVENT_ASYNCSENDMSG         0x000B
#define QEVENT_HUNGTHREAD           0x000C
#define QEVENT_CANCELMOUSEMOVETRK   0x000D
#define QEVENT_NOTIFYWINEVENT       0x000E
#define QEVENT_RITACCESSIBILITY     0x000F
#define QEVENT_RITSOUND             0x0010
#define QEVENT_APPCOMMAND           0x0011

#define RITSOUND_UPSIREN            0x0000
#define RITSOUND_DOWNSIREN          0x0001
#define RITSOUND_LOWBEEP            0x0002
#define RITSOUND_HIGHBEEP           0x0003
#define RITSOUND_KEYCLICK           0x0004
#define RITSOUND_DOBEEP             0x0005

/*
 * xxxProcessEventMessage flags
 */
#define PEM_ACTIVATE_RESTORE        0x0001
#define PEM_ACTIVATE_NOZORDER       0x0002

typedef struct _MOVESIZEDATA {
    PWND            spwnd;
    RECT            rcDrag;
    RECT            rcDragCursor;
    RECT            rcParent;
    POINT           ptMinTrack;
    POINT           ptMaxTrack;
    RECT            rcWindow;
    int             dxMouse;
    int             dyMouse;
    int             cmd;
    int             impx;
    int             impy;
    POINT           ptRestore;
    UINT            fInitSize         : 1;    // should we initialize cursor pos
    UINT            fmsKbd            : 1;    // who knows
    UINT            fLockWindowUpdate : 1;    // whether screen was locked ok
    UINT            fTrackCancelled   : 1;    // Set if tracking ended by other thread.
    UINT            fForeground       : 1;    // whether the tracking thread is foreground
                                              //  and if we should draw the drag-rect
    UINT            fDragFullWindows  : 1;
    UINT            fOffScreen        : 1;
} MOVESIZEDATA, *PMOVESIZEDATA;

/*
 * DrawDragRect styles.
 */
#define DDR_START     0     // - start drag.
#define DDR_ENDACCEPT 1     // - end and accept
#define DDR_ENDCANCEL 2     // - end and cancel.


/*
 * Pseudo Event stuff. (fManualReset := TRUE, fInitState := FALSE)
 */

DWORD WaitOnPseudoEvent(HANDLE *phE, DWORD dwMilliseconds);

#define PSEUDO_EVENT_ON     ((HANDLE)IntToPtr( 0xFFFFFFFF ))
#define PSEUDO_EVENT_OFF    ((HANDLE)IntToPtr( 0x00000000 ))
#define INIT_PSEUDO_EVENT(ph) *ph = PSEUDO_EVENT_OFF;

#define SET_PSEUDO_EVENT(phE)                                   \
    CheckCritIn();                                              \
    if (*(phE) == PSEUDO_EVENT_OFF) *(phE) = PSEUDO_EVENT_ON;   \
    else if (*(phE) != PSEUDO_EVENT_ON) {                       \
        KeSetEvent(*(phE), EVENT_INCREMENT, FALSE);             \
        ObDereferenceObject(*(phE));                            \
        *(phE) = PSEUDO_EVENT_ON;                               \
    }

#define RESET_PSEUDO_EVENT(phE)                                 \
    CheckCritIn();                                              \
    if (*(phE) == PSEUDO_EVENT_ON) *(phE) = PSEUDO_EVENT_OFF;   \
    else if (*(phE) != PSEUDO_EVENT_OFF) {                      \
        KeClearEvent(*(phE));                                   \
    }

#define CLOSE_PSEUDO_EVENT(phE)                                 \
    CheckCritIn();                                              \
    if (*(phE) == PSEUDO_EVENT_ON) *(phE) = PSEUDO_EVENT_OFF;   \
    else if (*(phE) != PSEUDO_EVENT_OFF) {                      \
        KeSetEvent(*(phE), EVENT_INCREMENT, FALSE);             \
        ObDereferenceObject(*(phE));                            \
        *(phE) = PSEUDO_EVENT_OFF;                              \
    }

typedef struct tagMLIST {
    PQMSG pqmsgRead;        // next message to be read. This is a FIFO queue
    PQMSG pqmsgWriteLast;   // last message  added to the queue. Used mainly for coalescing
    DWORD cMsgs;            // Count of messages. Used for optimizations and to enforce a max.
} MLIST, *PMLIST;

/*
 * Message Queue structure.
 *
 * Note, if you need to add a WORD sized value,
 * do so after xbtnDblClk.
 */
typedef struct tagQ {
    MLIST       mlInput;            // raw mouse and key message list.

    PTHREADINFO ptiSysLock;         // Thread currently allowed to process input
    ULONG_PTR    idSysLock;          // Last message removed or to be removed before unlocking
    ULONG_PTR    idSysPeek;          // Last message peeked

    PTHREADINFO ptiMouse;           // Last thread to get mouse msg.
    PTHREADINFO ptiKeyboard;

    PWND        spwndCapture;
    PWND        spwndFocus;
    PWND        spwndActive;
    PWND        spwndActivePrev;

    UINT        codeCapture;        // type of captue. See *_CAP* defines in this file
    UINT        msgDblClk;          // last mouse down message removed
    WORD        xbtnDblClk;         // last xbutton down
    DWORD       timeDblClk;         // max time for next button down to be taken as double click
    HWND        hwndDblClk;         // window that got last button down
    POINT       ptDblClk;           // last button down position. See SYSMET(C?DOUBLECLK)

    BYTE        afKeyRecentDown[CBKEYSTATERECENTDOWN];
    BYTE        afKeyState[CBKEYSTATE];

    CARET       caret;

    PCURSOR     spcurCurrent;
    int         iCursorLevel;       // show/hide count. < 0 if the cursor is not visible

    DWORD       QF_flags;            // QF_ flags go here

    USHORT      cThreads;            // Count of threads using this queue
    USHORT      cLockCount;          // Count of threads that don't want this queue freed

    UINT        msgJournal;         // See SetJournalTimer. Journal message to be delivered when timer goes off
    LONG_PTR    ExtraInfo;          // Extra info for last qmsg read. See GetMessageExtraInfo
} Q;

/*
 * Used for zzzAttachThreadInput()
 */
typedef struct tagATTACHINFO {
    struct tagATTACHINFO *paiNext;
    PTHREADINFO pti1;
    PTHREADINFO pti2;
} ATTACHINFO, *PATTACHINFO;

#define POLL_EVENT_CNT 5

#define IEV_IDLE    0
#define IEV_INPUT   1
#define IEV_EXEC    2
#define IEV_TASK    3
#define IEV_WOWEXEC 4


typedef struct tagWOWTHREADINFO {
    struct tagWOWTHREADINFO *pwtiNext;
    DWORD    idTask;                // WOW task id
    ULONG_PTR idWaitObject;          // pseudo handle returned to parent
    DWORD    idParentProcess;       // process that called CreateProcess
    PKEVENT  pIdleEvent;            // event that WaitForInputIdle will wait on
} WOWTHREADINFO, *PWOWTHREADINFO;

/*
 * Task Data Block structure.
 */
typedef struct tagTDB {
    PTDB            ptdbNext;
    int             nEvents;
    int             nPriority;
    PTHREADINFO     pti;
    PWOWTHREADINFO  pwti;               // per thread info for shared Wow
    WORD            hTaskWow;           // Wow cookie to find apps during shutdown
    WORD            TDB_Flags;             //  bit 0 means setup app
} TDB;

#define TDBF_SETUP 1


/*
 * Hack message for shell to tell them a setup app is exiting.
 * This message is defined in \nt\private\shell\inc, but I really
 * don't want to introduce that dependency in the build. DavidDS
 * has put a check in that file to make sure that the value does not
 * change and refers to this usage. FritzS
 */
#define DTM_SETUPAPPRAN (WM_USER+90)

/*
 * Menu animation GDI objects.
 */
typedef struct tagMENUANIDC
{
    HDC     hdcAni;         // Scratch dc for animation
} MENUANIDC;

/*
 * Menu Control Structure
 */
typedef struct tagMENUSTATE {
    PPOPUPMENU pGlobalPopupMenu;
    DWORD   fMenuStarted : 1;
    DWORD   fIsSysMenu : 1;
    DWORD   fInsideMenuLoop : 1;
    DWORD   fButtonDown:1;
    DWORD   fInEndMenu:1;
    DWORD   fUnderline:1;               /* Shorcut key underlines are shown */
    DWORD   fButtonAlwaysDown:1;        /* The mouse has always been down since the menu started */
    DWORD   fDragging:1;                /* Dragging (in DoDragDrop) or about to */
    DWORD   fModelessMenu:1;            /* No modal loop */
    DWORD   fInCallHandleMenuMessages:1;/* processing a msg from CallHandleMM */
    DWORD   fDragAndDrop:1;             /* This menu can do drag and drop */
    DWORD   fAutoDismiss:1;             /* This menu goes away on its own if mouse is off for certain time */
    DWORD   fAboutToAutoDismiss:1;      /* Autodismiss will take place when timer goes off */
    DWORD   fIgnoreButtonUp:1;          /* Eat next button up, i.e, cancel dragging */
    DWORD   fMouseOffMenu:1;            /* Mouse is off the menu - modeless menus only */
    DWORD   fInDoDragDrop:1;            /* in a WM_MENUDODRAGDROP callback */
    DWORD   fActiveNoForeground:1;      /* A menu window is active but we're not in the foreground */
    DWORD   fNotifyByPos:1;             /* Use WM_MENUCOMMAND */
    DWORD   fSetCapture:1;              /* True if the menu mode set capture */
    DWORD   iAniDropDir:5;              /* direction of animation */

    POINT   ptMouseLast;
    int     mnFocus;
    int     cmdLast;
    PTHREADINFO ptiMenuStateOwner;

    DWORD   dwLockCount;

    struct tagMENUSTATE *pmnsPrev;      /* Previous menustate for nested/context menus */

    POINT   ptButtonDown;               /* Mouse down position (begin drag position) */
    ULONG_PTR uButtonDownHitArea;        /* Return from xxxMNFindWindowFromPoint on button down */
    UINT    uButtonDownIndex;           /* Index of the item being dragged */

    int     vkButtonDown;               /* Mouse button being dragged */

    ULONG_PTR uDraggingHitArea;          /* Last hit area while InDoDragDrop */
    UINT    uDraggingIndex;             /* Last index  */
    UINT    uDraggingFlags;             /* Gap flags */

    HDC     hdcWndAni;      // window DC while animating
    DWORD   dwAniStartTime; // starting time of animation
    int     ixAni;          // current x-step in animation
    int     iyAni;          // current y-step in animation
    int     cxAni;          // total x in animation
    int     cyAni;          // total y in animation
    HBITMAP hbmAni;         // Scratch bmp for animation.

    /*
     * Important: The following structure must be the last
     *  thing in tagMENUSTATE. MNAllocMenuState doesn't NULL out
     *  this structure
     */
    MENUANIDC;

} MENUSTATE, *PMENUSTATE;

typedef struct tagLASTINPUT {  /* linp */
    DWORD timeLastInputMessage;
    DWORD dwFlags;
    PTHREADINFO ptiLastWoken;  /* Last thread woken by key or click  */
                               /* It can be NULL                     */
    POINT ptLastClick;         /* point of the last mouse click      */
} LASTINPUT, PLASTINPUT;

#define LINP_KEYBOARD       0x00000001
#define LINP_SCREENSAVER    0x00000002
#define LINP_LOWPOWER       0x00000004
#define LINP_POWEROFF       0x00000008
#define LINP_JOURNALLING    0x00000010
#define LINP_INPUTSOURCES   (LINP_KEYBOARD | LINP_JOURNALLING)
#define LINP_POWERTIMEOUTS  (LINP_LOWPOWER | LINP_POWEROFF)
#define LINP_INPUTTIMEOUTS  (LINP_SCREENSAVER | LINP_LOWPOWER | LINP_POWEROFF)

/*
 * Menu data to be passed to xxxRealDrawMenuItem from xxxDrawState
 */
typedef struct {
    PMENU pMenu;
    PITEM pItem;
} GRAYMENU;
typedef GRAYMENU *PGRAYMENU;


#define IS_THREAD_RESTRICTED(pti, r)                            \
    ((pti->TIF_flags & TIF_RESTRICTED) ?                        \
        (pti->ppi->pW32Job->restrictions & (r)) :               \
        FALSE)

#define IS_CURRENT_THREAD_RESTRICTED(r)                         \
    ((PtiCurrent()->TIF_flags & TIF_RESTRICTED) ?               \
        (PtiCurrent()->ppi->pW32Job->restrictions & (r)) :      \
        FALSE)

/*
 * These types are needed before they are fully defined.
 */
typedef struct tagSMS               * KPTR_MODIFIER PSMS;

/*
 * Make sure this structure matches up with W32THREAD, since they're
 * really the same thing.
 */

/*
 * NOTE -- this structure has been sorted (roughly) in order of use
 * of the fields. The x86 code set allows cheaper access to fields
 * that are in the first 0x80 bytes of a structure. Please attempt
 * to ensure that frequently-used fields are below this boundary.
 *          FritzS
 */

typedef struct tagTHREADINFO {
    W32THREAD;

//***************************************** begin: USER specific fields

    PTL             ptl;                // Listhead for thread lock list

    PPROCESSINFO    ppi;                // process info struct for this thread

    PQ              pq;                 // keyboard and mouse input queue

    PKL             spklActive;         // active keyboard layout for this thread

    PCLIENTTHREADINFO pcti;             // Info that must be visible from client

    PDESKTOP        rpdesk;
    PDESKTOPINFO    pDeskInfo;          // Desktop info visible to client
    PCLIENTINFO     pClientInfo;        // Client info stored in TEB

    DWORD           TIF_flags;          // TIF_ flags go here.

    PUNICODE_STRING pstrAppName;        // Application module name.

    PSMS            psmsSent;           // Most recent SMS this thread has sent
    PSMS            psmsCurrent;        // Received SMS this thread is currently processing
    PSMS            psmsReceiveList;    // SMSs to be processed

    LONG            timeLast;           // Time and ID of last message
    ULONG_PTR       idLast;

    int             exitCode;

    HDESK           hdesk;              // Desktop handle
    int             cPaintsReady;
    UINT            cTimersReady;

    PMENUSTATE      pMenuState;

    union {
        PTDB            ptdb;           // Win16Task Schedule data for WOW thread
        PWINDOWSTATION  pwinsta;        // Window station for SYSTEM thread
    };

    PSVR_INSTANCE_INFO psiiList;        // thread DDEML instance list
    DWORD           dwExpWinVer;
    DWORD           dwCompatFlags;      // The Win 3.1 Compat flags
    DWORD           dwCompatFlags2;     // new DWORD to extend compat flags for NT5+ features

    PQ              pqAttach;           // calculation variabled used in
                                        // zzzAttachThreadInput()

    PTHREADINFO     ptiSibling;         // pointer to sibling thread info

    PMOVESIZEDATA   pmsd;

    DWORD           fsHooks;                // WHF_ Flags for which hooks are installed
    PHOOK           sphkCurrent;            // Hook this thread is currently processing

    PSBTRACK        pSBTrack;

    HANDLE          hEventQueueClient;
    PKEVENT         pEventQueueServer;
    LIST_ENTRY      PtiLink;            // Link to other threads on desktop
    int             iCursorLevel;       // keep track of each thread's level
    POINT           ptLast;             // Position of last message

    PWND            spwndDefaultIme;    // Default IME Window for this thread
    PIMC            spDefaultImc;       // Default input context for this thread
    HKL             hklPrev;            // Previous active keyboard layout
    int             cEnterCount;
    MLIST           mlPost;             // posted message list.
    USHORT          fsChangeBitsRemoved;// Bits removed during PeekMessage
    WCHAR           wchInjected;        // character from last VK_PACKET
    DWORD           fsReserveKeys;      // Keys that must be sent to the active
                                        // active console window.
    PKEVENT        *apEvent;            // Wait array for xxxPollAndWaitForSingleObject
    ACCESS_MASK     amdesk;             // Granted desktop access
    UINT            cWindows;           // Number of windows owned by this thread
    UINT            cVisWindows;        // Number of visible windows on this thread

    PHOOK           aphkStart[CWINHOOKS];   // Hooks registered for this thread
    CLIENTTHREADINFO  cti;              // Use this when no desktop is available

#ifdef GENERIC_INPUT
    HANDLE          hPrevHidData;
#endif
#if DBG
    UINT            cNestedCalls;
#endif
} THREADINFO;

#define PWNDTOPSBTRACK(pwnd) (((GETPTI(pwnd)->pSBTrack)))

/*
 * The number of library module handles we can store in the dependency
 * tables. If this exceeds 32, the load mask implementation must be
 * changed.
 */
#define CLIBS           32

/*
 * Process Info structure.
 */
typedef struct tagWOWPROCESSINFO {
    struct tagWOWPROCESSINFO *pwpiNext; // List of WOW ppi's, gppiFirstWow is head
    PTHREADINFO ptiScheduled;           // current thread in nonpreemptive scheduler
    DWORD       nTaskLock;              // nonpreemptive scheduler task lock count
    PTDB        ptdbHead;               // list of this process's WOW tasks
    PVOID       lpfnWowExitTask;        // func addr for wow exittask callback
    PKEVENT     pEventWowExec;          // WowExec Virt HWint scheduler event
    HANDLE      hEventWowExecClient;    // client handle value for wowexec
    DWORD       nSendLock;              // Send Scheduler inter process Send count
    DWORD       nRecvLock;              // Send Scheduler inter process Receive count
    PTHREADINFO CSOwningThread;         // Pseudo Wow CritSect ClientThreadId
    LONG        CSLockCount;            // Pseudo Wow CritSect LockCount
}WOWPROCESSINFO, *PWOWPROCESSINFO;

typedef struct tagDESKTOPVIEW {
    struct tagDESKTOPVIEW *pdvNext;
    PDESKTOP              pdesk;
    ULONG_PTR              ulClientDelta;
} DESKTOPVIEW, *PDESKTOPVIEW;


/*
 * number of DWORDs in ppi->pgh
 */
#define GH_SIZE  8

/*
 * The delta allocation for ppiTable array in W32JOB structure.
 */
#define JP_DELTA  4

/*
 * W32JOB structure
 */
typedef struct tagW32JOB {
    struct tagW32JOB*  pNext;           // next W32JOB structure
    PEJOB              Job;             // pointer to the EJOB structure
    PVOID              pAtomTable;      // the atom table for the job object
    DWORD              restrictions;    // UI restrictions
    UINT               uProcessCount;   // number of processes in ppiTable
    UINT               uMaxProcesses;   // how much room is in ppiTable
    PPROCESSINFO*      ppiTable;        // the array of processes contained in the job
    UINT               ughCrt;          // crt number of handles in pgh
    UINT               ughMax;          // number of handles pgh can store
    PULONG_PTR         pgh;             // the granted handles table
} W32JOB, *PW32JOB;

#ifdef REDIRECTION
#define PF_REDIRECTED            0x00000001
#define PF_REDIRECTIONHOST       0x00000002
#endif // REDIRECTION

/*
 * Make sure this structure matches up with W32PROCESS, since they're
 * really the same thing.
 */

/*
 * NOTE -- this structure has been sorted (roughly) in order of use
 * of the fields. The x86 code set allows cheaper access to fields
 * that are in the first 0x80 bytes of a structure. Please attempt
 * to ensure that frequently-used fields are below this boundary.
 */

typedef struct tagPROCESSINFO {
    W32PROCESS;
//***************************************** begin: USER specific fields
    PTHREADINFO     ptiList;                    // threads in this process
    PTHREADINFO     ptiMainThread;              // pti of "main thread"
    PDESKTOP        rpdeskStartup;              // initial desktop
    PCLS            pclsPrivateList;            // this processes' private classes
    PCLS            pclsPublicList;             // this processes' public classes
    PWOWPROCESSINFO pwpi;                       // Wow PerProcess Info

    PPROCESSINFO    ppiNext;                    // next ppi structure in start list
    PPROCESSINFO    ppiNextRunning;
    int             cThreads;                   // count of threads using this process info
    HDESK           hdeskStartup;               // initial desktop handle
    UINT            cSysExpunge;                // sys expunge counter
    DWORD           dwhmodLibLoadedMask;        // bits describing loaded hook dlls
    HANDLE          ahmodLibLoaded[CLIBS];      // process unique hmod array for hook dlls
    struct          tagWINDOWSTATION *rpwinsta; // process windowstation
    HWINSTA         hwinsta;                    // windowstation handle
    ACCESS_MASK     amwinsta;                   // windowstation accesses

    DWORD           dwHotkey;                   // hot key from progman
    HMONITOR        hMonitor;                   // monitor handle from CreateProcess
    PDESKTOPVIEW    pdvList;                    // list of desktop views
    UINT            iClipSerialNumber;          // clipboard serial number
    RTL_BITMAP      bmHandleFlags;              // per handle flags
    PCURSOR         pCursorCache;               // process cursor/icon cache
    PVOID           pClientBase;                // LEAVE THIS FOR HYDRA; offset to the shared section
    DWORD           dwLpkEntryPoints;           // user mode language pack installed

    PW32JOB         pW32Job;                    // pointer to the W32JOB structure

    DWORD           dwImeCompatFlags;           // per-process Ime Compatibility flags
    LUID            luidSession;                // logon session id
    USERSTARTUPINFO usi;                        // process startup info

#ifdef VALIDATEHANDLEQUOTA
    LONG lHandles;
#endif

    DWORD           dwLayout;                   // the default Window orientation for this process

#ifdef GENERIC_INPUT
    PPROCESS_HID_TABLE pHidTable;               // per process device request list
#endif

#ifdef REDIRECTION
    DWORD           dwRedirection;             // redirection mode for this process
#endif // REDIRECTION
    DWORD           fDisableWindowsGhosting : 1;
} PROCESSINFO;

/*
 * Bit definitions for dwLpkEntryPoints in the processinfo structure.
 * These are passed from the client side when an lpk is registered.
 * The kernel determines when to perform callbacks based on which
 * entry points an lpk supports.
 */
#define LPK_TABBEDTEXTOUT 0x01
#define LPK_PSMTEXTOUT    0x02
#define LPK_DRAWTEXTEX    0x04
#define LPK_EDITCONTROL   0x08
#define LPK_INSTALLED     0x0f

#define CALL_LPK(ptiCurrent)  ((PpiCurrent()->dwLpkEntryPoints & LPK_INSTALLED) && \
                               !((ptiCurrent)->TIF_flags & TIF_INCLEANUP))

/*
 * This is used to send cool switch windows information
 * to the lpk
 */
typedef struct _LPKDRAWSWITCHWND {
    RECT rcRect;
    LARGE_UNICODE_STRING strName;
} LPKDRAWSWITCHWND;

/*
 * DC cache entry structure (DCE)
 *
 *   This structure identifies an entry in the DCE cache. It is
 *   usually initialized at GetDCEx() and cleanded during RelaseCacheDC
 *   calls.
 *
 *   Field
 *   -----
 *
 *   pdceNext       - Pointer to the next DCE entry.
 *
 *
 *   hdc            - GDI DC handle for the dce entry. This will have
 *                    the necessary clipping regions selected into it.
 *
 *   pwndOrg        - Identifies the window in the GetDCEx() call which owns
 *                    the DCE Entry.
 *
 *   pwndClip       - Identifies the window by which the DC is clipped to.
 *                    This is usually done for PARENTDC windows.
 *
 *   hrgnClip       - This region is set if the caller to GetDCEx() passes a
 *                    clipping region in which to intersect with the visrgn.
 *                    This is used when we need to recalc the visrgn for the
 *                    DCE entry. This will be freed at ReleaseCacheDC()
 *                    time if the flag doesn't have DCX_NODELETERGN set.
 *
 *   hrgnClipPublic - This is a copy of the (hrgnClip) passed in above. We
 *                    make a copy and set it as PUBLIC ownership so that
 *                    we can use it in computations during the UserSetDCVisRgn
 *                    call. This is necessary for Full-Hung-Draw where we
 *                    are drawing from a different process then the one
 *                    who created the (hrgnClip). This is always deleted
 *                    in the ReleaseCacheDC() call.
 *
 *   hrgnSavedVis   - This is a copy of the saved visrgn for the DCE entry.
 *
 *   flags          - DCX_ flags.
 *
 *   ptiOwner       - Thread owner of the DCE entry.
 *
 */
typedef struct tagDCE {
    PDCE                 pdceNext;
    HDC                  hdc;
    PWND                 pwndOrg;
    PWND                 pwndClip;
    HRGN                 hrgnClip;
    HRGN                 hrgnClipPublic;
    HRGN                 hrgnSavedVis;
    DWORD                DCX_flags;
    PTHREADINFO          ptiOwner;
    PMONITOR             pMonitor;
} DCE;

#define DCE_SIZE_CACHEINIT        5    // Initial number of DCEs in the cache.
#define DCE_SIZE_CACHETHRESHOLD  32    // Number of dce's as a threshold.

#define DCE_RELEASED              0    // ReleaseDC released
#define DCE_FREED                 1    // ReleaseDC freed
#define DCE_NORELEASE             2    // ReleaseDC in-use.

/*
 * CalcVisRgn DC type bits
 */
#define DCUNUSED        0x00        /* Unused cache entry */
#define DCC             0x01        /* Client area */
#define DCW             0x02        /* Window area */
#define DCSAVEDVISRGN   0x04
#define DCCLIPRGN       0x08
#define DCNOCHILDCLIP   0x10        /* Nochildern clip */
#define DCSAVEVIS       0x20        /* Save visrgn before calculating */
#define DCCACHE         0x40

/*
 * Window List Structure
 */
typedef struct tagBWL {
    struct tagBWL *pbwlNext;
    HWND          *phwndNext;
    HWND          *phwndMax;
    PTHREADINFO   ptiOwner;
    HWND          rghwnd[1];
} BWL, *PBWL;

/*
 * Numbers of HWND slots to to start with and to increase by.
 */
#define BWL_CHWNDINIT      32     /* initial # slots pre-allocated */
#define BWL_CHWNDMORE       8     /* # slots to obtain when required */

#define BWL_ENUMCHILDREN    1
#define BWL_ENUMLIST        2
#define BWL_ENUMOWNERLIST   4

#define BWL_ENUMIMELAST     0x08
#define BWL_REMOVEIMECHILD  0x10

/*
 * Saved Popup Bits structure
 */
typedef struct tagSPB {
    struct tagSPB *pspbNext;
    PWND          spwnd;
    HBITMAP       hbm;
    RECT          rc;
    HRGN          hrgn;
    DWORD         flags;
    ULONG_PTR     ulSaveId;
} SPB;

#define SPB_SAVESCREENBITS  0x0001  // GreSaveScreenBits() was called
#define SPB_LOCKUPDATE      0x0002  // LockWindowUpdate() SPB
#define SPB_DRAWBUFFER      0x0004  // BeginDrawBuffer() SPB

#define AnySpbs()   (gpDispInfo->pspbFirst != NULL)     // TRUE if there are any SPBs

/*
 * Macro to check if the journal playback hook is installed.
 */
#define FJOURNALRECORD()    (GETDESKINFO(PtiCurrent())->aphkStart[WH_JOURNALRECORD + 1] != NULL)
#define FJOURNALPLAYBACK()  (GETDESKINFO(PtiCurrent())->aphkStart[WH_JOURNALPLAYBACK + 1] != NULL)

#define TESTHMODLOADED(pti, x)       ((pti)->ppi->dwhmodLibLoadedMask & (1 << (x)))
#define SETHMODLOADED(pti, x, hmod)  ((pti)->ppi->ahmodLibLoaded[x] = hmod, \
                                      (pti)->ppi->dwhmodLibLoadedMask |= (1 << (x)))
#define CLEARHMODLOADED(pti, x)      ((pti)->ppi->ahmodLibLoaded[x] = NULL, \
                                      (pti)->ppi->dwhmodLibLoadedMask &= ~(1 << (x)))
#define PFNHOOK(phk) (phk->ihmod == -1 ? (PROC)phk->offPfn : \
        (PROC)(((ULONG_PTR)(PtiCurrent()->ppi->ahmodLibLoaded[phk->ihmod])) + \
        ((ULONG_PTR)(phk->offPfn))))

/*
 * Extended structures for message thunking.
 */
typedef struct _CREATESTRUCTEX {
    CREATESTRUCT cs;
    LARGE_STRING strName;
    LARGE_STRING strClass;
} CREATESTRUCTEX, *PCREATESTRUCTEX;

typedef struct _MDICREATESTRUCTEX {
    MDICREATESTRUCT mdics;
    LARGE_STRING strTitle;
    LARGE_STRING strClass;
} MDICREATESTRUCTEX, *PMDICREATESTRUCTEX;

typedef struct _CWPSTRUCTEX {
    struct tagCWPSTRUCT;
    PSMS            psmsSender;
} CWPSTRUCTEX, *PCWPSTRUCTEX;

typedef struct _CWPRETSTRUCTEX {
    LRESULT         lResult;
    struct tagCWPSTRUCT;
    PSMS            psmsSender;
} CWPRETSTRUCTEX, *PCWPRETSTRUCTEX;

/*
 * SendMessage structure and defines.
 */
typedef struct tagSMS {   /* sms */
    PSMS            psmsNext;          // link in global psmsList
#if DBG
    PSMS            psmsSendList;      // head of queue's SendMessage chain
    PSMS            psmsSendNext;      // link in queue's SendMessage chain
#endif // DBG
    PSMS            psmsReceiveNext;   // link in queue's ReceiveList
    DWORD           tSent;              // time message was sent
    PTHREADINFO     ptiSender;          // sending thread
    PTHREADINFO     ptiReceiver;        // receiving thread

    SENDASYNCPROC   lpResultCallBack;   // function to receive the SendMessageCallback return value
    ULONG_PTR        dwData;             // value to be passed back to the lpResultCallBack function
    PTHREADINFO     ptiCallBackSender;  // sending thread

    LRESULT         lRet;               // message return value
    UINT            flags;              // SMF_ flags
    WPARAM          wParam;             // message fields...
    LPARAM          lParam;
    UINT            message;
    PWND            spwnd;
    PVOID           pvCapture;          // captured argument data
} SMS;

#define SMF_REPLY                   0x0001      // message has been replied to
#define SMF_RECEIVERDIED            0x0002      // receiver has died
#define SMF_SENDERDIED              0x0004      // sender has died
#define SMF_RECEIVERFREE            0x0008      // receiver should free sms when done
#define SMF_RECEIVEDMESSAGE         0x0010      // sms has been received
#define SMF_CB_REQUEST              0x0100      // SendMessageCallback requested
#define SMF_CB_REPLY                0x0200      // SendMessageCallback reply
#define SMF_CB_CLIENT               0x0400      // Client process request
#define SMF_CB_SERVER               0x0800      // Server process request
#define SMF_WOWRECEIVE              0x1000      // wow sched has incr recv count
#define SMF_WOWSEND                 0x2000      // wow sched has incr send count
#define SMF_RECEIVERBUSY            0x4000      // reciver is processing this msg

/*
 * InterSendMsgEx parameter used for SendMessageCallback and TimeOut
 */
typedef struct tagINTERSENDMSGEX {   /* ism */
    UINT   fuCall;                      // callback or timeout call

    SENDASYNCPROC lpResultCallBack;     // function to receive the send message value
    ULONG_PTR dwData;                    // Value to be passed back to the SendResult call back function
    LRESULT lRet;                       // return value from the send message

    UINT fuSend;                        // how to send the message, SMTO_BLOCK, SMTO_ABORTIFHUNG
    UINT uTimeout;                      // time-out duration
    PULONG_PTR lpdwResult;               // the return value for a syncornis call
} INTRSENDMSGEX, *PINTRSENDMSGEX;

#define ISM_CALLBACK        0x0001      // callback function request
#define ISM_TIMEOUT         0x0002      // timeout function request
#define ISM_REQUEST         0x0010      // callback function request message
#define ISM_REPLY           0x0020      // callback function reply message
#define ISM_CB_CLIENT       0x0100      // client process callback function

/*
 * Event structure to handle broadcasts of notification messages.
 */
typedef struct tagASYNCSENDMSG {
    WPARAM  wParam;
    LPARAM  lParam;
    UINT    message;
    HWND    hwnd;
} ASYNCSENDMSG, *PASYNCSENDMSG;

/*
 * HkCallHook() structure
 */
#define IsHooked(pti, fsHook) \
    ((fsHook & (pti->fsHooks | pti->pDeskInfo->fsHooks)) != 0)

#define IsGlobalHooked(pti, fsHook) \
    ((fsHook & pti->pDeskInfo->fsHooks) != 0)

typedef struct tagHOOKMSGSTRUCT { /* hch */
    PHOOK   phk;
    int     nCode;
    LPARAM  lParam;
} HOOKMSGSTRUCT, *PHOOKMSGSTRUCT;

/*
 * BroadcastMessage() commands.
 */
#define BMSG_SENDMSG                0x0000
#define BMSG_SENDNOTIFYMSG          0x0001
#define BMSG_POSTMSG                0x0002
#define BMSG_SENDMSGCALLBACK        0x0003
#define BMSG_SENDMSGTIMEOUT         0x0004
#define BMSG_SENDNOTIFYMSGPROCESS   0x0005

/*
 * xxxBroadcastMessage parameter used for SendMessageCallback and TimeOut
 */
typedef union tagBROADCASTMSG {   /* bcm */
     struct {                               // for callback broadcast
         SENDASYNCPROC lpResultCallBack;    // function to receive the send message value
         ULONG_PTR dwData;                   // Value to be passed back to the SendResult call back function
         BOOL bClientRequest;               // if a cliet or server callback request
     } cb;
     struct {                               // for timeout broadcast
         UINT fuFlags;                      // timeout type flags
         UINT uTimeout;                     // timeout length
         PULONG_PTR lpdwResult;              // where to put the return value
     } to;
} BROADCASTMSG, *PBROADCASTMSG;

/*
 * Internal hotkey structures and defines.
 */
typedef struct tagHOTKEY {
    PTHREADINFO pti;
    PWND    spwnd;
    WORD    fsModifiers; // MOD_SHIFT, MOD_ALT, MOD_CONTROL, MOD_WIN
    WORD    wFlags;      // MOD_SAS
    UINT    vk;
    int     id;
    struct tagHOTKEY *phkNext;
} HOTKEY, *PHOTKEY;

#define PWND_INPUTOWNER (PWND)1    // Means send WM_HOTKEY to input owner.
#define PWND_FOCUS      (PWND)NULL // Means send WM_HOTKEY to queue's pwndFocus.
#define PWND_TOP        (PWND)0
#define PWND_BOTTOM     (PWND)1
#define PWND_GROUPTOTOP ((PWND)-1)
#define PWND_TOPMOST    ((PWND)-1)
#define PWND_NOTOPMOST  ((PWND)-2)
#define PWND_BROADCAST  ((PWND)-1)

#define IDHOT_DEBUG         (-5)
#define IDHOT_DEBUGSERVER   (-6)
#define IDHOT_WINDOWS       (-7)

/*
 * xPos, yPos for WM_CONTEXTMENU from keyboard
 */
#define KEYBOARD_MENU   ((LPARAM)-1)    // Keyboard generated menu

/*
 * Capture codes
 */
#define NO_CAP_CLIENT           0   /* no capture; in client area */
#define NO_CAP_SYS              1   /* no capture; in sys area */
#define CLIENT_CAPTURE          2   /* client-relative capture */
#define WINDOW_CAPTURE          3   /* window-relative capture */
#define SCREEN_CAPTURE          4   /* screen-relative capture */
#define FULLSCREEN_CAPTURE      5   /* capture entire machine */
#define CLIENT_CAPTURE_INTERNAL 6   /* client-relative capture (Win 3.1 style; won't release) */

#define CH_HELPPREFIX   0x08

#ifdef KANJI
    #define CH_KANJI1       0x1D
    #define CH_KANJI2       0x1E
    #define CH_KANJI3       0x1F
#endif // KANJI

#define xxxRedrawScreen() \
        xxxInternalInvalidate(PtiCurrent()->rpdesk->pDeskInfo->spwnd, \
        HRGN_FULL, RDW_INVALIDATE | RDW_ERASE | RDW_FRAME | RDW_ALLCHILDREN)

/*
 * Preallocated buffer for use during SetWindowPos to prevent memory
 * allocation failures.
 */
#define CCVR_WORKSPACE      4

/*
 * DrawIconCallBack data, global only for state data in tmswitch.c
 */
typedef struct tagDRAWICONCB {   /* dicb */
    PWND   pwndTop;                     // Window being drawn
    UINT   cx;                          // x offset for icon
    UINT   cy;                          // y offset for icon
} DRAWICONCB, *PDRAWICONCB;

/*
 * The following defines the components of nKeyboardSpeed
 */
#define KSPEED_MASK     0x001F          // Defines the key repeat speed.
#define KDELAY_MASK     0x0060          // Defines the keyboard delay.
#define KDELAY_SHIFT    5

/*
 * Property list checkpoint int
 */
#define PROP_CHECKPOINT     MAKEINTATOM(atomCheckpointProp)
#define PROP_DDETRACK       MAKEINTATOM(atomDDETrack)
#define PROP_QOS            MAKEINTATOM(atomQOS)
#define PROP_DDEIMP         MAKEINTATOM(atomDDEImp)
#define PROP_WNDOBJ         MAKEINTATOM(atomWndObj)
#define PROP_IMELEVEL       MAKEINTATOM(atomImeLevel)
#define PROP_LAYER          MAKEINTATOM(atomLayer)

#define WinFlags    ((WORD)(&__WinFlags))

/*
 * ntinput.c
 */
BOOL xxxInternalKeyEventDirect(
    BYTE  bVk,
    WORD  wScan,
    DWORD dwFlags,
    DWORD dwTime,
    ULONG_PTR dwExtraInfo);

UINT xxxSendInput(
    UINT    nInputs,
    LPINPUT pInputs);

BOOL _BlockInput(
    BOOL    fBlockIt);

int _GetMouseMovePointsEx(
    CONST MOUSEMOVEPOINT* ppt,
    MOUSEMOVEPOINT*       pptBuf,
    UINT                  nPoints,
    DWORD                 resolution);


VOID xxxProcessKeyEvent(
   PKE       pke,
   ULONG_PTR ExtraInformation,
   BOOL      bInjected);

VOID xxxButtonEvent(
    DWORD ButtonNumber,
    POINT ptPointer,
    BOOL  fBreak,
    DWORD time,
    ULONG_PTR ExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    BOOL  bInjected,
    BOOL  fDblClk);

VOID xxxMoveEvent(
    LONG         dx,
    LONG         dy,
    DWORD        dwFlags,
    ULONG_PTR    dwExtraInfo,
#ifdef GENERIC_INPUT
    HANDLE       hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    DWORD        time,
    BOOL         bInjected
    );

typedef struct _RIT_INIT {
    PTERMINAL pTerm;
    PKEVENT   pRitReadyEvent;
} RIT_INIT, *PRIT_INIT;

PDEVICEINFO StartDeviceRead(PDEVICEINFO pDeviceInfo);

NTSTATUS DeviceNotify(
    IN PPLUGPLAY_NOTIFY_HDR pNotification,
    IN PDEVICEINFO pDeviceInfo);

#define MOUSE_SENSITIVITY_MIN     1
#define MOUSE_SENSITIVITY_DEFAULT 10
#define MOUSE_SENSITIVITY_MAX     20
LONG CalculateMouseSensitivity(LONG lSens);

PDEVICEINFO FreeDeviceInfo(PDEVICEINFO pMouseInfo);


__inline PTHREADINFO PtiKbdFromQ(PQ pq)
{
    if (pq->spwndActive) {
        return GETPTI(pq->spwndActive);
    }
    UserAssert(pq->ptiKeyboard);
    return pq->ptiKeyboard;
}

__inline PTHREADINFO ValidatePtiKbd(PQ pq)
{
    if (pq == NULL) {
        return NULL;
    }
    return PtiKbdFromQ(pq);
}

__inline PTHREADINFO PtiMouseFromQ(PQ pq)
{
    if (pq->spwndCapture) {
        return GETPTI(pq->spwndCapture);
    }
    UserAssert(pq->ptiMouse);
    return pq->ptiMouse;
}

__inline PTHREADINFO ValidatePtiMouse(PQ pq)
{
    if (pq == NULL) {
        return NULL;
    }
    return PtiMouseFromQ(pq);
}


VOID QueueMouseEvent(
    USHORT       ButtonFlags,
    USHORT       ButtonData,
    ULONG_PTR    ExtraInfo,
    POINT        ptMouse,
    LONG         time,
#ifdef GENERIC_INPUT
    HANDLE       hDevice,
    PMOUSE_INPUT_DATA pmei,
#endif
    BOOL         bInjected,
    BOOL         bWakeRIT
    );

typedef struct {
    DWORD dwVersion;
    DWORD dwFlags;
    DWORD dwMapCount;
    DWORD dwMap[0];
} SCANCODEMAP, *PSCANCODEMAP;


#ifndef SCANCODE_NUMPAD_PLUS
#define SCANCODE_NUMPAD_PLUS    (0x4e)
#endif
#ifndef SCANCODE_NUMPAD_DOT
#define SCANCODE_NUMPAD_DOT     (0x53)
#endif

/*
 * Flag (LowLevel and HighLevel) for
 * hex Alt+Numpad mode.
 * If you need to add a new flag for gfInNumpadHexInput,
 * note the variable is BYTE.
 */
#define NUMPAD_HEXMODE_LL       (1)
#define NUMPAD_HEXMODE_HL       (2)

#define MODIFIER_FOR_ALT_NUMPAD(wModBit) \
    (((wModBits) == KBDALT) || ((wModBits) == (KBDALT | KBDSHIFT)) || \
     ((wModBits) == (KBDKANA | KBDALT)) || ((wModBits) == (KBDKANA | KBDALT | KBDSHIFT)))


BOOL UnqueueMouseEvent(PMOUSEEVENT pme);

BYTE    VKFromVSC(PKE pke, BYTE bPrefix, LPBYTE afKeyState);
BOOL    KEOEMProcs(PKE pke);
BOOL    xxxKELocaleProcs(PKE pke);
BOOL    xxxKENLSProcs(PKE pke, ULONG_PTR dwExtraInformation);

VOID    xxxKeyEvent(USHORT usVk, WORD wScanCode, DWORD time, ULONG_PTR ExtraInfo,
#ifdef GENERIC_INPUT
                    HANDLE hDevice,
                    PKEYBOARD_INPUT_DATA pkei,
#endif
                    BOOL bInjected);

typedef BITMAPINFOHEADER *PBMPHEADER, *LPBMPHEADER;

/*
 * Defines for WinOldAppHackoMatic flags which win386 oldapp can send to us.
 * These are kept in user's global variable winOldAppHackoMaticFlags
 */
#define WOAHACK_CHECKALTKEYSTATE 1
#define WOAHACK_IGNOREALTKEYDOWN 2

void xxxSimpleDoSyncPaint(PWND pwnd);
VOID xxxDoSyncPaint(PWND pwnd, DWORD flags);
void xxxInternalDoSyncPaint(PWND pwnd, DWORD flags);

/*
 * NOTE: the first 4 values must be as defined for backward compatibility
 * reasons. They are sent as parameters to the WM_SYNCPAINT message.
 * They used to be hard-coded constants.
 *
 * Only ENUMCLIPPEDCHILDREN, ALLCHILDREN, and NOCHECKPARENTS are passed on
 * during recursion. The other bits reflect the current window only.
 */
#define DSP_ERASE               0x0001  // Send WM_ERASEBKGND
#define DSP_FRAME               0x0002  // Send WM_NCPAINT
#define DSP_ENUMCLIPPEDCHILDREN 0x0004  // Enum children if WS_CLIPCHILDREN
#define DSP_WM_SYNCPAINT        0x0008  // Called from WM_SYNCPAINT handler
#define DSP_NOCHECKPARENTS      0x0010  // Don't check parents for update region
#define DSP_ALLCHILDREN         0x0020  // Enumerate all children.

BOOL xxxDrawAnimatedRects(
    PWND pwndClip,
    int idAnimation,
    LPRECT lprcStart,
    LPRECT lprcEnd);

typedef struct tagTIMER {           // tmr
    HEAD            head;
    struct tagTIMER *ptmrNext;
    struct tagTIMER *ptmrPrev;
    PTHREADINFO     pti;
    struct tagWND * spwnd;
    UINT_PTR        nID;
    DWORD           cmsCountdown;
    DWORD           cmsRate;
    UINT            flags;
    TIMERPROC_PWND  pfn;
    PTHREADINFO     ptiOptCreator;     // used for journal playback
                                       // will be NULL if timer was created by non-GUI thread
} TIMER, *PTIMER;

UINT_PTR InternalSetTimer(PWND pwnd, UINT_PTR nIDEvent, UINT dwElapse,
        TIMERPROC_PWND pTimerFunc, UINT flags);

VOID FreeTimer(PTIMER ptmr);
BOOL ValidateTimerCallback(PTHREADINFO, PWND, WPARAM, LPARAM);

/*
 * Call FindTimer() with fKill == TRUE and TMRF_RIT. This will basically
 * delete the timer.
 */
#define KILLRITTIMER(pwnd, nID) FindTimer(pwnd, nID, TMRF_RIT, TRUE)

/*
 * Raster Ops
 */
#define PATOR 0x00FA0089L  /* destination, pattern, or */

/*
 * Message thunks.
 */
typedef LRESULT (APIENTRY *SFNSCSENDMESSAGE)(PWND, UINT, WPARAM, LPARAM,
        ULONG_PTR, PROC, DWORD, PSMS);

#define SMESSAGEPROTO(func) \
     LRESULT CALLBACK Sfn ## func(                              \
        PWND pwnd, UINT msg, WPARAM wParam, LPARAM lParam,      \
        ULONG_PTR xParam, PROC xpfnWndProc, DWORD dwSCMSFlags, PSMS psms)

SMESSAGEPROTO(SENTDDEMSG);
SMESSAGEPROTO(DDEINIT);
SMESSAGEPROTO(DWORD);
SMESSAGEPROTO(NCDESTROY);
SMESSAGEPROTO(INWPARAMCHAR);
SMESSAGEPROTO(INWPARAMDBCSCHAR);

SMESSAGEPROTO(GETTEXTLENGTHS);

SMESSAGEPROTO(GETDBCSTEXTLENGTHS);
SMESSAGEPROTO(INLPCREATESTRUCT);
SMESSAGEPROTO(INLPDROPSTRUCT);
SMESSAGEPROTO(INOUTLPPOINT5);
SMESSAGEPROTO(INOUTLPSCROLLINFO);
SMESSAGEPROTO(INOUTLPRECT);
SMESSAGEPROTO(INOUTNCCALCSIZE);
SMESSAGEPROTO(OUTLPRECT);
SMESSAGEPROTO(INLPMDICREATESTRUCT);
SMESSAGEPROTO(INLPCOMPAREITEMSTRUCT);
SMESSAGEPROTO(INLPDELETEITEMSTRUCT);
SMESSAGEPROTO(INLPHLPSTRUCT);
SMESSAGEPROTO(INLPHELPINFOSTRUCT);      // WINHELP4
SMESSAGEPROTO(INLPDRAWITEMSTRUCT);
SMESSAGEPROTO(INOUTLPMEASUREITEMSTRUCT);
SMESSAGEPROTO(INSTRING);
SMESSAGEPROTO(INPOSTEDSTRING);
SMESSAGEPROTO(INSTRINGNULL);
SMESSAGEPROTO(OUTSTRING);
SMESSAGEPROTO(INCNTOUTSTRING);
SMESSAGEPROTO(POUTLPINT);
SMESSAGEPROTO(POPTINLPUINT);
SMESSAGEPROTO(INOUTLPWINDOWPOS);
SMESSAGEPROTO(INLPWINDOWPOS);
SMESSAGEPROTO(INLBOXSTRING);
SMESSAGEPROTO(OUTLBOXSTRING);
SMESSAGEPROTO(INCBOXSTRING);
SMESSAGEPROTO(OUTCBOXSTRING);
SMESSAGEPROTO(INCNTOUTSTRINGNULL);
SMESSAGEPROTO(INOUTDRAG);
SMESSAGEPROTO(FULLSCREEN);
SMESSAGEPROTO(INPAINTCLIPBRD);
SMESSAGEPROTO(INSIZECLIPBRD);
SMESSAGEPROTO(OUTDWORDDWORD);
SMESSAGEPROTO(OUTDWORDINDWORD);
SMESSAGEPROTO(OPTOUTLPDWORDOPTOUTLPDWORD);
SMESSAGEPROTO(DWORDOPTINLPMSG);
SMESSAGEPROTO(COPYGLOBALDATA);
SMESSAGEPROTO(COPYDATA);
SMESSAGEPROTO(INDESTROYCLIPBRD);
SMESSAGEPROTO(INOUTNEXTMENU);
SMESSAGEPROTO(INOUTSTYLECHANGE);
SMESSAGEPROTO(IMAGEIN);
SMESSAGEPROTO(IMAGEOUT);
SMESSAGEPROTO(INDEVICECHANGE);
SMESSAGEPROTO(INOUTMENUGETOBJECT);
SMESSAGEPROTO(POWERBROADCAST);
SMESSAGEPROTO(LOGONNOTIFY);
SMESSAGEPROTO(IMECONTROL);
SMESSAGEPROTO(IMEREQUEST);
SMESSAGEPROTO(INLPKDRAWSWITCHWND);
SMESSAGEPROTO(OUTLPCOMBOBOXINFO);
SMESSAGEPROTO(OUTLPSCROLLBARINFO);

/***************************************************************************\
* Function Prototypes
*
* NOTE: Only prototypes for GLOBAL (across module) functions should be put
* here. Prototypes for functions that are global to a single module should
* be put at the head of that module.
*
* LATER: There's still lots of bogus trash in here to be cleaned out.
*
\***************************************************************************/

/*
 * Random prototypes.
 */
DWORD _GetWindowContextHelpId(
    PWND pwnd);

BOOL _SetWindowContextHelpId(
    PWND pwnd,
    DWORD dwContextId);

void xxxSendHelpMessage(
    PWND   pwnd,
    int    iType,
    int    iCtrlId,
    HANDLE hItemHandle,
    DWORD  dwContextId);

HPALETTE _SelectPalette(
    HDC hdc,
    HPALETTE hpalette,
    BOOL fForceBackground);

int xxxRealizePalette(
    HDC hdc);

VOID xxxFlushPalette(
    PWND pwnd);

VOID xxxBroadcastPaletteChanged(
    PWND pwnd,
    BOOL fForceDesktop);

PCURSOR SearchIconCache(
    PCURSOR         pCursorCache,
    ATOM            atomModName,
    PUNICODE_STRING pstrResName,
    PCURSOR         pCursorSrc,
    PCURSORFIND     pcfSearch);

VOID ZombieCursor(PCURSOR pcur);

BOOL IsSmallerThanScreen(PWND pwnd);

BOOL zzzSetSystemCursor(
    PCURSOR pcur,
    DWORD   id);

BOOL zzzSetSystemImage(
    PCURSOR pcur,
    PCURSOR pcurOld);

BOOL _InternalGetIconInfo(
    IN  PCURSOR                  pcur,
    OUT PICONINFO                piconinfo,
    OUT OPTIONAL PUNICODE_STRING pstrModName,
    OUT OPTIONAL PUNICODE_STRING pstrResName,
    OUT OPTIONAL LPDWORD         pbpp,
    IN  BOOL                     fInternalCursor);

VOID LinkCursor(
    PCURSOR pcur);

BOOL _SetCursorIconData(
    PCURSOR         pcur,
    PUNICODE_STRING pstrModName,
    PUNICODE_STRING pstrResName,
    PCURSORDATA     pData,
    DWORD           cbData);

PCURSOR _GetCursorFrameInfo(
    PCURSOR pcur,
    int     iFrame,
    PJIF    pjifRate,
    LPINT   pccur);

BOOL zzzSetSystemCursor(
    PCURSOR pcur,
    DWORD id);

PCURSOR _FindExistingCursorIcon(
    ATOM            atomModName,
    PUNICODE_STRING pstrResName,
    PCURSOR         pcurSrc,
    PCURSORFIND     pcfSearch);

HCURSOR _CreateEmptyCursorObject(
    BOOL fPublic);

BOOL _GetUserObjectInformation(HANDLE h,
    int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded);
BOOL _SetUserObjectInformation(HANDLE h,
    int nIndex, PVOID pvInfo, DWORD nLength);
DWORD xxxWaitForInputIdle(ULONG_PTR idProcess, DWORD dwMilliseconds,
        BOOL fSharedWow);
VOID StartScreenSaver(BOOL bOnlyIfSecure);
UINT InternalMapVirtualKeyEx(UINT wCode, UINT wType, PKBDTABLES pKbdTbl);
SHORT InternalVkKeyScanEx(WCHAR cChar, PKBDTABLES pKbdTbl);



PWND ParentNeedsPaint(PWND pwnd);
VOID SetHungFlag(PWND pwnd, WORD wFlag);
VOID ClearHungFlag(PWND pwnd, WORD wFlag);

BOOL _DdeSetQualityOfService(PWND pwndClient,
        CONST PSECURITY_QUALITY_OF_SERVICE pqosNew,
        PSECURITY_QUALITY_OF_SERVICE pqosOld);
BOOL _DdeGetQualityOfService(PWND pwndClient,
        PWND pwndServer, PSECURITY_QUALITY_OF_SERVICE pqos);

BOOL QueryTrackMouseEvent(LPTRACKMOUSEEVENT lpTME);
void CancelMouseHover(PQ pq);
void ResetMouseTracking(PQ pq, PWND pwnd);

void _SetIMEShowStatus(BOOL fShow);
BOOL _GetIMEShowStatus(VOID);

/*
 * Prototypes for internal version of APIs.
 */
PWND _FindWindowEx(PWND pwndParent, PWND pwndChild,
                              LPCWSTR pszClass, LPCWSTR pszName, DWORD dwType);
UINT APIENTRY GreSetTextAlign(HDC, UINT);
UINT APIENTRY GreGetTextAlign(HDC);

/*
 * Prototypes for validation, RIP, error handling, etc functions.
 */
PWND FASTCALL   ValidateHwnd(HWND hwnd);

NTSTATUS ValidateHwinsta(HWINSTA, KPROCESSOR_MODE, ACCESS_MASK, PWINDOWSTATION*);
NTSTATUS ValidateHdesk(HDESK, KPROCESSOR_MODE, ACCESS_MASK, PDESKTOP*);

PMENU           ValidateHmenu(HMENU hmenu);
PMONITOR        ValidateHmonitor(HMONITOR hmonitor);
HRGN            UserValidateCopyRgn(HRGN);

BOOL    ValidateHandleSecure(HANDLE h);

NTSTATUS UserJobCallout(PKWIN32_JOBCALLOUT_PARAMETERS Parm);

BOOL RemoveProcessFromJob(PPROCESSINFO ppi);


BOOL    xxxActivateDebugger(UINT fsModifiers);

void ClientDied(void);

VOID    SendMsgCleanup(PTHREADINFO ptiCurrent);
VOID    ReceiverDied(PSMS psms, PSMS *ppsmsUnlink);
LRESULT xxxInterSendMsgEx(PWND, UINT, WPARAM, LPARAM, PTHREADINFO, PTHREADINFO, PINTRSENDMSGEX );
VOID    ClearSendMessages(PWND pwnd);
PPCLS   GetClassPtr(ATOM atom, PPROCESSINFO ppi, HANDLE hModule);
BOOL    ReferenceClass(PCLS pcls, PWND pwnd);
VOID    DereferenceClass(PWND pwnd);
ULONG_PTR MapClientToServerPfn(ULONG_PTR dw);


VOID xxxReceiveMessage(PTHREADINFO);
#define xxxReceiveMessages(pti) \
    while ((pti)->pcti->fsWakeBits & QS_SENDMESSAGE) { xxxReceiveMessage((pti)); }

PBWL     BuildHwndList(PWND pwnd, UINT flags, PTHREADINFO ptiOwner);
VOID     FreeHwndList(PBWL pbwl);

#define  MINMAX_KEEPHIDDEN 0x1
#define  MINMAX_ANIMATE    0x10000

PWND     xxxMinMaximize(PWND pwnd, UINT cmd, DWORD dwFlags);
void     xxxMinimizeHungWindow(PWND pwnd);
VOID     xxxInitSendValidateMinMaxInfo(PWND pwnd, LPMINMAXINFO lpmmi);
HRGN     CreateEmptyRgn(void);
HRGN     CreateEmptyRgnPublic(void);
HRGN     SetOrCreateRectRgnIndirectPublic(HRGN * phrgn, LPCRECT lprc);
BOOL     SetEmptyRgn(HRGN hrgn);
BOOL     SetRectRgnIndirect(HRGN hrgn, LPCRECT lprc);
void     RegisterCDROMNotify(void);
NTSTATUS xxxRegisterForDeviceClassNotifications();
VOID     xxxUnregisterDeviceClassNotifications();
BOOL     xxxInitInput(PTERMINAL);
VOID     InitMice();
void     UpdateMouseInfo(void);
BOOL     OpenMouse(PDEVICEINFO pMouseInfo);
void     ProcessDeviceChanges(DWORD DeviceType);
PDEVICEINFO CreateDeviceInfo(DWORD DeviceType, PUNICODE_STRING SymbolicLinkName, BYTE bFlags);
void     InitKeyboard(void);
void     InitKeyboardState(void);
UINT     xxxHardErrorControl(DWORD, HANDLE, PDESKRESTOREDATA);



#define UPDATE_KBD_TYPEMATIC 1
#define UPDATE_KBD_LEDS      2

VOID     SetKeyboardRate(UINT nKeySpeed);
VOID     RecolorDeskPattern();
BOOL     xxxInitWindowStation(PWINDOWSTATION);
VOID     zzzInternalSetCursorPos(int x, int y);
VOID     UpdateKeyLights(BOOL bInjected);
VOID     SetDebugHotKeys();
VOID     BoundCursor(LPPOINT lppt);

void     DestroyKF(PKBDFILE pkf);
VOID     DestroyKL(PKL pkl);
VOID     CleanupKeyboardLayouts();

BOOL     xxxSetDeskPattern(PUNICODE_STRING pProfileUserName,LPWSTR lpPat, BOOL fCreation);
BOOL     xxxSetDeskWallpaper(PUNICODE_STRING pProfileUserName,LPWSTR lpszFile);
HPALETTE CreateDIBPalette(LPBITMAPINFOHEADER pbmih, UINT colors);
BOOL     CalcVisRgn(HRGN* hrgn, PWND pwndOrg, PWND pwndClip, DWORD flags);

NTSTATUS xxxCreateThreadInfo(PETHREAD, BOOL);

BOOL     DestroyProcessInfo(PW32PROCESS);

#if DBG
PWCHAR GetDesktopName(PDESKTOP pdesk);
#endif // DBG


VOID    RawInputThread(PVOID pVoid);
HANDLE  GetRemoteProcessId(void);
void    HandleSystemThreadCreationFailure(BOOL bRemoteThread);
void    xxxCreateSystemThreads(BOOL bRemoteThread);

VOID     xxxDesktopThread(PTERMINAL pTerm);
VOID     ForceEmptyClipboard(PWINDOWSTATION);

NTSTATUS zzzInitTask(UINT dwExpWinVer, DWORD dwAppCompatFlags, DWORD dwUserWOWCompatFlags,
                PUNICODE_STRING pstrModName, PUNICODE_STRING pstrBaseFileName,
                DWORD hTaskWow, DWORD dwHotkey, DWORD idTask,
                DWORD dwX, DWORD dwY, DWORD dwXSize, DWORD dwYSize);
VOID    DestroyTask(PPROCESSINFO ppi, PTHREADINFO ptiToRemove);
BOOL    PostInputMessage(PQ pq, PWND pwnd, UINT message, WPARAM wParam,
                LPARAM lParam, DWORD time, ULONG_PTR dwExtraInfo);
PWND    PwndForegroundCapture(VOID);
BOOL    xxxSleepThread(UINT fsWakeMask, DWORD Timeout, BOOL fForegroundIdle);
VOID    SetWakeBit(PTHREADINFO pti, UINT wWakeBit);
VOID    WakeSomeone(PQ pq, UINT message, PQMSG pqmsg);
VOID    ClearWakeBit(PTHREADINFO pti, UINT wWakeBit, BOOL fSysCheck);
NTSTATUS xxxInitProcessInfo(PW32PROCESS);

PTHREADINFO PtiFromThreadId(DWORD idThread);
BOOL    zzzAttachThreadInput(PTHREADINFO ptiAttach, PTHREADINFO ptiAttachTo, BOOL fAttach);
BOOL    zzzReattachThreads(BOOL fJournalAttach);
PQ      AllocQueue(PTHREADINFO, PQ);
VOID    FreeQueue(PQ pq);


VOID    FreeCachedQueues(VOID);
VOID    CleanupGDI(VOID);
VOID    CleanupResources(VOID);

VOID    zzzDestroyQueue(PQ pq, PTHREADINFO pti);
PQMSG   AllocQEntry(PMLIST pml);
__inline VOID FreeQEntry(PQMSG pqmsg)
{
    extern PPAGED_LOOKASIDE_LIST QEntryLookaside;
    ExFreeToPagedLookasideList(QEntryLookaside, pqmsg);
}

VOID    DelQEntry(PMLIST pml, PQMSG pqmsg);
VOID    zzzAttachToQueue(PTHREADINFO pti, PQ pqAttach, PQ pqJournal,
        BOOL fJoiningForeground);
VOID    xxxProcessEventMessage(PTHREADINFO ptiCurrent, PQMSG pqmsg);
VOID    xxxProcessSetWindowPosEvent(PSMWP psmwpT);
VOID    xxxProcessAsyncSendMessage(PASYNCSENDMSG pmsg);
BOOL    PostEventMessage(PTHREADINFO pti, PQ pq, DWORD dwQEvent, PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL    xxxDoPaint(PWND pwndFilter, LPMSG lpMsg);
BOOL    DoTimer(PWND pwndFilter);
BOOL    CheckPwndFilter(PWND pwnd, PWND pwndFilter);

#define WHT_IGNOREDISABLED      0x00000001

#ifdef REDIRECTION

#define WHT_FAKESPEEDHITTEST    0x00000002

PWND    xxxCallSpeedHitTestHook(POINT* ppt);
VOID    PushMouseMove(PQ pq, POINT pt);
VOID    PopMouseMove(PQ pq, POINT* ppt);

#endif // REDIRECTION

BOOL    xxxGetCursorPos(LPPOINT lpPt);
HWND    xxxWindowHitTest(PWND pwnd,  POINT pt, int *pipos, DWORD dwHitTestFlags);
HWND    xxxWindowHitTest2(PWND pwnd, POINT pt, int *pipos, DWORD dwHitTestFlags);

PWND    SpeedHitTest(PWND pwndParent, POINT pt);
VOID    xxxDeactivate(PTHREADINFO pti, DWORD tidSetForeground);

#define SFW_STARTUP             0x0001
#define SFW_SWITCH              0x0002
#define SFW_NOZORDER            0x0004
#define SFW_SETFOCUS            0x0008
#define SFW_ACTIVATERESTORE     0x0010

BOOL    xxxSetForegroundWindow2(PWND pwnd, PTHREADINFO ptiCurrent, DWORD fFlags);
VOID    SetForegroundThread(PTHREADINFO pti);
VOID    xxxSendFocusMessages(PTHREADINFO pti, PWND pwndReceive);

#define ATW_MOUSE               0x0001
#define ATW_SETFOCUS            0x0002
#define ATW_ASYNC               0x0004
#define ATW_NOZORDER            0x0008

BOOL    FBadWindow(PWND pwnd);
BOOL    xxxActivateThisWindow(PWND pwnd, DWORD tidLoseForeground, DWORD fFlags);
BOOL    xxxActivateWindow(PWND pwnd, UINT cmd);

#define NTW_PREVIOUS         1
#define NTW_IGNORETOOLWINDOW 2
PWND    NextTopWindow(PTHREADINFO pti, PWND pwnd, PWND pwndSkip, DWORD flags);

int     xxxMouseActivate(PTHREADINFO pti, PWND pwnd, UINT message, WPARAM wParam, LPPOINT lppt, int ht);
int     UT_GetParentDCClipBox(PWND pwnd, HDC hdc, LPRECT lprc);
VOID    UpdateAsyncKeyState(PQ pq, UINT wVK, BOOL fBreak);
void    PostUpdateKeyStateEvent(PQ pq);
void    ProcessUpdateKeyStateEvent(PQ pq, CONST PBYTE pbKeyState, CONST PBYTE pbRecentDown);

BOOL    InternalSetProp(PWND pwnd, LPWSTR pszKey, HANDLE hData, DWORD dwFlags);
HANDLE  InternalRemoveProp(PWND pwnd, LPWSTR pszKey, BOOL fInternal);
VOID    DeleteProperties(PWND pwnd);
CHECKPOINT *CkptRestore(PWND pwnd, LPCRECT lprcWindow);
UINT_PTR _SetTimer(PWND pwnd, UINT_PTR nIDEvent, UINT dwElapse, TIMERPROC_PWND pTimerFunc);
BOOL    KillTimer2(PWND pwnd, UINT_PTR nIDEvent, BOOL fSystemTimer);
VOID    DestroyThreadsTimers(PTHREADINFO pti);
VOID    DecTimerCount(PTHREADINFO pti);
VOID    zzzInternalShowCaret();
VOID    zzzInternalHideCaret();
VOID    zzzInternalDestroyCaret();
VOID    ChangeAcquireResourceType(VOID);
VOID    EnterCrit(VOID);
VOID    EnterSharedCrit(VOID);
VOID    LeaveCrit(VOID);
VOID    _AssertCritIn(VOID);
VOID    _AssertDeviceInfoListCritIn(VOID);
VOID    _AssertCritInShared(VOID);
VOID    _AssertCritOut(VOID);
VOID    _AssertDeviceInfoListCritOut(VOID);
NTSTATUS _KeUserModeCallback (IN ULONG ApiNumber, IN PVOID InputBuffer,
    IN ULONG InputLength, OUT PVOID *OutputBuffer, OUT PULONG OutputLength);

#define UnlockProcess           ObDereferenceObject
#define UnlockThread            ObDereferenceObject

extern ULONG gSessionId;

#if DBG
    #define ValidateProcessSessionId(pEProcess)  \
        UserAssert(PsGetProcessSessionId(pEProcess) == gSessionId)

    #define ValidateThreadSessionId(pEThread)  \
        UserAssert(PsGetThreadSessionId(pEThread) == gSessionId)
#else
    #define ValidateProcessSessionId(pEProcess)
    #define ValidateThreadSessionId(pEThread)
#endif


__inline NTSTATUS LockProcessByClientId(
    HANDLE dwProcessId,
    PEPROCESS* ppEProcess)
{
    NTSTATUS Status;

    CheckCritOut();

    Status = PsLookupProcessByProcessId(dwProcessId, ppEProcess);

    if (NT_SUCCESS(Status) && (PsGetProcessSessionId(*ppEProcess) != gSessionId)) {
        UnlockProcess(*ppEProcess);
        return STATUS_UNSUCCESSFUL;
    }

    return Status;
}

__inline NTSTATUS LockThreadByClientId(
    HANDLE dwThreadId,
    PETHREAD* ppEThread)
{
    NTSTATUS Status;

    Status = PsLookupThreadByThreadId(dwThreadId, ppEThread);

    if (NT_SUCCESS(Status) && (PsGetThreadSessionId(*ppEThread) != gSessionId)) {
        UnlockThread(*ppEThread);
        return STATUS_UNSUCCESSFUL;
    }

    return Status;
}

BOOL    IsSAS(BYTE vk, UINT* pfsModifiers);
BOOL    xxxDoHotKeyStuff(UINT vk, BOOL fBreak, DWORD fsReserveKeys);
PHOTKEY IsHotKey(UINT fsModifiers, UINT vk);
void    ClearCachedHotkeyModifiers(void);

/*
 * Server.c
 */
BOOL InitCreateUserCrit(VOID);
PMDEV InitVideo(
    BOOL bReenumerationNeeded);

/*
 * DRVSUP.C
 */
BOOL InitUserScreen();

VOID InitLoadResources();

typedef struct tagDISPLAYRESOURCE {
    WORD cyThunb;
    WORD cxThumb;
    WORD xCompressIcon;
    WORD yCompressIcon;
    WORD xCompressCursor;
    WORD yCompressCursor;
    WORD yKanji;
    WORD cxBorder;
    WORD cyBorder;
} DISPLAYRESOURCE, *PDISPLAYRESOURCE;



VOID xxxUserResetDisplayDevice(VOID);

/*
 * Object management and security
 */
#define DEFAULT_WINSTA  L"\\Windows\\WindowStations\\WinSta0"

#define POBJECT_NAME(pobj) (OBJECT_HEADER_TO_NAME_INFO(OBJECT_TO_OBJECT_HEADER(pobj)) ? \
    &(OBJECT_HEADER_TO_NAME_INFO(OBJECT_TO_OBJECT_HEADER(pobj))->Name) : NULL)

PSECURITY_DESCRIPTOR CreateSecurityDescriptor(PACCESS_ALLOWED_ACE paceList,
        DWORD cbAce, BOOLEAN fDaclDefaulted);
PACCESS_ALLOWED_ACE AllocAce(PACCESS_ALLOWED_ACE pace, BYTE bType,
        BYTE bFlags, ACCESS_MASK am, PSID psid, LPDWORD lpdwLength);
BOOL CheckGrantedAccess(ACCESS_MASK, ACCESS_MASK);
BOOL AccessCheckObject(PVOID, ACCESS_MASK, KPROCESSOR_MODE, CONST GENERIC_MAPPING *);
BOOL InitSecurity(VOID);
BOOL IsPrivileged(PPRIVILEGE_SET ppSet);
BOOL CheckWinstaWriteAttributesAccess(void);

NTSTATUS xxxUserDuplicateObject(HANDLE SourceProcessHandle, HANDLE SourceHandle,
        HANDLE TargetProcessHandle, PHANDLE TargetHandle, ACCESS_MASK DesiredAccess,
        ULONG HandleAttributes, ULONG Options);
HWINSTA xxxConnectService(PUNICODE_STRING, HDESK *);
NTSTATUS TestForInteractiveUser(PLUID pluidCaller);
NTSTATUS _UserTestForWinStaAccess( PUNICODE_STRING pstrWinSta, BOOL fInherit);
HDESK xxxResolveDesktop(HANDLE hProcess, PUNICODE_STRING pstrDesktop,
    HWINSTA *phwinsta, BOOL fInherit, BOOL* pbShutDown);

/* NEW CODE */
NTSTATUS xxxResolveDesktopForWOW (
    IN OUT PUNICODE_STRING pstrDesktop);

WORD xxxClientWOWGetProcModule(WNDPROC_PWND pfn);
DWORD xxxClientWOWTask16SchedNotify(DWORD NotifyParm,DWORD dwParam);

PVOID _MapDesktopObject(HANDLE h);
PDESKTOPVIEW GetDesktopView(PPROCESSINFO ppi, PDESKTOP pdesk);
VOID TerminateConsole(PDESKTOP);


/*
 * Object manager callouts for windowstations
 */
NTSTATUS DestroyWindowStation(
     PKWIN32_CLOSEMETHOD_PARAMETERS pCloseParams );

NTSTATUS FreeWindowStation(
     PKWIN32_DELETEMETHOD_PARAMETERS pDeleteParams );

NTSTATUS ParseWindowStation(
     PKWIN32_PARSEMETHOD_PARAMETERS pParseParams );

NTSTATUS OkayToCloseWindowStation(
     PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS pOkCloseParams);

NTSTATUS WindowStationOpenProcedure(
     PKWIN32_OPENMETHOD_PARAMETERS pOpenParams);

/*
 * Object manager callouts for desktops
 */
NTSTATUS DesktopOpenProcedure(
    PKWIN32_OPENMETHOD_PARAMETERS pOpenParams);

NTSTATUS MapDesktop(
     PKWIN32_OPENMETHOD_PARAMETERS pOpenParams );

NTSTATUS UnmapDesktop(
     PKWIN32_CLOSEMETHOD_PARAMETERS pCloseParams );

NTSTATUS FreeDesktop(
    PKWIN32_DELETEMETHOD_PARAMETERS pDeleteParams );

NTSTATUS ParseDesktop(
    IN PVOID ParseObject,
    IN PVOID ObjectType,
    IN OUT PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE AccessMode,
    IN ULONG Attributes,
    IN OUT PUNICODE_STRING CompleteName,
    IN OUT PUNICODE_STRING RemainingName,
    IN OUT PVOID Context OPTIONAL,
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQos OPTIONAL,
    OUT PVOID *Object);

NTSTATUS OkayToCloseDesktop(
    PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS pOkCloseParams);

/*
 * Routines pilfered from kernel32
 */
VOID UserSleep(DWORD dwMilliseconds);
BOOL UserBeep(DWORD dwFreq, DWORD dwDuration);
NTSTATUS UserRtlCreateAtomTable(ULONG NumberOfBuckets);
ATOM UserAddAtom(LPCWSTR lpAtom, BOOL bPin);
ATOM UserFindAtom(LPCWSTR lpAtom);
ATOM UserDeleteAtom(ATOM atom);
UINT UserGetAtomName(ATOM atom, LPWSTR lpch, int cchMax);

#define FindClassAtom(lpszClassName) \
    (IS_PTR(lpszClassName) ? UserFindAtom(lpszClassName) : PTR_TO_ID(lpszClassName))

/*
 * Keyboard Layouts
 */
void SetGlobalKeyboardTableInfo(PKL pklNew);
VOID ChangeForegroundKeyboardTable(PKL pklOld, PKL pklNew);
HKL  xxxLoadKeyboardLayoutEx(PWINDOWSTATION, HANDLE, HKL, UINT,
                             PKBDTABLE_MULTI_INTERNAL,
                             LPCWSTR, UINT, UINT);
HKL  xxxActivateKeyboardLayout(PWINDOWSTATION pwinsta, HKL hkl, UINT Flags, PWND pwnd);
HKL  xxxInternalActivateKeyboardLayout(PKL pkl, UINT Flags, PWND pwnd);
BOOL GetKbdLangSwitch(PUNICODE_STRING pProfileUserName);

BOOL xxxUnloadKeyboardLayout(PWINDOWSTATION, HKL);
VOID RemoveKeyboardLayoutFile(PKBDFILE pkf);
HKL  _GetKeyboardLayout(DWORD idThread);
UINT _GetKeyboardLayoutList(PWINDOWSTATION pwinsta, UINT nItems, HKL *lpBuff);
VOID xxxFreeKeyboardLayouts(PWINDOWSTATION, BOOL bUnlock);

DWORD xxxDragObject(PWND pwndParent, PWND xhwndFrom, UINT wFmt,
        ULONG_PTR dwData, PCURSOR xpcur);
BOOL xxxDragDetect(PWND pwnd, POINT pt);
BOOL xxxIsDragging(PWND pwnd, POINT ptScreen, UINT uMsg);

HKL GetActiveHKL();

#define DMI_INVERT         0x00000001
#define DMI_GRAYED         0x00000002

VOID xxxDrawMenuItem(HDC hdc, PMENU pMenu, PITEM pItem, DWORD dwFlags);
BOOL xxxRealDrawMenuItem(HDC hdc, PGRAYMENU lpGray, int cx, int cy);
VOID xxxDrawMenuBarUnderlines(PWND pwnd, BOOL fShow);
UINT MNItemHitTest(PMENU pMenu, PWND pwnd, POINT pt);


/*
 * Menu macros
 */
__inline BOOL IsRootPopupMenu(PPOPUPMENU ppopupmenu)
{
    return (ppopupmenu == ppopupmenu->ppopupmenuRoot);
}
__inline BOOL ExitMenuLoop (PMENUSTATE pMenuState, PPOPUPMENU ppopupmenu)
{
    return  (!pMenuState->fInsideMenuLoop || ppopupmenu->fDestroyed);
}
__inline PMENUSTATE GetpMenuState (PWND pwnd)
{
    return (GETPTI(pwnd)->pMenuState);
}
__inline PPOPUPMENU GetpGlobalPopupMenu (PWND pwnd)
{
    return (GetpMenuState(pwnd) ? GetpMenuState(pwnd)->pGlobalPopupMenu : NULL);
}
__inline BOOL IsInsideMenuLoop(PTHREADINFO pti)
{
    return ((pti->pMenuState != NULL) && pti->pMenuState->fInsideMenuLoop);
}
__inline BOOL IsMenuStarted(PTHREADINFO pti)
{
    return ((pti->pMenuState != NULL) && pti->pMenuState->fMenuStarted);
}
__inline PITEM MNGetToppItem(PMENU pMenu)
{
    return pMenu->rgItems + pMenu->iTop;
}
__inline BOOL MNIsItemSelected(PPOPUPMENU ppopupmenu)
{
    return ((int)ppopupmenu->posSelectedItem >= 0);
}
__inline PITEM MNGetSelectedpitem(PPOPUPMENU ppopupmenu)
{
    return ppopupmenu->spmenu->rgItems + ppopupmenu->posSelectedItem;
}
__inline BOOL MNIsScrollArrowSelected(PPOPUPMENU ppopupmenu)
{
    return ((ppopupmenu->posSelectedItem == MFMWFP_UPARROW)
            || (ppopupmenu->posSelectedItem == MFMWFP_DOWNARROW));
}
__inline BOOL IsModelessMenuNotificationWindow (PWND pwnd)
{
    PMENUSTATE pMenuState;
    return (((pMenuState = GetpMenuState(pwnd)) != NULL)
                && pMenuState->fModelessMenu
                && (pMenuState->pGlobalPopupMenu->spwndNotify == pwnd));
}
__inline BOOL IsRecursedMenuState(PMENUSTATE pMenuState, PPOPUPMENU ppopupmenu)
{
    return (pMenuState->pGlobalPopupMenu != ppopupmenu->ppopupmenuRoot);
}

__inline BOOL IsMDIItem (PITEM pitem)
{
   return (TestMFS(pitem, MFS_CACHEDBMP)
      && (pitem->hbmp != NULL)
      && (pitem->hbmp <= HBMMENU_MBARLAST));
}

/*
 * This definition for CM_MODE_TRANSITION must match the one in ntcon\inc\server.h
 */

#define CM_MODE_TRANSITION       (WM_USER+6)

#define MNXBORDER (SYSMET(CXBORDER) + SYSMET(CXEDGE))
#define MNYBORDER (SYSMET(CYBORDER) + SYSMET(CYEDGE))
#define MNXSPACE  (SYSMET(CXEDGE))
#define MNLEFTMARGIN (SYSMET(CXEDGE))

/*
 * xxxMNUpdateShownMenu flags
 */
#define MNUS_DEFAULT      0x00000001
#define MNUS_DELETE       0x00000002
#define MNUS_DRAWFRAME    0x00000004

/* This tells xxxMNItemSize that the bitamp size is not avilable */
#define MNIS_MEASUREBMP -1


/*
 * MN_SIZEWINDOW wParam flag. xxxMNUpdateShownMenu sends this
 *  message, so keep MNSW_ and MNUS_ in sync.
 */
#define MNSW_RETURNSIZE  0
#define MNSW_SIZE        MNUS_DEFAULT
#define MNSW_DRAWFRAME   MNUS_DRAWFRAME

/*
 * Animation flags (pMenuState->iAniDropDir)
 */
#define PAS_RIGHT       (TPM_HORPOSANIMATION >> TPM_FIRSTANIBITPOS)
#define PAS_LEFT        (TPM_HORNEGANIMATION >> TPM_FIRSTANIBITPOS)
#define PAS_DOWN        (TPM_VERPOSANIMATION >> TPM_FIRSTANIBITPOS)
#define PAS_UP          (TPM_VERNEGANIMATION >> TPM_FIRSTANIBITPOS)
#define PAS_OUT         0x10
#define PAS_HORZ        (PAS_LEFT | PAS_RIGHT)
#define PAS_VERT        (PAS_UP | PAS_DOWN)

#if (PAS_HORZ + PAS_VERT >= PAS_OUT)
#error PAS_ & TPM_*ANIMATION conflict.
#endif

#define CXMENU3DEDGE 1
#define CYMENU3DEDGE 1

/*
 * Scrollbar initialization types
 */
#define SCROLL_NORMAL   0
#define SCROLL_DIRECT   1
#define SCROLL_MENU     2

/*
 * movesize.c
 */
void xxxDrawDragRect(PMOVESIZEDATA pmsd, LPRECT lprc, UINT flags);
void GetMonitorMaxArea(PWND pwnd, PMONITOR pMonitor, LPRECT * pprc);

/*
 * focusact.c
 */
VOID SetForegroundPriorityProcess(PPROCESSINFO ppi, PTHREADINFO pti, BOOL fSetForegound);
VOID SetForegroundPriority(PTHREADINFO pti, BOOL fSetForeground);
void xxxUpdateTray(PWND pwnd);


//
// mnchange.c
//
void xxxMNUpdateShownMenu(PPOPUPMENU ppopup, PITEM pItem, UINT uFlags);

//
// mnkey.c
//
UINT xxxMNFindChar(PMENU pMenu, UINT ch, INT idxC, INT *lpr);
UINT MNFindItemInColumn(PMENU pMenu, UINT idxB, int dir, BOOL fRoot);

//
// mndraw.c
//
void MNAnimate(PMENUSTATE pMenuState, BOOL fIterate);
void MNDrawFullNC(PWND pwnd, HDC hdcIn, PPOPUPMENU ppopup);
void MNDrawArrow(HDC hdcIn, PPOPUPMENU ppopup, UINT uArrow);
void MNEraseBackground (HDC hdc, PMENU pmenu, int x, int y, int cx, int cy);
void MNDrawEdge(PMENU pmenu, HDC hdc, RECT * prcDraw, UINT nFlags);


//
// mnstate.c
//
PMENUSTATE xxxMNAllocMenuState(PTHREADINFO ptiCurrent, PTHREADINFO ptiNotify, PPOPUPMENU ppopupmenuRoot);
void xxxMNEndMenuState(BOOL fFreePopup);
BOOL MNEndMenuStateNotify (PMENUSTATE pMenuState);
void MNFlushDestroyedPopups (PPOPUPMENU ppopupmenu, BOOL fUnlock);
BOOL MNSetupAnimationDC (PMENUSTATE pMenuState);
BOOL MNCreateAnimationBitmap(PMENUSTATE pMenuState, UINT cx, UINT cy);
void MNDestroyAnimationBitmap(PMENUSTATE pMenuState);
PMENUSTATE xxxMNStartMenuState(PWND pwnd, DWORD cmd, LPARAM lParam);
__inline VOID LockMenuState(
    PMENUSTATE pMenuState)
{
    (pMenuState->dwLockCount)++;
}
BOOL xxxUnlockMenuState (PMENUSTATE pMenuState);

//
// menu.c
//
#if DBG
    VOID Validateppopupmenu(PPOPUPMENU ppopupmenu);
#else // DBG
    #define Validateppopupmenu(ppopupmenu)
#endif // DBG

#if DBG
    #define MNGetpItemIndex DBGMNGetpItemIndex
UINT DBGMNGetpItemIndex(PMENU pmenu, PITEM pitem);
#else // DBG
    #define MNGetpItemIndex _MNGetpItemIndex
#endif // DBG

__inline UINT _MNGetpItemIndex(
    PMENU pmenu,
    PITEM pitem)
{
    return (UINT)(((ULONG_PTR)pitem - (ULONG_PTR)pmenu->rgItems) / sizeof(ITEM));
}

VOID xxxMNDismiss(PMENUSTATE pMenuState);
PITEM MNGetpItem(PPOPUPMENU ppopup, UINT uIndex);
VOID xxxMNSetCapture(PPOPUPMENU ppopup);
VOID xxxMNReleaseCapture(VOID);
VOID MNCheckButtonDownState(PMENUSTATE pMenuState);
PWND GetMenuStateWindow(PMENUSTATE pMenuState);
PVOID LockPopupMenu(PPOPUPMENU ppopup, PMENU * pspmenu, PMENU pmenu);
PVOID UnlockPopupMenu(PPOPUPMENU ppopup, PMENU * pspmenu);
PVOID LockWndMenu(PWND pwnd, PMENU * pspmenu, PMENU pmenu);
PVOID UnlockWndMenu(PWND pwnd, PMENU * pspmenu);
UINT MNSetTimerToCloseHierarchy(PPOPUPMENU ppopup);
BOOL xxxMNSetTop(PPOPUPMENU ppopup, int iNewTop);
LRESULT xxxMenuWindowProc(PWND, UINT, WPARAM, LPARAM);
VOID xxxMNButtonUp(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT posItemHit, LPARAM lParam);
VOID xxxMNButtonDown(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT posItemHit, BOOL fClick);
PITEM xxxMNSelectItem(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT itemPos);
BOOL xxxMNSwitchToAlternateMenu(PPOPUPMENU ppopupMenu);
VOID xxxMNCancel(PMENUSTATE pMenuState, UINT uMsg, UINT cmd, LPARAM lParam);
VOID xxxMNKeyDown(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT key);
BOOL xxxMNDoubleClick(PMENUSTATE pMenuState, PPOPUPMENU ppopup, int idxItem);
VOID xxxMNCloseHierarchy(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState);
PWND xxxMNOpenHierarchy(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState);
VOID LockMFMWFPWindow (PULONG_PTR puHitArea, ULONG_PTR uNewHitArea);
VOID UnlockMFMWFPWindow (PULONG_PTR puHitArea);
BOOL IsMFMWFPWindow (ULONG_PTR uHitArea);
LONG_PTR xxxMNFindWindowFromPoint(PPOPUPMENU ppopupMenu, PUINT pIndex, POINTS screenPt);
VOID xxxMNMouseMove(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, POINTS screenPt);
int xxxMNCompute(PMENU pMenu, PWND pwndNotify, DWORD yMenuTop,
        DWORD xMenuLeft,DWORD cxMax, LPDWORD lpdwHeight);
VOID xxxMNRecomputeBarIfNeeded(PWND pwndNotify, PMENU pMenu);
VOID xxxMenuDraw(HDC hdc, PMENU pMenu);
UINT  MNFindNextValidItem(PMENU pMenu, int i, int dir, UINT flags);
VOID MNFreeItem(PMENU pMenu, PITEM pItem, BOOL fFreeItemPopup);
BOOL   xxxMNStartMenu(PPOPUPMENU ppopupMenu, int mn);
VOID MNPositionSysMenu(PWND pwnd, PMENU pSysMenu);

PITEM xxxMNInvertItem(PPOPUPMENU ppopupmenu, PMENU pMenu,int itemNumber,PWND pwndNotify, BOOL fOn);

VOID   xxxSendMenuSelect(PWND pwndNotify, PWND pwndMenu, PMENU pMenu, int idx);
#define SMS_NOMENU      (PMENU)(-1)


BOOL   xxxSetSystemMenu(PWND pwnd, PMENU pMenu);
BOOL   xxxSetDialogSystemMenu(PWND pwnd);

VOID xxxMNChar(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT character);
PPOPUPMENU MNAllocPopup(BOOL fForceAlloc);
VOID MNFreePopup(PPOPUPMENU ppopupmenu);

/*
 * Menu entry points used by the rest of USER
 */
VOID xxxMNKeyFilter(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, UINT ch);
int  xxxMenuBarCompute(PMENU pMenu, PWND pwndNotify, DWORD yMenuTop,
        DWORD xMenuLeft, int cxMax);
VOID xxxEndMenu(PMENUSTATE pMenuState);
BOOL xxxCallHandleMenuMessages(PMENUSTATE pMenuState, PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL xxxHandleMenuMessages(LPMSG lpmsg, PMENUSTATE pMenuState, PPOPUPMENU ppopupmenu);
void xxxEndMenuLoop (PMENUSTATE pMenuState, PPOPUPMENU ppopupmenu);
int  xxxMNLoop(PPOPUPMENU ppopupMenu, PMENUSTATE pMenuState, LPARAM lParam, BOOL fDblClk);
VOID xxxSetSysMenu(PWND pwnd);
PMENU xxxGetSysMenuHandle(PWND pwnd);
PMENU xxxGetSysMenu(PWND pwnd, BOOL fSubMenu);
PMENU MakeMenuRtoL(PMENU pMenu, BOOL bRtoL);
HDC CreateCompatiblePublicDC(HDC hdc, HBITMAP *pbmDCGray);
void xxxPSMTextOut(HDC hdc, int xLeft, int yTop, LPWSTR lpsz, int cch, DWORD dwFlags);
BOOL xxxPSMGetTextExtent(HDC hdc, LPWSTR lpstr, int cch, PSIZE psize);

/*
 * LPK callbacks
 */
void xxxClientPSMTextOut(HDC hdc, int xLeft, int yTop, PUNICODE_STRING lpsz, int cch, DWORD dwFlags);
int  xxxClientLpkDrawTextEx(HDC hdc, int xLeft, int yTop, LPCWSTR lpsz, int nCount,
        BOOL fDraw, UINT wFormat, LPDRAWTEXTDATA lpDrawInfo, UINT bAction, int iCharSet);
BOOL xxxClientExtTextOutW(HDC hdc, int x, int y, int flOpts, RECT *prcl,
        LPCWSTR pwsz, UINT cwc, INT *pdx);
BOOL xxxClientGetTextExtentPointW(HDC hdc, LPCWSTR lpstr, int cch, PSIZE psize);

/*
 * Menu Drag and Drop
 */
NTSTATUS xxxClientRegisterDragDrop (HWND hwnd);
NTSTATUS xxxClientRevokeDragDrop (HWND hwnd);
NTSTATUS xxxClientLoadOLE(VOID);
void xxxMNSetGapState (ULONG_PTR uHitArea, UINT uIndex, UINT uFlags, BOOL fSet);
BOOL xxxMNDragOver(POINT * ppt, PMNDRAGOVERINFO pmndoi);
BOOL xxxMNDragLeave(VOID);
void xxxMNUpdateDraggingInfo (PMENUSTATE pMenuState, ULONG_PTR uHitArea, UINT uIndex);

/*
 * Scroll bar entry points
 */
VOID xxxSBTrackInit(PWND pwnd, LPARAM lParam, int curArea, UINT uType);
VOID SBCtlSetup(PSBWND psbwnd);
void CalcSBStuff(PWND pwnd, PSBCALC pSBCalc, BOOL fVert);
void CalcSBStuff2(PSBCALC  pSBCalc, LPRECT lprc, CONST PSBDATA pw, BOOL fVert);
BOOL xxxEnableScrollBar(PWND pwnd, UINT wSBflags, UINT wArrows);
void DrawSize(PWND pwnd, HDC hdc, int cxFrame, int cyFrame);
int xxxScrollWindowEx(PWND pwnd, int dx, int dy, LPRECT prcScroll,
        LPRECT prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, DWORD flags);
void xxxDoScrollMenu(PWND pwndNotify, PWND pwndSB, BOOL fVert, LPARAM lParam);

/*
 * ICONS.C
 */
BOOL xxxInternalEnumWindow(PWND pwndNext, WNDENUMPROC_PWND lpfn, LPARAM lParam, UINT fEnumChildren);
VOID ISV_InitMinMaxInfo(PWND pwnd, PPOINT aptMinMaxWnd);
VOID ISV_ValidateMinMaxInfo(PWND pwnd, PPOINT aptMinMaxWnd);
/*
 * GETSET.C
 */
WORD  _SetWindowWord(PWND pwnd, int index, WORD value);
DWORD xxxSetWindowLong(PWND pwnd, int index, DWORD value, BOOL bAnsi);
ULONG_PTR xxxSetWindowData(PWND pwnd, int index, ULONG_PTR dwData, BOOL bAnsi);
LONG  xxxSetWindowStyle(PWND pwnd, int gwl, DWORD styleNew);
BOOL FCallerOk(PWND pwnd);

int IntersectVisRect(HDC, int, int, int, int);  // Imported from GDI
PCURSOR xxxGetWindowSmIcon(PWND pwnd, BOOL fDontSendMsg);
VOID xxxDrawCaptionBar(PWND pwnd, HDC hdc, UINT fFlags);
VOID xxxDrawScrollBar(PWND pwnd, HDC hdc, BOOL fVert);
VOID xxxTrackBox(PWND, UINT, WPARAM, LPARAM, PSBCALC);
VOID xxxTrackThumb(PWND, UINT, WPARAM, LPARAM, PSBCALC);
VOID xxxEndScroll(PWND pwnd, BOOL fCancel);
VOID xxxDrawWindowFrame(PWND pwnd, HDC hdc, UINT wFlags);
BOOL xxxInternalPaintDesktop(PWND pwnd, HDC hdc, BOOL fPaint);
VOID xxxSysCommand(PWND pwnd, DWORD cmd, LPARAM lParam);
VOID xxxHandleNCMouseGuys(PWND pwnd, UINT message, int htArea, LPARAM lParam);
void xxxCreateClassSmIcon(PCLS pcls);
HICON xxxCreateWindowSmIcon(PWND pwnd, HICON hIconBig, BOOL fCopyFromRes);
BOOL DestroyWindowSmIcon(PWND pwnd);
BOOL DestroyClassSmIcon(PCLS pcls);
UINT DWP_GetHotKey(PWND);
UINT DWP_SetHotKey(PWND, DWORD);
PWND HotKeyToWindow(DWORD);

VOID xxxDWP_DoNCActivate(PWND pwnd, DWORD dwFlags, HRGN hrgnClip);
#define NCA_ACTIVE          0x00000001
#define NCA_FORCEFRAMEOFF   0x00000002

VOID xxxDWP_ProcessVirtKey(UINT key);
BOOL xxxDWP_EraseBkgnd(PWND pwnd, UINT msg, HDC hdc);
VOID SetTiledRect(PWND pwnd, LPRECT lprc, PMONITOR pMonitor);
VOID LinkWindow(PWND pwnd, PWND pwndInsert, PWND pwndParent);
VOID UnlinkWindow(PWND pwndUnlink, PWND pwndParent);
VOID xxxDW_DestroyOwnedWindows(PWND pwndParent);
VOID xxxDW_SendDestroyMessages(PWND pwnd);
VOID xxxFreeWindow(PWND pwnd, PTL ptlpwndFree);
VOID xxxFW_DestroyAllChildren(PWND pwnd);

PHOTKEY FindHotKey(PTHREADINFO pti, PWND pwnd, int id, UINT fsModifiers, UINT vk,
        BOOL fUnregister, PBOOL pfKeysExist);

NTSTATUS _BuildNameList(
        PWINDOWSTATION pwinsta,
        PNAMELIST pNameList,
        UINT cbNameList,
        PUINT pcbNeeded);

VOID xxxHelpLoop(PWND pwnd);

NTSTATUS _BuildPropList(PWND pwnd, PROPSET aPropSet[], UINT cPropMax, PUINT pcPropReturned);
BOOL xxxSendEraseBkgnd(PWND pwnd, HDC hdcBeginPaint, HRGN hrgnUpdate);
LONG xxxSetScrollBar(PWND pwnd, int code, LPSCROLLINFO lpsi, BOOL fRedraw);
VOID IncPaintCount(PWND pwnd);
VOID DecPaintCount(PWND pwnd);
PPROP CreateProp(PWND pwnd);

/*
 * METRICS.C
 */
VOID xxxRecreateSmallIcons(PWND pwnd);

VOID   TransferWakeBit(PTHREADINFO pti, UINT message);
BOOL   SysHasKanji(VOID);
LONG   xxxBroadcastMessage(PWND, UINT, WPARAM, LPARAM, UINT, PBROADCASTMSG );

VOID   zzzSetFMouseMoved();

VOID   TimersProc(VOID);

VOID   PostMove(PQ pq);
VOID   DestroyWindowsTimers(PWND pwnd);

UINT_PTR StartTimers(VOID);

/*==========================================================================*/
/*                                                                          */
/*  Internal Function Declarations                                          */
/*                                                                          */
/*==========================================================================*/

LRESULT xxxTooltipWndProc(PWND, UINT, WPARAM, LPARAM);
LRESULT xxxSwitchWndProc(PWND, UINT, WPARAM, LPARAM);
LRESULT xxxDesktopWndProc(PWND, UINT, WPARAM, LPARAM);

LRESULT xxxSBWndProc(PSBWND, UINT, WPARAM, LPARAM);

VOID   DrawThumb2(PWND, PSBCALC, HDC, HBRUSH, BOOL, UINT);
UINT   GetWndSBDisableFlags(PWND, BOOL);

HANDLE _ConvertMemHandle(LPBYTE lpData, UINT cbData);

VOID zzzRegisterSystemThread (DWORD flags, DWORD reserved);

VOID zzzUpdateCursorImage();
void zzzCalcStartCursorHide(PW32PROCESS Process, DWORD timeAdd);
BOOL FinalUserInit();
BOOL LW_RegisterWindows(BOOL fSystem);

BOOL xxxSystemParametersInfo(UINT wFlag, DWORD wParam, LPVOID lParam, UINT flags);

PWINDOWSTATION CheckClipboardAccess(void);
PCLIP FindClipFormat(PWINDOWSTATION pwinsta, UINT format);
BOOL InternalSetClipboardData(PWINDOWSTATION pwinsta, UINT format,
        HANDLE hData, BOOL fGlobalHandle, BOOL fIncSerialNumber);
VOID DisownClipboard(PWND pwndClipOwner);

VOID CaretBlinkProc(PWND pwnd, UINT message, UINT_PTR id, LPARAM lParam);
VOID xxxRedrawFrame(PWND pwnd);
VOID xxxRedrawFrameAndHook(PWND pwnd);
VOID BltColor(HDC, HBRUSH, HDC, int, int, int, int, int, int, UINT);
VOID StoreMessage(LPMSG pmsg, PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, DWORD time);
VOID StoreQMessage(PQMSG pqmsg, PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, DWORD time, DWORD dwQEvent, ULONG_PTR dwExtraInfo);

#ifdef REDIRECTION
__inline VOID StoreQMessagePti(
    PQMSG pqmsg,
    PTHREADINFO pti)
{
    if (pqmsg->msg.message >= WM_MOUSEFIRST && pqmsg->msg.message <= WM_MOUSELAST) {
        pqmsg->msg.pt.x = LOWORD(pqmsg->msg.lParam);
        pqmsg->msg.pt.y = HIWORD(pqmsg->msg.lParam);
    } else {
        if (pti != NULL)
            pqmsg->msg.pt = pti->ptLast;
    }
    pqmsg->pti = pti;
}
#else
__inline VOID StoreQMessagePti(
    PQMSG pqmsg,
    PTHREADINFO pti)
{
    pqmsg->pti = pti;
}
#endif // REDIRECTION

VOID xxxSendSizeMessage(PWND pwnd, UINT cmdSize);

VOID xxxCheckFocus(PWND pwnd);
VOID OffsetChildren(PWND pwnd, int dx, int dy, LPRECT prcHitTest);

VOID xxxMoveSize(PWND pwnd, UINT cmdMove, DWORD wptStart);
VOID xxxShowOwnedWindows(PWND pwndOwner, UINT cmdShow, HRGN hrgnHung);
VOID xxxAdjustSize(PWND pwnd, LPINT lpcx, LPINT lpcy);

VOID xxxNextWindow(PQ pq, DWORD wParam);
VOID xxxOldNextWindow(UINT flags);
VOID xxxCancelCoolSwitch(void);

VOID xxxCancelTracking(VOID);
VOID xxxCancelTrackingForThread(PTHREADINFO ptiCancel);
VOID xxxCapture(PTHREADINFO pti, PWND pwnd, UINT code);
UINT SystoChar(UINT message, LPARAM lParam);

PHOOK PhkFirstValid(PTHREADINFO pti, int nFilterType);
PHOOK PhkFirstGlobalValid(PTHREADINFO pti, int nFilterType);
VOID  FreeHook(PHOOK phk);
int   xxxCallHook(int, WPARAM, LPARAM, int);
LRESULT xxxCallHook2(PHOOK, int, WPARAM, LPARAM, LPBOOL);
BOOL  xxxCallMouseHook(UINT message, PMOUSEHOOKSTRUCTEX pmhs, BOOL fRemove);
VOID  xxxCallJournalRecordHook(PQMSG pqmsg);
DWORD xxxCallJournalPlaybackHook(PQMSG pqmsg);
VOID  SetJournalTimer(DWORD dt, UINT msgJournal);
VOID  FreeThreadsWindowHooks(VOID);

BOOL xxxSnapWindow(PWND pwnd);

BOOL    DefSetText(PWND pwnd, PLARGE_STRING pstrText);
PWND    DSW_GetTopLevelCreatorWindow(PWND pwnd);
VOID    xxxCalcClientRect(PWND pwnd, LPRECT lprc, BOOL fHungRedraw);
VOID    xxxUpdateClientRect(PWND pwnd);

BOOL   AllocateUnicodeString(PUNICODE_STRING pstrDst, PUNICODE_STRING pstrSrc);

HANDLE CreateDesktopHeap(PWIN32HEAP* ppheapRet, ULONG ulHeapSize);

BOOL xxxSetInternalWindowPos(PWND pwnd, UINT cmdShow, LPRECT lprcWin,
            LPPOINT lpptMin);
VOID xxxMetricsRecalc(UINT wFlags, int dx, int dy, int dyCaption, int dyMenu);

VOID xxxBroadcastDisplaySettingsChange(PDESKTOP, BOOL);


/*
 * This is for SPI_GET/SETUSERPREFERENCE.
 * Currently it's for DWORD values only. A type field will be added so all new
 * settings will be mostly handled through common SystemParametersInfo code.
 */
typedef struct tagPROFILEVALUEINFO {
    DWORD       dwValue;
    UINT        uSection;
    LPCWSTR     pwszKeyName;
} PROFILEVALUEINFO, *PPROFILEVALUEINFO;

/*
 *  SystemParametersInfo UserPreferences manipulation macros.
 *  SPI_ values in the BOOL or DWORD ranges (see winuser.w) are stored in
 *   gpdwCPUserPreferencesMask (BOOL) and gpviCPUserPreferences (DOWRD) (see kernel\globals.c).
 *  The following macros use the actual SPI_ value to determine the
 *   location of a given bit (BOOL mask) or DWORD in those  globals.
 *
 *  Macros to access DWORDs stored in gpviCPUserPreferences.
 *
 */
#define UPIsDWORDRange(uSetting)    \
            ((uSetting) >= SPI_STARTDWORDRANGE && (uSetting) < SPI_MAXDWORDRANGE)

/*
 * The first entry in gpviCPUserPreferences is reserved for the bitmask, so add 1.
 * Each setting has SPI_GET and SPI_SET, so divide by 2 to get the index
 */
#define UPDWORDIndex(uSetting)    \
            (1 + (((uSetting) - SPI_STARTDWORDRANGE) / 2))

/*
 * Macros to access BOOLs stored in gpdwCPUserPreferencesMask.
 */
#define UPIsBOOLRange(uSetting) \
    ((uSetting) >= SPI_STARTBOOLRANGE && (uSetting) < SPI_MAXBOOLRANGE)

/*
 * Each setting has SPI_GET and SPI_SET, so divide by 2 to get the index
 */
#define UPBOOLIndex(uSetting) \
    (((uSetting) - SPI_STARTBOOLRANGE) / 2)

/*
 * Returns a pointer to the DWORD that contains the bit corresponding to uSetting
 */
#define UPBOOLPointer(pdw, uSetting)    \
    (pdw + (UPBOOLIndex(uSetting) / 32))

/*
 * Returns the DWORD mask needed to test/set/clear the bit corresponding to uSetting
 */
#define UPBOOLMask(uSetting)    \
    (1 << (UPBOOLIndex(uSetting) - ((UPBOOLIndex(uSetting) / 32) * 32)))

#define TestUPBOOL(pdw, uSetting)   \
    (*UPBOOLPointer(pdw, uSetting) & UPBOOLMask(uSetting))

#define SetUPBOOL(pdw, uSetting)    \
    (*UPBOOLPointer(pdw, uSetting) |= UPBOOLMask(uSetting))

#define ClearUPBOOL(pdw, uSetting)                              \
{                                                               \
    UserAssert(UPIsBOOLRange(uSetting));                        \
    *UPBOOLPointer(pdw, uSetting) &= ~UPBOOLMask(uSetting);     \
}

/*
 * Use these macros ONLY if UPIsBOOLRange(SPI_GET ## uSetting) is TRUE
 */
#define TestUP(uSetting)    TestUPBOOL(gpdwCPUserPreferencesMask, SPI_GET ## uSetting)
#define SetUP(uSetting)     SetUPBOOL(gpdwCPUserPreferencesMask, SPI_GET ## uSetting)
#define ClearUP(uSetting)   ClearUPBOOL(gpdwCPUserPreferencesMask, SPI_GET ## uSetting)

#define IndexUP(uSetting) \
    (1 << (((uSetting) - SPI_STARTBOOLRANGE) / 2))

/*
 * Some settings (ie, UI Effects) are disabled when TestUP(UISETTINGS) is FALSE.
 */
#define TestEffectUP(uSetting)                                          \
    ((*gpdwCPUserPreferencesMask &                                      \
     (IndexUP(SPI_GET ## uSetting) | IndexUP(SPI_GETUIEFFECTS))) ==     \
     (IndexUP(SPI_GET ## uSetting) | IndexUP(SPI_GETUIEFFECTS)))

/*
 * Some UI effects have an "inverted" disabled value (ie, disabled is TRUE).
 */
#define TestEffectInvertUP(uSetting) (TestUP(uSetting) || !TestUP(UIEFFECTS))

/*
 * Some of these BOOL values are needed in the client side. This macro
 * propagates them to gpsi->PUSIFlags. Note that the SI_ value must match the
 * UPBOOLMask value for this to work fine.
 */
#define PropagetUPBOOLTogpsi(uSetting) \
    UserAssert((DWORD)(PUSIF_ ## uSetting) == (DWORD)UPBOOLMask(SPI_GET ## uSetting)); \
    COPY_FLAG(gpsi->PUSIFlags, TestUP(## uSetting), PUSIF_ ## uSetting)



/*
 * Test if a TS session is connected remotly or locally through the console
 * terminal.
 */
#define IsRemoteConnection() (gProtocolType != PROTOCOL_CONSOLE)
#define IsMultimon()  ((gpDispInfo != NULL)  && (gpDispInfo->cMonitors > 1))
#define GETCONSOLEHDEV() (gfRemotingConsole?gConsoleShadowhDev:gpDispInfo->hDev)

#ifdef IMM_PER_LOGON
BOOL UpdatePerUserImmEnabling(VOID);
#endif
BOOL xxxUpdatePerUserSystemParameters(DWORD dwFlags);
VOID SaveVolatileUserSettings(VOID);

VOID MenuRecalc(VOID);

#define UNDERLINE_RECALC    0x7FFFFFFF      // MAXINT; tells us to recalc underline position


/*
 * Library management routines.
 */
int GetHmodTableIndex(PUNICODE_STRING pstrName);
VOID AddHmodDependency(int iatom);
VOID RemoveHmodDependency(int iatom);
HANDLE xxxLoadHmodIndex(int iatom);
VOID xxxDoSysExpunge(PTHREADINFO pti);


VOID DestroyThreadsObjects(VOID);
VOID MarkThreadsObjects(PTHREADINFO pti);

VOID FreeMessageList(PMLIST pml);
VOID DestroyThreadsHotKeys(VOID);
VOID DestroyWindowsHotKeys(PWND pwnd);

VOID DestroyClass(PPCLS ppcls);
VOID PatchThreadWindows(PTHREADINFO);
VOID DestroyCacheDCEntries(PTHREADINFO);

VOID DestroyProcessesClasses(PPROCESSINFO);

/*
 *  Win16 Task Apis Taskman.c
 */

VOID InsertTask(PPROCESSINFO ppi, PTDB ptdbNew);

BOOL xxxSleepTask(BOOL fInputIdle, HANDLE);

BOOL xxxUserYield(PTHREADINFO pti);
VOID xxxDirectedYield(DWORD dwThreadId);
VOID DirectedScheduleTask(PTHREADINFO ptiOld, PTHREADINFO ptiNew, BOOL bSendMsg, PSMS psms);
VOID WakeWowTask(PTHREADINFO Pti);

/*
 *  WowScheduler assertion for multiple wow tasks running simultaneously
 */

_inline
VOID
EnterWowCritSect(
    PTHREADINFO pti,
    PWOWPROCESSINFO pwpi
)
{
   if (!++pwpi->CSLockCount) {
       pwpi->CSOwningThread = pti;
   } else {
       RIPMSG2(RIP_ERROR,
              "MultipleWowTasks running simultaneously %x %x\n",
              pwpi->CSOwningThread,
              pwpi->CSLockCount);
   }
}

_inline
VOID
ExitWowCritSect(
    PTHREADINFO pti,
    PWOWPROCESSINFO pwpi
)
{
   if (pti == pwpi->CSOwningThread) {
       pwpi->CSOwningThread = NULL;
       pwpi->CSLockCount--;
   }
}


////////////////////////////////////////////////////////////////////////////
//
// These are internal USER functions called from inside and outside the
// critical section (from server & client side). They are a private 'API'.
//
// The prototypes appear in pairs:
//    as called from outside the critsect (from client-side)
//    as called from inside the critsect (from server-side)
// there must be layer code for the 1st function of each pair which validates
// handles, enters the critsect, calls the 2nd of the pair of functions, and
// leaves the critsect again.
//
// Things may have to change when we go client server: InitPwSB() mustn't
// return a pointer to global (server) data! etc.
//
////////////////////////////////////////////////////////////////////////////

BOOL  xxxFillWindow(PWND pwndBrush, PWND pwndPaint, HDC hdc, HBRUSH hbr);
HBRUSH xxxGetControlBrush(PWND pwnd, HDC hdc, UINT msg);
HBRUSH xxxGetControlColor(PWND pwndParent, PWND pwndCtl, HDC hdc, UINT message);
PSBINFO  _InitPwSB(PWND);
BOOL  _KillSystemTimer(PWND pwnd, UINT_PTR nIDEvent);
BOOL  xxxPaintRect(PWND, PWND, HDC, HBRUSH, LPRECT);

////////////////////////////////////////////////////////////////////////////
//
// these are called from stubs.c in the client so will probably go away
//
////////////////////////////////////////////////////////////////////////////


/*
 * From CLASS.C
 */

typedef struct tagWNDCLASSVEREX {
    WNDCLASSEXW;
    LPCWSTR     lpszClassNameVer;
} WNDCLASSVEREX, *LPWNDCLASSVEREX;


PCLS InternalRegisterClassEx(
        LPWNDCLASSVEREX lpwndcls,
        WORD fnid,
        DWORD flags
        );

PCURSOR GetClassIcoCur(PWND pwnd, int index);
PCURSOR xxxSetClassIcon(PWND pwnd, PCLS pcls, PCURSOR pCursor, int gcw);
ULONG_PTR xxxSetClassData(PWND pwnd, int index, ULONG_PTR dwData, BOOL bAnsi);
ULONG_PTR SetClassCursor(PWND pwnd, PCLS pcls, DWORD index, ULONG_PTR dwData);

/*
 * CREATEW.C
 */

#define xxxNVCreateWindowEx(dwStyle, pstrClass, pstrName, style,        \
        x, y, cx, cy, pwndParent, pmenu, hModule, pCreateParams,        \
        dwExpWinVerAndFlags)                                            \
        xxxCreateWindowEx(dwStyle, pstrClass, pstrClass, pstrName,      \
        style, x, y, cx, cy, pwndParent, pmenu, hModule, pCreateParams, \
        dwExpWinVerAndFlags, NULL)

PWND xxxCreateWindowEx(DWORD dwStyle, PLARGE_STRING pstrNVClass, PLARGE_STRING pstrClass,
        PLARGE_STRING pstrName, DWORD style, int x, int y, int cx,
        int cy, PWND pwndParent, PMENU pmenu, HANDLE hModule,
        LPVOID pCreateParams, DWORD dwExpWinVerAndFlags, PACTIVATION_CONTEXT pActCtx);
BOOL xxxDestroyWindow(PWND pwnd);

/*
 * SENDMSG.C
 */
LRESULT xxxSendMessageFF(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam, ULONG_PTR xParam);
LONG xxxSendMessageBSM(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam,
        LPBROADCASTSYSTEMMSGPARAMS pbsmParams);
LRESULT xxxSendMessageEx(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam, ULONG_PTR xParam);
LRESULT xxxSendMessage(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT xxxSendMessageTimeout(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam,
        UINT fuFlags, UINT uTimeout, PLONG_PTR lpdwResult);
BOOL xxxSendNotifyMessage(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
void QueueNotifyMessage(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL xxxSendMessageCallback(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam,
        SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData, BOOL bClientReqest );
BOOL _ReplyMessage(LRESULT lRet);

/*
 * MN*.C
 */
int xxxTranslateAccelerator(PWND pwnd, LPACCELTABLE pat, LPMSG lpMsg);
BOOL  xxxSetMenu(PWND pwnd, PMENU pmenu, BOOL fRedraw);
VOID  ChangeMenuOwner(PMENU pMenu, PPROCESSINFO ppi);
int   xxxMenuBarDraw(PWND pwnd, HDC hdc, int cxFrame, int cyFrame);
BOOL  xxxDrawMenuBar(PWND pwnd);

UINT xxxPaintMenuBar(PWND pwnd, HDC hdc, int iLeftOffset, int iRightOffset, int iTopOffset, DWORD dwFlags);
UINT xxxCalcMenuBar(PWND pwnd, int iLeftOffset, int iRightOffset, int iTopOffset, LPCRECT prcWnd);

BOOL xxxSetMenuItemInfo(PMENU pMenu, UINT nPos, BOOL fByPosition,
    LPMENUITEMINFOW lpmii, PUNICODE_STRING pstrItem);
BOOL _SetMenuContextHelpId(PMENU pMenu, DWORD dwContextHelpId);
BOOL _SetMenuFlagRtoL(PMENU pMenu);
BOOL xxxInsertMenuItem(PMENU pMenu, UINT wIndex, BOOL fByPosition,
        LPMENUITEMINFOW lpmii, PUNICODE_STRING pstrItem);
BOOL  xxxRemoveMenu(PMENU pMenu, UINT nPos, UINT dwFlags);
BOOL  xxxDeleteMenu(PMENU pMenu, UINT nPos, UINT dwFlags);
BOOL  xxxSetMenuInfo(PMENU pMenu, LPCMENUINFO lpmi);
BOOL  xxxTrackPopupMenuEx(PMENU pmenu, UINT dwFlags, int x, int y,
        PWND pwnd, CONST TPMPARAMS *pparams);
LONG FindBestPos(int x, int y, int cx, int cy, LPRECT prcExclude,
                UINT wFlags, PPOPUPMENU ppopupmenu, PMONITOR pMonitor);
BOOL _SetMenuDefaultItem(PMENU pMenu, UINT wId, BOOL fByPosition);
int xxxMenuItemFromPoint(PWND pwnd, PMENU pMenu, POINT ptScreen);
BOOL xxxGetMenuItemRect(PWND pwnd, PMENU pMenu, UINT uIndex, LPRECT lprcScreen);
PPOPUPMENU MNGetPopupFromMenu(PMENU pMenu, PMENUSTATE *ppMenuState);
PVOID LockDesktopMenu(PMENU * ppmenu, PMENU pmenu);
PVOID UnlockDesktopMenu(PMENU * ppmenu);
#ifdef LAME_BUTTON
PMENU xxxLoadSysDesktopMenu (PMENU * ppmenu, UINT uMenuId, PWND pwnd);
#else
PMENU xxxLoadSysDesktopMenu (PMENU * ppmenu, UINT uMenuId);
#endif // LAME_BUTTON
__inline PVOID UnlockDesktopSysMenu(
    PMENU * ppmenu)
{
    ClearMF(*ppmenu, MFSYSMENU);
    return UnlockDesktopMenu(ppmenu);
}

/*
 * SHOWWIN.C
 */
BOOL xxxShowWindow(PWND pwnd, DWORD cmdShowAnimate);
BOOL _ShowWindowAsync(PWND pwnd, int cmdShow, UINT uWPFlags);
BOOL xxxShowOwnedPopups(PWND pwndOwner, BOOL fShow);

#define RDW_HASWINDOWRGN        0x8000
BOOL xxxSetWindowRgn(PWND pwnd, HRGN hrgn, BOOL fRedraw);

/*
 * SWP.C
 */
void SelectWindowRgn(PWND pwnd, HRGN hrgnClip);
PWND GetTopMostInsertAfter (PWND pwnd);

#define GETTOPMOSTINSERTAFTER(pwnd) \
    (gHardErrorHandler.pti == NULL ? NULL : GetTopMostInsertAfter(pwnd))

__inline BOOL FSwpTopmost(
   PWND pwnd)
{
    return (!!TestWF(pwnd, WEFTOPMOST) ^ !!TestWF(pwnd, WFTOGGLETOPMOST));
}


PWND CalcForegroundInsertAfter(PWND pwnd);
BOOL xxxSetWindowPos(PWND pwnd, PWND pwndInsertAfter, int x, int y,
        int cx, int cy, UINT flags);
PSMWP InternalBeginDeferWindowPos(int cwndGuess);
BOOL AllocateCvr (PSMWP psmwp, int cwndHint);
PSMWP _BeginDeferWindowPos(int cwndGuess);
PSMWP _DeferWindowPos(PSMWP psmwp, PWND pwnd, PWND pwndInsertAfter,
        int x, int y, int cx, int cy, UINT rgf);
BOOL xxxEndDeferWindowPosEx(PSMWP psmwp, BOOL fAsync);
BOOL xxxMoveWindow(PWND pwnd, int x, int y, int cx, int cy, BOOL fRedraw);
PWND GetLastTopMostWindow(VOID);
VOID xxxHandleWindowPosChanged(PWND pwnd, PWINDOWPOS ppos);
VOID IncVisWindows(PWND pwnd);
VOID DecVisWindows(PWND pwnd);
BOOL FVisCountable(PWND pwnd);
VOID SetVisible(PWND pwnd, UINT flags);
VOID ClrFTrueVis(PWND pwnd);

VOID SetWindowState(PWND pwnd, DWORD flags);
VOID ClearWindowState(PWND pwnd, DWORD flags);

BOOL xxxUpdateWindows(PWND pwnd, HRGN hrgn);

VOID SetMinimize(PWND pwnd, UINT uFlags);
#define SMIN_CLEAR            0
#define SMIN_SET              1

PWND NextOwnedWindow(PWND pwnd, PWND pwndOwner, PWND pwndParent);

/*
 * DWP.C
 */
LRESULT xxxDefWindowProc(PWND, UINT, WPARAM, LPARAM);
LRESULT xxxRealDefWindowProc(PWND, UINT, WPARAM, LPARAM);
PWND DWP_GetEnabledPopup(PWND pwndStart);


/*
 * INPUT.C
 */
#ifdef MESSAGE_PUMP_HOOK

BOOL xxxWaitMessageEx(UINT fsWakeMask, DWORD Timeout);
__inline BOOL xxxWaitMessage(
    VOID)
{
    return xxxWaitMessageEx(QS_ALLINPUT | QS_EVENT, 0);
}
BOOL xxxRealWaitMessageEx(UINT fsWakeMask, DWORD Timeout);

#else

BOOL xxxWaitMessage(VOID);

#endif

VOID DBGValidateQueueStates(PDESKTOP pdesk);
VOID IdleTimerProc(VOID);
VOID zzzWakeInputIdle(PTHREADINFO pti);
VOID SleepInputIdle(PTHREADINFO pti);
BOOL xxxInternalGetMessage(LPMSG lpmsg, HWND hwnd, UINT wMsgFilterMin,
        UINT wMsgFilterMax, UINT wRemoveMsg, BOOL fGetMessage);

#ifdef MESSAGE_PUMP_HOOK
BOOL xxxRealInternalGetMessage(LPMSG lpMsg, HWND hwndFilter, UINT msgMin,
        UINT msgMax, UINT flags, BOOL fGetMessage);
#endif

#define xxxPeekMessage(lpmsg, hwnd, wMsgMin, wMsgMax, wRemoveMsg) \
    xxxInternalGetMessage(lpmsg, hwnd, wMsgMin, wMsgMax, wRemoveMsg, FALSE)
#define xxxGetMessage(lpmsg, hwnd, wMsgMin, wMsgMax) \
    xxxInternalGetMessage(lpmsg, hwnd, wMsgMin, wMsgMax, PM_REMOVE, TRUE)
DWORD _GetMessagePos(VOID);
LRESULT xxxDispatchMessage(LPMSG lpmsg);
UINT GetMouseKeyFlags(PQ pq);
BOOL _PostMessage(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL IPostQuitMessage(PTHREADINFO pti, int nExitCode);
BOOL _PostQuitMessage(int nExitCode);
BOOL _PostThreadMessage(PTHREADINFO pti, UINT message, WPARAM wParam, LPARAM lParam);
BOOL xxxTranslateMessage(LPMSG pmsg, UINT flags);
BOOL _GetInputState(VOID);
DWORD _GetQueueStatus(UINT);
typedef VOID (CALLBACK* MSGWAITCALLBACK)(DWORD DeviceType);
DWORD xxxMsgWaitForMultipleObjects(DWORD nCount, PVOID *apObjects, MSGWAITCALLBACK pfnNonMsg, PKWAIT_BLOCK WaitBlockArray);

BOOL FHungApp(PTHREADINFO pti, DWORD dwTimeFromLastRead);
VOID xxxRedrawHungWindow(PWND pwnd, HRGN hrgnFullDrag);
VOID xxxRedrawHungWindowFrame(PWND pwnd, BOOL fActive);
VOID zzzActiveCursorTracking (PWND pwnd);
PWND GetActiveTrackPwnd(PWND pwnd, Q **ppq);
int xxxActiveWindowTracking(PWND pwnd, UINT uMsg, int iHitTest);
VOID xxxHungAppDemon(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam);

/*
 * shadow.c
 */
BOOL WindowHasShadow(PWND pwnd);
BOOL xxxAddShadow(PWND pwnd);
VOID xxxRemoveShadow(PWND pwnd);
VOID CleanupShadow(PWND pwndShadow);
VOID MoveShadow(PWND pwnd);
VOID UpdateShadowShape(PWND pwnd);
VOID xxxUpdateShadowZorder(PWND pwnd);
BOOL FAnyShadows(VOID);

/*
 * QUEUE.C
 */
__inline BOOL IsShellProcess(
    PPROCESSINFO ppi)
{
    return ((ppi->rpdeskStartup != NULL)
        && (ppi->rpdeskStartup->pDeskInfo->ppiShellProcess == ppi));
}

__inline DWORD GetAppCompatFlags2ForPti(
    PTHREADINFO pti,
    WORD wVer)
{
    if (wVer < pti->dwExpWinVer) {
        return 0;
    }

    return pti->dwCompatFlags2;
}

VOID ClearWakeMask(VOID);
VOID _AllowForegroundActivation(VOID);

ULONG GetTaskName(PTHREADINFO pti, PWSTR Buffer, ULONG BufferLength);
PQMSG FindQMsg(PTHREADINFO pti, PMLIST pml, PWND pwndFilter, UINT msgMin, UINT msgMax, BOOL bProcessAck);
VOID zzzShowStartGlass(DWORD dwTimeout);
DWORD _GetChangeBits(VOID);
NTSTATUS xxxSetCsrssThreadDesktop(PDESKTOP pdesk, PDESKRESTOREDATA pdrdRestore);
NTSTATUS xxxRestoreCsrssThreadDesktop(PDESKRESTOREDATA pdrdRestore);

PQ GetJournallingQueue(PTHREADINFO pti);
VOID ClearAppStarting (PPROCESSINFO ppi);
BOOL _GetProcessDefaultLayout(DWORD *pdwDefaultLayout);
BOOL _SetProcessDefaultLayout(DWORD dwDefaultLayout);


#ifdef HUNGAPP_GHOSTING

/*
 * GHOST.C
 */
VOID _DisableProcessWindowsGhosting(VOID);
LRESULT xxxGhostWndProc(PWND, UINT, WPARAM, LPARAM);
VOID SignalGhost(PWND pwnd);
BOOL xxxCreateGhost(PWND pwnd);
VOID RemoveGhost(PWND pwnd);
PWND FindGhost(PWND pwnd);
BOOL GhostSizedOrMoved(PWND pwnd);


#define WM_HUNGTHREAD (WM_USER + 0)
#define WM_CREATETRAILTIMER (WM_USER + 1)
#define WM_SCANGHOST (WM_USER + 2)

VOID    GhostThread(PDESKTOP pdesk);

__inline VOID SignalGhost(
    PWND pwnd)
{
    /*
     * No ghosting for applications that are debugged, since it can
     * make debugging confusing to developers.
     */
    if (TestWF(pwnd, WFMINIMIZED) ||
        (GETPTI(pwnd)->ppi->fDisableWindowsGhosting) ||
        (PsGetProcessDebugPort(GETPTI(pwnd)->ppi->Process) != NULL) ||
        (GetAppCompatFlags2ForPti(GETPTI(pwnd), VERMAX) & GACF2_NOGHOST)) {
        return;
    }

    _PostMessage(PWNDDESKTOP(pwnd), WM_HUNGTHREAD, 0, (LPARAM)HWq(pwnd));
}

#endif // HUNGAPP_GHOSTING

/*
 * TMSWITCH.C
 */
VOID xxxSwitchToThisWindow(PWND pwnd, BOOL fAltTab);

/*
 * TOUNICOD.C
 */
int xxxToUnicodeEx(UINT wVirtKey, UINT wScanCode, CONST BYTE *lpKeyState,
      LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL hkl);
int xxxInternalToUnicode(UINT wVirtKey, UINT wScanCode, CONST IN PBYTE pfvk,
      OUT PWCHAR awchChars, INT cChar, UINT uiTMFlags, OUT PDWORD pdwFlags, HKL hkl);

/*
 * HOTKEYS.C
 */
BOOL _RegisterHotKey(PWND pwnd, int id, UINT fsModifiers, UINT vk);
BOOL _UnregisterHotKey(PWND pwnd, int id);

/*
 * FOCUSACT.C
 */
PWND xxxSetFocus(PWND pwnd);
#ifdef FG_HOOKLOCK
#define FG_HOOKLOCK_PARAM(x)    , x
#else
#define FG_HOOKLOCK_PARAM(x)
#endif
BOOL CanForceForeground(PPROCESSINFO ppi FG_HOOKLOCK_PARAM(PTHREADINFO pti));
BOOL xxxStubSetForegroundWindow(PWND pwnd);
BOOL xxxSetForegroundWindow(PWND pwnd, BOOL fFlash);
PWND xxxSetActiveWindow(PWND pwnd);
PWND _GetActiveWindow(VOID);
BOOL xxxAllowSetForegroundWindow(DWORD dwProcessId);
BOOL _LockSetForegroundWindow(UINT uLockCode);

/*
 * UPDATE.C
 */
BOOL xxxInvalidateRect(PWND pwnd, LPRECT lprc, BOOL fErase);
BOOL xxxValidateRect(PWND pwnd, LPRECT lprc);
BOOL xxxInvalidateRgn(PWND pwnd, HRGN hrgn, BOOL fErase);
BOOL xxxValidateRgn(PWND pwnd, HRGN hrgn);
BOOL xxxUpdateWindow(PWND pwnd);
BOOL xxxGetUpdateRect(PWND pwnd, LPRECT lprc, BOOL fErase);
int  xxxGetUpdateRgn(PWND pwnd, HRGN hrgn, BOOL fErase);
int  _ExcludeUpdateRgn(HDC hdc, PWND pwnd);
int  CalcWindowRgn(PWND pwnd, HRGN hrgn, BOOL fClient);
VOID DeleteUpdateRgn(PWND pwnd);
BOOL xxxRedrawWindow(PWND pwnd, LPRECT lprcUpdate, HRGN hrgnUpdate, DWORD flags);
BOOL IntersectWithParents(PWND pwnd, LPRECT lprc);
VOID xxxInternalInvalidate(PWND pwnd, HRGN hrgnUpdate, DWORD flags);

/*
 * WINMGR.C
 */
BOOL xxxEnableWindow(PWND pwnd, BOOL fEnable);
int xxxGetWindowText(PWND pwnd, LPWSTR psz, int cchMax);
PWND xxxSetParent(PWND pwnd, PWND pwndNewParent);
BOOL xxxFlashWindow(PWND pwnd, DWORD dwFlags, DWORD dwTimeout);
extern ATOM gaFlashWState;
__inline DWORD GetFlashWindowState(
    PWND pwnd)
{
    return HandleToUlong(_GetProp(pwnd, MAKEINTATOM(gaFlashWState), PROPF_INTERNAL));
}

__inline VOID SetFlashWindowState(
    PWND pwnd,
    DWORD dwState)
{
    InternalSetProp(pwnd, MAKEINTATOM(gaFlashWState),
                    (HANDLE)ULongToPtr(dwState), PROPF_INTERNAL | PROPF_NOPOOL);
}
__inline VOID RemoveFlashWindowState(
    PWND pwnd)
{
    InternalRemoveProp(pwnd, MAKEINTATOM(gaFlashWState), PROPF_INTERNAL);
}
BOOL _GetWindowPlacement(PWND pwnd, PWINDOWPLACEMENT pwp);
BOOL xxxSetWindowPlacement(PWND pwnd, PWINDOWPLACEMENT pwp);
BOOL ValidateParentDepth(PWND pwnd, PWND pwndParent);
BOOL ValidateOwnerDepth(PWND pwnd, PWND pwndOwner);
VOID WPUpdateCheckPointSettings (PWND pwnd, UINT uWPFlags);

/*
 * DC.C
 */
HDC  _GetDC(PWND pwnd);
HDC  _GetDCEx(PWND pwnd, HRGN hrgnClip, DWORD flags);
HDC  _GetWindowDC(PWND pwnd);
BOOL _ReleaseDC(HDC hdc);
UINT ReleaseCacheDC(HDC hdc, BOOL fEndPaint);
HDC  CreateCacheDC(PWND, DWORD, PMONITOR);
BOOL DestroyCacheDC(PDCE *, HDC);
VOID InvalidateDce(PDCE pdce);
VOID DeleteHrgnClip(PDCE pdce);
PWND WindowFromCacheDC(HDC hdc);
PWND FastWindowFromDC(HDC hdc);
VOID DelayedDestroyCacheDC(VOID);
PDCE LookupDC(HDC hdc);
HDC GetMonitorDC(PDCE pdceOrig, PMONITOR pMonitor);
BOOL GetDCOrgOnScreen(HDC hdc, LPPOINT ppt);
__inline VOID MarkDCEInvalid(
    PDCE pdce)
{
    /*
     * Clear all bits, but these.
     */
    pdce->DCX_flags &= (DCX_CACHE | DCX_REDIRECTED);

    /*
     * Mark this cache entry as invalid
     */
    pdce->DCX_flags |= DCX_INVALID;
}

BOOL MirrorRegion(PWND pwnd, HRGN hrgn, BOOL bUseClient);

/*
 * PAINT.C
 */
HDC  xxxBeginPaint(PWND pwnd, PAINTSTRUCT *lpps);
BOOL xxxEndPaint(PWND pwnd, PAINTSTRUCT *lpps);

/*
 * CAPTURE.C
 */
PWND xxxSetCapture(PWND pwnd);
BOOL xxxReleaseCapture(VOID);

/*
 * KEYBOARD.C
 */
SHORT _GetAsyncKeyState(int vk);
BOOL _SetKeyboardState(CONST BYTE *pKeyboard);
int _GetKeyboardType(int nTypeFlag);
VOID RegisterPerUserKeyboardIndicators(PUNICODE_STRING pProfileUserName);
VOID UpdatePerUserKeyboardIndicators(PUNICODE_STRING pProfileUserName);
VOID UpdatePerUserKeyboardMappings(PUNICODE_STRING pProfileUserName);

#define TestRawKeyDown(vk)     TestKeyDownBit(gafRawKeyState, vk)
#define SetRawKeyDown(vk)      SetKeyDownBit(gafRawKeyState, vk)
#define ClearRawKeyDown(vk)    ClearKeyDownBit(gafRawKeyState, vk)
#define TestRawKeyToggle(vk)   TestKeyToggleBit(gafRawKeyState, vk)
#define SetRawKeyToggle(vk)    SetKeyToggleBit(gafRawKeyState, vk)
#define ClearRawKeyToggle(vk)  ClearKeyToggleBit(gafRawKeyState, vk)
#define ToggleRawKeyToggle(vk) ToggleKeyToggleBit(gafRawKeyState, vk)

/*
 * XLATE.C
 */
int  _GetKeyNameText(LONG lParam, LPWSTR lpString, int nSize);

/*
 * TIMERS.C
 */
BOOL _KillTimer(PWND pwnd, UINT_PTR nIDEvent);
PTIMER FindTimer(PWND pwnd, UINT_PTR nID, UINT flags, BOOL fKill);
VOID xxxSystemTimerProc(PWND pwnd, UINT msg, UINT_PTR id, LPARAM lParam);


/*
 * CARET.C
 */
BOOL zzzDestroyCaret(VOID);
BOOL xxxCreateCaret(PWND, HBITMAP, int, int);
BOOL zzzShowCaret(PWND);
BOOL zzzHideCaret(PWND);
BOOL _SetCaretBlinkTime(UINT);
BOOL zzzSetCaretPos(int, int);

/*
 * MSGBEEP.C
 */
BOOL xxxOldMessageBeep(VOID);
BOOL xxxMessageBeep(UINT wType);
VOID PlayEventSound(UINT idSound);

/*
 * WINWHERE.C
 */
PWND _ChildWindowFromPointEx(PWND pwndParent, POINT pt, UINT i);
PWND xxxWindowFromPoint(POINT pt);
PWND SizeBoxHwnd(PWND pwnd);

/*
 * GETSET.C
 */
WORD  _SetWindowWord(PWND pwnd, int index, WORD value);
DWORD xxxSetWindowLong(PWND pwnd, int index, DWORD value, BOOL bAnsi);
#ifdef _WIN64
ULONG_PTR xxxSetWindowLongPtr(PWND pwnd, int index, ULONG_PTR value, BOOL bAnsi);
#else
#define xxxSetWindowLongPtr xxxSetWindowLong
#endif
#define __GetWindowLong(pwnd, index) ((LONG)(*(DWORD UNALIGNED *)((BYTE *)((pwnd) + 1) + (index))))
#define __GetWindowLongPtr(pwnd, index) ((LONG_PTR)(*(ULONG_PTR UNALIGNED *)((BYTE *)((pwnd) + 1) + (index))))
#if DBG
ULONG DBGGetWindowLong(PWND pwnd, int index);
#define _GetWindowLong DBGGetWindowLong
ULONG_PTR DBGGetWindowLongPtr(PWND pwnd, int index);
#define _GetWindowLongPtr DBGGetWindowLongPtr
#else
#define _GetWindowLong __GetWindowLong
#define _GetWindowLongPtr __GetWindowLongPtr
#endif

/*
 * CLIPBRD.C
 */
BOOL xxxOpenClipboard(PWND pwnd, LPBOOL lpfEmptyClient);
BOOL xxxCloseClipboard(PWINDOWSTATION pwinsta);
UINT _EnumClipboardFormats(UINT fmt);
BOOL xxxEmptyClipboard(PWINDOWSTATION pwinsta);
HANDLE xxxGetClipboardData(PWINDOWSTATION pwinsta, UINT fmt, PGETCLIPBDATA gcd);
BOOL _IsClipboardFormatAvailable(UINT fmt);
int _GetPriorityClipboardFormat(UINT *lpPriorityList, int cfmts);
PWND xxxSetClipboardViewer(PWND pwndClipViewerNew);
BOOL xxxChangeClipboardChain(PWND pwndRemove, PWND pwndNewNext);

/*
 * miscutil.c
 */
VOID SetDialogPointer(PWND pwnd, LONG_PTR lPtr);
VOID ZapActiveAndFocus(VOID);
BOOL xxxSetShellWindow(PWND pwnd, PWND pwndBkGnd);
BOOL _SetProgmanWindow(PWND pwnd);
BOOL _SetTaskmanWindow(PWND pwnd);

#define STW_SAME    ((PWND) 1)
VOID xxxSetTrayWindow(PDESKTOP pdesk, PWND pwnd, PMONITOR pMonitor);
BOOL xxxAddFullScreen(PWND pwnd, PMONITOR pMonitor);
BOOL xxxRemoveFullScreen(PWND pwnd, PMONITOR pMonitor);
BOOL xxxCheckFullScreen(PWND pwnd, PSIZERECT psrc);
BOOL IsTrayWindow(PWND);

#define FDoTray()   (SYSMET(ARRANGE) & ARW_HIDE)
#define FCallHookTray() (IsHooked(PtiCurrent(), WHF_SHELL))
#define FPostTray(p) (p->pDeskInfo->spwndTaskman)
#define FCallTray(p) (FDoTray() && ( FCallHookTray()|| FPostTray(p) ))

// ----------------------------------------------------------------------------
//
//  FTopLevel() - TRUE if window is a top level window
//
//  FHas31TrayStyles() -  TRUE if window is either full screen or has
//                        both a system menu and a caption
//                        (NOTE:  minimized windows always have captions)
//
// ----------------------------------------------------------------------------
#define FTopLevel(pwnd)         (pwnd->spwndParent == PWNDDESKTOP(pwnd))
#define FHas31TrayStyles(pwnd)    (TestWF(pwnd, WFFULLSCREEN) || \
                                  (TestWF(pwnd, WFSYSMENU | WFMINBOX) && \
                                  (TestWF(pwnd, WFCAPTION) || TestWF(pwnd, WFMINIMIZED))))
BOOL IsVSlick(PWND pwnd);
BOOL Is31TrayWindow(PWND pwnd);

/*
 * fullscr.c
 */

#if DBG
#define  VerifyVisibleMonitorCount()    \
    {                                   \
        PMONITOR pMonitor = gpDispInfo->pMonitorFirst;  \
        ULONG cVisMon = 0;                              \
        while (pMonitor) {                              \
            if (pMonitor->dwMONFlags & MONF_VISIBLE) {  \
                cVisMon++;                              \
            }                                           \
            pMonitor = pMonitor->pMonitorNext;          \
        }                                               \
        UserAssert(cVisMon == gpDispInfo->cMonitors);   \
    }
#endif

BOOL xxxMakeWindowForegroundWithState(PWND, BYTE);
void FullScreenCleanup();
LONG xxxUserChangeDisplaySettings(PUNICODE_STRING pstrDeviceName, LPDEVMODEW pDevMode,
    HWND hwnd, PDESKTOP pdesk, DWORD dwFlags, PVOID lParam, MODE PreviousMode);
BOOL xxxbFullscreenSwitch(BOOL bFullscreenSwitch, HWND hwnd);


/*
 * SBAPI.C
 */
BOOL xxxShowScrollBar(PWND, UINT, BOOL);

/*
 * mngray.c
 */
BOOL xxxDrawState(HDC hdcDraw, HBRUSH hbrFore,
        LPARAM lData, int x, int y, int cx, int cy, UINT uFlags);

/*
 * SCROLLW.C
 */
BOOL _ScrollDC(HDC hdc, int dx, int dy, LPRECT prcSrc, LPRECT prcClip,
               HRGN hrgnUpdate, LPRECT prcUpdate);

/*
 * SPB.C
 */
VOID SpbCheckRect(PWND pwnd, LPRECT lprc, DWORD flags);
VOID SpbCheck(VOID);
PSPB FindSpb(PWND pwnd);
VOID FreeSpb(PSPB pspb);
VOID FreeAllSpbs(VOID);
VOID CreateSpb(PWND pwnd, UINT flags, HDC hdcScreen);
UINT RestoreSpb(PWND pwnd, HRGN hrgnUncovered, HDC *phdcScreen);
VOID SpbCheckPwnd(PWND pwnd);
VOID SpbCheckDce(PDCE pdce);
BOOL LockWindowUpdate2(PWND pwndLock, BOOL fThreadOverride);

/*
 * DRAWFRM.C
 */
BOOL BitBltSysBmp(HDC hdc, int x, int y, UINT i);

/*
 * SYSMET.c
 */
BOOL APIENTRY xxxSetSysColors(PUNICODE_STRING pProfileUserName,int count, PUINT pIndex, LPDWORD pClrVal, UINT uOptions);
VOID SetSysColor(UINT icol, DWORD rgb, UINT uOptions);

/*
 * ICONS.C
 */
UINT xxxArrangeIconicWindows(PWND pwnd);
BOOL  _SetSystemMenu(PWND pwnd, PMENU pMenu);

/*
 * RMCREATE.C
 */
PICON _CreateIconIndirect(PICONINFO piconinfo);
PCURSOR _CreateCursor(HANDLE hModule, int iXhotspot, int iYhotspot,
        int iWidth, int iHeight, LPBYTE lpANDplane, LPBYTE lpXORplane);
PICON _CreateIcon(HANDLE hModule, int iWidth, int iHeight,
        BYTE bPlanes, BYTE bBitsPixel, LPBYTE lpANDplane, LPBYTE lpXORplane);
VOID DestroyUnlockedCursor(VOID *pv);
BOOL _DestroyCursor(PCURSOR pcur, DWORD cmdDestroy);
HANDLE _CreateAcceleratorTable(LPACCEL ccxpaccel, int cbAccel);

/*
 * CURSOR.C
 */
#if DBG
    PCURSOR DbgLockQCursor(PQ pq, PCURSOR pcur);
    #define LockQCursor(pq, pcur)   DbgLockQCursor(pq, pcur)
#else
    #define LockQCursor(pq, pcur)   Lock(&pq->spcurCurrent, pcur)
#endif // DBG

PCURSOR zzzSetCursor(PCURSOR pcur);
BOOL    zzzSetCursorPos(int x, int y);
int     zzzShowCursor(BOOL fShow);
BOOL    zzzClipCursor(LPCRECT prcClip);
PCURSOR _GetCursor(VOID);
BOOL    _SetCursorContents(PCURSOR pcur, PCURSOR pcurNew);
VOID    SetPointer(BOOL fSet);
VOID    zzzHideCursorNoCapture(VOID);
#define GETPCI(pcur) ((PCURSINFO)&(pcur->CI_FIRST))

/*
 * WMICON.C
 */
BOOL _DrawIconEx(HDC hdc, int x, int y, PCURSOR pcur, int cx, int cy,
        UINT istepIfAniCur, HBRUSH hbrush, UINT diFlags) ;
BOOL BltIcon(HDC hdc, int x, int y, int cx, int cy,
        HDC hdcSrc, PCURSOR pcursor, UINT diFlag, LONG rop);

/*
 * DESKTOP.C
 */

HDESK xxxCreateDesktop(
        POBJECT_ATTRIBUTES,
        KPROCESSOR_MODE,
        PUNICODE_STRING,
        LPDEVMODEW,
        DWORD,
        DWORD);

#define CST_MAX_THREADS       30

/*
 * Flags for xxxSwitchDesktop().
 */
#define SDF_CREATENEW  0x01 /* New desktop, don't send enable/disable */
#define SDF_SLOVERRIDE 0x02 /* Don't respect WSF_SWITCHLOCK on pwinsta */

HDESK _OpenDesktop(POBJECT_ATTRIBUTES ccxObja, KPROCESSOR_MODE AccessMode, DWORD dwFlags, DWORD dwDesiredAccess, BOOL *pbShutDown);
BOOL OpenDesktopCompletion(PDESKTOP pdesk, HDESK hdesk, DWORD dwFlags, BOOL *pbShutDown);
BOOL xxxSwitchDesktop(PWINDOWSTATION pwinsta, PDESKTOP pdesk, DWORD dwFlags);
VOID zzzSetDesktop(PTHREADINFO pti, PDESKTOP pdesk, HDESK hdesk);
HDESK xxxGetInputDesktop(VOID);
BOOL xxxSetThreadDesktop(HDESK hdesk, PDESKTOP pdesk);
HDESK xxxGetThreadDesktop(DWORD dwThread, HDESK hdeskConsole, KPROCESSOR_MODE AccessMode);
BOOL xxxCloseDesktop(HDESK hdesk, KPROCESSOR_MODE AccessMode);
DWORD _SetDesktopConsoleThread(PDESKTOP pdesk, DWORD dwThreadId);
VOID xxxRealizeDesktop(PWND pwnd);

/*
 * WINSTA.C
 */
NTSTATUS CreateGlobalAtomTable(PVOID* ppAtomTable);
HWINSTA xxxCreateWindowStation(POBJECT_ATTRIBUTES ObjA,
    KPROCESSOR_MODE OwnershipMode,
    DWORD amRequest,
    HANDLE hKbdLayoutFile,
    DWORD offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    PCWSTR pwszKLID,
    UINT uKbdInputLocale);
HWINSTA _OpenWindowStation(POBJECT_ATTRIBUTES pObjA, DWORD dwDesiredAccess, KPROCESSOR_MODE AccessMode);
BOOL _CloseWindowStation(HWINSTA hwinsta);
NTSTATUS xxxSetProcessWindowStation(HWINSTA hwinsta, KPROCESSOR_MODE AccessMode);

PWINDOWSTATION _GetProcessWindowStation(HWINSTA *phwinsta);
BOOL _LockWorkStation(VOID);

NTSTATUS ReferenceWindowStation(PETHREAD Thread, HWINSTA hwinsta,
        ACCESS_MASK amDesiredAccess, PWINDOWSTATION *ppwinsta, BOOL fUseDesktop);

/*
 * HOOKS.C
 */
PROC zzzSetWindowsHookAW(int nFilterType, PROC pfnFilterProc, DWORD dwFlags);
BOOL zzzUnhookWindowsHookEx(PHOOK phk);
BOOL zzzUnhookWindowsHook(int nFilterType, PROC pfnFilterProc);
LRESULT xxxCallNextHookEx(int nCode, WPARAM wParam, LPARAM lParam);
BOOL _CallMsgFilter(LPMSG lpMsg, int nCode);
VOID zzzCancelJournalling(VOID);
#if DBG
VOID DbgValidateHooks(PHOOK phk, int iType);
#else
#define DbgValidateHooks(phk, iType)
#endif
BOOL _RegisterUserApiHook(PUNICODE_STRING pstrLib, ULONG_PTR offPfnInitDefWindowProc);
BOOL _UnregisterUserApiHook(VOID);
BOOL xxxLoadUserApiHook(VOID);


extern int gihmodUserApiHook;

__inline BOOL IsInsideUserApiHook(
    VOID)
{
    return gihmodUserApiHook >= 0;
}

#ifdef MESSAGE_PUMP_HOOK

BOOL _DoInitMessagePumpHook(VOID);
BOOL _DoUninitMessagePumpHook(VOID);

extern PTHREADINFO gptiCurrent;

__inline BOOL IsInsideMPH(
    VOID)
{
    PCLIENTTHREADINFO pcti = PtiCurrent()->pcti;
    return pcti->cMessagePumpHooks > 0;
}

#endif // MESSAGE_PUMP_HOOK


/*
 * SRVHOOK.C
 */
LRESULT fnHkINLPCWPEXSTRUCT(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);
LRESULT fnHkINLPCWPRETEXSTRUCT(PWND pwnd, UINT message, WPARAM wParam,
        LPARAM lParam, ULONG_PTR xParam);

/*
 * EXITWIN.C
 */
LONG xxxClientShutdown(PWND pwnd, WPARAM wParam);
BOOL xxxRegisterUserHungAppHandlers(PFNW32ET pfnW32EndTask, HANDLE hEventWowExec);

/*
 * INIT.C
 */
BOOL CreateTerminalInput(PTERMINAL pTerm);

VOID LW_LoadProfileInitData(PUNICODE_STRING pProfileUserName);
VOID xxxODI_ColorInit(PUNICODE_STRING pProfileUserName);
HRGN InitCreateRgn(VOID);
VOID xxxUpdateSystemCursorsFromRegistry(PUNICODE_STRING pProfileUserName);
VOID xxxUpdateSystemIconsFromRegistry(PUNICODE_STRING pProfileUserName);
VOID RegisterLPK(DWORD dwLpkEntryPoints);
HBITMAP CreateCaptionStrip(VOID);

BOOL LW_BrushInit(VOID);
VOID xxxLW_LoadFonts(BOOL bRemote);

VOID _LoadCursorsAndIcons(VOID);

VOID UnloadCursorsAndIcons(VOID);

VOID IncrMBox(VOID);
VOID DecrMBox(VOID);
VOID InitAnsiOem(PCHAR pOemToAnsi, PCHAR pAnsiToOem);
int  xxxAddFontResourceW(LPWSTR lpFile, FLONG flags, DESIGNVECTOR *pdv);
VOID EnforceColorDependentSettings(VOID);


/*
 * ACCESS.C
 */
VOID xxxUpdatePerUserAccessPackSettings(PUNICODE_STRING pProfileUserName);

/*
 * inctlpan.c
 */
VOID GetWindowNCMetrics(LPNONCLIENTMETRICS lpnc);

HFONT CreateFontFromWinIni(PUNICODE_STRING pProfileUserName,LPLOGFONT lplf, UINT idFont);
VOID SetMinMetrics(PUNICODE_STRING pProfileUserName,LPMINIMIZEDMETRICS lpmin);
BOOL xxxSetWindowNCMetrics(PUNICODE_STRING pProfileUserName,LPNONCLIENTMETRICS lpnc, BOOL fSizeChange, int clNewBorder);
BOOL SetIconMetrics(PUNICODE_STRING pProfileUserName,LPICONMETRICS lpicon);
BOOL xxxSetNCFonts(PUNICODE_STRING pProfileUserName, LPNONCLIENTMETRICS lpnc);
BOOL CreateBitmapStrip(VOID);
BOOL UpdateWinIniInt(PUNICODE_STRING pProfileUserName, UINT idSection, UINT wKeyNameId, int value);

/*
 * rare.c
 */
VOID SetDesktopMetrics(VOID);
VOID SetMsgBox(PWND pwnd);

BOOL _RegisterShellHookWindow(PWND pwnd);
BOOL _DeregisterShellHookWindow(PWND pwnd);
BOOL xxxSendMinRectMessages(PWND pwnd, RECT *lpRect);
void PostShellHookMessages(UINT message, LPARAM lParam);
VOID _ResetDblClk(VOID);
VOID xxxSimulateShiftF10(VOID);
BOOL VWPLAdd(PVWPL *ppvwpl, PWND pwnd, DWORD dwThreshold);
BOOL VWPLRemove(PVWPL *ppvwpl, PWND pwnd);
PWND VWPLNext(PVWPL pvwpl, PWND pwndPrev, DWORD *pnPrev);

/*
 * DDETRACK STUFF
 */

#if DBG
VOID ValidatePublicObjectList(VOID);
VOID TraceDdeMsg(UINT msg, HWND hwndFrom, HWND hwndTo, UINT code);
#define MSG_SENT    0
#define MSG_POST    1
#define MSG_RECV    2
#define MSG_PEEK    3
#else
#define ValidatePublicObjectList()
#define TraceDdeMsg(m, h1, h2, c)
#endif // DBG

typedef struct tagFREELIST {
    struct tagFREELIST *next;
    HANDLE h;                           // CSR client side GMEM_DDESHARE handle
    DWORD flags;                        // XS_ flags describing data
} FREELIST, *PFREELIST;

typedef struct tagDDEIMP {
    SECURITY_QUALITY_OF_SERVICE qos;
    SECURITY_CLIENT_CONTEXT ClientContext;
    short cRefInit;
    short cRefConv;
} DDEIMP, *PDDEIMP;

typedef struct tagDDECONV {
    THROBJHEAD          head;           // HM header
    struct tagDDECONV   *snext;
    struct tagDDECONV   *spartnerConv;  // siamese twin
    PWND                spwnd;          // associated pwnd
    PWND                spwndPartner;   // associated partner pwnd
    struct tagXSTATE    *spxsOut;       // transaction info queue - out point
    struct tagXSTATE    *spxsIn;        // transaction info queue - in point
    struct tagFREELIST  *pfl;           // free list
    DWORD               flags;          // CXF_ flags
    struct tagDDEIMP    *pddei;         // impersonation information
} DDECONV, *PDDECONV;

typedef DWORD (FNDDERESPONSE)(PDWORD pmsg, LPARAM *plParam, PDDECONV pDdeConv);
typedef FNDDERESPONSE *PFNDDERESPONSE;

typedef struct tagXSTATE {
    THROBJHEAD          head;           // HM header
    struct tagXSTATE    *snext;
    PFNDDERESPONSE      fnResponse;     // proc to handle next msg.
    HANDLE              hClient;        // GMEM_DDESAHRE handle on client side
    HANDLE              hServer;        // GMEM_DDESHARE handle on server side
    PINTDDEINFO         pIntDdeInfo;    // DDE data being transfered
    DWORD               flags;          // XS_ flags describing transaction/data
} XSTATE, *PXSTATE;

// values for flags field

#define CXF_IS_SERVER               0x0001
#define CXF_TERMINATE_POSTED        0x0002
#define CXF_PARTNER_WINDOW_DIED     0x0004
#define CXF_INTRA_PROCESS           0x8000

BOOL xxxDDETrackSendHook(PWND pwndTo, DWORD message, WPARAM wParam, LPARAM lParam);
DWORD xxxDDETrackPostHook(PUINT pmessage, PWND pwndTo, WPARAM wParam, LPARAM *plParam, BOOL fSent);
VOID FreeDdeXact(PXSTATE pxs);

VOID xxxDDETrackGetMessageHook(PMSG pmsg);
VOID xxxDDETrackWindowDying(PWND pwnd, PDDECONV pDdeConv);
VOID FreeDdeConv(PDDECONV pDdeConv);
BOOL _ImpersonateDdeClientWindow(PWND pwndClient, PWND pwndServer);


typedef struct tagMONITORPOS
{
    RECT     rcMonitor;     /* where the monitor rect was */
    RECT     rcWork;        /* where the work rect was */
    PMONITOR pMonitor;      /* what new monitor gets its windows */
} MONITORPOS, *PMONITORPOS;

typedef struct tagMONITORRECTS
{
    int             cMonitor;   /* number of monitors */
    MONITORPOS      amp[1];     /* the monitor positions */
} MONITORRECTS, *PMONITORRECTS;


// stuctures for windows resize/ reposition on reconnect.
// when disconnecting from local console, these structures allow
// to memorize the monitors layout and windows size and positions
// on the monitors. When reconnecting back to local console, the snapshot
// is used to restore windows positions for windows that still exist.


typedef struct tagWPSNAPSHOT
{
    RECT     rcWindow;                 /* Windows rect */
    HWND     hwnd;                     /* hwnd */
} WPSNAPSHOT, *PWPSNAPSHOT;

typedef struct tagWMSNAPSHOT
{
    PMONITORRECTS   pmr;        /* Monitors and their dimensions and positions */
    PWPSNAPSHOT     pwps;       /* Windows and their dimensions and positions */
    int cWindows;               /* number of windows in pwps */
} WMSNAPSHOT, *PWMSNAPSHOT;

NTSTATUS RestoreMonitorsAndWindowsRects(VOID);
NTSTATUS SnapShotMonitorsAndWindowsRects(VOID);
VOID  CleanupMonitorsAndWindowsSnapShot(VOID);
PWPSNAPSHOT SnapshotWindowRects(int *pnWindows);

PMONITORRECTS SnapshotMonitorRects(VOID);
VOID xxxDesktopRecalc(PMONITORRECTS pmrOld);
VOID UpdateMonitorRectsSnapShot(PMONITORRECTS pmr);
BOOL IsValidMonitor(PMONITOR pMonitor);

BOOL _SetDoubleClickTime(UINT dtTime);
BOOL _SwapMouseButton(BOOL fSwapButtons);
VOID xxxDestroyThreadInfo(VOID);

BOOL _GetWindowPlacement(PWND pwnd, PWINDOWPLACEMENT pwp);

PMENU xxxGetSystemMenu(PWND pWnd, BOOL bRevert);
PMENU _CreateMenu(VOID);
PMENU _CreatePopupMenu(VOID);
BOOL  _DestroyMenu(PMENU pMenu);
DWORD _CheckMenuItem(PMENU pMenu, UINT wIDCheckItem, UINT wCheck);
DWORD xxxEnableMenuItem(PMENU pMenu, UINT wIDEnableItem, UINT wEnable);

PWND _GetNextQueueWindow(PWND pwnd, BOOL fDir, BOOL fAltEsc);

UINT_PTR _SetSystemTimer(PWND pwnd, UINT_PTR nIDEvent, DWORD dwElapse,
        TIMERPROC_PWND pTimerFunc);
BOOL   _SetClipboardData(UINT fmt, HANDLE hData, BOOL fGlobalHandle, BOOL fIncSerialNumber);
WORD   _SetClassWord(PWND pwnd, int index, WORD value);
DWORD  xxxSetClassLong(PWND pwnd, int index, DWORD value, BOOL bAnsi);
#ifdef _WIN64
ULONG_PTR xxxSetClassLongPtr(PWND pwnd, int index, ULONG_PTR value, BOOL bAnsi);
#else
#define xxxSetClassLongPtr  xxxSetClassLong
#endif
ATOM   xxxRegisterClassEx(LPWNDCLASSVEREX pwc, PCLSMENUNAME pcmn,
        WORD fnid, DWORD dwFlags, LPDWORD pdwWOW);
BOOL  xxxHiliteMenuItem(PWND pwnd, PMENU pmenu, UINT cmd, UINT flags);
HANDLE _CreateAcceleratorTable(LPACCEL paccel, int cbAccel);
HANDLE xxxGetInputEvent(DWORD dwWakeMask);
BOOL   _UnregisterClass(LPCWSTR lpszClassName, HANDLE hModule, PCLSMENUNAME pcmn);
ATOM   _GetClassInfoEx(HANDLE hModule, LPCWSTR lpszClassName, LPWNDCLASSEX pwc, LPWSTR *ppszMenuName, BOOL bAnsi);
PWND   _WindowFromDC(HDC hdc);
PCLS   _GetWOWClass(HANDLE hModule, LPCWSTR lpszClassName);
LRESULT xxxHkCallHook(PHOOK phk, int nCode, WPARAM wParam, LPARAM lParam);
PHOOK  zzzSetWindowsHookEx(HANDLE hmod, PUNICODE_STRING pstrLib,
        PTHREADINFO ptiThread, int nFilterType, PROC pfnFilterProc, DWORD dwFlags);
DWORD  GetDebugHookLParamSize(WPARAM wParam, PDEBUGHOOKINFO pdebughookstruct);
BOOL   _RegisterLogonProcess(DWORD dwProcessId, BOOL fSecure);
UINT   _LockWindowStation(PWINDOWSTATION pwinsta);
BOOL   _UnlockWindowStation(PWINDOWSTATION pwinsta);
BOOL   _SetWindowStationUser(PWINDOWSTATION pwinsta, PLUID pluidUser,
        PSID psidUser, DWORD cbsidUser);
BOOL   _SetDesktopBitmap(PDESKTOP pdesk, HBITMAP hbitmap, DWORD dwStyle);

BOOL   _SetLogonNotifyWindow(PWND pwnd);


BOOL   _RegisterTasklist(PWND pwndTasklist);
LONG_PTR _SetMessageExtraInfo(LONG_PTR);
VOID   xxxRemoveEvents(PQ pq, int nQueue, DWORD flags);

PPCLS _InnerGetClassPtr(ATOM atom, PPCLS ppclsList, HANDLE hModule);

/*
 * ntcb.h funtions.
 */
DWORD ClientGetListboxString(PWND hwnd, UINT msg,
        WPARAM wParam, PVOID lParam,
        ULONG_PTR xParam, PROC xpfn, DWORD dwSCMSFlags, BOOL bNotString, PSMS psms);
HANDLE ClientLoadLibrary(PUNICODE_STRING pstrLib, ULONG_PTR offPfnInitDefWindowProc);
BOOL ClientFreeLibrary(HANDLE hmod);

#ifdef MESSAGE_PUMP_HOOK
BOOL ClientGetMessageMPH(LPMSG msg, HWND hwndFilter, UINT msgMin, UINT msgMax, UINT flags, BOOL fGetMessage);
BOOL ClientWaitMessageExMPH(UINT fsWakeMask, DWORD Timeout);
#endif

BOOL xxxClientGetCharsetInfo(LCID lcid, PCHARSETINFO pcs);
BOOL ClientExitProcess(PFNW32ET pfn, DWORD dwExitCode);
BOOL ClientGrayString(GRAYSTRINGPROC pfnOutProc, HDC hdc,
        DWORD lpData, int nCount);
BOOL CopyFromClient(LPBYTE lpByte, LPBYTE lpByteClient, DWORD cch,
        BOOL fString, BOOL fAnsi);
BOOL CopyToClient(LPBYTE lpByte, LPBYTE lpByteClient,
        DWORD cchMax, BOOL fAnsi);
VOID ClientNoMemoryPopup(VOID);
NTSTATUS xxxClientThreadSetup(VOID);

VOID ClientDeliverUserApc(VOID);

BOOL ClientImmLoadLayout(HKL, PIMEINFOEX);
DWORD ClientImmProcessKey(HWND, HKL, UINT, LPARAM, DWORD);

NTSTATUS xxxUserModeCallback (ULONG uApi, PVOID pIn, ULONG cbIn, PVOID pOut, ULONG cbOut);
int xxxClientLoadStringW(UINT StrID, LPWSTR szText, int cch);

PCURSOR ClassSetSmallIcon(
    PCLS pcls,
    PCURSOR pcursor,
    BOOL fServerCreated);

BOOL _GetTextMetricsW(
    HDC hdc,
    LPTEXTMETRICW ptm);

int xxxDrawMenuBarTemp(
    PWND pwnd,
    HDC hdc,
    LPRECT lprc,
    PMENU pMenu,
    HFONT hFont);

BOOL xxxDrawCaptionTemp(
    PWND pwnd,
    HDC hdc,
    LPRECT lprc,
    HFONT hFont,
    PCURSOR pcursor,
    PUNICODE_STRING pstrText OPTIONAL,
    UINT flags);

WORD xxxTrackCaptionButton(
    PWND pwnd,
    UINT hit);

VOID GiveForegroundActivateRight(HANDLE hPid);
BOOL HasForegroundActivateRight(HANDLE hPid);
BOOL FRemoveForegroundActivate(PTHREADINFO pti);
VOID RestoreForegroundActivate(VOID);
VOID CancelForegroundActivate(VOID);

#define ACTIVATE_ARRAY_SIZE 5
extern HANDLE ghCanActivateForegroundPIDs[ACTIVATE_ARRAY_SIZE];

__inline VOID GiveForegroundActivateRight(
    HANDLE hPid)
{
    static int index = 0;

    TAGMSG1(DBGTAG_FOREGROUND, "Giving 0x%x foreground activate right", hPid);
    ghCanActivateForegroundPIDs[index++] = hPid;
    if (index == ACTIVATE_ARRAY_SIZE) {
        index = 0;
    }
}

__inline BOOL HasForegroundActivateRight(
    HANDLE hPid)
{
    int i = 0;

    for(; i < ACTIVATE_ARRAY_SIZE; ++i) {
            if (ghCanActivateForegroundPIDs[i] == hPid) {
                TAGMSG1(DBGTAG_FOREGROUND, "HasForegroundActivateRight: Found 0x%x", hPid);
                return TRUE;
            }
     }

     TAGMSG1(DBGTAG_FOREGROUND, "HasForegroundActivateRight: Did NOT find 0x%x", hPid);
     return FALSE;
}


#define WHERE_NOONE_CAN_SEE_ME ((int) -32000)
BOOL MinToTray(PWND pwnd);

void xxxUpdateThreadsWindows(
    PTHREADINFO pti,
    PWND pwnd,
    HRGN hrgnFullDrag);

NTSTATUS xxxQueryInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    OUT PVOID ThreadInformation,
    IN ULONG ThreadInformationLength,
    OUT PULONG ReturnLength OPTIONAL);

NTSTATUS xxxSetInformationThread(
    IN HANDLE hThread,
    IN USERTHREADINFOCLASS ThreadInfoClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength);

NTSTATUS GetProcessDefaultWindowOrientation(
    IN HANDLE hProcess,
    OUT DWORD *pdwDefaultOrientation);

NTSTATUS SetProcessDefaultWindowOrientation(
    IN HANDLE hProcess,
    IN DWORD dwDefaultOrientation);

NTSTATUS SetInformationProcess(
    IN HANDLE hProcess,
    IN USERPROCESSINFOCLASS ProcessInfoClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength);


NTSTATUS xxxConsoleControl(
    IN CONSOLECONTROL ConsoleControl,
    IN PVOID ConsoleInformation,
    IN ULONG ConsoleInformationLength);


/***************************************************************************\
* String Table Defines
*
* KERNEL\STRID.MC has a nice big table of strings that are meant to be
* localized. Before use, the strings are pulled from the resource table
* with LoadString, passing it one of the following string ids.
*
* NOTE: Only strings that need to be localized should be added to the
*       string table. Class name strings, etc are NOT localized.
*
* LATER: All string table entries should be reexamined to be sure they
*        conform to the note above.
*
\***************************************************************************/

#define OCR_APPSTARTING         32650

/*
 * Win Event Hook struct
 */
typedef struct tagEVENTHOOK {
    THROBJHEAD          head;                //
    struct tagEVENTHOOK *pehNext;            // Next event hook
    UINT                eventMin;            // Min event (>=) to hook
    UINT                eventMax;            // Max event (<=) to hook
    UINT                fDestroyed:1;        // If orphaned while in use
// IanJa - we don't need this bit
//  UINT                f32Bit:1;            // If 32-bit client
    UINT                fIgnoreOwnThread:1;  // Ignore events for installer thread
    UINT                fIgnoreOwnProcess:1; // Ignore events for installer process
    UINT                fSync:1;             // Sync event (inject DLL into each process)
    HANDLE              hEventProcess;       // Process being hooked
    DWORD               idEventThread;       // Thread being hooked
// (IanJa - have head.pti: don't need ppiInstaller, can use GETPTI(peh)->ppi)
//  DWORD               idInstallerProcess;  // ID of process that installed hook
    ULONG_PTR            offPfn;             // offset event proc
    int                 ihmod;               // index of module containing event proc
    LPWSTR              pwszModulePath;      // Path of module library for global sync.
} EVENTHOOK, *PEVENTHOOK;

typedef struct tagNOTIFY {
    struct tagNOTIFY *pNotifyNext;         // Next notification
    PEVENTHOOK        spEventHook;         // Event this refers to
    DWORD             event;               // Event
    HWND              hwnd;                // hwnd to ask about it
    LONG              idObject;            // object ID
    LONG              idChild;             // child id
    DWORD             idSenderThread;      // Thread generating event
    DWORD             dwEventTime;         // Event time
    DWORD             dwWEFlags;           // WEF_DEFERNOTIFY etc.
    PTHREADINFO       ptiReceiver;         // Thread receiving event
} NOTIFY, *PNOTIFY;

VOID xxxWindowEvent(DWORD event, PWND pwnd, LONG idObject, LONG idChild, DWORD dwFlags);
#define WEF_USEPWNDTHREAD 0x0001
#define WEF_DEFERNOTIFY   0x0002
#define WEF_ASYNC         0x0004
#define WEF_POSTED        0x0008

#define DeferWinEventNotify()      CheckCritIn();          \
                                   gdwDeferWinEvent++
#define IsWinEventNotifyDeferred() (gdwDeferWinEvent > 0)
#define IsWinEventNotifyDeferredOK() (!IsWinEventNotifyDeferred() || ISATOMICCHECK())
#define zzzEndDeferWinEventNotify()                        \
        UserAssert(IsWinEventNotifyDeferred());            \
        CheckCritIn();                                     \
        if (--gdwDeferWinEvent == 0) {                     \
            if (gpPendingNotifies != NULL) { \
                xxxFlushDeferredWindowEvents();            \
            }                                              \
        }

/*
 * Only use this one for bookkeeping gdwDeferWinEvent,
 * which may be required without leaving the critical section.
 */
#define EndDeferWinEventNotifyWithoutProcessing()          \
        UserAssert(IsWinEventNotifyDeferred());            \
        CheckCritIn();                                     \
        --gdwDeferWinEvent

#define zzzWindowEvent(event, pwnd, idObject, idChild, dwFlags) \
        xxxWindowEvent(event, pwnd, idObject, idChild,          \
            IsWinEventNotifyDeferred() ? (dwFlags) | WEF_DEFERNOTIFY : (dwFlags))

VOID xxxFlushDeferredWindowEvents();

BOOL xxxClientCallWinEventProc(WINEVENTPROC pfn, PEVENTHOOK pEventHook, PNOTIFY pNotify);
void DestroyEventHook(PEVENTHOOK);
VOID FreeThreadsWinEvents(PTHREADINFO pti);

BOOL       _UnhookWinEvent(PEVENTHOOK peh);
VOID       DestroyNotify(PNOTIFY pNotify);
PEVENTHOOK xxxProcessNotifyWinEvent(PNOTIFY pNotify);
PEVENTHOOK _SetWinEventHook(DWORD eventMin, DWORD eventMax,
        HMODULE hmodWinEventProc, PUNICODE_STRING pstrLib,
        WINEVENTPROC pfnWinEventProc, HANDLE hEventProcess,
        DWORD idEventThread, DWORD dwFlags);
BOOL _GetGUIThreadInfo(PTHREADINFO pti, PGUITHREADINFO pgui);
BOOL xxxGetTitleBarInfo(PWND pwnd, PTITLEBARINFO ptbi);
BOOL xxxGetComboBoxInfo(PWND pwnd, PCOMBOBOXINFO ptbi);
DWORD xxxGetListBoxInfo(PWND pwnd);
BOOL xxxGetScrollBarInfo(PWND pwnd, LONG idObject, PSCROLLBARINFO ptbi);
PWND _GetAncestor(PWND pwnd, UINT gaFlags);
PWND _RealChildWindowFromPoint(PWND pwndParent, POINT pt);
BOOL _GetAltTabInfo(int iItem, PALTTABINFO pati,
        LPWSTR lpszItemText, UINT cchItemText, BOOL bAnsi);
BOOL xxxGetMenuBarInfo(PWND pwnd, long idObject, long idItem, PMENUBARINFO pmbi);

typedef HWND *PHWND;

typedef struct tagSwitchWndInfo {

    PBWL    pbwl;               // Pointer to the window list built.
    PHWND   phwndLast;          // Pointer to the last window in the list.
    PHWND   phwndCurrent;       // pointer to the current window.

    INT     iTotalTasks;        // Total number of tasks.
    INT     iTasksShown;        // Total tasks shown.
    BOOL    fScroll;            // Is there a need to scroll?

    INT     iFirstTaskIndex;    // Index to the first task shown.

    INT     iNoOfColumns;       // Max Number of tasks per row.
    INT     iNoOfRows;          // Max Number of rows of icons in the switch window.
    INT     iIconsInLastRow;    // Icons in last row.
    INT     iCurCol;            // Current column where hilite lies.
    INT     iCurRow;            // Current row where hilite lies.
    INT     cxSwitch;           // Switch Window dimensions.
    INT     cySwitch;
    POINT   ptFirstRowStart;    // Top left corner of the first Icon Slot.
    RECT    rcTaskName;         // Rect where Task name is displayed.
    BOOL    fJournaling;        // Determins how we check the keyboard state
} SWITCHWNDINFO, *PSWINFO;

typedef struct tagSWITCHWND {
    WND;
    PSWINFO pswi;
} SWITCHWND, *PSWITCHWND;

typedef struct tagHOTKEYSTRUCT {
    PWND  spwnd;
    DWORD key;
} HOTKEYSTRUCT, *PHOTKEYSTRUCT;

#define LANGTOGGLEKEYS_SIZE 3

/*
 * ACCF_ and PUDF_ flags share the same field. ACCF fields
 * are so named because they may later move to a differnt
 * struct.
 */
#define ACCF_DEFAULTFILTERKEYSON        0x00000001
#define ACCF_DEFAULTSTICKYKEYSON        0x00000002
#define ACCF_DEFAULTMOUSEKEYSON         0x00000004
#define ACCF_DEFAULTTOGGLEKEYSON        0x00000008
#define ACCF_DEFAULTTIMEOUTON           0x00000010
#define ACCF_DEFAULTKEYBOARDPREF        0x00000020
#define ACCF_DEFAULTSCREENREADER        0x00000040
#define ACCF_DEFAULTHIGHCONTRASTON      0x00000080
#define ACCF_ACCESSENABLED              0x00000100
#define ACCF_IGNOREBREAKCODE            0x00000400
#define ACCF_FKMAKECODEPROCESSED        0x00000800
#define ACCF_MKVIRTUALMOUSE             0x00001000
#define ACCF_MKREPEATVK                 0x00002000
#define ACCF_FIRSTTICK                  0x00004000
#define ACCF_SHOWSOUNDSON               0x00008000

/*
 * NOTE: PUDF_ANIMATE must have the same value as MINMAX_ANIMATE.
 */
#define PUDF_ANIMATE                    0x00010000

#define ACCF_KEYBOARDPREF               0x00020000
#define ACCF_SCREENREADER               0x00040000
#define PUDF_BEEP                       0x00080000  /* Warning beeps allowed?                   */
#define PUDF_DRAGFULLWINDOWS            0x00100000  /* Drag xor rect or full windows            */
#define PUDF_ICONTITLEWRAP              0x00200000  /* Wrap icon titles or just use single line */
#define PUDF_FONTSARELOADED             0x00400000
#define PUDF_POPUPINUSE                 0x00800000
#define PUDF_EXTENDEDSOUNDS             0x01000000
#define PUDF_MENUSTATEINUSE             0x02000000
#define PUDF_VDMBOUNDSACTIVE            0x04000000
#define PUDF_ALLOWFOREGROUNDACTIVATE    0x08000000
#define PUDF_DRAGGINGFULLWINDOW         0x10000000
#define PUDF_LOCKFULLSCREEN             0x20000000
#define PUDF_GSMWPINUSE                 0x40000000

#define TEST_ACCF(f)               TEST_FLAG(gdwPUDFlags, f)
#define TEST_BOOL_ACCF(f)          TEST_BOOL_FLAG(gdwPUDFlags, f)
#define SET_ACCF(f)                SET_FLAG(gdwPUDFlags, f)
#define CLEAR_ACCF(f)              CLEAR_FLAG(gdwPUDFlags, f)
#define SET_OR_CLEAR_ACCF(f, fSet) SET_OR_CLEAR_FLAG(gdwPUDFlags, f, fSet)
#define TOGGLE_ACCF(f)             TOGGLE_FLAG(gdwPUDFlags, f)

#define TEST_PUDF(f)               TEST_FLAG(gdwPUDFlags, f)
#define TEST_BOOL_PUDF(f)          TEST_BOOL_FLAG(gdwPUDFlags, f)
#define SET_PUDF(f)                SET_FLAG(gdwPUDFlags, f)
#define CLEAR_PUDF(f)              CLEAR_FLAG(gdwPUDFlags, f)
#define SET_OR_CLEAR_PUDF(f, fSet) SET_OR_CLEAR_FLAG(gdwPUDFlags, f, fSet)
#define TOGGLE_PUDF(f)             TOGGLE_FLAG(gdwPUDFlags, f)

/*
 * Power state stuff
 */

typedef struct tagPOWERSTATE {
    volatile ULONG           fInProgress:1;
    volatile ULONG           fCritical:1;
    volatile ULONG           fOverrideApps:1;
    volatile ULONG           fQueryAllowed:1;
    volatile ULONG           fUIAllowed:1;
    PKEVENT                  pEvent;
    BROADCASTSYSTEMMSGPARAMS bsmParams;
    POWERSTATEPARAMS         psParams;
    ULONG PowerStateTask;
} POWERSTATE, *PPOWERSTATE;

typedef struct _POWER_INIT {
    PVIDEO_WIN32K_CALLBACKS_PARAMS Params;
    PKEVENT   pPowerReadyEvent;
} POWER_INIT, *PPOWER_INIT;

#define POWERON_PHASE  -1
#define LOWPOWER_PHASE  1
#define POWEROFF_PHASE  2

NTSTATUS InitializePowerRequestList(HANDLE hPowerRequestEvent);
VOID     CleanupPowerRequestList(VOID);
VOID     DeletePowerRequestList(VOID);
VOID     xxxUserPowerCalloutWorker(VOID);
VOID     VideoPortCalloutThread(PPOWER_INIT pInitData);

/*
 * Fade-in / fade-out globals.
 */

typedef struct tagFADE {
    HANDLE hsprite;
    HDC hdc;
    HBITMAP hbm;
    POINT ptDst;
    SIZE size;
    DWORD dwTime;
    DWORD dwStart;
    DWORD dwFlags;
#ifdef MOUSE_IP
    COLORREF crColorKey;
#endif
} FADE, *PFADE;

/*
 * Globals are included last because they may require some of the types
 * being defined above.
 */
#include "globals.h"
#include "ddemlsvr.h"
/*
 * If you make a change that requires including strid.h when building
 *  ntuser\rtl, then you need to change the sources/makefil* files so this
 *  file will be built in ntuser\inc; make sure that the output of
 *  mc.exe still goes to the kernel directory; this is because there are
 *  other places (like ntuser\server) where we use the same file name.
 */
#ifndef _USERRTL_
#include "strid.h"
#endif

#include "ntuser.h"

#define TestALPHA(uSetting) (!gbDisableAlpha && TestEffectUP(uSetting))

/*
 * tooltips/tracking prototypes from tooltips.c
 */

typedef struct tagTOOLTIP {
    DWORD dwFlags;
    UINT uTID;
    DWORD dwAnimStart;
    int iyAnim;
    LPWSTR pstr;
} TOOLTIP;

typedef struct tagTOOLTIPWND {
    WND;

    DWORD dwShowDelay;
    DWORD dwHideDelay;
    HDC hdcMem;
    HBITMAP hbmMem;

    TOOLTIP;  // this field must be last!
} TOOLTIPWND, *PTOOLTIPWND;

#define HTEXSCROLLFIRST     60
#define HTSCROLLUP          60
#define HTSCROLLDOWN        61
#define HTSCROLLUPPAGE      62
#define HTSCROLLDOWNPAGE    63
#define HTSCROLLTHUMB       64
#define HTEXSCROLLLAST      64
#define HTEXMENUFIRST       65
#define HTMDISYSMENU        65
#define HTMDIMAXBUTTON      66
#define HTMDIMINBUTTON      67
#define HTMDICLOSE          68
#define HTMENUITEM          69
#define HTEXMENULAST        69

int FindNCHitEx(PWND pwnd, int ht, POINT pt);
void xxxTrackMouseMove(PWND pwnd, int htEx, UINT message);
BOOL xxxHotTrack(PWND pwnd, int htEx, BOOL fDraw);
void xxxResetTooltip(PTOOLTIPWND pttwnd);
void xxxCancelMouseMoveTracking (DWORD dwDTFlags, PWND pwndTrack, int htEx, DWORD dwDTCancel);

__inline PVOID DesktopRebaseToClient(
    PTHREADINFO pti,
    PVOID p)
{
    UserAssert(pti->pClientInfo->ulClientDelta != 0);
    return (p) ? (PVOID)((PBYTE)p - pti->pClientInfo->ulClientDelta) : NULL;
}

__inline PVOID SharedRebaseToClient(
    PPROCESSINFO ppi,
    PVOID p)
{
    UserAssert(ppi->pClientBase != 0);
    return (p) ? (PVOID)((PBYTE)ppi->pClientBase + ((PBYTE)p -
            (PBYTE)gpvSharedBase)) : NULL;
}

/*
 * String range IDs.
 *
 * These are defined here to avoid duplicate entries in strid.mc
 */
#define STR_COLORSTART                   STR_SCROLLBAR
#define STR_COLOREND                     STR_MENUBAR

/*
 * Sprite and Fade related functions and defines.
 */
#define FADE_SHOW           0x00000001
#define FADE_COMPLETED      0x00000002
#define FADE_SHOWN          0x00000004
#define FADE_WINDOW         0x00000008
#define FADE_MENU           0x00000010
#define FADE_TOOLTIP        0x00000020
#ifdef MOUSE_IP
#define FADE_COLORKEY       0x00000040
#define FADE_SONAR          0x00000080
#endif

HDC CreateFade(PWND pwnd, RECT *prc, DWORD dwTime, DWORD dwFlags);
VOID StartFade(void);
VOID StopFade(void);
VOID ShowFade(void);
VOID AnimateFade(void);
__inline DWORD TestFadeFlags(
    DWORD dwFlags)
{
    return (gfade.dwFlags & dwFlags);
}

#ifdef MOUSE_IP

#define IS_SONAR_ACTIVE()       (TestUP(MOUSESONAR) && TestFadeFlags(FADE_SONAR))
#define CLEAR_SONAR_LASTVK()        (void)((TestUP(MOUSESONAR) && gbLastVkForSonar) ? (gbLastVkForSonar = 0) : 0)

BOOL StartSonar();
void StopSonar();

#endif

HANDLE xxxSetLayeredWindow(PWND pwnd, BOOL fRepaintBehind);
VOID UnsetLayeredWindow(PWND pwnd);
void TrackLayeredZorder(PWND pwnd);
VOID UpdateRedirectedDC(PDCE pdce);
BOOL _UpdateLayeredWindow(PWND pwnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc,
        POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags);
BOOL _GetLayeredWindowAttributes(PWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags);
BOOL _SetLayeredWindowAttributes(PWND pwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
BOOL RecreateRedirectionBitmap(PWND pwnd);
VOID ResetRedirectedWindows(VOID);

PWND GetStyleWindow(PWND pwnd, DWORD dwStyle);
PWND GetLastChild(PWND pwnd);

BOOL SetRedirectedWindow(PWND pwnd, UINT uFlags);
VOID UnsetRedirectedWindow(PWND pwnd, UINT uFlags);

VOID xxxCompositedPaint(PWND pwnd);

#define REDIRECT_LAYER                     0x0001
#define REDIRECT_COMPOSITED                0x0002
#define REDIRECT_EXTREDIRECTED             0x0004
#define REDIRECT_PRINT                     0x0008

typedef struct tagREDIRECT {
    HBITMAP hbm;
    RECT rcUpdate;
    UINT uFlags;
    HRGN hrgnComp;

#if DBG
    PWND pwnd;
#endif // DBG

} REDIRECT, *PREDIRECT;

HBITMAP GetRedirectionBitmap(PWND pwnd);
BOOL SetRedirectionBitmap(PWND pwnd, HBITMAP hbm);
UINT GetRedirectionFlags(PWND pwnd);
BOOL xxxPrintWindow(PWND pwnd, HDC hdcBlt, UINT nFlags);
void xxxTurnOffCompositing(PWND pwndStart, BOOL fChild);


#ifdef REDIRECTION
BOOL xxxSetProcessRedirectionMode(BOOL fEnable, PPROCESSINFO ppi);
BOOL xxxSetDesktopRedirectionMode(BOOL fEnable, PDESKTOP pDesk, PPROCESSINFO ppi);
#endif // REDIRECTION

void InternalInvalidate3(
    PWND pwnd,
    HRGN hrgn,
    DWORD flags);

BOOL UserSetFont(PUNICODE_STRING pProfileUserName,
    LPLOGFONTW   lplf,
    UINT         idFont,
    HFONT*       phfont
    );

HICON DWP_GetIcon(
    PWND pwnd,
    UINT uType);

BOOL xxxRedrawTitle(
    PWND pwnd, UINT wFlags);

DWORD GetContextHelpId(
    PWND pwnd);


HANDLE xxxClientCopyImage(
    HANDLE hImage,
    UINT type,
    int cxNew,
    int cyNew,
    UINT flags);

VOID _WOWCleanup(
    HANDLE hInstance,
    DWORD hTaskWow);

VOID _WOWModuleUnload(HANDLE hModule);

/*
 * FastProfile APIs
 */
typedef struct tagPROFINTINFO {
    UINT idSection;
    LPWSTR lpKeyName;
    DWORD  nDefault;
    PUINT puResult;
} PROFINTINFO, *PPROFINTINFO;

typedef struct {
    UINT idSection;
    UINT id;
    UINT idRes;
    UINT def;
} SPINFO, *PSPINFO;


#define INITIAL_USER_HANDLE_QUOTA  10000
#define MINIMUM_USER_HANDLE_QUOTA    200

#define INITIAL_POSTMESSAGE_LIMIT   10000
#define MINIMUM_POSTMESSAGE_LIMIT    4000

/*
 * See aFastRegMap[] in ntuser\kernel\profile.c
 */
#define PMAP_COLORS             0
#define PMAP_CURSORS            1
#define PMAP_WINDOWSM           2
#define PMAP_WINDOWSU           3
#define PMAP_DESKTOP            4
#define PMAP_ICONS              5
#define PMAP_FONTS              6
#define PMAP_TRUETYPE           7
#define PMAP_KBDLAYOUT          8
#define PMAP_INPUT              9
#define PMAP_COMPAT            10
#define PMAP_SUBSYSTEMS        11
#define PMAP_BEEP              12
#define PMAP_MOUSE             13
#define PMAP_KEYBOARD          14
#define PMAP_STICKYKEYS        15
#define PMAP_KEYBOARDRESPONSE  16
#define PMAP_MOUSEKEYS         17
#define PMAP_TOGGLEKEYS        18
#define PMAP_TIMEOUT           19
#define PMAP_SOUNDSENTRY       20
#define PMAP_SHOWSOUNDS        21
#define PMAP_AEDEBUG           22
#define PMAP_NETWORK           23
#define PMAP_METRICS           24
#define PMAP_UKBDLAYOUT        25
#define PMAP_UKBDLAYOUTTOGGLE  26
#define PMAP_WINLOGON          27
#define PMAP_KEYBOARDPREF      28
#define PMAP_SCREENREADER      29
#define PMAP_HIGHCONTRAST      30
#define PMAP_IMECOMPAT         31
#define PMAP_IMM               32
#define PMAP_POOLLIMITS        33
#define PMAP_COMPAT32          34
#define PMAP_SETUPPROGRAMNAMES 35
#define PMAP_INPUTMETHOD       36
#define PMAP_COMPAT2           37
#define PMAP_MOUCLASS_PARAMS   38
#define PMAP_KBDCLASS_PARAMS   39
#define PMAP_COMPUTERNAME      40
#define PMAP_TS                41
#define PMAP_TABLETPC          42
#define PMAP_MEDIACENTER       43
#define PMAP_LAST              43

#define MAXPROFILEBUF 256

#define POLICY_NONE     0x0001
#define POLICY_USER     0x0002
#define POLICY_MACHINE  0x0004
#define POLICY_REMOTE   0x0008
#define POLICY_ONLY     0x0010
/*
 * POLICY_REMOTE is not included in POLICY_REMOTE intentionally.
 * Else, we will try to read the remote policy always.
 */
#define POLICY_ALL      (POLICY_NONE | POLICY_USER | POLICY_MACHINE)
#define POLICY_VALID    (POLICY_ALL | POLICY_ONLY | POLICY_REMOTE)

PUNICODE_STRING CreateProfileUserName(TL *ptl);
void FreeProfileUserName(PUNICODE_STRING pProfileUserName,TL *ptl);
HANDLE  OpenCacheKeyEx(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, ACCESS_MASK amRequest, PDWORD pdwPolicyFlags);
BOOL    CheckDesktopPolicy(PUNICODE_STRING pProfileUserName OPTIONAL, PCWSTR lpKeyName);
BOOL    CheckDesktopPolicyChange(PUNICODE_STRING pProfileUserName OPTIONAL);
DWORD   FastGetProfileKeysW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR pszDefault, LPWSTR *ppszKeys);
BOOL    FastGetProfileDwordW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName, DWORD dwDefault, PDWORD pdwReturn, DWORD dwPolicyOnly);
DWORD   FastGetProfileStringW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, DWORD dwPolicyOnly);
BOOL    FastGetProfileIntW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName, UINT nDefault, PUINT puiReturn, DWORD dwPolicyOnly);
BOOL    FastWriteProfileStringW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName, LPCWSTR lpString);
BOOL    FastGetProfileIntFromID(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, UINT idKey, int def, PINT pResult, DWORD dwPolicyOnly);
DWORD   FastGetProfileStringFromIDW(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, UINT idKey, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD cch, DWORD dwPolicyOnly);
BOOL    FastWriteProfileValue(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName, UINT uType, LPBYTE lpStruct, UINT cbSizeStruct);
DWORD   FastGetProfileValue(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, LPCWSTR lpKeyName,LPBYTE lpDefault, LPBYTE lpReturn, UINT cbSizeReturn, DWORD dwPolicyOnly);
BOOL    FastGetProfileIntsW(PUNICODE_STRING pProfileUserName OPTIONAL, PPROFINTINFO ppii, DWORD dwPolicyOnly);
BOOL    FastUpdateWinIni(PUNICODE_STRING pProfileUserName OPTIONAL, UINT idSection, UINT wKeyNameId, LPWSTR lpszValue);

VOID RecreateSmallIcons(PWND pwnd);

/*
 * # of pels added to border width. When a user requests a border width of 1
 * that user actualy gets a border width of BORDER_EXTRA + 1 if the window
 * has a sizing border.
 */
#define BORDER_EXTRA    3

/*
 * tmswitch.c stuff
 */

__inline int GetCaptionHeight(
    PWND pwnd)
{
    if (!TestWF(pwnd, WFCPRESENT)) {
        return 0;
    } else {
        return TestWF(pwnd, WEFTOOLWINDOW) ?
                   SYSMET(CYSMCAPTION) : SYSMET(CYCAPTION);
    }
}

__inline VOID InitTooltipDelay(
    PTOOLTIPWND pttwnd)
{
    if (pttwnd != NULL) {
        pttwnd->dwShowDelay = gdtDblClk * 3;
        pttwnd->dwHideDelay = gdtDblClk * 8;
    }
}

__inline PPROFILEVALUEINFO UPDWORDPointer(
    UINT uSetting)
{
    UserAssert(UPIsDWORDRange(uSetting));
    return gpviCPUserPreferences + UPDWORDIndex(uSetting);
}


/*
 * ComputeTickDelta
 *
 * ComputeTickDelta computes a time delta between two times. The
 * delta is defined as a 31-bit, signed value. It is best to think of time as
 * a clock that wraps around. The delta is the minimum distance on this circle
 * between two different places on the circle. If the delta goes
 * counter-clockwise, it is looking at a time in the PAST and is POSITIVE. If
 * the delta goes clockwise, it is looking at a time in the FUTURE and is
 * negative.
 *
 * It is IMPORTANT to realize that the (dwCurTime >= dwLastTime) comparison does
 * not determine the delta's sign, but only determines the operation to compute
 * the delta without an overflow occuring.
 */
__inline
int ComputeTickDelta(
        IN DWORD dwCurTick,
        IN DWORD dwLastTick)
{
    return (int) dwCurTick - dwLastTick;
}


__inline
DWORD ComputePastTickDelta(
        IN DWORD dwCurTick,
        IN DWORD dwLastTick)
{
    /*
     * This handles a wrap-around.
     */
    return dwCurTick - dwLastTick;
}

__inline BOOL IsTimeFromLastInput(
    DWORD dwTimeout)
{
    return ((NtGetTickCount() - glinp.timeLastInputMessage) > dwTimeout);
}

__inline BOOL IsTimeFromLastRITEvent(
    DWORD dwTimeout)
{
    return ((NtGetTickCount() - gpsi->dwLastRITEventTickCount) > dwTimeout);
}

#if DBG
__inline void DBGIncModalMenuCount(
    VOID)
{
    guModalMenuStateCount++;
}

__inline VOID DBGDecModalMenuCount(
    VOID)
{
    UserAssert(guModalMenuStateCount != 0);
    guModalMenuStateCount--;
}
#else
#define DBGIncModalMenuCount()
#define DBGDecModalMenuCount()
#endif

__inline BOOL IsForegroundLocked(
    VOID)
{
    return (guSFWLockCount != 0 || gppiLockSFW != NULL);
}


/* Bug 247768 - joejo
 * Add compatibility hack for foreground activation problems.
 *
 */
__inline
BOOL GiveUpForeground(
    VOID)
{
    if (gptiForeground == NULL) {
        return FALSE;
    }

    if (GetAppCompatFlags2ForPti(gptiForeground, VER40) & GACF2_GIVEUPFOREGROUND){
        TAGMSG0(DBGTAG_FOREGROUND, "GiveUpForeground Hack Succeeded!");
        return TRUE;
    }

    return FALSE;
}

__inline VOID IncSFWLockCount(
    VOID)
{
    guSFWLockCount++;
}

__inline VOID DecSFWLockCount(
    VOID)
{
    UserAssert(guSFWLockCount != 0);
    guSFWLockCount--;
}

__inline DWORD UPDWORDValue(
    UINT uSetting)
{
    return UPDWORDPointer(uSetting)->dwValue;
}
/*
 * Use this macro ONLY if UPIsDWORDRange(SPI_GET ## uSetting) is TRUE.
 */
#define UP(uSetting) UPDWORDValue(SPI_GET ## uSetting)

/*
 * NTIMM.C
 */

#define IMESHOWSTATUS_NOTINITIALIZED    ((BOOL)0xffff)

PIMC CreateInputContext(
    IN ULONG_PTR dwClientImcData);

BOOL DestroyInputContext(
    IN PIMC pImc);

VOID FreeInputContext(
    IN PIMC pImc);

HIMC AssociateInputContext(
    IN PWND pWnd,
    IN PIMC pImc);

AIC_STATUS AssociateInputContextEx(
    IN PWND  pWnd,
    IN PIMC  pImc,
    IN DWORD dwFlag);

BOOL UpdateInputContext(
    IN PIMC pImc,
    IN UPDATEINPUTCONTEXTCLASS UpdateType,
    IN ULONG_PTR UpdateValue);

VOID xxxFocusSetInputContext(
    IN PWND pwnd,
    IN BOOL fActivate,
    IN BOOL fQueueMsg);

UINT BuildHimcList(
    PTHREADINFO pti,
    UINT cHimcMax,
    HIMC *phimcFirst);

PWND xxxCreateDefaultImeWindow(
    IN PWND pwnd,
    IN ATOM atomT,
    IN HANDLE hInst);

BOOL xxxImmActivateThreadsLayout(
    PTHREADINFO pti,
    PTLBLOCK    ptlBlockPrev,
    PKL         pkl);

VOID xxxImmActivateAndUnloadThreadsLayout(
    IN PTHREADINFO *ptiList,
    IN UINT         nEntries,
    IN PTLBLOCK     ptlBlockPrev,
    PKL             pklCurrent,
    DWORD           dwHklReplace);

VOID xxxImmActivateLayout(
    IN PTHREADINFO pti,
    IN PKL pkl);

VOID xxxImmUnloadThreadsLayout(
    IN PTHREADINFO *ptiList,
    IN UINT         nEntry,
    IN PTLBLOCK     ptlBlockPrev,
    IN DWORD        dwFlag);

VOID xxxImmUnloadLayout(
    IN PTHREADINFO pti,
    IN DWORD       dwFlag);

PIMEINFOEX xxxImmLoadLayout(
    IN HKL hKL);

VOID xxxImmActivateLayout(
    IN PTHREADINFO pti,
    IN PKL pkl);

BOOL GetImeInfoEx(
    IN PWINDOWSTATION pwinsta,
    IN PIMEINFOEX piiex,
    IN IMEINFOEXCLASS SearchType);

BOOL SetImeInfoEx(
    IN PWINDOWSTATION pwinsta,
    IN PIMEINFOEX piiex);

DWORD xxxImmProcessKey(
    IN PQ   pq,
    IN PWND pwnd,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam);

BOOL GetImeHotKey(
    DWORD dwHotKeyID,
    PUINT puModifiers,
    PUINT puVKey,
    HKL   *phKL );

BOOL  SetImeHotKey(
    DWORD  dwHotKeyID,
    UINT   uModifiers,
    UINT   uVKey,
    HKL    hKL,
    DWORD  dwAction );

PIMEHOTKEYOBJ CheckImeHotKey(
    PQ   pq,
    UINT uVKey,
    LPARAM lParam);

BOOL ImeCanDestroyDefIME(
    IN PWND pwndDefaultIme,
    IN PWND pwndDestroy);

BOOL IsChildSameThread(
    IN PWND pwndParent,
    IN PWND pwndChild);

BOOL ImeCanDestroyDefIMEforChild(
    IN PWND pwndDefaultIme,
    IN PWND pwndDestroy);

VOID ImeCheckTopmost(
    IN PWND pwnd);

VOID ImeSetFutureOwner(
    IN PWND pwndDefaultIme,
    IN PWND pwndOrgOwner);

VOID ImeSetTopmostChild(
    IN PWND pwndRoot,
    IN BOOL fFlag);

VOID ImeSetTopmost(
    IN PWND pwndRoot,
    IN BOOL fFlag,
    IN PWND pwndInsertBefore);

PSOFTKBDDATA ProbeAndCaptureSoftKbdData(
    PSOFTKBDDATA Source);

VOID xxxNotifyIMEStatus(
    IN PWND pwnd,
    IN DWORD dwOpen,
    IN DWORD dwConversion );

BOOL xxxSetIMEShowStatus(
    IN BOOL fShow);

VOID xxxBroadcastImeShowStatusChange(
    IN PWND pwndDefIme,
    IN BOOL fShow);

VOID xxxCheckImeShowStatusInThread(
    IN PWND pwndDefIme);


#define IsWndImeRelated(pwnd)   \
    (pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME] || \
     TestCF(pwnd, CFIME))

/*
 * Critical section routines for processing mouse input
 */
__inline VOID EnterMouseCrit(
    VOID)
{

    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(gpresMouseEventQueue, TRUE);
}

__inline VOID LeaveMouseCrit(
    VOID)
{

    ExReleaseResourceLite(gpresMouseEventQueue);
    KeLeaveCriticalRegion();
}

#if DBG
#define EnterDeviceInfoListCrit _EnterDeviceInfoListCrit
#define LeaveDeviceInfoListCrit _LeaveDeviceInfoListCrit
VOID _EnterDeviceInfoListCrit();
VOID _LeaveDeviceInfoListCrit();
#else
/*
 * Critical section routines for accessing the Device List (gpDeviceInfoList)
 */
__inline VOID EnterDeviceInfoListCrit(
    VOID)
{
    KeEnterCriticalRegion();
    ExAcquireResourceExclusiveLite(gpresDeviceInfoList, TRUE);
}
__inline VOID LeaveDeviceInfoListCrit(
    VOID)
{
    ExReleaseResourceLite(gpresDeviceInfoList);
    KeLeaveCriticalRegion();
}
#endif // DBG

#define BEGIN_REENTER_DEVICEINFOLISTCRIT()                              \
{                                                                       \
    BOOL fAlreadyHadDeviceInfoCrit;                                     \
                                                                        \
    /*                                                                  \
     * If we're not in the user crit then acquire it.                   \
     */                                                                 \
    fAlreadyHadDeviceInfoCrit = ExIsResourceAcquiredExclusiveLite(gpresDeviceInfoList); \
    if (fAlreadyHadDeviceInfoCrit == FALSE) {                           \
        EnterDeviceInfoListCrit();                                      \
    }

#define END_REENTER_DEVICEINFOLISTCRIT()                                \
    if (fAlreadyHadDeviceInfoCrit == FALSE) {                           \
       LeaveDeviceInfoListCrit();                                       \
    }                                                                   \
}


/*
 * Request RIT to update the keyboard h/w settings
 */
__inline VOID RequestKeyboardRateUpdate(
    VOID)
{
    gdwUpdateKeyboard |= UPDATE_KBD_TYPEMATIC;
}



/*
 * Keep some capture state visible from user-mode for performance.
 */
__inline VOID LockCaptureWindow(
    PQ pq,
    PWND pwnd)
{
    if (pq->spwndCapture) {
        UserAssert(gpsi->cCaptures > 0);
        gpsi->cCaptures--;
    }

    if (pwnd) {
        gpsi->cCaptures++;
    }

    Lock(&pq->spwndCapture, pwnd);
}

__inline VOID UnlockCaptureWindow(
    PQ pq)
{
    if (pq->spwndCapture) {
        UserAssert(gpsi->cCaptures > 0);
        gpsi->cCaptures--;
        Unlock(&pq->spwndCapture);
    }
}

/*
 * Some routines for manipulating desktop and windowstation handles.
 */
#define HF_DESKTOPHOOK  0       // offset to desktop hook flag
#define HF_PROTECTED    1       // offset to protected flag
#define HF_LIMIT        2       // number of flags per handle

BOOL SetHandleFlag(HANDLE hObject, DWORD dwFlag, BOOL fSet);
BOOL CheckHandleFlag(PEPROCESS Process, DWORD dwSessionId, HANDLE hObject, DWORD dwFlag);
VOID SetHandleInUse(HANDLE hObject);
BOOL CheckHandleInUse(HANDLE hObject);

__inline NTSTATUS CloseProtectedHandle(
    HANDLE handle)
{
    if (handle != NULL) {
        SetHandleFlag(handle, HF_PROTECTED, FALSE);
        return ZwClose(handle);
    }

    return STATUS_SUCCESS;
}

__inline VOID EnterHandleFlagsCrit(
    VOID)
{
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpHandleFlagsMutex);
}

__inline VOID LeaveHandleFlagsCrit(
    VOID)
{
    ExReleaseFastMutexUnsafe(gpHandleFlagsMutex);
    KeLeaveCriticalRegion();
}

// multimon apis

BOOL    xxxEnumDisplayMonitors(
                HDC             hdc,
                LPRECT          lprcClip,
                MONITORENUMPROC lpfnEnum,
                LPARAM          dwData,
                BOOL            fInternal);

BOOL    xxxClientMonitorEnumProc(
                HMONITOR        hMonitor,
                HDC             hdcMonitor,
                LPRECT          lprc,
                LPARAM          dwData,
                MONITORENUMPROC xpfnProc);

VOID    ClipPointToDesktop(LPPOINT lppt);
VOID    DestroyMonitor(PMONITOR pMonitor);
BOOL    GetHDevName(HMONITOR hMon, PWCHAR pName);
ULONG   HdevFromMonitor(PMONITOR pMonitor);

/*
 * Rebasing functions for shared memory.
 */
#define REBASESHAREDPTR(p)       (p)
#define REBASESHAREDPTRALWAYS(p) (p)

#define PDEV_ENABLED() \
    InterlockedExchange((LPLONG)&gbMDEVDisabled, FALSE);

#define PDEV_DISABLED() \
    InterlockedExchange((LPLONG)&gbMDEVDisabled, TRUE);

__inline BOOL SafeEnableMDEV()
{
    if(gbMDEVDisabled) {
        if (DrvEnableMDEV(gpDispInfo->pmdev, TRUE)) {
            PDEV_ENABLED();
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        RIPMSG0(RIP_WARNING, "Trying to enable an enabled MDEV");
        return TRUE;
    }
}

__inline BOOL SafeDisableMDEV()
{
    if(!gbMDEVDisabled) {
        if (DrvDisableMDEV(gpDispInfo->pmdev, TRUE)) {
            PDEV_DISABLED();
            return TRUE;
        } else {
            return FALSE;
        }
    } else {
        RIPMSG0(RIP_WARNING, "Trying to disable a disabled MDEV");
        return TRUE;
    }
}

/*
 * Multimonitor macros used in RTL. There are similar definitions
 * in client\usercli.h
 */
__inline PDISPLAYINFO
GetDispInfo(
    VOID)
{
    return gpDispInfo;
}

__inline PMONITOR
GetPrimaryMonitor(
    VOID)
{
    return REBASESHAREDPTRALWAYS(GetDispInfo()->pMonitorPrimary);
}

VOID _QueryUserHandles(
        IN  LPDWORD     lpIn,
        IN  DWORD       dwInLength,
        OUT DWORD       pdwResult[][TYPE_CTYPES]);



#define REMOVE_FROM_LIST(type, pstart, pitem, next) \
    {                                                           \
        type** pp;                                              \
                                                                \
        for (pp = &pstart; *pp != NULL; pp = &(*pp)->next) {    \
            if (*pp == pitem) {                                 \
                *pp = pitem->next;                              \
                break;                                          \
            }                                                   \
        }                                                       \
    }                                                           \


#define HH_DRIVERENTRY              0x00000001
#define HH_USERINITIALIZE           0x00000002
#define HH_INITVIDEO                0x00000004
#define HH_REMOTECONNECT            0x00000008
#define HH_REMOTEDISCONNECT         0x00000010
#define HH_REMOTERECONNECT          0x00000020
#define HH_REMOTELOGOFF             0x00000040
#define HH_DRIVERUNLOAD             0x00000080
#define HH_GRECLEANUP               0x00000100
#define HH_USERKCLEANUP             0x00000200
#define HH_INITIATEWIN32KCLEANUP    0x00000400
#define HH_ALLDTGONE                0x00000800
#define HH_RITGONE                  0x00001000
#define HH_RITCREATED               0x00002000
#define HH_LOADCURSORS              0x00004000
#define HH_KBDLYOUTGLOBALCLEANUP    0x00008000
#define HH_KBDLYOUTFREEWINSTA       0x00010000
#define HH_CLEANUPRESOURCES         0x00020000
#define HH_DISCONNECTDESKTOP        0x00040000
#define HH_DTQUITPOSTED             0x00080000
#define HH_DTQUITRECEIVED           0x00100000
#define HH_DTWAITONHANDLES          0x00400000

#define HYDRA_HINT(ev)  (gdwHydraHint |= ev)

#if DBG
    VOID TrackAddDesktop(PVOID pDesktop);
    VOID TrackRemoveDesktop(PVOID pDesktop);
    VOID DumpTrackedDesktops(BOOL bBreak);

    #define DbgTrackAddDesktop(pdesk) TrackAddDesktop(pdesk)
    #define DbgTrackRemoveDesktop(pdesk) TrackRemoveDesktop(pdesk)
    #define DbgDumpTrackedDesktops(b) DumpTrackedDesktops(b)
#else
    #define DbgTrackAddDesktop(pdesk)
    #define DbgTrackRemoveDesktop(pdesk)
    #define DbgDumpTrackedDesktops(b)
#endif

#if DBG
    #define TRACE_HYDAPI(m)                                     \
        if (gbTraceHydraApi) {                                  \
            KdPrint(("HYD-%d API: ", gSessionId));              \
            KdPrint(m);                                         \
        }
#else
    #define TRACE_HYDAPI(m)
#endif

#if DBG
    #define TRACE_DESKTOP(m)                                    \
        if (gbTraceDesktop) {                                   \
            KdPrint(("HYD-%d DT ", gSessionId));                \
            KdPrint(m);                                         \
        }
#else
    #define TRACE_DESKTOP(m)
#endif

NTSTATUS
RemoteConnect(
    IN PDOCONNECTDATA pDoConnectData,
    IN ULONG DisplayDriverNameLength,
    IN PWCHAR DisplayDriverName);

NTSTATUS
xxxRemoteDisconnect(
    VOID);

NTSTATUS
xxxRemoteConsoleShadowStop(
    VOID);


NTSTATUS
xxxRemoteReconnect(
    IN PDORECONNECTDATA pDoReconnectData);


NTSTATUS
xxxRemoteNotify(
    IN PDONOTIFYDATA pDoNotifyData);

NTSTATUS
RemoteLogoff(
    VOID);

BOOL
PrepareForLogoff(
    UINT uFlags);

NTSTATUS
xxxRemoteStopScreenUpdates(
    BOOL fDisableGraphics);

VOID xxxPushKeyEvent(
    BYTE  bVk,
    BYTE  bScan,
    DWORD dwFlags,
    DWORD dwExtraInfo);

NTSTATUS
RemoteThinwireStats(
    OUT PVOID Stats);

NTSTATUS
RemoteNtSecurity(
    VOID);

NTSTATUS
xxxRemoteShadowSetup(
    VOID);

NTSTATUS
RemoteShadowStart(
    IN PVOID pThinwireData,
    ULONG ThinwireDataLength);

NTSTATUS
xxxRemoteShadowStop(
    VOID);

NTSTATUS
RemoteShadowCleanup(
    IN PVOID pThinwireData,
    ULONG ThinwireDataLength);

NTSTATUS
xxxRemotePassthruEnable(
    VOID);

NTSTATUS
RemotePassthruDisable(
    VOID);

NTSTATUS
CtxDisplayIOCtl(
    ULONG  DisplayIOCtlFlags,
    PUCHAR pDisplayIOCtlData,
    ULONG  cbDisplayIOCtlData);

DWORD
RemoteConnectState(
    VOID);

BOOL
_GetWinStationInfo(
    WSINFO* pWsInfo);

// from fullscr.c

NTSTATUS
RemoteRedrawRectangle(
    WORD Left,
    WORD Top,
    WORD Right,
    WORD Bottom);

NTSTATUS
RemoteRedrawScreen(
    VOID);

NTSTATUS
RemoteDisableScreen(
    VOID);

// from fekbd.c
VOID
NlsKbdSendIMEProc(
    DWORD dwImeOpen,
    DWORD dwImeConversion);


/*
 * Additional menu functions (dependant on previous inline functions)
 */
__inline BOOL MNIsFlatMenu(
    VOID)
{
    return TestEffectUP(FLATMENU);
}

VOID SetMouseTrails(UINT n);
VOID HideMouseTrails(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam);


#if DBG
#define CheckPublicDC(lpszStr, hdc)                                         \
{                                                                           \
    if (GreGetObjectOwner((HOBJ)hdc, DC_TYPE) == OBJECT_OWNER_PUBLIC) {     \
        RIPMSG1(RIP_ERROR, lpszStr, hdc);                                   \
    }                                                                       \
}
#else
#define CheckPublicDC(lpszStr, hdc)
#endif
#define szMESSAGE   L"Message"

#ifdef LAME_BUTTON
// Lame button constants
#define LBUTTON_DIALOG      0x4
#define LBUTTON_TOPLEVEL    0x8

VOID SetStackTrace(HWND hwnd, PVOID pStackTrace);

__inline BOOL NeedsLameButton(
    PWND pwnd,
    PWND pwndParent)
{
    /*
     * Windows with the WS_EX_TOOLWINDOW style can't have a lame button (see
     * Windows Bug #237648), nor can consoles.
     */
    if (TestWF(pwnd, WEFTOOLWINDOW) || PsGetCurrentProcess() == gpepCSRSS) {
        return FALSE;
    } else if (pwndParent != NULL && GETFNID(pwndParent) == FNID_DESKTOP) {
        return (gdwLameFlags & LBUTTON_TOPLEVEL) != 0;
    } else if (GETFNID(pwnd) == FNID_DIALOG) {
        return (gdwLameFlags & LBUTTON_DIALOG) != 0;
    } else {
        return FALSE;
    }
}
#endif // LAME_BUTTON

#ifdef TRACK_PNP_NOTIFICATION

typedef enum tagPNP_NOTIFICATION_TYPE {
    PNP_NTF_CLASSNOTIFY,
    PNP_NTF_CREATEDEVICEINFO,
    PNP_NTF_FREEDEVICEINFO,
    PNP_NTF_PROCESSDEVICECHANGES,
    PNP_NTF_REQUESTDEVICECHANGE,
    PNP_NTF_DEVICENOTIFY,
    PNP_NTF_FREEDEVICEINFO_DEFERRED,
    PNP_NTF_CLOSEDEVICE,
    PNP_NTF_DEVICENOTIFY_UNLISTED,
    PNP_NTF_UNREGISTER_NOTIFICATION,
    PNP_NTF_UNREGISTER_REMOTE_CANCELLED,
} PNP_NOTIFICATION_TYPE;

typedef struct tagPNP_NOTIFICATION_RECORD {
    UINT iSeq;
    PNP_NOTIFICATION_TYPE type;
    PVOID pKThread;
    PDEVICEINFO pDeviceInfo;
    HANDLE hDeviceInfo;
    UCHAR szPathName[80];
    ULONG_PTR NotificationCode;
    PVOID trace[LOCKRECORD_STACK];
} PNP_NOTIFICATION_RECORD, *PPNP_NOTIFICATION_RECORD;

void CleanupPnpNotificationRecord();

void RecordPnpNotification(
    PNP_NOTIFICATION_TYPE type,
    PDEVICEINFO pDeviceInfo,
    ULONG_PTR NotificationCode);

extern BOOL gfRecordPnpNotification;

#endif // TRACK_PNP_NOTIFICATION

#ifdef SUBPIXEL_MOUSE
VOID BuildMouseAccelerationCurve(
    PMONITOR pMonitor);

VOID DoNewMouseAccel(
    INT *dx,
    INT *dw);

VOID ReadDefaultAccelerationCurves(
    PUNICODE_STRING pProfileUserName);

VOID ResetMouseAccelerationCurves(
    VOID);
#endif // SUBPIXEL_MOUSE

#ifdef AUTORUN_CURSOR
VOID ShowAutorunCursor(
    ULONG ulTimeout);

VOID HideAutorunCursor(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam);
#endif // AUTORUN_CURSOR

/*
 * These must go after globals.h is #include'd, as they're inline functions and
 * they use gptiCurrent (indirectly, by way of ThreadLock()).
 */
__inline VOID ThreadLockMenuNoModify(
    PMENU pMenu,
    PTL ptl)
{
    UserAssert(!TestMF(pMenu, MFREADONLY));
    SetMF(pMenu, MFREADONLY);
    ThreadLock(pMenu, ptl);
}

__inline VOID ThreadLockMenuAlwaysNoModify(
    PMENU pMenu,
    PTL ptl)
{
    UserAssert(!TestMF(pMenu, MFREADONLY));
    SetMF(pMenu, MFREADONLY);
    ThreadLockAlways(pMenu, ptl);
}

__inline VOID ThreadUnlockMenuNoModify (
    PTL ptl)
{
    UserAssert(TestMF((PMENU)ptl->pobj, MFREADONLY));
    ClearMF((PMENU)ptl->pobj, MFREADONLY);
    ThreadUnlock(ptl);
}

__inline int
SetBestStretchMode(
    HDC hdc,
    UINT bpp,
    BOOL fHT)
{
    return GreSetStretchBltMode(
                   hdc,
                   ((fHT) ?
                       HALFTONE : ((bpp == 1) ? BLACKONWHITE : COLORONCOLOR)));
}

#endif  // !_USERK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\winable2.c ===
/**************************** Module Header ********************************\
* Module Name: winable2.c
*
* This has the following Active Accesibility API
*     GetGUIThreadInfo
*
* The Win Event Hooks are handled in winable.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 08-30-96 IanJa  Ported from Windows '95
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*****************************************************************************\
*
*  GetGUIThreadInfo()
*
*  This gets GUI information out of context.  If you pass in a NULL thread ID,
*  we will get the 'global' information, using the foreground thread.  This
*  is guaranteed to be the real active window, focus window, etc.  Yes, you
*  could do it yourself by calling GetForegroundWindow, getting the thread ID
*  of that window via GetWindowThreadProcessId, then passing the ID into
*  GetGUIThreadInfo().  However, that takes three calls and aside from being
*  a pain, anything could happen in the middle.  So passing in NULL gets
*  you stuff in one call and hence also works right.
*
*  This function returns FALSE if the thread doesn't have a queue or the
*  thread ID is bogus.
*
\*****************************************************************************/
BOOL WINAPI
_GetGUIThreadInfo(PTHREADINFO pti, PGUITHREADINFO pgui)
{
    PQ pq;

    /*
     * Validate threadinfo structure
     */
    if (pgui->cbSize != sizeof(GUITHREADINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "GUITHREADINFO.cbSize %d is wrong", pgui->cbSize);
        return FALSE;
    }

    /*
     * Is this a valid initialized GUI thread?
     */
    if (pti != NULL) {
        if ((pq = pti->pq) == NULL) {
            // does this ever happen?
            RIPMSG1(RIP_ERROR, "GetGUIThreadInfo: No queue for pti %lx", pti);
            return FALSE;
        }
    } else {
        /*
         * Use the foreground queue. To get menu state information we must also
         * figure out the right pti.  This matches _GetForegroundWindow() logic.
         */
        if ((pq = gpqForeground) == NULL) {
            // this does sometimes happen...
            RIPMSG0(RIP_WARNING, "GetGUIThreadInfo: No foreground queue");
            return FALSE;
        }

        if (pq->spwndActive && (GETPTI(pq->spwndActive)->pq == pq)) {
            pti = GETPTI(pq->spwndActive);
            if (PtiCurrentShared()->rpdesk != pti->rpdesk) {
                RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "Foreground window on different desktop");
                return FALSE;
            }
        }
    }

    UserAssert(pq != NULL);

    /*
     * For C2 security, verify that pq and pti are on the current thread's desktop.
     * We can't directly determine which desktop pq belongs to, but we can at
     * least ensure that any caret info we return is not from another desktop
     */
    if (pq->caret.spwnd &&
            (GETPTI(pq->caret.spwnd)->rpdesk != PtiCurrentShared()->rpdesk)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "Foreground caret on different desktop");
        return FALSE;
    }
    if (pti && (pti->rpdesk != PtiCurrentShared()->rpdesk)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "Foreground thread on different desktop");
        return FALSE;
    }

    pgui->flags        = 0;
    pgui->hwndMoveSize = NULL;
    pgui->hwndMenuOwner = NULL;

    /*
     * Get Menu information from the THREADINFO
     */
    if (pti != NULL) {
        if (pti->pmsd && !pti->pmsd->fTrackCancelled && pti->pmsd->spwnd) {
            pgui->flags |= GUI_INMOVESIZE;
            pgui->hwndMoveSize = HWq(pti->pmsd->spwnd);
        }

        if (pti->pMenuState && pti->pMenuState->pGlobalPopupMenu) {
            pgui->flags |= GUI_INMENUMODE;

            if (pti->pMenuState->pGlobalPopupMenu->fHasMenuBar) {
                if (pti->pMenuState->pGlobalPopupMenu->fIsSysMenu) {
                    pgui->flags |= GUI_SYSTEMMENUMODE;
                }
            } else {
                pgui->flags |= GUI_POPUPMENUMODE;
            }

            if (pti->pMenuState->pGlobalPopupMenu->spwndNotify)
                pgui->hwndMenuOwner = HWq(pti->pMenuState->pGlobalPopupMenu->spwndNotify);
        }

        if (pti->TIF_flags & TIF_16BIT) {
            pgui->flags |= GUI_16BITTASK;
        }
    }

    /*
     * Get the rest of the information from the queue
     */
    pgui->hwndActive   = HW(pq->spwndActive);
    pgui->hwndFocus    = HW(pq->spwndFocus);
    pgui->hwndCapture  = HW(pq->spwndCapture);

    pgui->hwndCaret    = NULL;

    if (pq->caret.spwnd) {
        pgui->hwndCaret = HWq(pq->caret.spwnd);

        if ((GETPTI(pq->caret.spwnd) != PtiCurrentShared()) &&
            (pq->caret.spwnd->pcls->style & CS_OWNDC)) {
            /*
             * This is the case where we are being called by a different
             * thread than created the window, and the window has a
             * private DC.  We have to do extra work to be able to
             * return the desired information.
             * These coords are always relative to the client of hwndCaret.
             */
            pgui->rcCaret.left   = pq->caret.xOwnDc;
            pgui->rcCaret.right  = pgui->rcCaret.left + pq->caret.cxOwnDc;
            pgui->rcCaret.top    = pq->caret.yOwnDc;
            pgui->rcCaret.bottom = pgui->rcCaret.top + pq->caret.cyOwnDc;
        } else {
            /*
             * These coords are still in logical coordinates.  Ie, these
             * are the coordinates we draw at in UT_InvertCaret.
             */
            pgui->rcCaret.left   = pq->caret.x;
            pgui->rcCaret.right  = pgui->rcCaret.left + pq->caret.cx;
            pgui->rcCaret.top    = pq->caret.y;
            pgui->rcCaret.bottom = pgui->rcCaret.top + pq->caret.cy;
        }

        if (pq->caret.iHideLevel == 0)
            pgui->flags |= GUI_CARETBLINKING;
    } else if (pti && (pti->ppi->W32PF_Flags & W32PF_CONSOLEHASFOCUS)) {
        /*
         * The thread is running in the console window with focus. Pull
         * out the info from the console pseudo caret.
         */
        pgui->hwndCaret = pti->rpdesk->cciConsole.hwnd;
        pgui->rcCaret = pti->rpdesk->cciConsole.rc;
    } else {
        SetRectEmpty(&pgui->rcCaret);
    }

    return TRUE;
}


/****************************************************************************\
*
* _GetTitleBarInfo()
*
* Gets info about a window's title bar.  If the window is bogus or
* doesn't have a titlebar, this will fail.
*
\****************************************************************************/
BOOL WINAPI
xxxGetTitleBarInfo(PWND pwnd, PTITLEBARINFO ptbi)
{
    int     cxB;

    CheckLock(pwnd);

    /*
     * Validate titlebarinfo structure
     */
    if (ptbi->cbSize != sizeof(TITLEBARINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "TITLEBARINFO.cbSize %d is wrong", ptbi->cbSize);
        return FALSE;
    }

    RtlZeroMemory(&ptbi->rgstate, sizeof(ptbi->rgstate));

    ptbi->rgstate[INDEX_TITLEBAR_SELF] |= STATE_SYSTEM_FOCUSABLE;
    if (TestWF(pwnd, WFBORDERMASK) != LOBYTE(WFCAPTION))
    {
        // No titlebar.
        ptbi->rgstate[INDEX_TITLEBAR_SELF] |= STATE_SYSTEM_INVISIBLE;
        return TRUE;
    }

    if (!TestWF(pwnd, WFMINIMIZED) && !TestWF(pwnd, WFCPRESENT))
    {
        // Off screen (didn't fit)
        ptbi->rgstate[INDEX_TITLEBAR_SELF] |= STATE_SYSTEM_OFFSCREEN;
        SetRectEmpty(&ptbi->rcTitleBar);
        return TRUE;
    }

    /*
     * Get titlebar rect
     */
    ptbi->rcTitleBar = pwnd->rcWindow;
    cxB = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
    InflateRect(&ptbi->rcTitleBar, -cxB * SYSMET(CXBORDER), -cxB * SYSMET(CYBORDER));
    if (TestWF(pwnd, WEFTOOLWINDOW)) {
        ptbi->rcTitleBar.bottom = ptbi->rcTitleBar.top + SYSMET(CYSMCAPTION);
    } else {
        ptbi->rcTitleBar.bottom = ptbi->rcTitleBar.top + SYSMET(CYCAPTION);
    }

    /*
     * Don't include the system menu area!
     */
    if (TestWF(pwnd, WFSYSMENU) && _HasCaptionIcon(pwnd))
        ptbi->rcTitleBar.left += (ptbi->rcTitleBar.bottom - ptbi->rcTitleBar.top - SYSMET(CYBORDER));

    /*
     * Close button
     */
    if (!TestWF(pwnd, WFSYSMENU) && TestWF(pwnd, WFWIN40COMPAT)) {
        ptbi->rgstate[INDEX_TITLEBAR_CLOSEBUTTON] |= STATE_SYSTEM_INVISIBLE;
    } else {
        if (!xxxMNCanClose(pwnd))
            ptbi->rgstate[INDEX_TITLEBAR_CLOSEBUTTON] |= STATE_SYSTEM_UNAVAILABLE;

        if (TestWF(pwnd, WFCLOSEBUTTONDOWN))
            ptbi->rgstate[INDEX_TITLEBAR_CLOSEBUTTON] |= STATE_SYSTEM_PRESSED;
    }


    /*
     * Max button
     */
    if (! TestWF(pwnd, WFSYSMENU) && TestWF(pwnd, WFWIN40COMPAT)) {
        ptbi->rgstate[INDEX_TITLEBAR_MAXBUTTON] |= STATE_SYSTEM_INVISIBLE;
    } else {
        if (! TestWF(pwnd, WFMAXBOX)) {
            if (! TestWF(pwnd, WFMINBOX)) {
                ptbi->rgstate[INDEX_TITLEBAR_MAXBUTTON] |= STATE_SYSTEM_INVISIBLE;
            } else {
                ptbi->rgstate[INDEX_TITLEBAR_MAXBUTTON] |= STATE_SYSTEM_UNAVAILABLE;
            }
        }

        if (TestWF(pwnd, WFZOOMBUTTONDOWN))
            ptbi->rgstate[INDEX_TITLEBAR_MAXBUTTON] |= STATE_SYSTEM_PRESSED;
    }


    /*
     * Min button
     */
    if (! TestWF(pwnd, WFSYSMENU) && TestWF(pwnd, WFWIN40COMPAT)) {
        ptbi->rgstate[INDEX_TITLEBAR_MINBUTTON] |= STATE_SYSTEM_INVISIBLE;
    } else {
        if (! TestWF(pwnd, WFMINBOX)) {
            if (! TestWF(pwnd, WFMAXBOX)) {
                ptbi->rgstate[INDEX_TITLEBAR_MINBUTTON] |= STATE_SYSTEM_INVISIBLE;
            } else {
                ptbi->rgstate[INDEX_TITLEBAR_MINBUTTON] |= STATE_SYSTEM_UNAVAILABLE;
            }
        }

        if (TestWF(pwnd, WFREDUCEBUTTONDOWN))
            ptbi->rgstate[INDEX_TITLEBAR_MINBUTTON] |= STATE_SYSTEM_PRESSED;
    }


    /*
     * Help button
     */
    if (!TestWF(pwnd, WEFCONTEXTHELP) || TestWF(pwnd, WFMINBOX) ||
            TestWF(pwnd, WFMAXBOX)) {
        ptbi->rgstate[INDEX_TITLEBAR_HELPBUTTON] |= STATE_SYSTEM_INVISIBLE;
    } else {
        if (TestWF(pwnd, WFHELPBUTTONDOWN))
            ptbi->rgstate[INDEX_TITLEBAR_HELPBUTTON] |= STATE_SYSTEM_PRESSED;
    }

    // IME button BOGUS!
    ptbi->rgstate[INDEX_TITLEBAR_IMEBUTTON] = STATE_SYSTEM_INVISIBLE;

#if 0
    /*
     * System menu
     */
    if (!TestWF(pwnd, WFSYSMENU) || !_HasCaptionIcon(pwnd))
        ptbi->stateSysMenu |= STATE_SYSTEM_INVISIBLE;
#endif

    return TRUE;
}

/*****************************************************************************\
*
*  _GetScrollBarInfo()
*
*  Gets state & location information about a scrollbar.
*
*  Note we fill in the minimal amount of useful info.  OLEACC is responsible
*  for extrapolation.  I.E., if both the line up and line down buttons are
*  disabled, the whole scrollbar is, and the thumb is invisible.
*
\*****************************************************************************/
BOOL WINAPI
xxxGetScrollBarInfo(PWND pwnd, LONG idObject, PSCROLLBARINFO psbi)
{
    UINT   wDisable;
    BOOL   fVertical;
    SBCALC SBCalc;
    PCLS    pcls;

    CheckLock(pwnd);

    /*
     * Validate scrollbarinfo structure
     */
    if (psbi->cbSize != sizeof(SCROLLBARINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "SCROLLBARINFO.cbSize %d is wrong", psbi->cbSize);
        return FALSE;
    }

    pcls = pwnd->pcls;

    if ((idObject == OBJID_CLIENT) &&
        (GETFNID(pwnd) != FNID_SCROLLBAR) &&
        (pcls->atomClassName != gpsi->atomSysClass[ICLS_SCROLLBAR])) {

        return (BOOL)xxxSendMessage(pwnd, SBM_GETSCROLLBARINFO, 0, (LPARAM)psbi);
    }

    RtlZeroMemory(&psbi->rgstate, sizeof(psbi->rgstate));

    /*
     * Calculate where everything is.
     */
    if (idObject == OBJID_CLIENT) {
        RECT rc;
        wDisable = ((PSBWND)pwnd)->wDisableFlags;
        fVertical = ((PSBWND)pwnd)->fVert;
        GetRect(pwnd, &rc, GRECT_CLIENT | GRECT_CLIENTCOORDS);
        CalcSBStuff2(&SBCalc, &rc, (PSBDATA)&((PSBWND)pwnd)->SBCalc, ((PSBWND)pwnd)->fVert);
    } else {
        /*
         * Is this window scrollbar here?
         */
        if (idObject == OBJID_VSCROLL) {
            fVertical = TRUE;
            if (! TestWF(pwnd, WFVSCROLL)) {
                // No scrollbar.
                psbi->rgstate[INDEX_SCROLLBAR_SELF] |= STATE_SYSTEM_INVISIBLE;
            } else if (! TestWF(pwnd, WFVPRESENT)) {
                // Window too short to display it.
                psbi->rgstate[INDEX_SCROLLBAR_SELF] |= STATE_SYSTEM_OFFSCREEN;
            }
        } else if (idObject == OBJID_HSCROLL) {
            fVertical = FALSE;
            if (! TestWF(pwnd, WFHSCROLL)) {
                // No scrollbar.
                psbi->rgstate[INDEX_SCROLLBAR_SELF] |= STATE_SYSTEM_INVISIBLE;
            } else if (! TestWF(pwnd, WFHPRESENT)) {
                psbi->rgstate[INDEX_SCROLLBAR_SELF] |= STATE_SYSTEM_OFFSCREEN;
            }
        } else {
            RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "invalid idObject %d", idObject);
            return FALSE;
        }

        if (psbi->rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_INVISIBLE)
            return TRUE;

        wDisable = GetWndSBDisableFlags(pwnd, fVertical);

        if (!(psbi->rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_OFFSCREEN))
            CalcSBStuff(pwnd, &SBCalc, fVertical);
    }

    /*
     * Setup button states.
     */
    if (wDisable & LTUPFLAG) {
        psbi->rgstate[INDEX_SCROLLBAR_UP] |= STATE_SYSTEM_UNAVAILABLE;
        psbi->rgstate[INDEX_SCROLLBAR_UPPAGE] |= STATE_SYSTEM_UNAVAILABLE;
    }

    if (wDisable & RTDNFLAG) {
        psbi->rgstate[INDEX_SCROLLBAR_DOWN] |= STATE_SYSTEM_UNAVAILABLE;
        psbi->rgstate[INDEX_SCROLLBAR_DOWNPAGE] |= STATE_SYSTEM_UNAVAILABLE;
    }

    if ((wDisable & (LTUPFLAG | RTDNFLAG)) == (LTUPFLAG | RTDNFLAG))
        psbi->rgstate[INDEX_SCROLLBAR_SELF] |= STATE_SYSTEM_UNAVAILABLE;

    /*
     * Button pressed?
     */
    if (TestWF(pwnd, WFSCROLLBUTTONDOWN) &&
            ((idObject != OBJID_VSCROLL) || TestWF(pwnd, WFVERTSCROLLTRACK))) {
        if (TestWF(pwnd, WFLINEUPBUTTONDOWN))
            psbi->rgstate[INDEX_SCROLLBAR_UP] |= STATE_SYSTEM_PRESSED;

        if (TestWF(pwnd, WFPAGEUPBUTTONDOWN))
            psbi->rgstate[INDEX_SCROLLBAR_UPPAGE] |= STATE_SYSTEM_PRESSED;

        if (TestWF(pwnd, WFPAGEDNBUTTONDOWN))
            psbi->rgstate[INDEX_SCROLLBAR_DOWNPAGE] |= STATE_SYSTEM_PRESSED;

        if (TestWF(pwnd, WFLINEDNBUTTONDOWN))
            psbi->rgstate[INDEX_SCROLLBAR_DOWN] |= STATE_SYSTEM_PRESSED;
    }

    /*
     * Fill in area locations.
     */
    if (!(psbi->rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_OFFSCREEN)) {
        if (fVertical) {
            psbi->rcScrollBar.left = SBCalc.pxLeft;
            psbi->rcScrollBar.top = SBCalc.pxTop;
            psbi->rcScrollBar.right = SBCalc.pxRight;
            psbi->rcScrollBar.bottom = SBCalc.pxBottom;
        } else {
            psbi->rcScrollBar.left = SBCalc.pxTop;
            psbi->rcScrollBar.top = SBCalc.pxLeft;
            psbi->rcScrollBar.right = SBCalc.pxBottom;
            psbi->rcScrollBar.bottom = SBCalc.pxRight;
        }

        if (idObject == OBJID_CLIENT) {
            OffsetRect(&psbi->rcScrollBar, pwnd->rcClient.left, pwnd->rcClient.top);
        } else {
            OffsetRect(&psbi->rcScrollBar, pwnd->rcWindow.left, pwnd->rcWindow.top);
        }

        psbi->dxyLineButton = (SBCalc.pxUpArrow - SBCalc.pxTop);
        psbi->xyThumbTop = (SBCalc.pxThumbTop - SBCalc.pxTop);
        psbi->xyThumbBottom = (SBCalc.pxThumbBottom - SBCalc.pxTop);

        /*
         * Is the thumb all the way to the left/top?  If so, page up is
         * not visible.
         */
        if (SBCalc.pxThumbTop == SBCalc.pxUpArrow)
            psbi->rgstate[INDEX_SCROLLBAR_UPPAGE] |= STATE_SYSTEM_INVISIBLE;

        /*
         * Is the thumb all the way to the right/down?  If so, page down
         * is not visible.
         */
        if (SBCalc.pxThumbBottom == SBCalc.pxDownArrow)
            psbi->rgstate[INDEX_SCROLLBAR_DOWNPAGE] |= STATE_SYSTEM_INVISIBLE;
    }

    return TRUE;
}


/*****************************************************************************\
* GetAncestor()
*
* This gets one of:
*     * The _real_ parent.  This does NOT include the owner, unlike
*         GetParent().  Stops at a top level window unless we start with
*         the desktop.  In which case, we return the desktop.
*     * The _real_ root, caused by walking up the chain getting the
*         ancestor.
*     * The _real_ owned root, caused by GetParent()ing up.
\*****************************************************************************/
PWND WINAPI
_GetAncestor(PWND pwnd, UINT gaFlags)
{
    PWND pwndParent;

    /*
     * If we start with the desktop, the message window or
     * the mother window, return NULL.
     */
    if (pwnd == PWNDDESKTOP(pwnd) || pwnd == PWNDMESSAGE(pwnd) || pwnd->spwndParent == NULL) {
        return NULL;
    }

    switch (gaFlags) {
    case GA_PARENT:
        pwnd = pwnd->spwndParent;
        break;

    case GA_ROOT:
        while ((pwnd->spwndParent != PWNDDESKTOP(pwnd)) &&
               (pwnd->spwndParent != PWNDMESSAGE(pwnd))) {
            pwnd = pwnd->spwndParent;
            UserAssert(pwnd);
        }
        break;

    case GA_ROOTOWNER:
        while (pwndParent = _GetParent(pwnd)) {
            pwnd = pwndParent;
        }
        break;
    }

    return pwnd;
}


/*****************************************************************************\
*
* RealChildWindowFromPoint()
*
* This returns the REAL child window at a point.  The problem is that
* ChildWindowFromPoint() doesn't deal with HTTRANSPARENT areas of
* standard controls.  We want to return a child behind a groupbox if it
* is in the "clear" area.  But we want to return a static field always
* even though it too returns HTTRANSPARENT.
*
\*****************************************************************************/
PWND WINAPI
_RealChildWindowFromPoint(PWND pwndParent, POINT pt)
{
    PWND    pwndChild;
    PWND    pwndSave;

    if (pwndParent != PWNDDESKTOP(pwndParent)) {
        pt.x += pwndParent->rcClient.left;
        pt.y += pwndParent->rcClient.top;
    }

    /*
     * Is this point even in the parent?
     */
    if (!PtInRect(&pwndParent->rcClient, pt)  ||
        (pwndParent->hrgnClip && !GrePtInRegion(pwndParent->hrgnClip, pt.x, pt.y))) {
        // Nope
        return NULL;
    }

    pwndSave = NULL;

    /*
     * Loop through the children.
     */
    for (pwndChild = pwndParent->spwndChild; pwndChild; pwndChild = pwndChild->spwndNext) {
        if (!TestWF(pwndChild, WFVISIBLE))
            continue;

        /*
         * Is this point in the child's window?
         */
        if (!PtInRect(&pwndChild->rcWindow, pt) ||
                (pwndChild->hrgnClip && !GrePtInRegion(pwndChild->hrgnClip, pt.x, pt.y)))
            continue;

        /*
         * OK, we are in somebody's window.  Is this by chance a group box?
         */
        if (IS_BUTTON(pwndChild)) {
            if (TestWF(pwndChild, BFTYPEMASK) == LOBYTE(BS_GROUPBOX)) {
               pwndSave = pwndChild;
               continue;
            }
        }

        return pwndChild;
    }

    /*
     * Did we save a groupbox which turned out to have nothing behind it
     * at that point?
     */
    if (pwndSave) {
        return pwndSave;
    } else {
        return pwndParent;
    }
}


/*****************************************************************************\
* xxxGetMenuBarInfo()
*
* This succeeds if the menu/menu item exists.
*
* Parameters:
*     pwnd        window
*     idObject    this can be OBJID_MENU, OBJID_SYSMENU, or OBJID_CLIENT
*     idItem      which thing do we need info on? 0..cItems. 0 indicates
*                 the menu itself, 1 is the first item on the menu...
*     pmbi        Pointer to a MENUBARINFO structure that gets filled in
*
\*****************************************************************************/
BOOL WINAPI
xxxGetMenuBarInfo(PWND pwnd, long idObject, long idItem, PMENUBARINFO pmbi)
{
    PMENU       pMenu;
    int         cBorders;
    PITEM       pItem;
    PPOPUPMENU  ppopup;

    CheckLock(pwnd);

    /*
     * Validate menubarinfo structure
     */
    if (pmbi->cbSize != sizeof(MENUBARINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "MENUBARINFO.cbSize %d is wrong", pmbi->cbSize);
        return FALSE;
    }

    /*
     * Initialize the fields
     */
    SetRectEmpty(&pmbi->rcBar);
    pmbi->hMenu = NULL;
    pmbi->hwndMenu = NULL;
    pmbi->fBarFocused = FALSE;
    pmbi->fFocused = FALSE;

    /*
     * Get the menu handle we will deal with.
     */
    if (idObject == OBJID_MENU) {
        int cBorders;

        if (TestWF(pwnd, WFCHILD) || !pwnd->spmenu)
            return FALSE;

        pMenu = pwnd->spmenu;
        if (!pMenu)
            return FALSE;

        // If we have an item, is it in the valid range?
        if ((idItem < 0) || ((DWORD)idItem > pMenu->cItems))
            return FALSE;

        /*
         * Menu handle
         */
        pmbi->hMenu = PtoHq(pMenu);

        /*
         * Menu rect
         */
        if (pMenu->cxMenu && pMenu->cyMenu) {
            if (!idItem) {
                cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
                pmbi->rcBar.left = pwnd->rcWindow.left + cBorders * SYSMET(CXBORDER);
                pmbi->rcBar.top = pwnd->rcWindow.top + cBorders * SYSMET(CYBORDER);

                if (TestWF(pwnd, WFCPRESENT)) {
                    pmbi->rcBar.top += (TestWF(pwnd, WEFTOOLWINDOW) ? SYSMET(CYSMCAPTION) : SYSMET(CYCAPTION));
                }

                pmbi->rcBar.right = pmbi->rcBar.left + pMenu->cxMenu;
                pmbi->rcBar.bottom = pmbi->rcBar.top + pMenu->cyMenu;
            } else {
                pItem = pMenu->rgItems + idItem - 1;

                pmbi->rcBar.left = pwnd->rcWindow.left + pItem->xItem;
                pmbi->rcBar.top = pwnd->rcWindow.top + pItem->yItem;
                pmbi->rcBar.right = pmbi->rcBar.left + pItem->cxItem;
                pmbi->rcBar.bottom = pmbi->rcBar.top + pItem->cyItem;
            }
        }

        /*
         * Are we currently in app menu bar mode?
         */
        ppopup = GetpGlobalPopupMenu(pwnd);
        if (ppopup && ppopup->fHasMenuBar && !ppopup->fIsSysMenu &&
            (ppopup->spwndNotify == pwnd))
        {
            // Yes, we are.
            pmbi->fBarFocused = TRUE;

            if (!idItem) {
                pmbi->fFocused = TRUE;
            } else if (ppopup->ppopupmenuRoot->posSelectedItem == (UINT)idItem-1) {
                pmbi->fFocused = TRUE;
                UserAssert(ppopup->ppopupmenuRoot);
                pmbi->hwndMenu = HW(ppopup->ppopupmenuRoot->spwndNextPopup);
            }
        }

    } else if (idObject == OBJID_SYSMENU) {
        if (!TestWF(pwnd, WFSYSMENU))
            return FALSE;

        pMenu = xxxGetSysMenu(pwnd, FALSE);
        if (!pMenu)
            return FALSE;

        // If we have an item, is it in the valid range?
        if ((idItem < 0) || ((DWORD)idItem > pMenu->cItems))
            return FALSE;

        pmbi->hMenu = PtoHq(pMenu);

        /*
         * Menu rect
         */
        if (_HasCaptionIcon(pwnd)) {
            // The menu and single item take up the same space
            cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
            pmbi->rcBar.left = pwnd->rcWindow.left + cBorders * SYSMET(CXBORDER);
            pmbi->rcBar.top = pwnd->rcWindow.top + cBorders * SYSMET(CYBORDER);

            pmbi->rcBar.right = pmbi->rcBar.left +
                (TestWF(pwnd, WEFTOOLWINDOW) ? SYSMET(CXSMSIZE) : SYSMET(CXSIZE));

            pmbi->rcBar.bottom = pmbi->rcBar.top +
                (TestWF(pwnd, WEFTOOLWINDOW) ? SYSMET(CYSMSIZE) : SYSMET(CYSIZE));
        }

        /*
         * Are we currently in system menu bar mode?
         */
        ppopup = GetpGlobalPopupMenu(pwnd);
        if (ppopup && ppopup->fHasMenuBar && ppopup->fIsSysMenu &&
            (ppopup->spwndNotify == pwnd))
        {
            // Yes, we are.
            pmbi->fBarFocused = TRUE;

            if (!idItem) {
                pmbi->fFocused = TRUE;
            } else if (ppopup->ppopupmenuRoot->posSelectedItem == (UINT)idItem - 1) {
                pmbi->fFocused = TRUE;
                UserAssert(ppopup->ppopupmenuRoot);
                pmbi->hwndMenu = HW(ppopup->ppopupmenuRoot->spwndNextPopup);
            }
        }
    }
    else if (idObject == OBJID_CLIENT)
    {
        HMENU hMenu;
        hMenu = (HMENU)xxxSendMessage(pwnd, MN_GETHMENU, 0, 0);
        pMenu = HtoP(hMenu);
        if (!pMenu)
            return FALSE;

        // If we have an item, is it in the valid range?
        if ((idItem < 0) || ((DWORD)idItem > pMenu->cItems))
            return FALSE;

        pmbi->hMenu = hMenu;

        if (!idItem) {
            pmbi->rcBar = pwnd->rcClient;
        } else {
            pItem = pMenu->rgItems + idItem - 1;

            pmbi->rcBar.left = pwnd->rcClient.left + pItem->xItem;
            pmbi->rcBar.top = pwnd->rcClient.top + pItem->yItem;
            pmbi->rcBar.right = pmbi->rcBar.left + pItem->cxItem;
            pmbi->rcBar.bottom = pmbi->rcBar.top + pItem->cyItem;
        }

        /*
         * Are we currently in popup mode with us as one of the popups
         * showing?
         */
        ppopup = ((PMENUWND)pwnd)->ppopupmenu;
        if (ppopup && (ppopup->ppopupmenuRoot == GetpGlobalPopupMenu(pwnd))) {
            pmbi->fBarFocused = TRUE;

            if (!idItem) {
                pmbi->fFocused = TRUE;
            } else if ((UINT)idItem == ppopup->posSelectedItem + 1) {
                pmbi->fFocused = TRUE;
                pmbi->hwndMenu = HW(ppopup->spwndNextPopup);
            }
        }
    } else {
        return FALSE;
    }

    return TRUE;
}


/***************************************************************************\
*
* _GetComboBoxInfo()
*
* This returns combobox information for either a combo or its dropdown
* list.
*
\***************************************************************************/
BOOL WINAPI
xxxGetComboBoxInfo(PWND pwnd, PCOMBOBOXINFO pcbi)
{
    PCLS    pcls;
    COMBOBOXINFO cbi = {
        sizeof cbi,
    };
    BOOL fOtherProcess;
    BOOL bRetval = FALSE;
    WORD wWindowType = 0;

    CheckLock(pwnd);

    /*
     * Make sure it is a combobox or a dropdown
     */
    pcls = pwnd->pcls;


    if ((GETFNID(pwnd) == FNID_COMBOBOX) ||
            (pcls->atomClassName == gpsi->atomSysClass[ICLS_COMBOBOX])) {
        wWindowType = FNID_COMBOBOX;
    } else if ((GETFNID(pwnd) == FNID_COMBOLISTBOX) ||
            (pcls->atomClassName == gpsi->atomSysClass[ICLS_COMBOLISTBOX])) {
        wWindowType = FNID_COMBOLISTBOX;
    } else {
        return (BOOL)xxxSendMessage(pwnd, CB_GETCOMBOBOXINFO, 0, (LPARAM)pcbi);
    }

    /*
     * Validate combo structure
     */
    if (pcbi->cbSize != sizeof(COMBOBOXINFO)) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "COMBOBOXINFO.cbSize %d is wrong", pcbi->cbSize);
        return FALSE;
    }

    if (fOtherProcess = (GETPTI(pwnd)->ppi != PpiCurrent())) {
        KeAttachProcess(PsGetProcessPcb(GETPTI(pwnd)->ppi->Process));
    }

    try {
        PCBOX ccxPcboxSnap;
        PWND  ccxPwndSnap;
        HWND  ccxHwndSnap;

        /*
         * Snap and probe the CBOX structure, since it is client side.
         */
        if (wWindowType == FNID_COMBOBOX) {
            ccxPcboxSnap = ((PCOMBOWND)pwnd)->pcbox;
        } else {
            PLBIV ccxPlbSnap;
            /*
             * If this is a listbox, we must snap and probe the LBIV structure
             * in order to get to the CBOX structure.
             */
            ccxPlbSnap = ((PLBWND)pwnd)->pLBIV;
            if (!ccxPlbSnap) {
                goto errorexit;
            }
            ProbeForRead(ccxPlbSnap, sizeof(LBIV), DATAALIGN);
            ccxPcboxSnap = ccxPlbSnap->pcbox;
        }
        if (!ccxPcboxSnap) {
            goto errorexit;
        }
        ProbeForRead(ccxPcboxSnap, sizeof(CBOX), DATAALIGN);

        /*
         * Get the combo information now
         */

        /*
         * Snap and probe the client side pointer to the Combo window
         */
        ccxPwndSnap = ccxPcboxSnap->spwnd;
        ProbeForRead(ccxPwndSnap, sizeof(HEAD), DATAALIGN);
        cbi.hwndCombo = HWCCX(ccxPwndSnap);

        /*
         * Snap & probe the client side pointer to the Edit window.
         * To compare spwndEdit and pwnd, we should compare handles
         * since spwndEdit is a client-side address and pwnd is a
         * kernel-mode address,
         */

        ccxPwndSnap = ccxPcboxSnap->spwndEdit;
        /*
         * If combobox is not fully initialized and spwndEdit is NULL,
         * we should fail.
         */
        ProbeForRead(ccxPwndSnap, sizeof(HEAD), DATAALIGN);
        ccxHwndSnap = HWCCX(ccxPwndSnap);
        if (ccxHwndSnap == HW(pwnd)) {
            /*
             * ComboBox doesn't have Edit control.
             */
            cbi.hwndItem = NULL;
        } else {
            cbi.hwndItem = HWCCX(ccxPwndSnap);
        }

        /*
         * Snap and probe the client side pointer to the List window
         */
        ccxPwndSnap = ccxPcboxSnap->spwndList;
        /*
         * If combobox is not fully initialized and spwndList is NULL,
         * we should fail.
         */
        ProbeForRead(ccxPwndSnap, sizeof(HEAD), DATAALIGN);
        cbi.hwndList = HWCCX(ccxPwndSnap);

        /*
         * Snap the rest of the combo information.
         * We don't need to probe any of these, since there are no more indirections.
         */
        cbi.rcItem = ccxPcboxSnap->editrc;
        cbi.rcButton = ccxPcboxSnap->buttonrc;

        /*
         * Button state
         */
        cbi.stateButton = 0;
        if (ccxPcboxSnap->CBoxStyle == CBS_SIMPLE) {
            cbi.stateButton |= STATE_SYSTEM_INVISIBLE;
        }
        if (ccxPcboxSnap->fButtonPressed) {
            cbi.stateButton |= STATE_SYSTEM_PRESSED;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        goto errorexit;
    }

    *pcbi = cbi;
    bRetval = TRUE;

errorexit:
    if (fOtherProcess) {
        KeDetachProcess();
    }
    return bRetval;
}


/***************************************************************************\
*
* _GetListBoxInfo()
*
* Currently returns back the # of items per column.  There is no way to get
* or calculate this info any other way in a multicolumn list.
*
* For now, no structure is returned. If we ever need one more thing, make one.
*
* Since I have to run on multiple platforms, I can't define a message.
* To do so would require that
*     * I make changes to the thunk table
*     * I make sure the 32-bit define doesn't collide with some NT new msg
*     * I use a different value on Win '95 vs Memphis due to additions
*     * I test apps extensively since many of them pass on bogus valued
*         messages to the listbox handler which checks to see if they
*         are in range.  In other words, any value I pick is probably
*         going to flake out MSVC++ 4.0.
*
*  Ergo an API instead.
*
\***************************************************************************/
DWORD WINAPI
xxxGetListBoxInfo(PWND pwnd)
{
    PCLS    pcls;
    DWORD   dwRet = 0;
    BOOL    fOtherProcess;

    CheckLock(pwnd);

    /*
     * Make sure it is a combobox or a dropdown
     */
    pcls = pwnd->pcls;
    if ((pcls->atomClassName != gpsi->atomSysClass[ICLS_LISTBOX]) &&
            (GETFNID(pwnd) != FNID_LISTBOX)) {

        return (DWORD)xxxSendMessage(pwnd, LB_GETLISTBOXINFO, 0, 0);
    }

    if (fOtherProcess = (GETPTI(pwnd)->ppi != PpiCurrent())) {
        KeAttachProcess(PsGetProcessPcb(GETPTI(pwnd)->ppi->Process));
    }

    try {
        PLBIV   ccxPlbSnap;

        /*
         * Snap and probe the pointer to the LBIV, since it is client-side.
         */
        ccxPlbSnap = ((PLBWND)pwnd)->pLBIV;
        if (!ccxPlbSnap) {
            goto errorexit;
        }
        ProbeForRead(ccxPlbSnap, sizeof(LBIV), DATAALIGN);

        if (ccxPlbSnap->fMultiColumn) {
            dwRet = ccxPlbSnap->itemsPerColumn;
        } else {
            dwRet = ccxPlbSnap->cMac;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        dwRet = 0;
    }

errorexit:
    if (fOtherProcess) {
        KeDetachProcess();
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\keizon\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\winprop.c ===
/****************************** Module Header ******************************\
* Module Name: winprop.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains routines having to do with window properties.
*
* History:
* 11-13-90 DarrinM      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* InternalSetProp
*
* SetProp searches the linked-list of window property structures for the
* specified key.  If found, the existing property structure is changed to
* hold the new hData handle.  If no property is found with the specified key
* a new property structure is created and initialized.
*
* Since property keys are retained as atoms, we convert the incoming pszKey
* to an atom before lookup or storage.  pszKey might actually be an atom
* already, so we keep a flag, PROPF_STRING, so we know whether the atom was
* created by the system or whether it was passed in.  This way we know
* whether we should destroy it when the property is destroyed.
*
* Several property values are for User's private use.  These properties are
* denoted with the flag PROPF_INTERNAL.  Depending on the fInternal flag,
* either internal (User) or external (application) properties are set/get/
* removed/enumerated, etc.
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

BOOL InternalSetProp(
    PWND pwnd,
    LPWSTR pszKey,
    HANDLE hData,
    DWORD dwFlags)
{
    PPROP pprop;

    if (pszKey == NULL) {
        RIPERR0(ERROR_INVALID_PARAMETER,
                RIP_WARNING,
                "Invalid parameter \"pszKey\" (NULL) to InternalSetProp");

        return FALSE;
    }

    /*
     * If no property list exists for this window, create one.
     */
    pprop = _FindProp(pwnd, pszKey, dwFlags & PROPF_INTERNAL);
    if (pprop == NULL) {

        /*
         * pszKey must be an atom within the server.
         */
        UserAssert(!IS_PTR(pszKey));

        /*
         * CreateProp allocates the property and links it into the window's
         * property list.
         */
        pprop = CreateProp(pwnd);
        if (pprop == NULL)
            return FALSE;

        pprop->atomKey = PTR_TO_ID(pszKey);
        pprop->fs = (WORD)dwFlags;
    }

    pprop->hData = hData;

    return TRUE;
}


/***************************************************************************\
* InternalRemoveProp
*
* Remove the specified property from the specified window's property list.
* The property's hData handle is returned to the caller who can then free
* it or whatever.  NOTE: This also applies to internal properties as well --
* InternalRemoveProp will free the property structure and atom (if created
* by User) but will not free the hData itself.
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

HANDLE InternalRemoveProp(
    PWND pwnd,
    LPWSTR pszKey,
    BOOL fInternal)
{
    PPROP pprop;
    PPROP ppropLast;
    HANDLE hT;

    /*
     * Find the property to be removed.
     */
    pprop = _FindProp(pwnd, pszKey, fInternal);
    if (pprop == NULL)
        return NULL;

    /*
     * Remember what it was pointing at.
     */
    hT = pprop->hData;

    /*
     * Move the property at the end of the list into this slot.
     */
    pwnd->ppropList->iFirstFree--;
    ppropLast = &pwnd->ppropList->aprop[pwnd->ppropList->iFirstFree];
    *pprop = *ppropLast;
    RtlZeroMemory(ppropLast, sizeof(*ppropLast));

    return hT;
}


/***************************************************************************\
* _BuildPropList
*
* This is a unique client/server routine - it builds a list of Props and
* returns it to the client.  Unique since the client doesn't know how
* big the list is ahead of time.
*
* 29-Jan-1992 JohnC    Created.
\***************************************************************************/

NTSTATUS _BuildPropList(
    PWND pwnd,
    PROPSET aPropSet[],
    UINT cPropMax,
    PUINT pcPropNeeded)
{
    UINT i;
    PPROPLIST ppropList;
    PPROP pProp;
    DWORD iRetCnt = 0;            // The number of Props returned
    DWORD iProp = 0;
    PPROPSET pPropSetLast = (aPropSet + cPropMax - 1);
    NTSTATUS Status;

    /*
     * If the Window does not have a property list then we're done
     */
    ppropList = pwnd->ppropList;
    if (ppropList == NULL) {
        *pcPropNeeded = 0;
        return STATUS_SUCCESS;
    }

    /*
     * For each element in the property list enumerate it.
     * (only if it is not internal!)
     */
    Status = STATUS_SUCCESS;
    pProp = ppropList->aprop;
    for (i = ppropList->iFirstFree; i > 0; i--) {

        /*
         * if we run out of space in shared memory return
         * STATUS_BUFFER_TOO_SMALL
         */
        if (&aPropSet[iProp] > pPropSetLast) {

            /*
             * Reset to the beginning of the output
             * buffer so we can continue and compute
             * the needed space.
             */
            iProp = 0;
            Status = STATUS_BUFFER_TOO_SMALL;
        }

        if (!(pProp->fs & PROPF_INTERNAL)) {
            aPropSet[iProp].hData = pProp->hData;
            aPropSet[iProp].atom = pProp->atomKey;
            iProp++;
            iRetCnt++;
        }
        pProp++;
    }

    /*
     * Return the number of PROPLISTs given back to the client
     */

    *pcPropNeeded = iRetCnt;

    return Status;
}


/***************************************************************************\
* CreateProp
*
* Create a property structure and link it at the head of the specified
* window's property list.
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

PPROP CreateProp(
    PWND pwnd)
{
    PPROPLIST ppropList;
    PPROP pprop;

    if (pwnd->ppropList == NULL) {
        pwnd->ppropList = (PPROPLIST)DesktopAlloc(pwnd->head.rpdesk,
                                                  sizeof(PROPLIST),
                                                  DTAG_PROPLIST);
        if (pwnd->ppropList == NULL) {
            return NULL;
        }
        pwnd->ppropList->cEntries = 1;
    } else if (pwnd->ppropList->iFirstFree == pwnd->ppropList->cEntries) {
        ppropList = (PPROPLIST)DesktopAlloc(pwnd->head.rpdesk,
                                            sizeof(PROPLIST) + pwnd->ppropList->cEntries * sizeof(PROP),
                                            DTAG_PROPLIST);
        if (ppropList == NULL) {
            return NULL;
        }
        RtlCopyMemory(ppropList, pwnd->ppropList, sizeof(PROPLIST) + (pwnd->ppropList->cEntries - 1) * sizeof(PROP));
        DesktopFree(pwnd->head.rpdesk, pwnd->ppropList);
        pwnd->ppropList = ppropList;
        pwnd->ppropList->cEntries++;
    }
    pprop = &pwnd->ppropList->aprop[pwnd->ppropList->iFirstFree];
    pwnd->ppropList->iFirstFree++;

    return pprop;
}


/***************************************************************************\
* DeleteProperties
*
* When a window is destroyed we want to destroy all its accompanying
* properties.  DestroyProperties does this, including destroying any hData
* that was allocated by User for internal properties.  Any atoms created
* along with the properties are destroyed as well.  hData in application
* properties are not destroyed automatically; we assume the application
* is taking care of that itself (in its WM_DESTROY handler or similar).
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

void DeleteProperties(
    PWND pwnd)
{
    PPROP pprop;
    UINT i;

    UserAssert(pwnd->ppropList);

    /*
     * Loop through the whole list of properties on this window.
     */
    pprop = pwnd->ppropList->aprop;
    for (i = pwnd->ppropList->iFirstFree; i > 0; i--) {

        /*
         * Is this an internal property?  If so, free any data we allocated
         * for it.
         */
        if ((pprop->fs & PROPF_INTERNAL) && !(pprop->fs & PROPF_NOPOOL)) {
                UserFreePool(pprop->hData);
        }

        /*
         * Advance to the next property in the list.
         */
        pprop++;
    }

    /*
     * All properties gone, free the property list and clear out the
     * window's property list pointer.
     */
    DesktopFree(pwnd->head.rpdesk, pwnd->ppropList);
    pwnd->ppropList = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\winsta.c ===
/**************************** Module Header ********************************\
* Module Name: winsta.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Windowstation Routines
*
* History:
* 01-14-91 JimA         Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
/***************************************************************************\
* InitTerminal
*
* Creates the desktop thread for a terminal and also the RIT for the
* IO terminal
*
* History:
* 27-10-97 CLupu        Created.
\***************************************************************************/

NTSTATUS xxxInitTerminal(
    PTERMINAL pTerm)
{
    NTSTATUS Status;
    PKEVENT  pEventTermInit;
    HANDLE   hEventInputReady, hEventTermInit;
    USER_API_MSG m;

    CheckCritIn();

    UserAssert(!(pTerm->dwTERMF_Flags & TERMF_INITIALIZED));

    if (pTerm->pEventInputReady != NULL) {

        /*
         * if we make it here it means that another thread is
         * executing xxxInitTerminal for the same terminal and it
         * left the critical section.
         */
        UserAssert(pTerm->pEventTermInit != NULL);

        /*
         * use a local variable so we can safely reset
         * pTerm->pEventTermInit when we're done with it
         */
        pEventTermInit = pTerm->pEventTermInit;

        ObReferenceObject(pEventTermInit);

        LeaveCrit();

        goto Wait;
    }

    /*
     * Create the input ready event. RIT and desktop thread will wait for it.
     * It will be set when the first desktop in this terminal will be created.
     */
    Status = ZwCreateEvent(
                     &hEventInputReady,
                     EVENT_ALL_ACCESS,
                     NULL,
                     NotificationEvent,
                     FALSE);

    if (!NT_SUCCESS(Status))
        return Status;

    Status = ObReferenceObjectByHandle(
                     hEventInputReady,
                     EVENT_ALL_ACCESS,
                     *ExEventObjectType,
                     KernelMode,
                     &pTerm->pEventInputReady, NULL);

    ZwClose(hEventInputReady);

    if (!NT_SUCCESS(Status))
        return Status;

    /*
     * Device and RIT initialization. Don't do it for
     * the system terminal.
     */
    if (!(pTerm->dwTERMF_Flags & TERMF_NOIO)) {
        if (!CreateTerminalInput(pTerm)) {
            ObDereferenceObject(pTerm->pEventInputReady);
            return STATUS_NO_MEMORY;
        }
    }

    /*
     * create an event to syncronize the terminal initialization
     */
    Status = ZwCreateEvent(
                     &hEventTermInit,
                     EVENT_ALL_ACCESS,
                     NULL,
                     NotificationEvent,
                     FALSE);

    if (!NT_SUCCESS(Status)) {
        ObDereferenceObject(pTerm->pEventInputReady);
        return Status;
    }

    Status = ObReferenceObjectByHandle(
                     hEventTermInit,
                     EVENT_ALL_ACCESS,
                     *ExEventObjectType,
                     KernelMode,
                     &pTerm->pEventTermInit, NULL);

    ZwClose(hEventTermInit);

    if (!NT_SUCCESS(Status)) {
        ObDereferenceObject(pTerm->pEventInputReady);
        return Status;
    }

    /*
     * use a local variable so we can safely reset
     * pTerm->pEventTermInit when we're done with it
     */
    pEventTermInit = pTerm->pEventTermInit;

    if (!InitCreateSystemThreadsMsg(&m, CST_DESKTOP, pTerm, 0, FALSE)) {
        ObDereferenceObject(pTerm->pEventInputReady);
        ObDereferenceObject(pEventTermInit);
        return STATUS_NO_MEMORY;
    }
    /*
     * Be sure that we are not in CSRSS context.
     * WARNING: If for any reason we changed this to run in CSRSS context then we have to use
     * LpcRequestPort instead of LpcRequestWaitReplyPort.
     */
    UserAssert (!ISCSRSS());

    LeaveCrit();

    /*
     * Create the desktop thread.
     */
    Status = LpcRequestWaitReplyPort(CsrApiPort, (PPORT_MESSAGE)&m, (PPORT_MESSAGE)&m);
    if (!NT_SUCCESS(Status)) {
        EnterCrit();
        ObDereferenceObject(pTerm->pEventInputReady);
        ObDereferenceObject(pEventTermInit);
        return STATUS_NO_MEMORY;
    }
Wait:
    KeWaitForSingleObject(pEventTermInit,
                          WrUserRequest,
                          KernelMode,
                          FALSE,
                          NULL);

    EnterCrit();

    /*
     * dereference the terminal init event. It will eventually
     * go away.
     */
    ObDereferenceObject(pEventTermInit);

    pTerm->pEventTermInit = NULL;

    if (pTerm->dwTERMF_Flags & TERMF_DTINITFAILED) {
        return STATUS_NO_MEMORY;
    }

    pTerm->dwTERMF_Flags |= TERMF_INITIALIZED;
    return STATUS_SUCCESS;
}


/***************************************************************************\
* xxxCreateWindowStation
*
* Creates the specified windowstation and starts a logon thread for the
* station.
*
* History:
* 01-15-91 JimA         Created.
\***************************************************************************/

static CONST LPCWSTR lpszStdFormats[] = {
    L"StdExit",
    L"StdNewDocument",
    L"StdOpenDocument",
    L"StdEditDocument",
    L"StdNewfromTemplate",
    L"StdCloseDocument",
    L"StdShowItem",
    L"StdDoVerbItem",
    L"System",
    L"OLEsystem",
    L"StdDocumentName",
    L"Protocols",
    L"Topics",
    L"Formats",
    L"Status",
    L"EditEnvItems",
    L"True",
    L"False",
    L"Change",
    L"Save",
    L"Close",
    L"MSDraw"
};

NTSTATUS CreateGlobalAtomTable(
    PVOID* ppAtomTable)
{
    NTSTATUS Status;
    RTL_ATOM Atom;
    ULONG    i;

    Status = RtlCreateAtomTable(0, ppAtomTable);

    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "Global atom table not created");
        return Status;
    }

    for (i = 0; i < ARRAY_SIZE(lpszStdFormats); i++) {
        Status = RtlAddAtomToAtomTable(*ppAtomTable,
                                       (PWSTR)lpszStdFormats[i],
                                       &Atom);
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "RtlAddAtomToAtomTable failed to add atom %ws",
                    lpszStdFormats[i]);

            RtlDestroyAtomTable(*ppAtomTable);
            return Status;
        }

        RtlPinAtomInAtomTable(*ppAtomTable, Atom);
    }
    return Status;
}

HWINSTA xxxCreateWindowStation(
    POBJECT_ATTRIBUTES  ObjectAttributes,
    KPROCESSOR_MODE     OwnershipMode,
    DWORD               dwDesiredAccess,
    HANDLE              hKbdLayoutFile,
    DWORD               offTable,
    PKBDTABLE_MULTI_INTERNAL pKbdTableMulti,
    PCWSTR              pwszKLID,
    UINT                uKbdInputLocale)
{
    PWINDOWSTATION          pwinsta;
    PTHREADINFO             ptiCurrent;
    PDESKTOP                pdeskTemp;
    HDESK                   hdeskTemp;
    PSECURITY_DESCRIPTOR    psd;
    PSECURITY_DESCRIPTOR    psdCapture;
    PPROCESSINFO            ppiSave;
    NTSTATUS                Status;
    PACCESS_ALLOWED_ACE     paceList = NULL, pace;
    ULONG                   ulLength, ulLengthSid;
    HANDLE                  hEvent;
    HWINSTA                 hwinsta;
    DWORD                   dwDisableHooks;
    PTERMINAL               pTerm = NULL;
    PWND                    pwnd;
    WCHAR                   szBaseNamedObjectDirectory[MAX_SESSION_PATH];

    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * Get the pointer to the security descriptor so we can
     * assign it to the new object later.
     */
    psdCapture = ObjectAttributes->SecurityDescriptor;

    /*
     * The first windowstation that gets created is Winsta0 and
     * it's the only interactive one.
     */
    if (grpWinStaList == NULL) {

        /*
         * Assert that winlogon is the first to call CreateWindowStation
         */
        UserAssert(PsGetCurrentProcessId() == gpidLogon);

        pTerm = &gTermIO;
    } else {
        pTerm = &gTermNOIO;

        UserAssert(grpWinStaList->rpwinstaNext == NULL ||
                   pTerm->dwTERMF_Flags & TERMF_NOIO);

        pTerm->dwTERMF_Flags |= TERMF_NOIO;
    }

    /*
     * Create the WindowStation object
     */
    Status = ObCreateObject(KernelMode, *ExWindowStationObjectType,
            ObjectAttributes, OwnershipMode, NULL, sizeof(WINDOWSTATION),
            0, 0, &pwinsta);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_WARNING, "Failed to create windowstation");
        return NULL;
    }

    /*
     * WindowStation object was created then reference gWinstaRunRef.
     * We have to dereference it at FreeWindowStation().
     * And wait for any live objects to get freed in Win32KDriverUnload().
     */
    if (!ExAcquireRundownProtection(&gWinstaRunRef)) {
        goto create_error;
    }

    /*
     * Initialize everything
     */
    RtlZeroMemory(pwinsta, sizeof(WINDOWSTATION));

    /*
     * Store the session id of the session who created the windowstation
     */
    pwinsta->dwSessionId = gSessionId;

    pwinsta->pTerm = pTerm;

    /*
     * All the windowstations in the system terminal are non-interactive.
     */
    if (pTerm->dwTERMF_Flags & TERMF_NOIO) {
        pwinsta->dwWSF_Flags = WSF_NOIO;
    }

    /*
     * Create the global atom table and populate it with the default OLE atoms
     * Pin each atom so they can't be deleted by bogus applications like Winword
     */
    Status = CreateGlobalAtomTable(&pwinsta->pGlobalAtomTable);

    if (pwinsta->pGlobalAtomTable == NULL) {
        UserAssert(!NT_SUCCESS(Status));
        RIPNTERR0(Status, RIP_WARNING, "CreateGlobalAtomTable failed");
        goto create_error;
    }

    /*
     * create the desktop thread
     * and the RIT (only for the IO terminal)
     */
    if (!(pTerm->dwTERMF_Flags & TERMF_INITIALIZED)) {

        Status = xxxInitTerminal(pTerm);

        if (!NT_SUCCESS(Status)) {
            RIPNTERR0(Status, RIP_WARNING, "xxxInitTerminal failed");
            goto create_error;
        }
    }

    if (!(pwinsta->dwWSF_Flags & WSF_NOIO)) {
        if (!xxxInitWindowStation(pwinsta)) {
            RIPNTERR0(STATUS_NO_MEMORY, RIP_WARNING, "xxxInitWindowStation failed");
            goto create_error;
        }
    }

    /*
     * Create only one desktop owner window per terminal.
     */
    if (pTerm->spwndDesktopOwner == NULL) {

        /*
         * Switch ppi values so window will be created using the
         * system's desktop window class.
         */
        ptiCurrent = PtiCurrent();
        ppiSave = ptiCurrent->ppi;
        ptiCurrent->ppi = pTerm->ptiDesktop->ppi;

        UserAssert(pTerm->ptiDesktop->ppi->W32PF_Flags & W32PF_CLASSESREGISTERED);

        pdeskTemp = ptiCurrent->rpdesk;            /* save current desktop */
        hdeskTemp = ptiCurrent->hdesk;
        if (pdeskTemp) {
            ObReferenceObject(pdeskTemp);
            LogDesktop(pdeskTemp, LD_REF_FN_CREATEWINDOWSTATION, TRUE, (ULONG_PTR)PtiCurrent());
        }

        /*
         * The following code is not supposed to leave the critical section because
         * CreateWindowStation is an API so the current thread can be on any state
         *  setting its pdesk to NULL it's kind of bogus
         */
        DeferWinEventNotify();
        BEGINATOMICCHECK();
        zzzSetDesktop(ptiCurrent, NULL, NULL);


        /*
         * HACK HACK HACK!!! (adams) In order to create the desktop window
         * with the correct desktop, we set the desktop of the current thread
         * to the new desktop. But in so doing we allow hooks on the current
         * thread to also hook this new desktop. This is bad, because we don't
         * want the desktop window to be hooked while it is created. So we
         * temporarily disable hooks of the current thread and desktop, and
         * reenable them after switching back to the original desktop.
         */

        dwDisableHooks = ptiCurrent->TIF_flags & TIF_DISABLEHOOKS;
        ptiCurrent->TIF_flags |= TIF_DISABLEHOOKS;

        /*
         * Create the desktop owner window
         *
         * CONSIDER (adams): Do we want to limit the desktop size so that the
         * width and height of a rect will fit in 16bit coordinates?
         *
         *         SHRT_MIN / 2, SHRT_MIN / 2, SHRT_MAX, SHRT_MAX,
         *
         * Or do we want to limit it so just any point has 16bit coordinates?
         *
         *         -SHRT_MIN, -SHRT_MIN, SHRT_MAX * 2, SHRT_MAX * 2
         */

        pwnd =  xxxNVCreateWindowEx(
                (DWORD)0,
                (PLARGE_STRING)DESKTOPCLASS,
                NULL,
                (WS_POPUP | WS_CLIPCHILDREN),
                SHRT_MIN / 2,
                SHRT_MIN / 2,
                SHRT_MAX,
                SHRT_MAX,
                NULL,
                NULL,
                hModuleWin,
                (LPWSTR)NULL,
                VER31
                );

        if (pwnd == NULL) {
            RIPMSG0(RIP_WARNING, "xxxCreateWindowStation: Failed to create mother desktop window");
            Status = STATUS_NO_MEMORY;
            EXITATOMICCHECK();
            zzzEndDeferWinEventNotify();
            /*
             * Restore caller's ppi
             */
            ptiCurrent->ppi = ppiSave;

            /*
             * Restore the previous desktop
             */
            zzzSetDesktop(ptiCurrent, pdeskTemp, hdeskTemp);

            goto create_error;
        }

        /*
         * Mark this handle entry that is allocated out of pool
         */
        {
            PHE phe;

            UserAssert(ptiCurrent->rpdesk == NULL);

            phe = HMPheFromObject(pwnd);
            phe->bFlags |= HANDLEF_POOL;
        }

        Lock(&(pTerm->spwndDesktopOwner), pwnd);

        UserAssert(ptiCurrent->TIF_flags & TIF_DISABLEHOOKS);
        ptiCurrent->TIF_flags = (ptiCurrent->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;

        SetVisible(pTerm->spwndDesktopOwner, SV_SET);
        HMChangeOwnerThread(pTerm->spwndDesktopOwner, pTerm->ptiDesktop);

        /*
         * Restore caller's ppi
         */
        ptiCurrent->ppi = ppiSave;

        /*
         * Restore the previous desktop
         */
        zzzSetDesktop(ptiCurrent, pdeskTemp, hdeskTemp);

        ENDATOMICCHECK();
        zzzEndDeferWinEventNotify();

        if (pdeskTemp) {
            LogDesktop(pdeskTemp, LD_DEREF_FN_CREATEWINDOWSTATION, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdeskTemp);
        }
    }

    /*
     * If this is the visible windowstation, assign it to
     * the server and create the desktop switch notification
     * event.
     */
    if (!(pwinsta->dwWSF_Flags & WSF_NOIO)) {
        UNICODE_STRING strName;
        HANDLE hRootDir;
        OBJECT_ATTRIBUTES obja;

        /*
         * Create desktop switch notification event.
         */
        ulLengthSid = RtlLengthSid(SeExports->SeWorldSid);
        ulLength = ulLengthSid + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);

        /*
         * Allocate the ACE list
         */
        paceList = (PACCESS_ALLOWED_ACE)UserAllocPoolWithQuota(ulLength, TAG_SECURITY);

        if (paceList == NULL) {
            Status = STATUS_NO_MEMORY;
            goto create_error;
        }

        /*
         * Initialize ACE 0
         */
        pace = paceList;
        pace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
        pace->Header.AceSize = (USHORT)ulLength;
        pace->Header.AceFlags = 0;
        pace->Mask = SYNCHRONIZE;
        RtlCopySid(ulLengthSid, &pace->SidStart, SeExports->SeWorldSid);

        /*
         * Create the SD
         */
        psd = CreateSecurityDescriptor(paceList, ulLength, FALSE);

        UserFreePool(paceList);

        if (psd == NULL) {
            Status = STATUS_NO_MEMORY;
            goto create_error;
        }

        /*
         * Create the named event.
         */
        UserAssert(ghEventSwitchDesktop == NULL);

        if (gbRemoteSession) {
            swprintf(szBaseNamedObjectDirectory, L"\\Sessions\\%ld\\BaseNamedObjects",
                     gSessionId);
            RtlInitUnicodeString(&strName, szBaseNamedObjectDirectory);
        } else {
            RtlInitUnicodeString(&strName, L"\\BaseNamedObjects");
        }

        InitializeObjectAttributes( &obja,
                                    &strName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                    );
        Status = ZwOpenDirectoryObject( &hRootDir,
                                        DIRECTORY_ALL_ACCESS &
                                            ~(DELETE | WRITE_DAC | WRITE_OWNER),
                                        &obja
                                    );
        if (NT_SUCCESS(Status)) {
            RtlInitUnicodeString(&strName, L"WinSta0_DesktopSwitch");
            InitializeObjectAttributes(&obja, &strName, OBJ_OPENIF, hRootDir, psd);
            Status = ZwCreateEvent(&hEvent, EVENT_ALL_ACCESS, &obja,
                    NotificationEvent, FALSE);
            ZwClose(hRootDir);

            if (NT_SUCCESS(Status)) {
                Status = ObReferenceObjectByHandle(hEvent, EVENT_ALL_ACCESS, *ExEventObjectType,
                        KernelMode, &gpEventSwitchDesktop, NULL);
                if (NT_SUCCESS(Status)) {

                    /*
                     * Attach to the system process and create a handle to the
                     * object.  This will ensure that the object name is retained
                     * when hEvent is closed.  This is simpler than creating a
                     * permanent object, which takes the
                     * SeCreatePermanentPrivilege.
                     */
                    KeAttachProcess(PsGetProcessPcb(gpepCSRSS));

                    Status = ObOpenObjectByPointer(
                            gpEventSwitchDesktop,
                            0,
                            NULL,
                            EVENT_ALL_ACCESS,
                            NULL,
                            KernelMode,
                            &ghEventSwitchDesktop);
                    KeDetachProcess();
                }
                ZwClose(hEvent);
            }
        }
        if (!NT_SUCCESS(Status))
            goto create_error;

        UserFreePool(psd);
    }

    /*
     * Create a handle to the windowstation
     */
    Status = ObInsertObject(pwinsta, NULL, dwDesiredAccess, 1,
            &pwinsta, &hwinsta);

    if (Status == STATUS_OBJECT_NAME_EXISTS) {

        /*
         * The windowstation already exists, so deref and leave.
         */
        ObDereferenceObject(pwinsta);

    } else if (NT_SUCCESS(Status)) {
        PSECURITY_DESCRIPTOR psdParent = NULL, psdNew;
        SECURITY_SUBJECT_CONTEXT Context;
        POBJECT_DIRECTORY pParentDirectory;
        SECURITY_INFORMATION siNew;
        BOOLEAN MemoryAllocated = FALSE;

        /*
         * Create security descriptor for the windowstation.
         * ObInsertObject only supports non-container
         * objects, so we must assign our own security descriptor.
         */
        SeCaptureSubjectContext(&Context);
        SeLockSubjectContext(&Context);

        pParentDirectory = OBJECT_HEADER_TO_NAME_INFO(
                OBJECT_TO_OBJECT_HEADER(pwinsta))->Directory;

        if (pParentDirectory != NULL) {
            Status = ObGetObjectSecurity(
                    pParentDirectory,
                    &psdParent,
                    &MemoryAllocated);
            if ( !NT_SUCCESS(Status) ) {
                goto create_error;
            }
        }

        Status = SeAssignSecurity(
                psdParent,
                psdCapture,
                &psdNew,
                TRUE,
                &Context,
                (PGENERIC_MAPPING)&WinStaMapping,
                PagedPool);

        ObReleaseObjectSecurity(
            psdParent,
            MemoryAllocated);

        SeUnlockSubjectContext(&Context);
        SeReleaseSubjectContext(&Context);

        if (!NT_SUCCESS(Status)) {
#if DBG
            if (Status == STATUS_ACCESS_DENIED) {
                RIPNTERR0(Status, RIP_WARNING, "Access denied during object creation");
            } else {
                RIPNTERR1(Status, RIP_ERROR,
                            "Can't create security descriptor! Status = %#lx",
                            Status);
            }
#endif
        } else {

            /*
             * Call the security method to copy the security descriptor
             */
            siNew = (OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                    DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION);
            Status = ObSetSecurityDescriptorInfo(
                    pwinsta,
                    &siNew,
                    psdNew,
                    &OBJECT_TO_OBJECT_HEADER(pwinsta)->SecurityDescriptor,
                    PagedPool,
                    (PGENERIC_MAPPING)&WinStaMapping);
            SeDeassignSecurity(&psdNew);

            if (NT_SUCCESS(Status)) {

                PWINDOWSTATION* ppwinsta;

                /*
                 * Put it on the tail of the global windowstation list
                 */
                ppwinsta = &grpWinStaList;
                while (*ppwinsta != NULL)
                    ppwinsta = &(*ppwinsta)->rpwinstaNext;
                LockWinSta(ppwinsta, pwinsta);

                /*
                 * For interactive window stations load the keyboard
                 * layout. !!!
                 */
                if ((pwinsta->dwWSF_Flags & WSF_NOIO) == 0 && pwszKLID != NULL) {
                    TL tlpwinsta;

                    PushW32ThreadLock(pwinsta, &tlpwinsta, UserDereferenceObject);
                    if (xxxLoadKeyboardLayoutEx(
                                pwinsta,
                                hKbdLayoutFile,
                                (HKL)NULL,
                                offTable,
                                pKbdTableMulti,
                                pwszKLID,
                                uKbdInputLocale,
                                KLF_ACTIVATE | KLF_INITTIME) == NULL) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                    PopW32ThreadLock(&tlpwinsta);
                }
            }
        }
        ObDereferenceObject(pwinsta);
    }

    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status,
                  RIP_WARNING,
                  "CreateWindowStation: Failed with Status 0x%x",
                  Status);
        return NULL;
    }

    return hwinsta;

    /*
     * Goto here if an error occurs so things can be cleaned up
     */
create_error:

    RIPNTERR1(Status,
              RIP_WARNING,
              "CreateWindowStation: Failed with Status 0x%x",
              Status);

    ObDereferenceObject(pwinsta);

    return NULL;
}

/***************************************************************************\
* FreeWindowStation
*
* Called when last lock to the windowstation is removed.  Frees all
* resources owned by the windowstation.
*
* History:
* 12-22-93 JimA         Created.
\***************************************************************************/

NTSTATUS FreeWindowStation(
    PKWIN32_DELETEMETHOD_PARAMETERS pDeleteParams
    )
{
    PWINDOWSTATION pwinsta = pDeleteParams->Object;
    UserAssert(OBJECT_TO_OBJECT_HEADER(pwinsta)->Type == *ExWindowStationObjectType);

    /*
     * Mark the windowstation as dying.  Make sure we're not recursing.
     */
    UserAssert(!(pwinsta->dwWSF_Flags & WSF_DYING));
    pwinsta->dwWSF_Flags |= WSF_DYING;

    UserAssert(pwinsta->rpdeskList == NULL);

    /*
     * Free up the other resources
     */

    if (!(pwinsta->dwWSF_Flags & WSF_NOIO) && (gpEventSwitchDesktop != NULL)) {
        KeSetEvent(gpEventSwitchDesktop, EVENT_INCREMENT, FALSE);
        ObDereferenceObject(gpEventSwitchDesktop);
        gpEventSwitchDesktop = NULL;
    }

    BEGIN_REENTERCRIT();

    RtlDestroyAtomTable(pwinsta->pGlobalAtomTable);

    ForceEmptyClipboard(pwinsta);

    /*
     * Free up keyboard layouts
     */
    if (!(pwinsta->dwWSF_Flags & WSF_NOIO) && pwinsta->spklList != NULL) {

        PKL pkl = pwinsta->spklList;
        PKL pklFirst = pkl;

        RIPMSG2(RIP_WARNING, "FreeWindowStation: pwinsta(%p)->spklList is not NULL, %p", pwinsta, pwinsta->spklList);

        do {
            PKL pklNext = pkl->pklNext;

            HMMarkObjectDestroy(pkl);
            pkl->dwKL_Flags |= KL_UNLOADED;

            Lock(&pwinsta->spklList, pklNext);

            pkl = pklNext;

        } while (pkl != pkl->pklNext && pkl != pklFirst);

        Unlock(&pwinsta->spklList);

        HYDRA_HINT(HH_KBDLYOUTFREEWINSTA);

        /*
         * make sure the logon notify window went away
         */
        UserAssert(gspwndLogonNotify == NULL);
    } else {
        UserAssert(pwinsta->spklList == NULL);
    }

    /*
     * Free the USER sid
     */
    if (pwinsta->psidUser != NULL) {
        UserFreePool(pwinsta->psidUser);
        pwinsta->psidUser = NULL;
    }

    /*
     * Dereference gWinstaRunRef, because it was referenced at WindowStation
     * creation time in xxxCreateWindowStation().
     */
    ExReleaseRundownProtection(&gWinstaRunRef);

    END_REENTERCRIT();

    return STATUS_SUCCESS;
}

/***************************************************************************\
* DestroyWindowStation
*
* Removes the windowstation from the global list.  We can't release
* any resources until all locks have been removed.
* station.
*
* History:
* 01-17-91 JimA         Created.
\***************************************************************************/

NTSTATUS DestroyWindowStation(
    PKWIN32_CLOSEMETHOD_PARAMETERS pCloseParams )
{
    PWINDOWSTATION pwinsta = pCloseParams->Object;
    PWINDOWSTATION *ppwinsta;
    PDESKTOP pdesk;
    PDESKTOP pdeskLock = NULL;

    UserAssert(OBJECT_TO_OBJECT_HEADER(pCloseParams->Object)->Type == *ExWindowStationObjectType);

    /*
     * If this is not the last handle, leave
     */
    if (pCloseParams->SystemHandleCount != 1)
        return STATUS_SUCCESS;

    BEGIN_REENTERCRIT();

    /*
     * If the window station was linked into the terminal's list,
     * go ahead and unlink it.
     */
    for (ppwinsta = &grpWinStaList;
            *ppwinsta != NULL && pwinsta != *ppwinsta;
            ppwinsta = &(*ppwinsta)->rpwinstaNext)
        ;
    if (*ppwinsta != NULL) {
        UnlockWinSta(ppwinsta);
        /*
         * Assert that unlocking it didn't destroy it.
         */
        UserAssert(OBJECT_TO_OBJECT_HEADER(pCloseParams->Object)->Type == *ExWindowStationObjectType);

        *ppwinsta = pwinsta->rpwinstaNext;
        /*
         * The instruction above transfered rpwinstaNext lock ownership to the previous
         *  element in the list. Hence the value in pwinsta can no longer be considered valid.
         */
        pwinsta->rpwinstaNext = NULL;
    }

    /*
     * Notify all console threads and wait for them to
     * terminate.
     */
    pdesk = pwinsta->rpdeskList;
    while (pdesk != NULL) {
        if (pdesk != grpdeskLogon && pdesk->dwConsoleThreadId) {
            LockDesktop(&pdeskLock, pdesk, LDL_FN_DESTROYWINDOWSTATION, 0);
            TerminateConsole(pdesk);

            /*
             * Restart scan in case desktop list has changed
             */
            pdesk = pwinsta->rpdeskList;
            UnlockDesktop(&pdeskLock, LDU_FN_DESTROYWINDOWSTATION, 0);
        } else
            pdesk = pdesk->rpdeskNext;
    }

    END_REENTERCRIT();

    return STATUS_SUCCESS;

}


/***************************************************************************\
* WindowStationOpenProcedure
*
* History:
* 06-11-01 GerardoB         Created for instrumentation/debugging purposes.
\***************************************************************************/
NTSTATUS WindowStationOpenProcedure(
    PKWIN32_OPENMETHOD_PARAMETERS pOpenParams)
{

    UNREFERENCED_PARAMETER(pOpenParams);

    #if 0

    /*
     * Stop if someone is openning a windowstation handle cross session.
     */
    if ((pOpenParams->Process != NULL) 
        && (PsGetProcessSessionId(pOpenParams->Process) != gSessionId)
        && KD_DEBUGGER_ENABLED) {

            DbgBreakPoint();
    }

    #endif

    return STATUS_SUCCESS;

}
/***************************************************************************\
* ParseWindowStation
*
* Parse a windowstation path.
*
* History:
* 06-14-95 JimA         Created.
\***************************************************************************/

NTSTATUS ParseWindowStation(
    PKWIN32_PARSEMETHOD_PARAMETERS pParseParams )
{
    PWINDOWSTATION pwinsta = pParseParams->ParseObject;

    UserAssert(OBJECT_TO_OBJECT_HEADER(pParseParams->ParseObject)->Type == *ExWindowStationObjectType);

    /*
     * If nothing remains to be parsed, return the windowstation.
     */
    *(pParseParams->Object) = NULL;
    if (pParseParams->RemainingName->Length == 0) {
        if (pParseParams->ObjectType != *ExWindowStationObjectType)
            return STATUS_OBJECT_TYPE_MISMATCH;

        ObReferenceObject(pwinsta);
        *(pParseParams->Object) = pwinsta;
        return STATUS_SUCCESS;
    }

    /*
     * Skip leading path separator, if present.
     */
    if (*(pParseParams->RemainingName->Buffer) == OBJ_NAME_PATH_SEPARATOR) {
        pParseParams->RemainingName->Buffer++;
        pParseParams->RemainingName->Length -= sizeof(WCHAR);
        pParseParams->RemainingName->MaximumLength -= sizeof(WCHAR);
    }

    /*
     * Validate the desktop name.
     */
    if (wcschr(pParseParams->RemainingName->Buffer, L'\\'))
        return STATUS_OBJECT_PATH_INVALID;
    if (pParseParams->ObjectType == *ExDesktopObjectType) {
        return ParseDesktop(
               pParseParams->ParseObject,
               pParseParams->ObjectType,
               pParseParams->AccessState,
               pParseParams->AccessMode,
               pParseParams->Attributes,
               pParseParams->CompleteName,
               pParseParams->RemainingName,
               pParseParams->Context,
               pParseParams->SecurityQos,
               pParseParams->Object );

    }

    return STATUS_OBJECT_TYPE_MISMATCH;
}



/***************************************************************************\
* OkayToCloseWindowStation
*
* We can only close windowstation handles if they're not in use.
*
* History:
* 08-Feb-1999 JerrySh   Created.
\***************************************************************************/

NTSTATUS OkayToCloseWindowStation(
    PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS pOkCloseParams  )
{
    PWINDOWSTATION pwinsta = (PWINDOWSTATION)pOkCloseParams->Object;


    UserAssert(OBJECT_TO_OBJECT_HEADER(pOkCloseParams->Object)->Type == *ExWindowStationObjectType);

    /*
     * Kernel mode code can close anything.
     */
    if (pOkCloseParams->PreviousMode == KernelMode) {
        return STATUS_SUCCESS;
    }

    /*
     * We can't close a windowstation that's being used.
     */
    if (CheckHandleInUse(pOkCloseParams->Handle) ||
        CheckHandleFlag(pOkCloseParams->Process, pwinsta->dwSessionId, pOkCloseParams->Handle, HF_PROTECTED)) {
        RIPMSG1(RIP_WARNING, "Trying to close windowstation %#p while still in use", pwinsta);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* _OpenWindowStation
*
* Open a windowstation for the calling process
*
* History:
* 03-19-91 JimA         Created.
\***************************************************************************/
HWINSTA _OpenWindowStation(
    POBJECT_ATTRIBUTES pObjA,
    DWORD dwDesiredAccess,
    KPROCESSOR_MODE AccessMode)
{
    HWINSTA hwinsta;
    NTSTATUS Status;

    /*
     * Obja is client-side.  Ob interfaces protect and capture is
     * appropriate.
     */
    Status = ObOpenObjectByName(
            pObjA,
            *ExWindowStationObjectType,
            AccessMode,
            NULL,
            dwDesiredAccess,
            NULL,
            &hwinsta);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        hwinsta = NULL;
    }
    return hwinsta;
}

/***************************************************************************\
* _CloseWindowStation
*
* Closes a windowstation for the calling process
*
* History:
* 15-Jun-1999 JerrySh   Created.
\***************************************************************************/

BOOL _CloseWindowStation(
    HWINSTA hwinsta)
{
    HWINSTA hwinstaCurrent;

    _GetProcessWindowStation(&hwinstaCurrent);
    if (hwinsta != hwinstaCurrent) {
        return NT_SUCCESS(ZwClose(hwinsta));
    }
    return FALSE;
}

/***************************************************************************\
* xxxSetProcessWindowStation (API)
*
* Sets the windowstation of the calling process to the windowstation
* specified by pwinsta.
*
* History:
* 01-14-91 JimA         Created.
\***************************************************************************/

NTSTATUS
xxxSetProcessWindowStation(
    HWINSTA         hwinsta,
    KPROCESSOR_MODE AccessMode)
{
    PETHREAD                    Thread = PsGetCurrentThread();
    PEPROCESS                   Process = PsGetCurrentProcess();
    HWINSTA                     hwinstaDup, hwinstaProcess;
    NTSTATUS                    Status;
    PPROCESSINFO                ppi;
    PWINDOWSTATION              pwinsta;
    PWINDOWSTATION              pwinstaOld;
    OBJECT_HANDLE_INFORMATION   ohi;
    OBJECT_HANDLE_INFORMATION   ohiOld;

    if (Process == NULL) {
        UserAssert(Process);
        return STATUS_UNSUCCESSFUL;
    }

    if (Thread == NULL) {
        UserAssert(Thread);
        return STATUS_UNSUCCESSFUL;
    }

    ppi = PpiFromProcess(PsGetThreadProcess(Thread));

    Status = ObReferenceObjectByHandle(
            hwinsta,
            0,
            *ExWindowStationObjectType,
            AccessMode,
            &pwinsta,
            &ohi);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR1(Status, RIP_WARNING, "Failed to reference windowstation with Status = 0x%#lx",
                  Status);
        return Status;
    }

   /*
    * Bug 38780. Lock the handle to window station so that an app cannot free the
    * this handle by calling  GetProcessWindowStation() & CloseHandle()
    */

    /*
     * Unprotect the old hwinsta
     */
    if (ppi->hwinsta) {
        SetHandleFlag(ppi->hwinsta, HF_PROTECTED, FALSE);
    }

    /*
     * Save the WindowStation information
     */
    LockWinSta(&ppi->rpwinsta, pwinsta);
    ObDereferenceObject(pwinsta);
    ppi->hwinsta = hwinsta;

    /*
     * Protect the new Window Station Handle
     */
    SetHandleFlag(ppi->hwinsta, HF_PROTECTED, TRUE);

    /*
     * Check the old Atom Manager WindowStation to see if we are
     * changing this process' WindowStation.
     */
    hwinstaProcess = PsGetProcessWin32WindowStation(Process);
    if (hwinstaProcess != NULL) {
        /*
         * Get a pointer to the old WindowStation object to see if it's
         * the same WindowStation that we are setting.
         */
        Status = ObReferenceObjectByHandle(
            hwinstaProcess,
            0,
            *ExWindowStationObjectType,
            AccessMode,
            &pwinstaOld,
            &ohiOld);
        if (NT_SUCCESS(Status)) {
            /*
             * Are they different WindowStations?  If so, NULL out the
             * atom manager cache so we will reset it below.
             */
            if (pwinsta != pwinstaOld) {
                ZwClose(hwinstaProcess);
                PsSetProcessWindowStation(Process, NULL);
            }
            ObDereferenceObject(pwinstaOld);

        } else {
            /*
             * Their Atom Manager handle is bad?  Give them a new one.
             */
            PsSetProcessWindowStation(Process, NULL);
#if DBG
            RIPMSG2(RIP_WARNING,
                    "SetProcessWindowStation: Couldn't reference old WindowStation (0x%X) Status=0x%X",
                    hwinstaProcess,
                    Status);
#endif
        }
    }

    /*
     * Duplicate the WindowStation handle and stash it in the atom
     * manager's cache (Process->Win32WindowStation).  We duplicate
     * the handle in case
     */
    hwinstaProcess = PsGetProcessWin32WindowStation(Process);
    if (hwinstaProcess == NULL) {
        Status = xxxUserDuplicateObject(
                     NtCurrentProcess(),
                     hwinsta,
                     NtCurrentProcess(),
                     &hwinstaDup,
                     0,
                     0,
                     DUPLICATE_SAME_ACCESS);

        if (NT_SUCCESS(Status)) {
            PsSetProcessWindowStation(Process, hwinstaDup);
        }
#if DBG
        else {
            RIPMSG2(RIP_WARNING,
                    "SetProcessWindowStation: Couldn't duplicate WindowStation handle (0x%X) Status=0x%X",
                    hwinsta,
                    Status);
        }
#endif
    }

    ppi->amwinsta = ohi.GrantedAccess;

    /*
     * Cache WSF_NOIO flag in the W32PROCESS so that GDI can access it.
     */
    if (pwinsta->dwWSF_Flags & WSF_NOIO) {
        ppi->W32PF_Flags &= ~W32PF_IOWINSTA;
    } else {
        ppi->W32PF_Flags |= W32PF_IOWINSTA;
    }

    /*
     * Do the access check now for readscreen so that
     * blts off of the display will be as fast as possible.
     */
    if (RtlAreAllAccessesGranted(ohi.GrantedAccess, WINSTA_READSCREEN)) {
        ppi->W32PF_Flags |= W32PF_READSCREENACCESSGRANTED;
    } else {
        ppi->W32PF_Flags &= ~W32PF_READSCREENACCESSGRANTED;
    }

    return STATUS_SUCCESS;
}


/***************************************************************************\
* _GetProcessWindowStation (API)
*
* Returns a pointer to the windowstation of the calling process.
*
* History:
* 01-14-91 JimA         Created.
\***************************************************************************/

PWINDOWSTATION _GetProcessWindowStation(
    HWINSTA *phwinsta)
{
    PPROCESSINFO ppi;

    ppi = PpiCurrent();
    UserAssert(ppi);

    if (phwinsta)
        *phwinsta = ppi->hwinsta;
    return ppi->rpwinsta;
}


/***************************************************************************\
* _BuildNameList
*
* Builds a list of windowstation or desktop names.
*
* History:
* 05-17-94 JimA         Created.
* 10-21-96 CLupu        Added TERMINAL enumeration
\***************************************************************************/

NTSTATUS _BuildNameList(
    PWINDOWSTATION pwinsta,
    PNAMELIST      ccxpNameList,
    UINT           cbNameList,
    PUINT          pcbNeeded)
{
    PBYTE                    pobj;
    PWCHAR                   ccxpwchDest, ccxpwchMax;
    ACCESS_MASK              amDesired;
    POBJECT_HEADER           pHead;
    POBJECT_HEADER_NAME_INFO pNameInfo;
    DWORD                    iNext;
    NTSTATUS                 Status;
    CONST GENERIC_MAPPING *pGenericMapping;

/*
 * Note -- NameList is client-side, and so must be protected.
 */

    try {
        ccxpNameList->cNames = 0;
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_ACCESS_VIOLATION;
    }

    ccxpwchDest = ccxpNameList->awchNames;
    ccxpwchMax = (PWCHAR)((PBYTE)ccxpNameList + cbNameList - sizeof(WCHAR));

    /*
     * If we're enumerating windowstations, pwinsta is NULL.  Otherwise,
     * we're enumerating desktops.
     */
    if (pwinsta == NULL) {
        pobj  = (PBYTE)grpWinStaList;
        amDesired = WINSTA_ENUMERATE;
        pGenericMapping = &WinStaMapping;
        iNext = FIELD_OFFSET(WINDOWSTATION, rpwinstaNext);
    } else {
        pobj = (PBYTE)pwinsta->rpdeskList;
        amDesired = DESKTOP_ENUMERATE;
        pGenericMapping = &DesktopMapping;
        iNext = FIELD_OFFSET(DESKTOP, rpdeskNext);
    }

    Status = STATUS_SUCCESS;
    *pcbNeeded = 0;
    while (pobj != NULL) {

        if (AccessCheckObject(pobj, amDesired, KernelMode, pGenericMapping)) {

            /*
             * Find object name
             */
            pHead = OBJECT_TO_OBJECT_HEADER(pobj);
            pNameInfo = OBJECT_HEADER_TO_NAME_INFO(pHead);
            if(pNameInfo == NULL){
                goto NEXT_ITERATION;
            }

            /*
             * If we run out of space, reset the buffer
             * and continue so we can compute the needed
             * space.
             */
            if ((PWCHAR)((PBYTE)ccxpwchDest + pNameInfo->Name.Length +
                    sizeof(WCHAR)) >= ccxpwchMax) {
                *pcbNeeded += (UINT)((PBYTE)ccxpwchDest - (PBYTE)ccxpNameList);
                ccxpwchDest = ccxpNameList->awchNames;
                Status = STATUS_BUFFER_TOO_SMALL;
            }

            try {
                ccxpNameList->cNames++;

                /*
                 * Copy and terminate the string
                 */
                RtlCopyMemory(ccxpwchDest, pNameInfo->Name.Buffer,
                    pNameInfo->Name.Length);
                (PBYTE)ccxpwchDest += pNameInfo->Name.Length;
                *ccxpwchDest++ = 0;
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                return STATUS_ACCESS_VIOLATION;
            }
        }

        NEXT_ITERATION:
        pobj = *(PBYTE*)(pobj + iNext);
    }

    /*
     * Put an empty string on the end.
     */
    try {
        *ccxpwchDest++ = 0;

        ccxpNameList->cb = (UINT)((PBYTE)ccxpwchDest - (PBYTE)ccxpNameList);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        return STATUS_ACCESS_VIOLATION;
    }

    *pcbNeeded += (UINT)((PBYTE)ccxpwchDest - (PBYTE)ccxpNameList);

    return Status;
}

NTSTATUS ReferenceWindowStation(
    PETHREAD Thread,
    HWINSTA hwinsta,
    ACCESS_MASK amDesiredAccess,
    PWINDOWSTATION *ppwinsta,
    BOOL fUseDesktop)
{
    PPROCESSINFO ppi;
    PTHREADINFO pti;
    PWINDOWSTATION pwinsta = NULL;
    NTSTATUS Status;

    /*
     * We prefer to use the thread's desktop to dictate which
     * windowstation/Atom table to use rather than the process.
     * This allows NetDDE, which has threads running under
     * different desktops on different windowstations but whos
     * process is set to only one of these windowstations, to
     * get global atoms properly without having to change its
     * process windowstation a billion times and synchronize.
     */
    ppi = PpiFromProcess(PsGetThreadProcess(Thread));
    pti = PtiFromThread(Thread);

    /*
     * First, try to get the windowstation from the pti, and then
     * from the ppi.
     */
    if (ppi != NULL) {
        if (!fUseDesktop || pti == NULL || pti->rpdesk == NULL ||
                ppi->rpwinsta == pti->rpdesk->rpwinstaParent) {

            /*
             * Use the windowstation assigned to the process.
             */
            pwinsta = ppi->rpwinsta;
            if (pwinsta != NULL) {
                RETURN_IF_ACCESS_DENIED(ppi->amwinsta, amDesiredAccess,
                        STATUS_ACCESS_DENIED);
            }
        }

        /*
         * If we aren't using the process' windowstation, try to
         * go through the thread's desktop.
         */
        if (pwinsta == NULL && pti != NULL && pti->rpdesk != NULL) {

            /*
             * Perform access check the parent windowstation.  This
             * is an expensive operation.
             */
            pwinsta = pti->rpdesk->rpwinstaParent;
            if (!AccessCheckObject(pwinsta, amDesiredAccess, KernelMode, &WinStaMapping))
                return STATUS_ACCESS_DENIED;
        }
    }

    /*
     * If we still don't have a windowstation and a handle was
     * passed in, use it.
     */
    if (pwinsta == NULL) {
        if (hwinsta != NULL) {
            Status = ObReferenceObjectByHandle(
                    hwinsta,
                    amDesiredAccess,
                    *ExWindowStationObjectType,
                    KernelMode,
                    &pwinsta,
                    NULL);
            if (!NT_SUCCESS(Status))
                return Status;
            ObDereferenceObject(pwinsta);
        } else {
            return STATUS_NOT_FOUND;
        }
    }

    *ppwinsta = pwinsta;

    return STATUS_SUCCESS;
}

/***************************************************************************\
* _SetWindowStationUser
*
* Private API for winlogon to associate a windowstation with a user.
*
* History:
* 06-27-94 JimA         Created.
\***************************************************************************/
BOOL _SetWindowStationUser(
    PWINDOWSTATION pwinsta,
    PLUID pluidUser,
    PSID ccxpsidUser,
    DWORD cbsidUser)
{
    /*
     * Make sure the caller is the logon process
     */
    if (GetCurrentProcessId() != gpidLogon) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied in _SetWindowStationUser: caller must be in the logon process");

        return FALSE;
    }

    if (pwinsta->psidUser != NULL)
        UserFreePool(pwinsta->psidUser);

    if (ccxpsidUser != NULL) {
        pwinsta->psidUser = UserAllocPoolWithQuota(cbsidUser, TAG_SECURITY);
        if (pwinsta->psidUser == NULL) {
            RIPERR0(ERROR_OUTOFMEMORY,
                    RIP_WARNING,
                    "Memory allocation failed in _SetWindowStationUser");

            return FALSE;
        }
        try {
            RtlCopyMemory(pwinsta->psidUser, ccxpsidUser, cbsidUser);
        } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {

            UserFreePool(pwinsta->psidUser);
            pwinsta->psidUser = NULL;
            return FALSE;
        }
    } else {
        pwinsta->psidUser = NULL;
    }

    pwinsta->luidUser = *pluidUser;

    return TRUE;
}


/***************************************************************************\
* _LockWorkStation (API)
*
* locks the workstation. This API just posts a message to winlogon
* and winlogon does all the work
*
* History:
* 06-11-97 CLupu        Created.
\***************************************************************************/

BOOL _LockWorkStation(
    VOID)
{
    UserAssert(gspwndLogonNotify != NULL);

    _PostMessage(gspwndLogonNotify,
                 WM_LOGONNOTIFY, LOGON_LOCKWORKSTATION, LOCK_NORMAL);

    return TRUE;
}

#ifdef LATER    // HY
BOOL _IsIoDesktop(
    HDESK hdesk)
{
    BOOL fRet = FALSE;
    NTSTATUS Status;
    PDESKTOP pdesk = NULL;

    Status = ValidateHdesk(hdesk, UserMode, 0, &pdesk);
    if (NT_SUCCESS(Status)) {
        UserAssert(pdesk && pdesk->rpwinstaParent);
        fRet = (pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO) == 0;
        ObDereferenceObject(pdesk);
    }
    return fRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\winwhere.c ===
/****************************** Module Header ******************************\
* Module Name: winwhere.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 08-Nov-1990 DavidPe   Created.
* 23-Jan-1991 IanJa     Serialization: Handle revalidation added
* 19-Feb-1991 JimA      Added enum access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* LayerHitTest
*
* 9/21/1998        vadimg      created
\***************************************************************************/

__inline BOOL LayerHitTest(PWND pwnd, POINT pt)
{
    ASSERT(TestWF(pwnd, WEFLAYERED));

    if (TestWF(pwnd, WEFTRANSPARENT))
        return FALSE;

    if (!GrePtInSprite(gpDispInfo->hDev, PtoHq(pwnd), pt.x, pt.y))
        return FALSE;

    return TRUE;
}

/***************************************************************************\
* ChildWindowFromPoint (API)
*
* Returns NULL if pt is not in parent's client area at all,
* hwndParent if point is not over any children, and a child window if it is
* over a child.  Will return hidden and disabled windows if they are at the
* given point.
*
* History:
* 19-Nov-1990 DavidPe   Created.
* 19-Feb-1991 JimA      Added enum access check
\***************************************************************************/

PWND _ChildWindowFromPointEx(
    PWND  pwnd,
    POINT pt,
    UINT  uFlags)
{
    if (pwnd != PWNDDESKTOP(pwnd)) {
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            pt.x = pwnd->rcClient.right - pt.x;
        } else {
            pt.x += pwnd->rcClient.left;
        }
        pt.y += pwnd->rcClient.top;
    }

    // _ClientToScreen(pwndParent, (LPPOINT)&pt);

    if (PtInRect(&pwnd->rcClient, pt)) {

        PWND pwndChild;

        if (pwnd->hrgnClip != NULL) {
            if (!GrePtInRegion(pwnd->hrgnClip, pt.x, pt.y))
                return NULL;
        }

        if (TestWF(pwnd, WEFLAYERED)) {
            if (!LayerHitTest(pwnd, pt))
                return NULL;
        }
        
        /*
         * Enumerate the children, skipping disabled and invisible ones
         * if so desired.  Still doesn't work for WS_EX_TRANSPARENT windows.
         */
        for (pwndChild = pwnd->spwndChild;
                 pwndChild;
                 pwndChild = pwndChild->spwndNext) {

            /*
             * Skip windows as desired.
             */
            if ((uFlags & CWP_SKIPINVISIBLE) && !TestWF(pwndChild, WFVISIBLE))
                continue;

            if ((uFlags & CWP_SKIPDISABLED) && TestWF(pwndChild, WFDISABLED))
                continue;

            if ((uFlags & CWP_SKIPTRANSPARENT) && TestWF(pwndChild, WEFTRANSPARENT))
                continue;

            if (PtInRect(&pwndChild->rcWindow, pt)) {

                if (pwndChild->hrgnClip != NULL) {
                    if (!GrePtInRegion(pwndChild->hrgnClip, pt.x, pt.y))
                        continue;
                }
                if (TestWF(pwndChild, WEFLAYERED)) {
                    if (!LayerHitTest(pwndChild, pt))
                        continue;
                }
                return(pwndChild);
            }
        }

        return pwnd;
    }

    return NULL;
}

/***************************************************************************\
* xxxWindowFromPoint (API)
*
* History:
* 19-Nov-1990 DavidPe   Created.
* 19-Feb-1991 JimA      Added enum access check
\***************************************************************************/

PWND xxxWindowFromPoint(
    POINT pt)
{
    HWND hwnd;
    PWND pwndT;
    TL   tlpwndT;

    pwndT = _GetDesktopWindow();
    ThreadLock(pwndT, &tlpwndT);
    
    hwnd = xxxWindowHitTest2(pwndT, pt, NULL, WHT_IGNOREDISABLED);

    ThreadUnlock(&tlpwndT);

    return RevalidateHwnd(hwnd);
}

#ifdef REDIRECTION

/***************************************************************************\
* xxxCallSpeedHitTestHook
*
* Call the speed hit test hook to give the opportunity to the hook to fake
* where the mouse pointer is.
*
* 25-Jan-1999 CLupu   Created.
\***************************************************************************/

PWND xxxCallSpeedHitTestHook(POINT* ppt)
{
    PHOOK pHook;
    PWND  pwnd = NULL;

    /*
     * Call the hit test hooks to give them the opportunity to change
     * the coordinates and the hwnd
     */
    if ((pHook = PhkFirstValid(PtiCurrent(), WH_HITTEST)) != NULL) {
        HTHOOKSTRUCT ht;
        BOOL         bAnsiHook;

        ht.pt      = *ppt;
        ht.hwndHit = NULL;

        xxxCallHook2(pHook, HC_ACTION, 0, (LPARAM)&ht, &bAnsiHook);

        if (ht.hwndHit != NULL) {
            
            pwnd = HMValidateHandle(ht.hwndHit, TYPE_WINDOW);

            if (pwnd != NULL) {
                ppt->x = ht.pt.x;
                ppt->y = ht.pt.y;
            }
        }
    }
    return pwnd;
}

#endif // REDIRECTION

/***************************************************************************\
* SpeedHitTest
*
* This routine quickly finds out what top level window this mouse point
* belongs to. Used purely for ownership purposes.
*
* 12-Nov-1992 ScottLu   Created.
\***************************************************************************/

PWND SpeedHitTest(
    PWND   pwndParent,
    POINT  pt)
{
    PWND pwndT;
    PWND pwnd;

    if (pwndParent == NULL)
        return NULL;

    for (pwnd = pwndParent->spwndChild; pwnd != NULL; pwnd = pwnd->spwndNext) {

        /*
         * Are we looking at an hidden window?
         */
        if (!TestWF(pwnd, WFVISIBLE))
            continue;

        /*
         * Are we barking up the wrong tree?
         */
        if (!PtInRect((LPRECT)&pwnd->rcWindow, pt)) {
            continue;
        }

        /*
         * Check to see if in window region (if it has one)
         */
        if (pwnd->hrgnClip != NULL) {
            if (!GrePtInRegion(pwnd->hrgnClip, pt.x, pt.y))
                continue;
        }

        /*
         * Is this a sprite?
         */
        if (TestWF(pwnd, WEFLAYERED)) {
            if (!LayerHitTest(pwnd, pt))
                continue;
        }

#ifdef REDIRECTION
        if (TestWF(pwnd, WEFEXTREDIRECTED)) {
            continue;
        }
#endif // REDIRECTION

        /*
         * Children?
         */
        if ((pwnd->spwndChild != NULL) &&
                PtInRect((LPRECT)&pwnd->rcClient, pt)) {

            pwndT = SpeedHitTest(pwnd, pt);
            if (pwndT != NULL)
                return pwndT;
        }

        return pwnd;
    }

    return pwndParent;
}

/***************************************************************************\
* xxxWindowHitTest
*
* History:
* 08-Nov-1990 DavidPe   Ported.
* 28-Nov-1990 DavidPe   Add pwndTransparent support for HTTRANSPARENT.
* 25-Jan-1991 IanJa     change PWNDPOS parameter to int *
* 19-Feb-1991 JimA      Added enum access check
* 02-Nov-1992 ScottLu   Removed pwndTransparent.
* 12-Nov-1992 ScottLu   Took out fSendHitTest, fixed locking bug
\***************************************************************************/

HWND xxxWindowHitTest(
    PWND  pwnd,
    POINT pt,
    int   *piPos,
    DWORD dwHitTestFlags)
{
    HWND hwndT;
    TL   tlpwnd;

    CheckLock(pwnd);

    hwndT = NULL;
    ThreadLockNever(&tlpwnd);
    while (pwnd != NULL) {
        ThreadLockExchangeAlways(pwnd, &tlpwnd);
        hwndT = xxxWindowHitTest2(pwnd, pt, piPos, dwHitTestFlags);
        if (hwndT != NULL)
            break;

        pwnd = pwnd->spwndNext;
    }

    ThreadUnlock(&tlpwnd);
    return hwndT;
}

/***************************************************************************\
* xxxWindowHitTest2
*
* When this routine is entered, all windows must be locked.  When this
* routine returns a window handle, it locks that window handle and unlocks
* all windows.  If this routine returns NULL, all windows are still locked.
* Ignores disabled and hidden windows.
*
* History:
* 08-Nov-1990 DavidPe   Ported.
* 25-Jan-1991 IanJa     change PWNDPOS parameter to int *
* 19-Feb-1991 JimA      Added enum access check
* 12-Nov-1992 ScottLu   Took out fSendHitTest
\***************************************************************************/

HWND xxxWindowHitTest2(
    PWND  pwnd,
    POINT pt,
    int   *piPos,
    DWORD dwHitTestFlags)
{
    int  ht = HTERROR, htGrip=HTBOTTOMRIGHT;
    HWND hwndT;
    TL   tlpwndChild;

    CheckLock(pwnd);

    /*
     * Are we at the bottom of the window chain?
     */
    if (pwnd == NULL)
        return NULL;

    /*
     * Are we looking at an hidden window?
     */
    if (!TestWF(pwnd, WFVISIBLE))
        return NULL;

    /*
     * Are we barking up the wrong tree?
     */
    if (!PtInRect((LPRECT)&pwnd->rcWindow, pt)) {
        return NULL;
    }

    if (pwnd->hrgnClip != NULL) {
        if (!GrePtInRegion(pwnd->hrgnClip, pt.x, pt.y))
            return(NULL);
    }
    
    if (TestWF(pwnd, WEFLAYERED)) {
        if (!LayerHitTest(pwnd, pt))
            return NULL;
    }
    
#ifdef REDIRECTION
    /*
     * If this is called when the layered window is actually trying
     * to process the message then let it see the hit test
     */
    if (TestWF(pwnd, WEFEXTREDIRECTED) && PpiCurrent() != GETPTI(pwnd)->ppi) {
        return NULL;
    }
#endif // REDIRECTION

    /*
     * Are we looking at an disabled window?
     */
    if (TestWF(pwnd, WFDISABLED) && (dwHitTestFlags & WHT_IGNOREDISABLED)) {
        if (TestwndChild(pwnd)) {
            return NULL;
        } else {
            ht = HTERROR;
            goto Exit;
        }
    }

#ifdef SYSMODALWINDOWS
    /*
     * If SysModal window present and we're not in it, return an error.
     * Be sure to assign the point to the SysModal window, so the message
     * will be sure to be removed from the queue.
     */
    if (!CheckPwndFilter(pwnd, gspwndSysModal)) {
        pwnd = gspwndSysModal;

        /*
         * Fix notorious stack overflow bug (some WINABLE fix from Memphis)
         */
        ht = HTCLIENT;
        goto Exit;
    }
#endif

    /*
     * Are we on a minimized window?
     */
    if (!TestWF(pwnd, WFMINIMIZED)) {
        /*
         * Are we in the window's client area?
         */
        if (PtInRect((LPRECT)&pwnd->rcClient, pt)) {
            /*
             * Recurse through the children.
             */
            ThreadLock(pwnd->spwndChild, &tlpwndChild);
            hwndT = xxxWindowHitTest(pwnd->spwndChild,
                                     pt,
                                     piPos,
                                     dwHitTestFlags);
            
            ThreadUnlock(&tlpwndChild);
            if (hwndT != NULL)
                return hwndT;
        }

    }

    /*
     * If window not in same task, don't send WM_NCHITTEST.
     */
    if (GETPTI(pwnd) != PtiCurrent()) {
        ht = HTCLIENT;
        goto Exit;
    }

    /*
     * Send the message.
     */
    ht = (int)xxxSendMessage(pwnd, WM_NCHITTEST, 0, MAKELONG(pt.x, pt.y));

    /*
     * If window is transparent keep enumerating.
     */
    if (ht == HTTRANSPARENT) {
        return NULL;
    }

Exit:

    /*
     * Set wndpos accordingly.
     */
    if (piPos) {
        *piPos = ht;
    }

    /*
     * If this is a RTL mirrored window, then the grip is at
     * HTBOTTOMLEFT (in terms of screen coordinates since they are
     * not RTL mirrored).
     */
    if (TestWF(pwnd, WEFLAYOUTRTL)) {
        htGrip = HTBOTTOMLEFT;
    }

    /*
     * if the click is in the sizebox of the window and this window itself is
     * not sizable, return the window that will be sized by this sizebox
     */
    if ((ht == htGrip) && !TestWF(pwnd, WFSIZEBOX)) {

        PWND  pwndT;
         /*
          * SizeBoxHwnd() can return NULL!  We don't want to act like this
          * is transparent if the sizebox isn't a grip
          */
         pwnd = (pwndT = SizeBoxHwnd(pwnd)) ? pwndT : pwnd;
    }

    return HWq(pwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\wmicon.c ===
/***************************************************************************\
* Module Name: wmicon.c
*
* Icon Drawing Routines
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* 22-Jan-1991 MikeKe  from win30
* 13-Jan-1994 JohnL   rewrote from Chicago (m5)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define GetCWidth(cxOrg, lrF, cxDes) \
    (cxOrg ? cxOrg : ((lrF & DI_DEFAULTSIZE) ? SYSMET(CXICON) : cxDes))

#define GetCHeight(cyOrg, lrF, cyDes) \
    (cyOrg ? cyOrg : ((lrF & DI_DEFAULTSIZE) ? SYSMET(CYICON) : cyDes))

/***************************************************************************\
* BltIcon
*
* Note: We use the following DI flags to indicate what bitmap to draw:
* DI_IMAGE - render the color image bits (also known as XOR image)
* DI_MASK - render the mask bits (also known and AND image)
* DI_NORMAL - even though this is normally used to indicate that both the
*             mask and the image pieces of the icon should be rendered, it
*             is used here to indicate that the alpha channel should be
*             rendered.  See _DrawIconEx.
\***************************************************************************/
BOOL BltIcon(
    HDC     hdc,
    int     x,
    int     y,
    int     cx,
    int     cy,
    HDC     hdcSrc,
    PCURSOR pcur,
    UINT    diFlag,
    LONG    rop)
{
    HBITMAP hbmpSave;
    HBITMAP hbmpUse;
    LONG    rgbText;
    LONG    rgbBk;
    int     nMode;
    int     yBlt = 0;

    /*
     * Setup the DC for drawing
     */
    switch (diFlag) {
    default:
    case DI_IMAGE:
        hbmpUse = pcur->hbmColor;

        /*
         * If there isn't an explicit color bitmap, it is encoded
         * along with the mask, but in the second half.
         */
        if (NULL == hbmpUse) {
            hbmpUse = pcur->hbmMask;
            yBlt = pcur->cy / 2;
        }
        break;

    case DI_MASK:
        hbmpUse = pcur->hbmMask;
        break;

    case DI_NORMAL:
        UserAssert(pcur->hbmUserAlpha != NULL);
        hbmpUse = pcur->hbmUserAlpha;
        break;
    }

    rgbBk   = GreSetBkColor(hdc, 0x00FFFFFFL);
    rgbText = GreSetTextColor(hdc, 0x00000000L);
    nMode   = SetBestStretchMode(hdc, pcur->bpp, FALSE);

    hbmpSave = GreSelectBitmap(hdcSrc, hbmpUse);

    if (diFlag == DI_NORMAL) {
        BLENDFUNCTION bf;
        bf.BlendOp = AC_SRC_OVER;
        bf.BlendFlags = AC_MIRRORBITMAP;
        bf.SourceConstantAlpha = 0xFF;
        bf.AlphaFormat = AC_SRC_ALPHA;

        GreAlphaBlend(hdc,
                      x,
                      y,
                      cx,
                      cy,
                      hdcSrc,
                      0,
                      yBlt,
                      pcur->cx,
                      pcur->cy / 2,
                      bf,
                      NULL);
    }
    else {
        /*
         * Do the output to the surface.  By passing in (-1) as the background
         * color, we are telling GDI to use the background-color already set
         * in the DC.
         */
        GreStretchBlt(hdc,
                      x,
                      y,
                      cx,
                      cy,
                      hdcSrc,
                      0,
                      yBlt,
                      pcur->cx,
                      pcur->cy / 2,
                      rop,
                      (COLORREF)-1);
    }

    GreSetStretchBltMode(hdc, nMode);
    GreSetTextColor(hdc, rgbText);
    GreSetBkColor(hdc, rgbBk);

    GreSelectBitmap(hdcSrc, hbmpSave);

    return TRUE;
}

/***************************************************************************\
* DrawIconEx
*
* Draws icon in desired size.
*
\***************************************************************************/
BOOL _DrawIconEx(
    HDC     hdc,
    int     x,
    int     y,
    PCURSOR pcur,
    int     cx,
    int     cy,
    UINT    istepIfAniCur,
    HBRUSH  hbr,
    UINT    diFlags)
{
    BOOL fSuccess = FALSE;
    BOOL fAlpha = FALSE;
    LONG rop = (diFlags & DI_NOMIRROR) ? NOMIRRORBITMAP : 0;

    /*
     * If this is an animated cursor, just grab the ith frame and use it
     * for drawing.
     */
    if (pcur->CURSORF_flags & CURSORF_ACON) {

        if ((int)istepIfAniCur >= ((PACON)pcur)->cicur) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "DrawIconEx, icon step out of range.");
            goto Done;
        }

        pcur = ((PACON)pcur)->aspcur[((PACON)pcur)->aicur[istepIfAniCur]];
    }

    /*
     * We really want to draw an alpha icon if we can.  But we need to
     * respect the user's request to draw only the image or only the
     * mask.  We decide if we are, or are not, going to draw the icon
     * with alpha information here.
     */
    if (pcur->hbmUserAlpha != NULL && ((diFlags & DI_NORMAL) == DI_NORMAL)) {
        fAlpha = TRUE;
    }

    /*
     * Setup defaults.
     */
    cx = GetCWidth(cx, diFlags, pcur->cx);
    cy = GetCHeight(cy, diFlags, (pcur->cy / 2));

    if (hbr) {

        HBITMAP    hbmpT = NULL;
        HDC        hdcT;
        HBITMAP    hbmpOld;
        POLYPATBLT PolyData;

        if (hdcT = GreCreateCompatibleDC(hdc)) {

            if (hbmpT = GreCreateCompatibleBitmap(hdc, cx, cy)) {
                POINT pt;
                BOOL bRet;

                hbmpOld = GreSelectBitmap(hdcT, hbmpT);

                /*
                 * Set new dc's brush origin in same relative
                 * location as passed-in dc's.
                 */
                bRet = GreGetBrushOrg(hdc, &pt);
                /*
                 * Bug 292396 - joejo
                 * Stop overactive asserts by replacing with RIPMSG.
                 */
                if (bRet != TRUE) {
                    RIPMSG0(RIP_WARNING, "DrawIconEx, GreGetBrushOrg failed.");
                }

                bRet = GreSetBrushOrg(hdcT, pt.x, pt.y, NULL);
                if (bRet != TRUE) {
                    RIPMSG0(RIP_WARNING, "DrawIconEx, GreSetBrushOrg failed.");
                }

                PolyData.x         = 0;
                PolyData.y         = 0;
                PolyData.cx        = cx;
                PolyData.cy        = cy;
                PolyData.BrClr.hbr = hbr;

                bRet = GrePolyPatBlt(hdcT, PATCOPY, &PolyData, 1, PPB_BRUSH);
                if (bRet != TRUE) {
                    RIPMSG0(RIP_WARNING, "DrawIconEx, GrePolyPatBlt failed.");
                }
                
                /*
                 * Output the image to the temporary memoryDC.
                 */
                if (fAlpha) {
                    BltIcon(hdcT, 0, 0, cx, cy, ghdcMem, pcur, DI_NORMAL, rop | SRCCOPY);
                }
                else {
                    BltIcon(hdcT, 0, 0, cx, cy, ghdcMem, pcur, DI_MASK, rop | SRCAND);
                    BltIcon(hdcT, 0, 0, cx, cy, ghdcMem, pcur, DI_IMAGE, rop | SRCINVERT);
                }


                /*
                 * Blt the bitmap to the original DC.
                 */
                GreBitBlt(hdc, x, y, cx, cy, hdcT, 0, 0, SRCCOPY, (COLORREF)-1);

                GreSelectBitmap(hdcT, hbmpOld);

                bRet = GreDeleteObject(hbmpT);
                if (bRet != TRUE) {
                    RIPMSG0(RIP_WARNING, "DrawIconEx, GreDeleteObject failed. Possible Leak");
                }
                
                fSuccess = TRUE;
            }

            GreDeleteDC(hdcT);
        }

    } else {
        if (fAlpha) {
            BltIcon(hdc, x, y, cx, cy, ghdcMem, pcur, DI_NORMAL, rop | SRCCOPY);
        } else {
            if (diFlags & DI_MASK) {

                BltIcon(hdc,
                        x,
                        y,
                        cx,
                        cy,
                        ghdcMem,
                        pcur,
                        DI_MASK,
                        ((diFlags & DI_IMAGE) ? rop | SRCAND : rop | SRCCOPY));
            }

            if (diFlags & DI_IMAGE) {

                BltIcon(hdc,
                        x,
                        y,
                        cx,
                        cy,
                        ghdcMem,
                        pcur,
                        DI_IMAGE,
                        ((diFlags & DI_MASK) ? rop | SRCINVERT : rop | SRCCOPY));
            }
        }

        fSuccess = TRUE;
    }

Done:

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\xlate.c ===
/****************************** Module Header ******************************\
* Module Name: xlate.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 12-07-90 GregoryW      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/*
 * "The great artist is the simplifier."
 * - Henri Frederic Amiel (1821-1881)
 * Ibid., November 25, 1861
 */

/*
 * Determine the state of all the Modifier Keys (a Modifier Key
 * is any key that may modify values produced by other keys: these are
 * commonly SHIFT, CTRL and/or ALT)
 * Build a bit-mask (wModBits) to encode which modifier keys are depressed.
 */
WORD GetModifierBits(
    PMODIFIERS pModifiers,
    LPBYTE afKeyState)
{
    PVK_TO_BIT pVkToBit = pModifiers->pVkToBit;
    WORD wModBits = 0;

    CheckCritIn();

    while (pVkToBit->Vk) {
        if (TestKeyDownBit(afKeyState, pVkToBit->Vk)) {
            wModBits |= pVkToBit->ModBits;
        }
        pVkToBit++;
    }
    return wModBits;
}

/*
 * Given modifier bits, return the modification number.
 */
WORD GetModificationNumber(
    PMODIFIERS pModifiers,
    WORD wModBits)
{
    CheckCritInShared();
    if (wModBits > pModifiers->wMaxModBits) {
         return SHFT_INVALID;
    }

    return pModifiers->ModNumber[wModBits];
}

/*****************************************************************************\
* VKFromVSC
*
* This function is called from KeyEvent() after each call to VSCFromSC.  The
* keyboard input data passed in is translated to a virtual key code.
* This translation is dependent upon the currently depressed modifier keys.
*
* For instance, scan codes representing the number pad keys may be
* translated into VK_NUMPAD codes or cursor movement codes depending
* upon the state of NumLock and the modifier keys.
*
* History:
*
\*****************************************************************************/
BYTE VKFromVSC(
    PKE pke,
    BYTE bPrefix,
    LPBYTE afKeyState
    )
{
    USHORT usVKey;
    PVSC_VK pVscVk;
    PKBDTABLES pKbdTbl;
    static BOOL fVkPause;

    CheckCritIn();
    DBG_UNREFERENCED_PARAMETER(afKeyState);

    /*
     * Initialize as an unknown VK (unrecognised scancode)
     */
    pke->usFlaggedVk = usVKey = VK_UNKNOWN;

    /* HACK ALERT
     * For Korean 103 keyboard:
     * Check this is Korean keyboard layout or not.
     */
    if (IS_IME_ENABLED() &&
            KOREAN_KBD_LAYOUT(GetActiveHKL())) {
        if ((pke->bScanCode == 0x71) || (pke->bScanCode == 0x72)) {
            pke->bScanCode |= 0x80;
            bPrefix = 0xE0;
        } else {
            pke->bScanCode &= 0x7F;
        }
    } else {
        pke->bScanCode &= 0x7F;
    }

    if (gptiForeground == NULL) {
        RIPMSG0(RIP_VERBOSE, "VKFromVSC: NULL gptiForeground\n");
        pKbdTbl = gpKbdTbl;
    } else {
        if (gptiForeground->spklActive) {
            pKbdTbl = gptiForeground->spklActive->spkf->pKbdTbl;
        } else {
            RIPMSG0(RIP_VERBOSE, "VKFromVSC: NULL spklActive\n");
            pKbdTbl = gpKbdTbl;
        }
    }
    if (bPrefix == 0) {
        if (pke->bScanCode < pKbdTbl->bMaxVSCtoVK) {
            /*
             * direct index into non-prefix table
             */
            usVKey = pKbdTbl->pusVSCtoVK[pke->bScanCode];
            if (usVKey == 0) {
                return 0xFF;
            }
        } else {
            /*
             * unexpected scancode
             */
            RIPMSG2(RIP_VERBOSE, "unrecognized scancode 0x%x, prefix %x",
                    pke->bScanCode, bPrefix);
            return 0xFF;
        }
    } else {
        /*
         * Scan the E0 or E1 prefix table for a match
         */
        if (bPrefix == 0xE0) {
            /*
             * Set the KBDEXT (extended key) bit in case the scancode is not
             * found in the table (eg: FUJITSU POS keyboard #65436)
             */
            usVKey |= KBDEXT;
            /*
             * Ignore the SHIFT keystrokes generated by the hardware
             */
            if ((pke->bScanCode == SCANCODE_LSHIFT) ||
                    (pke->bScanCode == SCANCODE_RSHIFT)) {
                TAGMSG1(DBGTAG_KBD, "VKFromVSC: E0, %02x ignored", pke->bScanCode);
                return 0;
            }
            pVscVk = pKbdTbl->pVSCtoVK_E0;
        } else if (bPrefix == 0xE1) {
            pVscVk = pKbdTbl->pVSCtoVK_E1;
        } else {
            /*
             * Unrecognized prefix (from ScancodeMap?) produces an
             * unextended and unrecognized VK.
             */
            return 0xFF;
        }
        while (pVscVk->Vk) {
            if (pVscVk->Vsc == pke->bScanCode) {
                usVKey = pVscVk->Vk;
                break;
            }
            pVscVk++;
        }
    }

    /*
     * Scancode set 1 returns PAUSE button as E1 1D 45 (E1 Ctrl NumLock)
     * so convert E1 Ctrl to VK_PAUSE, and remember to discard the NumLock
     */
    if (fVkPause) {
        /*
         * This is the "45" part of the Pause scancode sequence.
         * Discard this key event: it is a false NumLock
         */
        fVkPause = FALSE;
        return 0;
    }
    if (usVKey == VK_PAUSE) {
        /*
         * This is the "E1 1D" part of the Pause scancode sequence.
         * Alter the scancode to the value Windows expects for Pause,
         * and remember to discard the "45" scancode that will follow
         */
        pke->bScanCode = 0x45;
        fVkPause = TRUE;
    }

    /*
     * Convert to a different VK if some modifier keys are depressed.
     */
    if (usVKey & KBDMULTIVK) {
        WORD nMod;
        PULONG pul;

        nMod = GetModificationNumber(
                   gpModifiers_VK,
                   GetModifierBits(gpModifiers_VK, gafRawKeyState));

        /*
         * Scan gapulCvt_VK[nMod] for matching VK.
         */
        if ((nMod != SHFT_INVALID) && ((pul = gapulCvt_VK[nMod]) != NULL)) {
            while (*pul != 0) {
                if (LOBYTE(*pul) == LOBYTE(usVKey)) {
                    pke->usFlaggedVk = (USHORT)HIWORD(*pul);
                    return (BYTE)pke->usFlaggedVk;
                }
                pul++;
            }
        }
    }

    pke->usFlaggedVk = usVKey;
    return (BYTE)usVKey;
}

/***************************************************************************\
* UINT InternalMapVirtualKeyEx(UINT wCode, UINT wType, PKBDTABLES pKbdTbl);
*
* History:
* IanJa 5/13/91  from Win3.1 \\pucus\win31ro!drivers\keyboard\getname.asm
* GregoryW 2/21/95  renamed from _MapVirtualKey and added third parameter.
\***************************************************************************/

UINT InternalMapVirtualKeyEx(
    UINT wCode,
    UINT wType,
    PKBDTABLES pKbdTbl)
{
    PVK_TO_WCHARS1 pVK;
    PVK_TO_WCHAR_TABLE pVKT;
    UINT VkRet = 0;
    USHORT usScanCode;
    PVSC_VK pVscVk;
    PBYTE pVkNumpad;

    switch (wType) {
    case 0:

        /*
         * Convert Virtual Key (wCode) to Scan Code
         */
        if ((wCode >= VK_SHIFT) && (wCode <= VK_MENU)) {

            /*
             * Convert ambiguous Shift/Control/Alt keys to left-hand keys
             */
            wCode = (UINT)((wCode - VK_SHIFT) * 2 + VK_LSHIFT);
        }

        /*
         * Scan through the table that maps Virtual Scancodes to Virtual Keys
         * for non-extended keys.
         */
        for (usScanCode = 0; usScanCode < pKbdTbl->bMaxVSCtoVK; usScanCode++) {
            if ((UINT)LOBYTE(pKbdTbl->pusVSCtoVK[usScanCode]) == wCode) {
                return usScanCode & 0xFF;
            }
        }

        /*
         * Scan through the table that maps Virtual Scancodes to Virtual Keys
         * for extended keys.
         */
        for (pVscVk = pKbdTbl->pVSCtoVK_E0; pVscVk->Vk; pVscVk++) {
            if ((UINT)LOBYTE(pVscVk->Vk) == wCode) {
                return (UINT)pVscVk->Vsc;
            }
        }

        /*
         * There was no match: maybe the Virtual Key can only be generated
         * with Numlock on. Scan through aVkNumpad[] to determine scancode.
         */
        for (pVkNumpad = aVkNumpad; *pVkNumpad != 0; pVkNumpad++) {
            if ((UINT)(*pVkNumpad) == wCode) {
                return (UINT)(pVkNumpad - aVkNumpad) + SCANCODE_NUMPAD_FIRST;
            }
        }

        return 0;   // No match found!

    case 1:
    case 3:

        /*
         * Convert Scan Code (wCode) to Virtual Key, disregarding modifier keys
         * and NumLock key etc.  Returns 0 for no corresponding Virtual Key
         */
        if (wCode < (UINT)(pKbdTbl->bMaxVSCtoVK)) {
            VkRet = (UINT)LOBYTE(pKbdTbl->pusVSCtoVK[wCode]);
        } else {
            /*
             * Scan the E0 prefix table for a match
             */
            for (pVscVk = pKbdTbl->pVSCtoVK_E0; pVscVk->Vk; pVscVk++) {
                if ((UINT)pVscVk->Vsc == wCode) {
                    VkRet = (UINT)LOBYTE(pVscVk->Vk);
                    break;
                }
            }
        }

        if ((wType == 1) && (VkRet >= VK_LSHIFT) && (VkRet <= VK_RMENU)) {

            /*
             * Convert left/right Shift/Control/Alt keys to ambiguous keys
             * (neither left nor right)
             */
            VkRet = (UINT)((VkRet - VK_LSHIFT) / 2 + VK_SHIFT);
        }

        if (VkRet == 0xFF) {
            VkRet = 0;
        }
        return VkRet;

    case 2:

        /*
         * Bogus Win3.1 functionality: despite SDK documenation, return uppercase for
         * VK_A through VK_Z
         */
        if ((wCode >= (WORD)'A') && (wCode <= (WORD)'Z')) {
            return wCode;
        }

        // HIWORD is no loner the wchar, due to app compat problems #287134
        // We should not return the wchar from pti->wchInjected that cached
        // at GetMessage time.
        // (delete this commented-out section by end of March 1999 - IanJa)
        //
        // if (LOWORD(wCode) == VK_PACKET) {
        //    return HIWORD(wCode);
        // }

        /*
         * Convert Virtual Key (wCode) to ANSI.
         * Search each Shift-state table in turn, looking for the Virtual Key.
         */
        for (pVKT = pKbdTbl->pVkToWcharTable; pVKT->pVkToWchars != NULL; pVKT++) {
            pVK = pVKT->pVkToWchars;
            while (pVK->VirtualKey != 0) {
                if ((UINT)pVK->VirtualKey == wCode) {

                    /*
                     * Match found: return the unshifted character
                     */
                    if (pVK->wch[0] == WCH_DEAD) {

                        /*
                         * It is a dead character: the next entry contains its
                         * value.  Set the high bit to indicate dead key
                         * (undocumented behaviour)
                         */
                        pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);
                        return pVK->wch[0] | (UINT)0x80000000;
                    } else if (pVK->wch[0] == WCH_NONE) {
                        return 0; // 9013
                    }
                    if (pVK->wch[0] == WCH_NONE) {
                        return 0;
                    }
                    return pVK->wch[0];
                }
                pVK = (PVK_TO_WCHARS1)((PBYTE)pVK + pVKT->cbSize);
            }
        }
    }

    /*
     * Can't find translation, or wType was invalid
     */
    return 0;
}

/***************************************************************************\
* _GetKeyNameText (API)
*
* int _GetKeyNameText(DWORD lParam, LPSTR lpStr, UINT size);
*
*   lParam: value from WM_KEYDOWN message, etc.
*
*       Byte 3 (bits 16..23) of lParam contains a scan code.
*
*       Bit 20 of lParam is the Extended bit (distingushes some keys on
*       Enhanced keyboard).
*
*       Bit 21 of lParam is a don't care bit (don't distingush between
*       left and right control, shift, Enter keys, between edit keys
*       in edit area and on numeric pad, etc).  The app calling this
*       function sets this bit in lParam, if it so desires.
*
*   lpStr:      Pointer to output string.
*
*   iSize:      Maximum length of output string, not including null byte.
*
* History:
* IanJa 4/11/91  from Win3.1 \\pucus\win31ro!drivers\keyboard\getname.asm
\***************************************************************************/

int APIENTRY _GetKeyNameText(
    LONG lParam,
    LPWSTR ccxlpStr,
    int cchSize)
{
    BYTE Vsc = LOBYTE(HIWORD(lParam));
    PVSC_LPWSTR pKN;
    PTHREADINFO ptiT = PtiCurrentShared();
    PKBDTABLES pKbdTbl;
    UINT Vk;
    UINT Char;

    /*
     * NOTE -- lpStr can be a client-side address, so access through it
     *    must be guarded with try blocks.
     */

    if (cchSize < 1)
        return 0;

    /*
     * If bit 25 set (don't care about left vs. right) then:
     * 1) convert right-Shift into left-Shift
     * 2) clear the extended bit for Ctrl and Alt only (effectively converting
     *    right-Ctrl & right-Alt into left-Ctrl & right-Alt)
     * For Windows '95 compatibility, the DONTCARE_BIT doesn't apply to other
     * extended keys (eg: NumPad cursor movement keys, NumPad Enter). Some
     * applications (Word '95) depend on this.  #37796
     */
    if (lParam & DONTCARE_BIT) {
        if (Vsc == SCANCODE_RSHIFT) {
           Vsc = SCANCODE_LSHIFT;
        }
        if (lParam & EXTENDED_BIT) {
            if ((Vsc == SCANCODE_CTRL) || (Vsc == SCANCODE_ALT)) {
                lParam &= ~EXTENDED_BIT;
            }
        }
        lParam &= ~DONTCARE_BIT;
    }

    if (ptiT->spklActive == (PKL)NULL) {
        return 0;
    }
    pKbdTbl = ptiT->spklActive->spkf->pKbdTbl;

    /*
     * Scan pKbdTbl->pKeyNames[] or pKeyNamesExt[] for matching Virtual Scan Code
     */
    if (lParam & EXTENDED_BIT) {
        pKN = pKbdTbl->pKeyNamesExt;
    } else {
        pKN = pKbdTbl->pKeyNames;
    }

    if (pKN) {
        while (pKN->vsc != 0) {
            if (Vsc == pKN->vsc) {

                try {
                    cchSize = wcsncpycch(ccxlpStr, pKN->pwsz, cchSize);
                    cchSize--;
                    ccxlpStr[cchSize] = L'\0';
                } except(W32ExceptionHandler(TRUE, RIP_ERROR)) {
                    return 0;
                }
                return cchSize;
            }
            pKN++;
        }
    }

    /*
     * The name of the key was not found in the table, so we
     * now attempt to construct the key name from the character produced by
     * the key.  Translate Scancode -> Virtual Key -> character.
     */

    /*
     * Translate Scancode to Virtual Key (ignoring modifier keys etc.)
     */
    Vk = InternalMapVirtualKeyEx((UINT)Vsc, 1, pKbdTbl);
    if (Vk == 0) {
        return 0;
    }

    /*
     * Now translate Virtual Key to character (ignoring modifier keys etc.)
     */
    Char = InternalMapVirtualKeyEx((UINT)Vk, 2, pKbdTbl);
    if (Char == 0) {
        return 0;
    }

    if (Char & 0x80000000) {
        LPWSTR *ppwsz;

        ppwsz = pKbdTbl->pKeyNamesDead;
        if (ppwsz) {
            while (*ppwsz != NULL) {
                if (*ppwsz[0] == (WCHAR)Char) {
                    try {
                        cchSize = wcsncpycch(ccxlpStr, (*ppwsz)+1, cchSize);
                        cchSize--;
                        ccxlpStr[cchSize] = L'\0';
                    } except(W32ExceptionHandler(TRUE, RIP_ERROR)) {
                        return 0;
                    }
                    return cchSize;
                }
                ppwsz++;
            }
        }
    }

    /*
     * Construct a single character name (adding null-terminator if possible)
     */
    try {
        ccxlpStr[0] = (WCHAR)Char;
        if (cchSize >= 2) {
            ccxlpStr[1] = L'\0';
        }
    } except(W32ExceptionHandler(TRUE, RIP_ERROR)) {
        return 0;
    }
    return 1;
}

/***************************************************************************\
* xxxAltGr() - handle special case Right-hand ALT key (Locale dependent)
*
* Note:  gbAltGrDown reminds us to send the fake Ctrl key back up if we
* switched to a non-AltGr layout while ALtGr was down: otherwise the Ctrl key
* gets stuck down.  (For example: using AltGr with KBDSEL to switch from
* German to US layout).
\***************************************************************************/
BOOL gbAltGrDown = FALSE;

VOID xxxAltGr(
    PKE pKe)
{
    if ((pKe->usFlaggedVk & 0xFF) != VK_RMENU) {
        return;
    }

    if (!(pKe->usFlaggedVk & KBDBREAK)) {
        /*
         * If neither CTRL key is down, then fake one going down so that
         * the right hand ALT key is converted to CTRL + ALT.
         */
        if (!TestRawKeyDown(VK_CONTROL)) {
            gbAltGrDown = TRUE;
            xxxKeyEvent(VK_LCONTROL, 0x1D | SCANCODE_SIMULATED,
                        pKe->dwTime, 0,
#ifdef GENERIC_INPUT    // LATER: NULL, or pKe->hDevice?
                        NULL,
                        NULL,
#endif
                        FALSE);
        }
    } else {
        /*
         * If the physical Left Ctrl key is not really down, fake the
         * Left Ctrl key coming back up (undo earlier faked Left Ctrl down)
         */
        gbAltGrDown = FALSE;
        if (!TestRawKeyDown(VK_LCONTROL)) {
            xxxKeyEvent(VK_LCONTROL | KBDBREAK, 0x1D | SCANCODE_SIMULATED,
                        pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                        NULL,
                        NULL,
#endif
                        FALSE);
        }
    }
}

/*****************************************************************************\
* xxxShiftLock()
*     handle ShiftLock feature, where only hitting Shift turns CapsLock off
*
\*****************************************************************************/
BOOL xxxShiftLock(
    PKE pKe)
{
    USHORT Vk;

    /*
     * We only mess with downstrokes: return TRUE to let it pass unmolested.
     */
    if (pKe->usFlaggedVk & KBDBREAK) {
        return TRUE;
    }

    Vk = pKe->usFlaggedVk & 0xFF;

    /*
     * If CapsLock is pressed when CapsLock is already on, lose the keystroke.
     */
    if ((Vk == VK_CAPITAL) && TestAsyncKeyStateToggle(VK_CAPITAL)) {
        return FALSE;
    }

    /*
     * If a Shift key goes down when CapsLock is on, turn CapsLock off
     * by simulating a click on the CapsLock key.
     * Let the Shift down through FIRST, since it might be part of an
     * input lang toggle (tough luck that this toggle turns off CapsLock!)
     */
    if (((Vk == VK_LSHIFT) || (Vk == VK_RSHIFT) || (Vk == VK_SHIFT)) &&
            TestAsyncKeyStateToggle(VK_CAPITAL)) {
        xxxKeyEvent(pKe->usFlaggedVk, pKe->bScanCode,
                    pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    FALSE);
        xxxKeyEvent(VK_CAPITAL, 0x3A | SCANCODE_SIMULATED,
                    pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    FALSE);
        xxxKeyEvent(VK_CAPITAL | KBDBREAK, 0x3A | SCANCODE_SIMULATED,
                    pKe->dwTime, 0,
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    FALSE);
        return FALSE;
    }

    return TRUE;
}

/*
 * Returning FALSE means the Key Event has been deleted by a special-case
 * KeyEvent processor.
 * Returning TRUE means the Key Event should be passed on (although it may
 * have been altered.
 */
BOOL KEOEMProcs(PKE pKe)
{
    int i;

    CheckCritIn();

    for (i = 0; aKEProcOEM[i] != NULL; i++) {
        if (!aKEProcOEM[i](pKe)) {
            /*
             * Eat the key event
             */
            return FALSE;
        }
    }

    /*
     * Pass the (possibly altered) key event on.
     */
    return TRUE;
}

/*
 * Returning FALSE means the Key Event has been deleted by a special-case
 * KeyEvent processor.
 * Returning TRUE means the Key Event should be passed on (although it may
 * have been altered.
 */
BOOL xxxKELocaleProcs(PKE pKe)
{
    CheckCritIn();

    /*
     * AltGr is a layout-specific behavior
     * Modifier keys are sent up as necessary in xxxInternalActivateKeyboardLayout
     * (#139178), so left-Ctrl won't be left stuck down if we switch from an
     * AltGr keyboard to a non-AltGr keybord while the AltGr is held down.
     */
    if ((gpKbdTbl->fLocaleFlags & KLLF_ALTGR) || gbAltGrDown) {
        xxxAltGr(pKe);
    }

    /*
     * ShiftLock/CapsLock is per-user (global) behavior as well as (for
     * backward compatibility) per-layout behavior.
     */
    if ((gdwKeyboardAttributes & KLLF_SHIFTLOCK) ||
            (gpKbdTbl->fLocaleFlags & KLLF_SHIFTLOCK)) {
        if (!xxxShiftLock(pKe)) {
            return FALSE;
        }
    }

    /*
     * Other special Key Event processors
     */

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\winmgr.c ===
/****************************** Module Header ******************************\
* Module Name: winmgr.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Core Window Manager APIs and support routines.
*
* History:
* 24-Sep-1990 darrinm   Generated stubs.
* 22-Jan-1991 IanJa     Handle revalidation added
* 19-Feb-1991 JimA      Added enum access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxFlashWindow (API)
*
* New for 5.0: HIWORD(dwFlags) contains the number of times the window should be
*              flashed. LOWORD(dwFlags) contains the FLASHW_ bits.
*
* History:
* 27-Nov-1990 DarrinM   Ported.
* 15-Nov-1997 MCostea   Added dwTimeout and windowing the maximised cmd
\***************************************************************************/
BOOL xxxFlashWindow(
    PWND pwnd,
    DWORD dwFlags,
    DWORD dwTimeout)
{

    BOOL fStatePrev = FALSE;
    BOOL fFlashOn;
    DWORD dwState;

    CheckLock(pwnd);
    /*
     * Get the previous state. If not available (FLASHW_STOP) then
     *  initialize on/off based on frame
     */
    dwState = GetFlashWindowState(pwnd);
    if (dwState == FLASHW_DONE) {
        /*
         * We just need to clean up and to set the activation correctly
         */
        dwState |= FLASHW_KILLTIMER;
        dwFlags = FLASHW_STOP;
        goto flash;
    }
    if (dwState == FLASHW_STOP) {
#if defined(_X86_)
        /*
         * If there is a fullscreen cmd window, switch it to window mode
         * so that the user gets a chance to see the flashing one
         */
        if (gbFullScreen == FULLSCREEN) {
            _PostMessage(gspwndFullScreen, CM_MODE_TRANSITION, (WPARAM)WINDOWED, (LPARAM)0);
        }
#endif // _X86_
        if (TestWF(pwnd, WFFRAMEON)) {
            dwState = FLASHW_ON | FLASHW_STARTON;
        }
    } else if (dwFlags == FLASHW_TIMERCALL) {
        dwFlags = dwState;
    }
    dwFlags &= FLASHW_CALLERBITS;
    fStatePrev = (dwState & FLASHW_ON);
    /*
     * Later5.0 Gerardob
     * Not sure why we do this check but it used to be here.
     */
    if (pwnd == gspwndAltTab) {
        return fStatePrev;
    }
    /*
     * Check if we're waiting to come to the foreground to stop.
     */
    if (dwState & FLASHW_FLASHNOFG) {
        if (gpqForeground == GETPTI(pwnd)->pq)
            dwFlags = FLASHW_STOP;
    }

flash:
    /*
     * Figure out new state
     */
    if (dwFlags != FLASHW_STOP) {
        fFlashOn =  !fStatePrev;
    } else {
        fFlashOn = (gpqForeground != NULL) && (gpqForeground->spwndActive == pwnd);
    }
    /*
     * Flash'em
     */
    if ((dwFlags == FLASHW_STOP) || (dwFlags & FLASHW_CAPTION)) {
        xxxSendMessage(pwnd, WM_NCACTIVATE, fFlashOn, 0L);
    }
    if ((dwFlags == FLASHW_STOP) || (dwFlags & FLASHW_TRAY)) {
        if (IsTrayWindow(pwnd)) {
            HWND hw = HWq(pwnd);
            BOOL fShellFlash;
            if (dwState & FLASHW_DONE) {
                /*
                 * If the window is not the active one when we're done flashing,
                 * let the tray icon remain activated.  The Shell  is going to
                 * take care to restore it at the when the window gets activated
                 */
                fShellFlash = !fFlashOn;
            } else {
                fShellFlash = (dwFlags == FLASHW_STOP ? FALSE : fFlashOn);
            }
            xxxCallHook(HSHELL_REDRAW, (WPARAM) hw, (LPARAM) fShellFlash, WH_SHELL);
            PostShellHookMessages(fShellFlash? HSHELL_FLASH:HSHELL_REDRAW, (LPARAM)hw);
        }
    }
    /*
     *  If we're to continue, check count, set timer and store
     *   state as appropriate. Otherwise, kill timer and remove
     *   state
     */
    if (dwFlags != FLASHW_STOP) {
        /*
         * If counting, decrement count when we complete a cycle
         */
        if (HIWORD(dwFlags) != 0) {
            dwState |= FLASHW_COUNTING;
            if (!(fFlashOn ^ !!(dwState & FLASHW_STARTON))) {
                dwFlags -= MAKELONG(0,1);
            }
            /*
             * Make sure we have a timer going.
             */
            if (!(dwState & FLASHW_KILLTIMER)) {
                dwFlags |= FLASHW_TIMER;
            }
        }
        /*
         * Set a timer if needed.
         */
        if (dwFlags & FLASHW_TIMER) {
            dwState |= FLASHW_KILLTIMER;
            InternalSetTimer(pwnd,
                             IDSYS_FLASHWND,
                             dwTimeout ? dwTimeout : gpsi->dtCaretBlink,
                             xxxSystemTimerProc,
                             TMRF_SYSTEM);
        }
        /*
         * Remember on/off state, propagate public flags
         *  and count then save the state
         */
        if (dwState & FLASHW_COUNTING &&
            HIWORD(dwFlags) == 0) {
            dwState = FLASHW_DONE;
        }
        else {
            SET_OR_CLEAR_FLAG(dwState, FLASHW_ON, fFlashOn);
            COPY_FLAG(dwState, dwFlags, FLASHW_CALLERBITS & ~FLASHW_TIMER);
        }
        SetFlashWindowState(pwnd, dwState);

    } else {
        /*
         * We're done.
         */
        if (dwState & FLASHW_KILLTIMER) {
            _KillSystemTimer(pwnd, IDSYS_FLASHWND);
        }
        RemoveFlashWindowState(pwnd);
    }

    return fStatePrev;
}

/***************************************************************************\
* xxxEnableWindow (API)
*
*
* History:
* 12-Nov-1990 DarrinM   Ported.
\***************************************************************************/

BOOL xxxEnableWindow(
    PWND pwnd,
    BOOL fEnable)
{
    BOOL fOldState, fChange;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if ((GETFNID(pwnd) == FNID_DESKTOP) ||
        (GETFNID(pwnd) == FNID_MESSAGEWND)) {
        return FALSE;
    }

    fOldState = TestWF(pwnd, WFDISABLED);

    if (!fEnable) {
        fChange = !TestWF(pwnd, WFDISABLED);

        xxxSendMessage(pwnd, WM_CANCELMODE, 0, 0);

        if (pwnd == PtiCurrent()->pq->spwndFocus) {
                xxxSetFocus(NULL);
        }
        SetWF(pwnd, WFDISABLED);

    } else {
        fChange = TestWF(pwnd, WFDISABLED);
        ClrWF(pwnd, WFDISABLED);
    }

    if (fChange) {
        xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_WINDOW,
                INDEXID_CONTAINER, 0);

        xxxSendMessage(pwnd, WM_ENABLE, fEnable, 0L);
    }

    return fOldState;
}

/***************************************************************************\
* xxxDoSend
*
* The following code is REALLY BOGUS!!!! Basically it prevents an
* app from hooking the WM_GET/SETTEXT messages if they're going to
* be called from another app.
*
* History:
* 04-Mar-1992 JimA  Ported from Win 3.1 sources.
\***************************************************************************/

LRESULT xxxDoSend(
    PWND  pwnd,
    UINT  message,
    WPARAM wParam,
    LPARAM lParam)
{
    /*
     * We compare PROCESSINFO sturctures here so multi-threaded
     * app can do what the want.
     */
    if (GETPTI(pwnd)->ppi == PtiCurrent()->ppi) {
        return xxxSendMessage(pwnd, message, wParam, lParam);
    } else {
        return xxxDefWindowProc(pwnd, message, wParam, lParam);
    }
}

/***************************************************************************\
* xxxGetWindowText (API)
*
*
* History:
* 09-Nov-1990 DarrinM   Wrote.
\***************************************************************************/

int xxxGetWindowText(
    PWND   pwnd,
    LPTSTR psz,
    int    cchMax)
{
    LARGE_UNICODE_STRING str;
    UINT nRet, nLen;

    CheckLock(pwnd);

    if (cchMax) {
        /*
         * Initialize string empty, in case xxxSendMessage aborts validation
         * If a bogus value was returned, rely on str.Length
         */
        str.bAnsi         = FALSE;
        str.MaximumLength = cchMax * sizeof(WCHAR);
        str.Buffer        = psz;
        str.Length        = 0;

        *psz = TEXT('\0');

        nRet = (UINT)xxxDoSend(pwnd, WM_GETTEXT, cchMax, (LPARAM)&str);
        nLen = str.Length / sizeof(WCHAR);
        return (nRet > nLen) ? nLen : nRet;
    }

    return 0;
}

/***************************************************************************\
* xxxSetParent (API)
*
* Change a windows parent to a new window.  These steps are taken:
*
* 1. The window is hidden (if visible),
* 2. Its coordinates are mapped into the new parent's space such that the
*    window's screen-relative position is unchanged.
* 3. The window is unlinked from its old parent and relinked to the new.
* 4. xxxSetWindowPos is used to move the window to its new position.
* 5. The window is shown again (if originally visible)
*
* NOTE: If you have a child window and set its parent to be NULL (the
* desktop), the WS_CHILD style isn't removed from the window. This bug has
* been in windows since 2.x. It turns out the apps group depends on this for
* their combo boxes to work.  Basically, you end up with a top level window
* that never gets activated (our activation code blows it off due to the
* WS_CHILD bit).
*
* History:
* 12-Nov-1990 DarrinM   Ported.
* 19-Feb-1991 JimA      Added enum access check
* 12-Apr-2001 Mohamed   Added the check of parenting your owner.
\***************************************************************************/

PWND xxxSetParent(
    PWND pwnd,
    PWND pwndNewParent)
{
    POINT pt;
    BOOL  fVisible;
    PWND  pwndOldParent;
    TL    tlpwndOldParent;
    TL    tlpwndNewParent;
    PVOID pvRet;
    PWND  pwndDesktop;
    PWND  pwndT;
    int flags = SWP_NOZORDER | SWP_NOSIZE;

    CheckLock(pwnd);
    CheckLock(pwndNewParent);

    if (!ValidateParentDepth(pwnd, pwndNewParent)) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Exceeded nested children limit");
        return NULL;
    }

    pwndDesktop = PWNDDESKTOP(pwnd);

    /*
     * In 1.0x, an app's parent was null, but now it is pwndDesktop.
     * Need to remember to lock pwndNewParent because we're reassigning
     * it here.
     */
    if (pwndNewParent == NULL)
        pwndNewParent = pwndDesktop;

    /*
     * Don't ever change the parent of the desktop.
     */
    if ((pwnd == pwndDesktop) || (pwnd == PWNDMESSAGE(pwnd))) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_WARNING,
                "Access denied: can't change parent of the desktop");

        return NULL;
    }

    /*
     * Don't let the window become its own parent, grandparent, etc.
     */
    for (pwndT = pwndNewParent; pwndT != NULL; pwndT = pwndT->spwndParent) {

        if (pwnd == pwndT) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING,
                  "Attempting to create a parent-child relationship loop.");
            return NULL;
        }
    }

    /*
     * Don't let the window become the parent of its owner, or of its owner's
     * owner, etc.  This throws ZOrderByOwner2 into an infinite loop.
     */
    for (pwndT = pwndNewParent->spwndOwner; pwndT != NULL; pwndT = pwndT->spwndOwner) {
        if (pwnd == pwndT) {
            RIPERR0(ERROR_INVALID_PARAMETER,
                    RIP_WARNING,
                    "Attempting to create a parent-owner relationship loop.");
            return NULL;
        }
    }

    /*
     * We still need pwndNewParent across callbacks...  and even though
     * it was passed in, it may have been reassigned above.
     */
    ThreadLock(pwndNewParent, &tlpwndNewParent);

    /*
     * Make the thing disappear from original parent.
     */
    fVisible = xxxShowWindow(pwnd, MAKELONG(SW_HIDE, TEST_PUDF(PUDF_ANIMATE)));

    /*
     * Ensure that the window being changed and the new parent
     * are not in a destroyed state.
     *
     * IMPORTANT: After this check, do not leave the critical section
     * until the window links have been rearranged.
     */
    if (TestWF(pwnd, WFDESTROYED) || TestWF(pwndNewParent, WFDESTROYED)) {
        ThreadUnlock(&tlpwndNewParent);
        return NULL;
    }

    pwndOldParent = pwnd->spwndParent;
    ThreadLock(pwndOldParent, &tlpwndOldParent);

    if (TestWF(pwndOldParent, WEFLAYOUTRTL)) {
        pt.x = pwnd->rcWindow.right;
    } else {
        pt.x = pwnd->rcWindow.left;
    }
    pt.y = pwnd->rcWindow.top;
    _ScreenToClient(pwndOldParent, &pt);

    UnlinkWindow(pwnd, pwndOldParent);
    Lock(&pwnd->spwndParent, pwndNewParent);

    if (pwndNewParent == PWNDDESKTOP(pwnd) && !TestWF(pwnd, WEFTOPMOST)) {

        /*
         * Make sure a child who's owner is topmost inherits the topmost
         * bit. - win31 bug 7568
         */
        if (TestWF(pwnd, WFCHILD) &&
            (pwnd->spwndOwner) &&
            TestWF(pwnd->spwndOwner, WEFTOPMOST)) {

            SetWF(pwnd, WEFTOPMOST);
        }

        /*
         * BACKWARD COMPATIBILITY HACK ALERT
         *
         * All top level windows must be WS_CLIPSIBLINGs bit set.
         * The SDM ComboBox() code calls SetParent() with a listbox
         * window that does not have this set.  This causes problems
         * with InternalInvalidate2() because it does not subtract off
         * the window from the desktop's update region.
         *
         * We must invalidate the DC cache here, too, because if there is
         * a cache entry lying around, its clipping region will be incorrect.
         */
        if ((pwndNewParent == _GetDesktopWindow()) &&
            !TestWF(pwnd, WFCLIPSIBLINGS)) {

            SetWF(pwnd, WFCLIPSIBLINGS);
            zzzInvalidateDCCache(pwnd, IDC_DEFAULT);
        }

        /*
         * This is a top level window but it isn't a topmost window so we
         * have to link it below all topmost windows.
         */
        LinkWindow(pwnd,
                   CalcForegroundInsertAfter(pwnd),
                   pwndNewParent);
    } else {

        /*
         * If this is a child window or if this is a TOPMOST window, we can
         * link at the head of the parent chain.
         */
        LinkWindow(pwnd, NULL, pwndNewParent);
    }

    /*
     * If we're a child window, do any necessary attaching and
     * detaching.
     */
    if (TestwndChild(pwnd)) {

        /*
         * Make sure we're not a WFCHILD window that got SetParent()'ed
         * to the desktop.
         */
        if ((pwnd->spwndParent != PWNDDESKTOP(pwnd)) &&
            GETPTI(pwnd) != GETPTI(pwndOldParent)) {

            zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwndOldParent), FALSE);
        }

        /*
         * If the new parent window is on a different thread, and also
         * isn't the desktop window, attach ourselves appropriately.
         */
        if (pwndNewParent != PWNDDESKTOP(pwnd) &&
            GETPTI(pwnd) != GETPTI(pwndNewParent)) {

            zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwndNewParent), TRUE);
        }
    }


    /*
     * If we are moving under a WS_EX_COMPOSITED parent-chain, we need to turn
     * off any child windows in the subtree that are WS_EX_COMPOSITED.
     */

    if (GetStyleWindow(pwnd->spwndParent, WEFCOMPOSITED) != NULL) {
        xxxTurnOffCompositing(pwnd, FALSE);
    }


    if (pwndNewParent == PWNDMESSAGE(pwnd) || pwndOldParent == PWNDMESSAGE(pwnd))
        flags |= SWP_NOACTIVATE;

    xxxWindowEvent(EVENT_OBJECT_PARENTCHANGE, pwnd, OBJID_WINDOW,
            INDEXID_CONTAINER, WEF_USEPWNDTHREAD);

    /*
     * We mustn't return an invalid pwndOldParent
     */
    xxxSetWindowPos(pwnd, NULL, pt.x, pt.y, 0, 0, flags);

    if (fVisible) {
        xxxShowWindow(pwnd, MAKELONG(SW_SHOWNORMAL, TEST_PUDF(PUDF_ANIMATE)));
    }

    /*
     * returns pwndOldParent if still valid, else NULL.
     */
    pvRet = ThreadUnlock(&tlpwndOldParent);
    ThreadUnlock(&tlpwndNewParent);

    return pvRet;
}

/***************************************************************************\
* xxxFindWindowEx (API)
*
* Searches for a window among top level windows. The keys used are pszClass,
* (the class name) and/or pszName, (the window title name). Either can be
* NULL.
*
* History:
* 06-Jun-1994 JohnL     Converted xxxFindWindow to xxxFindWindowEx
* 10-Nov-1992 mikeke    Added 16bit and 32bit only flag
* 24-Sep-1990 DarrinM   Generated stubs.
* 02-Jun-1991 ScottLu   Ported from Win3.
* 19-Feb-1991 JimA      Added enum access check
\***************************************************************************/

#define CCHMAXNAME 80

PWND _FindWindowEx(
    PWND   pwndParent,
    PWND   pwndChild,
    LPCWSTR ccxlpszClass,
    LPCWSTR ccxlpszName,
    DWORD  dwType)
{
    /*
     * Note that the Class and Name pointers are client-side addresses.
     */

    PBWL    pbwl;
    HWND    *phwnd;
    PWND    pwnd;
    WORD    atomClass = 0;
    LPCWSTR lpName;
    BOOL    fTryMessage = FALSE;

    if (ccxlpszClass != NULL) {
        /*
         * note that we do a version-less check here, then call FindClassAtom right away.
         */
        atomClass = FindClassAtom(ccxlpszClass);
        if (atomClass == 0) {
            return NULL;
        }
    }

    /*
     * Setup parent window
     */
    if (!pwndParent) {
        pwndParent = _GetDesktopWindow();
        /*
         * If we are starting from the root and no child window
         * was specified, then check the message window tree too
         * in case we don't find it on the desktop tree.
         */

        if (!pwndChild)
            fTryMessage = TRUE;
    }

TryAgain:
    /*
     * Setup first child
     */
    if (!pwndChild) {
        pwndChild = pwndParent->spwndChild;
    } else {
        if (pwndChild->spwndParent != pwndParent) {
            RIPMSG0(RIP_WARNING,
                 "FindWindowEx: Child window doesn't have proper parent");
            return NULL;
        }

        pwndChild = pwndChild->spwndNext;
    }

    /*
     * Generate a list of top level windows.
     */
    if ((pbwl = BuildHwndList(pwndChild, BWL_ENUMLIST, NULL)) == NULL) {
        return NULL;
    }

    /*
     * Set pwnd to NULL in case the window list is empty.
     */
    pwnd = NULL;

    try {
        for (phwnd = pbwl->rghwnd; *phwnd != (HWND)1; phwnd++) {

            /*
             * Validate this hwnd since we left the critsec earlier (below
             * in the loop we send a message!
             */
            if ((pwnd = RevalidateHwnd(*phwnd)) == NULL)
                continue;

            /*
             * make sure this window is of the right type
             */
            if (dwType != FW_BOTH) {
                if (((dwType == FW_16BIT) && !(GETPTI(pwnd)->TIF_flags & TIF_16BIT)) ||
                    ((dwType == FW_32BIT) && (GETPTI(pwnd)->TIF_flags & TIF_16BIT)))
                    continue;
            }

            /*
             * If the class is specified and doesn't match, skip this window
             * note that we do a version-less check here, use pcls->atomNVClassName
             */
            if (!atomClass || (atomClass == pwnd->pcls->atomNVClassName)) {
                if (!ccxlpszName)
                    break;

                if (pwnd->strName.Length) {
                    lpName = pwnd->strName.Buffer;
                } else {
                    lpName = szNull;
                }

                /*
                 * Is the text the same? If so, return with this window!
                 */
                if (_wcsicmp(ccxlpszName, lpName) == 0)
                    break;
            }

            /*
             * The window did not match.
             */
            pwnd = NULL;
        }
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        pwnd = NULL;
    }

    FreeHwndList(pbwl);

    if (!pwnd && fTryMessage) {
        fTryMessage = FALSE;
        pwndParent = _GetMessageWindow();
        pwndChild = NULL;
        goto TryAgain;
    }

    return ((*phwnd == (HWND)1) ? NULL : pwnd);
}

/***************************************************************************\
* UpdateCheckpoint
*
* Checkpoints the current window size/position/state and returns a pointer
* to the structure.
*
* History:
\***************************************************************************/

PCHECKPOINT UpdateCheckpoint(
    PWND pwnd)
{
    RECT rc;

    GetRect(pwnd, &rc, GRECT_WINDOW | GRECT_PARENTCOORDS);
    return CkptRestore(pwnd, &rc);
}

/***************************************************************************\
* GetWindowPlacement
*
* History:
* 02-Mar-1992 MikeKe    From Win 3.1
\***************************************************************************/

BOOL _GetWindowPlacement(
    PWND             pwnd,
    PWINDOWPLACEMENT pwp)
{
    CHECKPOINT * pcp;

    /*
     * this will set the normal or the minimize point in the checkpoint,
     * so that all elements will be up to date.
     */
    pcp = UpdateCheckpoint(pwnd);

    if (!pcp)
        return FALSE;

    if (TestWF(pwnd, WFMINIMIZED)) {
        pwp->showCmd = SW_SHOWMINIMIZED;
    } else if (TestWF(pwnd, WFMAXIMIZED)) {
        pwp->showCmd = SW_SHOWMAXIMIZED;
    } else {
        pwp->showCmd = SW_SHOWNORMAL;
    }

    CopyRect(&pwp->rcNormalPosition, &pcp->rcNormal);

    if (pcp->fMinInitialized) {
        pwp->ptMinPosition = pcp->ptMin;
    } else {
        pwp->ptMinPosition.x = pwp->ptMinPosition.y = -1;
    }

    /*
     * We never ever save the position of "normal" maximized windows.  Other
     * wise, when the size border changes dimensions, the max pos would be
     * invalid, and you would never be able to reset it.
     */
    if (pcp->fMaxInitialized && !TestWF(pwnd, WFREALLYMAXIMIZABLE)) {
        pwp->ptMaxPosition = pcp->ptMax;
    } else {
        pwp->ptMaxPosition.x = pwp->ptMaxPosition.y = -1;
    }

    if ((pwnd->spwndParent == PWNDDESKTOP(pwnd)) &&
            !TestWF(pwnd, WEFTOOLWINDOW)) {

        PMONITOR    pMonitor;

        pMonitor = _MonitorFromRect(&pwp->rcNormalPosition, MONITOR_DEFAULTTOPRIMARY);

        /*
         * Convert min, normal positions to be relative to the working area.
         * The max pos already is (always is saved that way).
         *
         * working area, except for maximized position, which is always
         * working area relative.
         */
        if (pcp->fMinInitialized) {
            pwp->ptMinPosition.x -= (pMonitor->rcWork.left - pMonitor->rcMonitor.left);
            pwp->ptMinPosition.y -= (pMonitor->rcWork.top - pMonitor->rcMonitor.top);
        }

        OffsetRect(&pwp->rcNormalPosition,
            pMonitor->rcMonitor.left - pMonitor->rcWork.left,
            pMonitor->rcMonitor.top - pMonitor->rcWork.top);
    }

    pwp->flags = 0;

    /*
     * B#3276
     * Don't allow WPF_SETMINPOSITION on top-level windows.
     */
    if (TestwndChild(pwnd) && pcp->fDragged)
        pwp->flags |= WPF_SETMINPOSITION;

    if (pcp->fWasMaximizedBeforeMinimized || TestWF(pwnd, WFMAXIMIZED))
        pwp->flags |= WPF_RESTORETOMAXIMIZED;

    pwp->length = sizeof(WINDOWPLACEMENT);

    return TRUE;
}

/***************************************************************************\
* CheckPlacementBounds
*
* History:
* 02-Mar-1992 MikeKe    From Win 3.1
\***************************************************************************/

VOID CheckPlacementBounds(
    LPRECT      lprc,
    LPPOINT     ptMin,
    LPPOINT     ptMax,
    PMONITOR    pMonitor)
{
    int xIcon;
    int yIcon;
    int sTop;
    int sBottom;
    int sLeft;
    int sRight;

    /*
     * Check Normal Window Placement
     */

    /*
     * Possible values for these sign variables are :
     * -1 : less than the minimum for that dimension
     *  0 : within the range for that dimension
     *  1 : more than the maximum for that dimension
     */
    sTop = (lprc->top < pMonitor->rcWork.top) ? -1 :
        ((lprc->top > pMonitor->rcWork.bottom) ? 1 : 0);

    sBottom = (lprc->bottom < pMonitor->rcWork.top) ? -1 :
        ((lprc->bottom > pMonitor->rcWork.bottom) ? 1 : 0);

    sLeft = (lprc->left < pMonitor->rcWork.left) ? -1 :
        ((lprc->left > pMonitor->rcWork.right) ? 1 : 0);

    sRight = (lprc->right < pMonitor->rcWork.left) ? -1 :
        ((lprc->right > pMonitor->rcWork.right) ? 1 : 0);

    if ((sTop * sBottom > 0) || (sLeft * sRight > 0)) {

        /*
         * Window is TOTALLY outside monitor bounds.  The resolution and/or
         * configuration of monitors probably changed since the last time
         * we ran this app.
         *
         * Slide it FULLY onto the monitor at the nearest position.
         */
        int size;

        if (sTop < 0) {
            lprc->bottom -= lprc->top;
            lprc->top     = pMonitor->rcWork.top;
        } else if (sBottom > 0) {
            size = lprc->bottom - lprc->top;
            lprc->top    = max(pMonitor->rcWork.bottom - size, pMonitor->rcWork.top);
            lprc->bottom = lprc->top + size;
        }

        if (sLeft < 0) {
            lprc->right -= lprc->left;
            lprc->left   = pMonitor->rcWork.left;
        } else if (sRight > 0) {
            size = lprc->right - lprc->left;
            lprc->left  = max(pMonitor->rcWork.right - size, pMonitor->rcWork.left);
            lprc->right = lprc->left + size;
        }
    }

    /*
     * Check Iconic Window Placement
     */
    if (ptMin->x != -1) {

        xIcon = SYSMET(CXMINSPACING);
        yIcon = SYSMET(CYMINSPACING);

        sTop = (ptMin->y < pMonitor->rcWork.top) ? -1 :
            ((ptMin->y > pMonitor->rcWork.bottom) ? 1 : 0);

        sBottom = (ptMin->y + yIcon < pMonitor->rcWork.top) ? -1 :
            ((ptMin->y + yIcon > pMonitor->rcWork.bottom) ? 1 : 0);

        sLeft = (ptMin->x < pMonitor->rcWork.left) ? -1 :
            ((ptMin->x > pMonitor->rcWork.right) ? 1 : 0);

        sRight = (ptMin->x + xIcon < pMonitor->rcWork.left) ? -1 :
            ((ptMin->x + xIcon > pMonitor->rcWork.right) ? 1 : 0);

        /*
         * Icon is TOTALLY outside monitor bounds; repark it.
         */
        if ((sTop * sBottom > 0) || (sLeft * sRight > 0))
            ptMin->x = ptMin->y = -1;
    }

    /*
     * Check Maximized Window Placement
     */
    if (ptMax->x != -1 &&
        (ptMax->x + pMonitor->rcWork.left >= pMonitor->rcWork.right ||
         ptMax->y + pMonitor->rcWork.top >= pMonitor->rcWork.bottom)) {

        /*
         * window is TOTALLY below beyond maximum dimensions; zero the
         * position so that the window will at least be clipped to the
         * monitor.
         */
        ptMax->x = 0;
        ptMax->y = 0;
    }
}

/***************************************************************************\
* WPUpdateCheckPointSettings
*
* History:
* 02/23/98  GerardoB    Extracted from xxxSetWindowPlacement
\***************************************************************************/
void WPUpdateCheckPointSettings (PWND pwnd, UINT uWPFlags)
{
    CHECKPOINT *    pcp;

    UserAssert(TestWF(pwnd, WFMINIMIZED));
    if (pcp = UpdateCheckpoint(pwnd)) {

        /*
         * Save settings in the checkpoint struct
         */
        if (uWPFlags & WPF_SETMINPOSITION)
            pcp->fDragged = TRUE;

        if (uWPFlags & WPF_RESTORETOMAXIMIZED) {
            pcp->fWasMaximizedBeforeMinimized = TRUE;
        } else {
            pcp->fWasMaximizedBeforeMinimized = FALSE;
        }
    }
}
/***************************************************************************\
* xxxSetWindowPlacement
*
* History:
* 02-Mar-1992 MikeKe    From Win 3.1
\***************************************************************************/

BOOL xxxSetWindowPlacement(
    PWND             pwnd,
    PWINDOWPLACEMENT pwp)
{
    CHECKPOINT *    pcp;
    PMONITOR        pMonitor;
    RECT            rc;
    POINT           ptMin;
    POINT           ptMax;
    BOOL            fMin;
    BOOL            fMax;
    UINT            uSWPFlags;
    BOOL            fRealAsync;

    CheckLock(pwnd);

    CopyRect(&rc, &pwp->rcNormalPosition);
    if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
        pMonitor = _MonitorFromRect(&rc, MONITOR_DEFAULTTOPRIMARY);
    }

    ptMin = pwp->ptMinPosition;
    fMin  = ((ptMin.x != -1) && (ptMin.y != -1));

    ptMax = pwp->ptMaxPosition;
    fMax  = ((ptMax.x != -1) && (ptMax.y != -1));

    /*
     * Convert back to working rectangle coordinates
     */
    if (    pwnd->spwndParent == PWNDDESKTOP(pwnd) &&
            !TestWF(pwnd, WEFTOOLWINDOW)) {

        OffsetRect(
                &rc,
                pMonitor->rcWork.left - pMonitor->rcMonitor.left,
                pMonitor->rcWork.top - pMonitor->rcMonitor.top);

        if (fMin) {
            ptMin.x += pMonitor->rcWork.left - pMonitor->rcMonitor.left;
            ptMin.y += pMonitor->rcWork.top - pMonitor->rcMonitor.top;
        }

        CheckPlacementBounds(&rc, &ptMin, &ptMax, pMonitor);
    }

    if (pcp = UpdateCheckpoint(pwnd)) {

        /*
         * Save settings in the checkpoint struct
         */
        CopyRect(&pcp->rcNormal, &rc);

        pcp->ptMin                        = ptMin;
        pcp->fMinInitialized              = fMin;
        pcp->fDragged                     = (pwp->flags & WPF_SETMINPOSITION) ?
                                                TRUE : FALSE;
        pcp->ptMax                        = ptMax;
        pcp->fMaxInitialized              = fMax;
        pcp->fWasMaximizedBeforeMinimized = FALSE;
    }

    /*
     * WPF_ASYNCWINDOWPLACEMENT new for NT5.
     */
    uSWPFlags = SWP_NOZORDER | SWP_NOACTIVATE
                | ((pwp->flags & WPF_ASYNCWINDOWPLACEMENT) ? SWP_ASYNCWINDOWPOS : 0);

    if (TestWF(pwnd, WFMINIMIZED)) {

        if ((!pcp || pcp->fDragged) && fMin) {
            xxxSetWindowPos(pwnd,
                            PWND_TOP,
                            ptMin.x,
                            ptMin.y,
                            0,
                            0,
                            SWP_NOSIZE | uSWPFlags);
        }

    } else if (TestWF(pwnd, WFMAXIMIZED)) {

        if (pcp != NULL) {
            if (TestWF(pwnd, WFREALLYMAXIMIZABLE))
                pcp->fMaxInitialized = FALSE;

            if (pcp->fMaxInitialized) {
                if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
                    ptMax.x += pMonitor->rcWork.left;
                    ptMax.y += pMonitor->rcWork.top;
                }

                xxxSetWindowPos(pwnd,
                                PWND_TOP,
                                ptMax.x,
                                ptMax.y,
                                0,
                                0,
                                SWP_NOSIZE | uSWPFlags);
            }
        }


    } else {

        xxxSetWindowPos(pwnd,
                        PWND_TOP,
                        rc.left,
                        rc.top,
                        rc.right - rc.left,
                        rc.bottom - rc.top,
                        uSWPFlags);
    }
    /*
     * xxxSetWindowPos is only assync when the window's thread is on a
     *  different queue than the current thread's. See AsyncWindowPos.
     */
    fRealAsync = (pwp->flags & WPF_ASYNCWINDOWPLACEMENT)
                    && (GETPTI(pwnd)->pq != PtiCurrent()->pq);

    if (fRealAsync) {
        _ShowWindowAsync(pwnd, pwp->showCmd, pwp->flags);
    } else {
        xxxShowWindow(pwnd, MAKELONG(pwp->showCmd, TEST_PUDF(PUDF_ANIMATE)));
    }

    if (TestWF(pwnd, WFMINIMIZED) && !fRealAsync) {
        WPUpdateCheckPointSettings(pwnd, pwp->flags);
    }

    return TRUE;
}

/***************************************************************************\
* xxxSetInternalWindowPos
*
* Sets a window to the size, position and state it was most recently
* in.  Side effect (possibly bug): shows and activates the window as well.
*
* History:
* 28-Mar-1991 DavidPe   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL xxxSetInternalWindowPos(
    PWND    pwnd,
    UINT    cmdShow,
    LPRECT  lprcWin,
    LPPOINT lpptMin)
{
    CHECKPOINT *    pcp;
    PMONITOR        pMonitor;

    CheckLock(pwnd);

    if ((pcp = UpdateCheckpoint(pwnd)) == NULL) {
        return FALSE;
    }

    if (lprcWin) {

        pcp->rcNormal = *lprcWin;
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            pMonitor = _MonitorFromRect(lprcWin, MONITOR_DEFAULTTOPRIMARY);
            OffsetRect(
                    &pcp->rcNormal,
                    pMonitor->rcWork.left - pMonitor->rcMonitor.left,
                    pMonitor->rcWork.top - pMonitor->rcMonitor.top);
        }
    }

    if (lpptMin && (lpptMin->x != -1)) {

        pcp->ptMin = *lpptMin;
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd)) {
            pMonitor = _MonitorFromRect(&pcp->rcNormal, MONITOR_DEFAULTTOPRIMARY);
            pcp->ptMin.x += pMonitor->rcWork.left - pMonitor->rcMonitor.left;
            pcp->ptMin.y += pMonitor->rcWork.top - pMonitor->rcMonitor.top;
        }

        pcp->fDragged = TRUE;
        pcp->fMinInitialized = TRUE;

    } else {
        pcp->fMinInitialized = FALSE;
        pcp->fDragged = FALSE;
    }

    if (TestWF(pwnd, WFMINIMIZED)) {

        /*
         * need to move the icon
         */
        if (pcp->fMinInitialized) {
            xxxSetWindowPos(pwnd,
                            PWND_TOP,
                            pcp->ptMin.x,
                            pcp->ptMin.y,
                            0,
                            0,
                            SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        }

    } else if (!TestWF(pwnd, WFMAXIMIZED) && lprcWin) {
        /*
         * need to set the size and the position
         */
        xxxSetWindowPos(pwnd,
                        NULL,
                        lprcWin->left,
                        lprcWin->top,
                        lprcWin->right - lprcWin->left,
                        lprcWin->bottom - lprcWin->top,
                        SWP_NOZORDER);
    }

    xxxShowWindow(pwnd, MAKELONG(cmdShow, TEST_PUDF(PUDF_ANIMATE)));

    return TRUE;
}

/***************************************************************************\
* _GetDesktopWindow (API)
*
* History:
* 07-Nov-1990 DarrinM   Implemented.
\***************************************************************************/

PWND _GetDesktopWindow(VOID)
{
    PTHREADINFO  pti = PtiCurrent();
    PDESKTOPINFO pdi;

    if (pti == NULL)
        return NULL;

    pdi = pti->pDeskInfo;

    return pdi == NULL ? NULL : pdi->spwnd;
}

/***************************************************************************\
* _GetDesktopWindow (API)
*
* History:
* 07-Nov-1990 DarrinM   Implemented.
\***************************************************************************/

PWND _GetMessageWindow(VOID)
{
    PTHREADINFO  pti = PtiCurrent();
    PDESKTOP pdi;

    if (pti == NULL)
        return NULL;

    pdi = pti->rpdesk;

    return pdi == NULL ? NULL : pdi->spwndMessage;
}

/**************************************************************************\
* TestWindowProcess
*
* History:
* 14-Nov-1994 JimA      Created.
\**************************************************************************/

BOOL TestWindowProcess(
    PWND pwnd)
{
    return (PpiCurrent() == GETPTI(pwnd)->ppi);
}

/***************************************************************************\
* ValidateDepth
*
* The function conveniently simulates recursion by utilizing the fact
* that from any sibling in the Next chain we can correctly get to the
* parent window and that two siblings in the Next chain cannot have
* different parents.
*
* 12-Mar-1997   vadimg      created
\***************************************************************************/

#define NESTED_WINDOW_LIMIT 100

BOOL ValidateParentDepth(PWND pwnd, PWND pwndParent)
{
    UINT cDepth = 1, cDepthMax;
    PWND pwndStop;

    /*
     * Calculate the depth of the parent chain.
     */
    while (pwndParent != NULL) {
        pwndParent = pwndParent->spwndParent;
        cDepth++;
    }

    cDepthMax = cDepth;

    /*
     * When pwnd is NULL, it means that we want to add one more
     * level to the existing depth of pwndParent.
     */
    if (pwnd == NULL || pwnd->spwndChild == NULL) {
        goto Exit;
    } else {
        pwndStop = pwnd->spwndParent;
    }

Restart:
    if (pwnd->spwndChild != NULL) {
        pwnd = pwnd->spwndChild;
        cDepth++;
    } else if (pwnd->spwndNext != NULL) {
        pwnd = pwnd->spwndNext;
    } else {
        if (cDepth > cDepthMax) {
            cDepthMax = cDepth;
        }

        /*
         * Find a parent with siblings and recurse on them. Terminate
         * when we reach the parent of the original pwnd.
         */
        do {
            pwnd = pwnd->spwndParent;
            cDepth--;

            if (pwnd == pwndStop)
                goto Exit;

        } while (pwnd->spwndNext == NULL);

        pwnd = pwnd->spwndNext;
    }
    goto Restart;

Exit:
    return (cDepthMax <= NESTED_WINDOW_LIMIT);
}

/***************************************************************************\
* ValidateOwnerDepth
*
* pwndOwner is the new intended owner, we basically add 1 to the current
* nested owner chain depth. We assume that the actual window does not have
* any ownees. In reality, it can through SetWindowLong, but finding the
* maximum depth of the ownee chain is really tricky - just look in swp.c.
*
* 12-Mar-1997   vadimg      created
\***************************************************************************/

BOOL ValidateOwnerDepth(PWND pwnd, PWND pwndOwner)
{
    UINT cDepth = 1;

    while (pwndOwner != NULL) {

        /*
         * Do not allow loops in the owner chain.
         */
        if (pwndOwner == pwnd) {
            return FALSE;
        }

        pwndOwner = pwndOwner->spwndOwner;
        cDepth++;
    }

    return (cDepth <= NESTED_WINDOW_LIMIT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\getset.c ===
/****************************** Module Header ******************************\
* Module Name: getset.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains window manager information routines
*
* History:
* 10-22-90 MikeHar      Ported functions from Win 3.0 sources.
* 13-Feb-1991 mikeke    Added Revalidation code (None)
* 08-Feb-1991 IanJa     Unicode/ANSI aware and neutral
\***************************************************************************/

/***************************************************************************\
* MapServerToClientPfn
*
* Returns the client wndproc representing the server wndproc passed in
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/

ULONG_PTR MapServerToClientPfn(
    KERNEL_ULONG_PTR dw,
    BOOL bAnsi)
{
    int i;

    for (i = FNID_WNDPROCSTART; i <= FNID_WNDPROCEND; i++) {
        if ((WNDPROC_PWND)dw == STOCID(i)) {
            if (bAnsi) {
                return FNID_TO_CLIENT_PFNA_CLIENT(i);
            } else {
                return FNID_TO_CLIENT_PFNW_CLIENT(i);
            }
        }
    }
    return 0;
}

/***************************************************************************\
* MapClientNeuterToClientPfn
*
* Maps client Neuter routines like editwndproc to Ansi or Unicode versions
* and back again.
*
* 01-13-92 ScottLu      Created.
\***************************************************************************/

ULONG_PTR MapClientNeuterToClientPfn(
    PCLS pcls,
    KERNEL_ULONG_PTR dw,
    BOOL bAnsi)
{
    /*
     * Default to the class window proc.
     */
    if (dw == 0) {
        dw = (KERNEL_ULONG_PTR)pcls->lpfnWndProc;
    }

    /*
     * If this is one of our controls and it hasn't been subclassed, try
     * to return the correct ANSI/Unicode function.
     */
    if (pcls->fnid >= FNID_CONTROLSTART && pcls->fnid <= FNID_CONTROLEND) {
        if (!bAnsi) {
            if (FNID_TO_CLIENT_PFNA_KERNEL(pcls->fnid) == dw)
                return FNID_TO_CLIENT_PFNW_CLIENT(pcls->fnid);
        } else {
            if (FNID_TO_CLIENT_PFNW_KERNEL(pcls->fnid) == dw)
                return FNID_TO_CLIENT_PFNA_CLIENT(pcls->fnid);
        }
#ifdef BUILD_WOW6432
        if (!bAnsi) {
            if (FNID_TO_CLIENT_PFNW_KERNEL(pcls->fnid) == dw)
                return FNID_TO_CLIENT_PFNW_CLIENT(pcls->fnid);
        } else {
            if (FNID_TO_CLIENT_PFNA_KERNEL(pcls->fnid) == dw)
                return FNID_TO_CLIENT_PFNA_CLIENT(pcls->fnid);
        }
        dw = (KERNEL_ULONG_PTR)MapKernelClientFnToClientFn((WNDPROC_PWND)dw);
#endif
    }

    return (ULONG_PTR)dw;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\input.c ===
/****************************** Module Header ******************************\
* Module Name: input.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains common input functions.
*
* History:
* 09-12-95 JerrySh      Created.
\***************************************************************************/


/***************************************************************************\
* CheckMsgRange
*
* Checks to see if a message range is within a message filter
*
* History:
* 11-13-90 DavidPe      Created.
* 11-Oct-1993 mikeke    Macroized
\***************************************************************************/

#define CheckMsgRange(wMsgRangeMin, wMsgRangeMax, wMsgFilterMin, wMsgFilterMax) \
    (  ((wMsgFilterMin) > (wMsgFilterMax))      \
     ? (  ((wMsgRangeMax) >  (wMsgFilterMax))   \
        &&((wMsgRangeMin) <  (wMsgFilterMin)))  \
     : (  ((wMsgRangeMax) >= (wMsgFilterMin))   \
        &&((wMsgRangeMin) <= (wMsgFilterMax)))  \
    )

/***************************************************************************\
* CalcWakeMask
*
* Calculates which wakebits to check for based on the message
* range specified by wMsgFilterMin/Max.  This basically means
* if the filter range didn't input WM_KEYUP and WM_KEYDOWN,
* QS_KEY wouldn't be included.
*
* History:
* 10-28-90 DavidPe      Created.
\***************************************************************************/

UINT CalcWakeMask(
    UINT wMsgFilterMin,
    UINT wMsgFilterMax,
    UINT fsWakeMaskFilter)
{
    UINT fsWakeMask;

    /*
     * New for NT5: wake mask filter.
     * In addition to the message filter, the application can also provide
     *      a wake mask directly.
     * If none is provided, default to NT4 mask (plus QS_SENDMESSAGE).
     */
    if (fsWakeMaskFilter == 0) {
        fsWakeMask = (QS_ALLINPUT | QS_EVENT | QS_ALLPOSTMESSAGE);
    } else {
        /*
         * If the caller wants input, we force all input events. The
         *  same goes for posted messages. We do this to keep NT4
         *  compatibility as much as possible.
         */
        if (fsWakeMaskFilter & QS_INPUT) {
            fsWakeMaskFilter |= (QS_INPUT | QS_EVENT);
        }
        if (fsWakeMaskFilter & (QS_POSTMESSAGE | QS_TIMER | QS_HOTKEY)) {
            fsWakeMaskFilter |= (QS_POSTMESSAGE | QS_TIMER | QS_HOTKEY);
        }
        fsWakeMask = fsWakeMaskFilter;
    }

#ifndef _USERK_
    /*
     * The client PeekMessage in client\cltxt.h didn't used to
     *  call CalcWakeMask if wMsgFilterMax was 0. We call it now
     *  to take care of fsWakeMaskFilter but still bail before
     *  messing with the message filter.
     */
    if (wMsgFilterMax == 0) {
        return fsWakeMask;
    }
#endif

    /*
     * Message filter.
     * If the filter doesn't match certain ranges, we take out bits one by one.
     * First check for a 0, 0 filter which means we want all input.
     */
    if (wMsgFilterMin == 0 && wMsgFilterMax == ((UINT)-1)) {
        return fsWakeMask;
    }

    /*
     * We're not looking at all posted messages.
     */
    fsWakeMask &= ~QS_ALLPOSTMESSAGE;

    /*
     * Check for mouse move messages.
     */
    if ((CheckMsgFilter(WM_NCMOUSEMOVE, wMsgFilterMin, wMsgFilterMax) == FALSE) &&
            (CheckMsgFilter(WM_MOUSEMOVE, wMsgFilterMin, wMsgFilterMax) == FALSE)) {
        fsWakeMask &= ~QS_MOUSEMOVE;
    }

    /*
     * First check to see if mouse buttons messages are in the filter range.
     */
    if ((CheckMsgRange(WM_NCLBUTTONDOWN, WM_NCMBUTTONDBLCLK, wMsgFilterMin,
            wMsgFilterMax) == FALSE) && (CheckMsgRange(WM_MOUSEFIRST + 1,
            WM_MOUSELAST, wMsgFilterMin, wMsgFilterMax) == FALSE)) {
        fsWakeMask &= ~QS_MOUSEBUTTON;
    }

    /*
     * Check for key messages.
     */
    if (CheckMsgRange(WM_KEYFIRST, WM_KEYLAST, wMsgFilterMin, wMsgFilterMax) == FALSE) {
        fsWakeMask &= ~QS_KEY;
    }

#ifdef GENERIC_INPUT
    /*
     * Check for raw input messages
     */
    if (CheckMsgRange(WM_INPUT, WM_INPUT, wMsgFilterMin, wMsgFilterMax) == FALSE) {
        fsWakeMask &= ~QS_RAWINPUT;
    }
#endif

    /*
     * Check for paint messages.
     */
    if (CheckMsgFilter(WM_PAINT, wMsgFilterMin, wMsgFilterMax) == FALSE) {
        fsWakeMask &= ~QS_PAINT;
    }

    /*
     * Check for timer messages.
     */
    if ((CheckMsgFilter(WM_TIMER, wMsgFilterMin, wMsgFilterMax) == FALSE) &&
            (CheckMsgFilter(WM_SYSTIMER,
            wMsgFilterMin, wMsgFilterMax) == FALSE)) {
        fsWakeMask &= ~QS_TIMER;
    }

    /*
     * Check also for WM_QUEUESYNC which maps to all input bits.
     * This was added for CBT/EXCEL processing.  Without it, a
     * xxxPeekMessage(....  WM_QUEUESYNC, WM_QUEUESYNC, FALSE) would
     * not see the message. (bobgu 4/7/87)
     * Since the user can provide a wake mask now (fsWakeMaskFilter),
     *  we also add QS_EVENT in this case (it was always set on NT4).
     */
    if (wMsgFilterMin == WM_QUEUESYNC) {
        fsWakeMask |= (QS_INPUT | QS_EVENT);
    }

    return fsWakeMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\drawtext.c ===
/****************************** Module Header ******************************\
* Module Name: drawtext.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains common text drawing functions.
*
* History:
* 02-12-92 mikeke   Moved Drawtext to the client side
\***************************************************************************/


/***************************************************************************\
* Define some macros to test the format flags. We won't support them all
* on the kernel-mode side, since they're not all needed there.
\***************************************************************************/
#ifdef _USERK_
    #define CALCRECT(wFormat)               FALSE
    #define EDITCONTROL(wFormat)            FALSE
    #define EXPANDTABS(wFormat)             FALSE
    #define EXTERNALLEADING(wFormat)        FALSE
    #define MODIFYSTRING(wFormat)           FALSE
    #define NOPREFIX(wFormat)               TRUE
    #define PATHELLIPSIS(wFormat)           FALSE
    #define SINGLELINE(wFormat)             TRUE
    #define TABSTOP(wFormat)                FALSE
    #define WORDBREAK(wFormat)              FALSE
    #define WORDELLIPSIS(wFormat)           FALSE
    #define NOFULLWIDTHCHARBREAK(dwFormat)  FALSE
#else
    #define CALCRECT(wFormat)               (wFormat & DT_CALCRECT)
    #define EDITCONTROL(wFormat)            (wFormat & DT_EDITCONTROL)
    #define EXPANDTABS(wFormat)             (wFormat & DT_EXPANDTABS)
    #define EXTERNALLEADING(wFormat)        (wFormat & DT_EXTERNALLEADING)
    #define MODIFYSTRING(wFormat)           (wFormat & DT_MODIFYSTRING)
    #define NOPREFIX(wFormat)               (wFormat & DT_NOPREFIX)
    #define PATHELLIPSIS(wFormat)           (wFormat & DT_PATH_ELLIPSIS)
    #define SINGLELINE(wFormat)             (wFormat & DT_SINGLELINE)
    #define TABSTOP(wFormat)                (wFormat & DT_TABSTOP)
    #define WORDBREAK(wFormat)              (wFormat & DT_WORDBREAK)
    #define WORDELLIPSIS(wFormat)           (wFormat & DT_WORD_ELLIPSIS)
    // Note: DT_NOFULLWIDTHCHARBREAK exceeds WORD limit. Use dwFormat
    //  rather than wFormat.
    #define NOFULLWIDTHCHARBREAK(dwFormat)  (dwFormat & DT_NOFULLWIDTHCHARBREAK)
#endif
#define ENDELLIPSIS(wFormat)        (wFormat & DT_END_ELLIPSIS)
#define NOCLIP(wFormat)             (wFormat & DT_NOCLIP)
#define RTLREADING(wFormat)         (wFormat & DT_RTLREADING)
#define HIDEPREFIX(wFormat)         (wFormat & DT_HIDEPREFIX)

/***************************************************************************\
* Stuff used in DrawText code
\***************************************************************************/

#define CR 13
#define LF 10
#define SYM_SP 0xf020
#define DT_HFMTMASK 0x03
#define DT_VFMTMASK 0x0C
#define ETO_OPAQUEFGND 0x0A

static CONST WCHAR szEllipsis[CCHELLIPSIS+1] = TEXT("...");

extern HDC    ghdcBits2;

/* Max length of a full path is around 260. But, most of the time, it will
 * be less than 128. So, we alloc only this much on stack. If the string is
 * longer, we alloc from local heap (which is slower).
 *
 * BOGUS: For international versions, we need to give some more margin here.
 */
#define MAXBUFFSIZE     128

/***************************************************************************\
*  There are word breaking characters which are compatible with
* Japanese Windows 3.1 and FarEast Windows 95.
*
*  SJ - Country Japan , Charset SHIFTJIS, Codepage  932.
*  GB - Country PRC   , Charset GB2312  , Codepage  936.
*  B5 - Country Taiwan, Charset BIG5    , Codepage  950.
*  WS - Country Korea , Charset WANGSUNG, Codepage  949.
*  JB - Country Korea , Charset JOHAB   , Codepage 1361. *** LATER ***
*
* [START BREAK CHARACTERS]
*
*   These character should not be the last charatcer of the line.
*
*  Unicode   Japan      PRC     Taiwan     Korea
*  -------+---------+---------+---------+---------+
*
* + ASCII
*
*   U+0024 (SJ+0024)                     (WS+0024) Dollar sign
*   U+0028 (SJ+0028)                     (WS+0028) Opening parenthesis
*   U+003C (SJ+003C)                               Less-than sign
*   U+005C (SJ+005C)                               Backslash
*   U+005B (SJ+005B) (GB+005B)           (WS+005B) Opening square bracket
*   U+007B (SJ+007B) (GB+007B)           (WS+007B) Opening curly bracket
*
* + General punctuation
*
*   U+2018                               (WS+A1AE) Single Turned Comma Quotation Mark
*   U+201C                               (WS+A1B0) Double Comma Quotation Mark
*
* + CJK symbols and punctuation
*
*   U+3008                               (WS+A1B4) Opening Angle Bracket
*   U+300A (SJ+8173)                     (WS+A1B6) Opening Double Angle Bracket
*   U+300C (SJ+8175)                     (WS+A1B8) Opening Corner Bracket
*   U+300E (SJ+8177)                     (WS+A1BA) Opening White Corner Bracket
*   U+3010 (SJ+9179)                     (WS+A1BC) Opening Black Lenticular Bracket
*   U+3014 (SJ+816B)                     (WS+A1B2) Opening Tortoise Shell Bracket
*
* + Fullwidth ASCII variants
*
*   U+FF04                               (WS+A3A4) Fullwidth Dollar Sign
*   U+FF08 (SJ+8169)                     (WS+A3A8) Fullwidth opening parenthesis
*   U+FF1C (SJ+8183)                               Fullwidth less-than sign
*   U+FF3B (SJ+816D)                     (WS+A3DB) Fullwidth opening square bracket
*   U+FF5B (SJ+816F)                     (WS+A3FB) Fullwidth opening curly bracket
*
* + Halfwidth Katakana variants
*
*   U+FF62 (SJ+00A2)                               Halfwidth Opening Corner Bracket
*
* + Fullwidth symbol variants
*
*   U+FFE1                               (WS+A1CC) Fullwidth Pound Sign
*   U+FFE6                               (WS+A3DC) Fullwidth Won Sign
*
* [END BREAK CHARACTERS]
*
*   These character should not be the top charatcer of the line.
*
*  Unicode   Japan      PRC     Taiwan     Korea
*  -------+---------+---------+---------+---------+
*
* + ASCII
*
*   U+0021 (SJ+0021) (GB+0021) (B5+0021) (WS+0021) Exclamation mark
*   U+0025                               (WS+0025) Percent Sign
*   U+0029 (SJ+0029)                     (WS+0029) Closing parenthesis
*   U+002C (SJ+002C) (GB+002C) (B5+002C) (WS+002C) Comma
*   U+002E (SJ+002E) (GB+002E) (B5+002E) (WS+002E) Priod
*   U+003A                               (WS+003A) Colon
*   U+003B                               (WS+003B) Semicolon
*   U+003E (SJ+003E)                               Greater-than sign
*   U+003F (SJ+003F) (GB+003F) (B5+003F) (WS+003F) Question mark
*   U+005D (SJ+005D) (GB+005D) (B5+005D) (WS+005D) Closing square bracket
*   U+007D (SJ+007D) (GB+007D) (B5+007D) (WS+007D) Closing curly bracket
*
* + Latin1
*
*   U+00A8           (GB+A1A7)                     Spacing diaeresis
*   U+00B0                               (WS+A1C6) Degree Sign
*   U+00B7                     (B5+A150)           Middle Dot
*
* + Modifier letters
*
*   U+02C7           (GB+A1A6)                     Modifier latter hacek
*   U+02C9           (GB+A1A5)                     Modifier letter macron
*
* + General punctuation
*
*   U+2013                     (B5+A156)           En Dash
*   U+2014                     (b5+A158)           Em Dash
*   U+2015           (GB+A1AA)                     Quotation dash
*   U+2016           (GB+A1AC)                     Double vertical bar
*   U+2018           (GB+A1AE)                     Single turned comma quotation mark
*   U+2019           (GB+A1AF) (B5+A1A6) (WS+A1AF) Single comma quotation mark
*   U+201D           (GB+A1B1) (B5+A1A8) (WS+A1B1) Double comma quotation mark
*   U+2022           (GB+A1A4)                     Bullet
*   U+2025                     (B5+A14C)           Two Dot Leader
*   U+2026           (GB+A1AD) (B5+A14B)           Horizontal ellipsis
*   U+2027                     (B5+A145)           Hyphenation Point
*   U+2032                     (B5+A1AC) (WS+A1C7) Prime
*   U+2033                               (WS+A1C8) Double Prime
*
* + Letterlike symbols
*
*   U+2103                               (WS+A1C9) Degrees Centigrade
*
* + Mathemetical opetartors
*
*   U+2236           (GB+A1C3)                     Ratio
*
* + Form and Chart components
*
*   U+2574                     (B5+A15A)           Forms Light Left
*
* + CJK symbols and punctuation
*
*   U+3001 (SJ+8141) (GB+A1A2) (B5+A142)           Ideographic comma
*   U+3002 (SJ+8142) (GB+A1A3) (B5+A143)           Ideographic period
*   U+3003           (GB+A1A8)                     Ditto mark
*   U+3005           (GB+A1A9)                     Ideographic iteration
*   U+3009           (GB+A1B5) (B5+A172) (WS+A1B5) Closing angle bracket
*   U+300B (SJ+8174) (GB+A1B7) (B5+A16E) (WS+A1B7) Closing double angle bracket
*   U+300D (SJ+8176) (GB+A1B9) (B5+A176) (WS+A1B9) Closing corner bracket
*   U+300F (SJ+8178) (GB+A1BB) (B5+A17A) (WS+A1BB) Closing white corner bracket
*   U+3011 (SJ+817A) (GB+A1BF) (B5+A16A) (WS+A1BD) Closing black lenticular bracket
*   U+3015 (SJ+816C) (GB+A1B3) (B5+A166) (WS+A1B3) Closing tortoise shell bracket
*   U+3017           (GB+A1BD)                     Closing white lenticular bracket
*   U+301E                     (B5+A1AA)           Double Prime Quotation Mark
*
* + Hiragana
*
*   U+309B (SJ+814A)                               Katakana-Hiragana voiced sound mark
*   U+309C (SJ+814B)                               Katakana-Hiragana semi-voiced sound mark
*
* + CNS 11643 compatibility
*
*   U+FE30                     (B5+A14A)           Glyph for Vertical 2 Dot Leader
*   U+FE31                     (B5+A157)           Glyph For Vertical Em Dash
*   U+FE33                     (B5+A159)           Glyph for Vertical Spacing Underscore
*   U+FE34                     (B5+A15B)           Glyph for Vertical Spacing Wavy Underscore
*   U+FE36                     (B5+A160)           Glyph For Vertical Closing Parenthesis
*   U+FE38                     (B5+A164)           Glyph For Vertical Closing Curly Bracket
*   U+FE3A                     (B5+A168)           Glyph For Vertical Closing Tortoise Shell Bracket
*   U+FE3C                     (B5+A16C)           Glyph For Vertical Closing Black Lenticular Bracket
*   U+FE3E                     (B5+A16E)           Closing Double Angle Bracket
*   U+FE40                     (B5+A174)           Glyph For Vertical Closing Angle Bracket
*   U+FE42                     (B5+A178)           Glyph For Vertical Closing Corner Bracket
*   U+FE44                     (B5+A17C)           Glyph For Vertical Closing White Corner Bracket
*   U+FE4F                     (B5+A15C)           Spacing Wavy Underscore
*
* + Small variants
*
*   U+FE50                     (B5+A14D)           Small Comma
*   U+FE51                     (B5+A14E)           Small Ideographic Comma
*   U+FE52                     (B5+A14F)           Small Period
*   U+FE54                     (B5+A151)           Small Semicolon
*   U+FE55                     (B5+A152)           Small Colon
*   U+FE56                     (B5+A153)           Small Question Mark
*   U+FE57                     (B5+A154)           Small Exclamation Mark
*   U+FE5A                     (B5+A17E)           Small Closing Parenthesis
*   U+FE5C                     (B5+A1A2)           Small Closing Curly Bracket
*   U+FE5E                     (B5+A1A4)           Small Closing Tortoise Shell Bracket
*
* + Fullwidth ASCII variants
*
*   U+FF01 (SJ+8149) (GB+A3A1) (B5+A149) (WS+A3A1) Fullwidth exclamation mark
*   U+FF02           (GB+A3A2)                     Fullwidth Quotation mark
*   U+FF05                               (WS+A3A5) Fullwidth Percent Sign
*   U+FF07           (GB+A3A7)                     Fullwidth Apostrophe
*   U+FF09 (SJ+816A) (GB+A3A9) (B5+A15E) (WS+A3A9) Fullwidth Closing parenthesis
*   U+FF0C (SJ+8143) (GB+A3AC) (B5+A141) (WS+A3AC) Fullwidth comma
*   U+FF0D           (GB+A3AD)                     Fullwidth Hyphen-minus
*   U+FF0E (SJ+8144)           (B5+A144) (WS+A3AE) Fullwidth period
*   U+FF1A           (GB+A3BA) (B4+A147) (WS+A3BA) Fullwidth colon
*   U+FF1B           (GB+A3BB) (B5+A146) (WS+A3BB) Fullwidth semicolon
*   U+FF1E (SJ+8184)                               Fullwidth Greater-than sign
*   U+FF1F (SJ+8148) (GB+A3BF) (B5+A148) (WS+A3BF) Fullwidth question mark
*   U+FF3D (SJ+816E) (GB+A3DD)           (WS+A3DD) Fullwidth Closing square bracket
*   U+FF5C                     (B5+A155)           Fullwidth Vertical Bar
*   U+FF5D (SJ+8170)           (B5+A162) (WS+A3FD) Fullwidth Closing curly bracket
*   U+FF5E           (GB+A1AB)                     Fullwidth Spacing tilde
*
* + Halfwidth Katakana variants
*
*   U+FF61 (SJ+00A1)                               Halfwidth Ideographic period
*   U+FF63 (SJ+00A3)                               Halfwidth Closing corner bracket
*   U+FF64 (SJ+00A4)                               Halfwidth Ideographic comma
*   U+FF9E (SJ+00DE)                               Halfwidth Katakana voiced sound mark
*   U+FF9F (SJ+00DF)                               Halfwidth Katakana semi-voiced sound mark
*
* + Fullwidth symbol variants
*
*   U+FFE0                               (WS+A1CB) Fullwidth Cent Sign
*
\***************************************************************************/

#if 0   // not currently used --- FYI only
/***************************************************************************\
* Start Break table
*  These character should not be the last charatcer of the line.
\***************************************************************************/

CONST BYTE aASCII_StartBreak[] = {
/* 00       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 2X */                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,
/* 6X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aCJKSymbol_StartBreak[] = {
/* 30       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */                            1, 0, 1, 0, 1, 0, 1, 0,
/* 1X */    1, 0, 0, 0, 1
};

CONST BYTE aFullWidthHalfWidthVariants_StartBreak[] = {
/* FF       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */                1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* 1X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
/* 2X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
/* 6X */    0, 0, 1
};
#endif

/***************************************************************************\
* End Break table.
*  These character should not be the top charatcer of the line.
\***************************************************************************/

CONST BYTE aASCII_Latin1_EndBreak[] = {
/* 00       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 2X */       1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 6X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 8X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 9X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* AX */    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
/* BX */    1, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aGeneralPunctuation_EndBreak[] = {
/* 20       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 1X */             1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0,
/* 2X */    0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 1, 1
};

CONST BYTE aCJKSymbol_EndBreak[] = {
/* 30       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */       1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1,
/* 1X */    0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1
};

CONST BYTE aCNS11643_SmallVariants_EndBreak[] = {
/* FE       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 3X */    1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,
/* 4X */    1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
/* 5X */    1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1
};

CONST BYTE aFullWidthHalfWidthVariants_EndBreak[] = {
/* FF       0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
/* 0X */       1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0,
/* 1X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1,
/* 2X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 3X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
/* 4X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 5X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0,
/* 6X */    0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 7X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 8X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
/* 9X */    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1
};

/***************************************************************************\
*  UserIsFELineBreak() - Detects East Asia word breaking characters.        *
*                                                                           *
* History:                                                                  *
* 10-Mar-1996 HideyukN  Created.                                            *
\***************************************************************************/

#if 0   // not currently used --- FYI only
BOOL UserIsFELineBreakStart(WCHAR wch)
{
    switch (wch>>8) {
        case 0x00:
            //
            // Check if word breaking chars in ASCII.
            //
            if ((wch >= 0x0024) && (wch <= 0x007B))
                return((BOOL)(aASCII_StartBreak[wch - 0x0024]));
            else
                return(FALSE);

        case 0x20:
            //
            // Check if work breaking chars in "General punctuation"
            //
            if ((wch == 0x2018) || (wch == 0x201C))
                return(TRUE);
            else
                return(FALSE);

        case 0x30:
            //
            // Check if word breaking chars in "CJK symbols and punctuation"
            // and Hiragana.
            //
            if ((wch >= 0x3008) && (wch <= 0x3014))
                return((BOOL)(aCJKSymbol_StartBreak[wch - 0x3008]));
            else
                return(FALSE);

        case 0xFF:
            //
            // Check if word breaking chars in "Fullwidth ASCII variants",
            // "Halfwidth Katakana variants" or "Fullwidth Symbol variants".
            //
            if ((wch >= 0xFF04) && (wch <= 0xFF62))
                return((BOOL)(aFullWidthHalfWidthVariants_StartBreak[wch - 0xFF04]));
            else if ((wch == 0xFFE1) || (wch == 0xFFE6))
                return(TRUE);
            else
                return(FALSE);

        default:
            return(FALSE);
    }
}
#endif

BOOL UserIsFELineBreakEnd(WCHAR wch)
{
    switch (wch>>8) {
        case 0x00:
            //
            // Check if word breaking chars in ASCII or Latin1.
            //
            if ((wch >= 0x0021) && (wch <= 0x00B7))
                return((BOOL)(aASCII_Latin1_EndBreak[wch - 0x0021]));
            else
                return(FALSE);

        case 0x02:
            //
            // Check if work breaking chars in "Modifier letters"
            //
            if ((wch == 0x02C7) || (wch == 0x02C9))
                return(TRUE);
            else
                return(FALSE);

        case 0x20:
            //
            // Check if work breaking chars in "General punctuation"
            //
            if ((wch >= 0x2013) && (wch <= 0x2033))
                return((BOOL)(aGeneralPunctuation_EndBreak[wch - 0x2013]));
            else
                return(FALSE);

        case 0x21:
            //
            // Check if work breaking chars in "Letterlike symbols"
            //
            if (wch == 0x2103)
                return(TRUE);
            else
                return(FALSE);

        case 0x22:
            //
            // Check if work breaking chars in "Mathemetical opetartors"
            //
            if (wch == 0x2236)
                return(TRUE);
            else
                return(FALSE);

        case 0x25:
            //
            // Check if work breaking chars in "Form and Chart components"
            //
            if (wch == 0x2574)
                return(TRUE);
            else
                return(FALSE);

        case 0x30:
            //
            // Check if word breaking chars in "CJK symbols and punctuation"
            // and Hiragana.
            //
            if ((wch >= 0x3001) && (wch <= 0x301E))
                return((BOOL)(aCJKSymbol_EndBreak[wch - 0x3001]));
            else if ((wch == 0x309B) || (wch == 0x309C))
                return(TRUE);
            else
                return(FALSE);

        case 0xFE:
            //
            // Check if word breaking chars in "CNS 11643 compatibility"
            // or "Small variants".
            //
            if ((wch >= 0xFE30) && (wch <= 0xFE5E))
                return((BOOL)(aCNS11643_SmallVariants_EndBreak[wch - 0xFE30]));
            else
                return(FALSE);

        case 0xFF:
            //
            // Check if word breaking chars in "Fullwidth ASCII variants",
            // "Halfwidth Katakana variants" or "Fullwidth symbol variants".
            //
            if ((wch >= 0xFF01) && (wch <= 0xFF9F))
                return((BOOL)(aFullWidthHalfWidthVariants_EndBreak[wch - 0xFF01]));
            else if (wch >= 0xFFE0)
                return(TRUE);
            else
                return(FALSE);

        default:
            return(FALSE);
    }
}

#define UserIsFELineBreak(wChar)    UserIsFELineBreakEnd(wChar)

/***************************************************************************\
*  UserIsFullWidth() - Detects East Asia FullWidth character.               *
*                                                                           *
* History:                                                                  *
* 10-Mar-1996 HideyukN  Created                                             *
\***************************************************************************/

typedef struct _FULLWIDTH_UNICODE {
    WCHAR Start;
    WCHAR End;
} FULLWIDTH_UNICODE, *PFULLWIDTH_UNICODE;

#define NUM_FULLWIDTH_UNICODES    4

CONST FULLWIDTH_UNICODE FullWidthUnicodes[] = {
   { 0x4E00, 0x9FFF }, // CJK_UNIFIED_IDOGRAPHS
   { 0x3040, 0x309F }, // HIRAGANA
   { 0x30A0, 0x30FF }, // KATAKANA
   { 0xAC00, 0xD7A3 }  // HANGUL
};

BOOL UserIsFullWidth(DWORD dwCodePage,WCHAR wChar)
{
    INT  index;
    INT  cChars;
#ifdef _USERK_
    CHAR aChars[2];
#endif // _USERK_

    //
    // Early out for ASCII.
    //
    if (wChar < 0x0080) {
        //
        // if the character < 0x0080, it should be a halfwidth character.
        //
        return (FALSE);
    }
    //
    // Scan FullWdith definition table... most of FullWidth character is
    // defined here... this is more faster than call NLS API.
    //
    for (index = 0; index < NUM_FULLWIDTH_UNICODES; index++) {
        if ((wChar >= FullWidthUnicodes[index].Start) &&
            (wChar <= FullWidthUnicodes[index].End)      ) {
            return (TRUE);
        }
    }
    //
    // if this Unicode character is mapped to Double-Byte character,
    // this is also FullWidth character..
    //
#ifdef _USERK_
    cChars = EngWideCharToMultiByte((UINT)dwCodePage,&wChar,sizeof(WCHAR),aChars,sizeof(aChars));
#else
    cChars = WideCharToMultiByte((UINT)dwCodePage,0,&wChar,1,NULL,0,NULL,NULL);
#endif // _USERK_

    return(cChars > 1 ? TRUE : FALSE);
}
/***************************************************************************\
*  UserTextOutWInternal
*  Wrapper for UserTextOutW, used to adjust the parameter passed to
*  PSMTextOut
*
\***************************************************************************/
BOOL UserTextOutWInternal(
    HDC     hdc,
    int     x,
    int     y,
    LPCWSTR lp,
    UINT    cc,
    DWORD   dwFlags)
{
    UNREFERENCED_PARAMETER(dwFlags);
    return UserTextOutW(hdc, x, y, lp, cc);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  KKGetPrefixWidth() -                                                    */
/*                                                                          */
/*  Returns total width of prefix character. Japanese Windows has           */
/*  three shortcut prefixes, '&',\036 and \037.  They may have              */
/*  different width.                                                        */
/*                                                                          */
/*    From Chicago ctlmgr.c HideyukN                                        */
/*--------------------------------------------------------------------------*/

int KKGetPrefixWidth(HDC hdc, LPCWSTR lpStr, int cch)
{
    SIZE size;
    SIZE iPrefix1 = {-1L,-1L};
    SIZE iPrefix2 = {-1L,-1L};
    SIZE iPrefix3 = {-1L,-1L};
    int  iTotal   = 0;

    while (cch-- > 0 && *lpStr) {
        switch(*lpStr) {
        case CH_PREFIX:
            if (lpStr[1] != CH_PREFIX) {
                if (iPrefix1.cx == -1) {
                    UserGetTextExtentPointW(hdc, lpStr, 1, &iPrefix1);
                }
                iTotal += iPrefix1.cx;
            } else {
                lpStr++;
                cch--;
            }
            break;
        case CH_ENGLISHPREFIX:
            if (iPrefix2.cx == -1) {
                 UserGetTextExtentPointW(hdc, lpStr, 1, &iPrefix2);
            }
            iTotal += iPrefix2.cx;
            break;
        case CH_KANJIPREFIX:
            if (iPrefix3.cx == -1) {
                 UserGetTextExtentPointW(hdc, lpStr, 1, &iPrefix3);
            }
            iTotal += iPrefix3.cx;
            //
            // In NT, always alpha numeric mode, Then we have to sum
            // KANA accel key prefix non visible char width.
            // so always add the extent for next char.
            //
            UserGetTextExtentPointW(hdc, lpStr, 1, &size);
            iTotal += size.cx;
            break;
        default:
            // No need to taking care of Double byte since 2nd byte of
            // DBC is grater than 0x2f but all shortcut keys are less
            // than 0x30.
            break;
        }
        lpStr++;
    }
    return iTotal;
}

#if ((DT_WORDBREAK & ~0xff) != 0)
#error cannot use BOOLEAN for DT_WORDBREAK, or you should use "!!" before assigning it
#endif

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetNextWordbreak() -                                                    */
/*    From Chicago ctlmgr.c  FritzS                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LPCWSTR GetNextWordbreak(DWORD dwCodePage,
                         LPCWSTR lpch,
                         LPCWSTR lpchEnd,
                         DWORD  dwFormat,
                         LPDRAWTEXTDATA lpDrawInfo)

{
    /* ichNonWhite is used to make sure we always make progress. */
    int ichNonWhite = 1;
    int ichComplexBreak = 0;        // Breaking opportunity for complex scripts
    BOOLEAN fBreakSpace = (BOOLEAN)WORDBREAK(dwFormat);
    /*
     * If DT_WORDBREAK and DT_NOFULLWIDTHCHARBREAK are both set, we must
     * stop assuming FullWidth characters as word as we're doing in
     * NT4 and Win95. Instead, CR/LF and/or white space will only be
     * a line-break characters.
     */
    BOOLEAN fDbcsCharBreak = (fBreakSpace && !NOFULLWIDTHCHARBREAK(dwFormat));

#ifdef _USERK_
    /*
     * Well, we actually should not and do not call GetNextWordBreak() in
     * kernel, since only Menu stuff (no word break!) calls DrawText from kernel.
     * In reality, thanks to a smart linker, word-break helper
     * functions even does not exist in win32k.sys.
     * Later, we should explicitly omit to compile those routines when we
     * build kernel.
     */
    UNREFERENCED_PARAMETER(dwFormat);
#endif

    // We must terminate this loop before lpch == lpchEnd, otherwise, we
    // may gp fault during *lpch.
    while (lpch < lpchEnd) {
        switch (*lpch) {
        case CR:
        case LF:
            return lpch;

        case '\t':
        case ' ':
        case SYM_SP:
            if (fBreakSpace)
                return (lpch + ichNonWhite);

            /*** FALL THRU ***/

        default:
            /*
             * Since most Japanese writing don't use space character
             * to separate each word, we define each Kanji character
             * as a word.
             */
            if (fDbcsCharBreak && UserIsFullWidth(dwCodePage, *lpch)) {
                if (!ichNonWhite)
                    return lpch;
                /*
                 * if the next character is the last character of this string,
                 * We return the character, even this is a "KINSOKU" charcter...
                 */
                if ((lpch+1) != lpchEnd) {
                    /*
                     * Check next character of FullWidth character.
                     * if the next character is "KINSOKU" character, the character
                     * should be handled as a part of previous FullWidth character.
                     * Never handle is as A character, and should not be a Word also.
                     */
                    if (UserIsFELineBreak(*(lpch+1))) {
                        /*
                         * Then if the character is "KINSOKU" character, we return
                         * the next of this character,...
                         */
                        return (lpch + 1 + 1);
                    }
                }
                /*
                 * Otherwise, we just return the chracter that is next of FullWidth
                 * Character. Because we treat A FullWidth chacter as A Word.
                 */
                return (lpch + 1);
            }
            /*
             * If the character is not a FullWidth character and the complex script
             * LPK is present. Call it to determine the breaking opportunity for
             * script that requires word break such as Thai. Note that if *lpch is
             * NOT a complex script character. The LPK will fail the call and return 0
             * since currently Uniscribe does not know how to handle FE break.
             */
            else if(fBreakSpace && lpDrawInfo->bCharsetDll) {
#ifdef _USERK_
                PTHREADINFO ptiCurrent = PtiCurrentShared();
                if(CALL_LPK(ptiCurrent))
#endif
                    ichComplexBreak = (*UserLpkDrawTextEx)(0, 0, 0, lpch, (int)(lpchEnd - lpch), 0,
                                        0, NULL, DT_GETNEXTWORD, -1);
                if (ichComplexBreak > 0)
                    return (lpch + ichComplexBreak);
            }
            lpch++;
            ichNonWhite = 0;
        }
    }

    return lpch;
}

/***************************************************************************\
* GetPrefixCount
*
* This routine returns the count of accelerator mnemonics and the
* character location (starting at 0) of the character to underline.
* A single CH_PREFIX character will be striped and the following character
* underlined, all double CH_PREFIX character sequences will be replaced by
* a single CH_PREFIX (this is done by PSMTextOut). This routine is used
* to determine the actual character length of the string that will be
* printed, and the location the underline should be placed. Only
* cch characters from the input string will be processed. If the lpstrCopy
* parameter is non-NULL, this routine will make a printable copy of the
* string with all single prefix characters removed and all double prefix
* characters collapsed to a single character. If copying, a maximum
* character count must be specified which will limit the number of
* characters copied.
*
* The location of the single CH_PREFIX is returned in the low order
* word, and the count of CH_PREFIX characters that will be striped
* from the string during printing is in the hi order word. If the
* high order word is 0, the low order word is meaningless. If there
* were no single prefix characters (i.e. nothing to underline), the
* low order word will be -1 (to distinguish from location 0).
*
* These routines assume that there is only one single CH_PREFIX character
* in the string.
*
* WARNING! this rountine returns information in BYTE count not CHAR count
* (so it can easily be passed onto GreExtTextOutW which takes byte
* counts as well)
*
* History:
* 11-13-90 JimA         Ported to NT
* 30-Nov-1992 mikeke    Client side version
\***************************************************************************/

LONG GetPrefixCount(
    LPCWSTR lpstr,
    int cch,
    LPWSTR lpstrCopy,
    int charcopycount)
{
    int chprintpos = 0;         /* Num of chars that will be printed */
    int chcount = 0;            /* Num of prefix chars that will be removed */
    int chprefixloc = -1;       /* Pos (in printed chars) of the prefix */
    WCHAR ch;

    /*
     * If not copying, use a large bogus count...
     */
    if (lpstrCopy == NULL)
        charcopycount = 32767;

    while ((cch-- > 0) && *lpstr && charcopycount-- != 0) {

        /*
         * Is this guy a prefix character ?
         */
        if ((ch = *lpstr++) == CH_PREFIX) {

            /*
             * Yup - increment the count of characters removed during print.
             */
            chcount++;

            /*
             * Is the next also a prefix char?
             */
            if (*lpstr != CH_PREFIX) {

                /*
                 * Nope - this is a real one, mark its location.
                 */
                chprefixloc = chprintpos;

            } else {

                /*
                 * yup - simply copy it if copying.
                 */
                if (lpstrCopy != NULL)
                    *(lpstrCopy++) = CH_PREFIX;
                cch--;
                lpstr++;
                chprintpos++;
            }
        } else if (ch == CH_ENGLISHPREFIX) {    // Still needs to be parsed
            /*
             * Yup - increment the count of characters removed during print.
             */
            chcount++;

            /*
             * Next character is a real one, mark its location.
             */
            chprefixloc = chprintpos;

        } else if (ch == CH_KANJIPREFIX) {      // Still needs to be parsed
            /*
             * We only support Alpha Numeric(CH_ENGLISHPREFIX).
             * no support for Kana(CH_KANJIPREFIX).
             */
            /*
             * Yup - increment the count of characters removed during print.
             */
            chcount++;

            if(cch) {
                /* don't copy the character */
                chcount++;
                lpstr++;
                cch--;
            }
        } else {

            /*
             * Nope - just inc count of char.  that will be printed
             */
            chprintpos++;
            if (lpstrCopy != NULL)
                *(lpstrCopy++) = ch;
        }
    }

    if (lpstrCopy != NULL)
        *lpstrCopy = 0;

    /*
     * Return the character counts
     */
    return MAKELONG(chprefixloc, chcount);
}

/***************************************************************************\
*  DT_GetExtentMinusPrefixes
\***************************************************************************/

int DT_GetExtentMinusPrefixes(HDC hdc, LPCWSTR lpchStr, int cchCount, UINT wFormat,
                        int iOverhang, LPDRAWTEXTDATA  lpDrawInfo, int iCharSet)
{
  int  iPrefixCount;
  int  cxPrefixes = 0;
  WCHAR PrefixChar = CH_PREFIX;
  SIZE size;
  PCLIENTINFO pci = GetClientInfo();
#ifdef _USERK_
  PTHREADINFO ptiCurrent = PtiCurrentShared();
#endif
  UNREFERENCED_PARAMETER(wFormat);

  if(!NOPREFIX(wFormat) &&
      (iPrefixCount = HIWORD(GetPrefixCount(lpchStr, cchCount, NULL, 0)))) {
      //
      // Kanji Windows has three shortcut prefixes...
      //  (ported from Win95 ctlmgr.c)
      //
      if (IS_DBCS_ENABLED() && (pci->dwTIFlags & TIF_16BIT)) {
          // 16bit apps compatibility
          cxPrefixes = KKGetPrefixWidth(hdc, lpchStr, cchCount) - (iPrefixCount * iOverhang);
      }
      else {
          if(lpDrawInfo->bCharsetDll) {
#ifdef _USERK_
              if(CALL_LPK(ptiCurrent))
#endif // _USERK_
              {
                  // Call LPKDrawTextEx with fDraw = FALSE just to get the text extent.
                  return (*UserLpkDrawTextEx)(hdc, 0, 0, lpchStr, cchCount, FALSE,
                         wFormat, lpDrawInfo, DT_CHARSETDRAW, iCharSet);
              }
          } else {
              cxPrefixes = UserGetTextExtentPointW(hdc, &PrefixChar, 1, &size);
              cxPrefixes = size.cx - iOverhang;
              cxPrefixes *=  iPrefixCount;
          }
      }
  }
#ifdef _USERK_
  if(CALL_LPK(ptiCurrent))
    xxxClientGetTextExtentPointW(hdc, lpchStr, cchCount, &size);
  else
#endif // _USERK_
    UserGetTextExtentPointW(hdc, lpchStr, cchCount, &size);
  return (size.cx - cxPrefixes);
}

/***************************************************************************\
*   DT_DrawStr
*      This will draw the given string in the given location without worrying
*  about the left/right justification. Gets the extent and returns it.
*  If fDraw is TRUE and if NOT DT_CALCRECT, this draws the text.
*        NOTE: This returns the extent minus Overhang.
*
*   From Chicago ctlmgr.c  FritzS
\***************************************************************************/
int DT_DrawStr(HDC hdc, int  xLeft, int yTop, LPCWSTR lpchStr,
               int cchCount, BOOL fDraw, UINT wFormat,
               LPDRAWTEXTDATA  lpDrawInfo, int iCharSet)
{
    LPCWSTR        lpch;
    int   iLen;
    int   cxExtent;
    int   xOldLeft = xLeft;  // Save the xLeft given to compute the extent later
    int   xTabLength = lpDrawInfo->cxTabLength;
    int   iTabOrigin = lpDrawInfo->rcFormat.left;

    //
    // Because xLeft and yTop is a point in a rect, and we shift the rect in a mirrored hdc to include
    // its most right pixel, then shift this point as well.
    //
    if (UserGetLayout(hdc) & LAYOUT_RTL) {
        --xOldLeft;
        --xLeft;
    }

    //
    // if there is a charset dll, let it draw the text.
    //
    if(lpDrawInfo->bCharsetDll) {
#ifdef _USERK_
        PTHREADINFO ptiCurrent = PtiCurrentShared();

        //
        // Don't perform a callback if in thread cleanup mode.
        //
        if(!CALL_LPK(ptiCurrent))
            return 0 ;
#endif // _USERK_
        return (*UserLpkDrawTextEx)(hdc, xLeft, yTop, lpchStr, cchCount, fDraw,
                   wFormat, lpDrawInfo, DT_CHARSETDRAW, iCharSet);
    }

    // Check if the tabs need to be expanded
    if(EXPANDTABS(wFormat)) {
        while(cchCount) {
            // Look for a tab
            for(iLen = 0, lpch = lpchStr; iLen < cchCount; iLen++)
                  if(*lpch++ == TEXT('\t'))
                    break;

                // Draw text, if any, upto the tab
            if (iLen) {
                // Draw the substring taking care of the prefixes.
                if (fDraw && !CALCRECT(wFormat)) { // Only if we need to draw text
                    (*(lpDrawInfo->lpfnTextDraw))(hdc, xLeft, yTop, (LPWSTR)lpchStr, iLen, wFormat);
                }
                // Get the extent of this sub string and add it to xLeft.
                xLeft += DT_GetExtentMinusPrefixes(hdc, lpchStr, iLen, wFormat, lpDrawInfo->cxOverhang, lpDrawInfo, iCharSet) - lpDrawInfo->cxOverhang;
            }

            //if a TAB was found earlier, calculate the start of next sub-string.
            if (iLen < cchCount) {
                iLen++;  // Skip the tab
                if (xTabLength) // Tab length could be zero
                    xLeft = (((xLeft - iTabOrigin)/xTabLength) + 1)*xTabLength + iTabOrigin;
            }

            // Calculate the details of the string that remains to be drawn.
            cchCount -= iLen;
            lpchStr = lpch;
        }
        cxExtent = xLeft - xOldLeft;
    } else {
        // If required, draw the text (with either PSMTextOut or PSTextOut)
        if (fDraw && !CALCRECT(wFormat)) {
            (*(lpDrawInfo->lpfnTextDraw))(hdc, xLeft, yTop, (LPWSTR)lpchStr, cchCount, wFormat);
        }
        // Compute the extent of the text.
        cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchStr, cchCount, wFormat,
                                             lpDrawInfo->cxOverhang, lpDrawInfo, iCharSet) - lpDrawInfo->cxOverhang;
    }
    return cxExtent;
}

/***************************************************************************\
*  DT_DrawJustifiedLine
*      This function draws one complete line with proper justification
*
*   from Chicago ctlmgr.c  FritzS
\***************************************************************************/

void DT_DrawJustifiedLine(HDC  hdc, int yTop, LPCWSTR lpchLineSt,
                                 int cchCount, UINT wFormat,
                                 LPDRAWTEXTDATA lpDrawInfo, int iCharSet)
{
  LPRECT lprc;
  int   cxExtent;
  int   xLeft;

  lprc = &(lpDrawInfo->rcFormat);
  xLeft = lprc->left;

  // Handle the special justifications (right or centered) properly.
  if(wFormat & (DT_CENTER | DT_RIGHT)) {
      cxExtent = DT_DrawStr(hdc, xLeft, yTop, lpchLineSt, cchCount, FALSE,
                     wFormat, lpDrawInfo, iCharSet) + lpDrawInfo->cxOverhang;
      if(wFormat & DT_CENTER)
          xLeft = lprc->left + (((lprc->right - lprc->left) - cxExtent) >> 1);
      else
          xLeft = lprc->right - cxExtent;
    } else
      xLeft = lprc->left;

  // Draw the whole line.
  cxExtent = DT_DrawStr(hdc, xLeft, yTop, lpchLineSt, cchCount, TRUE, wFormat,
                        lpDrawInfo, iCharSet) +lpDrawInfo->cxOverhang;
  if(cxExtent > lpDrawInfo->cxMaxExtent)
      lpDrawInfo->cxMaxExtent = cxExtent;
}

/***************************************************************************\
* DT_InitDrawTextInfo
*      This is called at the begining of DrawText(); This initializes the
* DRAWTEXTDATA structure passed to this function with all the required info.
*
*  from Chicago ctlmgr.c  FritzS
\***************************************************************************/

BOOL DT_InitDrawTextInfo(
    HDC hdc,
    LPRECT lprc,
    UINT wFormat,
    LPDRAWTEXTDATA lpDrawInfo,
    LPDRAWTEXTPARAMS lpDTparams)
{
  SIZE   sizeViewPortExt = {0, 0},sizeWindowExt = {0, 0};
  TEXTMETRICW tm;
  LPRECT      lprcDest;
  int         iTabLength = 8;   // Default Tab length is 8 characters.
  int         iLeftMargin;
  int         iRightMargin;
  BOOL        fUseSystemFont;

  if (lpDTparams) {
      /*
       *  Only if DT_TABSTOP flag is mentioned, we must use the iTabLength field.
       */
      if (TABSTOP(wFormat))
          iTabLength = lpDTparams->iTabLength;
      iLeftMargin = lpDTparams->iLeftMargin;
      iRightMargin = lpDTparams->iRightMargin;
  } else {
      iLeftMargin = iRightMargin = 0;
  }

  /*
   *  Get the View port and Window extents for the given DC
   *  If this call fails, hdc must be invalid
   */
  if (!UserGetViewportExtEx(hdc,&sizeViewPortExt)) {
#ifndef _USERK_
      /*
       * This call fails on  standard Metafiles. So check
       * if the DC is really invalid to be compatible with
       * Win9x
       */
      if ((hdc == NULL) || !GdiValidateHandle(hdc))
#endif
          return FALSE;
  }
  UserGetWindowExtEx(hdc, &sizeWindowExt);

  /*
   *  For the current mapping mode,  find out the sign of x from left to right.
   */
  lpDrawInfo->iXSign =
      (((sizeViewPortExt.cx ^ sizeWindowExt.cx) & 0x80000000) ? -1 : 1);

  /*
   *  For the current mapping mode,  find out the sign of y from top to bottom.
   */
  lpDrawInfo->iYSign =
      (((sizeViewPortExt.cy ^ sizeWindowExt.cy) & 0x80000000) ? -1 : 1);

  /*
   *  Calculate the dimensions of the current font in this DC.
   * (If it is SysFont AND the mapping mode is MM_TEXT, use system font's data)
   */
  fUseSystemFont = ((wFormat & DT_INTERNAL) || IsSysFontAndDefaultMode(hdc));
  if (!fUseSystemFont) {
      /*
       *  Edit controls have their own way of calculating the aveCharWidth.
       */
      if (EDITCONTROL(wFormat)) {
          tm.tmAveCharWidth = UserGetCharDimensionsW(hdc, &tm, NULL);
          tm.tmCharSet = (BYTE)UserGetTextCharsetInfo(hdc, NULL, 0);
          if (tm.tmAveCharWidth == 0) {
              fUseSystemFont = TRUE;
          }
      } else if (!UserGetTextMetricsW(hdc, &tm)) {
          /*
           * This can fail in a hard error popup during logon or logoff
           * because UpdatePerUserSystemParameters destroys the server-side
           * font handle for the DC, and a repaint occurs before we switch
           * desktops (the switch recreates the popup from scratch with the
           * new font OK). ChrisWil's changes to move system-wide attributes
           * into desktops should take care of this in Kernel-mode.  This is
           * just a horrible, horrible hack for now.
           */
          RIPMSG0(RIP_WARNING, "UserGetTextMetricsW failed: only in logon/off?\n");
          tm.tmOverhang = 0;

          /*
           * We should probably set fUseSystemFont to TRUE here. But I
           *  assume that this "horrible hack" works fine plus it has been
           *  here for good. So I'll leave it alone. 6/3/96
           */
      }
  }

  if (fUseSystemFont) {
      /*
       *  Avoid GetTextMetrics for internal calls since they use sys font.
       */
      tm.tmHeight = gpsi->cySysFontChar;
      tm.tmExternalLeading = gpsi->tmSysFont.tmExternalLeading;
      tm.tmAveCharWidth = gpsi->tmSysFont.tmAveCharWidth;
      tm.tmOverhang = gpsi->tmSysFont.tmOverhang;
#ifdef _USERK_
      tm.tmCharSet = (BYTE)UserGetTextCharsetInfo(gpDispInfo->hdcScreen, NULL, 0);
#else
      tm.tmCharSet = (BYTE)UserGetTextCharsetInfo(ghdcBits2, NULL, 0);
#endif // _USERK_
  }


  // cyLineHeight is in pixels (This will be signed).
  lpDrawInfo->cyLineHeight = (tm.tmHeight +
            (EXTERNALLEADING(wFormat) ? tm.tmExternalLeading : 0)) *
            lpDrawInfo->iYSign;

  // cxTabLength is the tab length in pixels (This will not be signed)
  lpDrawInfo->cxTabLength = tm.tmAveCharWidth * iTabLength;

  // Set the cxOverhang
  lpDrawInfo->cxOverhang = tm.tmOverhang;

  // Pick up the proper TextOut function based on the prefix processing reqd.
#ifdef _USERK_
  lpDrawInfo->bCharsetDll = PpiCurrent()->dwLpkEntryPoints & LPK_DRAWTEXTEX;
  if (lpDrawInfo->bCharsetDll == FALSE) {
      lpDrawInfo->lpfnTextDraw = (NOPREFIX(wFormat) ? (LPFNTEXTDRAW)UserTextOutWInternal : xxxPSMTextOut);
  }
#else
  lpDrawInfo->bCharsetDll = (BOOL)(fpLpkDrawTextEx != (FPLPKDRAWTEXTEX)NULL);
  if (lpDrawInfo->bCharsetDll == FALSE) {
      lpDrawInfo->lpfnTextDraw = (NOPREFIX(wFormat) ? (LPFNTEXTDRAW)UserTextOutWInternal : PSMTextOut);
  }
#endif // _USERK_

  // Set up the format rectangle based on the margins.
//  LCopyStruct(lprc, lprcDest = (LPRECT)&(lpDrawInfo->rcFormat), sizeof(RECT));
  lprcDest = &(lpDrawInfo->rcFormat);
  *lprcDest = *lprc;

  // We need to do the following only if the margins are given
  if(iLeftMargin | iRightMargin) {
      lprcDest->left += iLeftMargin * lpDrawInfo->iXSign;
      lprcDest->right -= (lpDrawInfo->cxRightMargin = iRightMargin * lpDrawInfo->iXSign);
    } else
      lpDrawInfo->cxRightMargin = 0;  // Initialize to zero.

  // cxMaxWidth is unsigned.
  lpDrawInfo->cxMaxWidth = (lprcDest->right - lprcDest->left) * lpDrawInfo->iXSign;
  lpDrawInfo->cxMaxExtent = 0;  // Initialize this to zero.

  return TRUE;
}

/***************************************************************************\
* DT_AdjustWhiteSpaces
*      In the case of WORDWRAP, we need to treat the white spaces at the
* begining/end of each line specially. This function does that.
*  lpStNext = points to the begining of next line.
*  lpiCount = points to the count of characters in the current line.
\***************************************************************************/

LPCWSTR  DT_AdjustWhiteSpaces(LPCWSTR  lpStNext, LPINT lpiCount, UINT wFormat)
{
  switch(wFormat & DT_HFMTMASK) {
      case DT_LEFT:
        // Prevent a white space at the begining of a left justfied text.
        // Is there a white space at the begining of next line......
        if((*lpStNext == TEXT(' ')) || (*lpStNext == TEXT('\t'))) {
            // ...then, exclude it from next line.
            lpStNext++;
          }
        break;

      case DT_RIGHT:
        // Prevent a white space at the end of a RIGHT justified text.
        // Is there a white space at the end of current line,.......
        if((*(lpStNext-1) == TEXT(' ')) || (*(lpStNext - 1) == TEXT('\t'))) {
            // .....then, Skip the white space from the current line.
            (*lpiCount)--;
          }
        break;

      case DT_CENTER:
        // Exclude white spaces from the begining and end of CENTERed lines.
        // If there is a white space at the end of current line.......
        if((*(lpStNext-1) == TEXT(' ')) || (*(lpStNext - 1) == TEXT('\t')))
            (*lpiCount)--;    //...., don't count it for justification.
        // If there is a white space at the begining of next line.......
        if((*lpStNext == TEXT(' ')) || (*lpStNext == TEXT('\t')))
            lpStNext++;       //...., exclude it from next line.
        break;
    }
  return lpStNext;
}

/***************************************************************************\
*  DT_BreakAWord
*      A word needs to be broken across lines and this finds out where to
*  break it.
\***************************************************************************/
LPCWSTR  DT_BreakAWord(HDC  hdc, LPCWSTR lpchText,
              int iLength, int iWidth, UINT wFormat, int iOverhang, LPDRAWTEXTDATA  lpDrawInfo, int iCharSet)
{
  int  iLow = 0, iHigh = iLength;
  int  iNew;


  while((iHigh - iLow) > 1) {
      iNew = iLow + (iHigh - iLow)/2;
      if(DT_GetExtentMinusPrefixes(hdc, lpchText, iNew, wFormat, iOverhang, lpDrawInfo, iCharSet) > iWidth)
          iHigh = iNew;
      else
          iLow = iNew;
    }
  // If the width is too low, we must print atleast one char per line.
  // Else, we will be in an infinite loop.
  if(!iLow && iLength)
      iLow = 1;
  return (lpchText+iLow);
}

/***************************************************************************\
* DT_GetLineBreak
*      This finds out the location where we can break a line.
* Returns LPCSTR to the begining of next line.
* Also returns via lpiLineLength, the length of the current line.
* NOTE: (lpstNextLineStart - lpstCurrentLineStart) is not equal to the
* line length; This is because, we exclude some white spaces at the begining
* and/or end of lines; Also, CR/LF is excluded from the line length.
\***************************************************************************/

LPWSTR DT_GetLineBreak(
    HDC  hdc,
    LPCWSTR lpchLineStart,
    int   cchCount,
    DWORD dwFormat,
    LPINT lpiLineLength,
    LPDRAWTEXTDATA  lpDrawInfo,
    int iCharSet)
{
  LPCWSTR lpchText, lpchEnd, lpch, lpchLineEnd;
  int   cxStart, cxExtent, cxNewExtent;
  BOOL  fAdjustWhiteSpaces = FALSE;
  WCHAR  ch;
  DWORD dwCodePage = USERGETCODEPAGE(hdc);

  cxStart = lpDrawInfo->rcFormat.left;
  cxExtent = cxNewExtent = 0;
  lpchText = lpchLineStart;
  lpchEnd = lpchLineStart + cchCount;


  while(lpchText < lpchEnd) {
      lpchLineEnd = lpch = GetNextWordbreak(dwCodePage,lpchText, lpchEnd, dwFormat, lpDrawInfo);
      // DT_DrawStr does not return the overhang; Otherwise we will end up
      // adding one overhang for every word in the string.

      // For simulated Bold fonts, the summation of extents of individual
      // words in a line is greater than the extent of the whole line. So,
      // always calculate extent from the LineStart.
      // BUGTAG: #6054 -- Win95B -- SANKAR -- 3/9/95 --
      cxNewExtent = DT_DrawStr(hdc, cxStart, 0, lpchLineStart, (int)(((PBYTE)lpch - (PBYTE)lpchLineStart)/sizeof(WCHAR)), FALSE,
                 dwFormat, lpDrawInfo, iCharSet);

      if (WORDBREAK(dwFormat) && ((cxNewExtent + lpDrawInfo->cxOverhang) > lpDrawInfo->cxMaxWidth)) {
          // Are there more than one word in this line?
          if (lpchText != lpchLineStart)  {
              lpchLineEnd = lpch = lpchText;
              fAdjustWhiteSpaces = TRUE;
          } else {
              //One word is longer than the maximum width permissible.
              //See if we are allowed to break that single word.
              if(EDITCONTROL(dwFormat) && !WORDELLIPSIS(dwFormat)) {
                  lpchLineEnd = lpch = DT_BreakAWord(hdc, lpchText, (int)(((PBYTE)lpch - (PBYTE)lpchText)/sizeof(WCHAR)),
                        lpDrawInfo->cxMaxWidth - cxExtent,
                        dwFormat,
                        lpDrawInfo->cxOverhang, lpDrawInfo, iCharSet); //Break that word
                  //Note: Since we broke in the middle of a word, no need to
                  // adjust for white spaces.
              } else {
                  fAdjustWhiteSpaces = TRUE;
                  // Check if we need to end this line with ellipsis
                  if(WORDELLIPSIS(dwFormat))
                    {
                      // Don't do this if already at the end of the string.
                      if (lpch < lpchEnd)
                        {
                          // If there are CR/LF at the end, skip them.
                          if ((ch = *lpch) == CR || ch == LF)
                            {
                              if ((++lpch < lpchEnd) && (*lpch == (WCHAR)(ch ^ (LF ^ CR))))
                                  lpch++;
                              fAdjustWhiteSpaces = FALSE;
                            }
                        }
                    }
              }
          }
          // Well! We found a place to break the line. Let us break from this
          // loop;
          break;
      } else {
          // Don't do this if already at the end of the string.
          if (lpch < lpchEnd) {
              if ((ch = *lpch) == CR || ch == LF) {
                  if ((++lpch < lpchEnd) && (*lpch == (WCHAR)(ch ^ (LF ^ CR))))
                      lpch++;
                  fAdjustWhiteSpaces = FALSE;
                  break;
              }
          }
      }

      // Point at the beginning of the next word.
      lpchText = lpch;
      cxExtent = cxNewExtent;
  }

  // Calculate the length of current line.
  *lpiLineLength = (INT)((PBYTE)lpchLineEnd - (PBYTE)lpchLineStart)/sizeof(WCHAR);

  // Adjust the line length and lpch to take care of spaces.
  if(fAdjustWhiteSpaces && (lpch < lpchEnd))
      lpch = DT_AdjustWhiteSpaces(lpch, lpiLineLength, dwFormat);

  // return the begining of next line;
  return (LPWSTR)lpch;
}

/***************************************************************************\
*  NeedsEndEllipsis()
*      This function checks whether the given string fits within the given
*      width or we need to add end-ellipse. If it required end-ellipses, it
*      returns TRUE and it returns the number of characters that are saved
*      in the given string via lpCount.
\***************************************************************************/
BOOL  NeedsEndEllipsis(HDC        hdc,
                                     LPCWSTR     lpchText,
                                     LPINT      lpCount,
                                     LPDRAWTEXTDATA  lpDTdata,
                                     UINT       wFormat, LPDRAWTEXTDATA  lpDrawInfo, int iCharSet)
{
    int   cchText;
    int   ichMin, ichMax, ichMid;
    int   cxMaxWidth;
    int   iOverhang;
    int   cxExtent;
    SIZE size;
    cchText = *lpCount;  // Get the current count.

    if (cchText == 0)
        return FALSE;

    cxMaxWidth  = lpDTdata->cxMaxWidth;
    iOverhang   = lpDTdata->cxOverhang;

    cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchText, cchText, wFormat, iOverhang, lpDrawInfo, iCharSet);

    if (cxExtent <= cxMaxWidth)
        return FALSE;
    // Reserve room for the "..." ellipses;
    // (Assumption: The ellipses don't have any prefixes!)
    UserGetTextExtentPointW(hdc, szEllipsis, CCHELLIPSIS, &size);
    cxMaxWidth -= size.cx - iOverhang;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxMaxWidth > 0) {
        // Binary search to find characters that will fit.
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax) {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            cxExtent = DT_GetExtentMinusPrefixes(hdc, lpchText, ichMid, wFormat, iOverhang, lpDrawInfo, iCharSet);

            if (cxExtent < cxMaxWidth)
                ichMin = ichMid;
            else {
                if (cxExtent > cxMaxWidth)
                    ichMax = ichMid - 1;
                else {
                    // Exact match up up to ichMid: just exit.
                    //
                    ichMax = ichMid;
                    break;
                  }
              }
          }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
      }

    *lpCount = ichMax;
    return TRUE;
}

/***************************************************************************\
* BOGUS: The same function is available in SHELL2.DLL also.
* We need to remove from one of the places.
\***************************************************************************/
// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo
/***************************************************************************\
\***************************************************************************/


LPWSTR PathFindFileName(LPCWSTR pPath, int cchText)
{
    LPCWSTR pT;

    for (pT = pPath; cchText > 0 && *pPath; pPath++, cchText--) {
        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':')) && pPath[1])
            pT = pPath + 1;
    }

    return (LPWSTR)pT;   // REVIEW, should this be const?
}

/***************************************************************************\
* AddPathEllipse():
*      This adds a path ellipse to the given path name.
*      Returns TRUE if the resultant string's extent is less the the
* cxMaxWidth. FALSE, if otherwise.
\***************************************************************************/
int AddPathEllipsis(
    HDC    hDC,
    LPWSTR lpszPath,
    int    cchText,
    UINT   wFormat,
    int    cxMaxWidth,
    int    iOverhang, LPDRAWTEXTDATA  lpDrawInfo, int iCharSet)
{
  int    iLen;
  UINT   dxFixed, dxEllipsis;
  LPWSTR lpEnd;          /* end of the unfixed string */
  LPWSTR lpFixed;        /* start of text that we always display */
  BOOL   bEllipsisIn;
  int    iLenFixed;
  SIZE   size;

  lpFixed = PathFindFileName(lpszPath, cchText);
  if (lpFixed != lpszPath)
      lpFixed--;  // point at the slash
  else
      return cchText;

  lpEnd = lpFixed;
  bEllipsisIn = FALSE;
  iLenFixed = cchText - (int)(lpFixed - lpszPath);
  dxFixed = DT_GetExtentMinusPrefixes(hDC, lpFixed, iLenFixed, wFormat, iOverhang, lpDrawInfo, iCharSet);

  // It is assumed that the "..." string does not have any prefixes ('&').
  UserGetTextExtentPointW(hDC, szEllipsis, CCHELLIPSIS, &size);
  dxEllipsis = size.cx - iOverhang;

  while (TRUE) {
      iLen = dxFixed + DT_GetExtentMinusPrefixes(hDC, lpszPath, (int)((PBYTE)lpEnd - (PBYTE)lpszPath)/sizeof(WCHAR),
                                       wFormat, iOverhang, lpDrawInfo, iCharSet) - iOverhang;

      if (bEllipsisIn)
          iLen += dxEllipsis;

      if (iLen <= cxMaxWidth)
          break;

      bEllipsisIn = TRUE;

      if (lpEnd <= lpszPath) {
          /* Things didn't fit. */
          lpEnd = lpszPath;
          break;
      }

      /* Step back a character. */
      lpEnd--;
  }

  if (bEllipsisIn && (lpEnd + CCHELLIPSIS < lpFixed)) {
      // NOTE: the strings could over lap here. So, we use LCopyStruct.

      RtlMoveMemory((lpEnd + CCHELLIPSIS), lpFixed, iLenFixed * sizeof(WCHAR));
      RtlCopyMemory(lpEnd, szEllipsis, CCHELLIPSIS * sizeof(WCHAR));

      cchText = (int)(lpEnd - lpszPath) + CCHELLIPSIS + iLenFixed;

      // now we can NULL terminate the string
      *(lpszPath + cchText) = TEXT('\0');
  }

  return cchText;
}

//-----------------------------------------------------------------------
// This function returns the number of characters actually drawn.
//-----------------------------------------------------------------------
int AddEllipsisAndDrawLine(
    HDC            hdc,
    int            yLine,
    LPCWSTR        lpchText,
    int            cchText,
    DWORD          dwDTformat,
    LPDRAWTEXTDATA lpDrawInfo,
    int iCharSet)
{
    LPWSTR pEllipsis = NULL;
    WCHAR  szTempBuff[MAXBUFFSIZE];
    LPWSTR lpDest;
    BOOL   fAlreadyCopied = FALSE;

    // Check if this is a filename with a path AND
    // Check if the width is too narrow to hold all the text.
    if(PATHELLIPSIS(dwDTformat) &&
        ((DT_GetExtentMinusPrefixes(hdc, lpchText, cchText,
                   dwDTformat, lpDrawInfo->cxOverhang, lpDrawInfo, iCharSet)) > lpDrawInfo->cxMaxWidth)) {
        // We need to add Path-Ellipsis. See if we can do it in-place.
        if(!MODIFYSTRING(dwDTformat)) {
            // NOTE: When you add Path-Ellipsis, the string could grow by
            // CCHELLIPSIS bytes.
            if((cchText + CCHELLIPSIS + 1) <= MAXBUFFSIZE)
                lpDest = szTempBuff;
            else {   // Alloc from local heap.
                // Alloc the buffer from local heap.
                if(!(pEllipsis = (LPWSTR)UserRtlAllocMem(
                        (cchText+CCHELLIPSIS+1)*sizeof(WCHAR))))
                    return 0;
                lpDest = (LPWSTR)pEllipsis;
            }
            // Source String may not be NULL terminated. So, copy just
            // the given number of characters.
            RtlCopyMemory(lpDest, lpchText, cchText*sizeof(WCHAR));
            lpchText = lpDest;        // lpchText points to the copied buff.
            fAlreadyCopied = TRUE;    // Local copy has been made.
        }
        // Add the path ellipsis now!
        cchText = AddPathEllipsis(hdc, (LPWSTR)lpchText, cchText, dwDTformat,
            lpDrawInfo->cxMaxWidth, lpDrawInfo->cxOverhang, lpDrawInfo, iCharSet);
    }

    // Check if end-ellipsis are to be added.
    if((ENDELLIPSIS(dwDTformat) || WORDELLIPSIS(dwDTformat)) &&
        NeedsEndEllipsis(hdc, lpchText, &cchText, lpDrawInfo, dwDTformat, lpDrawInfo, iCharSet)) {
        // We need to add end-ellipsis; See if we can do it in-place.
        if(!MODIFYSTRING(dwDTformat) && !fAlreadyCopied) {
            // See if the string is small enough for the buff on stack.
            if((cchText+CCHELLIPSIS+1) <= MAXBUFFSIZE)
                lpDest = szTempBuff;  // If so, use it.
            else {
                // Alloc the buffer from local heap.
                if(!(pEllipsis = (LPWSTR)UserRtlAllocMem(
                        (cchText+CCHELLIPSIS+1)*sizeof(WCHAR))))
                    return 0;
                lpDest = pEllipsis;
            }
            // Make a copy of the string in the local buff.
            RtlCopyMemory(lpDest, lpchText, cchText*sizeof(WCHAR));
            lpchText = lpDest;
        }
        // Add an end-ellipsis at the proper place.
        RtlCopyMemory((LPWSTR)(lpchText+cchText), szEllipsis, (CCHELLIPSIS+1)*sizeof(WCHAR));
        cchText += CCHELLIPSIS;
    }

    // Draw the line that we just formed.
    DT_DrawJustifiedLine(hdc, yLine, lpchText, cchText, dwDTformat, lpDrawInfo, iCharSet);

    // Free the block allocated for End-Ellipsis.
    if(pEllipsis)
        UserRtlFreeMem(pEllipsis);

    return cchText;
}


/***************************************************************************\
* IDrawTextEx
*      This is the new DrawText API
\***************************************************************************/

/***************************************************************************\
* IDrawTextEx
*      This is the new DrawText API
\***************************************************************************/

int  DrawTextExW(
   HDC               hdc,
   LPWSTR            lpchText,
   int               cchText,
   LPRECT            lprc,
   UINT              dwDTformat,
   LPDRAWTEXTPARAMS  lpDTparams)
{
   /*
    * The LPK requires a charset.  The Unicode entry point always passes a -1,
    * but the ANSI entry point passes a more interesting value.  Both the
    * 'W' version and 'A' version of DrawTextEx call this common worker routine.
    */
   return DrawTextExWorker(hdc, lpchText, cchText, lprc, dwDTformat, lpDTparams, -1);
}

int  DrawTextExWorker(
   HDC               hdc,
   LPWSTR            lpchText,
   int               cchText,
   LPRECT            lprc,
   UINT              dwDTformat,
   LPDRAWTEXTPARAMS  lpDTparams,
   int               iCharset)
{
    DRAWTEXTDATA DrawInfo;
    WORD         wFormat = LOWORD(dwDTformat);
    LPWSTR       lpchTextBegin;
    LPWSTR       lpchEnd;
    LPWSTR       lpchNextLineSt;
    int          iLineLength;
    int          iySign;
    int          yLine;
    int          yLastLineHeight;
    HRGN         hrgnClip;
    int          iLineCount;
    RECT         rc;
    BOOL         fLastLine;
    WCHAR        ch;
    UINT         oldAlign;

#if DBG
    if (dwDTformat & ~DT_VALID)
        RIPMSG0 (RIP_WARNING, "DrawTextExW: Invalid dwDTformat flags");
#endif

    if (lpchText == NULL) {
        return 0;
    }

    if (cchText == 0 && *lpchText) {
        /*
         * infoview.exe passes lpchText that points to '\0'
         *
         * "Microsoft Expedia Streets and Trips 2000" and "MS MapPoint 2000"
         * tries cchText == 0 to detect if DrawTextW is supported.
         */

        /* Added by Chicago:
         * Lotus Notes doesn't like getting a zero return here
         */
        return 1;
    }

    if (cchText == -1)
        cchText = wcslen(lpchText);



    if ((lpDTparams) && (lpDTparams->cbSize != sizeof(DRAWTEXTPARAMS))) {
        RIPERR1(ERROR_INVALID_PARAMETER, RIP_WARNING, "DrawTextEx: cbSize %ld is invalid",
                lpDTparams->cbSize);
        return 0;
    }

#ifdef LATER
    /*
     * If DT_MODIFYSTRING is specified, then check for read-write pointer.
     */
    if (MODIFYSTRING(dwDTformat) &&
            (ENDELLIPSIS(dwDTformat) || PATHELLIPSIS(dwDTformat))) {
        if(IsBadWritePtr(lpchText, cchText)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "DrawTextEx: For DT_MODIFYSTRING, lpchText must be read-write");
            return(0);
        }
    }
#endif

    /*
     * Initialize the DrawInfo structure.
     */
    if (!DT_InitDrawTextInfo(hdc, lprc, dwDTformat, (LPDRAWTEXTDATA)&DrawInfo, lpDTparams))
        return 0;

    DrawInfo.iCharset = iCharset;
    /*
     * If the rect is too narrow or the margins are too wide.....Just forget it!
     *
     * If wordbreak is specified, the MaxWidth must be a reasonable value.
     * This check is sufficient because this will allow CALCRECT and NOCLIP
     * cases.  --SANKAR.
     *
     * This also fixed all of our known problems with AppStudio.
     */
    if (DrawInfo.cxMaxWidth <= 0) {

        /*
         * We used to return a non-zero value in win31.
         * If the kernel calls this we are always Ver 4.0 or above
         */
#ifdef _USERK_
        if (0) {
#else
        if (GETAPPVER() < VER40) {
#endif
            if((DrawInfo.cxMaxWidth == 0) && !CALCRECT(wFormat)) {
                return(1);
            }
        } else {
            if (WORDBREAK(wFormat)) {
                RIPMSG0 (RIP_WARNING, "DrawTextExW: FAILURE DrawInfo.cxMaxWidth <=0");
                return (1);
            }
        }
    }

    /*
     * if we're not doing the drawing, initialise the lpk-dll
     */
    if (RTLREADING(dwDTformat)) {
        oldAlign = UserSetTextAlign(hdc, TA_RTLREADING | UserGetTextAlign(hdc));
    }

    /*
     * If we need to clip, let us do that.
     */
    if (!NOCLIP(wFormat)) {
        //
        // Save clipping region so we can restore it later.
        //
        // hrgnSave = SaveClipRgn(hdc);
        // IntersectClipRect(hdc, lprc->left, lprc->top, lprc->right, lprc->bottom);

        hrgnClip = UserCreateRectRgn(0,0,0,0);
        if (hrgnClip != NULL) {
            if (UserGetClipRgn(hdc, hrgnClip) != 1) {
                UserDeleteObject(hrgnClip);
                hrgnClip = (HRGN)-1;
            }
            rc = *lprc;
            UserIntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
        }
    } else {
        hrgnClip = NULL;
    }

    lpchTextBegin = lpchText;
    lpchEnd = lpchText + cchText;

ProcessDrawText:

    iLineCount = 0;  // Reset number of lines to 1.
    yLine = lprc->top;

    if (SINGLELINE(wFormat)) {
        iLineCount = 1;  // It is a single line.


        /*
         * Process single line DrawText.
         */
        switch (wFormat & DT_VFMTMASK) {
            case DT_BOTTOM:
                yLine = lprc->bottom - DrawInfo.cyLineHeight;
                break;

            case DT_VCENTER:
                yLine = lprc->top + ((lprc->bottom - lprc->top - DrawInfo.cyLineHeight) / 2);
                break;
        }

        cchText = AddEllipsisAndDrawLine(hdc, yLine, lpchText, cchText, dwDTformat, &DrawInfo, iCharset);
        yLine += DrawInfo.cyLineHeight;
        lpchText += cchText;
    } else  {

        /*
         * Multiline
         * If the height of the rectangle is not an integral multiple of the
         * average char height, then it is possible that the last line drawn
         * is only partially visible. However, if DT_EDITCONTROL style is
         * specified, then we must make sure that the last line is not drawn if
         * it is going to be partially visible. This will help imitate the
         * appearance of an edit control.
         */
        if (EDITCONTROL(wFormat))
            yLastLineHeight = DrawInfo.cyLineHeight;
        else
            yLastLineHeight = 0;

        iySign = DrawInfo.iYSign;
        fLastLine = FALSE;
        // Process multiline DrawText.
        while ((lpchText < lpchEnd) && (!fLastLine)) {
          // Check if the line we are about to draw is the last line that needs
          // to be drawn.
          // Let us check if the display goes out of the clip rect and if so
          // let us stop here, as an optimisation;
          if (!CALCRECT(wFormat) &&         // We don't need to calc rect?
                  (!NOCLIP(wFormat)) &&     // Must we clip the display ?
                                            // Are we outside the rect?
                  ((yLine + DrawInfo.cyLineHeight + yLastLineHeight)*iySign > (lprc->bottom*iySign))) {
              fLastLine = TRUE;    // Let us quit this loop
          }


          /*
           * We do the Ellipsis processing only for the last line.
           */
          if (fLastLine && (ENDELLIPSIS(dwDTformat) || PATHELLIPSIS(dwDTformat))) {
              lpchText += AddEllipsisAndDrawLine(hdc, yLine, lpchText, cchText, dwDTformat, &DrawInfo, iCharset);
          } else {
              lpchNextLineSt = (LPWSTR)DT_GetLineBreak(hdc, lpchText, cchText, dwDTformat, &iLineLength, &DrawInfo, iCharset);

              /*
               * Check if we need to put ellipsis at the end of this line.
               * Also check if this is the last line.
               */
              if (WORDELLIPSIS(dwDTformat) ||
                       ((lpchNextLineSt >= lpchEnd) && (ENDELLIPSIS(dwDTformat) || PATHELLIPSIS(dwDTformat))))
                  AddEllipsisAndDrawLine(hdc, yLine, lpchText, iLineLength, dwDTformat, &DrawInfo, iCharset);
              else
                  DT_DrawJustifiedLine(hdc, yLine, lpchText, iLineLength, dwDTformat, &DrawInfo, iCharset);
              cchText -= (int)((PBYTE)lpchNextLineSt - (PBYTE)lpchText) / sizeof(WCHAR);
              lpchText = lpchNextLineSt;
          }
            iLineCount++; // We draw one more line.
            yLine += DrawInfo.cyLineHeight;
        }


        /*
         * For Win3.1 and NT compatibility, if the last char is a CR or a LF
         * then the height returned includes one more line.
         */
        if (!EDITCONTROL(dwDTformat) &&
                (lpchEnd > lpchTextBegin)    &&   // If zero length it will fault.
                (((ch = (*(lpchEnd-1))) == CR) || (ch == LF)))
            yLine += DrawInfo.cyLineHeight;
    }


    /*
     * If DT_CALCRECT, modify width and height of rectangle to include
     * all of the text drawn.
     */
    if (CALCRECT(wFormat)) {
        DrawInfo.rcFormat.right = DrawInfo.rcFormat.left + DrawInfo.cxMaxExtent * DrawInfo.iXSign;
        lprc->right = DrawInfo.rcFormat.right + DrawInfo.cxRightMargin;

        // If the Width is more than what was provided, we have to redo all
        // the calculations, because, the number of lines can be less now.
        // (We need to do this only if we have more than one line).
        if((iLineCount > 1) && (DrawInfo.cxMaxExtent > DrawInfo.cxMaxWidth)) {
            DrawInfo.cxMaxWidth = DrawInfo.cxMaxExtent;
            lpchText = lpchTextBegin;
            cchText = (int)((PBYTE)lpchEnd - (PBYTE)lpchTextBegin)/sizeof(WCHAR);
            goto  ProcessDrawText;  // Start all over again!
        }
        lprc->bottom = yLine;
    }

// if (!NOCLIP(wFormat))
// {
//     RestoreClipRgn(hdc, hrgnClip);
// }

    if (hrgnClip != NULL) {
        if (hrgnClip == (HRGN)-1) {
            UserExtSelectClipRgn(hdc, NULL, RGN_COPY);
        } else {
            UserExtSelectClipRgn(hdc, hrgnClip, RGN_COPY);
            UserDeleteObject(hrgnClip);
        }
    }

    if (RTLREADING(dwDTformat))
        UserSetTextAlign(hdc, oldAlign);

    /*
     * Copy the number of characters actually drawn
     */
    if(lpDTparams != NULL)
        lpDTparams->uiLengthDrawn = (UINT)((PBYTE)lpchText - (PBYTE)lpchTextBegin)/sizeof(WCHAR);

    if (yLine == lprc->top)
        return 1;

    return (yLine - lprc->top);
}

/***************************************************************************\
*
* IsSysFontAndDefaultMode()
*
* Returns TRUE if font selected into DC is the system font AND the current
* mapping mode of the DC is MM_TEXT (Default mode); else returns FALSE. This
* is called by interrupt time code so it needs to be in the fixed code
* segment.
*
* History:
* 07-Jul-95 BradG   Ported from Win95
\***************************************************************************/

BOOL IsSysFontAndDefaultMode(HDC hdc)
{
    return((UserGetHFONT(hdc) == ghFontSys) && (UserGetMapMode(hdc) == MM_TEXT));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\menu.c ===
/****************************** Module Header ******************************\
* Module Name: menu.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains common menu functions.
*
* History:
* 11-15-94 JimA         Created.
\***************************************************************************/


/***************************************************************************\
* GetMenuDefaultItem
*
* Searches through a menu for the default item. A menu can have at most
* one default. We will return either the ID or the position, as requested.
*
* We try to return back the first non-disabled default item. However, if
* all of the defaults we encountered were disabled, we'll return back the
* the first default if we found it.
*
\***************************************************************************/
DWORD _GetMenuDefaultItem(
    PMENU pMenu,
    BOOL fByPosition,
    UINT uFlags)
{
    int iItem, cItems;
    PITEM pItem;
    PMENU pSubMenu;

    pItem = REBASEALWAYS(pMenu, rgItems);
    cItems = pMenu->cItems;

    /*
     * Walk the list of items sequentially until we find one that has
     * MFS_DEFAULT set.
     */
    for (iItem = 0; iItem < cItems; iItem++, pItem++) {
        if (TestMFS(pItem, MFS_DEFAULT)) {
            if ((uFlags & GMDI_USEDISABLED) || !TestMFS(pItem, MFS_GRAYED)) {
                if ((uFlags & GMDI_GOINTOPOPUPS) && (pItem->spSubMenu != NULL)) {
                    DWORD id;

                    /*
                     * Is there a valid submenu default?  If not, we'll use
                     * this one.
                     */
                    pSubMenu = REBASEPTR(pMenu, pItem->spSubMenu);
                    id = _GetMenuDefaultItem(pSubMenu, fByPosition, uFlags);
                    if (id != MFMWFP_NOITEM)
                        return id;
                }

                break;
            }
        }
    }

    if (iItem < cItems) {
        return (fByPosition ? iItem : pItem->wID);
    } else {
        return MFMWFP_NOITEM;
    }
}

/***************************************************************************\
* xxxMNCanClose
*
* Returns TRUE if the given window either doesn't have a system menu or has
* a system menu which has an enabled menu item with the SC_CLOSE syscommand
* id.
*
\***************************************************************************/
BOOL xxxMNCanClose(
    PWND pwnd)
{
    PMENU   pMenu;
    PITEM   pItem;
    PCLS    pcls;

    CheckLock(pwnd);

    pcls = (PCLS)REBASEALWAYS(pwnd, pcls);
    if (TestCF2(pcls, CFNOCLOSE)) {
        return FALSE;
    }

    pMenu = xxxGetSysMenuHandle(pwnd);
    if (!pMenu || !(pMenu = REBASEPTR(pwnd, pMenu))) {
        return FALSE;
    }

    /*
     * Note how this parallels the code in SetCloseDefault -- we check for
     * 3 different IDs.
     */
    pItem = MNLookUpItem(pMenu, SC_CLOSE, FALSE, NULL);

    if (!pItem) {
        pItem = MNLookUpItem(pMenu, SC_CLOSE-0x7000, FALSE, NULL);
        if (!pItem) {
            pItem = MNLookUpItem(pMenu, 0xC070, FALSE, NULL);
        }
    }

    return (pItem && !TestMFS(pItem, MFS_GRAYED));
}

/***************************************************************************\
* xxxLoadSysMenu
*
* Loads a menu from USER32.DLL and then gives it the "NT5 look".
*
* History
*  04/02/97 GerardoB    Created.
*  06/28/00 JasonSch    Added code to add menu item for the lame button.
\***************************************************************************/
RTLMENU xxxLoadSysMenu(
#ifdef LAME_BUTTON
    UINT uMenuId,
    PWND pwnd)
#else
    UINT uMenuId)
#endif // LAME_BUTTON
{
    RTLMENU rtlMenu;
    MENUINFO mi;
    MENUITEMINFO mii;
    TL tlMenu;

#ifdef _USERK_
    UNICODE_STRING strMenuName;
    RtlInitUnicodeStringOrId(&strMenuName, MAKEINTRESOURCE(uMenuId));
    rtlMenu = xxxClientLoadMenu(NULL, &strMenuName);
#else
    rtlMenu = LoadMenu(hmodUser, MAKEINTRESOURCE(uMenuId));
#endif // _USERK_

    if (rtlMenu == NULL) {
        RIPMSG1(RIP_WARNING, "xxxLoadSysMenu failed to load: %#lx", uMenuId);
        return NULL;
    }

    ThreadLockAlways(rtlMenu, &tlMenu);

    /*
     * Add the checkorbmp style (draw bitmaps and checkmarks on the
     * same column).
     */
    mi.cbSize = sizeof(mi);
    mi.fMask = MIM_STYLE | MIM_APPLYTOSUBMENUS;
    mi.dwStyle = MNS_CHECKORBMP;
    xxxRtlSetMenuInfo(rtlMenu, &mi);

    /*
     * Add the bitmaps for close, minimize, maximize and restore items.
     */
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_BITMAP;
    mii.hbmpItem = HBMMENU_POPUP_CLOSE;
    xxxRtlSetMenuItemInfo(rtlMenu, SC_CLOSE, &mii);
    if (uMenuId != ID_DIALOGSYSMENU) {
        mii.hbmpItem = HBMMENU_POPUP_MINIMIZE;
        xxxRtlSetMenuItemInfo (rtlMenu, SC_MINIMIZE, &mii);
        mii.hbmpItem = HBMMENU_POPUP_MAXIMIZE;
        xxxRtlSetMenuItemInfo (rtlMenu, SC_MAXIMIZE, &mii);
        mii.hbmpItem = HBMMENU_POPUP_RESTORE;
        xxxRtlSetMenuItemInfo (rtlMenu, SC_RESTORE, &mii);
    }

#ifdef LAME_BUTTON
    if (pwnd && TestWF(pwnd, WEFLAMEBUTTON)) {
        /*
         * We want to add a lame button item to the this window's system menu.
         *
         * The menuitem is added to the beginning of the menu, and then a
         * separator is added after it.
         */
        RTLMENU rtlSubMenu = RtlGetSubMenu(rtlMenu, 0);
        PMENU pSubMenu;
#ifdef _USERK_
        pSubMenu = rtlSubMenu;
#else
        pSubMenu = VALIDATEHMENU(rtlSubMenu);
#endif // _USERK_

        if (pSubMenu != NULL) {
            UNICODE_STRING strItem;
            TL tlmenu;

            RtlInitUnicodeString(&strItem, gpsi->gwszLame);
            RtlZeroMemory(&mii, sizeof(mii));
            mii.cbSize = sizeof(mi);
            mii.fMask = MIIM_TYPE;
            mii.fType = MFT_SEPARATOR;

            ThreadLockAlways(rtlSubMenu, &tlmenu);
            xxxRtlInsertMenuItem(rtlSubMenu, 0, TRUE, &mii, &strItem);
            mii.fType = 0;
            mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_STRING;
            mii.dwTypeData = strItem.Buffer;
            mii.wID = SC_LAMEBUTTON;
            xxxRtlInsertMenuItem(rtlSubMenu, 0, TRUE, &mii, &strItem);
            ThreadUnlock(&tlmenu);
        }
    }
#endif // LAME_BUTTON

    ThreadUnlock(&tlMenu);
    return rtlMenu;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\alignrec.c ===
/**************************************************************************\
* Module Name: mergerec.c
*
* Contains all the code to reposition rectangles
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* NOTES:
*
* History:
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define MONITORS_MAX 10

#define RectCenterX(prc)    ((prc)->left+((prc)->right-(prc)->left)/2)
#define RectCenterY(prc)    ((prc)->top+((prc)->bottom-(prc)->top)/2)

// ----------------------------------------------------------------------------
//
//  INTERSECTION_AXIS()
//      This macro tells us how a particular set of overlapping rectangles
//  should be adjusted to remove the overlap.  It is basically a condensed
//  version of a lookup table that does the same job.  The parameters for the
//  macro are two rectangles, where one is the intersection of the other with
//  a third (unspecified) rectangle.  The macro compares the edges of the
//  rectangles to determine which sides of the intersection were "caused" by
//  the source rectangle.  In the pre-condensed version of this macro, the
//  results of these comparisons (4 bits) would be used to index into a 16
//  entry table which specifies the way to resolve the overlap.  However, this
//  is highly redundant, as the table would actually represents several rotated
//  and/or inverted instances of a few basic relationships:
//
//  Horizontal Vertical  Diagonal  Contained       Crossing
//      *--*    *-----*   *---*     *-----*         *----*
//   *--+* |    | *-* |   | *-+-*   | *-* |       *-+----+-*
//   |  || |    *-+-+-*   | | | |   | | | |  and  | |    | |
//   *--+* |      | |     *-+-* |   | *-* |       *-+----+-*
//      *--*      *-*       *---*   *-----*         *----*
//
//  What we are really interested in determining is whether we "should" move
//  the rectangles horizontally or vertically to resolve the overlap, hence we
//  are testing for three states: Horizontal, Vertical and Don't Know.
//
//  The macro gives us these three states by XORing the high and low bits of
//  of the comparison to reduce the table to 4 cases where 1 and 2 are
//  vertical and horizontal respectively, and then subtracting 1 so that the
//  2 bit signifies "unknown-ness."
//
//  Note that there are some one-off cases in the comparisons because we are
//  not actually looking at the third rectangle.  However this greatly reduces
//  the complexity so these small errors are acceptible given the scale of the
//  rectangles we are comparing.
//
// ----------------------------------------------------------------------------
#define INTERSECTION_AXIS(a, b) \
    (((((a->left == b->left) << 1) | (a->top == b->top)) ^ \
    (((a->right == b->right) << 1) | (a->bottom == b->bottom))) - 1)

#define INTERSECTION_AXIS_VERTICAL      (0)
#define INTERSECTION_AXIS_HORIZONTAL    (1)
#define INTERSECTION_AXIS_UNKNOWN(code) (code & 2)

// ----------------------------------------------------------------------------
//
//  CenterRectangles()
//      Move all the rectangles so their origin is the center of their union.
//
// ----------------------------------------------------------------------------
void NEAR PASCAL CenterRectangles(LPRECT arc, UINT count)
{
    LPRECT lprc, lprcL;
    RECT rcUnion;

    CopyRect(&rcUnion, arc);

    lprcL = arc + count;
    for (lprc = arc + 1; lprc < lprcL; lprc++)
    {
        UnionRect(&rcUnion, &rcUnion, lprc);
    }

    for (lprc = arc; count; count--)
    {
        OffsetRect(lprc, -RectCenterX(&rcUnion), -RectCenterY(&rcUnion));
        lprc++;
    }
}

// ----------------------------------------------------------------------------
//
//  RemoveOverlap()
//    This is called from RemoveOverlaps to resolve conflicts when two
//  rectangles overlap.  It returns the PMONITOR for the monitor it decided to
//  move.  This routine always moves rectangles away from the origin so it can
//  be used to converge on a zero-overlap configuration.
//
//  This function will bias slightly toward moving lprc2 (all other things
//  being equal).
//
// ----------------------------------------------------------------------------
LPRECT NEAR PASCAL RemoveOverlap(LPRECT lprc1, LPRECT lprc2, LPRECT lprcI)
{
    LPRECT lprcMove, lprcStay;
    POINT ptC1, ptC2;
    BOOL fNegative;
    BOOL fC1Neg;
    BOOL fC2Neg;
    int dC1, dC2;
    int xOffset;
    int yOffset;
    int nAxis;

    //
    // Compute the centers of both rectangles.  We will need them later.
    //
    ptC1.x = RectCenterX(lprc1);
    ptC1.y = RectCenterY(lprc1);
    ptC2.x = RectCenterX(lprc2);
    ptC2.y = RectCenterY(lprc2);

    //
    // Decide whether we should move things horizontally or vertically.  All
    // this goop is here so it will "feel" right when the system needs to
    // move a monitor on you.
    //
    nAxis = INTERSECTION_AXIS(lprcI, lprc1);

    if (INTERSECTION_AXIS_UNKNOWN(nAxis))
    {
        //
        // Is this a "big" intersection between the two rectangles?
        //
        if (PtInRect(lprcI, ptC1) || PtInRect(lprcI, ptC2))
        {
            //
            // This is a "big" overlap.  Decide if the rectangles
            // are aligned more "horizontal-ish" or "vertical-ish."
            //
            xOffset = ptC1.x - ptC2.x;
            if (xOffset < 0)
                xOffset *= -1;
            yOffset = ptC1.y - ptC2.y;
            if (yOffset < 0)
                yOffset *= -1;

            if (xOffset >= yOffset)
                nAxis = INTERSECTION_AXIS_HORIZONTAL;
            else
                nAxis = INTERSECTION_AXIS_VERTICAL;
        }
        else
        {
            //
            // This is a "small" overlap.  Move the rectangles the
            // smallest distance that will fix the overlap.
            //
            if ((lprcI->right - lprcI->left) <= (lprcI->bottom - lprcI->top))
                nAxis = INTERSECTION_AXIS_HORIZONTAL;
            else
                nAxis = INTERSECTION_AXIS_VERTICAL;
        }
    }

    //
    // We now need to pick the rectangle to move.  Move the one
    // that is further from the origin along the axis of motion.
    //
    if (nAxis == INTERSECTION_AXIS_HORIZONTAL)
    {
        dC1 = ptC1.x;
        dC2 = ptC2.x;
    }
    else
    {
        dC1 = ptC1.y;
        dC2 = ptC2.y;
    }

    if ((fC1Neg = (dC1 < 0)) != 0)
        dC1 *= -1;

    if ((fC2Neg = (dC2 < 0)) != 0)
        dC2 *= -1;

    if (dC2 < dC1)
    {
        lprcMove     = lprc1;
        lprcStay     = lprc2;
        fNegative    = fC1Neg;
    }
    else
    {
        lprcMove     = lprc2;
        lprcStay     = lprc1;
        fNegative    = fC2Neg;
    }

    //
    // Compute a new home for the rectangle and put it there.
    //
    if (nAxis == INTERSECTION_AXIS_HORIZONTAL)
    {
        int xPos;

        if (fNegative)
            xPos = lprcStay->left - (lprcMove->right - lprcMove->left);
        else
            xPos = lprcStay->right;

        xOffset = xPos - lprcMove->left;
        yOffset = 0;
    }
    else
    {
        int yPos;

        if (fNegative)
            yPos = lprcStay->top - (lprcMove->bottom - lprcMove->top);
        else
            yPos = lprcStay->bottom;

        yOffset = yPos - lprcMove->top;
        xOffset = 0;
    }

    OffsetRect(lprcMove, xOffset, yOffset);
    return lprcMove;
}

// ----------------------------------------------------------------------------
//
//  RemoveOverlaps()
//    This is called from CleanupDesktopRectangles make sure the monitor array
//  is non-overlapping.
//
// ----------------------------------------------------------------------------
void NEAR PASCAL RemoveOverlaps(LPRECT arc, UINT count)
{
    LPRECT lprc1, lprc2, lprcL;

    //
    // Center the rectangles around a common origin.  We will move them outward
    // when there are conflicts so centering (a) reduces running time and
    // hence (b) reduces the chances of totally mangling the positions.
    //
    CenterRectangles(arc, count);

    //
    // Now loop through the array fixing any overlaps.
    //
    lprcL = arc + count;
    lprc2 = arc + 1;

ReScan:
    while (lprc2 < lprcL)
    {
        //
        // Scan all rectangles before this one looking for intersections.
        //
        for (lprc1 = arc; lprc1 < lprc2; lprc1++)
        {
            RECT rcI;

            //
            // Move one of the rectanges if there is an intersection.
            //
            if (IntersectRect(&rcI, lprc1, lprc2))
            {
                //
                // Move one of the rectangles out of the way and then restart
                // the scan for overlaps with that rectangle (since moving it
                // may have created new overlaps).
                //
                lprc2 = RemoveOverlap(lprc1, lprc2, &rcI);
                goto ReScan;
            }
        }

        lprc2++;
    }
}

// ----------------------------------------------------------------------------
//
//  AddNextContiguousRectangle()
//    This is called from RemoveGaps to find the next contiguous rectangle
//  in the array.  If there are no more contiguous rectangles it picks the
//  closest rectangle and moves it so it is contiguous.
//
// ----------------------------------------------------------------------------
LPRECT FAR * NEAR PASCAL AddNextContiguousRectangle(LPRECT FAR *aprc,
    LPRECT FAR *pprcSplit, UINT count)
{
    LPRECT FAR *pprcL;
    LPRECT FAR *pprcTest;
    LPRECT FAR *pprcAxis;
    LPRECT FAR *pprcDiag;
    UINT dAxis = (UINT)-1;
    UINT dDiag = (UINT)-1;
    POINT dpAxis;
    POINT dpDiag;
    POINT dpMove;

    pprcL = aprc + count;

    for (pprcTest = aprc; pprcTest < pprcSplit; pprcTest++)
    {
        LPRECT lprcTest = *pprcTest;
        LPRECT FAR *pprcScan;

        for (pprcScan = pprcSplit; pprcScan < pprcL; pprcScan++)
        {
            RECT rcCheckOverlap;
            LPRECT lprcScan = *pprcScan;
            LPRECT FAR *pprcCheckOverlap;
            LPRECT FAR *FAR *pppBest;
            LPPOINT pdpBest;
            UINT FAR *pdBest;
            UINT dX, dY;
            UINT dTotal;

            //
            // Figure out how far the rectangle may be along both axes.
            // Note some of these numbers could be garbage at this point but
            // the code below will take care of it.
            //
            if (lprcScan->right <= lprcTest->left)
                dpMove.x = dX = lprcTest->left - lprcScan->right;
            else
                dpMove.x = -(int)(dX = (lprcScan->left - lprcTest->right));

            if (lprcScan->bottom <= lprcTest->top)
                dpMove.y = dY = lprcTest->top - lprcScan->bottom;
            else
                dpMove.y = -(int)(dY = (lprcScan->top - lprcTest->bottom));

            //
            // Figure out whether the rectangles are vertical, horizontal or
            // diagonal to each other and pick the measurements we will test.
            //
            if ((lprcScan->top < lprcTest->bottom) &&
                (lprcScan->bottom > lprcTest->top))
            {
                // The rectangles are somewhat horizontally aligned.
                dpMove.y = dY = 0;
                pppBest = &pprcAxis;
                pdpBest = &dpAxis;
                pdBest = &dAxis;
            }
            else if ((lprcScan->left < lprcTest->right) &&
                (lprcScan->right > lprcTest->left))
            {
                // The rectangles are somewhat vertically aligned.
                dpMove.x = dX = 0;
                pppBest = &pprcAxis;
                pdpBest = &dpAxis;
                pdBest = &dAxis;
            }
            else
            {
                // The rectangles are somewhat diagonally aligned.
                pppBest = &pprcDiag;
                pdpBest = &dpDiag;
                pdBest = &dDiag;
            }

            //
            // Make sure there aren't other rectangles in the way.  We only
            // need to check the upper array since that is the pool of
            // semi-placed rectangles.  Any rectangles in the lower array that
            // are "in the way" will be found in a different iteration of the
            // enclosing loop.
            //

            CopyRect(&rcCheckOverlap, lprcScan);
            OffsetRect(&rcCheckOverlap, dpMove.x, dpMove.y);

            for (pprcCheckOverlap = pprcScan + 1; pprcCheckOverlap < pprcL;
                pprcCheckOverlap++)
            {
                RECT rc;
                if (IntersectRect(&rc, *pprcCheckOverlap, &rcCheckOverlap))
                    break;
            }
            if (pprcCheckOverlap < pprcL)
            {
                // There was another rectangle in the way; don't use this one.
                continue;
            }

            //
            // If it is closer than the one we already had, use it instead.
            //
            dTotal = dX + dY;
            if (dTotal < *pdBest)
            {
                *pdBest = dTotal;
                *pdpBest = dpMove;
                *pppBest = pprcScan;
            }
        }
    }

    //
    // If we found anything along an axis use that otherwise use a diagonal.
    //
    if (dAxis != (UINT)-1)
    {
        pprcSplit = pprcAxis;
        dpMove = dpAxis;
    }
    else if (dDiag != (UINT)-1)
    {
        // NOTE (AndreVa): consider moving the rectangle to a side in this case.
        // (that, of course would add a lot of code to avoid collisions)
        pprcSplit = pprcDiag;
        dpMove = dpDiag;
    }
    else
        dpMove.x = dpMove.y = 0;

    //
    // Move the monitor into place and return it as the one we chose.
    //
    if (dpMove.x || dpMove.y)
        OffsetRect(*pprcSplit, dpMove.x, dpMove.y);

    return pprcSplit;
}

// ----------------------------------------------------------------------------
//
//  RemoveGaps()
//    This is called from CleanupDesktopRectangles to make sure the monitor
//  array is contiguous.  It assumes that the array is already non-overlapping.
//
// ----------------------------------------------------------------------------
void NEAR PASCAL RemoveGaps(LPRECT arc, UINT count)
{
    LPRECT aprc[MONITORS_MAX];
    LPRECT lprc, lprcL, lprcSwap, FAR *pprc, FAR *pprcNearest;
    UINT uNearest;

    //
    // We will need to find the rectangle closest to the center of the group.
    // We don't really need to center the array here but it doesn't hurt and
    // saves us some code below.
    //
    CenterRectangles(arc, count);

    //
    // Build an array of LPRECTs we can shuffle around with relative ease while
    // not disturbing the order of the passed array.  Also take note of which
    // one is closest to the center so we start with it and pull the rest of
    // the rectangles inward.  This can make a big difference in placement when
    // there are more than 2 rectangles.
    //
    uNearest = (UINT)-1;
    pprcNearest = pprc = aprc;
    lprcL = (lprc = arc) + count;

    while (lprc < lprcL)
    {
        int x, y;
        UINT u;

        //
        // Fill in the array.
        //
        *pprc = lprc;

        //
        // Check if this one is closer to the center of the group.
        //
        x = RectCenterX(lprc);
        y = RectCenterY(lprc);
        if (x < 0) x *= -1;
        if (y < 0) y *= -1;

        u = (UINT)x + (UINT)y;
        if (u < uNearest)
        {
            uNearest    = u;
            pprcNearest = pprc;
        }

        pprc++;
        lprc++;
    }

    //
    // Now make sure we move everything toward the centermost rectangle.
    //
    if (pprcNearest != aprc)
    {
        lprcSwap     = *pprcNearest;
        *pprcNearest = *aprc;
        *aprc        = lprcSwap;
    }

    //
    // Finally, loop through the array closing any gaps.
    //
    pprc = aprc + 1;
    for (lprc = arc + 1; lprc < lprcL; pprc++, lprc++)
    {
        //
        // Find the next suitable rectangle to combine into the group and move
        // it into position.
        //
        pprcNearest = AddNextContiguousRectangle(aprc, pprc, count);

        //
        // If the rectangle that was added is not the next in our array, swap.
        //
        if (pprcNearest != pprc)
        {
            lprcSwap     = *pprcNearest;
            *pprcNearest = *pprc;
            *pprc        = lprcSwap;
        }
    }
}

// ----------------------------------------------------------------------------
//
//  CleanUpDesktopRectangles()
//    This is called by CleanUpMonitorRectangles (etc) to force a set of
//  rectangles into a contiguous, non-overlapping arrangement.
//
// ----------------------------------------------------------------------------

BOOL
AlignRects(LPRECT arc, DWORD cCount, DWORD iPrimary, DWORD dwFlags)
{
    LPRECT lprc, lprcL;

    //
    // Limit for loops.
    //

    lprcL = arc + cCount;

    //
    // We don't need to get all worked up if there is only one rectangle.
    //

    if (cCount > MONITORS_MAX)
    {
        return FALSE;
    }


    if (cCount > 1)
    {
        if (!(dwFlags & CUDR_NOSNAPTOGRID))
        {
            //
            // Align monitors on 8 pixel boundaries so GDI can use the same
            // brush realization on compatible devices (BIG performance win).
            // Note that we assume the size of a monitor will be in multiples
            // of 8 pixels on X and Y.  We cannot do this for the work areas so
            // we convert them to be relative to the origins of their monitors
            // for the time being.
            //
            // The way we do this alignment is to just do the overlap/gap
            // resoluton in 8 pixel space (ie divide everything by 8 beforehand
            // and multiply it by 8 afterward).
            //
            // Note: WE CAN'T USE MULTDIV HERE because it introduces one-off
            // errors when monitors span the origin.  These become eight-off
            // errors when we scale things back up and we end up trying to
            // create DCs with sizes like 632x472 etc (not too good).  It also
            // handles rounding the wierdly in both positive and negative space
            // and we just want to snap things to a grid so we compensate for
            // truncation differently here.
            //
            for (lprc = arc; lprc < lprcL; lprc++)
            {
                RECT rc;
                int d;


                CopyRect(&rc, lprc);

                d = rc.right - rc.left;

                if (rc.left < 0)
                    rc.left -= 4;
                else
                    rc.left += 3;

                rc.left /= 8;
                rc.right = rc.left + (d / 8);

                d = rc.bottom - rc.top;

                if (rc.top < 0)
                    rc.top -= 4;
                else
                    rc.top += 3;

                rc.top /= 8;
                rc.bottom = rc.top + (d / 8);

                CopyRect(lprc, &rc);
            }
        }

        //
        // RemoveGaps is designed assuming that none of the rectangles that it
        // is passed will overlap.  Thus we cannot safely call it if we have
        // skipped the call to RemoveOverlaps or it might loop forever.
        //
        if (!(dwFlags & CUDR_NORESOLVEPOSITIONS))
        {
            RemoveOverlaps(arc, cCount);

            if (!(dwFlags & CUDR_NOCLOSEGAPS))
            {
                RemoveGaps(arc, cCount);
            }
        }

        if (!(dwFlags & CUDR_NOSNAPTOGRID))
        {
            //
            // Now return the monitor rectangles to pixel units this is a
            // simple multiply and MultDiv doesn't offer us any code size
            // advantage so (I guess that assumes a bit about the compiler,
            // but...) just do it right here.
            //
            for (lprc = arc; lprc < lprcL; lprc++)
            {
                lprc->left   *= 8;
                lprc->top    *= 8;
                lprc->right  *= 8;
                lprc->bottom *= 8;
            }
        }
    }

    if (!(dwFlags & CUDR_NOPRIMARY))
    {
        //
        // Reset all the coordinates based on the primaries position,
        // so that it is always located at 0,0
        //

        LONG dx = -((arc + iPrimary)->left);
        LONG dy = -((arc + iPrimary)->top);

        for (lprc = arc; lprc < lprcL; lprc++)
        {
            OffsetRect(lprc, dx, dy);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\chartran.c ===
/****************************** Module Header ******************************\
* Module Name: chartran.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the routines for translating ACP characters
* to Unicode and translating Unicode characters to ACP characters.
* NOTE: The ACP is the currently installed 8-bit code page.
*
*
* History:
* 08-01-91 GregoryW      Created.
* 05-14-92 GregoryW      Modified to use the Rtl translation routines.
\***************************************************************************/

extern __declspec(dllimport) USHORT NlsAnsiCodePage;

#ifndef THREAD_CODEPAGE
#ifdef _USERK_
#define THREAD_CODEPAGE() (PtiCurrent()->pClientInfo->CodePage)
#else
#define THREAD_CODEPAGE() (GetClientInfo()->CodePage)
#endif // _USERK_
#endif


#define IS_ACP(cp) (((cp) == NlsAnsiCodePage) || ((cp) == CP_ACP))

/***************************************************************************\
* WCSToMBEx (API)
*
* Convert a wide-character (Unicode) string to MBCS (ANSI) string.
*
* nAnsiChar > 0 indicates the number of bytes to allocate to store the
*    ANSI string (if bAllocateMem == TRUE) or the size of the buffer
*    pointed to by *pAnsiString (bAllocateMem == FALSE).
*
* nAnsiChar == -1 indicates that the necessary number of bytes be allocated
*    to hold the translated string.  bAllocateMem must be set to TRUE in
*    this case.
*
* Return value
*   Success: number of characters in the output string
*        If bAllocateMem was TRUE, then FreeAnsiString() may be
*        used to free the allocated memory at *ppAnsiString.
*   Failure: 0 means failure
*        (Any buffers allocated by this routine are freed)
*
* History:
*  1992-??-?? GregoryW   Created
*  1993-01-07 IanJa      fix memory leak on error case.
\***************************************************************************/

int
WCSToMBEx(
    WORD wCodePage,
    LPCWSTR pUnicodeString,
    int cchUnicodeString,
    LPSTR *ppAnsiString,
    int nAnsiChar,
    BOOL bAllocateMem)
{
    ULONG nCharsInAnsiString;
#ifdef _USERK_
    INT iCharsInAnsiString;
#endif // _USERK_

    if (nAnsiChar == 0 || cchUnicodeString == 0 || pUnicodeString == NULL) {
        return 0;      // nothing to translate or nowhere to put it
    }

    /*
     * Adjust the cchUnicodeString value.  If cchUnicodeString == -1 then the
     * string pointed to by pUnicodeString is NUL terminated so we
     * count the number of bytes.  If cchUnicodeString < -1 this is an
     * illegal value so we return FALSE.  Otherwise, cchUnicodeString is
     * set and requires no adjustment.
     */
    if (cchUnicodeString == -1) {
        cchUnicodeString = (wcslen(pUnicodeString) + 1);
    } else if (cchUnicodeString < -1) {
        return 0;     // illegal value
    }

    /*
     * Adjust the nAnsiChar value.  If nAnsiChar == -1 then we pick a
     * value based on cchUnicodeString to hold the converted string.  If
     * nAnsiChar < -1 this is an illegal value so we return FALSE.
     * Otherwise, nAnsiChar is set and requires no adjustment.
     */
    if (nAnsiChar == -1) {
        if (bAllocateMem == FALSE) {
            return 0;  // no destination
        }
        nAnsiChar = cchUnicodeString * DBCS_CHARSIZE;
    } else if (nAnsiChar < -1) {
        return 0;     // illegal value
    }

    if (bAllocateMem) {
        /*
         * We need to allocate memory to hold the translated string.
         */
        *ppAnsiString = (LPSTR)UserRtlAllocMem(nAnsiChar);
        if (*ppAnsiString == NULL) {
            return 0;
        }
    }

    /*
     * translate Unicode string pointed to by pUnicodeString into
     * ANSI and store in location pointed to by pAnsiString.  We
     * stop translating when we fill up the ANSI buffer or reach
     * the end of the Unicode string.
     */

    /*
     * if the target multibyte codepage is eqaul to ACP, Call faster Rtl function.
     */
    if (IS_ACP(wCodePage)) {

        NTSTATUS Status;

        Status = RtlUnicodeToMultiByteN(
                        (PCH)*ppAnsiString,
                        nAnsiChar,
                        &nCharsInAnsiString,
                        (PWCH)pUnicodeString,
                        cchUnicodeString * sizeof(WCHAR));
        /*
         * If the ansi buffer is too small, RtlUnicodeToMultiByteN()
         * returns STATUS_BUFFER_OVERFLOW. In this case, the function
         * put as many ansi characters as specified in the buffer and
         *  returns the number by chacacters(in bytes) written. We would
         * like to return the actual byte  count written in the ansi
         * buffer rather than returnning 0 since callers of this function
         * don't expect to be returned 0 in most case.
         */

        if (!NT_SUCCESS(Status) && Status != STATUS_BUFFER_OVERFLOW) {
            if (bAllocateMem) {
                UserRtlFreeMem(*ppAnsiString);
            }
            return 0;   // translation failed
        }

        return (int)nCharsInAnsiString;

    } else {

#ifdef _USERK_
        /*
         * Call GRE to convert string to Unicode. (Kernel mode)
         */

        iCharsInAnsiString = EngWideCharToMultiByte(
                                 (UINT)wCodePage,
                                 (LPWSTR)pUnicodeString,
                                 cchUnicodeString * sizeof(WCHAR),
                                 (LPSTR)*ppAnsiString,
                                 nAnsiChar);

        nCharsInAnsiString = (iCharsInAnsiString == -1) ? 0 :
                                                          (ULONG) iCharsInAnsiString;

#else
        /*
         * Call NLS API (Kernel32) to convert string to Unicode. (User mode)
         */
        nCharsInAnsiString = WideCharToMultiByte(
                                 (UINT)wCodePage, 0,
                                 (LPCWSTR)pUnicodeString,
                                 cchUnicodeString,
                                 (LPSTR)*ppAnsiString,
                                 nAnsiChar,
                                 NULL, NULL);
#endif // _USERK_

        if (nCharsInAnsiString == 0) {
            if (bAllocateMem) {
                UserRtlFreeMem(*ppAnsiString);
            }
        }

        return (int)nCharsInAnsiString;
    }
}

// Returns number of character converted

int MBToWCSEx(
    WORD wCodePage,
    LPCSTR pAnsiString,
    int nAnsiChar,
    LPWSTR *ppUnicodeString,
    int cchUnicodeString,
    BOOL bAllocateMem)
{
    ULONG nBytesInUnicodeString;

    if (nAnsiChar == 0 || cchUnicodeString == 0 || pAnsiString == NULL) {
        return 0;      // nothing to translate or nowhere to put it
    }

    /*
     * Adjust the nAnsiChar value.  If nAnsiChar == -1 then the
     * string pointed to by pAnsiString is NUL terminated so we
     * count the number of bytes.  If nAnsiChar < -1 this is an
     * illegal value so we return FALSE.  Otherwise, nAnsiChar is
     * set and requires no adjustment.
     */

#ifdef _USERK_
    UserAssert(nAnsiChar >= USER_AWCONV_COUNTSTRINGSZ);
#endif
    if (nAnsiChar < 0) {

        /*
         *  Bug 268035 - joejo
         *  Need to fail if the count is a negative number less than -2!
         */
        if (nAnsiChar < USER_AWCONV_COUNTSTRINGSZ) {
            return 0;
        }

#if (USER_AWCONV_COUNTSTRING != -1 || USER_AWCONV_COUNTSTRINGSZ != -2)
#error USER_AWCONV_COUNTSTRING or USER_AWCONV_COUNTSTRINGSZ has unexpected value.
#endif
        /* HACK HACK HACK
         * If nAnsiChar is -1 (USER_AWCONV_COUNTSTRING), nAnsiChar length will be strlen() + 1,
         * to allocate the memory including trailing \0: this is compatible to the original code.
         * If nAnsiCahr is -2 (USER_AWCONV_COUNTSTRINGSZ), memory for trailing \0 will not be needed,
         * so memory allocation is optimized and the return value would be same as strlen().
         */
        nAnsiChar = strlen(pAnsiString) + 2 + nAnsiChar;   // don't forget the NUL if nAnsiChar == -1

        if (nAnsiChar == 0) {
            return 0;
        }
    }

    /*
     * Adjust the cchUnicodeString value.  If cchUnicodeString == -1 then we
     * pick a value based on nAnsiChar to hold the converted string.  If
     * cchUnicodeString < -1 this is an illegal value so we return FALSE.
     * Otherwise, cchUnicodeString is set and requires no adjustment.
     */
    if (cchUnicodeString == -1) {
        if (bAllocateMem == FALSE) {
            return 0;    // no destination
        }
        cchUnicodeString = nAnsiChar;
    } else if (cchUnicodeString < -1) {
        return 0;     // illegal value
    }

    if (bAllocateMem) {
        *ppUnicodeString = (LPWSTR)UserRtlAllocMem(cchUnicodeString*sizeof(WCHAR));
        if (*ppUnicodeString == NULL) {
            return 0;    // allocation failed
        }
    }

    /*
     * if codepage is CP_ACP, We will call faster RtlXXX function.
     */
    if (IS_ACP(wCodePage)) {
        /*
         * translate ANSI string pointed to by pAnsiString into Unicode
         * and store in location pointed to by pUnicodeString.  We
         * stop translating when we fill up the Unicode buffer or reach
         * the end of the ANSI string.
         */
        if (!NT_SUCCESS(RtlMultiByteToUnicodeN(
                            (PWCH)*ppUnicodeString,
                            cchUnicodeString * sizeof(WCHAR),
                            &nBytesInUnicodeString,
                            (PCH)pAnsiString,
                            nAnsiChar
                            ))) {
            if (bAllocateMem) {
                UserRtlFreeMem(*ppUnicodeString);
            }
            return 0;   // translation failed
        }

        return (int)(nBytesInUnicodeString / sizeof(WCHAR));

    } else {
        /*
         * if wCodePage is not ACP, Call NLS API.
         */
        ULONG nCharsInUnicodeString;

#ifdef _USERK_

        /*
         * I believe we will never hit this code which is why I am
         * adding this assert.  [gerritv] 5-21-96
         */
#define SHOULD_NOT_REACH_HERE   0
        UserAssert(SHOULD_NOT_REACH_HERE);
#undef  SHOULD_NOT_REACH_HERE
        return 0;

#if 0   // FYI: old code
        INT   iCharsInUnicodeString;

        /*
         * Call GRE to convert string to Unicode. (Kernel mode)
         * I believe we will never hit this code which is why I am
         * adding this assert.  [gerritv] 5-21-96
         */

        UserAssert(0);

        iCharsInUnicodeString = EngMultiByteToWideChar(
                                    (UINT)wCodePage,
                                    (LPWSTR)*ppUnicodeString,
                                    (int)cchUnicodeString * sizeof(WCHAR),
                                    (LPSTR)pAnsiString,
                                    (int)nAnsiChar);

        nCharsInUnicodeString = (iCharsInUnicodeString == -1) ? 0 :
                                                          (ULONG) iCharsInUnicodeString;
#endif

#else
        /*
         * Call NLS API (Kernel32) to convert string to Unicode. (User mode)
         */
        nCharsInUnicodeString = MultiByteToWideChar(
                                    (UINT)wCodePage, 0,
                                    (LPCSTR)pAnsiString,
                                    (int)nAnsiChar,
                                    (LPWSTR)*ppUnicodeString,
                                    (int)cchUnicodeString);
#endif // _USERK_

        if (nCharsInUnicodeString == 0) {
            if (bAllocateMem) {
                UserRtlFreeMem(*ppUnicodeString);
            }
        }

        return (int)nCharsInUnicodeString;
    }

}


/**************************************************************************\
* RtlWCSMessageWParmCharToMB
*
* Converts a Wide Character to a Multibyte character; in place
* Returns the number of characters converted or zero if failure
*
* 11-Feb-1992  JohnC    Created
\**************************************************************************/

BOOL RtlWCSMessageWParamCharToMB(DWORD msg, WPARAM *pWParam)
{
    DWORD dwAnsi;
    NTSTATUS Status;
    WORD CodePage;
    int nbWch;

#ifdef FE_SB // RtlWCSMessageWParamCharToMB()
    //
    // Format of *pWParam here...
    //
    // LOWORD(*pWParam) = Unicode CodePoint...
    // HIWORD(*pWParam) = Has some information for DBCS messaging
    //                    (ex. WPARAM_IR_DBCSCHAR)
    //
    // Then we need to convert ONLY loword of wParam to Unicode...
    //
#endif // FE_SB
#ifndef FE_SB
    // NtBug #3135 (Closed 02/04/93)
    // Publisher Posts WM_CHAR messages with wParam > 0xFF (not a valid ANSI char)!
    //
    // It does this to disable TranslateAccelerator for that char.
    // MSPub's winproc must get the non-ANSI 'character' value, so PostMessage must
    // translate *two* characters of wParam for character messages, and PeekMessage
    // must translate *two* Unicode chars of wParam for ANSI app.
#endif

    /*
     * Only these messages have CHARs: others are passed through
     */

    switch(msg) {
#ifdef FE_IME // RtlWCSMessageWParamCharToMB()
    case WM_IME_CHAR:
    case WM_IME_COMPOSITION:
#endif // FE_IME
    case WM_CHAR:
    case WM_CHARTOITEM:
    case EM_SETPASSWORDCHAR:
    case WM_DEADCHAR:
    case WM_SYSCHAR:
    case WM_SYSDEADCHAR:
    case WM_MENUCHAR:

        CodePage = THREAD_CODEPAGE();
        dwAnsi = 0;

        nbWch = IS_DBCS_ENABLED() ? 1 * sizeof(WCHAR) : 2 * sizeof(WCHAR);

        if (IS_ACP(CodePage)) {
            // HACK HACK HACK HACK (for NtBug #3135)
            // to allow applications that store data in high word of wParam
            // Jan/06/96 hiroyama
            Status = RtlUnicodeToMultiByteN((LPSTR)&dwAnsi, sizeof(dwAnsi),
                    NULL, (LPWSTR)pWParam, nbWch);
            if (!NT_SUCCESS(Status)) {
                // LATER IanJa: returning FALSE makes GetMessage fail, which
                // terminates the app.  We should use some default 'bad character'
                // I use 0x00 for now.
                *pWParam = 0x00;
                return TRUE;
            }
        } else {
            int cwch;
            // assuming little endian
#ifdef _USERK_
            cwch = EngWideCharToMultiByte(CodePage,
                    (LPWSTR)pWParam, nbWch,
                    (LPSTR)&dwAnsi, sizeof(dwAnsi));
#else
            cwch = WideCharToMultiByte(CodePage, 0,
                    (LPCWSTR)pWParam, nbWch / sizeof(WCHAR),
                    (LPSTR)&dwAnsi, sizeof(dwAnsi), NULL, NULL);
#endif // _USERK_
            // KdPrint(("0x%04x -> 0x%02x (%d)\n", *pWParam, dwAnsi, CodePage));
            if (cwch == 0) {
                *pWParam = 0x00;
                return TRUE;
            }
        }
        if (IS_DBCS_ENABLED()) {
            WORD wAnsi = LOWORD(dwAnsi);
            //
            // From:
            //   HIBYTE(wAnsi)            = Dbcs TrailingByte.
            //   LOBYTE(wAnsi)            = Dbcs LeadingByte or Sbcs character.
            //
            // To:
            //   HIWORD(*pWParam)         = Original Data (information for DBCS messgaing).
            //   HIBYTE(LOWORD(*pWParam)) = Dbcs LeadingByte Byte.
            //   LOBYTE(LOWORD(*pWParam)) = Dbcs TrailingByte or Sbcs character.
            //
            if (IS_DBCS_MESSAGE(wAnsi)) {
                //
                // It's a DBCS character.
                //
                *pWParam = MAKEWPARAM(MAKEWORD(HIBYTE(wAnsi),LOBYTE(wAnsi)),HIWORD(*pWParam));
            } else {
                //
                // It's a SBCS character.
                //
                *pWParam = MAKEWPARAM(MAKEWORD(LOBYTE(wAnsi),0),0);
            }
        } else {
#if DBG
            if ((dwAnsi == 0) || (dwAnsi > 0xFF)) {
                RIPMSG1(RIP_VERBOSE, "msgW -> msgA: char = 0x%.4lX\n", dwAnsi);
            }
#endif
            *pWParam = dwAnsi;
        }
        break;
    }

    return TRUE;
}


/**************************************************************************\
* RtlMBMessageCharToWCS
*
* Converts a Multibyte character to a Wide character; in place
* Returns the number of characters converted or zero if failure
*
* 11-Feb-1992  JohnC    Created
* 13-Jan-1993  IanJa    Translate 2 characters (Publisher posts these!)
\**************************************************************************/

BOOL RtlMBMessageWParamCharToWCS(DWORD msg, WPARAM *pWParam)
{
    DWORD dwUni;
    NTSTATUS Status;
    // FE_SB    (RtlMBMessageWParamCharToWCS)
    BOOL  bWmCrIrDbcsChar = FALSE;
    WORD  wAnsi = LOWORD(*pWParam);
    // end FE_SB    (RtlMBMessageWParamCharToWCS)
    WORD CodePage = THREAD_CODEPAGE();

    /*
     * Only these messages have CHARs: others are passed through
     */

    switch(msg) {
    // FE_SB    (RtlMBMessageWParamCharToWCS)
    case WM_CHAR:
        //
        // WM_CHAR's wParam format for WM_IME_REPORT:IR_DBCSCHAR
        //
        if (IS_DBCS_ENABLED() && (*pWParam & WMCR_IR_DBCSCHAR)) {
            //
            // Mark this message is sent as IR_DBCSCHAR format.
            //
            bWmCrIrDbcsChar = TRUE;
        }

        //
        // Fall through....
        //
#ifdef FE_IME
    case WM_IME_CHAR:
    case WM_IME_COMPOSITION:
        //
        // We need to re-align for Unicode convertsion..
        // WM_CHAR/WM_IME_CHAR/WM_IME_COMPOSITION's wParam format :
        //
        // ReAlign IR_DBCS char format to regular sequence.
        //
        // From:
        //
        //  HIWORD(wParam)         = 0;
        //  HIBYTE(LOWORD(wParam)) = DBCS LeadingByte.
        //  LOBYTE(LOWORD(wParan)) = DBCS TrailingByte or SBCS character.
        //
        // To:
        //  HIWORD(wParam)         = 0;
        //  HIBYTE(LOWORD(wParam)) = DBCS TrailingByte.
        //  LOBYTE(LOWORD(wParam)) = DBCS LeadingByte or SBCS character.
        //
        if (IS_DBCS_ENABLED()) {
            *pWParam = MAKE_WPARAM_DBCSCHAR(wAnsi);
        }
#endif
        //
        // Fall through...
        //
        // end FE_SB    (RtlMBMessageWParamCharToWCS)
    case WM_CHARTOITEM:
    case EM_SETPASSWORDCHAR:
    case WM_DEADCHAR:
    case WM_SYSCHAR:
    case WM_SYSDEADCHAR:
    case WM_MENUCHAR:

        dwUni = 0;

        if (IS_ACP(CodePage)) {
            Status = RtlMultiByteToUnicodeN((LPWSTR)&dwUni, sizeof(dwUni),
                    NULL, (LPSTR)pWParam, 2 * sizeof(CHAR));
            if (!NT_SUCCESS(Status))
                return FALSE;
        } else {
            int cwch;
#ifdef _USERK_
            cwch = EngMultiByteToWideChar(CodePage,
                    (LPWSTR)&dwUni, sizeof(dwUni),
                    (LPSTR)pWParam, 2);
#else
            cwch = MultiByteToWideChar(CodePage, 0,
                    (LPSTR)pWParam, 2,
                    (LPWSTR)&dwUni, sizeof(dwUni) / sizeof(WCHAR));
#endif // _USERK_
            // KdPrint(("0x%02x -> 0x%04x (%d)\n", *pWParam, dwUni, CodePage));
            if (cwch == 0) {
                return FALSE;
            }
        }

        // FE_SB    (RtlMBMessageWParamCharToWCS)
        //
        // if this character is sent for WM_IME_REPORT:IR_DBCSCHAR, we mark it.
        //
        if (bWmCrIrDbcsChar)
            dwUni |= WMCR_IR_DBCSCHAR;
        // else FE_SB (RtlMBMessageWParamCharToWCS)
#if DBG
        if ((dwUni == 0) || (dwUni > 0xFF)) {
            RIPMSG1(RIP_VERBOSE, "msgA -> msgW: wchar = 0x%lX\n", dwUni);
        }
#endif
        // end FE_SB
        *pWParam = dwUni;
        break;
    }

    return TRUE;
}

/**************************************************************************\
* RtlInitLargeAnsiString
*
* Captures a large ANSI string in the same manner as
* RtlInitAnsiString.
*
* 03-22-95 JimA         Created.
\**************************************************************************/

VOID RtlInitLargeAnsiString(
    PLARGE_ANSI_STRING plstr,
    LPCSTR psz,
    UINT cchLimit)
{
    ULONG Length;

    plstr->Buffer = (PSTR)psz;
    plstr->bAnsi = TRUE;
    if (ARGUMENT_PRESENT( psz )) {
        Length = strlen( psz );
        plstr->Length = min(Length, cchLimit);
        plstr->MaximumLength = min((Length + 1), cchLimit);
    } else {
        plstr->MaximumLength = 0;
        plstr->Length = 0;
    }
}

/**************************************************************************\
* RtlInitLargeUnicodeString
*
* Captures a large unicode string in the same manner as
* RtlInitUnicodeString.
*
* 03-22-95 JimA         Created.
\**************************************************************************/

VOID RtlInitLargeUnicodeString(
    PLARGE_UNICODE_STRING plstr,
    LPCWSTR psz,
    UINT cchLimit)
{
    ULONG Length;

    plstr->Buffer = (PWSTR)psz;
    plstr->bAnsi = FALSE;
    if (ARGUMENT_PRESENT( psz )) {
        Length = wcslen( psz ) * sizeof( WCHAR );
        plstr->Length = min(Length, cchLimit);
        plstr->MaximumLength = min((Length + sizeof(UNICODE_NULL)), cchLimit);
    } else {
        plstr->MaximumLength = 0;
        plstr->Length = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\draw.c ===
/****************************** Module Header ******************************\
* Module Name: draw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains common drawing functions.
*
* History:
* 12-Feb-1992 MikeKe    Moved Drawtext to the client side
\***************************************************************************/


CONST WCHAR szRadio[] = L"nmlkji";
CONST WCHAR szCheck[] = L"gfedcb";

/***************************************************************************\
* FlipUserTextOutW
*
* Flip the check mark if the hdc is mirrored otherwise it just calls UserTextOutW
*
\***************************************************************************/
BOOL FlipUserTextOutW(HDC hdc, int x, int y, LPCWSTR ch, int nCount)
{
    BOOL bRet;
    int iOldTextAlign, iGraphicsModeOld;

    if ((UserGetLayout(hdc) & LAYOUT_RTL) &&
        (nCount == 1) &&
        ((ch[0] == TEXT('a')) ||(ch[0] == TEXT('b')))
       )
    {
        bRet = FALSE;

        //Check mark then set the hdc in GM_COMPATIBLE to unmirror it.
        if (iGraphicsModeOld = UserSetGraphicsMode(hdc, GM_COMPATIBLE))
        {
            iOldTextAlign = UserGetTextAlign(hdc);
            if ((iOldTextAlign & TA_CENTER) != TA_CENTER)
            {
                UserSetTextAlign(hdc, iOldTextAlign^TA_RIGHT);
            }
            bRet = UserTextOutW(hdc, x, y, ch, nCount);
            UserSetGraphicsMode(hdc, iGraphicsModeOld);
            UserSetTextAlign(hdc, iOldTextAlign);
        }
    } else {
        bRet = UserTextOutW(hdc, x, y, ch, nCount);
    }

    return bRet;
}
/***************************************************************************\
* FillRect
*
* Callable from either client or server contexts
*
* History:
* 29-Oct-1990 MikeHar   Ported from Windows.
\***************************************************************************/

int APIENTRY FillRect(
    HDC     hdc,
    LPCRECT prc,
    HBRUSH  hBrush)
{
    ULONG_PTR   iBrush;
    POLYPATBLT PolyData;

    iBrush = (ULONG_PTR)hBrush - 1;
    if (iBrush <= COLOR_ENDCOLORS) {
        hBrush = SYSHBRUSH(iBrush);
    }

    PolyData.x         = prc->left;
    PolyData.y         = prc->top;
    PolyData.cx        = prc->right - prc->left;
    PolyData.cy        = prc->bottom - prc->top;
    PolyData.BrClr.hbr = hBrush;

    /*
     * Win95 incompatibility: they return either hBrush or the brush that
     * was previosuly selected in hdc. Not documented this way though.
     */
    return UserPolyPatBlt(hdc, PATCOPY, &PolyData, 1, PPB_BRUSH);
}

/***************************************************************************\
* InvertRect
*
* Can be called from either the client or server contexts.
*
* History:
* 29-Oct-1990 MikeHar   Ported from Windows.
\***************************************************************************/

BOOL APIENTRY InvertRect(
    HDC     hdc,
    LPCRECT prc)
{
    return UserPatBlt(hdc,
                      prc->left,
                      prc->top,
                      prc->right - prc->left,
                      prc->bottom - prc->top,
                      DSTINVERT);
}

/***************************************************************************\
* DrawDiagonalLine
*
* History:
\***************************************************************************/

DWORD DrawDiagonalLine(
    HDC    hdc,
    LPRECT lprc,
    int    iDirection,
    int    iThickness,
    UINT   flags)
{
    RECT    rc;
    LPINT   py;
    int     cx;
    int     cy;
    int     dx;
    int     dy;
    LPINT   pc;

    POLYPATBLT ppbData[8];
    int        ppbCount = 0;

    if (IsRectEmpty(lprc))
        return 0L;

    rc = *lprc;

    /*
     * We draw slopes < 1 by varying y instead of x.
     */
    --iThickness;

    /*
     * See WinBug #139374
     */
    cy = rc.bottom - rc.top;
    cx = rc.right - rc.left;

    if (!flags && (cy != cx))
        cy -= iThickness * SYSMETRTL(CYBORDER);

    if (cy >= cx) {

        /*
         * "slope" is >= 1, so vary x by 1
         */
        cy /= cx;
        pc = &cy;

        cx = SYSMETRTL(CXBORDER);

    } else {

        /*
         * "slope" is < 1, so vary y by 1
         */
        cx /= cy;
        pc = &cx;

        cy = SYSMETRTL(CYBORDER);
    }

    dx = cx;
    dy = iDirection * cy;

    *pc = (*pc + iThickness) * SYSMETRTL(CYBORDER);

    rc.right  -= cx;
    rc.bottom -= cy;

    /*
     * For negative slopes, start from opposite side.
     */
    py = ((iDirection < 0) ? &rc.top : &rc.bottom);

    while ((rc.left <= rc.right) && (rc.top <= rc.bottom)) {

        if (!(flags & BF_MIDDLE)) {

            /*
             * UserPatBlt(hdc, rc.left, *py, cx, cy, PATCOPY);
             */

            ppbData[ppbCount].x         = rc.left;
            ppbData[ppbCount].y         = *py;
            ppbData[ppbCount].cx        = cx;
            ppbData[ppbCount].cy        = cy;
            ppbData[ppbCount].BrClr.hbr = NULL;

            ppbCount++;

        } else {

            /*
             * Fill interior.  We can determine vertex in interior
             * by vector define.
             */
            if (cy > SYSMETRTL(CYBORDER)) {

                if (flags & BF_LEFT) {

                    /*
                     * UserPatBlt(hdc, rc.left, lprc->top, cx, *py - lprc->top + cy, PATCOPY);
                     */

                    ppbData[ppbCount].x         = rc.left;
                    ppbData[ppbCount].y         = lprc->top;
                    ppbData[ppbCount].cx        = cx;
                    ppbData[ppbCount].cy        = *py - lprc->top + cy;
                    ppbData[ppbCount].BrClr.hbr = NULL;

                    ppbCount++;

                } else {
                    /*
                     * UserPatBlt(hdc, rc.left, *py, cx, lprc->bottom - *py, PATCOPY);
                     */

                    ppbData[ppbCount].x          = rc.left;
                    ppbData[ppbCount].y          = *py;
                    ppbData[ppbCount].cx         = cx;
                    ppbData[ppbCount].cy         = lprc->bottom - *py;
                    ppbData[ppbCount].BrClr.hbr  = NULL;

                    ppbCount++;
                }

            } else {

                if (flags & BF_TOP) {

                    /*
                     * UserPatBlt(hdc, rc.left, *py, lprc->right - rc.left, cy, PATCOPY);
                     */

                    ppbData[ppbCount].x          = rc.left;
                    ppbData[ppbCount].y          = *py;
                    ppbData[ppbCount].cx         = lprc->right - rc.left;
                    ppbData[ppbCount].cy         = cy;
                    ppbData[ppbCount].BrClr.hbr  = NULL;

                    ppbCount++;

                } else {
                    /*
                     * UserPatBlt(hdc, lprc->left, *py, rc.left - lprc->left + cx, cy, PATCOPY);
                     */

                    ppbData[ppbCount].x          = lprc->left;
                    ppbData[ppbCount].y          = *py;
                    ppbData[ppbCount].cx         = rc.left - lprc->left + cx;
                    ppbData[ppbCount].cy         = cy;
                    ppbData[ppbCount].BrClr.hbr  = NULL;

                    ppbCount++;

                }
            }
        }

        rc.left += dx;
        *py     -= dy;

        /*
         * do we need to flush PolyPatBlt ?
         */
        if (ppbCount == 8) {
            UserPolyPatBlt(hdc, PATCOPY, &ppbData[0], 8, PPB_BRUSH);
            ppbCount = 0;
        }
    }

    /*
     * any left-over PolyPatblt buffered operations?
     */
    if (ppbCount != 0) {
        UserPolyPatBlt(hdc, PATCOPY, &ppbData[0], ppbCount, PPB_BRUSH);
    }

    return MAKELONG(cx, cy);
}

/***************************************************************************\
* FillTriangle
*
* Fills in the triangle whose sides are two rectangle edges and a
* diagonal.  The vertex in the interior can be determined from the
* vector type.
*
* History:
\***************************************************************************/

BOOL FillTriangle(
    HDC    hdc,
    LPRECT lprc,
    HBRUSH hbr,
    UINT   flags)
{
    HBRUSH hbrT;
    int    nDirection;

    switch (flags & (BF_RECT | BF_DIAGONAL)) {

    case BF_DIAGONAL_ENDTOPLEFT:
    case BF_DIAGONAL_ENDBOTTOMRIGHT:
        nDirection = -1;
        break;

    default:
        nDirection = 1;
        break;
    }
    hbrT = UserSelectBrush(hdc, hbr);
    DrawDiagonalLine(hdc, lprc, nDirection, 1, flags);
    /*
     * Don't care if the above functions failed for a bad hdc
     */
    return (UserSelectBrush(hdc, hbrT) != NULL);
}

/***************************************************************************\
* DrawDiagonal
*
* Called by DrawEdge() for BF_DIAGONAL edges.
*
* Draws line of slope 1, one of 4 different ones.  The difference is
* where the line starts and where the end point is.  The BF_ flags for
* BF_DIAGONAL specify where the end point is.  For example, BF_DIAGONAL |
* BF_TOP | BF_LEFT means to draw a line ending up at the top left corner.
* So the origin must be bottom right, and the angle must be 3pi/4, or
* 135 degrees.
*
* History:
\***************************************************************************/

BOOL DrawDiagonal(
    HDC    hdc,
    LPRECT lprc,
    HBRUSH hbrTL,
    HBRUSH hbrBR,
    UINT   flags)
{
    HBRUSH  hbrT;
    int     nDirection;
    DWORD   dAdjust;

    /*
     * Away from light source
     */
    hbrT = ((flags & BF_BOTTOM) ? hbrBR : hbrTL);

    switch (flags & (BF_RECT | BF_DIAGONAL)){

    case BF_DIAGONAL_ENDTOPLEFT:
    case BF_DIAGONAL_ENDBOTTOMRIGHT:
        nDirection = -1;
        break;

    default:
        nDirection = 1;
        break;
    }

    hbrT = UserSelectBrush(hdc, hbrT);
    dAdjust = DrawDiagonalLine(hdc, lprc, nDirection, 1, (flags & ~BF_MIDDLE));
    /*
     * Adjust rectangle for next border
     */
    if (flags & BF_TOP)
        lprc->left += LOWORD(dAdjust);
    else
        lprc->right -= LOWORD(dAdjust);

    if (flags & BF_RIGHT)
        lprc->top += HIWORD(dAdjust);
    else
        lprc->bottom -= HIWORD(dAdjust);

    /*
     * Moved this to the end to save a check for return value
     */
    return (UserSelectBrush(hdc, hbrT) != NULL);
}

/***************************************************************************\
* DrawGrip
*
* History:
\***************************************************************************/

BOOL DrawGrip(
    HDC    hdc,
    LPRECT lprc,
    UINT   wState)
{
    int        x;
    int        y;
    int        c;
    HBRUSH     hbrOld;
    DWORD      rgbHilight;
    DWORD      rgbShadow;
    DWORD      rgbOld;
    POLYPATBLT PolyData;

    c = min((lprc->right - lprc->left), (lprc->bottom - lprc->top));
    x = lprc->right  - c;    // right justify
    y = lprc->bottom - c;    // bottom justify

    /*
     * Setup colors
     */
    if (wState & (DFCS_FLAT | DFCS_MONO)) {
        hbrOld = SYSHBR(WINDOW);
        rgbHilight = SYSRGBRTL(WINDOWFRAME);
        rgbShadow = SYSRGBRTL(WINDOWFRAME);
    } else {
        hbrOld = SYSHBR(3DFACE);
        rgbHilight = SYSRGBRTL(3DHILIGHT);
        rgbShadow = SYSRGBRTL(3DSHADOW);
    }

    PolyData.x         = lprc->left;
    PolyData.y         = lprc->top;
    PolyData.cx        = lprc->right-lprc->left;
    PolyData.cy        = lprc->bottom-lprc->top;
    PolyData.BrClr.hbr = hbrOld;
    UserPolyPatBlt(hdc, PATCOPY, &PolyData, 1, PPB_BRUSH);

    rgbOld = UserSetTextColor(hdc, rgbHilight);

    if (wState & DFCS_SCROLLSIZEGRIPRIGHT) {
        UserTextOutW(hdc, x, y, L"x", 1);
        UserSetTextColor(hdc, rgbShadow);
        UserTextOutW(hdc, x, y, L"y", 1);
    } else {
        UserTextOutW(hdc, x, y, L"o", 1);
        UserSetTextColor(hdc, rgbShadow);
        UserTextOutW(hdc, x, y, L"p", 1);
    }

    UserSetTextColor(hdc, rgbOld);
    return TRUE;
}

/***************************************************************************\
* DrawBox
*
* History:
\***************************************************************************/

BOOL DrawBox(
    HDC    hdc,
    LPRECT lprc,
    UINT   wControlState)
{
    int      cx;
    int      cy;
    int      c;
    int      x;
    int      y;
    LPCWSTR  lp = szRadio;
    int      i;
    BOOL     fSkip0thItem;
    COLORREF clr[6];
    COLORREF clrOld;

    fSkip0thItem = ((wControlState & (DFCS_BUTTON3STATE | DFCS_PUSHED |
        DFCS_INACTIVE | DFCS_CHECKED)) == (DFCS_BUTTON3STATE | DFCS_CHECKED));

    /*
     * Don't need radio mask with marlett font!
     */
    if (wControlState & DFCS_BUTTONRADIOMASK) {

        clr[0] = clr[1] = clr[2] = clr[3] = clr[4] = 0L;
        FillRect(hdc, lprc, ghbrWhite);

    } else {

        /*
         * DFCS_BUTTONRADIOIMAGE
         */
        if (wControlState & (DFCS_MONO | DFCS_FLAT)) {
            clr[1] = clr[2] = clr[3] = clr[4] = SYSRGBRTL(WINDOWFRAME);
        } else {
            clr[1] = SYSRGBRTL(3DLIGHT);
            clr[2] = SYSRGBRTL(3DDKSHADOW);
            clr[3] = SYSRGBRTL(3DHILIGHT);
            clr[4] = SYSRGBRTL(3DSHADOW);
        }


        if (wControlState & (DFCS_PUSHED | DFCS_INACTIVE))
            clr[0] = SYSRGBRTL(3DFACE);
        else if (fSkip0thItem)
            clr[0] = SYSRGBRTL(3DHILIGHT);
        else
            clr[0] = SYSRGBRTL(WINDOW);

        if (wControlState & DFCS_BUTTONRADIOIMAGE)
            FillRect(hdc, lprc, ghbrBlack);
        else if (!(wControlState & DFCS_BUTTONRADIO))
            lp = szCheck;
    }

    cx = lprc->right - lprc->left;
    cy = lprc->bottom - lprc->top;

    c = min(cx,cy);
    x = lprc->left + ((cx - c) / 2); // - 1;
    y = lprc->top  + ((cy - c) / 2);

    if (fSkip0thItem &&
        ((gpsi->BitCount < 8) || (SYSRGB(3DHILIGHT) == RGB(255,255,255)))) {

        COLORREF   clrBk;
        POLYPATBLT PolyData;

         /*
          * Make the interior of a 3State checkbox which is just checked a
          * dither, just like an indeterminate push button which is pressed.
          */
         clrBk  = UserSetBkColor(hdc, SYSRGB(3DHILIGHT));
         clrOld = UserSetTextColor(hdc, SYSRGB(3DFACE));

         PolyData.x         = x;
         PolyData.y         = y;
         PolyData.cx        = cx;
         PolyData.cy        = cy;
         PolyData.BrClr.hbr = gpsi->hbrGray;
         UserPolyPatBlt(hdc, PATCOPY, &PolyData, 1, PPB_BRUSH);

         UserSetBkColor(hdc, clrBk);

    } else {
        clrOld = UserSetTextColor(hdc, clr[0]);
        UserTextOutW(hdc, x, y, lp, 1);
    }

    lp++;

    for (i = 1; i < 5; i++) {
        UserSetTextColor(hdc, clr[i]);
        UserTextOutW(hdc, x, y, lp++, 1);
    }

    if (wControlState & DFCS_CHECKED) {
        COLORREF clrCheck;

        if (wControlState & (DFCS_BUTTON3STATE | DFCS_INACTIVE)) {
            clrCheck = SYSRGBRTL(3DSHADOW);
        } else if (wControlState & DFCS_HOT) {
            clrCheck = SYSRGBRTL(HOTLIGHT);
        } else {
            clrCheck = SYSRGBRTL(WINDOWTEXT);
        }

        UserSetTextColor(hdc, clrCheck);
        FlipUserTextOutW(hdc, x, y, lp, 1);
    }

    UserSetTextColor(hdc, clrOld);

    return TRUE;
}
/***************************************************************************\
* GetCaptionChar
*
* History:
* 04/02/97 GerardoB Created
\***************************************************************************/
WCHAR GetCaptionChar (UINT wState)
{
    wState &= DFCS_CAPTIONALL;
    switch (wState) {
    case DFCS_CAPTIONCLOSE:
        return TEXT('r');
    case DFCS_CAPTIONMIN:
        return TEXT('0');
    case DFCS_CAPTIONMAX:
        return TEXT('1');
    case DFCS_CAPTIONRESTORE:
        return TEXT('2');
    /* case DFCS_CAPTIONHELP: */
    default:
        return TEXT('s');
    }
}
/***************************************************************************\
* DrawMenuMark
*
* History:
\***************************************************************************/

BOOL DrawMenuMark(
    HDC    hdc,
    LPRECT lprc,
    UINT   wType,
    UINT   wState)
{
    COLORREF rgbOld;
    int      x;
    int      y;
    int      c;
    int      cx;
    int      cy;
    WCHAR    ch;

    cx = lprc->right - lprc->left;
    cy = lprc->bottom - lprc->top;

    c = min(cx,cy);
    x = lprc->left + ((cx - c) / 2) - ((cx > 0xb) ? 1 : 0);
    y = lprc->top  + ((cy - c) / 2);

    FillRect(hdc, lprc, ghbrWhite);

    rgbOld = UserSetTextColor(hdc, 0L);

    if (wType == DFC_MENU) {
        if (wState & DFCS_MENUCHECK) {
            ch = TEXT('a');
        } else if (wState & DFCS_MENUBULLET) {
            ch = TEXT('h');
        } else if (wState & DFCS_MENUARROWRIGHT) {
            ch = TEXT('w');
        } else {
            ch = TEXT('8');
        }
    } else {
        UserAssert(wType == DFC_POPUPMENU);
        ch = GetCaptionChar(wState);
    }

    FlipUserTextOutW(hdc, x, y, &ch, 1);
    UserSetTextColor(hdc, rgbOld);

    return TRUE;
}

/***************************************************************************\
* DrawIt
*
* History:
\***************************************************************************/

BOOL DrawIt(
    HDC    hdc,
    LPRECT lprc,
    UINT   wState,
    WCHAR  ch)
{
    COLORREF rgb;
    int      x;
    int      y;
    int      c;
    int      cx;
    int      cy;
    BOOL     fDrawDisabled = wState & DFCS_INACTIVE;

    cx = lprc->right - lprc->left;
    cy = lprc->bottom - lprc->top;

    c = min(cx,cy);
    x = lprc->left + ((cx - c) / 2);
    y = lprc->top  + ((cy - c) / 2);

    if (fDrawDisabled) {
        rgb = SYSRGBRTL(3DHILIGHT);
    } else if (wState & DFCS_HOT) {
        rgb = SYSRGBRTL(HOTLIGHT);
    } else {
        rgb = SYSRGBRTL(BTNTEXT);
    }

    rgb = UserSetTextColor(hdc, rgb);

    if (wState & (DFCS_INACTIVE | DFCS_PUSHED)) {
        x++;
        y++;
    }

    UserTextOutW(hdc, x, y, &ch, 1);

    if (fDrawDisabled) {
        UserSetTextColor(hdc, SYSRGBRTL(3DSHADOW));
        UserTextOutW(hdc, x - 1, y - 1, &ch, 1);
    }

    UserSetTextColor(hdc, rgb);

    return TRUE;
}

/***************************************************************************\
* DrawScrollArrow
*
* History:
\***************************************************************************/

BOOL DrawScrollArrow(
    HDC    hdc,
    LPRECT lprc,
    UINT   wControlState)
{
    WCHAR ch = (wControlState & DFCS_SCROLLHORZ) ? TEXT('3') : TEXT('5');

    if (wControlState & DFCS_SCROLLMAX)
        ch++;

    return DrawIt(hdc, lprc, wControlState, ch);
}


/***************************************************************************\
* DrawFrameControl
*
* History:
*   03-March-2001  Mohamed  Hooked API and created this wrapper.
\***************************************************************************/
FUNCLOG4(
    LOG_GENERAL,
    BOOL,
    DUMMYCALLINGTYPE,
    DrawFrameControl,
    HDC,
    hdc,
    LPRECT,
    lprc,
    UINT,
    wType,
    UINT,
    wState)
BOOL DrawFrameControl(
    HDC    hdc,
    LPRECT lprc,
    UINT   wType,
    UINT   wState)
{

/*
 * There is a note here about the use of _USERK_.  DrawFrameControl is present
 * both in kernel and user mode.  Kernel side is not aware of UAH and therefore
 * this directive protects the kernel side by eliminating all wrappers 
 * and UAH-related code from the kernel version and only exposing it during 
 * the build for user mode.
 */

#ifndef _USERK_     // Eliminate UAH code in kernel build.

    BOOL bRet;

    BEGIN_USERAPIHOOK()
        bRet = guah.pfnDrawFrameControl(hdc, lprc, wType, wState);
    END_USERAPIHOOK()

    return bRet;
}


/***************************************************************************\
* RealDrawFrameControl
*
* History:
*   03-March-2001  Mohamed  Hooked this API and changed to Real*
\***************************************************************************/

BOOL RealDrawFrameControl(
    HDC    hdc,
    LPRECT lprc,
    UINT   wType,
    UINT   wState)
{

#endif              // _USERK_

    RECT     rc;
    HFONT    hFont;
    HFONT    hOldFont;
    BOOL     fRet = TRUE;
    int      iOldBk;
    int      c;
    BOOL     fButton = FALSE;
    LOGFONTW lfw;
    int      iGraphicsModeOld = 0;
    int      iOldTextAlign;

    rc = *lprc;

    /*
     * If the hdc is mirrored then set it in GM_ADVANCED mode
     * to enforce the text to be mirrored.
     */
    if (UserGetLayout(hdc) & LAYOUT_RTL) {
        if (iGraphicsModeOld = UserSetGraphicsMode(hdc, GM_ADVANCED))
        {
            iOldTextAlign = UserGetTextAlign(hdc);
            if ((iOldTextAlign & TA_CENTER) != TA_CENTER)
            {
                UserSetTextAlign(hdc, iOldTextAlign^TA_RIGHT);
            }
        }
    }

    /*
     * Enforce monochrome/flat
     */
    if (gpsi->BitCount == 1)
        wState |= DFCS_MONO;

    if (wState & DFCS_MONO)
        wState |= DFCS_FLAT;

    if ((wType != DFC_MENU)
            && (wType != DFC_POPUPMENU)
            && ((wType != DFC_BUTTON) || (wState & DFCS_BUTTONPUSH))
            && ((wType != DFC_SCROLL)
                || !(wState & (DFCS_SCROLLSIZEGRIP | DFCS_SCROLLSIZEGRIPRIGHT))))
    {
        UINT wBorder = BF_ADJUST;

        if (wType != DFC_SCROLL)
            wBorder |= BF_SOFT;

        UserAssert(DFCS_FLAT == BF_FLAT);
        UserAssert(DFCS_MONO == BF_MONO);

        wBorder |= (wState & (DFCS_FLAT | DFCS_MONO));

        DrawPushButton(hdc, &rc, wState, wBorder);

        if (wState & DFCS_ADJUSTRECT)
            *lprc = rc;

        fButton = TRUE;
    }

    iOldBk = UserSetBkMode(hdc, TRANSPARENT);
    if (!iOldBk) {
        /*
         * return FALSE if the hdc is bogus
         */
        if (iGraphicsModeOld) {
            UserSetGraphicsMode(hdc, iGraphicsModeOld);
            UserSetTextAlign(hdc, iOldTextAlign);
        }
        return FALSE;
    }

    c = min(rc.right - rc.left, rc.bottom - rc.top);

    if (c <= 0) {
        if (iGraphicsModeOld){
            UserSetGraphicsMode(hdc, iGraphicsModeOld);
            UserSetTextAlign(hdc, iOldTextAlign);
        }
        return FALSE;
    }

    RtlZeroMemory(&lfw, sizeof(lfw));
    lfw.lfHeight         = c;
    lfw.lfWeight         = FW_NORMAL;
    lfw.lfCharSet        = SYMBOL_CHARSET;
    RtlCopyMemory(lfw.lfFaceName, L"Marlett", sizeof(L"Marlett"));
    hFont = UserCreateFontIndirectW(&lfw);

    hOldFont = UserSelectFont(hdc, hFont);

    if (!fButton) {

        if ((wType == DFC_MENU) || (wType == DFC_POPUPMENU)) {
            if (wState & (DFCS_MENUARROWUP | DFCS_MENUARROWDOWN)) {
                if (!(wState & DFCS_TRANSPARENT))  {
                    POLYPATBLT ppbData;

                    ppbData.x  = lprc->left;
                    ppbData.y  = lprc->top;
                    ppbData.cx = lprc->right - lprc->left;
                    ppbData.cy = lprc->bottom - lprc->top;
                    ppbData.BrClr.hbr = SYSHBR(MENU);
                    UserPolyPatBlt(hdc, PATCOPY, &ppbData, 1, PPB_BRUSH);
                }
                DrawScrollArrow(hdc, &rc,
                        (wState & (DFCS_HOT | DFCS_INACTIVE)) | ((wState & DFCS_MENUARROWUP) ? DFCS_SCROLLUP : DFCS_SCROLLDOWN));
            } else {
                DrawMenuMark(hdc, &rc, wType, wState);
            }
        } else if (wType == DFC_BUTTON) {
            DrawBox(hdc, &rc, wState);
        } else {  // wType == DFC_SCROLL
            DrawGrip(hdc, lprc, wState);
        }

    } else if (wType == DFC_CAPTION) {
        DrawIt(hdc, &rc, wState, GetCaptionChar(wState));
    } else if (wType == DFC_SCROLL) {

        DrawScrollArrow(hdc, &rc, wState);

    } else if (wType != DFC_BUTTON) {

        fRet = FALSE;
    }

    if (iGraphicsModeOld){
        UserSetGraphicsMode(hdc, iGraphicsModeOld);
        UserSetTextAlign(hdc, iOldTextAlign);
    }

    UserSetBkMode(hdc, iOldBk);
    UserSelectFont(hdc, hOldFont);
    UserDeleteObject(hFont);

    return fRet;
}

/***************************************************************************\
* DrawEdge
*
* Draws a 3D edge using 2 3D borders.  Adjusts interior rectangle if desired
* And fills it if requested.
*
* Returns:
*     FALSE if error
*
* History:
* 30-Jan-1991 Laurabu   Created.
\***************************************************************************/

BOOL DrawEdge(
    HDC    hdc,
    LPRECT lprc,
    UINT   edge,
    UINT   flags)
{
    HBRUSH     hbrTL;
    HBRUSH     hbrBR;
    RECT       rc;
    UINT       bdrType;
    POLYPATBLT ppbData[4];
    UINT       ppbCount;
    BOOL       fResult = TRUE;

    /*
     * Enforce monochromicity and flatness
     */
    if (gpsi->BitCount == 1)
        flags |= BF_MONO;

    if (flags & BF_MONO)
        flags |= BF_FLAT;

    rc = *lprc;

    /*
     * Draw the border segment(s), and calculate the remaining space as we
     * go.
     */
    if (bdrType = (edge & BDR_OUTER)) {

DrawBorder:

        /*
         * Get brushes.  Note the symmetry between raised outer,
         * sunken inner and sunken outer, raised inner.
         */
        if (flags & BF_FLAT) {

            if (flags & BF_MONO)
                hbrBR = (bdrType & BDR_OUTER) ? SYSHBR(WINDOWFRAME) : SYSHBR(WINDOW);
            else
                hbrBR = (bdrType & BDR_OUTER) ? SYSHBR(3DSHADOW) : SYSHBR(3DFACE);

            hbrTL = hbrBR;

        } else {

            /*
             * 5 == HILIGHT
             * 4 == LIGHT
             * 3 == FACE
             * 2 == SHADOW
             * 1 == DKSHADOW
             */

            switch (bdrType) {
            /*
             * +2 above surface
             */
            case BDR_RAISEDOUTER:
                hbrTL = ((flags & BF_SOFT) ? SYSHBR(3DHILIGHT) : SYSHBR(3DLIGHT));
                hbrBR = SYSHBR(3DDKSHADOW);     // 1
                break;

            /*
             * +1 above surface
             */
            case BDR_RAISEDINNER:
                hbrTL = ((flags & BF_SOFT) ? SYSHBR(3DLIGHT) : SYSHBR(3DHILIGHT));
                hbrBR = SYSHBR(3DSHADOW);       // 2
                break;

            /*
             * -1 below surface
             */
            case BDR_SUNKENOUTER:
                hbrTL = ((flags & BF_SOFT) ? SYSHBR(3DDKSHADOW) : SYSHBR(3DSHADOW));
                hbrBR = SYSHBR(3DHILIGHT);      // 5
                break;

            /*
             * -2 below surface
             */
            case BDR_SUNKENINNER:
                hbrTL = ((flags & BF_SOFT) ? SYSHBR(3DSHADOW) : SYSHBR(3DDKSHADOW));
                hbrBR = SYSHBR(3DLIGHT);        // 4
                break;

            default:
                return FALSE;
            }
        }

        /*
         * Draw the sides of the border.  NOTE THAT THE ALGORITHM FAVORS THE
         * BOTTOM AND RIGHT SIDES, since the light source is assumed to be top
         * left.  If we ever decide to let the user set the light source to a
         * particular corner, then change this algorithm.
         */
        if (flags & BF_DIAGONAL) {

            fResult = DrawDiagonal(hdc, &rc, hbrTL, hbrBR, flags);

        } else {

            /*
             * reset ppbData index
             */
            ppbCount = 0;

            /*
             * Bottom Right edges
             */
                /*
                 * Right
                 */
            if (flags & BF_RIGHT) {

                rc.right -= SYSMETRTL(CXBORDER);

                ppbData[ppbCount].x         = rc.right;
                ppbData[ppbCount].y         = rc.top;
                ppbData[ppbCount].cx        = SYSMETRTL(CXBORDER);
                ppbData[ppbCount].cy        = rc.bottom - rc.top;
                ppbData[ppbCount].BrClr.hbr = hbrBR;
                ppbCount++;
            }

            /*
             * Bottom
             */
            if (flags & BF_BOTTOM) {
                rc.bottom -= SYSMETRTL(CYBORDER);

                ppbData[ppbCount].x         = rc.left;
                ppbData[ppbCount].y         = rc.bottom;
                ppbData[ppbCount].cx        = rc.right - rc.left;
                ppbData[ppbCount].cy        = SYSMETRTL(CYBORDER);
                ppbData[ppbCount].BrClr.hbr = hbrBR;
                ppbCount++;
            }

            /*
             * Top Left edges
             */
            /*
             * Left
             */
            if (flags & BF_LEFT) {
                ppbData[ppbCount].x         = rc.left;
                ppbData[ppbCount].y         = rc.top;
                ppbData[ppbCount].cx        = SYSMETRTL(CXBORDER);
                ppbData[ppbCount].cy        = rc.bottom - rc.top;
                ppbData[ppbCount].BrClr.hbr = hbrTL;
                ppbCount++;

                rc.left += SYSMETRTL(CXBORDER);
            }

            /*
             * Top
             */
            if (flags & BF_TOP) {
                ppbData[ppbCount].x         = rc.left;
                ppbData[ppbCount].y         = rc.top;
                ppbData[ppbCount].cx        = rc.right - rc.left;
                ppbData[ppbCount].cy        = SYSMETRTL(CYBORDER);
                ppbData[ppbCount].BrClr.hbr = hbrTL;
                ppbCount++;

                rc.top += SYSMETRTL(CYBORDER);
            }
            /*
             * Send all queued PatBlts to GDI in one go
             */
            fResult = UserPolyPatBlt(hdc,PATCOPY,&ppbData[0],ppbCount,PPB_BRUSH);
        }
    }

    if (bdrType = (edge & BDR_INNER)) {
        /*
         * Strip this so the next time through, bdrType will be 0.
         * Otherwise, we'll loop forever.
         */
        edge &= ~BDR_INNER;
        goto DrawBorder;
    }


    /*
     * Select old brush back in, if we changed it.
     */

    /*
     * Fill the middle & clean up if asked
     */
    if (flags & BF_MIDDLE) {
        if (flags & BF_DIAGONAL)
            fResult = FillTriangle(hdc, &rc, ((flags & BF_MONO) ? (HBRUSH)SYSHBR(WINDOW) : (HBRUSH)SYSHBR(3DFACE)), flags);
        else
            fResult = FillRect(hdc, &rc, ((flags & BF_MONO) ? (HBRUSH)SYSHBR(WINDOW) : (HBRUSH)SYSHBR(3DFACE)));
    }

    if (flags & BF_ADJUST)
        *lprc = rc;

    return fResult;
}

/***************************************************************************\
* DrawPushButton
*
* Draws a push style button in the given state.  Adjusts passed in rectangle
* if desired.
*
* Algorithm:
*    Depending on the state we either draw
*             * raised edge   (undepressed)
*             * sunken edge with extra shadow (depressed)
*     If it is an option push button (a push button that is
*             really a check button or a radio button like buttons
*             in tool bars), and it is checked, then we draw it
*             depressed with a different fill in the middle.
*
* History:
* 05-Feb-19 Laurabu     Created.
\***************************************************************************/

VOID DrawPushButton(
    HDC    hdc,
    LPRECT lprc,
    UINT   state,
    UINT   flags)
{
    RECT   rc;
    HBRUSH hbrMiddle;
    DWORD  rgbBack;
    DWORD  rgbFore;
    BOOL   fDither;

    rc = *lprc;

    DrawEdge(hdc,
             &rc,
             (state & (DFCS_PUSHED | DFCS_CHECKED)) ? EDGE_SUNKEN : EDGE_RAISED,
             (UINT)(BF_ADJUST | BF_RECT | (flags & (BF_SOFT | BF_FLAT | BF_MONO))));

    /*
     * BOGUS
     * On monochrome, need to do something to make pushed buttons look
     * better.
     */

    /*
     * Fill in middle.  If checked, use dither brush (gray brush) with
     * black becoming normal color.
     */
    fDither = FALSE;

    if (state & DFCS_CHECKED) {

        if ((gpsi->BitCount < 8) || (SYSRGBRTL(3DHILIGHT) == RGB(255,255,255))) {
            hbrMiddle = KHBRUSH_TO_HBRUSH(gpsi->hbrGray);
            rgbBack = UserSetBkColor(hdc, SYSRGBRTL(3DHILIGHT));
            rgbFore = UserSetTextColor(hdc, SYSRGBRTL(3DFACE));
            fDither = TRUE;
        } else {
            hbrMiddle = SYSHBR(3DHILIGHT);
        }

    } else {
        hbrMiddle = SYSHBR(3DFACE);
    }

    FillRect(hdc, &rc, hbrMiddle);

    if (fDither) {
        UserSetBkColor(hdc, rgbBack);
        UserSetTextColor(hdc, rgbFore);
    }

    if (flags & BF_ADJUST)
        *lprc = rc;
}

/***************************************************************************\
* DrawFrame
*
* History:
\***************************************************************************/

BOOL DrawFrame(
    HDC   hdc,
    PRECT prc,
    int   clFrame,
    int   cmd)
{
    int        x;
    int        y;
    int        cx;
    int        cy;
    int        cxWidth;
    int        cyWidth;
    HANDLE     hbrSave;
    LONG       rop;
    POLYPATBLT PolyData[4];

    x = prc->left;
    y = prc->top;

    cxWidth = SYSMETRTL(CXBORDER) * clFrame;
    cyWidth = SYSMETRTL(CYBORDER) * clFrame;

    cx = prc->right - x - cxWidth;
    cy = prc->bottom - y - cyWidth;

    rop = ((cmd & DF_ROPMASK) ? PATINVERT : PATCOPY);

    if ((cmd & DF_HBRMASK) == DF_GRAY) {
        hbrSave = KHBRUSH_TO_HBRUSH(gpsi->hbrGray);
    } else {
        UserAssert(((cmd & DF_HBRMASK) >> 3) < COLOR_MAX);
        hbrSave = SYSHBRUSH((cmd & DF_HBRMASK) >> 3);
    }

    PolyData[0].x         = x;
    PolyData[0].y         = y;
    PolyData[0].cx        = cxWidth;
    PolyData[0].cy        = cy;
    PolyData[0].BrClr.hbr = hbrSave;

    PolyData[1].x         = x + cxWidth;
    PolyData[1].y         = y;
    PolyData[1].cx        = cx;
    PolyData[1].cy        = cyWidth;
    PolyData[1].BrClr.hbr = hbrSave;

    PolyData[2].x         = x;
    PolyData[2].y         = y + cy;
    PolyData[2].cx        = cx;
    PolyData[2].cy        = cyWidth;
    PolyData[2].BrClr.hbr = hbrSave;

    PolyData[3].x         = x + cx;
    PolyData[3].y         = y + cyWidth;
    PolyData[3].cx        = cxWidth;
    PolyData[3].cy        = cy;
    PolyData[3].BrClr.hbr = hbrSave;

    UserPolyPatBlt(hdc, rop, &PolyData[0], 4, PPB_BRUSH);

    return TRUE;
}

/***************************************************************************\
* GetSignFromMappingMode
*
* For the current mapping mode,  find out the sign of x from left to right,
* and the sign of y from top to bottom.
*
* History:
\***************************************************************************/

BOOL GetSignFromMappingMode (
    HDC    hdc,
    PPOINT pptSign)
{
    SIZE sizeViewPortExt;
    SIZE sizeWindowExt;

    if (!UserGetViewportExtEx(hdc, &sizeViewPortExt)
            || !UserGetWindowExtEx(hdc, &sizeWindowExt)) {

        return FALSE;
    }

    pptSign->x = ((sizeViewPortExt.cx ^ sizeWindowExt.cx) < 0) ? -1 : 1;

    pptSign->y = ((sizeViewPortExt.cy ^ sizeWindowExt.cy) < 0) ? -1 : 1;

    return TRUE;
}

/***************************************************************************\
* ClientFrame
*
* Draw a rectangle
*
* History:
* 19-Jan-1993 MikeKe    Created
\***************************************************************************/

BOOL ClientFrame(
    HDC     hDC,
    LPCRECT pRect,
    HBRUSH  hBrush,
    DWORD   patOp,
    int     cxBorder,
    int     cyBorder)
{
    int        x;
    int        y;
    POINT      point;
    POINT      ptSign;
    POLYPATBLT PolyData[4];

    if (!GetSignFromMappingMode (hDC, &ptSign))
        return FALSE;

    y = pRect->bottom - (point.y = pRect->top);
    if (y < 0) {
        return FALSE;
    }

    x = pRect->right -  (point.x = pRect->left);

    /*
     * Check width and height signs
     */
    if (((x ^ ptSign.x) < 0) || ((y ^ ptSign.y) < 0))
        return FALSE;

    /*
     * Factor in the thickness of the rectangle to be drawn.  This will
     * automatically offset the edges so that the actual rectangle gets filled
     * "in" as it becomes thicker.
     */
    ptSign.x *= cxBorder;
    ptSign.y *= cyBorder;

    // Top border
    PolyData[0].x         = point.x;
    PolyData[0].y         = point.y;
    PolyData[0].cx        = x;
    PolyData[0].cy        = ptSign.y;
    PolyData[0].BrClr.hbr = hBrush;

    // Bottom border
    point.y = pRect->bottom - ptSign.y;
    PolyData[1].x         = point.x;
    PolyData[1].y         = point.y;
    PolyData[1].cx        = x;
    PolyData[1].cy        = ptSign.y;
    PolyData[1].BrClr.hbr = hBrush;

    /*
     * Left Border
     * Don't xor the corners twice
     */
    point.y = pRect->top + ptSign.y;
    y -= 2 * ptSign.y;
    PolyData[2].x         = point.x;
    PolyData[2].y         = point.y;
    PolyData[2].cx        = ptSign.x;
    PolyData[2].cy        = y;
    PolyData[2].BrClr.hbr = hBrush;

    // Right Border
    point.x = pRect->right - ptSign.x;
    PolyData[3].x         = point.x;
    PolyData[3].y         = point.y;
    PolyData[3].cx        = ptSign.x;
    PolyData[3].cy        = y;
    PolyData[3].BrClr.hbr = hBrush;

    return UserPolyPatBlt(hDC, patOp, PolyData, sizeof (PolyData) / sizeof (*PolyData), PPB_BRUSH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\help.c ===
/****************************** Module Header ******************************\
* Module Name: help.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the various rectangle manipulation APIs.
*
* History:
* 23-May-95 BradG   Created for Kernel mode
\***************************************************************************/

BOOL FIsParentDude(PWND pwnd)
{
    return(TestWF(pwnd, WEFCONTROLPARENT) || TestWF(pwnd, WFDIALOGWINDOW) ||
        ((TestWF(pwnd, BFTYPEMASK) == BS_GROUPBOX) &&
         IS_BUTTON(pwnd)));
}


/***************************************************************************\
* GetContextHelpId()
*   Given a pwnd, this returns the Help Context Id for that window;
* Note: If a window does not have a Context Id of its own, then it inherits
* the ContextId of it's parent, if it is a child window; else, from its owner,
* it is a owned popup.
\***************************************************************************/

DWORD GetContextHelpId(
    PWND pwnd)
{
    DWORD  dwContextId;

    while (!(dwContextId = (DWORD)(ULONG_PTR)_GetProp(pwnd,
            MAKEINTATOM(gpsi->atomContextHelpIdProp), PROPF_INTERNAL))) {
        pwnd = (TestwndChild(pwnd) ?
                REBASEPWND(pwnd, spwndParent) :
                REBASEPWND(pwnd, spwndOwner));
        if (!pwnd || (GETFNID(pwnd) == FNID_DESKTOP))
            break;
    }

    return dwContextId;
}




/*
 * Dialog Child enumeration proc
 *
 * Enumerates children of a dialog looking for the child under the mouse.
 *
 */
BOOL CALLBACK EnumPwndDlgChildProc(PWND pwnd, LPARAM lParam)
{
    PDLGENUMDATA pDlgEnumData = (PDLGENUMDATA)lParam;

    if (pwnd != pDlgEnumData->pwndDialog && IsVisible(pwnd) &&
            PtInRect(KPRECT_TO_PRECT(&pwnd->rcWindow), pDlgEnumData->ptCurHelp)) {
        /*
         * If it's a group box, keep enumerating. This takes care of
         * the case where we have a disabled control in a group box.
         * We'll find the group box first, and keep enumerating until we
         * hit the disabled control.
         */
        pDlgEnumData->pwndControl = pwnd;
        return (FIsParentDude(pwnd));
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\precomp.h ===
#ifdef _USERK_
#define NOWINBASEINTERLOCK
#else
#define NONTOSPINTERLOCK
#endif
#include <ntosp.h>

#include <ntrtl.h>

#include <stdio.h>

#include "userrtl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(WINCORE_PATH)\core.inc

MAJORCOMP=user
MINORCOMP=rtl

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..\..;                                  \
        $(NTUSER_PATH)\inc;                      \
        $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O);  \
        $(NTUSER_PATH)\kernel\$(ALT_PROJECT);    \
        $(WINCORE_PATH)\w32inc;                  \
        $(WINCORE_PATH)\w32inc\$(O);             \
        $(BASE_INC_PATH);                        \
        $(TERMSRV_INC_PATH);                     \
        $(WINCORE_PATH)\ntgdi\inc


C_DEFINES=$(C_DEFINES) /DUNICODE /D_UNICODE

SOURCES=..\alignrec.c \
        ..\chartran.c \
        ..\draw.c     \
        ..\drawtext.c \
        ..\getset.c   \
        ..\help.c     \
        ..\input.c    \
        ..\menu.c     \
        ..\mmrtl.c    \
        ..\random.c   \
        ..\rect.c     \
        ..\text.c     \
        ..\winevent.c \
        ..\winmgr.c   \
        ..\winprop.c  \
        ..\wow.c

PRECOMPILED_INCLUDE=..\..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\..\sources.inc ..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\rect.c ===
/****************************** Module Header ******************************\
* Module Name: rect.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the various rectangle manipulation APIs.
*
* History:
* 10-20-90 DarrinM      Grabbed 'C' rect routines from Portable PM.
\***************************************************************************/

#ifdef _USERK_
    #define VALIDATERECT(prc, retval)   UserAssert(prc)
#else
    #define VALIDATERECT(prc, retval)   if (prc == NULL) return retval
#endif

/***********************************************************************\
* SetRect (API)
*
* This function fills a rectangle structure with the passed in coordinates.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\***********************************************************************/

BOOL APIENTRY SetRect(
    LPRECT prc,
    int left,
    int top,
    int right,
    int bottom)
{
    VALIDATERECT(prc, FALSE);

    prc->left = left;
    prc->top = top;
    prc->right = right;
    prc->bottom = bottom;
    return TRUE;
}

/************************************************************************\
* CopyInflateRect (API)
*
* This function copies the rect from prcSrc to prcDst, and inflates it.
*
* History:
* 12-16-93  FritzS
\************************************************************************/

BOOL APIENTRY CopyInflateRect(
    LPRECT prcDst,
    CONST RECT *prcSrc,
    int cx, int cy)
{
    prcDst->left   = prcSrc->left   - cx;
    prcDst->right  = prcSrc->right  + cx;
    prcDst->top    = prcSrc->top    - cy;
    prcDst->bottom = prcSrc->bottom + cy;
    return TRUE;
}

/************************************************************************\
* CopyOffsetRect (API)
*
* This function copies the rect from prcSrc to prcDst, and offsets it.
*
* History:
* 01-03-94  FritzS
\************************************************************************/

BOOL APIENTRY CopyOffsetRect(
    LPRECT prcDst,
    CONST RECT *prcSrc,
    int cx, int cy)
{
    prcDst->left   = prcSrc->left   + cx;
    prcDst->right  = prcSrc->right  + cx;
    prcDst->top    = prcSrc->top    + cy;
    prcDst->bottom = prcSrc->bottom + cy;
    return TRUE;
}

/************************************************************************\
* IsRectEmpty (API)
*
* This function returns TRUE if *prc is an empty rect, FALSE
* otherwise.  An empty rect is one that has no area: right is
* less than or equal to left, bottom is less than or equal to top.
*
* Warning:
*   This function assumes that the rect is in device coordinates
*   mode where left and top coordinate are smaller than right and
*   bottom.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY IsRectEmpty(
    CONST RECT *prc)
{
    VALIDATERECT(prc, TRUE);

    return ((prc->left >= prc->right) || (prc->top >= prc->bottom));
}

/***********************************************************************\
* PtInRect (API)
*
* This function returns TRUE if *ppt falls inside of *prc.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY PtInRect(
    CONST RECT *prc,
    POINT  pt)
{
    VALIDATERECT(prc, FALSE);

    return ((pt.x >= prc->left) && (pt.x < prc->right) &&
            (pt.y >= prc->top)  && (pt.y < prc->bottom));
}

/************************************************************************\
* OffsetRect (API)
*
* This function offsets the coordinates of *prc by adding cx to
* both the left and right coordinates, and cy to both the top and
* bottom coordinates.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY OffsetRect(
    LPRECT prc,
    int cx,
    int cy)
{
    VALIDATERECT(prc, FALSE);

    prc->left   += cx;
    prc->right  += cx;
    prc->bottom += cy;
    prc->top    += cy;
    return TRUE;
}

/************************************************************************\
* InflateRect (API)
*
* This function expands the given rect by cx horizantally and cy
* vertically on all sides.  If cx or cy are negative, the rect
* is inset.  cx is subtracted from the left and added to the right,
* and cy is subtracted from the top and added to the bottom.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY InflateRect(
    LPRECT prc,
    int cx,
    int cy)
{
    VALIDATERECT(prc, FALSE);

    prc->left   -= cx;
    prc->right  += cx;
    prc->top    -= cy;
    prc->bottom += cy;
    return TRUE;
}

/************************************************************************\
* IntersectRect (API)
*
* Calculates the intersection between *prcSrc1 and *prcSrc2,
* returning the resulting rect in *prcDst.  Returns TRUE if
* *prcSrc1 intersects *prcSrc2, FALSE otherwise.  If there is no
* intersection, an empty rect is returned in *prcDst
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

BOOL APIENTRY IntersectRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)

{
    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    prcDst->left  = max(prcSrc1->left, prcSrc2->left);
    prcDst->right = min(prcSrc1->right, prcSrc2->right);

    /*
     * check for empty rect
     */
    if (prcDst->left < prcDst->right) {

        prcDst->top = max(prcSrc1->top, prcSrc2->top);
        prcDst->bottom = min(prcSrc1->bottom, prcSrc2->bottom);

        /*
         * check for empty rect
         */
        if (prcDst->top < prcDst->bottom) {
            return TRUE;        // not empty
        }
    }

    /*
     * empty rect
     */
    SetRectEmpty(prcDst);

    return FALSE;
}

/********************************************************************\
* UnionRect (API)
*
* This function calculates a rect that bounds *prcSrc1 and
* *prcSrc2, returning the result in *prcDst.  If either
* *prcSrc1 or *prcSrc2 are empty, then the other rect is
* returned.  Returns TRUE if *prcDst is a non-empty rect,
* FALSE otherwise.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\*******************************************************************/

BOOL APIENTRY UnionRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)
{
    BOOL frc1Empty, frc2Empty;

    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    frc1Empty = ((prcSrc1->left >= prcSrc1->right) ||
            (prcSrc1->top >= prcSrc1->bottom));

    frc2Empty = ((prcSrc2->left >= prcSrc2->right) ||
            (prcSrc2->top >= prcSrc2->bottom));

    if (frc1Empty && frc2Empty) {
        SetRectEmpty(prcDst);
        return FALSE;
    }

    if (frc1Empty) {
        *prcDst = *prcSrc2;
        return TRUE;
    }

    if (frc2Empty) {
        *prcDst = *prcSrc1;
        return TRUE;
    }

    /*
     * form the union of the two non-empty rects
     */
    prcDst->left   = min(prcSrc1->left,   prcSrc2->left);
    prcDst->top    = min(prcSrc1->top,    prcSrc2->top);
    prcDst->right  = max(prcSrc1->right,  prcSrc2->right);
    prcDst->bottom = max(prcSrc1->bottom, prcSrc2->bottom);

    return TRUE;
}

/********************************************************************\
* EqualRect (API)
*
* This function returns TRUE if *prc1 and *prc2 are identical,
* FALSE otherwise.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\*****************************************************************/

#undef EqualRect     // don't let macro interfere with API
BOOL APIENTRY EqualRect(
    CONST RECT *prc1,
    CONST RECT *prc2)
{
    VALIDATERECT(prc1, FALSE);
    VALIDATERECT(prc2, FALSE);

    /*
     * Test equality only. This is what win31 does. win31 does not check to
     * see if the rectangles are "empty" first.
     */
    return RtlEqualMemory(prc1, prc2, sizeof(RECT));
}

/**********************************************************************\
* SubtractRect (API)
*
* This function subtracts *prc2 from *prc1, returning the result in *prcDst
* Returns FALSE if *lprDst is empty, TRUE otherwise.
*
* Warning:
*   Subtracting one rect from another may not always result in a
*   rectangular area; in this case SubtractRect will return *prc1 in
*   *prcDst.  For this reason, SubractRect provides only an
*   approximation of subtraction.  However, the area described by
*   *prcDst will always be greater than or equal to the "true" result
*   of the subtraction.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowsese.
\**********************************************************************/

BOOL APIENTRY SubtractRect(
    LPRECT prcDst,
    CONST RECT *prcSrc1,
    CONST RECT *prcSrc2)
{
    int cSidesOut;
    BOOL fIntersect;
    RECT rcInt;

    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc1, FALSE);
    VALIDATERECT(prcSrc2, FALSE);

    fIntersect = IntersectRect(&rcInt, prcSrc1, prcSrc2);

    /*
     * this is done after the intersection in case prcDst is the same
     * pointer as prcSrc2
     */
    *prcDst = *prcSrc1;

    if (fIntersect) {
        /*
         * exactly any 3 sides of prc2 must be outside prc1 to subtract
         */
        cSidesOut = 0;
        if (rcInt.left   <= prcSrc1->left)
            cSidesOut++;
        if (rcInt.top    <= prcSrc1->top)
            cSidesOut++;
        if (rcInt.right  >= prcSrc1->right)
            cSidesOut++;
        if (rcInt.bottom >= prcSrc1->bottom)
            cSidesOut++;

        if (cSidesOut == 4) {
            /*
             * result is the empty rect
             */
             SetRectEmpty(prcDst);
             return FALSE;
        }

        if (cSidesOut == 3) {
            /*
             * subtract the intersecting rect
             */
            if (rcInt.left > prcSrc1->left)
                prcDst->right = rcInt.left;

            else if (rcInt.right < prcSrc1->right)
                prcDst->left = rcInt.right;

            else if (rcInt.top > prcSrc1->top)
                prcDst->bottom = rcInt.top;

            else if (rcInt.bottom < prcSrc1->bottom)
                prcDst->top = rcInt.bottom;
        }
    }

    if ((prcDst->left >= prcDst->right) || (prcDst->top >= prcDst->bottom))
        return FALSE;

    return TRUE;
}

/************************************************************************\
* CopyRect (API)
*
* This function copies the rect from prcSrc to prcDst.
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

#undef CopyRect     // don't let macro interfere with API
BOOL APIENTRY CopyRect(
    LPRECT prcDst,
    CONST RECT *prcSrc)
{
    VALIDATERECT(prcDst, FALSE);
    VALIDATERECT(prcSrc, FALSE);

    *prcDst = *prcSrc;
    return TRUE;
}


/************************************************************************\
* SetRectEmpty (API)
*
* This fuction sets *prc to an empty rect by setting each field to 0.
* Equivalent to SetRect(prc, 0, 0, 0, 0).
*
* History:
* 10-20-90 DarrinM      Translated from PMese to Windowses.
\************************************************************************/

#undef SetRectEmpty     // don't let macro interfere with API
BOOL APIENTRY SetRectEmpty(
    LPRECT prc)
{
    VALIDATERECT(prc, FALSE);

    RtlZeroMemory(prc, sizeof(RECT));
    return TRUE;
}



/***************************************************************************\
* RECTFromSIZERECT
*
* This function converts a SIZERECT to a RECT.
*
* History:
* 24-Sep-1996 adams     Created.
\***************************************************************************/

void
RECTFromSIZERECT(PRECT prc, PCSIZERECT psrc)
{
    prc->left = psrc->x;
    prc->top = psrc->y;
    prc->right = psrc->x + psrc->cx;
    prc->bottom = psrc->y + psrc->cy;
}


/***************************************************************************\
* SIZERECTFromRECT
*
* Converts a RECT to a SIZERECT.
*
* History:
* 09-May-1997 adams     Created.
\***************************************************************************/

void
SIZERECTFromRECT(PSIZERECT psrc, LPCRECT prc)
{
    psrc->x = prc->left;
    psrc->y = prc->top;
    psrc->cx = prc->right - prc->left;
    psrc->cy = prc->bottom - prc->top;
}


/***************************************************************************\
* MirrorClientRect
*
* Mirror a rectangle using the client coordinates.
*
*
* History:
\***************************************************************************/
void MirrorClientRect(PWND pwnd, LPRECT lprc)
{
    int left, cx;

    cx          = pwnd->rcClient.right - pwnd->rcClient.left;
    left        = lprc->left;
    lprc->left  = cx - lprc->right;
    lprc->right = cx - left;
}


/***************************************************************************\
* MirrorWindowRect
*
* Mirror a rectangle using the window coordinates.
*
*
* History:
* 06-Jun-2000   JStall      Created
\***************************************************************************/
void MirrorWindowRect(PWND pwnd, LPRECT lprc)
{
    int left, cx;

    cx          = pwnd->rcWindow.right - pwnd->rcWindow.left;
    left        = lprc->left;
    lprc->left  = cx - lprc->right;
    lprc->right = cx - left;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\text.c ===
/****************************** Module Header ******************************\
* Module Name: text.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the MessageBox API and related functions.
*
* History:
* 10-01-90 EricK        Created.
* 11-20-90 DarrinM      Merged in User text APIs.
* 02-07-91 DarrinM      Removed TextOut, ExtTextOut, and GetTextExtentPoint stubs.
\***************************************************************************/


/***************************************************************************\
* PSMGetTextExtent
*
* NOTE: This routine should only be called with the system font since having
* to realize a new font would cause memory to move...
*
* LATER: Can't this be eliminated altogether?  Nothing should be moving
*        anymore.
*
* History:
* 11-13-90  JimA        Ported.
\***************************************************************************/

#ifdef _USERK_

BOOL xxxPSMGetTextExtent(
    HDC hdc,
    LPWSTR lpstr,
    int cch,
    PSIZE psize)
{
    int result;
    WCHAR szTemp[255], *pchOut;
    PTHREADINFO ptiCurrent = PtiCurrentShared();
    TL tl;

    if (cch > sizeof(szTemp)/sizeof(WCHAR)) {
        pchOut = (WCHAR*)UserAllocPool((cch+1) * sizeof(WCHAR), TAG_RTL);
        if (pchOut == NULL) {
            psize->cx = psize->cy = 0;
            return FALSE;
        }
        ThreadLockPool(ptiCurrent, pchOut, &tl);
    } else {
        pchOut = szTemp;
    }

    result = HIWORD(GetPrefixCount(lpstr, cch, pchOut, cch));

    if (result) {
        lpstr = pchOut;
        cch -= result;
    }
    if (CALL_LPK(ptiCurrent)) {
        xxxClientGetTextExtentPointW(hdc, lpstr, cch, psize);
    } else {
        UserGetTextExtentPointW(hdc, lpstr, cch, psize);
    }
    if (pchOut != szTemp)
        ThreadUnlockAndFreePool(ptiCurrent, &tl);

    /*
     * IanJa everyone seems to ignore the ret val
     */
    return TRUE;
}

#else

BOOL PSMGetTextExtent(
    HDC hdc,
    LPCWSTR lpstr,
    int cch,
    PSIZE psize)
{
    int result;
    WCHAR szTemp[255], *pchOut;

    if (cch > sizeof(szTemp)/sizeof(WCHAR)) {
        pchOut = (WCHAR*)UserLocalAlloc(0, (cch+1) * sizeof(WCHAR));
        if (pchOut == NULL) {
            psize->cx = psize->cy = 0;
            return FALSE;
        }
    } else {
        pchOut = szTemp;
    }

    result = HIWORD(GetPrefixCount(lpstr, cch, pchOut, cch));

    if (result) {
        lpstr = pchOut;
        cch -= result;
    }

    UserGetTextExtentPointW(hdc, lpstr, cch, psize);

    if (pchOut != szTemp)
        UserLocalFree(pchOut);

    /*
     * IanJa everyone seems to ignore the ret val
     */
    return TRUE;
}

#endif // _USERK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\mmrtl.c ===
/****************************** Module Header ******************************\
* Module Name: mmrtl.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Multimonitor APIs.
*
* History:
* 29-Mar-1997 adams     Created.
\***************************************************************************/

#define Int32x32To32(x, y) ((x) * (y))

/*
 * There is no object locking in the client, so the monitor object can
 * go away at any time. Therefore to be safe, we need an exception handler.
 */
#ifdef _USERK_
#define BEGIN_EXCEPTION_HANDLER
#define END_EXCEPTION_HANDLER
#define END_EXCEPTION_HANDLER_EMPTY
#else // _USERK_
#define BEGIN_EXCEPTION_HANDLER try {
#define END_EXCEPTION_HANDLER \
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) { \
        pMonitorResult = NULL; \
    }
#define END_EXCEPTION_HANDLER_EMPTY \
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) { \
    }
#endif // _USERK_


/***************************************************************************\
* _MonitorFromPoint
*
* Calculate the monitor that a point is in or is nearest to.
*
* Arguments:
*     pt      - The point.
*     dwFlags - One of:
*         MONITOR_DEFAULTTONULL - If the point isn't in a monitor,
*             return NULL.
*
*         MONITOR_DEFAULTTOPRIMARY - If the point isn't in a monitor,
*             return the primary monitor.
*
*         MONITOR_DEFAULTTONEAREST - Return the monitor nearest the point.
*
* History:
* 22-Sep-1996 adams     Created.
* 29-Mar-1997 adams     Moved to rtl.
\***************************************************************************/

PMONITOR
_MonitorFromPoint(POINT pt, DWORD dwFlags)
{
    PMONITOR        pMonitor, pMonitorResult;
    int             dx;
    int             dy;

    UserAssert(dwFlags == MONITOR_DEFAULTTONULL ||
               dwFlags == MONITOR_DEFAULTTOPRIMARY ||
               dwFlags == MONITOR_DEFAULTTONEAREST);

    if (GetDispInfo()->cMonitors == 1 && dwFlags != MONITOR_DEFAULTTONULL)
        return GetPrimaryMonitor();

    switch (dwFlags) {
    case MONITOR_DEFAULTTONULL:
    case MONITOR_DEFAULTTOPRIMARY:
        /*
         * Return the monitor the point is in.
         */

        BEGIN_EXCEPTION_HANDLER

        for (   pMonitor = REBASESHAREDPTRALWAYS(GetDispInfo()->pMonitorFirst);
                pMonitor;
                pMonitor = REBASESHAREDPTR(pMonitor->pMonitorNext)) {

            if (!(pMonitor->dwMONFlags & MONF_VISIBLE))
                continue;

            if (PtInRect(KPRECT_TO_PRECT(&pMonitor->rcMonitor), pt)) {
                return pMonitor;
            }
        }

        END_EXCEPTION_HANDLER_EMPTY

        /*
         * Return what the user wants if it's not found.
         */
        switch (dwFlags) {
        case MONITOR_DEFAULTTONULL:
            return NULL;

        case MONITOR_DEFAULTTOPRIMARY:
            return GetPrimaryMonitor();

        default:
            UserAssertMsg0(FALSE, "Logic error in _MonitorFromPoint");
            break;
        }

    case MONITOR_DEFAULTTONEAREST:

#define MONITORFROMPOINTALGORITHM(SUMSQUARESMAX, SUMSQUARESTYPE, POINTMULTIPLY)     \
        SUMSQUARESTYPE  sumsquare;                                                  \
        SUMSQUARESTYPE  leastsumsquare;                                             \
        leastsumsquare = SUMSQUARESMAX;                                             \
        for (   pMonitor = REBASESHAREDPTRALWAYS(GetDispInfo()->pMonitorFirst);     \
                pMonitor;                                                           \
                pMonitor = REBASESHAREDPTR(pMonitor->pMonitorNext)) {               \
                                                                                    \
            if (!(pMonitor->dwMONFlags & MONF_VISIBLE))                             \
                continue;                                                           \
                                                                                    \
            /*                                                                      \
             * Determine distance from monitor along x axis.                        \
             */                                                                     \
            if (pt.x < pMonitor->rcMonitor.left) {                                  \
                dx = pMonitor->rcMonitor.left - pt.x;                               \
            } else if (pt.x < pMonitor->rcMonitor.right) {                          \
                dx = 0;                                                             \
            } else {                                                                \
                /*                                                                  \
                 * Monitor rectangles do not include the rightmost edge.            \
                 */                                                                 \
                dx = pt.x - (pMonitor->rcMonitor.right - 1);                        \
            }                                                                       \
                                                                                    \
            /*                                                                      \
             * Skip this monitor if dx is greater than dx^2 + dy^2.                 \
             * We do this check to avoid multiplication operations.                 \
             */                                                                     \
            if ((SUMSQUARESTYPE) dx >= leastsumsquare)                              \
                continue;                                                           \
                                                                                    \
            /*                                                                      \
             * Determine distance from monitor along y axis.                        \
             */                                                                     \
            if (pt.y < pMonitor->rcMonitor.top) {                                   \
                dy = pMonitor->rcMonitor.top - pt.y;                                \
            } else if (pt.y < pMonitor->rcMonitor.bottom) {                         \
                /*                                                                  \
                 * The point is in the monitor and we're done                       \
                 * if both dx and dy are zero.                                      \
                 */                                                                 \
                if (dx == 0)                                                        \
                    return pMonitor;                                                \
                                                                                    \
                dy = 0;                                                             \
            } else {                                                                \
                dy = pt.y - (pMonitor->rcMonitor.bottom - 1);                       \
            }                                                                       \
                                                                                    \
            /*                                                                      \
             * Calculate dx^2. Skip this monitor if dx is greater                   \
             * than dx^2 + dy^2. We do this check to avoid                          \
             * multiplication operations.                                           \
             */                                                                     \
            sumsquare = POINTMULTIPLY(dx, dx);                                      \
            if (sumsquare >= leastsumsquare)                                        \
                continue;                                                           \
                                                                                    \
            /*                                                                      \
             * Skip this monitor if dx^2 + y is greater than dx^2 + dy^2.           \
             * We do this check to avoid multiplication operations.                 \
             */                                                                     \
            if (sumsquare + (SUMSQUARESTYPE) dy >= leastsumsquare)                  \
                continue;                                                           \
                                                                                    \
            /*                                                                      \
             * Compute dx^2 + dy^2. Skip this monitor if it's not the least.        \
             */                                                                     \
            sumsquare += (SUMSQUARESTYPE) POINTMULTIPLY(dy, dy);                    \
            if (sumsquare >= leastsumsquare)                                        \
                continue;                                                           \
                                                                                    \
            /*                                                                      \
             * This is the closest monitor so far.                                  \
             */                                                                     \
            leastsumsquare = sumsquare;                                             \
            pMonitorResult = pMonitor;                                              \
        }

#if DBG
        pMonitorResult = (PMONITOR) -1;
#endif

        if (    pt.x < SHRT_MIN || SHRT_MAX < pt.x ||
                pt.y < SHRT_MIN || SHRT_MAX < pt.y) {

            BEGIN_EXCEPTION_HANDLER
            MONITORFROMPOINTALGORITHM(_UI64_MAX, ULONGLONG, Int32x32To64)
            END_EXCEPTION_HANDLER

        } else {

            BEGIN_EXCEPTION_HANDLER
            MONITORFROMPOINTALGORITHM(UINT_MAX, UINT, Int32x32To32)
            END_EXCEPTION_HANDLER

        }

        UserAssert(pMonitorResult != (PMONITOR) -1);
        return pMonitorResult;

    default:
        UserAssert(0 && "Logic error in _MonitorFromPoint, shouldn't have gotten here.");
        break;
    }

    UserAssert(0 && "Logic error in _MonitorFromPoint, shouldn't have gotten here.");
    return NULL;
}



/***************************************************************************\
* _MonitorFromRect
*
* Calculate the monitor that a rect is in or is nearest to.
*
* Arguments:
*     lprc    - The rect.
*     dwFlags - One of:
*         MONITOR_DEFAULTTONULL - If the rect doesn't intersect a monitor,
*             return NULL.
*
*         MONITOR_DEFAULTTOPRIMARY - If the rect doesn't intersect a monitor,
*             return the primary monitor.
*
*         MONITOR_DEFAULTTONEAREST - Return the monitor nearest the rect.
*
* History:
* 22-Sep-1996 adams     Created.
* 29-Mar-1997 adams     Moved to rtl.
\***************************************************************************/

PMONITOR
_MonitorFromRect(LPCRECT lprc, DWORD dwFlags)
{
    PDISPLAYINFO    pDispInfo;
    PMONITOR        pMonitor, pMonitorResult;
    RECT            rc;
    int             area, areaMost;

    UserAssert(dwFlags == MONITOR_DEFAULTTONULL ||
               dwFlags == MONITOR_DEFAULTTOPRIMARY ||
               dwFlags == MONITOR_DEFAULTTONEAREST);

    /*
     * Special case the most common case - 1 monitor.
     */
    pDispInfo = GetDispInfo();
    if (pDispInfo->cMonitors == 1 && dwFlags != MONITOR_DEFAULTTONULL)
        return GetPrimaryMonitor();

    /*
     * If rect is empty, use topleft point.
     */
    if (IsRectEmpty(lprc)) {
        return _MonitorFromPoint(*(LPPOINT)lprc, dwFlags);
    }

    /*
     * Return the primary monitor if the rectangle covers the desktop.
     */
    if (    lprc->left   <= pDispInfo->rcScreen.left &&
            lprc->top    <= pDispInfo->rcScreen.top &&
            lprc->right  >= pDispInfo->rcScreen.right &&
            lprc->bottom >= pDispInfo->rcScreen.bottom) {

        return GetPrimaryMonitor();
    }

    /*
     * Calculate the nearest rectangle by determining which
     * monitor has the greatest intersection with the rectangle.
     */

    BEGIN_EXCEPTION_HANDLER

    areaMost = 0;
    for (   pMonitor = REBASESHAREDPTRALWAYS(GetDispInfo()->pMonitorFirst);
            pMonitor;
            pMonitor = REBASESHAREDPTR(pMonitor->pMonitorNext)) {

        if (!(pMonitor->dwMONFlags & MONF_VISIBLE))
            continue;

        if (IntersectRect(&rc, lprc, KPRECT_TO_PRECT(&pMonitor->rcMonitor))) {
            if (EqualRect(&rc, lprc))
                return pMonitor;

            /*
             * Calculate the area of the intersection. Note that
             * the intersection must be in 16bit coordinats, since
             * we limit monitor rects to 16bit coordinate space.
             * So the result of any area calculation will fit in
             * in an int.
             */
            area = (rc.right - rc.left) * (rc.bottom - rc.top);
            if (area > areaMost) {
                areaMost = area;
                pMonitorResult = pMonitor;
            }
        }
    }

    END_EXCEPTION_HANDLER

    UserAssert(areaMost >= 0);
    if (areaMost > 0)
        return pMonitorResult;


    switch (dwFlags) {
    case MONITOR_DEFAULTTONULL:
        return NULL;

    case MONITOR_DEFAULTTOPRIMARY:
        return GetPrimaryMonitor();

    case MONITOR_DEFAULTTONEAREST:
        {
            int dx, dy;

#define MONITORFROMRECTALGORITHM(SUMSQUARESMAX, SUMSQUARESTYPE, POINTMULTIPLY)      \
            SUMSQUARESTYPE  sumsquare;                                              \
            SUMSQUARESTYPE  leastsumsquare;                                         \
            leastsumsquare = SUMSQUARESMAX;                                         \
            for (   pMonitor = REBASESHAREDPTRALWAYS(GetDispInfo()->pMonitorFirst); \
                    pMonitor;                                                       \
                    pMonitor = REBASESHAREDPTR(pMonitor->pMonitorNext)) {           \
                                                                                    \
                if (!(pMonitor->dwMONFlags & MONF_VISIBLE))                         \
                    continue;                                                       \
                                                                                    \
                /*                                                                  \
                 * Determine distance from monitor along x axis.                    \
                 */                                                                 \
                if (lprc->right <= pMonitor->rcMonitor.left) {                      \
                    /*                                                              \
                     * Add 1 because rectangles do not include the rightmost edge.  \
                     */                                                             \
                    dx = pMonitor->rcMonitor.left - lprc->right + 1;                \
                } else if (lprc->left < pMonitor->rcMonitor.right) {                \
                    dx = 0;                                                         \
                } else {                                                            \
                    /*                                                              \
                     * Add 1 because rectangles do not include the rightmost edge.  \
                     */                                                             \
                    dx = lprc->left - (pMonitor->rcMonitor.right - 1);              \
                }                                                                   \
                                                                                    \
                /*                                                                  \
                 * Skip this monitor if dx is greater than dx^2 + dy^2.             \
                 * We do this check to avoid multiplication operations.             \
                 */                                                                 \
                if ((SUMSQUARESTYPE) dx >= leastsumsquare)                          \
                    continue;                                                       \
                                                                                    \
                /*                                                                  \
                 * Determine distance from monitor along y axis.                    \
                 */                                                                 \
                if (lprc->bottom <= pMonitor->rcMonitor.top) {                      \
                    /*                                                              \
                     * Add 1 because rectangles do not include the bottommost edge. \
                     */                                                             \
                    dy = pMonitor->rcMonitor.top - lprc->bottom + 1;                \
                } else if (lprc->top < pMonitor->rcMonitor.bottom) {                \
                    UserAssert(dx != 0 && "This rectangle intersects a monitor, so we shouldn't be here."); \
                    dy = 0;                                                         \
                } else {                                                            \
                    /*                                                              \
                     * Add 1 because rectangles do not include the bottommost edge. \
                     */                                                             \
                    dy = lprc->top - pMonitor->rcMonitor.bottom + 1;                \
                }                                                                   \
                                                                                    \
                /*                                                                  \
                 * Calculate dx^2. Skip this monitor if dx is greater               \
                 * than dx^2 + dy^2. We do this check to avoid                      \
                 * multiplication operations.                                       \
                 */                                                                 \
                sumsquare = POINTMULTIPLY(dx, dx);                                  \
                if (sumsquare >= leastsumsquare)                                    \
                    continue;                                                       \
                                                                                    \
                /*                                                                  \
                 * Skip this monitor if dx^2 + y is greater than dx^2 + dy^2.       \
                 * We do this check to avoid multiplication operations.             \
                 */                                                                 \
                if (sumsquare + (SUMSQUARESTYPE) dy >= leastsumsquare)              \
                    continue;                                                       \
                                                                                    \
                /*                                                                  \
                 * Compute dx^2 + dy^2. Skip this monitor if it's not the least.    \
                 */                                                                 \
                sumsquare += (SUMSQUARESTYPE) POINTMULTIPLY(dy, dy);                \
                if (sumsquare >= leastsumsquare)                                    \
                    continue;                                                       \
                                                                                    \
                /*                                                                  \
                 * This is the closest monitor so far.                              \
                 */                                                                 \
                leastsumsquare = sumsquare;                                         \
                pMonitorResult = pMonitor;                                          \
            }

#if DBG
            pMonitorResult = (PMONITOR) -1;
#endif

            if (    lprc->left < SHRT_MIN || SHRT_MAX < lprc->left ||
                    lprc->top < SHRT_MIN || SHRT_MAX < lprc->top ||
                    lprc->right < SHRT_MIN || SHRT_MAX < lprc->right ||
                    lprc->bottom < SHRT_MIN || SHRT_MAX < lprc->bottom) {

                BEGIN_EXCEPTION_HANDLER
                MONITORFROMRECTALGORITHM(_UI64_MAX, ULONGLONG, Int32x32To64)
                END_EXCEPTION_HANDLER

            } else {

                BEGIN_EXCEPTION_HANDLER
                MONITORFROMRECTALGORITHM(UINT_MAX, UINT, Int32x32To32)
                END_EXCEPTION_HANDLER

            }

            UserAssert(pMonitorResult != (PMONITOR) -1);
            return pMonitorResult;
        }

    default:
        UserAssertMsg0(0, "Logic error in _MonitorFromWindow, shouldn't have gotten here.");
        break;
    }

    UserAssertMsg0(0, "Logic error in _MonitorFromWindow, shouldn't have gotten here.");
    return NULL;
}



/***************************************************************************\
* _MonitorFromWindow
*
* Calculate the monitor that a window is in or is nearest to. We use
* the center of the window to determine its location. If the window
* is minimized, use its normal position.
*
* Arguments:
*     pwnd    - The window.
*     dwFlags - One of:
*         MONITOR_DEFAULTTONULL - If the window doesn't intersect a monitor,
*             return NULL.
*
*         MONITOR_DEFAULTTOPRIMARY - If the window doesn't intersect a monitor,
*             return the primary monitor.
*
*         MONITOR_DEFAULTTONEAREST - Return the monitor nearest the window.
*
* History:
* 22-Sep-1996 adams     Created.
* 29-Mar-1997 adams     Moved to rtl.
\***************************************************************************/

PMONITOR
_MonitorFromWindow(PWND pwnd, DWORD dwFlags)
{
    PWND            pwndParent;

    UserAssert(dwFlags == MONITOR_DEFAULTTONULL ||
               dwFlags == MONITOR_DEFAULTTOPRIMARY ||
               dwFlags == MONITOR_DEFAULTTONEAREST);

    if (GetDispInfo()->cMonitors == 1 && dwFlags != MONITOR_DEFAULTTONULL) {
        return GetPrimaryMonitor();
    }

    if (!pwnd)
        goto NoWindow;

    /*
     * Handle minimized windows.
     */
    if (TestWF(pwnd, WFMINIMIZED))
    {
#ifdef _USERK_
        CHECKPOINT *    pcp;

        pcp = (CHECKPOINT *)_GetProp(pwnd, PROP_CHECKPOINT, PROPF_INTERNAL);
        if (pcp) {
            return _MonitorFromRect(&pcp->rcNormal, dwFlags);
        }
#else
        WINDOWPLACEMENT wp;
        HWND            hwnd;

        wp.length = sizeof(wp);
        hwnd = (HWND)PtoH(pwnd);
        if (GetWindowPlacement(hwnd, &wp)) {
            return _MonitorFromRect(&wp.rcNormalPosition, dwFlags);
        }

        /*
         * (adams) If GetWindowPlacement fails, then either there was not enough
         * memory to allocate a CHECKPOINT, or the window was destroyed
         * and the API failed. If the later, the following code my be
         * playing with invalid memory. Although on the client side we
         * can never guarantee that a window is valid, it seems especially
         * likely that it is invalid here. So do another revalidation
         * by calling IsWindow.
         */
        if (!IsWindow(hwnd))
            goto NoWindow;
#endif

        UserAssert(GETFNID(pwnd) != FNID_DESKTOP);
        pwndParent = REBASEPWND(pwnd, spwndParent);
        if (GETFNID(pwndParent) == FNID_DESKTOP) {
            return GetPrimaryMonitor();
        }

        /*
         * Otherwise, if we are a child window, fall thru below to use the
         * window rect, which actually means something for non-toplevel dudes.
         */
    }

    return _MonitorFromRect(KPRECT_TO_PRECT(&pwnd->rcWindow), dwFlags);

NoWindow:
    if (dwFlags & (MONITOR_DEFAULTTOPRIMARY | MONITOR_DEFAULTTONEAREST)) {
        return GetPrimaryMonitor();
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\userrtl.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

/****************************** Module Header ******************************\
* Module Name: userrtl.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used by the User
* RTL library.
*
* History:
* 04-27-91 DarrinM      Created from PROTO.H, MACRO.H and STRTABLE.H
\***************************************************************************/

#ifndef _USERRTL_
#define _USERRTL_

/*
 * Typedefs copied from winbase.h to avoid using nturtl.h
 */
typedef struct _SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;
#define MAKEINTATOM(i)  (LPTSTR)((ULONG_PTR)((WORD)(i)))

#ifdef _USERK_
    #undef _USERK_
    #include "..\kernel\precomp.h"
    #define _USERK_
#else
    #include "..\client\precomp.h"
#endif

#include <w32p.h>

#include "ntuser.h"

/*
 * REBASE macros take kernel desktop addresses and convert them into
 * user addresses.
 *
 * REBASEALWAYS converts a kernel address contained in an object
 * REBASEPWND casts REBASEALWAYS to a PWND
 * REBASE only converts if the address is in kernel space.  Also works for NULL
 * REBASEPTR converts a random kernel address
 */

#ifdef _USERK_

#define REBASEALWAYS(p, elem) ((p)->elem)
#define REBASEPTR(obj, p) (p)
#define REBASE(p, elem) ((p)->elem)
#define REBASEPWND(p, elem) ((p)->elem)
#endif  // _USERK_


// jcjc extern SHAREDINFO gSharedInfo;
// jcjc extern HFONT ghFontSys;

PVOID UserRtlAllocMem(
    ULONG uBytes);
VOID UserRtlFreeMem(
    PVOID pMem);


#ifdef FE_SB // Prototype for FarEast Line break & NLS conversion.

    #ifdef _USERK_
        #define USERGETCODEPAGE(hdc) (GreGetCharSet(hdc) & 0x0000FFFF)
    #else
        #define USERGETCODEPAGE(hdc) (GdiGetCodePage(hdc))
    #endif // _USERK_


    BOOL UserIsFullWidth(
        DWORD dwCodePage,
        WCHAR wChar);
    BOOL UserIsFELineBreak(
        DWORD dwCodePage,
        WCHAR wChar);

#endif // FE_SB


/***************************************************************************\
*
* Function prototypes for client/server-specific routines
* called from rtl routines.
*
\***************************************************************************/

#ifdef _USERK_

BOOL _TextOutW(
    HDC     hdc,
    int     x,
    int     y,
    LPCWSTR lp,
    UINT    cc);

UINT APIENTRY GreSetTextAlign(HDC, UINT);
UINT APIENTRY GreGetTextAlign(HDC);

#define UserCreateFontIndirectW   GreCreateFontIndirectW
#define UserCreateRectRgn         GreCreateRectRgn
#define UserDeleteObject          GreDeleteObject
#define UserExtSelectClipRgn      GreExtSelectClipRgn
#define UserExtTextOutW           GreExtTextOutW
#define UserGetCharDimensionsW    GetCharDimensions
#define UserGetClipRgn(hdc, hrgnClip) \
        GreGetRandomRgn(hdc, hrgnClip, 1)
#define UserGetHFONT              GreGetHFONT
#define UserGetMapMode            GreGetMapMode
#define UserGetTextColor          GreGetTextColor
#define UserGetTextExtentPointW(hdc, pstr, i, psize) \
        GreGetTextExtentW(hdc, (LPWSTR)pstr, i, psize, GGTE_WIN3_EXTENT)
#define UserGetTextMetricsW       _GetTextMetricsW
#define UserGetViewportExtEx      GreGetViewportExt
#define UserGetWindowExtEx        GreGetWindowExt
#define UserIntersectClipRect     GreIntersectClipRect
#define UserPatBlt                GrePatBlt
#define UserPolyPatBlt            GrePolyPatBlt
#define UserSelectBrush           GreSelectBrush
#define UserSelectFont            GreSelectFont
#define UserSetBkColor            GreSetBkColor
#define UserSetBkMode             GreSetBkMode
#define UserSetTextColor          GreSetTextColor
#define UserTextOutW              _TextOutW
#define UserGetTextCharsetInfo    GreGetTextCharsetInfo
#define UserGetTextAlign          GreGetTextAlign
#define UserSetTextAlign          GreSetTextAlign
#define UserLpkDrawTextEx         xxxClientLpkDrawTextEx
#define UserGetLayout             GreGetLayout
#define UserSetGraphicsMode       GreSetGraphicsMode

#else

#define UserCreateFontIndirectW   CreateFontIndirectW
#define UserCreateRectRgn         CreateRectRgn
#define UserDeleteObject          DeleteObject
#define UserExtSelectClipRgn      ExtSelectClipRgn
#define UserExtTextOutW           ExtTextOutW
#define UserGetCharDimensionsW    GdiGetCharDimensions
#define UserGetClipRgn            GetClipRgn
#define UserGetHFONT              GetHFONT
#define UserGetMapMode            GetMapMode
#define UserGetTextColor          GetTextColor
#define UserGetTextExtentPointW   GetTextExtentPointW
#define UserGetTextMetricsW       GetTextMetricsW
#define UserGetViewportExtEx      GetViewportExtEx
#define UserGetWindowExtEx        GetWindowExtEx
#define UserIntersectClipRect     IntersectClipRect
#define UserPatBlt                PatBlt
#define UserPolyPatBlt            PolyPatBlt
#define UserSelectBrush           SelectObject
#define UserSelectFont            SelectObject
#define UserSetBkColor            SetBkColor
#define UserSetBkMode             SetBkMode
#define UserSetTextColor          SetTextColor
#define UserTextOutW              TextOutW
#define UserGetTextCharsetInfo    GetTextCharsetInfo
#define UserGetTextAlign          GetTextAlign
#define UserSetTextAlign          SetTextAlign
#define UserLpkDrawTextEx         fpLpkDrawTextEx
#define UserGetLayout             GetLayout
#define UserSetGraphicsMode       SetGraphicsMode

#endif // _USERK_

#endif  // !_USERRTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\random.c ===
/****************************** Module Header ******************************\
* Module Name: random.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains a random collection of support routines for the User
* API functions.  Many of these functions will be moved to more appropriate
* files once we get our act together.
*
* History:
* 10-17-90 DarrinM      Created.
* 02-06-91 IanJa        HWND revalidation added (none required)
\***************************************************************************/


/***************************************************************************\
* RtlGetExpWinVer
*
* Returns the expected windows version, in the same format as Win3.1's
* GetExpWinVer(). This takes it out of the module header. As such, this
* api cannot be called from the server context to get version info for
* a client process - instead that information needs to be queried ahead
* of time and passed with any client/server call.
*
* 03-14-92 ScottLu      Created.
\***************************************************************************/

DWORD RtlGetExpWinVer(
    HANDLE hmod)
{
    PIMAGE_NT_HEADERS pnthdr;
    DWORD dwMajor = 3;
    DWORD dwMinor = 0xA;

    /*
     * If it doesn't look like a valid 32bit hmod, use the default
     *  (i.e., assuming all 16bit hmods are 0x30a)
     */
    if ((hmod != NULL) && (LOWORD(HandleToUlong(hmod)) == 0)) {
        try {
            pnthdr = RtlImageNtHeader((PVOID)hmod);
            // If for some reason we can't get the header information,
            // just return the default
            if(pnthdr == NULL) {
                goto NO_HEADER;
            }
            dwMajor = pnthdr->OptionalHeader.MajorSubsystemVersion;
            /*
             * Still need this hack 'cuz the linker still puts
             * version 1.00 in the header of some things.
             */
            if (dwMajor == 1) {
                dwMajor = 0x3;
            } else {
                dwMinor = pnthdr->OptionalHeader.MinorSubsystemVersion;
            }
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            dwMajor = 3;        // just to be safe
            dwMinor = 0xA;
        }
    }


    /*
     * Return this is a win3.1 compatible format:
     *
     * 0x030A == win3.1
     * 0x0300 == win3.0
     * 0x0200 == win2.0, etc.
     */

    // dwMajor and dwMinor are initialized where they're declared
    NO_HEADER:
    return (DWORD)MAKELONG(MAKEWORD((BYTE)dwMinor, (BYTE)dwMajor), 0);
}

/***************************************************************************\
* FindCharPosition
*
* Finds position of character ch in lpString.  If not found, the length
* of the string is returned.
*
* History:
*   11-13-90 JimA                Created.
\***************************************************************************/

DWORD FindCharPosition(
    LPWSTR lpString,
    WCHAR ch)
{
    DWORD dwPos = 0L;

    while (*lpString && *lpString != ch) {
        ++lpString;
        ++dwPos;
    }
    return dwPos;
}


/***************************************************************************\
* TextCopy
*
* Returns: number of characters copied not including the NULL
*
* History:
* 10-25-90 MikeHar      Wrote.
* 11-09-90 DarrinM      Rewrote with a radically new algorithm.
* 01-25-91 MikeHar      Fixed the radically new algorithm.
* 02-01-91 DarrinM      Bite me.
* 11-26-91 DarrinM      Ok, this time it's perfect (except NLS, probably).
* 01-13-92 GregoryW     Now it's okay for Unicode.
\***************************************************************************/

UINT TextCopy(
    PLARGE_UNICODE_STRING pstr,
    LPWSTR pszDst,
    UINT cchMax)
{
    if (cchMax != 0) {
        cchMax = min(pstr->Length / sizeof(WCHAR), cchMax - 1);
        RtlCopyMemory(pszDst, KPVOID_TO_PVOID(pstr->Buffer), cchMax * sizeof(WCHAR));
        pszDst[cchMax] = 0;
    }

    return cchMax;
}

/***************************************************************************\
* DWORD wcsncpycch(dest, source, count) - copy no more than n wide chars
*
* Purpose:
*       Copies no more than count characters from the source string to the
*       destination.  If count is less than the length of source,
*       NO NULL CHARACTER is put onto the end of the copied string.
*       If count is greater than the length of sources, dest is NOT padded
*       with more than 1 null character.
*
*
* Entry:
*       LPWSTR dest - pointer to destination
*       LPWSTR source - source string for copy
*       DWORD count - max number of characters to copy
*
* Exit:
*       returns number of characters copied into dest, including the null
*   terminator, if any.
*
* Exceptions:
*
****************************************************************************/

DWORD wcsncpycch (
        LPWSTR dest,
        LPCWSTR source,
        DWORD count
        )
{
        LPWSTR start = dest;

        while (count && (*dest++ = *source++))    /* copy string */
                count--;

        return (DWORD)(dest - start);
}

/***************************************************************************\
* DWORD strncpycch(dest, source, count) - copy no more than n characters
*
* Purpose:
*       Copies no more than count characters from the source string to the
*       destination.  If count is less than the length of source,
*       NO NULL CHARACTER is put onto the end of the copied string.
*       If count is greater than the length of sources, dest is NOT padded
*       with more than 1 null character.
*
*
* Entry:
*       LPSTR dest - pointer to destination
*       LPSTR source - source string for copy
*       DWORD count - max number of characters to copy
*
* Exit:
*       returns number of characters copied into dest, including the null
*   terminator, if any.
*
* Exceptions:
*
*******************************************************************************/

DWORD strncpycch (
        LPSTR dest,
        LPCSTR source,
        DWORD count
        )
{
        LPSTR start = dest;

        while (count && (*dest++ = *source++))    /* copy string */
                count--;

        return (DWORD)(dest - start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\winevent.c ===
/****************************** Module Header ******************************\
* Module Name: winevent.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains routines common to client and kernel.
*
* History:
* 07-18-2000 DwayneN    Created
\***************************************************************************/

/*
 * Event Space Partitioning
 * This map describes how the event space is partioned up into separate
 * categories.  Each entry describes where a range of events begins, and
 * what category that range belongs to.  The range implicitly extends up
 * to, but not including the beginning of the next range.  The first range
 * must begin with EVENT_MIN.  The last range must begin with EVENT_MAX.
 * This last range is ignored except that it defines where the 
 * next-to-last range ends.
 *
 * Be sure to keep this in sync with the category definitions!
 */
typedef struct _EVCATINFO
{
    DWORD dwBeginRange;
    DWORD dwCategory;
} EVCATINFO, *PEVCATINFO;

static EVCATINFO geci[] = {
    {EVENT_MIN,                                 EVENTCATEGORY_OTHER},
    {EVENT_SYSTEM_MENUSTART,                    EVENTCATEGORY_SYSTEM_MENU},
    {EVENT_SYSTEM_CAPTURESTART,                 EVENTCATEGORY_OTHER},
    {EVENT_CONSOLE_CARET,                       EVENTCATEGORY_CONSOLE},
    {EVENT_CONSOLE_END_APPLICATION + 1,         EVENTCATEGORY_OTHER},
    {EVENT_OBJECT_FOCUS,                        EVENTCATEGORY_FOCUS},
    {EVENT_OBJECT_SELECTION,                    EVENTCATEGORY_OTHER},
    {EVENT_OBJECT_STATECHANGE,                  EVENTCATEGORY_STATECHANGE},
    {EVENT_OBJECT_LOCATIONCHANGE,               EVENTCATEGORY_LOCATIONCHANGE},
    {EVENT_OBJECT_NAMECHANGE,                   EVENTCATEGORY_NAMECHANGE},
    {EVENT_OBJECT_DESCRIPTIONCHANGE,            EVENTCATEGORY_OTHER},
    {EVENT_OBJECT_VALUECHANGE,                  EVENTCATEGORY_VALUECHANGE},
    {EVENT_OBJECT_PARENTCHANGE,                 EVENTCATEGORY_OTHER},
    {EVENT_MAX,                                 EVENTCATEGORY_OTHER}};

/***************************************************************************\
* IsEventInRange
*
* Returns TRUE if the specified event falls within the specified range,
* and FALSE if not.
*
\***************************************************************************/
__inline BOOL IsEventInRange(
    DWORD event,
    DWORD eventMin,
    DWORD eventMax)
{
    return ((event >= eventMin) && (event <= eventMax));
}

/***************************************************************************\
* RangesOverlap
*
* Returns TRUE if the two ranges overlap at all, FALSE if not.
*
* Note that the ranges are both assumed to be inclusinve on both ends.
*
\***************************************************************************/
__inline BOOL RangesOverlap(
    DWORD r1Min,
    DWORD r1Max,
    DWORD r2Min,
    DWORD r2Max)
{
    UserAssert(r1Min <= r1Max);
    UserAssert(r2Min <= r2Max);
    return (r1Min <= r2Max) && (r1Max >= r2Min);
}

/***************************************************************************\
* CategoryMaskFromEvent
*
* Returns the bit-mask for the category that the specified event belongs to.
*
\***************************************************************************/
DWORD CategoryMaskFromEvent(
    DWORD event)
{
    UserAssert(IsEventInRange(event, EVENT_MIN, EVENT_MAX));

    switch (event) {
    case EVENT_SYSTEM_MENUSTART:
    case EVENT_SYSTEM_MENUEND:
    case EVENT_SYSTEM_MENUPOPUPSTART:
    case EVENT_SYSTEM_MENUPOPUPEND:
        return EVENTCATEGORY_SYSTEM_MENU;

    case EVENT_CONSOLE_CARET:
    case EVENT_CONSOLE_UPDATE_REGION:
    case EVENT_CONSOLE_UPDATE_SIMPLE:
    case EVENT_CONSOLE_UPDATE_SCROLL:
    case EVENT_CONSOLE_LAYOUT:
    case EVENT_CONSOLE_START_APPLICATION:
    case EVENT_CONSOLE_END_APPLICATION:
        return EVENTCATEGORY_CONSOLE;

    case EVENT_OBJECT_FOCUS:
        return EVENTCATEGORY_FOCUS;
        
    case EVENT_OBJECT_NAMECHANGE:
        return EVENTCATEGORY_NAMECHANGE;
    
    case EVENT_OBJECT_VALUECHANGE:
        return EVENTCATEGORY_VALUECHANGE;
    
    case EVENT_OBJECT_STATECHANGE:
        return EVENTCATEGORY_STATECHANGE;
    
    case EVENT_OBJECT_LOCATIONCHANGE:
        return EVENTCATEGORY_LOCATIONCHANGE;

    default:
        return EVENTCATEGORY_OTHER;
    }
}

/***************************************************************************\
* CategoryMaskFromEventRange
*
* Returns a bit-mask for the categories that the events in the specified
* event range belong to.
*
\***************************************************************************/
DWORD CategoryMaskFromEventRange(
    DWORD eventMin,
    DWORD eventMax)
{
    DWORD dwCategoryMask = 0;
    DWORD i;
    DWORD iMax = ARRAY_SIZE(geci) - 1;

    /*
     * This is a DEBUG section that tries to verify some aspects of the
     * geci array.
     */
#if DBG
    UserAssert(iMax >= 1);
    UserAssert(geci[0].dwBeginRange == EVENT_MIN);
    UserAssert(geci[iMax].dwBeginRange == EVENT_MAX);
    for (i = 0; i < iMax; i++) {
        UserAssert(geci[i].dwBeginRange >= EVENT_MIN);
        UserAssert(geci[i].dwBeginRange <= EVENT_MAX);
        UserAssert(geci[i].dwBeginRange < geci[i+1].dwBeginRange);
        dwCategoryMask |= geci[i].dwCategory;
    }
    UserAssert(dwCategoryMask == EVENTCATEGORY_ALL);
    dwCategoryMask = 0;
#endif // DBG
    
    /*
     * Spin through the geci array and check to see which ranges overlap
     * the range passed to this function.
     */
    for (i = 0; i < iMax; i++) {
        /*
         * Bail out early once we pass the range we are checking.
         */
        if (geci[i].dwBeginRange > eventMax) {
            break;
        }
        
        /*
         * Check to see if the ith range in the table overlaps the range
         * passed to this function.
         */
        if (RangesOverlap(geci[i].dwBeginRange, geci[i+1].dwBeginRange-1, eventMin, eventMax)) {
            dwCategoryMask |= geci[ i ].dwCategory;
        }
    }

    return dwCategoryMask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\winprop.c ===
/***************************************************************************\
* MapPropertyKey
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Maps a property key string into an atom.
*
* History:
* 21-Dec-1994   JimA    Created.
\***************************************************************************/

__inline ATOM MapPropertyKey(
    PCWSTR pszKey)
{
#ifdef _USERK_
    /*
     * Internal properties must use atoms, not strings.
     */
    UserAssert(!IS_PTR(pszKey));
#else
    /*
     * Is pszKey an atom?  If not, find the atom that matches the string.
     * If one doesn't exist, bail out.
     */
    if (IS_PTR(pszKey))
        return GlobalFindAtomW(pszKey);
#endif

    return PTR_TO_ID(pszKey);
}

/***************************************************************************\
* FindProp
*
* Search the window's property list for the specified property.  pszKey
* could be a string or an atom.  If it is a string, convert it to an atom
* before lookup.  FindProp will only find internal or external properties
* depending on the fInternal flag.
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

PPROP _FindProp(
    PWND pwnd,
    PCWSTR pszKey,
    BOOL fInternal)
{
    UINT i;
    PPROPLIST ppropList;
    PPROP pprop;
    ATOM atomKey;

    /*
     * Make sure we have a property list.
     */
    ppropList = REBASE(pwnd, ppropList);
    if (ppropList == NULL)
        return NULL;

    /*
     * Call to the appropriate routine to verify the key name.
     */
    atomKey = MapPropertyKey(pszKey);
    if (atomKey == 0)
        return NULL;

    /*
     * Now we've got the atom, search the list for a property with the
     * same atom/name.  Make sure to only return internal properties if
     * the fInternal flag is set.  Do the same for external properties.
     */
    pprop = ppropList->aprop;
    for (i = ppropList->iFirstFree; i > 0; i--) {
        if (pprop->atomKey == atomKey) {
            if (fInternal) {
                if (pprop->fs & PROPF_INTERNAL)
                    return pprop;
            } else {
                if (!(pprop->fs & PROPF_INTERNAL))
                    return pprop;
            }
        }
        pprop++;
    }

    /*
     * Property not found, too bad.
     */
    return NULL;
}

/***************************************************************************\
* InternalGetProp
*
* Search the window's property list for the specified property and return
* the hData handle from it.  If the property is not found, NULL is returned.
*
* History:
* 11-14-90 darrinm      Rewrote from scratch with new data structures and
*                       algorithms.
\***************************************************************************/

HANDLE _GetProp(
    PWND pwnd,
    PCWSTR pszKey,
    BOOL fInternal)
{
    PPROP pprop;

    /*
     * A quick little optimization for that case where the window has no
     * properties at all.
     */
    if (pwnd->ppropList == NULL)
        return NULL;

    /*
     * FindProp does all the work, including converting pszKey to an atom
     * (if necessary) for property lookup.
     */
    pprop = _FindProp(pwnd, pszKey, fInternal);
    if (pprop == NULL)
        return NULL;

    return KHANDLE_TO_HANDLE(pprop->hData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\winmgr.c ===
/****************************** Module Header ******************************\
* Module Name: winmgr.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains routines common to client and kernel.
*
* History:
* 02-20-92 DarrinM      Pulled functions from user\server.
* 11-11-94 JimA         Separated from client.
\***************************************************************************/

/***************************************************************************\
* FindNCHit
*
* History:
* 11-09-90 DavidPe      Ported.
\***************************************************************************/
int FindNCHit(
    PWND pwnd,
    LONG lPt)
{
    POINT pt;
    RECT rcWindow;
    RECT rcClient;
    RECT rcClientAdj;
    int cBorders;
    int dxButton;

    pt.x = GET_X_LPARAM(lPt);
    pt.y = GET_Y_LPARAM(lPt);

    if (!PtInRect(KPRECT_TO_PRECT(&pwnd->rcWindow), pt))
        return HTNOWHERE;

    if (TestWF(pwnd, WFMINIMIZED)) {
        CopyInflateRect(&rcWindow, KPRECT_TO_PRECT(&pwnd->rcWindow),
            -(SYSMETRTL(CXFIXEDFRAME) + SYSMETRTL(CXBORDER)), -(SYSMETRTL(CYFIXEDFRAME) + SYSMETRTL(CYBORDER)));

        if (!PtInRect(&rcWindow, pt))
            return HTCAPTION;

        goto CaptionHit;
    }

    // Get client rectangle
    rcClient = pwnd->rcClient;
    if (PtInRect(&rcClient, pt))
        return HTCLIENT;

    // Are we in "pseudo" client, i.e. the client & scrollbars & border
    if (TestWF(pwnd, WEFCLIENTEDGE))
        CopyInflateRect(&rcClientAdj, &rcClient, SYSMETRTL(CXEDGE), SYSMETRTL(CYEDGE));
    else
        rcClientAdj = rcClient;

    if (TestWF(pwnd, WFVPRESENT)) {
       if ((!!TestWF(pwnd, WEFLEFTSCROLL)) ^ (!!TestWF(pwnd, WEFLAYOUTRTL)))
           rcClientAdj.left -= SYSMETRTL(CXVSCROLL);
       else
           rcClientAdj.right += SYSMETRTL(CXVSCROLL);
    }
    if (TestWF(pwnd, WFHPRESENT))
        rcClientAdj.bottom += SYSMETRTL(CYHSCROLL);

    if (!PtInRect(&rcClientAdj, pt))
    {
        // Subtract out window borders
        cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
        CopyInflateRect(&rcWindow, KPRECT_TO_PRECT(&pwnd->rcWindow),
            -cBorders*SYSMETRTL(CXBORDER), -cBorders*SYSMETRTL(CYBORDER));

        // Are we on the border?
        if (!PtInRect(&rcWindow, pt))
        {
            // On a sizing border?
            if (!TestWF(pwnd, WFSIZEBOX)) {
                //
                // Old compatibility thing:  For 3.x windows that just had
                // a border, we returned HTNOWHERE, believe it or not,
                // because our hit-testing code wasn't very good.
                //
                if (!TestWF(pwnd, WFWIN40COMPAT) &&
                        !TestWF(pwnd, WFDLGFRAME)    &&
                        !TestWF(pwnd, WEFDLGMODALFRAME)) {
                    return HTNOWHERE;

                } else {
                    return HTBORDER;  // We are on a dlg frame.
                }
            } else {

                int ht;

                //
                // Note this improvement.  The HT codes are numbered so that
                // if you subtract HTSIZEFIRST-1 from them all, they sum up.  I.E.,
                // (HTLEFT - HTSIZEFIRST + 1) + (HTTOP - HTSIZEFIRST + 1) ==
                // (HTTOPLEFT - HTSIZEFIRST + 1).
                //

                if (TestWF(pwnd, WEFTOOLWINDOW))
                    InflateRect(&rcWindow, -SYSMETRTL(CXSMSIZE), -SYSMETRTL(CYSMSIZE));
                else
                    InflateRect(&rcWindow, -SYSMETRTL(CXSIZE), -SYSMETRTL(CYSIZE));

                if (pt.y < rcWindow.top)
                    ht = (HTTOP - HTSIZEFIRST + 1);
                else if (pt.y >= rcWindow.bottom)
                    ht = (HTBOTTOM - HTSIZEFIRST + 1);
                else
                    ht = 0;

                if (pt.x < rcWindow.left)
                    ht += (HTLEFT - HTSIZEFIRST + 1);
                else if (pt.x >= rcWindow.right)
                    ht += (HTRIGHT - HTSIZEFIRST + 1);

                return (ht + HTSIZEFIRST - 1);
            }
        }

        // Are we above the client area?
        if (pt.y < rcClientAdj.top)
        {
            // Are we in the caption?
            if (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION))
            {
CaptionHit:

                if (TestWF(pwnd, WEFLAYOUTRTL)) {
                    pt.x = pwnd->rcWindow.right - (pt.x - pwnd->rcWindow.left);
                }

                if (pt.y >= rcWindow.top)
                {
                    if (TestWF(pwnd, WEFTOOLWINDOW))
                    {
                        rcWindow.top += SYSMETRTL(CYSMCAPTION);
                        dxButton = SYSMETRTL(CXSMSIZE);
                    }
                    else
                    {
                        rcWindow.top += SYSMETRTL(CYCAPTION);
                        dxButton = SYSMETRTL(CXSIZE);
                    }

                    if ((pt.y >= rcWindow.top) && TestWF(pwnd, WFMPRESENT))
                        return HTMENU;

                    if ((pt.x >= rcWindow.left)  &&
                        (pt.x <  rcWindow.right) &&
                        (pt.y <  rcWindow.top))
                    {
                        // Are we in the window menu?
                        if (TestWF(pwnd, WFSYSMENU))
                        {
                            rcWindow.left += dxButton;
                            if (pt.x < rcWindow.left)
                            {
                                if (!_HasCaptionIcon(pwnd))
                                // iconless windows have no sysmenu hit rect
                                    return HTCAPTION;

                                return HTSYSMENU;
                            }
                        } else if (TestWF(pwnd, WFWIN40COMPAT)) {
#ifdef LAME_BUTTON
                            /*
                             * The old code assumed that a 4.0 compatible app
                             * would not have "anything" else in the caption if
                             * it doesn't have a system menu. With the lame
                             * button, this is no longer true. The code will
                             * work fine if the else-if block below is removed.
                             * However, if we do that then we do a whole bunch
                             * of unnecessary checks below (looking for the
                             * minimize button, which we know isn't there, for
                             * example). Hence, this quick-and-dirty goto. This
                             * allows lame button hit tracking to work on
                             * windows with no system menu, as well as not
                             * change hit test behavior in the shipped bits
                             * (which we most definitely do NOT want to break!)
                             */
                            goto LameButtonHitTest;
#else
                            return HTCAPTION;
#endif // LAME_BUTTON
                        }

                        // Are we in the close button?
                        rcWindow.right -= dxButton;
                        if (pt.x >= rcWindow.right)
                            return HTCLOSE;

                        if ((pt.x < rcWindow.right) && !TestWF(pwnd, WEFTOOLWINDOW))
                        {
                            // Are we in the maximize/restore button?
                            if (TestWF(pwnd, (WFMAXBOX | WFMINBOX)))
                            {
                                // Note that sizing buttons are same width for both
                                // big captions and small captions.
                                rcWindow.right -= dxButton;
                                if (pt.x >= rcWindow.right)
                                    return HTZOOM;

                                // Are we in the minimize button?
                                rcWindow.right -= dxButton;
                                if (pt.x >= rcWindow.right)
                                    return HTREDUCE;
                            }
                            else if (TestWF(pwnd, WEFCONTEXTHELP))
                            {
                                rcWindow.right -= dxButton;
                                if (pt.x >= rcWindow.right)
                                    return HTHELP;
                            }
#ifdef LAME_BUTTON
                            LameButtonHitTest:
                            if (TestWF(pwnd, WEFLAMEBUTTON)) {
                                rcWindow.right -= (gpsi->ncxLame + 2 * SYSMET(CXEDGE));

                                if (TestWF(pwnd, WEFRIGHT)) {
                                    if (pt.x >= rcWindow.left &&
                                        pt.x < rcWindow.left + gpsi->ncxLame) {
                                        return HTLAMEBUTTON;
                                    }
                                } else {
                                    if (pt.x >= rcWindow.right &&
                                        pt.x < rcWindow.right + gpsi->ncxLame) {
                                        return HTLAMEBUTTON;
                                    }
                                }
                            }
#endif // LAME_BUTTON
                        }
                    }
                }

                // We're in the caption proper
                return HTCAPTION;
            }

            //
            // Are we in the menu?
            //
            if (TestWF(pwnd, WFMPRESENT)) {
                return HTMENU;
            }
        }
    } else {
        //
        // NOTE:
        // We can only be here if we are on the client edge, horz scroll,
        // sizebox, or vert scroll.  Hence, if we are not on the first 3,
        // we must be on the last one.
        //

        //
        // Are we on the client edge?
        //
        if (TestWF(pwnd, WEFCLIENTEDGE)) {
            InflateRect(&rcClientAdj, -SYSMETRTL(CXEDGE), -SYSMETRTL(CYEDGE));
            if (!PtInRect(&rcClientAdj, pt)) {
                return HTBORDER;
            }
        }

        //
        // Are we on the scrollbars?
        //
        if (TestWF(pwnd, WFHPRESENT) && (pt.y >= rcClient.bottom)) {
            int iHitTest = HTHSCROLL;
            UserAssert(pt.y < rcClientAdj.bottom);

            if (TestWF(pwnd, WFVPRESENT)) {
                PWND pwndSizeBox = SizeBoxHwnd(pwnd);

                if(pt.x >= rcClient.right) {
                    return pwndSizeBox ? HTBOTTOMRIGHT : HTGROWBOX;
                } else if (TestWF(pwnd, WEFLAYOUTRTL) && (pt.x < rcClient.left)) {
                    //
                    // Mirror the grip box location so that it becomes
                    // on the bottom-left side if this is a RTL mirrrored
                    // windows.
                    //
                    return pwndSizeBox ? HTBOTTOMLEFT : HTGROWBOX;
                }
            }

            return iHitTest;
        } else {
            UserAssert(TestWF(pwnd, WFVPRESENT));
            if ((!!TestWF(pwnd, WEFLEFTSCROLL)) ^ (!!TestWF(pwnd, WEFLAYOUTRTL))) {
                UserAssert(pt.x < rcClient.left);
                UserAssert(pt.x >= rcClientAdj.left);
            } else {
                UserAssert(pt.x >= rcClient.right);
                UserAssert(pt.x < rcClientAdj.right);
            }

            return HTVSCROLL;
        }
    }

    //
    // We give up.
    //
    // Win31 returned HTNOWHERE in this case; For compatibility, we will
    // keep it that way.
    //
    return HTNOWHERE;

}

BOOL _FChildVisible(
    PWND pwnd)
{
    while (TestwndChild(pwnd)) {
        pwnd = REBASEPWND(pwnd, spwndParent);
        if (pwnd == NULL) {
            break;
        } else if (!TestWF(pwnd, WFVISIBLE)) {
            return FALSE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* _MapWindowPoints
*
*
* History:
* 03-03-92 JimA             Ported from Win 3.1 sources.
\***************************************************************************/
int _MapWindowPoints(
    PWND pwndFrom,
    PWND pwndTo,
    LPPOINT lppt,
    DWORD cpt)
{
    int     dx = 0, dy = 0;
    int     SaveLeft, Sign = 1;
    RECT    *pR      = (RECT *)lppt;
    BOOL    bMirrored = FALSE;

    /*
     * If a window is NULL, use the desktop window.
     * If the window is the desktop, don't offset by
     * the client rect, since it won't work if the screen
     * origin is not (0,0) - use zero instead.
     */

    /*
     * Compute deltas
     */
    if (pwndFrom && GETFNID(pwndFrom) != FNID_DESKTOP) {
        if (TestWF(pwndFrom, WEFLAYOUTRTL)) {
            Sign      = -Sign;
            dx        = -pwndFrom->rcClient.right;
            bMirrored = (cpt == 2);
        } else {
            dx = pwndFrom->rcClient.left;
        }
        dy = pwndFrom->rcClient.top;
    }

    if (pwndTo && GETFNID(pwndTo) != FNID_DESKTOP) {
        if (TestWF(pwndTo, WEFLAYOUTRTL)) {
            Sign      = -Sign;
            dx        = dx + Sign * pwndTo->rcClient.right;
            bMirrored = (cpt == 2);
        } else {
            dx = dx - Sign * pwndTo->rcClient.left;
        }
        dy = dy - pwndTo->rcClient.top;
    }

    /*
     * Map the points
     */
    while (cpt--) {
        lppt->x += dx;
        lppt->x *= Sign;
        lppt->y += dy;
        ++lppt;
    }

    if (bMirrored) {     //Special case for Rect
        SaveLeft  = min (pR->left, pR->right);
        pR->right = max (pR->left, pR->right);
        pR->left  = SaveLeft;
    }

    return MAKELONG(dx, dy);
}


/***************************************************************************\
*
* GetRealClientRect()
*
* Gets real client rectangle, inc. scrolls and excl. one row or column
* of minimized windows.
*
* If hwndParent is the desktop, then
*     * If pMonitor is NULL, use the primary monitor
*     * Otherwise use the appropriate monitor's rectangles
*
\***************************************************************************/
VOID GetRealClientRect(
    PWND        pwnd,
    LPRECT      prc,
    UINT        uFlags,
    PMONITOR    pMonitor)
{
    if (GETFNID(pwnd) == FNID_DESKTOP) {
        if (!pMonitor) {
            pMonitor = GetPrimaryMonitor();
        }
        *prc = (uFlags & GRC_FULLSCREEN) ? pMonitor->rcMonitor : pMonitor->rcWork;
    } else {
        GetRect(pwnd, prc, GRECT_CLIENT | GRECT_CLIENTCOORDS);
        if (uFlags & GRC_SCROLLS) {
            if (TestWF(pwnd, WFHPRESENT)){
                prc->bottom += SYSMETRTL(CYHSCROLL);
            }

            if (TestWF(pwnd, WFVPRESENT)) {
                prc->right += SYSMETRTL(CXVSCROLL);
            }
        }
    }

    if (uFlags & GRC_MINWNDS) {
        switch (SYSMETRTL(ARRANGE) & ~ARW_HIDE) {
            case ARW_TOPLEFT | ARW_RIGHT:
            case ARW_TOPRIGHT | ARW_LEFT:
                //
                // Leave space on top for one row of min windows
                //
                prc->top += SYSMETRTL(CYMINSPACING);
                break;

            case ARW_TOPLEFT | ARW_DOWN:
            case ARW_BOTTOMLEFT | ARW_UP:
                //
                // Leave space on left for one column of min windows
                //
                prc->left += SYSMETRTL(CXMINSPACING);
                break;

            case ARW_TOPRIGHT | ARW_DOWN:
            case ARW_BOTTOMRIGHT | ARW_UP:
                //
                // Leave space on right for one column of min windows
                //
                prc->right -= SYSMETRTL(CXMINSPACING);
                break;

            case ARW_BOTTOMLEFT | ARW_RIGHT:
            case ARW_BOTTOMRIGHT | ARW_LEFT:
                //
                // Leave space on bottom for one row of min windows
                //
                prc->bottom -= SYSMETRTL(CYMINSPACING);
                break;
        }
    }
}


/***************************************************************************\
* _GetLastActivePopup (API)
*
*
*
* History:
* 11-27-90 darrinm      Ported from Win 3.0 sources.
* 02-19-91 JimA         Added enum access check
\***************************************************************************/
PWND _GetLastActivePopup(
    PWND pwnd)
{
    if (pwnd->spwndLastActive == NULL)
        return pwnd;

    return REBASEPWND(pwnd, spwndLastActive);
}


/***************************************************************************\
* IsDescendant
*
* Internal version if IsChild that is a bit faster and ignores the WFCHILD
* business.
*
* Returns TRUE if pwndChild == pwndParent (IsChild doesn't).
*
* History:
* 07-22-91 darrinm      Translated from Win 3.1 ASM code.
* 03-03-94 Johnl        Moved from server
\***************************************************************************/

BOOL _IsDescendant(
    PWND pwndParent,
    PWND pwndChild)
{
    while (1) {
        if (pwndParent == pwndChild)
            return TRUE;
        if (GETFNID(pwndChild) == FNID_DESKTOP)
            break;
        pwndChild = REBASEPWND(pwndChild, spwndParent);
    }

    return FALSE;
}

/***************************************************************************\
* IsVisible
*
* Return whether or not a given window can be drawn in or not.
*
* History:
* 07-22-91 darrinm      Translated from Win 3.1 ASM code.
\***************************************************************************/

BOOL IsVisible(
    PWND pwnd)
{
    PWND pwndT;

    for (pwndT = pwnd; pwndT; pwndT = REBASEPWND(pwndT, spwndParent)) {

        /*
         * Invisible windows are always invisible
         */
        if (!TestWF(pwndT, WFVISIBLE))
            return FALSE;

        if (TestWF(pwndT, WFMINIMIZED)) {

            /*
             * Children of minimized windows are always invisible.
             */
            if (pwndT != pwnd)
                return FALSE;
        }

        /*
         * If we're at the desktop, then we don't want to go any further.
         */
        if (GETFNID(pwndT) == FNID_DESKTOP)
            break;
    }

    return TRUE;
}


/***************************************************************************\
*
*  Function:       GetWindowBorders
*
*  Synopsis:       Calculates # of borders around window
*
*  Algorithm:      Calculate # of window borders and # of client borders
*
*   This routine is ported from Chicago wmclient.c -- FritzS
*
\***************************************************************************/

int GetWindowBorders(LONG lStyle, DWORD dwExStyle, BOOL fWindow, BOOL fClient)
{
    int cBorders = 0;

    if (fWindow) {
        //
        // Is there a 3D border around the window?
        //
        if (dwExStyle & WS_EX_WINDOWEDGE)
            cBorders += 2;
        else if (dwExStyle & WS_EX_STATICEDGE)
            ++cBorders;

        //
        // Is there a single flat border around the window?  This is true for
        // WS_BORDER, WS_DLGFRAME, and WS_EX_DLGMODALFRAME windows.
        //
        if ( (lStyle & WS_CAPTION) || (dwExStyle & WS_EX_DLGMODALFRAME) )
                ++cBorders;

        //
        // Is there a sizing flat border around the window?
        //
        if (lStyle & WS_SIZEBOX)
                cBorders += gpsi->gclBorder;
    }

    if (fClient) {
            //
            // Is there a 3D border around the client?
            //
            if (dwExStyle & WS_EX_CLIENTEDGE)
            cBorders += 2;
    }

    return cBorders;
}



/***************************************************************************\
*  SizeBoxHwnd()
*
*  Returns the HWND that will be sized if the user drags in the given window's
*  sizebox -- If NULL, then the sizebox is not needed
*
*  Criteria for choosing what window will be sized:
*  find first sizeable parent; if that parent is not maximized and the child's
*  bottom, right corner is within a scroll bar height and width of the parent's
*  bottom, right corner, that parent will be sized.
*
*   From Chicago
\***************************************************************************/

PWND SizeBoxHwnd(
    PWND pwnd)
{
    BOOL bMirroredSizeBox = (BOOL) TestWF(pwnd, WEFLAYOUTRTL);

    int xbrChild;
    int ybrChild = pwnd->rcWindow.bottom;

    if (bMirroredSizeBox) {
        xbrChild = pwnd->rcWindow.left;
    } else {
        xbrChild = pwnd->rcWindow.right;
    }

    while (GETFNID(pwnd) != FNID_DESKTOP) {
        if (TestWF(pwnd, WFSIZEBOX)) {
            // First sizeable parent found
            int xbrParent;
            int ybrParent;

            if (TestWF(pwnd, WFMAXIMIZED))
                return NULL;

            if (bMirroredSizeBox) {
                xbrParent = pwnd->rcClient.left;
            } else {
                xbrParent = pwnd->rcClient.right;
            }
            ybrParent = pwnd->rcClient.bottom;

            /*  If the sizebox dude is within an EDGE of the client's bottom
             *  right corner (left corner for mirrored windows), let this succeed.
             *  That way people who draw their own sunken clients will be happy.
             */
            if (bMirroredSizeBox) {
                if ((xbrChild - SYSMETRTL(CXEDGE) > xbrParent) || (ybrChild + SYSMETRTL(CYEDGE) < ybrParent)) {
                    //
                    // Child's bottom, left corner of SIZEBOX isn't close enough
                    // to bottom left of parent's client.
                    //
                    return NULL;
                }
            } else {
                if ((xbrChild + SYSMETRTL(CXEDGE) < xbrParent) || (ybrChild + SYSMETRTL(CYEDGE) < ybrParent)) {
                    //
                    // Child's bottom, right corner of SIZEBOX isn't close enough
                    // to bottom right of parent's client.
                    //
                    return NULL;
                }
            }

            return pwnd;
        }

        if (!TestWF(pwnd, WFCHILD) || TestWF(pwnd, WFCPRESENT))
            break;

        pwnd = REBASEPWND(pwnd, spwndParent);
    }
    return NULL;
}



// --------------------------------------------------------------------------
//
//  NeedsWindowEdge()
//
//  Modifies style/extended style to enforce WS_EX_WINDOWEDGE when we want
//  it.
//
//
// When do we want WS_EX_WINDOWEDGE on a window?
//      (1) If the window has a caption
//      (2) If the window has the WS_DLGFRAME or WS_EX_DLGFRAME style (note
//          that this takes care of (1))
//      (3) If the window has WS_THICKFRAME
//
// --------------------------------------------------------------------------
BOOL NeedsWindowEdge(
    DWORD dwStyle,
    DWORD dwExStyle,
    BOOL fNewApp)
{
    BOOL fGetsWindowEdge = FALSE;

    if (dwExStyle & WS_EX_DLGMODALFRAME) {
        fGetsWindowEdge = TRUE;
    } else if (dwExStyle & WS_EX_STATICEDGE) {
        fGetsWindowEdge = FALSE;
    } else if (dwStyle & WS_THICKFRAME) {
        fGetsWindowEdge = TRUE;
    } else {
        switch (dwStyle & WS_CAPTION) {
        case WS_DLGFRAME:
            fGetsWindowEdge = TRUE;
            break;

        case WS_CAPTION:
            fGetsWindowEdge = fNewApp;
            break;
        }
    }

    return fGetsWindowEdge;
}


// --------------------------------------------------------------------------
//
//  HasCaptionIcon()
//
//  TRUE if this is a window that should have an icon drawn in its caption
//  FALSE otherwise
//
// --------------------------------------------------------------------------
BOOL _HasCaptionIcon(
    PWND pwnd)
{
    HICON hIcon;
    PCLS pcls;

    if (TestWF(pwnd, WEFTOOLWINDOW)) {
        // it's a tool window -- it doesn't get an icon
        return FALSE;
    }

    if ((TestWF(pwnd, WFBORDERMASK) != (BYTE)LOBYTE(WFDLGFRAME)) &&
            !TestWF(pwnd, WEFDLGMODALFRAME)) {
        // they are not trying to look like a dialog, they get an icon
        return TRUE;
    }

    if (!TestWF(pwnd, WFWIN40COMPAT) &&
        (((PCLS)REBASEALWAYS(pwnd, pcls))->atomClassName == (ATOM)(ULONG_PTR)DIALOGCLASS)) {
        // it's an older REAL dialog -- it doesn't get an icon 
        return FALSE;
    }

    hIcon = (HICON) _GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), TRUE);

    if (hIcon) {
        // It's a 4.0 dialog with a small icon -- if that small icon is
        // something other than the generic small windows icon, it gets an icon.
        return hIcon != gpsi->hIconSmWindows;
    }
    hIcon = (HICON) _GetProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), TRUE);

    if (hIcon && (hIcon != gpsi->hIcoWindows)) {
        // It's a 4.0 dialog with no small icon, but instead a large icon
        // that's not the generic windows icon -- it gets an icon.
        return TRUE;
    }

    pcls = REBASEALWAYS(pwnd, pcls);
    if (pcls->spicnSm) {
        if (pcls->spicnSm != HMObjectFromHandle(gpsi->hIconSmWindows)) {
            // It's a 4.0 dialog with a class icon that's not the generic
            // windows icon -- it gets an icon.
            return TRUE;
        }
    }

    // It's a 4.0 dialog with no small or large icon -- it doesn't get an icon.
    return FALSE;
}


/***************************************************************************\
* GetTopLevelWindow
*
* History:
* 10-19-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/
PWND GetTopLevelWindow(
    PWND pwnd)
{
    if (pwnd != NULL) {
        while (TestwndChild(pwnd)) {
            pwnd = REBASEPWND(pwnd, spwndParent);
        }
    }

    return pwnd;
}



/***************************************************************************\
* GetRect
*
* Returns a rect from pwnd (client or window) and returns it in
* one of these coordinate schemes:
*
*      (a) Own Client
*      (b) Own Window
*      (c) Parent Client
*
* Moreover, it does the right thing for case (d) when pwnd is top level.
* In that case, we never want to offset by origin of the parent, which is the
* desktop, since that will not work when the virtual screen has a
* negative origin.  And it does the right thing for cases (b) and (c)
* if pwnd is the desktop.
*
* NOTE: The Win95 version of this function had a flag GRECT_SCREENCOORDS,
* which would return the rectangle in screen coords. There's no reason to
* call a function to do this, since the smallest and fastest to copy a
* rectangle is simple assignment. Therefore, I removed GRECT_SCREENCOORDS.
*
* History:
* 19-Sep-1996 adams     Created.
\***************************************************************************/
VOID GetRect(
    PWND pwnd,
    LPRECT lprc,
    UINT uCoords)
{
    PWND    pwndParent;
    LPRECT  lprcOffset;

    UserAssert(lprc);
    UserAssert((uCoords & ~(GRECT_COORDMASK | GRECT_RECTMASK)) == 0);
    UserAssert(uCoords & GRECT_COORDMASK);
    UserAssert(uCoords & GRECT_RECTMASK);

    *lprc = (uCoords & GRECT_WINDOW) ? pwnd->rcWindow : pwnd->rcClient;

    /*
     * If this is the desktop window, we have what we want, whether we
     * are asking for GRECT_PARENTCOORDS, WINDOWCOORD or CLIENTCOORDS
     */
    if (GETFNID(pwnd) == FNID_DESKTOP)
        return;

    switch (uCoords & GRECT_COORDMASK) {
    case GRECT_PARENTCOORDS:
        pwndParent = REBASEPWND(pwnd, spwndParent);
        if (GETFNID(pwndParent) == FNID_DESKTOP)
            return;

        lprcOffset = KPRECT_TO_PRECT(&pwndParent->rcClient);

        //
        // Let's mirror the edges of the child's window since the parent
        // is mirrored, so should the child window be. [samera]
        //
        if (TestWF(pwndParent,WEFLAYOUTRTL) &&
                (uCoords & GRECT_WINDOW) &&
                (TestWF(pwnd,WFCHILD))) {
            int iLeft;

            //
            // I am using OffsetRect instead of implementing a new
            // OffsetMirrorRect API since this is the only place I am
            // doing it in.
            //
            // Since screen coordinates are not mirrored, the rect offsetting
            // should be done relative to prcOffset->right since it is the
            // leading edge for mirrored windows. [samera]
            //

            UserVerify(OffsetRect(lprc, -lprcOffset->right, -lprcOffset->top));

            iLeft = lprc->left;
            lprc->left  = (lprc->right * -1);
            lprc->right = (iLeft * -1);

            return;
        }
        break;

    case GRECT_WINDOWCOORDS:
        lprcOffset = KPRECT_TO_PRECT(&pwnd->rcWindow);
        break;

    case GRECT_CLIENTCOORDS:
        lprcOffset = KPRECT_TO_PRECT(&pwnd->rcClient);
        break;

    default:
        RIPMSG0(RIP_ERROR, "Logic error in _GetRect - invalid uCoords");
        return;
    }

    UserVerify(OffsetRect(lprc, -lprcOffset->left, -lprcOffset->top));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\chartran.c ===
/****************************** Module Header ******************************\
* Module Name: chartran.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#define MOVE_TO_RTL
#include "precomp.h"
#pragma hdrstop
#include "..\chartran.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\alignrec.c ===
/****************************** Module Header ******************************\
* Module Name: chartran.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#define MOVE_TO_RTL
#include "precomp.h"
#pragma hdrstop
#include "..\alignrec.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\drawtext.c ===
/****************************** Module Header ******************************\
* Module Name: drawtext.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\drawtext.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\draw.c ===
/****************************** Module Header ******************************\
* Module Name: draw.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\draw.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\wow.c ===
/****************************** Module Header ******************************\
* Module Name: wow.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains shared code between USER32 and USER16
* No New CODE should be added to this file, unless its shared
* with USER16.
*
* History:
* 29-DEC-93 NanduriR      shared user32/user16 code.
\***************************************************************************/

#include "wow.h"


#ifdef _USERK_
    #define CHECK_RESTRICTED()                                                      \
        if (((PTHREADINFO)W32GetCurrentThread())->TIF_flags & TIF_RESTRICTED) {     \
            if (!ValidateHandleSecure(h))                                           \
                pobj = NULL;                                                        \
        }                                                                           \

#else
    #define CHECK_RESTRICTED()                                              \
        if (pci && (pci->dwTIFlags & TIF_RESTRICTED) && pobj) {             \
            if (!NtUserValidateHandleSecure(h))                             \
                pobj = NULL;                                                \
        }                                                                   \

#endif



#ifdef _USERK_
    #define GET_CURRENT_CLIENTINFO()                            \
        {                                                       \
            PW32THREAD pW32Thread;                              \
                                                                \
            pW32Thread = W32GetCurrentThread();                 \
                                                                \
            if (pW32Thread) {                                   \
                pci = ((PTHREADINFO)pW32Thread)->pClientInfo;   \
            } else {                                            \
                pci = NULL;                                     \
            }                                                   \
        }

#else
    #define GET_CURRENT_CLIENTINFO()                            \
        pci = GetClientInfo();

#endif // _USERK_


/*
 * We have two types of desktop validation:
 *
 */

#ifdef _USERK_

#define DESKTOPVALIDATE(pci, pobj) \
            UNREFERENCED_PARAMETER(pci);

#define DESKTOPVALIDATECCX(pci, pobj)                               \
        if (    ((PVOID)pobj >= pci->pDeskInfo->pvDesktopBase) &&  \
                ((PVOID)pobj < pci->pDeskInfo->pvDesktopLimit)) {  \
            pobj = (PBYTE)pobj - pci->ulClientDelta;               \
        }                                                           \

#define SHAREDVALIDATE(pobj)

#else

#define DESKTOPVALIDATE(pci, pobj)                              \
        if (    pci->pDeskInfo &&                               \
                pobj >= pci->pDeskInfo->pvDesktopBase &&        \
                pobj < pci->pDeskInfo->pvDesktopLimit) {        \
            pobj = (KERNEL_PVOID)((KERNEL_ULONG_PTR)pobj - pci->ulClientDelta);         \
        } else {                                                \
            pobj = (KERNEL_PVOID)NtUserCallOneParam((ULONG_PTR)h,                       \
                    SFI__MAPDESKTOPOBJECT);                     \
        }                                                       \

#define SHAREDVALIDATE(pobj)                                    \
        pobj = REBASESHAREDPTRALWAYS(pobj);

#endif // _USERK_


/*
 * Keep the general path through validation straight without jumps - that
 * means tunneling if()'s for this routine - this'll make validation fastest
 * because of instruction caching.
 *
 * In order to have the validation code in one place only, we define
 *  the *ValidateHandleMacro macros which are to be included by the
 *  HMValidateHanlde* routines. We don't make these into functions
 *  because we're optimizing on time, not size.
 */
#define ValidateHandleMacro(pci, pobj, h, bType) \
    StartValidateHandleMacro(h) \
    BeginAliveValidateHandleMacro()  \
    BeginTypeValidateHandleMacro(pobj, bType) \
    DESKTOPVALIDATE(pci, pobj) \
    EndTypeValidateHandleMacro \
    EndAliveValidateHandleMacro()  \
    EndValidateHandleMacro

#ifdef _USERK_
#define ValidateCatHandleMacro(pci, pobj, h, bType) \
    StartValidateHandleMacro(h) \
    BeginTypeValidateHandleMacro(pobj, bType) \
    DESKTOPVALIDATE(pci, pobj) \
    EndTypeValidateHandleMacro \
    EndValidateHandleMacro
#define ValidateCatHandleMacroCcx(pci, pobj, h, bType) \
    StartValidateHandleMacro(h) \
    BeginTypeValidateHandleMacro(pobj, bType) \
    DESKTOPVALIDATECCX(pci, pobj) \
    EndTypeValidateHandleMacro \
    EndValidateHandleMacro
#endif

#define ValidateSharedHandleMacro(pobj, h, bType) \
    StartValidateHandleMacro(h)  \
    BeginAliveValidateHandleMacro()  \
    BeginTypeValidateHandleMacro(pobj, bType) \
    SHAREDVALIDATE(pobj)        \
    EndTypeValidateHandleMacro \
    EndAliveValidateHandleMacro()  \
    EndValidateHandleMacro


/*
 * The handle validation routines should be optimized for time, not size,
 * since they get called so often.
 */
#pragma optimize("t", on)

/***************************************************************************\
* HMValidateHandle
*
* This routine validates a handle manager handle.
*
* 01-22-92 ScottLu      Created.
\***************************************************************************/

PVOID FASTCALL HMValidateHandle(
    HANDLE h,
    BYTE bType)
{
    DWORD       dwError;
    KERNEL_PVOID pobj = NULL;
    PCLIENTINFO pci;

    GET_CURRENT_CLIENTINFO();

#if DBG != 0 && !defined(_USERK_)
    /*
     * We don't want 32 bit apps passing 16 bit handles
     *  we should consider failing this before we get
     *  stuck supporting it (Some VB apps do this).
     */
    if (pci && (h != NULL)
           && (HMUniqFromHandle(h) == 0)
           && !(pci->dwTIFlags & TIF_16BIT)) {
        RIPMSG3(RIP_WARNING, "HMValidateHandle: 32bit process [%d] using 16 bit handle [%#p] bType:%#lx",
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), h, (DWORD)bType);
    }
#endif

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    /*
     * Validation macro. Falls through if the handle is invalid.
     */
    ValidateHandleMacro(pci, pobj, h, bType);

    /*
     * check for secure process
     */
    CHECK_RESTRICTED();

    if (pobj != NULL) {
        return KPVOID_TO_PVOID(pobj);
    }

    switch (bType) {

    case TYPE_WINDOW:
        dwError = ERROR_INVALID_WINDOW_HANDLE;
        break;

    case TYPE_MENU:
        dwError = ERROR_INVALID_MENU_HANDLE;
        break;

    case TYPE_CURSOR:
        dwError = ERROR_INVALID_CURSOR_HANDLE;
        break;

    case TYPE_ACCELTABLE:
        dwError = ERROR_INVALID_ACCEL_HANDLE;
        break;

    case TYPE_HOOK:
        dwError = ERROR_INVALID_HOOK_HANDLE;
        break;

    case TYPE_SETWINDOWPOS:
        dwError = ERROR_INVALID_DWP_HANDLE;
        break;

    default:
        dwError = ERROR_INVALID_HANDLE;
        break;
    }

    RIPERR2(dwError,
            RIP_WARNING,
            "HMValidateHandle: Invalid:%#p Type:%#lx",
            h, (DWORD)bType);

    /*
     * If we get here, it's an error.
     */
    return NULL;
}

/***************************************************************************\
* HMValidateHandleNoSecure
*
* This routine validates a handle manager handle.
*
* 01-22-92 ScottLu      Created.
\***************************************************************************/
PVOID FASTCALL HMValidateHandleNoSecure(
    HANDLE h,
    BYTE bType)
{
    KERNEL_PVOID pobj = NULL;
    PCLIENTINFO pci;

    GET_CURRENT_CLIENTINFO();

#if !defined(_USERK_)
    /*
     * We don't want 32 bit apps passing 16 bit handles
     *  we should consider failing this before we get
     *  stuck supporting it (Some VB apps do this).
     */
    if (pci && (h != NULL)
           && (HMUniqFromHandle(h) == 0)
           && !(pci->dwTIFlags & TIF_16BIT)) {
        RIPMSG3(RIP_WARNING, "HMValidateHandle: 32bit process [%d] using 16 bit handle [%#p] bType:%#lx",
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), h, (DWORD)bType);
    }
#endif

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    /*
     * Validation macro.
     */
    ValidateHandleMacro(pci, pobj, h, bType);

    return KPVOID_TO_PVOID(pobj);
}

#if defined(_USERK_)
PVOID FASTCALL HMValidateCatHandleNoSecure(
    HANDLE h,
    BYTE bType)
{
    PVOID       pobj = NULL;
    PCLIENTINFO pci;

    GET_CURRENT_CLIENTINFO();

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    /*
     * Validation macro.
     */
    ValidateCatHandleMacro(pci, pobj, h, bType);

    return pobj;
}
PVOID FASTCALL HMValidateCatHandleNoSecureCCX(
    HANDLE h,
    BYTE bType,
    PCLIENTINFO ccxPci)
{
    PVOID       pobj = NULL;

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    /*
     * Validation macro.
     */
    ValidateCatHandleMacroCcx(ccxPci, pobj, h, bType);

    return pobj;
}

PVOID FASTCALL HMValidateCatHandleNoRip(
    HANDLE h,
    BYTE bType)
{
    PVOID       pobj = NULL;
    PCLIENTINFO pci;

    /*
     * This is the fastest way way to do validation, because
     *  unlike HMValidateHandle, this function doesn't set the
     *  last error.
     *
     * Validation macro. Falls through if the handle is invalid.
     */

    GET_CURRENT_CLIENTINFO();

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    ValidateCatHandleMacro(pci, pobj, h, bType);

    /*
     * check for secure process
     */
    CHECK_RESTRICTED();

    return pobj;
}
#endif

PVOID FASTCALL HMValidateHandleNoRip(
    HANDLE h,
    BYTE bType)
{
    KERNEL_PVOID pobj = NULL;
    PCLIENTINFO pci;

    /*
     * This is the fastest way way to do validation, because
     *  unlike HMValidateHandle, this function doesn't set the
     *  last error.
     *
     * Validation macro. Falls through if the handle is invalid.
     */

    GET_CURRENT_CLIENTINFO();

    /*
     * Object can't be located in shared memory.
     */
    UserAssert(bType != TYPE_MONITOR);

    ValidateHandleMacro(pci, pobj, h, bType);

    /*
     * check for secure process
     */
    CHECK_RESTRICTED();

    return KPVOID_TO_PVOID(pobj);
}

#if DBG != 0 && !defined(_USERK_)
/*
 * HMValidateHandleNoDesktop is a debug-client-side only function
 *  used to verify a given handle without calling DESKTOPVALIDATE.
 * If the handle is valid, it returns the object's kernel pointer
 *  which can be used as a BOOL value only.
 * Use this function to verify handles for which corresponding phe->phead
 *  is a pool allocation (as opposed to desktop-heap allocations).
 */
KERNEL_PVOID FASTCALL HMValidateHandleNoDesktop(
    HANDLE h,
    BYTE bType)
{
    KERNEL_PVOID pobj = NULL;

    StartValidateHandleMacro(h)
    BeginTypeValidateHandleMacro(pobj, bType)
    EndTypeValidateHandleMacro
    EndValidateHandleMacro
    return pobj;
}
#endif


/***************************************************************************\
* HMValidateSharedHandle
*
* This routine validates a handle manager handle allocated in
* shared memory.
*
* History:
* 02-Apr-1997 adams     Created.
\***************************************************************************/

PVOID FASTCALL HMValidateSharedHandle(
    HANDLE h,
    BYTE bType)
{
    DWORD dwError;
    KERNEL_PVOID pobj = NULL;

#if DBG != 0 && !defined(_USERK_)

    /*
     * We don't want 32 bit apps passing 16 bit handles
     *  we should consider failing this before we get
     *  stuck supporting it (Some VB apps do this).
     */
    if ((h != NULL)
           && (HMUniqFromHandle(h) == 0)
           && !(GetClientInfo()->dwTIFlags & TIF_16BIT)) {
        RIPMSG3(RIP_WARNING, "HMValidateHandle: 32bit process [%d] using 16 bit handle [%#p] bType:%#lx",
                HandleToUlong(NtCurrentTeb()->ClientId.UniqueProcess), h, (DWORD)bType);
    }
#endif

    /*
     * Validation macro. Falls through if the handle is invalid.
     */
    ValidateSharedHandleMacro(pobj, h, bType);

    if (pobj != NULL)
        return KPVOID_TO_PVOID(pobj);

    switch (bType) {
        case TYPE_MONITOR:
            dwError = ERROR_INVALID_MONITOR_HANDLE;
            break;

        default:
            dwError = ERROR_INVALID_HANDLE;
            break;
    }

    RIPERR2(dwError,
            RIP_WARNING,
            "HMValidateSharedHandle: Invalid:%#p Type:%#lx",
            h, (DWORD)bType);

    /*
     * If we get here, it's an error.
     */
    return NULL;
}


/*
 * Switch back to default optimization.
 */
#pragma optimize("", on)

/***************************************************************************\
* MNLookUpItem
*
* Return a pointer to the menu item specified by wCmd and wFlags
*
* History:
*   10-11-90 JimA       Translated from ASM
*   01-07-93 FritzS     Ported from Chicago
\***************************************************************************/

PITEM MNLookUpItem(
    PMENU pMenu,
    UINT wCmd,
    BOOL fByPosition,
    PMENU *ppMenuItemIsOn)
{
    PITEM pItem;
    PITEM pItemRet = NULL;
    PITEM  pItemMaybe;
    PMENU   pMenuMaybe = NULL;
    int i;

    if (ppMenuItemIsOn != NULL)
        *ppMenuItemIsOn = NULL;

    if (pMenu == NULL || !pMenu->cItems || wCmd == MFMWFP_NOITEM) {
//      RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "MNLookUpItem: invalid item");
        return NULL;
    }

    /*
     * dwFlags determines how we do the search
     */
    if (fByPosition) {
        if (wCmd < (UINT)pMenu->cItems) {
            pItemRet = &((PITEM)REBASEALWAYS(pMenu, rgItems))[wCmd];
            if (ppMenuItemIsOn != NULL)
                *ppMenuItemIsOn = pMenu;
            return (pItemRet);
        } else
            return NULL;
    }
    /*
     * Walk down the menu and try to find an item with an ID of wCmd.
     * The search procedes from the end of the menu (as was done in
     * assembler).
     */

/* this is the Chicago code, which walks from the front of the menu -- Fritz */


//        for (pItem = &pMenu->rgItems[i - 1]; pItemRet == NULL && i--; --pItem) {
    for (i = 0, pItem = REBASEALWAYS(pMenu, rgItems); i < (int)pMenu->cItems;
            i++, pItem++) {

        /*
         * If the item is a popup, recurse down the tree
         */
        if (pItem->spSubMenu != NULL) {
        //
        // COMPAT:
        // Allow apps to pass in menu handle as ID in menu APIs.  We
        // remember that this popup had a menu handle with the same ID
        // value.  This is a 2nd choice though.  We still want to see
        // if there's some actual command that has this ID value first.
        //
            if (pItem->wID == wCmd) {
                pMenuMaybe = pMenu;
                pItemMaybe = pItem;
            }

            pItemRet = MNLookUpItem((PMENU)REBASEPTR(pMenu, pItem->spSubMenu),
                    wCmd, FALSE, ppMenuItemIsOn);
            if (pItemRet != NULL)
                return pItemRet;
        } else if (pItem->wID == wCmd) {

                /*
                 * Found the item, now save things for later
                 */
                if (ppMenuItemIsOn != NULL)
                    *ppMenuItemIsOn = pMenu;
                return pItem;
        }
    }

    if (pMenuMaybe) {
        // no non popup menu match found -- use the 2nd choice popup menu
        // match
        if (ppMenuItemIsOn != NULL)
            *ppMenuItemIsOn = pMenuMaybe;
        return(pItemMaybe);
    }

    return(NULL);
}

/***************************************************************************\
* GetMenuState
*
* Either returns the state of a menu item or the state and item count
* of a popup.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

UINT _GetMenuState(
    PMENU pMenu,
    UINT wId,
    UINT dwFlags)
{
    PITEM pItem;
    DWORD fFlags;

    /*
     * If the item does not exist, leave
     */
    if ((pItem = MNLookUpItem(pMenu, wId, (BOOL) (dwFlags & MF_BYPOSITION), NULL)) == NULL)
        return (UINT)-1;

    fFlags = pItem->fState | pItem->fType;

#ifndef _USERK_
    /*
     * Add old MFT_BITMAP flag to keep old apps happy
     */
    if ((pItem->hbmp != NULL) && (pItem->lpstr == NULL)) {
        fFlags |= MFT_BITMAP;
    }
#endif

    if (pItem->spSubMenu != NULL) {
        /*
         * If the item is a popup, return item count in high byte and
         * popup flags in low byte
         */

        fFlags = ((fFlags | MF_POPUP) & 0x00FF) +
            (((PMENU)REBASEPTR(pMenu, pItem->spSubMenu))->cItems << 8);
    }

    return fFlags;
}


/***************************************************************************\
* GetPrevPwnd
*
*
*
* History:
* 11-05-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

PWND GetPrevPwnd(
    PWND pwndList,
    PWND pwndFind)
{
    PWND pwndFound, pwndNext;

    if (pwndList == NULL)
        return NULL;

    if (pwndList->spwndParent == NULL)
        return NULL;

    pwndNext = REBASEPWND(pwndList, spwndParent);
    pwndNext = REBASEPWND(pwndNext, spwndChild);
    pwndFound = NULL;

    while (pwndNext != NULL) {
        if (pwndNext == pwndFind)
            break;
        pwndFound = pwndNext;
        pwndNext = REBASEPWND(pwndNext, spwndNext);
    }

    return (pwndNext == pwndFind) ? pwndFound : NULL;
}


/***************************************************************************\
* _GetWindow (API)
*
*
* History:
* 11-05-90 darrinm      Ported from Win 3.0 sources.
* 02-19-91 JimA         Added enum access check
* 05-04-02 DarrinM      Removed enum access check and moved to USERRTL.DLL
\***************************************************************************/

PWND _GetWindow(
    PWND pwnd,
    UINT cmd)
{
    PWND pwndT;
    BOOL fRebase = FALSE;

    /*
     * If this is a desktop window, return NULL for sibling or
     * parent information.
     */
    if (GETFNID(pwnd) == FNID_DESKTOP) {
        switch (cmd) {
        case GW_CHILD:
            break;

        default:
            return NULL;
            break;
        }
    }

    /*
     * Rebase the returned window at the end of the routine
     * to avoid multiple test for pwndT == NULL.
     */
    pwndT = NULL;
    switch (cmd) {
    case GW_HWNDNEXT:
        pwndT = pwnd->spwndNext;
        fRebase = TRUE;
        break;

    case GW_HWNDFIRST:
        if (pwnd->spwndParent) {
            pwndT = REBASEPWND(pwnd, spwndParent);
            pwndT = REBASEPWND(pwndT, spwndChild);
            if (GetAppCompatFlags(NULL) & GACF_IGNORETOPMOST) {
                while (pwndT != NULL) {
                    if (!TestWF(pwndT, WEFTOPMOST))
                        break;
                    pwndT = REBASEPWND(pwndT, spwndNext);
                }
            }
        }
        break;

    case GW_HWNDLAST:
        pwndT = GetPrevPwnd(pwnd, NULL);
        break;

    case GW_HWNDPREV:
        pwndT = GetPrevPwnd(pwnd, pwnd);
        break;

    case GW_OWNER:
        pwndT = pwnd->spwndOwner;
        fRebase = TRUE;
        break;

    case GW_CHILD:
        pwndT = pwnd->spwndChild;
        fRebase = TRUE;
        break;

#if !defined(_USERK_)
    case GW_ENABLEDPOPUP:
       pwndT = (PWND)NtUserCallHwnd(PtoHq(pwnd), SFI_DWP_GETENABLEDPOPUP);
       fRebase = TRUE;
       break;
#endif

    default:
        RIPERR0(ERROR_INVALID_GW_COMMAND, RIP_VERBOSE, "");
        return NULL;
    }

    if (pwndT != NULL && fRebase)
        pwndT = REBASEPTR(pwnd, pwndT);

    return pwndT;
}

/***************************************************************************\
* _GetParent (API)
*
*
*
* History:
* 11-12-90 darrinm      Ported.
* 02-19-91 JimA         Added enum access check
* 05-04-92 DarrinM      Removed enum access check and moved to USERRTL.DLL
\***************************************************************************/

PWND _GetParent(
    PWND pwnd)
{
    /*
     * For 1.03 compatibility reasons, we should return NULL
     * for top level "tiled" windows and owner for other popups.
     * pwndOwner is set to NULL in xxxCreateWindow for top level
     * "tiled" windows.
     */
    if (!(TestwndTiled(pwnd))) {
        if (TestwndChild(pwnd))
            pwnd = REBASEPWND(pwnd, spwndParent);
        else
            pwnd = REBASEPWND(pwnd, spwndOwner);
        return pwnd;
    }

    /*
     * The window was not a child window; they may have been just testing
     * if it was
     */
    return NULL;
}


/***************************************************************************\
* GetSubMenu
*
* Return the handle of a popup menu.
*
* History:
* 10-11-90 JimA       Translated from ASM
\***************************************************************************/

PMENU _GetSubMenu(
    PMENU pMenu,
    int nPos)
{
    PITEM pItem;
    PMENU pPopup = NULL;

    /*
     * Make sure nPos refers to a valid popup
     */
    if ((UINT)nPos < (UINT)((PMENU)pMenu)->cItems) {
        pItem = &((PITEM)REBASEALWAYS(pMenu, rgItems))[nPos];
        if (pItem->spSubMenu != NULL)
            pPopup = (PMENU)REBASEPTR(pMenu, pItem->spSubMenu);

    }

    return pPopup;
}


/***************************************************************************\
* _IsChild (API)
*
*
*
* History:
* 11-07-90 darrinm      Translated from Win 3.0 ASM code.
\***************************************************************************/

BOOL _IsChild(
    PWND pwndParent,
    PWND pwnd)
{
    /*
     * Don't need a test to get out of the loop because the
     * desktop is not a child.
     */
    while (pwnd != NULL) {
        if (!TestwndChild(pwnd))
            return FALSE;

        pwnd = REBASEPWND(pwnd, spwndParent);
        if (pwndParent == pwnd)
            return TRUE;
    }
    return FALSE;
}



/***************************************************************************\
* _IsWindowVisible (API)
*
* IsWindowVisible returns the TRUEVIS state of a window, rather than just
* the state of its WFVISIBLE flag.  According to this routine, a window is
* considered visible when it and all the windows on its parent chain are
* visible (WFVISIBLE flag set).  A special case hack was put in that causes
* any icon window being dragged to be considered as visible.
*
* History:
* 11-12-90 darrinm      Ported.
\***************************************************************************/

BOOL _IsWindowVisible(
    PWND pwnd)
{
    /*
     * Check if this is the iconic window being moved around with a mouse
     * If so, return a TRUE, though, strictly speaking, it is hidden.
     * This helps the Tracer guys from going crazy!
     * Fix for Bug #57 -- SANKAR -- 08-08-89 --
     */
    if (pwnd == NULL)
        return TRUE;

    for (;;) {
        if (!TestWF(pwnd, WFVISIBLE))
            return FALSE;
        if (GETFNID(pwnd) == FNID_DESKTOP)
            break;
        pwnd = REBASEPWND(pwnd, spwndParent);
    }

    return TRUE;
}


/***************************************************************************\
* _ClientToScreen (API)
*
* Map a point from client to screen-relative coordinates.
*
* History:
* 11-12-90 darrinm      Translated from Win 3.0 ASM code.
\***************************************************************************/

VOID _ClientToScreen(
    PWND pwnd,
    PPOINT ppt)
{
    /*
     * Client and screen coordinates are the same for the
     * desktop window.
     */
    if (GETFNID(pwnd) != FNID_DESKTOP) {
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            ppt->x  = pwnd->rcClient.right - ppt->x;
        } else {
            ppt->x += pwnd->rcClient.left;
        }
        ppt->y += pwnd->rcClient.top;
    }
}


/***************************************************************************\
* _GetClientRect (API)
*
*
*
* History:
* 26-Oct-1990 DarrinM   Implemented.
\***************************************************************************/

VOID _GetClientRect(
    PWND   pwnd,
    LPRECT prc)
{
    /*
     * If this is a 3.1 app, and it's minimized, then we need to return
     * a rectangle other than the real-client-rect.  This is necessary since
     * there is no client-rect-size in Win4.0.  Apps such as PackRat 1.0
     * will GPF if returned a empty-rect.
     */
    if (TestWF(pwnd, WFMINIMIZED) && !TestWF(pwnd, WFWIN40COMPAT)) {
        prc->left   = 0;
        prc->top    = 0;
        prc->right  = SYSMETRTL(CXMINIMIZED);
        prc->bottom = SYSMETRTL(CYMINIMIZED);

    } else {

        if (GETFNID(pwnd) != FNID_DESKTOP) {
            *prc = pwnd->rcClient;
            OffsetRect(prc, -pwnd->rcClient.left, -pwnd->rcClient.top);
        } else {
            /*
             * For compatibility, return the rect of the primary
             * monitor for the desktop window.
             */
            prc->left = prc->top = 0;
            prc->right = SYSMETRTL(CXSCREEN);
            prc->bottom = SYSMETRTL(CYSCREEN);
        }
    }
}


/***************************************************************************\
* _GetWindowRect (API)
*
*
*
* History:
* 26-Oct-1990 DarrinM   Implemented.
\***************************************************************************/

VOID _GetWindowRect(
    PWND   pwnd,
    LPRECT prc)
{

    if (GETFNID(pwnd) != FNID_DESKTOP) {
        *prc = pwnd->rcWindow;
    } else {
        /*
         * For compatibility, return the rect of the primary
         * monitor for the desktop window.
         */
        prc->left   = 0;
        prc->top    = 0;
        prc->right  = SYSMETRTL(CXSCREEN);
        prc->bottom = SYSMETRTL(CYSCREEN);
    }
}

/***************************************************************************\
* _ScreenToClient (API)
*
* Map a point from screen to client-relative coordinates.
*
* History:
* 11-12-90 darrinm      Translated from Win 3.0 ASM code.
\***************************************************************************/

VOID _ScreenToClient(
    PWND pwnd,
    PPOINT ppt)
{
    /*
     * Client and screen coordinates are the same for the
     * desktop window.
     */
    if (GETFNID(pwnd) != FNID_DESKTOP) {
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            ppt->x  = pwnd->rcClient.right - ppt->x;
        } else {
            ppt->x -= pwnd->rcClient.left;
        }
        ppt->y -= pwnd->rcClient.top;
    }
}
/***************************************************************************\
* PhkNextValid
*
* This helper routine walk the phkNext chain looking for the next valid
*  hook (i.e., not marked as destroyed). If the end of the local (or
*  thread specific) hook chain is reached, then it jumps to the global
*  (or desktop) chain.
*
* Once a hook is destroyed, we don't want anymore activity on it; however,
*  if the hook is locked at destroy time (= someone is calling it), then
*  we keep it in the list so CallNextHook will work properly
*
* History:
* 03/24/96  GerardoB        Moved to rtl and added *Valid stuff.
* 01-30-91  DavidPe         Created.
\***************************************************************************/
PHOOK PhkNextValid(PHOOK phk)
{

#if DBG
    int iHook = phk->iHook;
#ifdef _USERK_
    CheckCritInShared();
#endif
#endif

    do {
        /*
         * If this hook is marked as destroyed, it must be either
         *  locked or we should be in the process of destroying it
         */
        UserAssert(!(phk->flags & HF_DESTROYED)
                    || (((PHEAD)phk)->cLockObj != 0)
                    || (phk->flags & HF_INCHECKWHF));
        /*
         * Get the next hook
         */
        if (phk->phkNext != NULL) {
            phk = REBASEALWAYS(phk, phkNext);
        } else if (!(phk->flags & HF_GLOBAL)) {
#ifdef _USERK_
            phk = PtiCurrent()->pDeskInfo->aphkStart[phk->iHook + 1];
#else
            PCLIENTINFO pci = GetClientInfo();
            phk = pci->pDeskInfo->aphkStart[phk->iHook + 1];
            /*
             * If it found a pointer, rebase it.
             */
            if (phk != NULL) {
                (KPBYTE)phk -= pci->ulClientDelta;
            }
#endif
            UserAssert((phk == NULL) || (phk->flags & HF_GLOBAL));
        } else {
            return NULL;
        }
        /*
         * If destroyed, keep looking.
         */
    } while ((phk != NULL) && (phk->flags & HF_DESTROYED));

#ifdef _USERK_
    DbgValidateHooks(phk, iHook);
#endif

    return phk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\help.c ===
/****************************** Module Header ******************************\
* Module Name: help.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\help.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\getset.c ===
/****************************** Module Header ******************************\
* Module Name: getset.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\getset.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\menu.c ===
/****************************** Module Header ******************************\
* Module Name: menu.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\menu.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\mmrtl.c ===
/****************************** Module Header ******************************\
* Module Name: mmrtl.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* 31-Mar-1997 adams Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\mmrtl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\makefile.inc ===
..\..\precomp.h: $(NTUSER_PATH)\inc\user.h         \
                 $(WINDOWS_INC_PATH)\winuserp.h    \
                 ..\..\userrtl.h

#
# Dependencies for dummy targets
#
..\alignrec.c:  ..\..\alignrec.c
..\chartran.c:  ..\..\chartran.c
..\draw.c:      ..\..\draw.c
..\drawtext.c:  ..\..\drawtext.c
..\getset.c:    ..\..\getset.c
..\help.c:      ..\..\help.c
..\input.c:     ..\..\input.c
..\menu.c:      ..\..\menu.c
..\mmrtl.c:     ..\..\mmrtl.c
..\random.c:    ..\..\random.c
..\rect.c:      ..\..\rect.c
..\text.c:      ..\..\text.c
..\winevent.c:  ..\..\winevent.c
..\winmgr.c:    ..\..\winmgr.c
..\winprop.c:   ..\..\winprop.c
..\wow.c:       ..\..\wow.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\input.c ===
/****************************** Module Header ******************************\
* Module Name: input.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\input.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\rect.c ===
/****************************** Module Header ******************************\
* Module Name: rect.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\rect.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\random.c ===
/****************************** Module Header ******************************\
* Module Name: random.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\random.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=userrtl
TARGETTYPE=LIBRARY

TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_

!include ..\..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\keizon\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\alignrec.c ===
/****************************** Module Header ******************************\
* Module Name: chartran.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#define MOVE_TO_RTL
#include "precomp.h"
#pragma hdrstop
#include "..\alignrec.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\chartran.c ===
/****************************** Module Header ******************************\
* Module Name: chartran.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#define MOVE_TO_RTL
#include "precomp.h"
#pragma hdrstop
#include "..\chartran.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\text.c ===
/****************************** Module Header ******************************\
* Module Name: text.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\text.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\draw.c ===
/****************************** Module Header ******************************\
* Module Name: draw.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\draw.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\drawtext.c ===
/****************************** Module Header ******************************\
* Module Name: drawtext.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\drawtext.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\getset.c ===
/****************************** Module Header ******************************\
* Module Name: getset.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\getset.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\help.c ===
/****************************** Module Header ******************************\
* Module Name: help.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\help.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\input.c ===
/****************************** Module Header ******************************\
* Module Name: input.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\input.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\menu.c ===
/****************************** Module Header ******************************\
* Module Name: menu.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\menu.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\mmrtl.c ===
/****************************** Module Header ******************************\
* Module Name: mmrtl.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* 31-Mar-1997 adams Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\mmrtl.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\random.c ===
/****************************** Module Header ******************************\
* Module Name: random.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\random.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\winmgr.c ===
/****************************** Module Header ******************************\
* Module Name: winmgr.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winmgr.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\rect.c ===
/****************************** Module Header ******************************\
* Module Name: rect.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\rect.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\text.c ===
/****************************** Module Header ******************************\
* Module Name: text.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\text.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\winevent.c ===
/****************************** Module Header ******************************\
* Module Name: winevent.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
* It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
* files that are not stored in the current directory or the current
* directory's parent.
* Note also that a specific dependency line is included in makefile.inc
* so the corresponding object is properly rebuilt when the source file
* included below changes.
*
* History:
* Jul-18-2000 DwayneN Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winevent.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\winprop.c ===
/****************************** Module Header ******************************\
* Module Name: winprop.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winprop.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\client\wow.c ===
/****************************** Module Header ******************************\
* Module Name: wow.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#ifndef WOW
#pragma hdrstop
#endif
#include "..\wow.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\winmgr.c ===
/****************************** Module Header ******************************\
* Module Name: winmgr.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winmgr.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\winevent.c ===
/****************************** Module Header ******************************\
* Module Name: winevent.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
* It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
* files that are not stored in the current directory or the current
* directory's parent.
* Note also that a specific dependency line is included in makefile.inc
* so the corresponding object is properly rebuilt when the source file
* included below changes.
*
* History:
* Jul-18-2000 DwayneN Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winevent.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\winprop.c ===
/****************************** Module Header ******************************\
* Module Name: winprop.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\winprop.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\wow.c ===
/****************************** Module Header ******************************\
* Module Name: wow.c
*
* Copyright (c) 1985-96, Microsoft Corporation
*
* This file is included in the SOURCES= line of ntuser\rtl\sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#ifndef WOW
#pragma hdrstop
#endif
#include "..\wow.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\keizon\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\makefile.inc ===
..\..\precomp.h: $(NTUSER_PATH)\inc\user.h    \
    $(PROJECT_INC_PATH)\winuserp.h            \
    ..\..\userrtl.h

#
# Dependencies for dummy targets
#
..\alignrec.c:  ..\..\alignrec.c
..\chartran.c:  ..\..\chartran.c
..\draw.c:      ..\..\draw.c
..\drawtext.c:  ..\..\drawtext.c
..\getset.c:    ..\..\getset.c
..\help.c:      ..\..\help.c
..\input.c:     ..\..\input.c
..\menu.c:      ..\..\menu.c
..\mmrtl.c:     ..\..\mmrtl.c
..\random.c:    ..\..\random.c
..\rect.c:      ..\..\rect.c
..\text.c:      ..\..\text.c
..\winevent.c:  ..\..\winevent.c
..\winmgr.c:    ..\..\winmgr.c
..\winprop.c:   ..\..\winprop.c
..\wow.c:       ..\..\wow.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\rtl\kernel\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=userkrtl
TARGETTYPE=LIBRARY

TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_ -D_USERK_ -DNTOS_KERNEL_RUNTIME=1

NTTARGETFILES=

!include ..\..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\debug.c ===
/****************************** Module Header ******************************\
* Module Name: debug.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains random debugging related functions.
*
* History:
* 17-May-1991 DarrinM   Created.
* 22-Jan-1992 IanJa     ANSI/Unicode neutral (all debug output is ANSI)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/**************************************************************************\
* ActivateDebugger
*
* Force an exception on the active application's context so it will break
* into the debugger.
*
* History:
* 05-10-91 DarrinM      Created.
\***************************************************************************/

ULONG SrvActivateDebugger(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PACTIVATEDEBUGGERMSG a = (PACTIVATEDEBUGGERMSG)&m->u.ApiMessageData;
    PCSR_THREAD Thread;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(ReplyStatus);

    /*
     * If the process is CSR, break
     */
    if (a->ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) {
        DbgBreakPoint();
        return STATUS_SUCCESS;
    }

    /*
     * Impersonate the client if this is a user mode request.
     */
    if (m->h.u2.s2.Type == LPC_REQUEST) {
        if (!CsrImpersonateClient(NULL)) {
            return STATUS_UNSUCCESSFUL;
        }
    }

    /*
     * Lock the client thread
     */
    Status = CsrLockThreadByClientId(a->ClientId.UniqueThread, &Thread);
    if (NT_SUCCESS(Status)) {
        ASSERT(a->ClientId.UniqueProcess == Thread->ClientId.UniqueProcess);

        Status = DbgUiIssueRemoteBreakin (Thread->Process->ProcessHandle);

        UserAssert(NT_SUCCESS(Status));
        Status = NtAlertThread(Thread->ThreadHandle);
        UserAssert(NT_SUCCESS(Status));
        CsrUnlockThread(Thread);
    }

    /*
     * Stop impersonating the client.
     */
    if (m->h.u2.s2.Type == LPC_REQUEST) {
        CsrRevertToSelf();
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\exports.c ===
/**************************** Module Header ********************************\
* Module Name: exports.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Routines exported from winsrv.dll
*
* History:
* 03-04-95 JimA                Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _UserSoundSentry
*
* Private API for BASE to use for SoundSentry support.
*
* History:
* 08-02-93 GregoryW         Created.
\***************************************************************************/
BOOL
_UserSoundSentry(
    UINT uVideoMode)
{
    UNREFERENCED_PARAMETER(uVideoMode);

    return NT_SUCCESS(NtUserSoundSentry());
}

/***************************************************************************\
* _UserTestTokenForInteractive
*
* Returns TRUE if the token passed represents an interactive user logged
* on by winlogon, otherwise FALSE
*
* The token handle passed must have TOKEN_QUERY access.
*
* History:
* 05-06-92 Davidc       Created
\***************************************************************************/

NTSTATUS
_UserTestTokenForInteractive(
    HANDLE Token,
    PLUID pluidCaller
    )
{
    PTOKEN_STATISTICS pStats;
    ULONG BytesRequired;
    NTSTATUS Status;

    /*
     * Get the session id of the caller.
     */
    Status = NtQueryInformationToken(
                 Token,                     // Handle
                 TokenStatistics,           // TokenInformationClass
                 NULL,                      // TokenInformation
                 0,                         // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        return Status;
        }

    //
    // Allocate space for the user info
    //

    pStats = (PTOKEN_STATISTICS)LocalAlloc(LPTR, BytesRequired);
    if (pStats == NULL) {
        return Status;
        }

    //
    // Read in the user info
    //

    Status = NtQueryInformationToken(
                 Token,             // Handle
                 TokenStatistics,       // TokenInformationClass
                 pStats,                // TokenInformation
                 BytesRequired,         // TokenInformationLength
                 &BytesRequired         // ReturnLength
                 );

    if (NT_SUCCESS(Status)) {
        if (pluidCaller != NULL)
             *pluidCaller = pStats->AuthenticationId;

        /*
         * A valid session id has been returned.  Compare it
         * with the id of the logged on user.
         */
        Status = NtUserTestForInteractiveUser(&pStats->AuthenticationId);
#ifdef LATER
        if (pStats->AuthenticationId.QuadPart == pwinsta->luidUser.QuadPart)
            Status = STATUS_SUCCESS;
        else
            Status = STATUS_ACCESS_DENIED;
#endif
    }

    LocalFree(pStats);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\api.c ===
/*************************************************************************
*
* api.c
*
* WinStation Control API's for WIN32 subsystem.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

#include "ntuser.h"

#include <winsta.h>
#include <wstmsg.h>
#include <icadd.h>
#include "winbasep.h"

#define SESSION_ROOT L"\\Sessions"
#define MAX_SESSION_PATH 256

NTSTATUS CsrPopulateDosDevices(VOID);
NTSTATUS CleanupSessionObjectDirectories(VOID);

BOOL CtxInitUser32(VOID);

USHORT gHRes = 0;
USHORT gVRes = 0;
USHORT gColorDepth = 0;

#if DBG
ULONG  gulConnectCount = 0;
#endif // DBG

DWORD  gLUIDDeviceMapsEnabled = 0;

/*
 * The following are gotten from ICASRV.
 */
HANDLE G_IcaVideoChannel = NULL;
HANDLE G_IcaMouseChannel = NULL;
HANDLE G_IcaKeyboardChannel = NULL;
HANDLE G_IcaBeepChannel = NULL;
HANDLE G_IcaCommandChannel = NULL;
HANDLE G_IcaThinwireChannel = NULL;
WCHAR G_WinStationName[WINSTATIONNAME_LENGTH];




HANDLE G_ConsoleShadowVideoChannel;
HANDLE G_ConsoleShadowMouseChannel;
HANDLE G_ConsoleShadowKeyboardChannel;
HANDLE G_ConsoleShadowBeepChannel;
HANDLE G_ConsoleShadowCommandChannel;
HANDLE G_ConsoleShadowThinwireChannel;
BOOL   G_fCursorShadow;

/*
 * Definition for the WinStation control API's dispatch table
 */
typedef NTSTATUS (*PWIN32WINSTATION_API)(IN OUT PWINSTATION_APIMSG ApiMsg);

typedef struct _WIN32WINSTATION_DISPATCH {
    PWIN32WINSTATION_API pWin32ApiProc;
} WIN32WINSTATION_DISPATCH, *PWIN32WINSTATION_DISPATCH;

NTSTATUS W32WinStationDoConnect( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationDoDisconnect( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationDoReconnect( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationExitWindows( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationTerminate( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationNtSecurity( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationDoMessage( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationThinwireStats( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationShadowSetup( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationShadowStart( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationShadowStop( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationShadowCleanup( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationPassthruEnable( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationPassthruDisable( IN OUT PWINSTATION_APIMSG );

// This is the counter part to SMWinStationBroadcastSystemMessage
NTSTATUS W32WinStationBroadcastSystemMessage( IN OUT PWINSTATION_APIMSG );
// This is the counter part to SMWinStationSendWindowMessage
NTSTATUS W32WinStationSendWindowMessage( IN OUT PWINSTATION_APIMSG );

NTSTATUS W32WinStationSetTimezone( IN OUT PWINSTATION_APIMSG );


NTSTATUS W32WinStationDoNotify( IN OUT PWINSTATION_APIMSG );
/*
 * WinStation API Dispatch Table
 *
 * Only the API's that WIN32 implements as opposed to ICASRV
 * are entered here. The rest are NULL so that the same WinStation API
 * numbers may be used by ICASRV and WIN32.  If this table is
 * changed, the table below must be modified too, as well as the API
 * dispatch table in the ICASRV.
 */


WIN32WINSTATION_DISPATCH Win32WinStationDispatch[SMWinStationMaxApiNumber] = {
    NULL, // create
    NULL, // reset
    NULL, // disconnect
    NULL, // WCharLog
    NULL, // ApiWinStationGetSMCommand,
    NULL, // ApiWinStationBrokenConnection,
    NULL, // ApiWinStationIcaReplyMessage,
    NULL, // ApiWinStationIcaShadowHotkey,
    W32WinStationDoConnect,
    W32WinStationDoDisconnect,
    W32WinStationDoReconnect,
    W32WinStationExitWindows,
    W32WinStationTerminate,
    W32WinStationNtSecurity,
    W32WinStationDoMessage,
    NULL,
    W32WinStationThinwireStats,
    W32WinStationShadowSetup,
    W32WinStationShadowStart,
    W32WinStationShadowStop,
    W32WinStationShadowCleanup,
    W32WinStationPassthruEnable,
    W32WinStationPassthruDisable,
    W32WinStationSetTimezone,
    NULL, // [AraBern] this was missing: SMWinStationInitialProgram
    NULL, // [AraBern] this was missing: SMWinStationNtsdDebug
    W32WinStationBroadcastSystemMessage,
    W32WinStationSendWindowMessage,
    W32WinStationDoNotify,
};

#if DBG
PSZ Win32WinStationAPIName[SMWinStationMaxApiNumber] = {
    "SmWinStationCreate",
    "SmWinStationReset",
    "SmWinStationDisconnect",
    "SmWinStationWCharLog",
    "SmWinStationGetSMCommand",
    "SmWinStationBrokenConnection",
    "SmWinStationIcaReplyMessage",
    "SmWinStationIcaShadowHotkey",
    "SmWinStationDoConnect",
    "SmWinStationDoDisconnect",
    "SmWinStationDoReconnect",
    "SmWinStationExitWindows",
    "SmWinStationTerminate",
    "SmWinStationNtSecurity",
    "SmWinStationDoMessage",
    "SmWinstationDoBreakPoint",
    "SmWinStationThinwireStats",
    "SmWinStationShadowSetup",
    "SmWinStationShadowStart",
    "SmWinStationShadowStop",
    "SmWinStationShadowCleanup",
    "SmWinStationPassthruEnable",
    "SmWinStationPassthruDisable",
    "SMWinStationSetTimeZone",
    "SMWinStationInitialProgram",
    "SMWinStationNtsdDebug",
    "W32WinStationBroadcastSystemMessage",
    "W32WinStationSendWindowMessage",
    "W32WinStationDoNotify",
};
#endif

NTSTATUS TerminalServerRequestThread( PVOID );
NTSTATUS Win32CommandChannelThread( PVOID );
NTSTATUS Win32ConsoleShadowChannelThread( PVOID );
NTSTATUS RemoteDoMessage( PWINSTATION_APIMSG pMsg );
NTSTATUS MultiUserSpoolerInit();

extern HANDLE g_hDoMessageEvent;

NTSTATUS RemoteDoBroadcastSystemMessage( PWINSTATION_APIMSG pMsg );
NTSTATUS RemoteDoSendWindowMessage( PWINSTATION_APIMSG  pMsg);
BOOL CancelExitWindows(VOID);



/*****************************************************************************
 *
 *  WinStationAPIInit
 *
 *   Creates and initializes the WinStation API port and thread.
 *
 * ENTRY:
 *    No Parameters
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationAPIInit(
    VOID)
{
    NTSTATUS  Status;
    CLIENT_ID ClientId;
    HANDLE    ThreadHandle;
    KPRIORITY Priority;
    ULONG LUIDDeviceMapsEnabled;


#if DBG
    static BOOL Inited = FALSE;
#endif

    UserAssert(Inited == FALSE);

    gSessionId = NtCurrentPeb()->SessionId;



    //
    // Check if LUID DosDevices are enabled
    //
    Status = NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessLUIDDeviceMapsEnabled,
                                        &LUIDDeviceMapsEnabled,
                                        sizeof(LUIDDeviceMapsEnabled),
                                        NULL
                                      );

    if (NT_SUCCESS(Status)) {
        gLUIDDeviceMapsEnabled = LUIDDeviceMapsEnabled;
    }

#if DBG
    if (Inited)
        RIPMSG0(RIP_WARNING, "WinStationAPIInit called twice !!!");

    Inited = TRUE;
#endif

    Status = RtlCreateUserThread(NtCurrentProcess(),
                              NULL,
                              TRUE,
                              0L,
                              0L,
                              0L,
                              TerminalServerRequestThread,
                              NULL,
                              &ThreadHandle,
                              &ClientId);

    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "WinStationAPIInit: failed to create TerminalServerRequestThread");
        goto Exit;
    }
    /*
     *  Add thread to server thread pool
     */
    CsrAddStaticServerThread(ThreadHandle, &ClientId, 0);

    /*
     * Boost priority of ICA SRV Request thread
     */
    Priority = THREAD_BASE_PRIORITY_MAX;

    Status = NtSetInformationThread(ThreadHandle, ThreadBasePriority,
                                 &Priority, sizeof(Priority));

    if (!NT_SUCCESS(Status)) {
        RIPMSG0(RIP_WARNING, "WinStationAPIInit: failed to set thread priority");
        goto Exit;
    }

    /*
     * Resume the thread now that we've initialized things.
     */
    NtResumeThread(ThreadHandle, NULL);


Exit:
    return Status;
}

NTSTATUS
TerminalServerRequestThread(
    PVOID ThreadParameter)
{
    UNICODE_STRING              PortName;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    WINSTATIONAPI_CONNECT_INFO  info;
    ULONG                       ConnectInfoLength;
    WINSTATION_APIMSG           ApiMsg;
    PWIN32WINSTATION_DISPATCH   pDispatch;
    NTSTATUS                    Status;
    REMOTE_PORT_VIEW            ServerView;
    HANDLE                      CsrStartHandle, hevtTermSrvInit;
    HANDLE                      hLPCPort = NULL;

    UNREFERENCED_PARAMETER(ThreadParameter);

    hevtTermSrvInit = CreateEvent(NULL, TRUE, FALSE,
                                  L"Global\\TermSrvReadyEvent");
    if (hevtTermSrvInit == NULL) {
        RIPMSG1(RIP_WARNING,
                "Couldn't create TermSrvReadyEvent. Error = 0x%x",
                GetLastError());
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    NtWaitForSingleObject(hevtTermSrvInit, FALSE, NULL);
    NtClose(hevtTermSrvInit);

    /*
     * Connect to terminal server API port.
     */
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    RtlInitUnicodeString(&PortName, L"\\SmSsWinStationApiPort");

    /*
     * Init the REMOTE_VIEW structure.
     */
    ServerView.Length = sizeof(ServerView);
    ServerView.ViewSize = 0;
    ServerView.ViewBase = 0;

    /*
     * Fill in the ConnectInfo structure with our access request mask.
     */
    info.Version = CITRIX_WINSTATIONAPI_VERSION;
    info.RequestedAccess = 0;
    ConnectInfoLength = sizeof(WINSTATIONAPI_CONNECT_INFO);

    Status = NtConnectPort(&hLPCPort,
                           &PortName,
                           &DynamicQos,
                           NULL, // ClientView
                           &ServerView,
                           NULL, // Max message length [select default]
                           (PVOID)&info,
                           &ConnectInfoLength);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "TerminalServerRequestThread: Failed to connect to LPC port: Status = 0x%x", Status);
        UserExitWorkerThread(Status);
        return Status;
    }

    //
    // Terminal Server calls into Session Manager to create a new Hydra session.
    // The session manager creates and resume a new session and returns to Terminal
    // server the session id of the new session. There is a race condition where
    // CSR can resume and call into terminal server before terminal server can
    // store the session id in its internal structure. To prevent this CSR will
    // wait here on a named event which will be set by Terminal server once it
    // gets the sessionid for the newly created session
    //

    if (NtCurrentPeb()->SessionId != 0) {
        CsrStartHandle = CreateEvent(NULL, TRUE, FALSE, L"CsrStartEvent");

        if (!CsrStartHandle) {
            RIPMSG1(RIP_WARNING,
                    "Failed to create CsrStartEvent. Error = 0x%x",
                    GetLastError());
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        } else {
            Status = NtWaitForSingleObject(CsrStartHandle, FALSE, NULL);

            NtClose(CsrStartHandle);
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING,
                        "Wait for CsrStartEvent failed: Status = 0x%x", Status);
            }
        }
    }

    RtlZeroMemory(&ApiMsg, sizeof(ApiMsg));
    for (;;) {

        /*
         * Initialize LPC message fields.
         */
        ApiMsg.h.u1.s1.DataLength     = sizeof(ApiMsg) - sizeof(PORT_MESSAGE);
        ApiMsg.h.u1.s1.TotalLength    = sizeof(ApiMsg);
        ApiMsg.h.u2.s2.Type           = 0; // Kernel will fill in message type
        ApiMsg.h.u2.s2.DataInfoOffset = 0;
        ApiMsg.ApiNumber              = SMWinStationGetSMCommand;

        Status = NtRequestWaitReplyPort(hLPCPort,
                                        (PPORT_MESSAGE)&ApiMsg,
                                        (PPORT_MESSAGE)&ApiMsg);

        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING,
                    "TerminalServerRequestThread wait failed: Status 0x%x", Status);
            break;
        }

        if (ApiMsg.ApiNumber >= SMWinStationMaxApiNumber) {
            RIPMSG1(RIP_WARNING,
                    "TerminalServerRequestThread: Bad API number %d", ApiMsg.ApiNumber);

            ApiMsg.ReturnedStatus = STATUS_NOT_IMPLEMENTED;
        } else {
            /*
             * We must VALIDATE which ones are implemented here.
             */
            pDispatch = &Win32WinStationDispatch[ApiMsg.ApiNumber];

            if (pDispatch->pWin32ApiProc) {
                BOOL bRestoreDesktop = FALSE;
                NTSTATUS Status = STATUS_SUCCESS;
                USERTHREAD_USEDESKTOPINFO utudi;

                /*
                 * For all the win32k callouts - with the exception of terminate
                 * and timezone setting - set this thread to the current desktop.
                 */
                if (ApiMsg.ApiNumber != SMWinStationTerminate && ApiMsg.ApiNumber != SMWinStationSetTimeZone) {
                    BOOL bAttachDesktop = TRUE;
                    if (ApiMsg.ApiNumber == SMWinStationDoConnect) {
                        WINSTATIONDOCONNECTMSG* m = &ApiMsg.u.DoConnect;
                        if (!m->ConsoleShadowFlag) {
                            bAttachDesktop = FALSE;
                        }
                    }
                    if (bAttachDesktop) {
                        utudi.hThread = NULL;
                        utudi.drdRestore.pdeskRestore = NULL;
                        Status = NtUserSetInformationThread(NtCurrentThread(),
                                                            UserThreadUseActiveDesktop,
                                                            &utudi, sizeof(utudi));

                        if (NT_SUCCESS(Status)) {
                            bRestoreDesktop = TRUE;
                        }
                    }
                }


                /*
                 * Call the API
                 */
                if (Status == STATUS_SUCCESS) {
                    ApiMsg.ReturnedStatus = (pDispatch->pWin32ApiProc)(&ApiMsg);
                } else {
                    ApiMsg.ReturnedStatus = Status;
                }

                if (bRestoreDesktop) {
                    NtUserSetInformationThread(NtCurrentThread(),
                                               UserThreadUseDesktop,
                                               &utudi,
                                               sizeof(utudi));
                }

                /*
                 * Let's bail ...
                 */
                if (ApiMsg.ApiNumber == SMWinStationTerminate) {
                    break;
                }
            } else {
                // This control API is not implemented in WIN32
                ApiMsg.ReturnedStatus = STATUS_NOT_IMPLEMENTED;
            }
        }
    }

Exit:
    if (hLPCPort) {
        NtClose(hLPCPort);
    }

    UserExitWorkerThread(Status);
    return Status;
}

#if DBG
VOID
W32WinStationDumpReconnectInfo(
    WINSTATIONDORECONNECTMSG *pDoReconnect,
    BOOLEAN bReconnect)
{
    PSTR pCallerName;

    if (bReconnect) {
        pCallerName = "W32WinStationDoReconnect";
    } else {
        pCallerName = "W32WinStationDoConnect";
    }

    DbgPrint(pCallerName);
    DbgPrint(" - Display resolution information for session %d :\n", gSessionId);

    DbgPrint("\tProtocolType : %04d\n", pDoReconnect->ProtocolType);
    DbgPrint("\tHRes : %04d\n", pDoReconnect->HRes);
    DbgPrint("\tVRes : %04d\n", pDoReconnect->VRes);
    DbgPrint("\tColorDepth : %04d\n", pDoReconnect->ColorDepth);

    DbgPrint("\tKeyboardType : %d\n", pDoReconnect->KeyboardType);
    DbgPrint("\tKeyboardSubType : %d\n", pDoReconnect->KeyboardSubType);
    DbgPrint("\tKeyboardFunctionKey : %d\n", pDoReconnect->KeyboardFunctionKey);
}
#else
    #define W32WinStationDumpReconnectInfo(p, b)
#endif // DBG

NTSTATUS
W32WinStationDoConnect(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    WINSTATIONDOCONNECTMSG* m = &pMsg->u.DoConnect;
    WCHAR                   DisplayDriverName[10];
    CLIENT_ID               ClientId;
    HANDLE                  ThreadHandle;
    KPRIORITY               Priority;
    DOCONNECTDATA           DoConnectData;
    WINSTATIONDORECONNECTMSG mDoReconnect;
    HANDLE hDisplayChangeEvent = NULL;


    if (!m->ConsoleShadowFlag) {

        UserAssert(gulConnectCount == 0);



        if ((gLUIDDeviceMapsEnabled == 0) && (gSessionId != 0)) {
            /*
             * Populate the sessions \DosDevices from
             * the current consoles settings
             */
            Status = CsrPopulateDosDevices();
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING, "CsrPopulateDosDevices failed with Status %lx", Status);
                goto Exit;
            }
        }

        G_IcaVideoChannel    = m->hIcaVideoChannel;
        G_IcaMouseChannel    = m->hIcaMouseChannel;
        G_IcaKeyboardChannel = m->hIcaKeyboardChannel;
        G_IcaBeepChannel     = m->hIcaBeepChannel;
        G_IcaCommandChannel  = m->hIcaCommandChannel;
        G_IcaThinwireChannel = m->hIcaThinwireChannel;

        RtlZeroMemory(G_WinStationName, sizeof(G_WinStationName));
        memcpy(G_WinStationName, m->WinStationName,
                min(sizeof(G_WinStationName), sizeof(m->WinStationName)));
    }  else {


        G_ConsoleShadowVideoChannel    = m->hIcaVideoChannel;
        G_ConsoleShadowMouseChannel    = m->hIcaMouseChannel;
        G_ConsoleShadowKeyboardChannel = m->hIcaKeyboardChannel;
        G_ConsoleShadowBeepChannel     = m->hIcaBeepChannel;
        G_ConsoleShadowCommandChannel  = m->hIcaCommandChannel;
        G_ConsoleShadowThinwireChannel = m->hIcaThinwireChannel;

        G_fCursorShadow = FALSE;
        SystemParametersInfo(SPI_GETCURSORSHADOW, 0, &G_fCursorShadow, 0);
        if ( G_fCursorShadow )
            SystemParametersInfo(SPI_SETCURSORSHADOW, 0, FALSE, 0);

        hDisplayChangeEvent = m->hDisplayChangeEvent;
    }


    /*
     * This must be 8 unicode characters (file name) plus two zero wide characters.
     */
    RtlZeroMemory(DisplayDriverName, sizeof(DisplayDriverName));
    memcpy(DisplayDriverName, m->DisplayDriverName, sizeof(DisplayDriverName) - 2);

    /*
     * Give the information to the WIN32 driver.
     */
    RtlZeroMemory(&DoConnectData, sizeof(DoConnectData));

    DoConnectData.fMouse          = m->fMouse;
    DoConnectData.IcaBeepChannel  = m->hIcaBeepChannel;
    DoConnectData.IcaVideoChannel = m->hIcaVideoChannel;
    DoConnectData.IcaMouseChannel = m->hIcaMouseChannel;
    DoConnectData.fEnableWindowsKey = m->fEnableWindowsKey;;

    DoConnectData.IcaKeyboardChannel        = m->hIcaKeyboardChannel;
    DoConnectData.IcaThinwireChannel        = m->hIcaThinwireChannel;
    DoConnectData.fClientDoubleClickSupport = m->fClientDoubleClickSupport;

    DoConnectData.DisplayChangeEvent = hDisplayChangeEvent;

    /*
     * Give the information to the keyboard type/subtype/number of functions.
     */
    DoConnectData.ClientKeyboardType.Type        = m->KeyboardType;
    DoConnectData.ClientKeyboardType.SubType     = m->KeyboardSubType;
    DoConnectData.ClientKeyboardType.FunctionKey = m->KeyboardFunctionKey;

    memcpy(DoConnectData.WinStationName, G_WinStationName,
            min(sizeof(G_WinStationName), sizeof(DoConnectData.WinStationName)));

    DoConnectData.drProtocolType = m->ProtocolType;
    DoConnectData.drPelsHeight = m->VRes;
    DoConnectData.drPelsWidth = m->HRes;
    DoConnectData.drBitsPerPel = m->ColorDepth;

    mDoReconnect.ProtocolType = m->ProtocolType;
    mDoReconnect.HRes = m->HRes;
    mDoReconnect.VRes = m->VRes;
    mDoReconnect.ColorDepth = m->ColorDepth;

    W32WinStationDumpReconnectInfo(&mDoReconnect, FALSE);

    /* Give winstation protocol name */
    RtlZeroMemory(DoConnectData.ProtocolName, sizeof(DoConnectData.ProtocolName));
    memcpy(DoConnectData.ProtocolName, m->ProtocolName, sizeof(DoConnectData.ProtocolName) - 2);

    /* Give winstation audio drver name */
    RtlZeroMemory(DoConnectData.AudioDriverName, sizeof(DoConnectData.AudioDriverName));
    memcpy(DoConnectData.AudioDriverName, m->AudioDriverName, sizeof(DoConnectData.AudioDriverName) - 2);


    DoConnectData.fConsoleShadowFlag = (BOOL) m->ConsoleShadowFlag;

    Status = NtUserRemoteConnect(&DoConnectData,
                                sizeof(DisplayDriverName),
                                DisplayDriverName);

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "NtUserRemoteConnect failed with Status %lx", Status);
        goto Exit;
    }

    Status = RtlCreateUserThread(NtCurrentProcess(),
                                 NULL,
                                 TRUE,
                                 0L,
                                 0L,
                                 0L,
                                 Win32CommandChannelThread,
                                 (PVOID)m->ConsoleShadowFlag,
                                 &ThreadHandle,
                                 &ClientId);


    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "RtlCreateUserThread failed with Status %lx", Status);
        goto Exit;
    }

    /*
     * Add thread to server thread pool.
     */
    if (CsrAddStaticServerThread(ThreadHandle, &ClientId, 0) == NULL) {
        RIPMSG0(RIP_WARNING, "CsrAddStaticServerThread failed");
        goto Exit;
    }

    /*
     * Boost priority of thread
     */
    Priority = THREAD_BASE_PRIORITY_MAX;

    Status = NtSetInformationThread(ThreadHandle, ThreadBasePriority,
                                    &Priority, sizeof(Priority));

    UserAssert(NT_SUCCESS(Status));

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "NtSetInformationThread failed with Status %lx", Status);
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * Resume the thread now that we've initialized things.
     */
    NtResumeThread(ThreadHandle, NULL);



    if (!m->ConsoleShadowFlag) {
        if (CsrConnectToUser() == NULL) {
            RIPMSG0(RIP_WARNING, "CsrConnectToUser failed");
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        if (!CtxInitUser32()) {
            RIPMSG0(RIP_WARNING, "CtxInitUser32 failed");
            Status = STATUS_NO_MEMORY;
            goto Exit;
        }

        /*
         * Create the Spooler service thread
         */
        if (gSessionId != 0) {
            Status = MultiUserSpoolerInit();
        }

        /*
         * Save the resolution
         */
        gHRes       = mDoReconnect.HRes;
        gVRes       = mDoReconnect.VRes;
        gColorDepth = mDoReconnect.ColorDepth;

    } else {
        /*
         * By now, the object has been referenced in kernel mode.
         */
        CloseHandle(hDisplayChangeEvent);
    }


Exit:

#if DBG
    if (!m->ConsoleShadowFlag) {
        if (Status == STATUS_SUCCESS) {
            gulConnectCount++;
        }
    }
#endif // DBG

    return Status;
}


NTSTATUS
W32WinStationDoDisconnect(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status = STATUS_SUCCESS;
    WINSTATIONDODISCONNECTMSG* m = &pMsg->u.DoDisconnect;
    IO_STATUS_BLOCK IoStatus;


    if (!m->ConsoleShadowFlag) {
        RtlZeroMemory(G_WinStationName, sizeof(G_WinStationName));
        Status = (NTSTATUS)NtUserCallNoParam(SFI_XXXREMOTEDISCONNECT);
    } else {
        Status = (NTSTATUS)NtUserCallNoParam(SFI_XXXREMOTECONSOLESHADOWSTOP);

        if (G_ConsoleShadowMouseChannel) {
            CloseHandle(G_ConsoleShadowMouseChannel);
            G_ConsoleShadowMouseChannel = NULL;
        }
        if (G_ConsoleShadowKeyboardChannel) {
            CloseHandle(G_ConsoleShadowKeyboardChannel);
            G_ConsoleShadowKeyboardChannel = NULL;
        }

        // Dont close the G_ConsoleShadowCommandChannel now
        // Instead send a IOCTL to termdd
        // Win32CommandChannelThread will close this channel - closing in 2 places leads to a Race condition

        if (G_ConsoleShadowCommandChannel) {

            Status = NtDeviceIoControlFile(
                        G_ConsoleShadowCommandChannel,                        
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL,
                        NULL,
                        0,
                        NULL,
                        0);
        }

        // Dont close the G_ConsoleShadowVideoChannel now
        // Instead send a IOCTL to termdd
        // Win32CommandChannelThread will close this channel - closing in 2 places leads to a Race condition

        if (G_ConsoleShadowVideoChannel) {

            Status = NtDeviceIoControlFile(
                        G_ConsoleShadowVideoChannel,                        
                        NULL,
                        NULL,
                        NULL,
                        &IoStatus,
                        IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL,
                        NULL,
                        0,
                        NULL,
                        0);
        }

        if (G_ConsoleShadowBeepChannel) {
            CloseHandle(G_ConsoleShadowBeepChannel);
            G_ConsoleShadowBeepChannel = NULL;
        }
        if (G_ConsoleShadowThinwireChannel) {
            CloseHandle(G_ConsoleShadowThinwireChannel);
            G_ConsoleShadowThinwireChannel = NULL;
        }

        if ( G_fCursorShadow )
            SystemParametersInfo(SPI_SETCURSORSHADOW, 0, (LPVOID)TRUE, 0);
    }

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "xxxRemoteDisconnect failed with Status %lx", Status);
    }

#if DBG
    if (!m->ConsoleShadowFlag && Status == STATUS_SUCCESS) {
        gulConnectCount--;
    }

#endif // DBG

    return Status;

    UNREFERENCED_PARAMETER(pMsg);
}


NTSTATUS
W32WinStationDoReconnect(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    DORECONNECTDATA             DoReconnectData;
    WINSTATIONDORECONNECTMSG*   m = &pMsg->u.DoReconnect;

    UserAssert(gulConnectCount == 0);

    RtlZeroMemory(&DoReconnectData, sizeof(DoReconnectData));

    DoReconnectData.fMouse = m->fMouse;
    DoReconnectData.fEnableWindowsKey = m->fEnableWindowsKey;
    DoReconnectData.fClientDoubleClickSupport = m->fClientDoubleClickSupport;

    memcpy(G_WinStationName, m->WinStationName,
           min(sizeof(G_WinStationName), sizeof(m->WinStationName)));

    memcpy(DoReconnectData.WinStationName, G_WinStationName,
           min(sizeof(G_WinStationName), sizeof(DoReconnectData.WinStationName)));

    DoReconnectData.drProtocolType = m->ProtocolType;
    DoReconnectData.drPelsHeight = m->VRes;
    DoReconnectData.drPelsWidth = m->HRes;
    DoReconnectData.drBitsPerPel = m->ColorDepth;
    if (m->fDynamicReconnect ) {
       DoReconnectData.fChangeDisplaySettings = TRUE;
    }else{
       DoReconnectData.fChangeDisplaySettings = FALSE;
    }
    // DoReconnectData.drDisplayFrequency is no yet setup
    DoReconnectData.drDisplayFrequency = 0;

    /*
     * Give the information to the keyboard type/subtype/number of functions.
     */
    DoReconnectData.ClientKeyboardType.Type        = m->KeyboardType;
    DoReconnectData.ClientKeyboardType.SubType     = m->KeyboardSubType;
    DoReconnectData.ClientKeyboardType.FunctionKey = m->KeyboardFunctionKey;



    RtlZeroMemory(DoReconnectData.DisplayDriverName, sizeof(DoReconnectData.DisplayDriverName));

    ASSERT(sizeof(m->DisplayDriverName) <= sizeof(WCHAR)*DR_DISPLAY_DRIVER_NAME_LENGTH);
    memcpy(DoReconnectData.DisplayDriverName, m->DisplayDriverName, sizeof(m->DisplayDriverName) - 2);

    RtlZeroMemory(DoReconnectData.ProtocolName, sizeof(DoReconnectData.ProtocolName));

    ASSERT(sizeof(m->DisplayDriverName) <= sizeof(WCHAR)*DR_PROTOCOL_NAME_LENGTH);
    memcpy(DoReconnectData.ProtocolName, m->ProtocolName, sizeof(m->ProtocolName) - 2);

    RtlZeroMemory(DoReconnectData.AudioDriverName, sizeof(DoReconnectData.AudioDriverName));
    memcpy(DoReconnectData.AudioDriverName, m->AudioDriverName, sizeof(m->AudioDriverName) - 2);

    W32WinStationDumpReconnectInfo(m, TRUE);

    /*
     * Give the information to the WIN32 driver.
     */

    Status = (NTSTATUS)NtUserCallOneParam((ULONG_PTR)&DoReconnectData,
                                          SFI_XXXREMOTERECONNECT);

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "xxxRemoteReconnect failed with Status %lx", Status);
    } else {

        /*
         * Save the resolution
         */
        gHRes       = m->HRes;
        gVRes       = m->VRes;
        gColorDepth = m->ColorDepth;

#if DBG
        gulConnectCount++;
#endif // DBG
    }

    return Status;
}



NTSTATUS
W32WinStationDoNotify(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    DONOTIFYDATA                DoNotifyData;
    WINSTATIONDONOTIFYMSG*   m = &pMsg->u.DoNotify;

    switch (m->NotifyEvent) {
    case WinStation_Notify_DisableScrnSaver:
        DoNotifyData.NotifyEvent = Notify_DisableScrnSaver;
        break;

    case WinStation_Notify_EnableScrnSaver:
        DoNotifyData.NotifyEvent = Notify_EnableScrnSaver;
        break;

    case WinStation_Notify_Disconnect:

        DoNotifyData.NotifyEvent = Notify_Disconnect;
        break;

    case WinStation_Notify_SyncDisconnect:

        DoNotifyData.NotifyEvent = Notify_SyncDisconnect;
        break;

    case WinStation_Notify_Reconnect:

        DoNotifyData.NotifyEvent = Notify_Reconnect;
        break;

    case WinStation_Notify_PreReconnect:

       DoNotifyData.NotifyEvent = Notify_PreReconnect;
       break;

    case WinStation_Notify_PreReconnectDesktopSwitch:

       DoNotifyData.NotifyEvent = Notify_PreReconnectDesktopSwitch;
       break;

    case WinStation_Notify_HelpAssistantShadowStart:

       DoNotifyData.NotifyEvent = Notify_HelpAssistantShadowStart;
       break;

    case WinStation_Notify_HelpAssistantShadowFinish:

       DoNotifyData.NotifyEvent = Notify_HelpAssistantShadowFinish;
       break;

    case WinStation_Notify_DisconnectPipe:
        DoNotifyData.NotifyEvent = Notify_DisconnectPipe;
        break;

    default:
        ASSERT(FALSE);
        return STATUS_INVALID_PARAMETER;
        break;

    }

    /*
     * Give the information to the WIN32 driver.
     */

    Status = (NTSTATUS)NtUserCallOneParam((ULONG_PTR)&DoNotifyData,
                                          SFI_XXXREMOTENOTIFY);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxRemoteNotify failed with Status %lx", Status);
    } 

    return Status;
}



NTSTATUS
W32WinStationExitWindows(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    WINSTATIONEXITWINDOWSMSG*   m = &pMsg->u.ExitWindows;


    UserAssert(gulConnectCount <= 1);


    /*
     *  Cancel any existing ExitWindows call so that we can force logoff the user
     */
    CancelExitWindows();

    /*
     *  Tell winlogon to logoff
     */
    Status = (NTSTATUS)NtUserCallNoParam(SFI_REMOTELOGOFF);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteLogoff failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationTerminate(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE   hevtRitExited, hevtRitStuck, hevtShutDown;
    DONOTIFYDATA DoNotifyData;
    IO_STATUS_BLOCK IoStatus;

    UNREFERENCED_PARAMETER(pMsg);

    gbExitInProgress = TRUE;

    /*
     * Get rid of hard error thread.
     */
    if (gdwHardErrorThreadId != 0) {

        BoostHardError(-1, BHE_FORCE);

        /*
         * Poll (!!?) for hard error thread completion. The thread does
         * not exit.
         */
        while (gdwHardErrorThreadId != 0) {
            RIPMSG0(RIP_WARNING, "Waiting for hard error thread to stop...");

            Sleep(3 * 1000);
        }

        RIPMSG0(RIP_WARNING, "Stopped hard error thread");
    }

    if (g_hDoMessageEvent) {
        NtSetEvent(g_hDoMessageEvent, NULL);
    }

    /*
     * Give the information that we want to stop reading to the WIN32 driver.
     */

    DoNotifyData.NotifyEvent = Notify_StopReadInput;

    Status = (NTSTATUS)NtUserCallOneParam((ULONG_PTR)&DoNotifyData,
                                          SFI_XXXREMOTENOTIFY);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "W32WinStationTerminate : xxxRemoteNotify failed with Status %lx", Status);
    }


    if (G_IcaMouseChannel) {
        CloseHandle(G_IcaMouseChannel);
        G_IcaMouseChannel = NULL;
    }

    if (G_IcaKeyboardChannel) {
        CloseHandle(G_IcaKeyboardChannel);
        G_IcaKeyboardChannel = NULL;
    }

    // Dont close the CommandChannel now
    // Instead send a IOCTL to termdd
    // This is because we do not want the Win32CommandChannelThread to continue reading after we close the CommandChannel here (Race condition)
    // Win32CommandChannelThread will close the CommandChannel

    if (G_IcaCommandChannel) {

        Status = NtDeviceIoControlFile(
                    G_IcaCommandChannel,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL,
                    NULL,
                    0,
                    NULL,
                    0);
    }

    // Dont close the VideoChannel now
    // Instead send a IOCTL to termdd
    // This is because we do not want the Win32CommandChannelThread to continue reading after we close the VideoChannel here (Race condition)
    // Win32CommandChannelThread will close the VideoChannel

    if (G_IcaVideoChannel) {

        Status = NtDeviceIoControlFile(
                    G_IcaVideoChannel,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_ICA_CHANNEL_CLOSE_COMMAND_CHANNEL,
                    NULL,
                    0,
                    NULL,
                    0);
    }

    if (G_IcaBeepChannel) {
        CloseHandle(G_IcaBeepChannel);
        G_IcaBeepChannel = NULL;
    }
    if (G_IcaThinwireChannel) {
        CloseHandle(G_IcaThinwireChannel);
        G_IcaThinwireChannel = NULL;
    }

    hevtShutDown = OpenEvent(EVENT_ALL_ACCESS,
                             FALSE,
                             L"EventShutDownCSRSS");
    if (hevtShutDown == NULL) {
        /*
         * This case is for cached sessions where RIT and Destiop thread have
         * not been created.
         */
        RIPMSG0(RIP_WARNING, "W32WinStationTerminate terminating CSRSS ...");

        if (gLUIDDeviceMapsEnabled == 0) {

            Status = CleanupSessionObjectDirectories();

        }
        return 0;
    }

    hevtRitExited = CreateEvent(NULL,
                                FALSE,
                                FALSE,
                                L"EventRitExited");

    UserAssert(hevtRitExited != NULL);

    hevtRitStuck = CreateEvent(NULL,
                               FALSE,
                               FALSE,
                               L"EventRitStuck");

    UserAssert(hevtRitStuck != NULL);

    /*
     * RIT is created. Signal this event that starts the
     * cleanup in win32k.
     */
    SetEvent(hevtShutDown);

    TAGMSG0(DBGTAG_TermSrv, "EventShutDownCSRSS set in CSRSS ...");

    while (1) {
        HANDLE arHandles[2] = {hevtRitExited, hevtRitStuck};
        DWORD  result;

        result = WaitForMultipleObjects(2, arHandles, FALSE, INFINITE);

        switch (result) {
        case WAIT_OBJECT_0:
            goto RITExited;

        case WAIT_OBJECT_0 + 1:

            /*
             * The RIT is stuck because there are still GUI threads
             * assigned to desktops. One reason for this is that winlogon
             * died w/o calling ExitWindowsEx.
             */
            break;
        default:
            FRE_RIPMSG1(RIP_ERROR,
                    "WFMO returned unexpected value 0x%x",
                    result);
            break;
        }
    }

RITExited:

    TAGMSG0(DBGTAG_TermSrv, "EventRitExited set in CSRSS ...");

    CloseHandle(hevtRitExited);
    CloseHandle(hevtRitStuck);
    CloseHandle(hevtShutDown);

    Status = CleanupSessionObjectDirectories();
    return Status;
}


NTSTATUS
W32WinStationNtSecurity(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = (NTSTATUS)NtUserCallNoParam(SFI_REMOTENTSECURITY);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteNtSecurity failed with Status %lx", Status);
    }

    return Status;
    UNREFERENCED_PARAMETER(pMsg);
}


NTSTATUS
W32WinStationDoMessage(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = RemoteDoMessage(pMsg);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteDoMessage failed with Status %lx", Status);
    }

    return Status;
}

 // This is the counter part to SMWinStationBroadcastSystemMessage
NTSTATUS
W32WinStationBroadcastSystemMessage(
    PWINSTATION_APIMSG pMsg )
{

    NTSTATUS Status = STATUS_SUCCESS;

    Status = RemoteDoBroadcastSystemMessage(pMsg);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteDoBroadcastSystemMessage(): failed with status 0x%lx", Status);
    }

    return Status;
}
 // This is the counter part to SMWinStationSendWindowMessage
NTSTATUS
W32WinStationSendWindowMessage(
    PWINSTATION_APIMSG  pMsg)
{

    NTSTATUS Status = STATUS_SUCCESS;

    Status = RemoteDoSendWindowMessage(pMsg);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteDoSendWindowMessage failed with Status 0x%lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationThinwireStats(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    WINSTATIONTHINWIRESTATSMSG* m = &pMsg->u.ThinwireStats;

    Status = (NTSTATUS)NtUserCallOneParam((ULONG_PTR)&m->Stats,
                                          SFI_REMOTETHINWIRESTATS);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteThinwireStats failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationShadowSetup(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                  Status = STATUS_SUCCESS;
    WINSTATIONSHADOWSETUPMSG* m = &pMsg->u.ShadowSetup;

    Status = (NTSTATUS)NtUserCallNoParam(SFI_XXXREMOTESHADOWSETUP);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxRemoteShadowSetup failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationShadowStart(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                  Status = STATUS_SUCCESS;
    WINSTATIONSHADOWSTARTMSG* m = &pMsg->u.ShadowStart;

    Status = (NTSTATUS)NtUserCallTwoParam((ULONG_PTR)m->pThinwireData,
                                          (ULONG_PTR)m->ThinwireDataLength,
                                          SFI_REMOTESHADOWSTART);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteShadowStart failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationShadowStop(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                 Status = STATUS_SUCCESS;
    WINSTATIONSHADOWSTOPMSG* m = &pMsg->u.ShadowStop;

    Status = (NTSTATUS)NtUserCallNoParam(SFI_XXXREMOTESHADOWSTOP);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxRemoteShadowStop failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationShadowCleanup(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    WINSTATIONSHADOWCLEANUPMSG* m = &pMsg->u.ShadowCleanup;

    Status = (NTSTATUS)NtUserCallTwoParam((ULONG_PTR)m->pThinwireData,
                                          (ULONG_PTR)m->ThinwireDataLength,
                                          SFI_REMOTESHADOWCLEANUP);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteShadowCleanup failed with Status %lx", Status);
    }

    return Status;
}


NTSTATUS
W32WinStationPassthruEnable(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = (NTSTATUS)NtUserCallNoParam(SFI_XXXREMOTEPASSTHRUENABLE);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxRemotePassthruEnable failed with Status %lx", Status);
    }

    return Status;
    UNREFERENCED_PARAMETER(pMsg);
}


NTSTATUS
W32WinStationPassthruDisable(
    PWINSTATION_APIMSG pMsg)
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = (NTSTATUS)NtUserCallNoParam(SFI_REMOTEPASSTHRUDISABLE);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemotePassthruDisable failed with Status %lx", Status);
    }

    return Status;
    UNREFERENCED_PARAMETER(pMsg);
}


NTSTATUS
CleanupSessionObjectDirectories(
    VOID)
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING    UnicodeString;
    HANDLE            LinkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    BOOLEAN           RestartScan;
    UCHAR             DirInfoBuffer[ 4096 ];
    WCHAR             szSessionString [ MAX_SESSION_PATH ];
    ULONG             Context = 0;
    ULONG             ReturnedLength;
    HANDLE            DosDevicesDirectory;
    HANDLE            *HandleArray;
    ULONG             Size = 100;
    ULONG             i, Count = 0;

    swprintf(szSessionString,L"%ws\\%ld\\DosDevices",SESSION_ROOT,NtCurrentPeb()->SessionId);

    RtlInitUnicodeString(&UnicodeString, szSessionString);

    InitializeObjectAttributes(&Attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenDirectoryObject(&DosDevicesDirectory,
                                   DIRECTORY_ALL_ACCESS,
                                   &Attributes);

    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "NtOpenDirectoryObject failed with Status %lx", Status);
        return Status;
    }

Restart:
    HandleArray = (HANDLE *)LocalAlloc(LPTR, Size * sizeof(HANDLE));

    if (HandleArray == NULL) {

        NtClose(DosDevicesDirectory);
        return STATUS_NO_MEMORY;
    }

    RestartScan = TRUE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)&DirInfoBuffer;

    while (TRUE) {
        Status = NtQueryDirectoryObject( DosDevicesDirectory,
                                         (PVOID)DirInfo,
                                         sizeof(DirInfoBuffer),
                                         TRUE,
                                         RestartScan,
                                         &Context,
                                         &ReturnedLength);

        /*
         *  Check the status of the operation.
         */
        if (!NT_SUCCESS(Status)) {

            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }
            break;
        }

        if (!wcscmp(DirInfo->TypeName.Buffer, L"SymbolicLink")) {

            if ( Count >= Size ) {

                for (i = 0; i < Count ; i++) {
                    NtClose (HandleArray[i]);
                }
                Size += 20;
                Count = 0;
                LocalFree(HandleArray);
                goto Restart;

            }

            InitializeObjectAttributes( &Attributes,
                                        &DirInfo->Name,
                                        OBJ_CASE_INSENSITIVE,
                                        DosDevicesDirectory,
                                        NULL);

            Status = NtOpenSymbolicLinkObject( &LinkHandle,
                                               SYMBOLIC_LINK_ALL_ACCESS,
                                               &Attributes);

            if (NT_SUCCESS(Status)) {

                Status = NtMakeTemporaryObject( LinkHandle );

                if (NT_SUCCESS( Status )) {
                    HandleArray[Count] = LinkHandle;
                    Count++;
                }
            }

        }
        RestartScan = FALSE;
     }

     for (i = 0; i < Count ; i++) {

         NtClose (HandleArray[i]);

     }

     LocalFree(HandleArray);

     NtClose(DosDevicesDirectory);

     return Status;
}



NTSTATUS
W32WinStationSetTimezone(
    PWINSTATION_APIMSG pMsg)
{
     /*++

Routine Description:

   This function sets Time Zone Information as global shared data

Arguments:

    NONE

Return Value:

    NONE

--*/
    TIME_ZONE_INFORMATION tzi;

    tzi.Bias         = pMsg->u.SetTimeZone.TimeZone.Bias;
    tzi.StandardBias = pMsg->u.SetTimeZone.TimeZone.StandardBias;
    tzi.DaylightBias = pMsg->u.SetTimeZone.TimeZone.DaylightBias;
    memcpy(&tzi.StandardName,&(pMsg->u.SetTimeZone.TimeZone.StandardName),sizeof(tzi.StandardName));
    memcpy(&tzi.DaylightName,&(pMsg->u.SetTimeZone.TimeZone.DaylightName),sizeof(tzi.DaylightName));

    tzi.StandardDate.wYear         = pMsg->u.SetTimeZone.TimeZone.StandardDate.wYear        ;
    tzi.StandardDate.wMonth        = pMsg->u.SetTimeZone.TimeZone.StandardDate.wMonth       ;
    tzi.StandardDate.wDayOfWeek    = pMsg->u.SetTimeZone.TimeZone.StandardDate.wDayOfWeek   ;
    tzi.StandardDate.wDay          = pMsg->u.SetTimeZone.TimeZone.StandardDate.wDay         ;
    tzi.StandardDate.wHour         = pMsg->u.SetTimeZone.TimeZone.StandardDate.wHour        ;
    tzi.StandardDate.wMinute       = pMsg->u.SetTimeZone.TimeZone.StandardDate.wMinute      ;
    tzi.StandardDate.wSecond       = pMsg->u.SetTimeZone.TimeZone.StandardDate.wSecond      ;
    tzi.StandardDate.wMilliseconds = pMsg->u.SetTimeZone.TimeZone.StandardDate.wMilliseconds;

    tzi.DaylightDate.wYear         = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wYear        ;
    tzi.DaylightDate.wMonth        = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wMonth       ;
    tzi.DaylightDate.wDayOfWeek    = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wDayOfWeek   ;
    tzi.DaylightDate.wDay          = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wDay         ;
    tzi.DaylightDate.wHour         = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wHour        ;
    tzi.DaylightDate.wMinute       = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wMinute      ;
    tzi.DaylightDate.wSecond       = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wSecond      ;
    tzi.DaylightDate.wMilliseconds = pMsg->u.SetTimeZone.TimeZone.DaylightDate.wMilliseconds;

    //call to kernel32
    SetClientTimeZoneInformation(&tzi);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\command.c ===
/*************************************************************************
*
* command.c
*
* WinStation command channel handler
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* $Author:
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

#include "ntuser.h"

#include <winsta.h>
#include <wstmsg.h>

#include <icadd.h>

extern HANDLE G_IcaVideoChannel;
extern HANDLE G_IcaCommandChannel;
extern HANDLE WinStationIcaApiPort;

HANDLE G_ConsoleShadowVideoChannel;
HANDLE G_ConsoleShadowCommandChannel;


extern NTSTATUS BrokenConnection(BROKENCLASS, BROKENSOURCECLASS);
extern NTSTATUS ShadowHotkey(VOID);

NTSTATUS
Win32CommandChannelThread(
    PVOID ThreadParameter)
{
    ICA_CHANNEL_COMMAND Command;
    ULONG               ActualLength;
    NTSTATUS            Status;
    ULONG               Error;
    OVERLAPPED          Overlapped;
    USERTHREAD_USEDESKTOPINFO utudi;
    BOOL bRestoreDesktop = FALSE;
    BOOL bShadowCommandChannel = (BOOL)PtrToUlong(ThreadParameter);
    HANDLE hChannel = bShadowCommandChannel ? G_ConsoleShadowCommandChannel : G_IcaCommandChannel;
    HANDLE hChannelToClose = NULL; 

    for ( ; ; ) {
        RtlZeroMemory(&Overlapped, sizeof(Overlapped));

        if (!ReadFile(hChannel,
                      &Command,
                      sizeof(Command),
                      &ActualLength,
                      &Overlapped)) {

            Error = GetLastError();

            if (Error == ERROR_IO_PENDING) {
                
                /*
                 * check on the results of the asynchronous read
                 */
                if (!GetOverlappedResult(hChannel, &Overlapped,
                                         &ActualLength, TRUE)) {
                    // wait for result

                    RIPMSG1(RIP_WARNING, "Command Channel: Error 0x%x from GetOverlappedResult", GetLastError());
                    break;
                }
            } else {
                RIPMSG1(RIP_WARNING, "Command Channel: Error 0x%x from ReadFile", Error);
                break;
            }
        }

        if (ActualLength < sizeof(ICA_COMMAND_HEADER)) {
            
            RIPMSG1(RIP_WARNING, "Command Channel Thread bad length 0x%x",
                   ActualLength);
            continue;
        }

        /*
         * This is a Csrss thread with no desktop. It needs to grab a temporary one
         * before calling into win32k.
         */


        Status = STATUS_SUCCESS;
        bRestoreDesktop = FALSE;
        if (Command.Header.Command != ICA_COMMAND_BROKEN_CONNECTION && Command.Header.Command != ICA_COMMAND_SHADOW_HOTKEY) {
            if (Command.Header.Command != ICA_COMMAND_DISPLAY_IOCTL || Command.DisplayIOCtl.DisplayIOCtlFlags & DISPLAY_IOCTL_FLAG_REDRAW) {
                utudi.hThread = NULL;
                utudi.drdRestore.pdeskRestore = NULL;
                bRestoreDesktop = TRUE;
                Status = NtUserSetInformationThread(NtCurrentThread(),
                                                    UserThreadUseActiveDesktop,
                                                    &utudi, sizeof(utudi));
            }
        }

        if (NT_SUCCESS(Status)) {

            switch (Command.Header.Command) {

            case ICA_COMMAND_BROKEN_CONNECTION:
                /*
                 * broken procedure
                 */
                Status = BrokenConnection(
                            Command.BrokenConnection.Reason,
                            Command.BrokenConnection.Source);

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "BrokenConnection failed with Status 0x%x", Status);
                }
                break;

            case ICA_COMMAND_REDRAW_RECTANGLE:
                /*
                 * setfocus ???
                 */
                if (ActualLength < sizeof(ICA_COMMAND_HEADER) + sizeof(ICA_REDRAW_RECTANGLE)) {

                    RIPMSG1(RIP_WARNING, "Command Channel: redraw rect bad length %d", ActualLength);
                    break;
                }
                Status = NtUserRemoteRedrawRectangle(
                             Command.RedrawRectangle.Rect.Left,
                             Command.RedrawRectangle.Rect.Top,
                             Command.RedrawRectangle.Rect.Right,
                             Command.RedrawRectangle.Rect.Bottom);

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "NtUserRemoteRedrawRectangle failed with Status 0x%x", Status);
                }
                break;

            case ICA_COMMAND_REDRAW_SCREEN: // setfocus

                Status = NtUserRemoteRedrawScreen();

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "NtUserRemoteRedrawScreen failed with Status 0x%x", Status);
                }
                break;

            case ICA_COMMAND_STOP_SCREEN_UPDATES: // killfocus

                Status = NtUserRemoteStopScreenUpdates();

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "NtUserRemoteStopScreenUpdates failed with Status 0x%x", Status);
                } else {
                    IO_STATUS_BLOCK IoStatus;

                    NtDeviceIoControlFile( 
                                    bShadowCommandChannel ? G_ConsoleShadowVideoChannel 
                                        : G_IcaVideoChannel,
                                           NULL,
                                           NULL,
                                           NULL,
                                           &IoStatus,
                                           IOCTL_VIDEO_ICA_STOP_OK,
                                           NULL,
                                           0,
                                           NULL,
                                           0);
                }
                break;

            case ICA_COMMAND_SHADOW_HOTKEY: // shadow hotkey

                Status = ShadowHotkey();

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "ShadowHotkey failed with Status 0x%x", Status);
                }
                break;

            case ICA_COMMAND_DISPLAY_IOCTL:

                Status = NtUserCtxDisplayIOCtl(
                             Command.DisplayIOCtl.DisplayIOCtlFlags,
                             &Command.DisplayIOCtl.DisplayIOCtlData[0],
                             Command.DisplayIOCtl.cbDisplayIOCtlData);

                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "NtUserCtxDisplayIOCtl failed with Status 0x%x", Status);
                }
                break;

            default:
                RIPMSG1(RIP_WARNING, "Command Channel: Bad Command 0x%x", Command.Header.Command);
                break;
            }

            /*
             * Release the temporary desktop.
             */
            if (bRestoreDesktop) {
                NTSTATUS retStatus;
                retStatus = NtUserSetInformationThread(NtCurrentThread(),
                                           UserThreadUseDesktop,
                                           &utudi,
                                           sizeof(utudi));
            }
        }
    }

    if (!bShadowCommandChannel) {
        /*
         * Close command channel LPC port if there is one.
         */
        if (WinStationIcaApiPort) {
            NtClose(WinStationIcaApiPort);
            WinStationIcaApiPort = NULL;
        }
    }

    // We have to close the commandchannel handle here
    if (hChannel != NULL) {
        NtClose(hChannel);
    }

    // We have to close the relevant Video Channel here
    hChannelToClose = ( bShadowCommandChannel ? G_ConsoleShadowVideoChannel : G_IcaVideoChannel );
    if (hChannelToClose != NULL) {
        NtClose(hChannelToClose);
    }

    UserExitWorkerThread(STATUS_SUCCESS);
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\exitwin.c ===
/**************************** Module Header ********************************\
* Module Name: exitwin.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 07-23-92 ScottLu      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <wchar.h>

#define BEGIN_LPC_RECV(API)                                                 \
    P##API##MSG a = (P##API##MSG)&m->u.ApiMessageData;                      \
    PCSR_THREAD pcsrt;                                                      \
    PTEB Teb = NtCurrentTeb();                                              \
    NTSTATUS Status = STATUS_SUCCESS;                                       \
    UNREFERENCED_PARAMETER(ReplyStatus);                                    \
                                                                            \
    Teb->LastErrorValue = 0;                                                \
    pcsrt = CSR_SERVER_QUERYCLIENTTHREAD();

#define END_LPC_RECV()                                                  \
    a->dwLastError = Teb->LastErrorValue;                               \
    return Status;

#define CCHBODYMAX  512

#define CSR_THREAD_SHUTDOWNSKIP 0x00000008

BOOL WowExitTask(PCSR_THREAD pcsrt);
NTSTATUS UserClientShutdown(PCSR_PROCESS pcsrp, ULONG dwFlags, BOOLEAN fFirstPass);
BOOL CancelExitWindows(VOID);

/***************************************************************************\
* _ExitWindowsEx
*
* Determines whether shutdown is allowed, and if so calls CSR to start
* shutting down processes. If this succeeds all the way through, tell winlogon
* so it'll either logoff or reboot the system. Shuts down the processes in
* the caller's sid.
*
* History
* 07-23-92 ScottLu      Created.
\***************************************************************************/
NTSTATUS _ExitWindowsEx(
    PCSR_THREAD pcsrt,
    UINT dwFlags)
{
    LUID luidCaller;
    NTSTATUS Status = STATUS_SUCCESS;

    if ((dwFlags & EWX_REBOOT) || (dwFlags & EWX_POWEROFF)) {
        dwFlags |= EWX_SHUTDOWN;
    }

    //
    // Only winlogon gets to set the high flags:
    //

    if ((dwFlags & ~EWX_VALID) != 0) {
        if (HandleToUlong(pcsrt->ClientId.UniqueProcess) != gIdLogon) {
            KdPrint(("Process %x tried to call ExitWindowsEx with flags %x\n",
                        pcsrt->ClientId.UniqueProcess, dwFlags));

            return STATUS_ACCESS_DENIED;
        }
    }

    /*
     * Find out the callers sid. Only want to shutdown processes in the
     * callers sid.
     */
    if (!CsrImpersonateClient(NULL)) {
        return STATUS_BAD_IMPERSONATION_LEVEL;
    }

    Status = CsrGetProcessLuid(NULL, &luidCaller);
    if (!NT_SUCCESS(Status)) {
        CsrRevertToSelf();
        return Status;
    }

    /*
     * Loop until we can do the shutdown; if we cannot do it,
     * we'll go to fastexit and bail.
     */
    while (TRUE) {


        Status = NtUserSetInformationThread(pcsrt->ThreadHandle,
                                            UserThreadInitiateShutdown,
                                            &dwFlags, sizeof(dwFlags));

        switch (Status) {
        case STATUS_PENDING:
            /*
             * The logoff/shutdown is in progress and nothing
             * more needs to be done.
             */
            goto fastexit;

        case STATUS_RETRY:


            if (!CancelExitWindows()) {
               Status = STATUS_PENDING;
               goto fastexit;
            } else {
               continue;
            }

        case STATUS_CANT_WAIT:

            /*
             * There is no notify window and the calling thread has
             * windows that prevent this request from succeeding.
             * The client handles this by starting another thread
             * to recall ExitWindowsEx.
             */
            goto fastexit;

        default:
            if (!NT_SUCCESS(Status)) {
                SetLastError(RtlNtStatusToDosError(Status));
                goto fastexit;
            }
        }
        break;
    }

    /*
     * This thread is doing the shutdown
     */
    EnterCrit();
    UserAssert(gdwThreadEndSession == 0);
    gdwThreadEndSession = HandleToUlong(pcsrt->ClientId.UniqueThread);
    LeaveCrit();

    /*
     * Call csr to loop through the processes shutting them down.
     */
    Status = CsrShutdownProcesses(&luidCaller, dwFlags);
    if (Status == STATUS_CANCELLED) {
        SHUTDOWN_REASON sr;
        sr.cbSize = sizeof(SHUTDOWN_REASON);
        sr.uFlags = dwFlags;
        sr.dwReasonCode = 0;
        sr.fShutdownCancelled = TRUE;
        sr.dwEventType = SR_EVENT_EXITWINDOWS;
        sr.lpszComment = NULL;

        /*
         * Record the fact that the shutdown was cancelled.
         */
        RecordShutdownReason(&sr);
    }

    /*
     * Tell win32k.sys we're done.
     */
    NtUserSetInformationThread(pcsrt->ThreadHandle, UserThreadEndShutdown, &Status, sizeof(Status));

    EnterCrit();
    gdwThreadEndSession = 0;
    NtSetEvent(gheventCancelled, NULL);
    LeaveCrit();

fastexit:
    CsrRevertToSelf();

    return Status;
}

/***************************************************************************\
* UserClientShutdown
*
* This gets called from CSR. If we recognize the application (i.e., it has a
* top level window), then send queryend/end session messages to it. Otherwise
* say we don't recognize it.
*
* 07-23-92 ScottLu      Created.
\***************************************************************************/
NTSTATUS UserClientShutdown(
    PCSR_PROCESS pcsrp,
    ULONG dwFlags,
    BOOLEAN fFirstPass)
{
    PLIST_ENTRY ListHead, ListNext;
    PCSR_PROCESS Process;
    PCSR_THREAD Thread;
    USERTHREAD_SHUTDOWN_INFORMATION ShutdownInfo;
    BOOL fNoMsgs;
    BOOL fNoMsgsEver = TRUE;
    BOOL Forced = FALSE;
    BOOL bDoBlock;
    BOOL fNoRetry;
    DWORD cmd = 0, dwClientFlags;
    NTSTATUS Status;
    NTSTATUS TerminateStatus = STATUS_ACCESS_DENIED;
    UINT cThreads;
    BOOL fSendEndSession = FALSE;

#if DBG
    DWORD dwLocalThreadEndSession = gdwThreadEndSession;
#endif

    /*
     * If this is a logoff and the process does not belong to
     * the account doing the logoff and is not LocalSystem,
     * do not send end-session messages. Console will notify
     * the app of the logoff.
     */
    if (!(dwFlags & EWX_SHUTDOWN) && (pcsrp->ShutdownFlags & SHUTDOWN_OTHERCONTEXT)) {
        Status = SHUTDOWN_UNKNOWN_PROCESS;
        goto CleanupAndExit;
    }

    /*
     * Calculate whether to allow exit and force-exit this process before
     * we unlock pcsrp.
     */
    fNoRetry = (pcsrp->ShutdownFlags & SHUTDOWN_NORETRY) || (dwFlags & EWX_FORCE);

    /*
     * Setup flags for WM_CLIENTSHUTDOWN
     * -Assume the process is going to OK the WM_QUERYENDSESSION (WMCS_EXIT)
     * -NT's shutdown always starts with a logoff.
     * -Shutdown or logoff? (WMCS_SHUTDOWN)
     * -Should display dialog for hung apps? (WMCS_NODLGIFHUNG)
     * -is this process in the context being logged off? (WMCS_CONTEXTLOGOFF)
     */
    dwClientFlags = WMCS_EXIT | (fNoRetry ? WMCS_NORETRY : 0);

    /*
     * Check the flags originally passed by the ExitWindows caller to see if we're
     *  really just logging off.
     */
    if (!(dwFlags & (EWX_WINLOGON_OLD_REBOOT | EWX_WINLOGON_OLD_SHUTDOWN))) {
        dwClientFlags |= WMCS_LOGOFF;
    }

    if (dwFlags & EWX_FORCEIFHUNG) {
        dwClientFlags |= WMCS_NODLGIFHUNG;
    }
    if (!(pcsrp->ShutdownFlags & (SHUTDOWN_SYSTEMCONTEXT | SHUTDOWN_OTHERCONTEXT))) {
        dwClientFlags |= WMCS_CONTEXTLOGOFF;
    }


    /*
     * Lock the process while we walk the thread list. We know
     * that the process is valid and therefore do not need to
     * check the return status.
     */
    CsrLockProcessByClientId(pcsrp->ClientId.UniqueProcess, &Process);

    ShutdownInfo.StatusShutdown = SHUTDOWN_UNKNOWN_PROCESS;

    /*
     * Go through the thread list and mark them as not
     * shutdown yet.
     */
    ListHead = &pcsrp->ThreadList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
        Thread->Flags &= ~CSR_THREAD_SHUTDOWNSKIP;
        ListNext = ListNext->Flink;
    }

    /*
     * Perform the proper shutdown operation on each thread. Keep
     * a count of the number of gui threads found.
     */
    cThreads = 0;
    ShutdownInfo.drdRestore.pdeskRestore = NULL;
    ShutdownInfo.drdRestore.hdeskNew = NULL;
    while (TRUE) {
        ListNext = ListHead->Flink;
        while (ListNext != ListHead) {
            Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
            /*
             * Skip the thread doing the shutdown. Assume that it's
             * ready.
             * gdwThreadEndSession shouldn't change while the shutdown
             *  is in progress; so this should be thread safe.
             */
            UserAssert(gdwThreadEndSession == dwLocalThreadEndSession);
            if (HandleToUlong(Thread->ClientId.UniqueThread) == gdwThreadEndSession) {
                Thread->Flags |= CSR_THREAD_SHUTDOWNSKIP;
            }

            if (!(Thread->Flags &
                    (CSR_THREAD_DESTROYED | CSR_THREAD_SHUTDOWNSKIP))) {
                break;
            }
            ListNext = ListNext->Flink;
        }
        if (ListNext == ListHead) {
            break;
        }

        Thread->Flags |= CSR_THREAD_SHUTDOWNSKIP;
        ShutdownInfo.dwFlags = dwClientFlags;

        CsrReferenceThread(Thread);
        CsrUnlockProcess(Process);

        Status = NtUserQueryInformationThread(Thread->ThreadHandle,
                                              UserThreadShutdownInformation,
                                              &ShutdownInfo,
                                              sizeof(ShutdownInfo),
                                              NULL);

        CsrLockProcessByClientId(pcsrp->ClientId.UniqueProcess, &Process);
        CsrDereferenceThread(Thread);

        if (!NT_SUCCESS(Status)) {
            continue;
        }
        if (ShutdownInfo.StatusShutdown == SHUTDOWN_UNKNOWN_PROCESS) {
            continue;
        }
        if (ShutdownInfo.StatusShutdown == SHUTDOWN_KNOWN_PROCESS) {
            CsrUnlockProcess(Process);
            Status = SHUTDOWN_KNOWN_PROCESS;
            goto RestoreDesktop;
        }

        /*
         * If this process is not in the account being logged off and it
         * is not on the windowstation being logged off, don't send
         * the end session messages.
         */
        if (!(dwClientFlags & WMCS_CONTEXTLOGOFF) && (ShutdownInfo.hwndDesktop == NULL)) {
            /*
             * This process is not in the context being logged off. Do
             * not terminate it and let console send an event to the process.
             */
            ShutdownInfo.StatusShutdown = SHUTDOWN_UNKNOWN_PROCESS;
            continue;
        }

        /*
         * Shut down this process.
         */
        cThreads++;

        if (ISTS()) {
            Forced = (dwFlags & EWX_FORCE);
            fNoMsgs =  (pcsrp->ShutdownFlags & SHUTDOWN_NORETRY) ||
                       !(ShutdownInfo.dwFlags & USER_THREAD_GUI);
            fNoMsgsEver &= fNoMsgs;
            if (Forced && (!(dwFlags & EWX_NONOTIFY) || (gSessionId != 0)))  {
                dwClientFlags &= ~WMCS_LOGOFF; // WinStation Reset or Shutdown. Don't do this for console session.
            }

            if (fNoMsgs || Forced) {
                BoostHardError((ULONG_PTR)Thread->ClientId.UniqueProcess, BHE_FORCE);
            }
            bDoBlock = (fNoMsgs == FALSE);

        } else {
            if (fNoRetry || !(ShutdownInfo.dwFlags & USER_THREAD_GUI)) {

                /*
                 * Dispose of any hard errors.
                 */
                BoostHardError((ULONG_PTR)Thread->ClientId.UniqueProcess, BHE_FORCE);
                bDoBlock = FALSE;
            } else {
                bDoBlock = TRUE;
            }
        }

        if (bDoBlock) {
            CsrReferenceThread(Thread);
            CsrUnlockProcess(Process);

            /*
             * There are problems in changing shutdown to send all the
             * QUERYENDSESSIONs at once before doing any ENDSESSIONs, like
             * Windows does. The whole machine needs to be modal if you do this.
             * If it isn't modal, then you have this problem. Imagine app 1 and 2.
             * 1 gets the queryendsession, no problem. 2 gets it and brings up a
             * dialog. Now being a simple user, you decide you need to change the
             * document in app 1. Now you switch back to app 2, hit ok, and
             * everything goes away - including app 1 without saving its changes.
             * Also, apps expect that once they've received the QUERYENDSESSION,
             * they are not going to get anything else of any particular interest
             * (unless it is a WM_ENDSESSION with FALSE). We had bugs pre 511 where
             * apps were blowing up because of this.
             * If this change is made, the entire system must be modal
             * while this is going on. - ScottLu 6/30/94
             */
            cmd = ThreadShutdownNotify(dwClientFlags | WMCS_QUERYEND, (ULONG_PTR)Thread, 0);

            CsrLockProcessByClientId(pcsrp->ClientId.UniqueProcess, &Process);
            CsrDereferenceThread(Thread);

            /*
             * If shutdown has been cancelled, let csr know about it.
             */
            switch (cmd) {
            case TSN_USERSAYSCANCEL:
            case TSN_APPSAYSNOTOK:
                if (!Forced) {
                    dwClientFlags &= ~WMCS_EXIT;
                }

                /*
                 * Fall through.
                 */
            case TSN_APPSAYSOK:
                fSendEndSession = TRUE;
                break;

            case TSN_USERSAYSKILL:
                /*
                 * Since we cannot just kill one thread, the whole process
                 *  is going down. Hence, there is no point on continuing
                 *  checking other threads. Also, the user wants it killed
                 *  so we won't waste any time sending more messages
                 */
                dwClientFlags |= WMCS_EXIT;
                goto KillIt;

            case TSN_NOWINDOW:
                /*
                 * Did this process have a window?
                 * If this is the second pass we terminate the process even if it did
                 * not have any windows in case the app was just starting up.
                 * WOW hits this often because it takes so long to start up.
                 * Logon (with WOW auto-starting) then logoff WOW won't die but will
                 * lock some files open so you can't logon next time.
                 */
                if (fFirstPass) {
                    cThreads--;
                }
                break;
            }
        }
    }

    /*
     * If end session message need to be sent, do it now.
     */
    if (fSendEndSession) {

        /*
         * Go through the thread list and mark them as not
         * shutdown yet.
         */
        ListNext = ListHead->Flink;
        while (ListNext != ListHead) {
            Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
            Thread->Flags &= ~CSR_THREAD_SHUTDOWNSKIP;
            ListNext = ListNext->Flink;
        }

        /*
         * Perform the proper shutdown operation on each thread.
         */
        while (TRUE) {
            ListHead = &pcsrp->ThreadList;
            ListNext = ListHead->Flink;
            while (ListNext != ListHead) {
                Thread = CONTAINING_RECORD( ListNext, CSR_THREAD, Link );
                if (!(Thread->Flags &
                        (CSR_THREAD_DESTROYED | CSR_THREAD_SHUTDOWNSKIP))) {
                    break;
                }
                ListNext = ListNext->Flink;
            }
            if (ListNext == ListHead)
                break;

            CsrReferenceThread(Thread);
            CsrUnlockProcess(Process);

            Thread->Flags |= CSR_THREAD_SHUTDOWNSKIP;
            ShutdownInfo.dwFlags = dwClientFlags;

            Status = NtUserQueryInformationThread(Thread->ThreadHandle,
                    UserThreadShutdownInformation, &ShutdownInfo, sizeof(ShutdownInfo), NULL);

            if (!NT_SUCCESS(Status))
                goto SkipThread;

            if (ShutdownInfo.StatusShutdown == SHUTDOWN_UNKNOWN_PROCESS ||
                    !(ShutdownInfo.dwFlags & USER_THREAD_GUI))
                goto SkipThread;

            /*
             * Send the end session messages to the thread.
             */

            /*
             * If the user says kill it, the user wants it to go away now
             * no matter what. If the user didn't say kill, then call again
             * because we need to send WM_ENDSESSION messages.
             */
            ThreadShutdownNotify(dwClientFlags, (ULONG_PTR)Thread, 0);

SkipThread:
            CsrLockProcessByClientId(pcsrp->ClientId.UniqueProcess, &Process);
            CsrDereferenceThread(Thread);
        }
    }

KillIt:
    CsrUnlockProcess(Process);

    if (ISTS()) {
        bDoBlock = (!fNoMsgsEver && !(dwClientFlags & WMCS_EXIT));
    } else {
        bDoBlock = (!fNoRetry && !(dwClientFlags & WMCS_EXIT));
    }

    if (bDoBlock) {
        Status = SHUTDOWN_CANCEL;
        goto RestoreDesktop;
    }

    /*
     * Set the final shutdown status according to the number of gui
     * threads found. If the count is zero, we have an unknown process.
     */
    if (cThreads == 0)
        ShutdownInfo.StatusShutdown = SHUTDOWN_UNKNOWN_PROCESS;
    else
        ShutdownInfo.StatusShutdown = SHUTDOWN_KNOWN_PROCESS;

    if (ShutdownInfo.StatusShutdown == SHUTDOWN_UNKNOWN_PROCESS ||
            !(dwClientFlags & WMCS_CONTEXTLOGOFF)) {

        /*
         * This process is not in the context being logged off. Do
         * not terminate it and let console send an event to the process.
         */
        Status = SHUTDOWN_UNKNOWN_PROCESS;

        if (ShutdownInfo.drdRestore.hdeskNew) {
            goto RestoreDesktop;
        }
        goto CleanupAndExit;
    }

    /*
     * Calling ExitProcess() in the app's context will not always work
     * because the app may have .dll termination deadlocks: so the thread
     * will hang with the rest of the process. To ensure apps go away,
     * we terminate the process with NtTerminateProcess().
     *
     * Pass this special value, DBG_TERMINATE_PROCESS, which tells
     * NtTerminateProcess() to return failure if it can't terminate the
     * process because the app is being debugged.
     */

    if (ISTS()) {
        NTSTATUS ExitStatus;
        HANDLE DebugPort;

        ExitStatus = DBG_TERMINATE_PROCESS;
        if (NT_SUCCESS(NtQueryInformationProcess(NtCurrentProcess(),
                                                 ProcessDebugPort,
                                                 &DebugPort,
                                                 sizeof(HANDLE),
                                                 NULL)) &&
            (DebugPort != NULL)) {
            // Csr is being debugged - go ahead and kill the process
            ExitStatus = 0;
        }
        TerminateStatus = NtTerminateProcess(pcsrp->ProcessHandle, ExitStatus);
    } else {
        TerminateStatus = NtTerminateProcess(pcsrp->ProcessHandle, DBG_TERMINATE_PROCESS);
    }

    pcsrp->Flags |= CSR_PROCESS_TERMINATED;


    /*
     * Let csr know we know about this process - meaning it was our
     * responsibility to shut it down.
     */
    Status = SHUTDOWN_KNOWN_PROCESS;

RestoreDesktop:

    /*
     * Release the desktop that was used.
     */
    {
        USERTHREAD_USEDESKTOPINFO utudi;
        utudi.hThread = NULL;
        RtlCopyMemory(&(utudi.drdRestore), &(ShutdownInfo.drdRestore), sizeof(DESKRESTOREDATA));

        NtUserSetInformationThread(NtCurrentThread(), UserThreadUseDesktop,
                &utudi, sizeof(utudi));
    }

    /*
     * Now that we're done with the process handle, derefence the csr
     * process structure.
     */
    if (Status != SHUTDOWN_UNKNOWN_PROCESS) {

        /*
		 * If TerminateProcess returned STATUS_ACCESS_DENIED, then the process
		 * is being debugged and it wasn't terminated.Otherwise we need to wait
		 * anyway since TerminateProcess might return failure when the process
		 * is going away (ie STATUS_PROCESS_IS_TERMINATING).If termination
		 * indeed fail, something is wrong anyway so waiting a bit won't
		 * hurt much.
         * If we wait give the process whatever exit timeout value configured
		 * in the registry, but no less  than the 5 second Hung App timeout.

         */
        if (TerminateStatus != STATUS_ACCESS_DENIED) {
            LARGE_INTEGER li;

            li.QuadPart = (LONGLONG)-10000 * gdwProcessTerminateTimeout;
            TerminateStatus = NtWaitForSingleObject(pcsrp->ProcessHandle,
                                           FALSE,
                                           &li);
            if (TerminateStatus != STATUS_WAIT_0) {
                RIPMSG2(RIP_WARNING,
                        "UserClientShutdown: wait for process %x failed with status %x",
                        pcsrp->ClientId.UniqueProcess, TerminateStatus);
            }
        }

        CsrDereferenceProcess(pcsrp);
    }


CleanupAndExit:

    return Status;
}

/***************************************************************************\
* WMCSCallback
*
* This function is passed to SendMessageCallback when sending the
*  WM_CLIENTSHUTDOWN message. It propagates the return value back
*  if ThreadShutdownNotify is still waiting for it; otherwise,
*  it just frees the memory.
*
* 03-04-97 GerardoB     Created.
\***************************************************************************/
VOID CALLBACK WMCSCallback(
    HWND hwnd,
    UINT uMsg,
    ULONG_PTR dwData,
    LRESULT lResult)
{
    PWMCSDATA pwmcsd = (PWMCSDATA)dwData;
    if (pwmcsd->dwFlags & WMCSD_IGNORE) {
        LocalFree(pwmcsd);
        return;
    }

    pwmcsd->dwFlags |= WMCSD_REPLY;
    pwmcsd->dwRet = (DWORD)lResult;

    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(uMsg);
}

/***************************************************************************\
* GetInputWindow
*
* We assume a thread is waiting for input if it's not hung, the (main)
* window is disabled, and it owns an enabled popup.
*
* 03-06-97 GerardoB     Created.
\***************************************************************************/
HWND GetInputWindow(
    PCSR_THREAD pcsrt,
    HWND hwnd)
{
    DWORD dwTimeout;
    HWND hwndPopup;

    /*
     * Ask the kernel if the thread is hung.
     */
    dwTimeout = gCmsHungAppTimeout;
    NtUserQueryInformationThread(pcsrt->ThreadHandle,
       UserThreadHungStatus, &dwTimeout, sizeof(dwTimeout), NULL);

    /*
     * If not hung and disabled, see if it owns an enabled popup.
     */
    if (!dwTimeout && !IsWindowEnabled(hwnd)) {
        hwndPopup = GetWindow(hwnd, GW_ENABLEDPOPUP);
        if (hwndPopup != NULL && hwndPopup != hwnd) {
            return hwndPopup;
        }
    }

    return NULL;
}

/***************************************************************************\
* GetApplicationText
*
* Gets the text that identifies the given window or thread
*
* 08-01-97 GerardoB     Created.
\***************************************************************************/
VOID GetApplicationText(
    HWND hwnd,
    HANDLE hThread,
    WCHAR *pwcText,
    UINT uLen)
{
    /*
     * GetWindowText doesn't call the hwnd's proc; otherwise, we could
     * get blocked here for good.
     */
    GetWindowText(hwnd, pwcText, uLen);

    if (*pwcText == 0) {
        /*
         * We couldn't get the window's title; let's try the thread's name.
         */
        NtUserQueryInformationThread(hThread, UserThreadTaskName,
                                     pwcText, uLen * sizeof(WCHAR), NULL);
    }
}

/***************************************************************************\
* ReportHang
*
* This function launches an intermediate app (dumprep.exe) which packages up
* the hang information & ships it up to MS. We create an event and wait on
* it so that we know when the minidump information has been grabbed from the
* app.
*
* 08-31-00 DerekM       Created
\***************************************************************************/
VOID ReportHang(
    CLIENT_ID *pcidToKill)
{
    PROCESS_SESSION_INFORMATION psi;
    SECURITY_ATTRIBUTES         sa;
    SECURITY_DESCRIPTOR         sd;
    PCSR_THREAD                 pcsrt = CSR_SERVER_QUERYCLIENTTHREAD();
    NTSTATUS                    Status;
    HANDLE                      rghWait[2] = { NULL, NULL };
    HANDLE                      hProc = NULL;
    WCHAR                       wszEvent[MAX_PATH], *pwszSuffix;
    DWORD                       dw, dwTimeout, dwStartWait;
    BOOL                        fIs64Bit = FALSE;
#ifdef _WIN64
    ULONG_PTR                   Wow64Info = 0;
    HANDLE                      hProcKill = NULL;
#endif

#if defined(_DEBUG) || defined(DEBUG)
    dwTimeout = 600000; // 10 minutes
#else
    dwTimeout = 120000; //  2 minutes
#endif

    // we're going to launch dwwin in the context of the interactive user that 
    //  is logged on to the killing process's session. So we need to figure out
    //  what session it's in.
    // If any of these fail, we have to bail cuz otherwise we'd have to create
    // an instance of dwwin.exe in local system context, and since dwwin.exe
    // can launch helpcenter, this is bad.
    hProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE,
                        HandleToLong(pcsrt->ClientId.UniqueProcess));
    if (hProc == NULL) {
        RIPMSG2(RIP_WARNING,
                "HangReporting: Couldn't open killing process (pid: %d) (err: %08x)\n",
                HandleToLong(pcsrt->ClientId.UniqueProcess), GetLastError());
        goto done;
    }

    Status = NtQueryInformationProcess(hProc, ProcessSessionInformation, &psi,
                                       sizeof(psi), NULL);
    if (NT_SUCCESS(Status) == FALSE) {
        RIPMSG2(RIP_WARNING,
                "HangReporting: Couldn't get the session ID (pid: %d) (err: %08x)\n",
                HandleToLong(pcsrt->ClientId.UniqueProcess),
                RtlNtStatusToDosError(Status));
        goto done;
    }

#ifdef _WIN64
    // need to determine if we're a Wow64 process so we can build the appropriate
    //  signatures...
    hProcKill = OpenProcess(PROCESS_ALL_ACCESS, FALSE,
                            HandleToLong(pcidToKill->UniqueProcess));
    if (hProcKill == NULL) {
        RIPMSG2(RIP_WARNING,
                "HangReporting: Couldn't open dying process (pid: %d) (err: %08x)\n",
                HandleToLong(pcidToKill->UniqueProcess), GetLastError());
        goto done;
    }

    Status = NtQueryInformationProcess(hProcKill, ProcessWow64Information,
                                       &Wow64Info, sizeof(Wow64Info), NULL);
    if (NT_SUCCESS(Status) == FALSE) {
        RIPMSG2(RIP_WARNING,
                "HangReporting: Couldn't get Wow64 info (pid: %d) (err: %08x)\n",
                HandleToLong(pcidToKill->UniqueProcess),
                RtlNtStatusToDosError(Status));
        goto done;
    }

    fIs64Bit = (Wow64Info == 0);
#endif

    // Because of a bug where CreateProcessAsUser doesn't want to work from
    // the csrss process, we have to have a remote process sitting around
    // waiting on a pipe. It will call CreateProcessAsUser (as well as
    // determine the correct token for the session).
    //
    // Note that it only accepts requests from processes running as local
    // system.

    // Since a remote process does the creation of dumprep.exe, we need to
    // used a named event instead of relying on dumprep to inherit the event
    // handle.
    dw = swprintf(wszEvent, L"Global\\%d%x%x%x%x%x", psi.SessionId,
                  GetTickCount(), HandleToLong(pcsrt->ClientId.UniqueProcess),
                  HandleToLong(pcsrt->ClientId.UniqueThread),
                  NtCurrentTeb()->ClientId.UniqueProcess,
                  NtCurrentTeb()->ClientId.UniqueThread);
    pwszSuffix = wszEvent + dw;

    // make sure to create this event with a NULL DACL so a generic usermode
    // process has access to it.
    Status = RtlCreateSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    if (NT_SUCCESS(Status) == FALSE) {
        RIPMSG1(RIP_WARNING, "HangReporting: could not create SD (err: %08x)\n",
                RtlNtStatusToDosError(Status));
        goto done;
    }

    // This is implemented in reclient.h & creates a SD with creator &
    // LocalSystem having full rights & world & anonymous having sync
    // rights.
    Status = AllocDefSD(&sd,
                        STANDARD_RIGHTS_ALL | GENERIC_ALL | EVENT_ALL_ACCESS,
                        EVENT_MODIFY_STATE | SYNCHRONIZE | GENERIC_READ);
    if (NT_SUCCESS(Status) == FALSE) {
        RIPMSG1(RIP_WARNING, "HangReporting: could not create SD (err: %08x)\n",
                RtlNtStatusToDosError(Status));
        goto done;
    }

    ZeroMemory(&sa, sizeof(sa));
    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;

    // Need an event so we know when the app we're killing is no longer
    // necessary. If the event already exists, try to create a new one.
    // But only do this a maximum of 7 times.
    for (dw = 0; dw < 7; dw++) {
        rghWait[0] = CreateEventW(&sa, TRUE, FALSE, wszEvent);
        if (rghWait[0] == NULL) {
            RIPMSG1(RIP_WARNING,
                    "HangReporting: Error creating wait event (err: %08x)\n",
                    GetLastError());
            goto done;
        }

        if (GetLastError() != ERROR_ALREADY_EXISTS) {
            break;
        }

        // Sleep for a millisecond to make the result of GetTickCount() even
        // more unpredictable...
        Sleep(1);
        _ltow(GetTickCount(), pwszSuffix, 16);
    }

    if (dw >= 7) {
        RIPMSG0(RIP_WARNING, "HangReporting: Could not find unique wait event name\n");
        goto done;
    }

    FreeDefSD(&sd);

    if (StartHangReport(psi.SessionId, wszEvent, 
                        HandleToLong(pcidToKill->UniqueProcess),
                        HandleToLong(pcidToKill->UniqueThread),
                        fIs64Bit, &rghWait[1]) == FALSE)
    {
        RIPMSG1(RIP_WARNING, 
                "HangReporting: StartHangReport failed (err: %08x)\n", 
                GetLastError());
        goto done;
    }

    // use MsgWaitForMultipleObjects in case this thread is doing UI processing
    //  Not really likely, but you never know.  Anyway, only wait 2 minutes for
    //  dumprep to generate the minidump.  If it still hasn't done it by then, 
    //  it isn't likely to ever finish.
    dwStartWait = GetTickCount();
    for(;;)
    {
        dw = MsgWaitForMultipleObjects(2, rghWait, FALSE, dwTimeout, QS_ALLINPUT);
        if (dw == WAIT_OBJECT_0 + 2)
        {
            DWORD   dwNow;
            DWORD   dwSub;
            MSG     msg;

            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }

            dwNow = GetTickCount();
            if (dwNow < dwStartWait)
                dwSub = ((DWORD)-1 - dwStartWait) + dwNow;
            else
                dwSub = dwNow - dwStartWait;

            if (dwSub > dwTimeout)
                dwTimeout = 0;
            else
                dwTimeout -= dwSub;
                
            continue;
        }

        break;
    }

done:
#ifdef _WIN64
    if (hProcKill != NULL) {
        CloseHandle(hProcKill);
    }
#endif
    if (hProc != NULL) {
        CloseHandle(hProc);
    }
    if (rghWait[0] != NULL) {
        CloseHandle(rghWait[0]);
    }
    if (rghWait[1] != NULL) {
        CloseHandle(rghWait[1]);
    }
}

/***************************************************************************\
* ThreadShutdownNotify
*
* This function notifies a given thread that it's time (or about time)
* to go away. This is called from _EndTask to post the WM_CLOSE message
* or from UserClientShutdown to send the WM_QUERYENDSESSION and
* WM_ENDSESSION messages. If the thread fails to respond, then the
* "End Application" dialog is brought up. This function is also called
* from Console to display that dialog too.
*
* 03-07-97 GerardoB     Created to replace SendShutdownMessages,
*                       MySendEndSessionMessages and DoEndTaskDialog
* 08-15-00 JasonSch     Added code to limit number of CSRSS worker threads
*                       stuck in _EndTask to 8.
\***************************************************************************/
DWORD ThreadShutdownNotify(
    DWORD dwClientFlags,
    ULONG_PTR dwThread,
    LPARAM lParam)
{
    HWND hwnd, hwndOwner, hwndDlg;
    PWMCSDATA pwmcsd = NULL;
    ENDDLGPARAMS edp;
    DWORD dwRet, dwRealTimeout, dwTimeout, dwStartTiming, dwCmd;
    MSG msg;
    PCSR_THREAD pcsrt;
    HANDLE hThread;
    BOOL fEndTaskNow = FALSE;
    static DWORD dwTSNThreads = 0;

#define ESMH_CANCELEVENT     0
#define ESMH_THREAD          1
#define ESMH_HANDLECOUNT     2
    HANDLE ahandles[ESMH_HANDLECOUNT];

    if (dwTSNThreads > TSN_MAX_THREADS) {
        /*
         * If we've already reached our limit in terms of CSRSS threads stuck
         * in this function, "fail" this call.
         */
        return TSN_USERSAYSCANCEL;
    }

    /*
     * If this is console, just set up the wait loop and
     * bring the dialog up right away. Otherwise, find
     * the notification window, notify it, and go wait.
     */
    if (dwClientFlags & WMCS_CONSOLE) {
        hThread = (HANDLE)dwThread;
        dwRealTimeout = 0;
        goto SetupWaitLoop;
    } else {
        pcsrt = (PCSR_THREAD)dwThread;
        hThread = pcsrt->ThreadHandle;
        hwnd = (HWND)lParam;
    }

    /*
     * If no window was provided, find a top-level window owned by the thread.
     */
    if (hwnd == NULL) {
        EnumThreadWindows(HandleToUlong(pcsrt->ClientId.UniqueThread),
                            &FindWindowFromThread, (LPARAM)&hwnd);
    }
    if (hwnd == NULL) {
        return TSN_NOWINDOW;
    }

    /*
     * Find the root owner (we'll guess this is the "main" window)
     */
    while ((hwndOwner = GetWindow(hwnd, GW_OWNER)) != NULL) {
        hwnd = hwndOwner;
    }

#ifdef FE_IME
    /*
     * If this is a console window, then just returns TSN_APPSAYSOK.
     * In this routine:
     * Normally windows NT environment, hwnd never point to console window.
     * However, In ConIme process, its owner window point to console window.
     */
    if (!(dwClientFlags & WMCS_ENDTASK)) {
        if ((HANDLE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE) == ghModuleWin) {
            return TSN_APPSAYSOK;
        }
    }
#endif // FE_IME

    /*
     * If this is an EndTask request but the window is disabled,
     * then we want to bring the dialog up right way (the app
     * is probably waiting for input).
     *
     * Otherwise, we bring the window to the foreground, send/post
     * the request and wait.
     */


    /*
     * Bug 296188 - joejo
     *
     * Make sure we respond to the user ASAP when they
     * attempt to shutdown an application that we know is hung.
     */

    if ((dwClientFlags & WMCS_ENDTASK)) {
        dwTimeout = gCmsHungAppTimeout;
        NtUserQueryInformationThread(pcsrt->ThreadHandle, UserThreadHungStatus, &dwTimeout, sizeof(dwTimeout), NULL);

        if (!IsWindowEnabled(hwnd) || dwTimeout){
            dwRealTimeout = 0;
            fEndTaskNow = TRUE;
        }
    }

    if (!fEndTaskNow) {
        SetForegroundWindow(hwnd);
        dwRealTimeout = gCmsHungAppTimeout;
        if (dwClientFlags & WMCS_ENDTASK) {
            PostMessage(hwnd, WM_CLOSE, 0, 0);
        } else {
            /*
             * If the shutdown was canceled, we don't need to wait
             * (we're just sending the WM_ENDSESSION(FALSE)).
             */
            if (!(dwClientFlags & (WMCS_QUERYEND | WMCS_EXIT))) {
                SendNotifyMessage(hwnd, WM_CLIENTSHUTDOWN, dwClientFlags, 0);
                return TSN_APPSAYSOK;
            }

            /*
             * Allocate callback data. If out of memory, kill it.
             */
            pwmcsd = (PWMCSDATA)LocalAlloc(LPTR, sizeof(WMCSDATA));
            if (pwmcsd == NULL) {
                return TSN_USERSAYSKILL;
            }

            SendMessageCallback(hwnd, WM_CLIENTSHUTDOWN, dwClientFlags, 0,
                                WMCSCallback, (ULONG_PTR)pwmcsd);
        }
    }

SetupWaitLoop:
    /*
     * This thread is now officially going to be "stuck" in TSN. Increment our
     * count of threads so disposed.
     */
    ++dwTSNThreads;

    /*
     * This tells us if the hwndDlg is valid. This is set/cleared by EndTaskDlgProc.
     */
    ZeroMemory(&edp, sizeof(edp));
    edp.dwFlags = EDPF_NODLG;

    /*
     * Loop until the hwnd replies, the request is canceled
     * or the thread goes away. If it times out, bring up the
     * dialog and wait until the user tells us what to do.
     */
    *(ahandles + ESMH_CANCELEVENT) = gheventCancel;
    *(ahandles + ESMH_THREAD) = hThread;
    dwStartTiming = GetTickCount();
    dwCmd = 0;
    while (dwCmd == 0) {
        /*
         * Calculate how long we have to wait.
         */
        dwTimeout = dwRealTimeout;
        if ((dwTimeout != 0) && (dwTimeout != INFINITE)) {
            dwTimeout -= (GetTickCount() - dwStartTiming);
            if ((int)dwTimeout < 0) {
                dwTimeout = 0;
            }
        }

        dwRet = MsgWaitForMultipleObjects(ESMH_HANDLECOUNT, ahandles, FALSE, dwTimeout, QS_ALLINPUT);

        switch (dwRet) {
            case WAIT_OBJECT_0 + ESMH_CANCELEVENT:
                /*
                 * The request has been canceled.
                 */
                dwCmd = TSN_USERSAYSCANCEL;
                break;

            case WAIT_OBJECT_0 + ESMH_THREAD:
                /*
                 * The thread is gone.
                 */
                dwCmd = TSN_APPSAYSOK;
                break;

            case WAIT_OBJECT_0 + ESMH_HANDLECOUNT:
                /*
                 * We got some input; process it.
                 */
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    if ((edp.dwFlags & EDPF_NODLG)
                            || !IsDialogMessage(hwndDlg, &msg)) {

                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                /*
                 * If we got a reply to the message, act on it
                 */
                if (pwmcsd != NULL && (pwmcsd->dwFlags & WMCSD_REPLY)) {

                    switch (pwmcsd->dwRet) {
                        default:
                            /*
                             * If the message was not processed (the thread
                             * exited) or someone processed it and returned
                             * a bogus value, just shut them down.
                             *
                             * Fall through.
                             */
                        case WMCSR_ALLOWSHUTDOWN:
                            /*
                             * We're going to nuke this app, so get rid of
                             * any pending harderror boxes he might have.
                             */
                            BoostHardError((ULONG_PTR)pcsrt->ClientId.UniqueProcess, BHE_FORCE);
                            /*
                             * Fall through.
                             */
                        case WMCSR_DONE:
                            dwCmd = TSN_APPSAYSOK;
                            break;

                        case WMCSR_CANCEL:
                            dwCmd = TSN_APPSAYSNOTOK;
                            break;
                    }
                }
                /*
                 * Else if the dialog is still up, keep waiting for the user
                 *  to tell us what to do
                 */
                else if (!(edp.dwFlags & EDPF_NODLG)) {
                    break;
                }
                /*
                 * Else if the user dismissed the dialog, act on his response
                 */
                else if (edp.dwFlags & EDPF_RESPONSE) {
                    switch(edp.dwRet) {
                        case IDC_ENDNOW:
                            /*
                             * The user wants us to kill it
                             */
                            dwCmd = TSN_USERSAYSKILL;
                            if ((dwClientFlags & WMCS_ENDTASK) != 0 &&
                                (edp.dwFlags & EDPF_HUNG) != 0) {
                                THREAD_BASIC_INFORMATION tbi;
                                CLIENT_ID *pcidToKill = NULL;

                                if ((dwClientFlags & WMCS_CONSOLE) != 0) {
                                    if (NtQueryInformationThread(hThread,
                                                                 ThreadBasicInformation,
                                                                 &tbi,
                                                                 sizeof(tbi),
                                                                 NULL) == STATUS_SUCCESS) {
                                        pcidToKill = &(tbi.ClientId);
                                    }
                                } else {
                                    pcidToKill = &(pcsrt->ClientId);
                                }

                                if (pcidToKill != NULL) {
                                    ReportHang(pcidToKill);
                                }
                            }
                            break;

                        /* case IDCANCEL: */
                        default:
                            dwCmd = TSN_USERSAYSCANCEL;
                            break;
                    }
                }
                break;

            case WAIT_TIMEOUT:
                if (dwClientFlags & WMCS_NORETRY) {

                    /*
                     * We come here only for Terminal Server case. We return
                     * TSN_APPSAYSOK as Terminal Server 4 did in this case.
                     */
                    UserAssert(ISTS());

                    dwCmd = TSN_APPSAYSOK;
                    break;
                }


                /*
                 * Once we time out, we bring up the dialog and let
                 * its timer take over.
                 */
                dwRealTimeout = INFINITE;
                /*
                 * Check if the windows app is waiting for input;
                 * if not, we assume it is hung for EndTask. Otherwise,
                 * we enter a wait mode that brings the dialog up just
                 * to provide some (waiting) feedback. Console just gets
                 * the dialog right away.
                 */
                if (!(dwClientFlags & WMCS_CONSOLE)) {
                    if (BoostHardError((ULONG_PTR)pcsrt->ClientId.UniqueProcess, BHE_TEST)
                           || (GetInputWindow(pcsrt, hwnd) != NULL)) {

                        edp.dwFlags |= EDPF_INPUT;
                    } else {
                        /*
                         * If the window's gone and the thread is still responsive, then
                         * this must be an app that just hides its window on WM_CLOSE
                         * (e.g., MSN Instant Messenger). Let's nuke the app w/o
                         * bringing up the EndTask dialog.
                         */
                        if (!IsWindow(hwnd)) {
                            DWORD dwThreadHung;

                            /*
                             * Ask the kernel if the thread is hung.
                             */
                            dwThreadHung = gCmsHungAppTimeout;
                            NtUserQueryInformationThread(pcsrt->ThreadHandle,
                                                         UserThreadHungStatus,
                                                         &dwThreadHung,
                                                         sizeof(dwThreadHung),
                                                         NULL);
                            if (!dwThreadHung) {
                                dwCmd = TSN_APPSAYSOK;
                                break;
                            }
                        }

                        /*
                         * EWX_FORCEIFHUNG support.
                         * Also, if this is an ExitWindows call and the process is
                         * not in the context being logged off, we won't kill it.
                         * So don't bother asking the user what to do.
                         */
                        if ((dwClientFlags & WMCS_NODLGIFHUNG)
                                || (!(dwClientFlags & WMCS_ENDTASK)
                                        && !(dwClientFlags & WMCS_CONTEXTLOGOFF))) {

                            dwCmd = TSN_USERSAYSKILL;
                            break;
                        }

                        /*
                         * Hung or Wait?
                         */
                        if (dwClientFlags & WMCS_ENDTASK) {
                            edp.dwFlags |= EDPF_HUNG;
                        } else {
                            edp.dwFlags |= EDPF_WAIT;
                        }
                    }
                }

                /*
                 * If the registry says no dialog, then tell the caller
                 * the user wants to kill the app.
                 */
                if (gfAutoEndTask) {
                    dwCmd = TSN_USERSAYSKILL;
                    break;
                }

                /*
                 * Setup the parameters needed by EndTaskDlgProc.
                 */
                edp.dwRet = 0;
                edp.dwClientFlags = dwClientFlags;
                if (dwClientFlags & WMCS_CONSOLE) {
                    edp.pcsrt = NULL;
                    edp.lParam = lParam;
                } else {
                    edp.pcsrt = pcsrt;
                    edp.lParam = (LPARAM)hwnd;
                }

                hwndDlg = CreateDialogParam(ghModuleWin, MAKEINTRESOURCE(IDD_ENDTASK),
                                        NULL, EndTaskDlgProc, (LPARAM)(&edp));
                /*
                 * If we cannot ask the user, then kill the app.
                 */
                if (hwndDlg == NULL) {
                    edp.dwFlags |= EDPF_NODLG;
                    dwCmd = TSN_USERSAYSKILL;
                    break;
                }
                break;

            default:
                /*
                 * Unexpected return; something is wrong. Kill the app.
                 */
                UserAssert(dwRet != dwRet);
                dwCmd = TSN_USERSAYSKILL;
                break;
        }
    }

    /*
     * If the dialog is up, nuke it.
     */
    if (!(edp.dwFlags & EDPF_NODLG)) {
        DestroyWindow(hwndDlg);
    }

    /*
     * Make sure pwmcsd is freed or marked to be freed by WMCSCallback
     * when the reply comes.
     */
    if (pwmcsd != NULL) {
        if (pwmcsd->dwFlags & WMCSD_REPLY) {
            LocalFree(pwmcsd);
        } else {
            pwmcsd->dwFlags |= WMCSD_IGNORE;
        }
    }

#if DBG
    /*
     * If cancelling, let's name the app that didn't let us log off.
     */
    if ((dwClientFlags & WMCS_EXIT) && (dwCmd == TSN_APPSAYSNOTOK)) {
        WCHAR achTitle[CCHBODYMAX];
        WCHAR *pwcText;
        UserAssert(!(dwClientFlags & WMCS_CONSOLE));
        pwcText = achTitle;
        *(achTitle + CCHBODYMAX - 1) = (WCHAR)0;
        GetApplicationText(hwnd, hThread, pwcText, CCHBODYMAX - 1);
        RIPMSG3(RIP_WARNING, "Log off canceled by pid:%#lx tid:%#lx - '%ws'.\n",
                             HandleToUlong(pcsrt->ClientId.UniqueProcess),
                             HandleToUlong(pcsrt->ClientId.UniqueThread),
                             pwcText);
    }
#endif // DBG

    /*
     * If we're killing this dude, clean any hard errors.
     * Also if wow takes care of it, then our caller doesn't need to
     */
    if ((dwCmd == TSN_USERSAYSKILL) && !(dwClientFlags & WMCS_CONSOLE)) {

        BoostHardError((ULONG_PTR)pcsrt->ClientId.UniqueProcess, BHE_FORCE);

        if (!(pcsrt->Flags & CSR_THREAD_DESTROYED) && WowExitTask(pcsrt)) {
            dwCmd = TSN_APPSAYSOK;
        }
    }

    --dwTSNThreads;
    return dwCmd;
}

/***************************************************************************\
* SetEndTaskDlgStatus
*
* Displays the appropiate message and shows the dialog
*
* 03-11-97 GerardoB     Created
\***************************************************************************/
VOID SetEndTaskDlgStatus(
    ENDDLGPARAMS *pedp,
    HWND hwndDlg,
    UINT uStrId,
    BOOL fInit)
{
    BOOL f, fIsWaiting, fWasWaiting;
    WCHAR *pwcText;

    fWasWaiting = (pedp->uStrId == STR_ENDTASK_WAIT);
    fIsWaiting = (pedp->dwFlags & EDPF_WAIT) != 0;

    /*
     * Store the current message id, load it and show it.
     */
    pedp->uStrId = uStrId;
    pwcText = ServerLoadString(ghModuleWin, uStrId, NULL, &f);
    if (pwcText != NULL) {
        SetDlgItemText(hwndDlg, IDC_STATUSMSG, pwcText);
        LocalFree(pwcText);
    }

    /*
     * If we haven't decided that the app is hung, set a
     * timer to keep an eye on it.
     */
    if (!(pedp->dwFlags & EDPF_HUNG) && !(pedp->dwClientFlags & WMCS_CONSOLE)) {
        SetTimer(hwndDlg, IDT_CHECKAPPSTATE, gCmsHungAppTimeout, NULL);
    }

    /*
     * If initializing or switching to/from the wait mode,
     * set the proper status for IDC_STATUSCANCEL, IDCANCEL,
     * IDC_ENDNOW and  the start/stop the progress bar.
     *
     * Invalidate paint if/as needed.
     */
    if (fInit || (fIsWaiting ^ fWasWaiting)) {
        RECT rc;
        HWND hwndStatusCancel = GetDlgItem(hwndDlg, IDC_STATUSCANCEL);
        HWND hwndCancelButton = GetDlgItem(hwndDlg, IDCANCEL);
        HWND hwndEndButton = GetDlgItem(hwndDlg, IDC_ENDNOW);
        DWORD dwSwpFlags;
        /*
         * If on wait mode, we hide the cancel button and its
         *  explanatory text. The End button will be moved to
         *  the cancel button position.
         */
        dwSwpFlags = ((fIsWaiting ? SWP_HIDEWINDOW : SWP_SHOWWINDOW)
                                | SWP_NOREDRAW | SWP_NOSIZE | SWP_NOMOVE
                                | SWP_NOZORDER | SWP_NOSENDCHANGING
                                | SWP_NOACTIVATE);
        /*
         * If we're hiding the cancel button, give focus/def id to
         * the End button.
         *
         * Note that DM_SETDEIF won't do the right thing unless
         * both Cancel/End buttons are visible.
         */
        if (fIsWaiting) {
            SendMessage(hwndDlg, DM_SETDEFID, IDC_ENDNOW, 0);
            SetFocus(hwndEndButton);
        }
        SetWindowPos(hwndStatusCancel, NULL, 0, 0, 0, 0, dwSwpFlags);
        SetWindowPos(hwndCancelButton, NULL, 0, 0, 0, 0, dwSwpFlags);

        /*
         * If the cancel button is visible, give it focus/def id.
         */
        if (!fIsWaiting) {
            SendMessage(hwndDlg, DM_SETDEFID, IDCANCEL, 0);
            SetFocus(hwndCancelButton);
        }

        /*
         * Initialize progress bar (first time around).
         */
        if (fIsWaiting && (pedp->hbrProgress == NULL)) {
            int iMagic;
            /*
             * Initialize progress bar stuff.
             * The size and location calculations below were made up
             *  to make it look good(?).
             * We need that location on dialog coordiantes since the
             *  progress bar is painted on the dialog's WM_PAINT.
             */
            GetClientRect(hwndStatusCancel, &pedp->rcBar);
            iMagic = (pedp->rcBar.bottom - pedp->rcBar.top) / 4;
            InflateRect(&pedp->rcBar, 0, -iMagic + GetSystemMetrics(SM_CYEDGE));
            pedp->rcBar.right -= (5 * iMagic);
            OffsetRect(&pedp->rcBar, 0, -iMagic);
            MapWindowPoints(hwndStatusCancel, hwndDlg, (LPPOINT)&pedp->rcBar, 2);
            /*
             * Calculate drawing rectangle and dimensions. We kind of make it
             * look like comctrl's progress bar.
             */
            pedp->rcProgress = pedp->rcBar;
            InflateRect(&pedp->rcProgress, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYEDGE));
            pedp->iProgressStop = pedp->rcProgress.right;
            pedp->iProgressWidth = ((2 * (pedp->rcProgress.bottom - pedp->rcProgress.top)) / 3);

            pedp->rcProgress.right = pedp->rcProgress.left + pedp->iProgressWidth - 1;

            pedp->hbrProgress = CreateSolidBrush(GetSysColor(COLOR_ACTIVECAPTION));
            /*
             * Remember the End button position.
             */
            GetWindowRect(hwndEndButton, &pedp->rcEndButton);
            MapWindowPoints(NULL, hwndDlg, (LPPOINT)&pedp->rcEndButton, 2);
        }

        /*
         * Start/Stop progress bar and set End button position
         */
        if (fIsWaiting) {
            RECT rcEndButton;
            UINT uTimeout = (gdwHungToKillCount * gCmsHungAppTimeout)
                            / ((pedp->iProgressStop - pedp->rcProgress.left) / pedp->iProgressWidth);
            SetTimer(hwndDlg, IDT_PROGRESS, uTimeout, NULL);
            /*
             * The Cancel and the End buttons might have different widths when
             *  localized. So make sure we position it inside the dialog and
             *  to the right end of the dialog.
             */
            GetWindowRect(hwndCancelButton, &rc);
            GetWindowRect(hwndEndButton, &rcEndButton);
            rc.left = rc.right - (rcEndButton.right - rcEndButton.left);
            MapWindowPoints(NULL, hwndDlg, (LPPOINT)&rc, 2);
        } else if (fWasWaiting) {
            KillTimer(hwndDlg, IDT_PROGRESS);
            rc = pedp->rcEndButton;
        }

        /*
         * Move the End button if needed
         */
        if (fIsWaiting || fWasWaiting) {
            SetWindowPos(hwndEndButton, NULL, rc.left, rc.top, 0, 0,
                            SWP_NOREDRAW | SWP_NOSIZE | SWP_NOACTIVATE
                            | SWP_NOZORDER | SWP_NOSENDCHANGING);
        }

        /*
         * Make sure we repaint if needed
         */
        if (!fInit) {
            InvalidateRect(hwndDlg, NULL, TRUE);
        }
    }

    /*
     * If initializing or in hung mode, make sure the user can
     * see the dialog; only bring it to the foreground on
     * initialization (no rude focus stealing)
     */
    if (fInit || (pedp->dwFlags & EDPF_HUNG)) {
        SetWindowPos(hwndDlg, HWND_TOPMOST, 0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW
                     | SWP_NOACTIVATE | SWP_NOSENDCHANGING);

        if (fInit) {
            SetForegroundWindow(hwndDlg);
        }
    }
}

/***************************************************************************\
* EndTaskDlgProc
*
* This is the dialog procedure for the dialog that comes up when an app is
* not responding.
*
* 03-06-97 GerardoB     Rewrote it once again. New template though.
* 07-23-92 ScottLu      Rewrote it, but used same dialog template.
* 04-28-92 JonPa        Created.
\***************************************************************************/
INT_PTR APIENTRY EndTaskDlgProc(
    HWND hwndDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    ENDDLGPARAMS* pedp;
    WCHAR achTitle[CCHBODYMAX];
    WCHAR *pwcText, *pwcTemp;
    UINT uLen;
    UINT uStrId;
    PAINTSTRUCT ps;
    HDC hdc, hdcMem;
    BOOL fIsInput, fWasInput;
    int iOldLayout;

    switch (msg) {
    case WM_INITDIALOG:
        /*
         * Save parameters
         */
        pedp = (ENDDLGPARAMS*)lParam;
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (ULONG_PTR)pedp);
        /*
         * This tells the caller that the dialog is up
         */
        pedp->dwFlags &= ~EDPF_NODLG;
        /*
         * Build the dialog title making sure that
         *  we end up with a NULL terminated string.
         */
        *(achTitle + CCHBODYMAX - 1) = (WCHAR)0;
        uLen = GetWindowText(hwndDlg, achTitle, CCHBODYMAX - 1);
        pwcText = achTitle + uLen;
        uLen = CCHBODYMAX - 1 - uLen;
        /*
         * Console provides the title; we figure it out for windows apps.
         */
        if (pedp->dwClientFlags & WMCS_CONSOLE) {
            pwcTemp = (WCHAR *)pedp->lParam;
            while (uLen-- && (*pwcText++ = *pwcTemp++));
        } else {
            GetApplicationText((HWND)pedp->lParam, pedp->pcsrt->ThreadHandle, pwcText, uLen);
        }

        SetWindowText(hwndDlg, achTitle);
        /*
         * Get the app's icon: first look for atomIconProperty.
         * If not available, try the class icon.
         * Else, use the default icon.
         */
        pedp->hIcon = (HICON)GetProp((HWND)pedp->lParam, ICON_PROP_NAME);

        if (pedp->hIcon == NULL) {

            pedp->hIcon = (HICON)GetClassLongPtr((HWND)pedp->lParam, GCLP_HICON);

            if (pedp->hIcon == NULL) {

                if (pedp->dwClientFlags & WMCS_CONSOLE) {
                    pedp->hIcon = LoadIcon(ghModuleWin, MAKEINTRESOURCE(IDI_CONSOLE));
                }
                else {
                    pedp->hIcon = LoadIcon(NULL, IDI_APPLICATION);
                }
            }
        }

        /*
         * Figure out what message the caller wants initially
         */
        if (pedp->dwClientFlags & WMCS_CONSOLE) {
            uStrId = STR_ENDTASK_CONSOLE;
        } else if (pedp->dwFlags & EDPF_INPUT) {
            uStrId = STR_ENDTASK_INPUT;
        } else if (pedp->dwFlags & EDPF_WAIT) {
            uStrId = STR_ENDTASK_WAIT;
        } else {
            uStrId = STR_ENDTASK_HUNG;
        }

        /*
         * Display the message, set the focus and show the dialog
         */
        SetEndTaskDlgStatus(pedp, hwndDlg, uStrId, TRUE);
        return FALSE;


    case WM_PAINT:
        pedp = (ENDDLGPARAMS*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if ((pedp == NULL) || (pedp->hIcon == NULL)) {
            break;
        }

        /*
         * Draw the icon
         */
        hdc = BeginPaint(hwndDlg, &ps);
        iOldLayout = GetLayout(hdc);

        if (iOldLayout != GDI_ERROR) {
            SetLayout(hdc, iOldLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
        }

        DrawIcon(hdc, ETD_XICON, ETD_YICON, pedp->hIcon);

        if (iOldLayout != GDI_ERROR) {
            SetLayout(hdc, iOldLayout);
        }

        /*
         * If waiting, draw the progress bar;
         * else draw the warning sign.
         */
        if (pedp->dwFlags & EDPF_WAIT) {
            RECT rc;
            /*
             * Draw a client-edge-looking border.
             */
            rc = pedp->rcBar;
            DrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_RECT | BF_ADJUST);
            InflateRect(&rc, -1, -1);
            /*
             * Draw the blocks up to the current position.
             */
            rc.right = rc.left + pedp->iProgressWidth - 1;
            while (rc.left < pedp->rcProgress.left) {
                if (rc.right > pedp->iProgressStop) {
                    rc.right = pedp->iProgressStop;
                    if (rc.left >= rc.right) {
                        break;
                    }
                }
                FillRect(hdc, &rc, pedp->hbrProgress);
                rc.left += pedp->iProgressWidth;
                rc.right += pedp->iProgressWidth;
            }
        } else {
            /*
             * Load the bitmap the first time around and
             * figure out where it goes.
             */
            if (pedp->hbmpWarning == NULL) {
                BITMAP bmp;
                pedp->hbmpWarning = LoadBitmap(ghModuleWin, MAKEINTRESOURCE(IDB_WARNING));
                if (GetObject(pedp->hbmpWarning, sizeof(bmp), &bmp)) {
                    pedp->rcWarning.left = ETD_XICON;
                    pedp->rcWarning.top = ETD_XICON + 32 - bmp.bmHeight;
                    pedp->rcWarning.right = bmp.bmWidth;
                    pedp->rcWarning.bottom = bmp.bmHeight;
                }
            }
            /*
             * Blit it.
             */
            hdcMem = CreateCompatibleDC(hdc);
            SelectObject(hdcMem, pedp->hbmpWarning);
            GdiTransparentBlt(hdc, pedp->rcWarning.left, pedp->rcWarning.top,
                   pedp->rcWarning.right, pedp->rcWarning.bottom,
                   hdcMem, 0, 0, pedp->rcWarning.right, pedp->rcWarning.bottom, RGB(255, 0, 255));
            DeleteDC(hdcMem);
        }

        EndPaint(hwndDlg, &ps);
        return TRUE;

    case WM_TIMER:
        pedp = (ENDDLGPARAMS*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pedp == NULL) {
            return TRUE;
        }
        switch (wParam) {
        case IDT_CHECKAPPSTATE:
            pedp->dwCheckTimerCount++;
            /*
             * Check if the app has switched from/to a waiting-for-input
             *  mode. If so, update the dialog and wait a little longer
             */
            fIsInput = (BoostHardError((ULONG_PTR)pedp->pcsrt->ClientId.UniqueProcess, BHE_TEST)
                        || (GetInputWindow(pedp->pcsrt, (HWND)pedp->lParam) != NULL));
            fWasInput = (pedp->dwFlags & EDPF_INPUT);
            if (fIsInput ^ fWasInput) {
                UINT uProgress;
                pedp->dwFlags &= ~(EDPF_INPUT | EDPF_WAIT);
                pedp->dwFlags |= (fIsInput ? EDPF_INPUT : EDPF_WAIT);
                SetEndTaskDlgStatus(pedp, hwndDlg,
                                    (fIsInput ? STR_ENDTASK_INPUT : STR_ENDTASK_WAIT),
                                     FALSE);
                pedp->dwCheckTimerCount /= 2;
                uProgress = pedp->rcProgress.left - pedp->rcBar.left - GetSystemMetrics(SM_CXEDGE);
                uProgress /= 2;
                pedp->rcProgress.left -= uProgress;
                pedp->rcProgress.right -= uProgress;
            }
            /*
             * Is it time to declare it hung?
             */
            if (pedp->dwCheckTimerCount >= gdwHungToKillCount) {
                KillTimer(hwndDlg, IDT_CHECKAPPSTATE);
                pedp->dwFlags &= ~(EDPF_INPUT | EDPF_WAIT);
                pedp->dwFlags |= EDPF_HUNG;
                SetEndTaskDlgStatus(pedp, hwndDlg, STR_ENDTASK_HUNG, FALSE);
            }
        break;

        case IDT_PROGRESS:
            /*
             * Draw the next block in the progress bar.
             */
            if (pedp->rcProgress.right >= pedp->iProgressStop) {
                pedp->rcProgress.right = pedp->iProgressStop;
                if (pedp->rcProgress.left >= pedp->rcProgress.right) {
                    break;
                }
            }
            hdc = GetDC(hwndDlg);
            FillRect(hdc, &pedp->rcProgress, pedp->hbrProgress);
            ReleaseDC(hwndDlg, hdc);
            pedp->rcProgress.left += pedp->iProgressWidth;
            pedp->rcProgress.right += pedp->iProgressWidth;
        break;
        }
        return TRUE;


    case WM_NCACTIVATE:
        /*
         * Make sure we're uncovered when active and not covering the app
         *  when inactive
         */
        pedp = (ENDDLGPARAMS*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pedp != NULL) {
            HWND hwnd;
            if (wParam) {
                hwnd = HWND_TOPMOST;
            } else if (pedp->dwClientFlags & WMCS_CONSOLE) {
                hwnd = HWND_TOP;
            } else {
                hwnd = (HWND)pedp->lParam;
            }
            SetWindowPos(hwndDlg, hwnd,
                         0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
        }
        break;


    case WM_COMMAND:
        /*
         * The user has made a choice, we're done.
         */
        pedp = (ENDDLGPARAMS*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pedp != NULL) {
            pedp->dwRet = (DWORD)wParam;
        }
        DestroyWindow(hwndDlg);
        break;


    case WM_DESTROY:
        /*
         * We're dead. Make sure the caller knows we're history
         */
        pedp = (ENDDLGPARAMS*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pedp != NULL) {
            pedp->dwFlags |= (EDPF_NODLG | EDPF_RESPONSE);
            if (pedp->hbmpWarning != NULL) {
                DeleteObject(pedp->hbmpWarning);
            }
            if (pedp->hbrProgress != NULL) {
                DeleteObject(pedp->hbrProgress);
            }
        }
        break;
    }

    return FALSE;
}

/***************************************************************************\
* _EndTask
*
* This routine is called from the task manager to end an application - for
* gui apps, either a win32 app or a win16 app. Note: Multiple console
* processes can live in a single console window. We'll pass these requests
* for destruction to console.
*
* 07-25-92 ScottLu      Created.
\***************************************************************************/
BOOL _EndTask(
    HWND hwnd,
    BOOL fMeanKill)
{
    BOOL fRet = TRUE;
    PCSR_THREAD pcsrt = CSR_SERVER_QUERYCLIENTTHREAD();
    PCSR_THREAD pcsrtKill;
    DWORD dwThreadId;
    DWORD dwProcessId;
    LPWSTR lpszMsg;
    BOOL fAllocated;
    DWORD dwCmd;
    USERTHREAD_USEDESKTOPINFO utudi;
    NTSTATUS Status;

    /*
     * Set the current work thread to a desktop so we can
     * go safely into win32k.sys.
     */
    utudi.hThread = pcsrt->ThreadHandle;
    utudi.drdRestore.pdeskRestore = NULL;

    Status = NtUserSetInformationThread(NtCurrentThread(),
            UserThreadUseDesktop, &utudi, sizeof(utudi));
    if (!NT_SUCCESS(Status)) {
        /*
         * We were unable to get the thread's desktop. Game over.
         */
        return TRUE;
    }


    /*
     * Get the process and thread that owns hwnd.
     */
    dwThreadId = GetWindowThreadProcessId(hwnd, &dwProcessId);
    if (dwThreadId == 0) {
        goto RestoreDesktop;
    }

    /*
     * Don't allow destruction of winlogon.
     */
    if (dwProcessId == gIdLogon) {
        goto RestoreDesktop;
    }

    /*
     * If this is a console window, then just send the close message to
     * it, and let console clean up the processes in it.
     */
    if ((HANDLE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE) == ghModuleWin) {
        PostMessage(hwnd, WM_CLOSE, 0, 0);
        goto RestoreDesktop;
    }

    /*
     * Find the CSR_THREAD for the window.
     */
    CsrLockThreadByClientId(LongToHandle(dwThreadId), &pcsrtKill);
    if (pcsrtKill == NULL) {
        /*
         * This is probably the ghost thread, which CSRSS doesn't know about (as it's
         * created via RtlCreateUserThread, which doesn't LPC into CSRSS like regular
         * CreateThread does). When the ghost window gets the WM_CLOSE it'll handle
         * removing the real window and thread. If this *isn't* a ghost window, then
         * no real harm done, so we post no matter what.
         */
        PostMessage(hwnd, WM_CLOSE, 0, 0);
        goto RestoreDesktop;
    }
    CsrReferenceThread(pcsrtKill);
    CsrUnlockThread(pcsrtKill);

    /*
     * If this is a WOW app, then shutdown just this wow application.
     */
    if (!fMeanKill) {
        /*
         * Find out what to do now - did the user cancel or the app cancel,
         * etc? Only allow cancelling if we are not forcing the app to
         * exit.
         */
        dwCmd = ThreadShutdownNotify(WMCS_ENDTASK, (ULONG_PTR)pcsrtKill, (LPARAM)hwnd);

        switch (dwCmd) {
        case TSN_APPSAYSNOTOK:
            /*
             * App says not ok - this'll let taskman bring up the "are you sure?"
             * dialog to the user.
             */
            CsrDereferenceThread(pcsrtKill);
            fRet = FALSE;
            goto RestoreDesktop;

        case TSN_USERSAYSCANCEL:
            /*
             * User hit cancel on the timeout dialog - so the user really meant
             * it. Let taskman know everything is ok by returning TRUE.
             */
            CsrDereferenceThread(pcsrtKill);
            goto RestoreDesktop;
        }
    }

    /*
     * Kill the application now. If the thread has not been destroyed,
     * nuke the task. If WowExitTask returns that the thread is not
     * a WOW task, terminate the process.
     */
    if (!(pcsrtKill->Flags & CSR_THREAD_DESTROYED) && !WowExitTask(pcsrtKill)) {

        BOOL bDoBlock;

        /*
         * Calling ExitProcess() in the app's context will not always work
         * because the app may have .dll termination deadlocks: so the thread
         * will hang with the rest of the process. To ensure apps go away,
         * we terminate the process with NtTerminateProcess().
         *
         * Pass this special value, DBG_TERMINATE_PROCESS, which tells
         * NtTerminateProcess() to return failure if it can't terminate the
         * process because the app is being debugged.
         */
        if (ISTS()) {
            NTSTATUS ExitStatus;
            HANDLE DebugPort;

            ExitStatus = DBG_TERMINATE_PROCESS;
            if (NT_SUCCESS(NtQueryInformationProcess(NtCurrentProcess(),
                                                     ProcessDebugPort,
                                                     &DebugPort,
                                                     sizeof(HANDLE),
                                                     NULL)) &&
                (DebugPort != NULL)) {
                // Csr is being debugged - go ahead and kill the process
                ExitStatus = 0;
            }
            Status = NtTerminateProcess(pcsrtKill->Process->ProcessHandle, ExitStatus);
            if (!NT_SUCCESS(Status) && Status != STATUS_PROCESS_IS_TERMINATING) {

                bDoBlock = TRUE;
            } else {
                bDoBlock = FALSE;
            }
        } else {
            Status = NtTerminateProcess(pcsrtKill->Process->ProcessHandle, DBG_TERMINATE_PROCESS);
            if (!NT_SUCCESS(Status) && Status != STATUS_PROCESS_IS_TERMINATING) {
                bDoBlock = TRUE;
            } else {
                bDoBlock = FALSE;
            }
        }

        if (bDoBlock) {

            /*
             * If the app is being debugged, don't close it - because that can
             * cause a hang to the NtTerminateProcess() call.
             */
            lpszMsg = ServerLoadString(ghModuleWin, STR_APPDEBUGGED,
                    NULL, &fAllocated);
            if (lpszMsg) {
                MessageBoxEx(NULL, lpszMsg, NULL, MB_OK | MB_SETFOREGROUND, 0);
                LocalFree(lpszMsg);
            }
        } else {
            pcsrtKill->Process->Flags |= CSR_PROCESS_TERMINATED;
        }
    }
    CsrDereferenceThread(pcsrtKill);

RestoreDesktop:
    utudi.hThread = NULL;
    Status = NtUserSetInformationThread(NtCurrentThread(),
            UserThreadUseDesktop, &utudi, sizeof(utudi));
    UserAssert(NT_SUCCESS(Status));

    return fRet;
}

/***************************************************************************\
* WowExitTask
*
* Calls wow back to make sure a specific task has exited. Returns
* TRUE if the thread is a WOW task, FALSE if not.
*
* 08-02-92 ScottLu      Created.
\***************************************************************************/
BOOL WowExitTask(
    PCSR_THREAD pcsrt)
{
    HANDLE ahandle[2];
    USERTHREAD_WOW_INFORMATION WowInfo;
    NTSTATUS Status;

    ahandle[1] = gheventCancel;

    /*
     * Query task id and exit function.
     */
    Status = NtUserQueryInformationThread(pcsrt->ThreadHandle,
            UserThreadWOWInformation, &WowInfo, sizeof(WowInfo), NULL);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    /*
     * If no task id was returned, it is not a WOW task
     */
    if (WowInfo.hTaskWow == 0) {
        return FALSE;
    }

    /*
     * Try to make it exit itself. This will work most of the time.
     * If this doesn't work, terminate this process.
     */
    ahandle[0] = InternalCreateCallbackThread(pcsrt->Process->ProcessHandle,
                                              (ULONG_PTR)WowInfo.lpfnWowExitTask,
                                              (ULONG_PTR)WowInfo.hTaskWow);
    if (ahandle[0] == NULL) {
        NtTerminateProcess(pcsrt->Process->ProcessHandle, 0);
        pcsrt->Process->Flags |= CSR_PROCESS_TERMINATED;
        goto Exit;
    }

    WaitForMultipleObjects(2, ahandle, FALSE, INFINITE);
    NtClose(ahandle[0]);

Exit:
    return TRUE;
}

/***************************************************************************\
* InternalWaitCancel
*
* Console calls this to wait for objects or shutdown to be cancelled
*
* 29-Oct-1992 mikeke    Created
\***************************************************************************/
DWORD InternalWaitCancel(
    HANDLE handle,
    DWORD dwMilliseconds)
{
    HANDLE ahandle[2];

    ahandle[0] = handle;
    ahandle[1] = gheventCancel;

    return WaitForMultipleObjects(2, ahandle, FALSE, dwMilliseconds);
}


/***************************************************************************\
* InternalCreateCallbackThread
*
* This routine creates a remote thread in the context of a given process.
* It is used to call the console control routine, as well as ExitProcess when
* forcing an exit. Returns a thread handle.
*
* 07-28-92 ScottLu      Created.
\***************************************************************************/

HANDLE InternalCreateCallbackThread(
    HANDLE hProcess,
    ULONG_PTR lpfn,
    ULONG_PTR dwData)
{
    LONG BasePriority;
    HANDLE hThread, hToken;
    PTOKEN_DEFAULT_DACL lpDaclDefault;
    TOKEN_DEFAULT_DACL daclDefault;
    ULONG cbDacl;
    SECURITY_ATTRIBUTES attrThread;
    SECURITY_DESCRIPTOR sd;
    DWORD idThread;
    NTSTATUS Status;

    hThread = NULL;

    Status = NtOpenProcessToken(hProcess, TOKEN_QUERY, &hToken);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("NtOpenProcessToken failed, status = %x\n", Status));
        return NULL;
    }

    cbDacl = 0;
    NtQueryInformationToken(hToken,
            TokenDefaultDacl,
            &daclDefault,
            sizeof(daclDefault),
            &cbDacl);

    lpDaclDefault = (PTOKEN_DEFAULT_DACL)LocalAlloc(LMEM_FIXED, cbDacl);
    if (lpDaclDefault == NULL) {
        KdPrint(("LocalAlloc failed for lpDaclDefault"));
        goto closeexit;
    }

    Status = NtQueryInformationToken(hToken,
            TokenDefaultDacl,
            lpDaclDefault,
            cbDacl,
            &cbDacl);
    if (!NT_SUCCESS(Status)) {
        KdPrint(("NtQueryInformationToken failed, status = %x\n", Status));
        goto freeexit;
    }

    if (!NT_SUCCESS(RtlCreateSecurityDescriptor(&sd,
            SECURITY_DESCRIPTOR_REVISION1))) {
        UserAssert(FALSE);
        goto freeexit;
    }

    RtlSetDaclSecurityDescriptor(&sd, TRUE, lpDaclDefault->DefaultDacl, TRUE);

    attrThread.nLength = sizeof(attrThread);
    attrThread.lpSecurityDescriptor = &sd;
    attrThread.bInheritHandle = FALSE;

    GetLastError();
    hThread = CreateRemoteThread(hProcess,
        &attrThread,
        0L,
        (LPTHREAD_START_ROUTINE)lpfn,
        (LPVOID)dwData,
        0,
        &idThread);

    if (hThread != NULL) {
        BasePriority = THREAD_PRIORITY_HIGHEST;
        NtSetInformationThread(hThread,
                               ThreadBasePriority,
                               &BasePriority,
                               sizeof(LONG));
    }

freeexit:
    LocalFree((HANDLE)lpDaclDefault);

closeexit:
    NtClose(hToken);

    return hThread;
}

ULONG
SrvExitWindowsEx(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    BEGIN_LPC_RECV(EXITWINDOWSEX);

    Status = _ExitWindowsEx(pcsrt, a->uFlags);
    a->fSuccess = NT_SUCCESS(Status);

    END_LPC_RECV();
}

ULONG
SrvEndTask(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PENDTASKMSG petm = (PENDTASKMSG)&m->u.ApiMessageData;
    PCSR_THREAD pcsrt;
    PTEB Teb = NtCurrentTeb();

    Teb->LastErrorValue = 0;
    pcsrt = CSR_SERVER_QUERYCLIENTTHREAD();
    /*
     * Don't block the client so it can respond to messages while we
     * process this request -- we might bring up the End Application
     * dialog or the hwnd being shutdown might request some user action.
     */
    if (pcsrt->Process->ClientPort != NULL) {
        m->ReturnValue = STATUS_SUCCESS;
        petm->dwLastError = 0;
        petm->fSuccess = TRUE;
        NtReplyPort(pcsrt->Process->ClientPort, (PPORT_MESSAGE)m);
        *ReplyStatus = CsrServerReplied;
    }

    petm->fSuccess = _EndTask(petm->hwnd, petm->fForce);

    petm->dwLastError = Teb->LastErrorValue;
    return STATUS_SUCCESS;
}

/***************************************************************************\
* IsPrivileged
*
* Check to see if the client has the specified privileges
*
* History:
* 01-02-91 JimA       Created.
\***************************************************************************/
BOOL IsPrivileged(
    PPRIVILEGE_SET ppSet)
{
    HANDLE hToken;
    NTSTATUS Status;
    BOOLEAN bResult = FALSE;
    UNICODE_STRING strSubSystem;

    /*
     * Impersonate the client
     */
    if (!CsrImpersonateClient(NULL))
        return FALSE;

    /*
     * Open the client's token
     */
    RtlInitUnicodeString(&strSubSystem, L"USER32");
    if (NT_SUCCESS(Status = NtOpenThreadToken(NtCurrentThread(), TOKEN_QUERY,
            (BOOLEAN)TRUE, &hToken))) {

        /*
         * Perform the check
         */
        Status = NtPrivilegeCheck(hToken, ppSet, &bResult);
        NtPrivilegeObjectAuditAlarm(&strSubSystem, NULL, hToken,
                0, ppSet, bResult);
        NtClose(hToken);
        if (!bResult) {
            SetLastError(ERROR_ACCESS_DENIED);
        }
    }
    CsrRevertToSelf();
    if (!NT_SUCCESS(Status))
        SetLastError(RtlNtStatusToDosError(Status));

    /*
     * Return result of privilege check
     */
    return (BOOL)(bResult && NT_SUCCESS(Status));
}

/***************************************************************************\
* _RegisterServicesProcess
*
* Register the services process.
*
* History:
* 05-05-95 BradG         Created.
\***************************************************************************/

ULONG
SrvRegisterServicesProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PRIVILEGE_SET psTcb = { 1, PRIVILEGE_SET_ALL_NECESSARY,
        { SE_TCB_PRIVILEGE, 0 }
    };

    BEGIN_LPC_RECV(REGISTERSERVICESPROCESS);

    /*
     * Allow only one services process and then only if it has TCB
     * privilege.
     */
    EnterCrit();
    if ((gdwServicesProcessId != 0) || !IsPrivileged(&psTcb)) {
        SetLastError(ERROR_ACCESS_DENIED);
        a->fSuccess = FALSE;
    } else {
        gdwServicesProcessId = a->dwProcessId;
        a->fSuccess = TRUE;
    }
    LeaveCrit();

    END_LPC_RECV();
}

#ifdef FE_IME
/***************************************************************************\
* IsImeWindow
*
* Returns TRUE if it's an IME window.
*
* History:
* 06-05-96 KazuM         Created.
\***************************************************************************/
BOOL
IsImeWindow(
    HWND hwnd)
{
    int num;
    WCHAR ClassName[16];

    num = GetClassName(hwnd, ClassName, sizeof(ClassName)/sizeof(WCHAR)-1);
    if (num == 0) {
        return FALSE;
    }

    ClassName[num] = L'\0';
    if (wcsncmp(ClassName, L"IME", 3) == 0) {
        return TRUE;
    }

    return (GetClassLong(hwnd, GCL_STYLE) & CS_IME) != 0;
}
#endif // FE_IME

/***************************************************************************\
* CancelExitWindows
*
* Cancel any logoff/shutdown that is in progress. This is called from _ExitWindowsEx
* to cancel an existing exitwindows call if a new call arrives with a different sid.
* This call is also  used for Personal Terminal Services single session scenatio so
* that a force logoff can be initiated once the existing ExitWindows call is
* cancelled.
*
* History:
\***************************************************************************/
BOOL CancelExitWindows(
   VOID)
{
   LARGE_INTEGER li;

   /*
    * Another logoff/shutdown is in progress and we need
    * to cancel it so we can do an override.
    *
    * If someone else is trying to cancel shutdown, exit.
    */
   EnterCrit();
   li.QuadPart  = 0;
   if (NtWaitForSingleObject(gheventCancel, FALSE, &li) == WAIT_OBJECT_0) {
       LeaveCrit();
       return FALSE;
   }

   /*
    * If no one will set gheventCancelled, don't wait.
    */
   if (gdwThreadEndSession == 0) {
       LeaveCrit();
       return TRUE;
   }

   NtClearEvent(gheventCancelled);
   NtSetEvent(gheventCancel, NULL);
   LeaveCrit();
   /*
    * Wait for the other guy to be cancelled
    */
   NtWaitForSingleObject(gheventCancelled, FALSE, NULL);

   EnterCrit();

   /*
    * This signals that we are no longer trying to cancel a
    * shutdown
    */
   NtClearEvent(gheventCancel);

   /*
    * If someone managed to start a shutdown again, exit.
    * Can this happen? Let's assert to check it out.
    */
   if (gdwThreadEndSession != 0) {
       UserAssert(gdwThreadEndSession == 0);
       LeaveCrit();
       return FALSE;
   }
   LeaveCrit();

   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\globals.c ===
/****************************** Module Header ******************************\
* Module Name: globals.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the server's global variables.  One must be
* executing on the server's context to manipulate any of these variables.
* Serializing access to them is also a good idea.
*
* History:
* 10-15-90 DarrinM      Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

HANDLE ghModuleWin;
CRITICAL_SECTION gcsUserSrv;

DWORD gCmsHungAppTimeout = CMSHUNGAPPTIMEOUT;
DWORD gCmsWaitToKillTimeout = CMSWAITTOKILLTIMEOUT;
DWORD gdwHungToKillCount = CMSHUNGTOKILLCOUNT;
BOOL gfAutoEndTask;
BOOL gbExitInProgress;

DWORD gdwRIPFlags;

/*
 *  These globals are used when shutting down the services
 *  process.
 */
DWORD gdwServicesProcessId;
DWORD gdwServicesWaitToKillTimeout;
DWORD gdwProcessTerminateTimeout = 0;

/*
 * logon process id
 */
DWORD gIdLogon;

/*
 * Hard error stuff
 */
PHARDERRORINFO gphiList;
DWORD gdwHardErrorThreadId;
HANDLE gNtDllHandle;
HANDLE gEventSource;
PWSTR gpwszaSUCCESS;
PWSTR gpwszaSYSTEM_INFORMATION;
PWSTR gpwszaSYSTEM_WARNING;
PWSTR gpwszaSYSTEM_ERROR;

/*
 * EndTask / Shutdown stuff
 */
DWORD gdwThreadEndSession;
HANDLE gheventCancel;
HANDLE gheventCancelled;

ULONG gSessionId = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\globals.h ===
/****************************** Module Header ******************************\
* Module Name: globals.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains all the server's global variables
* One must be executing on the server's context to manipulate
* any of these variables or call any of these functions.  Serializing access
* to them is also a good idea.
*
* History:
* 10-15-90 DarrinM      Created.
\***************************************************************************/

#ifndef _GLOBALS_
#define _GLOBALS_

extern CRITICAL_SECTION gcsUserSrv;
extern BOOL gfAutoEndTask;
extern BOOL gbExitInProgress;

extern DWORD gdwRIPFlags;

/*
 * logon process id
 */
extern DWORD gIdLogon;


/*
 * Hard error globals
 */
extern DWORD gdwHardErrorThreadId;
extern HANDLE gNtDllHandle;
extern HANDLE gEventSource;
extern PHARDERRORINFO gphiList;
/*
 * EndTask / Shutdown stuff
 */
extern DWORD gdwThreadEndSession;
extern HANDLE gheventCancel;
extern HANDLE gheventCancelled;
extern PWSTR gpwszaSUCCESS;
extern PWSTR gpwszaSYSTEM_INFORMATION;
extern PWSTR gpwszaSYSTEM_WARNING;
extern PWSTR gpwszaSYSTEM_ERROR;

/*
 * EndTask globals
 */
extern DWORD   gpidWOW;

extern ULONG gSessionId;


#endif // _GLOBALS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\msgbeep.c ===
/****************************** Module Header ******************************\
* Module Name: msgbeep.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains ConsolePlaySound.
*
* History:
*  06-26-91 NigelT      Created it with some wood and a few nails.
*  05-07-92 SteveDav    Getting closer to the real thing.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "ntuser.h"

/***************************************************************************\
*
* ConsolePlaySound
*
* Play the Open sound for console applications.
*
\***************************************************************************/
VOID ConsolePlaySound(
    VOID)
{
    NtUserCallOneParam(USER_SOUND_OPEN, SFI_PLAYEVENTSOUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\makefile.inc ===
..\precomp.h: ..\usersrv.h ..\globals.h $(O)\strid.h  ..\..\inc\user.h ..\..\inc\csrmsg.h \
              $(WINDOWS_INC_PATH)\winuserp.h  $(WINCORE_PATH)\w32inc\winuserk.h

$(O)\strid.h $(O)\res.rc $(O)\msg00001.bin: ..\strid.mc
    mc -v -U ..\strid.mc -r $(O) -h $(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include "usersrv.h"
#include <winnls.h>
#define NOEXTAPI
#include "wdbgexts.h"
#include <ntdbg.h>
#include <stdio.h>
#include <limits.h>
#include "conapi.h"
#include <ntddkbd.h>
#include <string.h>
#include "conroute.h"
#include "heap.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\icamsg.c ===
/*************************************************************************\
*
* icamsg.c
*
* Process ICA send message requests
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* $Author:
*
\*************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <dbt.h>
#include <ntdddisk.h>
#include "ntuser.h"

#include <winsta.h>
#include <wstmsg.h>


/*
 *  Local functions
 */
VOID     HardErrorRemove(PCTXHARDERRORINFO);
DWORD    RemoteMessageThread(PVOID);


/*
 *  External functions
 */
VOID     HardErrorInsert(PCSR_THREAD, PHARDERROR_MSG, PCTXHARDERRORINFO);
NTSTATUS ReplyMessageToTerminalServer(PCTXHARDERRORINFO);

/*
 *  Local data
 */

PCTXHARDERRORINFO gpchiList = NULL;
HANDLE g_hDoMessageEvent = NULL;


/*******************************************************************************
 *
 *  RemoteDoMessage
 *
 * ENTRY:
 *
 * EXIT:
 *    STATUS_SUCCESS - successful
 *
 ******************************************************************************/

NTSTATUS
RemoteDoMessage(
    PWINSTATION_APIMSG pMsg)
{
    WINSTATIONSENDMESSAGEMSG * pSMsg = &pMsg->u.SendMessage;
    PCTXHARDERRORINFO pchi;
    NTSTATUS Status;
    static HANDLE hMessageThread = NULL;

    EnterCrit();        // to synchronize heap calls

    /*
     *  Create list entry
     */
    if ((pchi = (PCTXHARDERRORINFO)LocalAlloc(LPTR, sizeof(CTXHARDERRORINFO))) == NULL) {
        LeaveCrit();
        return (STATUS_NO_MEMORY);
    } else if ((pchi->pTitle = LocalAlloc(LPTR, pSMsg->TitleLength + sizeof(TCHAR))) == NULL) {
        LocalFree(pchi);
        LeaveCrit();
        return (STATUS_NO_MEMORY);
    } else if ((pchi->pMessage = LocalAlloc(LPTR, pSMsg->MessageLength + sizeof(TCHAR))) == NULL) {
        LocalFree(pchi->pTitle);
        LocalFree(pchi);
        LeaveCrit();
        return (STATUS_NO_MEMORY);
    }

    /*
     * Initialize
     */
    pchi->ClientId  = pMsg->h.ClientId;
    pchi->MessageId = pMsg->MessageId;
    pchi->Timeout   = pSMsg->Timeout;
    pchi->pResponse = pSMsg->pResponse;
    pchi->hEvent    = pSMsg->hEvent;
    pchi->DoNotWait = pSMsg->DoNotWait;
    pchi->Style     = pSMsg->Style;

    pchi->pTitle[pSMsg->TitleLength/sizeof(TCHAR)] = L'\0';
    RtlMoveMemory(pchi->pTitle, pSMsg->pTitle, pSMsg->TitleLength);

    pchi->pMessage[pSMsg->MessageLength/sizeof(TCHAR)] = L'\0';
    RtlMoveMemory(pchi->pMessage, pSMsg->pMessage, pSMsg->MessageLength);

    RIPMSG1(RIP_WARNING, "RemoteDoMessage: pchi->pTitle   - %S", pchi->pTitle);
    RIPMSG1(RIP_WARNING, "RemoteDoMessage: pchi->pMessage - %S", pchi->pMessage);

    /*
     * Link in at head
     */
    pchi->pchiNext = gpchiList;
    gpchiList = pchi;

    LeaveCrit();

    /*
     * Start message thread if not running, otherwise signal thread.
     */
    if (hMessageThread == NULL) {
        DWORD dwThreadId;
        RIPMSG0(RIP_WARNING, "RemoteDoMessage: starting RemoteMessageThread ...");
        
        if ((hMessageThread = CreateThread(NULL,
                                            0,
                                            RemoteMessageThread,
                                            NULL,
                                            0,
                                            &dwThreadId)) == NULL) {

            RIPMSG1(RIP_WARNING, "RemoteDoMessage: Cannot start RemoteMessageThread, error 0x%x", GetLastError());
        }
    } else {
        if (g_hDoMessageEvent == NULL) {
            return STATUS_UNSUCCESSFUL;
        }
        Status = NtSetEvent(g_hDoMessageEvent, NULL);
        
        if (!NT_SUCCESS(Status)) {
            RIPMSG2(RIP_WARNING, "RemoteDoMessage: Error NtSetEvent failed, Status=%x, rc=%u", Status, GetLastError());
            return Status;
        }
    }

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *
 *  RemoteMessageThread
 *
 * ENTRY:
 *
 * EXIT:
 *    STATUS_SUCCESS - successful
 *
 ******************************************************************************/
DWORD
RemoteMessageThread(
    PVOID pVoid)
{
    HARDERROR_MSG hemsg;
    PCTXHARDERRORINFO pchi, *ppchi;
    UNICODE_STRING Message, Title;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjA;

    UNREFERENCED_PARAMETER(pVoid);

    /*
     * Create sync event
     */
    InitializeObjectAttributes(&ObjA, NULL, 0, NULL, NULL);
    Status = NtCreateEvent(&g_hDoMessageEvent, EVENT_ALL_ACCESS, &ObjA,
                           NotificationEvent, FALSE);
    
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "RemoteMessageThread: Error NtCreateEvent failed, rc=0x%x", GetLastError());
        return GetLastError();
    }

    while (!gbExitInProgress) {

        EnterCrit();        // to synchronize heap calls

        /*
         * Valid list
         */
        if (gpchiList != NULL) {

            /*
             * Find last entry
             */
            for (ppchi = &gpchiList;
                 (*ppchi != NULL) && ((*ppchi)->pchiNext != NULL);
                 ppchi = &(*ppchi)->pchiNext) ;

            /*
             * Found it
             */
            if ((pchi = *ppchi) != NULL) {
                
                /*
                 * Unlink from the list.
                 */
                for (ppchi = &gpchiList; *ppchi != NULL && *ppchi != pchi;
                    ppchi = &(*ppchi)->pchiNext)
                    ;
                
                if (*ppchi != NULL) {
                    *ppchi = pchi->pchiNext;
                }

                LeaveCrit();

                /*
                 *  Make strings unicode
                 */
                RtlInitUnicodeString(&Title, pchi->pTitle);
                RtlInitUnicodeString(&Message, pchi->pMessage);

                /*
                 *  Initialize harderror message struct
                 */
                hemsg.h.ClientId = pchi->ClientId;
                hemsg.Status = STATUS_SERVICE_NOTIFICATION;
                hemsg.NumberOfParameters = 3;
                hemsg.UnicodeStringParameterMask = 3;
                hemsg.ValidResponseOptions = OptionOk;
                hemsg.Parameters[0] = (ULONG_PTR)&Message;
                hemsg.Parameters[1] = (ULONG_PTR)&Title;
                hemsg.Parameters[2] = (ULONG_PTR)pchi->Style;

                /*
                 *  Place message in harderror queue
                 */
                HardErrorInsert(NULL, &hemsg, pchi);
            } else {
                LeaveCrit();
            }
        } else {
            LeaveCrit();
        }

        if (gpchiList == NULL) {
            
            UserAssert(g_hDoMessageEvent != NULL);
            
            Status = NtWaitForSingleObject(g_hDoMessageEvent, FALSE, NULL);
            
            UserAssert(NT_SUCCESS(Status));
            
            NtResetEvent(g_hDoMessageEvent, NULL);
        }
    }

    NtClose(g_hDoMessageEvent);
    g_hDoMessageEvent = NULL;
    
    return 0;
}

/*******************************************************************************
 *
 *  HardErrorRemove
 *
 * ENTRY:
 *
 * EXIT:
 *    STATUS_SUCCESS - successful
 *
 ******************************************************************************/

VOID HardErrorRemove(
    PCTXHARDERRORINFO pchi)
{

    /*
     *  Notify ICASRV's RPC thread if waiting
     */
    if (!pchi->DoNotWait) {
        ReplyMessageToTerminalServer(pchi);
    }

    /*
     *  Free memory
     */
    LocalFree(pchi->pMessage);
    LocalFree(pchi->pTitle);
    LocalFree(pchi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\instdev.c ===
/**************************************************************************\
* Module Name: instdev.c
*
* Device handling routine for CSRSS.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 13-Mar-97
*
* History:
*   13-Mar-97 created by PaulaT
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "ntuser.h"
#include <dbt.h>
#include <pnpmgr.h>


/**************************************************************************\
* SrvDeviceEvent
*
* User-mode PNP manager (in services.exe) has a message to deliver to an
* app that has registered for this notification but services.exe isn't
* in WinSta0\Default so we need a CSRSS thread to simply send the message.
*
* PaulaT    06/04/97    Created.
* JasonSch  02/22/01    Removed bogus try/except.
\**************************************************************************/
ULONG
SrvDeviceEvent(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    NTSTATUS Status;
    PDEVICEEVENTMSG a = (PDEVICEEVENTMSG)&m->u.ApiMessageData;
    USERTHREAD_USEDESKTOPINFO utudi;

    UNREFERENCED_PARAMETER(ReplyStatus);

    //
    // Set the desktop to the active desktop before sending the
    // message.
    //

    utudi.hThread = NULL;
    utudi.drdRestore.pdeskRestore = NULL;
    Status = NtUserSetInformationThread(NtCurrentThread(),
                                        UserThreadUseActiveDesktop,
                                        &utudi, sizeof(utudi));
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "SrvDeviceEvent: NtUserSetInformationThread failed 0x%x\n", Status);
        goto Exit;
    }

    //
    // Verify the window handle is still valid. If not, let the caller know
    // so it can be purged from the notification window list that the
    // user-mode pnp manager keeps.
    //

    if (a->hWnd != HWND_BROADCAST && !IsWindow(a->hWnd)) {
        Status = STATUS_INVALID_HANDLE;
        goto ResetDesktop;
    }

    if (a->dwFlags) {

        //
        // This is a query so we have to send the message but use
        // timeouts so an app can't stall us forever.
        //

        RIPMSG3(RIP_VERBOSE, "SrvDeviceEvent: Sending WM_DEVICECHANGE to 0x%x, w 0x%p, l 0x%p",
                a->hWnd,
                a->wParam,
                a->lParam);


        if (!SendMessageTimeout(a->hWnd, WM_DEVICECHANGE, a->wParam, a->lParam,
                                SMTO_ABORTIFHUNG | SMTO_NORMAL,
                                PNP_NOTIFY_TIMEOUT, &a->dwResult)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    } else {
        //
        // It's not a query so just post it and return. We don't
        // care what the app returns.
        //

        RIPMSG3(RIP_VERBOSE, "SrvDeviceEvent: Posting WM_DEVICECHANGE to 0x%x, w 0x%p, l 0x%p",
                a->hWnd,
                a->wParam,
                a->lParam);

        if (!PostMessage(a->hWnd, WM_DEVICECHANGE, a->wParam, a->lParam)) {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

ResetDesktop:

    //
    // Reset this thread's desktop back to NULL before returning. This
    // decrements the desktop's reference count.
    //

    NtUserSetInformationThread(NtCurrentThread(),
                               UserThreadUseDesktop,
                               &utudi, sizeof(utudi));

Exit:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\harderr.c ===
/**************************** Module Header ********************************\
* Module Name: harderr.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Hard error handler
*
* History:
* 07-03-91 JimA                Created scaffolding.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include "ntlpcapi.h"
#include "xpsp1res.h"

#include <winsta.h>

VOID UserHardErrorEx(
    PCSR_THREAD pt,
    PHARDERROR_MSG pmsg,
    PCTXHARDERRORINFO pCtxHEInfo);

VOID ProcessHardErrorRequest(
    BOOL fNewThread);


CONST UINT wIcons[] = {
    0,
    MB_ICONINFORMATION,
    MB_ICONEXCLAMATION,
    MB_ICONSTOP
};
CONST UINT wOptions[] = {
    MB_ABORTRETRYIGNORE,
    MB_OK,
    MB_OKCANCEL,
    MB_RETRYCANCEL,
    MB_YESNO,
    MB_YESNOCANCEL,
    MB_OK,              // OptionShutdownSystem
    MB_OK,              // OptionOkNoWait
    MB_CANCELTRYCONTINUE
};
CONST DWORD dwResponses[] = {
    ResponseNotHandled, // MessageBox error
    ResponseOk,         // IDOK
    ResponseCancel,     // IDCANCEL
    ResponseAbort,      // IDABORT
    ResponseRetry,      // IDRETRY
    ResponseIgnore,     // IDIGNORE
    ResponseYes,        // IDYES
    ResponseNo,         // IDNO
    ResponseNotHandled, // Error as IDCLOSE can't show up
    ResponseNotHandled, // error as IDHELP can't show up
    ResponseTryAgain,   // IDTRYAGAIN
    ResponseContinue    // IDCONTINUE
};
CONST DWORD dwResponseDefault[] = {
    ResponseAbort,      // OptionAbortRetryIgnore
    ResponseOk,         // OptionOK
    ResponseOk,         // OptionOKCancel
    ResponseCancel,     // OptionRetryCancel
    ResponseYes,        // OptionYesNo
    ResponseYes,        // OptionYesNoCancel
    ResponseOk,         // OptionShutdownSystem
    ResponseOk,         // OptionOKNoWait
    ResponseCancel      // OptionCancelTryContinue
};

/*
 *  Citrix SendMessage entry point to harderror handler and cleanup routine
 */
VOID HardErrorInsert(PCSR_THREAD, PHARDERROR_MSG, PCTXHARDERRORINFO);
VOID HardErrorRemove(PCTXHARDERRORINFO);

/***************************************************************************\
* LogErrorPopup
*
* History:
* 09-22-97 GerardoB     Added Header
\***************************************************************************/
VOID
LogErrorPopup(
    IN LPWSTR Caption,
    IN LPWSTR Message
    )
{
    LPWSTR lps[2];

    lps[0] = Caption;
    lps[1] = Message;

    UserAssert(gEventSource != NULL);
    ReportEvent(gEventSource, EVENTLOG_INFORMATION_TYPE, 0,
        STATUS_LOG_HARD_ERROR, NULL, sizeof(lps) / sizeof(*lps),
        0, lps, NULL);
}

/***************************************************************************\
* SubstituteDeviceName
*
* History:
* 09-22-97 GerardoB     Added Header
\***************************************************************************/
static WCHAR wszDosDevices[] = L"\\??\\A:";
VOID
SubstituteDeviceName(
    PUNICODE_STRING InputDeviceName,
    LPSTR OutputDriveLetter
    )
{
    UNICODE_STRING LinkName;
    UNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE LinkHandle;
    NTSTATUS Status;
    ULONG i;
    PWCHAR p;
    WCHAR DeviceNameBuffer[MAXIMUM_FILENAME_LENGTH];

    RtlInitUnicodeString(&LinkName,wszDosDevices);
    p = wszDosDevices + ARRAY_SIZE(wszDosDevices) - ARRAY_SIZE(L"A:");
    for(i=0;i<26;i++){
        *p = (WCHAR)('A' + i);

        InitializeObjectAttributes(
            &Obja,
            &LinkName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
        Status = NtOpenSymbolicLinkObject(
                    &LinkHandle,
                    SYMBOLIC_LINK_QUERY,
                    &Obja
                    );
        if (NT_SUCCESS( Status )) {

            //
            // Open succeeded, Now get the link value
            //

            DeviceName.Length = 0;
            DeviceName.MaximumLength = sizeof(DeviceNameBuffer);
            DeviceName.Buffer = DeviceNameBuffer;

            Status = NtQuerySymbolicLinkObject(
                        LinkHandle,
                        &DeviceName,
                        NULL
                        );
            NtClose(LinkHandle);
            if ( NT_SUCCESS(Status) ) {
                if ( RtlEqualUnicodeString(InputDeviceName,&DeviceName,TRUE) ) {
                    OutputDriveLetter[0]=(CHAR)('A'+i);
                    OutputDriveLetter[1]=':';
                    OutputDriveLetter[2]='\0';
                    return;
                    }
                }
            }
        }
}
/***************************************************************************\
* GetErrorMode
*
* History:
* 09-22-97 GerardoB     Added Header
\***************************************************************************/
DWORD GetErrorMode(VOID)
{
    HANDLE hKey;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES OA;
    LONG Status;
    BYTE Buf[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    DWORD cbSize;
    DWORD dwRet = 0;

    RtlInitUnicodeString(&UnicodeString,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Windows");
    InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtOpenKey(&hKey, KEY_READ, &OA);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString, L"ErrorMode");
        Status = NtQueryValueKey(hKey,
                &UnicodeString,
                KeyValuePartialInformation,
                (PKEY_VALUE_PARTIAL_INFORMATION)Buf,
                sizeof(Buf),
                &cbSize);
        if (NT_SUCCESS(Status)) {
            dwRet = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)Buf)->Data);
        }
        NtClose(hKey);
    }
    return dwRet;
}
/***************************************************************************\
* FreePhi
*
* History:
* 09-18-97 GerardoB     Created
\***************************************************************************/
void FreePhi (PHARDERRORINFO phi)
{
    if (phi->dwHEIFFlags & HEIF_ALLOCATEDMSG) {
        LocalFree(phi->pmsg);
    }

    RtlFreeUnicodeString(&phi->usText);
    RtlFreeUnicodeString(&phi->usCaption);

    LocalFree(phi);
}
/***************************************************************************\
* ReplyHardError
*
* This function is called when we are done with a hard error.
*
* History:
* 03-11-97 GerardoB     Created
\***************************************************************************/
void ReplyHardError (PHARDERRORINFO phi, DWORD dwResponse)
{
    phi->pmsg->Response = dwResponse;
    /*
     * Signal the event if any. If not, reply if we haven't done so
     *  already.
     */
    if (phi->hEventHardError != NULL) {
        NtSetEvent(phi->hEventHardError, NULL);
    } else if (!(phi->dwHEIFFlags & HEIF_REPLIED)) {
        NtReplyPort(((PCSR_THREAD)phi->pthread)->Process->ClientPort,
                    (PPORT_MESSAGE)phi->pmsg);
    }
    /*
     * If we had locked the thread or were holding the client port,
     *   then let it go now.
     */
    if (phi->dwHEIFFlags & HEIF_DEREFTHREAD) {
        CsrDereferenceThread(phi->pthread);
    }
    /*
     * We're done with this dude
     */
    FreePhi(phi);
}
/***************************************************************************\
* CheckDefaultDesktop
*
* This function is called by the HardErrorHandler when it's notified
*  that we've switched desktops or upon waking up.
*  If we're on the default desktop now, then we clear the HEIF_WRONGDESKTOP
*  flag; this flag is set when we find a MB_DEFAULT_DESKTOP_ONLY request but
*  we are not in the right (default) desktop.
*
* History:
* 06-02-97 GerardoB     Created
\***************************************************************************/
void CheckDefaultDesktop(void)
{
    PHARDERRORINFO phi;

    if (HEC_WRONGDESKTOP == NtUserHardErrorControl(HardErrorInDefDesktop, NULL, NULL)) {
        return;
    }

    EnterCrit();
    phi = gphiList;
    while (phi != NULL) {
        phi->dwHEIFFlags &= ~HEIF_WRONGDESKTOP;
        phi = phi->phiNext;
    }
    LeaveCrit();
}

/***************************************************************************\
* GetHardErrorText
*
* This function figures out the message box title, text and flags.
* We want to do this up front so we can log this error when the hard error is
*  raised. Previously we used to log it after the user had dismissed the message
*  box -- but that was not when the error occurred (DCR Bug 107590)
*
* History:
* 09-18-97 GerardoB     Extracted (and cleaned up) from HardErrorHandler
\***************************************************************************/
void GetHardErrorText (PHARDERRORINFO phi)
{
    static WCHAR wszUnkownSoftwareException [] = L"unknown software exception";
    static WCHAR wszException [] = L"{EXCEPTION}";
    static WCHAR wszUnknownHardError [] = L"Unknown Hard Error";
    ANSI_STRING asLocal, asMessage;
    BOOL fFreeAppNameBuffer, fFreeCaption;
    BOOL fResAllocated, fResAllocated1, fErrorIsFromSystem;
    WCHAR wszErrorMessage[WSPRINTF_LIMIT + 1];
    DWORD dwCounter, dwStringsToFreeMask, dwMBFlags, dwTimeout;
    ULONG_PTR adwParameterVector[MAXIMUM_HARDERROR_PARAMETERS];
    HANDLE hClientProcess;
    HWND hwndOwner;
    NTSTATUS Status;
    PHARDERROR_MSG phemsg;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    PWSTR pwszCaption, pwszFormatString;
    PWSTR pwszAppName, pwszResBuffer, pwszResBuffer1;
    PWSTR pwszMsg, pwszTitle, pwszFullCaption;
    UINT uMsgLen, uCaptionLen, uTitleLen;
    UNICODE_STRING usScratch, usLocal, usMessage, usCaption;
    BOOL bMustFreeMessageEntry = FALSE;

    /*
     * Initialize working variables
     */
    fFreeAppNameBuffer = fFreeCaption = FALSE;
    hClientProcess = NULL;
    RtlInitUnicodeString(&usCaption, NULL);
    RtlInitUnicodeString(&usMessage, NULL);
    dwTimeout = INFINITE;

    /*
     * Initialize response in case something goes wrong
     */
    phemsg = phi->pmsg;
    phemsg->Response = ResponseNotHandled;
    /*
     * Make a copy of the parameters. Initialize unused ones to point to empty
     *  strings (in case we expect a string there).
     */
    UserAssert(phemsg->NumberOfParameters <= MAXIMUM_HARDERROR_PARAMETERS);
    RtlCopyMemory(adwParameterVector, phemsg->Parameters, phemsg->NumberOfParameters * sizeof(*phemsg->Parameters));
    dwCounter = phemsg->NumberOfParameters;
    while (dwCounter < MAXIMUM_HARDERROR_PARAMETERS) {
        adwParameterVector[dwCounter++] = (ULONG_PTR)L"";
    }
    /*
     * Open the client process so we can read the strings parameters, process
     *  name, etc., from its address space
     */
    hClientProcess = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
                                FALSE, HandleToUlong(phemsg->h.ClientId.UniqueProcess));
    fErrorIsFromSystem = (hClientProcess == NULL);
    /*
     * If there are unicode strings, then we need to
     * convert them to ansi and store them in the
     * parameter vector
     */
    dwStringsToFreeMask = 0;
    if (phemsg->UnicodeStringParameterMask) {

        for (dwCounter = 0; dwCounter < phemsg->NumberOfParameters; dwCounter++) {
            /*
             * if there is no string in this position, continue
             */
            if (!(phemsg->UnicodeStringParameterMask & (1 << dwCounter))) {
                continue;
            }
            /*
             * Point to an empty string in case we don't have
             * a client to read from or something fails later on.
             */
            adwParameterVector[dwCounter] = (ULONG_PTR)L"";
            if (hClientProcess == NULL) {
                continue;
            }

            Status = NtReadVirtualMemory(hClientProcess,
                            (PVOID)phemsg->Parameters[dwCounter],
                            (PVOID)&usScratch,
                             sizeof(usScratch), NULL);

            if (!NT_SUCCESS(Status)) {
                RIPMSG0(RIP_WARNING, "Failed to read error string struct!");
                continue;
            }

            usLocal = usScratch;
            usLocal.Buffer = (PWSTR)LocalAlloc(LMEM_ZEROINIT, usLocal.Length + sizeof(UNICODE_NULL));
            if (usLocal.Buffer == NULL) {
                RIPMSG0(RIP_WARNING, "Failed to alloc string buffer!");
                continue;
            }

            Status = NtReadVirtualMemory(hClientProcess,
                            (PVOID)usScratch.Buffer,
                            (PVOID)usLocal.Buffer,
                            usLocal.Length,
                            NULL);

            if (!NT_SUCCESS(Status)) {
                LocalFree(usLocal.Buffer);
                RIPMSG0(RIP_WARNING, "Failed to read error string!");
                continue;
            }

            usLocal.MaximumLength = usLocal.Length;
            Status = RtlUnicodeStringToAnsiString(&asLocal, &usLocal, TRUE);
            if (!NT_SUCCESS(Status)) {
                LocalFree(usLocal.Buffer);
                RIPMSG0(RIP_WARNING, "Failed to translate error string!");
                continue;
            }

            /*
             * check to see if string contains an NT
             * device name. If so, then attempt a
             * drive letter substitution
             */

            if (strstr(asLocal.Buffer,"\\Device") == asLocal.Buffer) {
                SubstituteDeviceName(&usLocal,asLocal.Buffer);
            } else if ((asLocal.Length > 4) && !_strnicmp(asLocal.Buffer, "\\??\\", 4)) {
                strcpy( asLocal.Buffer, asLocal.Buffer+4 );
                asLocal.Length -= 4;
            } else {
                /*
                 * Processing some status code doesn't require ansi strings.
                 * Since no substitution took place, let's ignore the translation
                 * to avoid losing chars -- incorrect code page translation
                 */
                switch (phemsg->Status) {
                    case STATUS_SERVICE_NOTIFICATION:
                    case STATUS_VDM_HARD_ERROR:
                        adwParameterVector[dwCounter] = (ULONG_PTR)usLocal.Buffer;
                        RtlFreeAnsiString(&asLocal);
                        continue;
                }

            }

            LocalFree(usLocal.Buffer);

            dwStringsToFreeMask |= (1 << dwCounter);
            adwParameterVector[dwCounter] = (ULONG_PTR)asLocal.Buffer;

        } /* for (dwCounter... */

    } /* if (phemsg->UnicodeStringParameterMask) */

    /*
     * Read additional MB flags, if provided.
     */
#if (HARDERROR_PARAMETERS_FLAGSPOS >= MAXIMUM_HARDERROR_PARAMETERS)
#error Invalid HARDERROR_PARAMETERS_FLAGSPOS value.
#endif
#if (HARDERROR_FLAGS_DEFDESKTOPONLY != MB_DEFAULT_DESKTOP_ONLY)
#error Invalid HARDERROR_FLAGS_DEFDESKTOPONLY
#endif
    dwMBFlags = 0;
    if (phemsg->NumberOfParameters > HARDERROR_PARAMETERS_FLAGSPOS) {
        /*
         * Currently we only use MB_DEFAULT_DESKTOP_ONLY
         */
        UserAssert(!(adwParameterVector[HARDERROR_PARAMETERS_FLAGSPOS] & ~MB_DEFAULT_DESKTOP_ONLY));
        if (adwParameterVector[HARDERROR_PARAMETERS_FLAGSPOS] & MB_DEFAULT_DESKTOP_ONLY) {
            dwMBFlags |= MB_DEFAULT_DESKTOP_ONLY;
        }
    }
    /*
     * For some status codes, all MessageBox parameters are provided in the HardError parameters
     */
    switch (phemsg->Status) {
        case STATUS_SERVICE_NOTIFICATION:
            if (phemsg->UnicodeStringParameterMask & 0x1) {
                RtlInitUnicodeString(&usMessage, (PWSTR)adwParameterVector[0]);
            } else {
                RtlInitAnsiString(&asMessage, (PSTR)adwParameterVector[0]);
                RtlAnsiStringToUnicodeString(&usMessage, &asMessage, TRUE);
            }

            if (phemsg->UnicodeStringParameterMask & 0x2) {
                RtlInitUnicodeString(&usCaption, (PWSTR)adwParameterVector[1]);
            } else {
                RtlInitAnsiString(&asMessage, (PSTR)adwParameterVector[1]);
                RtlAnsiStringToUnicodeString(&usCaption, &asMessage, TRUE);
            }

            dwMBFlags = (DWORD)adwParameterVector[2] & ~MB_SERVICE_NOTIFICATION;
            if (phemsg->NumberOfParameters == 4) {
                dwTimeout = (DWORD)adwParameterVector[3];
            } else {
                dwTimeout = INFINITE;
            }
            goto CleanUpAndSaveParams;

        case STATUS_VDM_HARD_ERROR:
            /*
             * Parameters[0] = (fForWOW << 16) | wBtn1;
             * Parameters[1] = (wBtn2   << 16) | wBtn3;
             * Parameters[2] = (DWORD) szTitle;
             * Parameters[3] = (DWORD) szMessage;
             */
            phi->dwHEIFFlags |= HEIF_VDMERROR;
            /*
             * Save VDM's Button(s) info to be used later.
             */
            phi->dwVDMParam0 = (DWORD)adwParameterVector[0];
            phi->dwVDMParam1 = (DWORD)adwParameterVector[1];
            /*
             * Get caption and text.
             */
            try {
                if (phemsg->UnicodeStringParameterMask & 0x4) {
                    RtlInitUnicodeString(&usCaption, (PWSTR)adwParameterVector[2]);
                } else {
                    MBToWCS((LPSTR)adwParameterVector[2], -1, &pwszTitle, -1, TRUE);
                    RtlCreateUnicodeString(&usCaption, pwszTitle);
                    RtlFreeHeap(RtlProcessHeap(), 0, pwszTitle);
                }

                if (phemsg->UnicodeStringParameterMask & 0x8) {
                    RtlInitUnicodeString(&usMessage, (PWSTR)adwParameterVector[3]);
                } else {
                    MBToWCS((LPSTR)adwParameterVector[3], -1, &pwszMsg, -1, TRUE);
                    RtlCreateUnicodeString(&usMessage, pwszMsg);
                    RtlFreeHeap(RtlProcessHeap(), 0, pwszMsg);
                }


            } except (EXCEPTION_EXECUTE_HANDLER) {

                RIPMSG0(RIP_WARNING, "Exception reading STATUS_VDM_HARD_ERROR paramerters");

                RtlFreeUnicodeString(&usCaption);
                RtlCreateUnicodeString(&usCaption, L"VDM Internal Error");
                RtlFreeUnicodeString(&usMessage);
                RtlCreateUnicodeString(&usMessage, L"Exception retrieving error text.");
            }
            goto CleanUpAndSaveParams;
    }

    /*
     * For all other status codes, we generate the information from the status code.
     * First, Map status code and valid response to MessageBox flags.
     */
    dwMBFlags |= wIcons[(ULONG)(phemsg->Status) >> 30] | wOptions[phemsg->ValidResponseOptions];


    /*
     * If we have a client process, try to get the actual application name
     */
    pwszAppName = NULL;
    if (!fErrorIsFromSystem) {
        PPEB Peb;
        PROCESS_BASIC_INFORMATION BasicInfo;
        PLDR_DATA_TABLE_ENTRY LdrEntry;
        LDR_DATA_TABLE_ENTRY LdrEntryData;
        PLIST_ENTRY LdrHead, LdrNext;
        PPEB_LDR_DATA Ldr;
        PVOID ImageBaseAddress;
        PWSTR ClientApplicationName;

        /*
         * This is cumbersome, but basically, we locate the processes
         * loader data table and get it's name directly out of the
         * loader table
         */

        Status = NtQueryInformationProcess(hClientProcess, ProcessBasicInformation,
                    &BasicInfo, sizeof(BasicInfo), NULL);

        if (!NT_SUCCESS(Status)) {
            fErrorIsFromSystem = TRUE;
            goto noname;
        }

        Peb = BasicInfo.PebBaseAddress;
        if (Peb == NULL) {
            fErrorIsFromSystem = TRUE;
            goto noname;
        }

        /*
         * ldr = Peb->Ldr
         */
        Status = NtReadVirtualMemory(hClientProcess, &Peb->Ldr, &Ldr,
                    sizeof(Ldr), NULL);

        if (!NT_SUCCESS(Status)) {
            goto noname;
        }

        LdrHead = &Ldr->InLoadOrderModuleList;

        /*
         * LdrNext = Head->Flink;
         */
        Status = NtReadVirtualMemory(hClientProcess, &LdrHead->Flink,
                    &LdrNext, sizeof(LdrNext), NULL );

        if (!NT_SUCCESS(Status)) {
            goto noname;
        }

        if (LdrNext == LdrHead) {
            goto noname;
        }
        /*
         * This is the entry data for the image.
         */
        LdrEntry = CONTAINING_RECORD(LdrNext, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        Status = NtReadVirtualMemory(hClientProcess, LdrEntry,
                    &LdrEntryData, sizeof(LdrEntryData), NULL);

        if (!NT_SUCCESS(Status)) {
            goto noname;
        }

        Status = NtReadVirtualMemory(hClientProcess, &Peb->ImageBaseAddress,
                    &ImageBaseAddress, sizeof(ImageBaseAddress), NULL);

        if (!NT_SUCCESS(Status)) {
            goto noname;
        }

        if (ImageBaseAddress != LdrEntryData.DllBase) {
            goto noname;
        }

        LdrNext = LdrEntryData.InLoadOrderLinks.Flink;

        ClientApplicationName = (PWSTR)LocalAlloc(LMEM_ZEROINIT, LdrEntryData.BaseDllName.MaximumLength);
        if (ClientApplicationName == NULL) {
            goto noname;
        }

        Status = NtReadVirtualMemory(hClientProcess, LdrEntryData.BaseDllName.Buffer,
                    ClientApplicationName, LdrEntryData.BaseDllName.MaximumLength,
                    NULL);

        if (!NT_SUCCESS(Status)) {
            LocalFree(ClientApplicationName);
            goto noname;
        }

        pwszAppName = ClientApplicationName;
        fFreeAppNameBuffer = TRUE;

noname:;
    } /* if (!fErrorIsFromSystem) */

    if (pwszAppName == NULL) {
        /*
         * Load default application name (to be used in the caption).
         */
        pwszAppName = ServerLoadString(ghModuleWin, STR_UNKNOWN_APPLICATION,
                                        L"System Process", &fFreeAppNameBuffer);
    }

    /*
     * Map status code to (optional) caption and format string.
     * If a caption is provided, it's enclosed in {} and it's
     *  the first thing in the format string
     */
    EnterCrit();
    if (gNtDllHandle == NULL) {
        gNtDllHandle = GetModuleHandle(TEXT("ntdll"));
        UserAssert(gNtDllHandle != NULL);
    }
    LeaveCrit();

    Status = RtlFindMessage((PVOID)gNtDllHandle, (ULONG_PTR)RT_MESSAGETABLE,
                            LANG_NEUTRAL, phemsg->Status, &MessageEntry);

    //
    // This is a HACK.	Due to localization concerns we can't put the
    // hard error message for our EA recovery into ntdll.dll.  So
    // instead we have to retrieve the message from xpsp1res.dll.
    //

    if (!NT_SUCCESS(Status) && (phemsg->Status == 0xC0000415)) {

	HINSTANCE hSp1Res = LoadLibraryEx(TEXT("xpsp1res.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (hSp1Res) {

	    MessageEntry = LocalAlloc(LPTR, sizeof(MESSAGE_RESOURCE_ENTRY) + 1024 * sizeof(WCHAR));

	    if (MessageEntry) {
		LoadString(hSp1Res, IDS_SAVEDUMP_HEADER_MSG, (PWSTR)&MessageEntry->Text, 1024);

		MessageEntry->Length = (USHORT)wcslen((PWSTR)&MessageEntry->Text);
		MessageEntry->Flags = 0;

		bMustFreeMessageEntry = TRUE;
		Status = STATUS_SUCCESS;
	    }

	    FreeLibrary(hSp1Res);
	}
    }

    /*
     * Parse the caption (if any) and the format string.
     */
    pwszCaption = NULL;
    if (!NT_SUCCESS(Status)) {
        pwszFormatString = wszUnknownHardError;
    } else {
        pwszFormatString = (PWSTR)MessageEntry->Text;
        /*
         * If the message starts with a '{', it has a caption.
         */
        if (*pwszFormatString == L'{') {
            uCaptionLen = 0;
            pwszFormatString++;
            /*
             * Find the closing bracket
             */
            while ((*pwszFormatString != (WCHAR)0) && (*pwszFormatString++ != L'}')) {
                uCaptionLen++;
            }
            /*
             * Eat any non-printable stuff (\r\n), up to the NULL
             */
            while ((*pwszFormatString != (WCHAR)0) && (*pwszFormatString <= L' ')) {
                pwszFormatString++;
            }
            /*
             * Allocate a buffer an copy the caption string
             */
            if ((uCaptionLen++ > 0)
                && ((pwszCaption = (PWSTR)LocalAlloc(LPTR, uCaptionLen * sizeof(WCHAR))) != NULL)) {

                RtlCopyMemory(pwszCaption, (PWSTR)MessageEntry->Text + 1, (uCaptionLen - 1) * sizeof(WCHAR));
                fFreeCaption = TRUE;
            }
        } /* if (*pszParsedCaption == '{') */

        if (*pwszFormatString == (WCHAR)0) {
            pwszFormatString = wszUnknownHardError;
        }
    } /* if (!NT_SUCCESS(Status))  (Failed to read caption/format string) */


    /*
     * If the message didn't include a caption (or we didn't find the message),
     *  default to something
     */
    if (pwszCaption == NULL) {
        switch (phemsg->Status & ERROR_SEVERITY_ERROR) {
            case ERROR_SEVERITY_SUCCESS:
                pwszCaption = gpwszaSUCCESS;
                break;
            case ERROR_SEVERITY_INFORMATIONAL:
                pwszCaption = gpwszaSYSTEM_INFORMATION;
                break;
            case ERROR_SEVERITY_WARNING:
                pwszCaption = gpwszaSYSTEM_WARNING;
                break;
            case ERROR_SEVERITY_ERROR:
                pwszCaption = gpwszaSYSTEM_ERROR;
                break;
        }
    }
    UserAssert(pwszCaption != NULL);
    /*
     * If the client has a window, get its title so it can be added to
     *  the caption.
     */
    hwndOwner = NULL;
    EnumThreadWindows(HandleToUlong(phemsg->h.ClientId.UniqueThread),
                        FindWindowFromThread, (LPARAM)&hwndOwner);
    if (hwndOwner == NULL) {
        uTitleLen = 0;
    } else {
        uTitleLen = GetWindowTextLength(hwndOwner);
        if (uTitleLen != 0) {
            pwszTitle = (PWSTR)LocalAlloc(LPTR, (uTitleLen + 3) * sizeof(WCHAR));
            if (pwszTitle != NULL) {
                GetWindowText(hwndOwner, pwszTitle, uTitleLen + 1);
                /*
                 * Add format chars.
                 */
                *(pwszTitle + uTitleLen++) = (WCHAR)':';
                *(pwszTitle + uTitleLen++) = (WCHAR)' ';
            } else {
                /*
                 * We couldn't allocate a buffer to get the title
                 */
                uTitleLen = 0;
            }
        } /* if (uTitleLen != 0) */
    } /* else if (hwndOwner == NULL) */
    /*
     * If we don't have a window title, make it an empty string so we won't
     *  have to special case it later.
     */
    if (uTitleLen == 0) {
        pwszTitle = L"";
    }
    /*
     * Finally we can build the caption string now.
     * It looks like this: [WindowTile: ]ApplicationName - ErrorCaption
     */
    uCaptionLen = uTitleLen + wcslen(pwszAppName) + 3 + wcslen(pwszCaption) + 1;
    pwszFullCaption = (PWSTR)LocalAlloc(LPTR, uCaptionLen * sizeof(WCHAR));
    if (pwszFullCaption != NULL) {
        #if DBG
        int iLen =
        #endif
            wsprintfW(pwszFullCaption, L"%s%s - %s", pwszTitle, pwszAppName, pwszCaption);
        UserAssert((UINT)iLen < uCaptionLen);
        RtlCreateUnicodeString(&usCaption, pwszFullCaption);
        LocalFree(pwszFullCaption);
    }
    /*
     * Free caption working buffers, as appropriate.
     */
    if (fFreeCaption) {
        LocalFree(pwszCaption);
    }
    if (fFreeAppNameBuffer) {
        LocalFree(pwszAppName);
    }
    if (uTitleLen != 0) {
        LocalFree(pwszTitle);
    }
    /*
     * Build the error message using pszFormatString and adwParameterVector.
     * Special case UAE
     */
    if (phemsg->Status == STATUS_UNHANDLED_EXCEPTION ) {
        /*
         * The first parameter has the exception status code. Map it to a
         *  format string and build the error message with it and the
         *  parameters.
         */
        Status = RtlFindMessage( (PVOID)gNtDllHandle, (ULONG_PTR)RT_MESSAGETABLE,
                                 LANG_NEUTRAL, (ULONG)adwParameterVector[0], &MessageEntry);

        if (!NT_SUCCESS(Status)) {
            /*
             * We couldn't read the exception name so let's use unknown.
             */
            pwszResBuffer = ServerLoadString(ghModuleWin, STR_UNKNOWN_EXCEPTION,
                            wszUnkownSoftwareException, &fResAllocated);

            wsprintfW(wszErrorMessage, pwszFormatString, pwszResBuffer,
                      adwParameterVector[0], adwParameterVector[1]);

            if (fResAllocated) {
                LocalFree(pwszResBuffer);
            }

            RtlCreateUnicodeString(&usMessage, wszErrorMessage);
            UserAssert(usMessage.MaximumLength <= sizeof(wszErrorMessage));

        } else {
            /*
             * Access Violations are handled a bit differently
             */

            if (adwParameterVector[0] == STATUS_ACCESS_VIOLATION ) {

                wsprintfW(wszErrorMessage, (PWSTR)MessageEntry->Text, adwParameterVector[1],
                          adwParameterVector[3], adwParameterVector[2] ? L"written" : L"read");

            } else if (adwParameterVector[0] == STATUS_IN_PAGE_ERROR) {
                wsprintfW(wszErrorMessage, (PWSTR)MessageEntry->Text, adwParameterVector[1],
                          adwParameterVector[3], adwParameterVector[2]);

            } else {
                /*
                 * If this is a marked exception, skip the mark;
                 *  the exception name follows it.
                 */
                pwszCaption = (PWSTR)MessageEntry->Text;
                if (!wcsncmp(pwszCaption, wszException, ARRAY_SIZE(wszException) - 1)) {
                    pwszCaption += ARRAY_SIZE(wszException) - 1;
                    /*
                     * Skip not printable stuff (\r\n)
                     */
                    while ((*pwszCaption != (WCHAR)0) && (*pwszCaption <= L' ')) {
                        pwszCaption++;
                    }

                } else {
                    pwszCaption = wszUnkownSoftwareException;
                }

                wsprintfW(wszErrorMessage, pwszFormatString, pwszCaption,
                          adwParameterVector[0], adwParameterVector[1]);
            }

            UserAssert(wcslen(wszErrorMessage) < ARRAY_SIZE(wszErrorMessage));

            /*
             * Add button(s) explanation text.
             */
            pwszResBuffer = ServerLoadString(ghModuleWin, STR_OK_TO_TERMINATE,
                            L"Click on OK to terminate the application",
                            &fResAllocated);


            if (phemsg->ValidResponseOptions == OptionOkCancel ) {
                pwszResBuffer1 = ServerLoadString(ghModuleWin,
                                STR_CANCEL_TO_DEBUG, L"Click on CANCEL xx to debug the application",
                                &fResAllocated1);
            } else {
                pwszResBuffer1 = NULL;
                fResAllocated1 = FALSE;
            }

            /*
             * Conncatenate all strings, one per line.
             */
            uMsgLen = wcslen(wszErrorMessage)
                        + wcslen(pwszResBuffer) + 1
                        + (pwszResBuffer1 == NULL ? 0 : wcslen(pwszResBuffer1) + 1)
                        + 1;

            pwszMsg = (PWSTR) LocalAlloc(LPTR, uMsgLen * sizeof(WCHAR));
            if (pwszMsg != NULL) {
                #if DBG
                int iLen =
                #endif
                    wsprintfW(pwszMsg, L"%s\n%s%s%s", wszErrorMessage, pwszResBuffer,
                              (pwszResBuffer1 == NULL ? L"" : L"\n"),
                              (pwszResBuffer1 == NULL ? L"" : pwszResBuffer1));

                UserAssert((UINT)iLen < uMsgLen);

                RtlCreateUnicodeString(&usMessage, pwszMsg);
                LocalFree(pwszMsg);
            }

            /*
             * Free ServerLoadString allocations.
             */
            if (fResAllocated) {
                LocalFree(pwszResBuffer);
            }

            if (fResAllocated1) {
                LocalFree(pwszResBuffer1);
            }


        }

    } else {
        /*
         * Default message text generation for all other status codes
         */
        try {
            #if DBG
            int iLen =
            #endif
                wsprintfW(wszErrorMessage, pwszFormatString, adwParameterVector[0],
                                              adwParameterVector[1],
                                              adwParameterVector[2],
                                              adwParameterVector[3]);
            UserAssert((UINT)iLen <  ARRAY_SIZE(wszErrorMessage));

            /*
             * Remove \r\n
             */
            pwszFormatString = wszErrorMessage;
            while (*pwszFormatString != (WCHAR)0) {
                if (*pwszFormatString == (WCHAR)0xd) {
                    *pwszFormatString = L' ';
                    /*
                     * Move everything up if a CR LF sequence is found
                     */
                    if (*(pwszFormatString+1) == (WCHAR)0xa) {
                        UINT uSize = (wcslen(pwszFormatString+1) + 1) * sizeof(WCHAR);
                        RtlMoveMemory(pwszFormatString, pwszFormatString+1, uSize);
                    }
                 }

                if (*pwszFormatString == (WCHAR)0xa) {
                    *pwszFormatString = L' ';
                }

                pwszFormatString++;
            }

            RtlCreateUnicodeString(&usMessage, wszErrorMessage);
            UserAssert(usMessage.MaximumLength <= sizeof(wszErrorMessage));
        } except(EXCEPTION_EXECUTE_HANDLER) {

            wsprintfW(wszErrorMessage, L"Exception Processing Message %lx Parameters %lx %lx %lx %lx",
                      phemsg->Status, adwParameterVector[0], adwParameterVector[1],
                      adwParameterVector[2], adwParameterVector[3]);

            RtlFreeUnicodeString(&usMessage);
            RtlCreateUnicodeString(&usMessage, wszErrorMessage);
            UserAssert(usMessage.MaximumLength <= sizeof(wszErrorMessage));

        } /* try */

    } /* else if (phemsg->Status == STATUS_UNHANDLED_EXCEPTION) */


CleanUpAndSaveParams:
     if (hClientProcess != NULL) {
         NtClose(hClientProcess);
     }
    /*
     * Free string parameters.
     * Note that we're supposed to call RtlFreeAnsiString since these were
     *  allocated by RtlUnicodeStringToAnsiString.... but we only saved the buffers...
     */
    if (dwStringsToFreeMask != 0) {
        for (dwCounter = 0; dwCounter < phemsg->NumberOfParameters; dwCounter++) {
            if (dwStringsToFreeMask & (1 << dwCounter)) {
                RtlFreeHeap(RtlProcessHeap(), 0, (PVOID)adwParameterVector[dwCounter]);
            }
        }
    }
    /*
     * Save MessageBox Parameters in phi to be used and freed later.
     */
    if (fErrorIsFromSystem) {
        phi->dwHEIFFlags |= HEIF_SYSTEMERROR;
    }

    //
    // If we needed to allocate our own MessageEntry free it here.
    //

    if (bMustFreeMessageEntry) {
	LocalFree(MessageEntry);
    }

    phi->usText = usMessage;
    phi->usCaption = usCaption;
    phi->dwMBFlags = dwMBFlags;
    phi->dwTimeout = dwTimeout;
}

/***************************************************************************\
* CheckShellHardError
*
* This function tries to send the hard error to the HardErrorHandler window
* to see if we can avoid handling it here.  If so, we avoid handling it.
*
* History:
* 03-29-01 BobDay   Added
\***************************************************************************/
BOOL CheckShellHardError(PHARDERRORINFO phi, int *pidResponse)
{
    HANDLE hKey;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES OA;
    LONG Status;
    BYTE Buf[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    DWORD cbSize;
    DWORD dwShellErrorMode = 0;
    BOOL fHandledThisMessage = FALSE;
    HWND hwndTaskman;

    // Shell can handle only the non-waiting case
    if (!(phi->dwHEIFFlags & HEIF_NOWAIT))
    {
        return FALSE;
    }

    RtlInitUnicodeString(&UnicodeString,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Windows");
    InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtOpenKey(&hKey, KEY_READ, &OA);
    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&UnicodeString, L"ShellErrorMode");
        Status = NtQueryValueKey(hKey,
                &UnicodeString,
                KeyValuePartialInformation,
                (PKEY_VALUE_PARTIAL_INFORMATION)Buf,
                sizeof(Buf),
                &cbSize);
        if (NT_SUCCESS(Status)) {
            dwShellErrorMode = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)Buf)->Data);
        }
        NtClose(hKey);
    }

    if (dwShellErrorMode != 1)            // 1 = try shell ("HardErrorHandler" window)
    {
        return FALSE;
    }

    hwndTaskman = GetTaskmanWindow();

    if (NULL != hwndTaskman)
    {
        BYTE *lpData;
        UINT cbTitle = 0;
        UINT cbText = 0;
        UINT cbData;

        // build up a copy data buffer to send to the hard error handler window
        cbTitle = phi->usCaption.Length + sizeof(WCHAR);
        cbText = phi->usText.Length + sizeof(WCHAR);
        cbData = sizeof(HARDERRORDATA) + cbTitle + cbText;
        lpData = (BYTE *)LocalAlloc(LPTR,cbData);
        if (lpData)
        {
            COPYDATASTRUCT cd;
            PHARDERRORDATA phed = (PHARDERRORDATA)lpData;
            PWSTR pwszTitle = (PWSTR)(phed + 1);
            PWSTR pwszText = (WCHAR *)((BYTE *)pwszTitle + cbTitle);
            LRESULT lResult;
            BOOL fSentMessage;

            cd.dwData = RegisterWindowMessage(TEXT(COPYDATA_HARDERROR));
            cd.cbData = cbData;
            cd.lpData = lpData;

            phed->dwSize = sizeof(HARDERRORDATA);
            phed->dwError = phi->pmsg->Status;
            phed->dwFlags = phi->dwMBFlags;
            phed->uOffsetTitleW = 0;
            phed->uOffsetTextW = 0;

            if (cbTitle != 0) {
                phed->uOffsetTitleW = (UINT)((BYTE *)pwszTitle - (BYTE *)phed);
                RtlCopyMemory(pwszTitle, phi->usCaption.Buffer, cbTitle);
            }
            if (cbText != 0) {
                phed->uOffsetTextW = (UINT)((BYTE *)pwszText - (BYTE *)phed);
                RtlCopyMemory(pwszText, phi->usText.Buffer, cbText);
            }

            // send the message.  If the app doesn't respond in a short
            // amount of time, blow it off and assume its unhandled.
            lResult = 0;
            fSentMessage = (BOOL)SendMessageTimeout(hwndTaskman, WM_COPYDATA, (WPARAM)NULL, (LPARAM)&cd, SMTO_ABORTIFHUNG, 3000, &lResult);

            // has to both be handled, and return non-zero
            if (fSentMessage && lResult != 0)
            {
                fHandledThisMessage = TRUE;
                *pidResponse = IDOK;
            }

            LocalFree(lpData);
        }
    }
    return fHandledThisMessage;
}

/***************************************************************************\
* HardErrorHandler
*
* This routine processes hard error requests from the CSR exception port
*
* History:
* 07-03-91 JimA             Created.
\***************************************************************************/
VOID HardErrorHandler(void)
{
    int idResponse;
    PHARDERRORINFO phi, *pphi;
    DWORD dwResponse;
    DESKRESTOREDATA drdRestore;
    BOOL fNuked;
    UINT uHECRet;
    DWORD dwCmd;
    HANDLE hThread;
    int aidButton[3], cButtons;
    LPWSTR apstrButton[3];
    MSGBOXDATA mbd;
    BOOL bDoBlock;
    PCTXHARDERRORINFO pCtxHEInfo = NULL;
    MSG msg;

#if DBG
    /*
     * We should have only one error handler at the time.
     */
    static long glReentered = -1;
    UserAssert(InterlockedIncrement(&glReentered) == 0);
#endif

    if (ISTS()) {
        bDoBlock = (gbExitInProgress || (HEC_ERROR == NtUserHardErrorControl(HardErrorSetup, NULL, NULL)));
    } else {
        bDoBlock = (HEC_ERROR == NtUserHardErrorControl(HardErrorSetup, NULL, NULL));
    }

    drdRestore.pdeskRestore = NULL;

    if (bDoBlock) {
        /*
         * We failed to set up to process hard errors.  Acknowledge all
         * pending errors as NotHandled.
         */
        EnterCrit();
        while (gphiList != NULL) {
            phi = gphiList;
            gphiList = phi->phiNext;
            LeaveCrit();
            ReplyHardError(phi, ResponseNotHandled);
            EnterCrit();
        }
        UserAssert(InterlockedDecrement(&glReentered) < 0);
        UserAssert(gdwHardErrorThreadId == HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread));
        gdwHardErrorThreadId = 0;
        LeaveCrit();
        return;
    }

    /*
     * Process all hard error requests.
     */

    for (;;) {
        /*
         * Grab the next request (for the current desktop)
         * If we're done, reset gdwHardErrorThreadId so any request
         *  after this point will be handled by someone else
         */
        EnterCrit();
        phi = gphiList;
        if (phi == NULL) {
            UserAssert(InterlockedDecrement(&glReentered) < 0);
            UserAssert(gdwHardErrorThreadId == HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread));
            gdwHardErrorThreadId = 0;
        } else {
            while ((phi != NULL) && (phi->dwHEIFFlags & HEIF_WRONGDESKTOP)) {
                phi = phi->phiNext;
            }
            if (phi != NULL) {
                /*
                 * We're going to show this one.
                 */
                phi->dwHEIFFlags |= HEIF_ACTIVE;
            } else {
                /*
                 * We have some requests pending but they are not
                 *  for the current desktop. Let's wait for another
                 *  request (WM_NULL posted) or a desktop switch (PostQuitMessage)
                 */
                LeaveCrit();
                MsgWaitForMultipleObjects(0, NULL, FALSE, INFINITE, QS_POSTMESSAGE);
                PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);
                CheckDefaultDesktop();
                continue;
            }
        }
        LeaveCrit();
        /*
         * If no messages are pending, we're done.
         */
        if (phi == NULL) {
            NtUserHardErrorControl(HardErrorCleanup, NULL, NULL);
            return;
        }

        /*
         * The Boost routine can mess with the list, so must get citrix info now.
         */
        if (ISTS()) {
            pCtxHEInfo = phi->pCtxHEInfo;
            if (gbExitInProgress) {
                dwResponse = ResponseOk;
                goto Reply;
            }
        }

        /*
         * Get win32k attach parameters.
         */
        dwCmd = (phi->dwMBFlags & MB_DEFAULT_DESKTOP_ONLY) ? HardErrorAttachUser : HardErrorAttach;
        hThread = (phi->pthread != NULL) ? phi->pthread->ThreadHandle : NULL;
        /*
         * We have already handled the MB_SERVICE_NOTIFICATION flags.
         * Clear it to prevent recursion.
         * Also, don't let hard error boxes steal the foreground
         */
        phi->dwMBFlags &= ~(MB_SERVICE_NOTIFICATION | MB_SETFOREGROUND | MB_SYSTEMMODAL);
        /*
         * If this is a VDM error, figure out buttons, default id, style, etc
         */
        if (phi->dwHEIFFlags & HEIF_VDMERROR) {
            int i;
            WORD rgwBtn[3], wBtn;
            /*
             * Initialize MSGBOXDATA with the information we
             *  have already figured out.
             */
            RtlZeroMemory(&mbd, sizeof(MSGBOXDATA));
            mbd.cbSize = sizeof(MSGBOXPARAMS);
            mbd.lpszText = phi->usText.Buffer;
            mbd.lpszCaption = phi->usCaption.Buffer;
            mbd.dwTimeout = INFINITE;

            /*
             * phi->dwVDMParam0 = (fForWOW << 16) | wBtn1;
             * phi->dwVDMParam1 = (wBtn2   << 16) | wBtn3;
             * Right now, only WOW does this.  If NTVDM does it,
             * fForWOW will be false.
             */
            rgwBtn[0] = LOWORD(phi->dwVDMParam0);
            rgwBtn[1] = HIWORD(phi->dwVDMParam1);
            rgwBtn[2] = LOWORD(phi->dwVDMParam1);
            cButtons = 0;
            for (i = 0; i < 3; i++) {
                wBtn = rgwBtn[i] & ~SEB_DEFBUTTON;
                if (wBtn && wBtn <= MAX_SEB_STYLES) {
                    apstrButton[cButtons] = MB_GetString(wBtn-1);
                    aidButton[cButtons] = i + 1;
                    if (rgwBtn[i] & SEB_DEFBUTTON) {
                        mbd.DefButton = cButtons;
                    }
                    if (wBtn == SEB_CANCEL) {
                        mbd.CancelId = cButtons;
                    }
                    cButtons++;
                }
            }
            mbd.dwStyle = MB_TOPMOST;
            if ((cButtons != 1) || (aidButton[0] != 1)) {
                mbd.dwStyle |= MB_OKCANCEL;
            }
            mbd.ppszButtonText = apstrButton;
            mbd.pidButton = aidButton;
            mbd.cButtons = cButtons;
        }
        /*
         * Attach to win32k and show the dialog.
         * If we switch desktops, (loop and) show it on the new desktop (if applicable)
         */
        do {
            phi->pmsg->Response = ResponseNotHandled;

            uHECRet = NtUserHardErrorControl(dwCmd, hThread, &drdRestore);

            if (uHECRet == HEC_SUCCESS) {
                if (phi->dwHEIFFlags & HEIF_VDMERROR) {
                    idResponse = SoftModalMessageBox(&mbd);
                } else {
                    /*
                     * Bring up the message box. Or in MB_TOPMOST so
                     * it comes up on top.
                     * We want to preserve the MB_DEFAULT_DESKTOP_ONLY flag
                     *  but don't want to pass it to MessageBox or we'll
                     *  recurse due to a compatibility hack
                     */

                    if (CheckShellHardError(phi, &idResponse) == FALSE) {
                        DWORD dwTimeout;
                        if (pCtxHEInfo && pCtxHEInfo->Timeout != 0 && pCtxHEInfo->Timeout != -1) {
                            dwTimeout = pCtxHEInfo->Timeout * 1000;
                        } else {
                            dwTimeout = phi->dwTimeout;
                        }
                        idResponse = MessageBoxTimeout(NULL, phi->usText.Buffer, phi->usCaption.Buffer,
                            (phi->dwMBFlags | MB_TOPMOST) & ~MB_DEFAULT_DESKTOP_ONLY, 0, dwTimeout);
                    }
                }
                /*
                 * Restore hard error handler desktop; this will also
                 *  tell us if the input desktop has changed; if so,
                 *  we want to bring the error box again on the new
                 *  desktop.
                 */
                uHECRet = NtUserHardErrorControl(HardErrorDetach, NULL, &drdRestore);

                if (ISTS()) {
                    /*
                     * Really a citrix message.
                     */
                    if (uHECRet != HEC_DESKTOPSWITCH && pCtxHEInfo != NULL) {
                        pCtxHEInfo->Response = idResponse;

                        /*
                         * Check for message box timeout.
                         */
                        if (idResponse == IDTIMEOUT) {
                            uHECRet = HEC_SUCCESS;
                        }
                    }

                    if (idResponse == IDTIMEOUT) {
                        idResponse = ResponseNotHandled;
                    }

                    if (dwResponses[idResponse] == ResponseNotHandled &&
                        uHECRet == HEC_DESKTOPSWITCH && gSessionId == 0) {

                        RIPMSG2(RIP_WARNING, "HardErrorHandler: abort harderror, idResponse %u, uHECRet %u",
                                    idResponse, uHECRet);

                        break;
                    }
                } else if (idResponse == IDTIMEOUT) {
                    idResponse = ResponseNotHandled;
                }
            } else {
                idResponse = ResponseNotHandled;
            }

            UserAssert((UINT)idResponse < ARRAY_SIZE(dwResponses));
            dwResponse = dwResponses[idResponse];

            /*
             * If we don't want to reshow this box, we're done.
             */
            if (uHECRet != HEC_DESKTOPSWITCH) {
                break;
            } else {
                /*
                 * We've switched desktops; if we're in the default one
                 *  now, then we can show all MB_DEFAULT_DESKTOP_ONLY
                 *  requests.
                 */
                CheckDefaultDesktop();
            }
            /*
             * If BoostHardError nuked it, don't re-show it
             */
            EnterCrit();
            fNuked = (phi->dwHEIFFlags & HEIF_NUKED);
            LeaveCrit();
        } while (!fNuked);

        /*
         * If we didn't show this box because we're not in the
         *  default desktop, mark this phi and continue
         */
        if (uHECRet == HEC_WRONGDESKTOP) {
            UserAssert(phi->dwMBFlags & MB_DEFAULT_DESKTOP_ONLY);
            EnterCrit();
            COPY_FLAG(phi->dwHEIFFlags, HEIF_WRONGDESKTOP, HEIF_ACTIVE | HEIF_WRONGDESKTOP);
            LeaveCrit();
            continue;
        }

Reply:
        /*
         * We're done with this phi.
         * Unlink it if BoostHardError haven't done so already;
         *  If unlinked, it is marked as nuked.
         */
        EnterCrit();
        UserAssert(phi->dwHEIFFlags & HEIF_ACTIVE);
        fNuked = (phi->dwHEIFFlags & HEIF_NUKED);
        if (!fNuked) {
            pphi = &gphiList;
            while ((*pphi != phi) && (*pphi != NULL)) {
                pphi = &(*pphi)->phiNext;
            }
            UserAssert(*pphi != NULL);
            *pphi = phi->phiNext;
        }

#if DBG
         else {
            /*
             * Let's make sure it was unlinked.
             */
            pphi = &gphiList;
            while ((*pphi != phi) && (*pphi != NULL)) {
                UserAssert(!((*pphi)->dwHEIFFlags & (HEIF_ACTIVE | HEIF_NUKED)));
                pphi = &(*pphi)->phiNext;
            }
            UserAssert(*pphi == NULL);
         }
#endif

        if (phi->pCtxHEInfo) {

            /*
             * Clean up
             */
            HardErrorRemove(phi->pCtxHEInfo);

            /*
             * Done
             */
            phi->pCtxHEInfo = NULL;
        }

        LeaveCrit();

        /*
         * Save the response, reply and free phi
         */
        ReplyHardError(phi, (fNuked ? ResponseNotHandled : dwResponse));

    } /* for (;;) */

    /*
     * Nobody should break out of the loop.
     */
    UserAssert(FALSE);
}


LPWSTR RtlLoadStringOrError(
    HANDLE hModule,
    UINT wID,
    LPWSTR lpDefault,
    PBOOL pAllocated,
    BOOL bAnsi
    )
{
    LPTSTR lpsz;
    int cch;
    LPWSTR lpw;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    NTSTATUS Status;

    cch = 0;
    lpw = NULL;

    Status = RtlFindMessage((PVOID)hModule, (ULONG_PTR)RT_MESSAGETABLE,
            0, wID, &MessageEntry);
    if (NT_SUCCESS(Status)) {

        /*
         * Return two fewer chars so the crlf in the message will be
         * stripped out.
         */
        cch = wcslen((PWCHAR)MessageEntry->Text) - 2;
        lpsz = (LPWSTR)MessageEntry->Text;

        if (bAnsi) {
            int ich;

            /*
             * Add one to zero terminate then force the termination
             */
            ich = WCSToMB(lpsz, cch+1, (CHAR **)&lpw, -1, TRUE);
            if (lpw) {
                ((LPSTR)lpw)[ich-1] = 0;
                }
            }
        else {
            lpw = (LPWSTR)LocalAlloc(LMEM_ZEROINIT,(cch+1)*sizeof(WCHAR));
            if ( lpw ) {

                /*
                 * Copy the string into the buffer.
                 */
                    RtlCopyMemory(lpw, lpsz, cch*sizeof(WCHAR));
                }
            }
        }

    if ( !lpw ) {
        lpw = lpDefault;
        *pAllocated = FALSE;
        } else {
        *pAllocated = TRUE;
        }

    return lpw;
}

/***************************************************************************\
* HardErrorWorkerThread
*
* Worker thread to handle hard error requests.
*
* History:
* 05-01-98 JerrySh      Created.
\***************************************************************************/

NTSTATUS
HardErrorWorkerThread(
    PVOID ThreadParameter
    )
{
    PCSR_THREAD pt;
    UNREFERENCED_PARAMETER(ThreadParameter);

    pt = CsrConnectToUser();
    ProcessHardErrorRequest(FALSE);
    if (pt) {
        CsrDereferenceThread(pt);
    }
    UserExitWorkerThread(STATUS_SUCCESS);

    return STATUS_SUCCESS;
}

/***************************************************************************\
* ProcessHardErrorRequest
*
* Figures out who should process the hard error. There are 3 possible cases.
* - If there is already a hard error thread, hand it off to him.
* - If not and we don't want to wait, create a worker thread to deal with it.
* - If we want to wait or thread creation fails, deal with it ourselves.
*
* History:
* 05-01-98 JerrySh      Created.
\***************************************************************************/

VOID
ProcessHardErrorRequest(
    BOOL fNewThread
    )
{
    NTSTATUS Status;
    CLIENT_ID ClientId;
    HANDLE hThread;

    EnterCrit();

    /*
     * If there's already a hard error handler, make sure he's awake.
     */
    if (gdwHardErrorThreadId) {
        DWORD dwHardErrorHandler = gdwHardErrorThreadId;
        LeaveCrit();
        PostThreadMessage(dwHardErrorHandler, WM_NULL, 0, 0);
        return;
    }

    /*
     * Create a worker thread to handle the hard error.
     */
    if (fNewThread) {
        LeaveCrit();
        Status = RtlCreateUserThread(NtCurrentProcess(),
                                     NULL,
                                     TRUE,
                                     0,
                                     0,
                                     0,
                                     HardErrorWorkerThread,
                                     NULL,
                                     &hThread,
                                     &ClientId);
        if (NT_SUCCESS(Status)) {
            CsrAddStaticServerThread(hThread, &ClientId, 0);
            NtResumeThread(hThread, NULL);
            return;
        }
        EnterCrit();
    }

    /*
     * Let this thread handle the hard error.
     */
    gdwHardErrorThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);
    LeaveCrit();
    HardErrorHandler();
}

/***************************************************************************\
* UserHardError
*
* Called from CSR to pop up hard error messages
*
* History:
* 03/12/97 GerardoB         Rewritten to support OptionOkNoWait
* 07-03-91 JimA             Created.
\***************************************************************************/

VOID UserHardError(
    PCSR_THREAD pt,
    PHARDERROR_MSG pmsg)
{
    UserHardErrorEx(pt, pmsg, NULL);
}

VOID HardErrorInsert(
    PCSR_THREAD pt,
    PHARDERROR_MSG pmsg,
    PCTXHARDERRORINFO pCtxHEInfo)
{
    UserHardErrorEx(pt, pmsg, pCtxHEInfo);
}

/***************************************************************************\
* UserHardErrorEx
*
* Called from CSR to pop up hard error messages
*
* History:
* 07-03-91 JimA             Created.
\***************************************************************************/

VOID UserHardErrorEx(
    PCSR_THREAD pt,
    PHARDERROR_MSG pmsg,
    PCTXHARDERRORINFO pCtxHEInfo)
{
    BOOL fClientPort, fNoWait, fMsgBox, fLogEvent;
    PHARDERRORINFO phi = NULL, *pphiLast;
    HANDLE hEvent;
    DWORD dwReportMode, dwResponse;

    UserAssert((ULONG)pmsg->NumberOfParameters <= MAXIMUM_HARDERROR_PARAMETERS);
    /*
     * Allocate memory to queue request.
     */
    phi = (PHARDERRORINFO)LocalAlloc(LPTR, sizeof(HARDERRORINFO));
    if (phi == NULL) {
        goto ErrorExit;
    }
    phi->pthread = pt;

    /*
     * Set up citrix specific stuff
     */
    if (ISTS()) {
        phi->pCtxHEInfo = pCtxHEInfo;
    }

    /*
     * Determine reply type
     */
    fClientPort = ((pt != NULL) && (pt->Process->ClientPort != NULL));
    fNoWait = (pmsg->ValidResponseOptions == OptionOkNoWait);

    /*
     * Capture HARDERROR_MSG data or create wait event as needed
     */
    if (fClientPort || fNoWait) {
        phi->pmsg = (PHARDERROR_MSG)LocalAlloc(LPTR, pmsg->h.u1.s1.TotalLength);
        if (phi->pmsg == NULL) {
            goto ErrorExit;
        }
        phi->dwHEIFFlags |= HEIF_ALLOCATEDMSG;
        RtlCopyMemory(phi->pmsg, pmsg, pmsg->h.u1.s1.TotalLength);
        hEvent = NULL;
        /*
         * Set the magic response value (-1) to let CsrApiRequestThread know
         * that we'll take care of dereferencing and replying.
         */
        if (pt != NULL) {
            phi->dwHEIFFlags |= HEIF_DEREFTHREAD;
        }
        pmsg->Response = (ULONG)-1;
        if (fNoWait) {
            phi->dwHEIFFlags |= HEIF_NOWAIT;
            phi->pmsg->ValidResponseOptions = OptionOk;
        }
    } else {
        phi->pmsg = pmsg;
        /*
         * There is no reply port but we need to wait; create an event.
         */
        hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (hEvent == NULL) {
            goto ErrorExit;
        }
        phi->hEventHardError = hEvent;
    }

    /*
     * Build hard error title, message and flags. Then log the event.
     */
    GetHardErrorText(phi);

    /*
     * Reply now if we're not going to wait.
     */
    if (fNoWait) {
        phi->dwHEIFFlags |= HEIF_REPLIED;
        phi->pmsg->Response = ResponseOk;
        if (fClientPort) {
            NtReplyPort(pt->Process->ClientPort, (PPORT_MESSAGE)phi->pmsg);
        } else {
            /*
             * Must let CsrApiRequestThread reply since we don't have a port
             */
            pmsg->Response = ResponseOk;
            /*
             * If we have a thread, reference it because we're telling
             *  CsrApiRequestThread that we're done with it.
             */
            if (pt != NULL) {
                /*
                 * Later5.0 GerardoB. Let's stop to see how this happens.
                 */
                UserAssert(pt == NULL);
                CsrReferenceThread(pt);
            }
        }
    }

    /*
     * Register the event if we haven't done so already.
     * Since RegisterEventSource is supported by a service, we must not hold
     *  any locks while making this call. Hence we might have several threads
     *  registering the event simultaneously.
     */
    fLogEvent = (gEventSource != NULL);
    if (!fLogEvent) {
        HANDLE hEventSource;
        hEventSource = RegisterEventSourceW(NULL, L"Application Popup");
        /*
         * Save the first handle, deregister all others.
         */
        if (InterlockedCompareExchangePointer(&gEventSource, hEventSource, NULL) == NULL) {
            /*
             * This is the first handle. If valid, we can log events.
             */
            fLogEvent = (hEventSource != NULL);
        } else {
            /*
             * We had already saved another handle (so we can log events). Deregister this one.
             */
            if (hEventSource != NULL) {
                UserVerify(DeregisterEventSource(hEventSource));
            }
            fLogEvent = TRUE;
        }
    }

    dwReportMode = (fLogEvent ? GetErrorMode() : 0);
    if (fLogEvent) {
        LogErrorPopup(phi->usCaption.Buffer, phi->usText.Buffer);
    }

    /*
     * Determine if we need to display a message box.
     */
    if ((phi->pmsg->Status == STATUS_SERVICE_NOTIFICATION) || (dwReportMode == 0)) {
        fMsgBox = TRUE;
    } else if (phi->pmsg->Status == STATUS_VDM_HARD_ERROR) {
        fMsgBox = (dwReportMode == 1);
        if (!fMsgBox) {
            dwResponse = ResponseOk;
        }
    } else {
        fMsgBox = ((dwReportMode == 1) && !(phi->dwHEIFFlags & HEIF_SYSTEMERROR));
        if (!fMsgBox) {
            UserAssert((UINT)phi->pmsg->ValidResponseOptions < ARRAY_SIZE(dwResponseDefault));
            dwResponse = dwResponseDefault[phi->pmsg->ValidResponseOptions];
        }
    }
    /*
     * If we don't have to display a message box, we're done.
     */
    if (!fMsgBox) {
        goto DontNeedErrorHandler;
    }

    /*
     * We want to display a message box. Queue the request and go for it.
     */
    EnterCrit();
    /*
     * Never mind if the process has terminated. Got to check this holding the
     * critical section to make sure that no other thread makes it to BoostHardError
     * before we add this phi to the list.
     */
    if ((pt != NULL) && (pt->Process->Flags & CSR_PROCESS_TERMINATED)) {
        LeaveCrit();
DontNeedErrorHandler:
        ReplyHardError(phi, dwResponse);
        if (hEvent != NULL) {
            NtClose(hEvent);
        }
        return;
    }
    /*
     * Add it to the end of the list.
     */
    pphiLast = &gphiList;
    while (*pphiLast != NULL) {
        pphiLast = &(*pphiLast)->phiNext;
    }
    *pphiLast = phi;
    LeaveCrit();

    /*
     * Process the hard error request. If this is a NoWait request and there
     * is no reply port, then we'll try to launch a new worker thread so this
     * one can return.
     */
    ProcessHardErrorRequest(fNoWait && !fClientPort);

    /*
     * If there is an event handle, wait for it.
     */
    if (hEvent != NULL) {
        NtWaitForSingleObject(hEvent, FALSE, NULL);
        NtClose(hEvent);
    }
    return;

ErrorExit:
    if (phi != NULL) {
        FreePhi(phi);
    }
    pmsg->Response = ResponseNotHandled;
}

/***************************************************************************\
* BoostHardError
*
* If one or more hard errors exist for the specified process, remove
* them from the list if forced, otherwise bring the first one to the
* top of the hard error list and display it.  Return TRUE if there
* is a hard error.
*
* History:
* 11-02-91 JimA             Created.
\***************************************************************************/

BOOL BoostHardError(
    ULONG_PTR dwProcessId,
    DWORD dwCode)
{
    DESKRESTOREDATA drdRestore;
    PHARDERRORINFO phi, *pphi;
    BOOL fHasError = FALSE;

    EnterCrit();
    /*
     * If the list is empty, nothing do to here.
     */
    if (gphiList == NULL) {
        LeaveCrit();
        return FALSE;
    }
    drdRestore.pdeskRestore = NULL;
    /*
     * Walk the hard error list
     */
    pphi = &gphiList;
    while (*pphi != NULL) {
        /*
         * If not not nuking all and not owned by dwProcessId, continue walking
         */
        if (dwProcessId != (ULONG_PTR)-1) {
            if (((*pphi)->pthread == NULL)
                    || ((ULONG_PTR)((*pphi)->pthread->ClientId.UniqueProcess) != dwProcessId)) {

                pphi = &(*pphi)->phiNext;
                continue;
            }
        } else {
            UserAssert(dwCode == BHE_FORCE);
        }
        /*
         * Got one so we want to return TRUE
         */
        fHasError = TRUE;
        /*
         * If nuking the request
         */
        if (dwCode == BHE_FORCE) {
            /*
             * Unlink it from the list.
             */
            phi = *pphi;
            *pphi = phi->phiNext;

            /*
             * If this box is being shown right now, signal it to go away.
             * Otherwise, nuke it
             */
            if (phi->dwHEIFFlags & HEIF_ACTIVE) {
                DWORD dwHardErrorHandler = gdwHardErrorThreadId;
                phi->dwHEIFFlags |= HEIF_NUKED;
                LeaveCrit();
                PostThreadMessage(dwHardErrorHandler, WM_QUIT, 0, 0);
            } else {
                /*
                 * Acknowledge the error as not handled, reply and free
                 */
                LeaveCrit();
                ReplyHardError(phi, ResponseNotHandled);
            }

            /*
             * Restart the search because we left the crit sect.
             */
            EnterCrit();
            pphi = &gphiList;

            /* continue */

        } else if (dwCode == BHE_ACTIVATE) {
            /*
             * If it's active, find it and show it.
             */
            phi = *pphi;
            if (phi->dwHEIFFlags & HEIF_ACTIVE) {
                HWND hwndError = NULL;
                DWORD dwHardErrorHandler = gdwHardErrorThreadId;

                LeaveCrit();
                EnumThreadWindows(dwHardErrorHandler, FindWindowFromThread, (LPARAM)&hwndError);

                if ((hwndError != NULL)
                        && (HEC_SUCCESS == NtUserHardErrorControl(HardErrorAttachNoQueue, NULL, &drdRestore))) {

                    SetForegroundWindow(hwndError);

                    NtUserHardErrorControl(HardErrorDetachNoQueue, NULL, &drdRestore);
                }
                return TRUE;
            }

            /*
             * It's not active so move it to the head of the list
             *  to make it show up next.
             */
            *pphi = phi->phiNext;
            phi->phiNext = gphiList;
            gphiList = phi;
            break;

        } else { /* BHE_TEST */
            /*
             * The caller just want to know if this process owns a hard error
             */
            break;
        }
    } /*  while (*pphi != NULL) */

    LeaveCrit();

    /*
     * Bug 284468. Wake up the hard error handler
     */
    if (dwCode == BHE_FORCE && gdwHardErrorThreadId != 0) {
        PostThreadMessage(gdwHardErrorThreadId, WM_NULL, 0, 0);
    }

    return fHasError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\icadis.c ===
/*************************************************************************
*
* icadis.c
*
* Send notice of ICA disconnect
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* $Author:
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

#include "ntuser.h"

#include <winsta.h>
#include <wstmsg.h>
#include <icadd.h>

HANDLE WinStationIcaApiPort = NULL;

/*******************************************************************************
 *
 *  ConnectToTerminalServer
 *
 * ENTRY:
 *    Access (input)
 *       security access
 *
 * EXIT:
 *    STATUS_SUCCESS - successful
 *
 ******************************************************************************/

NTSTATUS
ConnectToTerminalServer(
    ULONG Access,
    PHANDLE pPortHandle)
{
    UNICODE_STRING              PortName;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    WINSTATIONAPI_CONNECT_INFO  info;
    ULONG                       ConnectInfoLength;
    NTSTATUS                    Status;

    /*
     * Set up SM API port name
     */
    RtlInitUnicodeString(&PortName, L"\\SmSsWinStationApiPort");

    /*
     * Set up the security quality of service parameters to use over the
     * port.  Use the most efficient (least overhead) - which is dynamic
     * rather than static tracking.
     */
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    /*
     * Fill in the ConnectInfo structure with our access request mask
     */
    info.Version = CITRIX_WINSTATIONAPI_VERSION;
    info.RequestedAccess = Access;
    ConnectInfoLength = sizeof(WINSTATIONAPI_CONNECT_INFO);

    // Attempt to connect to the Session Manager API port
    Status = NtConnectPort(pPortHandle,
                            &PortName,
                            &DynamicQos,
                            NULL,
                            NULL,
                            NULL, // Max message length [select default]
                            (PVOID)&info,
                            &ConnectInfoLength);
    if (!NT_SUCCESS(Status)) {
        // Look at the returned INFO to see why if desired
        *pPortHandle = NULL;
#if DBG
        if (ConnectInfoLength == sizeof(WINSTATIONAPI_CONNECT_INFO)) {
            DbgPrint("WinstationConnectToICASrv: connect failed, Reason 0x%x\n", info.AcceptStatus);
        }
        DbgPrint("WinstationConnectToICASrv: Connect failed 0x%x\n", Status);
#endif
        return (Status);
    }

    return (STATUS_SUCCESS);
}


/*******************************************************************************
 *
 *  BrokenConnection
 *
 * ENTRY:
 *    Reason code
 *
 * EXIT:
 *    STATUS_SUCCESS - successful
 *
 ******************************************************************************/


NTSTATUS
BrokenConnection(
    BROKENCLASS       Reason,
    BROKENSOURCECLASS Source)
{
    WINSTATION_APIMSG Msg;
    NTSTATUS          Status;

    /*
     * Connect to Session Mgr
     */
    if (WinStationIcaApiPort == NULL) {
        Status = ConnectToTerminalServer(0, &WinStationIcaApiPort);        
        if (!NT_SUCCESS(Status)) {
            return (Status);
        }
    }


    Msg.h.u1.s1.DataLength = sizeof(Msg) - sizeof(PORT_MESSAGE);
    Msg.h.u1.s1.TotalLength = sizeof(Msg);
    Msg.h.u2.s2.Type = 0; // Kernel will fill in message type
    Msg.h.u2.s2.DataInfoOffset = 0;
    Msg.WaitForReply = TRUE;
    Msg.ApiNumber = SMWinStationBrokenConnection;
    Msg.ReturnedStatus = 0;

    Msg.u.Broken.Reason = Reason;
    Msg.u.Broken.Source = Source;

    Status = NtRequestWaitReplyPort(WinStationIcaApiPort, (PPORT_MESSAGE)&Msg, (PPORT_MESSAGE)&Msg);




#if DBG
    if (!NT_SUCCESS(Status)) {
        DbgPrint("BrokenConnection: rc=0x%x\n", Status);
    }
#endif

    return (Status);
}


/*******************************************************************************
 *
 *  ReplyMessageToTerminalServer
 *
 * ENTRY:
 *
 * EXIT:
 *    STATUS_SUCCESS - successful
 *
 ******************************************************************************/

NTSTATUS
ReplyMessageToTerminalServer(
    PCTXHARDERRORINFO pchi)
{
    WINSTATION_APIMSG Msg;
    NTSTATUS          Status;
    HANDLE            PortHandle;

    /*
     * Connect to Session Mgr
     */
    Status = ConnectToTerminalServer(0, &PortHandle);        
    if (!NT_SUCCESS(Status)) {
        return (Status);
    }


    Msg.h.u1.s1.DataLength = sizeof(Msg) - sizeof(PORT_MESSAGE);
    Msg.h.u1.s1.TotalLength = sizeof(Msg);
    Msg.h.u2.s2.Type = 0; // Kernel will fill in message type
    Msg.h.u2.s2.DataInfoOffset = 0;
    Msg.WaitForReply = TRUE;
    Msg.ApiNumber = SMWinStationIcaReplyMessage;
    Msg.ReturnedStatus = 0;

    Msg.u.ReplyMessage.Response  = pchi->Response;
    Msg.u.ReplyMessage.pResponse = pchi->pResponse;
    Msg.u.ReplyMessage.hEvent    = pchi->hEvent;

    Status = NtRequestWaitReplyPort(PortHandle, (PPORT_MESSAGE)&Msg, (PPORT_MESSAGE)&Msg);





#if DBG
    if (!NT_SUCCESS(Status)) {
        DbgPrint("ReplyMessageToTerminalServer: rc=0x%x\n", Status);
    }
#endif
    NtClose(PortHandle);

    return (Status);
}

NTSTATUS ReplyInvalidWindowToTerminalServer (HWND hWnd, ULONG ulSessionId)
{
    WINSTATION_APIMSG Msg;
    NTSTATUS          Status;
    HANDLE            PortHandle;

    /*
     * Connect to Session Mgr
     */
    Status = ConnectToTerminalServer(0, &PortHandle);        
    if (!NT_SUCCESS(Status)) {
        return (Status);
    }

    Msg.h.u1.s1.DataLength = sizeof(Msg) - sizeof(PORT_MESSAGE);
    Msg.h.u1.s1.TotalLength = sizeof(Msg);
    Msg.h.u2.s2.Type = 0; // Kernel will fill in message type
    Msg.h.u2.s2.DataInfoOffset = 0;
    Msg.WaitForReply = FALSE;
    Msg.ApiNumber = SMWinStationWindowInvalid;
    Msg.ReturnedStatus = 0;

    Msg.u.WindowInvalid.hWnd = HandleToULong(hWnd);
    Msg.u.WindowInvalid.SessionId = ulSessionId;

    Status = NtRequestPort(PortHandle, (PPORT_MESSAGE)&Msg);


#if DBG
    if (!NT_SUCCESS(Status)) {
        DbgPrint("ReplyInvalidWindowToTerminalServer: rc=0x%x\n", Status);
    }
#endif
    NtClose(PortHandle);

    return (Status);

}

/*******************************************************************************
 *
 *  ShadowHotkey
 *
 * ENTRY:
 *    none
 *
 * EXIT:
 *    STATUS_SUCCESS - successful
 *
 ******************************************************************************/

NTSTATUS
ShadowHotkey()
{
    WINSTATION_APIMSG Msg;
    NTSTATUS Status;

    /*
     * Connect to Session Mgr
     */
    if (WinStationIcaApiPort == NULL) {
        Status = ConnectToTerminalServer(0, &WinStationIcaApiPort);        
        if (!NT_SUCCESS(Status)) {
            return (Status);
        }
    }






    Msg.h.u1.s1.DataLength = sizeof(Msg) - sizeof(PORT_MESSAGE);
    Msg.h.u1.s1.TotalLength = sizeof(Msg);
    Msg.h.u2.s2.Type = 0; // Kernel will fill in message type
    Msg.h.u2.s2.DataInfoOffset = 0;
    Msg.WaitForReply = TRUE;
    Msg.ApiNumber = SMWinStationIcaShadowHotkey;
    Msg.ReturnedStatus = 0;

    Status = NtRequestWaitReplyPort(WinStationIcaApiPort, (PPORT_MESSAGE)&Msg, (PPORT_MESSAGE)&Msg);



#if DBG
    if (!NT_SUCCESS(Status)) {
        DbgPrint("ShadowHotkey: rc=0x%x\n", Status);
    }
#endif

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Mar-06-1996 HideyukN Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

!include $(WINCORE_PATH)\core.inc

TARGETNAME=usersrvl
TARGETTYPE=LIBRARY
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -DUNICODE -DNEW_MINLOOK -D_USER32_
!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

NTTARGETFILE0=$(O)\strid.h

PASS0_PUBLISH= \
    {..\console.ico=$(WINDOWS_INC_PATH)\console.ico}

INCLUDES=..\;                                    \
         $(NTUSER_PATH)\inc;                     \
         $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O); \
         $(WINCORE_PATH)\w32inc;                 \
         $(WINCORE_PATH)\w32inc\$(O);            \
         $(NTUSER_PATH)\client;                  \
         $(NTGDI_PATH)\inc;                      \
         $(SDKTOOLS_INC_PATH);                   \
         $(BASE_INC_PATH);                       \
	 $(SHELL_INC_PATH);			 \
	 $(PUBLIC_INTERNAL_PATH)\qfe\inc

SOURCES= \
        ..\debug.c    \
        ..\exitwin.c  \
        ..\exports.c  \
        ..\globals.c  \
        ..\harderr.c  \
        ..\msgbeep.c  \
        ..\instdev.c  \
        ..\server.c   \
	..\reclient.c

UMTYPE=windows

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\server.c ===
/**************************************************************************\
* Module Name: server.c
*
* Server support routines for the CSR stuff.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Created: 10-Dec-90
*
* History:
*   10-Dec-90 created by sMeans
*
\**************************************************************************/


#include "precomp.h"
#pragma hdrstop

#include <dbt.h>
#include <ntdddisk.h>
#include "ntuser.h"
#include <regstr.h>


HANDLE hThreadNotification;
HANDLE hKeyPriority;
UNICODE_STRING PriorityValueName;
IO_STATUS_BLOCK IoStatusRegChange;
ULONG RegChangeBuffer;
HANDLE ghNlsEvent;
BOOL gfLogon;
HANDLE ghPowerRequestEvent;
HANDLE ghMediaRequestEvent;

#define ID_NLS              0
#define ID_POWER            1
#define ID_MEDIACHANGE      2
#define ID_NETDEVCHANGE     3
#define ID_NUM_EVENTS       4


//
// Name of event to pulse to request a device-arrival broadcast,
//
#define SC_BSM_EVENT_NAME   L"ScNetDrvMsg"

//
// What the net drive bitmask was when we last broadcast (initially 0)
//
DWORD LastNetDrives;


HANDLE CsrApiPort;
HANDLE CsrQueryApiPort(VOID);

ULONG
SrvExitWindowsEx(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

ULONG
SrvEndTask(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

ULONG
SrvLogon(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

ULONG
SrvRegisterServicesProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

ULONG
SrvActivateDebugger(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

ULONG
SrvGetThreadConsoleDesktop(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

ULONG
SrvDeviceEvent(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

ULONG
SrvRegisterLogonProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

ULONG
SrvWin32HeapFail(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

ULONG
SrvWin32HeapStat(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

ULONG SrvCreateSystemThreads(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus);

PCSR_API_ROUTINE UserServerApiDispatchTable[ UserpMaxApiNumber - UserpExitWindowsEx ] = {
    (PCSR_API_ROUTINE)SrvExitWindowsEx,
    (PCSR_API_ROUTINE)SrvEndTask,
    (PCSR_API_ROUTINE)SrvLogon,
    (PCSR_API_ROUTINE)SrvRegisterServicesProcess,
    (PCSR_API_ROUTINE)SrvActivateDebugger,
    (PCSR_API_ROUTINE)SrvGetThreadConsoleDesktop,
    (PCSR_API_ROUTINE)SrvDeviceEvent,
    (PCSR_API_ROUTINE)SrvRegisterLogonProcess,
    (PCSR_API_ROUTINE)SrvWin32HeapFail,
    (PCSR_API_ROUTINE)SrvWin32HeapStat,
    (PCSR_API_ROUTINE)SrvCreateSystemThreads,
};

BOOLEAN UserServerApiServerValidTable[ UserpMaxApiNumber - UserpExitWindowsEx ] = {
    FALSE,      // ExitWindowsEx
    FALSE,      // EndTask
    FALSE,      // Logon
    FALSE,      // RegisterServicesProcess
    FALSE,      // ActivateDebugger
    TRUE,       // GetThreadConsoleDesktop
    FALSE,      // DeviceEvent
    FALSE,      // RegisterLogonProcess
    FALSE,      // Win32HeapFail
    FALSE,      // Win32HeapStat
    FALSE,      // CreateSystemThreads
};

#if DBG
PSZ UserServerApiNameTable[ UserpMaxApiNumber - UserpExitWindowsEx ] = {
    "SrvExitWindowsEx",
    "SrvEndTask",
    "SrvLogon",
    "SrvRegisterServicesProcess",
    "SrvActivateDebugger",
    "SrvGetThreadConsoleDesktop",
    "SrvDeviceEvent",
    "SrvRegisterLogonProcess",
    "SrvWin32HeapFail",
    "SrvWin32HeapStat",
    "SrvCreateSystemThreads"
};
#endif // DBG

NTSTATUS
UserServerDllInitialization(
    PCSR_SERVER_DLL psrvdll
    );

NTSTATUS UserClientConnect(PCSR_PROCESS Process, PVOID ConnectionInformation,
        PULONG pulConnectionLen);
VOID     UserHardError(PCSR_THREAD pcsrt, PHARDERROR_MSG pmsg);
NTSTATUS UserClientShutdown(PCSR_PROCESS Process, ULONG dwFlags, BOOLEAN fFirstPass);

VOID GetTimeouts(VOID);
VOID StartRegReadRead(VOID);
VOID RegReadApcProcedure(PVOID RegReadApcContext, PIO_STATUS_BLOCK IoStatus);
NTSTATUS NotificationThread(PVOID);
typedef BOOL (*PFNPROCESSCREATE)(DWORD, DWORD, ULONG_PTR, DWORD);

VOID InitializeConsoleAttributes(VOID);
NTSTATUS GetThreadConsoleDesktop(DWORD dwThreadId, HDESK *phdesk);
NTSTATUS MyRegOpenKey(IN HANDLE hKey, IN LPWSTR lpSubKey, OUT PHANDLE phResult);

BOOL BaseSetProcessCreateNotify(PFNPROCESSCREATE pfn);
VOID BaseSrvNlsUpdateRegistryCache(PVOID ApcContext,
                                   PIO_STATUS_BLOCK pIoStatusBlock);
NTSTATUS BaseSrvNlsLogon(BOOL);
NTSTATUS WinStationAPIInit(VOID);

/***************************************************************************\
* UserServerDllInitialization
*
* Called by the CSR stuff to allow a server DLL to initialize itself and
* provide information about the APIs it provides.
*
* Several operations are performed during this initialization:
*
* - The shared heap (client read-only) handle is initialized.
* - The Raw Input Thread (RIT) is launched.
* - GDI is initialized.
*
* History:
* 10-19-92 DarrinM      Integrated xxxUserServerDllInitialize into this rtn.
* 11-08-91 patrickh     move GDI init here from DLL init routine.
* 12-10-90 sMeans       Created.
\***************************************************************************/
NTSTATUS UserServerDllInitialization(
    PCSR_SERVER_DLL psrvdll)
{
    CLIENT_ID ClientId;
    BOOL bAllocated;
    NTSTATUS Status;

    /*
     * Initialize the RIP flags to default
     */
    gdwRIPFlags = RIPF_DEFAULT;

#if DBG
    if (RtlGetNtGlobalFlags() & FLG_SHOW_LDR_SNAPS) {
        RIPMSG0(RIP_WARNING,
                "UserServerDllInitialization: entered");
    }
#endif

    /*
     * Initialize a critical section structure that will be used to protect
     * all of the User Server's critical sections (except a few special
     * cases like the RIT -- see below).
     */

    Status = RtlInitializeCriticalSection(&gcsUserSrv);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "UserServerDllInitialization: InitializeCriticalSection failed with Status 0x%x",
                Status);
        return Status;
    }
    EnterCrit();

    /*
     * Remember WINSRV.DLL's hmodule so we can grab resources from it later.
     */
    ghModuleWin = psrvdll->ModuleHandle;

    psrvdll->ApiNumberBase = USERSRV_FIRST_API_NUMBER;
    psrvdll->MaxApiNumber = UserpMaxApiNumber;
    psrvdll->ApiDispatchTable = UserServerApiDispatchTable;

    if (ISTS()) {
        UserServerApiServerValidTable[0] = TRUE; // for ExitWindowsEx
    }

    psrvdll->ApiServerValidTable = UserServerApiServerValidTable;
#if DBG
    psrvdll->ApiNameTable = UserServerApiNameTable;
#else
    psrvdll->ApiNameTable = NULL;
#endif
    psrvdll->ConnectRoutine         = UserClientConnect;
    psrvdll->HardErrorRoutine       = UserHardError;
    psrvdll->ShutdownProcessRoutine = UserClientShutdown;

    /*
     * Create the events used by shutdown
     */
    Status = NtCreateEvent(&gheventCancel, EVENT_ALL_ACCESS, NULL,
                           NotificationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "UserServerDllInitialization: NtCreateEvent failed with Status 0x%x",
                Status);
        goto ExitUserInit;
    }
    Status = NtCreateEvent(&gheventCancelled, EVENT_ALL_ACCESS, NULL,
                           NotificationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "UserServerDllInitialization: NtCreateEvent failed with Status 0x%x",
                Status);
        goto ExitUserInit;
    }

    /*
     * Create the event used by the power request code.
     */
    Status = NtCreateEvent(&ghPowerRequestEvent, EVENT_ALL_ACCESS, NULL,
                           SynchronizationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "UserServerDllInitialization: NtCreateEvent failed with Status 0x%x",
                Status);
        goto ExitUserInit;
    }

    /*
     * Create the event used by the media change code.
     */
    Status = NtCreateEvent(&ghMediaRequestEvent, EVENT_ALL_ACCESS, NULL,
                           SynchronizationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "UserServerDllInitialization: NtCreateEvent failed with Status 0x%x",
                Status);
        goto ExitUserInit;
    }

    /*
     *  Create the event used by the nls code.
     */
    Status = NtCreateEvent(&ghNlsEvent,
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "UserServerDllInitialization: NtCreateEvent failed with Status 0x%x",
                Status);
        goto ExitUserInit;
    }

    /*
     * Tell the base what user address to call when it is creating a process
     * (but before the process starts running).
     */
    BaseSetProcessCreateNotify(NtUserNotifyProcessCreate);

    /*
     * Load some strings.
     */
    gpwszaSUCCESS            = (PWSTR)RtlLoadStringOrError(ghModuleWin,
                                STR_SUCCESS, NULL, &bAllocated, FALSE);
    gpwszaSYSTEM_INFORMATION = (PWSTR)RtlLoadStringOrError(ghModuleWin,
                                STR_SYSTEM_INFORMATION, NULL, &bAllocated, FALSE);
    gpwszaSYSTEM_WARNING     = (PWSTR)RtlLoadStringOrError(ghModuleWin,
                                STR_SYSTEM_WARNING, NULL, &bAllocated, FALSE);
    gpwszaSYSTEM_ERROR       = (PWSTR)RtlLoadStringOrError(ghModuleWin,
                                STR_SYSTEM_ERROR, NULL, &bAllocated, FALSE);
    /*
     * Initialize USER
     */

    Status = NtUserInitialize(USERCURRENTVERSION, ghPowerRequestEvent, ghMediaRequestEvent);

    if (!NT_SUCCESS(Status)) {
	RIPMSG1(RIP_WARNING,
		"UserServerDllInitialization: NtUserInitialize failed with Status 0x%x",
		Status);
	goto ExitUserInit;
    }

    if (ISTS()) {
        Status = WinStationAPIInit();
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING,
                    "UserServerDllInitialization: WinStationAPIInit failed with Status 0x%x",
                    Status);
            goto ExitUserInit;
        }
    }

    /*
     * Start registry notification thread
     */
    Status = RtlCreateUserThread(NtCurrentProcess(), NULL, FALSE, 0, 0, 0,
                                 NotificationThread, NULL, &hThreadNotification,
                                 &ClientId);
    if (NT_SUCCESS(Status)) {
        UserVerify(CsrAddStaticServerThread(hThreadNotification, &ClientId, 0));
    } else {
        RIPMSG1(RIP_WARNING,
                "UserServerDllInitialization: RtlCreateUserThread failed with Status 0x%x",
                Status);
    }

ExitUserInit:
    LeaveCrit();
    return Status;
}

/**************************************************************************\
* UserClientConnect
*
* This function is called once for each client process that connects to the
* User server.  When the client dynlinks to USER.DLL, USER.DLL's init code
* is executed and calls CsrClientConnectToServer to establish the connection.
* The server portion of ConnectToServer calls out this entrypoint.
*
* UserClientConnect first verifies version numbers to make sure the client
* is compatible with this server and then completes all process-specific
* initialization.
*
* History:
* 02-??-91 SMeans       Created.
* 04-02-91 DarrinM      Added User intialization code.
\**************************************************************************/

extern WORD gDispatchTableValues;

NTSTATUS UserClientConnect(
    PCSR_PROCESS Process,
    PVOID ConnectionInformation,
    PULONG pulConnectionLen)
{
    NTSTATUS Status;
    /*
     * Pass the api port to the kernel.  Do this early so the kernel
     * can send a datagram to CSR to activate a debugger.
     */
    if (CsrApiPort == NULL) {
        CsrApiPort = CsrQueryApiPort();

        UserAssert(CsrApiPort != NULL);

        Status = NtUserSetInformationThread(
                NtCurrentThread(),
                UserThreadCsrApiPort,
                &CsrApiPort,
                sizeof(HANDLE));

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }

    UserAssert(*pulConnectionLen == sizeof(USERCONNECT));
    if (*pulConnectionLen != sizeof(USERCONNECT)) {
        return STATUS_INVALID_PARAMETER;
    }

    ((PUSERCONNECT)ConnectionInformation)->dwDispatchCount = gDispatchTableValues;
    return NtUserProcessConnect(Process->ProcessHandle,
            (PUSERCONNECT)ConnectionInformation, *pulConnectionLen);
}


VOID
RegReadApcProcedure(
    PVOID RegReadApcContext,
    PIO_STATUS_BLOCK IoStatus
    )
{
    UNICODE_STRING ValueString;
    LONG Status;
    BYTE Buf[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
    DWORD cbSize;
    ULONG l;

    UNREFERENCED_PARAMETER(RegReadApcContext);
    UNREFERENCED_PARAMETER(IoStatus);

    RtlInitUnicodeString(&ValueString, L"Win32PrioritySeparation");
    Status = NtQueryValueKey(hKeyPriority,
            &ValueString,
            KeyValuePartialInformation,
            (PKEY_VALUE_PARTIAL_INFORMATION)Buf,
            sizeof(Buf),
            &cbSize);
    if (NT_SUCCESS(Status)) {
        l = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)Buf)->Data);
    } else {
        l = PROCESS_PRIORITY_SEPARATION_MAX;  // last resort default
    }

    NtSetSystemInformation(SystemPrioritySeperation,&l,sizeof(ULONG));

    NtNotifyChangeKey(
        hKeyPriority,
        NULL,
        (PIO_APC_ROUTINE)RegReadApcProcedure,
        NULL,
        &IoStatusRegChange,
        REG_NOTIFY_CHANGE_LAST_SET,
        FALSE,
        &RegChangeBuffer,
        sizeof(RegChangeBuffer),
        TRUE
        );
}

VOID
StartRegReadRead(VOID)
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES OA;

    RtlInitUnicodeString(&UnicodeString,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\PriorityControl");
    InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

    if (!NT_SUCCESS(NtOpenKey(&hKeyPriority, KEY_READ | KEY_NOTIFY, &OA)))
        UserAssert(FALSE);

    RegReadApcProcedure(NULL, NULL);
}


/***************************************************************************\
* HandleMediaChangeEvent
*
* This routine is responsible for broadcasting the WM_DEVICECHANGE message
* when media arrives or is removed from a CD-ROM device.
*
* History:
* 23-Feb-96     BradG       Modified to handle event per CD-ROM device
* 23-April-96   Salimc      Some CD-ROM drives notify us that media has
*                           arrived before the drive has recognized that it had
*                           new media. The call to DeviceIoctl() will fail in
*                           this case. To fix this we made the following changes
*
*                           aDriveState is an array of tri-state global variable
*                           for each drive.Each variable starts off in an UNKNOWN
*                           state and on the first event with any drive we do the
*                           full MAX_TRIES or less CHECK_VERIFY's which then gets
*                           us into either a INSERTED or EJECTED state. From then
*                           on we know that each new event is going to be the
*                           opposite of what we currently have.
*
*                           UNKNOWN => do upto MAX_TRIES CHECK_VERIFY's with
*                           delay to get into EJECTED or INSERTED state.
*
*                           INSERTED => do 1 CHECK_VERIFY to get into
*                           EJECTED state
*
*                           EJECTED => do upto MAX_TRIES CHECK_VERIFY's with
*                           delay to get into INSERTED state
*
\***************************************************************************/

VOID HandleMediaChangeEvent(VOID)
{
    /*
     * Local variables
     */

    DWORD                   dwRecipients;
    BOOL                    bResult;
    NTSTATUS                Status;
    DEV_BROADCAST_VOLUME    dbcvInfo;
    USERTHREAD_USEDESKTOPINFO utudi;

    ULONG cDrive;

    while (cDrive = (ULONG)NtUserCallNoParam(SFI_GETDEVICECHANGEINFO)) {

        /*
         * Determine if it's an arrival or removal
         */
        bResult = (cDrive & HMCE_ARRIVAL);
        cDrive &= ~HMCE_ARRIVAL;

        /*
         * Initialize the structures used for BroadcastSystemMessage
         */
        dbcvInfo.dbcv_size = sizeof(dbcvInfo);
        dbcvInfo.dbcv_devicetype = DBT_DEVTYP_VOLUME;
        dbcvInfo.dbcv_reserved = 0;
        dbcvInfo.dbcv_flags = DBTF_MEDIA;
        dbcvInfo.dbcv_unitmask = cDrive;

        dwRecipients = BSM_ALLCOMPONENTS | BSM_ALLDESKTOPS;

        /*
         * Temporarily we must assign this thread to a desktop so we can
         * call USER's BroascastSystemMessage() routine.  We call the
         * private SetThreadDesktopToDefault() to assign ourselves to the
         * desktop that is currently receiving input.
         */
        utudi.hThread = NULL;
        utudi.drdRestore.pdeskRestore = NULL;
        Status = NtUserSetInformationThread(NtCurrentThread(),
                                            UserThreadUseActiveDesktop,
                                            &utudi, sizeof(utudi));
        if (NT_SUCCESS(Status)) {
            /*
             * Broadcast the message
             */
            BroadcastSystemMessage(BSF_FORCEIFHUNG | ((bResult) ? BSF_ALLOWSFW : 0),
                                   &dwRecipients,
                                   WM_DEVICECHANGE,
// HACK: need to or 0x8000 in wParam
//       because this is a flag to let
//       BSM know that lParam is a pointer
//       to a data structure.
                                   0x8000 | ((bResult) ? DBT_DEVICEARRIVAL : DBT_DEVICEREMOVECOMPLETE),
                                   (LPARAM)&dbcvInfo);

            /*
             * Set our thread's desktop back to NULL.  This will decrement
             * the desktop's reference count.
             */
            NtUserSetInformationThread(NtCurrentThread(),
                                       UserThreadUseDesktop,
                                       &utudi,
                                       sizeof(utudi));
        }
    }
}

DWORD
GetNetworkDrives(
    )
/*++

Routine Description:

    Returns a drive bitmask similar to GetLogicalDrives, but including
    only the network drives.

Arguments:

Return Value:


--*/
{
    DWORD Mask = 0;
    DWORD DriveNumber;
    PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo;

    if (NT_SUCCESS(NtQueryInformationProcess( NtCurrentProcess(),
                                        ProcessDeviceMap,
                                        &ProcessDeviceMapInfo.Query,
                                        sizeof( ProcessDeviceMapInfo.Query ),
                                        NULL
                                      ))) {
        // For all the drives from C to Z
        for (DriveNumber = 2; DriveNumber < 26; DriveNumber++)
        {
            if (ProcessDeviceMapInfo.Query.DriveType[DriveNumber] == DOSDEVICE_DRIVE_REMOTE)
            {
                Mask |= (1 << DriveNumber);
            }
        }
    }

    return Mask;
}

VOID
HandleRemoteNetDeviceChangeEvent(
    )
/*++

Routine Description:


Arguments:

Return Value:

--*/
{
    DWORD    NetDrives;
    DEV_BROADCAST_VOLUME dbv;
    LONG status;
    USERTHREAD_USEDESKTOPINFO utudi;



    /*
     * Temporarily we must assign this thread to a desktop so we can
     * call USER's BroascastSystemMessage() routine.  We call the
     * private SetThreadDesktopToDefault() to assign ourselves to the
     * desktop that is currently receiving input.
     */
    utudi.hThread = NULL;
    utudi.drdRestore.pdeskRestore = NULL;
    status = NtUserSetInformationThread(NtCurrentThread(),
                                        UserThreadUseActiveDesktop,
                                        &utudi, sizeof(utudi));
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Keep broadcasting until the set of net drives stops changing
    //
    for (;;)
    {

        //
        // Get the current net drive bitmask and compare against the net
        // drive bitmask when we last broadcast
        //
        NetDrives = GetNetworkDrives();

        if (NetDrives == LastNetDrives)
        {
            break;
        }

        //
        // Broadcast about deleted volumes
        //
        dbv.dbcv_size       = sizeof(dbv);
        dbv.dbcv_devicetype = DBT_DEVTYP_VOLUME;
        dbv.dbcv_reserved   = 0;
        dbv.dbcv_unitmask   = LastNetDrives & ~NetDrives;
        dbv.dbcv_flags      = DBTF_NET;
        if (dbv.dbcv_unitmask != 0)
        {
            DWORD dwRec = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
            status = BroadcastSystemMessage(
                        BSF_FORCEIFHUNG | BSF_NOHANG | BSF_NOTIMEOUTIFNOTHUNG,
                        &dwRec,
                        WM_DEVICECHANGE,
                        (WPARAM) DBT_DEVICEREMOVECOMPLETE,
                        (LPARAM)(DEV_BROADCAST_HDR*)(&dbv)
                        );

        }

        //
        // Broadcast about added volumes
        //
        dbv.dbcv_unitmask   = NetDrives & ~LastNetDrives;
        if (dbv.dbcv_unitmask != 0)
        {
            DWORD dwRec = BSM_APPLICATIONS | BSM_ALLDESKTOPS;

            status = BroadcastSystemMessage(
                        BSF_FORCEIFHUNG | BSF_NOHANG | BSF_NOTIMEOUTIFNOTHUNG,
                        &dwRec,
                        WM_DEVICECHANGE,
                        (WPARAM) DBT_DEVICEARRIVAL,
                        (LPARAM)(DEV_BROADCAST_HDR*)(&dbv)
                        );


        }

        //
        // Remember the drive set that we last broadcast about
        //
        LastNetDrives = NetDrives;

        //
        // Go around the loop again to detect changes that may have occurred
        // while we were broadcasting
        //
    }

    /*
     * Set our thread's desktop back to NULL.  This will decrement
     * the desktop's reference count.
     */
    NtUserSetInformationThread(NtCurrentThread(),
                               UserThreadUseDesktop,
                               &utudi,
                               sizeof(utudi));

    return;
}

BOOL
CreateBSMEventSD(
    PSECURITY_DESCRIPTOR * SecurityDescriptor
    )
/*++

Routine Description:

    This function creates a security descriptor for the BSM request event.
    It grants EVENT_ALL_ACCESS to local system and EVENT_MODIFY_STATE access
    to the rest of the world.  This prevents principals other than local
    system from waiting for the event.

Arguments:

    SecurityDescriptor - Receives a pointer to the new security descriptor.
        Should be freed with LocalFree.

Return Value:

    TRUE - success

    FALSE - failure, use GetLastError


--*/
{
    NTSTATUS    Status;
    ULONG       AclLength;
    PACL        EventDacl;
    PSID        WorldSid = NULL;
    PSID        SystemSid = NULL;
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    BOOL        retval = TRUE;

    *SecurityDescriptor = NULL;

    Status = RtlAllocateAndInitializeSid( &NtSidAuthority,
                                          1,
                                          SECURITY_LOCAL_SYSTEM_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &SystemSid );

    if (!NT_SUCCESS(Status)) {
        retval = FALSE;
        goto Cleanup;
    }

    Status = RtlAllocateAndInitializeSid( &WorldSidAuthority,
                                          1,
                                          SECURITY_WORLD_RID,
                                          0, 0, 0, 0, 0, 0, 0,
                                          &WorldSid );

    if (!NT_SUCCESS(Status)) {
        retval = FALSE;
        goto Cleanup;
    }


    //
    // Allocate a buffer to contain the SD followed by the DACL
    // Note, the well-known SIDs are expected to have been created
    // by this time
    //

    AclLength = (ULONG)sizeof(ACL) +
                   (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                   RtlLengthSid( SystemSid ) +
                   RtlLengthSid( WorldSid ) +
                   8;       // 8 is for good measure

    *SecurityDescriptor = (PSECURITY_DESCRIPTOR)
        LocalAlloc( 0, SECURITY_DESCRIPTOR_MIN_LENGTH + AclLength );

    if (*SecurityDescriptor == NULL) {
        retval = FALSE;
        goto Cleanup;
    }

    EventDacl = (PACL) ((BYTE*)(*SecurityDescriptor) + SECURITY_DESCRIPTOR_MIN_LENGTH);


    //
    // Set up a default ACL
    //
    //    Public: WORLD:EVENT_MODIFY_STATE, SYSTEM:all

    Status = RtlCreateAcl( EventDacl, AclLength, ACL_REVISION2);
    if (!NT_SUCCESS(Status)) {
        retval = FALSE;
        goto Cleanup;
    }


    //
    // WORLD access
    //

    Status = RtlAddAccessAllowedAce (
                 EventDacl,
                 ACL_REVISION2,
                 EVENT_MODIFY_STATE,
                 WorldSid
                 );
    if (!NT_SUCCESS(Status)) {
        retval = FALSE;
        goto Cleanup;
    }


    //
    // SYSTEM access
    //

    Status = RtlAddAccessAllowedAce (
                 EventDacl,
                 ACL_REVISION2,
                 EVENT_ALL_ACCESS,
                 SystemSid
                 );
    if (!NT_SUCCESS(Status)) {
        retval = FALSE;
        goto Cleanup;
    }



    //
    // Now initialize security descriptors
    // that export this protection
    //

    Status = RtlCreateSecurityDescriptor(
                 *SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    if (!NT_SUCCESS(Status)) {
        retval = FALSE;
        goto Cleanup;
    }

    Status = RtlSetDaclSecurityDescriptor(
                 *SecurityDescriptor,
                 TRUE,                       // DaclPresent
                 EventDacl,
                 FALSE                       // DaclDefaulted
                 );

    if (!NT_SUCCESS(Status)) {
        retval = FALSE;
        goto Cleanup;
    }

Cleanup:

    if (WorldSid) {
        RtlFreeSid(WorldSid);
    }

    if (SystemSid) {
        RtlFreeSid(SystemSid);
    }

    if ((retval == FALSE) && (*SecurityDescriptor != NULL)) {
        LocalFree(*SecurityDescriptor);
        *SecurityDescriptor = NULL;
    }


    return retval;
}


NTSTATUS NotificationThread(
    PVOID ThreadParameter)
{
    KPRIORITY   Priority;
    NTSTATUS    Status;
    HANDLE      hEvent[ID_NUM_EVENTS];
    WCHAR       szObjectStr[MAX_SESSION_PATH];
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING UnicodeString;
    PSECURITY_DESCRIPTOR pSD = NULL;
    ULONG       NumEvents = ID_NUM_EVENTS;

    UNREFERENCED_PARAMETER(ThreadParameter);

    Priority = LOW_PRIORITY + 3;
    NtSetInformationThread(hThreadNotification, ThreadPriority, &Priority,
            sizeof(KPRIORITY));

    /*
     * Setup the NLS event.
     */
    hEvent[ID_NLS] = ghNlsEvent;

    /*
     * Setup the power request event.
     */
    hEvent[ID_POWER] = ghPowerRequestEvent;

    /*
     * Setup the MediaChangeEvent.
     */
    hEvent[ID_MEDIACHANGE] = ghMediaRequestEvent;

    /*
     * Setup the NetDeviceChange Event (only on remote sessions).
     */
    if (gSessionId != 0) {
        swprintf(szObjectStr,
                 L"%ws\\%ld\\BaseNamedObjects\\%ws",
                 SESSION_ROOT,
                 gSessionId,
                 SC_BSM_EVENT_NAME);

        RtlInitUnicodeString(&UnicodeString, szObjectStr);

        if (CreateBSMEventSD(&pSD)) {
            InitializeObjectAttributes(&Attributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE | OBJ_OPENIF,
                                       NULL,
                                       pSD);

            if (!NT_SUCCESS(NtCreateEvent(&hEvent[ID_NETDEVCHANGE], EVENT_ALL_ACCESS, &Attributes, SynchronizationEvent, FALSE))) {
                NumEvents--;
            }

            LocalFree(pSD);
        } else {
            NumEvents--;
        }
    } else {
        NumEvents--;
    }


    StartRegReadRead();

    /*
     * Sit and wait forever.
     */
    while (TRUE) {
        Status = NtWaitForMultipleObjects(NumEvents,
                                          hEvent,
                                          WaitAny,
                                          TRUE,
                                          NULL);

        if (Status == ID_NLS + WAIT_OBJECT_0) {
            /*
             * Handle the NLS event.
             */
            if (gfLogon) {
                gfLogon = FALSE;
                BaseSrvNlsUpdateRegistryCache(NULL, NULL);
            }
        } else if (Status == ID_POWER + WAIT_OBJECT_0) {
            /*
             * Handle the power request event.
             */
            NtUserCallNoParam(SFI_XXXUSERPOWERCALLOUTWORKER);

        } else if (Status == ID_MEDIACHANGE + WAIT_OBJECT_0) {
            /*
             * Handle the media change event.
             */
            HandleMediaChangeEvent();

            NtResetEvent(hEvent[ID_MEDIACHANGE], NULL);
        } else if (Status == ID_NETDEVCHANGE + WAIT_OBJECT_0) {
            /*
             * Handle the NetDevice change event for remote sessions.
             */
            HandleRemoteNetDeviceChangeEvent();
        }
    }

    UserExitWorkerThread(STATUS_SUCCESS);
    return STATUS_SUCCESS;
}


UINT GetRegIntFromID(
    HKEY hKey,
    int KeyID,
    UINT nDefault)
{
    LPWSTR lpszValue;
    BOOL fAllocated;
    UNICODE_STRING Value;
    DWORD cbSize;
    BYTE Buf[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 20 * sizeof(WCHAR)];
    NTSTATUS Status;
    UINT ReturnValue;

    lpszValue = (LPWSTR)RtlLoadStringOrError(ghModuleWin,
            KeyID, NULL, &fAllocated, FALSE);

    RtlInitUnicodeString(&Value, lpszValue);
    Status = NtQueryValueKey(hKey,
            &Value,
            KeyValuePartialInformation,
            (PKEY_VALUE_PARTIAL_INFORMATION)Buf,
            sizeof(Buf),
            &cbSize);
    if (NT_SUCCESS(Status)) {

        /*
         * Convert string to int.
         */
        RtlInitUnicodeString(&Value, (LPWSTR)((PKEY_VALUE_PARTIAL_INFORMATION)Buf)->Data);
        RtlUnicodeStringToInteger(&Value, 10, &ReturnValue);
    } else {
        ReturnValue = nDefault;
    }

    LocalFree(lpszValue);

    return(ReturnValue);
}

VOID GetTimeouts(VOID)
{
    HANDLE hCurrentUserKey;
    HANDLE hKey;
    NTSTATUS Status;

    Status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hCurrentUserKey);
    if (NT_SUCCESS(Status)) {
        Status = MyRegOpenKey(hCurrentUserKey,
                L"Control Panel\\Desktop",
                &hKey);
        if (NT_SUCCESS(Status)) {
            gCmsHungAppTimeout = GetRegIntFromID(
                    hKey,
                    STR_CMSHUNGAPPTIMEOUT,
                    gCmsHungAppTimeout);
            gCmsWaitToKillTimeout = GetRegIntFromID(
                    hKey,
                    STR_CMSWAITTOKILLTIMEOUT,
                    gCmsWaitToKillTimeout);

            gdwHungToKillCount = gCmsWaitToKillTimeout / gCmsHungAppTimeout;

            gfAutoEndTask = GetRegIntFromID(
                    hKey,
                    STR_AUTOENDTASK,
                    gfAutoEndTask);
            NtClose(hKey);
        }
        NtClose(hCurrentUserKey);
    }

    Status = MyRegOpenKey(NULL,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control",
            &hKey);
    if (NT_SUCCESS(Status)) {
        gdwServicesWaitToKillTimeout = GetRegIntFromID(
                hKey,
                STR_WAITTOKILLSERVICETIMEOUT,
                gCmsWaitToKillTimeout);
        gdwProcessTerminateTimeout = GetRegIntFromID(
                hKey,
                STR_PROCESSTERMINATETIMEOUT,
                PROCESSTERMINATETIMEOUT);
      if (gdwProcessTerminateTimeout < CMSHUNGAPPTIMEOUT) {
         gdwProcessTerminateTimeout = CMSHUNGAPPTIMEOUT;
      }

        NtClose(hKey);
    }
}

ULONG
SrvLogon(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PLOGONMSG a = (PLOGONMSG)&m->u.ApiMessageData;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(ReplyStatus);

    if (!CsrImpersonateClient(NULL))
        return (ULONG)STATUS_UNSUCCESSFUL;

    if (a->fLogon)
    {
        /*
         *  Flush the MultiLingual UI (MUI) alternate
         *  resource modules from within NTDLL, so that the
         *  new user logging-on gets his chance to
         *  load his own.
         */
        LdrFlushAlternateResourceModules();

        /*
         *  Take care of NLS cache for LogON.
         */
        BaseSrvNlsLogon(TRUE);

        /*
         *  Set the cleanup event so that the RIT can handle the NLS
         *  registry notification.
         */
        gfLogon = TRUE;
        Status = NtSetEvent(ghNlsEvent, NULL);
        ASSERT(NT_SUCCESS(Status));
    }
    else
    {
        /*
         *  Take care of NLS cache for LogOFF.
         */
        BaseSrvNlsLogon(FALSE);
    }

    /*
     * Get timeout values from registry
     */
    GetTimeouts();

    CsrRevertToSelf();

    /*
     * Initialize console attributes
     */
    InitializeConsoleAttributes();

    return (ULONG)STATUS_SUCCESS;
}

ULONG
SrvRegisterLogonProcess(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    /*
     * Fail if this is not the first call.
     */
    if (gIdLogon != 0) {
        return (ULONG)STATUS_UNSUCCESSFUL;
    }

    gIdLogon = *(DWORD*)m->u.ApiMessageData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    return (ULONG)STATUS_SUCCESS;
}

ULONG
SrvWin32HeapFail(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
#if DBG
    PWIN32HEAPFAILMSG a = (PWIN32HEAPFAILMSG)&m->u.ApiMessageData;

    Win32HeapFailAllocations(a->bFail);

#endif
    return (ULONG)STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(m);
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvWin32HeapStat(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
#if DBG
    extern DWORD Win32HeapStat(PDBGHEAPSTAT phs, DWORD dwLen, BOOL bNeedTagShift);

    PWIN32HEAPSTATMSG a = (PWIN32HEAPSTATMSG)&m->u.ApiMessageData;

    if (!CsrValidateMessageBuffer(m, &a->phs, a->dwLen, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }
    a->dwMaxTag = Win32HeapStat(a->phs, a->dwLen, TRUE);

#endif
    return (ULONG)STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(m);
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetThreadConsoleDesktop(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    PGETTHREADCONSOLEDESKTOPMSG a = (PGETTHREADCONSOLEDESKTOPMSG)&m->u.ApiMessageData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    return GetThreadConsoleDesktop(a->dwThreadId, &a->hdeskConsole);
}

/***************************************************************************\
* FindWindowFromThread
*
* This is a callback function passed to EnumThreadWindows by
*  to find a top level window owned by a given thread;
*  ideally, we want to find a top level owner.
*
* 07/18/96  GerardoB  Created
\***************************************************************************/
BOOL CALLBACK FindWindowFromThread (HWND hwnd, LPARAM lParam)
{
    BOOL fTopLevelOwner;
#ifdef FE_IME
    if ( IsImeWindow(hwnd) ) {
        return TRUE;
    }
#endif

    fTopLevelOwner = (GetWindow(hwnd, GW_OWNER) == NULL);
    if ((*((HWND *)lParam) == NULL) || fTopLevelOwner) {
        *((HWND *)lParam) = hwnd;
    }
    return !fTopLevelOwner;
}

DWORD GetRipComponent(VOID) { return RIP_USERSRV; }

DWORD GetDbgTagFlags(int tag)
{
    return 0;
    UNREFERENCED_PARAMETER(tag);
}

DWORD GetRipPID(VOID) { return 0; }
DWORD GetRipFlags(VOID) { return gdwRIPFlags; }

VOID SetRipFlags(DWORD dwRipFlags, DWORD dwRipPID)
{
    if ((dwRipFlags != (DWORD)-1) && !(dwRipFlags & ~RIPF_VALIDUSERFLAGS)) {
        gdwRIPFlags = (WORD)((gdwRIPFlags & ~RIPF_VALIDUSERFLAGS) | dwRipFlags);
    }
    UNREFERENCED_PARAMETER(dwRipPID);
}

VOID SetDbgTag(int tag, DWORD dwBitFlags)
{
    UNREFERENCED_PARAMETER(tag);
    UNREFERENCED_PARAMETER(dwBitFlags);
}

VOID UserRtlRaiseStatus(NTSTATUS Status)
{
    RtlRaiseStatus(Status);
}


/***************************************************************************\
* StartCreateSystemThreads
*
* Simply calls xxxCreateSystemThreads which will calls to the right
* thread routine (depending on uThreadID).
*
* History:
* 15-Mar-00 MHamid      Created.
\***************************************************************************/
VOID StartCreateSystemThreads (
    PVOID pUnused)
{
    PCSR_THREAD pt;


    pt = CsrConnectToUser();
    NtUserCallOneParam(FALSE, SFI_XXXCREATESYSTEMTHREADS);
    if (pt) {
       CsrDereferenceThread(pt);
    }

    UserExitWorkerThread(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(pUnused);
}

/***************************************************************************\
* SrvCreateSystemThreads
*
* Just creates a thread (at StartCreateSystemThreads) and return.
*
* History:
* 15-Mar-00 MHamid      Created.
\***************************************************************************/
ULONG SrvCreateSystemThreads(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    HANDLE UniqueProcessId;
    HANDLE hProcess;
    BOOL   bRemoteThread;
    CLIENT_ID ClientId;
    PCREATESYSTEMTHREADSMSG pCreateSystemThreads = (PCREATESYSTEMTHREADSMSG)&m->u.ApiMessageData;


    UNREFERENCED_PARAMETER(ReplyStatus);

    if ((bRemoteThread = pCreateSystemThreads->bRemoteThread)) {
        LPTHREAD_START_ROUTINE ThreadStart = NULL;
        PCSR_PROCESS Process;
        HANDLE huser32 = GetModuleHandle(TEXT("user32.dll"));

        if (huser32) {
            ThreadStart = (LPTHREAD_START_ROUTINE)GetProcAddress(huser32, "CreateSystemThreads");
        }

        if (ThreadStart) {
            UniqueProcessId = (HANDLE)NtUserCallNoParam(SFI_GETREMOTEPROCESSID);

            Status = CsrLockProcessByClientId(UniqueProcessId, &Process);
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING,
                    "SrvCreateSystemThreads: CsrLockProcessByClientId failed for remote thread with Status 0x%x", Status);
                NtUserCallOneParam(TRUE, SFI_HANDLESYSTEMTHREADCREATIONFAILURE);
                return Status;
            }
            hProcess = Process->ProcessHandle;

            Status = RtlCreateUserThread(hProcess, NULL, FALSE, 0, 0, 0x4000, ThreadStart, NULL, NULL, &ClientId);
            CsrUnlockProcess(Process);
        }

        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING,
                    "SrvCreateSystemThreads: Failed for remote thread with Status 0x%x", Status);
            NtUserCallOneParam(TRUE, SFI_HANDLESYSTEMTHREADCREATIONFAILURE);
        }
    } else {
        Status = CsrExecServerThread((PUSER_THREAD_START_ROUTINE)StartCreateSystemThreads, 0);
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING,
                    "SrvCreateSystemThreads: RtlCreateUserThread failed with Status 0x%x", Status);
            NtUserCallOneParam(FALSE, SFI_HANDLESYSTEMTHREADCREATIONFAILURE);
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\perf\makefile.inc ===
.\msg00001.bin .\userctrs.rc .\userctrs.h : userctrs.mc
        erase .\userctrs.h
        erase .\msg00001.bin
        erase .\userctrs.rc
        mc -v -s userctrs.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\usersrv.h ===
/*++ BUILD Version: 0015    // Increment this if a change has global effects

/****************************** Module Header ******************************\
* Module Name: usersrv.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used exclusively by the User
* and Console server-side DLL.
*
* History:
* 04-28-91 DarrinM      Created from PROTO.H, MACRO.H, and STRTABLE.H
* 01-25-95 JimA         Split off from kernel-mode.
\***************************************************************************/

#ifndef _USERSRV_
#define _USERSRV_

#include <windows.h>
#include <w32gdip.h>

 /*
  * Enable warnings that are turned off default for NT but we want on
  */
#ifndef RC_INVOKED       // RC can't handle #pragmas
#pragma warning(error:4101)   // Unreferenced local variable
#endif

#ifndef _USERKDX_  /* if not building ntuser\kdexts */
#include <stddef.h>
#include <w32gdip.h>
#include <ddeml.h>
#include "ddemlp.h"
#include "winuserp.h"
#include "winuserk.h"
#include <dde.h>
#include <ddetrack.h>
#include "kbd.h"
#include <wowuserp.h>
#include <memory.h>
#include <w32err.h>
#include <string.h>
#include "help.h"

#include "user.h"
#include "cscall.h"
#undef MONITOR

#include "strid.h"
#include "csrmsg.h"
#endif /* _USERKDX_ */

typedef struct tagCTXHARDERRORINFO {
    CLIENT_ID ClientId;
    ULONG MessageId;
    LPWSTR pTitle;
    LPWSTR pMessage;
    ULONG Style;
    ULONG Timeout;
    ULONG Response;
    PULONG pResponse;
    HANDLE hEvent;
    BOOLEAN DoNotWait;
    struct tagCTXHARDERRORINFO * pchiNext;
} CTXHARDERRORINFO, *PCTXHARDERRORINFO;

/*
 * EndTask dialog, controls, timers, etc
 */
#define IDD_ENDTASK             10
#define IDC_STATUSICON          0x100
#define IDC_STATUSMSG           0x101
#define IDC_STATUSCANCEL        0x102
#define IDC_ENDNOW              0x103

#define IDI_CONSOLE             1
#define ETD_XICON               10
#define ETD_YICON               10

#define IDB_WARNING             0x200

#define IDT_CHECKAPPSTATE       0x300
#define IDT_PROGRESS            0x301

/*
 * End task dialog parameters.
 */
INT_PTR APIENTRY EndTaskDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
typedef struct _ENDDLGPARAMS {
    DWORD dwFlags;          /* EDPF_* flags */
    DWORD dwClientFlags;    /* WMCS_* flags defined in ntuser\user.h */
    DWORD dwRet;            /* User selection */
    UINT uStrId;            /* IDC_STATUS message */
    PCSR_THREAD pcsrt;      /* Not provided for console */
    LPARAM lParam;          /* hwnd for windows - pwcTitle for Console */
    DWORD dwCheckTimerCount;/* IDT_CHECKAPPTIMER tick count */
    HBITMAP hbmpWarning;    /* Warning bitmap to display on icon if not waiting */
    RECT rcWarning;         /* Warning bitmap position */
    HICON hIcon;            /* Application's icon */
    RECT rcBar;             /* Progress bar rect including edge */
    RECT rcProgress;        /* Next block's rect */
    int iProgressStop;      /* Progress bar right most coordinate */
    int iProgressWidth;     /* Progress bar block width */
    HBRUSH hbrProgress;     /* Used to draw progress bar blocks */
    RECT rcEndButton;       /* End button original position (move while in wait mode) */
} ENDDLGPARAMS;
/*
 * ENDDLGPARAMS dwFlags field
 */
#define EDPF_NODLG      0x00000001
#define EDPF_RESPONSE   0x00000002
#define EDPF_HUNG       0x00000004
#define EDPF_WAIT       0x00000008
#define EDPF_INPUT      0x00000010
/*
 * Commands returned from ThreadShutdownNotify
 */
#define TSN_APPSAYSOK        1
#define TSN_APPSAYSNOTOK     2
#define TSN_USERSAYSKILL     3
#define TSN_USERSAYSCANCEL   4
#define TSN_NOWINDOW         5

/*
 * Max number of threads stuck in ThreadShutdownNotify at any one time.
 */
#define TSN_MAX_THREADS 0x8

/*
 * Shared data between user and console
 */
extern HANDLE ghModuleWin;
extern DWORD gCmsHungAppTimeout;
extern DWORD gCmsWaitToKillTimeout;
extern DWORD gdwHungToKillCount;
extern DWORD gdwServicesProcessId;
extern DWORD gdwServicesWaitToKillTimeout;
extern DWORD gdwProcessTerminateTimeout;

/*
 * Hard error information
 */
typedef struct tagHARDERRORINFO {
    struct tagHARDERRORINFO *phiNext;
    PCSR_THREAD pthread;
    HANDLE hEventHardError;
    PHARDERROR_MSG pmsg;
    DWORD dwHEIFFlags;
    UNICODE_STRING usText;      /* MessageBox text, caption and flags     */
    UNICODE_STRING usCaption;
    DWORD dwMBFlags;
    DWORD dwTimeout;            /* MessageBox timeout (could be INFINITE) */
    DWORD dwVDMParam0;
    DWORD dwVDMParam1;
    PCTXHARDERRORINFO pCtxHEInfo;
} HARDERRORINFO, *PHARDERRORINFO;

#define HEIF_ACTIVE         0x00000001
#define HEIF_NUKED          0x00000002
#define HEIF_ALLOCATEDMSG   0x00000004
#define HEIF_REPLIED        0x00000008
#define HEIF_DEREFTHREAD    0x00000010
#define HEIF_WRONGDESKTOP   0x00000020
#define HEIF_SYSTEMERROR    0x00000040
#define HEIF_VDMERROR       0x00000080
#define HEIF_NOWAIT         0x00000100

BOOL BoostHardError(ULONG_PTR dwProcessId, DWORD dwCode);
#define BHE_ACTIVATE        0
#define BHE_FORCE           1
#define BHE_TEST            2
DWORD ThreadShutdownNotify(DWORD dwClientFlags, ULONG_PTR dwThread, LPARAM lParam);

/*
 * WM_CLIENTSHUTDOWN message callback
 */
typedef struct tagWMCSDATA {
    DWORD dwFlags;
    DWORD dwRet;
} WMCSDATA, *PWMCSDATA;

#define WMCSD_IGNORE    0x00000001
#define WMCSD_REPLY     0x00000002
#define WMCSD_RECEIVED  0x00000004
/*
 * Prototypes from server.c
 */
BOOL CALLBACK FindWindowFromThread (HWND hwnd, LPARAM lParam);

/*
 * !!! LATER - move other internal routines out of winuserp.h
 */

int  InternalDoEndTaskDialog(TCHAR* pszTitle, HANDLE h, int cSeconds);

#ifndef _USERKDX_  /* if not building ntuser\kdexts */
LPWSTR RtlLoadStringOrError(
    HANDLE hModule,
    UINT wID,
    LPWSTR lpDefault,
    PBOOL pAllocated,
    BOOL bAnsi
    );
#define ServerLoadString(hmod, id, default, allocated)\
        RtlLoadStringOrError((hmod), (id), (default), (allocated), FALSE)
#endif /* _USERKDX_ */


#define EnterCrit()     RtlEnterCriticalSection(&gcsUserSrv)
#define LeaveCrit()     RtlLeaveCriticalSection(&gcsUserSrv)


#ifdef FE_IME
BOOL  IsImeWindow( HWND hwnd );
#endif

VOID UserExitWorkerThread(NTSTATUS Status);

// used by hang reporting since CreateProcessW does not work from CSRSS
BOOL StartHangReport(ULONG ulSessionId, LPWSTR wszEventName,
                     DWORD dwpidHung, DWORD dwtidHung, BOOL f64Bit, 
                     HANDLE *phProcDumprep);

// used by hang reporting to create the SD for the event that will signal when
//  it's ok to kill the hung process
NTSTATUS AllocDefSD(SECURITY_DESCRIPTOR *psd, DWORD dwOALS, DWORD dwWA);
void     FreeDefSD(SECURITY_DESCRIPTOR *psd);


#include "globals.h"

#endif  // !_USERSRV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\reclient.c ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    reclient.c

Abstract:
    Implements access to the DW creation pipe.

Revision History:
    created     derekm      10/15/00

******************************************************************************/

#include "precomp.h"
#include <pchrexec.h>

// **************************************************************************
BOOL MyCallNamedPipe(LPCWSTR wszPipe, LPVOID pvIn, DWORD cbIn, 
                     LPVOID pvOut, DWORD cbOut, DWORD *pcbRead, 
                     DWORD dwWaitPipe, DWORD dwWaitRead)
{
    HRESULT hr = NOERROR;
    HANDLE  hPipe = INVALID_HANDLE_VALUE;
    HANDLE  hev = NULL;
    DWORD   dwStart = GetTickCount(), dwNow, dw;
    BOOL    fRet = FALSE;

    if (wszPipe == NULL || pvIn == NULL || pvOut == NULL || pcbRead == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *pcbRead = 0;

    for(;;) 
    {
        hPipe = CreateFileW(wszPipe, GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED,
                            NULL);
        if (hPipe != INVALID_HANDLE_VALUE)
            break;

        fRet = WaitNamedPipeW(wszPipe, dwWaitPipe);
        if (fRet == FALSE)
            goto done;

        dwNow = GetTickCount();
        if (dwNow < dwStart)
            dw = ((DWORD)-1 - dwStart) + dwNow;
        else
            dw = dwNow - dwStart;
        if (dw >= dwWaitPipe)
            dwWaitPipe = 0;
        else
            dwWaitPipe -= dw;
    }


    __try 
    {
        OVERLAPPED  ol;
        DWORD       dwMode = PIPE_READMODE_MESSAGE | PIPE_WAIT;
        DWORD       cbRead = 0;
        
        __try
        {
            //  Default open is readmode byte stream- change to message mode.
            fRet = SetNamedPipeHandleState(hPipe, &dwMode, NULL, NULL);
            if (fRet == FALSE)
                __leave;

            // we need an event for the overlapped structure
            hev = CreateEventW(NULL, TRUE, FALSE, NULL);
            if (hev == NULL)
            {
                fRet = FALSE;
                __leave;
            }

            // populate the overlapped stuff
            ZeroMemory(&ol, sizeof(ol));
            ol.hEvent = hev;

            if (GetSystemMetrics(SM_SHUTTINGDOWN))
            {
                SetLastError(WAIT_TIMEOUT);
                __leave;
            }

            fRet = TransactNamedPipe(hPipe, pvIn, cbIn, pvOut, cbOut, &cbRead, 
                                     &ol);
            if (GetLastError() != ERROR_IO_PENDING)
            {
                if (fRet)
                    SetEvent(hev);
                else
                    __leave;
            }

            dw = WaitForSingleObject(hev, dwWaitRead);
            if (dw != WAIT_OBJECT_0)
            {
                if (dw == WAIT_TIMEOUT)
                    SetLastError(WAIT_TIMEOUT);
                __leave;
            }
            
            fRet = GetOverlappedResult(hPipe, &ol, &cbRead, FALSE);
            if (fRet == FALSE)
                __leave;

            *pcbRead = cbRead;

            hr = NOERROR;
        }

        __finally
        {
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

done:
    dw = GetLastError();

    if (hPipe != INVALID_HANDLE_VALUE)
        CloseHandle(hPipe);
    if (hev != NULL)
        CloseHandle(hev);

    SetLastError(dw);
    
    return fRet;
    }


// ***************************************************************************
LPWSTR MarshallString(LPWSTR wszSrc, PBYTE pBase, ULONG cbMaxBuf, 
                      PBYTE *ppToWrite, DWORD *pcbWritten)
{
    DWORD cb;
    PBYTE pwszNormalized;

    cb = (wcslen(wszSrc) + 1) * sizeof(WCHAR);

    if ((*pcbWritten + cb) > cbMaxBuf)
        return NULL;

    RtlMoveMemory(*ppToWrite, wszSrc, cb);

    // the normalized ptr is the current count
    pwszNormalized = (PBYTE)(*ppToWrite - pBase);

    // cb is always a mutliple of sizeof(WHCAR) so the pointer addition below
    //  always produces a result that is 2byte aligned (assuming the input was
    //  2byte aligned of course)
    *ppToWrite  += cb;
    *pcbWritten += cb;

    return (LPWSTR)pwszNormalized;
}

// ***************************************************************************
BOOL StartHangReport(ULONG ulSessionId, LPWSTR wszEventName, DWORD dwpidHung,
                     DWORD dwtidHung, BOOL f64Bit, HANDLE *phProcDumprep)
{
    SPCHExecServHangRequest *pesreq;
    SPCHExecServHangReply   esrep;
    DWORD                   cbRead, cbReq;
    WCHAR                   wszPipeName[MAX_PATH];
    BYTE                    Buf[ERRORREP_PIPE_BUF_SIZE];
    BYTE                    *pBuf;
    BOOL                    fRet = FALSE;

    // validate params
    if (wszEventName == NULL || phProcDumprep == NULL || dwpidHung == 0 || 
        dwtidHung == 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    *phProcDumprep = NULL;

    wcscpy(wszPipeName, ERRORREP_HANG_PIPENAME);

    // setup the marshalling- make sure that pBuf is aligned on a 2byte
    //  boundary beacause we'll be writing WCHAR buffers to it.
    ZeroMemory(Buf, sizeof(Buf));
    pesreq  = (SPCHExecServHangRequest *)Buf;
    cbReq   = sizeof(SPCHExecServHangRequest) + 
              (sizeof(WCHAR) - 
               (sizeof(SPCHExecServHangRequest) % sizeof(WCHAR)));
    pBuf    = Buf + cbReq;

    // set the basic parameters
    pesreq->cbESR          = sizeof(SPCHExecServHangRequest);
    pesreq->pidReqProcess  = GetCurrentProcessId();
    pesreq->ulSessionId    = ulSessionId;
    pesreq->dwpidHung      = dwpidHung;
    pesreq->dwtidHung      = dwtidHung;
    pesreq->fIs64bit       = f64Bit;


    // marshall all the strings we send across the wire.

    // CommandLine
    if (wszEventName != NULL)
    {
        pesreq->wszEventName = (UINT64)MarshallString(wszEventName, Buf, 
                                                      sizeof(Buf), &pBuf,
                                                      &cbReq);
        if (pesreq->wszEventName == 0)
            goto done;
    }

    // set the total size of the message
    pesreq->cbTotal = cbReq;

    if (GetSystemMetrics(SM_SHUTTINGDOWN))
    {
        SetLastError(WAIT_TIMEOUT);
        goto done;
    }

    // Send the buffer out to the server- wait at most 2m for this to
    //  succeed.  If it times out, bail.
    fRet = MyCallNamedPipe(wszPipeName, Buf, cbReq, &esrep, sizeof(esrep),
                           &cbRead, 120000, 120000);
    if (fRet == FALSE)
        goto done;

    // Check the result
    fRet = (esrep.ess == essOk);
    if (fRet == FALSE)
    {
        SetLastError(esrep.dwErr);
        goto done;
    }

    *phProcDumprep = esrep.hProcess;

done:
    return fRet;
}

// ***************************************************************************
NTSTATUS AllocDefSD(SECURITY_DESCRIPTOR *psd, DWORD dwOALS, DWORD dwWA)
{
    SID_IDENTIFIER_AUTHORITY    siaNT = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    siaWorld = SECURITY_WORLD_SID_AUTHORITY;
    TOKEN_USER                  *ptu = NULL;
    NTSTATUS                    Status;
    HANDLE                      hToken = NULL;
    DWORD                       cb, cbGot;
    PACL                        pacl = NULL;
    PSID                        psidOwner = NULL;
    PSID                        psidLS = NULL;
    PSID                        psidWorld = NULL;
    PSID                        psidAnon = NULL;

    if (psd == NULL)
    {
        SetLastError(STATUS_INVALID_PARAMETER_1);
        goto done;
    }

    Status = RtlCreateSecurityDescriptor(psd, SECURITY_DESCRIPTOR_REVISION);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    // get the SID for the creator / owner
    Status = NtOpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if (NT_SUCCESS(Status) == FALSE && Status == STATUS_NO_TOKEN)
        Status = NtOpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    Status = NtQueryInformationToken(hToken, TokenUser, NULL, 0, &cb);
    if (NT_SUCCESS(Status) == FALSE && Status != STATUS_BUFFER_TOO_SMALL)
        goto done;

    __try { ptu = (TOKEN_USER *)_alloca(cb); }
    __except(EXCEPTION_EXECUTE_HANDLER) { ptu = NULL; }
    if (ptu == NULL)
    {
        Status = STATUS_SECTION_NOT_EXTENDED;
        goto done;
    }

    Status = NtQueryInformationToken(hToken, TokenUser, (LPVOID)ptu, cb, &cbGot);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    // make a copy of the owner SID so we can use it in the owner & group field
    cb = RtlLengthSid(ptu->User.Sid);
    psidOwner = (PSID)LocalAlloc(LMEM_FIXED, cb);
    if (psidOwner == NULL)
    {
        Status = STATUS_SECTION_NOT_EXTENDED;
        goto done;
    }

    Status = RtlCopySid(cb, psidOwner, ptu->User.Sid);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    // get the SID for local system acct
    Status = RtlAllocateAndInitializeSid(&siaNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                       0, 0, 0, 0, 0, 0, 0, &psidLS);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    cb = sizeof(ACL) + RtlLengthSid(psidLS) + RtlLengthSid(psidOwner) +
         2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD));

    if (dwWA != 0)
    {
        // get the SID for the world (everyone)
        Status = RtlAllocateAndInitializeSid(&siaNT, 1, 
                                             SECURITY_ANONYMOUS_LOGON_RID,
                                             0, 0, 0, 0, 0, 0, 0, &psidWorld);
                        

        // get the SID for the anonymous users acct
        Status = RtlAllocateAndInitializeSid(&siaWorld, 1, SECURITY_WORLD_RID,
                                             0, 0, 0, 0, 0, 0, 0, &psidAnon);
        if (NT_SUCCESS(Status) == FALSE)
            goto done;

        cb += RtlLengthSid(psidWorld) + RtlLengthSid(psidAnon) +
              2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD));
    }

    // make the DACL
    pacl = (PACL)LocalAlloc(LMEM_FIXED, cb);
    if (pacl == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto done;
    }

    Status = RtlCreateAcl(pacl, cb, ACL_REVISION);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    Status = RtlAddAccessAllowedAce(pacl, ACL_REVISION, dwOALS, psidOwner);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    Status = RtlAddAccessAllowedAce(pacl, ACL_REVISION, dwOALS, psidLS);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    if (dwWA != 0)
    {
        Status = RtlAddAccessAllowedAce(pacl, ACL_REVISION, dwWA, psidWorld);
        if (NT_SUCCESS(Status) == FALSE)
            goto done;

        Status = RtlAddAccessAllowedAce(pacl, ACL_REVISION, dwWA, psidAnon);
        if (NT_SUCCESS(Status) == FALSE)
            goto done;
    }

    // set the SD owner
    Status = RtlSetOwnerSecurityDescriptor(psd, psidOwner, TRUE);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    // set the SD group
    Status = RtlSetGroupSecurityDescriptor(psd, psidOwner, FALSE);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    // set the SD dacl
    Status = RtlSetDaclSecurityDescriptor(psd, TRUE, pacl, FALSE);
    if (NT_SUCCESS(Status) == FALSE)
        goto done;

    psidOwner = NULL;
    pacl      = NULL;

done:

    if (hToken != NULL)
        CloseHandle(hToken);

    if (psidLS != NULL)
        RtlFreeSid(psidLS);
    if (psidWorld != NULL)
        RtlFreeSid(psidWorld);
    if (psidAnon != NULL)
        RtlFreeSid(psidAnon);
    if (psidOwner != NULL)
        LocalFree(psidOwner);
    if (pacl != NULL)
        LocalFree(pacl);

    return Status;
}

// ***************************************************************************
void FreeDefSD(SECURITY_DESCRIPTOR *psd)
{
    BOOLEAN f1, f2;
    PSID    psid = NULL;
    PACL    pacl = NULL;

    if (psd == NULL)
        return;

    if (NT_SUCCESS(RtlGetOwnerSecurityDescriptor(psd, &psid, &f1)))
    {
        if (psid != NULL) 
            LocalFree(psid);
    }

    if (NT_SUCCESS(RtlGetDaclSecurityDescriptor(psd, &f1, &pacl, &f2)))
    {
        if (pacl != NULL)
            LocalFree(pacl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\server\sendmsg.c ===
/*************************************************************************
*
* sendmsg.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Terminal Server (Hydra) specific code
*
* Processend message to winstation
*
* $Author:  Ara bernardi
*
*************************************************************************/

//
// Includes
//

#include "precomp.h"
#pragma hdrstop

#include "dbt.h"
#include "ntdddisk.h"
#include "ntuser.h"

#include <winsta.h>
#include <wstmsg.h>
#include <winuser.h>

NTSTATUS ReplyInvalidWindowToTerminalServer (HWND hWnd, ULONG ulSessionId);
/*******************************************************************************
 *
 *  RemoteDoBrroadcastSystemMessage
 *
 * ENTRY:
 *
 * EXIT:
 *    STATUS_SUCCESS - successful
 *
 ******************************************************************************/

NTSTATUS
RemoteDoBroadcastSystemMessage(
    PWINSTATION_APIMSG pMsg)
{
    LONG rc;
    WINSTATIONBROADCASTSYSTEMMSG     *pmsg;
    LPARAM      tmpLPARAM;
    NTSTATUS    status;


    pmsg = &(pMsg->u.bMsg);

    if ( pmsg->bufferSize )
    {
        // we have a databuffer, set the lParam to our copied data buffer
        tmpLPARAM = (LPARAM)pmsg->dataBuffer;
    }
    else
    {
        tmpLPARAM = pmsg->lParam ;
    }

    rc = BroadcastSystemMessage( pmsg->dwFlags, &pmsg->dwRecipients,
                    pmsg->uiMessage, pmsg->wParam, tmpLPARAM );

    status = STATUS_SUCCESS;

    pmsg->Response = rc;

    return status ;
}



NTSTATUS
RemoteDoSendWindowMessage(
    PWINSTATION_APIMSG pMsg)
{
    static UINT uiReasonableTimeout = 10000;    // 10 sec.
    static BOOL bReadTimeout = FALSE;
    WINSTATIONSENDWINDOWMSG  *pmsg;
    LPARAM  tmpLPARAM;
    ULONG_PTR rc;


    if (!bReadTimeout)
    {
        HKEY hKey;
        UNICODE_STRING UnicodeString;
        OBJECT_ATTRIBUTES OA;
        NTSTATUS Status;

        //
        // read a timeout value from registry
        //
        RtlInitUnicodeString(&UnicodeString,
            L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server");
        InitializeObjectAttributes(&OA, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL);

        Status = NtOpenKey(&hKey, KEY_READ, &OA);
        if (NT_SUCCESS(Status))
        {

            BYTE Buf[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(DWORD)];
            DWORD cbSize;

            RtlInitUnicodeString(&UnicodeString, L"NotificationTimeOut");
            Status = NtQueryValueKey(hKey,
                    &UnicodeString,
                    KeyValuePartialInformation,
                    (PKEY_VALUE_PARTIAL_INFORMATION)Buf,
                    sizeof(Buf),
                    &cbSize);

            if (NT_SUCCESS(Status))
            {
                uiReasonableTimeout = *((PDWORD)((PKEY_VALUE_PARTIAL_INFORMATION)Buf)->Data);
                if (uiReasonableTimeout == 0)
                    uiReasonableTimeout = 10000;
            }

            NtClose(hKey);
        }

        bReadTimeout = TRUE;
    }

    pmsg = &(pMsg->u.sMsg);

    if ( pmsg->bufferSize )
    {
        // we have a databuffer, set the lParam to our copied data buffer
        tmpLPARAM = (LPARAM)pmsg->dataBuffer;
    }
    else
    {
        tmpLPARAM = (LPARAM)pmsg->lParam;
    }

    //
    // No need to worry about disconnected sessions (desktop), since msg is sent to a specific hwnd.
    // I have verified this imperically.
    //

    RIPMSG3(RIP_VERBOSE, "MEssage %x, wPAram %x, lParam %x", pmsg->Msg,
            pmsg->wParam, pmsg->lParam);

    if (pmsg->Msg == WM_WTSSESSION_CHANGE)
    {
        if (!PostMessage(pmsg->hWnd, pmsg->Msg, pmsg->wParam, pmsg->lParam) && ERROR_INVALID_WINDOW_HANDLE == GetLastError())
        {
            ReplyInvalidWindowToTerminalServer(pmsg->hWnd, gSessionId);
        }

        return STATUS_SUCCESS;

    }
    else if (pmsg->Msg == WM_APPCOMMAND)
    {
        GUITHREADINFO threadInfo;
        HWND hWndForeground;

        threadInfo.cbSize = sizeof(GUITHREADINFO);
        if (GetGUIThreadInfo(0, &threadInfo)) {
            hWndForeground = threadInfo.hwndFocus ? threadInfo.hwndFocus : threadInfo.hwndActive;
            if (hWndForeground) {
                RIPMSG1(RIP_WARNING, "Sending app command 0x%x", pmsg->wParam);
                SendNotifyMessage(hWndForeground,
                                  WM_APPCOMMAND,
                                  (WPARAM)hWndForeground,
                                  ((pmsg->wParam | FAPPCOMMAND_OEM)<<16));
                return STATUS_SUCCESS;
            } else {
                RIPMSG1(RIP_WARNING, "No window available to send to, error %x", GetLastError());
                return STATUS_UNSUCCESSFUL;
            }
        } else {
            RIPMSG1(RIP_WARNING, "Unable to get the focus window, error %x", GetLastError());
            return STATUS_UNSUCCESSFUL;
        }
    }
    else if (pmsg->Msg == WM_KEYDOWN || pmsg->Msg == WM_KEYUP)
    {
        INPUT input;

        ZeroMemory(&input, sizeof(INPUT));

        input.type = INPUT_KEYBOARD;
        input.ki.dwFlags = (pmsg->Msg == WM_KEYDOWN) ? 0 : KEYEVENTF_KEYUP;

        input.ki.wVk = LOWORD(pmsg->wParam);
        input.ki.wScan = LOWORD(pmsg->lParam);
        input.ki.dwFlags |= input.ki.wScan ? KEYEVENTF_UNICODE : KEYEVENTF_EXTENDEDKEY;
        RIPMSG4(RIP_WARNING, "Sending sc %c, vk %x, %s to session %x", input.ki.wScan,
                pmsg->wParam, (pmsg->Msg == WM_KEYDOWN) ? "down" : "up", gSessionId);

        SendInput(1, &input, sizeof(INPUT));
        return STATUS_SUCCESS;
    }
    else
    {
        if (!SendMessageTimeout(
                    pmsg->hWnd,
                    pmsg->Msg,
                    pmsg->wParam,
                    tmpLPARAM,
                    SMTO_ABORTIFHUNG | SMTO_NORMAL,
                    uiReasonableTimeout,
                    &rc))
        {
            RIPMSG1(RIP_WARNING, "SendMessageTimeOut failed. LastError = %d", GetLastError());
            return STATUS_UNSUCCESSFUL;
        }
        else
        {
            pmsg->Response = (ULONG)rc;
            return STATUS_SUCCESS;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\perf\perfmsg.h ===
/*++ BUILD Version: 0001

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:    perfmsg.h

Abstract:
    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Revision History:

--*/

#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_

//
// Report error message ID's for Counters
//

#define APP_NAME  "perfuser"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging
//             LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3
#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//
//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//

#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log

extern DWORD  dwLogUsers;  // counter of event log using routines

extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\perf\perfutil.h ===
/*++ BUILD Version: 0001

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:    perfutil.h

Abstract:

    This file supports routines used to parse and create Performance Monitor Data
    Structures. It actually supports Performance Object types with multiple instances

Revision History:
    Sept 97 Borrowed from the SDK samples and slightly modified

--*/

#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

//
//  Utility macro.  This is used to reserve a DWORD multiple of bytes for Unicode strings
//  embedded in the definitional data, viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)

#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];          // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];         // get data from foreign computers
extern WCHAR  COSTLY_STRING[];
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a performance data
// instance (PERF_INSTANCE_DEFINITION) as described in winperf.h
//

HANDLE  MonOpenEventLog ();
VOID    MonCloseEventLog ();
DWORD   GetQueryType (IN LPWSTR);

//
// To Do:
// Add a flag like this for additional objects added.
// Used by IsNumberInUnicodeListand Collect.
//

// special value: query all counters but the counter values doesn't matter
#define     QUERY_NOCOUNTERS  0x0001
#define     QUERY_USER        0x0002
#define     QUERY_CS          0x0004
DWORD   IsNumberInUnicodeList (LPWSTR);

#define ALLOC(size)      HeapAlloc (GetProcessHeap(), 0, size)
#define ALLOCZERO(size)  HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, size)
#define REALLOC(pointer, newsize) \
                         HeapReAlloc (GetProcessHeap(), 0, pointer, newsize)
#define FREE(pointer)    HeapFree (GetProcessHeap(), 0, pointer)

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\perf\perfuser.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:    perfuser.c

Abstract:
    This file implements the Extensible Objects for the User object type

Revision History

    July 97     MCostea     created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winuser.h>
#include <winperf.h>
#include <ntprfctr.h>
#include <string.h>
#include <wcstr.h>
#include "userctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "userdata.h"

#define ALL_PROCESSES_STRING L"_All Processes"

/*
 * Declared in winuserp.h
 */
#define QUC_PID_TOTAL       0xffffffff
#define QUERYUSER_TYPE_USER    0x1
#define QUERYUSER_TYPE_CS      0x2

/*
 *  The counters in CSSTATISTICS refer to the USER critical section:
 *      gCSExclusive counts how many times the CS was aquired exclusive
 *      gCSShared counts how many times the CS was aquired shared
 *      gCSTimeExclusive counts the time (NtQueryPerformanceCounter() units)
 *      spent in the resource since the last query.
 */
typedef struct _tagCSStatistics {
        DWORD   cExclusive;
        DWORD   cShared;
        __int64 i64TimeExclusive;
} CSSTATISTICS;

BOOL (WINAPI *QueryUserCounters)(DWORD, LPVOID, DWORD, LPVOID, DWORD );

/*
 *  References to constants which initialize the Object type definitions
 */
extern USER_DATA_DEFINITION UserDataDefinition;
extern CS_DATA_DEFINITION   CSDataDefinition;

/*
 * Global to store the process instances
 * This array is filled when the dll is attached (OpenUserPerformanceData)
 */
typedef struct _tagInstance {
    LPWSTR     pName;    // pointer to Unicode string
    DWORD      sizeName; // in bytes, including terminating NULL
    DWORD      id;       // client side ID
} ProcessInstance;

ProcessInstance *gaInstances;
int     gNumInstances;
PDWORD  gpPid;            // globals to store the allocate blocks of memory used
PDWORD  gpdwResult;       // as parameters in QueryUserCounters
DWORD   dwOpenCount;      // count of "Open" threads
HANDLE  ghHeap;
BOOL    gbInitOK;          // true = DLL initialized OK

/*
 * Function Prototypes
 * used to insure that the data collection functions
 * accessed by Perflib will have the correct calling format.
 */
DWORD GlobalCollect(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes,
    IN      DWORD   dwQueryType);
BOOL  FillInstances(VOID);

PM_OPEN_PROC    OpenUserPerformanceData;
PM_COLLECT_PROC CollectUserPerformanceData;
PM_CLOSE_PROC   CloseUserPerformanceData;

BOOL
__stdcall
DllInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
)
{
    char szUser32DllPath[MAX_PATH+15];
    HMODULE hUser32Module;
    ReservedAndUnused;
    /*
     *  this will prevent the DLL from getting the DLL_THREAD_* messages
     */
    DisableThreadLibraryCalls (DLLHandle);

    switch(Reason) {
        case DLL_PROCESS_ATTACH:

            if (!GetSystemDirectory(szUser32DllPath, MAX_PATH+1)) {
                return FALSE;
            }
            strcat( szUser32DllPath, "\\user32.dll");

            hUser32Module = GetModuleHandle(szUser32DllPath);
            if (!hUser32Module) {
                return FALSE;
            }
            QueryUserCounters = (BOOL (WINAPI  *)(DWORD, LPVOID, DWORD, LPVOID, DWORD ))
                            GetProcAddress(hUser32Module, "QueryUserCounters");
            if (!QueryUserCounters) {
                return FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

DWORD APIENTRY OpenUserPerformanceData(
    LPWSTR lpDeviceNames    )
/*++
Routine Description:

    This routine opens the interface with the event log and
    initializes the data structures used to pass data back to the registry.
    It also calls FillInstances.

Arguments:
    Pointer to object ID of each device to be opened

Return Value:
    None.
--*/
{
    LONG    status;
    HKEY    hKeyDriverPerf;
    DWORD   size;
    DWORD   type;
    DWORD   dwFirstCounter;
    DWORD   dwFirstHelp;

    PDWORD  pCounterNameTitleIndex;
    LPWSTR  *pCounterNameTitle;
    PDWORD  pCounterHelpTitleIndex;
    LPWSTR  *pCounterHelpTitle;
    int     i;

    /*
     *  Since SCREG is multi-threaded and will call this routine in
     *  order to service remote performance queries, this library
     *  must keep track of how many times it has been opened (i.e.
     *  how many threads have accessed it). the registry routines will
     *  limit access to the initialization routine to only one thread
     *  at a time so synchronization (i.e. reentrancy) should not be
     *  a problem
     */
    if (!dwOpenCount) {

        hEventLog = MonOpenEventLog();  // open Eventlog interface
        /*
         * get counter and help index base values from registry
         *      Open key to registry entry
         *      read First Counter and First Help values
         *      update static data structures by adding base to
         *      offset value in structure.
         */
        status = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\PerfUser\\Performance",
            0L,
            KEY_ALL_ACCESS,
            &hKeyDriverPerf);

        if (status != ERROR_SUCCESS) {
            REPORT_ERROR_DATA (USERPERF_UNABLE_OPEN_DRIVER_KEY, LOG_USER,
                &status, sizeof(status));
            /*
             * these failures are fatal, if we can't get the base values of the
             * counter or help names, then the names won't be available
             * to the requesting application  so there's not much
             * point in continuing.
             */
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Counter",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstCounter,
                     &size);

        if (status != ERROR_SUCCESS) {
            REPORT_ERROR_DATA (USERPERF_UNABLE_READ_FIRST_COUNTER, LOG_USER,
                &status, sizeof(status));
            goto OpenExitPoint;
        }

        status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Help",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstHelp,
                    &size);

        if (status != ERROR_SUCCESS) {
            REPORT_ERROR_DATA (USERPERF_UNABLE_READ_FIRST_HELP, LOG_USER,
                &status, sizeof(status));
            goto OpenExitPoint;
        }

        UserDataDefinition.UserObjectType.ObjectNameTitleIndex += dwFirstCounter;
        UserDataDefinition.UserObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        pCounterNameTitleIndex = &UserDataDefinition.NumTotals.CounterNameTitleIndex;
        pCounterHelpTitleIndex = &UserDataDefinition.NumTotals.CounterHelpTitleIndex;

        for (i = 0; i<NUM_USER_COUNTERS;
                i++,
                pCounterNameTitleIndex += sizeof(PERF_COUNTER_DEFINITION)/sizeof(DWORD),
                pCounterHelpTitleIndex += sizeof(PERF_COUNTER_DEFINITION)/sizeof(DWORD))
        {
            *pCounterNameTitleIndex += dwFirstCounter;
            *pCounterHelpTitleIndex += dwFirstHelp;
        }
        /*
         * Set CSDataDefinition indexes
         */
        CSDataDefinition.CSObjectType.ObjectNameTitleIndex += dwFirstCounter;
        CSDataDefinition.CSObjectType.ObjectHelpTitleIndex += dwFirstHelp;
        CSDataDefinition.CSExEnter.CounterNameTitleIndex += dwFirstCounter;
        CSDataDefinition.CSExEnter.CounterHelpTitleIndex += dwFirstHelp;
        CSDataDefinition.CSShEnter.CounterNameTitleIndex += dwFirstCounter;
        CSDataDefinition.CSShEnter.CounterHelpTitleIndex += dwFirstHelp;
        CSDataDefinition.CSExTime.CounterNameTitleIndex += dwFirstCounter;
        CSDataDefinition.CSExTime.CounterHelpTitleIndex += dwFirstHelp;

        RegCloseKey (hKeyDriverPerf); // close key to registry
        gbInitOK = TRUE;     // ok to use this function
    }

    dwOpenCount++;          // increment OPEN counter
    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}

DWORD APIENTRY CollectUserPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes)

/*++

Routine Description:    This routine will return the data for the User counters.

Arguments:
   IN       LPWSTR   lpValueName
            pointer to a wide character string passed by registry.
   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is written to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is written to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.
      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.
--*/
{

    //  Variables for reformatting the data
    PERF_COUNTER_BLOCK      *pPerfCounterBlock;
    USER_DATA_DEFINITION    *pUserDataDefinition;
    ULONG   SpaceNeeded;
    PDWORD  pdwCounter, dwProcList;
    DWORD   dwQueryType;
    DWORD   dwObjects;
    int     i;

    /*
     * before doing anything else, see if Open went OK
     */
    if (!gbInitOK) {
        // unable to continue because open failed.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    /*
     * see if this is a foreign (i.e. non-NT) computer data request
     */
    dwQueryType = GetQueryType (lpValueName);
    if (dwQueryType == QUERY_FOREIGN) {
        /*
         * this routine does not service requests for data from
         * Non-NT computers
         */
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }
    if (dwQueryType == QUERY_ITEMS) {
        if ( !(dwObjects = IsNumberInUnicodeList (lpValueName) )) {

            /*
             * request received for data object not provided by this routine
             */
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;

        }

        return GlobalCollect(
                lpValueName,
                lppData,
                lpcbTotalBytes,
                lpNumObjectTypes,
                dwObjects);
    }
    else {
        /*
         * General request to fill the instance combo-box
         * No need to actually retrieve the counter values
         */
        return GlobalCollect(
                lpValueName,
                lppData,
                lpcbTotalBytes,
                lpNumObjectTypes,
                QUERY_NOCOUNTERS);
    }

    return ERROR_SUCCESS;
}

DWORD APIENTRY
CloseUserPerformanceData()
/*++
Routine Description:
    This routine closes the open handles to win32k device performance counters

Arguments:
    None.

Return Value:
    ERROR_SUCCESS
--*/

{
    int i;
    if (!(--dwOpenCount)) { // when this is the last thread...
        MonCloseEventLog();
    }
    if (gpdwResult)
        FREE(gpdwResult);
    if (gpPid)
        FREE(gpPid);
    if (gaInstances) {
        for (i = 0; i<gNumInstances; i++) {
            FREE(gaInstances[i].pName);
        }
        FREE(gaInstances);
    }
    return ERROR_SUCCESS;
}

/*
 * As PerfMon calls GlobalCollect when it first loads the DLL
 * I will NOT call QueryUserCounters for it.
 * This is decided by the value of startMonitoring
 */
DWORD GlobalCollect(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes,
    IN      DWORD   dwQueryType)
{
    PERF_COUNTER_BLOCK      *pPerfCounterBlock;
    USER_DATA_DEFINITION    *pUserDataDefinition;
    CS_DATA_DEFINITION      *pCSDataDefinition;
    static CSSTATISTICS     PrevCSStatistics;
    static __int64          i64Frecv;
    PERF_INSTANCE_DEFINITION    *pPerfInstanceDefinition;
    PDWORD  pdwCounter;     // write pointer in the lppData
    DWORD   dwTotal, dwSpaceNeeded;
    int     i, counter;

    /*
     *  FillInstances() is quite expensive and should normally be called only
     *  once, in OpenUserPerformanceData().  The problem is that, when monitoring
     *  remote machines, the Open get called by screg.exe only once, no matter how
     *  many remote "probes" are attached.  So, if there are new processes on the
     *  target machine, they can not be seen by the probes that are added afterwards.
     */
    if (dwQueryType & (QUERY_USER | QUERY_NOCOUNTERS)) {
        if (!FillInstances()) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }
    /*
     * First make sure we have enough space
     * If the space will not sufice, we will get called again with a larger buffer
     */
    dwSpaceNeeded = 0;
    if (dwQueryType & (QUERY_USER | QUERY_NOCOUNTERS)) {
        dwSpaceNeeded += (gNumInstances)*(
                            sizeof(PERF_INSTANCE_DEFINITION) +
                            MAX_PATH * sizeof (WCHAR) +
                            sizeof(PERF_COUNTER_BLOCK) + SIZE_OF_USER_PERFORMANCE_DATA) +
                            sizeof(USER_DATA_DEFINITION);
    }
    if (dwQueryType & (QUERY_CS | QUERY_NOCOUNTERS)) {
        dwSpaceNeeded += SIZE_OF_CS_PERFORMANCE_DATA
                        + sizeof(CS_DATA_DEFINITION)
                        + sizeof(PERF_COUNTER_BLOCK);
    }
    if (*lpcbTotalBytes < dwSpaceNeeded) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
    }

    /*
     * fill the return data
     */

    *lpNumObjectTypes = 0;
    /*
     * pUserDataDefinition also keeps track of the buffer starting point
     */
    pUserDataDefinition = (USER_DATA_DEFINITION *) *lppData;
    pdwCounter = (DWORD *) *lppData;

    if (dwQueryType & (QUERY_USER | QUERY_NOCOUNTERS)) {
        /*
         * USER object is requested
         */
        (*lpNumObjectTypes) ++;

        if (dwQueryType & QUERY_USER) {
            if (!NT_SUCCESS(QueryUserCounters(QUERYUSER_TYPE_USER,
                                gpPid, gNumInstances*sizeof(DWORD),
                                gpdwResult, (NUM_USER_COUNTERS-1)*gNumInstances*sizeof(DWORD)))) {
                *lpcbTotalBytes = (DWORD) 0;
                *lpNumObjectTypes = (DWORD) 0;
                return ERROR_SUCCESS;
            }
        }
        else {
            memset(gpdwResult, 0, sizeof(DWORD)*gNumInstances*NUM_USER_COUNTERS);
        }
        /*
         * Copy the (constant, initialized) Object Type and counter definitions
         * to the caller's data buffer
         */
        memmove(pUserDataDefinition, &UserDataDefinition, sizeof(USER_DATA_DEFINITION));
        pUserDataDefinition->UserObjectType.NumInstances = gNumInstances;

        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *) &pUserDataDefinition[1];
        for (i = 0; i < gNumInstances; i++) {

            /*
             * Collect and format all process instances
             */
            pPerfInstanceDefinition->ParentObjectTitleIndex = 0;
            pPerfInstanceDefinition->ParentObjectInstance = 0;
            pPerfInstanceDefinition->UniqueID = (LONG)gaInstances[i].id;
            pPerfInstanceDefinition->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
            pPerfInstanceDefinition->NameLength = gaInstances[i].sizeName;

            pPerfInstanceDefinition->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                                        pPerfInstanceDefinition->NameLength;

            wcscpy((wchar_t*)((PBYTE)pPerfInstanceDefinition + sizeof(PERF_INSTANCE_DEFINITION)),
                    gaInstances[i].pName);

            pPerfCounterBlock = (PERF_COUNTER_BLOCK *) ((PBYTE)pPerfInstanceDefinition
                                + pPerfInstanceDefinition->ByteLength);

            pPerfCounterBlock->ByteLength = SIZE_OF_USER_PERFORMANCE_DATA;
            pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

            for (counter = dwTotal = 0; counter<NUM_USER_COUNTERS-1; counter++) {
                dwTotal += gpdwResult[i*(NUM_USER_COUNTERS-1)+counter];
            }
            *pdwCounter++ = dwTotal;
            memmove(pdwCounter,  gpdwResult + i*(NUM_USER_COUNTERS-1), (NUM_USER_COUNTERS-1)*sizeof(DWORD));
            pdwCounter += NUM_USER_COUNTERS-1;

            pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)pdwCounter;
        }

        ((USER_DATA_DEFINITION *)*lppData)->UserObjectType.TotalByteLength =
                (ULONG)((PBYTE)pdwCounter - (PBYTE)pUserDataDefinition);
    }

    if (dwQueryType & (QUERY_CS | QUERY_NOCOUNTERS)) {
        /*
         * CS object is requested
         */
        (*lpNumObjectTypes) ++;

        /*
         * Write CS_DATA_DEFINITION object, no instances
         *
         * Copy the (constant, initialized) Object Type and counter definitions
         * to the caller's data buffer
         */
        pCSDataDefinition = (CS_DATA_DEFINITION *)pdwCounter;
        memmove(pCSDataDefinition, &CSDataDefinition, sizeof(CS_DATA_DEFINITION));

        pPerfCounterBlock = (PERF_COUNTER_BLOCK *) &pCSDataDefinition[1];
        pPerfCounterBlock->ByteLength = SIZE_OF_CS_PERFORMANCE_DATA;

        pdwCounter = (DWORD *) &pPerfCounterBlock[1];

        if (dwQueryType & QUERY_NOCOUNTERS) {
            memset(pdwCounter, 0, sizeof(DWORD)*NUM_CS_COUNTERS);
        }
        else {
            CSSTATISTICS CSCounters;

            /*
             * When entering for the first time, grab the hardware
             * cycle counter frequency (if any)
             */
            if (!PrevCSStatistics.i64TimeExclusive) {

                if (!QueryPerformanceFrequency((LARGE_INTEGER*)&i64Frecv))
                    i64Frecv = 0;
            }
            /*
             * Retrieve the CS counters
             */
             if (!QueryUserCounters(QUERYUSER_TYPE_CS, NULL, 0, &CSCounters, sizeof(CSSTATISTICS))) {
                REPORT_ERROR (USERPERF_CS_CANT_QUERY, LOG_USER);
             }
             /*
              * In case of overflow, the error will be of 1, no big deal
              */
             *pdwCounter = CSCounters.cExclusive - PrevCSStatistics.cExclusive;
             *(pdwCounter + 1) = CSCounters.cShared - PrevCSStatistics.cShared;

             if (i64Frecv) {
                 /*
                  * Translate the value in counts per milisecond
                  */
                  *(pdwCounter + 2) = (DWORD)((CSCounters.i64TimeExclusive-PrevCSStatistics.i64TimeExclusive)*1000/i64Frecv);
             }
             else {
                 /*
                  * No support for high resolution timer in the hardware
                  */
                  *(pdwCounter + 2) = 0;
             }

             PrevCSStatistics.cExclusive = CSCounters.cExclusive;
             PrevCSStatistics.cShared = CSCounters.cShared;
             PrevCSStatistics.i64TimeExclusive = CSCounters.i64TimeExclusive;
        }
        pdwCounter += NUM_CS_COUNTERS;
    }


    /*
     *  update arguments for return
     */
    *lpcbTotalBytes = (ULONG)((PBYTE)pdwCounter - (PBYTE)*lppData);
    *lppData = (PVOID) pdwCounter;

    return ERROR_SUCCESS;
}


VOID CleanUpInstances(VOID)
/*++
Routine Description:
    Clean-up previous allocated memory
    Helper function

--*/
{
    int i;

    if (gaInstances) {
        for (i = 0; i<gNumInstances; i++) {
            FREE(gaInstances[i].pName);
        }
        FREE(gaInstances);
        gaInstances = NULL;
    }
}

BOOL FillInstances(VOID)
/*++

Routine Description:
    This routine will fill the gaInstances array when the performance dll is opened
    The data in gaInstances will be used for every Collect call

Arguments:      none

Return Value:   success status

--*/
{
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    ULONG   TotalOffset = 0, ResultLength;
    PWCHAR  p, pPeriod;
    DWORD   status;
    UCHAR   *pLargeBuffer;
    int     cNumAllocatedInstances;
    int     i, oldInstances;

    oldInstances  = gNumInstances;
    gNumInstances = 0;

    CleanUpInstances();

    if (!(pLargeBuffer = ALLOC(sizeof(UCHAR)*64*1024))) {
        REPORT_ERROR_DATA (STATUS_NO_MEMORY, LOG_USER,
                    &status, sizeof(status));
        return FALSE;
    }

    status = NtQuerySystemInformation(
                SystemProcessInformation,
                pLargeBuffer,
                sizeof(UCHAR)*64*1024,
                &ResultLength);
    if (!NT_SUCCESS(status)) {
        goto ExitNoMemory;
    }

    cNumAllocatedInstances = ResultLength/sizeof(SYSTEM_PROCESS_INFORMATION);
    gaInstances = ALLOC(cNumAllocatedInstances*sizeof(ProcessInstance));
    if (!gaInstances) {

        REPORT_ERROR_DATA (STATUS_NO_MEMORY, LOG_USER,
            &status, sizeof(status));
        goto ExitNoMemory;
    }

    /*
     * create the first instance named _All Processes so that it will usualy show
     * the first in the list
     */
    gaInstances[gNumInstances].sizeName = sizeof(ALL_PROCESSES_STRING);
    gaInstances[gNumInstances].id = QUC_PID_TOTAL;
    gaInstances[gNumInstances].pName = ALLOC(gaInstances[gNumInstances].sizeName);
    if (!gaInstances[gNumInstances].pName) {
        REPORT_ERROR_DATA (STATUS_NO_MEMORY, LOG_USER,
            &status, sizeof(status));
        goto ExitNoMemory;
    }
    wcscpy(gaInstances[gNumInstances].pName, ALL_PROCESSES_STRING);
    gNumInstances++;

    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pLargeBuffer;
    while (TRUE) {
        if ( ProcessInfo->ImageName.Buffer ) {
            p = wcsrchr(ProcessInfo->ImageName.Buffer, L'\\');
            if ( p ) {
                p++;
                }
            else {
                p = ProcessInfo->ImageName.Buffer;
                }
            /*
             *  remove .exe from the name
             */
            if (pPeriod =  wcsrchr(p, L'.'))
                *pPeriod = L'\0';
            }
        else {
                p = L"SystemProc";
            }
        gaInstances[gNumInstances].sizeName = wcslen(p);
        /*
         *  convert to bytes
         */
        gaInstances[gNumInstances].sizeName = (gaInstances[gNumInstances].sizeName + 1)
                                                * sizeof(WCHAR);
        gaInstances[gNumInstances].pName = ALLOC(gaInstances[gNumInstances].sizeName);
        if (!gaInstances[gNumInstances].pName) {
            REPORT_ERROR_DATA (STATUS_NO_MEMORY, LOG_USER,
                &status, sizeof(status));
            goto ExitNoMemory;
        }
        wcscpy(gaInstances[gNumInstances].pName, p);
        gaInstances[gNumInstances].id = (WORD)ProcessInfo->UniqueProcessId;
        gNumInstances++;

        if (ProcessInfo->NextEntryOffset == 0) {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)((BYTE*)pLargeBuffer + TotalOffset);
    }

    FREE(pLargeBuffer);
    pLargeBuffer = NULL;

    if (oldInstances != gNumInstances) {
        /*
         *  adjust the global buffers
         */
        if (gpdwResult)
            FREE(gpdwResult);
        if (gpPid)
            FREE(gpPid);

        if (!(gpdwResult = ALLOC(sizeof(DWORD)*gNumInstances*NUM_USER_COUNTERS))) {
            gpdwResult = NULL;
            goto ExitNoMemory;
        }

        if (!(gpPid = ALLOC(sizeof(DWORD)*gNumInstances))) {
            gpPid = NULL;
            goto ExitNoMemory;
        }
        for (i = 0; i < gNumInstances; i++) {
            gpPid[i] = gaInstances[i].id;
        }
    }
    return TRUE;

ExitNoMemory:

    CleanUpInstances();

    if (pLargeBuffer) {
        FREE(pLargeBuffer);
    }
    gbInitOK = FALSE;
    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\perf\userdata.h ===
/*++ BUILD Version: 0001

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

      userdata.h

Abstract:

    Header file for the USER Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    win32k.sys is placed into the structures shown here.

Revisions:
    Sept 15 1997    MCostea     Added CriticalSection object

--*/

#ifndef _USERDATA_H_
#define _USERDATA_H_

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundaries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following define when adding an object type.

#define USER_NUM_PERF_OBJECT_TYPES 2

//
// Create a section like this for each performance object you add
//

//----------------------------------------------------------------------------
//
//  USER Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

//
// If adding more counters please preserve NumTotals as the first one and
// NumInputContexts as the last one.  The counters are sorted in perfmon
//
#define NUM_TOTALS_OFFSET         sizeof(DWORD)
#define NUM_FREEONES_OFFSET       NUM_TOTALS_OFFSET     + sizeof(DWORD)
#define NUM_WINDOWS_OFFSET        NUM_FREEONES_OFFSET       + sizeof(DWORD)
#define NUM_MENUS_OFFSET          NUM_WINDOWS_OFFSET    + sizeof(DWORD)
#define NUM_CURSORS_OFFSET        NUM_MENUS_OFFSET      + sizeof(DWORD)
#define NUM_SETWINDOWPOS_OFFSET   NUM_CURSORS_OFFSET    + sizeof(DWORD)
#define NUM_HOOKS_OFFSET          NUM_SETWINDOWPOS_OFFSET   + sizeof(DWORD)
#define NUM_CLIPDATAS_OFFSET      NUM_HOOKS_OFFSET      + sizeof(DWORD)
#define NUM_CALLPROCS_OFFSET      NUM_CLIPDATAS_OFFSET  + sizeof(DWORD)
#define NUM_ACCELTABLES_OFFSET    NUM_CALLPROCS_OFFSET  + sizeof(DWORD)
#define NUM_DDEACCESS_OFFSET      NUM_ACCELTABLES_OFFSET    + sizeof(DWORD)
#define NUM_DDECONVS_OFFSET       NUM_DDEACCESS_OFFSET  + sizeof(DWORD)
#define NUM_DDEXACTS_OFFSET       NUM_DDECONVS_OFFSET   + sizeof(DWORD)
#define NUM_MONITORS_OFFSET       NUM_DDEXACTS_OFFSET   + sizeof(DWORD)
#define NUM_KBDLAYOUTS_OFFSET     NUM_MONITORS_OFFSET   + sizeof(DWORD)
#define NUM_KBDFILES_OFFSET       NUM_KBDLAYOUTS_OFFSET + sizeof(DWORD)
#define NUM_WINEVENTHOOKS_OFFSET  NUM_KBDFILES_OFFSET   + sizeof(DWORD)
#define NUM_TIMERS_OFFSET         NUM_WINEVENTHOOKS_OFFSET  + sizeof(DWORD)
#define NUM_INPUTCONTEXTS_OFFSET  NUM_TIMERS_OFFSET     + sizeof(DWORD)

#define SIZE_OF_USER_PERFORMANCE_DATA \
                    NUM_INPUTCONTEXTS_OFFSET + sizeof(DWORD)

typedef struct _USER_DATA_DEFINITION {
    PERF_OBJECT_TYPE           UserObjectType;
    PERF_COUNTER_DEFINITION    NumTotals;
    PERF_COUNTER_DEFINITION    NumFreeOnes;
    PERF_COUNTER_DEFINITION    NumWindows;
    PERF_COUNTER_DEFINITION    NumMenus;
    PERF_COUNTER_DEFINITION    NumCursors;
    PERF_COUNTER_DEFINITION    NumSetwindowPos;
    PERF_COUNTER_DEFINITION    NumHooks;
    PERF_COUNTER_DEFINITION    NumClipdatas;
    PERF_COUNTER_DEFINITION    NumCallProcs;
    PERF_COUNTER_DEFINITION    NumAccelTables;
    PERF_COUNTER_DEFINITION    NumDDEAccess;
    PERF_COUNTER_DEFINITION    NumDDEConvs;
    PERF_COUNTER_DEFINITION    NumDDEXActs;
    PERF_COUNTER_DEFINITION    NumMonitors;
    PERF_COUNTER_DEFINITION    NumKBDLayouts;
    PERF_COUNTER_DEFINITION    NumKBDFiles;
    PERF_COUNTER_DEFINITION    NumWinEventHooks;
    PERF_COUNTER_DEFINITION    NumTimers;
    PERF_COUNTER_DEFINITION    NumInputContexts;
} USER_DATA_DEFINITION;
#define NUM_USER_COUNTERS    (sizeof(USER_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/sizeof(PERF_COUNTER_DEFINITION)

//----------------------------------------------------------------------------
//
//  Critical Section object definition
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define CS_EXENTER_OFFSET         sizeof(DWORD)
#define CS_SHENTER_OFFSET         CS_EXENTER_OFFSET + sizeof(DWORD)
#define CS_EXTIME_OFFSET          CS_SHENTER_OFFSET + sizeof(DWORD)

#define SIZE_OF_CS_PERFORMANCE_DATA \
                    CS_EXTIME_OFFSET + sizeof(DWORD)

typedef struct _CS_DATA_DEFINITION {
    PERF_OBJECT_TYPE           CSObjectType;
    PERF_COUNTER_DEFINITION    CSExEnter;
    PERF_COUNTER_DEFINITION    CSShEnter;
    PERF_COUNTER_DEFINITION    CSExTime;
} CS_DATA_DEFINITION;
#define NUM_CS_COUNTERS    (sizeof(CS_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/sizeof(PERF_COUNTER_DEFINITION)

#pragma pack ()

#endif //_USERDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\perf\userdata.c ===
/*++ BUILD Version: 0001

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    userdata.c

Abstract:

    A file containing the constant data structures used by the Performance
    Monitor data for the USER Extensible Objects.

Revision History:

    Sept 97 MCostea Created
    Oct. 97 MCostea Added Critical Section Object

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include "userctrnm.h"
#include "userdata.h"

//
//  Constant structure initializations
//      defined in userdata.h
//

USER_DATA_DEFINITION UserDataDefinition = {

    {
        0,
        sizeof(UserDataDefinition),
        sizeof(PERF_OBJECT_TYPE),
        USEROBJ,
        0,
        USEROBJ,
        0,
        PERF_DETAIL_NOVICE,
        NUM_USER_COUNTERS,
        0,
        0,
        0
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        TOTALS,
        0,
        TOTALS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_TOTALS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        FREEONES,
        0,
        FREEONES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_FREEONES_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        WINDOWS,
        0,
        WINDOWS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_WINDOWS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        MENUS,
        0,
        MENUS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_MENUS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        CURSORS,
        0,
        CURSORS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_CURSORS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        SETWINDOWPOS,
        0,
        SETWINDOWPOS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_SETWINDOWPOS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        HOOKS,
        0,
        HOOKS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_HOOKS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        CLIPDATAS,
        0,
        CLIPDATAS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_CLIPDATAS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        CALLPROCS,
        0,
        CALLPROCS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_CALLPROCS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        ACCELTABLES,
        0,
        ACCELTABLES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_ACCELTABLES_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        DDEACCESS,
        0,
        DDEACCESS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DDEACCESS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        DDECONVS,
        0,
        DDECONVS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DDECONVS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        DDEXACTS,
        0,
        DDEXACTS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DDEXACTS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        MONITORS,
        0,
        MONITORS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_MONITORS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        KBDLAYOUTS,
        0,
        KBDLAYOUTS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_KBDLAYOUTS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        KBDFILES,
        0,
        KBDFILES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_KBDFILES_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        WINEVENTHOOKS,
        0,
        WINEVENTHOOKS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_WINEVENTHOOKS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        TIMERS,
        0,
        TIMERS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_TIMERS_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        INPUTCONTEXTS,
        0,
        INPUTCONTEXTS,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_INPUTCONTEXTS_OFFSET
    }

};



CS_DATA_DEFINITION CSDataDefinition = {

    {
        sizeof(CS_DATA_DEFINITION) + SIZE_OF_CS_PERFORMANCE_DATA,
        sizeof(CS_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        CSOBJ,
        0,
        CSOBJ,
        0,
        PERF_DETAIL_NOVICE,
        NUM_CS_COUNTERS,
        0,
        PERF_NO_INSTANCES,
        0
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        EXENTER,
        0,
        EXENTER,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_VALUE | PERF_SIZE_DWORD,
        sizeof(DWORD),
        CS_EXENTER_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        SHENTER,
        0,
        SHENTER,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_VALUE | PERF_SIZE_DWORD,
        sizeof(DWORD),
        CS_SHENTER_OFFSET
    },

    {
        sizeof(PERF_COUNTER_DEFINITION),
        EXTIME,
        0,
        EXTIME,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        CS_EXTIME_OFFSET
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\perf\perfutil.c ===
/*++ BUILD Version: 0001

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:    perfutil.c

Abstract:
    This file implements the utility routines used to construct the
    common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Revision History:
--*/

//
//  include files
//

#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "userctrs.h"     // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "userdata.h"
#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG   ulInfoBufferSize = 0;
HANDLE  hEventLog   = NULL;    // event log handle for reporting events
                               // initialized in Open... routines
DWORD   dwLogUsers      = 0;   // count of functions using event log
DWORD   MESSAGE_LEVEL   = 0;
WCHAR   GLOBAL_STRING[]     = L"Global";
WCHAR   FOREIGN_STRING[]    = L"Foreign";
WCHAR   COSTLY_STRING[]     = L"Costly";
WCHAR   NULL_STRING[]       = L"\0";

//
// Global data from userdata.c
//
extern USER_DATA_DEFINITION UserDataDefinition;
extern CS_DATA_DEFINITION CSDataDefinition;

// pointer to null string
// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//

#define DIGIT       1
#define DELIMITER   2
#define ENDOFSTRING 3
#define INVALID     4
#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? ENDOFSTRING : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

HANDLE MonOpenEventLog ()
/*++
Routine Description:

    Reads the level of event logging from the registry and opens the
    channel to the event logger for subsequent event log entries.

Arguments:
        None

Return Value:
        Handle to the event log for reporting events.
        NULL if open not successful.
--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\PerfLib";
    TCHAR LogLevelValueName[] = "EventLogLevel";
    LONG lStatus;
    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {
        lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);
        dwValueSize = sizeof (dwLogLevel);
        if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);
            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            }
            else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
        }
        else {
            MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
        }
    }
    if (hEventLog == NULL) {
        hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry
         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }
    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}

VOID MonCloseEventLog ()
/*++
Routine Description:
      Closes the handle to the event logger if this is the last caller

Arguments:      None

Return Value:   None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;               // decrement usage
        if (dwLogUsers <= 0) {      // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD GetQueryType (
    IN LPWSTR lpValue)
/*++
Routine Description:
    Returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments
    IN lpValue
    string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string
    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string
    QUERY_COSTLY
        if lpValue == pointer to "Costly" string
    otherwise:

    QUERY_ITEMS

--*/

{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;
    if (lpValue == 0) {
        return QUERY_GLOBAL;
    }
    else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request
    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }
    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }
    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }
    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;
}

DWORD
IsNumberInUnicodeList (
    IN LPWSTR  lpwszUnicodeList
)
/*++
Routine Description:
    When querying counters, the collect function receives a list of Unicode strings
    representing object indexes.  This function parses the string and returns a bit
    combination representing the needed objects.

Arguments:
     IN lpwszUnicodeList
        Null terminated, space delimited list of decimal numbers

Return Value:
    The returned DWORD is a combination of QUERY_USER and QUERY_CS
--*/
{
    DWORD   dwThisNumber;
    DWORD   dwReturnValue;
    WCHAR   *pwcThisChar;
    WCHAR   wcDelimiter;
    BOOL    bValidNumber;
    BOOL    bNewItem;

    if (lpwszUnicodeList == 0) return 0;    // null pointer, # not found

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    dwReturnValue = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            case ENDOFSTRING:
            case DELIMITER:
                // a delimiter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == UserDataDefinition.UserObjectType.ObjectNameTitleIndex) {
                        dwReturnValue |= QUERY_USER;
                    }
                    else if (dwThisNumber == CSDataDefinition.CSObjectType.ObjectNameTitleIndex) {
                        dwReturnValue |= QUERY_CS;
                    }
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return dwReturnValue;
                }
                else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
    pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\perf\userctrnm.h ===
//
//  userctrnm.h
//
//  Offset definition file for extensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values for the device they belong to,
//  in order to determine the absolute location of the counter and
//  object names and corresponding Explain text in the registry.
//
//  This file is used by the extensible counter DLL code as well as the
//  counter name and Explain text definition file (names.txt) file that is used
//  by LODCTR to load the names into the registry.
//
//  To Do: Add your object and it's counters at the end.
//


#define USEROBJ         0
#define TOTALS          2
#define FREEONES        4
#define WINDOWS         6
#define MENUS           8
#define CURSORS         10
#define SETWINDOWPOS    12
#define HOOKS           14
#define CLIPDATAS       16
#define CALLPROCS       18
#define ACCELTABLES     20
#define DDEACCESS       22
#define DDECONVS        24
#define DDEXACTS        26
#define MONITORS        28
#define KBDLAYOUTS      30
#define KBDFILES        32
#define WINEVENTHOOKS   34
#define TIMERS          36
#define INPUTCONTEXTS   38
#define CSOBJ           40
#define EXENTER         42
#define SHENTER         44
#define EXTIME          46
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\showicon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ShowIcon.rc
//
#define IDC_MYICON                      2
#define IDD_SHOWICON_DIALOG             102
#define IDD_ABOUTBOX                    103
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDS_HELLO                       106
#define IDI_SHOWICON                    107
#define IDI_SMALL                       108
#define IDC_SHOWICON                    109
#define IDR_MAINFRAME                   128
#define IDI_SAMPLE16                    129
#define IDI_SAMPLE64                    130
#define IDI_SAMPLE32                    131
#define IDI_ICON1                       132
#define IDM_FILE_EXTRACTICON            133
#define IDD_EXTRACTICON                 134
#define IDM_NORMALDC                    135
#define IDM_METAFILEDC                  136
#define IDM_ENHMETAFILEDC               137
#define IDC_EI_ICONINDEX                1000
#define IDC_EI_NUMICONS                 1001
#define IDM_SAMPLE16                    32771
#define IDM_SAMPLE32                    32772
#define IDM_SAMPLE64                    32773
#define VIEW_ICON                       32774
#define VIEW_MASK                       32775
#define VIEW_COLOR                      32776
#define VIEW_ICONCURSOR                 32777
#define VIEW_REALCURSOR                 32778
#define VIEW_DEFAULTCURSOR              32779
#define VIEW_ALPHA                      32780
#define IDM_FILE_OPEN                   32781
#define IDM_DEFAULT_SIZE                32782
#define IDM_REAL_SIZE                   32783
#define IDM_SIZE_16                     32784
#define IDM_SIZE_32                     32785
#define IDM_SIZE_48                     32786
#define IDM_SIZE_64                     32787
#define IDM_SIZE_96                     32788
#define IDM_SIZE_128                    32789
#define VIEW_REFRESH                    32790
#define IDM_APPICON                     32791
#define IDM_FILE_REOPEN                 32792
#define IDM_MYCOMPUTER                  32793
#define IDI_MYCOMPUTER                  32794
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        138
#define _APS_NEXT_COMMAND_VALUE         32795
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\aw.h ===
// aw.h

// IF(ansi, widechar)
// AW(x)        add suffix (A or W)
// L(x)         makes widechar when WIDE is defined

#ifdef AW
#undef AW
#endif
#ifdef IF
#undef IF
#endif
#ifdef L
#undef L
#endif

#ifndef CONCAT
#define CONCAT(a,b) a##b
#endif

#if defined(WIDE) && (WIDE)

#define IF(a,w) w
#define AW(x)   x##W
#define L(x)    CONCAT(L, x)

#else

#define IF(a,w) a
#define AW(x)   x##A
#define L(x)    x

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\ab.h ===
// ab.h

// Input:
// A1: A or W: Ansi, Wide
// A2: A or W

// macros: (where x is 1 or 2)
// IFx(ansi,wide)
// AWx:         adds suffix (A or W)
// Lx(a)        makes widechar

#if !defined(A1) || !defined(A2)
#error A1 and A2 must be defined as A or W
#endif

#ifdef AW1

#undef AW1
#undef AW2
#undef IF1
#undef IF2
#undef L1
#undef L2
#undef FAW

#endif

#ifndef CONCAT
#define CONCAT(a,b) a##b
#endif

#if A1

#define IF1(a,w)    w
#define AW1(x)   x##W
#define L1(x)    CONCAT(L, x)

#else

#define IF1(a,w)    a
#define AW1(x)  x##A
#define L1(x)   x

#endif

#if A2

#define IF2(a,w)    w
#define AW2(x)  x##W
#define L2(x)   CONCAT(L, x)

#else

#define IF2(a,w)    a
#define AW2(x)  x##A
#define L2(x)   x

#endif

#if A1
#if A2
#define FAW(x)  x##WW
#else
#define FAW(x)  x##WA
#endif
#else
#if A2
#define FAW(x)  x##AW
#else
#define FAW(x)  x##AA
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\showicon\showicon.cpp ===
#include "ShowIcon.h"

HINSTANCE g_hInstance;

enum ICONVIEW
{
    IV_ICON,
    IV_MASK,
    IV_COLOR,
    IV_ALPHA
};

enum CURSORVIEW
{
    CV_ICON,
    CV_CURSOR,
    CV_DEFAULT
};

enum LOADOPTIONS
{
    LO_DEFAULT,
    LO_REAL,
    LO_16,
    LO_32,
    LO_48,
    LO_64,
    LO_96,
    LO_128
};

enum DISPLAYOPTIONS
{
    DO_NORMALDC,
    DO_METAFILEDC,
    DO_ENHMETAFILEDC
};

struct VIEWDATA
{
    ICONINFO iconinfo;
    HICON hIcon;
    HCURSOR hIconCursor;
    HCURSOR hDefaultCursor;
    HBITMAP hbmpAlpha;
    HBITMAP hbmpPreMultiplied;  // Premultiplied version of the color bitmap.
    HBRUSH hbrBackground;
};

/////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK ExtractIconDlgProc(
    HWND hwndDlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    static int * pcIcons = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            pcIcons = (int *)lParam;
            WCHAR strDesc[100];
            wsprintf(strDesc, L"There are %d icons in this file.", *pcIcons);
            SetDlgItemText(hwndDlg, IDC_EI_NUMICONS, strDesc);
            SetDlgItemInt(hwndDlg, IDC_EI_ICONINDEX, 0, FALSE);
        }
        break;

    case WM_COMMAND:
        {
            WORD wCommand = LOWORD(wParam);
            switch(wCommand)
            {
            case IDOK:
                {
                    BOOL fTranslated = FALSE;

                    *pcIcons = GetDlgItemInt(hwndDlg, IDC_EI_ICONINDEX, &fTranslated, FALSE);
                    if(!fTranslated || (*pcIcons < 0)) {
                        *pcIcons = -1;
                    }
                }
                EndDialog(hwndDlg, IDOK);
                break;

            case IDCANCEL:
                *pcIcons = -1;
                EndDialog(hwndDlg, IDCANCEL);
                break;
            }
        }
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
void GetBitmapSize(VIEWDATA & vd, DWORD & dwWidth, DWORD & dwHeight, bool & fAlpha)
{
    BITMAP bmp;

    if (vd.iconinfo.hbmColor != NULL) {
        if (!GetObject(vd.iconinfo.hbmColor, sizeof(BITMAP), (LPSTR) &bmp)) {
            bmp.bmWidth = 0;
            bmp.bmHeight = 0;
            bmp.bmBitsPixel = 0;
        }
    } else {
        if (GetObject(vd.iconinfo.hbmMask, sizeof(BITMAP), (LPSTR) &bmp)) {
            bmp.bmHeight /= 2;
        } else {
            bmp.bmWidth = 0;
            bmp.bmHeight = 0;
            bmp.bmBitsPixel = 0;
        }
    }

    dwWidth = bmp.bmWidth;
    dwHeight = bmp.bmHeight;

    //
    // Note: This just means that the bitmap MIGHT have an alpha channel.
    //
    fAlpha = (bmp.bmBitsPixel == 32 && bmp.bmPlanes == 1);
}

/////////////////////////////////////////////////////////////////////////////
void SetShowIconTitle(HWND hwndMain, TCHAR * pszFileName, VIEWDATA & vd)
{
    TCHAR szTitle[MAX_PATH * 2];
    DWORD dwWidth, dwHeight;
    bool fAlpha = false;
    
    GetBitmapSize(vd, dwWidth, dwHeight, fAlpha);
        
    wsprintf(szTitle,
            TEXT("ShowIcon [%dx%d] - %s"),
            dwWidth,
            dwHeight,
            NULL == pszFileName ? TEXT("[Internal]") : pszFileName);
    SetWindowText(hwndMain, szTitle);
}

/////////////////////////////////////////////////////////////////////////////
void InitializeViewData(VIEWDATA & vd)
{
    vd.hIcon = NULL;
    vd.hIconCursor = NULL;
    vd.hDefaultCursor = LoadCursor(NULL, IDC_ARROW);
    vd.iconinfo.hbmColor = NULL;
    vd.iconinfo.hbmMask = NULL;
    vd.iconinfo.fIcon = TRUE;
    vd.iconinfo.xHotspot = 0;
    vd.iconinfo.yHotspot = 0;
    vd.hbmpAlpha = NULL;
    vd.hbmpPreMultiplied = NULL;
    vd.hbrBackground = NULL;
}

/////////////////////////////////////////////////////////////////////////////
void ClearViewData(VIEWDATA & vd)
{
    if (vd.hIcon != NULL) {
        DestroyIcon(vd.hIcon);
        vd.hIcon = NULL;
    }

    if (vd.hIconCursor != NULL) {
        DestroyCursor(vd.hIconCursor);
        vd.hIconCursor = NULL;
    }

    if (vd.hDefaultCursor != NULL) {
        DestroyCursor(vd.hDefaultCursor);
        vd.hDefaultCursor = NULL;
    }

    if (vd.iconinfo.hbmColor != NULL) {
        DeleteObject(vd.iconinfo.hbmColor);
        vd.iconinfo.hbmColor = NULL;
    }

    if (vd.iconinfo.hbmMask != NULL) {
        DeleteObject(vd.iconinfo.hbmMask);
        vd.iconinfo.hbmMask = NULL;
    }

    vd.iconinfo.fIcon = TRUE;
    vd.iconinfo.xHotspot = 0;
    vd.iconinfo.yHotspot = 0;

    if (vd.hbmpAlpha != NULL) {
        DeleteObject(vd.hbmpAlpha);
        vd.hbmpAlpha = NULL;
    }

    if (vd.hbmpPreMultiplied != NULL) {
        DeleteObject(vd.hbmpPreMultiplied);
        vd.hbmpPreMultiplied = NULL;
    }

    if (vd.hbrBackground != NULL) {
        DeleteObject(vd.hbrBackground);
        vd.hbrBackground = NULL;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// This function takes an existing VIEWDATA structure, and rebuilds the
// ICONINFO data and hbmpAlpha from the already-loaded HICON.
//
void RefreshViewData(VIEWDATA & vd)
{
    if (vd.hDefaultCursor == NULL) {
        vd.hDefaultCursor = LoadCursor(NULL, IDC_ARROW);
    }

    if (vd.hbrBackground == NULL) {
        LOGBRUSH lb;
        lb.lbStyle = BS_HATCHED;
        lb.lbColor = RGB(0, 0, 0);
        lb.lbHatch = HS_BDIAGONAL;
        vd.hbrBackground = CreateBrushIndirect(&lb);
    }

    if (vd.hIcon != NULL) {
        //
        // First, clear out any existing fields.
        //
        if (vd.iconinfo.hbmColor != NULL) {
            DeleteObject(vd.iconinfo.hbmColor);
            vd.iconinfo.hbmColor = NULL;
        }

        if (vd.iconinfo.hbmMask != NULL) {
            DeleteObject(vd.iconinfo.hbmMask);
            vd.iconinfo.hbmMask = NULL;
        }

        vd.iconinfo.fIcon = TRUE;
        vd.iconinfo.xHotspot = 0;
        vd.iconinfo.yHotspot = 0;

        if (vd.hbmpAlpha != NULL) {
            DeleteObject(vd.hbmpAlpha);
            vd.hbmpAlpha = NULL;
        }

        if (vd.hbmpPreMultiplied != NULL) {
            DeleteObject(vd.hbmpPreMultiplied);
            vd.hbmpPreMultiplied = NULL;
        }

        //
        // Now get the new data.
        //
        GetIconInfo(vd.hIcon, &vd.iconinfo);
    }
    else if(vd.iconinfo.hbmColor != NULL)
    {
        //
        // This appears to be a simple bitmap.  There still might be an
        // alpha channel.
        //
        // First, clear out any existing fields.
        //
        if (vd.iconinfo.hbmMask != NULL) {
            DeleteObject(vd.iconinfo.hbmMask);
            vd.iconinfo.hbmMask = NULL;
        }

        vd.iconinfo.fIcon = TRUE;  // Well, certainly not a cursor.
        vd.iconinfo.xHotspot = 0;
        vd.iconinfo.yHotspot = 0;

        if (vd.hbmpAlpha != NULL) {
            DeleteObject(vd.hbmpAlpha);
            vd.hbmpAlpha = NULL;
        }

        if (vd.hbmpPreMultiplied != NULL) {
            DeleteObject(vd.hbmpPreMultiplied);
            vd.hbmpPreMultiplied = NULL;
        }
    }
    else
    {
        //
        // Neither an icon, nor a bitmap.  Bail.
        //
        return;
    }

    DWORD dwWidth;
    DWORD dwHeight;
    bool fAlpha;
    GetBitmapSize(vd, dwWidth, dwHeight, fAlpha);

    //
    // Create a bitmap to store a representation of the alpha channel.
    //
    if (fAlpha) {
        BITMAPINFO bmi;
        bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bmi.bmiHeader.biWidth = dwWidth;
        bmi.bmiHeader.biHeight = dwHeight;
        bmi.bmiHeader.biPlanes = 1;
        bmi.bmiHeader.biBitCount = 32;
        bmi.bmiHeader.biCompression = BI_RGB;
        bmi.bmiHeader.biSizeImage = 0;
        bmi.bmiHeader.biXPelsPerMeter = 0;
        bmi.bmiHeader.biYPelsPerMeter = 0;
        bmi.bmiHeader.biClrUsed = 0;
        bmi.bmiHeader.biClrImportant = 0;

        //
        // We need the desktop DC for various reasons.
        //
        HDC hdc = GetDC(NULL);

        //
        // Create the bitmap and get back a pointer to where the actual
        // bits are located.
        //
        RGBQUAD * pImageBits = NULL;
        vd.hbmpAlpha = CreateDIBSection(NULL, &bmi, DIB_RGB_COLORS, (void **) &pImageBits, NULL, 0);

        //
        // Now, copy the bits from the icon image bitmap into our new bitmap.
        //
        if (0 != GetDIBits(hdc, vd.iconinfo.hbmColor, 0, dwHeight, pImageBits, &bmi, DIB_RGB_COLORS)) {
            bool fAlphaUsed = false;

            //
            // Now, spin through the bitmap and look to see if the alpha
            // channel is even used.
            //
            for(DWORD y = 0; y < dwHeight && !fAlphaUsed; y++) {
                for(DWORD x = 0; x < dwWidth && !fAlphaUsed; x++) {
                    BYTE bAlpha = pImageBits[y*dwWidth + x].rgbReserved;
                    if (bAlpha != 0) {
                        fAlphaUsed = true;
                    }
                }
            }

            //
            // Now, spin through the bitmap and create a grey-scale ramp
            // that reflects the alpha channel.
            //
            if (fAlphaUsed) {
                for(DWORD y = 0; y < dwHeight; y++) {
                    for(DWORD x = 0; x < dwWidth; x++) {
                        BYTE bAlpha = pImageBits[y*dwWidth + x].rgbReserved;

                        pImageBits[y*dwWidth + x].rgbRed = bAlpha;
                        pImageBits[y*dwWidth + x].rgbGreen = bAlpha;
                        pImageBits[y*dwWidth + x].rgbBlue = bAlpha;
                        pImageBits[y*dwWidth + x].rgbReserved = 0xFF;
                    }
                }
            } else {
                //
                // Clean up the unused alpha bitmap.
                //
                DeleteObject(vd.hbmpAlpha);
                vd.hbmpAlpha = NULL;
            }
        }

        //
        // We're done with the desktop DC.
        //
        ReleaseDC(NULL, hdc);
    }

    //
    // Create a bitmap to store the premultiplied version of the color bitmap.
    //
    if (fAlpha && vd.hbmpAlpha != NULL) {
        BITMAPINFO bmi;
        bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        bmi.bmiHeader.biWidth = dwWidth;
        bmi.bmiHeader.biHeight = dwHeight;
        bmi.bmiHeader.biPlanes = 1;
        bmi.bmiHeader.biBitCount = 32;
        bmi.bmiHeader.biCompression = BI_RGB;
        bmi.bmiHeader.biSizeImage = 0;
        bmi.bmiHeader.biXPelsPerMeter = 0;
        bmi.bmiHeader.biYPelsPerMeter = 0;
        bmi.bmiHeader.biClrUsed = 0;
        bmi.bmiHeader.biClrImportant = 0;

        //
        // We need the desktop DC for various reasons.
        //
        HDC hdc = GetDC(NULL);

        //
        // Create the bitmap and get back a pointer to where the actual
        // bits are located.
        //
        RGBQUAD * pImageBits = NULL;
        vd.hbmpPreMultiplied = CreateDIBSection(NULL, &bmi, DIB_RGB_COLORS, (void **) &pImageBits, NULL, 0);

        //
        // Now, copy the bits from the icon image bitmap into our new bitmap.
        //
        if (0 != GetDIBits(hdc, vd.iconinfo.hbmColor, 0, dwHeight, pImageBits, &bmi, DIB_RGB_COLORS)) {
            //
            // Now, spin through the bitmap and pre-multiply each pixel.
            //
            RGBQUAD pixel;
            for(DWORD y = 0; y < dwHeight; y++) {
                for(DWORD x = 0; x < dwWidth; x++) {
                    pixel = pImageBits[y*dwWidth + x];

                    pImageBits[y*dwWidth + x].rgbRed = (pixel.rgbRed * pixel.rgbReserved) / 0xFF;
                    pImageBits[y*dwWidth + x].rgbGreen = (pixel.rgbGreen * pixel.rgbReserved) / 0xFF;
                    pImageBits[y*dwWidth + x].rgbBlue = (pixel.rgbBlue * pixel.rgbReserved) / 0xFF;
                }
            }
        }

        //
        // We're done with the desktop DC.
        //
        ReleaseDC(NULL, hdc);
    }
}

/////////////////////////////////////////////////////////////////////////////
void LoadViewData(VIEWDATA & vd, TCHAR * pszFileName, UINT fuLoad, LOADOPTIONS lo)
{
    int x = 0;
    int y = 0;
    HINSTANCE hInstance = (fuLoad == LR_LOADFROMFILE ? NULL : g_hInstance);
    
    ClearViewData(vd);

    switch (lo) {
    case LO_REAL:
        x = 0;
        y = 0;
        break;

    case LO_DEFAULT:
        fuLoad |= LR_DEFAULTSIZE;
        break;

    case LO_16:
        x = 16;
        y = 16;
        break;

    case LO_32:
        x = 32;
        y = 32;
        break;

    case LO_48:
        x = 48;
        y = 48;
        break;

    case LO_64:
        x = 64;
        y = 64;
        break;

    case LO_96:
        x = 96;
        y = 96;
        break;

    case LO_128:
        x = 128;
        y = 128;
        break;
    }

    vd.hIcon = (HICON) LoadImage(hInstance, pszFileName, IMAGE_ICON, x, y, fuLoad | LR_SHARED);
    if (vd.hIcon != NULL) {
        vd.hIconCursor = (HCURSOR) LoadImage(hInstance, pszFileName, IMAGE_CURSOR, x, y, fuLoad | LR_SHARED);
    } else {
        //
        // Try to load the image as a bitmap...
        //
        vd.hIcon = NULL;
        vd.hIconCursor = NULL;
        vd.iconinfo.fIcon = TRUE; // Well, it certainly isn't a cursor....
        vd.iconinfo.hbmColor = (HBITMAP) LoadImage(hInstance, pszFileName, IMAGE_BITMAP, x, y, fuLoad | LR_SHARED);
        vd.iconinfo.hbmMask = NULL;
        vd.iconinfo.xHotspot = 0;
        vd.iconinfo.yHotspot = 0;
        vd.hbmpAlpha = NULL;
    }

    RefreshViewData(vd);
}

/////////////////////////////////////////////////////////////////////////////
void ReLoadViewData(VIEWDATA & vd, UINT fuLoad, LOADOPTIONS lo)
{
    int x = 0;
    int y = 0;
    HINSTANCE hInstance = (fuLoad == LR_LOADFROMFILE ? NULL : g_hInstance);
    HICON hIcon = NULL;
    HCURSOR hIconCursor = NULL;
    HBITMAP hbmColor = NULL;

    switch (lo) {
    case LO_REAL:
        x = 0;
        y = 0;
        break;

    case LO_DEFAULT:
        fuLoad |= LR_DEFAULTSIZE;
        break;

    case LO_16:
        x = 16;
        y = 16;
        break;

    case LO_32:
        x = 32;
        y = 32;
        break;

    case LO_48:
        x = 48;
        y = 48;
        break;

    case LO_64:
        x = 64;
        y = 64;
        break;

    case LO_96:
        x = 96;
        y = 96;
        break;

    case LO_128:
        x = 128;
        y = 128;
        break;
    }


    //
    // Make copies of the exisitng icon and cursor.
    //
    if (vd.hIcon != NULL) {
        hIcon = (HICON) CopyImage(vd.hIcon, IMAGE_ICON, x, y, fuLoad | LR_COPYFROMRESOURCE | LR_SHARED);
    }

    if (hIcon != NULL) {
        if (vd.hIconCursor != NULL) {
            hIconCursor = (HCURSOR) CopyImage(vd.hIconCursor, IMAGE_CURSOR, x, y, fuLoad | LR_COPYFROMRESOURCE | LR_SHARED);
        }
    } else {
        if (vd.iconinfo.hbmColor != NULL) {
            hbmColor = (HBITMAP) CopyImage(vd.iconinfo.hbmColor, IMAGE_BITMAP, x, y, fuLoad | LR_COPYFROMRESOURCE | LR_SHARED);
        }
    }

    //
    // Nuke the existing draw data.
    //
    ClearViewData(vd);

    vd.hIcon = hIcon;
    if (vd.hIcon != NULL) {
        vd.hIconCursor = hIconCursor;
    } else {
        //
        // Try to load the image as a bitmap...
        //
        vd.hIcon = NULL;
        vd.hIconCursor = NULL;
        vd.iconinfo.fIcon = TRUE; // Well, it certainly isn't a cursor....
        vd.iconinfo.hbmColor = hbmColor;
        vd.iconinfo.hbmMask = NULL;
        vd.iconinfo.xHotspot = 0;
        vd.iconinfo.yHotspot = 0;
        vd.hbmpAlpha = NULL;
    }

    RefreshViewData(vd);
}

/////////////////////////////////////////////////////////////////////////////
ICONVIEW SelectIconView(HMENU hMenu, int id)
{
    MENUITEMINFO mii;
    int rgMenuItems[] = { VIEW_ICON, VIEW_MASK, VIEW_COLOR, VIEW_ALPHA };

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_STATE;

    for(int i = 0; i < sizeof(rgMenuItems) / sizeof(rgMenuItems[ 0 ]); i++) {
        GetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);

        if (rgMenuItems[ i ] == id) {
            if ((mii.fState & MFS_CHECKED) == 0) {
                mii.fState |= MFS_CHECKED;
                SetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);
            }
        } else {
            if (mii.fState & MFS_CHECKED) {
                mii.fState &= (~MFS_CHECKED);
                SetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);
            }
        }
    }

    switch (id) {
    case VIEW_ICON:
    default:
        return IV_ICON;

    case VIEW_MASK:
        return IV_MASK;

    case VIEW_COLOR:
        return IV_COLOR;

    case VIEW_ALPHA:
        return IV_ALPHA;
    }
}

/////////////////////////////////////////////////////////////////////////////
CURSORVIEW SelectCursorView(HMENU hMenu, int id)
{
    MENUITEMINFO mii;
    int rgMenuItems[] = { VIEW_ICONCURSOR, VIEW_REALCURSOR, VIEW_DEFAULTCURSOR };

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_STATE;

    for(int i = 0; i < sizeof(rgMenuItems) / sizeof(rgMenuItems[ 0 ]); i++) {
        GetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);

        if (rgMenuItems[ i ] == id) {
            if ((mii.fState & MFS_CHECKED) == 0) {
                mii.fState |= MFS_CHECKED;
                SetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);
            }
        } else {
            if (mii.fState & MFS_CHECKED) {
                mii.fState &= (~MFS_CHECKED);
                SetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);
            }
        }
    }

    switch (id) {
    case VIEW_ICONCURSOR:
        return CV_ICON;

    case VIEW_REALCURSOR:
        return CV_CURSOR;

    case VIEW_DEFAULTCURSOR:
    default:
        return CV_DEFAULT;
    }
}

/////////////////////////////////////////////////////////////////////////////
LOADOPTIONS SelectLoadOptions(HMENU hMenu, int id)
{
    MENUITEMINFO mii;
    int rgMenuItems[] = { IDM_DEFAULT_SIZE, IDM_REAL_SIZE, IDM_SIZE_16, IDM_SIZE_32, IDM_SIZE_48, IDM_SIZE_64, IDM_SIZE_96, IDM_SIZE_128 };

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_STATE;

    for(int i = 0; i < sizeof(rgMenuItems) / sizeof(rgMenuItems[ 0 ]); i++) {
        GetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);

        if (rgMenuItems[ i ] == id) {
            if ((mii.fState & MFS_CHECKED) == 0) {
                mii.fState |= MFS_CHECKED;
                SetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);
            }
        } else {
            if (mii.fState & MFS_CHECKED) {
                mii.fState &= (~MFS_CHECKED);
                SetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);
            }
        }
    }

    switch (id) {
    case IDM_REAL_SIZE:
        return LO_REAL;

    case IDM_SIZE_16:
        return LO_16;

    case IDM_SIZE_32:
        return LO_32;

    case IDM_SIZE_48:
        return LO_48;

    case IDM_SIZE_64:
        return LO_64;

    case IDM_SIZE_96:
        return LO_96;

    case IDM_SIZE_128:
        return LO_128;

    case IDM_DEFAULT_SIZE:
    default:
        return LO_DEFAULT;
    }
}

/////////////////////////////////////////////////////////////////////////////
DISPLAYOPTIONS SelectDisplayOptions(HMENU hMenu, int id)
{
    MENUITEMINFO mii;
    int rgMenuItems[] = { IDM_METAFILEDC, IDM_ENHMETAFILEDC, IDM_NORMALDC };

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_STATE;

    for(int i = 0; i < sizeof(rgMenuItems) / sizeof(rgMenuItems[ 0 ]); i++) {
        GetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);

        if (rgMenuItems[ i ] == id) {
            if ((mii.fState & MFS_CHECKED) == 0) {
                mii.fState |= MFS_CHECKED;
                SetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);
            }
        } else {
            if (mii.fState & MFS_CHECKED) {
                mii.fState &= (~MFS_CHECKED);
                SetMenuItemInfo(hMenu, rgMenuItems[ i ], FALSE, &mii);
            }
        }
    }
    
    switch(id)
    {
    case IDM_METAFILEDC:
        return DO_METAFILEDC;
        break;

    case IDM_ENHMETAFILEDC:
        return DO_ENHMETAFILEDC;
        break;

    case IDM_NORMALDC:
    default:
        return DO_NORMALDC;
    }
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static VIEWDATA vd;
    static TCHAR szFileName[MAX_PATH];
    static ICONVIEW iv = IV_ICON;
    static CURSORVIEW cv = CV_DEFAULT;
    static LOADOPTIONS lo = LO_REAL;
    static DISPLAYOPTIONS dop = DO_NORMALDC;

    switch (message) {
    case WM_CREATE:
        InitializeViewData(vd);
        szFileName[0] = '\0';
        iv = IV_ICON;
        cv = CV_DEFAULT;
        lo = LO_REAL;
        dop = DO_NORMALDC;

        DragAcceptFiles(hWnd, TRUE);
        LoadViewData(vd, szFileName, 0, lo);
        SetShowIconTitle(hWnd, szFileName, vd);
        break;

    case WM_DROPFILES:
        {
            HDROP hdrop = (HDROP) wParam;
            DragQueryFile(hdrop, 0, szFileName, MAX_PATH);
            LoadViewData(vd, szFileName, LR_LOADFROMFILE, lo);
            SetShowIconTitle(hWnd, szFileName, vd);
            InvalidateRgn(hWnd, NULL, TRUE);
        }
        break;

    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            int wmEvent HIWORD(wParam);

            switch (wmId) {
            case IDM_DEFAULT_SIZE:
            case IDM_REAL_SIZE:
            case IDM_SIZE_16:
            case IDM_SIZE_32:
            case IDM_SIZE_48:
            case IDM_SIZE_64:
            case IDM_SIZE_96:
            case IDM_SIZE_128:
                lo = SelectLoadOptions(GetMenu(hWnd), wmId);
                break;

            case IDM_NORMALDC:
            case IDM_METAFILEDC:
            case IDM_ENHMETAFILEDC:
                dop = SelectDisplayOptions(GetMenu(hWnd), wmId);
                InvalidateRgn(hWnd, NULL, TRUE);
                break;

            case VIEW_ICON:
            case VIEW_MASK:
            case VIEW_COLOR:
            case VIEW_ALPHA:
                iv = SelectIconView(GetMenu(hWnd), wmId);
                InvalidateRgn(hWnd, NULL, TRUE);
                break;

            case VIEW_REFRESH:
                RefreshViewData(vd);
                InvalidateRgn(hWnd, NULL, TRUE);
                break;

            case VIEW_ICONCURSOR:
            case VIEW_REALCURSOR:
            case VIEW_DEFAULTCURSOR:
                cv = SelectCursorView(GetMenu(hWnd), wmId);
                break;

            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;

            case IDM_SAMPLE16:
                LoadViewData(vd, MAKEINTRESOURCE(IDI_SAMPLE16), LR_DEFAULTCOLOR, lo);
                SetShowIconTitle(hWnd, NULL, vd);
                InvalidateRgn(hWnd, NULL, TRUE);
                break;

            case IDM_SAMPLE32:
                LoadViewData(vd, MAKEINTRESOURCE(IDI_SAMPLE32), LR_DEFAULTCOLOR, lo);
                SetShowIconTitle(hWnd, NULL, vd);
                InvalidateRgn(hWnd, NULL, TRUE);
                break;

            case IDM_SAMPLE64:
                LoadViewData(vd, MAKEINTRESOURCE(IDI_SAMPLE64), LR_DEFAULTCOLOR, lo);
                SetShowIconTitle(hWnd, NULL, vd);
                InvalidateRgn(hWnd, NULL, TRUE);
                break;

            case IDM_APPICON:
                LoadViewData(vd, MAKEINTRESOURCE(IDI_SHOWICON), LR_DEFAULTCOLOR, lo);
                SetShowIconTitle(hWnd, NULL, vd);
                InvalidateRgn(hWnd, NULL, TRUE);
                break;

            case IDM_MYCOMPUTER:
                LoadViewData(vd, MAKEINTRESOURCE(IDI_MYCOMPUTER), LR_DEFAULTCOLOR, lo);
                SetShowIconTitle(hWnd, NULL, vd);
                InvalidateRgn(hWnd, NULL, TRUE);
                break;

            case IDM_FILE_OPEN:
                {
                    OPENFILENAME ofn;
                    TCHAR * szFilter = TEXT("Icons (*.ico)\0*.ico\0")
                                       TEXT("Cursors (*.cur)\0*.cur\0")
                                       TEXT("Bitmaps (*.bmp)\0*.bmp\0")
                                       TEXT("All Supported Formats (*.ico;*.cur;*.bmp)\0*.ico;*.cur;*.bmp\0")
                                       TEXT("All Files (*.*)\0*.*\0");
                    szFileName[0] = TEXT('\0');

                    ZeroMemory(&ofn, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = hWnd;
                    ofn.hInstance = g_hInstance;
                    ofn.lpstrFilter = szFilter;
                    ofn.lpstrFile = szFileName;
                    ofn.nMaxFile = MAX_PATH;
                    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
                    ofn.lpstrDefExt = TEXT("*.ico");

                    if (GetOpenFileName(&ofn)) {
                        LoadViewData(vd, szFileName, LR_LOADFROMFILE, lo);
                        SetShowIconTitle(hWnd, szFileName, vd);
                        InvalidateRgn(hWnd, NULL, TRUE);
                    }
                }
                break;

            case IDM_FILE_EXTRACTICON:
                {
                    OPENFILENAME ofn;
                    TCHAR * szFilter = TEXT("Programs (*.exe)\0*.exe\0")
                                       TEXT("DLLs (*.dll;*.ocx)\0*.dll;*.ocx\0")
                                       TEXT("All Supported Formats (*.exe;*.dll;*.ocx)\0*.exe;*.dll;*.ocx\0")
                                       TEXT("All Files (*.*)\0*.*\0");
                    
                    szFileName[0] = TEXT('\0');

                    ZeroMemory(&ofn, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = hWnd;
                    ofn.hInstance = g_hInstance;
                    ofn.lpstrFilter = szFilter;
                    ofn.lpstrFile = szFileName;
                    ofn.nMaxFile = MAX_PATH;
                    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
                    ofn.lpstrDefExt = TEXT("*.exe");

                    if (GetOpenFileName(&ofn)) {
                        ClearViewData(vd);
                        int cIcons = (int) ExtractIconW(g_hInstance, szFileName, -1);
                        if (cIcons > 0) {
                            if(DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_EXTRACTICON), hWnd, ExtractIconDlgProc, LPARAM(&cIcons)) == IDOK) {
                                vd.hIcon = ExtractIconW(g_hInstance, szFileName, cIcons);
                                RefreshViewData(vd);
                                SetShowIconTitle(hWnd, szFileName, vd);
                            }
                        }
                        InvalidateRgn(hWnd, NULL, TRUE);
                    }
                }
                break;

            case IDM_FILE_REOPEN:
                {
                    ReLoadViewData(vd, 0, lo);
                    InvalidateRgn(hWnd, NULL, TRUE);
                }
                break;

            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;

    case WM_SO_LOADFILE:
        LoadViewData(vd, (TCHAR*)lParam, LR_LOADFROMFILE, lo);
        SetShowIconTitle(hWnd, (TCHAR*)lParam, vd);
        InvalidateRgn(hWnd, NULL, TRUE);
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdcWindow = BeginPaint(hWnd, &ps);
            RECT rcClient;
            HDC hdcPaint = NULL;

            if (dop == DO_METAFILEDC) {
                hdcPaint = CreateMetaFile(NULL);
            } else if (dop == DO_ENHMETAFILEDC) {
                hdcPaint = CreateEnhMetaFile(hdcWindow, NULL, NULL, NULL);
            } else {
                hdcPaint = hdcWindow;
            }

            GetClientRect(hWnd, &rcClient);
            SetBrushOrgEx(hdcPaint, -5, -5, NULL);
            SetBkColor(hdcPaint, RGB(128, 128, 128));
            SetBkMode(hdcPaint, OPAQUE);

            if (ps.fErase) {
                FillRect(hdcPaint, &(ps.rcPaint), vd.hbrBackground);
            }

            if (iv == IV_ICON) {
                //
                // Draw either the icon, alpha-blended bitmap, or normal bitmap.
                //
                if (vd.hIcon != NULL) {
                    DrawIconEx(hdcPaint, 5, 5, vd.hIcon, rcClient.right - 10, rcClient.bottom - 10, 0, NULL, DI_NORMAL);
                } else if(vd.hbmpPreMultiplied != NULL) {
                    HDC hdcBitmap = NULL;
                    HBITMAP hbmOld = NULL;
                    DWORD dwWidth, dwHeight;
                    bool fAlpha;
                    BLENDFUNCTION bf;
                    GetBitmapSize(vd, dwWidth, dwHeight, fAlpha);

                    hdcBitmap = CreateCompatibleDC(hdcPaint);
                    hbmOld = (HBITMAP) SelectObject(hdcBitmap, vd.iconinfo.hbmColor);
                    bf.BlendOp = AC_SRC_OVER;
                    bf.BlendFlags = 0;
                    bf.SourceConstantAlpha = 255;
                    bf.AlphaFormat = AC_SRC_ALPHA;
                    AlphaBlend(hdcPaint, 5, 5, rcClient.right - 10, rcClient.bottom - 10, hdcBitmap, 0, 0, dwWidth, dwHeight, bf);
                    SelectObject(hdcBitmap, hbmOld);
                    DeleteDC(hdcBitmap);
                } else if(vd.iconinfo.hbmColor != NULL) {
                    HDC hdcBitmap = NULL;
                    HBITMAP hbmOld = NULL;
                    DWORD dwWidth, dwHeight;
                    bool fAlpha;

                    GetBitmapSize(vd, dwWidth, dwHeight, fAlpha);

                    hdcBitmap = CreateCompatibleDC(hdcPaint);
                    hbmOld = (HBITMAP) SelectObject(hdcBitmap, vd.iconinfo.hbmColor);
                    StretchBlt(hdcPaint, 5, 5, rcClient.right - 10, rcClient.bottom - 10, hdcBitmap, 0, 0, dwWidth, dwHeight, SRCCOPY);
                    SelectObject(hdcBitmap, hbmOld);
                    DeleteDC(hdcBitmap);
                } else {
                    DrawText(hdcPaint, TEXT("No icon data to display"), -1, &rcClient, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
                }
            } else if (iv == IV_COLOR && vd.iconinfo.hbmColor != NULL) {
                HDC hdcBitmap = NULL;
                HBITMAP hbmOld = NULL;
                DWORD dwWidth, dwHeight;
                bool fAlpha;

                GetBitmapSize(vd, dwWidth, dwHeight, fAlpha);

                hdcBitmap = CreateCompatibleDC(hdcPaint);
                hbmOld = (HBITMAP) SelectObject(hdcBitmap, vd.iconinfo.hbmColor);
                StretchBlt(hdcPaint, 5, 5, rcClient.right - 10, rcClient.bottom - 10, hdcBitmap, 0, 0, dwWidth, dwHeight, SRCCOPY);
                SelectObject(hdcBitmap, hbmOld);
                DeleteDC(hdcBitmap);
            } else if (iv == IV_MASK && vd.iconinfo.hbmMask != NULL) {
                HDC hdcBitmap = NULL;
                HBITMAP hbmOld = NULL;
                DWORD dwWidth, dwHeight;
                bool fAlpha;
                
                GetBitmapSize(vd, dwWidth, dwHeight, fAlpha);

                hdcBitmap = CreateCompatibleDC(hdcPaint);
                hbmOld = (HBITMAP) SelectObject(hdcBitmap, vd.iconinfo.hbmMask);
                StretchBlt(hdcPaint, 5, 5, rcClient.right - 10, rcClient.bottom - 10, hdcBitmap, 0, 0, dwWidth, dwHeight, SRCCOPY);

                SelectObject(hdcBitmap, hbmOld);
                DeleteDC(hdcBitmap);
            } else if (iv == IV_ALPHA && vd.hbmpAlpha != NULL) {
                HDC hdcBitmap = NULL;
                HBITMAP hbmOld = NULL;
                DWORD dwWidth, dwHeight;
                bool fAlpha;

                GetBitmapSize(vd, dwWidth, dwHeight, fAlpha);

                hdcBitmap = CreateCompatibleDC(hdcPaint);
                hbmOld = (HBITMAP) SelectObject(hdcBitmap, vd.hbmpAlpha);
                StretchBlt(hdcPaint, 5, 5, rcClient.right - 10, rcClient.bottom - 10, hdcBitmap, 0, 0, dwWidth, dwHeight, SRCCOPY);
                SelectObject(hdcBitmap, hbmOld);
                DeleteDC(hdcBitmap);
            } else {
                DrawText(hdcPaint, TEXT("No icon data to display"), -1, &rcClient, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
            }

            if (dop == DO_METAFILEDC) {
                HMETAFILE hMetafile = CloseMetaFile(hdcPaint);
                PlayMetaFile(hdcWindow, hMetafile);
                DeleteMetaFile(hMetafile);
            } else if (dop == DO_ENHMETAFILEDC) {
                HENHMETAFILE hMetafile = CloseEnhMetaFile(hdcPaint);
                PlayEnhMetaFile(hdcWindow, hMetafile, &rcClient);
                DeleteEnhMetaFile(hMetafile);
            } else {
                hdcPaint = NULL;
            }

            EndPaint(hWnd, &ps);
        }
        break;

    case WM_SETCURSOR:
        if (LOWORD(lParam) == HTCLIENT) {
            HCURSOR hCursor = NULL;

            switch (cv) {
            case CV_ICON:
                hCursor = (HCURSOR) vd.hIcon;
                break;

            case CV_CURSOR:
                hCursor = vd.hIconCursor;
                break;

            case CV_DEFAULT:
                hCursor = vd.hDefaultCursor;
                break;
            }

            SetCursor(hCursor);
            return(TRUE);
        } else {
            return DefWindowProc(hWnd, message, wParam, lParam);
        }
        break;

    case WM_DESTROY:
        ClearViewData(vd);
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
ATOM RegisterLoadIconClass(HINSTANCE hInstance)
{
    WNDCLASSEX wcex;

    wcex.cbSize           = sizeof(WNDCLASSEX); 
    wcex.style            = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS;
    wcex.lpfnWndProc      =  WndProc;
    wcex.cbClsExtra       = 0;
    wcex.cbWndExtra       = 0;
    wcex.hInstance        = hInstance;
    wcex.hIcon            = LoadIcon(hInstance, (LPCTSTR) IDI_SHOWICON);
    wcex.hCursor          = NULL;
    wcex.hbrBackground    = NULL;
    wcex.lpszMenuName     = (LPCTSTR) IDC_SHOWICON;
    wcex.lpszClassName    = TEXT("LoadIconClass");
    wcex.hIconSm          = LoadIcon(hInstance, (LPCTSTR) IDI_SHOWICON);

    return RegisterClassEx(&wcex);
}

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow)
{
    MSG msg;
    HACCEL hAccelTable = LoadAccelerators(hInstance, (LPCTSTR) IDC_SHOWICON);
    LPWSTR *argv;
    int argc;

    g_hInstance = hInstance;

    //
    // Register the window class.
    //
    RegisterLoadIconClass(hInstance);

    HWND hwndMain = CreateWindow(TEXT("LoadIconClass"),
                                 TEXT("LoadIcon"),
                                 WS_OVERLAPPEDWINDOW,
                                 CW_USEDEFAULT,
                                 0,
                                 180,
                                 180,
                                 NULL,
                                 NULL,
                                 hInstance,
                                 NULL);
    if (hwndMain == NULL) {
        return FALSE;
    }

    argv = CommandLineToArgvW(GetCommandLineW(), &argc);
    /*
     * For now we only allow one file to be passed on the command line.
     * Ideally, we should package up the VIEWDATA, LOADOPTIONS, etc. into a
     * struct that we hang off each window. Then we can open a window for every
     * file (however many) on the cl.
     *
     * Moreover, the file can't be on a share; it must be local. I'm not sure if
     * this is by design, but it's something to look into.
     */
    if (argc == 2) {
        SendMessage(hwndMain, WM_SO_LOADFILE, (WPARAM)0, (LPARAM)argv[1]);
    }
    GlobalFree(argv);
    ShowWindow(hwndMain, nCmdShow);


    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
     }

     return msg.wParam != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\showicon\showicon.h ===
#ifndef __SHOWICON_H__
#define __SHOWICON_H__

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <windows.h>
#include <commdlg.h>
#include <shellapi.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

#include "resource.h"

#define WM_SO_LOADFILE (WM_USER + 1)

#endif // !__SHOWICON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\abtest.inc ===
// abtest.inc

#include "ab.h"

ULONGLONG FAW(msProfSendMessage)(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    INIT_TIMER;
    AW2(WNDCLASS) wc;

    wc.style            = 0;
    wc.lpfnWndProc      = IF2(CreateDestroyWndProc, CreateDestroyWndProcW);
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = L2("CreateDestroyWindow");

    if (!AW2(RegisterClass)(&wc)) {
        MessageBox(NULL, "18RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwnd = AW2(CreateWindow)(L2("CreateDestroyWindow"), NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    START_TIMER;

    while (ix--)
    {
        AW1(SendMessage)(hwnd, WM_SETTEXT, 0, (LPARAM)L1("A fairly reasonable bit of text"));
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);
    AW2(UnregisterClass)(L2("CreateDestroyWindow"), ghinst);

    RETURN_STOP_TIME;

}

#undef A1
#undef A2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\awtest.inc ===
// awtest.inc

#include "aw.h"

ULONGLONG AW(msProfPeekMessage)(HDC hdc, ULONG Iter)
{

    MSG msg;
    INIT_TIMER;

    START_TIMER;

    while (ix--)
    {
        AW(PeekMessage)(&msg, NULL, 0, 0, PM_REMOVE);
    }

    END_TIMER;
}

ULONGLONG AW(msProfDispatchMessage)(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    MSG msg;
    INIT_TIMER;
    AW(WNDCLASS) wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = L("CreateDestroyWindow");

    if (!AW(RegisterClass)(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "14RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwnd = AW(CreateWindow)(L("CreateDestroyWindow"), NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    msg.hwnd = hwnd;
    msg.message = WM_MOUSEMOVE;
    msg.wParam = 1;
    msg.lParam = 2;
    msg.time = 3;
    msg.pt.x = 4;
    msg.pt.y = 5;

    START_TIMER;

    while (ix--)
    {
        AW(DispatchMessage)(&msg);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);
    AW(UnregisterClass)(L("CreateDestroyWindow"), ghinst);

    RETURN_STOP_TIME;

}

ULONGLONG AW(msProfCharXXX)(HDC hDC, ULONG Iter,
                            BOOL (WINAPI *tester)(IF(char,WCHAR)))
{
    static const IF(char,WCHAR) sample[] =
        L("The quick brown fox jumps over the lazy dog")
        L("0123456789")
        L("Jackdaws love my big sphinx of quartz");
    INIT_TIMER;

    START_TIMER;
    while (ix--) {
        const IF(char,WCHAR)* p = sample;
        while (*p) {
            tester(*p++);
        }
    }
    END_TIMER;
}


ULONGLONG AW(msProfCharUpper)(HDC hDC, ULONG Iter)
{
    return AW(msProfCharXXX)(hDC, Iter, AW(IsCharUpper));
}

ULONGLONG AW(msProfCharLower)(HDC hDC, ULONG Iter)
{
    return AW(msProfCharXXX)(hDC, Iter, AW(IsCharLower));
}

ULONGLONG AW(msProfCharNext)(HDC hDC, ULONG Iter)
{
    static const IF(char,WCHAR) sample[] =
        L("The quick brown fox jumps over the lazy dog")
        L("0123456789")
        L("Jackdaws love my big sphinx of quartz");
    INIT_TIMER;

    START_TIMER;
    while (ix--) {
        const IF(char,WCHAR)* p = sample;
        while (*p) {
            AW(CharNext)(p++);
        }
    }
    END_TIMER;
}

ULONGLONG AW(msProfGetMessage)(HDC hDC, ULONG Iter)
{
    MSG msg;
    AW(WNDCLASS) wc;
    HWND hwnd;
    RECT rect;
    static const IF(char, WCHAR)* className = L("GetMessageTest");
    INIT_TIMER;

    wc.style            = 0;
    wc.lpfnWndProc      = IF(CreateDestroyWndProc, CreateDestroyWndProcW);
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = className;

    if (!AW(RegisterClass)(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "RegisterClass call failed.",
                "ERROR!", MB_OK);
        return FALSE;
    }

    hwnd = AW(CreateWindow)(className, NULL,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, ghinst, NULL);
    if (hwnd == NULL) {
        MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
            "ERROR!", MB_OK);
            return 0;
    }

    START_TIMER;
    while (ix--) {
        START_OVERHEAD;
        AW(PostMessage)(hwnd, WM_MOUSEMOVE, 0, 0);
        END_OVERHEAD;
        AW(GetMessage)(&msg, hwnd, 0, 0);
    }
    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);
    AW(UnregisterClass)(className, ghinst);

    RETURN_STOP_TIME;
}

ULONGLONG AW(msProfGetWindowTextLength)(HDC hdc, ULONG Iter)
{
    INIT_TIMER;
    static const IF(CHAR, WCHAR)* className = L("GetWindowTextLengthTest");
    AW(WNDCLASS) wc;
    HWND hwnd;

    wc.style            = 0;
    wc.lpfnWndProc      = AW(DefWindowProc);
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = className;

    if (!AW(RegisterClass)(&wc)) {
        DispErrorMsg("RegisterClass");
        return FALSE;
    }

    hwnd = AW(CreateWindow)(className, NULL,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, ghinst, NULL);
    if (hwnd == NULL) {
        DispErrorMsg("CreateWindow");
    }

    AW(SetWindowText)(hwnd, L("The quick brown fox jumps over the lazy dog"));

    START_TIMER;

    while (ix--)
    {
        AW(GetWindowTextLength)(hwnd);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);
    AW(UnregisterClass)(className, ghinst);

    RETURN_STOP_TIME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\bench.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   bench.c

Abstract:

   Measure time for a number of API calls or small application modules

Author:

   Dan Almosnino (danalm) July 96
   Based on code by (MarkE) and DarrinM

Enviornment:

   User Mode

Revision History:

    Dan Almosnino (danalm) 20-Sept-195

1. Timer call modified to run on both NT and WIN95.

    Dan Almosnino (danalm) 20-Nov-1995

1.  Modified Timer call to measure Pentium cycle counts when applicable
2.  Modified default numbers for test iterations to accomodate the statistical module add-on.
    (Typically 10 test samples are taken, doing 10-1000 iterations each).

    Dan Almosnino (danalm) 25-July-96

1.  Adapted to the same format as that of GDIbench, including the features above.
2.  Cleanup some tests.

--*/

#include "precomp.h"
#include "bench.h"
#include "usrbench.h"
#include "resource.h"

#ifndef WIN32
#define APIENTRY FAR PASCAL
typedef int INT;
typedef char CHAR;
#endif

#define SETWINDOWLONGVAL  99999L
/*
 * Function prototypes
 */
INT_PTR APIENTRY FileOpenDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY ClearDlg(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY ClearDlgNoState(HWND, UINT, WPARAM, LPARAM);
LRESULT APIENTRY CreateDestroyWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
LRESULT APIENTRY CreateDestroyWndProcW(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#ifdef ASSERT
#undef ASSERT
#endif

#define ASSERT(expr)    if (!(expr)) { char szBuf[256];                   \
sprintf(szBuf,"Assertion Failure %s %ld:"#expr"\n", __FILE__, __LINE__);  \
MessageBox(NULL, szBuf, "Assert Failure", MB_OK); }


static void DispErrorMsg(const char* title)
{
    LPVOID msgbuf;

    if (title == NULL) {
        title = "Error";
    }
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &msgbuf,
        0,
        NULL);
    MessageBox(NULL, msgbuf, title, MB_OK | MB_ICONEXCLAMATION);
    LocalFree(msgbuf);
}

/*
 * Global variables
 */
CHAR *aszTypical[] = {
    "change", "alteration", "amendment", "mutation", "permutation",
    "variation", "substitution", "modification", "transposition",
    "transformation"
};
INT NStrings = sizeof(aszTypical)/sizeof(aszTypical[0]);

BOOL gfSetFocus = TRUE;
#define PROPCLASSNAME TEXT("PropWindow")

/*
 * External global variables.
 */

extern HWND ghwndFrame, ghwndMDIClient;
extern HANDLE ghinst;

/*++

Routine Description:

    Measure start count

Arguments



Return Value - Performance Count


--*/
extern BOOL gfPentium;
_int64
BeginTimeMeasurement()
{
    _int64 PerformanceCount;
    extern BOOL gfUseCycleCount;

#ifdef _X86_
                SYSTEM_INFO SystemInfo;
                GetSystemInfo(&SystemInfo);
                if(gfUseCycleCount&&(PROCESSOR_INTEL_PENTIUM==SystemInfo.dwProcessorType))
                        gfPentium = TRUE;
                else
#endif
                        gfPentium = FALSE;
#ifdef _X86_
                if(gfPentium)
                    PerformanceCount = GetCycleCount();
                else
#endif
                QueryPerformanceCounter((LARGE_INTEGER *)&PerformanceCount);

    return(PerformanceCount);
}

/*++

Routine Description:

    Measure stop count and return the calculated time difference

Arguments

    StartTime   = Start Time Count
    Iter        = No. of Test Iterations

Return Value - Test Time per Iteration, in 100 nano-second units


--*/

ULONGLONG
EndTimeMeasurement(
    _int64  StartTime,
    ULONG      Iter)
{

   _int64 PerformanceCount;
   extern  _int64 PerformanceFreq;
   extern  BOOL gfPentium;

#ifdef _X86_
                if(gfPentium)
                {
                    PerformanceCount = GetCycleCount();
                    PerformanceCount -= CCNT_OVERHEAD;
                }
                else
#endif
                    QueryPerformanceCounter((LARGE_INTEGER *)&PerformanceCount);

   PerformanceCount -= StartTime ;

#ifdef _X86_
                if(gfPentium)
                    PerformanceCount /= Iter;
                else
#endif
                    PerformanceCount /= (PerformanceFreq * Iter); // Result is in 100ns units
                                                                  // because PerformanceFreq
                                                                  // was set to Counts/(100ns)
   return((ULONGLONG)PerformanceCount);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*++

Routine Description:

   Measure APIs

Arguments

   hdc   - dc
   iter  - number of times to call

Return Value

   time for calls

--*/

/***************************************************************************\
* RegisterClass
*
*
* History:
\***************************************************************************/

ULONGLONG
msProfRegisterClass(
    HDC hdc,
    ULONG Iter)
{
    INIT_TIMER;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = PROPCLASSNAME;

    START_TIMER;

    while (ix--)
    {
        RegisterClass(&wc);
        UnregisterClass(PROPCLASSNAME, ghinst);
    }

    END_TIMER;

}


/***************************************************************************\
* Class Query APIs
*
*
* History:
\***************************************************************************/

ULONGLONG msProfClassGroup(HDC hdc, ULONG Iter)
{

    char szBuf[50];
    HICON hIcon;
    INIT_TIMER;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = hIcon = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = PROPCLASSNAME;
    RegisterClass(&wc);

    START_TIMER;

    while (ix--)
    {
        GetClassInfo(ghinst, PROPCLASSNAME, &wc);
        GetClassName(ghwndFrame, szBuf, sizeof(szBuf)/sizeof(szBuf[0]));
        GetClassLongPtr(ghwndFrame, GCLP_HBRBACKGROUND);
        SetClassLongPtr(ghwndFrame, GCLP_HICON, (LONG_PTR)hIcon);
    }

    END_TIMER_NO_RETURN;

    UnregisterClass(PROPCLASSNAME, ghinst);

    RETURN_STOP_TIME;
}


/***************************************************************************\
* Clipboard APIs tests
*
*
* History:
\***************************************************************************/

ULONGLONG msProfClipboardGroup(HDC hdc, ULONG Iter)
{

    INIT_TIMER;
    HGLOBAL h;
    int i;

    START_TIMER;

    while (ix--)
    {
        START_OVERHEAD;
        h = GlobalAlloc(GPTR | GMEM_DDESHARE, 80);
        strcpy( h, "hello");
        END_OVERHEAD;

        OpenClipboard(ghwndFrame);
        EmptyClipboard();
        SetClipboardData(CF_TEXT, h);
        GetClipboardData(CF_TEXT);
        CloseClipboard();
    }

    END_TIMER_NO_RETURN;
    RETURN_STOP_TIME;
}


/***************************************************************************\
* ProfAvgDlgDraw
*
*
* History:
\***************************************************************************/

ULONGLONG msProfAvgDlgDraw(HDC hdc, ULONG Iter)
{

    CHAR szFile[128];
    INIT_TIMER;

    HWND hwnd = CreateDialogParam(ghinst, MAKEINTRESOURCE(CLEARBOX), ghwndFrame,
            ClearDlg, MAKELONG(szFile,0));

    START_TIMER;

    while (ix--)
    {
        ShowWindow(hwnd, TRUE);
        UpdateWindow(hwnd);
        ShowWindow(hwnd, FALSE);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);

    RETURN_STOP_TIME;

}


ULONGLONG msProfAvgDlgCreate(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    CHAR szFile[128];
    INIT_TIMER;

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateDialogParam(ghinst, MAKEINTRESOURCE(CLEARBOX), ghwndFrame,
                ClearDlg, MAKELONG(szFile,0));
        ShowWindow(hwnd, TRUE);
        UpdateWindow(hwnd);
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    RETURN_STOP_TIME;
}


ULONGLONG msProfAvgDlgCreateDestroy(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    CHAR szFile[128];
    INIT_TIMER;

    gfSetFocus = FALSE;     // Trying to minimize GDI's impact.

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateDialogParam(ghinst, MAKEINTRESOURCE(CLEARBOX), ghwndFrame,
                ClearDlg, MAKELONG(szFile,0));
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    gfSetFocus = TRUE;

    RETURN_STOP_TIME;

}


ULONGLONG msProfAvgDlgCreateDestroyNoMenu(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    CHAR szFile[128];
    INIT_TIMER;

    gfSetFocus = FALSE;     // Trying to minimize GDI's impact.

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateDialogParam(ghinst, MAKEINTRESOURCE(CLEARBOXNOMENU), ghwndFrame,
                ClearDlg, MAKELONG(szFile,0));
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    gfSetFocus = TRUE;

    RETURN_STOP_TIME;
}


ULONGLONG msProfAvgDlgCreateDestroyNoFont(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    CHAR szFile[128];
    INIT_TIMER;

    gfSetFocus = FALSE;     // Trying to minimize GDI's impact.

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateDialogParam(ghinst, MAKEINTRESOURCE(CLEARBOXNOFONT), ghwndFrame,
                ClearDlg, MAKELONG(szFile,0));
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    gfSetFocus = TRUE;

    RETURN_STOP_TIME;

}


ULONGLONG msProfAvgDlgCreateDestroyEmpty(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    CHAR szFile[128];
    INIT_TIMER;

    gfSetFocus = FALSE;     // Trying to minimize GDI's impact.

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateDialogParam(ghinst, MAKEINTRESOURCE(EMPTY), ghwndFrame,
                ClearDlgNoState, MAKELONG(szFile,0));
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    gfSetFocus = TRUE;

    RETURN_STOP_TIME;

}



ULONGLONG msProfCreateDestroyWindow(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    INIT_TIMER;
    WNDCLASS wc;

    if(!ghinst)MessageBox(GetParent(ghwndMDIClient), "1ghinst==0","ERROR!", MB_OK);


    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor((HINSTANCE)NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";


    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "1RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }


    START_TIMER;

    while (ix--)
    {
        hwnd = CreateWindow("CreateDestroyWindow", "Create/DestroyWindow test",
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                NULL, NULL, ghinst, NULL);
        if (hwnd == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            break;
        }
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfCreateDestroyChildWindow(HDC hdc, ULONG Iter)
{

    HWND hwnd, hwndParent;
    INIT_TIMER;

    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "2RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwndParent = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateWindow("CreateDestroyWindow", "Create/DestroyWindow test",
                WS_CHILD,
                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                hwndParent, NULL, ghinst, NULL);
        if (hwnd == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            break;
        }
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwndParent);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;
}


LRESULT APIENTRY CreateDestroyWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (msg) {
    case WM_SETTEXT:
    case WM_GETTEXTLENGTH:
        break;
    default:
        return DefWindowProc(hwnd, msg, wParam, lParam);

    }

    return 0;
}

LRESULT APIENTRY CreateDestroyWndProcW(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (msg) {
    case WM_SETTEXT:
    case WM_GETTEXTLENGTH:
        break;
    default:
        return DefWindowProcW(hwnd, msg, wParam, lParam);
    }

    return 0;
}


ULONGLONG msProfLocalAllocFree(HDC hdc, ULONG Iter)
{

    HANDLE h1, h2, h3, h4, h5;
    INIT_TIMER;

    START_TIMER;

    // Try to stress the heap a little bit more than just doing a
    // series of Alloc/Frees.

    while (ix--)                         // originally ix<Iter/5 as well
    {
        h1 = LocalAlloc(0, 500);
        h2 = LocalAlloc(0, 600);
        h3 = LocalAlloc(0, 700);
        LocalFree(h2);
        h4 = LocalAlloc(0, 1000);
        h5 = LocalAlloc(0, 100);
        LocalFree(h1);
        LocalFree(h3);
        LocalFree(h4);
        LocalFree(h5);
    }

    END_TIMER;
}


ULONGLONG msProfGetWindowLong(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    INIT_TIMER;
    LONG l;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 4;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "3RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwnd = CreateWindow("CreateDestroyWindow", "Create/DestroyWindow test",
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, ghinst, NULL);

    if (hwnd == NULL) {
        MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    START_TIMER;

    while (ix--)
        l = GetWindowLong(hwnd, 0);

    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfSetWindowLong(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    INIT_TIMER;
    LONG l;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 4;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "4RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwnd = CreateWindow("CreateDestroyWindow", "Create/DestroyWindow test",
            WS_OVERLAPPEDWINDOW,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            NULL, NULL, ghinst, NULL);

    if (hwnd == NULL) {
        MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    START_TIMER;

    while (ix--)
        l = SetWindowLong(hwnd, 0, SETWINDOWLONGVAL);

    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfCreateDestroyListbox(HDC hdc, ULONG Iter)
{

    HWND hwnd, hwndParent;
    INIT_TIMER;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "5RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwndParent = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateWindow("ListBox", NULL, WS_CHILD | LBS_STANDARD | WS_VISIBLE,
                50, 50, 200, 250, hwndParent, NULL, ghinst, NULL);
        if (hwnd == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            return (ULONGLONG)(0);
        }
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwndParent);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfCreateDestroyButton(HDC hdc, ULONG Iter)
{

    HWND hwnd, hwndParent;
    INIT_TIMER;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "6RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwndParent = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateWindow("Button", "OK", WS_CHILD | BS_PUSHBUTTON,
                50, 50, 200, 250, hwndParent, NULL, ghinst, NULL);
        if (hwnd == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            return (ULONGLONG)(0);
        }
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwndParent);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfCreateDestroyCombobox(HDC hdc, ULONG Iter)
{

    HWND hwnd, hwndParent;
    INIT_TIMER;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "7RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwndParent = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateWindow("Combobox", NULL, WS_CHILD | CBS_SIMPLE | CBS_HASSTRINGS | WS_VISIBLE,
                50, 50, 200, 250, hwndParent, NULL, ghinst, NULL);
        if (hwnd == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            return (ULONGLONG)(0);
        }
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwndParent);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfCreateDestroyEdit(HDC hdc, ULONG Iter)
{

    HWND hwnd, hwndParent;
    INIT_TIMER;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "8RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwndParent = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateWindow("Edit", NULL, WS_CHILD | WS_VISIBLE,
                50, 50, 200, 250, hwndParent, NULL, ghinst, NULL);
        if (hwnd == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            return (ULONGLONG)(0);
        }
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwndParent);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfCreateDestroyStatic(HDC hdc, ULONG Iter)
{

    HWND hwnd, hwndParent;
    INIT_TIMER;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "9RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwndParent = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateWindow("Static", "Hello", WS_CHILD | SS_SIMPLE,
                50, 50, 200, 250, hwndParent, NULL, ghinst, NULL);
        if (hwnd == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            return (ULONGLONG)(0);
        }
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwndParent);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfCreateDestroyScrollbar(HDC hdc, ULONG Iter)
{

    HWND hwnd, hwndParent;
    INIT_TIMER;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "10RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwndParent = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    START_TIMER;

    while (ix--)
    {
        hwnd = CreateWindow("Scrollbar", "Hello", WS_CHILD | SBS_HORZ | SBS_TOPALIGN,
                50, 50, 100, 100, hwndParent, NULL, ghinst, NULL);
        if (hwnd == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            return (ULONGLONG)(0);
        }
        DestroyWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwndParent);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfListboxInsert1(HDC hdc, ULONG Iter)
{

    ULONG i;
    HWND hwndParent;
    INIT_TIMER;
    WNDCLASS wc;
    HWND *ahwnd = LocalAlloc(LPTR,Iter*sizeof(HANDLE));
    if(!ahwnd)
       MessageBox(GetParent(ghwndMDIClient),
        "Could not Allocate Memory for Handle Array",
        "ERROR!", MB_OK);

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "11RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwndParent = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    for (i=0; i < Iter; i++)
    {
        ahwnd[i] = CreateWindow("ListBox", NULL, WS_CHILD | LBS_STANDARD,
                50, 50, 200, 250, hwndParent, NULL, ghinst, NULL);
        if (ahwnd[i] == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            return (ULONGLONG)(0);
        }
    }

    START_TIMER;

    while (ix--)
        for (i = 0; i < 200; i++)
            SendMessage(ahwnd[ix], LB_ADDSTRING, 0, (LPARAM)aszTypical[i % NStrings]);

    END_TIMER_NO_RETURN;

    for (i = 0; i < Iter; i++)
        DestroyWindow(ahwnd[i]);

    DestroyWindow(hwndParent);
    UnregisterClass("CreateDestroyWindow", ghinst);
    LocalFree(ahwnd);

    RETURN_STOP_TIME;

}


ULONGLONG msProfListboxInsert2(HDC hdc, ULONG Iter)
{
    ULONG i;
    HWND hwndParent;
    INIT_TIMER;
    WNDCLASS wc;
    HWND *ahwnd = LocalAlloc(LPTR,Iter*sizeof(HANDLE));
    if(!ahwnd)
       MessageBox(GetParent(ghwndMDIClient),
        "Could not Allocate Memory for Handle Array",
        "ERROR!", MB_OK);

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "12RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwndParent = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    for (i = 0; i < Iter; i++) {
        ahwnd[i] = CreateWindow("ListBox", NULL,
                WS_CHILD | LBS_OWNERDRAWFIXED | LBS_HASSTRINGS,
                50, 50, 200, 250, hwndParent, NULL, ghinst, NULL);
        if (ahwnd[i] == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            return (ULONGLONG)(0);
        }
    }

    START_TIMER;

    while (ix--)
        for (i = 0; i < 200; i++)
            SendMessage(ahwnd[ix], LB_ADDSTRING, 0, (LPARAM)aszTypical[i % NStrings]);

    END_TIMER_NO_RETURN;

    for (i = 0; i < Iter; i++)
        DestroyWindow(ahwnd[i]);

    DestroyWindow(hwndParent);
    UnregisterClass("CreateDestroyWindow", ghinst);
    LocalFree(ahwnd);

    RETURN_STOP_TIME;

}


ULONGLONG msProfListboxInsert3(HDC hdc, ULONG Iter)
{
    ULONG i;
    HWND hwndParent;
    INIT_TIMER;
    WNDCLASS wc;
    HWND *ahwnd = LocalAlloc(LPTR,Iter*sizeof(HANDLE));
    if(!ahwnd)
       MessageBox(GetParent(ghwndMDIClient),
        "Could not Allocate Memory for Handle Array",
        "ERROR!", MB_OK);

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "13RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwndParent = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    for (i = 0; i < Iter; i++) {
        ahwnd[i] = CreateWindow("ListBox", NULL,
                WS_CHILD | LBS_SORT | LBS_OWNERDRAWFIXED,
                50, 50, 200, 250, hwndParent, NULL, ghinst, NULL);
        if (ahwnd[i] == NULL) {
            MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
                    "ERROR!", MB_OK);
            return (ULONGLONG)(0);
        }
    }

    START_TIMER;

    while (ix--)
        for (i = 0; i < 200; i++)
            SendMessage(ahwnd[ix], LB_ADDSTRING, 0, (LPARAM)aszTypical[i % NStrings]);

    END_TIMER_NO_RETURN;

    for (i = 0; i < Iter; i++)
        DestroyWindow(ahwnd[i]);

    DestroyWindow(hwndParent);
    UnregisterClass("CreateDestroyWindow", ghinst);
    LocalFree(ahwnd);

    RETURN_STOP_TIME;

}


/*
 * Mostly stolen from pbrush.
 */
INT_PTR APIENTRY ClearDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static BOOL bChangeOk = TRUE;

    HDC dc;
    INT wid, hgt, numcolors;

    switch (message) {
    case WM_INITDIALOG:
        /*
         * standard init stuff for pbrush
         */
        dc = GetDC(NULL);
        numcolors = GetDeviceCaps(dc, NUMCOLORS);
        ReleaseDC(NULL, dc);

        dc = GetDC(NULL);
        wid = GetDeviceCaps(dc, HORZRES);
        hgt = GetDeviceCaps(dc, VERTRES);
        ReleaseDC(NULL, dc);

        CheckRadioButton (hDlg, ID2, ID256, ID2);

        EnableWindow(GetDlgItem(hDlg, ID256), FALSE);
        CheckRadioButton(hDlg, ID2, ID256, ID256);

        CheckRadioButton(hDlg, ID2, ID256, ID2);
        EnableWindow(GetDlgItem(hDlg, ID256), FALSE);
        CheckRadioButton(hDlg, ID2, ID256, ID256);

        SetDlgItemInt(hDlg, IDWIDTH, 0, FALSE);
        SetDlgItemInt(hDlg, IDHEIGHT, 0, FALSE);
        CheckRadioButton(hDlg, IDIN, IDPELS, TRUE);

        if (!gfSetFocus)
            return FALSE;

        break;

    default:
        return FALSE;
    }

    return TRUE;
}


INT_PTR APIENTRY ClearDlgNoState(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static BOOL bChangeOk = TRUE;

    HDC dc;
    INT wid, hgt, numcolors;

    switch (message) {
    case WM_INITDIALOG:
        if (!gfSetFocus)
            return FALSE;

        break;

    default:
        return FALSE;
    }

    return TRUE;
}


ULONGLONG msProfSize(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    RECT rc;
    INIT_TIMER;

    GetClientRect(ghwndMDIClient, (LPRECT)&rc);
    InflateRect((LPRECT)&rc, -10, -10);

    hwnd = GetWindow(ghwndMDIClient, GW_CHILD);
    ShowWindow(hwnd, SW_RESTORE);
    ShowWindow(hwnd, FALSE);
    UpdateWindow(hwnd);

    /* time start */

    START_TIMER;

    while (ix--)
    {
        SetWindowPos(hwnd, NULL, rc.left, rc.top,
                rc.right - rc.left, rc.bottom - rc.top,
                SWP_NOZORDER | SWP_NOACTIVATE);
        SetWindowPos(hwnd, NULL, rc.left, rc.top,
                (rc.right - rc.left) / 2, (rc.bottom - rc.top) / 2,
                SWP_NOZORDER | SWP_NOACTIVATE);
    }

    /* time end */

    END_TIMER_NO_RETURN;

    ShowWindow(hwnd, SW_RESTORE);

    RETURN_STOP_TIME;

}


ULONGLONG msProfMove(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    RECT rc;
    INIT_TIMER;

    GetClientRect(ghwndMDIClient, (LPRECT)&rc);
    InflateRect((LPRECT)&rc, -(rc.right - rc.left) / 4,
            -(rc.bottom - rc.top) / 4);

    hwnd = GetWindow(ghwndMDIClient, GW_CHILD);
    ShowWindow(hwnd, SW_RESTORE);
    ShowWindow(hwnd, FALSE);
    UpdateWindow(hwnd);

    /* time start */

    START_TIMER;

    while (ix--)
    {
        SetWindowPos(hwnd, NULL, rc.left, rc.top,
                rc.right - rc.left, rc.bottom - rc.top,
                SWP_NOZORDER | SWP_NOACTIVATE);
        SetWindowPos(hwnd, NULL, 0, 0, 0, 0,
                SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE);
    }

    /* time end */

    END_TIMER_NO_RETURN;

    ShowWindow(hwnd, SW_RESTORE);

    RETURN_STOP_TIME;

}


#define WM_SYSTIMER 0x0118

ULONGLONG msProfMenu(HDC hdc, ULONG Iter)
{

    MSG msg;
    INIT_TIMER;

    HWND hwnd = GetParent(ghwndMDIClient);

    ShowWindow(hwnd, FALSE);

    /*
     * Multipad's edit menu is a great choice. Multipad does a goodly lot
     * of WM_INITMENU time initialization. The WM_SYSTIMER message is
     * to circumvent menu type ahead so the menu actually shows.
     */

    START_TIMER;

    while (ix--)
    {
        PostMessage(hwnd, WM_KEYDOWN, VK_ESCAPE, 0L);
        PostMessage(hwnd, WM_KEYDOWN, VK_ESCAPE, 0L);
        PostMessage(hwnd, WM_SYSTIMER, 0, 0L);
        SendMessage(hwnd, WM_SYSCOMMAND, SC_KEYMENU, (DWORD)(WORD)'e');
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            DispatchMessage(&msg);
    }

    END_TIMER_NO_RETURN;

    ShowWindow(hwnd, SW_RESTORE);
    UpdateWindow(hwnd);

    RETURN_STOP_TIME;

}



ULONGLONG msProfGetClientRect(HDC hdc, ULONG Iter)
{

    RECT rc;
    INIT_TIMER;

    START_TIMER;

    while (ix--)
    {
        GetClientRect(ghwndMDIClient, &rc);
    }

    END_TIMER;
}


ULONGLONG msProfScreenToClient(HDC hdc, ULONG Iter)
{

    POINT pt;
    INIT_TIMER;

    pt.x = 100;
    pt.y = 200;

    START_TIMER;

    while (ix--)
    {
        ScreenToClient(ghwndMDIClient, &pt);
    }

    END_TIMER;
}


ULONGLONG msProfGetInputState(HDC hdc, ULONG Iter)
{

    INIT_TIMER;

    START_TIMER;

    while (ix--)
    {
        GetInputState();
    }

    END_TIMER;
}


ULONGLONG msProfGetKeyState(HDC hdc, ULONG Iter)
{

    INIT_TIMER;

    START_TIMER;

    while (ix--)
    {
        GetKeyState(VK_ESCAPE);
    }

    END_TIMER;
}


ULONGLONG msProfGetAsyncKeyState(HDC hdc, ULONG Iter)
{

    INIT_TIMER;

    START_TIMER;

    while (ix--)
    {
        GetAsyncKeyState(VK_ESCAPE);
    }

    END_TIMER;
}


ULONGLONG msProfDispatchMessage(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    MSG msg;
    INIT_TIMER;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "14RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwnd = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    msg.hwnd = hwnd;
    msg.message = WM_MOUSEMOVE;
    msg.wParam = 1;
    msg.lParam = 2;
    msg.time = 3;
    msg.pt.x = 4;
    msg.pt.y = 5;

    START_TIMER;

    while (ix--)
    {
        DispatchMessage(&msg);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfCallback(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    INIT_TIMER;
    WNDCLASSW wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProcW;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = L"CreateDestroyWindow";

    if (!RegisterClassW(&wc)) {
// Fails On Chicago
//        MessageBox(GetParent(ghwndMDIClient), "15RegisterClass call failed.",
//                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwnd = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    START_TIMER;

    while (ix--)
    {
        SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}


ULONGLONG msProfSendMessage(HDC hdc, ULONG Iter)
{

    HWND hwnd;
    INIT_TIMER;
    WNDCLASS wc;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "CreateDestroyWindow";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "16RegisterClass call failed.",
                "ERROR!", MB_OK);
        return (ULONGLONG)(0);
    }

    hwnd = CreateWindow("CreateDestroyWindow", NULL, WS_CHILD,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            ghwndMDIClient, NULL, ghinst, NULL);

    START_TIMER;

    while (ix--)
    {
        SendMessage(hwnd, WM_MOUSEMOVE, 1, 2);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);
    UnregisterClass("CreateDestroyWindow", ghinst);

    RETURN_STOP_TIME;

}

HWND hwndShare;

DWORD SendMessageDiffThreadFunc(PVOID pdwData)
{
    WNDCLASS wc;
    MSG msg;
    BOOL b;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = "SendMessageDiffThread";

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "19RegisterClass call failed.",
                "ERROR!", MB_OK);
        return FALSE;
    }

    hwndShare = CreateWindow("SendMessageDiffThread", NULL, 0,
            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
            GetDesktopWindow(), NULL, ghinst, NULL);


    ASSERT(hwndShare);

    SetEvent(*((PHANDLE)pdwData));

    while (GetMessage(&msg, NULL, 0, 0)) {
        DispatchMessage(&msg);
    }

    b = DestroyWindow(hwndShare);

    ASSERT(b);

    b = UnregisterClass("SendMessageDiffThread", ghinst);

    ASSERT(b);

    return TRUE;
}

ULONGLONG msProfSendMessageDiffThread(HDC hdc, ULONG Iter)
{

    DWORD dwData;
    DWORD id;
    HANDLE hEvent;
    HANDLE hThread;
    INIT_TIMER;

    hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    hwndShare = (HWND)0;

    hThread = CreateThread( NULL, 0, SendMessageDiffThreadFunc, &hEvent, 0, &id);

    WaitForSingleObject( hEvent, 20*1000);

    Sleep(10*1000);

    ASSERT(hwndShare);

    START_TIMER;

    while (ix--)
    {
        SendMessage(hwndShare, WM_MOUSEMOVE, 1, 2);
    }

    END_TIMER_NO_RETURN;

    PostThreadMessage(id, WM_QUIT, 0, 0);
    WaitForSingleObject(hThread, 2*1000); // Wait for Cleanup before Starting Next Cycle
    CloseHandle(hThread);

    RETURN_STOP_TIME;

}


ULONGLONG msProfUpdateWindow(HDC hDC, ULONG Iter)
{
    WNDCLASS wc;
    HWND hwnd;
    RECT rect;
    static LPCSTR className = "UpdateWindowTest";
    INIT_TIMER;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = className;

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "RegisterClass call failed.",
                "ERROR!", MB_OK);
        return FALSE;
    }

    hwnd = CreateWindow(className, NULL,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, ghinst, NULL);
    if (hwnd == NULL) {
        MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
            "ERROR!", MB_OK);
            return 0;
    }
    GetClientRect(hwnd, &rect);

    START_TIMER;
    while (ix--) {
        START_OVERHEAD;
        InvalidateRect(hwnd, &rect, FALSE);
        END_OVERHEAD;
        UpdateWindow(hwnd);
    }

    END_TIMER_NO_RETURN;

    DestroyWindow(hwnd);
    UnregisterClass(className, ghinst);

    RETURN_STOP_TIME;
}

ULONGLONG msProfTranslateMessage(HDC hDC, ULONG Iter)
{
    WNDCLASS wc;
    HWND hwnd;
    RECT rect;
    static LPCSTR className = "TranslateMessageTest";
    static MSG msgTemplate = {
        (HWND)NULL, WM_KEYDOWN,
        (WPARAM)0,
        (LPARAM)0,
        0,  // time
        {0, 0}, // mouse pointer
    };
    INIT_TIMER;

    wc.style            = 0;
    wc.lpfnWndProc      = CreateDestroyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghinst;
    wc.hIcon            = LoadIcon(ghinst, (LPSTR)IDUSERBENCH);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = className;

    if (!RegisterClass(&wc)) {
        MessageBox(GetParent(ghwndMDIClient), "RegisterClass call failed.",
                "ERROR!", MB_OK);
        return FALSE;
    }

    hwnd = CreateWindow(className, NULL,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, ghinst, NULL);
    if (hwnd == NULL) {
        MessageBox(GetParent(ghwndMDIClient), "CreateWindow call failed.",
            "ERROR!", MB_OK);
            return 0;
    }
    msgTemplate.hwnd = hwnd;


    START_TIMER;
    while (ix--) {
        MSG msg = msgTemplate;
        TranslateMessage(&msg);
    }

    DestroyWindow(hwnd);
    UnregisterClass(className, ghinst);

    END_TIMER;
}

#define WIDE    1
#include "awtest.inc"
#undef WIDE
#include "awtest.inc"

#define A1  A
#define A2  A
#include "abtest.inc"
#define A1  A
#define A2  W
#include "abtest.inc"
#define A1  W
#define A2  A
#include "abtest.inc"
#define A1  W
#define A2  W
#include "abtest.inc"


/*********************************************************************/

#define TEST_DEFAULT 300

TEST_ENTRY  gTestEntry[] = {
    (PUCHAR)"AvgDialog draw",(PFN_MS)msProfAvgDlgDraw, 10, 0 ,
    (PUCHAR)"AvgDialog create/draw/destroy",(PFN_MS)msProfAvgDlgCreate, 10, 0 ,
    (PUCHAR)"AvgDialog create/destroy",(PFN_MS)msProfAvgDlgCreateDestroy, 100, 0 ,
    (PUCHAR)"AvgDialog(no font) create/destroy",(PFN_MS)msProfAvgDlgCreateDestroyNoFont, 100, 0 ,
    (PUCHAR)"AvgDialog(no menu) create/destroy",(PFN_MS)msProfAvgDlgCreateDestroyNoMenu, 100, 0 ,
    (PUCHAR)"AvgDialog(empty) create/destroy",(PFN_MS)msProfAvgDlgCreateDestroyEmpty, 200, 0 ,
    (PUCHAR)"SizeWindow",(PFN_MS)msProfSize, 200, 0 ,
    (PUCHAR)"MoveWindow",(PFN_MS)msProfMove, 2000, 0 ,
    (PUCHAR)"Create/DestroyWindow (top)",(PFN_MS)msProfCreateDestroyWindow, 1000, 0 ,
    (PUCHAR)"Create/DestroyWindow (child)",(PFN_MS)msProfCreateDestroyChildWindow, 1000, 0 ,

    (PUCHAR)"Create/Destroy Listbox",(PFN_MS)msProfCreateDestroyListbox, 1000, 0 ,
    (PUCHAR)"Create/Destroy Button",(PFN_MS)msProfCreateDestroyButton, 1000, 0 ,
    (PUCHAR)"Create/Destroy Combobox",(PFN_MS)msProfCreateDestroyCombobox, 1000, 0 ,
    (PUCHAR)"Create/Destroy Edit",(PFN_MS)msProfCreateDestroyEdit, 1000, 0 ,
    (PUCHAR)"Create/Destroy Static",(PFN_MS)msProfCreateDestroyStatic, 1000, 0 ,
    (PUCHAR)"Create/Destroy Scrollbar",(PFN_MS)msProfCreateDestroyScrollbar, 1000, 0 ,
    (PUCHAR)"SendMessage w/callback",(PFN_MS)msProfCallback, 4000, 0 ,
    (PUCHAR)"SendMessage",(PFN_MS)msProfSendMessage, 4000, 0 ,
    (PUCHAR)"SendMessage Ansi->Ansi text",(PFN_MS)msProfSendMessageAA, 4000, 0 ,
    (PUCHAR)"SendMessage Ansi->Unicode text",(PFN_MS)msProfSendMessageAW, 4000, 0 ,
    (PUCHAR)"SendMessage Unicode->Ansi text", (PFN_MS)msProfSendMessageWA, 4000, 0,
    (PUCHAR)"SendMessage Unicode->Unicode text", (PFN_MS)msProfSendMessageWW, 4000, 0,

    (PUCHAR)"SendMessage - DiffThread",(PFN_MS)msProfSendMessageDiffThread, 1000, 0 ,
    (PUCHAR)"SetWindowLong",(PFN_MS)msProfSetWindowLong, 400, 0 ,
    (PUCHAR)"GetWindowLong",(PFN_MS)msProfGetWindowLong, 2000, 0 ,

    (PUCHAR)"PeekMessageA",(PFN_MS)msProfPeekMessageA, 1000, 0 ,
    (PUCHAR)"PeekMessageW",(PFN_MS)msProfPeekMessageW, 1000, 0 ,
    (PUCHAR)"DispatchMessageA",(PFN_MS)msProfDispatchMessageA, 4000, 0 ,
    (PUCHAR)"DispatchMessageW",(PFN_MS)msProfDispatchMessageW, 4000, 0 ,

    (PUCHAR)"LocalAlloc/Free",(PFN_MS)msProfLocalAllocFree, 2000, 0 ,

    (PUCHAR)"200 Listbox Insert",(PFN_MS)msProfListboxInsert1, 20, 0 ,
    (PUCHAR)"200 Listbox Insert (ownerdraw)",(PFN_MS)msProfListboxInsert2, 20, 0 ,
    (PUCHAR)"200 Listbox Insert (ownerdraw/sorted)",(PFN_MS)msProfListboxInsert3, 20, 0 ,

    (PUCHAR)"GetClientRect",(PFN_MS)msProfGetClientRect, 8000, 0 ,
    (PUCHAR)"ScreenToClient",(PFN_MS)msProfScreenToClient, 8000, 0 ,
    (PUCHAR)"GetInputState",(PFN_MS)msProfGetInputState, 2000, 0 ,
    (PUCHAR)"GetKeyState",(PFN_MS)msProfGetKeyState, 2000, 0 ,
    (PUCHAR)"GetAsyncKeyState",(PFN_MS)msProfGetAsyncKeyState, 8000, 0 ,

    (PUCHAR)"Register|UnregisterClass",(PFN_MS)msProfRegisterClass, 500, 0 ,
    (PUCHAR)"GetClassInfo|Name|Long|SetClassLong",(PFN_MS)msProfClassGroup, 500, 0 ,

    (PUCHAR)"Menu pulldown",(PFN_MS)msProfMenu, 2000, 0 ,

    (PUCHAR)"Open|Empty|Set|Get|CloseClipboard",(PFN_MS)msProfClipboardGroup, 1000, 0 ,

    (PUCHAR)"GetWindowTextLengthA",(PFN_MS)msProfGetWindowTextLengthA, 10000, 0,
    (PUCHAR)"GetWindowTextLengthW",(PFN_MS)msProfGetWindowTextLengthW, 10000, 0,

    (PUCHAR)"UdpateWindow",(PFN_MS)msProfUpdateWindow, 10000, 0,
    (PUCHAR)"TranslateMessage", (PFN_MS)msProfTranslateMessage, 10000, 0,
    (PUCHAR)"IsCharUpperA", (PFN_MS)msProfCharUpperA, 2000, 0,
    (PUCHAR)"IsCharLowerA", (PFN_MS)msProfCharLowerA, 2000, 0,
    (PUCHAR)"IsCharUpperW", (PFN_MS)msProfCharUpperW, 2000, 0,
    (PUCHAR)"IsCharLowerW", (PFN_MS)msProfCharLowerW, 2000, 0,
    (PUCHAR)"CharNextA", (PFN_MS)msProfCharNextA, 2000, 0,
    (PUCHAR)"CharNextW", (PFN_MS)msProfCharNextW, 2000, 0,
    (PUCHAR)"GetMessageW", (PFN_MS)msProfGetMessageW, 5000, 0,
    (PUCHAR)"GetMessageA", (PFN_MS)msProfGetMessageA, 5000, 0,
// Add New Tests Here
};


ULONG gNumTests = sizeof gTestEntry / sizeof gTestEntry[0]; //Total No. of Tests
ULONG gNumQTests = 10;// No. of tests in Group 1 (starting from first in the list)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\bench.h ===
#include <windows.h>

#ifdef RC_INVOKED
#define ID(id)              id
#else
#define ID(id)              MAKEINTRESOURCE(id)
#endif

#define GWLP_HWNDEDIT       0
#define IDUSERBENCH         ID(1)
#define IDNOTE              ID(2)

#ifndef RC_INVOKED

#ifndef WIN32
#define APIENTRY FAR PASCAL
typedef int INT;
typedef char CHAR;
#else
#define DLGPROC WNDPROC
#endif

#define A   0
#define W   1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\cycle.h ===
/*
**  Cycle count overhead. This is a number of cycles required to actually
**  calculate the cycle count. To get the actual number of net cycles between
**  two calls to GetCycleCount, subtract CCNT_OVERHEAD.
**
**  For example:
**
**	__int64 start, finish, actual_cycle_count;
**
**	start = GetCycleCount ();
**
**		... do some stuff ...
**
**	finish = GetCycleCount ();
**
**	actual_cycle_count = finish - start - CCNT_OVERHEAD;
**
**
*/

#define CCNT_OVERHEAD 8


#pragma warning( disable: 4035 )	/* Don't complain about lack of return value */

__inline __int64 GetCycleCount ()
{
__asm   _emit   0x0F
__asm   _emit   0x31    /* rdtsc */
    // return EDX:EAX       causes annoying warning
};

__inline unsigned GetCycleCount32 ()  // enough for about 40 seconds
{
__asm   push    EDX
__asm   _emit   0x0F
__asm   _emit   0x31    /* rdtsc */
__asm   pop     EDX
    // return EAX       causes annoying warning
};

#pragma warning( default: 4035 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commdlg.h>
#include <string.h>
#include <math.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <commctrl.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\resource.h ===
/*--

Copyright (c) 1990  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    defines for resource file

Author:

    Mark Enstrom (marke) 30-Dec-1992

Revision History:

	Dan Almosnino (danalm) 20-Sep-1995

	Added TEXT_QRUN, Text String-Length choice items (IDM_S...), Font choice option

	Dan Almosnino (danalm) 17-Oct-1995

	Added RUN_BATCH			for batch mode execution
	Added IDM_TRANSPARENT 	for transparent background text option
--*/
#define IDR_ACCELERATOR2                106
#define ID_RUN               40001

#define ID_DC                   110
#define IDD_RESULTS             111
#define IDD_HELP				913
#define IDC_RESULTSLIST         112
#define IDM_SAVERESULTS         113
#define IDM_SHOW                114
#define IDR_USRBENCH_MENU       101
//#define IDUSERBENCH				122
#define IDM_EXIT                202
#define IDM_RUN                 205
#define IDM_QRUN1               206
#define IDM_QRUN2   			207
#define RUN_BATCH				208
#define SHOW_HELP				911
#define IDM_HELP				911
#define IDC_HELPLIST			912
#define IDM_S001	             221
#define IDM_S002	             222
#define IDM_S004	             223
#define IDM_S008	             224
#define IDM_S016	             225
#define IDM_S032	             226
#define IDM_S064	             227
#define IDM_S128	             228
#define IDM_SXXX	             240
#define IDM_FONT                250
#define IDM_TRANSPARENT			260
#define ID_TEST_START           400
/*
 * Menu IDs.
 */

#define IDM_DUMMY           1
#define IDM_ABOUT           150
//#define IDM_EXIT            151
#define IDM_ALL             152
#define IDM_VIEWRESULTS     153
//#define IDM_SAVERESULTS     154
#define IDM_PROFILEALL      155

//#define IDM_BENCHFIRST      1000

/*
 * Control IDs.
 */

//#define IDC_RESULTSLIST     100
#define ID_EDIT             0xCAC
#define ID2             134
#define ID256           135
#define IDWIDTH         100
#define IDHEIGHT        101
#define IDIN            102
#define IDCM            103
#define IDPELS          104

/*
 * Dialog IDs
 */

#define IDD_ABOUT       300
//#define IDD_RESULTS     301
#define CLEARBOX        302
#define CLEARBOXNOMENU  303
#define CLEARBOXNOFONT  304
#define EMPTY           305



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\stats.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name

   stats.h

Abstract:

	Header file for Statistics module stats.c

Author:

   Dan Almosnino   (danalm)  20-Nov-1995
   Wrote it.

Enviornment:

   User Mode

Revision History:

++*/


#define HI_FILTER 		3
#define LO_FILTER		1
#define HI_LO_FILTER	2
#define NO_FILTER		0
#define HIGH_FILTER		HI_FILTER
#define LOW_FILTER		LO_FILTER
#define	HILO_FILTER		HI_LO_FILTER
#define HIGH_LOW_FILTER	HI_LO_FILTER


typedef struct _TEST_STATS
{
	double 	Average;
	double 	StdDev;
	double  Minimum_Result;
	double  Maximum_Result;
	long   	NumSamplesValid;

}TEST_STATS, *PTEST_STATS;	


BOOL 
Get_Stats(
	double 		*array, 
	long 		num_samples, 
	const 		filter_option, 
	long 		var_limit, 
	PTEST_STATS stats);

BOOL
GetAverage(
	double Sample_Array[],
	long No_Samples, 
	double *Average);

BOOL
GetStdDev(
	double Sample_Array[], 
	double Average, 
	long No_Samples,
	double *varcoef);

void 
SortUp(
	double *array, 
	long array_size);

BOOL 
FilterResults(
	double Sorted_Array[], 
	double *tmpAverage, 
	double *tmpSD, 
	long *tmpNumSamples, 
	long limit,
	const filter_option);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\stats.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name

   stats.c

Abstract:

   Perform basic statistics on a sample array of data: Average, Standard Deviation Coefficient.
   Perform simple filtering of Data to meet a specified Standard Deviation Coeficient (Optional). 

Author:

   Dan Almosnino   (danalm)  20-Nov-1995 -  Wrote it
  
Enviornment:

   User Mode

Revision History:

++*/

#include "precomp.h"
#include "stats.h"

/*++

Routine Description:

    Shell for statistic processing of data

Arguments

	double 		*array, 			   Raw data array
	long 		num_samples, 		   Number of samples taken
	const 		filter_option, 		   available options: HI_FILTER, LO_FILTER, HI_LO_FILTER, NO_FILTER
	long 		var_limit, 			   Filter data so that its variation coefficient (StdDev/Average) 
									   Won't exceed var_limit (in whole percent units)
	PTEST_STATS stats)				   Pointer to struct that contains the calculated statistical data 
  									   Members:	double	Average, StdDev(%) (variation coefficient),
  									  					Minimum_Result, Maximum_Result
									  			long	NumSamplesValid (after filtering)
									   Notes: Minimum_Result and Max_Result are always before filtering.
									  	 	A negative value of StdDev means that the average was zero, and
									   		the number returned is the negative value of the standard deviation
									   		itself and not a relative number (coeficient of variation)  
Return Value

    TRUE for Success
	FALSE for Failure 	(Indicates a failure of one of the called functions due to either:
						 Too small No. of original Samples or Valid Samples left after filtering, or
						 Zero Arithmetic Average of data (filtering cannot continue), or
						 Invalid filter option.
						   
--*/

BOOL 
Get_Stats(
	double 		*array, 			  
	long 		num_samples, 		  
	const 		filter_option, 		  
	long 		var_limit, 			   
	PTEST_STATS stats)				   

	{  

		double 	Averagetmp;
		double 	StdDevtmp;
		long 	NumSamplestmp;

		if(!GetAverage(array, num_samples, &Averagetmp))
			return FALSE; 

		SortUp(array, num_samples);

		if(!GetStdDev(array, Averagetmp, num_samples, &StdDevtmp))
			return FALSE;

		stats->Minimum_Result	= array[0];
		stats->Maximum_Result	= array[num_samples - 1];

		if(filter_option == NO_FILTER)
		{
			stats->Average = Averagetmp;
			stats->StdDev  = StdDevtmp;
			stats->NumSamplesValid	= num_samples;
			return TRUE;
		}


		NumSamplestmp 	= num_samples;
		if(!FilterResults(array,&Averagetmp,&StdDevtmp,&NumSamplestmp,var_limit,filter_option))
			return FALSE;

		stats->Average	 			= Averagetmp;
		stats->StdDev 				= StdDevtmp;
		stats->NumSamplesValid		= NumSamplestmp;
		return TRUE;

	}

/*++

Routine Description:

    Calculate the arithmetic average of an array of numbers

Arguments

    double	Sample_Array	- data array
	long	No_Samples		- number of samples to calculate the average of
	double *Average			- pointer to the result

Return Value

    TRUE 	for Success
	FALSE 	for Failure (No_Samples is zero)

--*/


BOOL 
GetAverage(
	double 	Sample_Array[], 
	long 	No_Samples, 
	double 	*Average)
	{
		long i;
		(*Average) = 0.0;
		
		if(No_Samples == 0)return FALSE;

		for(i = 0; i < No_Samples; i++)
		{
			(*Average) += Sample_Array[i];
		}

		(*Average) /= No_Samples;

		return TRUE;

	}

/*++

Routine Description:

    Calculate the standard deviation of a set of data

Arguments

    double	Sample_Array	- The data array
	double	Average			- The arithmetic Average of the Sample_Array
	long	No_Samples		- Number of Samples to Calculate
	double *varcoef			- The resulting coeficient of variation (StdDev / Average) in percent
							  (If the average is zero then the standard deviation itself is returned in 
							  negative value) 

Return Value

    TRUE for 	Success
	FALSE for 	Failure	(No. of Samples is less than two)

--*/
					 


BOOL
GetStdDev(
	double 	Sample_Array[], 
	double 	Average, 
	long 	No_Samples, 
	double 	*varcoef)
	{
		long 	i;
		double 	tmp;
		double 	Sum = 0.0;

		if(No_Samples <= 1L)
		{
			return FALSE;
		}

		for(i=0; i<No_Samples; i++)
		{
			tmp = (Sample_Array[i] - Average);
			Sum += (tmp*tmp);
		}

		Sum /= (No_Samples - 1);

		if(fabs( (float)Average) < 1.E-6)
		{
			*varcoef = (-sqrt(Sum));	// return the Standard Deviation itself in negative sign for distinction
		} 			
		else
		{
			*varcoef = (100*sqrt(Sum)/Average);	// return the variation coeficient in percents
		}

		return TRUE;
	}

/*++

Routine Description:

    Simplest Quick Sort routine (sorts-up an array of doubles)

Arguments

    double *Array		- Pointer to the array to be sorted (result is returned in the same address)
	long	array_size	- Size of array to be sorted

Return Value

    none

--*/


void
SortUp(
	double 	*array, 
	long	array_size)
	{
		long gap, i, j;
		double temp;
			
		for(gap = array_size/2; gap > 0; gap /= 2)
			for(i = gap; i < array_size; i++)
				for(j = i - gap; j >= 0 && array[j] > array[j + gap]; j -= gap)
				{
					temp = array[j];
					array[j] = array[j + gap];
					array[j + gap] = temp;
				}

	}			

/*++

Routine Description:

    Filter a set of data to meet a pre-defined coeficient of variation

Arguments

	double Sorted_Array		- A pointer to a pre-sorted up array of data to be filtered
	double *tmpAverage		- A pointer to the arithmetic average of the array of data.
							  Upon exit will contain the resulting average of the filtered data.
	double *tmpSD			- A pointer to the variation coefficient (in percent) of the input array of data.
							  Upon exit will contain the resulting variation coefficient of the filtered data
							  after the constraint was met.
	long 	*tmpNumSamples	- A pointer to the number of samples to be filtered.
							  Upon return will contain the number of valid samples left after the filtering.
	long 	limit			- The pre defined coefficient of variation (StdDev / Average)to be met 
							  (in whole percents).
	const	filter_option	- One of the following:	
								HI_FILTER	- filter eliminates the high values from top down until limit is met
								LO_FILTER	- filter eliminates the low values from bottom up until limit is met
								HI_LO_FILTER- filter eliminates both high and low values in this order until limit is met
								other	- routine will return a FALSE 

Return Value

    TRUE 	for Success
	FALSE 	for failure (Either number of samples left after sequential filtering passes is less than three,
						 or for some reason the filtered average became zero,
						 or the filter option is an invalid value)

--*/



BOOL 
FilterResults(
	double 	Sorted_Array[], 
	double 	*tmpAverage, 
	double 	*tmpSD, 
	long 	*tmpNumSamples, 
	long 	limit,
	const	filter_option)
	{


		switch (filter_option)
		{
			case HI_FILTER:
			{
				while(*tmpSD > (double)limit)
				{

					if(*tmpNumSamples <= 2)return FALSE;

					(*tmpAverage) 	*= (*tmpNumSamples);
					(*tmpAverage) 	-= Sorted_Array[(*tmpNumSamples) - 1];
					(*tmpNumSamples)--;
					(*tmpAverage) 	/= (*tmpNumSamples);

					GetStdDev(Sorted_Array, *tmpAverage, *tmpNumSamples, &(*tmpSD));
				
				}
			
				if(*tmpSD < 0)return FALSE;
			}
			break;

			case LO_FILTER:
			{

				while(*tmpSD > (double)limit)
				{

					if(*tmpNumSamples <= 2)return FALSE;

					(*tmpAverage) 	*= (*tmpNumSamples);
					(*tmpAverage) 	-= (*Sorted_Array);
					Sorted_Array++;
					(*tmpNumSamples)--;
					(*tmpAverage) 	/= (*tmpNumSamples);

					GetStdDev(Sorted_Array, *tmpAverage, *tmpNumSamples, &(*tmpSD));
				
				}
			
				if(*tmpSD < 0)return FALSE;

			}
			break;

			case HI_LO_FILTER:
			{
				
				while(*tmpSD > (double)limit)
				{

					if(*tmpNumSamples <= 2)return FALSE;

					if(fabs((*Sorted_Array) - (*tmpAverage)) > fabs(Sorted_Array[*tmpNumSamples - 1] - *tmpAverage))
					{
						(*tmpAverage) 	*= (*tmpNumSamples);
						(*tmpAverage) 	-= (*Sorted_Array);
						Sorted_Array++;
					}
					else
					{
						(*tmpAverage) 	*= (*tmpNumSamples);
						(*tmpAverage) 	-= Sorted_Array[(*tmpNumSamples) - 1];
					}						

					(*tmpNumSamples)--;
					(*tmpAverage) 	/= (*tmpNumSamples);

					GetStdDev(Sorted_Array, *tmpAverage, *tmpNumSamples, &(*tmpSD));
				
				}
			
				if(*tmpSD < 0)return FALSE;

			}
			break;

			default:
			return FALSE;

		}				//switch filter_option

		return TRUE;
						
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\usrbench.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name

   usrbench.c

Abstract:

    USER performance numbers

Author:

   Dan Almosnino (danalm)   25-July-1996
   Based on code by MarkE and DarrinM

Enviornment:

   User Mode

Revision History:

   Dan Almosnino (danalm) 20-Sept-1995

1. Timer call modified to run on both NT and WIN95.
2. Test-Menu flag option added to prevent long one-colomn menu that flows out of the window in new
   shell (both WIN95 and NT).
3. Added Option menu item to choose fonts and string size for text-string related function calls.
4. Added Run 2nd Suite option for the above.
5. Modified the output save file to report the information for the above.

    Dan Almosnino (danalm) 17-Oct-1995

1.  Added Batch Mode and help for running batch mode
2.  Added "Transparent" background text option to menu

    Dan Almosnino (danalm) 20-Nov-1995

1.  Added Option for using the Pentium Cycle Counter instead of "QueryPerformanceCounter" when applicable.
2.  Added a simple statistics module and filter for processing the raw test data.

    Dan Almosnino (danalm) 25-July-1996

1.  Adapted the GDIbench UI and processing to UserBench

  Hiro Yamamoto (hiroyama) 18-Sept-1996

* use listview control to show results

--*/


#include "precomp.h"
#include "resource.h"
#include "wchar.h"
#define MAIN_MODULE
#include "usrbench.h"
#undef MAIN_MODULE
#include "bench.h"

//
// some globals
//

PSZ     pszTest                 = DEFAULT_A_STRING;
PWSTR   pwszTest                = DEFAULT_W_STRING;

BOOL    gfPentium               = FALSE;
BOOL    gfUseCycleCount         = TRUE;

HINSTANCE   hInstMain;

// USERBENCH GLOBALS
HANDLE ghaccel;
HANDLE ghinst;
HWND ghwndFrame = NULL, ghwndMDIClient = NULL;

//

MDICREATESTRUCT mcs;


CHAR szChild[] = "child";           // Class name for "Child" window
CHAR szFrame[] = "frame";           // Class name for "frame" window

static CHOOSEFONT    cf;
static LOGFONT       lf;        /* logical font structure       */


LRESULT APIENTRY MDIChildWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

BOOL APIENTRY InitializeInstance(HINSTANCE hInst, HINSTANCE hPrev, INT nCmdShow);




int PASCAL
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrev,
    LPSTR szCmdLine,
    int cmdShow
)

/*++

Routine Description:

   Process messages.

Arguments:

   hWnd    - window hande
   msg     - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation


Revision History:

      02-17-91      Initial code

--*/


{
    MSG         msg;
    HWND        hWndDesk;
    HWND        hwnd;
    HDC hdc2;

    char txtbuf[80];
    char *ptr;

    hInstMain =  hInst;
    ghinst    =  hInst;

    // Initialize Instance, Create Frame Window, Desktop Window and an MDI client Window

    if(!InitializeInstance(hInst, hPrev, cmdShow))
        return FALSE;

    // Initialize Source Strings

    strcpy(SourceString, "This is just a silly test string. Would you rather have a different one? Well, you can define one if you run GDI bench in batch!");
    wcscpy(SourceStringW, L"This is just a silly test string. Would you rather have a different one? Well, you can define one if you run GDI bench in batch!");
    StrLen                  = DEFAULT_STRING_LENGTH;

    //  Batch Mode Related

    TextSuiteFlag           = FALSE;
    BatchFlag               = FALSE;
    Finish_Message          = FALSE;
    Dont_Close_App          = FALSE;
    SelectedFontTransparent = FALSE;
    String_Length_Warn      = FALSE;
    Print_Detailed          = FALSE;

//  GdiSetBatchLimit(1);                // Kills all GDI Batching


    // Check for help or batch-mode command-line parameters


    if(CMD_IS("-?") || CMD_IS("/?") || CMD_IS("-h") || CMD_IS("-H") ||CMD_IS("/h") || CMD_IS("/H"))
    {
        SendMessage(ghwndFrame,WM_COMMAND,IDM_HELP,0L);       // Show Help Dialog
    }

    if (CMD_IS("-b") || CMD_IS("-B") || CMD_IS("/b") || CMD_IS("/B"))
    {
        BatchFlag = TRUE;
        GetCurrentDirectory(sizeof(IniFileName),IniFileName);  // Prepare INI file path, append name later
        strcat(IniFileName,"\\");
    }

    if (CMD_IS("-m") || CMD_IS("-M") || CMD_IS("/m") || CMD_IS("/M"))
        Finish_Message = TRUE;

    if ( CMD_IS("-s") || CMD_IS("-S") || CMD_IS("/s") || CMD_IS("/S"))
        Dont_Close_App = TRUE;

    if ( CMD_IS("-t") || CMD_IS("-T") || CMD_IS("/t") || CMD_IS("/T"))
        gfUseCycleCount = FALSE;

    if ( CMD_IS("-d") || CMD_IS("-D") || CMD_IS("/d") || CMD_IS("/D"))
        Print_Detailed = TRUE;


    if ( CMD_IS("-i"))
    {
        ptr = strstr(szCmdLine, "-i");
        sscanf(ptr+2,"%s",txtbuf);
        strcat(IniFileName,txtbuf);
    }
    else if (CMD_IS("-I"))
    {
        ptr = strstr(szCmdLine, "-I");
        sscanf(ptr+2,"%s",txtbuf);
        strcat(IniFileName,txtbuf);
    }
    else if (CMD_IS("/i"))
    {
        ptr = strstr(szCmdLine, "/i");
        sscanf(ptr+2,"%s",txtbuf);
        strcat(IniFileName,txtbuf);
    }
    else if (CMD_IS("/I"))
    {
        ptr = strstr(szCmdLine, "/I");
        sscanf(ptr+2,"%s",txtbuf);
        strcat(IniFileName,txtbuf);
    }
    else
    {
        strcat(IniFileName,"USRBATCH.INI");
    }

    if(BatchFlag == TRUE) {
        /*
         * pull any messages out of the queue before starting to avoid
         * contaminating our results.
         */
        while (PeekMessage(&msg,NULL,0,0,PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

        SendMessage(ghwndFrame,WM_COMMAND,RUN_BATCH,0L);      // Start Batch
    }

    //
    // Main message loop
    //

    while (GetMessage(&msg,(HWND)NULL,0,0))
    {
        /*
         * If a keyboard message is for the MDI, let the MDI client
         * take care of it.  Otherwise, check to see if it's a normal
         * accelerator key (like F3 = find next).  Otherwise, just handle
         * the message as usual.
         */
        if (!TranslateMDISysAccel(ghwndMDIClient, &msg) &&
                !TranslateAccelerator(ghwndFrame, ghaccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    }

  return (int)msg.wParam;
}



LRESULT FAR
PASCAL WndProc(
    HWND        hWnd,
    unsigned    msg,
    WPARAM      wParam,
    LPARAM      lParam)

/*++

Routine Description:

   Process messages.

Arguments:

   hWnd    - window hande
   msg     - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation


Revision History:

      02-17-91      Initial code

--*/

{

    BOOL Status;
    UCHAR tmsg[256];
    int MBresult;
    char txtbuf[80];
    char strbuf[256];
    char tmpbuf[5][20];
    int i,j,k,n;
    char *kptr;
    char TestTypeEntry[16];
    int TestType;
    int Num_Selected_Tests;
    int Test_Item[25];
    char SelectedFont[32];
    int  SelectedFontSize       = 12;
    BYTE SelectedFontBold       = FALSE;
    BYTE SelectedFontItalic     = FALSE;
    BYTE SelectedFontUnderline  = FALSE;
    BYTE SelectedFontStrike     = FALSE;
    COLORREF SelectedFontColor  = RGB(0,0,0);
    char tst[2];
    BYTE FontRed, FontGreen, FontBlue;
    char TextString[256];
    int No_String_Lengths, No_Font_Sizes;
    int StringLength[16], FontSize[16];
    int Source_String_Length;
    int Text_Test_Order[16];
    int VPixelsPerLogInch;
    static int Last_Checked = 5;

    double Sum;
    double Sample[NUM_SAMPLES];

    static HDC hdc2;          /* display DC handle            */
    static HFONT hfont;       /* new logical font handle      */
    static HFONT hfontOld;    /* original logical font handle */
    static COLORREF crOld;    /* original text color          */


    switch (msg) {

    case WM_CREATE:
    {
        ULONG ix;
        HWND hwnd;
        HMENU hAdd = GetSubMenu(GetMenu(hWnd),1);
        HMENU hmenu = GetSubMenu(GetSubMenu(GetSubMenu(GetMenu(hWnd),2),0),0);

        for (ix=0;ix<NUM_TESTS;ix++)
        {

            if ((ix > 0) && ((ix % 20) == 0))
            {
                AppendMenu(hAdd, MF_MENUBARBREAK | MF_SEPARATOR,0,0);
            }

            wsprintf(tmsg,"T%i: %s",ix,gTestEntry[ix].Api);
            AppendMenu(hAdd, MF_STRING | MF_ENABLED, ID_TEST_START + ix, tmsg);
        }

        CheckMenuItem(hmenu,5,MF_BYPOSITION|MF_CHECKED);

    }
    break;
    case WM_COMMAND:
    {

            switch (LOWORD(wParam)){
            case IDM_EXIT:
            {
                SendMessage(hWnd,WM_CLOSE,0,0L);
            }
             break;

            case IDM_SHOW:
                DialogBox(hInstMain, (LPSTR)IDD_RESULTS, hWnd, ResultsDlgProc);
                break;

            case IDM_HELP:
                DialogBox(hInstMain, (LPSTR)IDD_HELP, hWnd, HelpDlgProc);
                break;

//
// Choose and Set Text String Length
//

            case IDM_S001:
                {
                    StrLen = 1;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 0);
                }
                break;

            case IDM_S002:
                {
                    StrLen = 2;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 1);

                }
                break;

            case IDM_S004:
                {
                    StrLen = 4;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 2);

                }
                break;

            case IDM_S008:
                {
                    StrLen = 8;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 3);

                }
                break;

            case IDM_S016:
                {
                    StrLen = 16;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 4);

                }
                break;

            case IDM_S032:
                {
                    StrLen = 32;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 5);

                }
                break;

            case IDM_S064:
                {
                    StrLen = 64;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 6);

                }
                break;

            case IDM_S128:
                {
                    StrLen = 128;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 7);

                }
                break;

//            case IDM_SXXX:
//
//            break;

            case IDM_TRANSPARENT:
                {
                    HMENU hmenu = GetSubMenu(GetSubMenu(GetMenu(hWnd),2),0);
                    if(SelectedFontTransparent == TRUE)
                    {
                        SelectedFontTransparent = FALSE;
                        CheckMenuItem(hmenu,2,MF_BYPOSITION|MF_UNCHECKED);
                    }
                    else if(SelectedFontTransparent == FALSE)
                    {
                        SelectedFontTransparent = TRUE;
                        CheckMenuItem(hmenu,2,MF_BYPOSITION|MF_CHECKED);
                    }
                }
                break;


            case IDM_FONT:         // Invoke the ChooseFont Dialog (interactive mode)
                {
        /* Initialize the necessary members */

                    cf.lStructSize = sizeof (CHOOSEFONT);
                    cf.hwndOwner = hWnd;
                    cf.lpLogFont = &lf;
                    cf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT;
                    cf.nFontType = SCREEN_FONTTYPE;
/*
 * Display the dialog box, allow the user to
 * choose a font, and render the text in the
 * window with that selection.
 */
                    if (ChooseFont(&cf)){
                        hdc2 = GetDC(hWnd);
                        hfont = CreateFontIndirect(cf.lpLogFont);
                        hfontOld = SelectObject(hdc2, hfont);
                        crOld = SetTextColor(hdc2, cf.rgbColors);

                    }

                }
                break;

            //
            // Run all tests
            //

            case IDM_RUN:               // Run all tests
                {
                    ULONG Index;
                    PFN_MS pfn;
                    HDC hdc = GetDC(hWnd);
                    RECT CliRect = {20,20,500,40};

                    if(NULL==GetWindow(ghwndMDIClient,GW_CHILD))                     //If Test Object doesn't exist
                    SendMessage(ghwndMDIClient, WM_MDICREATE, 0, (LPARAM)&mcs); //Create Test Object

                    for (Index=0;Index<NUM_TESTS;Index++)
                    {
                        HDC hdc2 = GetDC(hWnd);

                        FillRect(hdc,&CliRect,GetStockObject(GRAY_BRUSH));
                        wsprintf(tmsg,"Testing %s",gTestEntry[Index].Api);
                        TextOut(hdc2,20,20,tmsg,strlen(tmsg));
                        pfn = gTestEntry[Index].pfn;
                        ShowCursor(FALSE);

                        hfont = CreateFontIndirect(cf.lpLogFont);
                        hfontOld = SelectObject(hdc2, hfont);
                        crOld = SetTextColor(hdc2, cf.rgbColors);
                        if(SelectedFontTransparent)SetBkMode(hdc2,TRANSPARENT);

    ////// Statistics

                        for(j=0; j<NUM_SAMPLES; j++)
                        {

                            GdiFlush();

                            Sample[j] = (double)(*pfn)(hdc2,gTestEntry[Index].Iter);
                            Detailed_Data[Index][j] = (long)(0.5 + Sample[j]);
                        }

                        Get_Stats(Sample,NUM_SAMPLES,HI_FILTER,VAR_LIMIT,&TestStats[Index]);
    ///////

                        ShowCursor(TRUE);

                        SetTextColor(hdc, crOld);
                        SelectObject(hdc, hfontOld);
                        DeleteObject(hfont);
                        SetBkMode(hdc2,OPAQUE);

                        ReleaseDC(hWnd,hdc2);
                    }

                    ReleaseDC(hWnd,hdc);
                    if(BatchFlag != TRUE)
                        DialogBox(hInstMain, (LPSTR)IDD_RESULTS, hWnd, ResultsDlgProc);
                }
                break;

            case IDM_QRUN1:             // Run the quick test suite 1
                {
                    ULONG Index;
                    PFN_MS pfn;
                    HDC hdc = GetDC(hWnd);
                    RECT CliRect = {20,20,500,40};


                    if(NULL==GetWindow(ghwndMDIClient,GW_CHILD))                     //If Test Object doesn't exist
                    SendMessage(ghwndMDIClient, WM_MDICREATE, 0, (LPARAM)&mcs); //Create Test Object

                    for (Index=0;Index<NUM_QTESTS;Index++)
                    {
                        HDC hdc2 = GetDC(hWnd);

                        FillRect(hdc,&CliRect,GetStockObject(GRAY_BRUSH));
                        wsprintf(tmsg,"Testing %s",gTestEntry[Index].Api);
                        TextOut(hdc2,20,20,tmsg,strlen(tmsg));
                        pfn = gTestEntry[Index].pfn;
                        ShowCursor(FALSE);

                        hfont = CreateFontIndirect(cf.lpLogFont);
                        hfontOld = SelectObject(hdc2, hfont);
                        crOld = SetTextColor(hdc2, cf.rgbColors);
                        if(SelectedFontTransparent)SetBkMode(hdc2,TRANSPARENT);

    ////// Statistics

                        for(j=0; j<NUM_SAMPLES; j++)
                        {

                            GdiFlush();

                            Sample[j] = (double)(*pfn)(hdc2,gTestEntry[Index].Iter);
                            Detailed_Data[Index][j] = (long)(0.5 + Sample[j]);
                        }

                        Get_Stats(Sample,NUM_SAMPLES,HI_FILTER,VAR_LIMIT,&TestStats[Index]);
    ///////


                        ShowCursor(TRUE);

                        SetTextColor(hdc, crOld);
                        SelectObject(hdc, hfontOld);
                        DeleteObject(hfont);
                        SetBkMode(hdc2,OPAQUE);
                        ReleaseDC(hWnd,hdc2);
                    }

                    ReleaseDC(hWnd,hdc);

                    if(BatchFlag != TRUE)
                        DialogBox(hInstMain, (LPSTR)IDD_RESULTS, hWnd, ResultsDlgProc);
                }
                break;

            case IDM_QRUN2:         // Run Quick Test Suite 2
                {
                    ULONG Index;
                    PFN_MS pfn;
                    HDC hdc = GetDC(hWnd);
                    RECT CliRect = {20,20,500,40};

                    TextSuiteFlag = TRUE;

                    if(NULL==GetWindow(ghwndMDIClient,GW_CHILD))                     //If Test Object doesn't exist
                    SendMessage(ghwndMDIClient, WM_MDICREATE, 0, (LPARAM)&mcs); //Create Test Object

                    for (Index = FIRST_TEXT_FUNCTION; Index <= LAST_TEXT_FUNCTION; Index++)
                    {
                        HDC hdc2 = GetDC(hWnd);

                        FillRect(hdc,&CliRect,GetStockObject(GRAY_BRUSH));
                        wsprintf(tmsg,"Testing %s",gTestEntry[Index].Api);
                        TextOut(hdc2,20,20,tmsg,strlen(tmsg));
                        pfn = gTestEntry[Index].pfn;
                        ShowCursor(FALSE);

                        hfont = CreateFontIndirect(cf.lpLogFont);
                        hfontOld = SelectObject(hdc2, hfont);
                        crOld = SetTextColor(hdc2, cf.rgbColors);
                        if(SelectedFontTransparent)SetBkMode(hdc2,TRANSPARENT);
    ////// Statistics

                        for(j=0; j<NUM_SAMPLES; j++)
                        {

                            GdiFlush();

                            Sample[j] = (double)(*pfn)(hdc2,gTestEntry[Index].Iter);
                            Detailed_Data[Index][j] = (long)(0.5 + Sample[j]);

                        }

                        Get_Stats(Sample,NUM_SAMPLES,HI_FILTER,VAR_LIMIT,&TestStats[Index]);
    ///////

                        ShowCursor(TRUE);
                        SetTextColor(hdc, crOld);
                        SelectObject(hdc, hfontOld);
                        DeleteObject(hfont);
                        SetBkMode(hdc2,OPAQUE);

                        ReleaseDC(hWnd,hdc2);

                    }

                    ReleaseDC(hWnd,hdc);

                    if(BatchFlag != TRUE)
                        DialogBox(hInstMain, (LPSTR)IDD_RESULTS, hWnd, ResultsDlgProc);

                }
                break;

//
// Run in Batch Mode
//
            case RUN_BATCH:
                {
                    fpIniFile = fopen(IniFileName,"r");
                    if(NULL == fpIniFile)
                    {
                        MessageBox(hWnd,"USRBATCH.INI File Not Found, Cannot Continue in Batch Mode","INI File Not Found",MB_ICONSTOP|MB_OK);
                        BatchFlag = FALSE;
                        break;
                    }
                    else                    //Start reading INI file Keys

                    {
                        if(!GetPrivateProfileString("BATCH","RUN","TEXT",TestTypeEntry,sizeof(TestTypeEntry),IniFileName))
                        {
                            MessageBox(hWnd,"Invalid Caption 1 in USRBATCH.INI File ", "INI File Error",MB_ICONSTOP|MB_OK);
                            BatchFlag = FALSE;
                            break;
                        }

                        BatchCycle = GetPrivateProfileInt("BATCH","CYCLE",1,IniFileName);

                        if(NULL != strstr(TestTypeEntry, "ALL"))
                        {
                            TestType = ALL;
                        }
                        else if(NULL != strstr(TestTypeEntry, "QUICK"))
                        {
                            TestType = QUICK;
                        }
                        else if(NULL != strstr(TestTypeEntry, "TEXT"))
                        {
                            TestType = TEXT_SUITE;
                        }
                        else if(NULL != strstr(TestTypeEntry, "SELECT"))
                        {
                            TestType = SELECT;
                        }
                        else
                        {
                            MessageBox(hWnd,"Invalid or No Test-Type Entry in USRBATCH.INI File", "INI File Error",MB_ICONSTOP|MB_OK);
                            BatchFlag = FALSE;
                            break;
                        }

                        switch (TestType)
                        {
                            case ALL:                   // Run all tests
                            {
                                fclose(fpIniFile);
                                OutFileName = SelectOutFileName(hWnd);
                                if(NULL == OutFileName)
                                {
                                    BatchFlag = FALSE;
                                    break;
                                }
                                fpOutFile = fopen(OutFileName, "w+");

                                for(i=0; i < BatchCycle; i++)
                                {
                                    SendMessage(hWnd,WM_COMMAND,IDM_RUN,0L);
                                    WriteBatchResults(fpOutFile, TestType, i+1);
                                }

                                fclose(fpOutFile);

                                if(Finish_Message == TRUE)
                                {
                                    strcpy(txtbuf,"Batch Job Finished Successfully, Results Written to ");
                                    strcat(txtbuf,OutFileName);
                                    MessageBox(hWnd,txtbuf, "Batch Job Finished",MB_ICONINFORMATION|MB_OK);
                                }

                                if(Dont_Close_App == TRUE)
                                {
                                    BatchFlag = FALSE;
                                    for(i=0; i<(int)NUM_TESTS; i++)
                                    {
                                        gTestEntry[i].Result = 0;
                                    }
                                }
                                else
                                {
                                    SendMessage(hWnd,WM_COMMAND,IDM_EXIT,0L);
                                }

                            }

                            break;

                            case QUICK:                 // Run the quick suite
                            {
                                fclose(fpIniFile);

                                OutFileName = SelectOutFileName(hWnd);

                                fpOutFile = fopen(OutFileName, "w+");
                                if(NULL == fpOutFile)
                                {
                                    BatchFlag = FALSE;
                                    break;
                                }

                                for(i=0; i < BatchCycle; i++)
                                {
                                    SendMessage(hWnd,WM_COMMAND,IDM_QRUN1,0L);
                                    WriteBatchResults(fpOutFile, TestType, i+1);
                                }

                                fclose(fpOutFile);

                                if(Finish_Message == TRUE)
                                {
                                    strcpy(txtbuf,"Batch Job Finished Successfully, Results Written to ");
                                    strcat(txtbuf,OutFileName);
                                    MessageBox(hWnd,txtbuf, "Batch Job Finished",MB_ICONINFORMATION|MB_OK);
                                }

                                if(Dont_Close_App == TRUE)
                                {
                                    BatchFlag = FALSE;
                                    for(i=0; i<(int)NUM_TESTS; i++)
                                    {
                                        gTestEntry[i].Result = 0;
                                    }
                                }
                                else
                                {
                                    SendMessage(hWnd,WM_COMMAND,IDM_EXIT,0L);
                                }

                            }
                            break;

                            case TEXT_SUITE:                    // Get some more keys then run the text suite
                            {

                                n = GetPrivateProfileString("TEXT","FONT","Arial",txtbuf,sizeof(txtbuf),IniFileName);

                                i = 0;

                                do
                                {
                                    sscanf(&txtbuf[i],"%1c",tst);
                                    ++i;
                                }
                                while((i <= n ) && (tst[0] != ',') && (tst[0] != ';'));

                                strncpy(&SelectedFont[0],&txtbuf[0],i-1);
                                strcpy(&SelectedFont[i-1],"\0");

                                if(NULL != strstr(&txtbuf[i], "BOLD"))
                                {
                                    SelectedFontBold = TRUE;
                                }

                                if(NULL != strstr(&txtbuf[i], "ITALIC"))
                                {
                                    SelectedFontItalic = TRUE;
                                }

                                if(NULL != strstr(&txtbuf[i], "UNDERLINE"))
                                {
                                    SelectedFontUnderline = TRUE;
                                }

                                if(NULL != strstr(&txtbuf[i], "STRIKE"))
                                {
                                    SelectedFontStrike = TRUE;
                                }

                                if(NULL != strstr(&txtbuf[i], "TRANSPARENT"))
                                {
                                    SelectedFontTransparent = TRUE;
                                }

                                kptr = strstr(&txtbuf[0], "RGB(");   // Parse and interpret the RGB values if exist
                                if(NULL != kptr)
                                {
                                    sscanf(kptr+4,"%s",tmpbuf[0]);

                                    FontRed     = 0;
                                    FontGreen   = 0;
                                    FontBlue    = 0;

                                    j = 0;

                                    sscanf(&tmpbuf[0][j],"%1c",tst);

                                    while(tst[0] == ' ')
                                    {
                                        ++j;
                                        sscanf(&tmpbuf[0][j],"%1c",tst);
                                    }
                                    while(tst[0] != ',')
                                    {
                                        FontRed = 10*FontRed + atoi(tst);
                                        ++j;
                                        sscanf(&tmpbuf[0][j],"%1c",tst);
                                    }

                                    ++j;
                                    sscanf(&tmpbuf[0][j],"%1c",tst);
                                    while(tst[0] == ' ')
                                    {
                                        ++j;
                                        sscanf(&tmpbuf[0][j],"%1c",tst);
                                    }
                                    while(tst[0] != ',')
                                    {
                                        FontGreen = 10*FontGreen + atoi(tst);
                                        ++j;
                                        sscanf(&tmpbuf[0][j],"%1c",tst);
                                    }

                                    ++j;
                                    sscanf(&tmpbuf[0][j],"%1c",tst);
                                    while(tst[0] == ' ')
                                    {
                                        ++j;
                                        sscanf(&tmpbuf[0][j],"%1c",tst);
                                    }
                                    while(tst[0] != ')')
                                    {
                                        FontBlue = 10*FontBlue + atoi(tst);
                                        ++j;
                                        sscanf(&tmpbuf[0][j],"%1c",tst);
                                        if(tst[0] == ' ')break;
                                    }

                                    SelectedFontColor = RGB(FontRed, FontGreen, FontBlue);
                                }

                                k = GetPrivateProfileString("TEXT","STRING_CONTENT",DEFAULT_A_STRING,strbuf,sizeof(strbuf),IniFileName);

                                strncpy(SourceString,strbuf,(size_t)k);
                                Source_String_Length = k;

                                MultiByteToWideChar(CP_ACP|CP_OEMCP,0,SourceString,-1,SourceStringW,sizeof(SourceStringW));

                                for(j=0; j<2; j++)
                                    Text_Test_Order[j] = 0;

                                GetPrivateProfileString("RUN","ORDER","FONT_SIZE, STRING_LENGTH",txtbuf,sizeof(txtbuf),IniFileName);
                                if(strstr(txtbuf,"STRING_LENGTH") > strstr(txtbuf,"FONT_SIZE"))
                                {
                                    Text_Test_Order[0] = 1;
                                    Text_Test_Order[1] = 2;
                                }
                                else
                                {
                                    Text_Test_Order[0] = 2;
                                    Text_Test_Order[1] = 1;
                                }

                                k = GetPrivateProfileString("RUN","STRING_LENGTH","32",txtbuf,sizeof(txtbuf),IniFileName);
                                No_String_Lengths = Std_Parse(txtbuf, k, StringLength);

                                if(No_String_Lengths==0)
                                {
                                    MessageBox(hWnd,"Invalid or No String Length Entry in GDIBATCH.INI File", "INI File Error",MB_ICONSTOP|MB_OK);
                                    BatchFlag = FALSE;
                                    break;
                                }

                                k = GetPrivateProfileString("RUN","FONT_SIZE","10",txtbuf,sizeof(txtbuf),IniFileName);
                                No_Font_Sizes = Std_Parse(txtbuf, k, FontSize);

                                if(No_Font_Sizes==0)
                                {
                                    MessageBox(hWnd,"Invalid or No Font Size Entry in GDIBATCH.INI File", "INI File Error",MB_ICONSTOP|MB_OK);
                                    BatchFlag = FALSE;
                                    break;
                                }

                                fclose(fpIniFile);

    // Initialize the LOGFONT struct

                                lf.lfWidth          = 0;
                                lf.lfEscapement     = 0;
                                lf.lfOrientation    = 0;
                                lf.lfWeight         = (SelectedFontBold == FALSE)? 400 : 700;
                                lf.lfItalic         = SelectedFontItalic;
                                lf.lfUnderline      = SelectedFontUnderline;
                                lf.lfStrikeOut      = SelectedFontStrike;
                                lf.lfCharSet        = ANSI_CHARSET;
                                lf.lfOutPrecision   = OUT_DEFAULT_PRECIS;
                                lf.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
                                lf.lfQuality        = DEFAULT_QUALITY;
                                lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
                                lstrcpy(&lf.lfFaceName[0],&SelectedFont[0]);

    // Get some necessary font information for the present screen to be able to determine its height

                                hdc2 = GetDC(hWnd);
                                GetTextFace(hdc2, sizeof(SelectedFont), &SelectedFont[0]);
                                VPixelsPerLogInch = GetDeviceCaps(hdc2, LOGPIXELSY);
                                ReleaseDC(hWnd,hdc2);

    // Some more font initialization

                                cf.lStructSize      = sizeof (CHOOSEFONT);
                                cf.hwndOwner        = hWnd;
                                cf.lpLogFont        = &lf;
                                cf.Flags            = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT;
                                cf.nFontType        = SCREEN_FONTTYPE;
                                cf.rgbColors        = SelectedFontColor;

    // Auto Select an output file name

                                OutFileName = SelectOutFileName(hWnd);
                                fpOutFile = fopen(OutFileName, "w+");
                                if(NULL == OutFileName)
                                {
                                    MessageBox(hWnd,"Could not Open an Output File, Batch Mode Halted", "Output Open File Error",MB_ICONSTOP|MB_OK);
                                    BatchFlag = FALSE;
                                    break;
                                }

    // Execute Text Suite, Depending on the Predefined Order of Loops

                                if(Text_Test_Order[1] == 1)
                                {

                                    for(i = 0; i < No_String_Lengths; i++)
                                    {
                                        StrLen = StringLength[i];
                                        String_Length_Warn = (StrLen <= (size_t)Source_String_Length)? FALSE : TRUE;
                                        strcpy(&DestString[StrLen],"\0");
                                        pszTest =(PSZ) strncpy(&DestString[0], SourceString, StrLen);
                                        pwszTest = (PWSTR) wcsncpy(&DestStringW[0], SourceStringW, StrLen);

                                        for(j = 0; j < No_Font_Sizes; j++)
                                        {
                                            lf.lfHeight = -MulDiv(FontSize[j], VPixelsPerLogInch, POINTS_PER_INCH);
                                            cf.iPointSize = 10*FontSize[j];  // Point Size is in 1/10 of a point

                                            for(k=0; k < BatchCycle; k++)
                                            {
                                                SendMessage(hWnd,WM_COMMAND,IDM_QRUN2,0L);
                                                WriteBatchResults(fpOutFile, TestType, k+1);
                                            }

                                        }

                                    }

                                }               //endif

                                else
                                {

                                    for(i = 0; i < No_Font_Sizes; i++)
                                    {

                                        lf.lfHeight = -MulDiv(FontSize[i], VPixelsPerLogInch, POINTS_PER_INCH);
                                        cf.iPointSize = 10*FontSize[i];  // Point Size is in 1/10 of a point

                                        for(j = 0; j < No_String_Lengths; j++)
                                        {
                                            StrLen = StringLength[j];
                                            String_Length_Warn = (StrLen <= (size_t)Source_String_Length)? FALSE : TRUE;
                                            strcpy(&DestString[StrLen],"\0");
                                            pszTest =(PSZ) strncpy(&DestString[0], SourceString, StrLen);
                                            pwszTest = (PWSTR) wcsncpy(&DestStringW[0], SourceStringW, StrLen);

                                            for(k=0; k < BatchCycle; k++)
                                            {
                                                SendMessage(hWnd,WM_COMMAND,IDM_QRUN2,0L);
                                                WriteBatchResults(fpOutFile, TestType, k+1);
                                            }

                                        }

                                    }

                                }                //else

    // Cleanup
                                fclose(fpOutFile);

                                if(Finish_Message == TRUE)
                                {
                                    strcpy(txtbuf,"Batch Job Finished Successfully, Results Written to ");
                                    strcat(txtbuf,OutFileName);
                                    MessageBox(hWnd,txtbuf, "Batch Job Finished",MB_ICONINFORMATION|MB_OK);
                                }

                                if(Dont_Close_App == TRUE)// App Stays Open, Check Appropriate Menu Items for Last Selection
                                {
                                    HMENU hmenu = GetSubMenu(GetSubMenu(GetMenu(hWnd),2),0);
                                    if(SelectedFontTransparent == TRUE)
                                    {
                                        CheckMenuItem(hmenu,2,MF_BYPOSITION|MF_CHECKED);
                                    }

                                    if(StrLen == 1)i=0;
                                    else if(StrLen ==     2)i=1;
                                    else if(StrLen ==     4)i=2;
                                    else if(StrLen ==     8)i=3;
                                    else if(StrLen ==    16)i=4;
                                    else if(StrLen ==    32)i=5;
                                    else if(StrLen ==    64)i=6;
                                    else if(StrLen ==   128)i=7;
                                    else
                                    {
                                        i = 8;                         // "Other" non-standard menu selection
                                    }
                                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, i);

                                    BatchFlag = FALSE;
                                    for(i=0; i<(int)NUM_TESTS; i++)
                                    {
                                        gTestEntry[i].Result = 0;
                                    }

                                }
                                else
                                {
                                    SendMessage(hWnd,WM_COMMAND,IDM_EXIT,0L);
                                }

                            }             //case TEXT_SUITE

                            break;

                            case SELECT:        // Read some more keys then run the selected test suite
                            {

                                k = GetPrivateProfileString("BATCH","TEST","0",txtbuf,sizeof(txtbuf),IniFileName);
                                fclose(fpIniFile);

                                Num_Selected_Tests = Std_Parse(txtbuf, k, Test_Item);

                                if(Num_Selected_Tests == 0)
                                {
                                    MessageBox(hWnd,"Invalid Test-Number Entry in USRBATCH.INI File ", "INI File Error",MB_ICONSTOP|MB_OK);
                                    BatchFlag = FALSE;
                                    break;
                                }

                                for(i=0; i<Num_Selected_Tests; i++)
                                {
                                    if(Test_Item[i] > (int)NUM_TESTS)
                                    {
                                        MessageBox(hWnd,"Invalid Test-Number Entry in USRBATCH.INI File ", "INI File Error",MB_ICONSTOP|MB_OK);
                                        BatchFlag = FALSE;
                                        break;
                                    }
                                }

                                OutFileName = SelectOutFileName(hWnd);
                                if(NULL == OutFileName)
                                {
                                    BatchFlag = FALSE;
                                    break;
                                }
                                fpOutFile = fopen(OutFileName, "w+");

                                for(j=0; j < BatchCycle; j++)
                                {
                                    for(i=0; i < Num_Selected_Tests; i++)
                                    {
                                        SendMessage(hWnd,WM_COMMAND,ID_TEST_START+Test_Item[i],0L);
                                    }

                                    WriteBatchResults(fpOutFile, TestType, i+1);
                                }

                                fclose(fpOutFile);

                                if(Finish_Message == TRUE)
                                {
                                    strcpy(txtbuf,"Batch Job Finished Successfully, Results Written to ");
                                    strcat(txtbuf,OutFileName);
                                    MessageBox(hWnd,txtbuf, "Batch Job Finished",MB_ICONINFORMATION|MB_OK);
                                }

                                if(Dont_Close_App == TRUE)
                                {
                                    BatchFlag = FALSE;
                                    for(i=0; i<(int)NUM_TESTS; i++)
                                    {
                                        gTestEntry[i].Result = 0;
                                    }
                                }
                                else
                                {
                                    SendMessage(hWnd,WM_COMMAND,IDM_EXIT,0L);
                                }

                            }
                            break;

                        }       // switch TestType

                    }           //else (RUN_BATCH - OK to Proceed)

                }               // case RUN_BATCH
                break;

            //
            // run a single selected test (interactive mode)
            //

            default:

                {
                    ULONG Test = LOWORD(wParam) - ID_TEST_START;
                    ULONG Index;
                    PFN_MS pfn;
                    RECT CliRect = {0,0,10000,10000};
                    HDC hdc = GetDC(hWnd);
                    FillRect(hdc,&CliRect,GetStockObject(GRAY_BRUSH));

                    if(NULL==GetWindow(ghwndMDIClient,GW_CHILD))                     //If Test Object doesn't exist
                    SendMessage(ghwndMDIClient, WM_MDICREATE, 0, (LPARAM)&mcs); //Create Test Object

                    if (Test < NUM_TESTS)
                    {
                        HDC hdc2 = GetDC(hWnd);

                        wsprintf(tmsg,"Testing %s",gTestEntry[Test].Api);
                        TextOut(hdc,20,20,tmsg,strlen(tmsg));

                        pfn = gTestEntry[Test].pfn;
                        ShowCursor(FALSE);

                        hfont = CreateFontIndirect(cf.lpLogFont);
                        hfontOld = SelectObject(hdc2, hfont);
                        crOld = SetTextColor(hdc2, cf.rgbColors);
                        if(SelectedFontTransparent)SetBkMode(hdc2,TRANSPARENT);

////// Statistics
                        Index = Test;
                        for(j = 0; j < NUM_SAMPLES; j++)
                        {

                            GdiFlush();

                            Sample[j] = (double)(*pfn)(hdc2,gTestEntry[Index].Iter);
                            Detailed_Data[Index][j] = (long)(0.5 + Sample[j]);
                            if (Sample[j] == 0) {
                                // error occurred
                                break;
                            }

                        }

                        Get_Stats(Sample,NUM_SAMPLES,HI_FILTER,VAR_LIMIT,&TestStats[Index]);
///////

                        ShowCursor(TRUE);

                        SetTextColor(hdc2, crOld);
                        SelectObject(hdc2, hfontOld);
                        DeleteObject(hfont);
                        SetBkMode(hdc2, OPAQUE);

                        ReleaseDC(hWnd,hdc2);
                        // HIRO
                        wsprintf(tmsg,"Finished %s",gTestEntry[Test].Api);
                        TextOut(hdc,20,20,tmsg,strlen(tmsg));
                    }

                    ReleaseDC(hWnd,hdc);
                }

            }       // SWITCH CASE


            if(BatchFlag == FALSE)               // Initialize Test Strings (interactive mode)
            {
                pszTest =(PSZ) strncpy(DestString, SourceString, StrLen);
                DestString[StrLen] = '\0';
                pwszTest = (PWSTR) wcsncpy(DestStringW, SourceStringW, StrLen);
                DestStringW[StrLen] = L'\0';
            }

        }       // WM_COMMAND
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hDC = BeginPaint(hWnd,&ps);
            EndPaint(hWnd,&ps);
        }
        break;

    case WM_DESTROY:
            PostQuitMessage(0);
            break;

    default:

        //
        // Passes message on if unproccessed
        //
        /*
         * Use DefFrameProc() instead of DefWindowProc() since there are
         * things that have to be handled differently because of MDI.
         */
        return DefFrameProc(hWnd, ghwndMDIClient, msg, wParam, lParam);

    }

/* Calculate Timer Frequency For Current Machine and Convert to MicroSeconds (Actual time will be presented in units of 100ns) */

    Status = QueryPerformanceFrequency((LARGE_INTEGER *)&PerformanceFreq);
    if(Status){
           PerformanceFreq /= 10000;//PerformanceFreq is in Counts/Sec.
                                    //Dividing it by 1,000,000 gives Counts/nanosecond
    }                               //Dividing it by 10,000 gives Counts/(100 nanosecond unit)
    else
    {
            MessageBox(NULL,
               "High Resolution Performance Counter Doesn't Seem to be Supported on This Machine",
               "Warning", MB_OK | MB_ICONEXCLAMATION);

            PerformanceFreq = 1;                /* To Prevent Possible Div by zero later */
    }


    return ((LRESULT)NULL);
}


/*++

Routine Description:

    Save results to file

Arguments

    none

Return Value

    none

--*/

VOID
SaveResults()
{
    static OPENFILENAME ofn;
    static char szFilename[80];
    char szT[80];
    int i, hfile;
    FILE *fpOut;

    BatchFlag = FALSE;

    for (i = 0; i < sizeof(ofn); i++)
    {
        //
        // clear out the OPENFILENAME struct
        //

        ((char *)&ofn)[i] = 0;
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = ghwndFrame;
    ofn.hInstance = hInstMain;

    ofn.lpstrFilter = "USRBench (*.cs;*.km)\0*.cs;*.km\0All Files\0*.*\0\0";
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = "C:\\";
    ofn.Flags = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    lstrcpy(szFilename, "USRB001.km");

    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = sizeof(szFilename);
    ofn.lpstrTitle = "Save As";

    if (!GetSaveFileName(&ofn))
    {
        return;
    }

    fpOut = fopen(szFilename, "w+");
    if(NULL != fpOut)
    {
        WriteBatchResults(fpOut,0,0);
        fclose(fpOut);
    }
    else
    {
        MessageBox(ghwndFrame,"Cannot Open File to Save Results", "Output File Creation Error",MB_ICONSTOP|MB_OK);
    }

}




/*++

Routine Description:

    Show results  (Interactive Mode Dialog)

Arguments

    Std dlg

Return Value

    Status

--*/

INT_PTR
APIENTRY
ResultsDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    ULONG ix;
    char szT[180];
    BOOL fResults;
    int aiT[2];

    switch (msg) {
    case WM_INITDIALOG:
        aiT[0] = 100;
        aiT[1] = 190;
        fResults = FALSE;

        {
            LV_COLUMN lvc;
            LV_ITEM lvl;
            UINT width;
            RECT rc;
            HWND hwndList = GetDlgItem(hwnd, IDC_RESULTSLIST);
            int i;
            static LPCSTR title[] = {
                "Function", "Time(100ns)", "StdDev%", "Best", "Worst",
                "Valid Samples", "Out of", "Iterations",
            };
#ifdef _X86_
            if (gfPentium)
                title[1] = "Cycle Counts";
#endif
            if (hwndList == NULL)
                break;
            GetClientRect(hwndList, &rc);
            // only first column has doubled width
            lvc.cx = (width = (rc.right - rc.left) / (sizeof title / sizeof *title + 1)) * 2;
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt = LVCFMT_LEFT;
            for (i = 0; i < sizeof title / sizeof *title; ++i) {
                lvc.pszText = (LPSTR)title[i];
                ListView_InsertColumn(hwndList, i, &lvc);
                lvc.cx = width;     // normal width
            }

            lvl.iItem = 0;
            lvl.mask = LVIF_TEXT;
            for (ix = 0; ix < NUM_TESTS; ix++) {
                if ((long)(0.5 + TestStats[ix].Average) == 0) {
                    // no measuement, skip
                    continue;
                }
                lvl.iSubItem = 0;
                lvl.pszText = gTestEntry[ix].Api;
                ListView_InsertItem(hwndList, &lvl);
#define SUBITEM(fmt, v) \
                sprintf(szT, fmt, v); \
                ListView_SetItemText(hwndList, lvl.iItem, ++lvl.iSubItem, szT);

                SUBITEM("%ld", (long)(0.5 + TestStats[ix].Average));
                SUBITEM("%.2f", (float)TestStats[ix].StdDev);
                SUBITEM("%ld", (long)(0.5 + TestStats[ix].Minimum_Result));
                SUBITEM("%ld", (long)(0.5 + TestStats[ix].Maximum_Result));
                SUBITEM("%ld", TestStats[ix].NumSamplesValid);
                SUBITEM("%ld", (long)NUM_SAMPLES);
                SUBITEM("%ld", gTestEntry[ix].Iter);
#undef SUBITEM
                ++lvl.iItem;
                fResults = TRUE;
            }

            if (!fResults)
                MessageBox(hwnd, "No results have been generated yet or Test may have failed!",
                    "UsrBench", MB_OK | MB_ICONEXCLAMATION);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;

        case IDM_SAVERESULTS:
            SaveResults();
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR
APIENTRY
HelpDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    ULONG ix, last_ix;
    static const char* szT[] = {
        "Usage:",
        "usrbench (interactive mode), or ",
        "usrbench /b (batch mode)",
        "         /d (Print detailed distribution if more than 5 percent of samples filtered out)",
        "         /m (Message when batch finished)",
        "         /s (Stay, don't close application when batch finished)",
        "         /t (Batch and Interactive Modes; Measure test time - not Cycle Counts, on Pentium Machines)",
        "         /i [INI filename] (optional, def.= USRBATCH.INI )",
        "",
        "Batch Mode requires preparing an INI file (default: USRBATCH.INI) in the same directory where the application is being run.",
        "You may also specify an INI filename using /i [INI filename] in the command line (must reside in the directory mentioned above).",
        "",
        "INI file Sections and Keys: (Use  ' , '  or  ' ; '  as separators where necessary)",
        "[BATCH]",
        "RUN= ALL / QUICK / TEXT / SELECT (Test type, select one, def.= TEXT",
        "CYCLE= (No. of batch cycles, def.= 1)",
        "TEST= test numbers (Selected tests to run, needed only for test type= SELECT)",
        "[TEXT]",
        "FONT = name, +optional parameters   (Font name + any combination of:",
        " BOLD, ITALIC, UNDERLINE, STRIKE, TRANSPARENT, RGB(r,g,b), def.= Arial)",
        "STRING_CONTENT= string (Text string to be used, up to 128 characters)",
        "[RUN]",
        "FONT_SIZE= font sizes (Font sizes to be tested, def. 12)",
        "STRING_LENGTH= string lengths (String Length to be tested, taken as sub-strings of the one specified, def. 32)",
        "ORDER= test loop order (Order of test loops (first is outer); example: FONT_SIZE STRING_LENGTH )",
        "",
        "Batch Output:",
        "Output files will be generated automatically in the run directory, with the name [USBxxx.log], where xxx is a number.",
        "Note that the program will refuse to run if more than 200 output files are accumulated...",
    };

    int aiT[2];

    switch (msg) {
    case WM_INITDIALOG:
        aiT[0] = 100;
        aiT[1] = 190;
        SendDlgItemMessage(hwnd, IDC_HELPLIST, LB_SETTABSTOPS, 2,
                (LPARAM)aiT);

        for (ix = 0; ix < sizeof szT / sizeof szT[0]; ix++) {
            SendDlgItemMessage(hwnd, IDC_HELPLIST, LB_ADDSTRING, 0,
                        (LPARAM)szT[ix]);
        }


        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            EndDialog(hwnd, 0);
            break;
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

/*++

Routine Description:

    SelectOutFileName  - Select the next output file name (batch mode)

Arguments

    HWND hWnd

Return Value

    char *OutFileName

--*/

char *
SelectOutFileName(HWND hWnd)

{

    static char buf[11];
    char buf2[4];
    FILE *fpFile;
    int i;

    lstrcpy(buf,"usb");

    for (i=1; i<201; i++)   // Allow for up to 200 output files to exist in current directory
    {
      sprintf(&buf[3],"%03s.log",_itoa(i,buf2,10));

      fpFile = fopen(&buf[0],"r");  // Try to open for read, if succeeds the file already exists
                                    //                       if fails, thats the next file selected
      if(NULL != fpFile)
      {
        fclose(fpFile);
        continue;
      }
      return buf;
    }

    MessageBox(hWnd,"Cannot Continue, Limit of 200 usbxxx.log Output Files Exceeded, Please Clean Up! ", "Output File Creation Error",MB_ICONSTOP|MB_OK);
    return NULL;
}


/*++

Routine Description:

    WriteBatchResults - Save Batch results to file

Arguments

    FILE *fpOutFile
    int  TestType

Return Value

    none

--*/


void WriteBatchResults(FILE *fpOut, int TestType, int cycle)
{
    char szT[180];
    OSVERSIONINFO Win32VersionInformation;
    MEMORYSTATUS MemoryStatus;
    char ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    int SizBuf = MAX_COMPUTERNAME_LENGTH + 1;
    int i,j;
    ULONG ix;
    char *pszOSName;
    ULONG ixStart = 0;
    ULONG ixEnd  = NUM_TESTS;

    if(TEXT_SUITE == TestType){
        ixStart = FIRST_TEXT_FUNCTION;
        ixEnd  = LAST_TEXT_FUNCTION + 1;
    }


    /*
     * Write out the build information and current date.
     */
    Win32VersionInformation.dwOSVersionInfoSize = sizeof(Win32VersionInformation);
    if (GetVersionEx(&Win32VersionInformation))
    {
        switch (Win32VersionInformation.dwPlatformId)
        {
            case VER_PLATFORM_WIN32s:
                pszOSName = "WIN32S";
                break;
            case VER_PLATFORM_WIN32_WINDOWS:
                pszOSName = "Windows 95";
                break;
            case VER_PLATFORM_WIN32_NT:
                pszOSName = "Windows NT";
                break;
            default:
                pszOSName = "Windows ???";
                break;
        }

        GetComputerName(ComputerName, &SizBuf);
        wsprintf(szT, "\n\n///////////////   ");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT, "%s Version %d.%d Build %d ", pszOSName,
        Win32VersionInformation.dwMajorVersion,
        Win32VersionInformation.dwMinorVersion,
        Win32VersionInformation.dwBuildNumber);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        MemoryStatus.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus(&MemoryStatus);

        wsprintf(szT, "Physical Memory = %dKB   ////////////////\n", MemoryStatus.dwTotalPhys/1024);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT,"\nComputer Name = %s", ComputerName);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

    }

    wsprintf(szT, "\n\nMaximum Variation Coefficient (Standard Deviation/Average) Imposed on Test Data = %d %%", VAR_LIMIT);
    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
    wsprintf(szT, "\n\nBest and Worst Cycle or Time Counts per Call are Unprocessed Values", VAR_LIMIT);
    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);


    if(BatchFlag == TRUE)
    {
        wsprintf(szT, "\n\nBatch Cycle No. %d Out of %d Cycles", cycle, BatchCycle );
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
    }
    else
    {
        wsprintf(szT, "\n\nResults of interactive mode session;");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
    }

    if(TEXT_SUITE == TestType || TRUE == TextSuiteFlag){
        wsprintf(szT, "\n\nFor Text Function Suit:\n\nTest String Length = %d Characters", StrLen);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT, "\nString Used=   %s", DestString);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        if(String_Length_Warn == TRUE)
        {
            wsprintf(szT, "\n!!!WARNING: One or More String Lengths Specified in INI File \n           is Longer than Supplied or Default Source String");
            fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
        }

        wsprintf(szT, "\nFont name = %s, Font Size = %d", &lf.lfFaceName[0], cf.iPointSize/10);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT, "\nFont Weight = %ld (400 = Normal, 700 = Bold)",lf.lfWeight);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        (lf.lfItalic != FALSE)?wsprintf(szT,"\nItalic = TRUE"):wsprintf(szT,"\nItalic = FALSE");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        (lf.lfUnderline==TRUE)?wsprintf(szT,"\nUnderline = TRUE"):wsprintf(szT,"\nUnderline = FALSE");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        (lf.lfStrikeOut==TRUE)?wsprintf(szT,"\nStrikeOut = TRUE"):wsprintf(szT,"\nStrikeOut = FALSE");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        (SelectedFontTransparent==TRUE)?wsprintf(szT,"\nTransparent Background = TRUE"):wsprintf(szT,"\nOpaque Background = TRUE");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT, "\nColor Used: RED = %d, GREEN = %d, BLUE = %d", (unsigned char)cf.rgbColors, (unsigned char)(cf.rgbColors>>8), (unsigned char)(cf.rgbColors>>16) );
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
   }

    if(TEXT_SUITE == TestType || TRUE == TextSuiteFlag)
      {
#ifdef _X86_
                if(gfPentium)
                    lstrcpy(szT, "\n\n  Function\t\t Cycle Counts \tStdDev%\tBest \t Worst \t Valid Samples \t Out of\tIterations  StrLen \t Font Size   Font Name\n\n");
                else
#endif
                    lstrcpy(szT, "\n\n  Function\t\tTime (100 ns) \tStdDev%\tBest \t Worst \t Valid Samples \t Out of\tIterations  StrLen \t Font Size   Font Name\n\n");
      }
    else
      {
#ifdef _X86_
                if(gfPentium)
                    lstrcpy(szT, "\n\n  Function\t\t Cycle Counts \tStdDev% \t Best \t Worst \t Valid Samples \t Out of \t Iterations\n\n");
                else
#endif
                    lstrcpy(szT, "\n\n  Function\t\tTime (100 ns) \tStdDev% \t Best \t Worst \t Valid Samples \t Out of \t Iterations\n\n");

      }

    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

    for (ix = ixStart; ix < ixEnd; ix++) {

        if(TEXT_SUITE == TestType || TRUE == TextSuiteFlag)
        {
            sprintf(szT,
                   "%-30s\t,%6ld\t,%6.2f\t,%6ld\t,%6ld\t,%6ld\t\t,%6ld\t,%6ld\t,%6ld\t,%6ld\t,%s\n",
                   (LPSTR)gTestEntry[ix].Api,
                                (long)(0.5 + TestStats[ix].Average),
                                (float)TestStats[ix].StdDev,
                                (long)(0.5 + TestStats[ix].Minimum_Result),
                                (long)(0.5 + TestStats[ix].Maximum_Result),
                                TestStats[ix].NumSamplesValid,
                                (long)NUM_SAMPLES,
                                gTestEntry[ix].Iter,
                                StrLen,
                                cf.iPointSize / 10,
                                &lf.lfFaceName[0]);


        }
        else
        {
            sprintf(szT,
                   "%-50s\t,%10ld\t,%6.2f\t,%10ld\t,%10ld\t,%6ld\t\t,%6ld\t,%6ld\n",
                   (LPSTR)gTestEntry[ix].Api,
                                (long)(0.5 + TestStats[ix].Average),
                                (float)TestStats[ix].StdDev,
                                (long)(0.5 + TestStats[ix].Minimum_Result),
                                (long)(0.5 + TestStats[ix].Maximum_Result),
                                TestStats[ix].NumSamplesValid,
                                (long)NUM_SAMPLES,
                                gTestEntry[ix].Iter);
        }

        if((long)(0.5 + TestStats[ix].Average) != 0)
        {
            fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
            if((Print_Detailed == TRUE) && ((float)(NUM_SAMPLES - TestStats[ix].NumSamplesValid)/(float)NUM_SAMPLES > 0.05F))
            {
                sprintf(szT,"\nThe Last Test Had More Than 5 Percent of Its Samples Filtered Out;\n\n");
                fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

                sprintf(szT,"Here Is a Detailed Distribution of the Samples:\n\n");
                fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

                for(j = 0; j < NUM_SAMPLES; j++)
                {
                    if((j+1)%10)
                        sprintf(szT,"%d\t",Detailed_Data[ix][j]);
                    else
                        sprintf(szT,"%d\n",Detailed_Data[ix][j]);

                    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
                }
                sprintf(szT,"\n");
                fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

            }
        }
        else {
            fputs("\n", fpOut);
        }
    }

    if(TRUE == TextSuiteFlag)TextSuiteFlag = FALSE;
}

/*++

Routine Description:

    SyncMenuChecks - toggle checkmarks between String-Length menu items

Arguments

    HWND hwnd
    int Last_Checked - index of last menu item checked
    int New_Checked  - index of new menu item to check

Return Value

    int Last_Checked - new index of menu item just checked

--*/

int SyncMenuChecks(HWND hWnd, int Last_Checked, int New_Checked)
{
    HMENU hmenu = GetSubMenu(GetSubMenu(GetSubMenu(GetMenu(hWnd),2),0),0);
    CheckMenuItem(hmenu,Last_Checked,MF_BYPOSITION|MF_UNCHECKED);
    CheckMenuItem(hmenu,New_Checked,MF_BYPOSITION|MF_CHECKED);
    Last_Checked = New_Checked;
    return Last_Checked;
}

/*++

Routine Description:

    StdParse - Standard parser for comma, semi-colon or space delimited integer containing strings

Arguments

    char txtbuf - buffer containing the string to parse
    int limit -   max no. of characters to search in txtbuf
    int * array - returned array containing the integers found

Return Value

    int i - number of integers found in txtbuf

--*/

int Std_Parse(char *txtbuf, int limit, int *array)
{
    int i = 0;
    int n = 0;
    char tst[2];

    array[0] = 0;

    do
    {
        sscanf(&txtbuf[n],"%1c",tst);

        if((array[i] != 0)&&((tst[0] == ' ')||(tst[0] == ',')||(tst[0] == ';')))
        {
            ++i;
            array[i] = 0;
        }

        if(tst[0] == '\n')
        {
            ++i;
            break;
        }
        while((n<limit)&&((tst[0] == ' ')||(tst[0] == ',')||(tst[0] == ';')))
        {
            ++n;
            sscanf(&txtbuf[n],"%1c",tst);
        }
        if(n>=limit)
            break;

        array[i] = 10*array[i] + atoi(tst);
        ++n;

    }while(n<limit );

    if(array[i] != 0) ++i;
    return i;
}


/***************************************************************************\
* MDIChildWndProc
*
* History:
* 01-24-92 DarrinM      Created.
\***************************************************************************/

LRESULT APIENTRY MDIChildWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    HWND hwndEdit;

    switch (msg) {
    case WM_MDICREATE:

        /*
         * Create an edit control
         */
        hwndEdit = CreateWindow("edit", NULL,
                WS_CHILD | WS_HSCROLL | WS_MAXIMIZE | WS_VISIBLE |
                WS_VSCROLL | ES_AUTOHSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | WS_OVERLAPPEDWINDOW,
                0, 0, 0, 0, ghwndMDIClient, (HMENU)ID_EDIT, ghinst, NULL);

        /*
         * Remember the window handle and initialize some window attributes
         */
        SetWindowLongPtr(hwnd, GWLP_HWNDEDIT, (LONG_PTR)hwndEdit);
        SetFocus(hwndEdit);
        break;

    case WM_CLOSE:
        break;

    case WM_SIZE: {
        RECT rc;

        /*
         * On creation or resize, size the edit control.
         */

        hwndEdit = (HWND)GetWindowLongPtr(hwnd, GWLP_HWNDEDIT);
        GetClientRect(hwnd, &rc);
        MoveWindow(hwndEdit, rc.left, rc.top,
                rc.right - rc.left, rc.bottom - rc.top, TRUE);
        return DefMDIChildProc(hwnd, msg, wParam, lParam);
    }

    case WM_SETFOCUS:
        SetFocus((HWND)GetWindowLongPtr(hwnd, GWLP_HWNDEDIT));
        break;

    default:
        return DefMDIChildProc(hwnd, msg, wParam, lParam);
    }

    return FALSE;
}
/***************************************************************************\
* InitializeInstance  (danalm)
*
* History:
* 01-24-92 DarrinM      Created.
* 07-25-96 DanAlm       Modified.
\***************************************************************************/

BOOL APIENTRY InitializeInstance(
    HINSTANCE hInst,
    HINSTANCE hPrev,
    INT nCmdShow)
{

    WNDCLASS    wc;
    HWND        hWndDesk;
    RECT        hwRect;
    RECT        rc;

    CLIENTCREATESTRUCT ccs;

    hWndDesk = GetDesktopWindow();
    GetWindowRect(hWndDesk,&hwRect);

    if (!hPrev)
    {
        wc.hInstance      = hInst;
        wc.hCursor        = LoadCursor((HINSTANCE)NULL, IDC_ARROW);
        wc.hIcon          = LoadIcon(hInst, MAKEINTRESOURCE(IDR_USRBENCH_MENU));
        wc.lpszMenuName   = MAKEINTRESOURCE(IDR_USRBENCH_MENU);
        wc.lpszClassName  = szFrame;
        wc.hbrBackground  = (HBRUSH)GetStockObject(GRAY_BRUSH);
        wc.style          = (UINT)0;
        wc.lpfnWndProc    = WndProc;
        wc.cbWndExtra     = 0;
        wc.cbClsExtra     = 0;


        if (!RegisterClass(&wc)) {
            return FALSE;
        }
    /*
     * Register the MDI child class
     */
        wc.lpfnWndProc   = MDIChildWndProc;
        wc.hIcon         = LoadIcon(ghinst, IDNOTE);
        wc.lpszMenuName  = NULL;
        wc.cbWndExtra    = sizeof(HWND);
        wc.lpszClassName = szChild;

        if(!RegisterClass(&wc))return FALSE;


    }


    //
    // Create and show the main Frame window
    //

    ghwndFrame = CreateWindow (szFrame,
                            "USER Call Performance",
                            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                            0,
                            0,
                            hwRect.right,
                            hwRect.bottom,
                            (HWND)NULL,
                            (HMENU)NULL,
                            (HINSTANCE)hInst,
                            (LPSTR)NULL
                           );

    if (ghwndFrame == NULL) {
        return(FALSE);

    }

    //
    //  Show the window
    //

    ShowWindow(ghwndFrame,nCmdShow);
    UpdateWindow(ghwndFrame);
    SetFocus(ghwndFrame);

    //  Create a Desktop Window inside the Frame Window

    ccs.hWindowMenu = NULL;
    ccs.idFirstChild = 0;

    GetClientRect(ghwndFrame, (LPRECT)&rc);

    ghwndMDIClient = CreateWindow("mdiclient",
                                    "Desktop",
                                    WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE | WS_BORDER,
                                    rc.left,
                                    rc.top+100,
                                    rc.right-rc.left,
                                    rc.bottom-(rc.top+100),
                                    ghwndFrame,
                                    (HMENU)0xCAC,
                                    ghinst,
                                    (LPSTR)&ccs
                                  );

    if (ghwndMDIClient == NULL) {
        return(FALSE);
    }

    /*
     * Create MDI child window for potential use of Userbench tests.
     */

    mcs.szClass = "mdiclient";
    mcs.szTitle = "Test Object";
    mcs.hOwner  = ghinst;
    mcs.x = mcs.cx = CW_USEDEFAULT;
    mcs.y = mcs.cy = CW_USEDEFAULT;
    mcs.style = WS_OVERLAPPEDWINDOW;

    SendMessage(ghwndMDIClient, WM_MDICREATE, 0, (LPARAM)&mcs);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\rtl\client\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\rtl\kernel\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\rtl\heap.c ===
/*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*/

#include "precomp.h"

#if DBG
WIN32HEAP gWin32Heaps[MAX_HEAPS];
/*
 * These globals are used to fail gFail allocs and the succeed the next gSucceed
 * Set with Win32HeapStat
 */
DWORD   gFail, gSucceed;
DWORD   gToFail, gToSucceed;

/*
 * Support to keep records of pool free
 */
HEAPRECORD garrFreeHeapRecord[64];
CONST DWORD gdwFreeHeapRecords = ARRAY_SIZE(garrFreeHeapRecord);
DWORD gdwFreeHeapRecordCrtIndex;
DWORD gdwFreeHeapRecordTotalFrees;

#ifdef _USERK_

    FAST_MUTEX* gpHeapFastMutex;

    #define EnterHeapCrit()                             \
        KeEnterCriticalRegion();                        \
        ExAcquireFastMutexUnsafe(pheap->pFastMutex);

    #define LeaveHeapCrit()                             \
        ExReleaseFastMutexUnsafe(pheap->pFastMutex);    \
        KeLeaveCriticalRegion();

    #define EnterGlobalHeapCrit()                       \
        KeEnterCriticalRegion();                        \
        ExAcquireFastMutexUnsafe(gpHeapFastMutex);

    #define LeaveGlobalHeapCrit()                       \
        ExReleaseFastMutexUnsafe(gpHeapFastMutex);      \
        KeLeaveCriticalRegion();
#else

    RTL_CRITICAL_SECTION gheapCritSec;

    #define EnterHeapCrit()         RtlEnterCriticalSection(&pheap->critSec)
    #define LeaveHeapCrit()         RtlLeaveCriticalSection(&pheap->critSec)

    #define EnterGlobalHeapCrit()   RtlEnterCriticalSection(&gheapCritSec)
    #define LeaveGlobalHeapCrit()   RtlLeaveCriticalSection(&gheapCritSec)
#endif


/***************************************************************************\
* InitWin32HeapStubs
*
* Initialize heap stub management
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
BOOL InitWin32HeapStubs(
    VOID)
{
#ifdef _USERK_
    gpHeapFastMutex = ExAllocatePoolWithTag(NonPagedPool,
                                            sizeof(FAST_MUTEX),
                                            'yssU');
    if (gpHeapFastMutex == NULL) {
        RIPMSG0(RIP_WARNING, "Fail to create fast mutex for heap allocations");
        return FALSE;
    }
    ExInitializeFastMutex(gpHeapFastMutex);

#else
    if (!NT_SUCCESS(RtlInitializeCriticalSection(&gheapCritSec))) {
        RIPMSG0(RIP_WARNING, "Fail to initialize critical section for heap allocations");
        return FALSE;
    }
#endif

    return TRUE;
}

/***************************************************************************\
* CleanupWin32HeapStubs
*
* Cleanup heap stub management
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
VOID CleanupWin32HeapStubs(
    VOID)
{
#ifdef _USERK_
    if (gpHeapFastMutex != NULL) {
        ExFreePool(gpHeapFastMutex);
        gpHeapFastMutex = NULL;
    }
#else
    RtlDeleteCriticalSection(&gheapCritSec);
#endif
}

/***************************************************************************\
* Win32HeapGetHandle
*
* stub routine for Heap management
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
PVOID Win32HeapGetHandle(
    PWIN32HEAP pheap)
{
    UserAssert(pheap != NULL && (pheap->dwFlags & WIN32_HEAP_INUSE));

    return pheap->heap;
}

/***************************************************************************\
* Win32HeapCreateTag
*
* stub routine for Heap management
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
ULONG Win32HeapCreateTag(
    PWIN32HEAP pheap,
    ULONG      Flags,
    PWSTR      TagPrefix,
    PWSTR      TagNames)
{
#ifndef _USERK_
    UserAssert(pheap->dwFlags & WIN32_HEAP_INUSE);

    pheap->dwFlags |= WIN32_HEAP_USE_HM_TAGS;

    return RtlCreateTagHeap(pheap->heap, Flags, TagPrefix, TagNames);
#endif // _USERK_

    return 0;
    UNREFERENCED_PARAMETER(Flags);
    UNREFERENCED_PARAMETER(TagPrefix);
    UNREFERENCED_PARAMETER(TagNames);
}
/***************************************************************************\
* Win32HeapCreate
*
* stub routine for Heap management
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
PWIN32HEAP Win32HeapCreate(
    char*                pszHead,
    char*                pszTail,
    ULONG                Flags,
    PVOID                HeapBase,
    SIZE_T               ReserveSize,
    SIZE_T               CommitSize,
    PVOID                Lock,
    PRTL_HEAP_PARAMETERS Parameters)
{
    int        ind;
    PWIN32HEAP pheap = NULL;

    UserAssert(strlen(pszHead) == HEAP_CHECK_SIZE - sizeof(char));
    UserAssert(strlen(pszTail) == HEAP_CHECK_SIZE - sizeof(char));

    EnterGlobalHeapCrit();

    /*
     * Walk the global array of heaps to get an empty spot
     */
    for (ind = 0; ind < MAX_HEAPS; ind++) {
        if (gWin32Heaps[ind].dwFlags & WIN32_HEAP_INUSE)
            continue;

        /*
         * Found an empty spot
         */
        break;
    }

    if (ind >= MAX_HEAPS) {
        RIPMSG1(RIP_ERROR, "Too many heaps created %d", ind);
        goto Exit;
    }

    pheap = &gWin32Heaps[ind];

#ifdef _USERK_
    /*
     * Initialize the fast mutex that will protect the memory
     * allocations for this heap
     */
    pheap->pFastMutex = ExAllocatePoolWithTag(NonPagedPool,
                                              sizeof(FAST_MUTEX),
                                              'yssU');
    if (pheap->pFastMutex == NULL) {
        RIPMSG0(RIP_WARNING, "Fail to create fast mutex for heap allocations");
        pheap = NULL;
        goto Exit;
    }
    ExInitializeFastMutex(pheap->pFastMutex);
#else
    /*
     * Initialize the critical section that will protect the memory
     * allocations for this heap
     */
    if (!NT_SUCCESS(RtlInitializeCriticalSection(&pheap->critSec))) {
        RIPMSG0(RIP_WARNING, "Fail to initialize critical section for heap allocations");
        pheap = NULL;
        goto Exit;
    }
#endif

    /*
     * Create the heap
     */
    pheap->heap = RtlCreateHeap(Flags,
                                HeapBase,
                                ReserveSize,
                                CommitSize,
                                Lock,
                                Parameters);

    if (pheap->heap == NULL) {
        RIPMSG0(RIP_WARNING, "Fail to create heap");
#ifdef _USERK_
        ExFreePool(pheap->pFastMutex);
        pheap->pFastMutex = NULL;
#else
        RtlDeleteCriticalSection(&pheap->critSec);
#endif
        pheap = NULL;
        goto Exit;
    }

    pheap->dwFlags = (WIN32_HEAP_INUSE | WIN32_HEAP_USE_GUARDS);
    pheap->heapReserveSize = ReserveSize;

    RtlCopyMemory(pheap->szHead, pszHead, HEAP_CHECK_SIZE);
    RtlCopyMemory(pheap->szTail, pszTail, HEAP_CHECK_SIZE);

Exit:
    LeaveGlobalHeapCrit();
    return pheap;
}

/***************************************************************************\
* Win32HeapDestroy
*
* stub routine for Heap management
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
BOOL Win32HeapDestroy(
    PWIN32HEAP pheap)
{
    UserAssert(pheap != NULL && (pheap->dwFlags & WIN32_HEAP_INUSE));

    EnterGlobalHeapCrit();

    /*
     * Mark the spot available
     */
    pheap->dwFlags = 0;

    RtlDestroyHeap(pheap->heap);

#ifdef _USERK_
    ExFreePool(pheap->pFastMutex);
    pheap->pFastMutex = NULL;
#else
    RtlDeleteCriticalSection(&pheap->critSec);
#endif

    RtlZeroMemory(pheap, sizeof(WIN32HEAP));

    LeaveGlobalHeapCrit();

    return TRUE;
}

/***************************************************************************\
* Win32HeapSize
*
* stub routine for Heap management
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
SIZE_T Win32HeapSize(
    PWIN32HEAP pheap,
    PVOID      p)
{
    PDbgHeapHead ph;

    if (!Win32HeapCheckAlloc(pheap, p)) {
        return 0;
    }

    ph = (PDbgHeapHead)p - 1;

    return ph->size;
}
/***************************************************************************\
* Win32HeapAlloc
*
* stub routine for Heap management
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
PVOID Win32HeapAlloc(
    PWIN32HEAP pheap,
    SIZE_T     uSize,
    ULONG      tag,
    ULONG      Flags)
{
    PVOID         p = NULL;
    PDbgHeapHead  ph;
    SIZE_T        uRealSize = uSize;

#ifdef HEAP_ALLOC_TRACE
    ULONG         hash;
#endif

    EnterHeapCrit();

    UserAssert(pheap != NULL && (pheap->dwFlags & WIN32_HEAP_INUSE));

    /*
     * Fail if this heap has WIN32_HEAP_FAIL_ALLOC set.
     */
    if (pheap->dwFlags & WIN32_HEAP_FAIL_ALLOC) {
        RIPMSG3(RIP_WARNING, "Heap allocation failed because of global restriction.  heap %#p, size 0x%x tag %d",
                pheap, uSize, tag);
        goto Exit;
    }

    /*
     * Fail if gToFail is set.
     */
    if (gToFail) {
        if (--gToFail == 0) {
            gToSucceed = gSucceed;
        }
        RIPMSG3(RIP_WARNING, "Heap allocation failed on temporary restriction. heap %#p, size 0x%x tag %d",
                pheap, uSize, tag);
        goto Exit;
    }
    if (gToSucceed) {
        if (--gToSucceed) {
            gToFail = gFail;
        }
    }

    /*
     * Calculate the size that we actually are going to allocate.
     */
    uSize += sizeof(DbgHeapHead);

    if (pheap->dwFlags & WIN32_HEAP_USE_GUARDS) {
        uSize += sizeof(pheap->szHead) + sizeof(pheap->szTail);
    }

    p = RtlAllocateHeap(pheap->heap,
                        Flags,
                        uSize);

    if (p == NULL) {
        RIPMSG3(RIP_WARNING, "Heap allocation failed. heap %#p, size 0x%x tag %d",
                pheap, uSize, tag);
        goto Exit;
    }

    /*
     * Copy the secure strings in the head and tail of the allocation.
     */
    if (pheap->dwFlags & WIN32_HEAP_USE_GUARDS) {
        RtlCopyMemory((PBYTE)p,
                      pheap->szHead,
                      sizeof(pheap->szHead));

        RtlCopyMemory((PBYTE)p + uSize - sizeof(pheap->szTail),
                      pheap->szTail,
                      sizeof(pheap->szTail));

        ph = (PDbgHeapHead)((PBYTE)p + sizeof(pheap->szHead));
    } else {
        ph = (PDbgHeapHead)p;
    }

    /*
     * Zero out the header
     */
    RtlZeroMemory(ph, sizeof(DbgHeapHead));

    ph->mark  = HEAP_ALLOC_MARK;
    ph->pheap = pheap;
    ph->size  = uRealSize;
    ph->tag   = tag;

#ifdef HEAP_ALLOC_TRACE
    RtlZeroMemory(ph->trace, HEAP_ALLOC_TRACE_SIZE * sizeof(PVOID));

    RtlCaptureStackBackTrace(
                       1,
                       HEAP_ALLOC_TRACE_SIZE,
                       ph->trace,
                       &hash);
#endif // HEAP_ALLOC_TRACE

    /*
     * Now link it into the list for this tag (if any).
     */
    ph->pPrev = NULL;
    ph->pNext = pheap->pFirstAlloc;

    (pheap->crtAllocations)++;
    pheap->crtMemory += uRealSize;

    if (pheap->maxAllocations < pheap->crtAllocations) {
        pheap->maxAllocations = pheap->crtAllocations;
    }

    if (pheap->maxMemory < pheap->crtMemory) {
        pheap->maxMemory = pheap->crtMemory;
    }

    if (pheap->pFirstAlloc != NULL) {
        pheap->pFirstAlloc->pPrev = ph;
    }

    pheap->pFirstAlloc = ph;

    p = (PVOID)(ph + 1);

Exit:
    LeaveHeapCrit();
    return p;
}

/***************************************************************************\
* RecordFreeHeap
*
* Records free heap
*
* 3-24-99 CLupu      Created.
\***************************************************************************/
VOID RecordFreeHeap(
    PWIN32HEAP pheap,
    PVOID      p,
    SIZE_T     size)
{
    garrFreeHeapRecord[gdwFreeHeapRecordCrtIndex].p = p;
    garrFreeHeapRecord[gdwFreeHeapRecordCrtIndex].size = size;
    garrFreeHeapRecord[gdwFreeHeapRecordCrtIndex].pheap = pheap;

    gdwFreeHeapRecordTotalFrees++;

    RtlZeroMemory(garrFreeHeapRecord[gdwFreeHeapRecordCrtIndex].trace,
                  RECORD_HEAP_STACK_TRACE_SIZE * sizeof(PVOID));

    RtlWalkFrameChain(garrFreeHeapRecord[gdwFreeHeapRecordCrtIndex].trace,
                      RECORD_HEAP_STACK_TRACE_SIZE,
                      0);

    gdwFreeHeapRecordCrtIndex++;

    if (gdwFreeHeapRecordCrtIndex >= gdwFreeHeapRecords) {
        gdwFreeHeapRecordCrtIndex = 0;
    }
}

/***************************************************************************\
* Win32HeapReAlloc
*
* stub routine for Heap management
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
PVOID Win32HeapReAlloc(
    PWIN32HEAP pheap,
    PVOID      p,
    SIZE_T     uSize,
    ULONG      Flags)
{
    PVOID        pdest;
    PDbgHeapHead ph;

    if (!Win32HeapCheckAlloc(pheap, p)) {
        return NULL;
    }

    ph = (PDbgHeapHead)p - 1;

    pdest = Win32HeapAlloc(pheap, uSize, ph->tag, Flags);
    if (pdest != NULL) {

        /*
         * If the block is shrinking, don't copy too many bytes.
         */
        if (ph->size < uSize) {
            uSize = ph->size;
        }

        RtlCopyMemory(pdest, p, uSize);

        Win32HeapFree(pheap, p);
    }

    return pdest;
}

/***************************************************************************\
* Win32HeapFree
*
* stub routine for Heap management
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
BOOL Win32HeapFree(
    PWIN32HEAP pheap,
    PVOID      p)
{
    PDbgHeapHead  ph;
    SIZE_T        uSize;
    BOOL          bRet;

    EnterHeapCrit();

    UserAssert(pheap != NULL && (pheap->dwFlags & WIN32_HEAP_INUSE));

    ph = (PDbgHeapHead)p - 1;

    /*
     * Validate always on free
     */
    Win32HeapCheckAlloc(pheap, p);

    UserAssert((pheap->crtAllocations > 1  && pheap->crtMemory > ph->size) ||
               (pheap->crtAllocations == 1 && pheap->crtMemory == ph->size));

    (pheap->crtAllocations)--;
    pheap->crtMemory -= ph->size;

    /*
     * now, remove it from the linked list
     */
    if (ph->pPrev == NULL) {
        if (ph->pNext == NULL) {

            pheap->pFirstAlloc = NULL;
        } else {
            ph->pNext->pPrev = NULL;
            pheap->pFirstAlloc = ph->pNext;
        }
    } else {
        ph->pPrev->pNext = ph->pNext;
        if (ph->pNext != NULL) {
            ph->pNext->pPrev = ph->pPrev;
        }
    }

    uSize = ph->size + sizeof(DbgHeapHead);

    if (pheap->dwFlags & WIN32_HEAP_USE_GUARDS) {
        p = (PVOID)((BYTE*)ph - sizeof(pheap->szHead));
        uSize += sizeof(pheap->szHead) + sizeof(pheap->szTail);
    } else {
        p = (PVOID)ph;
    }

    RecordFreeHeap(pheap, p, ph->size);

    /*
     * Fill the allocation with a pattern that we can recognize
     * after the free takes place.
     */
    RtlFillMemoryUlong(p, uSize, (0xCACA0000 | ph->tag));

    /*
     * Free the allocation
     */
    bRet = RtlFreeHeap(pheap->heap, 0, p);

    LeaveHeapCrit();

    return bRet;
}

/***************************************************************************\
* Win32HeapCheckAlloc
*
* validates heap allocations in a heap
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
BOOL Win32HeapCheckAllocHeader(
    PWIN32HEAP    pheap,
    PDbgHeapHead  ph)
{
    PBYTE pb;

    if (ph == NULL) {
        RIPMSG0(RIP_ERROR, "NULL pointer passed to Win32HeapCheckAllocHeader");
        return FALSE;
    }

    UserAssert(pheap != NULL && (pheap->dwFlags & WIN32_HEAP_INUSE));

    /*
     * Make sure it's one of our heap allocations
     */
    if (ph->mark != HEAP_ALLOC_MARK) {
        RIPMSG2(RIP_ERROR, "%#p invalid heap allocation for pheap %#p",
                ph, pheap);
        return FALSE;
    }

    /*
     * Make sure it belongs to this heap
     */
    if (ph->pheap != pheap) {
        RIPMSG3(RIP_ERROR, "%#p heap allocation for heap %#p belongs to a different heap %#p",
                ph,
                pheap,
                ph->pheap);
        return FALSE;
    }

    if (pheap->dwFlags & WIN32_HEAP_USE_GUARDS) {
        pb = (BYTE*)ph - sizeof(pheap->szHead);

        if (!RtlEqualMemory(pb, pheap->szHead, sizeof(pheap->szHead))) {
            RIPMSG2(RIP_ERROR, "head corrupted for heap %#p allocation %#p", pheap, ph);
            return FALSE;
        }

        pb = (BYTE*)ph + ph->size + sizeof(*ph);

        if (!RtlEqualMemory(pb, pheap->szTail, sizeof(pheap->szTail))) {
            RIPMSG2(RIP_ERROR, "tail corrupted for heap %#p allocation %#p",
                    pheap,
                    ph);
            return FALSE;
        }
    }
    return TRUE;
}

/***************************************************************************\
* Win32HeapCheckAlloc
*
* validates heap allocations in a heap
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
BOOL Win32HeapCheckAlloc(
    PWIN32HEAP    pheap,
    PVOID         p)
{
    PDbgHeapHead ph;

    UserAssert(pheap != NULL && (pheap->dwFlags & WIN32_HEAP_INUSE));

    if (p == NULL) {
        RIPMSG0(RIP_ERROR, "NULL pointer passed to Win32HeapCheckAlloc");
        return FALSE;
    }

    ph = (PDbgHeapHead)p - 1;

    return Win32HeapCheckAllocHeader(pheap, ph);
}

/***************************************************************************\
* Win32HeapValidate
*
* validates all the heap allocations in a heap
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
BOOL Win32HeapValidate(
    PWIN32HEAP pheap)
{
    PDbgHeapHead  ph;

    UserAssert(pheap != NULL && (pheap->dwFlags & WIN32_HEAP_INUSE));

    EnterHeapCrit();

    ph = pheap->pFirstAlloc;

    while (ph != NULL) {
        Win32HeapCheckAllocHeader(pheap, ph);
        ph = ph->pNext;
    }

    LeaveHeapCrit();

#ifndef _USERK_
    return RtlValidateHeap(pheap->heap, 0, NULL);
#else
    return TRUE;
#endif
}

/***************************************************************************\
* Win32HeapDump
*
* dump heap allocations in a heap
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
VOID Win32HeapDump(
    PWIN32HEAP pheap)
{
    PDbgHeapHead  pAlloc = pheap->pFirstAlloc;

    if (pAlloc == NULL) {
        return;
    }

    UserAssert(pAlloc->pPrev == NULL);

    RIPMSG1(RIP_WARNING, "-- Dumping heap allocations for heap %#p... --",
            pheap);

    while (pAlloc != NULL) {

        DbgPrint("tag %04d size %08d\n", pAlloc->tag, pAlloc->size);
        pAlloc = pAlloc->pNext;
    }

    RIPMSG0(RIP_WARNING, "--- End Dump ---");
}

/***************************************************************************\
* Win32HeapFailAllocations
*
* fails the heap allocations
*
* History:
* 11/10/98  CLupu        Created
\***************************************************************************/
VOID Win32HeapFailAllocations(
    BOOL bFail)
{
    PWIN32HEAP pheap;
    int        ind;

    EnterGlobalHeapCrit();

    for (ind = 0; ind < MAX_HEAPS; ind++) {
        pheap = &gWin32Heaps[ind];

        if (!(pheap->dwFlags & WIN32_HEAP_INUSE))
            continue;

        EnterHeapCrit();

        if (bFail) {
            pheap->dwFlags |= WIN32_HEAP_FAIL_ALLOC;
            RIPMSG1(RIP_WARNING, "Heap allocations for heap %#p will fail !", pheap);
        } else {
            pheap->dwFlags &= ~WIN32_HEAP_FAIL_ALLOC;
        }

        LeaveHeapCrit();
    }

    LeaveGlobalHeapCrit();
}

/***************************************************************************\
* Win32HeapStat
*
* Retrieves the heap statistics.
*   dwLen is the size of phs in bytes.  If there are more tags in this module
*   than what the caller requested, a higher buffer is asked for by returning
*   the total number of tags in use.
* winsrv uses the MAKE_TAG macro to construct their tags, so it needs to pass
* TRUE for bNeedTagShift
*
*   If there is only one structure passed in, the phs->dwSize will hold gXFail
*   and phs->dwCount will hold gYFail to be used to fail gXFail allocs and then
*   succeed the next gYFail allocations.
*
* History:
* 02/25/99  MCostea     Created
\***************************************************************************/
DWORD Win32HeapStat(
    PDBGHEAPSTAT    phs,
    DWORD   dwLen,
    BOOL    bNeedTagShift)
{
    PWIN32HEAP pheap;
    PDbgHeapHead  pAlloc;
    UINT    ind, maxTagExpected, maxTag, currentTag;

    /*
     * We need at least one structure to do anything
     */
    if (dwLen < sizeof(DBGHEAPSTAT)) {
        return 0;
    }

    if (dwLen == sizeof(DBGHEAPSTAT)) {
        /*
         * This call is actually intended to set the gXFail and gYFail parameters
         */
        gFail = phs->dwSize;
        gSucceed = phs->dwCount;
        gToFail = gFail;
        return 1;
    }

    RtlZeroMemory(phs, dwLen);
    maxTagExpected = dwLen/sizeof(DBGHEAPSTAT) - 1;
    maxTag = 0;

    EnterGlobalHeapCrit();

    for (ind = 0; ind < MAX_HEAPS; ind++) {
        pheap = &gWin32Heaps[ind];

        if (!(pheap->dwFlags & WIN32_HEAP_INUSE))
            continue;

        EnterHeapCrit();

        pAlloc = pheap->pFirstAlloc;

        while (pAlloc != NULL) {
            currentTag = pAlloc->tag;
            if (bNeedTagShift) {
                currentTag >>= HEAP_TAG_SHIFT;
            }
            if (maxTag < currentTag) {
                maxTag = currentTag;
            }
            if (currentTag <= maxTagExpected) {
                phs[currentTag].dwSize += (DWORD)(pAlloc->size);
                phs[currentTag].dwCount++;
            }
            pAlloc = pAlloc->pNext;
        }
        LeaveHeapCrit();
    }
    LeaveGlobalHeapCrit();
    /*
     * Now fill the dwTag for tags that have allocations
     */
    for (ind = 0; ind < maxTagExpected; ind++) {
        if (phs[ind].dwCount) {
            phs[ind].dwTag = ind;
        }
    }

    return maxTag;
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\rtl\precomp.h ===
#ifdef _USERK_
#define NOWINBASEINTERLOCK
#else
#define NONTOSPINTERLOCK
#endif
#include <ntosp.h>

#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winuserp.h>

#include <stdio.h>

#include "heap.h"
#include "w32err.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\rtl\tag.c ===
/****************************** Module Header ******************************\
* Module Name: tag.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Implementation of debug tags.
*
* History:
* 11-Aug-1996 adams      Created
\***************************************************************************/

#include "precomp.h"

#if DEBUGTAGS

#undef DECLARE_DBGTAG
#define DECLARE_DBGTAG(tagName, tagDescription, tagFlags, tagIndex) \
            {tagFlags, #tagName, tagDescription},

DBGTAG gadbgtag[] = {
#include "dbgtag.h"
};

/***************************************************************************\
* InitDbgTags
*
* Initialize debug tag flags into gpsi->adwDBGTAGFlags.
*
* History:
* 15-Aug-1996 adams     Created.
\***************************************************************************/

#ifdef _USERK_

void
InitDbgTags(void)
{
    #undef DECLARE_DBGTAG
    #define DECLARE_DBGTAG(tagName, tagDescription, tagFlags, tagIndex) \
        SetDbgTag(tagIndex, tagFlags);

    #include "dbgtag.h"

    #undef DECLARE_DBGTAG
}

#endif

/***************************************************************************\
* IsDbgTagEnabled
*
* Return TRUE if the tag is enabled, FALSE otherwise.
*
* History:
* 15-Aug-1996 adams     Created.
\***************************************************************************/

BOOL
IsDbgTagEnabled(int tag)
{
    UserAssert(tag < DBGTAG_Max);
    return ((GetDbgTagFlags(tag) & DBGTAG_VALIDUSERFLAGS) >= DBGTAG_ENABLED);
}

/***************************************************************************\
* GetDbgTag
*
* Get the state of a debug tag.
*
* History:
* 15-Aug-1996 adams     Created.
\***************************************************************************/

DWORD
GetDbgTag(int tag)
{
    UserAssert(tag < DBGTAG_Max);
    return GetDbgTagFlags(tag);
}

#endif // if DEBUGTAGS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\rtl\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=w32
MINORCOMP=rtl

TARGETPATH=$(_OBJ_DIR)

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..;                            \
        $(WINCORE_PATH)\w32inc;         \
        $(WINCORE_PATH)\w32inc\$(O);    \
        $(BASE_INC_PATH)
	
C_DEFINES=$(C_DEFINES) /DUNICODE /D_UNICODE

SOURCES=..\heap.c  \
        ..\debug.c \
        ..\tag.c


PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\tools\usrbench\usrbench.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name

   usrbench.h

Abstract:

    USER performance numbers

Author:

   Dan Almosnino (danalm) 25-July-1996
   Based on code by Mark Enstrom   (marke)  13-Apr-1995

Enviornment:

   User Mode

Revision History:

    Dan Almosnino (danalm) 20-Sept-1995

    Added some default values for text string-related tests

    Dan Almosnino (danalm) 17-Oct-1995

    Added some default values, globals and new functions for batch mode execution

    Dan Almosnino (danalm) 20-Nov-1995

    Included header files for Pentium Cycle Counter and Statistics module.
    Added some variables for statistic processing.

    Dan Almosnino (danalm) 25-July-1996

    Adapted from GDIbench to USERbench
--*/



int PASCAL
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrev,
    LPSTR szCmdLine,
    int cmdShow
);

LRESULT FAR
PASCAL WndProc(
    HWND        hWnd,
    unsigned    msg,
    WPARAM      wParam,
    LPARAM      lParam);


ULONGLONG
msSetBkColor(
   HDC   hdc,
   ULONG iter
   );

ULONGLONG
msGetBkColor(
   HDC   hdc,
   ULONG iter
   );

ULONGLONG
msCreateDCW(
   HDC   hdc,
   ULONG iter
   );

ULONGLONG
msCreateDCA(
   HDC   hdc,
   ULONG iter
   );

INT_PTR
APIENTRY
ResultsDlgProc(
    HWND,
    UINT,
    WPARAM,
    LPARAM);

INT_PTR
APIENTRY
HelpDlgProc(
    HWND,
    UINT,
    WPARAM,
    LPARAM);


VOID
SaveResults();

char *
SelectOutFileName(
    HWND hWnd
    );

VOID
WriteBatchResults(
    FILE *fpOut,
    int  TestType,
    int  cycle
    );

int
SyncMenuChecks(
    HWND hWnd,
    int Last_Checked,
    int New_Checked
    );

int
Std_Parse(
    char *txtbuf,
    int limit,
    int *array);

#ifdef _X86_
#include "cycle.h"
#endif

#include "stats.h"

typedef ULONG (*PFN_MS)(HDC,ULONG);

typedef struct _TEST_ENTRY
{
    PUCHAR Api;
    PFN_MS pfn;
    ULONG  Iter;
    ULONG  Result;

}TEST_ENTRY,*PTEST_ENTRY;

#define CMD_IS(x) (NULL != strstr(szCmdLine,x))

#define INIT_TIMER    ULONGLONG StartTime,StopTime; \
                      ULONG ix = Iter; \
                      ULONGLONG overhead = 0; \
                      ULONGLONG ov1, ov2


#define START_TIMER   UpdateWindow(ghwndMDIClient); \
                      StartTime = BeginTimeMeasurement()

#define END_TIMER_NO_RETURN \
     StopTime = EndTimeMeasurement(StartTime + overhead, Iter)

#define RETURN_STOP_TIME        return StopTime

#define END_TIMER \
    StopTime = EndTimeMeasurement(StartTime + overhead, Iter); \
    return StopTime

#ifdef _X86_
#define START_OVERHEAD \
    if(gfPentium) \
        ov1 = GetCycleCount(); \
    else \
        QueryPerformanceCounter((LARGE_INTEGER *)&ov1)
#define END_OVERHEAD \
    if(gfPentium) \
        ov2 = GetCycleCount(); \
    else \
        QueryPerformanceCounter((LARGE_INTEGER *)&ov2); \
    overhead += ov2 - ov1

#else // !_X86_

#define START_OVERHEAD \
    QueryPerformanceCounter((LARGE_INTEGER *)&ov1)
#define END_OVERHEAD \
    QueryPerformanceCounter((LARGE_INTEGER *)&ov2); \
    overhead += ov2 - ov1

#endif


#define FIRST_TEXT_FUNCTION 10
#define LAST_TEXT_FUNCTION 19

#define DEFAULT_STRING_LENGTH 32
#define DEFAULT_A_STRING    "This is just a silly test string"
#define DEFAULT_W_STRING    L"This is just a silly test string"

#define ALL             11
#define QUICK           12
#define TEXT_SUITE      13
#define SELECT          14
#define POINTS_PER_INCH 72

extern ULONG gNumTests;
extern ULONG gNumQTests;
extern TEST_ENTRY  gTestEntry[];


#define NUM_TESTS  gNumTests
#define NUM_QTESTS gNumQTests
#define NUM_SAMPLES     10      // Number of test samples to be taken, each performing the test
                                    // TEST_DEFAULT times
#define VAR_LIMIT       3           // Desired Variation Coefficient (StdDev/Average) in percents

#ifdef MAIN_MODULE
#define PUBLIC
#else
#define PUBLIC  extern
#endif

PUBLIC TEST_STATS TestStats[200];           // Sample Array [of size at least as number of test entries]
PUBLIC long Detailed_Data[200][NUM_SAMPLES];        // Storage for detailed sample data

PUBLIC _int64   PerformanceFreq;        /* Timer Frequency  */

// Text String Tests Related

PUBLIC size_t   StrLen;

PUBLIC char     SourceString[129];
PUBLIC wchar_t SourceStringW[129];
PUBLIC char     DestString[256];
PUBLIC wchar_t DestStringW[256];
PUBLIC wchar_t WCstrbuf[256];


PUBLIC BYTE    DisplayHelp;

//  Batch Mode Related

PUBLIC BYTE     TextSuiteFlag;
PUBLIC BYTE     BatchFlag;
PUBLIC int  BatchCycle;
PUBLIC BYTE     Finish_Message;
PUBLIC BYTE     Dont_Close_App;
PUBLIC BYTE     SelectedFontTransparent;
PUBLIC BYTE     String_Length_Warn;
PUBLIC BYTE Print_Detailed;

PUBLIC FILE *fpIniFile;
PUBLIC FILE *fpOutFile;
PUBLIC char IniFileName[80];
PUBLIC char *OutFileName;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\rtl\debug.c ===
/****************************** Module Header ******************************\
* Module Name: debugc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains random debugging related functions.
*
* History:
* 17-May-1991 DarrinM   Created.
* 22-Jan-1992 IanJa     ANSI/Unicode neutral (all debug output is ANSI)
* 11-Mar-1993 JerrySh   Pulled functions from user\server.
\***************************************************************************/

#include "precomp.h"

#if DEBUGTAGS
extern DBGTAG gadbgtag[];
#endif



// common globals
extern CONST ALWAYSZERO gZero;

#if DBG != 0 || DEBUGTAGS != 0

CONST LPCSTR aszComponents[] = {
    "?",              //                    0x00000000
    "USER",           //  RIP_USER          0x00010000
    "WSRV",           //  RIP_USERSRV       0x00020000
    "URTL",           //  RIP_USERRTL       0x00030000
    "GDI",            //  RIP_GDI           0x00040000
    "GDIK",           //  RIP_GDIKRNL        0x00050000
    "GRTL",           //  RIP_GDIRTL        0x00060000
    "KRNL",           //  RIP_BASE          0x00070000
    "BSRV",           //  RIP_BASESRV       0x00080000
    "BRTL",           //  RIP_BASERTL       0x00090000
    "DISP",           //  RIP_DISPLAYDRV    0x000A0000
    "CONS",           //  RIP_CONSRV        0x000B0000
    "USRK",           //  RIP_USERKRNL      0x000C0000
#ifdef FE_IME
    "IMM",            //  RIP_IMM           0x000D0000
#else
    "?",              //                    0x000D0000
#endif
    "?",              //                    0x000E0000
    "?",              //                    0x000F0000
};


BOOL IsNumChar(int c, int base)
{
    return ('0' <= c && c <= '9') ||
           (base == 16 && (('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')));
}

NTSTATUS
GetInteger(LPSTR psz, int base, int * pi, LPSTR * ppsz)
{
    NTSTATUS status = STATUS_INVALID_PARAMETER;

    for (;;) {
        if (IsNumChar(*psz, base)) {
            status = RtlCharToInteger(psz, base, pi);
            if (ppsz && NT_SUCCESS(status)) {
                while (IsNumChar(*psz++, base))
                    ;

                *ppsz = psz;
            }

            break;
        }

        if (*psz != ' ' && *psz != '\t') {
            break;
        }

        psz++;
    }

    return status;
}

/*
 * Use a separate debug assertion that doesn't cause recursion
 * into this code.
 */

#define DebugAssertion(x)                                                                       \
    do {                                                                                        \
        if (!(x)) {                                                                             \
            if (TEST_RIPF(RIPF_PRINTONERROR)) {                                                 \
                KdPrint(("USER: Debug function assertion failure: %s \nFile %s line %ld\n", #x, __FILE__, __LINE__)); \
            }                                                                                   \
            if (TEST_RIPF(RIPF_PROMPTONERROR)) {                                                \
                DbgBreakPoint();                                                                \
            }                                                                                   \
        }                                                                                       \
    } while (FALSE)

/***************************************************************************\
* PrintAndPrompt
*
* Sets the last error, prints an error message, and prompts for
* debug actions.
*
* History:
* 11-Aug-1996 adams   Created.
\***************************************************************************/

BOOL
PrintAndPrompt(
        BOOL                fPrint,
        BOOL                fPrompt,
        DWORD               idErr,
        DWORD               flags,
        LPCSTR              pszLevel,
        LPCSTR              pszFile,
        int                 iLine,
        LPSTR               pszErr,
        PEXCEPTION_POINTERS pexi)
{
    extern VOID UserRtlRaiseStatus(NTSTATUS Status);

    static CONST CHAR *szLevels[8] = {
        "<none>",
        "Errors",
        "Warnings",
        "Errors and Warnings",
        "Verbose",
        "Errors and Verbose",
        "Warnings and Verbose",
        "Errors, Warnings, and Verbose"
    };

#ifdef _USERK_
    static CONST CHAR *szSystem = "System";
    static CONST CHAR *szUnknown = "???";
    CONST CHAR        *pszImage;

    extern ULONG      gSessionId;
#else
    static CONST WCHAR *wszUnknown = L"???";
    WCHAR              *pwszImage;
    ULONG              ulLenImage;
#endif

    DWORD       dwT;
    DWORD       dwP;
    DWORD       dwSession;
    char        szT[512];

    BOOL        fBreak = FALSE;

    /*
     * Set the last error, but don't clear it!
     */
    if (idErr) {
        UserSetLastError(idErr);
    }

    /*
     * Print the message.
     */
    if (!(fPrint || fPrompt))
        return FALSE;

#ifdef _USERK_
    {
        PETHREAD    pet;
        PEPROCESS   pep;

        dwT = HandleToUlong(PsGetCurrentThreadId());
        dwP = HandleToUlong(PsGetCurrentProcessId());

        pszImage = PsGetCurrentProcessImageFileName();
        if (*pszImage == '\0') {
            pszImage = szSystem;
        }
    }
#else
    {
        PTEB    pteb;
        PPEB    ppeb;

        if (pteb = NtCurrentTeb()) {
            dwT = HandleToUlong(pteb->ClientId.UniqueThread);
            dwP = HandleToUlong(pteb->ClientId.UniqueProcess);
        } else {
            dwT = dwP = 0;
        }

        if ((ppeb = NtCurrentPeb()) && ppeb->ProcessParameters != NULL) {
            /*
             * Get Pointers to the image path
             */
            pwszImage = ppeb->ProcessParameters->ImagePathName.Buffer;
            ulLenImage = (ppeb->ProcessParameters->ImagePathName.Length) / sizeof(WCHAR);

            /*
             * If the ProcessParameters haven't been normalized yet, then do it.
             */
            if (pwszImage != NULL && !(ppeb->ProcessParameters->Flags & RTL_USER_PROC_PARAMS_NORMALIZED)) {
                pwszImage = (PWSTR)((PCHAR)(pwszImage) + (ULONG_PTR)(ppeb->ProcessParameters));
            }

            /*
             * Munge out the path part.
             */
            if (pwszImage != NULL && ulLenImage != 0) {
                PWSTR pwszT = pwszImage + (ulLenImage - 1);
                ULONG ulLenT = 1;

                while (ulLenT != ulLenImage && *(pwszT-1) != L'\\') {
                    pwszT--;
                    ulLenT++;
                }

                pwszImage = pwszT;
                ulLenImage = ulLenT;
            }

        } else {
            pwszImage = (PWSTR)wszUnknown;
            ulLenImage = 3;
        }
    }
#endif


    if (!((flags & RIP_LEVELBITS) == RIP_ERROR) &&
        GetRipPID() != 0 &&
        GetRipPID() != dwP) {

        return FALSE;
    }

#ifdef _USERK_
    dwSession = gSessionId;
#else
    {
        PPEB ppeb = NtCurrentPeb();

        dwSession = (ppeb != NULL ? ppeb->SessionId : 0);
    }
#endif

    szT[0] = 'p';
    for (;;) {
        switch (szT[0] | (char)0x20) {
        /* print */
        case 'p':
        case ' ':
            if (!(flags & RIP_NONAME) && (!TEST_RIPF(RIPF_HIDEPID))) {
#ifdef _USERK_
                KdPrint((
                        "(s: %d %#lx.%lx %s) %s-[%s",
                        dwSession,
                        dwP,
                        dwT,
                        pszImage,
                        aszComponents[(flags & RIP_COMPBITS) >> RIP_COMPBITSSHIFT],
                        pszLevel));

#else // _USERK_
                KdPrint((
                        "(s: %d %#lx.%lx %*ws) %s-[%s",
                        dwSession,
                        dwP,
                        dwT,
                        ulLenImage,
                        pwszImage,
                        aszComponents[(flags & RIP_COMPBITS) >> RIP_COMPBITSSHIFT],
                        pszLevel));
#endif // _USERK_

                if (idErr) {
                    KdPrint(("=%ld] ", idErr));
                } else {
                    KdPrint(("] "));
                }
            }

            KdPrint(("%s", pszErr));
            if (!(flags & RIP_NONEWLINE)) {
                KdPrint(("\n"));
            }

            if (flags & RIP_THERESMORE) {
                fPrompt = FALSE;
            } else if (TEST_RIPF(RIPF_PRINTFILELINE) && (pexi == NULL)) {
                KdPrint(("File: %s, Line: %d\n", pszFile, iLine));
            }

            break;

        /* go */
        case 'g':
            fPrompt = FALSE;
            break;

        /* break */
        case 'b':

            KdPrint(("File: %s, Line: %d\n", pszFile, iLine));

            fBreak = TRUE;
            fPrompt = FALSE;
            break;

        /* display where this originated from */
        case 'w':
            if (pexi != NULL)
                break;

            KdPrint(("File: %s, Line: %d\n", pszFile, iLine));
            break;

        /* kill this thread */
        case 'x':
            if (pexi != NULL) {
                /*
                 * The root-level exception handler will complete the
                 * termination of this thread.
                 */
                 fPrompt = FALSE;
                 break;
            } else {

                /*
                 * Raise an exception, that will kill it real good.
                 */
                KdPrint(("Now raising the exception of death.  "
                        "Type 'x' again to finish the job.\n"));
                UserRtlRaiseStatus( 0x15551212 );
            }
            break;

        /* dump information about this exception */
        case 'i':
            /*
             * Dump some useful information about this exception, like its
             * address, and the contents of the interesting registers at
             * the time of the exception.
             */
            if (pexi == NULL)
                break;
#if defined(i386) // legal
            /*
             * eip = instruction pointer
             * esp = stack pointer
             * ebp = stack frame pointer
             */
            KdPrint(("eip = %lx\n", pexi->ContextRecord->Eip));
            KdPrint(("esp = %lx\n", pexi->ContextRecord->Esp));
            KdPrint(("ebp = %lx\n", pexi->ContextRecord->Ebp));
#elif defined(_IA64_)
             /*
              * StIIP = instruction pointer
              * IntSp = stack pointer
              * RsBSP = Rsestack pointer
              */
              KdPrint(("StIIP = %lx\n", pexi->ContextRecord->StIIP));
              KdPrint(("IntSp = %lx\n", pexi->ContextRecord->IntSp));
              KdPrint(("RsBsp = %lx\n", pexi->ContextRecord->RsBSP));
#elif defined(_AMD64_)
            /*
             * rip = instruction pointer
             * rsp = stack pointer
             * rbp = stack frame pointer
             */
            KdPrint(("rip = %lx\n", pexi->ContextRecord->Rip));
            KdPrint(("rsp = %lx\n", pexi->ContextRecord->Rsp));
            KdPrint(("rbp = %lx\n", pexi->ContextRecord->Rbp));
#else
#error "No target architecture"
#endif
            break;

         /* modify RIP flags */
         case 'f':
             {
                 ULONG      ulFlags;
                 NTSTATUS   status;

                 szT[ARRAY_SIZE(szT) - 1] = 0;              /* don't overflow buffer */
                 status = GetInteger(szT + 1, 16, &ulFlags, NULL);
                 if (NT_SUCCESS(status)) {
                    SetRipFlags(ulFlags, -1);
                 }

                 KdPrint(("Flags = %.3x\n", (GetRipFlags() & RIPF_VALIDUSERFLAGS)));
                 KdPrint(("  Print Process/Component %sabled\n", (GetRipFlags() & RIPF_HIDEPID) ? "dis" : "en"));
                 KdPrint(("  Print File/Line %sabled\n", (TEST_RIPF(RIPF_PRINTFILELINE)) ? "en" : "dis"));
                 KdPrint(("  Print on %s\n",  szLevels[(GetRipFlags() & RIPF_PRINT_MASK)  >> RIPF_PRINT_SHIFT]));
                 KdPrint(("  Prompt on %s\n", szLevels[(GetRipFlags() & RIPF_PROMPT_MASK) >> RIPF_PROMPT_SHIFT]));

                 break;
            }

#if DEBUGTAGS
        /* modify tags */
        case 't':
            {
                NTSTATUS    status;
                int         tag;
                LPSTR       psz;
                DWORD       dwDBGTAGFlags;
                int         i;
                int         iStart, iEnd;

                szT[ARRAY_SIZE(szT) - 1] = 0;              /* don't overflow buffer */
                status = GetInteger(szT + 1, 10, &tag, &psz);
                if (!NT_SUCCESS(status) || tag < 0 || DBGTAG_Max - 1 < tag) {
                    tag = -1;
                } else  {
                    status = GetInteger(psz, 16, &dwDBGTAGFlags, NULL);
                    if (NT_SUCCESS(status)) {
                        SetDbgTag(tag, dwDBGTAGFlags);
                    }
                }

                KdPrint(("%-5s%-7s%-*s%-*s\n",
                         "Tag",
                         "Flags",
                         DBGTAG_NAMELENGTH,
                         "Name",
                         DBGTAG_DESCRIPTIONLENGTH,
                         "Description"));

                for (i = 0; i < 12 + DBGTAG_NAMELENGTH + DBGTAG_DESCRIPTIONLENGTH; i++) {
                    szT[i] = '-';
                }

                szT[i++] = '\n';
                szT[i] = 0;
                KdPrint((szT));

                if (tag != -1) {
                    iStart = iEnd = tag;
                } else {
                    iStart = 0;
                    iEnd = DBGTAG_Max - 1;
                }

                for (i = iStart; i <= iEnd; i++) {
                    KdPrint(("%-5d%-7d%-*s%-*s\n",
                             i,
                             GetDbgTagFlags(i) & DBGTAG_VALIDUSERFLAGS,
                             DBGTAG_NAMELENGTH,
                             gadbgtag[i].achName,
                             DBGTAG_DESCRIPTIONLENGTH,
                             gadbgtag[i].achDescription));
                }

                break;
            }
#endif // if DEBUGTAGS

        /* display help */
        case '?':
            KdPrint(("g  - GO, ignore the error and continue execution\n"));
            if (pexi != NULL) {
                KdPrint(("b  - BREAK into the debugger at the location of the exception (part impl.)\n"));
                KdPrint(("i  - INFO on instruction pointer and stack pointers\n"));
                KdPrint(("x  - execute cleanup code and KILL the thread by returning EXECUTE_HANDLER\n"));
            } else {
                KdPrint(("b  - BREAK into the debugger at the location of the error (part impl.)\n"));
                KdPrint(("w  - display the source code location WHERE the error occured\n"));
                KdPrint(("x  - KILL the offending thread by raising an exception\n"));
            }

            KdPrint(("p  - PRINT this message again\n"));
            KdPrint(("f  - FLAGS, enter debug flags in format <Detail><Print><Prompt>\n"));
            KdPrint(("          <Detail>    = [0-3] Print File/Line = 1, Hide PID/Component = 2\n"));
            KdPrint(("          <Print>     = [0-7] Errors = 1, Warnings = 2, Verbose = 4\n"));
            KdPrint(("          <Prompt>    = [0-7] Errors = 1, Warnings = 2, Verbose = 4\n"));
            KdPrint(("     The default is 031\n"));
#if DEBUGTAGS
            KdPrint(("t  - TAGS, display and modify tag flags\n"));
            KdPrint(("          no argument displays all tags\n"));
            KdPrint(("          <tag> displays one tag\n"));
            KdPrint(("          <tag> <flags> modifies one tag\n"));
            KdPrint(("          <tag> = 0 - %d\n", DBGTAG_Max - 1));
            KdPrint(("          <flags> = [0-3] Disabled = 0, Enabled = 1, Print = 2, Prompt = 3\n"));
#endif // if DEBUGTAGS

            break;

        /* prompt again on bad input */
        default:
            break;
        }

        /* Prompt the user */
        if (!fPrompt)
            break;

#if DEBUGTAGS
        if (pexi != NULL) {
            DbgPrompt("[gbixpft?]", szT, sizeof(szT));
        } else {
            DbgPrompt("[gbwxpft?]", szT, sizeof(szT));
        }
#else
        if (pexi != NULL) {
            DbgPrompt("[gbixpf?]", szT, sizeof(szT));
        } else {
            DbgPrompt("[gbwxpf?]", szT, sizeof(szT));
        }
#endif

    }

    return fBreak;
}

#endif // if DBG != 0 || DEBUGTAGS != 0

#if DBG

/***************************************************************************\
* VRipOutput
*
* Formats a variable argument string and calls RipOutput.
*
* History:
* 19-Mar-1996 adams     Created.
\***************************************************************************/

ULONG _cdecl VRipOutput(
    ULONG       idErr,
    ULONG       flags,
    LPSTR       pszFile,
    int         iLine,
    LPSTR       pszFmt,
    ...)
{
    char szT[512];
    va_list arglist;

    va_start(arglist, pszFmt);
    _vsnprintf(szT, ARRAY_SIZE(szT) - 1, pszFmt, arglist);
    szT[ARRAY_SIZE(szT) - 1] = 0;              /* ensure null termination */
    va_end(arglist);
    return RipOutput(idErr, flags, pszFile, iLine, szT, NULL);
}


/***************************************************************************\
* RipOutput
*
* Sets the last error if it is non-zero, prints a message to
* the debugger, and prompts for more debugging actions.
*
* History:
* 01-23-91 DarrinM      Created.
* 04-15-91 DarrinM      Added exception handling support.
* 03-19-96 adams        Made flags a separate argument, cleanup.
\***************************************************************************/

ULONG RipOutput(
    ULONG       idErr,
    ULONG       flags,
    LPSTR       pszFile,
    int         iLine,
    LPSTR       pszErr,
    PEXCEPTION_POINTERS pexi)
{
    struct Level{
        LPSTR   szLevel;
        DWORD   dwPrint;
        DWORD   dwPrompt;
    };

    static struct Level aLevel[4] =
    {
        "?",          0,                      0,
        "Err",      RIPF_PRINTONERROR,      RIPF_PROMPTONERROR,
        "Wrn",      RIPF_PRINTONWARNING,    RIPF_PROMPTONWARNING,
        "Vrbs",     RIPF_PRINTONVERBOSE,    RIPF_PROMPTONVERBOSE,
    };

    int iLevel;

    DebugAssertion(flags & RIP_LEVELBITS);
    iLevel = ((flags & RIP_LEVELBITS) >> RIP_LEVELBITSSHI