rFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 322 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 324 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 326 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure DecryptKey */

/* 330 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 332 */	NdrFcLong( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0xa ),	/* 10 */
/* 338 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 340 */	NdrFcShort( 0x0 ),	/* 0 */
/* 342 */	NdrFcShort( 0x8 ),	/* 8 */
/* 344 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 346 */	0x8,		/* 8 */
			0x47,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, has range on conformance */
/* 348 */	NdrFcShort( 0x3d ),	/* 61 */
/* 350 */	NdrFcShort( 0x262 ),	/* 610 */
/* 352 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter psaIV */

/* 354 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 356 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 358 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter psaEncryptedData */

/* 360 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 362 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 364 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter psaRawData */

/* 366 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 368 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 370 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 372 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 374 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 376 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EncryptKey */

/* 378 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 380 */	NdrFcLong( 0x0 ),	/* 0 */
/* 384 */	NdrFcShort( 0xb ),	/* 11 */
/* 386 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 390 */	NdrFcShort( 0x8 ),	/* 8 */
/* 392 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 394 */	0x8,		/* 8 */
			0x47,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, has range on conformance */
/* 396 */	NdrFcShort( 0x32b ),	/* 811 */
/* 398 */	NdrFcShort( 0x40 ),	/* 64 */
/* 400 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter psaRawData */

/* 402 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
/* 404 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 406 */	NdrFcShort( 0x4b8 ),	/* Type Offset=1208 */

	/* Parameter psaIV */

/* 408 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 410 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 412 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Parameter psaEncryptedData */

/* 414 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 416 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 418 */	NdrFcShort( 0x4a6 ),	/* Type Offset=1190 */

	/* Return value */

/* 420 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 422 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 424 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const helperwrapper_MIDL_TYPE_FORMAT_STRING helperwrapper__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/*  4 */	NdrFcShort( 0x4a2 ),	/* Offset= 1186 (1190) */
/*  6 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
/* 10 */	
			0x13, 0x0,	/* FC_OP */
/* 12 */	NdrFcShort( 0x488 ),	/* Offset= 1160 (1172) */
/* 14 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 16 */	NdrFcShort( 0x18 ),	/* 24 */
/* 18 */	NdrFcShort( 0xa ),	/* 10 */
/* 20 */	NdrFcLong( 0x8 ),	/* 8 */
/* 24 */	NdrFcShort( 0x84 ),	/* Offset= 132 (156) */
/* 26 */	NdrFcLong( 0xd ),	/* 13 */
/* 30 */	NdrFcShort( 0xce ),	/* Offset= 206 (236) */
/* 32 */	NdrFcLong( 0x9 ),	/* 9 */
/* 36 */	NdrFcShort( 0x114 ),	/* Offset= 276 (312) */
/* 38 */	NdrFcLong( 0xc ),	/* 12 */
/* 42 */	NdrFcShort( 0x330 ),	/* Offset= 816 (858) */
/* 44 */	NdrFcLong( 0x24 ),	/* 36 */
/* 48 */	NdrFcShort( 0x364 ),	/* Offset= 868 (916) */
/* 50 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 54 */	NdrFcShort( 0x380 ),	/* Offset= 896 (950) */
/* 56 */	NdrFcLong( 0x10 ),	/* 16 */
/* 60 */	NdrFcShort( 0x3a4 ),	/* Offset= 932 (992) */
/* 62 */	NdrFcLong( 0x2 ),	/* 2 */
/* 66 */	NdrFcShort( 0x3c8 ),	/* Offset= 968 (1034) */
/* 68 */	NdrFcLong( 0x3 ),	/* 3 */
/* 72 */	NdrFcShort( 0x3ec ),	/* Offset= 1004 (1076) */
/* 74 */	NdrFcLong( 0x14 ),	/* 20 */
/* 78 */	NdrFcShort( 0x410 ),	/* Offset= 1040 (1118) */
/* 80 */	NdrFcShort( 0xffff ),	/* Offset= -1 (79) */
/* 82 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 84 */	NdrFcShort( 0x2 ),	/* 2 */
/* 86 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 88 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 90 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 92 */	0x0 , 
			0x0,		/* 0 */
/* 94 */	NdrFcLong( 0x0 ),	/* 0 */
/* 98 */	NdrFcLong( 0x0 ),	/* 0 */
/* 102 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 104 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 106 */	NdrFcShort( 0x8 ),	/* 8 */
/* 108 */	NdrFcShort( 0xffe6 ),	/* Offset= -26 (82) */
/* 110 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 112 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 114 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 116 */	NdrFcShort( 0x4 ),	/* 4 */
/* 118 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 122 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 124 */	0x0 , 
			0x0,		/* 0 */
/* 126 */	NdrFcLong( 0x0 ),	/* 0 */
/* 130 */	NdrFcLong( 0x0 ),	/* 0 */
/* 134 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 136 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 138 */	NdrFcShort( 0x4 ),	/* 4 */
/* 140 */	NdrFcShort( 0x0 ),	/* 0 */
/* 142 */	NdrFcShort( 0x1 ),	/* 1 */
/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 148 */	0x13, 0x0,	/* FC_OP */
/* 150 */	NdrFcShort( 0xffd2 ),	/* Offset= -46 (104) */
/* 152 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 154 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 156 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 158 */	NdrFcShort( 0x8 ),	/* 8 */
/* 160 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 162 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 164 */	NdrFcShort( 0x4 ),	/* 4 */
/* 166 */	NdrFcShort( 0x4 ),	/* 4 */
/* 168 */	0x11, 0x0,	/* FC_RP */
/* 170 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (114) */
/* 172 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 174 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 176 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 178 */	NdrFcLong( 0x0 ),	/* 0 */
/* 182 */	NdrFcShort( 0x0 ),	/* 0 */
/* 184 */	NdrFcShort( 0x0 ),	/* 0 */
/* 186 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 188 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 190 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 192 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 194 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 204 */	0x0 , 
			0x0,		/* 0 */
/* 206 */	NdrFcLong( 0x0 ),	/* 0 */
/* 210 */	NdrFcLong( 0x0 ),	/* 0 */
/* 214 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 218 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 220 */	0x0 , 
			0x0,		/* 0 */
/* 222 */	NdrFcLong( 0x0 ),	/* 0 */
/* 226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 230 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 232 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (176) */
/* 234 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 236 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 238 */	NdrFcShort( 0x8 ),	/* 8 */
/* 240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 242 */	NdrFcShort( 0x6 ),	/* Offset= 6 (248) */
/* 244 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 246 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 248 */	
			0x11, 0x0,	/* FC_RP */
/* 250 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (194) */
/* 252 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 254 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 264 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 266 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 268 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 270 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 272 */	NdrFcShort( 0x0 ),	/* 0 */
/* 274 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 276 */	NdrFcShort( 0x0 ),	/* 0 */
/* 278 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 280 */	0x0 , 
			0x0,		/* 0 */
/* 282 */	NdrFcLong( 0x0 ),	/* 0 */
/* 286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 290 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 294 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 296 */	0x0 , 
			0x0,		/* 0 */
/* 298 */	NdrFcLong( 0x0 ),	/* 0 */
/* 302 */	NdrFcLong( 0x0 ),	/* 0 */
/* 306 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 308 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (252) */
/* 310 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 312 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 314 */	NdrFcShort( 0x8 ),	/* 8 */
/* 316 */	NdrFcShort( 0x0 ),	/* 0 */
/* 318 */	NdrFcShort( 0x6 ),	/* Offset= 6 (324) */
/* 320 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 322 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 324 */	
			0x11, 0x0,	/* FC_RP */
/* 326 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (270) */
/* 328 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 330 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 332 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 334 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 336 */	0x0 , 
			0x0,		/* 0 */
/* 338 */	NdrFcLong( 0x0 ),	/* 0 */
/* 342 */	NdrFcLong( 0x0 ),	/* 0 */
/* 346 */	NdrFcShort( 0x2 ),	/* Offset= 2 (348) */
/* 348 */	NdrFcShort( 0x10 ),	/* 16 */
/* 350 */	NdrFcShort( 0x2f ),	/* 47 */
/* 352 */	NdrFcLong( 0x14 ),	/* 20 */
/* 356 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 358 */	NdrFcLong( 0x3 ),	/* 3 */
/* 362 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 364 */	NdrFcLong( 0x11 ),	/* 17 */
/* 368 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 370 */	NdrFcLong( 0x2 ),	/* 2 */
/* 374 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 376 */	NdrFcLong( 0x4 ),	/* 4 */
/* 380 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 382 */	NdrFcLong( 0x5 ),	/* 5 */
/* 386 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 388 */	NdrFcLong( 0xb ),	/* 11 */
/* 392 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 394 */	NdrFcLong( 0xa ),	/* 10 */
/* 398 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 400 */	NdrFcLong( 0x6 ),	/* 6 */
/* 404 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (636) */
/* 406 */	NdrFcLong( 0x7 ),	/* 7 */
/* 410 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 412 */	NdrFcLong( 0x8 ),	/* 8 */
/* 416 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (642) */
/* 418 */	NdrFcLong( 0xd ),	/* 13 */
/* 422 */	NdrFcShort( 0xff0a ),	/* Offset= -246 (176) */
/* 424 */	NdrFcLong( 0x9 ),	/* 9 */
/* 428 */	NdrFcShort( 0xff50 ),	/* Offset= -176 (252) */
/* 430 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 434 */	NdrFcShort( 0xd4 ),	/* Offset= 212 (646) */
/* 436 */	NdrFcLong( 0x24 ),	/* 36 */
/* 440 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (654) */
/* 442 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 446 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (654) */
/* 448 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 452 */	NdrFcShort( 0x10a ),	/* Offset= 266 (718) */
/* 454 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 458 */	NdrFcShort( 0x108 ),	/* Offset= 264 (722) */
/* 460 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 464 */	NdrFcShort( 0x106 ),	/* Offset= 262 (726) */
/* 466 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 470 */	NdrFcShort( 0x104 ),	/* Offset= 260 (730) */
/* 472 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 476 */	NdrFcShort( 0x102 ),	/* Offset= 258 (734) */
/* 478 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 482 */	NdrFcShort( 0x100 ),	/* Offset= 256 (738) */
/* 484 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 488 */	NdrFcShort( 0xea ),	/* Offset= 234 (722) */
/* 490 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 494 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (726) */
/* 496 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 500 */	NdrFcShort( 0xf2 ),	/* Offset= 242 (742) */
/* 502 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 506 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (738) */
/* 508 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 512 */	NdrFcShort( 0xea ),	/* Offset= 234 (746) */
/* 514 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 518 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (750) */
/* 520 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 524 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (754) */
/* 526 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 530 */	NdrFcShort( 0xe4 ),	/* Offset= 228 (758) */
/* 532 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 536 */	NdrFcShort( 0xea ),	/* Offset= 234 (770) */
/* 538 */	NdrFcLong( 0x10 ),	/* 16 */
/* 542 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 544 */	NdrFcLong( 0x12 ),	/* 18 */
/* 548 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 550 */	NdrFcLong( 0x13 ),	/* 19 */
/* 554 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 556 */	NdrFcLong( 0x15 ),	/* 21 */
/* 560 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 562 */	NdrFcLong( 0x16 ),	/* 22 */
/* 566 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 568 */	NdrFcLong( 0x17 ),	/* 23 */
/* 572 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 574 */	NdrFcLong( 0xe ),	/* 14 */
/* 578 */	NdrFcShort( 0xc8 ),	/* Offset= 200 (778) */
/* 580 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 584 */	NdrFcShort( 0xcc ),	/* Offset= 204 (788) */
/* 586 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 590 */	NdrFcShort( 0xca ),	/* Offset= 202 (792) */
/* 592 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 596 */	NdrFcShort( 0x7e ),	/* Offset= 126 (722) */
/* 598 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 602 */	NdrFcShort( 0x7c ),	/* Offset= 124 (726) */
/* 604 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 608 */	NdrFcShort( 0x7a ),	/* Offset= 122 (730) */
/* 610 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 614 */	NdrFcShort( 0x70 ),	/* Offset= 112 (726) */
/* 616 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 620 */	NdrFcShort( 0x6a ),	/* Offset= 106 (726) */
/* 622 */	NdrFcLong( 0x0 ),	/* 0 */
/* 626 */	NdrFcShort( 0x0 ),	/* Offset= 0 (626) */
/* 628 */	NdrFcLong( 0x1 ),	/* 1 */
/* 632 */	NdrFcShort( 0x0 ),	/* Offset= 0 (632) */
/* 634 */	NdrFcShort( 0xffff ),	/* Offset= -1 (633) */
/* 636 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 638 */	NdrFcShort( 0x8 ),	/* 8 */
/* 640 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 642 */	
			0x13, 0x0,	/* FC_OP */
/* 644 */	NdrFcShort( 0xfde4 ),	/* Offset= -540 (104) */
/* 646 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 648 */	NdrFcShort( 0x2 ),	/* Offset= 2 (650) */
/* 650 */	
			0x13, 0x0,	/* FC_OP */
/* 652 */	NdrFcShort( 0x208 ),	/* Offset= 520 (1172) */
/* 654 */	
			0x13, 0x0,	/* FC_OP */
/* 656 */	NdrFcShort( 0x2a ),	/* Offset= 42 (698) */
/* 658 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 660 */	NdrFcLong( 0x2f ),	/* 47 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 668 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 670 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 672 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 674 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 676 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 678 */	NdrFcShort( 0x1 ),	/* 1 */
/* 680 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 682 */	NdrFcShort( 0x4 ),	/* 4 */
/* 684 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 686 */	0x0 , 
			0x0,		/* 0 */
/* 688 */	NdrFcLong( 0x0 ),	/* 0 */
/* 692 */	NdrFcLong( 0x0 ),	/* 0 */
/* 696 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 698 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 700 */	NdrFcShort( 0x10 ),	/* 16 */
/* 702 */	NdrFcShort( 0x0 ),	/* 0 */
/* 704 */	NdrFcShort( 0xa ),	/* Offset= 10 (714) */
/* 706 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 708 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 710 */	NdrFcShort( 0xffcc ),	/* Offset= -52 (658) */
/* 712 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 714 */	
			0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 716 */	NdrFcShort( 0xffd8 ),	/* Offset= -40 (676) */
/* 718 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 720 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 722 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 724 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 726 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 728 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 730 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 732 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 734 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 736 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 738 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 740 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 742 */	
			0x13, 0x0,	/* FC_OP */
/* 744 */	NdrFcShort( 0xff94 ),	/* Offset= -108 (636) */
/* 746 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 748 */	NdrFcShort( 0xff96 ),	/* Offset= -106 (642) */
/* 750 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 752 */	NdrFcShort( 0xfdc0 ),	/* Offset= -576 (176) */
/* 754 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 756 */	NdrFcShort( 0xfe08 ),	/* Offset= -504 (252) */
/* 758 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 760 */	NdrFcShort( 0x2 ),	/* Offset= 2 (762) */
/* 762 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 764 */	NdrFcShort( 0x2 ),	/* Offset= 2 (766) */
/* 766 */	
			0x13, 0x0,	/* FC_OP */
/* 768 */	NdrFcShort( 0x194 ),	/* Offset= 404 (1172) */
/* 770 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 772 */	NdrFcShort( 0x2 ),	/* Offset= 2 (774) */
/* 774 */	
			0x13, 0x0,	/* FC_OP */
/* 776 */	NdrFcShort( 0x14 ),	/* Offset= 20 (796) */
/* 778 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 780 */	NdrFcShort( 0x10 ),	/* 16 */
/* 782 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 784 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 786 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 788 */	
			0x13, 0x0,	/* FC_OP */
/* 790 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (778) */
/* 792 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 794 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 796 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 798 */	NdrFcShort( 0x20 ),	/* 32 */
/* 800 */	NdrFcShort( 0x0 ),	/* 0 */
/* 802 */	NdrFcShort( 0x0 ),	/* Offset= 0 (802) */
/* 804 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 806 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 808 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 810 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 812 */	NdrFcShort( 0xfe1c ),	/* Offset= -484 (328) */
/* 814 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 816 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 818 */	NdrFcShort( 0x4 ),	/* 4 */
/* 820 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 824 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 826 */	0x0 , 
			0x0,		/* 0 */
/* 828 */	NdrFcLong( 0x0 ),	/* 0 */
/* 832 */	NdrFcLong( 0x0 ),	/* 0 */
/* 836 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 838 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 840 */	NdrFcShort( 0x4 ),	/* 4 */
/* 842 */	NdrFcShort( 0x0 ),	/* 0 */
/* 844 */	NdrFcShort( 0x1 ),	/* 1 */
/* 846 */	NdrFcShort( 0x0 ),	/* 0 */
/* 848 */	NdrFcShort( 0x0 ),	/* 0 */
/* 850 */	0x13, 0x0,	/* FC_OP */
/* 852 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (796) */
/* 854 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 856 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 858 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 860 */	NdrFcShort( 0x8 ),	/* 8 */
/* 862 */	NdrFcShort( 0x0 ),	/* 0 */
/* 864 */	NdrFcShort( 0x6 ),	/* Offset= 6 (870) */
/* 866 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 868 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 870 */	
			0x11, 0x0,	/* FC_RP */
/* 872 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (816) */
/* 874 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 876 */	NdrFcShort( 0x4 ),	/* 4 */
/* 878 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 882 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 884 */	0x0 , 
			0x0,		/* 0 */
/* 886 */	NdrFcLong( 0x0 ),	/* 0 */
/* 890 */	NdrFcLong( 0x0 ),	/* 0 */
/* 894 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 896 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 898 */	NdrFcShort( 0x4 ),	/* 4 */
/* 900 */	NdrFcShort( 0x0 ),	/* 0 */
/* 902 */	NdrFcShort( 0x1 ),	/* 1 */
/* 904 */	NdrFcShort( 0x0 ),	/* 0 */
/* 906 */	NdrFcShort( 0x0 ),	/* 0 */
/* 908 */	0x13, 0x0,	/* FC_OP */
/* 910 */	NdrFcShort( 0xff2c ),	/* Offset= -212 (698) */
/* 912 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 914 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 916 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 918 */	NdrFcShort( 0x8 ),	/* 8 */
/* 920 */	NdrFcShort( 0x0 ),	/* 0 */
/* 922 */	NdrFcShort( 0x6 ),	/* Offset= 6 (928) */
/* 924 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 926 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 928 */	
			0x11, 0x0,	/* FC_RP */
/* 930 */	NdrFcShort( 0xffc8 ),	/* Offset= -56 (874) */
/* 932 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 934 */	NdrFcShort( 0x8 ),	/* 8 */
/* 936 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 938 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 940 */	NdrFcShort( 0x10 ),	/* 16 */
/* 942 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 944 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 946 */	0x0,		/* 0 */
			NdrFcShort( 0xfff1 ),	/* Offset= -15 (932) */
			0x5b,		/* FC_END */
/* 950 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 952 */	NdrFcShort( 0x18 ),	/* 24 */
/* 954 */	NdrFcShort( 0x0 ),	/* 0 */
/* 956 */	NdrFcShort( 0xa ),	/* Offset= 10 (966) */
/* 958 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 960 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 962 */	NdrFcShort( 0xffe8 ),	/* Offset= -24 (938) */
/* 964 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 966 */	
			0x11, 0x0,	/* FC_RP */
/* 968 */	NdrFcShort( 0xfcfa ),	/* Offset= -774 (194) */
/* 970 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 972 */	NdrFcShort( 0x1 ),	/* 1 */
/* 974 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 976 */	NdrFcShort( 0x0 ),	/* 0 */
/* 978 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 980 */	0x0 , 
			0x0,		/* 0 */
/* 982 */	NdrFcLong( 0x0 ),	/* 0 */
/* 986 */	NdrFcLong( 0x0 ),	/* 0 */
/* 990 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 992 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 994 */	NdrFcShort( 0x8 ),	/* 8 */
/* 996 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 998 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1000 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1002 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1004 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1006 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (970) */
/* 1008 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1010 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1012 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1014 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1016 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1018 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1020 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1022 */	0x0 , 
			0x0,		/* 0 */
/* 1024 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1028 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1032 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1034 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1036 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1038 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1040 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1042 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1044 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1046 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1048 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1012) */
/* 1050 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1052 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1054 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1056 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1058 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1060 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1062 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1064 */	0x0 , 
			0x0,		/* 0 */
/* 1066 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1070 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1074 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1076 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1078 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1080 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1082 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1084 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1086 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1088 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1090 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1054) */
/* 1092 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1094 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1096 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1098 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1100 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1102 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1104 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1106 */	0x0 , 
			0x0,		/* 0 */
/* 1108 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1112 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1116 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1118 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 1120 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1122 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 1124 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 1126 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1128 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1130 */	0x13, 0x20,	/* FC_OP [maybenull_sizeis] */
/* 1132 */	NdrFcShort( 0xffdc ),	/* Offset= -36 (1096) */
/* 1134 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 1136 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1138 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1140 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1142 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1144 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1146 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1150 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1152 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 1154 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1156 */	0x0 , 
			0x0,		/* 0 */
/* 1158 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1166 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1168 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (1138) */
/* 1170 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1172 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1174 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1176 */	NdrFcShort( 0xffe2 ),	/* Offset= -30 (1146) */
/* 1178 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1178) */
/* 1180 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1182 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1184 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1186 */	NdrFcShort( 0xfb6c ),	/* Offset= -1172 (14) */
/* 1188 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1190 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1194 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1198 */	NdrFcShort( 0xfb58 ),	/* Offset= -1192 (6) */
/* 1200 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 1202 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1204) */
/* 1204 */	
			0x12, 0x0,	/* FC_UP */
/* 1206 */	NdrFcShort( 0xffde ),	/* Offset= -34 (1172) */
/* 1208 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1212 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1216 */	NdrFcShort( 0xfff0 ),	/* Offset= -16 (1200) */
/* 1218 */	
			0x12, 0x0,	/* FC_UP */
/* 1220 */	NdrFcShort( 0xfba4 ),	/* Offset= -1116 (104) */
/* 1222 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1224 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1226 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1230 */	NdrFcShort( 0xfff4 ),	/* Offset= -12 (1218) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            },
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IXoCryptoWrapper, ver. 0.0,
   GUID={0x4CC1CC3B,0x38A6,0x4AF2,{0xB7,0x5F,0xE4,0x57,0xA4,0x50,0x72,0x52}} */

#pragma code_seg(".orpc")
static const unsigned short IXoCryptoWrapper_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    42,
    96,
    150
    };

static const MIDL_STUBLESS_PROXY_INFO IXoCryptoWrapper_ProxyInfo =
    {
    &Object_StubDesc,
    helperwrapper__MIDL_ProcFormatString.Format,
    &IXoCryptoWrapper_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IXoCryptoWrapper_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    helperwrapper__MIDL_ProcFormatString.Format,
    &IXoCryptoWrapper_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(11) _IXoCryptoWrapperProxyVtbl = 
{
    &IXoCryptoWrapper_ProxyInfo,
    &IID_IXoCryptoWrapper,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IXoCryptoWrapper::XOCryptGenRandomWrp */ ,
    (void *) (INT_PTR) -1 /* IXoCryptoWrapper::DecryptWithMasterKeyWrp */ ,
    (void *) (INT_PTR) -1 /* IXoCryptoWrapper::GenPPAforDBWrp */ ,
    (void *) (INT_PTR) -1 /* IXoCryptoWrapper::EncryptWithMasterKeyWrp */
};


static const PRPC_STUB_FUNCTION IXoCryptoWrapper_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IXoCryptoWrapperStubVtbl =
{
    &IID_IXoCryptoWrapper,
    &IXoCryptoWrapper_ServerInfo,
    11,
    &IXoCryptoWrapper_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: IXoKeyEncryptionHelperWrp, ver. 0.0,
   GUID={0x86BA703A,0xDEDA,0x42DC,{0x8A,0x27,0x62,0x2F,0x39,0xB1,0x3D,0x9F}} */

#pragma code_seg(".orpc")
static const unsigned short IXoKeyEncryptionHelperWrp_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    216,
    252,
    282,
    330,
    378
    };

static const MIDL_STUBLESS_PROXY_INFO IXoKeyEncryptionHelperWrp_ProxyInfo =
    {
    &Object_StubDesc,
    helperwrapper__MIDL_ProcFormatString.Format,
    &IXoKeyEncryptionHelperWrp_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IXoKeyEncryptionHelperWrp_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    helperwrapper__MIDL_ProcFormatString.Format,
    &IXoKeyEncryptionHelperWrp_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(12) _IXoKeyEncryptionHelperWrpProxyVtbl = 
{
    &IXoKeyEncryptionHelperWrp_ProxyInfo,
    &IID_IXoKeyEncryptionHelperWrp,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *) (INT_PTR) -1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *) (INT_PTR) -1 /* IXoKeyEncryptionHelperWrp::Init */ ,
    (void *) (INT_PTR) -1 /* IXoKeyEncryptionHelperWrp::Terminate */ ,
    (void *) (INT_PTR) -1 /* IXoKeyEncryptionHelperWrp::GenerateNewKey */ ,
    (void *) (INT_PTR) -1 /* IXoKeyEncryptionHelperWrp::DecryptKey */ ,
    (void *) (INT_PTR) -1 /* IXoKeyEncryptionHelperWrp::EncryptKey */
};


static const PRPC_STUB_FUNCTION IXoKeyEncryptionHelperWrp_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _IXoKeyEncryptionHelperWrpStubVtbl =
{
    &IID_IXoKeyEncryptionHelperWrp,
    &IXoKeyEncryptionHelperWrp_ServerInfo,
    12,
    &IXoKeyEncryptionHelperWrp_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    helperwrapper__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x70001f4, /* MIDL Version 7.0.500 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * _helperwrapper_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IXoKeyEncryptionHelperWrpProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IXoCryptoWrapperProxyVtbl,
    0
};

const CInterfaceStubVtbl * _helperwrapper_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IXoKeyEncryptionHelperWrpStubVtbl,
    ( CInterfaceStubVtbl *) &_IXoCryptoWrapperStubVtbl,
    0
};

PCInterfaceName const _helperwrapper_InterfaceNamesList[] = 
{
    "IXoKeyEncryptionHelperWrp",
    "IXoCryptoWrapper",
    0
};

const IID *  _helperwrapper_BaseIIDList[] = 
{
    &IID_IDispatch,
    &IID_IDispatch,
    0
};


#define _helperwrapper_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _helperwrapper, pIID, n)

int __stdcall _helperwrapper_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _helperwrapper, 2, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _helperwrapper, 2, *pIndex )
    
}

const ExtendedProxyFileInfo helperwrapper_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _helperwrapper_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _helperwrapper_StubVtblList,
    (const PCInterfaceName * ) & _helperwrapper_InterfaceNamesList,
    (const IID ** ) & _helperwrapper_BaseIIDList,
    & _helperwrapper_IID_Lookup, 
    2,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#pragma optimize("", on )
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrappermanaged\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__helperwrappermanaged_0_none_12.4.56.0_none_d6b63523a8f97f42
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_helperwrappermanaged_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0.manifest
XP_MANIFEST_PATH=manifests\x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0.cat
XP_CATALOG_PATH=manifests\x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0.cat
XP_PAYLOAD_PATH=x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_helperwrappermanaged_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrappermanaged\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__helperwrappermanaged_0_none_12.4.56.0_none_d6b63523a8f97f42
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_helperwrappermanaged_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0.manifest
XP_MANIFEST_PATH=manifests\x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0.cat
XP_CATALOG_PATH=manifests\x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0.cat
XP_PAYLOAD_PATH=x86__helperwrappermanaged_0_no-public-key_12.4.56.0_x-ww_d6d172c0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_helperwrappermanaged_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\mc\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\helperwrappermanaged\HelperWrapperManaged.cs ===
/* This file was generated by:
 * 1: Build the native version of CryptoWrapper.dll
 * 2: Run that through tlbimp.exe:
 *      tlbimp CryptoWrapper.dll /namespace:xonline.common.crypto /out:HELPERWRAPPERLib.dll
 * 3: Run the .net reflector on HELPERWRAPPERLib.dll
 *      reflector HELPERWRAPPERLib.dll
 *      expand xonline.common.crypto
 *      expand HELPERWRAPPERLib.dll
 *      right-click xonline.common.crypto, select "disasemble"
 *      On the right-hand pane, click "expand types"
 *      Replace this file's HELPERWRAPPERLib namespace with that from the reflector
 *      Also, all the interfaces and classes must be declared as *internal* rather than *public*.
 *          If you don't do this, anything that references both a dll that builds this file
 *          and this file itself will fail to build.
 *      Build
 *      Profit
 */

using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;

namespace xonline.common.crypto
{
    [ComImport, TypeLibType((short) 0x1040), Guid("4CC1CC3B-38A6-4AF2-B75F-E457A4507252")]
    public interface IXoCryptoWrapper
    {
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(1)]
        byte[] XOCryptGenRandomWrp([In] uint ulDataSize);
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(2)]
        byte[] DecryptWithMasterKeyWrp([In] uint ulMasterKeyVersion, [In] uint pulDataSize, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaEncData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(3)]
        void GenPPAforDBWrp([In, MarshalAs(UnmanagedType.BStr)] string bstrName, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] ppsaKey, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] ppsaSPPA, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] ppsaPPA);
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(4)]
        byte[] EncryptWithMasterKeyWrp([In] uint ulMasterKeyVersion, [In] uint cbPublicKey, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaPublicKey, [In] uint ulDataSize, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaDecData);
    }

    [ComImport, TypeLibType((short) 0x1040), Guid("86BA703A-DEDA-42DC-8A27-622F39B13D9F")]
    internal interface IXoKeyEncryptionHelperWrp
    {
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(1)]
        void Init([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] saKEK);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(2)]
        void Terminate();
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(3)]
        void GenerateNewKey([MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaIV, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaEncryptedData, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaRawData);
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(4)]
        byte[] DecryptKey([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaIV, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaEncryptedData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(5)]
        void EncryptKey([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaRawData, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaIV, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaEncryptedData);
    }

    [ComImport, CoClass(typeof(XoCryptoWrapperClass)), Guid("4CC1CC3B-38A6-4AF2-B75F-E457A4507252")]
    public interface XoCryptoWrapper : IXoCryptoWrapper
    {
    }

    [ComImport, ClassInterface((short) 0), TypeLibType((short) 2), Guid("007CDE6D-353E-4F97-98E2-B351D009BD1B")]
    public class XoCryptoWrapperClass : IXoCryptoWrapper, XoCryptoWrapper
    {
        // Methods
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(2)]
        public virtual extern byte[] DecryptWithMasterKeyWrp([In] uint ulMasterKeyVersion, [In] uint pulDataSize, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaEncData);
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(4)]
        public virtual extern byte[] EncryptWithMasterKeyWrp([In] uint ulMasterKeyVersion, [In] uint cbPublicKey, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaPublicKey, [In] uint ulDataSize, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaDecData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(3)]
        public virtual extern void GenPPAforDBWrp([In, MarshalAs(UnmanagedType.BStr)] string bstrName, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] ppsaKey, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] ppsaSPPA, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] ppsaPPA);
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(1)]
        public virtual extern byte[] XOCryptGenRandomWrp([In] uint ulDataSize);
    }

    [ComImport, Guid("86BA703A-DEDA-42DC-8A27-622F39B13D9F"), CoClass(typeof(XoKeyEncryptionHelperWrpClass))]
    internal interface XoKeyEncryptionHelperWrp : IXoKeyEncryptionHelperWrp
    {
    }

    [ComImport, ClassInterface((short) 0), Guid("50C34C88-45C4-483F-94A5-FEB32E6E2A71"), TypeLibType((short) 2)]
    internal class XoKeyEncryptionHelperWrpClass : IXoKeyEncryptionHelperWrp, XoKeyEncryptionHelperWrp
    {
        // Methods
        [return: MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)]
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(4)]
        public virtual extern byte[] DecryptKey([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaIV, [In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaEncryptedData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(5)]
        public virtual extern void EncryptKey([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] psaRawData, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaIV, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaEncryptedData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(3)]
        public virtual extern void GenerateNewKey([MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaIV, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaEncryptedData, [MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] out byte[] psaRawData);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(1)]
        public virtual extern void Init([In, MarshalAs(UnmanagedType.SafeArray, SafeArraySubType=VarEnum.VT_UI1)] byte[] saKEK);
        [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType=MethodCodeType.Runtime), DispId(2)]
        public virtual extern void Terminate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\mc\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__mc_0_none_12.4.56.0_none_e77cf02f6ba55f9a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_mc_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc.manifest
XP_MANIFEST_PATH=manifests\x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc.cat
XP_CATALOG_PATH=manifests\x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc.cat
XP_PAYLOAD_PATH=x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_mc_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\mc\MusicnetToken.cs ===
using System;
using System.Collections;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using System.Web;
using System.Web.Caching;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;

using xonline.common.config;
using xonline.common.mgmt;
using xonline.common.service;
using xonline.common.utilities;

namespace xonline.common.crypto
{
    public class MusicnetToken
    {
        private static RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();


        public static string GetMusicNetAuthToken(ulong userPuid)
        {
            return GetMusicNetAuthToken(userPuid.ToString("x"));
        }


        public static string GetMusicNetAuthToken(string customerId)
        {
            // get timestamp
            string utcNow = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ssUTC");

            // generate random salt
            int saltLength = Config.GetIntSetting("crux_MusicNetTokenSaltLen");
            byte[] salt = new byte[saltLength];
            rng.GetBytes(salt);

            // generate random IV
            byte[] iv = new byte[16];
            rng.GetBytes(iv);

            // build the encrypted token
            string token = GetMusicNetAuthToken(customerId, utcNow, salt, iv);

            return token;
        }


        public static string GetMusicNetAuthToken(string customerId, string utcNow, byte[] salt, byte[] iv)
        {
            int keyType = Config.GetIntSetting("crux_MusicNetAESKeyType");
            int keyVersion = Config.GetIntSetting("crux_MusicNetAESKeyVer");

            byte[] key = null;

            // get the raw MusicNet key
            try
            {
                key = CryptoReader.GetKey(keyType, keyVersion);
            }
            catch (Exception e)
            {
                HResult hr = HResult.XONLINE_E_UODB_KEY_NOT_FOUND;

                string msg = "GetMusicNetAuthToken: failed to load MusicNet key from UODB.  Verify that xkeymgr been run to add key type 20 to UODB.\r\nException: " + e;

                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR, msg );

                throw new XRLException( hr, XEvent.Id.CRUX_MUSICNET_KEY_LOAD_ERROR, msg );
            }

            string authToken = GetMusicNetAuthToken(key, customerId, utcNow, salt, iv);
            
            return authToken;
        }


        public static string GetMusicNetAuthToken(byte[] key, string customerId, string utcNow, byte[] salt, byte[] iv)
        {
            Xom.Trace(XomAreaName.cryptotools, LogLevel.L_LOW, "ArgoSignIn.GetMusicNetAuthToken: generating authtoken for user: 0x" + customerId);

            string token =
                  Config.GetSetting("crux_MusicNetTokenMagicString") // "TKN"
                + customerId                                         // xuid
                + "|"
                + utcNow;

            Xom.Trace(XomAreaName.cryptotools, LogLevel.L_LOW, "GetMusicNetAuthToken: token: " + token);

            byte[] payload = Encoding.ASCII.GetBytes(token);

            // plaintext is composed of the salt + payload
            byte[] plainText = new byte[salt.Length + payload.Length];

            // first, the salt
            salt.CopyTo(plainText, 0);

            // next, the payload itself
            payload.CopyTo(plainText, salt.Length);

            // encrypt the plain text
            byte[] cipherText = null;
            AesUtil.Encrypt(plainText, key, iv, out cipherText);

            // token = Base64.Encode(iv + cipherText)

            byte[] tokenBytes = new byte[iv.Length + cipherText.Length];
            iv.CopyTo(tokenBytes, 0);
            cipherText.CopyTo(tokenBytes, iv.Length);

            string authToken = Convert.ToBase64String(tokenBytes);

            return authToken;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\mc\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__mc_0_none_12.4.56.0_none_e77cf02f6ba55f9a
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_mc_0
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc.manifest
XP_MANIFEST_PATH=manifests\x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc.cat
XP_CATALOG_PATH=manifests\x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc.cat
XP_PAYLOAD_PATH=x86__mc_0_no-public-key_12.4.56.0_x-ww_2c2727dc
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_mc_0,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\bignumcb.cpp ===
//
// Copyright (C) Microsoft
//

#include <precomp.h>
#include "bignumcb.h"

/* --------------------- */

void nfutil_copybytes ( unsigned char *dst, const unsigned char *src,
	unsigned nbytes, int swapends, int swapwords )
{
  int inc;
  unsigned nwords;

  /* Copies dst to src, swapping endianness and/or word order. dst and src mustn't overlap! */

  assert( (nbytes & 3)==0 ); /* Must be whole number of M_Words */

  if ( !swapends && !swapwords )
  {
    memcpy(dst, src, nbytes);
    return;
  }

  if ( swapwords )
  {
    dst += (nbytes-4);
    inc=-4;
  }
  else
    inc=4;

  nwords = nbytes>>2;

  if ( swapends )
  {
    while ( nwords-- > 0 )
    {
      dst[0]=src[3];
      dst[1]=src[2];
      dst[2]=src[1];
      dst[3]=src[0];
      dst += inc;
      src += 4;
    }
  }
  else
  {
    while ( nwords-- > 0 )
    {
      dst[0]=src[0];
      dst[1]=src[1];
      dst[2]=src[2];
      dst[3]=src[3];
      dst += inc;
      src += 4;
    }
  }
}

/* --------------------- */

int sbn_bignumreceiveupcall(struct NFast_Application *app,
                               struct NFast_Call_Context *cctx,
                               struct NFast_Transaction_Context *tctx,
                               M_Bignum *bignum, int nbytes,
                               const void *source,
                               int msbitfirst, int mswordfirst)
{
  struct NFast_Bignum *pBN;

  if ( nbytes > MAXBIGNUMBITS/8 ) return Status_OutOfRange;
  assert( (nbytes & 3)==0 );

  pBN = (struct NFast_Bignum *)NFastApp_Malloc(app, sizeof(struct NFast_Bignum), cctx, tctx);
  if ( !pBN ) return NOMEM;

  nfutil_copybytes(pBN->bytes, (const unsigned char *)source,
	nbytes, 0, 0);

  pBN->msb_first = msbitfirst;
  pBN->msw_first = mswordfirst;
  pBN->nbytes=nbytes;
  *bignum=pBN;
  return Status_OK;
}

/* --------------------- */

int sbn_bignumsendlenupcall(struct NFast_Application *app,
                               struct NFast_Call_Context *cctx,
                               struct NFast_Transaction_Context *tctx,
                               const M_Bignum *bignum, int *nbytes_r)
{
  assert( ((*bignum)->nbytes & 3)==0 );
  *nbytes_r= (*bignum)->nbytes;
  return Status_OK;
}

/* --------------------- */

int sbn_bignumsendupcall(struct NFast_Application *app,
                            struct NFast_Call_Context *cctx,
                            struct NFast_Transaction_Context *tctx,
                            const M_Bignum *bignum, int nbytes,
                            void *dest, int msbitfirst, int mswordfirst)
{
  int swapends, swapwords;
  struct NFast_Bignum *pBN = *bignum;

  assert( pBN->nbytes==nbytes );

  /* Is format which we're sending in the same as that of the
     bignumber? 
     (NB '!' used to constrain result to 0,1 range)
     If not, work out which ends to swap.
  */

  swapends = (!msbitfirst) ^ (!pBN->msb_first);
  swapwords = (!mswordfirst) ^ (!pBN->msw_first);
  nfutil_copybytes( (unsigned char *)dest, (*bignum)->bytes, nbytes,
	swapends, swapwords );
  return Status_OK;
}

/* --------------------- */

void sbn_bignumfreeupcall(struct NFast_Application *app,
                             struct NFast_Call_Context *cctx,
                             struct NFast_Transaction_Context *tctx,
                             M_Bignum *bignum)
{
  NFastApp_Free(app, (*bignum), cctx, tctx);
  *bignum=NULL;
}

/* --------------------- */

int sbn_bignumformatupcall(struct NFast_Application *app,
                              struct NFast_Call_Context *cctx,
                              struct NFast_Transaction_Context *tctx,
                              int *msbitfirst_io, int *mswordfirst_io)
{
  /* Send to the module in little-endian format.
     (This is not officially necessary. However, some
     versions of the monitor (Maintenance mode) don't accept
     big-endian bignums due to a bug) */
  *msbitfirst_io=0;
  *mswordfirst_io=0;
  return Status_OK;
}

/* --------------------- */

static int char2hex ( char c )
{
  if ( c >= '0' && c <= '9' ) return c-'0';
  if ( c >= 'A' && c <= 'F' ) return c-'A'+10;
  if ( c >= 'a' && c <= 'f' ) return c-'a'+10;
  return -1;
}

/* --------------------- */

int sbn_char2bignum ( struct NFast_Bignum **ppBN_out,
			const char *text,
			struct NFast_Application *app,
                        struct NFast_Call_Context *cctx,
                        struct NFast_Transaction_Context *tctx )
{
  struct NFast_Bignum *pBN;
  int i, d, len;

  /* Strip leading whitespace */

  while ( text[0] != 0 && isspace((unsigned char)text[0]) )
    text++;

  /* Strip trailing whitespace */
  len=strlen(text);
  while ( len > 0 && isspace((unsigned char)text[len-1]) )
    len--;

  if ( len > MAXBIGNUMBITS/4 ) return Status_OutOfRange;

  pBN = (struct NFast_Bignum *)NFastApp_Malloc(app, sizeof(struct NFast_Bignum), cctx, tctx);
  if ( !pBN ) return NOMEM;

  pBN->msb_first = 0;
  pBN->msw_first = 0;

  /* Read in from the LS digit */
  for ( i=0; i<len; i++ )
  {
    d = char2hex(text[len-1-i]);
    if ( d < 0 ) return Status_Malformed;
    if ( i & 1 )
      pBN->bytes[i/2] |= (d << 4);
    else
      pBN->bytes[i/2] = (unsigned char)d;
  }

  /* Pad to words if necessary */
  i = (len+1)/2;
  while ( (i & 3) != 0 )
    pBN->bytes[i++] = 0;

  pBN->nbytes=i;
  *ppBN_out=pBN;
  return Status_OK;
}

/* --------------------- */

static int getbyte ( const struct NFast_Bignum *pN, int pos )
{
  /* Get a byte from a bignum, taking account of possible strange endianness */
  if ( pos >= pN->nbytes ) return 0;

  if ( pN->msb_first ) pos ^= 3; /* Big endian words */

  if ( pN->msw_first )
  {
    pos = pN->nbytes-1-pos;
    pos ^= 3;
  }

  return pN->bytes[pos];
}

/* --------------------- */

static int getbytelen ( const struct NFast_Bignum *pN )
{
  int n=pN->nbytes-1;
  while ( n >= 0 && getbyte(pN, n)==0 )
    n--;

  return n+1;
}

/* --------------------- */

int sbn_bignum2char ( char *buf, int buflen,
			const struct NFast_Bignum *pBN,
			struct NFast_Application *app,
                        struct NFast_Call_Context *cctx,
                        struct NFast_Transaction_Context *tctx )
{
  int i, d, pos, len;
  static const char *hexdigits="0123456789ABCDEF";

  len = pBN->nbytes;

  pos = len*2+1;
  if ( buflen < pos )
    return Status_BufferFull;

  buf[--pos] = 0;

  for ( i=0; i<len; i++ )
  {
    d = getbyte(pBN,i);
    buf[--pos] = hexdigits[d & 0xF];
    buf[--pos] = hexdigits[(d>>4) & 0xF];
  }

  return Status_OK;
}

/* --------------------- */

void sbn_printbignum ( FILE *f, const char *prefix, const struct NFast_Bignum *pBN )
{
  char buf[MAXBIGNUMBITS/4+1];
  int rc;

  rc=sbn_bignum2char(buf, sizeof(buf), pBN, NULL, NULL, NULL);
  if ( rc != Status_OK ) strcpy(buf, "<invalid length>");
  fprintf( f, "%s=\n %s\n", prefix, buf );
}

/* --------------------- */

int sbn_compare ( const struct NFast_Bignum *pA, 
			const struct NFast_Bignum *pB )
{
  int i, aa, bb;

  aa=getbytelen(pA); 
  bb=getbytelen(pB);
  if ( aa != bb ) return (aa > bb) ? 1 : -1;

  i=aa;
  while ( i-- > 0 )
  {
    aa=getbyte(pA,i);
    bb=getbyte(pB,i);
    if ( aa != bb ) return (aa > bb) ? 1 : -1;
  }

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\precomp.h ===
//
// Copyright (C) Microsoft
//

#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <windows.h>
#include <wincrypt.h>

#include "xmgmt.h"
#include "xeventids.h"
#include "cryptohelper.h"

// Macros -------------------------------------------------------------------
#if _DEBUG
#define NcTrace printf("\n%s: ",__FUNCTION__) && printf
#define NcAssert(x) { if(!(x)) { NcTrace("Assert failed at %s,%d : %s", __FILE__, __LINE__, #x); DebugBreak(); } }
#else
#define NcTrace __noop
#define NcAssert(x)
#endif

#define LOCAL static

//@@@ We have no environment with the testkey in the ncipher yet.
// #define XMACS_CRYPTO_USE_NCIPHER_TEST_KEY 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\mc\CryptoMgr.cs ===
///
///  CryptoMgr.cs :  Declaration and implementation of the PUID manager class.
///
///  Date:  May 01/2002
///  Dev:  lohab
///  Copyright (c) Microsoft Corporation.  All rights reserved.
///

using System;
using System.Collections;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

using Microsoft.Webstore.WstClient;

using xonline.common.config;
using xonline.common.service;
using xonline.common.sql.webstore;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.cryptomgr)]

namespace xonline.common.crypto
{
    /// <summary>
    /// The crypto manager is responsible for attain and maintaining key encryption keys from the UODB.
    /// </summary>
    public class CryptoReader
    {
        public static byte[] GetKey(int keyType, int keyVersion)
        {
            LoadKeysFromDatabase( keyType );

            string hashKey = GetHashKey(keyType, keyVersion);

            byte[] rawKey = (byte[]) m_keyTable[hashKey];

            // The old GetKeyWrp method threw an IndexOutOfRangeException if an unknown
            // key version was specified.  Since xsig depends on those semantics, preserve
            // them here.
            if ( rawKey == null )
            {
                throw new IndexOutOfRangeException("unknown keyVersion:" + keyVersion + " (keyType: " + keyType + ")");
            }

            return rawKey;
        }

        public static byte[] GetLatestKey(int keyType)
        {
            LoadKeysFromDatabase( keyType );
            // Since this is a brand-spankin'-new function, I don't have to go forward with the IndexOutOfRangeException like above.
            return GetKey(keyType, (int) m_keyTable[GetKeyTypeKey(keyType)]);
        }

        protected static string GetHashKey(int keyType, int keyVersion)
        {
            string hashKey = keyType.ToString("d") + ":" + keyVersion.ToString("d");
            return hashKey;
        }

        protected static string GetKeyTypeKey(int keyType)
        {
            return "keyType:" + keyType;
        }

        public static void ReloadKeys()
        {
            // force keyTable to be reloaded
            m_keyTable = new Hashtable();
        }

        //
        // Protected

        // methods
        protected static void LoadKeysFromDatabase(int keyType)
        {
            string keyTypeKey = GetKeyTypeKey(keyType);

            if ( m_keyTable[keyTypeKey] == null )
            {
                lock(syncObject)
                {
                    if ( m_keyTable[keyTypeKey] == null )
                    {
                        // create the instance of the main crypto wrapper class.
                        if ( m_cryptoWrp != null )
                        {
                            Marshal.ReleaseComObject( m_cryptoWrp );
                            m_cryptoWrp = null;
                        }
                        m_cryptoWrp = new XoCryptoWrapperClass();

                        int keyVersionsFound = 0;
                        
                        // Making SQL call to retrieve service key
                        using ( SqlConnection conn = new SqlConnection( ConfigUtil.NpdbConnectionString ) )
                        {
                            conn.Open();

                            using ( SqlCommand cmd = conn.CreateCommand() )
                            {
                                cmd.CommandText = "dbo.p_xuacs_get_servicekey_values";
                                cmd.CommandType = CommandType.StoredProcedure;

                                cmd.Parameters.Add( "@i_keyType", SqlDbType.Int ).Value = keyType;

                                Xom.Trace(XomAreaName.cryptomgr, LogLevel.L_LOW, "CryptoReader.GetKeyFromDatabase: executing stored procedure:" + cmd.CommandText + " with keyType = " + keyType );

                                // execute the stored proc.
                                using ( SqlDataReader reader = cmd.ExecuteReader() )
                                {
                                    // the results are expected in the following format.
                                    // scan the list for all entires...
                                    while ( reader.Read() )
                                    {
                                        int keyVersion;
                                        uint keySize = 0;
                                        uint masterKeyVersion;

                                        // retrieve the key version
                                        keyVersion = reader.GetInt32( 0 );

                                        // put the entry in the list.
                                        keySize = (uint) reader.GetBytes(1, 0, null, 0, 0);

                                        byte[] encryptedKey = new byte[keySize];
                                        reader.GetBytes(1, 0, encryptedKey, 0, encryptedKey.Length);

                                        // retrieve the master key version
                                        masterKeyVersion = (uint) reader.GetInt32( 2 );

                                        // decrypt the key and store the result.
                                        byte[] rawKey = m_cryptoWrp.DecryptWithMasterKeyWrp( masterKeyVersion, keySize, encryptedKey);
#if DEBUG
                                        Xom.Trace(XomAreaName.cryptomgr, LogLevel.L_HIGH, "LoadKeysFromDatabase: loaded keyType: " + keyType + ", keyVersion: " + keyVersion + ", rawKey: 0x" + ByteConvert.ToString(rawKey) );
#endif
                                        string hashKey = GetHashKey(keyType, keyVersion);
                                        m_keyTable[hashKey] = rawKey;

                                        // increment number of key versions loaded
                                        keyVersionsFound++;
                                    }
                                }
                            }
                        }

                        // indicate all versions of the given keyType have been loaded
                        if ( keyVersionsFound > 0 )
                        {
                            m_keyTable[keyTypeKey] = keyVersionsFound;
                        }
                    }
                }
            }
        }

        static protected internal XoCryptoWrapperClass m_cryptoWrp = null;
        static protected Hashtable m_keyTable = new Hashtable();
        static object syncObject = new object();
    }

    public class KEKCryptoMgr: CryptoReader
    {
        const int c_IVSize = 16;                // should match AES_KEYSIZE in crytohelper.h
        const int c_OnlineKeySize = 16;         // should match ONLINE_KEY_LEN in crytohelper.h

        public static void GenerateNewKey( out byte[] iv, out byte[] encKey, out byte[] rawKey )
        {
            int keyType = Config.GetIntSetting(Setting.crypto_serviceKeyType);
            int keyVersion = Config.GetIntSetting(Setting.crypto_serviceKeyVersion);

            byte[] keKey = GetKey(keyType, keyVersion);

            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;
            aes.GenerateIV();
            iv = aes.IV;

            // allocate memory for values.
            rawKey = new byte[c_OnlineKeySize];

            // create a random number generator
            RNGCryptoServiceProvider randGen = new RNGCryptoServiceProvider();

            // get random bytes for information.
            randGen.GetBytes( rawKey );

            encKey = new byte[c_OnlineKeySize];
            MemoryStream ms = new MemoryStream(encKey);
            ICryptoTransform cryptTrans = aes.CreateEncryptor( keKey, iv );
            CryptoStream cs = new CryptoStream(ms, cryptTrans, CryptoStreamMode.Write);
            cs.Write(rawKey, 0, c_OnlineKeySize);
            cs.Close();
        }

        public static void EncryptWithKEK( int kekversion, byte[] rawDataArr, out byte[] iv, out byte[] encData)
        {
            int keyType = Config.GetIntSetting(Setting.crypto_serviceKeyType);
            byte[] keKey = GetKey(keyType, kekversion);

            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;
            aes.GenerateIV();
            iv = aes.IV;


            encData = new byte[rawDataArr.Length];
            MemoryStream ms = new MemoryStream(encData);

            ICryptoTransform cryptTrans = aes.CreateEncryptor( keKey, iv );
            CryptoStream cs = new CryptoStream(ms, cryptTrans, CryptoStreamMode.Write);
            cs.Write( rawDataArr, 0 , rawDataArr.Length );
            cs.Close();

            Xom.Trace(XomAreaName.cryptomgr, LogLevel.L_LOW, "(CryptoMgr::EncryptWithKEK):  Encrypted Data Length = " + encData.Length + ", IV data Length = " + iv.Length + ", KEKVersion = " + kekversion );
        }

        public static void DecryptWithKEK( int kekversion, byte[] iv, byte[] encData, out byte[] rawDataArr )
        {
            int keyType = Config.GetIntSetting(Setting.crypto_serviceKeyType);
            byte[] keKey = GetKey(keyType, kekversion);

            Xom.Trace(XomAreaName.cryptomgr, LogLevel.L_LOW, "(CryptoMgr::DecryptoWithKEK):  Encrypted Data Length = " + encData.Length + ", IV data Length = " + iv.Length + ", KEKVersion = " + kekversion );

            Debug.Assert(iv.Length == 16);

            RijndaelManaged aes = new RijndaelManaged();
            aes.BlockSize = 128;
            aes.KeySize = 256;
            aes.Padding = PaddingMode.None;

            // create a buffer for the raw data
            rawDataArr = new byte[ encData.Length ];

            MemoryStream ms = new MemoryStream(rawDataArr);
            ICryptoTransform cryptTrans = aes.CreateDecryptor( keKey, iv );
            CryptoStream cs = new CryptoStream(ms, cryptTrans, CryptoStreamMode.Write);
            cs.Write( encData, 0, encData.Length );
            cs.Close();


            Xom.Trace(XomAreaName.cryptomgr, LogLevel.L_LOW, "(CryptoMgr::DecryptoWithKEK):  Raw Key Length = " + rawDataArr.Length );

        }

        public static bool GetCurrentUserKeyFromUODB(String gamerTag, out byte[] rawKey)
        {
            UInt64 userPuid = 0;
            Int32 keyEncKeyVersion = 0;
            Int32 keyVersion = 0;
            byte[] iv = null;
            byte[] key = null;

            rawKey = null;

            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.StoredProc = "p_askdc_get_principal";
                ws.SetHashVal(gamerTag);
                ws.AddParameter("@vc_name", gamerTag);
                ws.AddParameter("@f_only_xenon_keys", 1);
                using (WstDataReader reader = ws.Execute())
                {
                    if (reader.RecordsAffected > 1)
                    {
                        // Warn that there's more than 1 key that was found
                        Xom.NtEvent(XEvent.Id.CRYPTO_TOO_MANY_USER_KEYS, "There were multiple keys returned for user gamertag: " + gamerTag);
                    }
                    if (reader.Read())
                    {
                        userPuid = (ulong)reader.GetInt64(0);
                        keyEncKeyVersion = reader.GetInt32(1);
                        keyVersion = reader.GetInt32(2);
                        iv = WSClient.GetBytes(reader, "bin_iv");
                        key = WSClient.GetBytes(reader, "bin_key");
                    }
                    else
                    {
                        // Failure to read or 0 rows affected
                        Xom.NtEvent(XEvent.Id.CRYPTO_FAILED_GET_USER_KEYS, "Could not read result from p_askdc_get_principal.");
                    }
                }

                if (userPuid != 0)
                {
                    // Successfully returned from stored proc
                    DecryptWithKEK(keyEncKeyVersion, iv, key, out rawKey);
                    return true;
                }

                return false;
            }
        }

        public static void GenPPAforDBWrp( string GamerTag, byte[]rawKey, out byte [] SPPA, out byte [] PPA )
        {
            m_cryptoWrp.GenPPAforDBWrp(GamerTag, rawKey, out SPPA, out PPA);
        }
        public static byte [] DecryptWithMasterKeyWrp (uint masterkeyver, uint encPasswordLength, byte[] encPassword)
        {
            return m_cryptoWrp.DecryptWithMasterKeyWrp(masterkeyver, encPasswordLength, encPassword);
        }

        public static int GetKeyVersion()
        {
            return Config.GetIntSetting(Setting.crypto_serviceKeyVersion);
        }
    }

    public static class AesUtil
    {
        public static void Encrypt(byte[] plainText, byte[] key, byte[] iv, out byte[] cipherText)
        {
            // check arguments
            if ( plainText == null || plainText.Length <= 0 )
            {
                throw new ArgumentNullException("plainText");
            }

            if ( key == null || key.Length <= 0 )
            {
                throw new ArgumentNullException("key");
            }

            if ( iv == null || iv.Length <= 0 )
            {
                throw new ArgumentNullException("iv");
            }

            cipherText = null;

            // declare the streams used to encrypt to an in-memory array of bytes
            MemoryStream ms = null;
            CryptoStream cs = null;

            // declare the RijndaelManaged object used to encrypt the data
            RijndaelManaged aes = null;

            try
            {
                // create a RijndaelManaged object with the specified key and iv
                aes = new RijndaelManaged();
                aes.Key = key;
                aes.IV = iv;

                // create an encryptor to perform the stream transform.
                ICryptoTransform cryptoXform = aes.CreateEncryptor(aes.Key, aes.IV);

                // create the streams used for encryption.
                ms = new MemoryStream();
                cs = new CryptoStream(ms, cryptoXform, CryptoStreamMode.Write);

                // write all data to the stream.
                cs.Write(plainText, 0, plainText.Length);
                cs.FlushFinalBlock();
            }
            finally
            {
                if ( cs != null )
                {
                    cs.Close();
                }

                if ( ms != null )
                {
                    ms.Close();
                }

                // clear the RijndaelManaged object
                if ( aes != null )
                {
                    aes.Clear();
                }
            }

            // return the encrypted bytes from the memory stream
            cipherText = ms.ToArray();
        }

        public static void Encrypt(string plainText, byte[] key, byte[] iv, out byte[] cipherText)
        {
            // check arguments
            if ( plainText == null || plainText.Length <= 0 )
            {
                throw new ArgumentNullException("plainText");
            }

            if ( key == null || key.Length <= 0 )
            {
                throw new ArgumentNullException("key");
            }

            if ( iv == null || iv.Length <= 0 )
            {
                throw new ArgumentNullException("iv");
            }

            cipherText = null;

            // declare the streams used to encrypt to an in-memory array of bytes
            MemoryStream ms = null;
            CryptoStream cs = null;
            StreamWriter sw = null;

            // declare the RijndaelManaged object used to encrypt the data
            RijndaelManaged aes = null;

            try
            {
                // create a RijndaelManaged object with the specified key and iv
                aes = new RijndaelManaged();
                aes.Key = key;
                aes.IV = iv;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform cryptoXform = aes.CreateEncryptor(aes.Key, aes.IV);

                // Create the streams used for encryption.
                ms = new MemoryStream();
                cs = new CryptoStream(ms, cryptoXform, CryptoStreamMode.Write);
                sw = new StreamWriter(cs);

                //Write all data to the stream.
                sw.Write(plainText);
                sw.Close();

            }
            finally
            {
                if ( sw != null )
                {
                    sw.Close();
                }

                if ( cs != null )
                {
                    cs.Close();
                }

                if ( ms != null )
                {
                    ms.Close();
                }

                // clear the RijndaelManaged object
                if ( aes != null )
                {
                    aes.Clear();
                }
            }

            // return the encrypted bytes from the memory stream
            cipherText = ms.ToArray();
        }

        public static void Decrypt(byte[] cipherText, byte[] key, byte[] iv, out string plainText)
        {
            // check arguments
            if ( cipherText == null || cipherText.Length <= 0 )
            {
                throw new ArgumentNullException("cipherText");
            }

            if ( key == null || key.Length <= 0 )
            {
                throw new ArgumentNullException("key");
            }

            if ( iv == null || iv.Length <= 0 )
            {
                throw new ArgumentNullException("iv");
            }

            plainText = null;

            // declare the streams used to encrypt to an in-memory array of bytes
            MemoryStream ms = null;
            CryptoStream cs = null;
            StreamReader sr = null;

            // declare the RijndaelManaged object used to encrypt the data
            RijndaelManaged aes = null;

            try
            {
                // create a RijndaelManaged object with the specified key and iv
                aes = new RijndaelManaged();
                aes.Key = key;
                aes.IV = iv;
                aes.Padding = PaddingMode.PKCS7;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform cryptoXform = aes.CreateDecryptor(aes.Key, aes.IV);

                // Create the streams used for encryption.
                ms = new MemoryStream(cipherText);
                cs = new CryptoStream(ms, cryptoXform, CryptoStreamMode.Read);
                sr = new StreamReader(cs);

                // Read all data from the stream.
                plainText = sr.ReadToEnd();
            }
            finally
            {
                if ( sr != null )
                {
                    sr.Close();
                }

                if ( cs != null )
                {
                    cs.Close();
                }

                if ( ms != null )
                {
                    ms.Close();
                }

                // clear the RijndaelManaged object
                if ( aes != null )
                {
                    aes.Clear();
                }
            }
        }

        public static void Decrypt(byte[] cipherText, byte[] key, byte[] iv, out byte[] plainText)
        {
            // check arguments
            if ( cipherText == null || cipherText.Length <= 0 )
            {
                throw new ArgumentNullException("cipherText");
            }

            if ( key == null || key.Length <= 0 )
            {
                throw new ArgumentNullException("key");
            }

            if ( iv == null || iv.Length <= 0 )
            {
                throw new ArgumentNullException("iv");
            }

            plainText = null;

            // declare the streams used to encrypt to an in-memory array of bytes
            MemoryStream ms = null;
            CryptoStream cs = null;
            StreamReader sr = null;

            // declare the RijndaelManaged object used to encrypt the data
            RijndaelManaged aes = null;

            try
            {
                // create a RijndaelManaged object with the specified key and iv
                aes = new RijndaelManaged();
                aes.Key = key;
                aes.IV = iv;
                aes.Padding = PaddingMode.PKCS7;

                // Create a decrytor to perform the stream transform.
                ICryptoTransform cryptoXform = aes.CreateDecryptor(aes.Key, aes.IV);

                // Create the streams used for encryption.
                ms = new MemoryStream(cipherText);
                cs = new CryptoStream(ms, cryptoXform, CryptoStreamMode.Read);

                MemoryStream outMs = new MemoryStream();

                byte[] buf = new byte[22];

                for (;;)
                {
                    int bytesRead = cs.Read(buf, 0, buf.Length);
                    if ( bytesRead == 0 )
                    {
                        break;
                    }

                    outMs.Write(buf, 0, bytesRead);
                }

                plainText = outMs.ToArray();
            }
            finally
            {
                if ( sr != null )
                {
                    sr.Close();
                }

                if ( cs != null )
                {
                    cs.Close();
                }

                if ( ms != null )
                {
                    ms.Close();
                }

                // clear the RijndaelManaged object
                if ( aes != null )
                {
                    aes.Clear();
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\mc\CryptoTools.cs ===
///
///  CryptoTools.cs :  Implementation of CryptoTools class.  Handles cryptography on
///     Xbox Live system.
///
///  Date:  April 6/2004
///  Dev:  lohab
///  Copyright (c) Microsoft Corporation.  All rights reserved.
///

using System;
using System.Text;
using System.Runtime.InteropServices;
using System.IO;
using System.Security.Cryptography;
using System.Diagnostics;
using System.Collections;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.cryptotools)]

namespace xonline.common.crypto
{
    /// <summary>
    /// WIN32 Crypto API:  Unmanaged code extensions necessary for key management.
    /// </summary>
    /// NOTE:  Add more functions when deemed necessary.
    public class CryptoApi
    {
        #region Crypto API imports

        private const uint ALG_CLASS_HASH = (4 << 13);
        private const uint ALG_TYPE_ANY = (0);
        private const uint ALG_CLASS_DATA_ENCRYPT = (3 << 13);
        private const uint ALG_TYPE_STREAM = (4 << 9);
        private const uint ALG_TYPE_BLOCK = (3 << 9);

        private const uint ALG_SID_DES = 1;
        private const uint ALG_SID_RC4 = 1;
        private const uint ALG_SID_RC2 = 2;
        private const uint ALG_SID_MD5 = 3;
        private const uint ALG_SID_3DES = 3;
        private const uint ALG_SID_SHA1= 4;

        public const string MS_DEF_PROV = "Microsoft Base Cryptographic Provider v1.0";
        public const string MS_ENHANCED_PROV = "Microsoft Enhanced Cryptographic Provider v1.0";

        public const uint PROV_RSA_FULL = 1;

        // dwFlags definitions for CryptAcquireContext

        public const uint CRYPT_VERIFYCONTEXT   = 0xF0000000;
        public const uint CRYPT_NEWKEYSET       = 0x00000008;
        public const uint CRYPT_DELETEKEYSET    = 0x00000010;
        public const uint CRYPT_MACHINE_KEYSET  = 0x00000020;
        public const uint CRYPT_SILENT          = 0x00000040;


        public static readonly uint CALG_SHA1= (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA1);
        public static readonly uint CALG_MD5 = (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5);
        public static readonly uint CALG_DES = (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_DES);
        public static readonly uint CALG_RC2 = (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_RC2);
        public static readonly uint CALG_RC4 = (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_STREAM| ALG_SID_RC4);
        public static readonly uint CALG_3DES= (ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_3DES);

        // Use these dlls for all other pcs and servers
        const string CryptDll = "advapi32.dll";
        const string KernelDll = "kernel32.dll";

        [DllImport(CryptDll, CharSet = CharSet.Unicode)]
        public static extern bool CryptAcquireContext(  ref IntPtr phProv,
            string pszContainer,
            string pszProvider,
            uint dwProvType,
            uint dwFlags);

        [DllImport(CryptDll)]
        public static extern bool CryptReleaseContext(  IntPtr hProv,
            uint dwFlags);

        [DllImport(CryptDll)]
        public static extern bool CryptEncrypt( IntPtr hKey,
            IntPtr hHash,
            bool Final,
            uint dwFlags,
            byte[] pbData,
            ref uint pdwDataLen,
            uint dwBufLen);

        [DllImport(CryptDll)]
        public static extern bool CryptDecrypt( IntPtr hKey,
            IntPtr hHash,
            bool Final,
            uint dwFlags,
            byte[] pbData,
            ref uint pdwDataLen);


        [DllImport(CryptDll)]
        public static extern bool CryptImportKey( IntPtr hProv,
            byte[] pbData,
            uint dwDataLen,
            IntPtr hPubKey,
            uint dwFlags,
            ref IntPtr phKey );


        [DllImport(CryptDll)]
        public static extern bool CryptExportKey( IntPtr hKey,
            IntPtr hExpKey,
            uint dwBlobType,
            uint dwFlags,
            byte[] pbData,
            ref uint pdwDataLen );


        [DllImport(CryptDll)]
        public static extern bool CryptDestroyKey( IntPtr hKey );


        [DllImport(CryptDll)]
        public static extern bool CryptGetUserKey( IntPtr hProv,
            uint dwKeySpec,
            ref IntPtr hKey) ;

        [DllImport(CryptDll)]
        public static extern bool CryptCreateHash( IntPtr hProv,
            uint algId,
            IntPtr hKey,
            uint flags,
            ref IntPtr hHash) ;

        [DllImport(CryptDll)]
        public static extern bool CryptHashData( IntPtr hHash,
            byte[] data,
            uint dataLength,
            uint flags);

        [DllImport(CryptDll)]
        public static extern bool CryptDeriveKey( IntPtr hProv,
            uint algId,
            IntPtr hHash,
            uint flags,
            ref IntPtr hKey) ;

        [DllImport(CryptDll)]
        public static extern bool CryptDestroyHash( IntPtr hHash );

        #endregion

        #region Error reporting imports

        public const uint NTE_BAD_UID                    = 0x80090001;
        public const uint NTE_BAD_HASH                   = 0x80090002;
        public const uint NTE_BAD_KEY                    = 0x80090003;
        public const uint NTE_BAD_LEN                    = 0x80090004;
        public const uint NTE_BAD_DATA                   = 0x80090005;
        public const uint NTE_BAD_SIGNATURE              = 0x80090006;
        public const uint NTE_BAD_VER                    = 0x80090007;
        public const uint NTE_BAD_ALGID                  = 0x80090008;
        public const uint NTE_BAD_FLAGS                  = 0x80090009;
        public const uint NTE_BAD_TYPE                   = 0x8009000A;
        public const uint NTE_BAD_KEY_STATE              = 0x8009000B;
        public const uint NTE_BAD_HASH_STATE             = 0x8009000C;
        public const uint NTE_NO_KEY                     = 0x8009000D;
        public const uint NTE_NO_MEMORY                  = 0x8009000E;
        public const uint NTE_EXISTS                     = 0x8009000F;
        public const uint NTE_PERM                       = 0x80090010;
        public const uint NTE_NOT_FOUND                  = 0x80090011;
        public const uint NTE_DOUBLE_ENCRYPT             = 0x80090012;
        public const uint NTE_BAD_PROVIDER               = 0x80090013;
        public const uint NTE_BAD_PROV_TYPE              = 0x80090014;
        public const uint NTE_BAD_PUBLIC_KEY             = 0x80090015;
        public const uint NTE_BAD_KEYSET                 = 0x80090016;
        public const uint NTE_PROV_TYPE_NOT_DEF          = 0x80090017;
        public const uint NTE_PROV_TYPE_ENTRY_BAD        = 0x80090018;
        public const uint NTE_KEYSET_NOT_DEF             = 0x80090019;
        public const uint NTE_KEYSET_ENTRY_BAD           = 0x8009001A;
        public const uint NTE_PROV_TYPE_NO_MATCH         = 0x8009001B;
        public const uint NTE_SIGNATURE_FILE_BAD         = 0x8009001C;
        public const uint NTE_PROV_DLL_NOT_FOUND         = 0x8009001E;
        public const uint NTE_BAD_KEYSET_PARAM           = 0x8009001F;
        public const uint NTE_FAIL                       = 0x80090020;
        public const uint NTE_SYS_ERR                    = 0x80090021;
        public const uint NTE_SILENT_CONTEXT             = 0x80090022;
        public const uint NTE_TOKEN_KEYSET_STORAGE_FULL  = 0x80090023;
        public const uint NTE_TEMPORARY_PROFILE          = 0x80090024;
        public const uint NTE_FIXEDPARAMETER             = 0x80090025;

        [DllImport(KernelDll)]
        public static extern uint GetLastError();

        #endregion
    }

    public class CryptoException: Exception
    {
        public CryptoException(string message) : base(message)
        {
        }

        public CryptoException(string message, Exception innerException) : base(message, innerException)
        {
        }

        public CryptoException( uint eventId, string message) : base(message)
        {
            //LogEvent(eventId, new StringBuilder(message));
        }

        public CryptoException( uint eventId, string message, Exception innerException) : base(message, innerException)
        {
            //LogEvent(eventId, message, null, innerException);
        }

        public const uint CRYPTO_GENERAL_ERROR_EVENT = 0xC000C69E;//XEvent.Id.CRYPTO_GENERAL_ERROR;
    }

    /// <summary>
    /// CryptoTools:  Cryptography tools and methods to make managing crypto32 and managed code crypto more usable.
    /// </summary>
    public class CryptoTools
    {
        public CryptoTools()
        {
        }

        /// <summary>
        /// GenerateRandomEncryptedKey:  Creates a random key and en
        /// </summary>
        /// <param name="keySize">Size of the key to generate.</param>
        /// <param name="publicMasterKeyFileName">File name that carries the public master key file.</param>
        /// <param name="masterKeyVersion">out -- returns the master key version from the file.</param>
        /// <returns></returns>
        public byte[] GenerateRandomEncryptedKey( uint keySize, string publicMasterKeyFileName, ref uint masterKeyVersion )
        {
            byte[] randomKey = null;
            byte[] encryptedKey = null;

            // make sure the size is greater than 0
            if ( keySize == 0 )
            {
                return null;
            }

            try
            {
                int bytesRead = -1;
                byte[] fileData = null;
                byte[] keyBlob = null;

                // create the random key array.
                randomKey = GenerateRandomBytes( keySize );

                // --------------------

                // get the public master key.
                using (FileStream pubMasterKeyFile = new FileStream( publicMasterKeyFileName, FileMode.Open, FileAccess.Read ))
                {

                    // read the file data.
                    fileData = new byte[ pubMasterKeyFile.Length ];

                    // read all the data out at once.
                    bytesRead = pubMasterKeyFile.Read( fileData, 0, (int)pubMasterKeyFile.Length );

                    if ( ! ReadPublicKeyFile( fileData, ref masterKeyVersion, ref keyBlob ) )
                    {
                        throw new CryptoException("Failed for read public key file.");
                    }
                }

                // --------------------
                encryptedKey = RSA_Encrypt( randomKey, keyBlob, masterKeyVersion );

            }
            catch ( CryptoException ce )
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GenerateRandomEncryptedKey: (ERROR)  "  + ce.ToString() );
                throw;
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GenerateRandomEncryptedKey: (ERROR)  "  + e.ToString() );
                throw new CryptoException( CryptoException.CRYPTO_GENERAL_ERROR_EVENT,
                    "CryptoTools::GenerateRandomEncryptedKey: (ERROR)  "  + e.Message,
                    e );
            }

            return encryptedKey;
        }

        /// <summary>
        /// RSA_Encrypt:  Does RSA encryption using the public key.
        /// </summary>
        /// <param name="rawData">data to be encrypted.</param>
        /// <param name="publicKeyBlob">Public key blob to import into CSP for encryption.</param>
        /// <param name="keyVersion">Version of the RSA key to use.</param>
        /// <returns>Encrypted binary array of raw data.</returns>
        /// <exception>Thrown if some error occurs with the encryption.  Details are in the message body.</exception>
        public byte[] RSA_Encrypt( byte[] rawData, byte[] publicKeyBlob, uint keyVersion )
        {
            byte[] encryptedKey = null;
            bool createdNewKeySet = false;
            HResult hr = 0;
            uint dataLength = 0;

            IntPtr hProv = IntPtr.Zero;
            IntPtr hKey = IntPtr.Zero;

            try
            {
                // ensure the key size.
                if ( rawData.Length >= c_masterKeySize )
                {
                    throw new CryptoException( "Invalid Key Size." );
                }

                // acquire context with the provider of the master key.
                if ( !CryptoApi.CryptAcquireContext( ref hProv,
                    c_cspContainerName + keyVersion,
                    CryptoApi.MS_ENHANCED_PROV,
                    CryptoApi.PROV_RSA_FULL,
                    CryptoApi.CRYPT_MACHINE_KEYSET )
                    )
                {
                    hr = CryptoApi.GetLastError();

                    // if not keyset exists we can create one.
                    if ( hr == CryptoApi.NTE_BAD_KEYSET )
                    {
                        if ( !CryptoApi.CryptAcquireContext( ref hProv,
                            c_cspContainerName + keyVersion,
                            CryptoApi.MS_ENHANCED_PROV,
                            CryptoApi.PROV_RSA_FULL,
                            CryptoApi.CRYPT_MACHINE_KEYSET | CryptoApi.CRYPT_NEWKEYSET )
                            )
                        {
                            hr = CryptoApi.GetLastError();
                            throw new CryptoException( "Failed CryptAcquireContext with Win32 Error = " + hr );
                        }
                        createdNewKeySet = true;
                    }
                    else
                    {
                        throw new CryptoException( "Failed CryptAcquireContext with Win32 Error = " + hr );
                    }

                }

                // make sure we have a provider.
                if ( hProv == IntPtr.Zero )
                {
                    throw new CryptoException( "Received a NULL provider.  This should be impossible, something is corrupted.  Please investigate." );
                }

                // import the public key.
                if(! CryptoApi.CryptImportKey( hProv,
                    publicKeyBlob,
                    (uint)publicKeyBlob.Length,
                    IntPtr.Zero,
                    0,
                    ref hKey))
                {
                    hr = CryptoApi.GetLastError();
                    throw new CryptoException( "Failed CryptImportKey with Win32 Error = " + hr );
                }

                // ensure we have a key handle.
                if ( hKey == IntPtr.Zero )
                {
                    throw new CryptoException( "Received a NULL handle for our imported key.  This should be impossible, something is corrupted.  Please investigate." );
                }

                // create our buffer at 256 bytes.
                encryptedKey = new byte[ c_masterKeySize ];
                dataLength = (uint)rawData.Length;
                rawData.CopyTo( encryptedKey, 0 );

                // perform the encryption.
                if(!CryptoApi.CryptEncrypt( hKey,
                    IntPtr.Zero,
                    true,
                    0,
                    encryptedKey,
                    ref dataLength,
                    (uint)encryptedKey.Length )
                    )
                {
                    hr = CryptoApi.GetLastError();
                    throw new CryptoException( "Failed Encryption with Win32 Error = " + hr );
                }

            }
            catch ( CryptoException ce )
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::EncryptWithMasterKey: (ERROR)  "  + ce.ToString() );
                throw;
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::EncryptWithMasterKey: (ERROR)  "  + e.ToString() );
                throw new CryptoException( CryptoException.CRYPTO_GENERAL_ERROR_EVENT,
                    "CryptoTools::EncryptWithMasterKey: (ERROR)  "  + e.Message,
                    e );
            }
            finally
            {
                // destroy the key if it exists.
                if ( hKey != IntPtr.Zero )
                {
                    CryptoApi.CryptDestroyKey(hKey);
                }

                // release the provider if it exists.
                if ( hProv != IntPtr.Zero )
                {
                    CryptoApi.CryptReleaseContext( hProv, 0 );
                }

                // if we created a new keyset we don't need it anymore.
                if ( createdNewKeySet )
                {
                    CryptoApi.CryptAcquireContext( ref hProv,
                        c_cspContainerName + keyVersion,
                        CryptoApi.MS_ENHANCED_PROV,
                        CryptoApi.PROV_RSA_FULL,
                        CryptoApi.CRYPT_MACHINE_KEYSET | CryptoApi.CRYPT_DELETEKEYSET
                        );

                    // release the provider.
                    CryptoApi.CryptReleaseContext( hProv, 0 );

                }

            }

            return encryptedKey;
        }

        /// <summary>
        /// GetSymmetricKey:  Gets special symmetric key... it's a surprise ;)
        /// </summary>
        /// <param name="hProv">Handle to the correct provider.</param>
        /// <param name="hSymKey">handle for the symmetric key.</param>
        public static bool GetSymmetricKey ( IntPtr hProv, ref IntPtr hSymKey )
        {
            bool result = false;
            IntPtr hHash = IntPtr.Zero;

            // make sure the provider isnt' a waste of time.
            if ( hProv == IntPtr.Zero )
            {
                throw new CryptoException( "CryptoTools::GetSymmetricKey:  Key Provider is invalid." );
            }

            try
            {
                hSymKey = IntPtr.Zero;

                // create the hash object
                if(!CryptoApi.CryptCreateHash( hProv,
                                     CryptoApi.CALG_SHA1,
                                     IntPtr.Zero,
                                     0,
                                     ref hHash ) )
                {
                    uint err = CryptoApi.GetLastError();
                    throw new CryptoException( "Error during CryptCreateHash!  Error = " + err.ToString("X") + ".\r\n" );
                }

                // Hash the password
                if(!CryptoApi.CryptHashData(
                    hHash,
                    System.Text.ASCIIEncoding.ASCII.GetBytes( c_MKSymKey ),
                    (uint)c_MKSymKey.Length,
                    0))
                {
                    uint err = CryptoApi.GetLastError();
                    throw new CryptoException( "Error during CryptHashData!  Error = " + err.ToString("X") + ".\r\n" );
                }

                // Create a session key based on the hash of the password.
                if(!CryptoApi.CryptDeriveKey(
                    hProv,
                    CryptoApi.CALG_3DES,
                    hHash,
                    0,
                    ref hSymKey))
                {
                    uint err = CryptoApi.GetLastError();
                    throw new CryptoException( "Error during CryptDeriveKey!  Error = " + err.ToString("X") + ".\r\n" );
                }

                result = true;
            }
            catch ( CryptoException ce )
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GetSymmetricKey: (ERROR)  "  + ce.ToString() );
                throw;
            }
            catch ( Exception e )
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GetSymmetricKey: (ERROR)  "  + e.ToString() );
                throw new CryptoException( CryptoException.CRYPTO_GENERAL_ERROR_EVENT,
                    "CryptoTools::GetSymmetricKey: (ERROR)  "  + e.Message,
                    e );
            }
            finally
            {
                if( hHash != IntPtr.Zero )
                {
                    CryptoApi.CryptDestroyHash(hHash);
                }
            }

            return result;
        }

        /// <summary>
        /// GenerateRandomBytes:  Generates an array of crypto safe random bytes.
        /// </summary>
        /// <param name="size">Size of array to return.</param>
        /// <returns></returns>
        public static byte[] GenerateRandomBytes( uint size )
        {
            byte[] randomKey = null;

            try
            {
                //check the size.
                if ( size < 1 )
                {
                    throw new Exception("The requested array size is invalid.  It must be > 0.");
                }

                // create the random key array.
                randomKey = new byte[ size ];
                RNGCryptoServiceProvider rng = new RNGCryptoServiceProvider();

                // get our new random key.
                rng.GetBytes( randomKey );

            }
            catch ( CryptoException ce )
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GenerateRandomBytes: (ERROR)  "  + ce.ToString() );
                randomKey = null;
            }
            catch (Exception e)
            {
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::GenerateRandomBytes: (ERROR)  "  + e.ToString() );
                randomKey = null;
            }

            return randomKey;
        }

        /// <summary>
        /// ReadPublicKeyFile:  Reads Xbox Live Key Files
        /// </summary>
        /// <param name="publicKeyFileData">File blob</param>
        /// <param name="keyVersion">Key version of the file.</param>
        /// <param name="Key Blob">The Key blob to be imported.</param>
        /// <returns>True if successfully read.</returns>
        public static bool ReadPublicKeyFile( byte[] publicKeyFileData, ref uint keyVersion, ref byte[] keyBlob )
        {
            bool result = true;

            try
            {
                if ( publicKeyFileData == null )
                {
                    result = false;
                    throw new Exception("No public key file data provided." );
                }

                MemoryStream ms = new MemoryStream( publicKeyFileData );
                BinaryReader br = new BinaryReader( ms );

                keyVersion = br.ReadUInt32();

                // read the rest of the buffer into the blob.
                keyBlob = br.ReadBytes( publicKeyFileData.Length - (int)c_keyVersionSize );
            }
            catch (Exception e)
            {
                // TODO:  add proper logging code here.
                Xom.Trace(XomAreaName.cryptotools, LogLevel.L_ERROR,
                    "CryptoTools::ReadPublicKeyFile: (ERROR)  "  + e.ToString() );
            }

            return result;
        }

        // constants
        protected const uint    c_publicKeyMagic    = 0x31415352;
        protected const uint    c_privateKeyMagic   = 0x32415352;
        protected const uint    c_ExponentSize      = 4;

        protected const uint    c_keyVersionSize    = 4;            // key versions are 4 bytes big.
        protected const string  c_MKSymKey          = "XOCryptGenRandom failed!";
        public    const string  c_cspContainerName  = "XOMasterKey";
        public    const uint    c_masterKeySize     = 256;


    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\bignumcb.h ===
//
// Copyright (C) Microsoft
//

#ifndef SIMPLEBIGNUM_H
#define SIMPLEBIGNUM_H

#include "nfkm.h"

#ifndef MAXBIGNUMBITS
#define MAXBIGNUMBITS	4096
#endif
 
struct NFast_Bignum {	/* An 'M_Bignum' is a pointer to this structure */
  int msb_first, msw_first;	/* Format of data in 'bytes' array */
  int nbytes; 			/* Number of bytes in use in 'bytes' */
  unsigned char bytes[MAXBIGNUMBITS/8]; /* Data */
};

/* Bignum send & receive upcalls -------------------------- */

/* As well as being used directly as upcalls,
   these can be used to create bignums from data blocks and
   extract data from bignums.
 */

extern int sbn_bignumreceiveupcall(struct NFast_Application *app,
                               struct NFast_Call_Context *cctx,
                               struct NFast_Transaction_Context *tctx,
                               M_Bignum *bignum, int nbytes,
                               const void *source,
                               int msbitfirst, int mswordfirst);


extern int sbn_bignumsendlenupcall(struct NFast_Application *app,
                               struct NFast_Call_Context *cctx,
                               struct NFast_Transaction_Context *tctx,
                               const M_Bignum *bignum, int *nbytes_r);

extern int sbn_bignumsendupcall(struct NFast_Application *app,
                            struct NFast_Call_Context *cctx,
                            struct NFast_Transaction_Context *tctx,
                            const M_Bignum *bignum, int nbytes,
                            void *dest, int msbitfirst, int mswordfirst);



extern void sbn_bignumfreeupcall(struct NFast_Application *app,
                             struct NFast_Call_Context *cctx,
                             struct NFast_Transaction_Context *tctx,
                             M_Bignum *bignum);

extern int sbn_bignumformatupcall(struct NFast_Application *app,
                              struct NFast_Call_Context *cctx,
                              struct NFast_Transaction_Context *tctx,
                              int *msbitfirst_io, int *mswordfirst_io);


/* Bignum utility functions ----------------------------- */

extern int sbn_char2bignum ( struct NFast_Bignum **ppBN_out,
			const char *text,
			struct NFast_Application *app,
                        struct NFast_Call_Context *cctx,
                        struct NFast_Transaction_Context *tctx );

extern int sbn_bignum2char ( char *buf, int buflen,
			const struct NFast_Bignum *pBN,
			struct NFast_Application *app,
                        struct NFast_Call_Context *cctx,
                        struct NFast_Transaction_Context *tctx );

extern void sbn_printbignum ( FILE *f, 
		const char *prefix, const struct NFast_Bignum *pBN );


extern int sbn_compare ( const struct NFast_Bignum *pA, 
			const struct NFast_Bignum *pB );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\threadcb.cpp ===
//
// Copyright (C) Microsoft
//

#include <precomp.h>
#include "threadcb.h"

int mutex_createupcall(
    struct NFast_Application *a,
    mutex **pm,
    struct NFast_Call_Context *cc)
{
    mutex *m;
    int rc;

    m = (mutex*)NFastApp_Malloc(a, sizeof(*m), cc, 0);
    if (m == 0)
        return Status_NoHostMemory;
    
    m->hMutex = CreateMutex(
        NULL,
        FALSE,  // initial owner.. ?
        NULL);
    if (m->hMutex == NULL)
    {
        NFastApp_Free(a, m, cc, 0);
        return Status_Failed;
    }

    *pm = m;
    return Status_OK;
}

void mutex_destroyupcall(
    struct NFast_Application *a, 
    mutex *m,
    struct NFast_Call_Context *cc)
{
    CloseHandle(m->hMutex);
    NFastApp_Free(a, m, cc, 0);
}

int mutex_lockupcall(
    struct NFast_Application *a, 
    mutex *m,
    struct NFast_Call_Context *cc)
{
    DWORD dwReason = WaitForSingleObject(m->hMutex, INFINITE);
    if (dwReason != WAIT_OBJECT_0)
        return Status_Failed;
    return Status_OK;
}

void mutex_unlockupcall(
    struct NFast_Application *a, 
    mutex *m,
    struct NFast_Call_Context *cc)
{
    ReleaseMutex(m->hMutex);
}

/*
 * Implementing condition variables in Windows is a bit tricky. 
 * See http://www.cs.wustl.edu/~schmidt/win32-cv-1.html for more info.
 *
 *
 * @@@kgoodier @@@dcaifa TODO - code review this.
 */

int cond_createupcall(
     struct NFast_Application *a, 
     cond **pc,
     struct NFast_Call_Context *cc)
{
    cond *c;
    c = (cond*)NFastApp_Malloc(a, sizeof(*c), cc, 0);
    if (c == 0)
        return Status_NoHostMemory;

    c->dwWaitingThreads = 0;
    c->bWasBroadcast = 0;
    c->hSemaphore = CreateSemaphore(
        NULL,
        0,
        0x7FFFFFFF,  // max
        NULL);
    if (c->hSemaphore == NULL)
    {
        NFastApp_Free(a, c, cc, 0);
        return Status_Failed;
    }
    InitializeCriticalSection(&c->lockWaitingThreads);
    c->hWaitingThreadsDoneEvent = CreateEvent(
        NULL,
        FALSE,  // auto reset?
        FALSE,  // signalled initially?
        NULL);
    if (c->hWaitingThreadsDoneEvent == NULL)
    {
        NFastApp_Free(a, c, cc, 0);
        return Status_Failed;
    }

    *pc = c;
    return Status_OK;
}

void cond_destroyupcall(
     struct NFast_Application *a, 
     cond *c,
     struct NFast_Call_Context *cc)
{
    // Any threads still waiting?
    EnterCriticalSection(&c->lockWaitingThreads);
    bool bThreadsAreWaiting = c->dwWaitingThreads > 0;
    LeaveCriticalSection(&c->lockWaitingThreads);

    if (bThreadsAreWaiting)
        return;

    CloseHandle(c->hSemaphore);
    CloseHandle(c->hWaitingThreadsDoneEvent);
    DeleteCriticalSection(&c->lockWaitingThreads);
    NFastApp_Free(a, c, cc, 0);
}

int cond_waitupcall(
     struct NFast_Application *a, 
     cond *c, 
     mutex *m,
     struct NFast_Call_Context *cc)
{    
    int rc = Status_OK;

    // Increment wait count
    EnterCriticalSection(&c->lockWaitingThreads);
    c->dwWaitingThreads++;
    LeaveCriticalSection(&c->lockWaitingThreads);

    // Release mutex and wait on semaphore until signal or broadcast is called
    // by another thread.
    if (SignalObjectAndWait(m->hMutex, c->hSemaphore, INFINITE, FALSE) != WAIT_OBJECT_0)
        rc = Status_Failed;

    // Decrement wait count
    EnterCriticalSection(&c->lockWaitingThreads);
    c->dwWaitingThreads--;
    // Are we the last one?
    bool bLastWaitingThread = c->bWasBroadcast && c->dwWaitingThreads == 0;
    LeaveCriticalSection(&c->lockWaitingThreads);

    if (bLastWaitingThread)
    {
        // Signal event for waiting threads done and wait until mutex acquired.
        if (SignalObjectAndWait(c->hWaitingThreadsDoneEvent, m->hMutex, INFINITE, FALSE) != WAIT_OBJECT_0)
            rc = Status_Failed;
    }
    else
    {
        // Just get external mutex like we're supposed to
        if (WaitForSingleObject(m->hMutex, INFINITE) != WAIT_OBJECT_0)
            rc = Status_Failed;
    }

    return rc;
}

int cond_signalupcall(
     struct NFast_Application *a, 
     cond *c,
     struct NFast_Call_Context *cc)
{
    // Any threads still waiting?
    EnterCriticalSection(&c->lockWaitingThreads);
    bool bThreadsAreWaiting = c->dwWaitingThreads > 0;
    LeaveCriticalSection(&c->lockWaitingThreads);

    // Do nothing if no threads are waiting, otherwise release the semaphore
    if (bThreadsAreWaiting)
    {
        if (!ReleaseSemaphore(c->hSemaphore, 1, 0))
            return Status_Failed;
    }
    
    return Status_OK;
}

int cond_broadcastupcall(
     struct NFast_Application *a, 
     cond *c,
     struct NFast_Call_Context *cc)
{
    BOOL bThreadsAreWaiting = FALSE;
    int rc = Status_OK;

    // Any threads still waiting?
    EnterCriticalSection(&c->lockWaitingThreads);
    if (c->dwWaitingThreads > 0)
    {
        c->bWasBroadcast = TRUE;
        bThreadsAreWaiting = TRUE;

        // Wake up all waiting threads
        if (!ReleaseSemaphore(c->hSemaphore, c->dwWaitingThreads, 0))
            rc = Status_Failed;

        LeaveCriticalSection(&c->lockWaitingThreads);

        // Wait for the threads we just woke up to acqure the semaphore.
        if (WaitForSingleObject(c->hWaitingThreadsDoneEvent, INFINITE) != WAIT_OBJECT_0)
            rc = Status_Failed;

        c->bWasBroadcast = FALSE;
    }
    else
    {
        // Nothing to do
        LeaveCriticalSection(&c->lockWaitingThreads);
    }
    
    return rc;    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\threadcb.h ===
//
// Copyright (C) Microsoft
//

#ifndef THREADCB_H
#define THREADCB_H

#include "nfkm.h"

//This is what nFast has to say about these:
//typedef struct NFast_MutexStruct *NFast_Mutex;
//typedef struct NFast_CondStruct *NFast_Cond;

typedef struct NFast_MutexStruct {
    HANDLE hMutex;
} mutex;

typedef struct NFast_CondStruct {
    DWORD               dwWaitingThreads;
    CRITICAL_SECTION    lockWaitingThreads;
    HANDLE              hSemaphore;
    HANDLE              hWaitingThreadsDoneEvent;
    BOOL                bWasBroadcast;
} cond;

/* Thread / synchronization upcalls -------------------------- */

extern int mutex_createupcall(
    struct NFast_Application *a,
    mutex **m,
    struct NFast_Call_Context *cc);

extern void mutex_destroyupcall(
    struct NFast_Application *a, 
    mutex *m,
    struct NFast_Call_Context *cc);

extern int mutex_lockupcall(
    struct NFast_Application *a, 
    mutex *m,
    struct NFast_Call_Context *cc);

extern void mutex_unlockupcall(
    struct NFast_Application *a, 
    mutex *m,
    struct NFast_Call_Context *cc);

extern int cond_createupcall(
     struct NFast_Application *a, 
     cond **c,
     struct NFast_Call_Context *cc);

extern void cond_destroyupcall(
     struct NFast_Application *a, 
     cond *c,
     struct NFast_Call_Context *cc);

extern int cond_waitupcall(
     struct NFast_Application *a, 
     cond *c, 
     NFast_Mutex m,
     struct NFast_Call_Context *cc);

extern int cond_signalupcall(
     struct NFast_Application *a, 
     cond *c,
     struct NFast_Call_Context *cc);

extern int cond_broadcastupcall(
     struct NFast_Application *a, 
     cond *c,
     struct NFast_Call_Context *cc);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\XmacsCrypto.h ===
//
// Copyright (C) Microsoft
//

#pragma once

#ifndef NCAPI
#define NCAPI __stdcall
#endif

BOOL NCAPI XmacsCryptoInit(BOOL fUseTestKey, BOOL fUseNcipher);
VOID NCAPI XmacsCryptoTerm();
BOOL NCAPI XmacsCryptoDecryptWithXmacsKey( IN BYTE* pbCipherText, IN DWORD cbCipherText, OUT BYTE* pbPlainText, OUT DWORD* pcbPlainText, IN DWORD cbPlainTextBuffer );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\XeNcipher.h ===
//
// Copyright (C) Microsoft
//

// Errors -------------------------------------------------------------------

#pragma once

typedef DWORD NCERROR;
#define NCERROR_NOERROR                         0
#define NCERROR_NOT_INITIALIZED                 1
#define NCERROR_KEY_NOT_FOUND                   2
#define NCERROR_INVALID_KEY_TYPE                3
#define NCERROR_OUTPUT_BUFFER_TOO_SMALL         4
#define NCERROR_INVALID_ENCRYPTION_TYPE         5
#define NCERROR_UNEXPECTED                      999

// HNCKEY
typedef VOID* HNCKEY;

// NCKEY_TYPE
// Type of the key. 
enum NCKEY_TYPE
{
    NCKEY_TYPE_PUBLIC    = 1,
    NCKEY_TYPE_PRIVATE   = 2,
    NCKEY_TYPE_SYMMETRIC = 3,
};

// Type of encryption operation to perform
enum NCENCRYPT_TYPE
{
    NCENCRYPT_TYPE_RSA      = 1,
    NCENCRYPT_TYPE_3DES     = 2,
};

#define NCAPI   __stdcall

// Functions
NCERROR NCAPI   NcInit();
VOID NCAPI      NcTerm();
NCERROR NCAPI   NcOpenKey( IN LPSTR keyApp, IN LPSTR keyName, IN NCKEY_TYPE keyType, OUT HNCKEY* phKey );
NCERROR NCAPI   NcCloseKey( HNCKEY hKey );
NCERROR NCAPI   NcEncrypt( IN HNCKEY hKey, IN NCENCRYPT_TYPE encryptType, IN BYTE* pbPlainText, IN DWORD cbPlainText, OUT BYTE* pbCipherText, OUT DWORD* pcbCipherText, IN DWORD cbCipherTextBuffer );
NCERROR NCAPI   NcDecrypt( IN HNCKEY hKey, IN BYTE* pbCipherText, IN DWORD cbCipherText, OUT BYTE* pbPlainText, OUT DWORD* pcbPlainText, IN DWORD cbPlainTextBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\XeNcipher.cpp ===
//
// Copyright (C) Microsoft
//

#include "precomp.h"
#include "XeNcipher.h"
#include "nfkm.h"
#include "bignumcb.h"

// Define USETHREADUPCALLS to use the nCipher mutex/cond upcalls for synchronization.
// If this is not defined, we will fall back to using a critical section around the
// nCipher Transact function.  This has the downside of only working for this chunk
// of code -- any other programs/routines that also use nCipher concurrently may
// run into thread synch problems (the invisible dialog problem). 

#ifdef USETHREADUPCALLS
#include "threadcb.h"
#endif

// Definitions {{{-----------------------------------------------------------

// NCKEY
// Internal key structure. It's this thing that we hand out to the caller but 
// in the form of a HNCKEY.
struct NCKEY
{
    M_KeyID key;
};

//}}}
// Globals {{{---------------------------------------------------------------

static volatile LONG            g_lNcInitRefCount;
static NFast_AppHandle          g_NcAppHandle = NULL;
static NFastApp_Connection      g_NcAppConnect = NULL;
static NFKM_WorldInfo*          g_pNfkmWorldInfo = NULL;

#ifndef USETHREADUPCALLS
static CRITICAL_SECTION         g_NcLock;
#endif

// }}}
// Forward Declarations {{{--------------------------------------------------

LOCAL NCERROR      LoadKey         ( IN NFKM_Key* pKey, IN NCKEY_TYPE keyType, OUT M_KeyID* pKeyId );
LOCAL NCERROR      LoadCardSet     ( IN NFKM_ModuleInfo* pModuleInfo, IN NFKM_Key* pKey, OUT M_KeyID* pkidToken );

//}}}

int Transact(NFastApp_Connection conn,
             struct NFast_Call_Context *cctx,
             const M_Command *command,
             M_Reply *reply,
             struct NFast_Transaction_Context *tctx)
{
    int rc;
#ifdef USETHREADUPCALLS
    rc = NFastApp_Transact(conn, cctx, command, reply, tctx);
#else
    EnterCriticalSection(&g_NcLock);
    rc = NFastApp_Transact(conn, cctx, command, reply, tctx);
    LeaveCriticalSection(&g_NcLock);
#endif
    return rc;
}

// Function NcInit {{{-------------------------------------------------------
// Initialize nCipher. Needs to be called before anything else.  
NCERROR
NCAPI
NcInit()
{
    NCERROR error = NCERROR_UNEXPECTED;
    int rc;

    if(InterlockedIncrement(&g_lNcInitRefCount) != 1)
        return NCERROR_NOERROR;

    NcAssert(g_NcAppHandle == NULL);

    rc = NFastApp_Init(&g_NcAppHandle, NULL, NULL, NULL, NULL);
    if(rc != Status_OK)
    {
        NcTrace("NFastApp_Init failed. rc = %d", rc);
        goto cleanup;
    }

    rc = NFastApp_SetBignumUpcalls(g_NcAppHandle,
                                   sbn_bignumreceiveupcall,
                                   sbn_bignumsendlenupcall,
                                   sbn_bignumsendupcall,
                                   sbn_bignumfreeupcall,
                                   sbn_bignumformatupcall,
                                   NULL);
    
    if(rc != Status_OK)
    {
        NcTrace("NFastApp_SetBignumUpcalls failed. rc = %d", rc);
        goto cleanup;
    }

#ifdef USETHREADUPCALLS
    // This is probably the "best" way to do the synchronization, and it seems to work.
    // @@@kgoodier @@@dcaifa TODO - code review this
    rc = NFastApp_SetThreadUpcalls(
        g_NcAppHandle,
        mutex_createupcall,
        mutex_destroyupcall,
        mutex_lockupcall,
        mutex_unlockupcall,
        cond_createupcall,
        cond_destroyupcall,
        cond_waitupcall,
        cond_signalupcall,
        cond_broadcastupcall,
        NULL);
    if(rc != Status_OK)
    {
        NcTrace("NFastApp_SetThreadUpcalls failed. rc = %d", rc);
        goto cleanup;
    }
#endif

    rc = NFKM_getinfo(g_NcAppHandle, &g_pNfkmWorldInfo, 0);
    if(rc != Status_OK)
    {
        NcTrace("NFKM_getinfo failed. rc = %d", rc);
        goto cleanup;
    }
    
    if(!(g_pNfkmWorldInfo->flags & WorldInfo_flags_Usable))
    {
        NcTrace("World is not available");
        goto cleanup;
    }

    rc = NFastApp_Connect(g_NcAppHandle,
                          &g_NcAppConnect,
                          NFastApp_ConnectionFlags_ForceClientID, 
                          0);
    if(rc != Status_OK)
    {
        NcTrace("NFastApp_Connect failed. rc = %d", rc);
        goto cleanup;
    }

    error = NCERROR_NOERROR;

#ifndef USETHREADUPCALLS
    InitializeCriticalSection(&g_NcLock);
#endif

cleanup:

    if(error != NCERROR_NOERROR)
        NcTerm();

    return error; 
} 

//}}}
// Function NcTerm {{{------------------------------------------------------
VOID
NCAPI
NcTerm()
{
    if(g_lNcInitRefCount == 0 ||
       InterlockedDecrement(&g_lNcInitRefCount) > 0 ||
       g_NcAppHandle == NULL)
    {
        return;
    }

    if (g_pNfkmWorldInfo != NULL)
    {
        NFKM_freeinfo(g_NcAppHandle, &g_pNfkmWorldInfo, NULL);
    }

    if (g_NcAppConnect != NULL)
    {
        NFastApp_Disconnect(g_NcAppConnect, NULL);
    }

    NFastApp_Finish(g_NcAppHandle, NULL);

#ifndef USETHREADUPCALLS
    DeleteCriticalSection(&g_NcLock);
#endif

    NcTrace("NcTerm succeeded");
}

//}}}
// Function NcOpenKey {{{----------------------------------------------------
// Open/Load a key in the nCipher module and return a handle to that key. The 
// handle can be used in encrypt/decrypt/sign/verify functions. The key handle 
// must be released using NcCloseKey.
NCERROR
NCAPI
NcOpenKey(
    IN LPSTR        keyApp,
    IN LPSTR        keyName,
    IN NCKEY_TYPE   keyType,
    OUT HNCKEY*     phKey
)
{
    NCKEY*          pnckey = NULL;
    NFKM_Key*       pKey = NULL;
    NFKM_KeyIdent   keyid;
    M_KeyID         key;
    int             rc;
    NCERROR         error = NCERROR_UNEXPECTED;
    
    if(!g_lNcInitRefCount)
    {
        error = NCERROR_NOT_INITIALIZED;
        goto cleanup;
    }
    
    // Find the key
    memset(&keyid, 0, sizeof(keyid));
    keyid.appname = keyApp;
    keyid.ident   = keyName;

    rc = NFKM_findkey(g_NcAppHandle, keyid, &pKey, 0);
    if(rc != Status_OK)
    {
        NcTrace("NFKM_findkey failed. rc = %d", rc);
        goto cleanup;
    }
    
    if(!pKey)
    {
        NcTrace("Key not found");
        error = NCERROR_KEY_NOT_FOUND;
        goto cleanup;
    }
    
    // Load the key
    error = LoadKey(pKey, keyType, &key);
    if(error != NCERROR_NOERROR)
    {
        NcTrace("LoadKey failed. error = %u", error);
        goto cleanup;
    }
    error = NCERROR_UNEXPECTED;

    // Return the key to the caller in form of a handle (HNCKEY)
    pnckey = (NCKEY*) malloc(sizeof(NCKEY));
    if(!pnckey)
    {
        NcTrace("Failed to allocate NCKEY");
        goto cleanup;
    }
    memset(pnckey, 0, sizeof(NCKEY));
    pnckey->key = key;
    *phKey = (HNCKEY) pnckey;
    pnckey = NULL;

    error = NCERROR_NOERROR;
    
cleanup:
    
    if(pnckey) free(pnckey);
    if(pKey) NFKM_freekey(g_NcAppHandle, pKey, NULL);

    return error;
} 

//}}}
// Function NcCloseKey {{{----------------------------------------------------
// Close key that was opened by NcOpenKey
NCERROR
NCAPI
NcCloseKey(
    HNCKEY hKey
)
{
    if(hKey != NULL)
    {
        free((NCKEY*)hKey);
    }

    return NCERROR_NOERROR;
}

//}}}
// Function NcEncrypt {{{----------------------------------------------------
// Encrypt a blob using a private key
NCERROR
NCAPI
NcEncrypt(
    IN HNCKEY   hKey,
    IN NCENCRYPT_TYPE encryptType,
    IN BYTE*    pbPlainText,
    IN DWORD    cbPlainText,
    OUT BYTE*   pbCipherText,
    OUT DWORD*  pcbCipherText,
    IN DWORD    cbCipherTextBuffer
)
{
    NcAssert(hKey);
    NcAssert(pbPlainText);
    NcAssert(cbPlainText > 0);
    NcAssert(pbCipherText);
    NcAssert(pcbCipherText);
    NcAssert(cbCipherTextBuffer > 0);

    NCERROR         error = NCERROR_UNEXPECTED;
    NCKEY*          pKey = (NCKEY*) hKey;
    M_Command       cmd;
    M_Reply         reply;
    M_PlainText*    ppt = NULL;
    M_CipherText*   pct = NULL;
    BYTE*           pb;
    DWORD           cb;
    int             rc;
    
    memset(&cmd, 0, sizeof(cmd));
    memset(&reply, 0, sizeof(reply));
    
    if(!g_lNcInitRefCount)
    {
        error = NCERROR_NOT_INITIALIZED;
        goto cleanup;
    }
    
    // Prepare encrypt command
    cmd.cmd                 = Cmd_Encrypt;
    cmd.args.encrypt.key    = pKey->key;

    switch (encryptType)
    {
    case NCENCRYPT_TYPE_RSA:
        cmd.args.encrypt.mech = Mech_RSApPKCS1OAEP;
        break;

    case NCENCRYPT_TYPE_3DES:
        cmd.args.encrypt.mech = Mech_DES3mCBCpNONE;
        cmd.args.encrypt.flags |= Cmd_Encrypt_Args_flags_given_iv_present;
        cmd.args.encrypt.given_iv = (M_IV *)malloc(sizeof(M_IV));
        if (cmd.args.encrypt.given_iv == NULL)
        {
            NcTrace("Failed to allocate given_iv");
            goto cleanup;
        }
        cmd.args.encrypt.given_iv->mech = cmd.args.encrypt.mech;
        memset(cmd.args.encrypt.given_iv, 0, 8);
        break;

    default:
        NcTrace("Invalid encryption type %u", encryptType);
        error = NCERROR_INVALID_ENCRYPTION_TYPE;
        goto cleanup;
    }
    
    ppt = &cmd.args.encrypt.plain;
    ppt->type = PlainTextType_Bytes;
    ppt->data.bytes.data.len = cbPlainText;
    ppt->data.bytes.data.ptr = pbPlainText; 

    rc = Transact(g_NcAppConnect, 0, &cmd, &reply, 0);

    if(rc != Status_OK)
    {
        NcTrace("NFastApp_Transact failed. rc = %d", rc);
        goto cleanup;
    }
    
    if(reply.status != Status_OK)
    {
        NcTrace("Reply contains error status = %d", reply.status);
        goto cleanup;
    }

    pct = &reply.reply.encrypt.cipher;
    if(pct->mech != cmd.args.encrypt.mech)
    {
        NcTrace("Bad reply. Wrong mech %d", (int)pct->mech);
        goto cleanup;
    }

    switch(encryptType)
    {
    case NCENCRYPT_TYPE_RSA:
        pb = pct->data.rsappkcs1.m->bytes;
        cb = (unsigned) pct->data.rsappkcs1.m->nbytes;
        break;

    case NCENCRYPT_TYPE_3DES:
        pb = pct->data.generic64.cipher.ptr;
        cb = pct->data.generic64.cipher.len;
        break;

    default:
        NcTrace("Invalid encryption type %u", encryptType);
        error = NCERROR_INVALID_ENCRYPTION_TYPE;
        goto cleanup;
    }
    

    if(cbCipherTextBuffer < cb)
    {
        NcTrace("Insufficent buffer space in pbCipherText. cbCipherTextBuffer=%u, cb=%u", cbCipherTextBuffer, cb);
        error = NCERROR_OUTPUT_BUFFER_TOO_SMALL;
        goto cleanup;
    }

    // Copy ciphertext to caller's buffer
    memcpy(pbCipherText, pb, cb);
    *pcbCipherText = cb;

    error = NCERROR_NOERROR;

cleanup:

    NFastApp_Free_Reply(g_NcAppHandle, NULL, NULL, &reply);
    
    if (cmd.args.encrypt.mech == Mech_DES3mCBCpNONE)
    {
        free(cmd.args.encrypt.given_iv);
    }

    return error;
}

//}}}
// Function NcDecrypt {{{----------------------------------------------------
NCERROR
NCAPI
NcDecrypt(
    IN HNCKEY   hKey,
    IN BYTE*    pbCipherText,
    IN DWORD    cbCipherText,
    OUT BYTE*   pbPlainText,
    OUT DWORD*  pcbPlainText,
    IN DWORD    cbPlainTextBuffer
)
{
    NcAssert(hKey);

    NCERROR         error = NCERROR_UNEXPECTED;
    NCKEY*          pKey = (NCKEY*) hKey;
    M_Command       cmd;
    M_Reply         reply;
    M_PlainText*    ppt = NULL;
    M_CipherText*   pct = NULL;
    BYTE*           pb;
    DWORD           cb;
    int             rc;
    
    if(!g_lNcInitRefCount)
    {
        error = NCERROR_NOT_INITIALIZED;
        goto cleanup;
    }

    memset(&cmd, 0, sizeof(cmd));
    memset(&reply, 0, sizeof(reply));

    cmd.cmd                     = Cmd_Decrypt;
    cmd.args.decrypt.key        = pKey->key;
    cmd.args.decrypt.mech       = Mech_RSApPKCS1OAEP;
    cmd.args.decrypt.reply_type = PlainTextType_Bytes;
    
    pct = &cmd.args.decrypt.cipher;
    pct->mech = Mech_RSApPKCS1OAEP;
    // This allocates memory to pct->data.rsappkdc1.m
    rc = sbn_bignumreceiveupcall(g_NcAppHandle,
                                 NULL,
                                 NULL,
                                 &pct->data.rsappkcs1.m,
                                 cbCipherText,
                                 pbCipherText,
                                 0,
                                 0);

    if(rc != Status_OK)
    {
        NcTrace("sbn_bignumreceiveupcall failed. rc = %d", rc);
        goto cleanup;
    }

    rc = Transact(g_NcAppConnect, 0, &cmd, &reply, 0);

    if(rc != Status_OK)
    {
        NcTrace("NFastApp_Transact failed. rc = %d", rc);
        goto cleanup;
    }
    
    if(reply.status != Status_OK)
    {
        NcTrace("Reply contains error status = %d", reply.status);
        goto cleanup;
    }

    ppt = &reply.reply.decrypt.plain;
    if(ppt->type != PlainTextType_Bytes)
    {
        NcTrace("Invalid plaintext type %u", (ULONG)ppt->type);
        goto cleanup;
    }

    pb = ppt->data.bytes.data.ptr;
    cb = (DWORD)ppt->data.bytes.data.len;

    if(cbPlainTextBuffer < cb)
    {
        NcTrace("Output buffer is too small. cbPlainTextBuffer=%u, cb=%u", cbPlainTextBuffer, cb);
        error = NCERROR_OUTPUT_BUFFER_TOO_SMALL;
    }
    
    // Copy plaintext to caller's buffer
    memcpy(pbPlainText, pb, cb);
    *pcbPlainText = cb;

    error = NCERROR_NOERROR;

cleanup:

    // @@@kgoodier @@@dcaiafa TODO - do we need to clean up pct->data.rsappkcs1.m from the sbn_bignumreceiveupcall() function?
    // Removed for now at tonychen's request, dcaifa sould look at this and see if it is necessary or if NFastApp_Free_Command() 
    // will clean this up for us.
    //sbn_bignumfreeupcall(g_NcAppHandle, NULL, NULL, &pct->data.rsappkcs1.m);

    NFastApp_Free_Command(g_NcAppHandle, NULL, NULL, &cmd);
    NFastApp_Free_Reply(g_NcAppHandle, NULL, NULL, &reply);

    return error;
}

//}}}
// Function LoadKey {{{------------------------------------------------------
// Load a key into the module and return the ncipher key id 
LOCAL
NCERROR
LoadKey(
    IN NFKM_Key*    pKey,
    IN NCKEY_TYPE   keyType,
    OUT M_KeyID*    pKeyId
)
{
    NFKM_ModuleInfo*    pModuleInfo = NULL;
    M_KeyID             kidToken = 0;
    M_ByteBlock*        pBlob = NULL;
    int i;
    int rc;
    NCERROR error = NCERROR_UNEXPECTED;

    rc = NFKM_getinfo(g_NcAppHandle, &g_pNfkmWorldInfo, 0);
    if(rc != Status_OK)
    {
        NcTrace("NFKM_getinfo failed. rc = %d", rc);
        goto cleanup;
    }

    for(i=0; i < g_pNfkmWorldInfo->n_modules; i++)
    {
        if(g_pNfkmWorldInfo->modules[i]->state == ModuleState_Usable)
        {
            pModuleInfo = g_pNfkmWorldInfo->modules[i];
            break;
        }
    }

    if(!pModuleInfo)
    {
        NcTrace("Couldn't find an usable module");
        goto cleanup;
    }
    
    // If key requires a card, get a logical token from the card currently 
    // inserted in the module
    if(pKey->flags & Key_flags_ProtectionCardSet)
    {
        error = LoadCardSet(pModuleInfo, pKey, &kidToken);
        if(error != NCERROR_NOERROR)
        {
            goto cleanup;
        }
        NcAssert(kidToken != 0);
        error = NCERROR_UNEXPECTED;
    }

    switch(keyType)
    {
    case NCKEY_TYPE_SYMMETRIC:
    case NCKEY_TYPE_PRIVATE:
        pBlob = &pKey->privblob;
        break;
    case NCKEY_TYPE_PUBLIC:
        pBlob = &pKey->pubblob;
        break;
    default:
        NcTrace("Invalid key type %u", keyType);
        error = NCERROR_INVALID_KEY_TYPE;
        goto cleanup;
    }

    rc = NFKM_cmd_loadblob(g_NcAppHandle,
                           g_NcAppConnect,
                           pModuleInfo->module,
                           pBlob,
                           kidToken,
                           pKeyId,
                           "Loading key",
                           0);

    if(rc != Status_OK)
    {
        NcTrace("NFKM_cmd_loadblob failed. rc = %d", rc);
        goto cleanup;
    }

    NcTrace("key [%s,%s,%u] loaded sucessfully. Id = %u", pKey->appname, pKey->ident, (ULONG)keyType, (ULONG)*pKeyId);
    error = NCERROR_NOERROR;

cleanup:

    return error;
} 

//}}}
// Function LoadCardSet {{{ -------------------------------------------------
// Load a cardset for a key in a module and return a logical token
LOCAL
NCERROR
LoadCardSet(
    IN NFKM_ModuleInfo*     pModuleInfo,
    IN NFKM_Key*            pKey, 
    OUT M_KeyID*            pkidToken
)
{
    NFKM_LoadCSHandle   hCardSet = NULL;
    NFKM_SlotInfo*      pSlotInfo = NULL;
    NFKM_CardSet*       pCardSet = NULL;
    int                 iCardsLeft = 0;
    NCERROR             error = NCERROR_NOERROR;
    int                 rc;

    if(pModuleInfo->n_slots == 0)
    {
        NcTrace("Key requires card but module has no slots");
        goto cleanup;
    }

    pSlotInfo = pModuleInfo->slots[0];

    rc = NFKM_findcardset(g_NcAppHandle, &pKey->cardset, &pCardSet, NULL);
    if(rc != Status_OK)
    {
        NcTrace("NFKM_findcardset failed. rc = %d", rc);
        goto cleanup;
    }
    
    if(!pCardSet)
    {
        NcTrace("Coudn't find cardset");
        goto cleanup;
    }
    
    rc = NFKM_loadcardset_begin(g_NcAppHandle,
                                g_NcAppConnect, 
                                pModuleInfo,
                                pCardSet,
                                &hCardSet,
                                0);

    if(rc != Status_OK)
    {
        NcTrace("NFKM_loadcardset_begin failed. rc = %d", rc);
        goto cleanup;
    }

    if(pSlotInfo->slotstate != SlotState_Operator)
    {
        NcTrace("Bad slot state. Is there a card on the slot?. state = %u", pSlotInfo->slotstate);
        goto cleanup;
    }

    if(memcmp(pSlotInfo->cardset->hkltu.bytes,
              pCardSet->hkltu.bytes,
              sizeof(pCardSet->hkltu.bytes)) != 0)
    {
        NcTrace("Operator card belongs to a different cardset ('%s')", pSlotInfo->cardset->name);
        goto cleanup;
    }

    if(pSlotInfo->pp)
    {
        NcTrace("Card requires pass phrase. This is not supported.");
        goto cleanup;
    }

    rc = NFKM_loadcardset_nextcard(hCardSet, 
                                   pSlotInfo,
                                   NULL,
                                   &iCardsLeft);

    if(rc != Status_OK)
    {
        NcTrace("NFKM_loadcardset_nextcard failed. rc = %d", rc);
        goto cleanup;
    }

    if(iCardsLeft)
    {
        NcTrace("Key requires more than one card. This is not supported.");
        goto cleanup;
    }

    rc = NFKM_loadcardset_done(hCardSet, pkidToken);
    if(rc != Status_OK)
    {
        NcTrace("NFKM_loadcardset_done failed. rc = %d", rc);
        goto cleanup;
    }

    error = NCERROR_NOERROR;

cleanup:

    if(pCardSet) NFKM_freecardset(g_NcAppHandle, pCardSet, NULL);

    return error;
} 
//}}}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\XmacsCrypto.cpp ===
//
// Copyright (C) Microsoft
//

#include <precomp.h>
#include <cryptohelper.h>
#include "XeNcipher.h"
#include "XmacsCrypto.h"

// Config
static BOOL     g_fXmacsCryptoInitialized           = FALSE;
static BOOL     g_fXmacsCryptoUseTestKey            = FALSE;
static BOOL     g_fXmacsCryptoUseNcipher            = TRUE;

// Key details
static WCHAR    g_szXmacsCryptoCapiContainerTestXmacsKey[100] = TEST_KEY_CONTAINER_XMACS_ENCRYPT;
static CHAR     g_szXmacsCryptoNcipherApp[100] = "xbox";
static CHAR     g_szXmacsCryptoNcipherNameTestXmacsKey[100] = "masterxmacskeytest";
static CHAR     g_szXmacsCryptoNcipherNameXmacsKey[100] = "masterxmacskey";

// Keys
CXoCryptoCspPk* g_pXmacsCryptoCspTestKey     = NULL;
HNCKEY          g_hXmacsCryptoNcipherTestKey = NULL;
HNCKEY          g_hXmacsCryptoNcipherRealKey = NULL;

BOOL
NCAPI
XmacsCryptoInit(
    BOOL fUseTestKey,
    BOOL fUseNcipher
)
{
    NCERROR ncerr;
    CXoCryptoCspPk::OpenContainerStatus ocstatus;
    BOOL ret = FALSE;

    if(g_fXmacsCryptoInitialized)
        return TRUE;

    g_fXmacsCryptoUseTestKey = fUseTestKey;
    g_fXmacsCryptoUseNcipher = fUseNcipher;

    if(!g_fXmacsCryptoUseTestKey
        && !g_fXmacsCryptoUseNcipher)
    {
        XomNtEvent(XEVENT_COMMON_CONFIG_244, "XmacsCryptoInit: Xmacs is configured to not use test key but it's also configured to not use the nCipher");
        goto cleanup;
    }

    if(g_fXmacsCryptoUseTestKey)
        XomNtEvent(XEVENT_COMMON_CONFIG_245, "XmacsCryptoInit: SECURITY RISK! Xmacs is configured to use test key");

    if(!g_fXmacsCryptoUseNcipher)
        XomNtEvent(XEVENT_COMMON_CONFIG_246, "XmacsCryptoInit: SECURITY RISK! Xmacs is configured to NOT use the nCipher");

    if(g_fXmacsCryptoUseNcipher)
    {
        XomNtEvent(XEVENT_COMMON_INFO_37, "Initializing nCipher");
        ncerr = NcInit();
        if(ncerr != NCERROR_NOERROR)
        {
            XomNtEvent(XEVENT_COMMON_CONFIG_247, "NcInit failed. err = %u", ncerr);
            goto cleanup;
        }

#if XMACS_CRYPTO_USE_NCIPHER_TEST_KEY
        // nCipher, test key
        if(g_fXmacsCryptoUseTestKey)
        {
            XomNtEvent(XEVENT_COMMON_INFO_38, "Initializing nCipher's xmacs test key");
            ncerr = NcOpenKey(g_szXmacsCryptoNcipherApp,
                              g_szXmacsCryptoNcipherNameTestXmacsKey,
                              NCKEY_TYPE_PRIVATE,
                              &g_hXmacsCryptoNcipherTestKey);

            if(ncerr != NCERROR_NOERROR)
            {
                XomNtEvent(XEVENT_COMMON_CONFIG_248, "NcOpenKey failed. err = %u", err);
                goto cleanup;
            }
        }
#endif

        // nCipher, real key
        XomNtEvent(XEVENT_COMMON_INFO_39, "Initializing nCipher's xmacs key");
        ncerr = NcOpenKey(g_szXmacsCryptoNcipherApp,
                          g_szXmacsCryptoNcipherNameXmacsKey,
                          NCKEY_TYPE_PRIVATE,
                          &g_hXmacsCryptoNcipherRealKey);

        if(ncerr != NCERROR_NOERROR)
        {
            XomNtEvent(XEVENT_COMMON_CONFIG_249, "NcOpenKey failed. err = %u", ncerr);
            goto cleanup;
        }
    }
#if XMACS_CRYPTO_USE_NCIPHER_TEST_KEY
    else
#endif
    {
        if(g_fXmacsCryptoUseTestKey)
        {
            XomNtEvent(XEVENT_COMMON_INFO_40, "Initializing CAPI's xmacs test key");

            g_pXmacsCryptoCspTestKey = new CXoCryptoCspPk();
            if(!g_pXmacsCryptoCspTestKey)
            {
                XomNtEvent(XEVENT_COMMON_CODE_22, "Failed to allocate g_pXmacsCryptoCspTestKey");
                goto cleanup;
            }

            ocstatus = g_pXmacsCryptoCspTestKey->OpenContainer(
                    g_szXmacsCryptoCapiContainerTestXmacsKey,
                    MS_ENHANCED_PROV,
                    true);

            if(ocstatus != CXoCryptoCspPk::OpenContainerSuccess)
            {
                XomNtEvent(XEVENT_COMMON_CONFIG_250, "g_pXmacsCryptoCspTestKey->OpenContainer failed. ocstatus = %u", ocstatus);
                goto cleanup;
            }
        }
    }
    
    g_fXmacsCryptoInitialized = TRUE;
    ret = TRUE;

cleanup:

    if(!ret)
    {
        XmacsCryptoTerm();
    }

    return ret;
}
    
VOID
NCAPI
XmacsCryptoTerm()
{
    if(g_pXmacsCryptoCspTestKey)
    {
        delete g_pXmacsCryptoCspTestKey;
        g_pXmacsCryptoCspTestKey = NULL;
    }

    if(g_hXmacsCryptoNcipherTestKey)
    {
        NcCloseKey(g_hXmacsCryptoNcipherTestKey);
        g_hXmacsCryptoNcipherTestKey = NULL; 
    }
    
    if(g_hXmacsCryptoNcipherRealKey)
    {
        NcCloseKey(g_hXmacsCryptoNcipherRealKey);
        g_hXmacsCryptoNcipherRealKey = NULL;
    }
    
    NcTerm();
}

BOOL
NCAPI
XmacsCryptoDecryptWithXmacsKey(
    IN BYTE* pbCipherText,
    IN DWORD cbCipherText,
    OUT BYTE* pbPlainText,
    OUT DWORD* pcbPlainText,
    IN DWORD cbPlainTextBuffer
)
{
    NCERROR ncerr1 = 0, ncerr2 = 0;
    bool fCsp = false;

    if(!g_fXmacsCryptoInitialized)
    {
        XomNtEvent(XEVENT_COMMON_CODE_23, "XmacsCryptoDecryptWithXmacsKey: XmacsCrypto was not initialized");
        return FALSE;
    }

    if(g_hXmacsCryptoNcipherRealKey)
    {
        ncerr1 = NcDecrypt(g_hXmacsCryptoNcipherRealKey,
                           pbCipherText,
                           cbCipherText,
                           pbPlainText,
                           pcbPlainText,
                           cbPlainTextBuffer);

        if(ncerr1 == NCERROR_NOERROR)
        {
            return TRUE;
        }
    }
        
#if XMACS_CRYPTO_USE_NCIPHER_TEST_KEY
    if(g_hXmacsCryptoNcipherTestKey)
    {
        ncerr2 = NcDecrypt(g_hXmacsCryptoNcipherTestKey,
                           pbCipherText,
                           cbCipherText,
                           pbPlainText,
                           pcbPlainText,
                           cbPlainTextBuffer);
        if(ncerr2 == NCERROR_NOERROR)
        {
            return TRUE;
        }
    }
#endif
    
    if(g_pXmacsCryptoCspTestKey)
    {
        if(cbPlainTextBuffer < cbCipherText)
        {
            XomNtEvent(XEVENT_COMMON_CODE_24, "XmacsCryptoDecryptWithXmacsKey: plain-text buffer is too small");
            return FALSE;
        }
        memcpy(pbPlainText, pbCipherText, cbCipherText);
        *pcbPlainText = cbPlainTextBuffer;
        fCsp = g_pXmacsCryptoCspTestKey->Decrypt(pbPlainText,
                                                 pcbPlainText);

        if(fCsp)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xecrypto_none_12.4.56.0_none_a21eb7ae08442588
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xecrypto
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4.manifest
XP_MANIFEST_PATH=manifests\x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4.cat
XP_CATALOG_PATH=manifests\x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4.cat
XP_PAYLOAD_PATH=x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xecrypto,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\dll\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\dll\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\crypto\XeCrypto\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_xecrypto_none_12.4.56.0_none_a21eb7ae08442588
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=xecrypto
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4.manifest
XP_MANIFEST_PATH=manifests\x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4.cat
XP_CATALOG_PATH=manifests\x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4.cat
XP_PAYLOAD_PATH=x86_xecrypto_no-public-key_12.4.56.0_x-ww_61ebd6a4
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=xecrypto,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\puidmgr\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\puidmgr\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__puidmgr_3_none_12.4.56.0_none_df2c7970c8db5aa5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_puidmgr_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03.manifest
XP_MANIFEST_PATH=manifests\x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03.cat
XP_CATALOG_PATH=manifests\x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03.cat
XP_PAYLOAD_PATH=x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_puidmgr_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\puidmgr\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86__puidmgr_3_none_12.4.56.0_none_df2c7970c8db5aa5
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=_puidmgr_3
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03.manifest
XP_MANIFEST_PATH=manifests\x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03.cat
XP_CATALOG_PATH=manifests\x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03.cat
XP_PAYLOAD_PATH=x86__puidmgr_3_no-public-key_12.4.56.0_x-ww_e6406c03
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=_puidmgr_3,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\puidmgr\PUIDMgr.cs ===
///
///  PUIDMgr.cs :  Declaration and implementation of the PUID manager class.
///
///  Date:  April 12/2002
///  Dev:  lohab
///  Copyright (c) Microsoft Corporation.  All rights reserved.
///
using System;
using System.Data;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Runtime.InteropServices;

using xonline.common.config;
using xonline.common.service;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.puidmgr)]

namespace xonline.common.puidmgr
{
    /// <summary>
    /// PUIDMgr class should be used to retrieve and manage the use of PUIDs by a C# server.
    /// servers should only have to call GetNewPUID(), the manager should take care of the rest.
    /// This is a singleton class and can only be created using the static methods.
    /// </summary>
    public class PUIDMgr
    {
        public const ulong PUID_BASE_MASK  = 0xFFFF000000000000;
        public const ulong PUID_BASE_XBOX  = 0x0009000000000000;
        public const ulong PUID_BASE_XENON = 0xFA00000000000000;

        public static bool IsXenonMachinePuid(ulong puid)
        {
            return ((puid & PUID_BASE_MASK) == PUID_BASE_XENON);
        }

        public static bool IsXboxPuid(ulong puid)
        {
            return ((puid & PUID_BASE_MASK) == PUID_BASE_XBOX);
        }

        // static constructor.
        static PUIDMgr()
        {
            m_nextPUID = 0;
            m_numPUIDAvailable = 0;
        }

        /// <summary>
        /// GetNewPUID():  Gets the next PUID available.  If none are available, it reads a block of PUIDS out of the db.
        /// </summary>
        /// <returns>The next available PUID.</returns>
        public static ulong GetNewPUID()
        {
            ulong res = 0;

            // this section should be atomic.
            lock( typeof(PUIDMgr) )
            {
                // check for available PUIDs
                if ( m_numPUIDAvailable == 0 )
                {
                    //  get a new PUID block from the NPDB
                    GetPUIDBlock();
                }

                // we got a PUID... return the value
                res = m_nextPUID;
                Debug.Assert( IsXboxPuid(res) );
                m_nextPUID++;
                m_numPUIDAvailable--;
                Xom.Trace(XomAreaName.puidmgr, LogLevel.L_INFO, "Returning PUID:  " + res + "  \nOnly " + m_numPUIDAvailable + " PUIDs remaining." );
            }

            return res;
        }

        /// <summary>
        /// GetNewXenonPuid():  Gets the next Xenon PUID available.  If none are available, it reads a block of Xenon PUIDS out of the db.
        /// </summary>
        /// <returns>The next available Xenon PUID.</returns>
        public static ulong GetNewXenonPuid()
        {
            ulong puid = 0;

            // this section should be atomic.
            lock( typeof(PUIDMgr) )
            {
                // check for available PUIDs
                if ( m_numXenonPuidsAvailable == 0 )
                {
                    //  get a new Xenon PUID block from the NPDB
                    GetXenonPuidBlock();
                }

                // we got a PUID... return the value
                puid = m_nextXenonPuid;
                Debug.Assert( IsXenonMachinePuid(puid) );

                m_nextXenonPuid++;
                m_numXenonPuidsAvailable--;
                Xom.Trace(XomAreaName.puidmgr, LogLevel.L_INFO, "Returning Xenon PUID: 0x" + puid.ToString("X") + "  \nOnly " + m_numXenonPuidsAvailable + " Xenon PUIDs remaining." );
            }

            return puid;
        }

        //
        // PRIVATE

        // methods

        /// <summary>
        /// GetPUIDBlock: talks to NPDB to get a new PUID range.
        /// </summary>
        private static void GetPUIDBlock()
        {
            int blockSize = Config.GetIntSetting(Setting.puidmgr_blockSize);
            int bucket = Config.GetIntSetting(Setting.puidmgr_userPuidBucket);

            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "dbo.p_puid_get_next_id";
                    cmd.CommandType = CommandType.StoredProcedure;

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    cmd.Parameters.Add("@i_bucket_id", SqlDbType.Int).Value = bucket;
                    cmd.Parameters.Add("@i_req_block_size", SqlDbType.Int).Value = blockSize;

                    SqlParameter puidParam = cmd.CreateParameter();
                    puidParam.Direction = ParameterDirection.Output;
                    puidParam.DbType = DbType.Int64;
                    puidParam.ParameterName = "@bi_next_id";
                    cmd.Parameters.Add(puidParam);

                    cmd.ExecuteNonQuery();

                    int retVal = (int) ret.Value;

                    // log the result information.
                    Xom.Trace(XomAreaName.puidmgr, LogLevel.L_INFO, "PUID acquistion from NPDB returned :  RETVAL:  " + retVal + "\nNew PUID Start Point:  " + m_nextPUID + "\nBucket = " + bucket + "\nBlock Size = " + blockSize );

                    if (retVal == 0)
                    {
                        m_nextPUID = (ulong) ((long) puidParam.Value);
                        m_numPUIDAvailable = (uint) blockSize;
                    }
                    else
                    {
                        m_nextPUID = 0;
                        m_numPUIDAvailable = 0;
                        throw new XRLException( HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.COMMON_CODE_180, "Failed to attain PUID block from NPDB.  Please investigate. RETVAL:  " + retVal + "\n New PUID Start Point:  " + m_nextPUID);
                    }
                }
            }
        }

        /// <summary>
        /// GetXenonPuidBlock: talks to NPDB to get a new PUID range.
        /// </summary>
        private static void GetXenonPuidBlock()
        {
            int blockSize = Config.GetIntSetting(Setting.puidmgr_blockSize);
            int bucket = 0; // XMACS always uses bucket 0 for Xenon machine puids

            using (SqlConnection conn = new SqlConnection(ConfigUtil.NpdbConnectionString))
            {
                conn.Open();

                using (SqlCommand cmd = conn.CreateCommand())
                {
                    cmd.CommandText = "dbo.p_puid_get_next_id";
                    cmd.CommandType = CommandType.StoredProcedure;

                    SqlParameter ret = cmd.CreateParameter();
                    ret.Direction = ParameterDirection.ReturnValue;
                    cmd.Parameters.Add(ret);

                    cmd.Parameters.Add("@i_bucket_id", SqlDbType.Int).Value = bucket;
                    cmd.Parameters.Add("@i_req_block_size", SqlDbType.Int).Value = blockSize;
                    cmd.Parameters.Add("@bi_base", SqlDbType.BigInt).Value = unchecked((long) PUID_BASE_XENON);

                    SqlParameter puidParam = cmd.CreateParameter();
                    puidParam.Direction = ParameterDirection.Output;
                    puidParam.DbType = DbType.Int64;
                    puidParam.ParameterName = "@bi_next_id";
                    cmd.Parameters.Add(puidParam);

                    cmd.ExecuteNonQuery();

                    int retVal = (int) ret.Value;

                    // log the result information.
                    Xom.Trace(XomAreaName.puidmgr, LogLevel.L_INFO, "PUID acquistion from NPDB returned :  RETVAL:  " + retVal + "\nNew PUID Start Point:  " + m_nextXenonPuid + "\nBucket = " + bucket + "\nBlock Size = " + blockSize );

                    if (retVal == 0)
                    {
                        m_nextXenonPuid = (ulong) ((long) puidParam.Value);
                        m_numXenonPuidsAvailable = (uint) blockSize;
                    }
                    else
                    {
                        m_nextXenonPuid = 0;
                        m_numXenonPuidsAvailable = 0;
                        throw new XRLException( HResult.XONLINE_E_DATABASE_RESULT_ERROR, XEvent.Id.COMMON_CODE_181, "Failed to attain Xenon PUID block from NPDB.  Please investigate. RETVAL:  " + retVal + "\n New PUID Start Point:  " + m_nextXenonPuid);
                    }
                }
            }
        }

        // private attributes.
        static private ulong    m_nextPUID;
        static private uint     m_numPUIDAvailable;

        static private ulong    m_nextXenonPuid;
        static private uint     m_numXenonPuidsAvailable;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\bigdefs.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef BIGDEFS_H              /* If not previously #included */
#define BIGDEFS_H 1

//       File bigdefs.h     Version 10 February 2004

//       This file declared the fundamental types and constants used
//       within the bignum code.

//           BOOL
//           BYTE
//           digit_t and digit_tc
//           DWORD and DWORDC
//           DWORDREG and DWORDREGC
//           sdigit_t and sdigit_tc
//           WINAPI
//
//        used within the bignum code and headers.
//        BOOL, BYTE, DWORD, FALSE, TRUE are defined in windef.h
//        but repeated here.
//        We also declare the most fundamental routines for operating on these.

//        Most procedures have a WINAPI keyword after the type
//        (e.g, after "int").
//        This is defined in windows.h, and specifies the
//        calling sequence used on the X86.
//
//        If you need to perform arithmetic, not just copy data, see bignum.h .


#include "bigenv.h"    // Identify compiler, operating system, target architecture 
#include <drmcommon.h>
#include <drmtypes.h>
#include <string.h>    // memcpy, memset procedures
#include <stdlib.h>    // 

/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

/*
        The letter 'c' following a type name identifies
        a const entity of that type.
*/
typedef const DRM_CHAR charc;
typedef const DRM_INT intc;

#if TARGET_OS == OS_WCE || TARGET_OS == OS_WNT
// #include <stdarg.h>
#include <windows.h>
#include <windef.h>
#include <winbase.h>     /* SYSTEM_INFO struct */
#else
typedef DRM_BOOL BOOL;       /* Same as windef.h */
#ifndef TRUE
#define TRUE 1
#endif
#ifndef FALSE
#define FALSE 0
#endif

typedef DRM_BYTE BYTE;
typedef DRM_VOID VOID;
typedef DRM_DWORD DWORD;
typedef DRM_INT INT;
typedef DRM_RESULT HRESULT;
#define WINAPI DRM_API
#endif

typedef const DWORD DWORDC;


#define DWORD_BITS 32
#define DWORD_LEFT_BIT 0x80000000UL

/*
     Pre-2002 bignum interfaces declared most lengths as DWORD,
     which is 32 bits on all platforms.  DWORD arithmetic operates
     modulo 2^32, making it hard for compilers to optimize

              DWORD i, j;   // 32-bits, unsigned
              for (i = 0; i < 100; i++) array[i+j] = 0;

     on 64-bit platforms, since array[i+j] and array[i+j+1] won't be adjacent
     when i+j = 0xffffffff.  DWORDREG has the same size as a machine register
     but is allowed only to have values through 2^32 - 1.
     It (rather than DWORD) should be used for subscripts and loop indices.
*/
#if (COMPILER == COMPILER_TMS320C55X)
/* TI Compiler uses size_t */
typedef DWORD DWORDREG;
#else
typedef size_t DWORDREG;
#endif

typedef const DWORDREG DWORDREGC;


//          Multiple-precision data is normally represented
//      in radix 2^RADIX_BITS, with RADIX_BITS bits per word.
//      Here ``word'' means type digit_t.  RADIX_BITS
//      is 32 on some architectures (Intel x86, MIPS, PowerPC)
//      and 64 bits on other architectures (Alpha, IA-64).

//          Within Windows NT, the data type DWORD predominates.
//      DWORD is a 32-bit unsigned data type on all platforms
//      (Intel x86, Alpha, IA-64, MIPS, PowerPC, Windows CE).
//      DWORD data can safely be written to disk on one architecture
//      and read back on another, unlike digit_t.

//      [CAUTION -- Even DWORD is not safe when sending data to
//      big-endian architectures, such as Office products for the Macintosh.]

#if (COMPILER == COMPILER_ARM_ATTILA ) || (COMPILER == COMPILER_GCC) || (COMPILER == COMPILER_TMS320C55X)
    #define RADIX_BITS 32
    #define RADIX_BYTES 4
    typedef   signed long sdigit_t;
    typedef unsigned long digit_t;
#elif TARGET == TARGET_ALPHA || TARGET == TARGET_IA64 /*|| TARGET == TARGET_AMD64*/
    #define RADIX_BITS 64
    #define RADIX_BYTES 8
    typedef   signed __int64 sdigit_t;
    typedef unsigned __int64  digit_t;
#else 
    // Use 32-bit path for x64 too, since the 64-bit path gives incorrect results (on x64 at least).
    // We may want to eventually go back to the 64-bit path for speed once it is fixed. -thjones 11/9/04
    #define RADIX_BITS 32
    #define RADIX_BYTES 4
    typedef   signed __int32 sdigit_t;
    typedef unsigned __int32 digit_t;
#endif

typedef const  digit_t  digit_tc;
typedef const sdigit_t sdigit_tc;


#define DIGIT_ZERO ((digit_t)0)
#define DIGIT_ONE  ((digit_t)1)

#define RADIX_HALF (DIGIT_ONE << (RADIX_BITS - 1))
#define RADIXM1 (DIGIT_ZERO - DIGIT_ONE)
#define F_RADIX ((double)RADIXM1 + 1.0)

#define HALF_RADIX_BITS (RADIX_BITS/2)
#if (RADIX_BITS != 2*HALF_RADIX_BITS)
    #error -- "RADIX_BITS must be even"
#endif
#define RADIX_HALFMASK_BOTTOM (RADIXM1 >> HALF_RADIX_BITS)




//    DWORD is 32 bits on all platforms.
//    Many codes simply require at least 32 bits,
//    but a few assume it is exactly 32 bits,
//    with integer overflow ignored.  The SHAVE32 macro
//    is intended to identify where only 32 bits are to be used.
//    For example, it should be used before a right shift
//    if earlier calculations may have overflowed.

#if DWORD_BITS == 32
#define SHAVE32(x) ((DWORD)(x))
#else
#define SHAVE32(x) ((DWORD)((x) & 0xffffffffU))
#endif


//  Rotate a 32-bit DWORD value left circularly by amt bits,
//  where 0 <= amt < 32.


#if TARGET == TARGET_IX86
#pragma intrinsic(_rotl)
#define ROTATE32L(x, amt) ((DWORD)_rotl((x), (amt)))
#else
#define ROTATE32L(x, amt) (((x) << (amt)) \
                  | (SHAVE32(x) >> (31 & (0 - (DWORD)(amt)))))
#endif



#if RADIX_BITS % DWORD_BITS != 0
    #error "RADIX_BITS not a multiple of 32"
#endif


#define DWORDS_PER_DIGIT (RADIX_BITS/DWORD_BITS)

//      DWORDS_TO_DIGITS(lng_dwords) computes the number of digit_t
//      elements required to store an array with -lng_dwords- DWORDs.
//      DIGITS_TO_DWORDS converts in the opposite direction.


#define DWORDS_TO_DIGITS(lng_dwords) \
                ( ((lng_dwords) + DWORDS_PER_DIGIT - 1)/DWORDS_PER_DIGIT)

#define DIGITS_TO_DWORDS(lng_digits) ((lng_digits) * DWORDS_PER_DIGIT)

#define BITS_TO_DIGITS(nb) (((nb) + RADIX_BITS - 1)/RADIX_BITS)


#define digit_getbit(iword, ibit) (((iword) >> (ibit)) & 1)
// TBD #define dword_getbit(iword, ibit) digit_getbit(iword, ibit)
                        /* Extract bit from a word.
                        // 0 <= ibit <= RADIX_BITS - 1.
                        // Rightmost (i.e., least significant) bit is bit 0.
                        */

/*
        Test whether a (possibly negative) number is odd or even.
*/
#define IS_EVEN(n) (~(unsigned int)(n) & 1)
#define IS_ODD(n) ((unsigned int)(n) & 1)

/*
        Maximum and minimum of two arguments
        (no side effects in arguments)
*/

#if 0
    #define MAX _max
    #define MIN _min
#else
    #define MAX(x, y) ((x) > (y) ? (x) : (y))
    #define MIN(x, y) ((x) > (y) ? (y) : (x))
#endif



/*
      The library can be compiled in to print messages (in English)
      when certain errors are detected.  That flag is PRINT_ERROR_MESSAGES.
      Messages go to file mp_errfil unless mp_errfil == NULL.
      The application program can change the file.
*/

#ifndef PRINT_ERROR_MESSAGES
    #ifdef ENABLE_ERROR_MESSAGES
        #define PRINT_ERROR_MESSAGES 1
    #else
        #define PRINT_ERROR_MESSAGES 0
    #endif
#endif

#if PRINT_ERROR_MESSAGES
    #include <stdio.h>
    extern FILE* mp_errfil;   // Declared in bigerrno.h or its substitute.
                              // May be a NULL pointer.
                              // Application may initialize
                              //     mp_errfil = stdout or stderr.
#endif /* PRINT_ERROR_MESSAGES */



//  The following are used in function prototypes

#define MP_INPUT      digit_tc*
#define MP_OUTPUT     digit_t*
#define MP_MODIFIED   digit_t*

/*
      Occasionally a struct name is used before the struct itself is
      declared.  The Future_Struct macro avoids a warning message
      with Vicusl C .NET (2002).
*/
#define Future_Struct(strname) struct strname

Future_Struct(bigctx_t);

/*
        Many procedures have a final argument identifying the
        caller (or caller's caller, etc.).  The application
        can use this for thread-specific data, such as
        having a separate random number generator seed
        for each thread or forwarding error information
        to the caller.

        The last formal argument to a procedure
        should be PBIGCTX_ARG, which will declare a
        pointer pbigctx to a type not decided as
        of February, 2004.  Use PBIGCTX_PASS
        to pass pbigctx to a lower procedure.
*/

#define PBIGCTX_PASS  pbigctx
#define PBIGCTX_ARG   struct bigctx_t *pbigctx
#define PBIGCTX_UNUSED (void)pbigctx
#define PBIGCTX_NULL  0



//  The following functions may be referenced without calling
//  mp_initialization.

//  Some of these have assembly language or machine-specific
//  versions in bignum.h or bignum.c.

#if 0
extern BOOL WINAPI big_endian_bytes_to_digits
        (const BYTE  *barray,   // IN
         digit_t     *darray,   // OUT
         DWORDREGC    bitlen,   // IN
         PBIGCTX_ARG);

extern BOOL WINAPI little_endian_bytes_to_digits
        (const BYTE  *barray,   // IN
         digit_t     *darray,   // OUT
         DWORDREGC    bitlen,   // IN
         PBIGCTX_ARG);

extern BOOL WINAPI digits_to_big_endian_bytes
        (digit_tc    *darray,   // IN
         BYTE        *barray,   // OUT
         DWORDREGC    bitlen,   // IN
         PBIGCTX_ARG);

extern BOOL WINAPI digits_to_little_endian_bytes
        (digit_tc    *darray,   // IN
         BYTE        *barray,   // OUT
         DWORDREGC    bitlen,   // IN
         PBIGCTX_ARG);

extern BOOL WINAPI little_endian_bytes_to_digits
        (const BYTE  *barray,   // IN
         digit_t     *darray,   // OUT
         DWORDREGC    bitlen,   // IN
         PBIGCTX_ARG);

#endif
extern DWORDREG WINAPI mp_trailing_zero_count(MP_INPUT, DWORDREGC, PBIGCTX_ARG);

#define mp_clear(dest, lng, ctx) (BOOL)(ctx, memset((void *)(dest), 0,\
                                                (size_t)(lng)*sizeof(digit_t)), TRUE)
#define mp_copy(src, dest, lng, ctx) \
            (BOOL)(ctx, memcpy((void *)(dest), (const void *)(src), \
                               (size_t)(lng)*sizeof(digit_t)), TRUE)

#define all_zero(a, lng) (significant_digit_count(a, lng) == 0)

extern DWORDREG WINAPI trailing_zero_count(digit_tc);
                 /* Has special code on some platforms */

#if !INLINING_SUPPORTED

extern DWORDREG WINAPI significant_bit_count(digit_tc);
                 /* Has special code on some platforms */

extern DWORDREG WINAPI mp_significant_bit_count
                            (MP_INPUT, DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI digits_to_dwords(MP_INPUT, DWORD*,
                                    DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI dwords_to_digits(DWORDC*, MP_OUTPUT,
                                    DWORDREGC, PBIGCTX_ARG);

extern void WINAPI mp_extend(MP_INPUT, DWORDREGC, MP_OUTPUT,
                             DWORDREGC, PBIGCTX_ARG);

extern digit_t WINAPI mp_getbit(MP_INPUT, DWORDREGC, PBIGCTX_ARG);

extern void WINAPI mp_setbit(MP_MODIFIED, DWORDREGC, digit_tc, PBIGCTX_ARG);

extern DWORDREG WINAPI significant_digit_count(MP_INPUT, DWORDREGC);
#endif

extern void * BignumSecureZeroMemory(
    IN void* ptr,
    IN DWORD cnt
    );

#if INLINING_SUPPORTED

INLINE void WINAPI mp_extend
        (digit_tc  a[],
         DWORDREGC lnga,
         digit_t   b[],
         DWORDREGC lngb,
         PBIGCTX_ARG)
/*
        Copy a to b, while changing its length from
        lnga to lngb (zero fill).  Require lngb >= lnga.
*/
{
    PBIGCTX_UNUSED;
    mp_copy(a, b, lnga, PBIGCTX_PASS);
    mp_clear(b + lnga, lngb - lnga, PBIGCTX_PASS);
}  // mp_extend
/****************************************************************************/
INLINE digit_t WINAPI mp_getbit
        (digit_tc a[],
         DWORDREGC ibit,
         PBIGCTX_ARG)
                /* Extract bit of multiple precision number */
{
    PBIGCTX_UNUSED;
    return digit_getbit(a[ibit/RADIX_BITS],  ibit % RADIX_BITS);
}
/****************************************************************************/
INLINE void WINAPI mp_setbit
        (digit_t   a[],
         DWORDREGC ibit,
         digit_tc  new_value,
         PBIGCTX_ARG)
/*
        Set a bit to 0 or 1,
        when the number is viewed as a bit array.
*/

{
    DWORDREGC j       = ibit / RADIX_BITS;
    DWORDREGC ishift  = ibit % RADIX_BITS;

    digit_tc mask1 = (DIGIT_ONE &  new_value) << ishift;
    digit_tc mask2 = (DIGIT_ONE & ~new_value) << ishift;

    PBIGCTX_UNUSED;
    a[j] = (a[j] & ~mask2) | mask1;
} // end mp_setbit
/****************************************************************************/
INLINE DWORDREG WINAPI significant_digit_count
        (digit_tc  a[],
         DWORDREGC    lng)
/*
        Return the number of significant digits in a.
        Function value is zero precisely when a == 0.
*/
{
    DWORDREG i = lng;

    while (i != 0 && a[i-1] == 0) i--;
    return i;
}  /* significant_digit_count */
/****************************************************************************/
INLINE BOOL WINAPI digits_to_dwords
        (digit_tc  pdigit[],
         DWORD     pdword[],
         DWORDREGC lng_dwords,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;

#if DWORDS_PER_DIGIT == 1
    PBIGCTX_UNUSED;
    mp_copy(pdigit, (digit_t*)pdword, lng_dwords, PBIGCTX_PASS);
#elif DWORDS_PER_DIGIT == 2
    DWORDREGC lng_half = lng_dwords >> 1;
    DWORD i;
    PBIGCTX_UNUSED;


    if (IS_ODD(lng_dwords)) {
        pdword[lng_dwords-1] = (DWORD)pdigit[lng_half];
    }
    for (i = 0; i != lng_half; i++) {
        digit_tc dig = pdigit[i];
        pdword[2*i    ] = (DWORD)dig;
        pdword[2*i + 1] = (DWORD)(dig >> DWORD_BITS);
    }
#else
    #error "Unexpected DWORDS_PER_DIGIT"
#endif
    return OK;
}  /* digits_to_dwords */
/****************************************************************************/
INLINE BOOL WINAPI dwords_to_digits
        (DWORDC    pdword[],
         digit_t   pdigit[],
         DWORDREGC lng_dwords,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;

#if DWORDS_PER_DIGIT == 1
    PBIGCTX_UNUSED;
    mp_copy((digit_t*)pdword, pdigit, lng_dwords, PBIGCTX_PASS);
#elif DWORDS_PER_DIGIT == 2
    DWORDREGC lng_half = lng_dwords >> 1;
    DWORDREG i;
    PBIGCTX_UNUSED;

    if (IS_ODD(lng_dwords)) {
        pdigit[lng_half] = (digit_t)pdword[lng_dwords - 1];  // Zero fill
    }
    for (i = 0; i != lng_half; i++) {
        pdigit[i] =    ((digit_t)pdword[2*i+1] << DWORD_BITS)
                     |  (digit_t)pdword[2*i];
    }
#else
    #error "Unexpected DWORDS_PER_DIGIT"
#endif
    return OK;
}  /* dwords_to_digits */

#undef significant_bit_count    // In case a macro version existed
FORCE_INLINE DWORDREG WINAPI significant_bit_count(digit_tc d)
/*
        Compute the number of significant bits in d.
        This is one more than the truncated base 2 logarithm of d.
        significant_bit_count(0)  is undefined.

        For example, significant_bit_count(d) = 8 for 128 <= d <= 255.

        On platforms which have a Count Leading Zeroes or
        similar instruction, UNIFORM_SIGNIFICANT_BIT_COUNT
        should be 1, with special code used.
        For other platforms, use this algorithm.
        The algorithm performs best when the argument is large,
        a feature used by the GCD routines.
*/
{
    digit_t dadj = d | 1;
    DWORDREG width = RADIX_BITS;
    DWORDREG width_adj;

    while (dadj < (DIGIT_ONE << (RADIX_BITS - 5))) {
        width -= 5;
        dadj <<= 5;
    }
    dadj >>= (RADIX_BITS - 4);     /* From 0 to 15 */
    width_adj = ((DWORDREG)0000000011112234 >> dadj) >> (2*dadj);
                     // Shift by 3*dadj, to index into array of octal digits
    return width - (width_adj & 7);
                    // Subtract 5 - significant_bit_count(2*dadj + 1)
} /* significant_bit_count */

FORCE_INLINE DWORDREG WINAPI mp_significant_bit_count
        (digit_tc  a[],
        DWORDREGC  lnga,
        PBIGCTX_ARG)
/*
        Return the number of significant bits in a, which
        is one more than the truncated base 2 logarithm of a.
        Return 0 if a == 0.
*/
{
    DWORDREGC lng_sig = significant_digit_count(a, lnga);

    PBIGCTX_UNUSED;
    if (lng_sig == 0) {
        return 0;
    } else {
       return    (lng_sig - 1)*RADIX_BITS
               + significant_bit_count(a[lng_sig-1]);
    }
}


/****************************************************************************/
#endif // INLINING_SUPPORTED

/*
        The application should define the
        following three malloc-like functions.
        Sample definitions appear in bigalloc.h.
*/

extern void* WINAPI bignum_alloc(const size_t, PBIGCTX_ARG);
extern void* WINAPI bignum_realloc(void*, const size_t, PBIGCTX_ARG);
extern void  WINAPI bignum_free(void*, PBIGCTX_ARG);

/*
        The test version of the library includes
        mp_print_allocation_statistics to help identify
        memory leaks and other errors.
*/
#if PRINT_ERROR_MESSAGES
    extern void WINAPI mp_print_allocation_statistics(FILE*, PBIGCTX_ARG);
#else
    extern void WINAPI mp_print_allocation_statistics(void*, PBIGCTX_ARG);
          // Declare it, but library routine does nothing.
#endif /* PRINT_ERROR_MESSAGES */

#ifdef __cplusplus
}
#endif

#endif // BIGDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\bigenv.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef BIGENV_H              /* If not previously #included */
#define BIGENV_H 1

/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif


//     File bigenv.h   Version 16 November, 2000

//     This file looks at predefined macros.
//     It sets the flags
//
//          COMPILER        -- Identification of compiler or family of compilers
//          COMPILER_NAME   -- String with description of compiler.
//          EXPORTED_INLINE --.Used for local defintions of functions which are
//                            inlined on that file but available elsewhere.
//          EXTERN_INLINE   -- Used for extern declarations of functions which
//                             are inline on their definition file.
//          INLINING_SUPPORTED -- Does compiler support the _inline_ keyword?
//          TARGET          -- Identification of target architecture.
//          TARGET_NAME     -- String with description of target architecture
//          TARGET_OS       -- Identification of target operating system.

//     The COMPILER_NAME and TARGET_NAME strings should be used
//     only in printf-like contexts.
//     These are English-language descriptions even
//     in international versions of the software.


#define COMPILER_GCC 1
#define COMPILER_VC  2
#define COMPILER_ARM_ATTILA 3
#define COMPILER_TMS320C55X 4

#ifndef COMPILER
    #ifdef __GNUC__
        #define COMPILER COMPILER_GCC
                        /* GNU compiler */
    #endif
    #ifdef _MSC_VER
        #define COMPILER COMPILER_VC
    #endif              /* Microsoft Visual C compiler */

    #if defined(__arm) && !defined(COMPILER)
        #define COMPILER COMPILER_ARM_ATTILA
                        /* Native ARM compiler */
        #define TARGET TARGET_ARM
    #endif
    #ifdef __TMS320C55X__
        #define COMPILER COMPILER_TMS320C55X
        #define _ANSI 1
    #endif
#endif

/*
        Define a string with the compiler name,

        INLINING_SUPPORTED should be 1 if the compiler
        inlines procedures declared with the -inline-
        keyword (while deleting unused static procedures).
        If the compiler lacks these features,
        INLINING_SUPPORTED should be 0.
        These flags may vary with the version of the compiler.
*/


#if COMPILER == COMPILER_GCC
    #define COMPILER_NAME "GCC compiler"
    #define INLINING_SUPPORTED 1
    #define EXTERN_INLINE extern inline
    #define EXPORTED_INLINE inline
    #define FORCE_INLINE inline
    #define INLINE inline
#elif COMPILER == COMPILER_TMS320C55X
    #define COMPILER_NAME "Texas Instruments TMS320C55X compiler"
    #define INLINING_SUPPORTED 1
    #define EXTERN_INLINE extern
    #define EXPORTED_INLINE
    #define FORCE_INLINE inline
    #define INLINE inline
#elif COMPILER == COMPILER_VC
    #define COMPILER_NAME "Microsoft Visual C++ compiler"
    #if 1 /*defined(NDEBUG)*/    // Release mode
        #define INLINING_SUPPORTED 1
        #define inline __inline
    #else                  // Debug mode
        #define INLINING_SUPPORTED 0
        #define inline __inline
    #endif
    #define EXTERN_INLINE extern __inline
    #define EXPORTED_INLINE __inline
    #define FORCE_INLINE __forceinline
    #define INLINE __inline
#elif defined(_ANSI)
    #define COMPILER_NAME "ANSI C"
    #define EXTERN_INLINE extern
    #define EXPORTED_INLINE 
    #define INLINING_SUPPORTED 0
    #define INLINE
    #define FORCE_INLINE 
#endif

#if COMPILER == COMPILER_ARM_ATTILA
    #define COMPILER_NAME "ARM compiler for Attila"
#if 0
    // As of November, 2000, inlining increases code size 10%.
    // An elliptic curve test found less than 1% performance difference.

    // The compiler compiled vmul66 and vmul88 incorrectly with inlining.

    #define inline __inline
    #define INLINING_SUPPORTED 1
#else
    #define inline
    #define INLINING_SUPPORTED 0
#endif
    #define EXTERN_INLINE extern
    #define EXPORTED_INLINE  /* nothing */
    #define FORCE_INLINE 
#endif

#if    !defined(COMPILER) || COMPILER <= 0 \
    || !defined(COMPILER_NAME) || !defined(INLINING_SUPPORTED)
    #error -- "Unknown COMPILER"
#endif

/*
        Major Windows operating systems.
        Windows 95/98/Millennium are not supported.
*/

#define OS_WCE 1
           // Windows CE
#define OS_WNT 2
           // Windows NT or 2000 or XP or Palladium or Longhorn or ...
#define OS_ATTILA 3
           // Attila wireless phone -- no operating system (2000)
#define OS_ANSI 4
           // ANSI C


#if defined(_WIN32_WCE)
    #define TARGET_OS OS_WCE
#elif defined(WIN32)  // Includes 64-bit IA-64 and AMD-64
    #define TARGET_OS OS_WNT
#elif defined(__arm)
    #define TARGET_OS OS_ATTILA
#elif defined(_ANSI)
    #define TARGET_OS OS_ANSI
#else
    #error "Unknown OS target"
#endif
/*
        List of architectures on which code has been run.
        The inclusion of an architecture in this list does
        not necessarily imply that the present code
        will run on that architecture.
*/

#define TARGET_ALPHA 1
#define TARGET_AMD64 2
#define TARGET_ARM 3
#define TARGET_IA64 4
#define TARGET_IX86 5
#define TARGET_MIPS 6
#define TARGET_PPC 7
#define TARGET_SHX 8
#define TARGET_SPARC 9
#define TARGET_ANSI 10

#ifndef TARGET
    #ifdef _M_ALPHA     // DEC (Compaq) Alpha
        #define TARGET TARGET_ALPHA
    #endif
    #if defined(_ARM_)
        #define TARGET TARGET_ARM
    #endif
    #if defined(_M_IA64)      // Intel IA-64 (e.g., Merced, McKinley)
        #define TARGET TARGET_IA64
    #endif
    #if defined(_M_IX86) || defined(_x86)  // Intel X86 (e.g., 486, Pentium)
        #define TARGET TARGET_IX86
    #endif
    #if defined(_M_MRX000) || defined(_MIPS_) // MIPS 32-bit systems
        #define TARGET TARGET_MIPS
    #endif
    #if defined(_M_PPC)       // Motorola/Macintosh Power PC
        #define TARGET TARGET_PPC
    #endif
    #if defined(_SHX_)   // Hitachi SH-3 or SH-4
        #define TARGET TARGET_SHX
    #endif
    #if defined(__sparc__)    // Sun SPARC
        #define TARGET TARGET_SPARC
    #endif
    #if defined(_SH3_) || defined(_SH4_)   // Hitachi SH-3 or SH-4
        #define TARGET TARGET_SHX
    #endif
    #if defined(_AMD64_)
        #define TARGET TARGET_AMD64
    #endif
    #if defined(__TMS320C55X__)
        #define TARGET TARGET_ANSI
    #endif
#endif

#if TARGET == TARGET_ALPHA
#define TARGET_NAME "Compaq Alpha"
#endif

#if TARGET == TARGET_AMD64
#define TARGET_NAME "AMD x86-64"
#endif

#if TARGET == TARGET_ARM
#define TARGET_NAME "ARM"
#endif

#if TARGET == TARGET_IA64
#define TARGET_NAME "Intel IA-64"
#endif

#if TARGET == TARGET_IX86
#define TARGET_NAME "Intel Pentium"
#endif

#if TARGET == TARGET_MIPS || TARGET == TARGET_PPC
#define TARGET_NAME "Macintosh/Motorola PowerPC"
#endif

#if TARGET == TARGET_SHX
#define TARGET_NAME "Hitachi SHx"
#endif

#if TARGET == TARGET_SPARC
#define TARGET_NAME "Sun SPARC"
#endif

#if TARGET == TARGET_ANSI
#define TARGET_NAME "ANSI C"
#endif

#if !defined(TARGET) || TARGET <= 0 || !defined(TARGET_NAME)
    #error -- "Unknown TARGET"
#endif

#ifdef __cplusplus
}
#endif

#endif // BIGENV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\bigalloc.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
    File bigalloc.h

    This file has sample versions of files which
    should be provided by the application program:

    void* bignum_alloc(size_t cblen)
    void* bignum_realloc(void * pvMem, size_t cblen)
    void  bignum_free(void *pvMem)

    These operate analogously to the standard
    malloc, realloc, free.
    Memory contents are undefined after a malloc.

    If these definitions are satisfactory, then
    #include "bigalloc.h" somewhere in
    the application program, typically near
    the main program,
*/

#ifndef BIGALLOC_H
#define BIGALLOC_H 1

#include "bigdefs.h"
#include <stdio.h>
#include <stdlib.h>

/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif



#if TARGET_OS == OS_WNT && !defined(OLD_CODE)
// the OLD_CODE test is temporary,
// until petmon gets the code to work on his laptop.
// InterlockedCompareExchangePointer is new to Whistler,
//  November, 2000

#include <windows.h>

//
// Multi-threaded memory allocation support for NT.
//

#ifdef _X86_
#define InterlockedAccess(pl) *(pl)
#define InterlockedPointerAccess(ppv) *(ppv)
#else
#define InterlockedAccess(pl) InterlockedExchangeAdd((pl), 0)
#define InterlockedPointerAccess(ppv) InterlockedExchangePointer((ppv), *(ppv))
#endif

static HANDLE l_hHeap = NULL;

LPVOID
bignum_alloc(
    const size_t cbLen)
{
    HANDLE hHeap = InterlockedPointerAccess(&l_hHeap);

    if (NULL == hHeap)
    {
        hHeap = HeapCreate(0, 0, 0);
        if (NULL == hHeap)
            return NULL;

        if (NULL != InterlockedCompareExchangePointer(&l_hHeap, hHeap, NULL))
        {
            HeapDestroy(hHeap);
            hHeap = InterlockedPointerAccess(&l_hHeap);
        }
    }

    return HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cbLen);
}

LPVOID
bignum_realloc(
    LPVOID pvMem,
    const size_t cbLen)
{
    return HeapReAlloc(l_hHeap, HEAP_ZERO_MEMORY, pvMem, cbLen);
}

void
bignum_free(
    LPVOID pvMem)
{
    HeapFree(l_hHeap, 0, pvMem);
}

#elif 0    // Case not now used

void *bignum_alloc(const size_t cblen)
{
    return LocalAlloc(LMEM_FIXED, cblen);
}

// bignum_realloc presently undefined

void bignum_free(void *pvMem)
{
    LocalFree((HLOCAL)pvMem);
}

#else /* Other operating systems */

void* WINAPI bignum_alloc(const size_t cblen)
{
    return malloc(cblen);
}

void* WINAPI bignum_realloc(void *pvMem, const size_t cblen)
{
    return realloc(pvMem, cblen);
}

void WINAPI bignum_free(void *pvMem)
{
    free(pvMem);
}

#endif /* operating system */

#ifdef __cplusplus
}
#endif


#endif // BIGALLOC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\bignum.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*

       File bignum.c
       Version 20 February 2005

       This file has extern definitions of functions
       which are ordinarily inlined.  In particular, it exists to
       support compilers which don't support inlining.
       It also has simple routines defined nowhere else.
*/
#define BIGNUM_C 1
#include "bignum.h"
#ifndef assert
#include <assert.h>
#endif
/*
        DWORDREG mp_significant_digit_count(a, lng) --  Count the number
                                            of significant bits in a.
                                            This is one more than the
                                            truncated base 2 logarithm of a.

        DWORDEG mp_trailing_zero_count(a, lng) -- Count the
                                            number of zero bits
                                            at the bottom of the binary
                                            representation of a.
                                            This is the exponent of the
                                            highest power of 2 dividing a.
                                            a should be nonzero.

        DWORDREG significant_bit_count(d) -- Compute the number of
                                          significant bits in d (d != 0).
                                          This is one more than the
                                          truncated base 2 logarithm of d.

        DWORDREG trailing_zero_count(d) -- Count the number of trailing
                                           zero bits in d.  d must be nonzero.

        BOOL two_adic_inverse(d, &dinv, &ctx) -- Returns dinv so that
                                           d*dinv == 1 (mod RADIX).
                                           d must be odd.

*/
/****************************************************************************/
#if USEASM_ALPHA
    /* Alpha version uses inline assembly plus this table */
    const BYTE half_byte_significant_bit_count[128]
        = { 0, 1, 2, 2, 3, 3, 3, 3,
            4, 4, 4, 4, 4, 4, 4, 4,
            5, 5, 5, 5, 5, 5, 5, 5,
            5, 5, 5, 5, 5, 5, 5, 5,
            6, 6, 6, 6, 6, 6, 6, 6,
            6, 6, 6, 6, 6, 6, 6, 6,
            6, 6, 6, 6, 6, 6, 6, 6,
            6, 6, 6, 6, 6, 6, 6, 6,
            7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7,
            7, 7, 7, 7, 7, 7, 7, 7};
#endif

/****************************************************************************/

#undef trailing_zero_count  // In case a macro version existed
DWORDREG WINAPI trailing_zero_count(digit_tc d)
/*
        Given a nonzero integer d, this routine computes
        the largest integer n such that 2^n divides d.

        The code is optimized for low values of n.

        N.B.  It is the caller's responsibility to ensure d <> 0.
        If nonetheless d = 0, then this code may return a
        meaningless result (but will not abort or loop endlessly).
*/
{
    static const BYTE discrete_log_mod_11[11]
    = {(BYTE)-1, 0, 1,   8, 2,  4,   9,  7, 3,  6,  5};
    //           1  2  256  4  16  512 128  8  64  32

    digit_t dadj = d & (0 - d);          // A power of 2
    DWORDREG answer = 0;

    while (dadj >= 1024) {
        dadj >>= 10;
        answer += 10;
    }
    dadj -= 11*((23*dadj) >> 8);      // Reduce mod 11
                                      // Old dadj is power of 2 from 1 to 512.
    return answer + (DWORDREG)discrete_log_mod_11[dadj];
}  /* trailing_zero_count */
/****************************************************************************/
BOOL WINAPI two_adic_inverse(digit_tc d, digit_t *pdinv, PBIGCTX_ARG)
/*
      Find *pdinv so that (*pdinv)*d == 1 (mod RADIX)
*/
{
    BOOL OK = TRUE;

    if (IS_EVEN(d)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "two_adic_inverse", PBIGCTX_PASS);
    } else {
        digit_t dinv = (3*d)^2;     // 5-bit  2-adic inverse approximation
        digit_t err = 1 - d*dinv;
        DWORDREG nbits;   // Bits of accuracy so far

        assert((err & 31) == 0);
        for (nbits = 5; nbits < RADIX_BITS/2; nbits *= 2) {
            dinv += dinv*err;
            err = err*err;
            assert(err == (digit_t)(1 - d*dinv));
        }
        *pdinv = dinv*err + dinv;
    }
    return OK;
} // two_adic_inverse
/****************************************************************************/
DWORDREG WINAPI mp_trailing_zero_count
        (digit_tc   a[],
         DWORDREGC  lng,
         PBIGCTX_ARG)
/*
//        Return (the index of) the highest power of 2 dividing a.
//        The value of a should be nonzero.
*/
{
    DWORDREG i;
    for (i = 0; i != lng; i++) {
        if (a[i] != 0) return i*RADIX_BITS + trailing_zero_count(a[i]);
    }
// TBD -- present interface does not let use return error indicator
//     (TRUE/FALSE) to caller
    SetMpErrno_clue(MP_ERRNO_ZERO_OPERAND,
                    "mp_trailing_zero_count",
                    PBIGCTX_PASS);
    return 0;
} /* mp_trailing_zero_count */

/****************************************************************************/


/*
        Here are some simple routines which fit nowhere else.

      carry  = accumulate(a, mult, b, lng)   -- b := b + mult*a, where a, b
                                                           have length lng


borrow = decumulate(a, mult, b, lng)   -- b := b - mult*a, where a, b
                                                           have length lng
carry  = multiply_immediate(a, mult, b, lng) -- b := mult*a, where a, b
                                                            have length lng

        BOOL mp_shift(a, amt, b, lng)    -- Compute lower lng words
                                            of b = a*2^amt, where
                                            amt can be arbitrarily large.
                                            Overflow/underflow is lost.
                                            Does left shift if amt >= 0,
                                            right shift if amt < 0.

        digit_t mp_shift_lost(a, amt, b, lng, plost)
                                         -- Compute lower lng words
                                            of b = a*2^amt, where
                                            |amt| <= RADIX_BITS.
                                            *plost will receive bits
                                            lost due to overflow/underflow.

        BOOL multiply(a, lnga, b, lngb, c) - Compute c = a * b
                                             (classical algorithm).

        BOOL set_immediate(a, ivalue, lngs) -- Set  a = ivalue (a scalar)

         multiply_low(a, b, c, lng)    -- c := a * b (mod RADIX^lng)
         (see file multlow.c)
*/
/***************************************************************************/
digit_t WINAPI accumulate
        (digit_tc  a[],
         digit_tc  mult,
         digit_t   b[],
         DWORDREGC  lng,
         PBIGCTX_ARG)
/*
        Compute b = b + mult*a, where a and b have length lng.
        Function value is carry out of leftmost digit.
*/
{
    digit_t carry = 0;
    DWORDREG i;

    PBIGCTX_UNUSED;
    for (i = 0; i != lng; i++) {
        dblint_tc dtemp = MULTIPLY_ADD2(mult, a[i], b[i], carry);
        b[i] = LOW_DIGIT(dtemp);
        carry = HIGH_DIGIT(dtemp);
    }
    return carry;
}  /* accumulate */

/****************************************************************************/
digit_t WINAPI decumulate
        (digit_tc  a[],
         digit_tc  mult,
         digit_t   b[],
         DWORDREGC lng,
         PBIGCTX_ARG)
/*
        Compute b = b - mult*a, where a and b have length lng.
        Function value is borrow out of leftmost digit.
*/
{
    digit_t borrow = 0;
    DWORDREG i;

    PBIGCTX_UNUSED;
    for (i = 0; i != lng; i++) {
        dblint_tc dtemp = DBLINT_SUB(DBLINT_SUB(DBLINT(b[i]),
                                                DBLINT(borrow)),
                                     DPRODUU(mult, a[i]));
        b[i] = LOW_DIGIT(dtemp);
        borrow = 0 - HIGH_DIGIT(dtemp);
    }
    return borrow;
}  /* decumulate */
/***************************************************************************/
BOOL WINAPI mp_shift
       (digit_tc  a[],
        intc      ishift,
        digit_t   b[],
        DWORDREGC lng,
        PBIGCTX_ARG)
/*
//              Compute  b = a << ishift     (if ishift >= 0)
//                   or  b = a >> (-ishift)  (if ishift < 0).
//
//              Both input and output are length lng.
//              Unlike mp_shift, the shift count may
//              exceed RADIX_BITS bits (either direction).
//              It may even exceed lng*RADIX_BITS.
//              Bits shifted past either end are lost.
*/
{
    intc itranslate = (ishift >= 0 ?   (int) (DWORDREG)ishift/RADIX_BITS
                                   : - (int)((DWORDREG)(-ishift)/RADIX_BITS));
                   /* Round quotient ishift/RADIX_BITS towards zero */
    DWORDREG i;
    BOOL OK = TRUE;
    digit_t lost = 0;

    OK = OK && mp_shift_lost(a, ishift - RADIX_BITS*itranslate, b,
                             lng, &lost, PBIGCTX_PASS);

    if (!OK) {
    } else if (itranslate < 0) {               /* Right shift, multiple words */
        DWORDREGC dtranslate = (DWORDREG)(-itranslate);
        for (i = 0; i != lng; i++) {
            b[i] = (i + dtranslate < lng ? b[i + dtranslate] : 0);
        }
    } else if (itranslate > 0) {        /* Left shift, multiple words */
        DWORDREGC dtranslate = (DWORDREG)itranslate;
        for (i = lng; (i--) != 0; /*null*/) {
            b[i] = (i >= dtranslate ? b[i - dtranslate] : 0);
        }
    }
    return OK;
} /* mp_shift */
/****************************************************************************/
BOOL WINAPI mp_shift_lost
        (digit_tc  a[],
         intc      shift_amt,
         digit_t   b[],
         DWORDREGC lng,
         digit_t  *plost,
         PBIGCTX_ARG)
/*
//      Compute b = a*2^shift_amt.
//      Require -RADIX_BITS <= shift_amt <= RADIX_BITS.
//      Function value reflects bits shifted off the
//      right or off the left.

//      The arrays a and b should be identical, or not overlap.
*/
{
    DWORDREG i;
    BOOL OK = TRUE;
    digit_t bits_lost = 0;

    if (abs(shift_amt) > RADIX_BITS) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "mp_shift_lost -- bad shift count",
                        PBIGCTX_PASS);
    } else if (lng == 0) {
    } else if (shift_amt > 0) {           /* left shift */
        if (shift_amt == RADIX_BITS) {
            bits_lost = a[lng-1];
            for (i = lng-1; i != 0; i--) b[i] = a[i-1];
            b[0] = 0;
        } else {
            for (i = 0; i != lng; i++) {
                digit_tc bnew = (a[i] << shift_amt) | bits_lost;

                bits_lost = a[i] >> (RADIX_BITS - shift_amt);
                b[i] = bnew;
            }
        }
    } else if (shift_amt < 0) {
        if (shift_amt == -RADIX_BITS) {
            bits_lost = a[0];
            for (i = 1; i != lng; i++) b[i-1] = a[i];
            b[lng-1] = 0;
        } else {

            for (i = lng; (i--) != 0; /*null*/) {
                digit_tc bnew = (a[i] >> (-shift_amt) ) | bits_lost;
                bits_lost = a[i] << (RADIX_BITS + shift_amt);
                b[i] = bnew;
            }
            bits_lost >>= (RADIX_BITS + shift_amt); /* Move to bottom of word */
        }
    } else {
        mp_copy(a, b, lng, PBIGCTX_PASS);
    }
    if (OK) *plost = bits_lost;
    return OK;
} /* mp_shift_lost */

/****************************************************************************/
digit_t WINAPI multiply_immediate
        (digit_tc  a[],
         digit_tc  mult,
         digit_t   b[],
         DWORDREGC lng,
         PBIGCTX_ARG)
/*
        Compute b = mult*a, where a and b have length lng.
        Function value is carry out of leftmost digit.
*/
{
    digit_t carry = 0;
    DWORDREG i;

    PBIGCTX_UNUSED;
    for (i = 0; i != lng; i++) {
        dblint_tc dtemp = MULTIPLY_ADD1(mult, a[i], carry);
        b[i] = LOW_DIGIT(dtemp);
        carry = HIGH_DIGIT(dtemp);
    }
    return carry;
} /* multiply_immediate */
/****************************************************************************/
BOOL WINAPI set_immediate
        (digit_t   a[],          // OUT
         digit_tc  ivalue,       // IN
         DWORDREGC lnga,         // IN
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    if (lnga == 0) {
        if (ivalue != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_OVERFLOW,
                            "set_immediate",
                            PBIGCTX_PASS);
        }
    } else {
        a[0] = ivalue;
        mp_clear(a + 1, lnga - 1, PBIGCTX_PASS);
    }
    return OK;
} // end set_immediate
/****************************************************************************/
#if 0
BOOL WINAPI big_endian_bytes_to_digits
        (const BYTE *barray,   // IN
        digit_t     *darray,   // OUT
        DWORDREGC    bitlen,   // IN
        PBIGCTX_ARG)
/*
    Copy a big-endian BYTE array to a digit_t array.
*/
{
    DWORDREGC diglen = BITS_TO_DIGITS(bitlen);
    DWORDREG ibyte, idig;
    BOOL OK = TRUE;

    if (bitlen == 0) return OK;
    mp_clear(darray, diglen, PBIGCTX_PASS);

    for (idig = 0; idig != diglen; idig++) {
        DWORDREGC bytremain = (bitlen + 7)/8 - RADIX_BYTES*idig;
        digit_t dvalue = 0;
        for (ibyte = 0; ibyte != MIN(RADIX_BYTES, bytremain); ibyte++) {
            dvalue ^= (digit_t)barray[bytremain - 1 - ibyte] << (8*ibyte);
        }
        darray[idig] = dvalue;
    } // for idig
    darray[diglen-1] &= RADIXM1 >> (RADIX_BITS*diglen - bitlen);
                                                     // Strip high bits
    return OK;
} // end big_endian_bytes_to_digits
/******************************************************************************/
BOOL WINAPI little_endian_bytes_to_digits
        (const BYTE *barray,   // IN
        digit_t     *darray,   // OUT
        DWORDREGC    bitlen,   // IN
        PBIGCTX_ARG)
/*
    Copy a little-endian BYTE array to a digit_t array.
*/
{
    DWORDREGC diglen = BITS_TO_DIGITS(bitlen);
    DWORDREG ibyte, idig;
    BOOL OK = TRUE;

    if (bitlen == 0) return OK;
    mp_clear(darray, diglen, PBIGCTX_PASS);

    for (idig = 0; idig != diglen; idig++) {
        DWORDREGC bytremain = (bitlen + 7)/8 - RADIX_BYTES*idig;
        digit_t dvalue = 0;
        for (ibyte = 0; ibyte != MIN(RADIX_BYTES, bytremain); ibyte++) {
            dvalue ^= (digit_t)barray[idig*RADIX_BYTES + ibyte] << (8*ibyte);
        }
        darray[idig] = dvalue;
    } // for idig
    darray[diglen-1] &= RADIXM1 >> (RADIX_BITS*diglen - bitlen);
                                                    // Strip high bits
    return OK;
} // end little_endian_bytes_to_digits
/******************************************************************************/
BOOL WINAPI digits_to_big_endian_bytes
       (digit_tc    *darray,   // IN
        BYTE        *barray,   // OUT
        DWORDREGC    bitlen,   // IN
        PBIGCTX_ARG)
/*
        Convert digit_t array to bytes, putting most significant byte first.
*/
{
    DWORDREG ibyte, idig;
    BOOL OK = TRUE;

    PBIGCTX_UNUSED;
    for (idig = 0; idig != BITS_TO_DIGITS(bitlen); idig++) {
        digit_t dvalue = darray[idig];
        DWORDREGC bytremain = (bitlen + 7)/8 - RADIX_BYTES*idig;
        for (ibyte = 0; ibyte != MIN(bytremain, RADIX_BYTES); ibyte++) {
            barray[bytremain - 1 - ibyte] = (BYTE)(dvalue & 0xff);
            dvalue >>= 8;
        }
    } // for idig
    return OK;
} // end digits_to_big_endian_bytes
/******************************************************************************/
BOOL WINAPI digits_to_little_endian_bytes
       (digit_tc    *darray,   // IN
        BYTE        *barray,   // OUT
        DWORDREGC    bitlen,   // IN
        PBIGCTX_ARG)
/*
        Convert digit_t array to bytes, putting least significant byte first.
*/
{
    DWORDREG ibyte, idig;
    BOOL OK = TRUE;

    PBIGCTX_UNUSED;
    for (idig = 0; idig != BITS_TO_DIGITS(bitlen); idig++) {
        digit_t dvalue = darray[idig];
        DWORDREGC bytremain = (bitlen + 7)/8 - RADIX_BYTES*idig;
        for (ibyte = 0; ibyte != MIN(bytremain, RADIX_BYTES); ibyte++) {
            barray[RADIX_BYTES*idig + ibyte] = (BYTE)(dvalue & 0xff);
            dvalue >>= 8;
        }
    } // for idig
    return OK;
} // end digits_to_little_endian_bytes
/******************************************************************************/
#endif

#if !INLINING_SUPPORTED
/****************************************************************************/
BOOL WINAPI multiply
        (digit_tc  a[],
         DWORDREGC lnga,
         digit_tc  b[],
         DWORDREGC lngb,
         digit_t   c[],
         PBIGCTX_ARG)
/*
//        Multiply a (length lnga) times b (length lngb),
//        getting a product c (length lnga + lngb).

//        The output should not overlap the inputs.
*/
{
    BOOL OK = TRUE;
    digit_tc *p1, *p2;
    DWORDREG i, lng1, lng2;

    if (lnga > lngb) {           /* Put longer operand in p1 */
        p1 = a; p2 = b; lng1 = lnga; lng2 = lngb;
    } else {
        p2 = a; p1 = b; lng2 = lnga; lng1 = lngb;
    }

    if (!OK) {
    } else if (a == c || b == c) {
        OK = FALSE;        
    } else if (lng2 == 0) {       /* If an operand has length zero */
        mp_clear(c, lng1, PBIGCTX_PASS);
    } else {
        c[lng1] = multiply_immediate(p1, p2[0], c, lng1, PBIGCTX_PASS);
        for (i = 1; i != lng2; i++) {
            c[i + lng1] = accumulate(p1, p2[i], &c[i], lng1, PBIGCTX_PASS);
        }
    }
    return OK;
} /* multiply */
#endif

void * BignumSecureZeroMemory(
    IN void* ptr,
    IN DWORD cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;

    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }

    return ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\bigerrno.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"

exportable_var_declaration volatile
    mp_errno_t mp_errno = MP_ERRNO_NO_ERROR; 
                /* No error detected so far */

mp_errno_t GetMpErrno(PBIGCTX_ARG)
{
    return mp_errno;
}

void SetMpErrno(const mp_errno_t code, PBIGCTX_ARG)
{
    mp_errno = code;
}

//   SetMpErrno_clue1 is called by the SetMpErrno_clue macro.
//   The string from the macro is passed on in debug mode but
//   replaced by a NULL pointer in production mode.

void SetMpErrno_clue1(mp_errno_tc code, const char *hint, PBIGCTX_ARG)
{
    (void)hint;     // Avoid warning if argument is unused
    SetMpErrno(code, PBIGCTX_PASS);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\bigpriv.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef __BIGPRIV_H
#define __BIGPRIV_H 1
/*
      File bigpriv.h.   Version 20 September, 2002

      Declarations accessible to bignum library but invisible to application.
      Also see ecpriv.h and fieldpriv.h
*/
/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

#include "bignum.h"

#if COMPILER == COMPILER_VC

    #pragma intrinsic(abs, labs, memcpy)

    #if TARGET != TARGET_SHX
    #pragma intrinsic(memset)
    #endif

    #pragma warning(disable: 4146 4514)  // TBD
         /* 4146 -- unary minus operator applied
            to unsigned type, result still unsigned.
            4514 -- unreferenced inline function
          */
#endif

// The next symbols relate to existence of certain hardware features.

#if TARGET == TARGET_IX86
exportable_var BOOL   MMX_available;   /* See mpglobal.c */
exportable_var BOOL  SSE2_available;
#endif

/*
     Convert between void* pointers and size_t
     (same binary representation, different types).
*/
#define vptr_to_size_t(vp) ((size_t)(vp))
#define size_t_to_vptr(vp) ((void*)((vp) + (char*)0))
/*
        vptr_roundup_alignnment(p, al) gets a pointer vp
        and rounds it up to a multiple of al, returning a void*.
        al must be a power of 2.

        If one wants to malloc a struct with 32-byte aligned items,
        then one should first malloc SIZEOF(struct) + 31 bytes.
        Use this macro to adjust the pointer received, but
        retain the original pointer for a free.
*/
#define vptr_roundup_alignment(vp, al) \
        size_t_to_vptr((vptr_to_size_t(vp) + (al) - 1) & ~(al - 1))



/*
      On IX86, Pentium 4 and higher have have an SSE2
      (Streaming SIMD Extensions 2) instruction set,
      which allows operations such as two independent 64-bit integer adds.

      All AMD64 hosts have SSE2.
      However, since digit_t has 32 bits on IX86 and 64 bits on AMD64,
      many SSE2 algorithms are different on the two architectures.
*/
#if defined(USESSE2)
        // Retain existing value
#elif TARGET == TARGET_IX86 || TARGET == TARGET_AMD64
    #define USESSE2 (TARGET_OS == OS_WNT)
                        // Avoid under WinCE
#else
    #define USESSE2 0
#endif

#if USESSE2
#include <emmintrin.h>    // SSE2 intrinsics
/*
      SSE2_digit0 through SSE2_digit3 extract
      32-bit pieces of a 128-bit integer.
      digit_0 is the rightmost (least significant) 32 bits.

      N.B.  The shift count to _mm_srli_si128 is bytes, not bits.
*/

#define SSE2_digit0(m128i) ((digit_t)_mm_cvtsi128_si32(m128i))
#define SSE2_digit1(m128i) SSE2_digit0(_mm_srli_si128(m128i, 4))
#define SSE2_digit2(m128i) SSE2_digit0(_mm_srli_si128(m128i, 8))
#define SSE2_digit3(m128i) SSE2_digit0(_mm_srli_si128(m128i, 12))

/*
     ptr_roundup_m128i rounds a pointer up to a multiple of 16 bytes,
     casting the output as __m128i .
*/
#define ptr_roundup_m128i(p) \
        ((__m128i*)vptr_roundup_alignment((void*)(p), __alignof(__m128i)))

#endif // USESSE2

/*
     Some routines allow the caller to supply temps, but
     accept a digit_NULL argument to say "Allocate them yourself!".
     possible_digit_allocate assists in doing the allocate
     if the caller passed digit_NULL.
*/

typedef struct digit_tempinfo_t {
    digit_t *address;       // Address supplied by user.
                            // Updated to specify address
                            // to use for temporaries.
    DWORDREG nelmt;         // Number of digit_t elements needed
    BOOL     need_to_free;  // Should be set FALSE by application.
                            // Changed to TRUE if a free is required.
} digit_tempinfo_t;

typedef const digit_tempinfo_t digit_tempinfo_tc;

extern BOOL WINAPI possible_digit_allocate_named(digit_tempinfo_t*,
                                                 charc*, PBIGCTX_ARG);

#define possible_digit_allocate(tempinfo, name, ctx) \
         possible_digit_allocate_named((tempinfo), \
                                       _bignum_DEBUG_ARGUMENT(name), ctx)

/*
       digit2_aligned(array) checks that _array_ is
       aligned on a 2*SIZEOF(digit_t) boundary.

       Assembly code versions of the software sometimes load
       or store two digit_t values with one instruction.
       Specifically, MMX code on X86 can load or store two 32-bit
       digit_t values with one 64-bit MOVQ instruction.
       IA-64 code can load two 64-bit values to the floating
       point registers with a load pair instruction.

       The digit2_aligned macro checks whether its operand is
       appropriately aligned.  The required alignment is never
       worse than that returned by mp_alloc_temp.
*/

#if TARGET == TARGET_IX86 || TARGET == TARGET_IA64
   // TBD -- revise this
#define digit2_aligned(array) (((size_t)(array) & (2*SIZEOF(digit_t) - 1)) == 0)
#else
#define digit2_aligned(array) (TRUE)
#endif

/*
     The following are used while manipulating signed operands.
     Only the bottom 32 bits of the signed length are used.
*/

#define sign_of(lng) ((DWORD)(lng) & DWORD_LEFT_BIT)
#define abs_of(lng)  (SHAVE32(sign_of(lng) ? 0-(lng) : (lng)) )

extern BOOL WINAPI modmul_choices1(mp_modulus_t*, int*, PBIGCTX_ARG);

extern BOOL WINAPI modmul_choicesSSE2(mp_modulus_t*, int*, PBIGCTX_ARG);

#ifdef __cplusplus
}
#endif

#endif  //  __BIGPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\bignum.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef BIGNUM_H              /* If not previously #included */
#define BIGNUM_H 1

/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

#include "bigdefs.h"


#if TARGET_OS == OS_ATTILA
#define MP_LONGEST_BITS 1024
#else
#define MP_LONGEST_BITS 2048
#endif
                        /*
                           Multiple precision moduli can have up to
                           MP_LONGEST_BITS bits, which is
                           MP_LONGEST words.  Some routines allow
                           longer operands.

                           Older codes have used this (and MP_LONGEST, below)
                           to dimension arrays.  New code should avoid
                           referencing MP_LONGEST and MP_LONGEST_BITS.

                        */


                        /*
                           Error messages are not printed in the
                           production version of the code.
                           In the test version, compiled
                           with PRINT_ERROR_MESSAGES=1,
                           they are printed,
                        */



/*
      _bignum_SOURCE_INFO() returns a string with file name
       and line number information
      (identifying where macro is invoked, not where it is declared).
*/

#define _bignum_SOURCE_INFO() __FILE__ " line " _bignum_STRINGIFY(__LINE__)
#define _bignum_STRINGIFY(arg) _bignum_STRINGIFY1(arg)
#define _bignum_STRINGIFY1(arg) #arg


/*
    _bignum_DEBUG_ARGUMENT is used to pass an argument only during debugging.
    In release mode a zero is passed.
    It could be used to pass a string identifying the caller, for example.
*/


#if PRINT_ERROR_MESSAGES
    #define _bignum_DEBUG_ARGUMENT(arg) (arg)
#else     
    #define _bignum_DEBUG_ARGUMENT(arg) 0
#endif

#define MP_LONGEST (MP_LONGEST_BITS/RADIX_BITS)


/*
        USEASM_ALPHA, ... specify whether to use assembly language,
        if it has been written for a platform.
*/
// #define USEASM 0

#ifndef USEASM
    #if TARGET == TARGET_ALPHA
        #define USEASM 1
    #elif TARGET == TARGET_AMD64
        #define USEASM 1
    #elif TARGET == TARGET_ARM && TARGET_OS == OS_ATTILA
        #define USEASM 1
    #elif TARGET == TARGET_IA64
        #define USEASM 1
    #elif TARGET == TARGET_IX86
        #define USEASM 1
    #elif TARGET == TARGET_MIPS
        #define USEASM 1
    #elif TARGET == TARGET_PPC
        #define USEASM 1
    #elif TARGET == TARGET_SHX
        #define USEASM 1
    #elif TARGET == TARGET_SPARC
        #define USEASM 1
    #else
        #define USEASM 0
    #endif
#endif

#if !defined(USEASM) || (USEASM != 0 && USEASM != 1)
    #error "USEASM not defined"
#endif

#define USEASM_ALPHA    (USEASM && TARGET == TARGET_ALPHA)
#define USEASM_AMD64    (USEASM && TARGET == TARGET_AMD64)
#define USEASM_ARM      (USEASM && TARGET == TARGET_ARM)
#define USEASM_IA64     (USEASM && TARGET == TARGET_IA64)
#define USEASM_IX86     (USEASM && TARGET == TARGET_IX86)
#define USEASM_MIPS     (USEASM && TARGET == TARGET_MIPS)
#define USEASM_PPC      (USEASM && TARGET == TARGET_PPC)
#define USEASM_SHX      (USEASM && TARGET == TARGET_SHX)
#define USEASM_SPARC    (USEASM && TARGET == TARGET_SPARC)


#if USEASM_SHX
void __asm(const char*, ...);  // this declaration needed to allow inline of asm
#endif

/*
        Some non-inlined x86 assembly routines are declared naked,
        so they do their own stack management and register saving.

        When using a DLL on Intel platforms, all functions use
        the __stdcall convention, so the assembly routines use it too.
        To ensure they are called with the __stdcall
        conventions always (i.e., even when compiled under Microsoft
        Developer Studio), we put __stdcall explicitly in the prototypes.
*/

#if USEASM_IX86    // TBD -- eliminate this
    #define Naked86 __declspec(naked)
    #define Stdcall86 __stdcall
#else
    #define Naked86
    #define Stdcall86
#endif


/*
        DOUBLE_SHIFT_LEFT(n1, n0, amt) returns
        n1 shifted left by amt bits,
        with new bits coming in from the top of n0.

        DOUBLE_SHIFT_RIGHT(n1, n0, amt) returns n0 shifted right
        by amt bits, with new bits coming from the bottom of n1.

        The shift counts must satisfy 0 <= amt <= RADIX_BITS - 1.
        The shift by    RADIX_BITS - amt   is done in two stages
        (first by 1, then by RADIX_BITS - 1 - amt),
        to avoid an illegal shift count of RADIX_BITS when amt = 0.

        DOUBLE_SHIFT_LEFT_NONZERO and DOUBLE_SHIFT_RIGHT_NONZERO
        are similar, but disallow a zero shift count, allowing the
        RADIX_BITS - amt shift to be done in one stage,
        DOUBLE_SHIFT_LEFT_NONZERO(n1, n0, amt) is the same as
        DOUBLE_SHIFT_RIGHT_NONZERO(n1, n0, RADIX_BITS - amt).

        TBD -- If the x86 VC compiler optimizes __int64 shifts,
        (6.0 SP3 does not), try to rewrite these definitions to generate
        SHLD and SHRD instructions..
*/

#define DOUBLE_SHIFT_LEFT(n1, n0, amt)  \
        (((n1) << (amt)) | (((n0) >> 1) >> (RADIX_BITS - 1 - (amt))))

#define DOUBLE_SHIFT_LEFT_NONZERO(n1, n0, amt)  \
        (((n1) << (amt)) | ((n0) >> (RADIX_BITS - (amt))))

#define DOUBLE_SHIFT_RIGHT(n1, n0, amt)  \
        (((n0) >> (amt)) | (((n1) << 1) << (RADIX_BITS - 1 - (amt))))

#define DOUBLE_SHIFT_RIGHT_NONZERO(n1, n0, amt)  \
        (((n0) >> (amt)) | ((n1) << (RADIX_BITS - (amt))))

#include "dblint.h"

#define exportable_var extern
#define exportable_var_declaration

/*
      Some struct names are referenced in #include files before they are
      defined.  For example, there might be two struct definitions each
      containing a pointer to the other struct type.
      We list some struct names in advance here, to avoid warnings.
*/
Future_Struct(mp_modulus_t);      // See this file
Future_Struct(digit_tempinfo_t);  // See bigpriv.h

#ifndef __cplusplus
// typedef struct ec_NIST_t;          TBD   // See ecpriv.h
// typedef struct k2nmulshifts_t;        // See field2n.c
#endif

/*
        The reciprocal_1_t type is used when div21
        or divide or divide_immediate would otherwise
        divide by the same number repeatedly.  See file divide.c.
*/

typedef struct {
                digit_t    multiplier;
                DWORDREG   shiftamt;
               } reciprocal_1_t;

typedef const reciprocal_1_t reciprocal_1_tc;

/*
        mp_modulus_t struct has modulus-dependent constants
        used for fast reduction (typically for a fixed modulus,
        which will be used several times, as in modular exponentiation).
        These constants are initialized by function create_modulus:

        modulus -- Modulus used for computations.  Must be nonzero.

        length  -- Length (>= 1) of the modulus, without leading zeros.
                   Operands to mod_add, mod_mul, mod_sub, ...
                   are assumed to have this length.

        reddir  -- Equal to FROM_LEFT if reductions of
                   products are done from the left (traditional
                   division), and to FROM_RIGHT if reductions of
                   products are done from the right (Montgomery reduction).

                   When using FROM_RIGHT, the modulus must be odd.
                   Arguments to mod_mul should be pre-scaled by
                   2^scaling_power2 (mod modulus).
                   The product will be similarly scaled.

        scaling_power2 --  Equal to length*RADIX_BITS when reddir = FROM_RIGHT.
                   Zero if reddir = FROM_LEFT.

        one --     Constant 1 (muldiplicative identity), length length.
                   Nmerical value is 2^scaling_power2 (mod modulus).
    Denote

              length = pmodulo->length
              modulus = pmodulo->modulus
              shiftamt = pmodulo->left_reciprocal_1.shiftamt.

          Then

              0 <= shiftamt < RADIX_BITS
              RADIX^length/2 <= modulus * 2^shiftamt < RADIX^length
              modulus < RADIX^length / 2^shiftamt <= 2*modulus

          Some variants of modmul_algorithm use additional constants
          lngred2, multiplier_first, multiplier_second.
          FROM_LEFT arithmetic, these constants satisfy

              modulus * (multiplier_second + RADIX^lngred2)
            = RADIX^(length + lngred2) / 2^shiftamt + multiplier_first

              0 <= multiplier_first < modulus
              0 <= multiplier_second < RADIX^lngred2
              lngred2 = CEIL(length/2)

         For FROM_RIGHT arithmetic, these constants satisfy

              multiplier_second * modulus
            = 1 + multiplier_first * RADIX^lngred2

              0 <= multipler_first < modulus
              0 <= multiplier_second < RADIX^lngred2
              lngred2 = CEIL(length/2)

        one --     Constant 1 (multiplicative identity).
                   For FROM_LEFT arithmetic, pmodulo->one = 1.
                   For FROM_RIGHT arithmetic,
                       pmodulo->one = (RADIX^length) % pmodulus;

        left_reciprocal_1 -- Reciprocal of the divisor starting at the
                   leftmost digit (i.e., modulus[length-1]);

                   See file divide.c for an explanation
                   about how this constant is used to get accurate
                   quotients when dividing from the left.

        right_reciprocal_1 -- If modulus is odd, this holds
                   1/modulus (mod RADIX), for use in mod_shift.
                   Otherwise the field is zero.

          Denote

              length = pmodulo->length
              modulus = pmodulo->modulus
              shiftamt = pmodulo->left_reciprocal_1.shiftamt.

          Then

              0 <= shiftamt < RADIX_BITS
              RADIX^length/2 <= modulus * 2^shiftamt < RADIX^length
              modulus < RADIX^length / 2^shiftamt <= 2*modulus

        modmul_algorithm --
              This library has a variety of codes for modular multiplication.
              The mp_modulus_t struct has a pointer to the precise code
              being used for a particular number and architecture.  A call

                    (*modmul_algorithm)(a, b, c, pmodulo, temps)

              is supposed to set

                     c = a*b/3^(pmodulo->scaling_power2)  (mod pmodulo->modulus)

              where 0 <= a, b, < pmodulo->modulus.
              The output c may overlap a or b.

              The temps array will have at least pmodulo->modmul_algorithm_temps
              elements of type digit_t, aligned on a digit_t boundary.

              The simplest modmul_algoriuthm procedures,
              modmul_from_left_default and modmul_from_right_default,
              work on all architectures.

              In some implementations of this library, create_modulus may
              examine the precise modulus and the precise hardware
              we are running on, substituting another algorithm
              or an assembly language code.

              Some variants of modmul_algorithm use additional constants
              lngred2, multiplier_first, multiplier_second.
              In FROM_LEFT arithmetic, these constants satisfy

                  modulus * (multiplier_second + RADIX^lngred2 + 1))
                = RADIX^(length + lngred2) / 2^shiftamt + multiplier_first

                  0 <= multiplier_first < modulus
                  0 <= multiplier_second < RADIX^lngred2
                  lngred2 = CEIL(length/2)

             For FROM_RIGHT arithmetic, these constants satisfy

                  multiplier_second * modulus
                = 1 + multiplier_first * RADIX^lngred2

                  0 <= multipler_first < modulus
                  0 <= multiplier_second < RADIX^lngred2
                  lngred2 = CEIL(length/2)
*/

Future_Struct(mp_modulus_t);

typedef BOOL WINAPI modmul_algorithm_t (MP_INPUT, MP_INPUT, MP_OUTPUT,
                                   const struct mp_modulus_t*,
                                   MP_MODIFIED, PBIGCTX_ARG);

typedef enum {FROM_LEFT, FROM_RIGHT} reddir_t;
typedef const reddir_t reddir_tc;

typedef struct mp_modulus_t {
                  DWORDREG  length;         // Length passed to create_modulus
                  DWORDREG  lngred2;        // CEIL(length/2)
                  DWORDREG  modmul_algorithm_temps; // Number of digit_t temps
                                                    // used by modmul_algorithm
                  int       scaling_power2; // RADIX_BITS*length for FROM_RIGHT,
                                            // 0 for FROM_LEFT
                  reddir_t  reddir;         // FROM_LEFT or FROM_RIGHT */
                  reciprocal_1_t  left_reciprocal_1;
                  digit_t   right_reciprocal_1;  // 1/modulus[0] mod RADIX,
                                                 // if modulus is odd
                  digit_t   *modulus;
                  digit_t   *multiplier_first;  // See text
                  digit_t   *multiplier_second; // See text
                  digit_t   *one;               // Multiplicative constant 1
                  digit_t   *cofactor;
                             /*
                                In factorization codes, this holds
                                the cofactor (length length) after
                                dividing modulus by any factors found.
                                Used by gcdex_jacobi.
                            */
                  modmul_algorithm_t *modmul_algorithm;
                                  // Function pointer for multiplication
                  const char *modmul_algorithm_name;
                                  // Name of modmul_algorithm procedure
                                  // while debugging or testing, else zero.
                } mp_modulus_t;

typedef const mp_modulus_t mp_modulus_tc;
#define mp_modulus_NULL ((mp_modulus_t*)0)

/*
        mod_exp2000 returns statistics on what happened during an
        exponentiation.
*/

typedef struct {              // Statistics from mod_exp2000
                              // This struct may change in future versions.
        DWORDREG cnt_mod_add;           // Calls to mod_add
        DWORDREG cnt_mod_mul;           // Calls to mod_mul
        DWORDREG cnt_mod_shift;         // Calls to mod_shift
        DWORDREG cnt_mp_copy;           // Calls to mp_copy
    } mod_exp_stats_t;

/*
        When an error is detected, the SetMpErrno_clue macro gets
        an error code (below) and an English-language string
        with more information.
        This macro will normally call an application-supplied routine.
        The application routine might print a message or set a global variable.

        The library routine detecting the error will exit with return value
        FALSE, notifying its caller that something abnormal occurred.

        Except for MP_ERRNO_NO_ERROR, the error codes are
        in alphabetical order.
*/

typedef enum {
        MP_ERRNO_NO_ERROR = 0,     // Success
               // Broader codes, introduced September, 2002.
        MP_ERRNO_DEGREE_OVERFLOW,  // Polynomial degree too high
                                   // for allocated memory
        MP_ERRNO_DIVIDE_ZERO, // Divide by zero (or by number with leading zero)
        MP_ERRNO_ELSEWHERE,        // Error indicator returned by some routine
                                   // which may not have called SetMpErrno_clue
                                   // (e.g., CRYPTAPI library, assembly codes)
        MP_ERRNO_INTERNAL_ERROR,   // Bug found -- please report
        MP_ERRNO_INVALID_DATA,     // Invalid arguments
        MP_ERRNO_MODULAR_TOO_BIG,  // Modular operand >= modulus
        MP_ERRNO_NO_MEMORY,        // From mp_alloc_temp - malloc failure
        MP_ERRNO_NOT_IMPLEMENTED,  // Case not implemented
        MP_ERRNO_NOT_INVERTIBLE,   // Perhaps trying to invert modulo non-prime
        MP_ERRNO_NOT_ON_CURVE,     // Point is not on elliptic curve
        MP_ERRNO_NULL_POINTER,   // NULL argument where valid argument expected
        MP_ERRNO_OVERFLOW,       // Integer overflow (or unexpectedly negative)
        MP_ERRNO_OVERLAPPING_ARGS, // Overlapping (i.e., duplicate) arguments
                                   // where they are disallowed
        MP_ERRNO_TOO_MANY_ITERATIONS,  // e.g., unable to find large prime
        MP_ERRNO_ZERO_OPERAND,     // Zero operand(s) where nonzero expected

        MP_ERRNO_COUNT             // Number of entries above
    } mp_errno_t;

typedef const mp_errno_t mp_errno_tc;
extern const char* mp_errno_name(mp_errno_tc);  // Table of strings

//   User-supplied error routines.
//   In debug mode,the SetMpErrno_clue macro passes
//   the string directly to the SetMpErrno_clue1 function.
//   In release mode, this string is replaced by a zero.

extern mp_errno_t GetMpErrno(PBIGCTX_ARG);
extern void SetMpErrno(mp_errno_tc, PBIGCTX_ARG);
extern void SetMpErrno_clue1(mp_errno_tc, const char*, PBIGCTX_ARG);
#define SetMpErrno_clue(errcode, debug_info, ctx) \
        SetMpErrno_clue1(errcode, "", ctx)

/*
        Some routine allow an argument of digit_NULL or
        reciprocal_1_NULL when the corresponding argument
        is not otherwise used.  For example, the division
        routine allows but does not require a
        reciprocal structure as argument,
        and allows the quotient to be suppressed.
*/

#define digit_NULL ((digit_t*)0)
#define reciprocal_1_NULL ((reciprocal_1_t*)0)

/*
        The next several #defines are used in function prototypes.
*/

extern digit_t WINAPI accumulate(MP_INPUT, digit_tc, MP_MODIFIED,
                                 DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI add_diff(MP_INPUT, DWORDREGC, MP_INPUT, DWORDREGC,
                            MP_OUTPUT, digit_t*, PBIGCTX_ARG);

extern BOOL WINAPI add_full(MP_INPUT, DWORDREGC, MP_INPUT,
                            DWORDREGC, MP_OUTPUT, DWORDREG*, PBIGCTX_ARG);

extern digit_t WINAPI add_immediate(MP_INPUT, digit_tc, MP_OUTPUT, DWORDREGC);

extern BOOL WINAPI add_mod(MP_INPUT, MP_INPUT, MP_OUTPUT, MP_INPUT,
                           DWORDREGC, PBIGCTX_ARG);

extern digit_t WINAPI add_same(MP_INPUT, MP_INPUT, MP_OUTPUT, DWORDREGC);

extern BOOL WINAPI add_signed(MP_INPUT, DWORDC, MP_INPUT, DWORDC,
                              MP_OUTPUT, DWORD*, PBIGCTX_ARG);

extern BOOL WINAPI add_signed_immediate(MP_INPUT, DWORDC, sdigit_tc,
                                        MP_OUTPUT, DWORD*, PBIGCTX_ARG);

extern sdigit_t WINAPI add_sub_same(MP_INPUT, MP_INPUT, MP_INPUT,
                                    MP_OUTPUT, DWORDREGC);

extern int WINAPI compare_diff(MP_INPUT, DWORDREGC, MP_INPUT, DWORDREGC);

extern int WINAPI compare_same(MP_INPUT, MP_INPUT, DWORDREGC);

extern int WINAPI compare_sum_diff(MP_INPUT, DWORDREGC,
                                   MP_INPUT, DWORDREGC, MP_INPUT, DWORDREGC);

extern int WINAPI compare_sum_same(MP_INPUT, MP_INPUT, MP_INPUT, DWORDREGC);

extern BOOL WINAPI create_modulus(MP_INPUT, DWORDREGC, reddir_tc,
                                  mp_modulus_t*, PBIGCTX_ARG, 
                                  struct bigctx_t *);

extern BOOL WINAPI dblint_gcd(dblint_tc, dblint_tc, dblint_t*, PBIGCTX_ARG);

extern BOOL WINAPI dblint_ogcd(dblint_tc, dblint_tc, dblint_t*, PBIGCTX_ARG);

extern digit_t WINAPI dblint_sqrt(dblint_tc, PBIGCTX_ARG);

extern digit_t WINAPI decumulate(MP_INPUT, digit_tc, MP_MODIFIED,
                                 DWORDREGC, PBIGCTX_ARG);

extern digit_t* WINAPI digit_allocate_named(DWORDREGC,
                                            const char*, PBIGCTX_ARG);
#define digit_allocate(nelmt, name, ctx) digit_allocate_named(nelmt, \
                                              _bignum_DEBUG_ARGUMENT(name), ctx)

extern DWORDREG WINAPI digit_factor(digit_tc, digit_t[],
                                    DWORDREG[], PBIGCTX_ARG);

extern BOOL WINAPI digit_gcd(digit_tc, digit_tc, digit_t*, PBIGCTX_ARG);

extern BOOL WINAPI digit_jacobi(digit_tc, digit_tc, int*, PBIGCTX_ARG);

extern digit_t WINAPI digit_least_prime_divisor(digit_tc, PBIGCTX_ARG);

extern BOOL WINAPI digit_mod_divide_odd(digit_tc, digit_tc, digit_tc,
                                        digit_t*, PBIGCTX_ARG);

extern BOOL WINAPI digit_ogcd(digit_tc, digit_tc, digit_t*, PBIGCTX_ARG);

#define MP_DECIMAL_BUFFER(lng) (3 + 28*RADIX_BITS*(lng)/93)
       /* Upper bound on length of ASCII decimal output buffer for number
          with lng digit_t's.  Includes sign and trailing zero.
          28/93 = 0.301075 ... is upper bound for log10(2) = 0.301030 ... */

typedef char digit_out_buf_t[MP_DECIMAL_BUFFER(1)];
extern char* WINAPI digit_out  ( digit_tc, digit_out_buf_t,
                                PBIGCTX_ARG); // Decimal unsigned
extern char* WINAPI sdigit_out (sdigit_tc, digit_out_buf_t,
                                PBIGCTX_ARG); // Decimal   signed
extern char* WINAPI digit_out_hex( digit_tc, digit_out_buf_t,
                                  PBIGCTX_ARG);  // Hex unsigned

extern digit_t WINAPI digit_sqrt(digit_tc, PBIGCTX_ARG);

extern BOOL WINAPI div21(dblint_tc, digit_tc, digit_t*, digit_t*, PBIGCTX_ARG);

EXTERN_INLINE BOOL WINAPI div21_fast(dblint_tc, digit_tc,
                       reciprocal_1_tc*, digit_t*, digit_t*, PBIGCTX_ARG);

extern BOOL WINAPI divide(MP_INPUT, DWORDREGC, MP_INPUT, DWORDREGC,
                       reciprocal_1_tc*, MP_OUTPUT, MP_OUTPUT, PBIGCTX_ARG);

extern BOOL WINAPI divide_rounded(MP_INPUT, DWORDREGC, MP_INPUT, DWORDREGC,
                       reciprocal_1_tc*, MP_OUTPUT, MP_OUTPUT,
                       DWORD*, PBIGCTX_ARG);

extern BOOL WINAPI divide_precondition_1(MP_INPUT, DWORDREGC,
                                         reciprocal_1_t*, PBIGCTX_ARG);

extern BOOL WINAPI divide_immediate(MP_INPUT, digit_tc,
                         reciprocal_1_tc*, MP_OUTPUT, DWORDREGC,
                         digit_t*, PBIGCTX_ARG);

EXTERN_INLINE digit_t WINAPI estimated_quotient_1(digit_tc, digit_tc,
                                    digit_tc, reciprocal_1_tc*, PBIGCTX_ARG);

extern BOOL WINAPI find_big_prime(DWORDREGC, MP_INPUT, DWORDREGC,
                           MP_INPUT, DWORDREGC, MP_OUTPUT, PBIGCTX_ARG);

extern BOOL WINAPI from_modular(MP_INPUT, MP_OUTPUT,
                                mp_modulus_tc*, PBIGCTX_ARG);

extern BOOL WINAPI gcdex_jacobi(MP_INPUT, mp_modulus_tc*, MP_OUTPUT,
                                MP_OUTPUT, int*, PBIGCTX_ARG);

// extern BOOL WINAPI get_generator(DWORD*, DWORD*, DWORDC);

// extern BOOL WINAPI get_prime(MP_OUTPUT, DWORDREGC);

extern digit_t* WINAPI low_prime_prod_construction(PBIGCTX_ARG);
extern void WINAPI low_prime_prod_destruction(digit_t*, PBIGCTX_ARG);
extern BOOL WINAPI low_prime_divisibility(MP_INPUT, DWORDREGC,
                                          digit_tc*, digit_t*, PBIGCTX_ARG);

#define mod_add(a, b, c, pmodulo, ctx) add_mod(a, b, c, (pmodulo)->modulus,\
                                                   (pmodulo)->length, ctx)

extern BOOL WINAPI mod_exp(MP_INPUT, MP_INPUT, DWORDREGC, MP_OUTPUT,
                        mp_modulus_tc*, PBIGCTX_ARG);

extern BOOL WINAPI mod_exp2000(MP_INPUT, MP_INPUT, DWORDREGC, MP_OUTPUT,
                        mp_modulus_tc*, mod_exp_stats_t*, PBIGCTX_ARG);

extern DWORDREG WINAPI mod_exp_immediate(MP_INPUT, digit_tc, MP_OUTPUT,
                                  mp_modulus_tc*, PBIGCTX_ARG);

#if 0
#define mod_jacobi_immediate(r, modulo, pjcbi, ctx) \
      mp_jacobi_immediate(r, (modulo)->modulus, (modulo)->length, pjcbi, ctx)

extern BOOL WINAPI mod_jacobi_immediate(sdigit_tc, mp_modulus_tc*,
                                        int*, PBIGCTX_ARG);
#endif

extern BOOL WINAPI mod_Lucas(MP_INPUT, MP_INPUT, DWORDREGC, MP_OUTPUT,
                      mp_modulus_tc*, PBIGCTX_ARG);

extern BOOL WINAPI mod_LucasUV(MP_INPUT, MP_INPUT, MP_INPUT, DWORDREGC,
                        MP_OUTPUT, MP_OUTPUT, mp_modulus_tc*, PBIGCTX_ARG);

extern BOOL WINAPI mod_mul(MP_INPUT, MP_INPUT, MP_OUTPUT,
                    mp_modulus_tc*, MP_MODIFIED, PBIGCTX_ARG);

extern BOOL WINAPI mod_mul_immediate(MP_INPUT, digit_tc,
                              MP_OUTPUT, mp_modulus_tc*, PBIGCTX_ARG);

#define mod_negate(a, b, pmodulo, ctx) neg_mod(a, b, (pmodulo)->modulus,\
                                             (pmodulo)->length, ctx)

extern BOOL WINAPI mod_shift(MP_INPUT, intc, MP_OUTPUT,
                             mp_modulus_tc*, PBIGCTX_ARG);

extern BOOL WINAPI mod_sqrt(MP_INPUT, MP_OUTPUT, mp_modulus_tc*,
                            BOOL*, PBIGCTX_ARG);

#define mod_sub(a, b, c, pmodulo, ctx) sub_mod(a, b, c, (pmodulo)->modulus, \
                                                        (pmodulo)->length, ctx)

extern void* WINAPI mp_alloc_temp(DWORDREGC, charc*, PBIGCTX_ARG);
#define Allocate_Temporaries(typename, ptr, ctx) \
        Allocate_Temporaries_Multiple(1, typename, ptr, ctx)

#define Allocate_Temporaries_Multiple(nelmt, typename, ptr, ctx) \
               ptr = (typename*)mp_alloc_temp((nelmt)*SIZEOF(typename), \
                          _bignum_DEBUG_ARGUMENT(_bignum_SOURCE_INFO()), ctx )

extern char* WINAPI mp_decimal(MP_INPUT, DWORDREGC, char*, PBIGCTX_ARG);

extern long WINAPI mp_decimal_parse(charc*, MP_OUTPUT, DWORDREGC,
                                    charc**, PBIGCTX_ARG);

extern char* WINAPI mp_dword_decimal(DWORDC*, DWORDREGC,
                                     char *buf, PBIGCTX_ARG);

extern int WINAPI mp_format(MP_INPUT, DWORDREGC,
                     digit_tc, charc*, char*, DWORDREGC, PBIGCTX_ARG);

extern void WINAPI mp_free_temp(void*, charc*, PBIGCTX_ARG);
#define Free_Temporaries(ptr, ctx)    mp_free_temp(/* (void*) */ (ptr), \
                  _bignum_DEBUG_ARGUMENT(_bignum_SOURCE_INFO()), ctx )


extern BOOL WINAPI mp_gcd(MP_INPUT, DWORDREGC, MP_INPUT, DWORDREGC,
                          MP_OUTPUT, DWORDREG*, PBIGCTX_ARG);

extern BOOL WINAPI mp_gcdex
       (MP_INPUT, DWORDREGC,
        MP_INPUT, DWORDREGC,
        MP_OUTPUT, MP_OUTPUT,
        MP_OUTPUT, MP_OUTPUT,
        DWORDREG*, MP_MODIFIED, PBIGCTX_ARG);

EXTERN_INLINE DWORDREG WINAPI mp_gcdex_ntemps
        (DWORDREGC, DWORDREGC, PBIGCTX_ARG);
           // Temporary count required by last argument to mp_gcdex

extern BOOL WINAPI mp_initialization(PBIGCTX_ARG);

EXTERN_INLINE DWORDREG WINAPI mp_invert_ntemps(DWORDREGC, PBIGCTX_ARG);
           // Temporary count required by last argument to mp_invert

extern BOOL WINAPI mp_invert(MP_INPUT, MP_INPUT, DWORDREGC,
                             MP_OUTPUT, const char*,
                             MP_MODIFIED, PBIGCTX_ARG);

extern BOOL WINAPI mp_jacobi_immediate   (sdigit_tc, MP_INPUT,
                                          DWORDREGC, int*, PBIGCTX_ARG);

extern BOOL WINAPI mp_jacobi_wrt_immediate(MP_INPUT, DWORDREGC,
                                           digit_tc, int*, PBIGCTX_ARG);

extern BOOL WINAPI mp_mul22s(digit_tc[4], MP_MODIFIED, MP_MODIFIED,
                             DWORDREGC, sdigit_t[2], PBIGCTX_ARG);

extern BOOL WINAPI mp_mul22u(digit_tc[4], MP_MODIFIED, MP_MODIFIED,
                             DWORDREGC,  digit_t[2], PBIGCTX_ARG);

extern DWORDREG mp_remove2(MP_MODIFIED, DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI mp_shift(MP_INPUT, intc, MP_OUTPUT,
                            DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI mp_shift_lost(MP_INPUT, intc, MP_OUTPUT,
                                 DWORDREGC, digit_t*, PBIGCTX_ARG);

extern BOOL WINAPI mp_sqrt(MP_INPUT, MP_OUTPUT, DWORDREGC,
                           BOOL*, PBIGCTX_ARG);

extern digit_t WINAPI multiply_immediate(MP_INPUT, digit_tc,
                                         MP_OUTPUT, DWORDREGC, PBIGCTX_ARG);

extern void WINAPI multiply_low(MP_INPUT, MP_INPUT, MP_OUTPUT,
                                DWORDREGC, PBIGCTX_ARG);
// TBD -- should interface change?

extern BOOL WINAPI multiply_signed(MP_INPUT, DWORDC, MP_INPUT, DWORDC,
                                   MP_OUTPUT, DWORD*, PBIGCTX_ARG);

extern BOOL WINAPI multiply_signed_immediate(MP_INPUT, DWORDC,
                                       sdigit_tc, MP_OUTPUT,
                                       DWORD*, PBIGCTX_ARG);

extern BOOL WINAPI neg_mod(MP_INPUT, MP_OUTPUT, MP_INPUT,
                           DWORDREGC, PBIGCTX_ARG);

#if TARGET_OS == OS_WCE || TARGET_OS == OS_ATTILA
    #define PRIME_SIEVE_LENGTH 300
#else
    #define PRIME_SIEVE_LENGTH 3000
#endif
          // Must be multiple of 3
#if PRIME_SIEVE_LENGTH % 3 != 0
    #error "PRIME_SIEVE_LENGTH must be a multiple of 3"
#endif

typedef struct {
    digit_t sievbeg;
    digit_t max_sieved_squared;
    digit_t sieve[PRIME_SIEVE_LENGTH];
} next_prime_info_t;

#define next_prime_info_NULL ((next_prime_info_t*)0)

extern BOOL WINAPI next_prime(digit_tc, next_prime_info_t*,
                              digit_t*, PBIGCTX_ARG);
extern BOOL WINAPI next_prime_initialization(next_prime_info_t*, PBIGCTX_ARG);

extern BOOL WINAPI probable_prime(MP_INPUT, DWORDREGC, MP_INPUT,
                                  DWORDREGC, DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI remove_small_primes(MP_INPUT, DWORDREGC, digit_tc,
                                digit_t[], DWORDREG[], DWORDREG*,
                                MP_OUTPUT, DWORDREG*, PBIGCTX_ARG);

extern BOOL WINAPI set_immediate(MP_OUTPUT, digit_tc, DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI set_immediate_signed(MP_OUTPUT, sdigit_tc,
                                        DWORD*, PBIGCTX_ARG);

extern BOOL WINAPI signed_ashift(MP_INPUT, intc, MP_OUTPUT,
                                 DWORDC, DWORD*, PBIGCTX_ARG);

extern digit_t WINAPI signed_low(MP_INPUT, DWORDC);

extern DWORDREG WINAPI signed_mp_significant_bit_count(MP_INPUT, DWORDC,
                                                       PBIGCTX_ARG);

#define validate_modular_data(a, mod, lng, name, ctx) validate_modular_data1 \
                  ((a), (mod), (lng), _bignum_DEBUG_ARGUMENT((name)), ctx )
extern BOOL WINAPI validate_modular_data1(MP_INPUT, MP_INPUT,
                                         DWORDREGC, const char*, PBIGCTX_ARG);
#if !INLINING_SUPPORTED

extern BOOL WINAPI multiply(digit_tc  a[],DWORDREGC lnga,digit_tc  b[],DWORDREGC lngb,digit_t   c[],PBIGCTX_ARG);

#else

/****************************************************************************/
FORCE_INLINE BOOL WINAPI multiply
        (digit_tc  a[],
         DWORDREGC lnga,
         digit_tc  b[],
         DWORDREGC lngb,
         digit_t   c[],
         PBIGCTX_ARG)
/*
//        Multiply a (length lnga) times b (length lngb),
//        getting a product c (length lnga + lngb).

//        The output should not overlap the inputs.
*/
{
    BOOL OK = TRUE;
    digit_tc *p1, *p2;
    DWORDREG i, lng1, lng2;

    if (lnga > lngb) {           /* Put longer operand in p1 */
        p1 = a; p2 = b; lng1 = lnga; lng2 = lngb;
    } else {
        p2 = a; p1 = b; lng2 = lnga; lng1 = lngb;
    }

    if (!OK) {
    } else if (a == c || b == c) {
        OK = FALSE;        
    } else if (lng2 == 0) {       /* If an operand has length zero */
        mp_clear(c, lng1, PBIGCTX_PASS);
    } else {
        c[lng1] = multiply_immediate(p1, p2[0], c, lng1, PBIGCTX_PASS);
        for (i = 1; i != lng2; i++) {
            c[i + lng1] = accumulate(p1, p2[i], &c[i], lng1, PBIGCTX_PASS);
        }
    }
    return OK;
} /* multiply */

#endif

#if INLINING_SUPPORTED && USEASM_IX86
    #define significant_bit_count significant_bit_count_ix86
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 1
    #pragma warning(disable : 4035)      /* No return value */
    static inline DWORDREG significant_bit_count(digit_tc pattern)
    {
    _asm {
            mov  eax,pattern        ; Nonzero pattern
            bsr  eax,eax            ; eax = index of leftmost nonzero bit
            inc  eax                ; Add one to get significant bit count
         }
    }
    #pragma warning(default : 4035)
#elif INLINING_SUPPORTED && USEASM_ALPHA
    #define significant_bit_count significant_bit_count_alpha
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 1
    extern const BYTE half_byte_significant_bit_count[128];  /* See bignum.c */
            /*
                The Alpha code uses the CMPBGE instruction to
                identify which bytes are nonzero.  The most significant
                bit must occur within the leftmost nonzero byte.
                We use the CMPBGE output to identify which byte that is.
                After we extract that byte,
                we identify its most significant bit.

                (Starting with EV6 (21264), one can use leading zero count.)
            */
    static inline DWORDREG significant_bit_count(digit_tc pattern)
    {
        DWORDREGC zero_byte_pattern = __asm("cmpbge  zero, %0, v0", pattern);

        DWORDREGC byte_offset_plus_1
                = 8*half_byte_significant_bit_count[127
                                      - (zero_byte_pattern >> 1)] + 1;

        return byte_offset_plus_1
               + half_byte_significant_bit_count[pattern >> byte_offset_plus_1];
    }
#else
    #define UNIFORM_SIGNIFICANT_BIT_COUNT 0
           /* Algorithm faster for larger inputs.  See mpmisc.c */
#endif

extern BOOL WINAPI sub_diff(MP_INPUT, DWORDREGC, MP_INPUT, DWORDREGC,
                            MP_OUTPUT, digit_t*, PBIGCTX_ARG);

extern digit_t WINAPI sub_immediate(MP_INPUT, digit_tc, MP_OUTPUT, DWORDREGC);

extern BOOL WINAPI sub_mod(MP_INPUT, MP_INPUT, MP_OUTPUT, MP_INPUT,
                           DWORDREGC, PBIGCTX_ARG);

extern digit_t WINAPI sub_same(MP_INPUT, MP_INPUT, MP_OUTPUT, DWORDREGC);

#define sub_signed(a, lnga, b, lngb, c, plngc, ctx) \
        add_signed(a, lnga, b, 0-(lngb), c, plngc, ctx)

extern BOOL WINAPI test_primality(MP_INPUT, DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI test_primality_check_low(MP_INPUT, DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI to_modular(MP_INPUT, DWORDREGC, MP_OUTPUT,
                              mp_modulus_tc*, PBIGCTX_ARG);

extern BOOL WINAPI two_adic_inverse(digit_tc, digit_t*, PBIGCTX_ARG);

extern void WINAPI uncreate_modulus(mp_modulus_t*, PBIGCTX_ARG);

#if PRINT_ERROR_MESSAGES
    extern BOOL WINAPI mp_decimal_output(FILE*, MP_INPUT, DWORDREGC,
                                         charc*, PBIGCTX_ARG);

    extern void WINAPI mp_display(FILE*, charc*, MP_INPUT,
                                  DWORDREGC, PBIGCTX_ARG);
#endif /* PRINT_ERROR_MESSAGES */


#if !INLINING_SUPPORTED
extern int WINAPI compare_immediate(MP_INPUT, digit_tc, DWORDREGC);
extern digit_t WINAPI sub_immediate(MP_INPUT, digit_tc, MP_OUTPUT, DWORDREGC);
#endif


#if INLINING_SUPPORTED
/***************************************************************************/
INLINE int WINAPI compare_immediate
        (digit_tc  a[],
         digit_tc  ivalue,
         DWORDREGC    lng)
/*
        Compare a multiple-precision number to a scalar.
*/
{
    return compare_diff(a, lng, &ivalue, 1);
}
/****************************************************************************/
#if USEASM_MIPS
   /* See mips.s */
#else
#define significant_digit_count significant_digit_count_inlined
INLINE DWORDREG WINAPI significant_digit_count
        (digit_tc  a[],
         DWORDREGC lng)
/*
        Return the number of significant digits in a.
        Function value is zero precisely when a == 0.
*/
#if USEASM_IX86
    #pragma warning(disable : 4035)      /* No return value */
{
                /*
                   We could use REPE SCASD,
                   but the REPE overhead is
                   four cycles/compare on early Pentiums.
                   We would also need sld and cld.
                   It is shorter to use RISC instructions.
                   We anticipate that the leading term a[lng-1]
                   will usually be nonzero.
                */

    _asm {
        mov  eax,lng
        mov  edx,a
     label1:
        test eax,eax
        jz   label2             ; If nothing left in number, return 0

        mov  ecx,[edx+4*eax-4]
        dec  eax

        test ecx,ecx            ; Test leading digit
        jz   label1

        inc  eax                ; Nonzero element found; return old eax
     label2:
    }
}
    #pragma warning(default : 4035)
#else
{
    DWORDREG i = lng;

    while (i != 0 && a[i-1] == 0) i--;
    return i;
}  /* significant_digit_count */
#endif
#endif
/****************************************************************************/
#if USEASM_IX86
#define trailing_zero_count trailing_zero_count_ix86
INLINE DWORDREG trailing_zero_count(digit_tc d)
    #pragma warning(disable : 4035)      /* No return value */
{
    _asm {
            mov  eax,d
            bsf  eax,eax            ; eax = index of rightmost nonzero bit
         }
}
    #pragma warning(default : 4035)
#elif UNIFORM_SIGNIFICANT_BIT_COUNT
#define trailing_zero_count trailing_zero_count_inlined
static inline DWORDREG WINAPI trailing_zero_count(digit_tc d)
/*
        Given a nonzero integer d, this routine computes
        the largest integer n such that 2^n divides d.

        If d = 2^n * (2k + 1), then

                        d =     k *2^(n+1) + 2^n
                       -d = (-1-k)*2^(n+1) + 2^n

        The integers k and -1 - k are one's complements of
        each other, so d & (-d) = 2^n.  Once we determine
        2^n from d, we can get n via significant_bit_count.

        If architecture has population count, one can use
        POPULATION((d-1) & ~d)).
*/
{
    return significant_bit_count(d & (-d)) - 1;
}  /* trailing_zero_count */
#endif

#endif  // INLINING_SUPPORTED


#ifdef __cplusplus
}
#endif

#endif // BIGNUM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\config.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/****************************************************************************
*
*
*	FILENAME:	config.h
*
*	PRODUCT NAME:	CRYPTOGRAPHIC TOOLKIT
*
*	FILE STATUS:
*
*	DESCRIPTION:	Cryptographic Toolkit Configuration File
*			Machine Architecture Dependant Definitions
*		    
*
*	PUBLIC FUNCTIONS:
*
*
*	REVISION  HISTORY:
*
*
*		10 Feb 96	AK		Created
*
*
* Created for Cylink Corporation by Secant
*
****************************************************************************/

#ifndef CONFIG_H
#define CONFIG_H


/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif


/*************************************
*
* Module Defines
*
*************************************/


/* Define if you have the ANSI C header files.  */
#define	STDC_HEADERS		1


/* Define processor endian */
#define	LITTLE_ENDIAN
/* define BIG_ENDIAN */


/* use ANSI or K&R style C? */
#define __USE_ANSI_C__ 		1


/* Define ORD size */
#define	ORD_16
/* #define	ORD_32 */

/* Bit Size */
#ifdef ORD_16
#define BITS_COUNT	16
#else
#define BITS_COUNT	32
#endif


/* Max digit */
#define	MAXDIGIT	(ord)(0xFFFF)


/* The number of bytes in a double.  */
#define SIZEOF_DOUBLE		8


/* The number of bytes in a int.  */
#define SIZEOF_INT		4


/* The number of bytes in a long.  */
#define SIZEOF_LONG		4


/* The number of bytes in a short.  */
#define SIZEOF_SHORT		2


/***************************************
*
* Perform checks
*
***************************************/

/* Check endian */
#if  !defined(LITTLE_ENDIAN) && !defined(BIG_ENDIAN)
#error Not defined CPU type LITTLE or BIG ENDIAN.
#endif
#if  defined(LITTLE_ENDIAN) && defined(BIG_ENDIAN)
#error Use only one define CPU type LITTLE or BIG ENDIAN.
#endif


/* Check ord size */
#if !defined(ORD_16) && !defined(ORD_32)
#error Not defined ORD size for the machine.
#endif
#if defined(ORD_16) && defined(ORD_32)
#error Machine size cannot be both 16 and 32.
#endif


#ifdef __cplusplus
}
#endif


#endif /* CONFIG_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\cryptdsa.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef __CRYPTDSA_H
#define __CRYPTDSA_H

//  September, 2002 -- petmon.  This and cryptdsa.c have not been altered
//       to use DWORDREG since I don't know the implications
//       on the rest of CAPI.   TBD
//
//       P.S.  DWORD arrays in dsa_dwkey_t should perhaps be converted to BYTE.

#ifdef __cplusplus
extern "C" {
#endif

#include "ecapi.h"          // SHA
#include "mprand.h"         // RNGINFO

#define SHA_BITS      (8*A_SHA_DIGEST_LEN)
                            // Number of bits output by SHA
#define SHA_DWORDS    (A_SHA_DIGEST_LEN / 4)
                            // Number of DWORDS output by SHA
#if SHA_BITS != DWORD_BITS*SHA_DWORDS
   #error -- "A_SHA_DIGEST_LEN not multiple of 4 bytes"
#endif


#define DSA_Q_MINDWORDS 5
                            // Minimum number of DWORDS in q
#define DSA_Q_MAXDWORDS 128
                            // Maximum number of DWORDS in q
#define DSA_P_MINDWORDS 16
                            // Minimum number of DWORDS in p
#define DSA_P_MAXDWORDS 128
                            // Maximum number of DWORDS in p

#define DSA_Q_MAXDIGITS DWORDS_TO_DIGITS(DSA_Q_MAXDWORDS)
#define DSA_P_MAXDIGITS DWORDS_TO_DIGITS(DSA_P_MAXDWORDS)

//   The DSA algorithms require modular exponentiation.
//   The DSA codes will normally invoke
//   DSA_exponentiator_default to do this exponentiation,
//   but the application may substitute a specialized one of its own.
//   The dsa_exponentiator_t type declares the interface
//   to that routine.

//   A specialized exponentiation routine might
//   observe that, when signing, the base never varies.
//   When verifying, there is one base from the generator
//   and one base per public key.  The exponentiator might
//   take advantage of the fixed bases.

//   The precise argument list to an exponentiator
//   may change in later versions of this library.

//   If one is using a specialized hardware coprocessor, then
//   the exponentiation interface should copy the
//   digit_t arguments to BYTE arrays or whatever
//   the hardware expects.
//   You may need to convert between FROM_LEFT and FROM_RIGHT
//   formats.


typedef BOOL WINAPI dsa_exponentiator_t
        (MP_INPUT       base,       // In
         MP_INPUT       exponent,   // In
         DWORDREGC      nbitq,      // In (number of bits in exponent)
                                    // Unused bits in top word are zero-filled
         MP_OUTPUT      result,     // Out
         mp_modulus_tc *modulo,     // In   Modulus
         PBIGCTX_ARG);

//    dsa_dwkey_t holds a public or private key, in external (DWORD) format

typedef struct {
        DWORD    nbitp;             // Number of significant bits in p.
                                    // (Multiple of 64,   512 <= nbitp <= 1024)
        DWORD    nbitq;             // Number of significant bits in q.
                                    // Must be exactly 160.
        DWORD    nbitx;             // Number of bits in x.
                                    // Will equal nbitq for new keys
                                    //      (Longhorn and later).
                                    // May equal nbitp for older keys.
        DWORD    p[DSA_P_MAXDWORDS];// Public prime p, 512-1024 bits
        DWORD    q[DSA_Q_MAXDWORDS];// Public prime q (160 bits, divides p-1)
        DWORD    g[DSA_P_MAXDWORDS];// Public generator g of order q (mod p)
 //       DWORD    j[DSA_P_MAXDWORDS];// j = (p - 1) / q
        DWORD    x[DSA_P_MAXDWORDS];// Private exponent (zero in putlic key)
                                             //    x (mod q or mod p)
        DWORD    y[DSA_P_MAXDWORDS];// Public value g^x (mod p),
                                    //     where x is private
        DWORD    S[SHA_DWORDS];     // 160-bit pattern used to construct q
        DWORD    C;                 // 12-bit value of C used to construct p
               } dsa_dwkey_t;
typedef const dsa_dwkey_t  dsa_dwkey_tc;

typedef struct {
 //       VOID *pOffload;           // pointer to exponentiation offload info
// TBD above not used
        dsa_exponentiator_t *pExponentiator;
        RNGINFO *pRNGInfo;        // pointer to Random Number Generator info
        } dsa_other_info_t;

typedef const dsa_other_info_t  dsa_other_info_tc;

typedef struct {
                dsa_dwkey_tc  *pdwkey;                // Pointer to public or
                                                      // private key in
                                                      // external format
                dsa_other_info_t other;               // Exponentiator
                                                      //   RNG addresses
                DWORDREG       lngq_digits;           // Length of q in digits
                reciprocal_1_t qrecip;                // Information about 1/q
                digit_t        gmodular[DSA_P_MAXDIGITS];
                                                      // g as residue mod p
                digit_t        qdigit[DSA_Q_MAXDIGITS];
                digit_t        xdigit[DSA_P_MAXDIGITS];
                                                // Private exponent x (or zero)
                digit_t        ymodular[DSA_P_MAXDIGITS];
                                                         // y as residue mod p
                mp_modulus_t   pmodulus;                 // Constants mod p
               } dsa_fullkey_t;

typedef const dsa_fullkey_t     dsa_fullkey_tc;

typedef struct {
        DWORD r[SHA_DWORDS];            // (g^k mod p)       mod q
        DWORD s[SHA_DWORDS];            // (SHA(m) + x*r)/k  mod q
               } dsa_signature_t;

typedef const dsa_signature_t   dsa_signature_tc;

// DSA_check_g switched to static November, 2002   petmon

//BOOL WINAPI DSA_check_g
//        (DWORDREGC       lngp_digits,                   // In
//         digit_tc       *pGModular,                    // In
//         mp_modulus_t   *pPModulo,                     // In
//         DWORDREGC      lngq_digits,                   // In
//         digit_tc       *pQDigit);                     // In

extern BOOL WINAPI DSA_build_fullkey
        (dsa_dwkey_tc      *pdwkey,          // In
         dsa_other_info_tc *pother,          // In
         dsa_fullkey_t     *pfullkey,        // In
         const BOOL         checkSC,         // In
         PBIGCTX_ARG);

extern dsa_exponentiator_t DSA_exponentiator_default;


extern BOOL WINAPI DSA_key_generation
        (DWORDC             nbitp,           // In
         DWORDC             nbitq,           // In
         dsa_other_info_tc *pother,          // In
         dsa_fullkey_t     *pfullkey,        // Out
         dsa_dwkey_t       *dwkey,           // Out
         PBIGCTX_ARG);

extern BOOL WINAPI DSA_parameter_verification(
                                dsa_fullkey_tc  *fullkey,  // In
                                PBIGCTX_ARG
                                );
#if 0
extern BOOL WINAPI DSA_convert_pgy
        (dsa_dwkey_tc      *dwkey,            // In
         dsa_fullkey_t     *pfullkey);        // Out
#endif

extern BOOL WINAPI DSA_sign
        (DWORDC             message_hash[SHA_DWORDS],   // In
         dsa_fullkey_tc    *pfullkey,                   // In
         dsa_signature_t   *signature,                  // Out
         PBIGCTX_ARG);

extern BOOL WINAPI DSA_signature_verification
        (DWORDC              message_hash[SHA_DWORDS],  // In
         dsa_fullkey_tc      *pfullkey,                 // In
         dsa_signature_tc    *signature,                // In
         BOOL                *pverified,                // Out
         PBIGCTX_ARG);
       // Users of
       //            DSA_build_fullkey,
       //            DSA_key_generation

       //       are responsible for subsequent call to DSA_unbuild_fullkey

extern void WINAPI DSA_unbuild_fullkey
        (dsa_fullkey_t   *pfullkey,                     // In/Out
         PBIGCTX_ARG);


#if 0
extern BOOL WINAPI DSA_verify_j
        (dsa_fullkey_tc  *fullkey);                     // In
// TBD -- Who uses verify_j?  It needs to be put in the test suite.
#endif

#ifdef __cplusplus
}
#endif

#endif __CRYPTDSA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\divide.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"

#ifndef assert
#include <assert.h>
#endif

/*
        File divide.c  Version 02 November 2002.


        This file has five routines:

        BOOL div21(db, d, &q, &r, PBIGCTX_ARG) --
                                        Divide dblint_t db by d,
                                        where db < d*RADIX (so that
                                        0 <= quotient < RADIX).
                                        The quotient is stored in q,
                                        and the remainder in r.

        BOOL div21_fast(db, d, &recip, &q, &r, PBIGCTX_ARG)--
                                        Similar to div21,
                                        but useful when dividing by
                                        the same denominator
                                        repeatedly.  The recip
                                        argument (of type reciprocal_1_t)
                                        must have been initialized
                                        by divide_precondition_1.
                                        The algorithm uses two
                                        multiplications
                                        (top and bottom halves of each)
                                        and several additions/subtractions.

        BOOL divide(numer, lnum, denom, lden, &recip,
                    quot, rem, plrem, PBIGCTX_ARG) --
                                        Divide numer (of length lnum)
                                        by denom (of length lden).
                                        Quotient
                                        (of length MAX(lnum - lden + 1 ,0))
                                        goes to quot and
                                        remainder (length lden) to rem.
                                        recip can be a reciprocal_1_t
                                        struct for the denominator,
                                        or reciprocal_1_NULL.

        BOOL divide_immediate(numer, den, &recip,
                              quot, lng, prem, PBIGCTX_ARG) --
                                        Divide numer (of length lng)
                                        by den (of length 1);
                                        quotient goes to quot
                                        and remainder to *prem.
                                        recip can be the reciprocal_1_t
                                        struct for the denominator,
                                        or reciprocal_1_NULL.

        BOOL divide_precondition_1(denom, lng, &reciprocal, PBIGCTX_ARG)
                                        Initialize a reciprocal_1_t
                                        struct for div21_fast or
                                        divide or divide_immediate.

        Also see divide_rounded in divround.c

        The div21 code is slow but assumes only ANSI C.


                Some architectures (e.g., Intel 386, Power PC,
        Motorola 68020, 32-bit SPARC version 8)
        have a hardware instruction to divide a double-length integer
        by a single-length integer.  On such machines,
        the translation of div21 into assembly code
        is straightforward (although we may need to compute
        the remainder via a multiplication and subtraction).
        Other architectures (e.g., MIPS, 64-bit SPARC version 9)
        have an integer division instruction but allow only
        single-length numerator and denominator.
        Still other architectures (e.g., Alpha, IA-64)
        lack an integer divide instruction.
        On the latter architectures, the div21_fast algorithm is attractive.
        Even when there is a hardware instruction which functions
        like div21, the alternative code is attractive if
        division is much slower than multiplication.

                The div21_fast algorithm resembles that on p. 68 of

                        Torjborn Granlund and Peter L. Montgomery,
                        Division by Invariant Integers using Multiplication,
                        pp. 61-72 of Proceedings of SIGPLAN '94 Conference on
                        Programming Language Design and Implementation (PLDI),
                        ACM Press, 1994.

                Let DBOUND = RADIX be a strict upper bound on the divisor.
        and QBOUND = RADIX be a strict upper bound on the quotient.
        These should be powers of 2, with QBOUND dividing DBOUND.
        (The multiple-precision modular reduction
        analogue of this algorithm uses DBOUND = QBOUND^2.)
        Suppose we want to divide repeatedly by d, where 0 < d < DBOUND.
        Start by computing three constants dependent only on d:

                shiftamt = LOG2(DBOUND) - 1 - FLOOR(LOG2(d))
                dnorm = d * 2^shiftamt      // Normalized divisor
                multiplier = FLOOR((DBOUND*QBOUND - 1)/dnorm) - QBOUND

        Also define k = QBOUND*DBOUND - (multiplier + QBOUND)*dnorm.
        These satisfy

                DBOUND/2 <= dnorm < DBOUND
                0 <= multiplier < QBOUND
                0 < k <= dnorm

                Later, given n with 0 <= n <= d*QBOUND - 1,
        do the following computations:

                qprod, nshifted hold values in [0, QBOUND*DBOUND - 1]
                remest holds values in [1-DBOUND, DBOUND-1]
                qest, nshiftedhi hold values in [0, QBOUND - 1]

                nshifted   = n * 2^shiftamt;
                nshiftedhi = FLOOR(nshifted/DBOUND);
                nshiftedlo = (nshifted mod DBOUND);

                adjust = (top bit of nshiftedlo)*FLOOR(multiplier/2);
                qprod =   nshifted
                        + (multiplier*nshiftedhi + adjust)*DBOUND/QBOUND;
                qest = FLOOR(qprod/DBOUND);
                remest = n - qest*d - d;
                if (remest < 0) then
                    quotient is qest, remainder is remest + d
                else
                    quotient is qest+1, remainder is remest
                end if

        We claim that the correct quotient is either qest or qest + 1.
        We achieve this by proving

(*)            0 <= nshifted/dnorm - qprod/DBOUND < 1.

        Add this to qest <= qprod/DBOUND < qest + 1
        and use nshifted/dnorm = n/d to prove

                qest <= n/d < qest + 2.

        Therefore FLOOR(n/d) is either qest or qest + 1.

                Inequality (a) will be useful later:

  (a)     0 <= multiplier*nshiftedlo/DBOUND - adjust
            <  (multiplier + 1)/2
             = (QBOUND*DBOUND - k - QBOUND*dnorm + dnorm)/(2*dnorm)

        The proof of (a) has two cases:

                Case 1:  0 <= nshiftedlo < DBOUND/2 and adjust = 0;

                Case 2:  DBOUND/2 <= nshiftedlo < DBOUND
                         and adjust = FLOOR(multiplier/2).

        Each case is straightforward.

                Next check that

               qprod*QBOUND
             = nshifted*QBOUND + (multiplier*nshiftedhi + adjust)*DBOUND
             =   nshifted*QBOUND
               + multiplier*(nshifted - nshiftedlo) + adjust*DBOUND
             =   nshifted * (multiplier + QBOUND)
               - (multiplier*nshiftedlo - adjust*DBOUND)
             =   nshifted * (QBOUND * DBOUND - k)/dnorm
               - (multiplier*nshiftedlo - adjust*DBOUND)   .

        Multiply this by dnorm/DBOUND to get

                 QBOUND*(nshifted - qprod*dnorm/DBOUND)
             =   QBOUND*nshifted
               - nshifted*(QBOUND*DBOUND - k)/DBOUND
               + dnorm*(multiplier*nshiftedlo - adjust*DBOUND)/DBOUND
             =   nshifted*k/DBOUND
               + dnorm*(multiplier*nshiftedlo/DBOUND - adjust) .

        By (a), the right side above is nonnegative,
        which proves the left inequality in (*).
        Using nshifted < QBOUND*dnorm and (a),
        we can bound the right side above by

        QBOUND*(nshifted - qprod*dnorm/DBOUND)
      = nshifted*k/DBOUND + dnorm*(multiplier*nshiftedlo/DBOUND - adjust)
     <  QBOUND*dnorm*k/DBOUND + (QBOUND*DBOUND - k - QBOUND*dnorm + dnorm)/2
      = k*(QBOUND*dnorm/DBOUND - 1/2) + dnorm/2 + QBOUND*(DBOUND - dnorm)/2
     <=   dnorm*(QBOUND*dnorm/DBOUND - 1/2)
        + dnorm/2 + QBOUND*(DBOUND - dnorm)/2
      = QBOUND*dnorm - QBOUND*(DBOUND - dnorm)*(dnorm/DBOUND - 1/2)
     <= QBOUND*dnorm.

        (we used QBOUND*dnorm/DBOUND >= QBOUND/2 >= 1/2 above).
        This proves the right inequality in (*).
*/

/****************************************************************************/
EXPORTED_INLINE digit_t WINAPI estimated_quotient_1
        (digit_tc         n2,
         digit_tc         n1,
         digit_tc         n0,
         reciprocal_1_tc *recip,
         PBIGCTX_ARG)
/*
        This routine estimates a quotient digit given
        the three most significant digits of the unshifted
        numerator and given the multiplier from
        divide_precondition_1.

        The quotient returned will be in the interval
        [0, RADIX - 1] and will be correct or one too low.
*/
{
    dblint_t qprod;
    digit_tc nshiftedhi = DOUBLE_SHIFT_LEFT(n2, n1, recip->shiftamt);
    digit_tc nshiftedlo = DOUBLE_SHIFT_LEFT(n1, n0, recip->shiftamt);

    PBIGCTX_UNUSED;
    qprod = DBLINT_ADD(MAKE_DBLINT(nshiftedhi, nshiftedlo),
                       DPRODUU(nshiftedhi, recip->multiplier));

    if (nshiftedlo & RADIX_HALF) {
        qprod = DBLINT_ADD(qprod, DBLINT(recip->multiplier >> 1));
    }
    return HIGH_DIGIT(qprod);
} /* estimated_quotient_1 */
/****************************************************************************/
BOOL WINAPI div21(dblint_tc db,        /* Dividend */
                  digit_tc d,          /* Divisor */
                  digit_t *quot,       /* Quotient (output) */
                  digit_t *rem,        /* Remainder (output) */
                  PBIGCTX_ARG)
/*
                This routine divides a double-length
        dividend (db = nhigh * RADIX + nlow) by a single-length divisor (d).
        All arguments are unsigned.
        We require db < d*RADIX, to ensure the quotient will be <= RADIX - 1.
        The quotient *quot and the remainder *rem satisfy the usual rules:

                0 <= *rem < d
                db = d * (*quot) + (*rem)
*/
{
    BOOL OK = TRUE;
    digit_tc nhigh = HIGH_DIGIT(db), nlow = LOW_DIGIT(db);
    if (!OK) {
    } else if (nhigh >= d) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA, "div21", PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
        if (mp_errfil != NULL) {
            digit_out_buf_t dbuf1, dbuf2, dbuf3;
            fflush(stdout);
            fprintf(mp_errfil, "Invalid div21 arguments: "
                "numerator = %s:%s, divisor = %s\n",
                digit_out(nhigh, dbuf1, PBIGCTX_PASS),
                digit_out(nlow, dbuf2, PBIGCTX_PASS),
                digit_out(d, dbuf3, PBIGCTX_PASS));
            fflush(mp_errfil);
        }
#endif
    } else {   /* nhigh < d */

#if DBLINT_BUILTIN
/*
                Use the 2-digit / 1-digit division built into the language.
*/
        digit_tc q = (digit_t)(db/DBLINT(d));
        *quot = q;
        *rem = nlow - d*q;
#else /* DBLINT_BUILTIN */
/*
                Construct quotient one bit at a time.
*/
        digit_t rhigh = nhigh, rlow = nlow, q = 0, ipow2;

        for (ipow2 = RADIX_HALF; ipow2 != 0; ipow2 >>= 1) {
/*
                At this point,

                nhigh * RADIX + nlow
              = q*d + rhigh*(2*ipow2) + rlow*(2*ipow2/RADIX)

                0 <= rhigh < d

                If 2*rhigh + 2*rlow/RADIX >= d, increase q by ipow2.
                Avoid integer overflow during the test.
*/
            digit_t rlow_hibit = rlow >> (RADIX_BITS - 1);

            if (rhigh + rlow_hibit >= d - rhigh) {
                q += ipow2;
                rlow_hibit -= d;
            }
            rhigh = 2*rhigh + rlow_hibit;
            rlow <<= 1;
        } /* for ipow2 */
/*
        Store quotient and remainder.  rlow is zero now.
*/
        *quot = q;
        *rem = rhigh;
#endif /* DBLINT_BUILTIN */
    } /* if nhigh */
    return OK;
} /* div21 */
/****************************************************************************/
EXPORTED_INLINE BOOL WINAPI div21_fast
        (dblint_tc         db,
         digit_tc           d,
         reciprocal_1_tc  *recip,
         digit_t          *quot,
         digit_t          *rem,
         PBIGCTX_ARG)
{
/*
        See start of file for explanation of algorithm.
*/
    digit_tc n1 = HIGH_DIGIT(db);
    digit_tc n0 = LOW_DIGIT(db);
    digit_tc qestcomp
        = RADIXM1 - estimated_quotient_1(n1, n0, 0, recip, PBIGCTX_PASS);
                                             /* RADIX - 1 - qest */

    dblint_tc remest = DBLINT_ADD(MAKE_DBLINT(n1 - d, n0),
                                  DPRODUU(qestcomp, d) );

/*
        remest = (n1 - d)*RADIX + n0 + (RADIX - 1 - qest)*d
               = n1*RADIX + n0 - (qest + 1)*d
        is the remainder using qest+1 as estimated quotient.
        Be careful since qest+1 may equal RADIX.
        remest is in [-d, d - 1]

        If HIGH_DIGIT(remest) = 0, then remest is nonnegative;
        set the quotient to qest + 1 = RADIX - qestcomp
        and the remainder to LOW_DIGIT(remest).
        Otherwise HIGH_DIGIT(remest) = RADIXM1;
        set the quotient to qest = RADIXM1 - qestcomp
        and the remainder to LOW_DIGIT(remest) + d - RADIX.
*/
    *quot = HIGH_DIGIT(remest) - qestcomp;
    *rem  = LOW_DIGIT(remest) + (d & HIGH_DIGIT(remest));
    return TRUE;
} /* div21_fast */
/****************************************************************************/
BOOL WINAPI divide
        (digit_tc  numer[],
         DWORDREGC    lnum,
         digit_tc  denom[],
         DWORDREGC    lden,
         reciprocal_1_tc *supplied_reciprocal,
                                   /* reciprocal_t struct for this denominator,
                                      or reciprocal_1_NULL
                                      if not previously precomputed */
         digit_t   quot[],     /* Quotient -- length MAX(lnum - lden + 1, 0) */
         digit_t   rem[],      /* Remainder -- length lden  */
         PBIGCTX_ARG)
/*
        Divide numer (of length lnum) by denom (of length lden).
        Fifth argument can be the reciprocal_1_t struct
        from divide_precondition_1 if same denominator is used
        repeatedly, or can be reciprocal_1_NULL if
        this denominator is new.

        Quotient (of length MAX(lnum - lden + 1, 0)) is put in quot.
        However, if quot == digit_NULL, no quotient is returned.

        Remainder (of length lden) is put in rem.
        There is no option to suppress the remainder.

        Function value is the number of significant digits
        in the remainder.  The function value is zero precisely
        when the remainder is zero.

        Quotient and remainder should not overlap other arguments.
        The leading digit of the denominator should be nonzero.
*/
{
    BOOL OK = TRUE;
    digit_t dlead;

    if (lden == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_DIVIDE_ZERO, "divide", PBIGCTX_PASS);
    } else if (numer == digit_NULL || denom == digit_NULL || rem == digit_NULL){
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "divide", PBIGCTX_PASS);
    } else if (numer == quot || numer == rem || denom == quot || denom == rem) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_OVERLAPPING_ARGS, "divide", PBIGCTX_PASS);
    }
    if (OK) {
        dlead = denom[lden - 1];
        if (dlead == 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "divide -- leading zero",
                            PBIGCTX_PASS);
        } else if (lnum < lden) {
            mp_extend(numer, lnum, rem, lden, PBIGCTX_PASS);
                             // Quotient length zero
        } else if (lden == 1) {
            OK = OK && divide_immediate(numer, dlead, supplied_reciprocal,
                                        quot, lnum, &rem[0], PBIGCTX_PASS);
        } else {
            DWORDREG iq, i;
            reciprocal_1_t computed_reciprocal;
            reciprocal_1_tc *used_reciprocal;

            used_reciprocal = supplied_reciprocal;
            if (used_reciprocal == reciprocal_1_NULL) {
                divide_precondition_1(denom, lden,
                                      &computed_reciprocal, PBIGCTX_PASS);
                used_reciprocal = &computed_reciprocal;
            }
/*
                Copy top lden-1 words of numerator to remainder.
                Zero most significant word of remainder.
*/
            rem[lden-1] = 0;
            mp_copy(&numer[lnum-lden+1], rem, lden-1, PBIGCTX_PASS);

            for (iq = lnum-lden+1; OK && (iq--) != 0; /*null*/) {
                digit_tc remtop = rem[lden-1];
                digit_t qest;
/*
                    Multiply old remainder by RADIX.  Add numer[iq].
*/
                for (i = lden-1; i != 0; i--) {
                    rem[i] = rem[i-1];
                }
                rem[0] = numer[iq];
/*
                    Check for zero digit in quotient.
                    This is especially likely to happen on the
                    first iteration of the iq loop.
*/
                if (remtop == 0 && compare_same(rem, denom, lden) < 0) {
                    qest = 0;
                } else {
                    digit_t borrow;
                    qest = estimated_quotient_1(remtop, rem[lden-1],
                                                rem[lden-2],
                                                used_reciprocal,
                                                PBIGCTX_PASS);
                       /* qest is correct or one too low */
                    qest += (qest < RADIXM1);
                       /* Now qest is correct or one too high */
                    borrow = decumulate(denom, qest, rem, lden, PBIGCTX_PASS);
                       /* Subtract qest*denom from rem */
                    if (borrow > remtop) { // If estimated quotient is too high
                        qest--;
                        borrow -= add_same(rem, denom, rem, lden);
                    }

                    if (borrow != remtop) {
                        OK = FALSE;
                        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                        "divide -- bad qest\n", PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
                        if (mp_errfil != NULL) {
                            digit_out_buf_t dbuf1, dbuf2;
                            fflush(stdout);
                            fprintf(mp_errfil,
                                "Quotient estimation error in divide.\n");
                            fprintf(mp_errfil,
                                "borrow = %s, numtop = %s, shift = %ld\n",
                                digit_out(borrow, dbuf1, PBIGCTX_PASS),
                                digit_out(remtop, dbuf2, PBIGCTX_PASS),
                               (long)used_reciprocal->shiftamt);
                            fflush(mp_errfil);
                        }
#endif
                    }
                } /* qest == 0 */

                if (quot != digit_NULL) quot[iq] = qest;
            }  /* for iq */
        }
    }
    return OK;
}  /* divide */
/****************************************************************************/
BOOL WINAPI divide_immediate
        (digit_tc  numer[],
         digit_tc  den,
         reciprocal_1_tc *supplied_reciprocal,
         digit_t   quot[],
         DWORDREGC  lng,
         digit_t    *prem,      // OUT (remainder)
         PBIGCTX_ARG)
/*
        Divide numer (length lng) by den (length 1).
        Quotient (length lng) is written to quot (or can be suppressed
        if quot = digit_NULL).
        Remainder is returned as function value.

        supplied_reciprocal is the output of
        divide_precondition_1 for this denominator,
        or can be reciprocal_1_NULL if reciprocal was not
        previously computed.
*/
{
    BOOL OK = TRUE;
    digit_t carry = 0;
    DWORDREG i, lngleft = lng;

    if (lngleft > 0 && numer[lngleft-1] < den) {
        lngleft--;
        carry = numer[lngleft];
        if (quot != digit_NULL) quot[lngleft] = 0;
    }

    if (supplied_reciprocal == reciprocal_1_NULL && lngleft < 2) {
        for (i = lngleft; (i--) != 0; /*null*/) {
            digit_t qest = 0;
            OK = OK && div21(MAKE_DBLINT(carry, numer[i]),
                             den, &qest, &carry, PBIGCTX_PASS);
            if (quot != digit_NULL) quot[i] = qest;
        }
    } else {
        reciprocal_1_t computed_reciprocal;
        reciprocal_1_tc *used_reciprocal = supplied_reciprocal;

        if (used_reciprocal == reciprocal_1_NULL) {
            OK = OK && divide_precondition_1(&den, 1,
                              &computed_reciprocal, PBIGCTX_PASS);
            used_reciprocal = &computed_reciprocal;
        }

        for (i = lngleft; OK && (i--) != 0; /*null*/) {
            digit_t qest = 0;
            OK = OK && div21_fast(MAKE_DBLINT(carry, numer[i]),
                                   den,used_reciprocal, &qest,
                                   &carry, PBIGCTX_PASS);
            if (quot != digit_NULL) quot[i] = qest;
        }
    }
    if (OK) *prem = carry;
    return OK;
} /* divide_immediate */
/****************************************************************************/
BOOL WINAPI divide_precondition_1
        (digit_tc        denom[],
         DWORDREGC       lden,
         reciprocal_1_t *recip,
         PBIGCTX_ARG)
/*
        This routine computes the reciprocal_1_t structure
        for the denominator denom, of length lden.
        The leading digit denom[lden-1] must be nonzero.
        It computes a multiplier accurate enough for estimated_quotient_1
        to predict one digit of a quotient (with an error at most 1).
        This is the case QBOUND = RADIX, DBOUND = RADIX^lden
        of the theory atop this file.
*/
{
    BOOL OK = TRUE;

    if (denom == digit_NULL || recip == reciprocal_1_NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER,
                        "divide_precondition_1", PBIGCTX_PASS);
    } else if (lden == 0 || denom[lden-1] == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "divide_precondition_1", PBIGCTX_PASS);
    } else {
        DWORDREG iden, recip_shift;
        digit_t recip_multiplier = 0, dlead[3], dshiftedhi, dshiftedlo, rem = 0;

        recip_shift = RADIX_BITS - significant_bit_count(denom[lden-1]);
        dlead[2] = denom[lden-1];
        dlead[1] = (lden >= 2 ? denom[lden-2] : 0);
        dlead[0] = (lden >= 3 ? denom[lden-3] : 0);

        dshiftedhi = DOUBLE_SHIFT_LEFT(dlead[2], dlead[1], recip_shift);
        dshiftedlo = DOUBLE_SHIFT_LEFT(dlead[1], dlead[0], recip_shift);
/*
             We want our RADIX + multiplier to be the integer part of

                               RADIX^lden - 1
             ---------------------------------------------------------
             dshiftedhi*RADIX^(lden-2) + dshiftedlo*RADIX^(lden-3) + ...


        The leading digit of this quotient is 1*RADIX^1
        since dshiftedhi >= RADIX/2.
        After subtracting RADIX*denominator from the numerator,
        we get the next digit of the quotient by approximating
        the denominator by dshiftedhi*RADIX^(lden-1). Standard theory
        (see, e.g., Knuth, Seminumerical Algorithms, 1981,
        Theorem B, p. 257) says the so-estimated quotient
        differs from the real quotient by at most 2,
        and the so-estimated quotient is never smaller than the real
        quotient.  When we use the two leading digits from the
        divisor, the error in the estimate can be at most one.
        We allow one correction while looking at
        the dshiftedlo term and one more later on.
*/

        OK = OK && div21(MAKE_DBLINT(RADIXM1 - dshiftedhi,
                                     RADIXM1 - dshiftedlo),
                         dshiftedhi, &recip_multiplier, &rem, PBIGCTX_PASS);

/*
                Quick adjustment.  Check the sign of

//        RADIX^3 - 1 - (RADIX + multiplier)*(dshiftedhi*RADIX + dshiftedlo)
//       =    RADIX*(RADIX^2 - 1 - dshiftedhi*RADIX - dshliftedlo)
//         - multiplier*(dshiftedhi*RADIX + dshiftedlo)
//         + RADIX - 1
//      = RADIX*(rem + multiplier*dshiftedhi) + RADIX - 1
//         - multiplier*(dshiftedhi*RADIX + dshiftedlo)
//      = rem*RADIX + RADIX - 1 - multiplier*dshiftedlo
*/
        if (OK) {
            if (HPRODUU(recip_multiplier, dshiftedlo) > rem) {
                recip_multiplier--;
            }

/*
                Fine adjustment.  Check the sign of

                      RADIX^(lden+1)/2^shiftamt - 1
                    - (RADIX+multiplier)*denom[lden-1:0].

                If this is negative, then the multiplier is too large.
                If this is nonnegative, then the multiplier is correct.
*/
            rem = (RADIXM1 >> recip_shift) - denom[lden-1];
                             /* RADIX/2^shiftamt - 1 - den[lden-1] */
/*
                Repeatedly replace rem by

            rem*RADIX + RADIX - 1 - denom[iden-1] - multiplier*denom[iden]

        until it is known whether rem >= multiplier or rem < 0.
        Once one of these happens, the sign of rem won't change.
*/
            for (iden = lden; (iden--) != 0 && rem < recip_multiplier;/*null*/){
                        /* CAUTION -- loop may exit early */

                dblint_t  test1 = MAKE_DBLINT(rem,
                                      RADIXM1 - (iden > 0 ? denom[iden-1] : 0));
                dblint_tc test2 = DPRODUU(recip_multiplier, denom[iden]);
                if (DBLINT_GT(test2, test1)) {
                    recip_multiplier--;
                    break;
                }
                test1 = DBLINT_SUB(test1, test2);
                rem = LOW_DIGIT(test1);
                if (HIGH_DIGIT(test1) != 0) break;
            } // for iden
            recip->shiftamt   = recip_shift;
            recip->multiplier = recip_multiplier;
        } // if OK
    } // else
    return OK;
} /* divide_precondition_1 */
/****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\ecapi.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef ECAPI_H
#define ECAPI_H 1

#include "bigdefs.h"

/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

//  -------------- SHA-1 message digest ------------------


#define A_SHA_DIGEST_LEN 20
        /* Number of bytes output by SHA-1 */



typedef struct {
        DWORD magic_sha1;    // Magic value for A_SHA_CTX
        DWORD awaiting_data[16];
                             // Data awaiting full 512-bit block.
                             // Length (nbit_total[0] % 512) bits.
                             // Unused part of buffer (at end) is zero
        DWORD partial_hash[5];
                             // Hash through last full block
        DWORD nbit_total[2];
                             // Total length of message so far
                             // (bits, mod 2^64)
} A_SHA_CTX;

extern BOOL WINAPI A_SHAInit(A_SHA_CTX *ctx);
extern BOOL WINAPI A_SHAUpdate(A_SHA_CTX*, const BYTE*, DWORDREGC);
extern BOOL WINAPI A_SHAFinal(A_SHA_CTX*, BYTE digest[A_SHA_DIGEST_LEN]);
// Next is new
extern BOOL WINAPI A_SHA(const BYTE *msg, DWORDREGC msglen,
                         BYTE digest[A_SHA_DIGEST_LEN]);

//  -------------- MD5 message digest --------------------

#define MD5DIGESTLEN 16
#define MD5_LEN MD5DIGESTLEN
        /* Two names for number of bytes output by MD5 */

typedef struct {
        DWORD magic_md5;     // Magic value for MD5_CTX
        DWORD awaiting_data[16];
                             // Data awaiting full 512-bit block.
                             // Length (nbit_total[0] % 512) bits.
                             // Unused part of buffer (at end) is zero.
        DWORD partial_hash[4];
                             // Hash through last full block
        DWORD nbit_total[2];
                             // Total length of message so far
                             // (bits, mod 2^64)
        BYTE digest[MD5DIGESTLEN];
                             // Actual digest after MD5Final completes
} MD5_CTX;

typedef const MD5_CTX MD5_CTXc;

// N.B.  Following were void in RSA32API.
//       How were errors reported?
extern BOOL WINAPI MD5Init(MD5_CTX*);
extern BOOL WINAPI MD5Update(MD5_CTX*, const BYTE*, DWORDREGC);
extern BOOL WINAPI MD5Final(MD5_CTX*);

// Next is new
extern BOOL WINAPI MD5(const BYTE *msg, DWORDREGC msglen,
                       BYTE digest[MD5DIGESTLEN]);

// ------------------------------------------------------
#ifdef __cplusplus
}
#endif
#endif // ECAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\ecex2001.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"
#include "ecpriv.h"
#include "ecurve.h"

#ifndef assert
#include <assert.h>
#endif

/*
    File ecex2001.c.    Version 01 October 2001

        Let E be an elliptic curve (over GF(2^m) or GF(p), where p is prime).
        The costs of some group operations (using affine coordinates) are
        (I = inversion, S = squaring, M = multiplication)

     Operation           GF(2^m)        GF(p)
        2P              I +  S + 2M    I + 2S + 2M
       P+Q              I +  S + 2M    I +  S + 2M
     2P+Q = P+(P+Q)    2I + 2S + 3M   2I + 2S + 3M  (ecaffine_PPQ)
      Both P +- Q       I + 2S + 4M    I + 2S + 4M
                                                (ecaffine_addition_subtraction)

 3P+Q = (2P) + (P+Q)   2I + 3S + 9M   2I + 4S + 9M  (after replacing I by 3M)
 3P+Q = P+(P+(P+Q))    3I + 3S + 4M   3I + 2S + 4M  (using same idea as in 2P+Q)
 3P+Q = 2(P+Q) + (P-Q) 3I + 4S + 7M   3I + 4S + 7M


    These costs appply to the generic case, where no input is a
    point at infinity and where we encounter no divisions by zero.

        We are given a point P0 on E and a nonnegative exponent expon.
    Select a width w (2 <= w <= WMAX),
    dependent upon the number of bits in our exponent.
    Set oddmax = 2^(w-1) - 1.  The plan is tabulate j*P0 for all odd j,
    1 <= j <= oddmax, as well as j = 3*2^(w - 3) when w > 2.
    The table is constructed as follows (when w <= 6):

                 if (w >= 3) then
                     Use 2P + Q code to form 2*P0 + P0 = 3*P0.
                 end if
                 if (w >= 4) then
                     Use doubling code to form 6*P0.
                     Use (both P +- Q) code to form 5*P0 and 7*P0    (6 +- 1)
                 end if
                 if (w >= 5) then
                     Use doubling code to form 12*P0
                     Use (both P +- Q) code to form 9*P0, 11*P0, 13*P0, 15*P0
                                                     (12 +- 1, 12 +- 3)
                 end if
                 if (w >= 6) then
                     Use doubling code to form 24*P0
                     Use (both P +- Q) code to form 17*P0, 19*P0, ..., 31*P0
                                         (24 +- 1, 24 +- 3, 24 +- 5, 24 +- 7)
                end if

    This strategy can be improved slightly by (for example)
    computing 6*P0 + 6*P0, and 6*P0 +- P0 together, replacing one of the
    inversions by three multiplications.
    This strategy would do  2^(w-3) - 2 such replacements when w >= 4.
    Assuming such is later implemented, this initialization would use

         1           invocation  of 2*P + Q code
         2^(w-3) - 1 invocations of (both P +- Q) code
         w - 3       invocations of doubling code
         2^(w-3) - 2 replacements of an inversion by 3 multiplications

        After this table is built, the idea is to use windows of width w,
    with odd signed digits from -oddmax to +oddmax.
    A simplified, recursive, description is

              Function multiply_by(e)    // Return e*P0, assuming e > 0
                  if (e is small) then
                      use a table entry, or a sum of a few table entries
                  else if e is even then
                      return 2*multiply_by(e/2)
                  else
                      choose j == e (mod 2^w), -oddmax <= j <= oddmax
                      return 2*multiply_by((e-j)/2) + j*P0
                  end if
              end function multiply_by

    We estimate this cost as log2(e) doublings and log2(e)/(w + 1) additions.
    That is log2(e)*w/(w + 1) invocations of the doubling code and
    log2(e)/(w + 1) invocations of the 2*P + Q code

        Suppose w = 6, so that oddmax = 31 and doublings3pwr = 24.
     Here is how we aim to compute expleft*P0 for various small expleft:

No operation

       0                                       0
       table                                   odd 1 to 31
                                               24

One group operation
       P+Q or 2P                               even 2 to 62 (except 24)
                                               odd 33 to 55

Two group operations
       2P + Q or 3P                            odd 57 to 93
                                               2 mod 4, 66 to 86
                                               72
       2(P + Q)                                2 mod 4, 90 to 110
                                               0 mod 4, 64 to 124 (except 72)

Three group operations
       2(P + Q) + R                            odd 95 to 155
       3(P + Q)                                0 mod 6, 96 to 186
                                                   (except 96, 108, 120)
                                               3 mod 6, 99 to 165

     w             = {2, 3, 4,  5,  6}
     doublings3pwr = (1, 3, 6, 12, 24)
     oddmax =        (1, 3, 7, 15, 31)

     if (expleft is high or more bits left) {
         delay
     else if (expleft == 0) then
         identity
     else if (expleftodd && expleft <= oddmax) then
         Copy from table
     else if (expleft == doublings3pwr) then
         Copy from table
     else if (even(expleft) && expleft <= 2*oddmax) then
         Use MIN(expleft - 1, oddmax) and another odd value
     else if (    odd(expleft + doublings3pwr)
              and expleft <= doublings3pwr + oddmax) then
         Use doublings3pwr   and odd value
     else if (expleftodd && expleft <= 3*oddmax) then
         odd1 =  2*((expleft - oddmax + 2)/4) - 1
         Use 2*odd1 + odd
     else if (expleft - doublings3pwr == 2 mod 4, at most 2*oddmax) then
         Use 2*odd + doublings3pwr
     else if (expleft is even, at most 2*(oddmax + doublings3pwr)) then
         delay
     else if (expleft = 0 mod 4, at most 4*oddmax) then
         delay
     else if (expleft == 0 mod 6, at most 6*oddmax) then
         Use 3 *(odd + odd)
     else if (odd (expleft + doublings3pwr) and
              expleft divisible by 3,
              at most 3*(doublings3pwr + oddmax) then
         Use 3*(doublings3pwr + odd)
     else if (expleftodd, at most 5*oddmax) then
         even1 = 2*((expleft - oddmax + 2)/4)
         Use 2*(oddmax + (even1 - oddmax)) + (oddmax or oddmax - 2)
     else
         delay
     end if
*/


BOOL WINAPI ecaffine_exponentiation2001
             (ecaffine_tc    *P0,
              digit_tc        exponent[],
              DWORDREGC       lng_exponent,
              ecaffine_t     *Presult,        // OUT
              ecurve_tc      *E,
              PBIGCTX_ARG)

// Compute Pesult = exponent*P0 in the elliptic curve group.
// Unlike ecaffine_exponentiation1998, this code allows
// P0 and Pesult to overlap.
{
    field_desc_tc *fdesc = E->fdesc;
    DWORDREGC elng = fdesc->elng;
    DWORDREGC expbits = mp_significant_bit_count(exponent, lng_exponent,
                                                 PBIGCTX_PASS);
    const BOOL char2 =  CHARACTERISTIC_2(fdesc);

    BOOL OK = TRUE;
    BOOL delay;
    digit_t *dtemps = digit_NULL;
    digit_t *etemps = digit_NULL;              // Length E->ndigtemps;
    digit_t *adjustment_locs = digit_NULL;     // Length lng_exponent
    digit_t *Presult1998 = digit_NULL;         // Length 2*elng
    digit_t *p0muls = digit_NULL;              // length 2*elng ((oddmax + 1)/2)
    digit_t doublings3pwr, expon_partial, oddmax;
    sdigit_t expon_excess;
    DWORDREG iexpbit, numdoubling, w;

    static const DWORD wcutoffs[] = {22, 50, 110, 256, 600};
    #define WMAX ((DWORDREG)(2 + SIZEOF(wcutoffs)/SIZEOF(wcutoffs[0])))

/*
    Use       w = 2 (digits  -1 to  1) if expbits <= 22,
    otherwise w = 3 (digits  -3 to  3) if expbits <= 50,
    otherwise w = 4 (digits  -7 to  7) if expbits <= 110,
    otherwise w = 5 (digits -15 to 15) if expbits <= 256,
    otherwise w = 6 (digits -31 to 31) if expbits <= 600,
    otherwise w = 7 (digits -63 to 63).

    wcutoffs has approximations to the cutoffs suggested by the
    Maple program at the end of this file.
    [Actual cutoffs are about 20% lower for GF(2^n) than
    for GF(p) -- this table has compromise values.]
 */
    w = 2;
    while (w < WMAX && expbits > wcutoffs[w-2]) w++;

         // Check for Koblitz curves (ec_Koblitz2_exponentiation).
         // The Koblitz code allows overlapping arguments.

    if (E->fexpon != ec_exponentiation_NULL) {
        return (*E->fexpon)(P0, exponent, lng_exponent,
                            Presult, E, PBIGCTX_PASS);
    }

#if 0
    printf("expbits = %ld, w = %ld, char2 = %d, elow = %8lx (hex)\n",
        (long)expbits, (long)w, (int)char2, (long)exponent[0]);
    fflush(stdout);
#else
    (void)char2;    // Avoid warning for unused variable
#endif

    oddmax = ((digit_t)1 << (w-1)) - 1;          // 1, 3, 7, 15, 31, or 63
/*
         Decide how many temporaries we need.  Allocate them.
*/
    if (OK) {
        DWORDREGC ndigtemp = E->ndigtemps + ((DWORDREG)oddmax + 3)*elng
                                          + lng_exponent;

        dtemps = digit_allocate(ndigtemp,
                                "ecaffine_exponentiation2001", PBIGCTX_PASS);
        if (dtemps == digit_NULL) {
            OK = FALSE;
        } else {
            mp_clear(dtemps, ndigtemp, PBIGCTX_PASS);

            adjustment_locs = dtemps;
            p0muls = adjustment_locs + lng_exponent;
            Presult1998 = p0muls + (oddmax + 1)*elng;
            etemps = Presult1998 + 2*elng;
            assert(etemps + E->ndigtemps == dtemps + ndigtemp);
        }
    }

#define p0location(iodd) (assert((iodd) & 1), \
                          assert((digit_t)(iodd) <= oddmax), \
                           &p0muls[elng*(iodd) - elng])
               // Return address in p0muls array, after validating
               // subscript in debug mode.

    doublings3pwr = 1;
    if (OK) {
        DWORDREG iw;
        digit_t j;
/*
             Initialize table of multiples of P0.

             Presult = doublings3pwr * P0
             p0muls = (1, 3, 5, 7, ..., oddmax) * P0
*/
        OK = OK && ecaffine_copy(P0, p0location(1), E, PBIGCTX_PASS);
        if (w == 2) {
            OK = OK && ecaffine_copy(P0, Presult, E, PBIGCTX_PASS);
                                                      // Only P0 stored in table
        } else {
            doublings3pwr = 3;
            OK = OK && ecaffine_PPQ(P0, P0, p0location(3), +1,
                                    E, etemps, PBIGCTX_PASS);
                                                           // 3*P0

            if (w == 3) {
                OK = OK && ecaffine_copy(p0location(3), Presult,
                                         E, PBIGCTX_PASS);
                                                           // P0 and 3*P0 saved
            } else {
                OK = OK && ecaffine_addition(p0location(3), p0location(3),
                                             Presult, +1, E,
                                             etemps, PBIGCTX_PASS);
                                   // Presult = 6*P0

                for (iw = 4; iw <= w; iw++) {
                    doublings3pwr *= 2;
                    assert(doublings3pwr == (digit_t)3 << (iw - 3));

                          // At this point Presult = doublings3pwr * P0
                          // p0muls has been initialized p0location(2^(w-1) - 1)

// TBD -- Future inplementation should do all group operations below at once,
// combining the inversions
                    for (j = 1; j >> (iw-3) == 0; j += 2) {
#if 0
                        printf("doublings3pwr = %ld, j = %ld\n",
                                (long)doublings3pwr, (long)j);
                        fflush(stdout);
#endif
                        OK = OK && ecaffine_addition_subtraction(Presult,
                                        p0location(j),
                                        p0location(doublings3pwr + j),
                                        p0location(doublings3pwr - j),
                                        E, etemps, PBIGCTX_PASS);
                    } // for j
                    if (iw != w) {
                        OK = OK && ecaffine_addition(Presult, Presult,
                                                     Presult, +1, E,
                                                     etemps, PBIGCTX_PASS);
                    }
                }  // for iw
            } // if w > 3
        } // if w > 2
#if PRINT_ERROR_MESSAGES
        if (mp_errfil == NULL) {
        } else if (!OK) {
            fprintf(mp_errfil, "ecaffine_exponentiation2001 "
                        " -- OK = FALSE initializing multiples of P0\n");
        } else {
#if EC_EXPENSIVE_DEBUGGING
            OK = OK && ecaffine_exponentiation1998(p0location(1),
                                                   &doublings3pwr, 1,
                                                   Presult1998,
                                                   E, PBIGCTX_PASS);
            OK = OK && ecaffine_equal(Presult, Presult1998, E, PBIGCTX_PASS);
            if (!OK) {
                fprintf(mp_errfil, "ecaffine_exponentiation2001 --"
                        " Presult <> %ld * P0 after initialiation, w = %ld\n",
                         (long)doublings3pwr, (long)w);
            } else {
                for (j = 1; OK && j <= oddmax; j += 2) {
                    OK = OK && ecaffine_exponentiation1998(p0location(1), &j, 1,
                                   Presult1998, E, PBIGCTX_PASS);
                    OK = OK && ecaffine_equal(p0location(j), Presult1998.
                                              E, PBIGCTX_PASS);
                    if (!OK) {
                        fprintf(mp_errfil, "ecaffine_exponentiation2001 "
                             "-- p0location(%ld) improperly initialized\n",
                             (long)j);
                    }
                } // for j
            } // if

#endif  // EC_EXPENSIVE_DEBUGGING
        } // if OK
#endif
    } // if OK

    numdoubling = 0;
    expon_partial = 0;

    for (iexpbit = 0; iexpbit != expbits; iexpbit++) {
        expon_partial += mp_getbit(exponent, iexpbit, PBIGCTX_PASS)
                                << (iexpbit - numdoubling);
        if (iexpbit < numdoubling + w + 1) {
            /* delay */
        } else {
            if (IS_ODD(expon_partial)) {
                sdigit_tc sindex =   ((expon_partial + oddmax) & (2*oddmax))
                                   - oddmax;
                expon_partial -= (digit_t)sindex;
                assert((expon_partial & (2*oddmax + 1)) == 0);
                mp_setbit(adjustment_locs, numdoubling, 1, PBIGCTX_PASS);
#if 0
                printf("sindex 1 = %ld at %ld\n", (long)sindex,
                                                  (long)numdoubling);
#endif
            }
            expon_partial >>= 1;
            numdoubling++;
        }
    } // for iexpbit

    delay = TRUE;
    while (OK && delay) {
        const BOOL expon_partial_odd = IS_ODD(expon_partial);
        digit_tc expon_partial3 = expon_partial - doublings3pwr;
                                         /* May be negative */
        const BOOL expon_partial3_odd = IS_ODD(expon_partial3);
        digit_tc expon_partial_div3 = expon_partial/3;
        digit_tc expon_partial_mod3 = expon_partial - 3*expon_partial_div3;

#if 0
        printf("delay loop, w = %ld, expon_partial = %ld, numdoubling = %ld\n",
               (long)w, (long)expon_partial, (long)numdoubling);
        fflush(stdout);
#endif

        delay = FALSE;
        if (expon_partial == 0) {
            OK = OK && ecaffine_set_infinite(Presult, E, PBIGCTX_PASS);
        } else if (expon_partial_odd && expon_partial <= oddmax) {
            OK = OK && ecaffine_copy(p0location(expon_partial),
                                     Presult, E, PBIGCTX_PASS);
        } else if (expon_partial == doublings3pwr) {
            /* Presult already has doublings3pwr * P0 */
        } else if (!expon_partial_odd && expon_partial <= 2*oddmax) {
            digit_tc odd1 = MIN(expon_partial - 1, oddmax);
            digit_tc odd2 = expon_partial - odd1;

            OK = OK && ecaffine_addition(p0location(odd1),
                                         p0location(odd2),
                                         Presult, +1, E,
                                         etemps, PBIGCTX_PASS);
        } else if (   expon_partial3_odd
                   && expon_partial <= doublings3pwr + oddmax) {
            OK = OK && ecaffine_addition(Presult,
                                         p0location(expon_partial3),
                                         Presult, +1, E,
                                         etemps, PBIGCTX_PASS);
        } else if (expon_partial_odd && expon_partial <= 3*oddmax) {
            digit_tc odd1 = ((expon_partial - oddmax)/2) | 1;
            digit_tc odd2 = expon_partial - 2*odd1;
            OK = OK && ecaffine_PPQ(p0location(odd1),
                                    p0location(odd2),
                                    Presult, +1, E,
                                    etemps, PBIGCTX_PASS);
        } else if (    (expon_partial3 & 3) == 2
                    && expon_partial3 <= 2*oddmax) {
            OK = OK && ecaffine_PPQ(p0location(expon_partial3 >> 1),
                                    Presult, Presult, +1, E,
                                    etemps, PBIGCTX_PASS);
        } else if (   !expon_partial_odd
                   && expon_partial <= 2*(oddmax + doublings3pwr)) {
            delay = TRUE;
        } else if ( (expon_partial & 3) == 0 && expon_partial <= 4*oddmax) {
            delay = TRUE;
        } else if (    !expon_partial_odd
                    && expon_partial_mod3 == 0
                    && expon_partial_div3 <= 2*oddmax) {
            digit_tc odd1 = MIN(expon_partial_div3 - 1, oddmax);
            digit_tc odd2 = expon_partial_div3 - odd1;
                            // expon_partial = 3*(odd1 + odd2)

            OK = OK && ecaffine_addition(p0location(odd1), p0location(odd2),
                                         Presult, +1, E,
                                         etemps, PBIGCTX_PASS);
            OK = OK && ecaffine_PPQ(Presult, Presult, Presult, +1, E,
                                         etemps, PBIGCTX_PASS);
        } else if (   expon_partial_mod3 == 0
                   && expon_partial3_odd
                   && expon_partial_div3 - doublings3pwr <= oddmax) {
            assert (  expon_partial == 3*(doublings3pwr
                    + (expon_partial_div3 - doublings3pwr)));

            OK = OK && ecaffine_addition(
                           p0location(expon_partial_div3 - doublings3pwr),
                           Presult, Presult, +1, E,
                           etemps, PBIGCTX_PASS);
            OK = OK && ecaffine_PPQ(Presult, Presult, Presult, +1, E,
                           etemps, PBIGCTX_PASS);
        } else if (expon_partial_odd && expon_partial <= 5*oddmax) {
                     // Use 2*(oddmax + odd) + odd
            digit_tc even1 = 2*((expon_partial - oddmax + 2)/4);
            assert(expon_partial >= 3*oddmax + 2);

            OK = OK && ecaffine_addition(p0location(oddmax),
                                         p0location(even1 - oddmax),
                                         Presult, +1, E,
                                         etemps, PBIGCTX_PASS);
            OK = OK && ecaffine_PPQ(Presult,
                                    p0location(expon_partial - 2*even1),
                                    Presult, +1, E,
                                    etemps, PBIGCTX_PASS);
        } else {
            delay = TRUE;
        }
        if (!OK) {
#if PRINT_ERROR_MESSAGES
            if (mp_errfil != NULL) {
                 fprintf(mp_errfil, "ecaffine_exponentiation2001 -- OK = FALSE"
                      "multiplying by expon_partial = %ld\n",
                      (long)expon_partial);
            }
#endif
        } else if (delay) {
            if (expon_partial_odd) {
                sdigit_tc sindex =    ((expon_partial + oddmax) & (2*oddmax))
                                    - oddmax;
                expon_partial -= (digit_t)sindex;
                assert((expon_partial & (2*oddmax + 1)) == 0);
                mp_setbit(adjustment_locs, numdoubling, 1, PBIGCTX_PASS);
#if 0
                printf("sindex 2 = %ld at %ld\n", (long)sindex,
                                                  (long)numdoubling);
#endif
            }
            numdoubling++;
            expon_partial >>= 1;
        } // if
    } // while

#if PRINT_ERROR_MESSAGES && EC_EXPENSIVE_DEBUGGING
    if (mp_errfil != NULL) {
        OK = OK && ecaffine_exponentiation1998(p0location(1),
                    &expon_partial,
                    1, Presult1998, E, PBIGCTX_PASS);
        if (!ecaffine_equal(Presult, Presult1998, E)) {
            fprintf(mp_errfil, "ecaffine_exponentiation2001 -- "
                    "error multiplying by expon_partial = %ld, w = %ld\n",
                     (long)expon_partial, (long)w);
            OK = FALSE;
        }
    }
#endif

/*
        At this point, Presult = expon_partial * P0.

        We intend to double Presult numdoubling times,
        occasionally adding or subtracting
        (odd value in [1, oddmax] * P0).
*/

    expon_excess = (sdigit_t)expon_partial;
    for (iexpbit = expbits; iexpbit-- && OK; ) {
        digit_tc adjustment_bit = mp_getbit(adjustment_locs,
                                            iexpbit, PBIGCTX_PASS);
        digit_tc exponent_bit = mp_getbit(exponent, iexpbit, PBIGCTX_PASS);

#if 0
        printf("iexpbit = %ld, expon_excess = %ld,"
            " numdoubling = %ld, adjustment_bit = %d\n",
            (long)iexpbit, (long)expon_excess,
            (long)numdoubling, (int)adjustment_bit);
        fflush(stdout);
#endif
/*
           The final result is

              (Presult - expon_excess*P0) * 2^numdoubling
              + (bits 0 to iexpbit-1 of exponent)*P0
*/
        while (OK && numdoubling > iexpbit + adjustment_bit) {
            OK = OK && ecaffine_addition(Presult, Presult,
                                         Presult, +1, E,
                                         etemps, PBIGCTX_PASS);
            numdoubling--;
            expon_excess *= 2;
        }

        if (!OK) {
        } else if (adjustment_bit == 0) {
            assert(iexpbit >= numdoubling);
            expon_excess -= exponent_bit << (iexpbit - numdoubling);
        } else {
            int pm1;
            digit_t index;
            sdigit_t sindex;
            DWORDREGC pre_doublings = numdoubling - iexpbit;

            expon_excess = (expon_excess << pre_doublings) - exponent_bit;
            pm1 = (expon_excess > 0 ? -1 : +1);

            sindex = 1 | (-expon_excess);
            index = (digit_t)(pm1*sindex);
            expon_excess += sindex;

            if (pre_doublings > 1) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "ecaffine_exponentiaiton2001 pre_doublings",
                                PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
                fprintf(mp_errfil, "ecaffine_exponentiaiton2001 --"
                             "pre_doublings = %ld out of range\n",
                             (long)pre_doublings);
#endif
            } else if (index > oddmax) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "ecaffine_exponentiaiton2001 index > oddmax",
                                PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
                fprintf(mp_errfil, "ecaffine_exponentiation2001 -- "
                            "index = %ld exceeds oddmax = %ld\n",
                             (long)index, (long)oddmax);
#endif
            } else {
                numdoubling = iexpbit;
                assert(expon_excess == 0 || expon_excess == 1);
            }

            if (!OK) {
            } else if (pre_doublings == 0) {
                OK = OK && ecaffine_addition(Presult,
                               p0location(index), Presult, pm1, E,
                               etemps, PBIGCTX_PASS);
            } else if (pre_doublings == 1) {
                OK = OK && ecaffine_PPQ(Presult, p0location(index),
                                        Presult, pm1, E,
                                        etemps, PBIGCTX_PASS);
            } else {
                assert(FALSE);
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "ecaffine_exponentiation2001 - 3",
                                PBIGCTX_PASS);
            }
        } // if (OK && adjustment_bit)
    } // for iexpbit

    if (OK) {
        assert(numdoubling == 0);
        assert(expon_excess == 0);
    }
    if (dtemps != digit_NULL) {
        Free_Temporaries(dtemps, PBIGCTX_PASS);
    }
#if PRINT_ERROR_MESSAGES
    if (!OK) {
        fprintf(mp_errfil,
                "ecaffine_exponentiation2001 exiting unsuccessfully\n");
    }
#endif
    return OK;
#undef p0location
#undef WMAX

/*

#      Maple code for estimating change-overs.
#      Paste this code into a maple input buffer.


# I = inversion, S = squaring, M = multiplication

for char2 in [false, true] do

    if (char2) then     # Relative operation costs over GF(2^m)
                        # with polynomial basis.   October, 2001.
        cS := cM/3;
        cI := 6*cM;
        cost2P := costPQ;
    else                # Relative operation costs over GF(p)
        cS := 9*cM/10;
        cI := 11*cM/2;
        cost2P := costPQ + cS;
    fi;
    costPQ := cI + cS + 2*cM;


    costPPQ := 2*costPQ - cM;
    costPpmQ := 2*costPQ - cI;

# Next approximation assumes w >= 2.

    costtot := costPPQ + (2^(w-3) - 1)*costPpmQ
           + (w - 3)*cost2P
           + (2^(w-3) - 2) * (3*cM - cI)
           + (costPPQ + w*cost2P)*log2e/(w + 1);

    for ww from 3 to 8 do
        savings := subs(w = ww, costtot) - subs(w = ww-1, costtot);
        print(char2, ww, evalf(solve(savings = 0, log2e)));
    od:
od;  # char2

# End of maple code

*/
} // ecaffine_exponentiation2001
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\dblint.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef DBLINT_H
#define DBLINT_H 1


/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

/*
        File: dblint.h.  Supplement to bignum.h.  Version 10 December, 2002.

        This file has declarations related to double-precision integers,
        such as typedefs, constants, and primitive operations.

        Before #including this, one should #define

                digit_t -- typedef for unsigned single-precision integers.
                sdigit_t -- typedef for signed single-precision integers
                RADIX_BITS -- Number of bits per digit_t.

        and identify which compiler one is using.

        Constants defined herein include

                DBLINT_BUILTIN -- 1 if compiler directly
                                  supports double integers, 0 if not.

                DBLINT_HIGH_INDEX (optional)  -- When DBLINT_BUILTIN == 1,
                                  this is 0 if compiler stores
                                  the most significant half of a
                                  dblint_t datum first, and 1
                                  if compiler stores the least
                                  significant half first.  See
                                  HIGH_DIGIT and MAKE_DBLINT below.

                                  If this is not defined, then HIGH_DIGIT
                                  and MAKE_DBLINT are defined using
                                  shifts by RADIX_BITS.  If the compiler
                                  optimizes such shifts, then
                                  leave DBLINT_HIGH_INDEX undefined.


        The dblint_t type is unsigned and holds twice as many bits
        as a digit_t datum.  If (DBLINT_BUILTIN = 1), then use the type
        already in the language.  Otherwise (DBLINT_BUILTIN = 0)
        construct one of our own, using a struct with two digit_t fields.

        Let u, u1, u2 have type digit_t and
        d, d1, d2 have type dblint_t.
        The following primitives are defined,
        whether we use the built-in type or our own type:

                DBLINT(u) -- Convert u from type digit_t to type dblint_t.
                SDBLINT(s) -- Convert signed value s from sdigit_t to dblint_t.
                DBLINT_ADD(d1, d2) -- Sum d1 + d2.
                DBLINT_EQ(d1, d2)  -- Test whether d1 == d2.
                DBLINT_GE(d1, d2)  -- Test whether d1 >= d2.
                DBLINT_GT(d1, d2)  -- Test whether d1 > d2.
                DBLINT_LE(d1, d2)  -- Test whether d1 <= d2.
                DBLINT_LT(d1, d2)  -- Test whether d1 < d2.
                DBLINT_NE(d1, d2)  -- Test whether d1 != d2.
                DBLINT_SHIFT_LEFT(d, sh) -- Shift d left by sh bits,
                                       where 0 <= sh <= 2*RADIX_BITS - 1
                DBLINT_SUB(d1, d2) -- Difference d1 - d2
                DBLINT_XOR(d1, d2) -- Exclusive OR d1 ^ d2.
                DBLINT_SUM(u1, u2) -- Sum u1 + u2.
                DPRODUU(u1, u2) -- Product of u1 and u2, as a dblint_t.
                HPRODUU(u1, u2) -- Most significant half of product
                                   of u1 and u2, as a digit_t.
                HIGH_DIGIT(d) -- Most significant half of d.
                SHIGH_DIGIT(d) -- Most significant half of d, as signed value.
                LOW_DIGIT(d) -- Least significant half of d.
                MAKE_DBLINT(u1, u2) -- Construct a dblint_t
                        whose most significant half is u1 and
                        whose least significant half is u2.
*/

#if COMPILER == COMPILER_ARM_ATTILA
     /*
      __value_in_regs tells the ARM cc compiler to pass
      small structs (up to four words) in registers, for function returns.
     */

    #define DBLINT_FUNCTION __value_in_regs dblint_t
#else
    #define DBLINT_FUNCTION dblint_t
#endif

#if COMPILER == COMPILER_GCC

    #define DBLINT_BUILTIN 1
    typedef unsigned long long dblint_t;
    #define DBLINT_HIGH_INDEX 0
                /* GCC on SPARC stores high half of dblint_t first */
#endif

#if COMPILER == COMPILER_VC && RADIX_BITS == 32
    #define DBLINT_BUILTIN 1
    typedef unsigned __int64 dblint_t;
#if TARGET == TARGET_ALPHA
/* If the Alpha is using RADIX_BITS == 32,
   then use the shift instruction
   for HIGH_DIGIT and MAKE_DBLINT */
#else
    #define DBLINT_HIGH_INDEX 1
                /* Visual C++ on ix86 stores low half of dblint_t first */
// Next line inserted March 2000 -- hope the compilers inline shifts.
// Quickly removed for SHx.
//    #undef DBLINT_HIGH_INDEX
#endif
#endif


#ifndef DBLINT_BUILTIN
                        /* No language support -- simulate using structs */
    #define DBLINT_BUILTIN 0
    #include <drmint64.h>

    typedef DRM_UINT64 dblint_t;

    #define HIGH_DIGIT(d) DRM_UI64High32((d))
    #define LOW_DIGIT(d)  DRM_UI64Low32((d))
#endif

typedef const dblint_t dblint_tc;


#if DBLINT_BUILTIN
/*
        If language has support for double-length integers, use it.
        Good compilers will inline these simple operations.
*/

#define DBLINT(u) ((dblint_t)(u))
#define SDBLINT(s) ((dblint_t)(sdigit_t)(s))

#define DBLINT_ADD(d1, d2) ((d1) + (d2))
#define DBLINT_EQ( d1, d2) ((d1) == (d2))
#define DBLINT_GE( d1, d2) ((d1) >= (d2))
#define DBLINT_GT( d1, d2) ((d1) > (d2))
#define DBLINT_LE( d1, d2) ((d1) <= (d2))
#define DBLINT_LT( d1, d2) ((d1) < (d2))
#define DBLINT_NE( d1, d2) ((d1) != (d2))
#define DBLINT_SHIFT_LEFT(d, sh) ((d) << (sh))
#define DBLINT_SUB(d1, d2) ((d1) - (d2))
#define DBLINT_XOR(d1, d2) ((d1) ^ (d2))


#if COMPILER == COMPILER_GCC
#define DPRODUU(u1, u2) (DBLINT(u1) * DBLINT(u2))
#endif

#if COMPILER == COMPILER_VC
/*
        A problem in Visual C/C++ 4.0 (x86 version, 1995)
        prevents proper inlining of the DPRODUU function
        if we code it in a straightforward way.  Specifically,
        if we have two nearby references DPRODUU(x, y)
        and DPRODUU(x, z), where one argument (here x) is
        repeated, then the compiler calls library function
        __allmul rather than emit a MUL instruction.

        x86 version of VC 4.1 adds an __emulu function.
        VC 7.0 (2002) does not recognize it in C+ programs.
*/
#if INLINING_SUPPORTED
static __forceinline dblint_t WINAPI DPRODUU(digit_tc u1, digit_tc u2)
{
#if TARGET == TARGET_IX86 && !defined(__cplusplus)
//        #pragma intrinsic(__emulu)
        return __emulu(u1, u2);
#elif TARGET == TARGET_MIPS && defined(NDEBUG)    // MIPS Release
       // #pragma intrinsic(__emulu)
        return __emulu(u1, u2);
#elif TARGET == TARGET_SHX && USEASM_SHX
        dblint_t result;
    #if 0
           // Following fails sporadically (March, 2000, Jornada SJ3)
        __asm(  "    DMULU.L R4, R5      ; 32*32 => MACH MACL\n"
                "    STS.L   MACH,@-R6   ; Store high product\n"
                "    STS.L   MACL,@-R6   ; Store low product\n"
              , u1, u2, &result + 1);    // R4==u1, R5==u2, R6==&result + 1
    #else
           // Following seems OK
        __asm(  "    DMULU.L R4, R5      ; 32*32 => MACH MACL\n"
                "    STS     MACL,R4     ;\n"
                "    STS     MACH,R5     ;\n"
                "    MOV.L   R4,@R6      ; Store low product\n"
                "    MOV.L   R5,@(4,R6)  ; Store high product\n"
              , u1, u2, &result);        // R4==u1, R5==u2, R6==&result
    #endif

        return result;
#else
        return DBLINT(u1) * DBLINT(u2);
#endif
}
#else // INLINING
#define DPRODUU(u1, u2) (DBLINT(u1) * DBLINT(u2))
#endif
#endif // COMPILER_VC

#define LOW_DIGIT(d)   ((digit_t)((d) & RADIXM1))

#ifdef DBLINT_HIGH_INDEX
    #if DBLINT_HIGH_INDEX < 0 || DBLINT_HIGH_INDEX > 1
        #error "Illegal value of DBLINT_HIGH_INDEX"
    #endif

    #if !INLINING_SUPPORTED
        extern digit_t WINAPI HIGH_DIGIT(dblint_tc);
        extern dblint_t WINAPI MAKE_DBLINT(digit_tc, digit_tc);
    #endif

    #if INLINING_SUPPORTED
        INLINE digit_t WINAPI HIGH_DIGIT(dblint_tc d)
        {
            dblint_tc dcopy = d;
            return ((digit_tc*)&dcopy)[DBLINT_HIGH_INDEX];
        }

        INLINE dblint_t WINAPI MAKE_DBLINT(digit_tc high, digit_tc low)
        {
            dblint_t build = low;
            ((digit_t*)&build)[DBLINT_HIGH_INDEX] = high;
            return build;
        }
    #endif
#else /* DBLINT_HIGH_INDEX */
    #define HIGH_DIGIT(d)  ((digit_t)((d) >> RADIX_BITS))

    #define MAKE_DBLINT(high, low) \
       ( (DBLINT(high) << RADIX_BITS) | DBLINT(low) )

#endif /* DBLINT_HIGH_INDEX */

#define DBLINT_SUM(d1, d2) DBLINT_ADD(DBLINT(d1), DBLINT(d2))
            /* d1 + d2 */

#define MULTIPLY_ADD1(d1, d2, d3) \
        DBLINT_ADD(DPRODUU(d1, d2), DBLINT(d3))
           /* d1*d2 + d3 */

#define MULTIPLY_ADD2(d1, d2, d3, d4) \
        DBLINT_ADD(DBLINT_ADD(DPRODUU(d1, d2), DBLINT(d3)), \
                   DBLINT(d4))
          /* d1*d2 + d3 + d4 */

#else  /* DBLINT_BUILTIN */

#define DBLINT_LE(d1, d2) DBLINT_GE(d2, d1)
#define DBLINT_LT(d1, d2) DBLINT_GT(d2, d1)

#if TARGET == TARGET_ALPHA
    #pragma intrinsic(__UMULH)
    #define HPRODUU(u1, u2) __UMULH(u1, u2)
#endif

#if TARGET == TARGET_AMD64
    #pragma intrinsic(__umulh)
    #define HPRODUU(u1, u2) __umulh(u1, u2)
#endif

// HPRODUU not presently available directly on other platforms

#if !INLINING_SUPPORTED
extern DBLINT_FUNCTION WINAPI MAKE_DBLINT(digit_tc, digit_tc);

extern DBLINT_FUNCTION WINAPI DBLINT(digit_tc);
extern DBLINT_FUNCTION WINAPI SDBLINT(sdigit_tc);
extern DBLINT_FUNCTION WINAPI DBLINT_ADD(dblint_tc, dblint_tc);
extern DBLINT_FUNCTION WINAPI DBLINT_SHIFT_LEFT(dblint_tc, DWORDREGC);
extern DBLINT_FUNCTION WINAPI DBLINT_XOR(dblint_tc, dblint_tc);
extern DBLINT_FUNCTION WINAPI DBLINT_SUB(dblint_tc, dblint_tc);
extern DBLINT_FUNCTION WINAPI DBLINT_SUM(digit_tc, digit_tc);
extern DBLINT_FUNCTION WINAPI DPRODUU(digit_tc, digit_tc);
extern DBLINT_FUNCTION WINAPI MULTIPLY_ADD1(digit_tc, digit_tc, digit_tc);
extern DBLINT_FUNCTION WINAPI MULTIPLY_ADD2(digit_tc, digit_tc,
                                            digit_tc, digit_tc);

extern BOOL WINAPI DBLINT_EQ(dblint_tc, dblint_tc);
extern BOOL WINAPI DBLINT_GE(dblint_tc, dblint_tc);
extern BOOL WINAPI DBLINT_GT(dblint_tc, dblint_tc);
extern BOOL WINAPI DBLINT_NE(dblint_tc, dblint_tc);

#endif // INLINING_SUPPORTED

#if INLINING_SUPPORTED

INLINE DBLINT_FUNCTION WINAPI DPRODUU(digit_tc u1, digit_tc u2)
/*
        Multiply two single-precision operands,
        return double precision product.
        This will normally be replaced by an assembly language routine.
        unless the top half of the product (HPRODUU) is available in C.
*/
{
    return DRM_UI64Mul( DRM_UI64( u1 ), DRM_UI64( u2 ) );
}   // end DPRODUU
 




INLINE DBLINT_FUNCTION WINAPI DBLINT(digit_tc d)
{
    return DRM_UI64( d );    
}

INLINE DBLINT_FUNCTION WINAPI SDBLINT(sdigit_tc s)
                                // Convert signed value to DBLINT
{
    DRM_INT64 i64 = DRM_I64( s );
    DRM_UINT64 ui64;

    ui64 = *(DRM_UINT64*)&i64;
    return ui64;
}  // SDBLINT


INLINE DBLINT_FUNCTION WINAPI DBLINT_ADD(dblint_tc d1, dblint_tc d2)
{
    return DRM_UI64Add( d1, d2 );
}

INLINE DBLINT_FUNCTION WINAPI DBLINT_SHIFT_LEFT(dblint_tc d, DWORDREGC sh)
{
//  Left shift.  An excellent compiler will sometimes infer
//  whether sh >= RADIX_BITS from other code near the invocation.
    return DRM_UI64ShL( d, sh );
} // DBLINT_SHIFT_LEFT

#if 0
INLINE DBLINT_FUNCTION WINAPI DBLINT_XOR(dblint_tc d1, dblint_tc d2)
{
    dblint_t answer;
    answer.low = d1.low ^ d2.low;
    answer.high = d1.high ^ d2.high;
    return answer;
}  // DBLINT_XOR
#endif


INLINE BOOL WINAPI DBLINT_EQ(dblint_tc d1, dblint_tc d2)
{
   return DRM_UI64Eql(d1, d2);
}  // DBLINT_RQ

INLINE BOOL WINAPI DBLINT_GE(dblint_tc d1, dblint_tc d2)
{
   return !DRM_UI64Les(d1, d2) || DRM_UI64Eql(d1, d2);
}  // DBLINT_GE

INLINE BOOL WINAPI DBLINT_GT(dblint_tc d1, dblint_tc d2)
{
   return !DRM_UI64Les(d1, d2);
}  // DBLINT_GT

INLINE BOOL WINAPI DBLINT_NE(dblint_tc d1, dblint_tc d2)
{
   return !DRM_UI64Eql(d1, d2);
}  // DVLINT_NE

INLINE DBLINT_FUNCTION WINAPI DBLINT_SUB(dblint_tc d1, dblint_tc d2)
{
    return DRM_UI64Sub(d1, d2);
}  // DBLINT_SUB


INLINE DBLINT_FUNCTION WINAPI MAKE_DBLINT(digit_tc high, digit_tc low)
{
     return DRM_UI64HL( high, low );
}  // MAKE_DBLINT

/*
    The DBLINT_SUM, MULTIPLY_ADD1. MULTIPLY_ADD2
    functions take single-length (digit_t) operands and
    return double-length (dblint_t) results.
    Overflow is impossible.
*/

INLINE DBLINT_FUNCTION WINAPI DBLINT_SUM(digit_tc d1, digit_tc d2)
{
    return DRM_UI64Add( DRM_UI64(d1), DRM_UI64(d2) );
}  // DBLINT_SUM

INLINE DBLINT_FUNCTION WINAPI MULTIPLY_ADD1(digit_tc d1, digit_tc d2,
                                                 digit_tc d3)
{
    return DRM_UI64Add( DRM_UI64Mul( DRM_UI64(d1), DRM_UI64(d2) ), DRM_UI64(d3) );
} // MULTIPLY_ADD1


INLINE DBLINT_FUNCTION WINAPI MULTIPLY_ADD2(digit_tc d1, digit_tc d2,
                                                 digit_tc d3, digit_tc d4)
{
    return DRM_UI64Add( DRM_UI64Add( DRM_UI64Mul( DRM_UI64(d1), DRM_UI64(d2) ), DRM_UI64(d3) ), DRM_UI64(d4) );
} // MULTIPLY_ADD2

#endif // INLINING_SUPPORTED

#endif // DBLINT_BUILTIN

#undef DBLINT_FUNCTION

#define SHIGH_DIGIT(d) ((sdigit_t)HIGH_DIGIT((d)))

#ifndef HPRODUU
    #define HPRODUU(u1, u2) HIGH_DIGIT(DPRODUU((u1), (u2)))
#endif

#ifdef __cplusplus
}
#endif

#endif // DBLINT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\ecppq.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"
#include "field.h"
#include "ecurve.h"
#include "ecpriv.h"


/*
         File ecPPQ.c.    Version 19 September 2001


   Let P and Q be points on an elliptic curve

          y^2 + xy = x^3 + ax^2 + b        (characteristic 2)
or
          y^2 = x^3 + ax + b               (field GF(p), p odd)

using affine coordinates.  We want R = 2*P + Q (or 2P - Q)

    We optimize for the frequent case where P and Q are distinct and
neither of these nor any intermediate result is the point at infinity,
while designing the code to work properly in all cases.

    Computing P + (P + Q) rather than (2*P) + Q saves a squaring when using
GF(p) arithmetic, where a doubling is more expensive than an addition.
In summer, 2001, Microsoft Research intern Kirsten Eisentrager observed that
we can save another multiplication (both GF(p) and characteristic 2 cases)
by not explicitly computing y(P + Q).  See the `Think' lines below.



Algorithm for 2*P + Q

    if (P = infinity) then
        return Q;
    else if (Q = infinity)
        Use conventional algorithm for 2*P;
    else
        xP = x(P);  yP = y(P);
        xQ = x(Q);  yQ = y(Q);

        char2 = (TRUE if characteristic 2, else FALSE);
        yQplus = yQ;
        yQminus = (char2 ? xQ + yQ : -yQ);

        if (pm1 == -1) then       // 2*P - Q wanted
            exchange yQplus, yQminus
        }

        if (xP <> xQ) then
            m_1 = (yP - yQplus) / (xP - xQ);   // slope of line through P, Q
        else if (yP == yQminus) then
            return P;                    // P and Q are negatives, so 2P + Q = P
        else if (char2) then
            m_1 = xP + yP/xP;              // P = Q, tangent slope
        else
            m_1 = (3*xP^2 + a) / (2*yP);   // P = Q.  tangent slope
        end if;

        if (char2) then
            xPQ = m_1^2 + m_1 - a - xP - xQ;
                       // Think yPQ = xPQ + yP + m_1 * (xPQ - xP);
            if (xPQ = xP) then
                return infinity;    // P + Q and P cannot be same point,
                                    // must be negatives
            end if;
                       // Think m_2 = (yPQ - yP) / (xPQ - xP);
            m_2 + 1 = m_1 + xP / (xPQ - xP);
            xPPQ = m_2^2 + m_2 - a - xPQ - xP;
            yPPQ = xP + yP + (m_2 + 1) * (xPPQ - xP);
        else
            xPQ = m_1^2 - xP - xQ;
                       // Think yPQ = - [yP + m_1 * (xPQ - xP)];
            if (xPQ = xP) then
                return infinity;    // P + Q and P must be negatives
            end if;
                       // Think m_2 = (yPQ - yP) / (xPQ - xP);
            -m_2 = (2*yP) / (xPQ - xP) + m_1;
            xPPQ = m_2^2 - xPQ - xP;
            yPPQ = -[yP + m_2*(xPPQ - xP)];
        end if;
        return (xPPQ, yPPQ);
    end if;
*/

BOOL WINAPI ecaffine_PPQ(
    ecaffine_tc  *P,
    ecaffine_tc  *Q,
    ecaffine_t   *PPQ,    // OUT
    const int     pm1,     // +- 1
    ecurve_tc    *E,
    digit_t      *supplied_temps,
    PBIGCTX_ARG)
{
    /*
           Compute PPQ = 2*P + Q if pm1 = +1
                   PPQ = 2*P - Q if pm1 = -1
    */

    BOOL OK = TRUE;
    BOOL done = FALSE;
    field_desc_tc *fdesc = E->fdesc;
    DWORDREGC elng = fdesc->elng;
    const BOOL char2 = CHARACTERISTIC_2(fdesc);
                      /* Is field characteristic 2? */

    digit_tc *xP = P,     *yP = P + elng;        // IN
    digit_tc *xQ = Q,     *yQ = Q + elng;        // IN
    digit_t  *xPPQ = PPQ, *yPPQ = PPQ + elng;    // OUT

    digit_t *m1 = digit_NULL, *m2 = digit_NULL;
    digit_t *xtemp = digit_NULL, *ytemp = digit_NULL;
    digit_t *ftemps = digit_NULL;
    DWORDREG j;

#if MAX_ECTEMPS < 4
    #error -- Increase MAX_ECTEMPS
#endif

    if (supplied_temps == digit_NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "ecaffine_PPQ", PBIGCTX_PASS);
    } else {
        m1 = supplied_temps;
        m2 = m1 + elng;
        xtemp = m2 + elng;
        ytemp = xtemp + elng;
        ftemps = ytemp + elng;
    }

#if EC_EXPENSIVE_DEBUGGING
    OK = OK && ecaffine_on_curve(P, E, "ecaffine_PPQ P",
                                 supplied_temps, PBIGCTX_PASS);
    OK = OK && ecaffine_on_curve(Q, E, "ecaffine_PPQ Q",
                                 supplied_temps, PBIGCTX_PASS);
#endif

    // Check whether either supplied point is infinite.

    if (ecaffine_is_infinite(P, E, PBIGCTX_PASS)) {
                              // P = identity so 2*P +- Q = +-Q
        OK = OK && ecaffine_multiply_pm1(Q, PPQ, pm1, E, PBIGCTX_PASS);
        done = TRUE;
    } else if (ecaffine_is_infinite(Q, E, PBIGCTX_PASS)) {
                              // Q = identity so 2*P +- Q = 2*P = P + P
        OK = OK && ecaffine_addition(P, P, PPQ, +1, E,
                                     supplied_temps, PBIGCTX_PASS);
        done = TRUE;
    } else {
        digit_tc *yQplus, *yQminus;
        OK = OK && Ksub(xP, xQ, xtemp, fdesc, PBIGCTX_PASS);   // xP - xQ
        if (char2) {
            OK = OK && Kadd(yQ, xQ, m2, fdesc, PBIGCTX_PASS);  // m2 = y(-Q)
        } else {
            OK = OK && Knegate(yQ, m2, fdesc, PBIGCTX_PASS);   // m2 = y(-Q)
        }

        if (pm1 == +1) {           // 2*P + Q wanted
            yQplus = yQ;           // y(pm1*Q)
            yQminus = m2;          // y(-pm1*Q)
        } else if (pm1 == -1) {    // 2*P - Q wanted
            yQplus = m2;           // y(pm1*Q)
            yQminus = yQ;          // y(-pm1*Q)
        } else {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ecaffine_PPQ pm1",
                            PBIGCTX_PASS);
            yQplus = yQminus = digit_NULL;
        }

        OK = OK && Ksub(xP, xQ, xtemp, fdesc,
                        PBIGCTX_PASS);       // xtemp = xP - xQ

        if (!Kiszero(xtemp, fdesc, PBIGCTX_PASS)) {
            OK = OK && Kinvert(xtemp, m1, fdesc, ftemps, PBIGCTX_PASS);
            OK = OK && Ksub(yP, yQplus, ytemp, fdesc, PBIGCTX_PASS);
                                                 // ytemp = y(P) - y(pm1*Q)
            OK = OK && Kmul2000(m1, ytemp, m1, fdesc, ftemps, PBIGCTX_PASS);
                                                 // m1 = ytemp/xtemp
        } else if (Kequal(yP, yQminus, fdesc, PBIGCTX_PASS)) {
                              // Same x, y(P) = y(-pm1*Q). so
                              // P and pm1*Q must be negatives
                              // Therefore 2P + pm1*Q = P.
            OK = OK && ecaffine_copy(P, PPQ, E, PBIGCTX_PASS);
            done = TRUE;
        } else if (!Kequal(yP, yQplus, fdesc, PBIGCTX_PASS)) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "ecaffine_PPQ expected P = pm1*Q", PBIGCTX_PASS);
        } else if (char2) {    // xtemp = 0.    P and pm1*Q are equal
            OK = OK && Kinvert(xP, m1, fdesc, ftemps, PBIGCTX_PASS);
            OK = OK && Kmul2000(yP, m1, m1, fdesc, ftemps, PBIGCTX_PASS);
            for (j = 0; OK && j != elng; j++) {
                m1[j] ^= xP[j];
            }            // m1 = xP + yP/xP in char 2
        } else {
            OK = OK && Kmul2000(xP, xP, m1, fdesc, ftemps, PBIGCTX_PASS);
            OK = OK && Kadd(E->a, m1, xtemp, fdesc, PBIGCTX_PASS);
            OK = OK && Kadd(xtemp, m1, xtemp, fdesc, PBIGCTX_PASS);
            OK = OK && Kadd(xtemp, m1, xtemp, fdesc,
                            PBIGCTX_PASS);    // xtemp = a + 3*xP^2

            OK = OK && Kadd(yP, yP, ytemp, fdesc, PBIGCTX_PASS);
            OK = OK && Kinvert(ytemp, m1, fdesc, ftemps,
                               PBIGCTX_PASS);  // 1/(2*yP)
            OK = OK && Kmul2000(xtemp, m1, m1, fdesc, ftemps, PBIGCTX_PASS);
        }
    }
    if (!done) {
        OK = OK && Kmul2000(m1, m1, xtemp, fdesc, ftemps, PBIGCTX_PASS);
        if (char2) {
            digit_t xcompare = 0;
            for (j = 0; OK && j != elng; j++) {
                digit_tc itemp = xtemp[j] ^ m1[j] ^ E->a[j] ^ xQ[j];
                xcompare |= itemp;
                   //  xPQ[j] = xP[j] ^ itemp;
                xtemp[j] = itemp;   // xtemp = xPQ - xP
            }
            if (xcompare == 0) { // if xPQ == xP
                OK = OK && ecaffine_set_infinite(PPQ, E, PBIGCTX_PASS);
                done = TRUE;
            } else {
                digit_t *m2p1 = m2; /* For m2 + 1 */
                OK = OK && Kinvert(xtemp, m2, fdesc, ftemps, PBIGCTX_PASS);
                OK = OK && Kmul2000(m2, xP, m2, fdesc, ftemps, PBIGCTX_PASS);
                                // xP / (xPQ - xP)
                OK = OK && Kadd(m2, m1, m2p1, fdesc, PBIGCTX_PASS);
                                // m2p1 = m1 + xP / (xPQ - xP)
                OK = OK && Kmul2000(m2p1, m2p1, m1, fdesc,
                                    ftemps, PBIGCTX_PASS);
                                  // m2^2 + 1
                for (j = 0; OK && j != elng; j++) {
                    digit_tc temp1 = m1[j] ^ m2p1[j] ^ E->a[j] ^ xtemp[j];
                          // m2^2 + m2 - a - xPQ - xP
                    digit_tc temp2 = xP[j] ^ yP[j];

                    xtemp[j] = temp1 ^ xP[j];  // xPPQ - xP
                    xPPQ[j] = temp1;
                    yPPQ[j] = temp2;
                    // N.B.  (xPPQ, yPPQ) may overlap (xP, yP)
                }
                OK = OK && Kmul2000(m2p1, xtemp, xtemp, fdesc,
                                    ftemps, PBIGCTX_PASS);
                                // (m2 + 1) * (xPPQ - xP)
                OK = OK && Kadd(yPPQ, xtemp, yPPQ, fdesc,
                                PBIGCTX_PASS);
                done = TRUE;
            }
        } else {   // Not characteristic 2
            OK = OK && Ksub(xtemp, xP, xtemp, fdesc, PBIGCTX_PASS);
            OK = OK && Ksub(xtemp, xQ, xtemp, fdesc, PBIGCTX_PASS);
                             // xPQ = m1^2 - xP - xQ
            if (Kequal(xtemp, xP, fdesc, PBIGCTX_PASS)) {
                    // P + Q and P must be negatives
                OK = OK && ecaffine_set_infinite(PPQ, E, PBIGCTX_PASS);
                done = TRUE;
            } else {
                digit_t *m2neg = m2;   // -m2
                OK = OK && Ksub(xtemp, xP, ytemp, fdesc, PBIGCTX_PASS);
                                          // xPQ - xP
                OK = OK && Kinvert(ytemp, m2neg, fdesc, ftemps, PBIGCTX_PASS);
                                   //  1/(xPQ - xP)
                OK = OK && Kmul2000(yP, m2neg, m2neg, fdesc,
                                    ftemps, PBIGCTX_PASS);
                       // Think m_2 = (yPQ - yP) / (xPQ - xP);
                OK = OK && Kadd(m2neg, m2neg, m2neg, fdesc, PBIGCTX_PASS);
                OK = OK && Kadd(m2neg, m1, m2neg, fdesc, PBIGCTX_PASS);
                    // -m2 = 2*yP / (xPQ - xP) + m1
                OK = OK && Kmul2000(m2neg, m2neg, m1, fdesc,
                                    ftemps, PBIGCTX_PASS);
                                       // m2^2
                OK = OK && Ksub(m1, xtemp, m1, fdesc, PBIGCTX_PASS);
                OK = OK && Ksub(m1, xP, xtemp, fdesc, PBIGCTX_PASS);
                                      // xtemp = m2^2 - xPQ - xP (new xPPQ)
                OK = OK && Ksub(xtemp, xP, ytemp, fdesc,
                                PBIGCTX_PASS);  // xPPQ - xP
                OK = OK && Kmul2000(ytemp, m2neg, ytemp, fdesc,
                                ftemps, PBIGCTX_PASS);
                                      // -m2 * (xPPQ - xP);
                OK = OK && Ksub(ytemp, yP, yPPQ, fdesc, PBIGCTX_PASS);
                OK = OK && Kcopy(xtemp, xPPQ, fdesc, PBIGCTX_PASS);
                done = TRUE;
            }
        } // if !char2
    } // if !done

    if (OK && !done) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                        "ecaffine_PPQ -- OK = T, done = F", PBIGCTX_PASS);
    }
#if EC_EXPENSIVE_DEBUGGING
    OK = OK && ecaffine_on_curve(PPQ, E, "ecaffine_PPQ output",
                                 supplied_temps, PBIGCTX_PASS);
#endif

#if PRINT_ERROR_MESSAGES
    if (!OK && mp_errfil != NULL) {
        fprintf(mp_errfil, "Some error found in ecaffine_PPQ\n");
    }
#endif
    return OK;
}  // ecaffine_PPQ
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\ecexpon.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "ecpriv.h"
#ifndef assert
#include "assert.h"
#endif

#include <drmpkcrypto.h>

#ifndef EC_EXPENSIVE_DEBUGGING
     #error -- EC_EXPENSIVE_DEBUGGING not defined
#endif

//      File ecexpon.c.    Version 04 December, 2002.
//
//          Exponentiation on an elliptic curve,
//      with or without using tables.  This code uses
//      projective coordinates for intermediate points.
//
//          Let E be the elliptic curve
//
//              y^2      = x^3 + ax + b     modulo a large prime q,
//      or
//              y^2 + xy = x^3 + ax^2 + b   over GF(2^m).
//
//      Given a point Pbase on E, in affine form,
//      we want to find  exponent*Pbase, where
//      exponent is multiple precision and nonnegative.

//          More precisely we are given the affine points
//      (2^table_spacing)^j * Pbase for 0 <= j <= table_last.
//      [When there is no pre-existing table, set table_last = 0,
//      and store only Pbase = 2^0 * Pbase in the `table'.]
//      We allow exponent > (2^table_spacing)^table_last.
//      That is, we will generate beyond the end of the table if needed.

//          Denote table_radix = 2^table_spacing, with table_spacing > 0.
//      We write the exponent in base table_radix
//      with digits -table_radix/2 to table_radix/2.
//      Some exponents have multiple such representations.

//                                                    i
//          Suppose exponent = sum    e  * table_radix  ,
//                                i    i
//
//      where | e_i | <= table_radix/2.  There are 1 + table_radix/2
//      buckets, where bucket  j   has  +- (table_radix^i)*P
//      wherever   e_i = +- j.  Now we must compute
//
//             sum        j * sum                Q
//                j > 0           (Q in bucket j)


//          We do the inner summations (those within individual buckets)
//      in semi-parallel fashion, keeping everything in affine form.
//      If bucket j has b_j members, then try to do FLOOR(b_j/2)
//      independent elliptic curve additions semi-concurrently.
//      Additions within different buckets can occur
//      semi-concurrently, as can two independent additions
//      in one bucket.  ``Semi-concurrently'' means
//      we schedule the additions to be done back-to-back,
//      and the addition code arranges to do only one inversion
//      (over GF(q) or GF(2^m)).

//          After a few iterations
//      [at most ceil(log_2(largest bucket size))],
//      each bucket shrinks to at most a single point.
//      Then we start combining buckets, to evaluate the outer sum
//
//                  sum        j * (contents of bucket j, in affine form)
//                      j > 0
//
//      [In practice, we start this outer sum before all
//      buckets have shrunk, overlapping these additions with
//      the earlier additions.]

//          Suppose table_radix = 128, so the bucket numbers
//      go from 1 to 64 (we can ignore bucket 0).
//      When a bucket shrinks to a single point,
//      we usually move it to two other buckets:

//          Bucket 48 acquires buckets 32 to 64
//          Bucket 24 acquires 17 to 31
//          Bucket 16 acquires 16, -32, 64
//          Bucket 15 acquires 15, -33, 63
//          Bucket 14 acquires 14, -34, 62
//          Bucket 13 acquires 13, -35, 61
//          Bucket 12 acquires 12, -36, 60
//          Bucket 11 acquires 11, -37, 59
//          Bucket 10 acquires 10, -38, 58
//          Bucket  9 acquires  9, -39, 57
//          Bucket  8 acquires  8, -40, 56
//          Bucket  7 acquires  7, -17, 31, -41, 55
//          Bucket  6 acquires  6, -18, 30, -42, 54
//          Bucket  5 acquires  5, -19, 29, -43, 53
//          Bucket  4 acquires  4, -20, 28, -44, 52
//          Bucket  3 acquires  3, -21, 27, -45, 51
//          Bucket  2 acquires  2, -22, 26, -46, 50
//          Bucket  1 acquires  1, -23, 25, -47, 49

//      (a minus sign means we negate the point during the move).
//      For example, we represent 59*Q59 as 48*Q59 + 11*Q59
//      whereas 37*Q37 is represented as 48*Q37 - 11*Q37.

//          The last two sum to 48*(Q59 + Q37) + 11*(Q59 - Q37).
//      We can do Q59 +- Q37 with one elliptic curve combined affine
//      addition-subtraction, inverting the shared denominator only once.
//      The sum goes to bucket 48 and the difference to bucket 11.

//          After two more rounds of intra-bucket merges.
//      bucket 48 has at most 9 members,
//      bucket 24 at most 3 members,
//      buckets 8 to 16 at most 1 member, and
//      buckets 1 to 7 at most 2 members.  Next

//          Bucket 12 acquires 8, 9, 10, 11, 12, 13, 14, 15, 16.
//          Bucket  6 acquires 5, 6, 7 [May need to wait one round.]
//          Bucket  4 acquires 4, -8, 16
//          Bucket  3 acquires 3, -9, 15
//          Bucket  2 acquires 2, -10, 14
//          Bucket  1 acquires 1, -5, 7, -11, 13

//      After the buckets shrink again, we need

//         48*Q48 + 24*Q24 + 12*Q12 + 6*Q6 + 4*Q4 + 3*Q3 + 2*Q2 + Q1.

//      (the 4*Q4 term is not present if table_radix is an even
//      power of 2, such as 64).  We do this final summation
//      in projective form, starting with  2*(2*Q48 + Q24) + Q12.
//      After summing everything else into the Q3, Q2, Q1 terms,
//      we write 3*Q3 + 2*Q2 + Q1 as 2*(Q3 + Q2) + (Q3 + Q1).

//      ---------------   WITHOUT A TABLE -----------------

//           If table_last = 0, then only one point
//      Pbase_powers[0] = Pbase is supplied by the caller.
//      We select table_spacing based on the number of
//      bits in the exponent.

//          We repeatedly double Pbase, but
//      store only into odd-numbered buckets [except possibly
//      at the end, for the leading digits of the exponent].
//      We combine the buckets as above, but typically need
//      fewer steps since most even-numbered buckets are empty.
//      The doublings are done in projective mode,
//      but everything is converted to affine mode (together)
//      before buckets are combined.

//      ----------------   BASIC OPERATIONS ------------------------

//      AFFINIZATION.  Convert the projective point (X, Y, Z)
//      (where X, Y, Z are not all zero) to (x, y) = (X/Z^2, Y/Z^3).

//          IF Z == 0 THEN
//              Return point at infinity;
//          ELSE
//              zinv = 1/Z;
//              zinv2 = zinv^2;
//              x = X*zinv2;
//              y = Y*zinv*zinv2;
//          END IF

//      Costs 1 inversion, 1 squaring, and 3 more multiplications.


//      AFFINE ADDITION.  Given (x1, y1) and (x2, y2) on E,
//      compute (x3, y3) = (x1, y1) + (x2, y2) on E.

//          IF (x1, y1) is point at infinity THEN
//              Set result to (x2, y2);
//          ELSE IF (x2, y2) is point at infinity THEN
//              Set result to (x1, y1);
//          ELSE IF x1 == x2 THEN
//              IF y1 == y2 THEN
//                  Use AFFINE DOUBLING algorithm
//              ELSE
//                  Set result to point at infinity
//              END IF
//          ELSE
//              m = (y1 - y2)/(x1 - x2);
//              IF working over GF(q)
//                  x3 = m^2 - x1 - x2;
//                  y3 = m*(x1 - x3) - y1;
//              ELSE
//                  x3 = m^2 + m - x1 - x2 - a;
//                  y3 = m*(x1 - x3) - y1 - x3;
//              END IF
//          END IF

//      Usually the cost is one division (= multiplication + inversion)
//      plus a squaring and multiplication.


//      AFFINE ADDITION-SUBTRACTION.  Given two affine points
//      (x1, y1) and (x2, y2) on E, compute
//      (x3, y3) = (x1, y1) + (x2, y2) and
//      (x4, y4) = (x1, y1) - (x2, y2).

//          IF (x1, y1) or (x2, y2) is the point at infinity
//              Set answers to other point, or its negative.
//          ELSE IF x1 == x2 THEN
//              One result is the point at infinity.
//              Use AFFINE DOUBLING for the other.
//          ELSE
//              deltax_inv = 1/(x1 - x2)
//              IF working over GF(q) THEN
//                  m3 = (y1 - y2)*deltax_inv;
//                  m4 = (y1 + y2)*deltax_inv;
//                  x3 = m3^2 - x1 - x2;
//                  x4 = m4^2 - x1 - x2;
//                  y3 = m3*(x1 - x3) - y1;
//                  y4 = m4*(x1 - x4) - y1;
//              ELSE
//                  m3 = (y1 - y2)*deltax_inv;
//                  m4 = (y1 + x2 + y2)*deltax_inv;
//                  x3 = m3^2 + m3 - x1 - x2 - a;
//                  x4 = m4^2 + m4 - x1 - x2 - a;
//                  y3 = m3*(x1 - x3) - x3 - y1;
//                  y4 = m4*(x1 - x4) - x4 - y1;
//              END IF
//          END IF

//      Usually the cost is 1 inversion, 2 squarings, 4 multiplications


//      AFFINE DOUBLING.  Given (x1, y1) on E, compute
//      (x2, y2) = 2*(x1, y1) on E.

//          IF working over GF(q) THEN
//              IF (y1 == 0) THEN
//                  Set result to point at infinity
//              ELSE
//                  m = (3*x1^2 + a)/(2*y1);
//                  x2 = m^2 - 2*x1;
//                  y2 = m*(x1 - x2) - y1;
//              END IF
//          ELSE
//              IF (x1 == 0) THEN
//                  Set result to point at infinity
//              ELSE
//                  m = x1 + y1/x1;
//                                 (from (3*x1^2 + 2*a*x1 - y1)/(2*y1 + x1)
//                  x2 = m^2 + m - a;    (from m^2 + m - 2*x1 - a)
//                  y2 = m*(x1 - x2) - y1 - x2;
//              END IF
//          END IF

//      Usual cost is:
//              1 division (inversion + multiplication)
//              1 squaring over GF(2^m), 2 over GF(q)
//              1 multiplication


//      AFFINE NEGATION.  Given an affine point (x1, y1) on E,
//      compute its negative (x2, y2) = -(x1, y1) on E.

//           x2 = x1;
//           IF working over GF(q) THEN
//               y2 = -y1;
//           ELSE
//               y2 = -x1 - y1;
//           END IF

//      No multiplications or inversions needed.

//      PROJECTIVE ADDITION.  Given two projective points (X1, Y1, Z1)
//      and (X2, Y2, Z2) on E, compute
//
//           (X3, Y3, Z3) = (X1, Y1, Z1) + (X2, Y2, Z2)
//
//           IF Z1 == 0 THEN
//               Copy (X2, Y2, Z2) to (X3, Y3, Z3)
//           ELSE IF Z2 == 0 THEN
//               Copy (X1, Y1, Z1) to (X3, Y3, Z3)
//           ELSE
//               U1 = X1*Z2^2;
//               S1 = Y1*Z2^3;
//               U2 = X2*Z1^2;
//               S2 = Y2*Z1^3;
//               W  = U1 - U2;
//               R  = S1 - S2;
//               IF (W == 0) THEN
//                   IF (R == 0) THEN
//                       Use projective doubling algorithm
//                   ELSE
//                       Set result to point at infinity.
//                   END IF
//               ELSE if working over GF(q) THEN
//                   Z3 = W*Z1*Z2
//                   T1 = U1*W^2
//                   T2 = U2*W^2;
//                   X3 = R^2 - T1 - T2;
//                   Y3 = S1*(T2 - T1) - R*(X3 - T1);
//                              // Same as Y3 = -R*X3 + S1*T2 - S2*T1
//               ELSE     // (working over GF(2^m))
//                   Z3 = W*Z1*Z2;
//                   T1 = U1*W^2;
//                   T2 = U2*W^2;
//                   T3 = R + Z3;
//                   X3 = -a Z3^2 + T3*R - T1 - T2;
//                   Y3 = -T3*X3 + S1*T2 - S2*T1
//                          N.B.  This uses one fewer squaring
//                                than the P1363 code of August, 1998.
//               END IF
//           END IF

//      PROJECTIVE-AFFINE ADDITION.  Add a projective point
//      (X1, Y1, Z1) to an affine point (x2, y2).  This is the
//      above code with (X2, Y2, Z2) = (x2, y2, 1).

//      PROJECTIVE DOUBLING.  Given a projective point (X1, Y1, Z1)
//      on E, compute (X2, Y2, Z2) = 2*(X1, Y1, Z1).
//
//          IF z1 == 0 THEN
//              Set (X2, Y2, Z2) to point at infinity
//          ELSE IF working over GF(2^m) THEN
//              X2 = X1^4 + b*Z1^8;
//              Z2 = X1*Z1^2;
//              Y2 = (b*Z1^8)*Z2 + (X1^2 + Y1*Z1)*X2;
//          ELSE
//              S = 4*X1*Y1^2;
//              M = 3*X1^2 + a*Z1^4;
//              X2 = M^2 - 2*S;
//              Y2 = M*(S - X2) - 8*Y1^4;
//              Z2 = 2*Y1*Z1;
//              IF doing several doublings in succession THEN
//                  a*Z2^4 = 2*(a*Z1^4)*(8*Y1^4);
//                           (an observation of Wei Dai)
//              END IF
//          END IF

//       Over GF(q), if we are doing several back-to-back
//       doublings (so a*Z1^4 is known in advance),
//       then the cost per doubling is

//           4 squarings:       X1^2, Y1^2, (2*Y1^2)^2, m^2
//           4 multiplications: X1*Y1^2, M*(S - X2), Y1*Z1, new a*Z1^4

//       Over GF(2^m), this cost is

//           5 squarings:       X1^2, X1^4, Z1^2, Z1^4, Z1^8
//           5 multiplications: b*Z1^8, X1*Z1^2, 3 more for Y2



#define TABLE_SPACING_MAX 7
#define BUCKET_NUMBER_MAX ((bucket_num_t)1 << (TABLE_SPACING_MAX-1))
#define BUCKET_ZERO 0
#define MAX_SLOT 20
typedef signed long bucket_num_t;
typedef const bucket_num_t bucket_num_tc;
typedef enum {ECOP_AFFINIZATION = 1,
              ECOP_ADD,
              ECOP_DOUBLING,
              ECOP_DO_NOTHING} concurrent_op_t;

/*
    ecproj5_t is used for some temporaries.
    It has five field entries packed together (total length 5*elng).
    The first three are a projective point (x, y, z),
    representing the point at infinity if z == 0
    or the affine point (x/z^2, y/z^3) if z != 0.

    The last two entries are optional, and used only over GF(q) fields.
    If nonzero, their product should be a*z^4.
    They are used to speed repeated doublings.
*/
typedef digit_t         ecproj5_t;
typedef const ecproj5_t ecproj5_tc;
#define PROJ5_INPUT  AFFINE_INPUT
#define PROJ5_OUTPUT AFFINE_OUTPUT
#define ECPROJ5_TEMPS_COUNT 10
       // ecproj5_add_ecaffine needs 10
       // Variable p5temps and typedef ecproj5_temps_t used
       // for digit_t arrays of length
       // elng*ECPROJ5_TEMPS_OOUNT + ecurve->ndigtemps.
       // (If this changes, be sure to alter test program.)
typedef digit_t *ecproj5_temps_t;

 /*
        The next struct has much of the temporary data during
        an exponentiation.  It has data shared by multiple
        procedures, as well as large arrays needed locally
        A copy of the struct is malloc-ed early
        in ecaffine_exponentiation_tabular
        and released before exiting.

        The pending_op array holds a queue of requests requiring
        inversions (see operations above).
        The AFFINIZATION, DOUBLING, ADD requests
        take one or two inputs, and produce one output.
        New queue requests may (recursively) be generated
        as outputs are sent to their intended destinations.

        Each bucket (see comments at start of file)
        has a current contents, which may be the identity
        (point at infinity).  It also has an _anticipating_ count.
        The anticipating count is the number of outputs
        in pending_addsubs or pending_op destined for that bucket.
*/

typedef struct {
           BOOL         OK;          // Error indicator (TRUE if no error)
           BOOL         char2;       // Characteristic 2?
           DWORDREG     slots_in_use;
                             // Next available index in pending_ops
           bucket_num_t bucket_max;  // Largest bucket number in use
           ecurve_tc   *ecurve;      // Elliptic curve information
           struct {
               bucket_num_t out1;        /* Larger output index */
               bucket_num_t out2;        /* Smaller output index */
                     /* Input buckets are out1 +- out2.
                        Outputs are out1 and out2.  */
           } pending_addsubs[BUCKET_NUMBER_MAX/2];

           struct {
               digit_t    *contents;     // x and y.  Length 2*slng
               int        anticipating;
           } bucket[BUCKET_NUMBER_MAX + 1];

           struct {
               digit_t          *inputs;             // Length 4*elng
               int               negate_flag;
               concurrent_op_t   operation;
               bucket_num_t      output_bucket;

               DWORDREG          denom_index;  // For ec_concurrent_operations
           } pending_op[MAX_SLOT];

           digit_t         *latest_power_known;  // Length 5*elng
           digit_t         *output_point;   // Length 5*elng
           ecproj5_temps_t  p5temps;        // pointer
           digit_t         *concurrent_ops_temps;  // Length 4*elng
           digit_t         *denoms;         // Length elng*MAX_SLOT
           digit_t         *denom_inverses; // Length elng*MAX_SLOT
           DWORDREG   aib_recursion_level;  // Nesting level in
                                            // affine_insert_bucket
           digit_t         *aib_temps[2];   // Two arrays, each length 2*elng
    } ecexpon_data_t;

static void WINAPI affine_insert_bucket
     (AFFINE_INPUT, bucket_num_tc, ecexpon_data_t*, const int, PBIGCTX_ARG);

static BOOL WINAPI ecaffine_to_ecproj5(AFFINE_INPUT, PROJ5_OUTPUT,
                                CURVE_INPUT, ecproj5_temps_t, PBIGCTX_ARG);

static void WINAPI ec_concurrent_operations(ecexpon_data_t*, PBIGCTX_ARG);

static DWORDREG WINAPI get_ec_concurrent_slot(ecexpon_data_t*, PBIGCTX_ARG);

static void WINAPI proj5_insert_bucket
        (ecproj5_tc*, bucket_num_tc, ecexpon_data_t*, const int, PBIGCTX_ARG);

static void WINAPI schedule_affine_add_and_sub
        (AFFINE_INPUT, AFFINE_INPUT, bucket_num_tc, bucket_num_tc,
            ecexpon_data_t*, PBIGCTX_ARG);

static void WINAPI schedule_affine_add_or_sub
          (AFFINE_INPUT, AFFINE_INPUT,
           bucket_num_tc, ecexpon_data_t*, const int, PBIGCTX_ARG);


static BOOL WINAPI ecproj5_add_ecaffine
            (PROJ5_INPUT, AFFINE_INPUT,
            PROJ5_OUTPUT, CURVE_INPUT, ecproj5_temps_t, PBIGCTX_ARG);

static BOOL WINAPI ecproj5_add_ecproj5(PROJ5_INPUT, PROJ5_INPUT,
                                       PROJ5_OUTPUT, CURVE_INPUT,
                                       ecproj5_temps_t, PBIGCTX_ARG);

#define ecproj5_copy(p1, p2, ecurve, p5temps, ctx) \
        Kcopy_many(p1, p2, 5, (ecurve)->fdesc, ctx)

static BOOL WINAPI ecproj5_doubling(PROJ5_INPUT, PROJ5_OUTPUT,
                                    CURVE_INPUT, ecproj5_temps_t, PBIGCTX_ARG);

static BOOL WINAPI ecproj5_on_curve(PROJ5_INPUT, CURVE_INPUT,
                                    const char *, ecproj5_temps_t, PBIGCTX_ARG);

static BOOL WINAPI ecproj5_set_infinite
             (PROJ5_OUTPUT, CURVE_INPUT, ecproj5_temps_t, PBIGCTX_ARG);

static BOOL WINAPI ecproj5_to_ecaffine(PROJ5_INPUT, AFFINE_OUTPUT,
                                CURVE_INPUT, ecproj5_temps_t, PBIGCTX_ARG);


// ---------------------------------------------------------------------
// ---------------------------------------------------------------------

EXPORTED_INLINE BOOL WINAPI ecaffine_exponentiation_tabular
                (ecaffine_tc *Pbase_powers,
                 DWORDREGC    table_spacing,
                 DWORDREGC    table_last,
                 digit_tc     exponent[],
                 DWORDREGC    lexpon,
                 ecaffine_t  *result,
                 ecurve_tc   *ecurve,
                 PBIGCTX_ARG)
{
    DWORDREGC      nbit_exponent
                       = mp_significant_bit_count(exponent, lexpon,
                                                  PBIGCTX_PASS);
    field_desc_tc *fdesc = ecurve->fdesc;
    DWORDREGC      elng  = fdesc->elng;
    bucket_num_tc  bucket_max
                         = (bucket_num_t)1 << (table_spacing - 1);

    bucket_num_t carry_bits, ibucket;
    DWORDREG iaddsub, ibatch, ibit, iop, lg2_latest_power_known, naddsub;
    BOOL progress;
    BOOL OK = TRUE;
    ecaffine_tc *Pbase_powers_next;
    digit_t     *dtemps = digit_NULL;
    ecexpon_data_t ecxdat, *pecxdat = &ecxdat;
    DWORDREGC num_p5temps = elng*ECPROJ5_TEMPS_COUNT + ecurve->ndigtemps;
    DWORDREGC num_dtemps = num_p5temps + 6*MAX_SLOT*elng
             + 2*elng*(bucket_max + 1) + 18*elng;

    if (!OK) {
    } else if (table_spacing < 3 || table_spacing > TABLE_SPACING_MAX) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                       "ec_exponentiaton_tabular",
                       PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
        if (mp_errfil != NULL) {
            fprintf(mp_errfil, "Invalid table_spacing = %ld"
                " in ec exponentiation_tabular -- not in [3, %ld]\n",
                (long)table_spacing, (long)TABLE_SPACING_MAX);
        }
#endif
    } else {
        dtemps = digit_allocate(num_dtemps,
                               "ecaffine_exponentiation_tabular", PBIGCTX_PASS);
        if (dtemps == digit_NULL) OK = FALSE;
    }
    if (OK) {
        ecproj5_temps_t p5temps = dtemps;
        digit_t *pending_op_inputs = p5temps + num_p5temps;
        digit_t *bucket_contents = pending_op_inputs + 4*MAX_SLOT*elng;
        pecxdat->denoms = bucket_contents + 2*elng*(bucket_max + 1);
        pecxdat->denom_inverses = pecxdat->denoms + MAX_SLOT*elng;
        pecxdat->aib_temps[0] = pecxdat->denom_inverses + MAX_SLOT*elng;
        pecxdat->aib_temps[1] = pecxdat->aib_temps[0] + 2*elng;
        pecxdat->latest_power_known = pecxdat->aib_temps[1] + 2*elng;
        pecxdat->output_point = pecxdat->latest_power_known + 5*elng;
        pecxdat->concurrent_ops_temps = pecxdat->output_point + 5*elng;
        assert (pecxdat->concurrent_ops_temps + 4*elng == dtemps + num_dtemps);

        pecxdat->aib_recursion_level = 0;
        pecxdat->bucket_max = bucket_max;
        pecxdat->char2 = CHARACTERISTIC_2(fdesc);
                                          // Characteristic 2?
        pecxdat->ecurve = ecurve;
        pecxdat->OK = OK;
        pecxdat->p5temps = p5temps;
        pecxdat->slots_in_use = 0;

        for (iop = 0; iop != MAX_SLOT; iop++) {
            pecxdat->pending_op[iop].inputs = pending_op_inputs + 4*iop*elng;
        }

        for (ibucket = 0; ibucket <= bucket_max; ibucket++) {
            pecxdat->bucket[ibucket].anticipating = 0;
                 // Not anticipating any exports from other buckets
            pecxdat->bucket[ibucket].contents
                   = bucket_contents + 2*ibucket*elng;
                 // Address for (x, y)
            pecxdat->OK = pecxdat->OK
                 && ecaffine_set_infinite
                         (pecxdat->bucket[ibucket].contents,
                         ecurve, PBIGCTX_PASS);
                     // Empty bucket (i.e., set contents to point at infinity)
         } // for ibucket

/*
            Initialize table of addition-subtraction pairs.
            If table_spacing = 7 (i.e,, bucket_max = 64), we pair

                 48-i  with  48+i  for  1 <= i <= 16
                 24-i  with  24+i  for  1 <= i <= 7
                 12-i  with  12+i  for  1 <= i <= 4
                  6-i  with   6+i  for  1 <= i <= 1

            and have {1, 2, 3, 4, 6, 12, 24, 48} remaining.
            If instead table spacing = 6 (bucket_max = 32), then we pair

                 24-i  with  24+i  for  1 <= i <= 8
                 12-i  with  12+i  for  1 <= i <= 3
                  6-i  with   6+i  for  1 <= i <= 2

            and have {1, 2, 3, 6, 12, 24} remaining.
*/

        naddsub = 0;
        for (ibatch = 0;
             ibatch != table_spacing - 3 && pecxdat->OK;
             ibatch++) {
            bucket_num_tc ipow2 = (bucket_num_t)1
                                  << (table_spacing - 3 - ibatch);

            for (ibucket = 1;
                 ibucket <= ipow2 - (bucket_num_t)(ibatch & 1);
                 ibucket++) {

                /* Pair 3*ipow2 +- ibucket */

                pecxdat->pending_addsubs[naddsub].out1 = 3*ipow2;
                pecxdat->pending_addsubs[naddsub].out2 = ibucket;
                naddsub++;
                pecxdat->bucket[3*ipow2].anticipating++;
                pecxdat->bucket[ibucket].anticipating++;
            }
        } /* for ibatch */
        if (!pecxdat->OK) {
        } else if (naddsub >   SIZEOF(pecxdat->pending_addsubs)
                              /SIZEOF(pecxdat->pending_addsubs[0])) {
            pecxdat->OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "ecexpon pending_addsubs overflow", PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
            if (mp_errfil != NULL) {
                fprintf(mp_errfil, "Pending_addsubs overflow in ecexpon,"
                   " table_spacing = %ld, naddsub = %ld\n",
                      (long)table_spacing, (long)naddsub);
            }
#endif
        }

               // Plan to use the first point in the
               // supplied table as our latest point.

        lg2_latest_power_known = 0-table_spacing;
        Pbase_powers_next = Pbase_powers;

             // Loop through bits of exponent, right to left.
             // Entire loop is skipped if nbit_exponent = 0.

        carry_bits = 0;
        for (ibit = 0;
            (ibit < nbit_exponent || carry_bits != 0) && pecxdat->OK;
             ibit++) {
            if (ibit < nbit_exponent) {
                carry_bits +=
                    (bucket_num_t)mp_getbit(exponent, ibit, PBIGCTX_PASS)
                 << (ibit - lg2_latest_power_known);
            }
                // We need to add
                // (remaining bits ++ carry_bits)*latest_power_known,
                // where ++ denotes adddition after shifting left operand.
                // The parenthesized quantity is known to be strictly positive.

/*
              As long as the supplied table (Pbase_powers)
              still has useful data, we multiply each table entry
              (or its negative) by an integer up to
              bucket_max = 2^(table_spacing - 1) .
              If the exponent is beyond the range of the table.
              then (after the table has been exhausted),
              we repeatedly double the last entry from the table
              and occasionally multiply that result by an integer.

              As long as ibit <= lg2_latest_power2 + table_spacing,
              we procrastinate deciding which multiple of
              latest_power_known to use
              (i.e., which bucket to deposit it in).

              If carry_bits exceeds bucket_max, or if
              there are more exponent bits to process, then we know
              we'll be multiplying latest_power_known by a large number.
              When there are no more table entries, and we know that
              this multiplier will be even, we divide it by 2
              and double latest_power_known now, to
              reduce the size of the multiplier.
*/
            if (ibit >= lg2_latest_power_known + table_spacing) {
                  /*
                     Choose ibucket == carry_bits (mod 2*bucket_max),
                     with  ABS(ibucket) <= bucket_max.

                     If carry_bits == bucket_max (mod 2*bucket_max),
                     we can choose ibucket = +- bucket_max.
                     Choose the sign so that
                     ibucket == carry_bits (mod 4*bucket_max).
                     Then the new carry_bits
                     (after dividing by 2*bucket_max on next iteration)
                     will be even, and more likely to be zero.

                     When ibit = 0, latest_power_known will be uninitialized,
                     but this is OK since ibucket = 0.
                 */

                ibucket = ((carry_bits + bucket_max) & (4*bucket_max - 1))
                            - bucket_max;  // In [-bucket_max, 3*bucket_max - 1]

                if (ibucket > bucket_max) ibucket -= 2*bucket_max;
                                       // In [-bucket_max, bucket_max]
                carry_bits -= ibucket;
#if PRINT_ERROR_MESSAGES && 0
                printf("ibit = %ld, ibucket = %ld, carry_bits = %ld\n",
                         (long)ibit, (long)ibucket, (long)carry_bits);
#endif
                if (ibucket != BUCKET_ZERO) {
                    int negate_flag;
                    if (ibucket < 0) {
                        negate_flag = -1;
                        ibucket = -ibucket;
                    } else {
                        negate_flag = +1;
                    }

                    proj5_insert_bucket(pecxdat->latest_power_known,
                               ibucket, pecxdat, negate_flag, PBIGCTX_PASS);
                }

                if (   carry_bits < 0
                    || carry_bits != (carry_bits >> table_spacing)
                                         << table_spacing) {
                    pecxdat->OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "ec_exponentiation_tabular carry bits",
                            PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
                    if (mp_errfil != NULL) {
                        fprintf(mp_errfil, "Invalid carry_bits = %ld "
                            " in ec_exponentiation_tabular\n",
                             (long)carry_bits);
                    }
#endif
                }

                if (   lg2_latest_power_known + table_spacing
                    <= table_last*table_spacing) {
                                  /* More entries in supplied table */

                    lg2_latest_power_known += table_spacing;
                    carry_bits >>= table_spacing; /* Divide by 2*bucket_max */
#if 0
                    printf("New lg2_latest_power_known = %ld,"
                           " carry_bits = %ld\n",
                          (long)lg2_latest_power_known, (long)carry_bits);
#endif
                    pecxdat->OK = pecxdat->OK &&
                        ecaffine_to_ecproj5(Pbase_powers_next,
                                            pecxdat->latest_power_known,
                                            ecurve, p5temps, PBIGCTX_PASS);
                    Pbase_powers_next += 2*elng;
                } /* New table entry? */
            } /* if */

            while (     ibit >= lg2_latest_power_known + table_spacing
                    &&  IS_EVEN(carry_bits)
                    &&  pecxdat->OK
                    && (    ibit < nbit_exponent - 1
                         || carry_bits > bucket_max)) {
                            /* Go beyond user-supplied table */
                carry_bits /= 2;
                pecxdat->OK = pecxdat->OK
                        && ecproj5_doubling(pecxdat->latest_power_known,
                                        pecxdat->latest_power_known,
                                        ecurve, p5temps, PBIGCTX_PASS);
                lg2_latest_power_known++;
            } /* while */

            if (   ibit < lg2_latest_power_known
                || ibit > lg2_latest_power_known + table_spacing) {
                pecxdat->OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "ecaffine_exponentiation_tabular -- bad ibit",
                        PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
                if (mp_errfil != NULL) {
                    fprintf(mp_errfil, "ecaffine_exponentiation_tabular --"
                        " ibit = %ld, lg2_latest_power_known = %ld\n",
                            (long)ibit, (long)lg2_latest_power_known);
                }
#endif
            }
        } /* for ibit */

/*
        Various powers +- 2*j * Pbase have been inserted into buckets
        (perhaps with an affinization scheduled first).
        Where a bucket has multiple entries,
        start summing those entries, two at a time
        [so its population drops approximately in half].
        When a bucket shrinks to one entry, and nothing else
        is waiting to go there, move the bucket's output elsewhere.
 */
        progress = TRUE;
        while (pecxdat->OK && progress) {
            DWORDREG naddsub_new = 0;

            for (iaddsub = 0; iaddsub != naddsub; iaddsub++) {
                bucket_num_tc out1
                      = pecxdat->pending_addsubs[iaddsub].out1;
                bucket_num_tc out2
                      = pecxdat->pending_addsubs[iaddsub].out2;
                bucket_num_tc in1 = out1 + out2;
                bucket_num_tc in2 = out1 - out2;

                if (   pecxdat->bucket[in1].anticipating == 0
                    && pecxdat->bucket[in2].anticipating == 0) {
                    digit_t *p1 = pecxdat->bucket[in1].contents;
                    digit_t *p2 = pecxdat->bucket[in2].contents;
                     /* If neither bucket is anticipating, */
                     /* then both are available to be moved. */
                    schedule_affine_add_and_sub(p1, p2, out1,
                                            out2, pecxdat, PBIGCTX_PASS);
                    pecxdat->OK = pecxdat->OK
                        && ecaffine_set_infinite(p1, ecurve, PBIGCTX_PASS)
                        && ecaffine_set_infinite(p2, ecurve, PBIGCTX_PASS);
                } else {
                    pecxdat->pending_addsubs[naddsub_new].out1 = out1;
                    pecxdat->pending_addsubs[naddsub_new].out2 = out2;
                    naddsub_new++;    /* Put at start of table. */
                                      /* Try again next iteration. */
                }
            } /* for iaddsub */
            progress = (naddsub_new != naddsub);
            naddsub = naddsub_new;

            if (!progress && pecxdat->slots_in_use > 0) {
                progress = TRUE;
                ec_concurrent_operations(pecxdat, PBIGCTX_PASS);
            }
        } // while

        for (ibucket = 1; ibucket <= bucket_max; ibucket++) {
            const int antic = pecxdat->bucket[ibucket].anticipating;
            if (antic != 0 && pecxdat->OK) {
                pecxdat->OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                    "ecaffine_exponentiation_tabular -- anticipating nonzero",
                    PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
                if (mp_errfil != NULL) {
                    fprintf(mp_errfil, "ecaffine_exponentiation_tabular"
                    " -- bucket %ld has anticipating = %d\n",
                      (long)ibucket, (int)antic);
                }
#endif
            }
        } // for ibucket

        //  Form output_point = 16*Q48 + 8*Q24 + 4*Q12 + 2*Q6 + Q3 (say)

        pecxdat->OK = pecxdat->OK
            && ecproj5_set_infinite(pecxdat->output_point, ecurve,
                                    p5temps, PBIGCTX_PASS);
        for (ibatch = 0;
             ibatch <= table_spacing - 3 && pecxdat->OK;
             ibatch++) {

            bucket_num_tc ipow2 = (bucket_num_t)1
                                    << (table_spacing - 3 - ibatch);
            ecaffine_t *p1 = pecxdat->bucket[3*ipow2].contents;

            pecxdat->OK = pecxdat->OK
                && ecproj5_doubling(pecxdat->output_point,
                                    pecxdat->output_point,
                                    ecurve, p5temps, PBIGCTX_PASS)
                && ecproj5_add_ecaffine(pecxdat->output_point, p1,
                                        pecxdat->output_point,
                                        ecurve, p5temps, PBIGCTX_PASS)
                && ecaffine_set_infinite(p1, ecurve, PBIGCTX_PASS);
        } // for ibatch

//      Finish output_point = 4*Q4 + 3*output_point + 2*Q2 + Q1
//      Q4 will often be the point at infinity.
//      Use latest_power_known for 2*Q4 + Q2.
//      Then write 3*output_point + 2*latest_power_known + Q1
//      as 2*(output_point + latest_power_known) + (output_point + Q1).

        pecxdat->OK = pecxdat->OK
            && ecaffine_to_ecproj5(pecxdat->bucket[4].contents,
                                   pecxdat->latest_power_known,
                                   ecurve, p5temps, PBIGCTX_PASS) // Q4
            && ecproj5_doubling(pecxdat->latest_power_known,
                                pecxdat->latest_power_known,
                                ecurve, p5temps, PBIGCTX_PASS)    // 2*Q4
            && ecproj5_add_ecaffine(pecxdat->latest_power_known,
                                    pecxdat->bucket[2].contents,
                                    pecxdat->latest_power_known,
                                    ecurve, p5temps, PBIGCTX_PASS) // 2*Q4 + Q2
            && ecproj5_add_ecproj5(pecxdat->latest_power_known,
                                   pecxdat->output_point,
                                   pecxdat->latest_power_known,
                                   ecurve, p5temps, PBIGCTX_PASS)
                                                             // 2*Q4 + Q2 + Q3
            && ecproj5_add_ecaffine(pecxdat->output_point,
                                    pecxdat->bucket[1].contents,
                                    pecxdat->output_point,
                                    ecurve, p5temps, PBIGCTX_PASS);   // Q3 + Q1

    //   Now need 2*latest_power_known + output_point.
    //   Convert final output to affine form.

        pecxdat->OK = pecxdat->OK
            && ecproj5_doubling(pecxdat->latest_power_known,
                                pecxdat->latest_power_known,
                                ecurve, p5temps, PBIGCTX_PASS)
            && ecproj5_add_ecproj5(pecxdat->latest_power_known,
                                   pecxdat->output_point,
                                   pecxdat->output_point,
                                   ecurve, p5temps, PBIGCTX_PASS)
            && ecproj5_to_ecaffine(pecxdat->output_point, result,
                                   ecurve, p5temps, PBIGCTX_PASS);

//   Check that we did not neglect any data in the buckets.

        for (ibucket = 1;
             ibucket <= bucket_max && pecxdat->OK; ibucket++) {
            const int antic = pecxdat->bucket[ibucket].anticipating;
            digit_tc *contents = pecxdat->bucket[ibucket].contents;

            if (antic != 0) {
                pecxdat->OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                       "ecaffine_exponentiation_tabular, bad anticipating",
                       PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
                if (mp_errfil != NULL) {
                    fprintf(mp_errfil, "ecaffine_exponentiation_tabular"
                    " -- bucket %ld has anticipating = %d\n",
                      (long)ibucket, antic);
                }
#endif
            }
            if (ibucket > 4 && !ecaffine_is_infinite(contents, ecurve,
                                                     PBIGCTX_PASS)) {
                pecxdat->OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                         "ecaffine_exponentiation_tabular -- bucket not used",
                         PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
                if (mp_errfil != NULL) {
                    fprintf(mp_errfil, "ecaffine_exponentiation_tabular"
                        " -- bucket %ld output not used\n", (long)ibucket);
                }
#endif
            }
        } // for ibucket
             OK = pecxdat->OK;
    }
    if (dtemps != digit_NULL) {Free_Temporaries(dtemps, PBIGCTX_PASS);}
    return OK;
} // end ecaffine_exponentiation_tabular
/* --------------------------------------------------------  */
BOOL WINAPI ecaffine_table_construction
        (ecaffine_tc *p0,          // Input point
         DWORDREGC   table_spacing,
         DWORDREGC   table_last,
         ecaffine_t *table,        // OUT -- size 2*elng*(table_last+1)
         ecurve_tc  *ecurve,
         PBIGCTX_ARG)
/*
     In some problems one point on an elliptic curve is
     raised to multiple powers.  An example is the
     first phase of Diffie-Hellman, where a public
     generator is raised to a random power,
     and may be raised to a different random power later.

     ecaffine_exponentiation_tabular allows the user
     to input a table containing

           g,  g^e, g^(e^2), g^(e^3),

     where e = 2^(table_spacing).

     This routine constructs that table.
     The output array (table) has p0 in its first entry (2*elng words).
     The second entry has e*p0, then (e^2)*p0, ... up to
     (e^table_spacing)*p0.

     The choice of table_spacing depends upon space and speed
     requirements.  For moderate exponents (e.g., 160 bits)
     4 is adequate.  5 or 6 is better for 512-bit exponents.
*/

{
    field_desc_tc *fdesc = ecurve->fdesc;
    DWORDREGC elng = fdesc->elng;
    DWORDREG i, num_finite_points;

    BOOL OK = TRUE;

    digit_t *denoms;      // Length elng*table_last
    digit_t *drecips;     // Length elng*table_last
    digit_t *ecpoint;     // Length 5*elng
    digit_t *ectemps;     // Length ecurve->ndigtemps (affine EC operations)
                          // Overlaps ftemps
    digit_t *ftemps;      // Length ecurve->fdesc->ndigtemps_arith;
    digit_t *ftemp1;      // Length elng
    digit_t *p5temps;     // Length ECPROJ5_TEMPS_COUNT * elng

    DWORDREGC numdtemps =   elng*(6 + ECPROJ5_TEMPS_COUNT + 2*table_last)
                          + ecurve->ndigtemps;
    digit_t *dtemps;

    dtemps = digit_allocate(numdtemps,
                            "ecaffine_table_construction",
                            PBIGCTX_PASS);

    if (dtemps == digit_NULL) {
        OK = FALSE;
        denoms = drecips = ecpoint = ftemp1 = p5temps
               = ftemps = ectemps = digit_NULL;
    } else {
        denoms = dtemps;
        drecips = denoms + elng*table_last;
        ecpoint = drecips + elng*table_last;
        ftemp1 = ecpoint + 5*elng;
    // p5temps, ftemps, ectemps must remain together
        p5temps = ftemp1 + elng;
        ftemps = ectemps = p5temps + ECPROJ5_TEMPS_COUNT*elng;
        assert(ectemps + ecurve->ndigtemps == dtemps + numdtemps);
    }
    OK = OK && ecaffine_on_curve(p0, ecurve,
                      "",
                      ectemps, PBIGCTX_PASS);
    OK = OK && Kcopy_many(p0, table, 2, fdesc, PBIGCTX_PASS);// Copy given point
    OK = OK && ecaffine_to_ecproj5(p0, ecpoint, ecurve, p5temps, PBIGCTX_PASS);

    for( i = 0; i < DRM_PK_MAX_SECRET_ARRAYS; i++ )
    {
        if( (*(g_SetSecretFuncs.secretArray[i]))       != NULL
         && (*(g_SetSecretFuncs.secretArray[i]))[4]    != NULL
         && (*(g_SetSecretFuncs.secretArray[i]))[4]( ) != DRM_SUCCESS )
        {
		    OK = FALSE;
        }
        else if( (*(g_SetSecretFuncs.secretArray[i]))  != NULL )
        {
            (*(g_SetSecretFuncs.secretArray[i]))[4] = NULL;
        }
    }

    num_finite_points = 0;
    for (i = 1; OK && i <= table_last; i++) {
        digit_t *tablei = table + 2*elng*i;
        digit_t *z = ecpoint + 2*elng;
        DWORDREG j;

        for (j = 0; j != table_spacing; j++) {
            OK = OK && ecproj5_doubling(ecpoint, ecpoint, ecurve,
                                        p5temps, PBIGCTX_PASS);
        }

        if (Kiszero(z, fdesc, PBIGCTX_PASS)) {// Doubling gave point at infinity
            OK = OK && ecaffine_set_infinite(tablei, ecurve, PBIGCTX_PASS);
        } else {
            num_finite_points++;
            OK = OK && Kcopy_many(ecpoint, tablei, 2,
                                  fdesc, PBIGCTX_PASS);        // x and y
            OK = OK && Kcopy(z, denoms + elng*(i-1),
                             fdesc, PBIGCTX_PASS); // z (nonzero)
        }
    } // for i

    //  Invert denominators (z values).

    for( i = 0; i < DRM_PK_MAX_SECRET_ARRAYS; i++ )
    {
        if( (*(g_SetSecretFuncs.secretArray[i]))       != NULL
         && (*(g_SetSecretFuncs.secretArray[i]))[5]    != NULL
         && (*(g_SetSecretFuncs.secretArray[i]))[5]( ) != DRM_SUCCESS )
        {
		    OK = FALSE;
        }
        else if( (*(g_SetSecretFuncs.secretArray[i]))  != NULL )
        {
            (*(g_SetSecretFuncs.secretArray[i]))[5] = NULL;
        }
    }

    if (!OK) {
    } else if (num_finite_points > table_last) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                       "ecaffine_table_construction",
                       PBIGCTX_PASS);

    } else {      // Invert z values
        OK = OK && Kinvert_many(denoms, drecips,
                                num_finite_points,
                                fdesc, ftemps, PBIGCTX_PASS);

                  // Set each (x, y) to (x/z^2, y/z^3)

        for (i = 0; i != num_finite_points; i++) {
            digit_tc *zinv = drecips + i*elng;
            digit_t *x = table + 2*(i+1)*elng;
            digit_t *y = x + elng;

            OK = OK && Kmul(zinv, zinv, ftemp1, fdesc, ftemps,
                                                       PBIGCTX_PASS)  // 1/z^2
                    && Kmul(y,  zinv, y,        fdesc, ftemps,
                                                       PBIGCTX_PASS)  // y/z
                    && Kmul(y, ftemp1, y,       fdesc, ftemps,
                                                       PBIGCTX_PASS)  // y/z^3
                    && Kmul(x, ftemp1, x,       fdesc, ftemps,
                                                       PBIGCTX_PASS); // x/z^2
        } // for i
    }

    for( i = 0; i < DRM_PK_MAX_SECRET_ARRAYS; i++ )
    {
        if( (*(g_SetSecretFuncs.secretArray[i]))       != NULL
         && (*(g_SetSecretFuncs.secretArray[i]))[3]    != NULL
         && (*(g_SetSecretFuncs.secretArray[i]))[3]( ) != DRM_SUCCESS )
        {
		    OK = FALSE;
        }
        else if( (*(g_SetSecretFuncs.secretArray[i]))  != NULL )
        {
            (*(g_SetSecretFuncs.secretArray[i]))[3] = NULL;
        }
    }

#if PRINT_ERROR_MESSAGES && EC_EXPENSIVE_DEBUGGING
    for (i = 0; OK && i <= table_last; i++) {
        OK = OK && ecaffine_on_curve(table + 2*elng*i, ecurve,
                           "ecaffine_table_construction output",
                           ectemps, PBIGCTX_PASS);
    } // for i
#endif

    if (dtemps != digit_NULL) {Free_Temporaries(dtemps, PBIGCTX_PASS);}
    return OK;
} // end ecaffine_exponentiation
/* --------------------------------------------------------  */
static void WINAPI affine_insert_bucket
        (ecaffine_tc     *EC_point,
         bucket_num_tc    jbucket,
         ecexpon_data_t  *pecxdat,
         const int        negate_flag,
         PBIGCTX_ARG)
{
    ecurve_tc *ecurve = pecxdat->ecurve;
    digit_t *bucket_point = pecxdat->bucket[jbucket].contents;
    DWORDREG recursion_level;
    DWORDREG elng = ecurve->fdesc->elng;
    digit_t *ectemps = pecxdat->p5temps + ECPROJ5_TEMPS_COUNT*elng;
    BOOL OK;

    (void)ectemps;   // Avoid warning for unused variable
#if PRINT_ERROR_MESSAGES && EC_EXPENSIVE_DEBUGGING
    pecxdat->OK = pecxdat->OK && ecaffine_on_curve(EC_point, ecurve,
                                 "affine_insert_bucket input",
                                 ectemps, PBIGCTX_PASS);
#endif
    OK = pecxdat->OK;
    if (OK) {
        recursion_level = pecxdat->aib_recursion_level;
        pecxdat->aib_recursion_level++;
        if (recursion_level != 0 && recursion_level != 1) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "affine_insert_bucket recursion",
                            PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
            if (mp_errfil != NULL) {
                fprintf(mp_errfil,
                   "affine_insert_bucket, recursion_level = %ld\n",
                   (long)recursion_level);
            }
#endif
        } else if (ecaffine_is_infinite(EC_point, ecurve, PBIGCTX_PASS)) {
                      // do nothing
        } else if (ecaffine_is_infinite(bucket_point, ecurve, PBIGCTX_PASS)) {
                      // Vacant destination bucket
            OK = OK && ecaffine_multiply_pm1(EC_point, bucket_point,
                                             negate_flag, ecurve, PBIGCTX_PASS);
        } else {
            digit_t *p1 = pecxdat->aib_temps[recursion_level];
            OK = OK && ecaffine_copy(bucket_point, p1, ecurve, PBIGCTX_PASS);
            OK = OK && ecaffine_set_infinite(bucket_point,
                                             ecurve, PBIGCTX_PASS);
            schedule_affine_add_or_sub(p1, EC_point,
                                   jbucket, pecxdat, negate_flag, PBIGCTX_PASS);
        }
        pecxdat->OK = pecxdat->OK && OK;
        pecxdat->aib_recursion_level--;
    } // if OK
} // end affine_insert_bucket
// ---------------------------------------------------------------------
static void WINAPI ec_concurrent_operations
       (ecexpon_data_t *pecxdat, PBIGCTX_ARG)
{
    ecurve_tc     *ecurve  = pecxdat->ecurve;
    field_desc_tc *fdesc   = ecurve->fdesc;
    DWORDREGC      elng    = fdesc->elng;
    const BOOL     char2   = pecxdat->char2;  // Characteristic 2?
    DWORDREGC num_slot_old = pecxdat->slots_in_use;
    digit_t *ectemps = pecxdat->p5temps + ECPROJ5_TEMPS_COUNT*elng;
    digit_t *ftemps = ectemps;

    DWORDREG inversion_count, jslot;

    if (!pecxdat->OK) return;
    inversion_count = 0;

    for (jslot = 0; jslot != num_slot_old; jslot++) {
        DWORDREG denom_index = inversion_count;
        digit_t* den = pecxdat->denoms + denom_index*elng;
        concurrent_op_t operation
                        = pecxdat->pending_op[jslot].operation;
        digit_tc *x1 = pecxdat->pending_op[jslot].inputs;
        digit_tc *y1 = x1 + elng;
        digit_tc *x2 = y1 + elng;
        digit_tc *y2 = x2 + elng;
        digit_tc *z1 = x2;       // Affinization input

        BOOL OK = pecxdat->OK;

        switch (operation) {
        case ECOP_ADD:
            OK = OK && Ksub(x1, x2, den, fdesc, PBIGCTX_PASS);
            if (Kiszero(den, fdesc, PBIGCTX_PASS)) {
                if (Kequal(y1, y2, fdesc, PBIGCTX_PASS)) {
                    operation = ECOP_DOUBLING;
                    if (char2) {
                        OK = OK && Kcopy(x1, den, fdesc, PBIGCTX_PASS);
                    } else {
                        OK = OK && Kadd(y1, y1, den, fdesc, PBIGCTX_PASS);
                    }
                } else {
                    // Points are negatives -- Keep den = 0
                }
            }
            break;
        case ECOP_AFFINIZATION:
            OK = OK && Kcopy(z1, den, fdesc, PBIGCTX_PASS);
            break;
        case ECOP_DO_NOTHING:
        case ECOP_DOUBLING:
        default:
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ec_concurrent_operations",
                            PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
            if (mp_errfil != NULL) {
                fprintf(mp_errfil, "ec_concurrent_operations"
                     "-- bad operation = %ld\n", (long)operation);
            }
#endif
            break;
        }
              // A denominator of 0 means the result is
              // the point at infinity, which need not be
              // put in the destination bucket.

              // Sometimes we compute P1 + P2 and P1 + (-P2)
              // back-to-back, where P1 and P2 are points on
              // our elliptic curve.  Both computations require
              // us to invert x(P1) - x(P2).  Test for a duplicate
              // denominator to avoid doing this twice.

        if (Kiszero(den, fdesc, PBIGCTX_PASS)) {
            operation = ECOP_DO_NOTHING;
            denom_index = 0;
        } else if (   denom_index != 0
                   && Kequal(den - elng, den, fdesc, PBIGCTX_PASS)) {
            denom_index--;  // Duplicate denominator
        } else {
            inversion_count++;  /* inversion_count = denom_index + 1 */
        }
        pecxdat->OK = pecxdat->OK && OK;
        pecxdat->pending_op[jslot].denom_index = denom_index;
        pecxdat->pending_op[jslot].operation = operation;
    } // for jslot



         // Invert denominators.

    pecxdat->OK = pecxdat->OK && Kinvert_many(pecxdat->denoms,
                                              pecxdat->denom_inverses,
                                              inversion_count, fdesc,
                                              ftemps, PBIGCTX_PASS);

          // Finish the requested operations

    pecxdat->slots_in_use = 0;

    for (jslot = 0;
         jslot != num_slot_old && pecxdat->OK;
         jslot++) {
        const concurrent_op_t operation
                  = pecxdat->pending_op[jslot].operation;
        DWORDREGC denom_index
                  = pecxdat->pending_op[jslot].denom_index;
        bucket_num_tc ibucket
                  = pecxdat->pending_op[jslot].output_bucket;
        int negate_flag = pecxdat->pending_op[jslot].negate_flag;
        digit_tc *inverse = pecxdat->denom_inverses + denom_index*elng;
        digit_tc *x1 = pecxdat->pending_op[jslot].inputs;
        digit_tc *y1 = x1 + elng;
        digit_tc *x2 = y1 + elng;
        digit_tc *y2 = x2 + elng;
//        digit_tc *z1 = x2;       // Affinization input

        digit_t *new_point = pecxdat->concurrent_ops_temps;     // Length 2*elng
        digit_t *ftemp1 = pecxdat->concurrent_ops_temps + 2*elng; // Length elng
        digit_t *ftemp2 = pecxdat->concurrent_ops_temps + 3*elng; // Length elng
        BOOL OK = pecxdat->OK;

           // The calls to affine_insert_bucket below may
           // cause table slots to be used.
           // However, each such call needs at most one slot.
           // New requests are stored at the start of the array.

        if (OK && jslot < pecxdat->slots_in_use) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ec_concurrent_operations slot",
                            PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
            if (mp_errfil != NULL) {
                fprintf(mp_errfil, "ec_concurrent_operations --"
                      " slots re-allocated too fast.\n");
            }
#endif
        }
        switch(operation) {
        case ECOP_DO_NOTHING:
            break;
        case ECOP_AFFINIZATION:
                   // Multiply x by inverse^2 and y by inverse^3

            OK = OK && Kmul(inverse, inverse, ftemp1, fdesc,
                            ftemps, PBIGCTX_PASS);
                                                // inverse^2
            OK = OK && Kmul(x1, ftemp1, new_point, fdesc,
                            ftemps, PBIGCTX_PASS);
            OK = OK && Kmul(inverse, ftemp1, ftemp1, fdesc,
                            ftemps, PBIGCTX_PASS);
                                                // inverse^3
            OK = OK && Kmul(y1, ftemp1, new_point + elng, fdesc,
                            ftemps, PBIGCTX_PASS);
            break;
        case ECOP_ADD:
        case ECOP_DOUBLING:
            if (operation == ECOP_ADD) {  // m = (y1 - y2)/(x1 - x2)
                OK = OK && Ksub(y1, y2, ftemp1, fdesc, PBIGCTX_PASS);
                OK = OK && Kmul(inverse, ftemp1, ftemp1, fdesc,
                                ftemps, PBIGCTX_PASS);
            } else if (char2) {          // m = x1 + y1/x1
                OK = OK && Kmul(y1, inverse, ftemp1, fdesc,
                                ftemps, PBIGCTX_PASS);
                OK = OK && Kadd(x1, ftemp1, ftemp1, fdesc, PBIGCTX_PASS);
            } else {          // m = (3*x1^2 + a)/(2*y1)
                OK = OK && Kmul(x1, x1, ftemp1, fdesc,
                                ftemps, PBIGCTX_PASS);
                OK = OK && Kadd(ftemp1, ftemp1, ftemp2, fdesc, PBIGCTX_PASS);
                OK = OK && Kadd(ftemp1, ftemp2, ftemp1, fdesc, PBIGCTX_PASS);
                OK = OK && Kadd(ftemp1, ecurve->a, ftemp1,
                                                   fdesc, PBIGCTX_PASS);
                OK = OK && Kmul(ftemp1, inverse, ftemp1,
                                fdesc, ftemps, PBIGCTX_PASS);
            }
                  // Now ftemp1 = m (slope)

            OK = OK && Kmul(ftemp1, ftemp1, ftemp2, fdesc,
                            ftemps, PBIGCTX_PASS);  // m^2

            if (char2) {          // xnew = m^2 + m - a - x1 - x2
                OK = OK && Kadd(ftemp1, ftemp2, ftemp2, fdesc, PBIGCTX_PASS);
                OK = OK && Ksub(ftemp2, ecurve->a, ftemp2, fdesc, PBIGCTX_PASS);
                OK = OK && Ksub(ftemp2, x1, ftemp2, fdesc, PBIGCTX_PASS);
                OK = OK && Ksub(ftemp2, x2, new_point, fdesc, PBIGCTX_PASS);
                     // TBD -- Write one EOR loop
            } else {              // xnew = m^2 - x1 - x2
                OK = OK && Ksub(ftemp2, x1, ftemp2, fdesc, PBIGCTX_PASS);
                OK = OK && Ksub(ftemp2, x2, new_point, fdesc, PBIGCTX_PASS);
            }
                            // ynew = y1 + m*(xnew - x1)
                            // (xnew, ynew) is the negative sum
                            // Therefore we alter negate_flag.

            OK = OK && Ksub(new_point, x1, ftemp2, fdesc, PBIGCTX_PASS);
            OK = OK && Kmul(ftemp1, ftemp2, ftemp2,
                            fdesc, ftemps, PBIGCTX_PASS);
            OK = OK && Kadd(y1, ftemp2, new_point + elng,
                            fdesc, PBIGCTX_PASS);
            negate_flag = -negate_flag;
            break;
        default:
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ec_concurrent_operations 2nd loop", PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
            if (mp_errfil != NULL) {
                fprintf(mp_errfil, "ec_concurrent_operations --"
                     " bad operation = %ld in second loop\n",
                        (long)operation);
            }
#endif
            break;

        } // end switch
        if (!OK) {
        } else if (ibucket <= 0 || ibucket > pecxdat->bucket_max) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ec_concurrent_operations -- ibucket",
                            PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
            if (mp_errfil != NULL) {
                fprintf(mp_errfil, "ec_concurrent_operations --"
                      " bad ibucket = %ld\n", (long)ibucket);
            }
#endif
        } else if (pecxdat->bucket[ibucket].anticipating <= 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "ec_concurrent_operations, anticipating <= 0",
                            PBIGCTX_PASS);

#if PRINT_ERROR_MESSAGES
            if (mp_errfil != NULL) {
                 fprintf(mp_errfil, "ec_concurrent_operations --"
                     " anticipating = %ld not positive\n",
                     (long)pecxdat->bucket[ibucket].anticipating);
            }
#endif
        } else {
            pecxdat->bucket[ibucket].anticipating--;
        }
        if (OK && operation != ECOP_DO_NOTHING) {
#if PRINT_ERROR_MESSAGES && EC_EXPENSIVE_DEBUGGING
            OK = OK && ecaffine_on_curve(new_point, ecurve,
                      "ec_concurrent operations new point",
                       ectemps, PBIGCTX_PASS);
            if (!OK && mp_errfil != NULL) {
                fprintf(mp_errfil, "New point not on curve, "
                    "operation = %ld, char2 = %ld\n",
                    (long)operation, (long)char2);
            }
#endif
            affine_insert_bucket(new_point, ibucket,
                                 pecxdat, negate_flag, PBIGCTX_PASS);
        }
        pecxdat->OK = pecxdat->OK && OK;
    } // for jslot
} // end ec_concurrent_operations
/* --------------------------------------------------------- */
static DWORDREG WINAPI get_ec_concurrent_slot
       (ecexpon_data_t *pecxdat,
       PBIGCTX_ARG)
{
    while (pecxdat->OK && pecxdat->slots_in_use == MAX_SLOT) {
        ec_concurrent_operations(pecxdat, PBIGCTX_PASS);
    }
    if (pecxdat->OK) {
        DWORDREGC islot = pecxdat->slots_in_use;
        pecxdat->slots_in_use++;
        return islot;
    } else {
        return 0;
    }
} // end get_ec_concurrent_slot
// --------------------------------------------------------------------
static void WINAPI proj5_insert_bucket
        (ecproj5_tc      *EC_point,
         bucket_num_tc    ibucket,
         ecexpon_data_t  *pecxdat,
         const int        negate_flag,
         PBIGCTX_ARG)
/*
    Insert the projective point EC_point into
    bucket jbucket, possibly negating it.
*/
{
    ecurve_tc     *ecurve = pecxdat->ecurve;
    field_desc_tc *fdesc  = ecurve->fdesc;
    DWORDREGC      elng   = fdesc->elng;
    digit_tc      *pz     = EC_point + 2*elng;

    if (!pecxdat->OK) {
        // Return if earlier error
    } else if (Kiszero(pz, fdesc, PBIGCTX_PASS)) {
                                       // Check for point at infinity
    } else if (ibucket == BUCKET_ZERO) {
                                       // Skip bucket zero
    } else if (Kequal(pz, fdesc->one, fdesc, PBIGCTX_PASS)) {
        affine_insert_bucket(EC_point, ibucket, pecxdat,
                             negate_flag, PBIGCTX_PASS);
                          // N.B. -- x and y occur first in EC_point,
                          // so we can treat it as affine if z == 1.
    } else {
        DWORDREGC islot = get_ec_concurrent_slot(pecxdat, PBIGCTX_PASS);

        pecxdat->pending_op[islot].operation = ECOP_AFFINIZATION;
        pecxdat->pending_op[islot].output_bucket = ibucket;
        pecxdat->pending_op[islot].negate_flag = negate_flag;
        pecxdat->bucket[ibucket].anticipating++;
        pecxdat->OK = pecxdat->OK
           && Kcopy_many(EC_point, pecxdat->pending_op[islot].inputs,
           3, fdesc, PBIGCTX_PASS);
                              // Copy x, y, z
    }
} // end proj5_insert_bucket
// ----------------------------------------------------------------------
static BOOL WINAPI ecaffine_to_ecproj5
        (ecaffine_tc      *p1,
         ecproj5_t        *p2,
         ecurve_tc        *ecurve,
         ecproj5_temps_t   p5temps,
         PBIGCTX_ARG)
// Convert p1 from affine to projective form, result in p2.
{
    field_desc_tc *fdesc  = ecurve->fdesc;
    DWORDREGC      elng   = fdesc->elng;
    BOOL OK = TRUE;

    if (ecaffine_is_infinite(p1, ecurve, PBIGCTX_PASS)) {
        OK = OK && ecproj5_set_infinite(p2, ecurve, p5temps, PBIGCTX_PASS);
    } else {
        OK = OK && Kcopy_many(p1, p2, 2, fdesc, PBIGCTX_PASS)
                && Kcopy(fdesc->one, p2 + 2*elng, fdesc, PBIGCTX_PASS)
                && Kclear_many(p2 + 3*elng, 2, fdesc, PBIGCTX_PASS);
    }
    return OK;
} // end ecaffine_to_ecproj5
// ----------------------------------------------------------------------
static BOOL WINAPI ecproj5_add_ecaffine
        (ecproj5_tc      *p1,
         ecaffine_tc     *p2,
         ecproj5_t       *psum,
         ecurve_tc       *ecurve,
         ecproj5_temps_t  p5temps,
         PBIGCTX_ARG)
// Add p1 + p2, where p1 is projective and p2 is affine.
// Result (psum) is projective.
{
    DWORDREGC elng  = ecurve->fdesc->elng;
    BOOL OK = TRUE;
// CAUTION -- temp_point must not overlap storage in
//            procedures called by this function.
    ecproj5_t *temp_point = p5temps + 5*elng;
#if ECPROJ5_TEMPS_COUNT < 10
#error "ecproj5_add_ecaffine -- Temps array too short"
#endif

    OK = OK && ecaffine_to_ecproj5(p2, temp_point, ecurve,
                                   p5temps, PBIGCTX_PASS)
            && ecproj5_add_ecproj5(p1, temp_point, psum, ecurve,
                                   p5temps, PBIGCTX_PASS);
    return OK;
} // end ecproj5_add_ecaffine
//-----------------------------------------------------------------------

static BOOL WINAPI ecproj5_add_ecproj5
        (ecproj5_tc      *p1,
         ecproj5_tc      *p2,
         ecproj5_t       *psum,
         ecurve_tc       *ecurve,
         ecproj5_temps_t  p5temps,
         PBIGCTX_ARG)
//  Add p1 + p2 where both are projective.  Sum goes into psum.
//  psum may overlap p1 or p2
{
    field_desc_tc *fdesc = ecurve->fdesc;
    DWORDREGC       elng  = fdesc->elng;
    digit_tc *p1x = p1;
    digit_tc *p1y = p1 +   elng;
    digit_tc *p1z = p1 + 2*elng;
    digit_tc *p2x = p2;
    digit_tc *p2y = p2 +   elng;
    digit_tc *p2z = p2 + 2*elng;
    const BOOL char2 = CHARACTERISTIC_2(fdesc);

    BOOL OK = TRUE;
    digit_t  *p3x = psum;
    digit_t  *p3y = psum + elng;
    digit_t  *p3z = psum + 2*elng;
    digit_t  *ftemps = p5temps + elng*ECPROJ5_TEMPS_COUNT;

#if PRINT_ERROR_MESSAGES && EC_EXPENSIVE_DEBUGGING
    OK = OK && ecproj5_on_curve(p1, ecurve,
                                "ecproj5_add_proj5 first point",
                                p5temps, PBIGCTX_PASS);
    OK = OK && ecproj5_on_curve(p2, ecurve,
                                "ecproj5_add_proj5 second point",
                                p5temps, PBIGCTX_PASS);
#endif


    if (Kiszero(p1z, fdesc, PBIGCTX_PASS)) {
        OK = ecproj5_copy(p2, psum, ecurve, p5temps, PBIGCTX_PASS);
    } else if (Kiszero(p2z, fdesc, PBIGCTX_PASS)) {
        OK = ecproj5_copy(p1, psum, ecurve, p5temps, PBIGCTX_PASS);
    } else {
        const BOOL p1affine = Kequal(p1z, fdesc->one, fdesc, PBIGCTX_PASS);
        const BOOL p2affine = Kequal(p2z, fdesc->one, fdesc, PBIGCTX_PASS);

        digit_t *T0 = p5temps;
        digit_t *U1 = p5temps + elng;
        digit_t *U2 = p5temps + 2*elng;
        digit_t *S1 = p5temps + 3*elng;
        digit_t *S2 = p5temps + 4*elng;
    // CAUTION -- ecproj5_add_ecaffine assumes nothing
    // beyond here is modified until x, y inputs have been read.
        digit_t *W  = p5temps + 5*elng;
        digit_t *R  = p5temps + 6*elng;

        if (p1affine) {
            OK = OK && Kcopy(p2x, U2, fdesc, PBIGCTX_PASS)
                    && Kcopy(p2y, S2, fdesc, PBIGCTX_PASS);
        } else {
            OK = OK && Kmul(p1z, p1z, T0, fdesc,
                            ftemps, PBIGCTX_PASS)  // z1^2
                    && Kmul(p2x, T0, U2, fdesc,
                            ftemps, PBIGCTX_PASS)   // U2 = x2 * z1^2
                    && Kmul(p1z, T0, T0, fdesc,
                            ftemps, PBIGCTX_PASS)   // z1^3
                    && Kmul(p2y, T0, S2, fdesc,
                            ftemps, PBIGCTX_PASS);  // S2 = y2 * z1^3
        }
        if (p2affine) {
            OK = OK && Kcopy(p1x, U1, fdesc, PBIGCTX_PASS)
                    && Kcopy(p1y, S1, fdesc, PBIGCTX_PASS);
        } else {
            OK = OK && Kmul(p2z, p2z, T0, fdesc,
                            ftemps, PBIGCTX_PASS)   // z2^2
                    && Kmul(p1x, T0, U1, fdesc,
                            ftemps, PBIGCTX_PASS)    // U1 = x1 * z2^2
                    && Kmul(p2z, T0, T0, fdesc,
                            ftemps, PBIGCTX_PASS)    // z2^3
                    && Kmul(p1y, T0, S1, fdesc,
                            ftemps, PBIGCTX_PASS);   // S1 = t1 * z2^2
        }
        if (Kequal(U1, U2, fdesc, PBIGCTX_PASS)) {
            if (Kequal(S1, S2, fdesc, PBIGCTX_PASS)) {
                OK = OK && ecproj5_doubling(p2, psum, ecurve,
                                            p5temps, PBIGCTX_PASS);
            } else {
                OK = OK && ecproj5_set_infinite(psum, ecurve,
                                                p5temps, PBIGCTX_PASS);
            }
        } else {
            OK = OK && Ksub(U1, U2, W, fdesc, PBIGCTX_PASS)
                    && Ksub(S1, S2, R, fdesc, PBIGCTX_PASS);

            if (p1affine) {
                OK = OK && Kcopy(W, T0, fdesc, PBIGCTX_PASS);
            } else {
                OK = OK && Kmul(W, p1z, T0, fdesc, ftemps, PBIGCTX_PASS);
            }
            if (p2affine) {
                OK = OK && Kcopy(T0, p3z, fdesc, PBIGCTX_PASS);
            } else {
                OK = OK && Kmul(T0, p2z, p3z, fdesc, ftemps, PBIGCTX_PASS);
            }                              // z3 = W * z1 * z2 (nonzero)

            OK = OK && Kmul(W, W, T0, fdesc, ftemps, PBIGCTX_PASS)
                && Kmul(U1, T0, U1, fdesc,
                        ftemps, PBIGCTX_PASS)    // T1 = U1 * W^2
                    && Kmul(U2, T0, U2, fdesc,
                        ftemps, PBIGCTX_PASS);   // T2 = U2 * W^2
            OK = OK && Kadd(U1, U2, T0, fdesc,
                        PBIGCTX_PASS);   // T1 + T2 */

            if (char2) {
                OK = OK && Kmul(S2, U1, U1, fdesc,
                                ftemps, PBIGCTX_PASS)     // S2 * T1
                        && Kmul(S1, U2, U2, fdesc,
                                ftemps, PBIGCTX_PASS)     // S1 * T2
                        && Ksub(U2, U1, U2,
                                fdesc, PBIGCTX_PASS)          // S1*T2 - S2*T1
                        && Kmul(p3z, p3z, p3x, fdesc,
                                ftemps, PBIGCTX_PASS)  // z3^2
                        && Kmul(ecurve->a, p3x, p3x, fdesc,
                                ftemps, PBIGCTX_PASS) // a*z3^2
                        && Kadd(p3x, T0, p3x, fdesc,
                                PBIGCTX_PASS)  // a*z3^2 + T1 + T2
                        && Kadd(R, p3z, T0, fdesc,
                                PBIGCTX_PASS)    // T3 = R + z3
                        && Kmul(T0, R, R, fdesc, ftemps,
                                PBIGCTX_PASS)      // R*(R + z3)
                        && Ksub(R, p3x, p3x, fdesc,
                                PBIGCTX_PASS)   // New x3
                        && Kmul(T0, p3x, T0, fdesc, ftemps,
                                PBIGCTX_PASS)   // T3*x3
                        && Ksub(U2, T0, p3y, fdesc,
                                PBIGCTX_PASS);  // New y3
            } else {
                OK = OK && Kmul(R, R, p3x, fdesc,
                                ftemps, PBIGCTX_PASS)
                        && Ksub(p3x, T0, p3x, fdesc,
                                PBIGCTX_PASS)          // x3 = R^2 - T1 - T2
                        && Ksub(U2, U1, U2, fdesc,
                                PBIGCTX_PASS)            // T2 - T1
                        && Kmul(S1, U2, U2, fdesc,
                                ftemps, PBIGCTX_PASS)    // S1*(T2 - t1)
                        && Ksub(p3x, U1, T0, fdesc,
                                PBIGCTX_PASS)           // x3 - T1
                        && Kmul(T0, R, T0, fdesc,
                                ftemps, PBIGCTX_PASS)     // R*(x3 - T1)
                        && Ksub(U2, T0, p3y, fdesc,
                                PBIGCTX_PASS);          // New y3
            } // end if characteristic
        } // end if doubling or infinite sum
#if PRINT_ERROR_MESSAGES && EC_EXPENSIVE_DEBUGGING
        OK = OK && ecproj5_on_curve(psum, ecurve,
                                    "ecproj5_add_ecproj5 sum",
                                    p5temps, PBIGCTX_PASS);
#endif
    } // end if input point infinite
    return OK;
} // end ecproj5_add_ecproj5
// ----------------------------------------------------------------------
static BOOL WINAPI ecproj5_doubling
        (ecproj5_tc       *p1,
         ecproj5_t        *p2,
         ecurve_tc        *ecurve,
         ecproj5_temps_t   p5temps,
         PBIGCTX_ARG)
// Double a projective point on an elliptic curve.
// Return p2 = 2*p1.  p1 and p2 may overlap
{
    field_desc_tc *fdesc = ecurve->fdesc;
    DWORDREGC      elng  = fdesc->elng;
    BOOL OK = TRUE;
    digit_tc *p1x = p1;
    digit_tc *p1y = p1 +   elng;
    digit_tc *p1z = p1 + 2*elng;
    digit_t  *p2x = p2;
    digit_t  *p2y = p2 +   elng;
    digit_t  *p2z = p2 + 2*elng;
    digit_t  *ftemps = p5temps + ECPROJ5_TEMPS_COUNT*elng;

#if PRINT_ERROR_MESSAGES && EC_EXPENSIVE_DEBUGGING
    OK = OK && ecproj5_on_curve(p1, ecurve, "ecproj5_doubling input",
                                p5temps, PBIGCTX_PASS);
#endif
    if (!OK) {
    } else if (Kiszero(p1z, fdesc, PBIGCTX_PASS)) {
        OK = OK && ecproj5_set_infinite(p2, ecurve,
                                        p5temps, PBIGCTX_PASS);
    } else if (CHARACTERISTIC_2(fdesc)) {
        digit_t *xsq   = p5temps;
        digit_t *zsq   = p5temps + elng;
        digit_t *bz8   = p5temps + 2*elng;
        digit_t *temp1 = p5temps + 3*elng;

        OK = OK && Kmul(p1x, p1x, xsq, fdesc,
                        ftemps, PBIGCTX_PASS)
                && Kmul(p1z, p1z, zsq, fdesc,
                        ftemps, PBIGCTX_PASS)
                && Kmul(zsq, zsq, bz8, fdesc,
                        ftemps, PBIGCTX_PASS)        // Z^4
                && Kmul(bz8, bz8, bz8, fdesc,
                        ftemps, PBIGCTX_PASS)        // Z^8
                && Kmul(ecurve->b, bz8, bz8, fdesc,
                        ftemps, PBIGCTX_PASS)  // b * Z^8
                && Kmul(p1y, p1z, temp1, fdesc,
                        ftemps, PBIGCTX_PASS)
                && Kadd(xsq, temp1, temp1, fdesc,
                        PBIGCTX_PASS)            // X^2 + Y*Z
                && Kmul(p1x, zsq, p2z, fdesc, ftemps,
                        PBIGCTX_PASS)        // Z2 = X * Z^2
                && Kmul(xsq, xsq, xsq, fdesc, ftemps,
                        PBIGCTX_PASS)        // X^4
                && Kadd(xsq, bz8, p2x, fdesc,
                        PBIGCTX_PASS)                // X2 = X^4 + bZ^8
                && Kmul(bz8, p2z, bz8, fdesc, ftemps,
                        PBIGCTX_PASS)        // (b Z^8) * Z2
                && Kmul(temp1, p2x, temp1, fdesc, ftemps,
                        PBIGCTX_PASS)    // (X^2 + Y*Z)*X2
                && Kadd(bz8, temp1, p2y, fdesc,
                        PBIGCTX_PASS);             // Y2
    } else {
        // TBD -- check fourth and fifth components of vector
        digit_t *xsq  = p5temps;
        digit_t *S    = p5temps + elng;
        digit_t *az4  = p5temps + 2*elng;
        digit_t *M    = p5temps + 3*elng;
        digit_t *y4th = p5temps + 4*elng;

        OK = OK && Kmul(p1x, p1x, xsq, fdesc,
                        ftemps, PBIGCTX_PASS)     //
                && Kadd(xsq, xsq, M, fdesc,
                        PBIGCTX_PASS)
                && Kadd(xsq, M, M, fdesc,
                        PBIGCTX_PASS)                 // 3 * X^2
                && Kmul(p1z, p1z, az4, fdesc,
                        ftemps, PBIGCTX_PASS)     // Z^2
                && Kmul(az4, az4, az4, fdesc,
                        ftemps, PBIGCTX_PASS)     // Z^4
                && Kmul(ecurve->a, az4, az4, fdesc,
                        ftemps, PBIGCTX_PASS)  // a*Z^4
                && Kadd(M, az4, M, fdesc,
                        PBIGCTX_PASS)                 // M = 3 X^2 + a Z^4
                && Kadd(p1y, p1y, y4th, fdesc,
                        PBIGCTX_PASS)            // 2*Y
                && Kmul(y4th, p1z, p2z, fdesc,
                        ftemps, PBIGCTX_PASS)    // Z2 = (2*Y)*Z
                && Kmul(y4th, y4th, y4th, fdesc,
                        ftemps, PBIGCTX_PASS)  // 4 * Y^2
                && Kmul(p1x, y4th, S, fdesc,
                        ftemps, PBIGCTX_PASS)      // S = 4 * X * Y^2
                && Kmul(y4th, y4th, y4th, fdesc,
                        ftemps, PBIGCTX_PASS)  // 16*Y^4
                && Kmul(M, M, p2x, fdesc,
                        ftemps, PBIGCTX_PASS)
                && Ksub(p2x, S, p2x, fdesc,
                        PBIGCTX_PASS)
                && Ksub(p2x, S, p2x, fdesc,
                        PBIGCTX_PASS)               // X2 = M^2 - 2*S
                && Ksub(S, p2x, S, fdesc,
                        PBIGCTX_PASS)
                && Kmul(M, S, p2y, fdesc,
                        ftemps, PBIGCTX_PASS)         // M*(S - X2)
                && Kmulpower2(y4th, -1, y4th, fdesc,
                       PBIGCTX_PASS)      // 8*Y^4
                && Ksub(p2y, y4th, p2y, fdesc,
                        PBIGCTX_PASS);       // Y2 = M*(S - X2) - 8 Y^4
    }
#if PRINT_ERROR_MESSAGES && EC_EXPENSIVE_DEBUGGING
    OK = OK && ecproj5_on_curve(p2, ecurve,
                                "ecproj5_doubling output",
                                p5temps, PBIGCTX_PASS);
#endif
    return OK;
} // end ecproj5_doubling
// ----------------------------------------------------------------------
static BOOL WINAPI ecproj5_on_curve
        (ecproj5_tc      *p1,
         ecurve_tc       *ecurve,
         const char      *pdebug_info,
         ecproj5_temps_t  p5temps,
         PBIGCTX_ARG)
// Test whether a projective point is on the curve.
//
//       GF(2^m) -- Is Y^2 + XYZ == X^3 + a X^2 Z^2 + b Z^6 ?
//
//
//       GF(q) --   Is Y^2       == X^3 + a X Z^4   + b Z^6 ?



{
    field_desc_tc *fdesc = ecurve->fdesc;
    DWORDREGC      elng  = fdesc->elng;
    BOOL OK = TRUE;
    const BOOL char2 = CHARACTERISTIC_2(fdesc);
    digit_tc *p1x = p1;
    digit_tc *p1y = p1 +   elng;
    digit_tc *p1z = p1 + 2*elng;
// Avoid using over five temporaries.
// to prevent conflict with ecproj5_add_ecaffine.
    digit_t *temp1 = p5temps;
    digit_t *zsq   = p5temps + elng;
    digit_t *xsq   = p5temps + 2*elng;
    digit_t *ysq   = p5temps + 3*elng;
    digit_t *z4th  = p5temps + 4*elng;
    digit_t *ftemps = p5temps + ECPROJ5_TEMPS_COUNT*elng;

    if (    Kiszero(p1x, fdesc, PBIGCTX_PASS)
         && Kiszero(p1y, fdesc, PBIGCTX_PASS)
         && Kiszero(p1z, fdesc, PBIGCTX_PASS)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_ZERO_OPERAND,
                        "ecproj5_on_curve", PBIGCTX_PASS);
    }
    OK = OK && Kmul(p1x, p1x, xsq, fdesc,
                    ftemps, PBIGCTX_PASS)          // X^2
            && Kmul(p1y, p1y, ysq, fdesc,
                    ftemps, PBIGCTX_PASS)
            && Kmul(p1z, p1z, zsq, fdesc,
                    ftemps, PBIGCTX_PASS)
            && Kmul(zsq, zsq, z4th, fdesc,
                    ftemps, PBIGCTX_PASS)         // Z^4
            && Kmul(p1x, xsq, temp1, fdesc,
                    ftemps, PBIGCTX_PASS)
            && Ksub(ysq, temp1, ysq, fdesc,
                    PBIGCTX_PASS)                // Y^2 - X^3
            && Kmul(ecurve->b, zsq, zsq, fdesc,
                    ftemps, PBIGCTX_PASS);   // b*Z^2

    if (char2) {
        OK = OK && Kmul(zsq, z4th, temp1, fdesc,
                        ftemps, PBIGCTX_PASS)   // b*Z^6
                && Ksub(ysq, temp1, ysq, fdesc,
                        PBIGCTX_PASS)            // Y^2 - X^3 - bZ^6
                && Kmul(p1x, p1z, temp1, fdesc,
                        ftemps, PBIGCTX_PASS)    // X*Z
                && Kmul(ecurve->a, temp1, zsq, fdesc,
                        ftemps, PBIGCTX_PASS)
                && Ksub(zsq, p1y, zsq, fdesc,
                        PBIGCTX_PASS)              // a*X*Z - Y
                && Kmul(temp1, zsq, temp1, fdesc,
                        ftemps, PBIGCTX_PASS); // X*Z*(a*X*Z - Y)
    } else {
        OK = OK && Kmul(ecurve->a, p1x, temp1, fdesc,
                        ftemps, PBIGCTX_PASS)
                && Kadd(temp1, zsq, temp1, fdesc,
                        PBIGCTX_PASS)           // a*X + b*Z^2
                && Kmul(temp1, z4th, temp1, fdesc,
                        ftemps, PBIGCTX_PASS); // (a*X + b*Z^2)*Z^4
    }
    if (OK) {
        const BOOL on_curve = Kequal(ysq, temp1, fdesc, PBIGCTX_PASS);
        if (!on_curve) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_NOT_ON_CURVE,
                            pdebug_info,
                            PBIGCTX_PASS);
        }
    }
    return OK;
} // end ecproj5_on_curve
// --------------------------------------------------------------------
static BOOL WINAPI ecproj5_set_infinite
        (ecproj5_t       *p1,
         ecurve_tc       *ecurve,
         ecproj5_temps_t  p5temps,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    field_desc_tc *fdesc = ecurve->fdesc;
    DWORDREGC elng = fdesc->elng;

    (void)p5temps;   // Reference argument to avoid warning

    OK = OK && Kcopy(fdesc->one, p1, fdesc, PBIGCTX_PASS)
            && Kcopy(fdesc->one, p1 + elng, fdesc, PBIGCTX_PASS)
            && Kclear_many(p1 + 2*elng, 3, fdesc, PBIGCTX_PASS);
    return OK;
} // end ecproj5_set_infinite
// ---------------------------------------------------------------------
static BOOL WINAPI ecproj5_to_ecaffine
        (ecproj5_tc       *p1,
         ecaffine_t       *p2,
         ecurve_tc        *ecurve,
         ecproj5_temps_t   p5temps,
         PBIGCTX_ARG)
// Convert p1 from projective to affine form, result in p2.
// If p1 = (x, y, z, *, *), return (x/z^2, y/z^3)
{
    BOOL OK = TRUE;
    field_desc_tc *fdesc = ecurve->fdesc;
    DWORDREGC elng = fdesc->elng;
    digit_tc *p1z = p1 + 2*elng;
    digit_t *ftemps = p5temps + elng*ECPROJ5_TEMPS_COUNT;

    if (Kiszero(p1z, fdesc, PBIGCTX_PASS)) {
        OK = OK && ecaffine_set_infinite(p2, ecurve, PBIGCTX_PASS);
    } else {
        digit_t *z1inv = p5temps;
        digit_t *z1invsq = p5temps + elng;

        OK = OK && Kinvert(p1z, z1inv, fdesc,
                        ftemps, PBIGCTX_PASS)
                && Kmul(z1inv, z1inv, z1invsq, fdesc,
                        ftemps, PBIGCTX_PASS)
                && Kmul(p1, z1invsq, p2, fdesc,
                        ftemps, PBIGCTX_PASS)       // x2 = X/Z^2
                && Kmul(z1inv, z1invsq, z1invsq, fdesc,
                        ftemps, PBIGCTX_PASS)  // 1/Z^3
                && Kmul(p1 + elng, z1invsq, p2 + elng, fdesc,
                        ftemps, PBIGCTX_PASS);      // y2 = Y/Z^3
    }
    return OK;
} // end ecproj5_to_ecaffine
/* ------------------------------------------------------------ */
static void WINAPI schedule_affine_add_and_sub(
                      ecaffine_tc     *point1,
                      ecaffine_tc     *point2,
                      bucket_num_tc    out1,
                      bucket_num_tc    out2,
                      ecexpon_data_t  *pecxdat,
                      PBIGCTX_ARG)
/*
          Insert point1 + point2 in bucket out1
          and    point1 - point2 in bucket out2.

          We are replacing

                (out1 + out2)*point1 + (out1 - out2)*point2
          by
                out1*(point1 + point2) + out2*(point1 - point2)

          Buckets out1 +- out2 will acquire no more entries
          during this exponentiation.  We send the data elsewhere
          (i.e., to out1, out2) as we funnel everything into
          fewer buckets, until we do final processing.
*/
{
    ecurve_tc *ecurve = pecxdat->ecurve;
    if (!pecxdat->OK) {
    } else if (    out1 <= 0
                || out2 <= 0
                || out1 > pecxdat->bucket_max
                || out2 > pecxdat->bucket_max
                || pecxdat->bucket[out1].anticipating <= 0
                || pecxdat->bucket[out2].anticipating <= 0) {
        pecxdat->OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "schedule_affine_add_and_sub 1", PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
        if (mp_errfil != NULL) {
            fprintf(mp_errfil, "schedule_affine_add_and_sub --"
                " Bad output buckets = %ld %ld\n",
                   (long)out1, (long)out2);
        }
#endif
    } else {
        pecxdat->bucket[out1].anticipating--;
                  // Cancel transfers to out1 and out2 scheduled
                  // when pending_addsubs table was created.
                  // They will be rescheduled below if still needed.
        pecxdat->bucket[out2].anticipating--;

        if (   !ecaffine_is_infinite(point1, ecurve, PBIGCTX_PASS)
            && !ecaffine_is_infinite(point2, ecurve, PBIGCTX_PASS) ) {
            if (pecxdat->slots_in_use > MAX_SLOT - 2) {
                ec_concurrent_operations(pecxdat, PBIGCTX_PASS);
                   /* Try to schedule addition and subtraction
                      in adjacent slots, since both need
                      to invert x(point1) - x(point2).
                    */
            }
        }

        schedule_affine_add_or_sub(point1, point2, out1,
                                   pecxdat, +1, PBIGCTX_PASS);
        schedule_affine_add_or_sub(point1, point2, out2,
                                   pecxdat, -1, PBIGCTX_PASS);
    }
} // end schedule_affine_add_and_sub
/* ------------------------------------------------------------ */
static void WINAPI schedule_affine_add_or_sub
        (ecaffine_tc    *point1,
         ecaffine_tc    *point2,
         bucket_num_tc   jbucket,
         ecexpon_data_t *pecxdat,
         const int       negate_second,
         PBIGCTX_ARG)
//
//       If negate_second = +1, add affine points point1 and point2.
//       If negate_second = -1, subtract point1 - point2.
//       In either case send the result to bucket jbucket.
//

{
    ecurve_tc *ecurve = pecxdat->ecurve;
    DWORDREGC elng = ecurve->fdesc->elng;
    BOOL OK = pecxdat->OK;
    digit_t *ectemps = pecxdat->p5temps + ECPROJ5_TEMPS_COUNT*elng;

    if (!OK) {
    } else if (jbucket < 0 || jbucket > pecxdat->bucket_max) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "schedule_affine_add_or_sub", PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
        if (mp_errfil != NULL) {
            fprintf(mp_errfil, "schedule_affine_add_or_sub, jbucket = %ld\n",
                         (long)jbucket);
        }
#endif
    }

    (void)ectemps;  // Avoid warning for unused variable
#if EC_EXPENSIVE_DEBUGGING
    OK = OK && ecaffine_on_curve(point1, ecurve,
                                 "schedule_affine point1",
                                 ectemps, PBIGCTX_PASS);
    OK = OK && ecaffine_on_curve(point1, ecurve,
                                 "schedule_affine point2",
                                 ectemps, PBIGCTX_PASS);
#endif
    if (!OK) {
    }else if (ecaffine_is_infinite(point1, ecurve, PBIGCTX_PASS)) {
        affine_insert_bucket(point2, jbucket, pecxdat,
                             negate_second, PBIGCTX_PASS);
    } else if (ecaffine_is_infinite(point2, ecurve, PBIGCTX_PASS)) {
        affine_insert_bucket(point1, jbucket, pecxdat,
                             +1, PBIGCTX_PASS);
    } else {
        DWORDREG islot = get_ec_concurrent_slot(pecxdat, PBIGCTX_PASS);
        digit_t *inputs = pecxdat->pending_op[islot].inputs;
        OK = OK && ecaffine_copy(point1, inputs, ecurve, PBIGCTX_PASS);
        OK = OK && ecaffine_multiply_pm1(point2,
            inputs + 2*elng, negate_second, ecurve, PBIGCTX_PASS);
        pecxdat->pending_op[islot].negate_flag = +1;
        pecxdat->pending_op[islot].operation = ECOP_ADD;
        pecxdat->pending_op[islot].output_bucket = jbucket;
        pecxdat->bucket[jbucket].anticipating++;
    }
    pecxdat->OK = pecxdat->OK && OK;
} // end schedule_affine_add_or_sub
/* ------------------------------------------------------------ */
/*
       The routines declared static cannot be called directly
       from mptest.c.  Instead we test some mathematical
       ones here.  mptest tests the major ones separately.

       The next routine is not present when the system
       library is built.
*/
#if PRINT_ERROR_MESSAGES
#include "mprand.h"

BOOL WINAPI ecproj5_test(ecurve_tc *E, PBIGCTX_ARG)
{
    digit_t j;
    DWORDREGC elng = E->fdesc->elng;
    digit_t *a1, *a2, *a3, *a4, *a5, *a6, *a7, *a8;  // Each length 2*elng
    digit_t *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8;  // Each length 5*elng
    digit_t *etemps;
    BYTE bytes[3];
    BOOL OK = TRUE;
    DWORDREGC numdtemps = 56*elng + E->ndigtemps;
    digit_t *dtemps = digit_allocate(numdtemps, "ecproj5_test 1", PBIGCTX_PASS);
    /* ecproj5_temps_t */ digit_t* temps5
          = digit_allocate(elng*ECPROJ5_TEMPS_COUNT + E->ndigtemps,
                           "ecproj5_test 2", PBIGCTX_PASS);

    if (dtemps == digit_NULL || temps5 == digit_NULL) {
        OK = FALSE;
        goto clean_up;
    }
    a1 = dtemps;
    a2 = a1 + 2*elng;
    a3 = a2 + 2*elng;
    a4 = a3 + 2*elng;
    a5 = a4 + 2*elng;
    a6 = a5 + 2*elng;
    a7 = a6 + 2*elng;
    a8 = a7 + 2*elng;
    p1 = a8 + 2*elng;
    p2 = p1 + 5*elng;
    p3 = p2 + 5*elng;
    p4 = p3 + 5*elng;
    p5 = p4 + 5*elng;
    p6 = p5 + 5*elng;
    p7 = p6 + 5*elng;
    p8 = p7 + 5*elng;
    etemps = p8 + 5*elng;
    if (dtemps + numdtemps != etemps + E->ndigtemps) {
        fprintf(mp_errfil, "ecproj5_test, error allocating dtemps\n");
        OK = FALSE;
        goto clean_up;
    }

    random_bytes(bytes, 3, PBIGCTX_PASS);
    OK = OK && ecaffine_random(a1, E, etemps, PBIGCTX_PASS);
    OK = OK && ecaffine_random(a2, E, etemps, PBIGCTX_PASS);
    OK = OK && ecaffine_random(a3, E, etemps, PBIGCTX_PASS);

    if (bytes[0] < 30) {
        OK = OK && ecaffine_set_infinite(a1, E, PBIGCTX_PASS);
    }

    if (bytes[1] < 30) {
        OK = OK && ecaffine_set_infinite(a2, E, PBIGCTX_PASS);
    } else if (bytes[1] < 50) {
        OK = OK && ecaffine_copy(a1, a2, E, PBIGCTX_PASS);
    }

    if (bytes[2] < 30) {
        OK = OK && ecaffine_set_infinite(a3, E, PBIGCTX_PASS);
    }

    OK = OK && ecaffine_on_curve(a1, E, "a1", etemps, PBIGCTX_PASS);
    OK = OK && ecaffine_on_curve(a2, E, "a2", etemps, PBIGCTX_PASS);
    OK = OK && ecaffine_on_curve(a3, E, "a3", etemps, PBIGCTX_PASS);
    if (!OK) {
        fprintf(mp_errfil, "ecaffine point not on curve\n");
        goto clean_up;
    }
    OK = OK && ecaffine_to_ecproj5(a1, p1, E, temps5, PBIGCTX_PASS);
    OK = OK && ecaffine_to_ecproj5(a2, p2, E, temps5, PBIGCTX_PASS);
    OK = OK && ecaffine_to_ecproj5(a3, p3, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_on_curve(p1, E, "ecproj5_test p1", temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_on_curve(p2, E, "ecproj5_test p2", temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_on_curve(p3, E, "ecproj5_test p3", temps5, PBIGCTX_PASS);
    if (!OK) {
        fprintf(mp_errfil,
               "ecaffine_to_ecproj5 output not on curve\n");
        goto clean_up;
    }

    OK = OK && ecproj5_to_ecaffine(p1, a4, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_to_ecaffine(p2, a5, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_to_ecaffine(p3, a6, E, temps5, PBIGCTX_PASS);
    OK = OK && ecaffine_equal(a1, a4, E, PBIGCTX_PASS);
    OK = OK && ecaffine_equal(a2, a5, E, PBIGCTX_PASS);
    OK = OK && ecaffine_equal(a3, a6, E, PBIGCTX_PASS);
    if (!OK) {
        fprintf(mp_errfil, "affine/proj5 conversions inconsistent\n");
        goto clean_up;
    }
    OK = OK && ecproj5_add_ecproj5(p1, p2, p4, E, temps5, PBIGCTX_PASS);
    OK = OK && ecaffine_addition(a1, a2, a5, +1, E, etemps, PBIGCTX_PASS);
    OK = OK && ecproj5_to_ecaffine(p4, a4, E, temps5, PBIGCTX_PASS);
    OK = OK && ecaffine_equal(a4, a5, E, PBIGCTX_PASS);
    if (!OK) {
        fprintf(mp_errfil, "ecproj5_add_ecproj5 and ecaffine_add differ\n");
        goto clean_up;
    }
    OK = OK && ecproj5_add_ecproj5(p4, p3, p5, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_add_ecproj5(p3, p2, p4, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_add_ecproj5(p4, p1, p6, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_to_ecaffine(p5, a5, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_to_ecaffine(p6, a6, E, temps5, PBIGCTX_PASS);
    OK = OK && ecaffine_equal(a5, a6, E, PBIGCTX_PASS);
    if (!OK) {
        fprintf(mp_errfil, "ecproj5_add_ecproj5 not associative\n");
        goto clean_up;
    }
    OK = OK && ecproj5_add_ecaffine(p4, a1, p5, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_to_ecaffine(p5, a5, E, temps5, PBIGCTX_PASS);
    OK = OK && ecaffine_equal(a5, a6, E, PBIGCTX_PASS);
    if (!OK) {
        fprintf(mp_errfil, "ecproj5_add_ecaffine failed\n");
        goto clean_up;
    }
    OK = OK && ecproj5_add_ecproj5(p5, p6, p7, E, temps5, PBIGCTX_PASS);
                             // N.B.  p5 and p6 are same point
    OK = OK && ecproj5_doubling(p5, p8, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_to_ecaffine(p7, a7, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_to_ecaffine(p8, a8, E, temps5, PBIGCTX_PASS);
    OK = OK && ecaffine_equal(a7, a8, E, PBIGCTX_PASS);
    if (!OK) {
        fprintf(mp_errfil, "ecproj5_doubling test 1 failed\n");
        goto clean_up;
    }
    OK = OK && ecproj5_add_ecaffine(p1, a2, p4, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_add_ecaffine(p4, a1, p5, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_doubling(p1, p6, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_add_ecaffine(p6, a2, p7, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_to_ecaffine(p5, a5, E, temps5, PBIGCTX_PASS);
    OK = OK && ecproj5_to_ecaffine(p7, a7, E, temps5, PBIGCTX_PASS);
    if (!OK) {
        fprintf(mp_errfil, "ecproj5_doubling/ecproj5_add_ecaffine"
                            " test failed\n");
        goto clean_up;
    }
    for (j = 0; OK && j <= 50; j++) {
        digit_t expon = j;

        if (j >= 30) OK = OK && random_digits(&expon, 1, PBIGCTX_PASS);
        OK = OK && ecaffine_exponentiation(a1, &expon, 1, p6, E, PBIGCTX_PASS);
        OK = OK && ecaffine_exponentiation_tabular(a1, 4, 0,
                         &expon, 1, p7, E, PBIGCTX_PASS);
        OK = OK && ecaffine_equal(p6, p7, E, PBIGCTX_PASS);
        if (!OK) {
            fprintf(mp_errfil, "exponentiations differ, j = %ld\n",
                       (long)j);
            goto clean_up;
        }
    } /* for j */
clean_up:
    if (dtemps != digit_NULL) {
        Free_Temporaries(dtemps, PBIGCTX_PASS);
    }
    if (temps5 != digit_NULL) {
        Free_Temporaries(temps5, PBIGCTX_PASS);
    }
    return OK;
} /* end ecproj5_test */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\ecpriv.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
     File ecpriv.h .

     This file has elliptic curve declarations which
     are visible to the bignum library but not to
     application programs.  Data types and constants
     herein can be altered with (theoretically)
     no impact on applications.

*/
#ifndef ECPRIV_H
#define ECPRIV_H 1

/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

#include "fieldpriv.h"
#include "ecurve.h"


#define EC_EXPENSIVE_DEBUGGING 0
          // 1  while testing code, 0 in production

#define MAX_ECTEMPS 5
          // Maximum number of field temporaries needed
          // by any EC addition/subtraction/doubling routine,
          // including

          //     ecaffine_addition,
          //     ecaffine_addition_subtraction
          //     ecaffine_line_through
          //     ecaffine_on_curve
          //     ecaffine_PPQ
          //     ecaffine_random

#define ecNIST_GFp       1
                           // Curves y^2 = x^3 + ax + b mod p,
                           // where p is an odd prime.
                           // Group order is a prime Gr.
                           // a = p - 3 for NIST curves.
#define ecNIST_GF2m      2
                           // y^2 + xy = x^3 + ax^2 + b over GF(2^m)
                           // Group order is 2*Gr where Gr is prime.
                           // a = 1 for NIST curves.
#define ecNIST_Koblitz2  3
                           // y^2 + x*y = x^3 + ax^2 + 1
                           // where a = 0 or 1.
                           // Group order is 2*Gr if a = 1
                           // and 4*Gr if a = 0.
/*
     ecNISTtype -- One of ecNIST_GFp, ecNIST_GF2n, ecNIST_Koblitz2.

     field_identification -- Pointer to gf2_predefined_tc
                 structure (for GF(2^m) polynomial basis)
                 or to TBD (for GF(p) fields).
     a        -- Pointer to a.
                 If this is NULL, assume a = 1 (ecNIST_GF2n curves)
                 or a = p - 3 (ecNIST_GFp curves).
                 For ecNIST_Koblitz2 curves, this is not used
     bKoblitz -- Pointer to b, or to Koblitz2_tc struct.
     (Gx, Gy) -- pointers to x and y coordinates of generator,
     Gr       -- pointer to order of generator (prime)

*/


typedef struct ec_NIST_t {
     BYTE         ecNISTtype;
     BYTE         dwords;
     const void  *field_identification;
     ec_exponentiation_t *fexpon;  // Special exponentiation routine
     DWORDC      *a;
     const void  *bKoblitz;
     DWORDC      *Gx;
     DWORDC      *Gy;
     DWORDC      *Gr;
} ec_NIST_t;

typedef const ec_NIST_t ec_NIST_tc;

typedef struct {
    BYTE         a;         // 0 or 1
} Koblitz2_t;

#define NIST_a_default 0
                          // Null pointer
typedef const Koblitz2_t Koblitz2_tc;

extern ec_exponentiation_t ec_Koblitz2_exponentiation;

// ecaffine_attributes2 inspects two points
// being added/subtracted.
// It sets the flags in the struct.

typedef struct {
    BOOL inf1;           // Set if first point infinite
    BOOL inf2;           // Set if second point infinite
    BOOL equal;          // Set if points are equal
    BOOL negatives;      // Set if points are negatives
} ecaffine_attributes2_t;


extern BOOL WINAPI ecaffine_attributes2(
            AFFINE_INPUT, AFFINE_INPUT,
            ecaffine_attributes2_t*,
            CURVE_INPUT, PBIGCTX_ARG);

#ifdef __cplusplus
}
#endif

#endif // ECPRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\ecurve.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "ecurve.h"
#include "ecpriv.h"

//           This file (ecurve.c) has routines for
//       elliptic curve arithmetic.  See ecurve.h for
//       background information.

#ifndef MAX_ECTEMPS
    #error -- MAX_ECTEMPS undefined
#endif

#ifndef EC_EXPENSIVE_DEBUGGING
    #error -- EC_EXPENSIVE_DEBUGGING undefined
#endif





//   An elliptic curve over GF(q) is all points (x, y) satisfying
//   y^2 = x^3 + ax + b mod p, plus a point at infinity.
//   The ecurve_t struct has a and b.

//   Points on an elliptic curve may be represented in affine
//   or projective form.  Affine form has simply x and y.
//   If b = 0, the point at infinity has x = 0 and y = 1.
//   If b <> 0, the point at infinity has x = 0 and y = 0.

//   Projective coordinates use a format suggested in
//   the February 6, 1997 IEEE P1363 Working Draft.
//   We represent (x, y) by (X, Y, Z) where x = X/Z^2 and y = Y/Z^2.
//   Then we need Y^2 = X^3 + aX Z^2 + bZ^4.
//   The point at infinity is (lambda^2, lambda^3, 0) where lambda != 0.


//   Over GF(2^m) we use the curves y^2 + x*y = x^3 + a*x^2 + b
//   where b <> 0.  The affine representation of the point at infinity
//   has x = y = 0.  The negative of a point (x, y) is (x, x+y).

BOOL WINAPI ecaffine_addition
        (ecaffine_tc *p1,
         ecaffine_tc *p2,
         ecaffine_t  *p3,     // OUT
         const int   addsub,
         ecurve_tc   *E,
         digit_t     *supplied_temps,
         PBIGCTX_ARG)

// Compute p3 = p1 + p2 on an elliptic curve (addsub = +1)
//      or p3 = p1 = p2 (addsub = -1)
// Any or all of p1, p2, p3 can overlap.
{
    BOOL simple_case = FALSE;
    BOOL OK = TRUE;
    field_desc_tc *fdesc = E->fdesc;
    const BOOL char2 = CHARACTERISTIC_2(fdesc);
    BOOL fFree = FALSE;
                      /* Is field characteristic 2? */
    DWORDREGC elng = fdesc->elng;
    digit_tc *x1 = p1, *y1 = p1 + elng;
    digit_tc *x2 = p2, *y2 = p2 + elng;
    digit_t  *x3 = p3, *y3 = p3 + elng;
    digit_t *t1 = NULL;    // Each length elng
    digit_t *t2 = NULL;
    digit_t *t3 = NULL;
    digit_t *ftemps = NULL;

    if (supplied_temps == digit_NULL) {
        Allocate_Temporaries_Multiple(3*elng+E->ndigtemps, digit_t, t1, PBIGCTX_PASS);
        if( t1 == NULL )
        {
            return FALSE;
        }
        fFree = TRUE;
        t2 = t1 + elng;
        t3 = t2 + elng;
        ftemps = t3 + elng;
    } 
    else 
    {
        t1 = supplied_temps;
        t2 = t1 + elng;
        t3 = t2 + elng;
        ftemps = t3 + elng;
    }
    
    if (   (fdesc->ftype != FIELD_Q_MP && !char2)
               || (addsub != 1 && addsub != -1) )
    {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "ecaffine_addition",
                        PBIGCTX_PASS);
    }

#if MAX_ECTEMPS < 3
#error -- Need more EC temporaries
#endif

    if (ecaffine_is_infinite(p2, E, PBIGCTX_PASS)) {
        OK = OK && ecaffine_copy(p1, p3, E, PBIGCTX_PASS);
        simple_case = TRUE;
    } else if (ecaffine_is_infinite(p1, E, PBIGCTX_PASS)) {
        if (addsub == +1) {
            OK = OK && ecaffine_copy(p2, p3, E, PBIGCTX_PASS);
        } else {
            OK = OK && ecaffine_negate(p2, p3, E, PBIGCTX_PASS);
        }
        simple_case = TRUE;
    } else {                  // t2 = y coordinate of -addsub * (x2, y2)
        if (addsub == -1) {
            OK = OK && Kcopy(y2, t2, fdesc, PBIGCTX_PASS);  // t2 = y2
        } else if (char2) {
            OK = OK && Kadd(x2, y2, t2, fdesc,
                            PBIGCTX_PASS);  // t2 = -y2 - x2
        } else {
            OK = OK && Knegate(y2, t2, fdesc,
                                PBIGCTX_PASS);   // t2 = -y2
        }                              // Plan to do (x1, y1) - (x2, t2)
        }
    if (simple_case || !OK) {
        // Done
    } else if (Kequal(x1, x2, fdesc, PBIGCTX_PASS)) {
        if (Kequal(y1, t2, fdesc, PBIGCTX_PASS)) {
                                                // Subtracting equal points
            OK = OK && ecaffine_set_infinite(p3, E, PBIGCTX_PASS);
            simple_case = TRUE;
        } else if (char2) {        // Doubling over GF(2^m)
            OK = OK && Kinvert(x1, t1, fdesc, ftemps,
                                PBIGCTX_PASS);  // t1 = 1/x
            OK = OK && Kmul2000(y1, t1, t1, fdesc, ftemps, PBIGCTX_PASS);
                                                // t1 = y/x
            OK = OK && Kadd(x1, t1, t1, fdesc,
                            PBIGCTX_PASS);   // t1 = m = y/x + x
        } else {                   // Doubling over GF(q)
            OK = OK && Kadd(y1, y1, t2, fdesc, PBIGCTX_PASS);   // t2 = 2*y
            OK = OK && Kmul2000(x1, x1, t1, fdesc,
                                ftemps, PBIGCTX_PASS);   // t1 = x^2
            OK = OK && Kadd(t1, E->a, t3, fdesc,
                                PBIGCTX_PASS); // t3 = x^2 + a
            OK = OK && Kadd(t1, t3, t3, fdesc,
                                PBIGCTX_PASS);   // t3 = 2x^2 + a
            OK = OK && Kadd(t1, t3, t3, fdesc,
                                PBIGCTX_PASS);   // t3 = 3x^2 + a
            OK = OK && Kinvert(t2, t1, fdesc, ftemps,
                                PBIGCTX_PASS); // t1 = 1/(2*y)
            OK = OK && Kmul2000(t3, t1, t1, fdesc,
                                ftemps, PBIGCTX_PASS);
                                                // t1 = m = (3x^2 + a)/(2*y)
        } // if x1 == x2
    } else {   // Distinct x coordinates
        OK = OK && Kadd(y1, t2, t3, fdesc,
                        PBIGCTX_PASS);       // t3 = y1 + t2
        if (char2) {
            OK = OK && Kadd(t3, x2, t3, fdesc,
                            PBIGCTX_PASS);
                                        // Use t3 = y1 + t2 + x2 in char 2
        }
        OK = OK && Ksub(x1, x2, t2, fdesc,
                        PBIGCTX_PASS);       // t2 = x1 - x2
        OK = OK && Kinvert(t2, t1, fdesc, ftemps,
                        PBIGCTX_PASS);   // t1 = 1/t2
        OK = OK && Kmul2000(t3, t1, t1, fdesc,
                            ftemps, PBIGCTX_PASS); // t1 = m = t3/t2
    }
    if (simple_case || !OK) {
        // Do nothing
    } else if (char2) {
        DWORDREG i;
        OK = OK && Kmul2000(t1, t1, t2, fdesc,
                            ftemps, PBIGCTX_PASS);   // t2 = m^2
        for (i = 0; i != elng; i++) {
            t2[i] = t2[i] ^ t1[i] ^ E->a[i] ^ x2[i];
        }                                       // t2 = m^2 + m - a - x2
        OK = OK && Kmul2000(t1, t2, t3, fdesc, ftemps, PBIGCTX_PASS);
                                                // t3 = (t2 - 2*x1)*m
        for (i = 0; i != elng; i++) {
            digit_tc x3i = t2[i] ^ x1[i];   // x3 = t2 - x1
            y3[i] = t3[i] ^ y1[i] ^ x3i;    // y3 = -(t2 - 2*x1)*m - y1 - x3
            x3[i] = x3i;
        }
    } else {
        OK = OK && Kmul2000(t1, t1, t2, fdesc,
                            ftemps, PBIGCTX_PASS); // t2 = m^2
        OK = OK && Ksub(t2, x1, t2, fdesc,
                        PBIGCTX_PASS);     //  m^2 - x1
        OK = OK && Ksub(t2, x2, t2, fdesc,
                        PBIGCTX_PASS);     // t2 = x3 = m^2 - x1 - x2;
        OK = OK && Ksub(x1, t2, t3, fdesc,
                        PBIGCTX_PASS);     // t3 = x1 - x3
        OK = OK && Kcopy(t2, x3, fdesc,
                        PBIGCTX_PASS);
        OK = OK && Kmul2000(t1, t3, t2, fdesc,
                        ftemps, PBIGCTX_PASS); // t2 = m*(x1 - x3)
        OK = OK && Ksub(t2, y1, y3, fdesc,
                        PBIGCTX_PASS);     // y3 = m*(x1 - x3) - y1
    }

#if EC_EXPENSIVE_DEBUGGING
    OK = OK && ecaffine_on_curve(p3, E, "",
                                         supplied_temps, PBIGCTX_PASS);
#endif
    if( fFree )
    {
        Free_Temporaries( t1, PBIGCTX_PASS );
    }
    return OK;
} // end ecaffine_addition


BOOL WINAPI ecaffine_addition_subtraction
          (ecaffine_tc *p1,
           ecaffine_tc *p2,
           ecaffine_t  *psum,     // OUT
           ecaffine_t  *pdif,     // OUT
           ecurve_tc   *E,
           digit_t     *supplied_temps,
           PBIGCTX_ARG)

// Compute psum = p1 + p2 and pdif = p1 - p2
// on an elliptic curve.
// Do this in a way which uses only one inversion.
// Outputs may overlap inputs.
{
    BOOL special_case = FALSE;
    BOOL OK = TRUE;
    field_desc_tc *fdesc = E->fdesc;
    const BOOL char2 = CHARACTERISTIC_2(fdesc);
                      /* Is field characteristic 2? */
    DWORDREGC elng = fdesc->elng;
    digit_tc *x1 = p1, *y1 = p1 + elng;
    digit_tc *x2 = p2, *y2 = p2 + elng;

    DWORDREG i;

    if (fdesc->ftype != FIELD_Q_MP && !char2) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "ecaffine_addition_subtraction",
                        PBIGCTX_PASS);
    } else if (supplied_temps == digit_NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER,
                        "ecaffine_addition_subtraction",
                        PBIGCTX_PASS);
    }
#if EC_EXPENSIVE_DEBUGGING
     OK = OK && ecaffine_on_curve(p1, E, "",
                                  supplied_tempsm PBIGCTX_PASS);
     OK = OK && ecaffine_on_curve(p2, E, "",
                                  supplied_temps, PBIGCTX_PASS);
#endif

     if (OK) {
#if !defined(MAX_ECTEMPS) || MAX_ECTEMPS < 5
    #error -- Increase MAX_ECTEMPS
#endif
// WARNING -- ps must come first for special_case code to work.
// This also requires that ecaffine_addition use only three field temps.
        digit_t *ps = supplied_temps;
        digit_t *pd = ps + 2*elng;
        digit_t *t0 = pd + 2*elng;
        digit_t *ftemps = t0 + elng;
        digit_t *special_case_temps = pd;

            // If either input or either output is
            // the point at infinity, use special code.

        if (   ecaffine_is_infinite(p1, E, PBIGCTX_PASS)
            || ecaffine_is_infinite(p2, E, PBIGCTX_PASS)
            || Kequal(x1, x2, fdesc, PBIGCTX_PASS)) {

            special_case = TRUE;
            OK = OK && ecaffine_addition(p1, p2, ps, +1, E,
                                        special_case_temps, PBIGCTX_PASS);
            OK = OK && ecaffine_addition(p1, p2, pdif, -1, E,
                                         special_case_temps, PBIGCTX_PASS);
            OK = OK && ecaffine_copy(ps, psum, E, PBIGCTX_PASS);
        }

        if (OK && !special_case) {
            digit_t *psx = ps, *psy = ps + elng;
            digit_t *pdx = pd, *pdy = pd + elng;

            OK = OK && Ksub(x1, x2, psx, fdesc, PBIGCTX_PASS);
            OK = OK && Kinvert(psx, t0, fdesc,
                               ftemps, PBIGCTX_PASS);  // t0 = 1/(x1 - x2)
            if (char2) {
                for (i = 0; OK && i != elng; i++) {
                    digit_tc deltay = y1[i] ^ y2[i];   // y1 - y2

                    psy[i] = deltay;
                    pdy[i] = deltay ^ x2[i];           // y1 - (-y2 - x2)
                }
            } else {
                OK = OK && Ksub(y1, y2, psy, fdesc,
                                PBIGCTX_PASS);   // y1 - y2
                OK = OK && Kadd(y1, y2, pdy, fdesc,
                                PBIGCTX_PASS);   // y1 - (-y2)
            }
            OK = OK && Kmul2000(t0, psy, psy, fdesc, ftemps,
                                PBIGCTX_PASS);
                                             // ms = (y1 - y2)/(x1 - x2)
            OK = OK && Kmul2000(t0, pdy, pdy, fdesc, ftemps,
                                PBIGCTX_PASS);
                                             // md = (y1 + y2)/(x1 - x2)
                                             // or (y1 + y2 + x2)/(x1 - x2)
            OK = OK && Kmul2000(psy, psy, psx, fdesc, ftemps,
                                PBIGCTX_PASS);  // ms^2
            OK = OK && Kmul2000(pdy, pdy, pdx, fdesc, ftemps,
                                PBIGCTX_PASS);  // md^2
            if (char2) {
                for (i = 0; OK && i != elng; i++) {
                    digit_tc itemp = E->a[i] ^ x1[i] ^ x2[i];

                    psx[i] ^= psy[i] ^ itemp;  // ms^2 + ms - a - x1 - x2
                    pdx[i] ^= pdy[i] ^ itemp;  // md^2 + md - a - x1 - x2
                }
            } else {
                OK = OK && Kadd(x1, x2, t0, fdesc,
                                PBIGCTX_PASS);    // x1 + x2
                OK = OK && Ksub(psx, t0, psx, fdesc,
                                PBIGCTX_PASS);  // ms^2 - x1 - x2
                OK = OK && Ksub(pdx, t0, pdx, fdesc,
                                PBIGCTX_PASS);  // md^2 - x1 - x2
            }

              // Now psx has x(P1 + P2) and pdx has x(P1 - P2)
              // Compute y(P1 + P2) = ms*(x1 - psx) - y1
              //     (subtract another psx in characteristic 2
              // Likewise y(P1 - P2) = md*(x1 - pdx) - y1

            OK = OK && Ksub(x1, psx, t0, fdesc,
                            PBIGCTX_PASS);
            OK = OK && Kmul2000(psy, t0, psy, fdesc, ftemps,
                                PBIGCTX_PASS);
            OK = OK && Ksub(x1, pdx, t0, fdesc,
                            PBIGCTX_PASS);
            OK = OK && Kmul2000(pdy, t0, pdy, fdesc, ftemps,
                                PBIGCTX_PASS);

            if (char2) {
                for (i = 0; OK && i != elng; i++) {
                    digit_tc y1i = y1[i];
                    digit_tc xsumi = psx[i];
                    digit_tc ysumi = psy[i] ^ y1i ^ xsumi;
                    digit_tc xdifi = pdx[i];
                    digit_tc ydifi = pdy[i] ^ y1i ^ xdifi;

                    psum[i]      = xsumi;
                    psum[i+elng] = ysumi;

                    pdif[i]      = xdifi;
                    pdif[i+elng] = ydifi;
                } // for i
            } else {
                OK = OK && Ksub(psy, y1, psy, fdesc, PBIGCTX_PASS);
                OK = OK && Ksub(pdy, y1, pdy, fdesc, PBIGCTX_PASS);

                for (i = 0; OK && i != elng; i++) {
                    digit_tc xsumi = psx[i];
                    digit_tc ysumi = psy[i];
                    digit_tc xdifi = pdx[i];
                    digit_tc ydifi = pdy[i];

                    psum[i]      = xsumi;
                    psum[i+elng] = ysumi;
                    pdif[i]      = xdifi;
                    pdif[i+elng] = ydifi;
                } // for i
            }
        } // if !special_case
    }
#if EC_EXPENSIVE_DEBUGGING
    OK = OK && ecaffine_on_curve(psum, E, "",
                                  supplied_temps, PBIGCTX_PASS);
    OK = OK && ecaffine_on_curve(pdif, E,
                                 "",
                                 supplied_temps, PBIGCTX_PASS);
#endif
#if PRINT_ERROR_MESSAGES
    if (!OK && mp_errfil != NULL) {
        fprintf(mp_errfil, "ecaffine_addition_subtraction "
                           "exiting abnormally\n");
    }
#endif
    return OK;
} // end ecaffine_addition_subtraction


BOOL WINAPI ecaffine_attributes2
               (ecaffine_tc *p1,     // IN
                ecaffine_tc *p2,     // IN
    ecaffine_attributes2_t  *attr,   // OUT
                  ecurve_tc *E,      // IN
                  PBIGCTX_ARG)

//    Given two points p1, p2 on E, test both for point at infinity.
//    Also check whether p1 = +- p2.
//
//    If p1 and p2 have different x coordinates, they are equal or negatives.
//    If the x's match but the y's are different, they must be negatives.
//    When p1 = p2 is finite, check for a point of order 2.
//    Such points have x = 0 in characteristic 2, y = 0 otherwise.

{
    field_desc_tc *fdesc = E->fdesc;
    DWORDREGC elng = fdesc->elng;
    BOOL OK = TRUE;

    attr->inf1 = ecaffine_is_infinite(p1, E, PBIGCTX_PASS);
    attr->inf2 = ecaffine_is_infinite(p2, E, PBIGCTX_PASS);
    attr->equal = Kequal_many(p1, p2, 2, fdesc, PBIGCTX_PASS);

    if (attr->inf1 || attr->inf2) {
        attr->negatives = attr->equal;      // Are both infinite?
    } else if (attr->equal) {
        attr->negatives = Kiszero((CHARACTERISTIC_2(fdesc) ? p1 : p1 + elng),
                                  fdesc, PBIGCTX_PASS);
                             // Check for point of order 2
    } else {
        attr->negatives = Kequal(p1, p2, fdesc, PBIGCTX_PASS);
                             // Same x, different y.
    }
    return OK;
} // end ecaffine_attributes2




BOOL WINAPI ecaffine_is_infinite (ecaffine_tc *p1,
                                  ecurve_tc   *E,
                                  PBIGCTX_ARG)

// Check for point at infinity,
// If b = 0, check whether x = 0 and y = 1.
// If b <> 0, check whether x = y = 0

//    If an error occurs, this routine returns FALSE.
{
    field_desc_tc *fdesc = E->fdesc;
    DWORDREGC elng = fdesc->elng;
    BOOL OK = TRUE, infinite;

    if (Kiszero(p1, fdesc, PBIGCTX_PASS)) {    // If x = 0
        if (E->biszero) {
            infinite = Kequal(p1 + elng, fdesc->one, fdesc, PBIGCTX_PASS);
        } else {
            infinite = Kiszero(p1 + elng, fdesc, PBIGCTX_PASS);
        }
    } else {
        infinite = FALSE;
    }
    return OK && infinite;
} // end ecaffine_is_infinite


BOOL WINAPI ecaffine_multiply_pm1(ecaffine_tc *p1,
                           ecaffine_t  *p2,
                           const int    negate_flag,
                           ecurve_tc   *E,
                           PBIGCTX_ARG)

//      Set p2 =  p1 if negate_flag = +1
//      Set p2 = -p1 if negate_flag = -1

{
    BOOL OK = TRUE;
    if (negate_flag == +1) {
        OK = OK && ecaffine_copy(p1, p2, E, PBIGCTX_PASS);
    } else if (negate_flag == -1) {
        OK = OK && ecaffine_negate(p1, p2, E, PBIGCTX_PASS);
    } else {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "ecaffine_multiply_pm1",
                        PBIGCTX_PASS);
    }
    return OK;
} // end ecaffine_multiply_pm1



BOOL WINAPI ecaffine_negate
        (ecaffine_tc *p1,
         ecaffine_t  *p2,
         ecurve_tc   *E,
         PBIGCTX_ARG)

// Compute p2 = -p1 with elliptic curve arithmetic.
{
    BOOL OK = TRUE;
    field_desc_tc *fdesc = E->fdesc;
    DWORDREGC elng = fdesc->elng;

    if (ecaffine_is_infinite(p1, E, PBIGCTX_PASS)) {
        OK = Kcopy(p1 + elng, p2 + elng, fdesc,
                   PBIGCTX_PASS);    // y2 = y1
    } else if (CHARACTERISTIC_2(fdesc)) {
        OK = Kadd(p1, p1 + elng, p2 + elng, fdesc,
                  PBIGCTX_PASS); // y2 = x1 + y1
    } else {
        OK = Knegate(p1 + elng, p2 + elng, fdesc,
                  PBIGCTX_PASS);  // y2 = -y1
    }
    OK = OK && Kcopy(p1, p2, fdesc,
                     PBIGCTX_PASS);                // x2 = x1
    return OK;
} // end ecaffine_negate



BOOL WINAPI ecaffine_on_curve
            (ecaffine_tc  *p1,
             ecurve_tc    *E,
             const char   *pdebug_info,
             digit_t      *supplied_temps,
             PBIGCTX_ARG)

// Test whether p1 = (x1, y1) is on the curve.
// In GF(q) case, check whether y1^2 = x1 * (x1^2 + a) + b.
// In GF(2^m) case, check whether y1*(x1 + y1) = x1^2*(x1 + a) + b.

// When the point is not on the curve, we call SetMpErrno_clue,
// using *pdebug_info as a hint
{
    BOOL OK = TRUE;
    field_desc_tc *fdesc = E->fdesc;
    DWORDREGC elng = fdesc->elng;
    digit_tc *x1 = p1, *y1 = p1 + elng;
    digit_t *t1 = digit_NULL, *t2 = digit_NULL, *ftemps = digit_NULL;
    digit_tempinfo_t tempinfo;

    if (ecaffine_is_infinite(p1, E, PBIGCTX_PASS)) return TRUE;

    tempinfo.address = supplied_temps;
    tempinfo.need_to_free = FALSE;
    tempinfo.nelmt = E->ndigtemps;
    OK = OK && possible_digit_allocate(&tempinfo,
                                       "",
                                       PBIGCTX_PASS);

    if (OK) {
        t1 = tempinfo.address;
        t2 = t1 + elng;
        ftemps = t2 + elng;
#if MAX_ECTEMPS < 2
    #error -- "Increase MAX_ECTEMPS"
#endif
    }

    OK = OK && Kmul2000(x1, x1, t1, fdesc, ftemps, PBIGCTX_PASS);      // x^2

    if (CHARACTERISTIC_2(fdesc)) {       // Characteristic 2
        OK = OK && Kadd(x1, E->a, t2, fdesc,
                        PBIGCTX_PASS);            // t2 = x + a
        OK = OK && Kmul2000(t1, t2, t1, fdesc, ftemps,
                        PBIGCTX_PASS);  // t1 = x^2*(x + a)
        OK = OK && Kadd(t1, E->b, t1, fdesc,
                        PBIGCTX_PASS);            // t1 = x^2*(x + a) + b
        OK = OK && Kadd(y1, x1, t2, fdesc,
                        PBIGCTX_PASS);              // t2 = y1 + x1;
        OK = OK && Kmul2000(y1, t2, t2, fdesc, ftemps,
                        PBIGCTX_PASS);  // t2 = y1*(y1 + x1)

    } else {                            // Odd characteristic
        OK = OK && Kadd(t1, E->a, t1, fdesc,
                        PBIGCTX_PASS);            // t1 = x^2 + a
        OK = OK && Kmul2000(x1, t1, t1, fdesc, ftemps,
                        PBIGCTX_PASS);  // t1 = x*(x^2 + a)
        OK = OK && Kadd(t1, E->b, t1, fdesc,
                        PBIGCTX_PASS);            // t1 = x*(x^2 + a) + b
        OK = OK && Kmul2000(y1, y1, t2, fdesc, ftemps,
                        PBIGCTX_PASS);  // t2 = y^2
    }
    if (OK && !Kequal(t1, t2, fdesc, PBIGCTX_PASS)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NOT_ON_CURVE, pdebug_info, PBIGCTX_PASS);
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }
    return OK;
} // end ecaffine_on_curve



BOOL WINAPI ecaffine_set_infinite
        (ecaffine_t *p1,           // OUT
         ecurve_tc  *E,
         PBIGCTX_ARG)
// Set p1 to identity (point at infinity).
// If b = 0, set x = 0 and y = 1.
// If b <> 0. set x = y = 0.
{
    field_desc_tc *fdesc = E->fdesc;
    DWORDREGC elng = fdesc->elng;
    BOOL OK = TRUE;

    OK = OK && Kclear_many(p1, 2, fdesc, PBIGCTX_PASS);
    if (E->biszero) {
        OK = OK && Kcopy(fdesc->one, p1 + elng, fdesc, PBIGCTX_PASS);
    }
    return OK;
} // end ecaffine_set_infinite


BOOL WINAPI ec_free(ecurve_t *E, PBIGCTX_ARG)
// Free the temporaries associated with an elliptic curve.
{
    BOOL OK = TRUE;
    if (E->free_field && E->fdesc != field_desc_NULL) {
        OK = OK && Kfree((field_desc_t*)E->fdesc, PBIGCTX_PASS);
                                   // Remove const attribute

        Free_Temporaries((field_desc_t*)E->fdesc, PBIGCTX_PASS);
    }
    if (E->deallocate != digit_NULL) {
        Free_Temporaries(E->deallocate, PBIGCTX_PASS);
    }
    E->deallocate = digit_NULL;
    E->generator = digit_NULL;
    E->a = digit_NULL;
    E->b = digit_NULL;
    E->gorder = digit_NULL;
    E->fdesc = field_desc_NULL;
    return OK;
} // end ec_free


BOOL WINAPI ec_initialize
        (digit_tc      *a,
         digit_tc      *b,
         field_desc_tc *fdesc,
         ecurve_t      *E,         
         PBIGCTX_ARG,
         struct bigctx_t      *pbigctxGlobal)
// Initialize struct for elliptic curve with parameters a and b
{
    DWORDREGC elng = fdesc->elng;
    BOOL OK = TRUE;
    digit_t *fields = digit_allocate(5*elng + 1, "ec_initialize", pbigctxGlobal);
    E->deallocate = fields;
    E->free_field = FALSE;
    E->ndigtemps = fdesc->ndigtemps_arith + MAX_ECTEMPS*elng;
    E->biszero = Kiszero(b, fdesc, PBIGCTX_PASS);

    if (fields == digit_NULL) {
        OK = FALSE;
    } else {
        E->a = fields;  fields += elng;
        E->b = fields;  fields += elng;
        E->generator = fields;  fields += 2*elng;
        E->gorder = fields; fields += (elng+1);
        E->fexpon = ec_exponentiation_NULL;
    }

    if (CHARACTERISTIC_2(fdesc)) {
        OK = OK && !E->biszero;        // GF(2^m) requires b <> 0
    } else {
        digit_t *ftemps = digit_NULL;
        OK = OK && Kimmediate(27, E->b, fdesc, PBIGCTX_PASS)
                && Kmul2000(E->b, b, E->b, fdesc, ftemps,
                            PBIGCTX_PASS)        // 27*b
                && Kmul2000(E->b, b, E->b, fdesc, ftemps,
                            PBIGCTX_PASS)        // 27*b^2
                && Kadd(a, a, E->a, fdesc,
                            PBIGCTX_PASS)                       // 2*a
                && Kmul2000(E->a, E->a, E->a, fdesc, ftemps,
                            PBIGCTX_PASS)     // 4*a^2
                && Kmuladd(a, E->a, E->b, E->a, fdesc, ftemps,
                            PBIGCTX_PASS)   // 4*a^3 + 27*b^2
                && !Kiszero(E->a, fdesc,
                            PBIGCTX_PASS);   // Ensure discriminant nonzero
    }
    if (OK) {
        E->fdesc = fdesc;
        OK = OK && Kcopy(a, E->a, fdesc, PBIGCTX_PASS)
                && Kcopy(b, E->b, fdesc, PBIGCTX_PASS)

          // Initialize generator to point at infinity
          // and order to 1.  Application can change these.

                && ecaffine_set_infinite(E->generator, E, PBIGCTX_PASS)
                && set_immediate(E->gorder, 1, elng+1, PBIGCTX_PASS);
    }
    if (!OK) {
        (void)ec_free(E, PBIGCTX_PASS);
    }
    return OK;
} // end ec_initialize_curve
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\kdiv.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
       File kdiv.c.    Version 10 April 2002
*/


#include "fieldpriv.h"

BOOL WINAPI Kdiv
        (digit_tc *f1,        // f3 = f1/f2
         digit_tc *f2,
         digit_t*  f3,
         field_desc_tc *fdesc,
         digit_t *supplied_temps,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    digit_tempinfo_t tempinfo;
    DWORDREGC elng = fdesc->elng;

    tempinfo.address = supplied_temps;
    tempinfo.need_to_free = FALSE;
    tempinfo.nelmt = fdesc->ndigtemps_arith;

    OK = OK && possible_digit_allocate(&tempinfo, "Kdiv", PBIGCTX_PASS);

    if (OK) {
        digit_t *f2inv = tempinfo.address;
        digit_t *ftemps = f2inv + elng;

        OK = OK && Kinvert(f2, f2inv, fdesc, ftemps, PBIGCTX_PASS);
        OK = OK && Kmul2000(f1, f2inv, f3, fdesc, ftemps, PBIGCTX_PASS);
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }
    return OK;
} /* Kdiv */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\field.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef __FIELD_H
#define __FIELD_H 1
#include "bignum.h"


/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

/*
        This file defines field_desc_t, a struct representing a field.
        The data structures allow
        GF(2^m) or GF(q) (with multiple precision q).
        finite-degree extensions.

        The letter `K' is often used in mathematics
        to denote a field.  We use names like Kadd
        for field addition, since the name `Fadd'
        suggests a floating point addition routine.

        A field element is an array of type digit_t.
        The elng element of the field_sesc_t struct tells its length

    Arithmetic routines:

        Kadd(f1, f2, f3, &fdesc) -- f3 = f1 + f2
        Kdiv(f1, f2, f3, &fdesc, ftemps) -- f3 = f1 / f2
                            Array of fdesc->ndigtemps_arith temps supplied
        Kdot(ops. nop, result, &fdesc, &ftemps) --
                 Evaluate a sum of terms of form x_i or x_i*x_j,
                 where some operands may be negated.
        Kequal (f1, f2,  &fdesc) -- Is f1 == f2?
        Kexpon (f1, exponent, lng_expon, f2, &fdesc) -- f2 = f1^exponent .
        Kimmediate(scalar, f1, &fdesc) -- f1 = scalar (a signed digit_t)
        Kinvert(f1, f2,  &fdesc, ftemps) -- f2 = 1/f1
                            Array of fdesc-->ndigtemps_invert1 supplied
        Kiszero(f1,      &fdesc) -- Is f1 == 0?
        Kmulpower2(f1, ishift, f3, fdesc) -- f3 = f1 * 2^ishift
        Kmul(f1, f2, f3, &fdesc) -- f3 = f1 * f2
        Kmul1998(f1, f2, f3, &fdesc) -- f3 = f1*f2,
        Kmul2000(f1, f2, f3, &fdesc, ftemps) -- f3 = f1*f2,
                            Array of fdesc->ndigtemps_mul temps supplied
        Kmul -- defaults to Kmul2000
        Kmuladd(f1, f2, f3, f4, &fdesc, ftemps) -- f4 = f1 * f2 + f3
                            Array of fdesc->ndigtemps_arith temps supplied
        Kmulsub(f1, f2, f3, f4, &fdesc, ftemps) -- f4 = f1 * f2 - f3
                            Array of fdesc->ndigtemps_arith temps supplied
        Kmulsubfrom(f1, f2, f3, f4, &fdesc, ftemps) -- f4 = f3 - f1 * f2
                            Array of fdesc->ndigtemps_arith temps supplied
        Knegate(f1, f2,  &fdesc) -- f2 = -f1
        Ksqrt(f1, f2,    &fdesc) -- f2 = sqrt(f1) (either root)
        Ksub(f1, f2, f3, &fdesc) -- f3 = f1 - f2

     Mixed base-extension field arithemtic

        Kbase_to_ext(f1, fdesc1, f3, fdesc3)   f3 = f1, converting from
                                               fdesc1 to fdesc3.
                                               fdesc3 is an extension of fdesc1
        Kext_to_base(f1, fdesc1, f3, fdesc3)   f3 = f1, converting from
                                               fdesc1 to fdesc3
                                               fdesc3 is a subfield of fdesc1.
        Kin_base_field(f1, fdesc1, fdesc3)     Test whether f1 (in fdesc1) is an
                                               element of fdesc3.  fdesc3 must
                                               be a subfield of fdesc1.

        Kbase_mul_ext(f1, fdesc1, f2, f3, fdesc3, &temps)
                                               f3 = f1 * f2, where
                                               f1 is in fdesc1 but f2 and f3
                                               are in fdesc3.  fdesc3 must
                                               be an extension of fdesc1.

    Miscellaneous routines:

        Kclear(f1, &fdesc)              -- Set one field element to zero
        Kclear_many(f1, nelmt,    &fdesc) -- Set nelmt elements to zero.
        Kcopy(f1, f2, &fdesc)             -- Copy a field element from f1 to f2.
        Kcopy_many(f1, f2, nelmt, &fdesc) -- Copy nelmt elements from f1 to f2
        Kfree  (&fdesc)                -- Free any memory malloc-ed
                                          when field was initialized.
        Kget_field_size(mpnum, &fdesc) -- Get (finite) field size, as a
                                          normal integer (length elng + 1)
        Kinitialize_extension(&bfdesc, minpoly, degree, &fdesc) --
                                       -- Initialize extension field fdesc
                                          minpoly is monic minimal polynomial,
                                          coefficients in subfield bfdesc.
        Kinitalize_normal2(m, T, &fdesc) -- Initialize for normal basis.
        Kinitialize_polynomial2(minpoly, degree, reduction_code, &fdesc)
                                       -- Initialize GF(2^m) field with
                                             polynomial basis
        Kinitialize_prime(&modulus, &fdesc)
                                       -- Initialize field with prime modulus.
        Krandom     (f1, &fdesc)       -- Set f1 to random value
        Krandom_many(f1, nelmt,     &fdesc) -- Set f1 to random values
                                               (nelmt values)
        Krandom_nonzero(f1,    &fdesc) -- Set f1 to random nonzero element
        Krandom_nonzero_many(f1, nelmt, &fdesc) -- Set f1 to random nonzero
                                                   values (nelmt values)

        K2n_normal_basis_exists(m, T) -- Test for existence of normal basis.


    Polynomials over GF(2), packed coefficients,
                           least significant bit for X^0,
                           most significant word zero filled.
                           Some algorithms have not been optimized.

        mbit3 = GF2_add_diff(p1, nbit1, p2, nbit2, p3)
                         -- Add two polynomials of possibly different length,
                            p3 = p1 + p2.

        GF2_add_same(p1, p2, p3, nbit) -- Add two polynomials of same length,
                            p3 = p1 + p2.

        GF2_extended_GCD(p1, nbit1, p2, nbit2, p1invmodp2, gcd)
                         -- Find gcd = GCD(p1, p2)
                            and pinvmodp2 such that
                            p1*pinvmodp2 == gcd (mod p2).
                            Either output can be digit_NULL.

        GF2_irreducible(p, deg) -- Test whether p is irreducible of degree deg.

        GF2_mod_exp(base, expon, lng_expon, result, modulus, nbit) --
                            Compute result = base^expon (mod modulus).
                            base and result have nbit bits.
                            modulus has degree nbit (i.e., nbit+1 nbits).

        GF2_mod_mul(p1, p2, p3, modulus, pinv, nbit, freduc, temps) --
                            Compute p3 == p1*p2 (mod modulus).
                            p1, p2, p3, pinv have nbit bits.
                            modulus has degree nbit (nbit+1 bits).
                            pinv must be the inverse of modulus,
                            from GF2_poly_inverse.
                            freduc is optionally a special
                            polynomial reduction code.
                            temps may be digit_NULL or a digit_t
                            array of length GF2_mod_mul_temps(nbit)

        GF2_mod_mul_temps(nbit) -- Number of digit_t temporaries
                            needed by GF2_mod_mul.

        DWORDREG GF2_mulk_multiplications(elng) --
                            Return the number of single-precision
                            (RADIX_BITS x RADIX_BITS) multiplications
                            needed to multiply two GF(2) polynomials
                            of length elng.  This is used to compute
                            the space for GF2_multiply_same.

        GF2_multiply_same(a, b, elng, prod, temps. ltemps) --
                            Multiply prod = a * b over GF(2)
                            where a, b have length elng and prod has
                            length 2*elng.
                            temps should be digit_NULL or have ltemps
                            entries of type digit_t, where
                            ltemps > 2*GF2_mulk_multiplications(elng).

        GF2_poly_inverse(poly, deg, pinv) --
                            Compute pinv = FLOOR(X^(2*deg-1) / poly).
                            poly should be monic with degree deg.

        GF2_random(p, nbit) -- Generate random polynomial with nbit bits
                               (degree <= nbit-1).

        GF2_random_monic(p, deg) -- Generate random monic polynomial
                                    of degree deg (deg+1 bits).

        GF2_random_nonzero(p, nbit) -- Generate random nonzero polynomial
                                       with nbit bits (nbit > 0).
*/
#include "bignum.h"

typedef enum {FIELD_TYPE_INVALID = 0,
              FIELD_Q_MP,          // Field mod multiple-precision prime q
              FIELD_2_NORMAL,      // Field GF(2^m) with normal basis over GF(2)
              FIELD_2_POLYNOMIAL}  // Field GF(2^m) with polynomial basis
                                   //   over GF(2)
           field_type_t;

typedef const field_type_t field_type_tc;

#define CHARACTERISTIC_2(fdesc) ((fdesc)->ftype >= FIELD_2_NORMAL)
                         // Test for characteristic 2 field.

#if TARGET_OS == OS_ATTILA
#define FIELD_LONGEST (1 + 255/RADIX_BITS)
#else
#define FIELD_LONGEST MP_LONGEST
#endif
typedef digit_t flongest_t[FIELD_LONGEST];
           // Avoid using FIELD_LONGEST in new code

#define k2nmulshifts_NULL ((struct k2nmulshifts_t*)0)
                    // See field2n.c for struct definition.

   //   Special GF(2^m) fields defined by sparse polynomials.

typedef BOOL WINAPI gf2_reduction_t(MP_MODIFIED, PBIGCTX_ARG);
#define gf2_reduction_NULL ((gf2_reduction_t*)0)
                                      // See gf2NIST.c

typedef struct {
    DWORD weight;             // 3 for trinomial, 5 for pentanomial
    DWORD exponents[5];       // Nonzero coefficients. exponents[0] is degree.
    gf2_reduction_t *freduc;  // Function to reduce double-length polynomial
                              //   modulo field-defining polynomial
} gf2_predefined_t;

typedef const gf2_predefined_t gf2_predefined_tc;

exportable_var gf2_predefined_tc gf2NIST163;
exportable_var gf2_predefined_tc gf2NIST233;
exportable_var gf2_predefined_tc gf2NIST283;
exportable_var gf2_predefined_tc gf2NIST409;
exportable_var gf2_predefined_tc gf2NIST571;

exportable_var gf2_predefined_tc gf2WTLS113;
exportable_var gf2_predefined_tc gf2WTLS163;

#define FIELD_INPUT  digit_tc*
#define FIELD_OUTPUT digit_t*

Future_Struct(field_desc_t);

typedef BOOL WINAPI field_0op_notemps_t (FIELD_OUTPUT, DWORDREGC,
                                      const struct field_desc_t*, PBIGCTX_ARG);
typedef BOOL WINAPI field_1op_notemps_t (FIELD_INPUT, FIELD_OUTPUT,
                                      DWORDREGC, const struct field_desc_t*,
                                      PBIGCTX_ARG);
typedef BOOL WINAPI field_1op_notemps_err_t (FIELD_INPUT, FIELD_OUTPUT,
                                      DWORDREGC, const struct field_desc_t*,
                                      BOOL*, PBIGCTX_ARG);
typedef BOOL WINAPI field_2op_notemps_t (FIELD_INPUT, FIELD_INPUT, FIELD_OUTPUT,
                                      DWORDREGC, const struct field_desc_t*,
                                      PBIGCTX_ARG);

typedef struct {
          field_2op_notemps_t *adder;       // x + y
          BOOL        (WINAPI *equaler)     (FIELD_INPUT, FIELD_INPUT,
                                             DWORDREGC,
                                             const struct field_desc_t*,
                                             PBIGCTX_ARG);
                                            // Does x == y?


          //
          //  BEVANS -- Removed exponentiator1 -- it's currently unreferenced.
          //

//          BOOL        (WINAPI *exponentiator1) (FIELD_INPUT, MP_INPUT,
//                                                DWORDREGC, FIELD_OUTPUT,
//                                                const struct field_desc_t*,
//                                                PBIGCTX_ARG);



                                            // Compute base^exponent
                                            // (exponent an integer)
          BOOL        (WINAPI *freer)       (struct field_desc_t*, PBIGCTX_ARG);
                                             // Free ftype-dependent data when
                                             // Kfree called.
          BOOL        (WINAPI *immediater)  (sdigit_tc*, FIELD_OUTPUT,
                                             DWORDREGC,
                                             const struct field_desc_t*,
                                             PBIGCTX_ARG);

          BOOL        (WINAPI *inverter1)   (FIELD_INPUT, FIELD_OUTPUT,
                                             const struct field_desc_t*,
                                             const struct digit_tempinfo_t*,
                                             PBIGCTX_ARG);
          BOOL        (WINAPI *iszeroer)    (FIELD_INPUT, DWORDREGC,
                                             const struct field_desc_t*,
                                             PBIGCTX_ARG);
                                            // Does x == 0?
          BOOL        (WINAPI *mulpower2er) (FIELD_INPUT, const int,
                                             FIELD_OUTPUT, DWORDREGC,
                                             const struct field_desc_t*,
                                             PBIGCTX_ARG);
                                            // Multiply by 2^(second argument)
          BOOL        (WINAPI *multiplier1) (FIELD_INPUT, FIELD_INPUT,
                                             FIELD_OUTPUT,
                                             const struct field_desc_t*,
                                             MP_MODIFIED, PBIGCTX_ARG);
                                            // x * y

          field_1op_notemps_t *negater;     // -x
          field_1op_notemps_err_t *quad1_solver; // Find x given x^2 + x
                                             // (characteristic 2 only)
          
          //
          //  BEVANS:  Removed the following pointer because it is never referenced (randomizer).
          //
          
          // field_0op_notemps_t *randomizer;  // random
          BOOL        (WINAPI *sizer) (MP_OUTPUT,  const struct field_desc_t*,
                                       PBIGCTX_ARG);
                                // Return size of field (array length elng+1)
          //
          //  BEVANS:  Removed the following pointer because it is never referenced (sqrter).
          //
          //field_1op_notemps_err_t *sqrter;   // sqrt(x)


          field_2op_notemps_t *subtracter;   // x - y
          field_0op_notemps_t *zeroizer;     // 0
} field_arithmetic_t;

#define field_arithmetic_NULL ((field_arithmetic_t*)0)

#define Kadd_many(f1, f2, f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->adder) ((f1), (f2), (f3), (nelmt), (fdesc), ctx))
#define Kclear_many(      f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->zeroizer)  ((f3), (nelmt), (fdesc), ctx))
#define Kequal_many(f1, f2,   nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->equaler)   ((f1), (f2), (nelmt), (fdesc), ctx))
#define Kget_field_size(mp, fdesc, ctx) \
        (((fdesc)->arithmetic->sizer) ((mp), (fdesc), ctx))

#define Kimmediate_many(sarray, f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->immediater) \
                ((sarray), (f3), (nelmt), (fdesc), ctx))
#define Kiszero_many(f1,      nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->iszeroer)  ((f1), (nelmt), (fdesc), ctx))
#define Kmulpower2_many(f1, ishift, f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->mulpower2er) \
         ( (f1), (ishift), (f3), (nelmt), (fdesc), ctx))
#define Knegate_many(f1,  f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->negater)   ((f1), (f3), (nelmt), (fdesc), ctx))
#define Krandom_many(     f3, nelmt, fdesc, ctx) \
        (((fdesc)->arithmetic->randomizer)((f3), (nelmt), (fdesc), ctx))
#define Ksqrt_many(f1,    f3, nelmt, fdesc, are_squares, ctx) \
        (((fdesc)->arithmetic->sqrter) \
         ((f1), (f3), (nelmt), (fdesc), (are_squares), ctx))
#define Ksub_many(f1, f2, f3, nelmt, fdesc, ctx) \
      (((fdesc)->arithmetic->subtracter) \
             ((f1), (f2), (f3), (nelmt), (fdesc), ctx))

// N.B.  Prior to March, 2002, Kcopy, Kclear, Krandom had an extra argument.
//       Those older versions are now named
//       Kcopy_many, Kclear_many, Krandom_many.
//       are_squares argument added to Ksqrt_many in November, 2002


#define Kadd(f1, f2, f3, fdesc, ctx)   \
        Kadd_many(   (f1), (f2), (f3), 1, (fdesc), ctx)
#define Kbase_to_ext(f1, fdesc1, f3, fdesc3, ctx) \
        Kbase_to_ext_many((f1), (fdesc1), (f3), 1, (fdesc3), ctx)
#define Kclear(      f3, fdesc, ctx)   \
        Kclear_many(             (f3), 1, (fdesc), ctx)
#define Kcopy(f1,    f3, fdesc, ctx)   \
        Kcopy_many(  (f1),       (f3), 1, (fdesc), ctx)
#define Kequal(f1, f2,   fdesc, ctx)   \
        Kequal_many( (f1), (f2),       1, (fdesc), ctx)
#define Kexpon(f1, exponent, lng_expon, f3, fdesc, ctx) \
                     (((fdesc)->arithmetic->exponentiator1) \
                       ( (f1), (exponent), (lng_expon), (f3), (fdesc), ctx ) )

#define Kext_to_base(f1, fdesc1, f3, fdesc3, ctx) \
        Kext_to_base_many((f1), (fdesc1), (f3), 1, (fdesc3), ctx)

#define Kin_base_field(f1, fdesc1, fdesc3, ctx) \
        Kin_base_field_many((f1), (fdesc1), 1, (fdesc3), ctx)
#define Kin_base_field_many(f1, fdesc1, nelmt, fdesc3, ctx) \
        Kext_to_base_many((f1), (fdesc1), digit_NULL, (nelmt), (fdesc3), ctx)

#define Kiszero(f1,      fdesc, ctx)   \
        Kiszero_many((f1),             1, (fdesc), ctx)
#define Kmulpower2(f1, ishift, f3, fdesc, ctx)\
        Kmulpower2_many((f1), (ishift), (f3), 1, (fdesc), ctx)
#define Knegate(f1,  f3, fdesc, ctx)   \
        Knegate_many((f1),       (f3), 1, (fdesc), ctx)
#define Krandom(     f3, fdesc, ctx)   \
        Krandom_many(            (f3), 1, (fdesc), ctx)
#define Ksqrt(f1,    f3, fdesc, is_square, ctx)  \
        Ksqrt_many(  (f1),       (f3), 1, (fdesc), (is_square), ctx)
#define Ksub(f1, f2, f3, fdesc, ctx)   \
        Ksub_many(   (f1), (f2), (f3), 1, (fdesc), ctx)


typedef struct field_desc_t {
          DWORDREG     elng;   // Length of each field element, in digit_t's
          DWORDREG     degree; // Extension degree m if GF(2^m)
                               // Also used for extension fields
          DWORDREG     ndigtemps_arith;  // Number of digit_t temporaries
                                         // adequate for any of the following:

                                         // Kbase_mul_ext
                                         //   (use subfield->ndigtemps_arith)
                                         // Kdiv
                                         // Kinvert
                                         // Kinvert_many
                                         // Kmul2000
                                         // Kmuladd
                                         // Kmulsubfrom
          DWORDREG     ndigtemps_mul;
                               // Number of digit_t temporaries
                               // needed for a multiplication.
          DWORDREG     ndigtemps_invert1;
                               // Number of digit_t temporaries
                               // needed for an inversion.
          field_type_t ftype;  // Type of base field
          BOOL         free_modulus;   // If TRUE, Kfree frees
                                       // the modulo field.
                                       // Can be set by application.
          digit_t      *one;   // Constant 1
          digit_t      *deallocate;

          const field_arithmetic_t *arithmetic;
                                     // Pointers to arithmetic routines

// Next items apply only for extension fields
          const struct field_desc_t *base_field;  // Recursive data type
                                 // field_desc_NULL if not an extension field.
// Next item applies for extension fields and FIELD_2_POLYNOMIAL
          digit_t      *minimal_polynomial;

// Next items apply only if ftype = FIELD_Q_MP
          mp_modulus_tc *modulo;      // Information about q
          digit_t *inverse_adjustment;
                                      // Multiplier to adjust reciprocal
                                      // for FROM_RIGHT arithmetic
// Next items apply only if ftype = FIELD_2_NORMAL
          DWORDREG     T;      // See field2n.c
          DWORDREG     lng_mulshifts;
          struct k2nmulshifts_t *mulshifts;
                               // Pairs of shifts.  See field2n.c
// Next items apply only if ftype = FIELD_2_POLYNOMIAL or extension field.
//
          DWORDREG     nonzero_trace_power;
                               // Chosen so trace(alpha^nonzero_trace_power) = 1
          digit_t      *leading_inverse;
                     // FLOOR(X^(2*degree-1) / minimal_polynomial)
                     // N.B. Either leading_inverse = NULL or freduc = NULL.
// For extension fields, nonzero_trace_power is chosen so
//     minimal_polynomial = X^degree
//        + (nonzero const)*X^(nonzero_trace_power - 1) + ...
//     That is, it counts 1 + degree(minimal polynomial, minus leading term).

//     leading_inverse has signed bytes converting these low coefficients
//     into signed integers in [-16, 16], if possible.

          gf2_reduction_t  *freduc;

// Following apply to FIELD_2_NORMAL and FIELD_2_POLYNOMIAL.

          DWORDREG     unused_bits_top;  // elng*RADIX_BITS - degree
          digit_t      mask_used_bits;
                                  // Mask to avoid extraneous bits in
                                  // most significant word of a field element
} field_desc_t;


typedef const field_desc_t field_desc_tc;

#define field_desc_NULL ((field_desc_t*)0)


//     The following typedefs are for functions
//     indexed indirectly via pointers.
//     A call to GF2_get_funcs (after mp_initialization)
//     selects the best version of each routine
//     (depending possibly upon the client's hardware,
//     such as availability of MMX) and initializes the pointers.


typedef BOOL Stdcall86 gf2mul_t(MP_MODIFIED, DWORDREGC, PBIGCTX_ARG);

typedef BOOL Stdcall86 gf2mat22_t(digit_tc, digit_tc,
                                  digit_tc, digit_tc,
                                  digit_t[4], PBIGCTX_ARG);

typedef BOOL Stdcall86 gf2mul22_t(digit_tc[4],
                              MP_MODIFIED, MP_MODIFIED, DWORDREGC, MP_OUTPUT,
                              MP_MODIFIED, MP_MODIFIED, DWORDREGC, MP_OUTPUT,
                              PBIGCTX_ARG);

#define   gf2mul_NULL ((gf2mul_t*)0)
#define gf2mat22_NULL ((gf2mat22_t*)0)
#define gf2mul22_NULL ((gf2mul22_t*)0)

typedef struct {
    gf2mul_t   *pgf2mul;
    gf2mat22_t *pgf2mat22;
    gf2mul22_t *pgf2mul22;
} GF2_funcs_t;


extern BOOL WINAPI GF2_get_funcs(GF2_funcs_t*, PBIGCTX_ARG);

extern DWORDREG WINAPI GF2_add_diff(FIELD_INPUT, DWORDREGC,
                                    FIELD_INPUT, DWORDREGC,
                                    FIELD_OUTPUT, PBIGCTX_ARG);

extern BOOL WINAPI GF2_add_same(FIELD_INPUT, FIELD_INPUT,
                                FIELD_OUTPUT, DWORDREGC, PBIGCTX_ARG);

#define GF2_copy(p1, p2, nbit, ctx) \
        (mp_copy(p1, p2, BITS_TO_DIGITS(nbit), ctx), TRUE)
#define GF2_equal(p1, p2, nbit, ctx) \
        (compare_same(p1, p2, BITS_TO_DIGITS(nbit))==0)
#define GF2_iszero(p1, nbit, ctx) (all_zero(p1, BITS_TO_DIGITS(nbit)))

extern BOOL WINAPI GF2_double_reduce_general(FIELD_INPUT, FIELD_INPUT,
                            FIELD_INPUT, DWORDREGC, FIELD_OUTPUT, PBIGCTX_ARG);

extern BOOL WINAPI GF2_extended_GCD(FIELD_INPUT, DWORDREGC, FIELD_INPUT,
                            DWORDREGC, FIELD_OUTPUT, FIELD_OUTPUT, PBIGCTX_ARG);

extern BOOL WINAPI GF2_irreducible(FIELD_INPUT, DWORDREGC, PBIGCTX_ARG);

#define GF2_monic(f, deg, ctx) \
               ((f)[(deg)/RADIX_BITS] >> ((deg) % RADIX_BITS) == 1)
                      // Is f monic of degree deg?

extern BOOL WINAPI GF2_mod_exp(FIELD_INPUT, MP_INPUT, DWORDREGC,
                        FIELD_OUTPUT, FIELD_INPUT, DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI GF2_mod_mul(FIELD_INPUT, FIELD_INPUT, FIELD_OUTPUT,
                        FIELD_INPUT, FIELD_INPUT, DWORDREGC,
                        gf2_reduction_t*, MP_MODIFIED, PBIGCTX_ARG);

extern DWORDREG WINAPI GF2_mulk_multiplications(DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI GF2_multiply_same(FIELD_INPUT, FIELD_INPUT, DWORDREGC,
                                     FIELD_OUTPUT, MP_MODIFIED,
                                     DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI GF2_poly_inverse(FIELD_INPUT, DWORDREGC,
                                    FIELD_OUTPUT, PBIGCTX_ARG);

extern BOOL WINAPI GF2_random        (FIELD_OUTPUT, DWORDREGC, PBIGCTX_ARG);
extern BOOL WINAPI GF2_random_monic  (FIELD_OUTPUT, DWORDREGC, PBIGCTX_ARG);
extern BOOL WINAPI GF2_random_nonzero(FIELD_OUTPUT, DWORDREGC, PBIGCTX_ARG);

extern BOOL Stdcall86 GF2_square(FIELD_INPUT, DWORDREGC,
                                      FIELD_OUTPUT, PBIGCTX_ARG);

extern BOOL WINAPI Kbase_mul_ext(FIELD_INPUT, field_desc_tc*,
                                 FIELD_INPUT, FIELD_OUTPUT, field_desc_tc*,
                                 MP_MODIFIED, PBIGCTX_ARG);

extern BOOL WINAPI Kbase_to_ext_many(FIELD_INPUT, field_desc_tc*,
                                     FIELD_OUTPUT, DWORDREGC,
                                     field_desc_tc*, PBIGCTX_ARG);
extern BOOL WINAPI Kext_to_base_many(FIELD_INPUT, field_desc_tc*,
                                     FIELD_OUTPUT, DWORDREGC,
                                     field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI Kcopy_many(FIELD_INPUT, FIELD_OUTPUT,
                              DWORDREGC, field_desc_tc*, PBIGCTX_ARG);
extern BOOL WINAPI Kdiv(FIELD_INPUT, FIELD_INPUT, FIELD_OUTPUT,
                        field_desc_tc*, MP_MODIFIED, PBIGCTX_ARG);
extern BOOL WINAPI Kfree   (field_desc_t*, PBIGCTX_ARG);
extern BOOL WINAPI Kimmediate(sdigit_tc, FIELD_OUTPUT,
                              field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI Kinitialize_extension(field_desc_tc*, FIELD_INPUT,
                                         DWORDREGC, field_desc_t*, PBIGCTX_ARG);
extern BOOL WINAPI Kinitialize_normal2(DWORDREGC, DWORDREGC,
                                       field_desc_t*, PBIGCTX_ARG);
extern BOOL WINAPI Kinitialize_polynomial2(FIELD_INPUT, DWORDREGC,
                                   gf2_reduction_t*, field_desc_t*,
                                   PBIGCTX_ARG);
extern BOOL WINAPI Kinitialize_prime(mp_modulus_tc*, field_desc_t*,
                                     struct bigctx_t *,
                                     PBIGCTX_ARG);
extern BOOL WINAPI Kinvert(FIELD_INPUT, FIELD_OUTPUT,
                           field_desc_tc*, MP_MODIFIED, PBIGCTX_ARG);
extern BOOL WINAPI Kinvert_many(FIELD_INPUT, FIELD_OUTPUT,
                                DWORDREGC, field_desc_tc*,
                                MP_MODIFIED, PBIGCTX_ARG);

#define Kmul1998(f1, f2, f3, fdesc, ctx) \
        Kmul2000(f1, f2, f3, fdesc, digit_NULL, ctx)
#define Kmul2000(f1, f2, f3, fdesc, temps, ctx) Kmul_many((f1), (f2),\
                                           (f3), 1, (fdesc), (temps), ctx)
#define Kmul Kmul2000
// Old code may use Kmul with only four arguments (no temps).
// Those applications should   #undef Kmul  and   #define Kmul Kmul1998
// until the source code is converted.



extern BOOL WINAPI Kmul_many(FIELD_INPUT, FIELD_INPUT, FIELD_OUTPUT,
                             DWORDREGC, field_desc_tc*,
                             MP_MODIFIED, PBIGCTX_ARG);
extern BOOL WINAPI Kmuladd (FIELD_INPUT, FIELD_INPUT,
                          FIELD_INPUT, FIELD_OUTPUT,
                          field_desc_tc*, MP_MODIFIED, PBIGCTX_ARG);
extern BOOL WINAPI Kmulsub (FIELD_INPUT, FIELD_INPUT,
                          FIELD_INPUT, FIELD_OUTPUT,
                          field_desc_tc*, MP_MODIFIED, PBIGCTX_ARG);
extern BOOL WINAPI Kmulsubfrom(FIELD_INPUT, FIELD_INPUT, FIELD_INPUT,
                               FIELD_OUTPUT, field_desc_tc*,
                               MP_MODIFIED, PBIGCTX_ARG);
#define K2_quad1(f1, f3, fdesc, psuccess, ctx) \
                        ((fdesc)->arithmetic->quad1_solver) \
                         ((f1), (f3), 1, (fdesc), (psuccess), ctx)

#define Krandom_nonzero(f3, fdesc, ctx) \
            Krandom_nonzero_many((f3), 1, (fdesc), ctx)
extern BOOL WINAPI Krandom_nonzero_many(FIELD_OUTPUT, DWORDREGC,
                                        field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI K2n_normal_basis_exists(DWORDREGC,
                                           DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI Kprime_sqrter
        (digit_tc      *f1,        // IN
         digit_t       *f3,        // OUT
         DWORDREGC      nelmt,     // IN
         field_desc_tc *fdesc,     // IN
         BOOL          *psquares,  // OUT
         PBIGCTX_ARG);

#ifdef __cplusplus
}
#endif

#endif /* __FIELD_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\field.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "field.h"
#include "mprand.h"
#include "bigpriv.h"
/*
        This file (field.c) has the routines in field.h,
        for field arithmetic.
        Arithmetic is defined on GF(q) (q odd prime) or GF(2^m).
        GF(2^m) arithmetic can use normal or polynomial bases over GF(2)
        A field element is an array of type digit_t.

    Arithmetic routines (not necessarily on this file):

        Kadd(f1, f2, f3, &fdesc) -- f3 = f1 + f2
        Kdiv(f1, f2, f3, &fdesc, ftemps) -- f3 = f1 / f2
        Kequal (f1, f2,  &fdesc) -- Is f1 == f2?
        Kimmediate(scalar, f1, &fdesc) -- f1 = scalar (a long)
        Kinvert(f1, f2,  &fdesc, temps) -- f2 = 1/f1, temps supplied
        Kiszero(f1,      &fdesc) -- Is f1 == 0?
        Kmul1998(f1, f2, f3, &fdesc) -- f3 = f1 * f2
        Kmul2000(f1, f2, f3, &fdesc, temps) -- f3 = f1 * f2, temps supplied
        Kmuladd(f1, f2, f3, f4, &fdesc, ftemps) -- f4 = f1 * f2 + f3
        Kmulsub(f1, f2, f3, f4, &fdesc, ftemps) -- f4 = f1 * f2 - f3
        Kmulsubfrom(f1, f2, f3, f4, &fdesc, ftemps) -- f4 = f3 - f1 * f2
        Knegate(f1, f2,  &fdesc) -- f2 = -f1
        Ksub(f1, f2, f3, &fdesc) -- f3 = f1 - f2

    Miscellaneous routines:

        Kclear(f1, &fdesc)                -- Set one field element to zero
        Kclear_many(f1, nelmt,    &fdesc) -- Set nelmt elements to zero.
        Kcopy(f1, f2, &fdesc)             -- Copy one field element
                                             from f1 to f2.
        Kcopy_many(f1, f2, nelmt, &fdesc) -- Copy nelmt elements from f1 to f2
        Kfree  (&fdesc)                   -- Free any memory malloc-ed
                                             when field was initialized.
        Kinitialize_prime(&modulus, &modmultemps, &fdesc)
                                       -- Initialize field with prime modulus.
        Krandom     (f1, &fdesc)       -- Set f1 to random value
        Krandom_many(f1, nelmt,     &fdesc)
                                       -- Set f1 to random values (nelmt values)
        Krandom_nonzero(f1,    &fdesc) -- Set f1 to random nonzero element
*/



BOOL WINAPI Kcopy_many
        (digit_tc   *f1,       // Copy f1 to f2 (nelmt field elements)
         digit_t    *f2,
         DWORDREGC   nelmt,
         field_desc_tc *fdesc,
         PBIGCTX_ARG)
{
    PBIGCTX_UNUSED;  // mp_copy ignores last argument as of 2004
    mp_copy(f1, f2, nelmt * fdesc->elng, PBIGCTX_PASS);
    return TRUE;
} /* Kcopy_many */



BOOL WINAPI Kfdesc_initialize
        (field_desc_t *fdesc,                // OUT
         DWORDREGC     nalloc,               // IN
         PBIGCTX_ARG)
{
//   Initialize many fields of fdesc,
//   before those for the specific field type are set up by the caller.
//   fdesc->deallocate is set to an array of length nalloc digit_t entities.
//   This array is set to binary zero (not necessarily field zero).
//   For internal use only.

    BOOL OK = TRUE;

    if (fdesc->deallocate != digit_NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
             "Kfdesc_initialize -- fdesc->deallocate not NULL on entry",
             PBIGCTX_PASS);
    }

    if (OK) {
        MEMSET(fdesc, 0, SIZEOF(*fdesc));
                                          // In case something missed below

        fdesc->arithmetic = field_arithmetic_NULL;
        fdesc->base_field = field_desc_NULL;
        fdesc->degree = 0;
        fdesc->elng = 0;
        fdesc->freduc = gf2_reduction_NULL;
        fdesc->free_modulus = FALSE;
        fdesc->ftype = FIELD_TYPE_INVALID;
        fdesc->inverse_adjustment = digit_NULL;
        fdesc->leading_inverse = digit_NULL;
        fdesc->lng_mulshifts = 0;
        fdesc->mask_used_bits = RADIXM1;
        fdesc->minimal_polynomial = digit_NULL;
        fdesc->modulo = mp_modulus_NULL;
        fdesc->mulshifts = k2nmulshifts_NULL;
        fdesc->ndigtemps_mul = 0;
        fdesc->ndigtemps_invert1 = 0;
        fdesc->ndigtemps_arith = 0x12345678;
        fdesc->nonzero_trace_power = 0;
        fdesc->one = digit_NULL;
        fdesc->T = 0;
        fdesc->unused_bits_top = 0;
    }
    if (OK && nalloc != 0) {
        fdesc->deallocate = digit_allocate(nalloc,
                                           "Kfdesc_initialize",
                                           PBIGCTX_PASS);
        if (fdesc->deallocate == digit_NULL) {
            OK = FALSE;
        } else {
            mp_clear(fdesc->deallocate, nalloc, PBIGCTX_PASS);
        }
    }
    return OK;
} // Kfdesc_initialize



BOOL WINAPI Kfree(field_desc_t *fdesc, PBIGCTX_ARG)
/*
   Free any parts of a field descriptor
   which may have been malloc-ed.
*/
{
    BOOL OK = TRUE;

    if (fdesc->ftype == FIELD_TYPE_INVALID) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "Kfree -- argument does not point to active field",
                        PBIGCTX_PASS);
    }

    OK = OK && (fdesc->arithmetic->freer)(fdesc, PBIGCTX_PASS);
                  // Anything dependent on ftype

    if (OK && fdesc->deallocate != digit_NULL) {
        Free_Temporaries(fdesc->deallocate, PBIGCTX_PASS);
        fdesc->deallocate = digit_NULL;
    }

    fdesc->arithmetic = field_arithmetic_NULL;
    fdesc->ftype = FIELD_TYPE_INVALID;
    return OK;
} // end Kfree




BOOL WINAPI Kimmediate
        (sdigit_tc scalar,  // Cast a scalar to an element of the field
         digit_t *f3,
         field_desc_tc *fdesc,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;

    OK = OK && Kimmediate_many(&scalar, f3, 1, fdesc, PBIGCTX_PASS);
                                // Treat as one-element array
    return OK;
} /* Kimmediate */



BOOL WINAPI Kmul_many
        (digit_tc *f1,     // Set f3 = f1 * f2
         digit_tc *f2,
         digit_t  *f3,
         DWORDREGC nelmt,
         field_desc_tc *fdesc,
         digit_t  *supplied_temps,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    digit_tempinfo_t tempinfo;
    DWORDREG i;
    DWORDREGC elng = fdesc->elng;

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = fdesc->ndigtemps_mul;
    tempinfo.need_to_free = FALSE;

         // Use user array if supplied.
         // Otherwise allocate our own, if ndigtemps_mul <> 0.

    OK = OK && possible_digit_allocate(&tempinfo, "Kmul_many", PBIGCTX_PASS);

    for (i = 0; OK && i != elng*nelmt; i += elng) {
        OK = OK && (fdesc->arithmetic->multiplier1)(f1 + i, f2 + i, f3 + i,
            fdesc, tempinfo.address, PBIGCTX_PASS);
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }

#if PRINT_ERROR_MESSAGES
    if (!OK) {
       fprintf(mp_errfil, "Kmul2000 error, ftype = %ld,"
                         " elng = %ld, degree = %ld,"
                         " ndigtemps = %ld, supplied_temps = %p\n",
                         (long)fdesc->ftype, (long)fdesc->elng,
                         (long)fdesc->degree, (long)fdesc->ndigtemps_mul,
                         supplied_temps);
    }
#endif
    return OK;
} /* Kmul2000 */


BOOL WINAPI Kadder_2
        (digit_tc   *f1,
         digit_tc   *f2,
         digit_t    *f3,
         DWORDREGC   nelmt,
         field_desc_tc *fdesc,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    DWORDREG i;
    DWORDREGC ibound = nelmt*fdesc->elng;

    if (!CHARACTERISTIC_2(fdesc)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "Kadder_2 -- not characteristic 2",
                        PBIGCTX_PASS);
    }
    for (i = 0; OK && i != ibound; i++) {
        f3[i] = f1[i] ^ f2[i];
    }
    return OK;
} // end Kadder_2


BOOL WINAPI Kequaler_default
        (digit_tc      *f1,
         digit_tc      *f2,        // Is f1 == f2?
         DWORDREGC      nelmt,
         field_desc_tc *fdesc,
         PBIGCTX_ARG)
/*
     Test two arrays of field elements for equality, assuming
     each field element has a unique binary representaiton.
*/
{
    PBIGCTX_UNUSED;
    return (compare_same(f1, f2, nelmt * fdesc->elng) == 0);
} /* Kequaler_default */


BOOL WINAPI Kimmediater_2
        (sdigit_tc  *scalars,
         digit_t    *f3,
         DWORDREGC   nelmt,
         field_desc_tc *fdesc,
         PBIGCTX_ARG)
/*
       Convert a signed digit_t value
       (usually a 32-bit signed integer)
       to a field element.  Even values map to 0.
       Odd values map to 1.
*/
{
    BOOL OK = TRUE;
    DWORDREG i;
    DWORDREGC elng = fdesc->elng;

    if (!CHARACTERISTIC_2(fdesc)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "Kimmediater_2 -- not characteristic 2",
                        PBIGCTX_PASS);
    }
    for (i = 0; OK && i != nelmt; i++) {
        digit_tc parity = 1 & (digit_t)scalars[i];
        digit_t *f3addr = f3 + i*elng;

        if (parity == 0) {
            OK = OK && Kclear(f3addr, fdesc, PBIGCTX_PASS);
        } else {
            OK = OK && Kcopy(fdesc->one, f3addr, fdesc, PBIGCTX_PASS);
        }
    }
    return OK;
} // end Kimmediater_2



BOOL WINAPI Kiszeroer_default
        (digit_tc *f1,   // Is f1 == 0?
         DWORDREGC nelmt,
         field_desc_tc *fdesc,
         PBIGCTX_ARG)
/*
     Test an array of field elements for zero, assuming the only
     zero field element is a binary zero.
*/
{
    PBIGCTX_UNUSED;
    return all_zero(f1, nelmt * fdesc->elng);
} /* Kiszeroer_default */


BOOL WINAPI Kmulpower2er_2
        (digit_tc      *f1,
         const int      ishift,
         digit_t       *f3,        // OUT
         DWORDREGC      nelmt,
         field_desc_tc *fdesc,
         PBIGCTX_ARG)
/*
      Multiply field elements in f1 by 2^ishift,
      store results in f3.
*/
{
    BOOL OK = TRUE;

    if (!CHARACTERISTIC_2(fdesc)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "Kmulpower2er_2 -- not characteristic 2",
                        PBIGCTX_PASS);
    } else if (ishift < 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                "Kmulpower2er_2 -- right shift illegal in characteristic 2",
                PBIGCTX_PASS);
    } else if (ishift == 0) {
        OK = OK && Kcopy_many(f1, f3, nelmt, fdesc, PBIGCTX_PASS);
    } else {    // ishift > 1
        OK = OK && Kclear_many(f3, nelmt, fdesc, PBIGCTX_PASS);
    }
    return OK;
}  // end Kmulpower2er_2



BOOL WINAPI Krandomizer_2
        (digit_t   *f3,
         DWORDREGC  nelmt,
         field_desc_tc *fdesc,
         PBIGCTX_ARG)
/*
       This sets nelmt field elements to random values.
       We assume the field elements occupy
       an exact number of bits, as in the case of
       GF(2^m) (normal or polynomial basis).
*/
{
    DWORDREGC elng = fdesc->elng;
    DWORDREGC ibound = nelmt * elng;
    BOOL OK = CHARACTERISTIC_2(fdesc);
    DWORDREG i;

    if (!CHARACTERISTIC_2(fdesc)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "Krandomizer_2 -- not characteristic 2",
                        PBIGCTX_PASS);
    }
    OK = OK && random_digits(f3, ibound, PBIGCTX_PASS);

    for (i = 0; OK && i != ibound; i += elng) {
        f3[i + elng - 1] &= fdesc->mask_used_bits;
                                    // Ensure upper bits are zeros.
    }
    return OK;
} // end Krandomizer_2



BOOL WINAPI Ksizer_2(digit_t *size,
                     field_desc_tc *fdesc,
                     PBIGCTX_ARG)
//
//    Return the size of a field GF(2^m), polynomial or normal basis.
//    The output has length elng + 1.
{
    BOOL OK = TRUE;
    DWORDREGC deg = fdesc->degree;
    DWORDREGC elng = fdesc->elng;

    if (!CHARACTERISTIC_2(fdesc)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "Ksizer_2 -- not characteristic 2", PBIGCTX_PASS);
    } else {
        mp_clear(size, elng+1, PBIGCTX_PASS);
        mp_setbit(size, deg, 1, PBIGCTX_PASS);      // size = 2^deg
    }
    return OK;
} // end Ksizer_2



BOOL WINAPI Kzeroizer_default
        (digit_t    *f3,
         DWORDREGC   nelmt,
         field_desc_tc *fdesc,
         PBIGCTX_ARG)
/*
       This zeros an array of field elements in the
       usual case where the binary zero is also a field zero.
*/
{
    BOOL OK = TRUE;
    PBIGCTX_UNUSED;
    mp_clear(f3, nelmt*fdesc->elng, PBIGCTX_PASS);
    return OK;
} // end Kzeroizer_default
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\fieldpriv.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
      File fieldpriv.h.   Version 20 September 2002

      Declarations for field routines which the application program
      doesn't need to know about.
*/

#ifndef __FIELDPRIV_H
#define __FIELDPRIV_H 1
#include "bigpriv.h"
#include "field.h"


/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif


//   The following routines are for internal use only

extern DWORDREG WINAPI GF2_mod_mul_temps(DWORDREGC, PBIGCTX_ARG);

typedef struct {
        int      sign;      //  +1 or -1
        digit_tc *mul1;
        digit_tc *mul2;
} Kdot_operand_t;           // Operand for Kdot

typedef const Kdot_operand_t Kdot_operand_tc;

extern BOOL WINAPI Kadder_2(FIELD_INPUT, FIELD_INPUT, FIELD_OUTPUT,
                            DWORDREGC, field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI Kdot    (Kdot_operand_tc*, DWORDREGC, FIELD_OUTPUT,
                            field_desc_tc*, MP_MODIFIED, PBIGCTX_ARG);

extern BOOL WINAPI K2_expon(FIELD_INPUT, MP_INPUT,
                            DWORDREGC, FIELD_OUTPUT,
                            field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI Kequaler_default (FIELD_INPUT, FIELD_INPUT,
                                     DWORDREGC, field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI Kexponentiator1_default(FIELD_INPUT, MP_INPUT, DWORDREGC,
                                    FIELD_OUTPUT, field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI Kfdesc_initialize(field_desc_t*, DWORDREGC, PBIGCTX_ARG);

extern BOOL WINAPI Kimmediater_2(sdigit_tc*, FIELD_OUTPUT,
                                 DWORDREGC, field_desc_tc*, PBIGCTX_ARG);
extern BOOL WINAPI Kiszeroer_default(FIELD_INPUT, DWORDREGC,
                                     field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI Kmulpower2er_2
                          (FIELD_INPUT, const int, FIELD_OUTPUT,
                           DWORDREGC, field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI KPgcd_helper(FIELD_INPUT   f1,
                         FIELD_INPUT   f2,
                         DWORDREGC     lngf1,
                         DWORDREGC     lngf2,
                         FIELD_OUTPUT  gcd,
                         DWORDREG     *lnggcd,     // OUT
                         FIELD_OUTPUT  f1mulby,
                         FIELD_OUTPUT  f2mulby,
                         field_desc_tc *fdesc,
                         MP_MODIFIED   temps,
                         PBIGCTX_ARG);

extern BOOL WINAPI KPgcd_helper_space
        (DWORDREGC    lngf1,
         DWORDREGC    lngf2,
         const BOOL   need_f1mulby,
         const BOOL   need_f2mulby,
         field_desc_tc *fdesc,
         DWORDREG      *pneed,     // OUT
         PBIGCTX_ARG);


extern BOOL WINAPI Krandomizer_2(FIELD_OUTPUT, DWORDREGC,
                                 field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI Ksizer_2(MP_OUTPUT, field_desc_tc*, PBIGCTX_ARG);

extern BOOL WINAPI Kzeroizer_default(FIELD_OUTPUT, DWORDREGC,
                                     field_desc_tc*, PBIGCTX_ARG);


#ifdef __cplusplus
}
#endif

#endif /* __FIELDPRIV_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\ecurve.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#ifndef ECURVE_H
#define ECURVE_H 1
#include "bignum.h"
#include "field.h"

/* For C++ */
#ifdef __cplusplus
extern "C" {
#endif

//
//           This file (ecurve.h) has definitions for
//       elliptic curve operations.


//           Over a field GF(q), where q > 3 is prime,
//       an elliptic curve is all points (x, y) in GF(q) x GF(q)
//       satisfying the Weierstrass equation
//
//                y^2 = x^3 + ax + b,          (4a^3 + 27 b^2 != 0)
//
//       plus a point at infinity.  The points form an abelian group
//       under a well-known addition rule.
//
//           Over GF(2^m), the curve is instead
//
//                 y^2 + xy = x^3 + ax^2 + b   (b != 0)

//       Fields a and b of the struct should have length
//       elng = fdesc->elng.
//       generator should have length 2*elng or be digit_NULL.
//       gorder, the order of generator, should be have length
//       elng+1 or be digit_NULL.

//       Field deallocate is the address to pass to free
//       (unless it is digit_NULL) when the curve becomes inactive.

// Points are usually in affine form, with only x and y.
// When b <> 0,  the point at infinity has x = y = 0.
// When b = 0, the point at infinity has x = 0 and y = 1.
// fdesc.elng digit_t words are used for each of x and y,
// with no gap between them.

typedef digit_t ecaffine_t;
typedef const ecaffine_t ecaffine_tc;

#define AFFINE_INPUT ecaffine_tc*
#define AFFINE_OUTPUT ecaffine_t*

Future_Struct(ecurve_t);
#define CURVE_INPUT const struct ecurve_t*
#define CURVE_OUTPUT struct ecurve_t*

typedef BOOL WINAPI ec_exponentiation_t(AFFINE_INPUT, MP_INPUT, DWORDREGC,
                                        AFFINE_OUTPUT, CURVE_INPUT,
                                        PBIGCTX_ARG);

#define ec_exponentiation_NULL ((ec_exponentiation_t*)0)


typedef struct ecurve_t {
             field_desc_tc     *fdesc;
             digit_t           *a;
             digit_t           *b;
             ecaffine_t        *generator;  // Generator of cyclic group
                                            // (affine form, x and y)
             digit_t           *gorder;     // Order of cyclic group
             digit_t           *deallocate;
             ec_exponentiation_t *fexpon;   // Special exponentiation code
                                            // Used for Koblitz curves
             BOOL               free_field; // Flag telling ec_free to call
                                            // Kfree.  For system use only.
             BOOL               biszero;    // Is b == 0?
             DWORDREG           ndigtemps;  // Number of digit_t temporaries
                                            // needed by EC
                                            // addition/subtraction routines:
                                            //
                                            //     ecaffine_addition
                                            //     ecaffine_addition_subtraction
                                            //     ecaffine_line_through
                                            //     ecaffine_on_curve
                                            //     ecaffine_PPQ
                                            //     ecaffine_random
                                            //
                                            // Includes enough for a
                                            // multiplication or inversion
                                            // (or Kmuladd, etc.)
                                            // in the base field.
             DWORDREG           lnggorder;  // Number of significant words
                                            // in *gorder, if not digit_NULL.
             reciprocal_1_t     grecip;     // Reciprocal for gorder
               } ecurve_t;

typedef const ecurve_t ecurve_tc;

/*
     Some elliptic curves are predefined, typically because
     they appear in a standards document.
     Use ec_useNIST to access these.
*/

exportable_var const struct ec_NIST_t ec_NIST_B163;
exportable_var const struct ec_NIST_t ec_SECT163R1;
exportable_var const struct ec_NIST_t ec_NIST_B233;
exportable_var const struct ec_NIST_t ec_NIST_B283;
exportable_var const struct ec_NIST_t ec_NIST_B409;
exportable_var const struct ec_NIST_t ec_NIST_B571;

exportable_var const struct ec_NIST_t ec_NIST_K163;
exportable_var const struct ec_NIST_t ec_NIST_K233;
exportable_var const struct ec_NIST_t ec_NIST_K283;
exportable_var const struct ec_NIST_t ec_NIST_K409;
exportable_var const struct ec_NIST_t ec_NIST_K571;

exportable_var const struct ec_NIST_t ec_NIST_P192;
exportable_var const struct ec_NIST_t ec_NIST_P224;
exportable_var const struct ec_NIST_t ec_NIST_P256;
exportable_var const struct ec_NIST_t ec_NIST_P384;
exportable_var const struct ec_NIST_t ec_NIST_P521;

exportable_var const struct ec_NIST_t ec_WTLS_1;
          /* As of June, 2000, there is no ec_WTLS_2 */
#define ec_WTLS_3 ec_NIST_K163
exportable_var const struct ec_NIST_t ec_WTLS_4;
exportable_var const struct ec_NIST_t ec_WTLS_5;
exportable_var const struct ec_NIST_t ec_WTLS_6;
exportable_var const struct ec_NIST_t ec_WTLS_7;
exportable_var const struct ec_NIST_t ec_WTLS_8;
exportable_var const struct ec_NIST_t ec_WTLS_9;


extern BOOL WINAPI ecaffine_addition
      (AFFINE_INPUT, AFFINE_INPUT, AFFINE_OUTPUT,
       const int, CURVE_INPUT, MP_MODIFIED, PBIGCTX_ARG);

extern BOOL WINAPI ecaffine_addition_subtraction
      (AFFINE_INPUT, AFFINE_INPUT, AFFINE_OUTPUT,
       AFFINE_OUTPUT, CURVE_INPUT, MP_MODIFIED, PBIGCTX_ARG);

#define ecaffine_copy(p1, p2, E, ctx) \
            (Kcopy_many((p1), (p2), 2, (E)->fdesc, ctx))

#define ecaffine_equal(p1, p2, E, ctx) \
            (Kequal_many((p1), (p2), 2, (E)->fdesc, ctx))

extern BOOL WINAPI ecaffine_exponentiation1998
          (AFFINE_INPUT, MP_INPUT, DWORDREGC, AFFINE_OUTPUT,
           CURVE_INPUT, PBIGCTX_ARG);

#define ecaffine_exponentiation2001 ecaffine_exponentiation
extern BOOL WINAPI ecaffine_exponentiation
          (AFFINE_INPUT, MP_INPUT, DWORDREGC, AFFINE_OUTPUT,
           CURVE_INPUT, PBIGCTX_ARG);

extern BOOL WINAPI ecaffine_is_infinite(AFFINE_INPUT, CURVE_INPUT, PBIGCTX_ARG);

extern BOOL WINAPI ecaffine_line_through(AFFINE_INPUT, AFFINE_INPUT,
               AFFINE_OUTPUT, FIELD_OUTPUT, CURVE_INPUT,
               MP_MODIFIED, PBIGCTX_ARG);

extern BOOL WINAPI ecaffine_multiply_pm1
          (AFFINE_INPUT, AFFINE_OUTPUT, const int, CURVE_INPUT, PBIGCTX_ARG);

extern BOOL WINAPI ecaffine_negate(AFFINE_INPUT, AFFINE_OUTPUT,
                                   CURVE_INPUT, PBIGCTX_ARG);

extern BOOL WINAPI ecaffine_on_curve(AFFINE_INPUT, CURVE_INPUT,
                                     const char*, MP_MODIFIED, PBIGCTX_ARG);

extern BOOL WINAPI ecaffine_PPQ(AFFINE_INPUT, AFFINE_INPUT,
                                AFFINE_OUTPUT, const int,
                                CURVE_INPUT, MP_MODIFIED, PBIGCTX_ARG);

extern BOOL WINAPI ecaffine_random(AFFINE_OUTPUT, CURVE_INPUT,
                                   MP_MODIFIED, PBIGCTX_ARG);

extern BOOL WINAPI ecaffine_set_infinite(AFFINE_OUTPUT,
                                         CURVE_INPUT, PBIGCTX_ARG);

extern BOOL WINAPI ec_initialize(FIELD_INPUT, FIELD_INPUT,
                                field_desc_tc*, CURVE_OUTPUT, PBIGCTX_ARG, struct bigctx_t*);

extern BOOL WINAPI ec_free(CURVE_OUTPUT, PBIGCTX_ARG);     // IN/OUT

extern BOOL WINAPI ec_useNIST(const struct ec_NIST_t*,
                              CURVE_OUTPUT, PBIGCTX_ARG);


// The next two are not supported as of April, 2002


EXTERN_INLINE BOOL WINAPI ecaffine_exponentiation_tabular
          (AFFINE_INPUT, DWORDREGC, DWORDREGC, MP_INPUT,
           DWORDREGC, AFFINE_OUTPUT, CURVE_INPUT, PBIGCTX_ARG);

extern BOOL WINAPI ecaffine_table_construction(AFFINE_INPUT, DWORDREGC,
                                               DWORDREGC, AFFINE_OUTPUT,
                                               CURVE_INPUT, PBIGCTX_ARG);

#ifdef __cplusplus
}
#endif

#endif // ECURVE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\kmuladd.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
       File kmuladd.c. Version  10 April 2002
*/
#include "fieldpriv.h"

BOOL WINAPI Kmuladd
        (digit_tc *f1,     // Set f4 = f1 * f2 + f3
         digit_tc *f2,
         digit_tc *f3,
         digit_t  *f4,
    field_desc_tc *fdesc,
         digit_t  *supplied_temps,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    DWORDREGC elng = fdesc->elng;
    digit_tempinfo_t tempinfo;

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = elng + fdesc->ndigtemps_mul;
    tempinfo.need_to_free = FALSE;

    OK = OK && possible_digit_allocate(&tempinfo, "Kmuladd", PBIGCTX_PASS);

    if (OK) {
        digit_t *prod = tempinfo.address;
        digit_t *ftemps = prod + elng;

        OK = OK && Kmul2000(f1, f2, prod, fdesc, ftemps, PBIGCTX_PASS);
        OK = OK && Kadd(prod, f3, f4, fdesc, PBIGCTX_PASS);
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }
    return OK;
} /* Kmuladd */


BOOL WINAPI Kmulsub
        (digit_tc *f1,     // Set f4 = f1 * f2 - f3
         digit_tc *f2,
         digit_tc *f3,
         digit_t  *f4,
    field_desc_tc *fdesc,
         digit_t  *supplied_temps,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    DWORDREGC elng = fdesc->elng;
    digit_tempinfo_t tempinfo;

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = elng + fdesc->ndigtemps_mul;
    tempinfo.need_to_free = FALSE;

    OK = OK && possible_digit_allocate(&tempinfo, "Kmulsub", PBIGCTX_PASS);

    if (OK) {
        digit_t *prod = tempinfo.address;
        digit_t *ftemps = prod + elng;

        OK = OK && Kmul2000(f1, f2, prod, fdesc, ftemps, PBIGCTX_PASS);
        OK = OK && Ksub(prod, f3, f4, fdesc, PBIGCTX_PASS);
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }
    return OK;
} /* Kmulsub */


BOOL WINAPI Kmulsubfrom
        (digit_tc *f1,     // Set f4 = f3 - f1 * f2
         digit_tc *f2,
         digit_tc *f3,
         digit_t  *f4,
         field_desc_tc *fdesc,
         digit_t  *supplied_temps,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    DWORDREGC elng = fdesc->elng;
    digit_tempinfo_t tempinfo;

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = elng + fdesc->ndigtemps_mul;
    tempinfo.need_to_free = FALSE;

    OK = OK && possible_digit_allocate(&tempinfo, "Kmulsubfrom", PBIGCTX_PASS);

    if (OK) {
        digit_t *prod = tempinfo.address;
        digit_t *ftemps = prod + elng;

        OK = OK && Kmul2000(f1, f2, prod, fdesc, ftemps, PBIGCTX_PASS);
        OK = OK && Ksub(f3, prod, f4, fdesc, PBIGCTX_PASS);
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }
    return OK;
} /* Kmulsubfrom */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\kinvert.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
     File kinvert.c.    Version 08 March 2002
*/
#include "fieldpriv.h"

BOOL WINAPI Kinvert
        (digit_tc *f1,
         digit_t  *f3,     // OUT
         field_desc_tc *fdesc,
         digit_t  *supplied_temps,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    digit_tempinfo_t tempinfo;

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = fdesc->ndigtemps_invert1;
    tempinfo.need_to_free = FALSE;

    if (OK && Kiszero(f1, fdesc, PBIGCTX_PASS)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_DIVIDE_ZERO, "Kinvert", PBIGCTX_PASS);
    }
    OK = OK && possible_digit_allocate(&tempinfo, "Kinvert", PBIGCTX_PASS);

    OK = OK && (fdesc->arithmetic->inverter1)(f1, f3, fdesc, &tempinfo,
                                              PBIGCTX_PASS);

    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }
    return OK;
} // end Kinvert


BOOL WINAPI Kinvert_many
        (digit_tc *f1,
         digit_t  *f3,     // OUT
         DWORDREGC   nelmt,
         field_desc_tc *fdesc,
         digit_t  *supplied_temps,
         PBIGCTX_ARG)
/*
        Compute f3[i] = 1/f1[i] for 0 <= i < nelmt.
        When nelmt > 1, the f1 and f3 arrays are not allowed to overlap.

        We use the identities 1/x = y*(1/(x*y)) and 1/y = x*(1/(x*y))
        to exchange all but one inversion for three multiplications.

        If the temporaries array is supplied, it must have length
        at least fdesc->ndigtemps_arith .
*/
 {
    DWORDREGC elng = fdesc->elng;
    BOOL OK = TRUE;
    digit_tempinfo_t tempinfo, tempinfo2;

    if (nelmt == 0) return OK;
    if (nelmt > 1 && f1 == f3) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_OVERLAPPING_ARGS,
                        "Kinvert_many -- Arrays overlap, nelmt > 1",
                        PBIGCTX_PASS);
    }

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = fdesc->ndigtemps_arith;
                    // Field element ftemp
                    // Temporaries for Kinvert and Kmul2000
    tempinfo.need_to_free = FALSE;

    OK = OK && possible_digit_allocate(&tempinfo, "Kinvert_many", PBIGCTX_PASS);

    if (OK) {
/*
                 Suppose the f1 has nelmt = 4 values a0, a1, a2, a3.
                 Successively store the following in f3 and ftemp

             f3[0]       f3[1]       f3[2]      f3[3]         ftemp

               a0
                         a0*a1
                                     a0*a1*a2
                                               a0*a1*a2*a3
                                                             (a0*a1*a2*a3)^(-1)
                                                  a3^(-1)    (a0*a1*a2)^(-1)
                                      a2^(-1)                (a0*a1)^(-1)
                          a1^(-1)                            a0^(-1)
              a0^(-1)

                  We use the identities 1/x = y*(1/(x*y)) and 1/y = x*(1/(x*y))
                  to exchange all but one inversion for three multiplications.

                  When nelmt = 1, we allow f1 == f3 (i.e., same array).
                  The copy of a0 from f1 to f3 becomes a no-op.
*/
        DWORDREG i;
        digit_t *ftemp = tempinfo.address;  // Length elng
        digit_t *ftemps = ftemp + elng;  // Length MAX(fdesc->ndigtemps_mul,
                                         //            fdesc->ndigtemps_invert1)

        OK = OK && Kcopy(f1, f3, fdesc, PBIGCTX_PASS);

        for (i = elng; OK && i != nelmt*elng; i += elng) {
                                           // CAUTION -- index variable used
                                           // after loop exit

            OK = OK && Kmul2000(f1 + i, f3 + i - elng, f3 + i,
                                fdesc, ftemps, PBIGCTX_PASS);
                     // Store partial products in f3
        }

        i -= elng;     // (nelmt - 1)*elng

        if (!OK) {
        } else if (Kiszero(f3 + i, fdesc, PBIGCTX_PASS)) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_NOT_INVERTIBLE,
                            "Kinvert_many",
                            PBIGCTX_PASS);
        } else {
            tempinfo2.need_to_free = FALSE;
            tempinfo2.address = ftemps;
            tempinfo2.nelmt = fdesc->ndigtemps_invert1;

            OK = OK && (fdesc->arithmetic->inverter1)(f3 + i, ftemp,
                                              fdesc, &tempinfo2, PBIGCTX_PASS);
                           // Invert product of everything

            while (i != 0) {
                OK = OK && Kmul2000(ftemp, f3 + i - elng,
                                    f3 + i, fdesc, ftemps, PBIGCTX_PASS);
                OK = OK && Kmul2000(ftemp, f1 + i, ftemp, fdesc,
                                    ftemps, PBIGCTX_PASS);
                i -= elng;
           } // while

           OK = OK && Kcopy(ftemp, f3, fdesc, PBIGCTX_PASS);
        }
    } // if OK

    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }
    return OK;
} // end Kinvert_many
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\kinitpr.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
/*
       File kinitpr.c.   Version 03 October 2002.

       Routines for fields GF(p), p prime.
*/

#include "fieldpriv.h"
#include "mprand.h"

#ifndef assert
#include <assert.h>
#endif


#if PRINT_ERROR_MESSAGES
static BOOL WINAPI Kprime_truly
        (field_desc_tc  *fdesc,        // IN
         const char     *caller,       // IN
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    if (   fdesc->base_field != field_desc_NULL
        || fdesc->ftype != FIELD_Q_MP) {
         OK = FALSE;
         SetMpErrno_clue(MP_ERRNO_INVALID_DATA, caller, PBIGCTX_PASS);
    }
    return OK;
} // end Kprime_truly
#else
#define Kprime_truly(fdesc, caller, ctx) TRUE
#endif



static BOOL WINAPI Kprime_adder
        (digit_tc      *f1,           // IN
         digit_tc      *f2,           // IN
         digit_t       *f3,           // OUT
         DWORDREGC      nelmt,        // IN
         field_desc_tc *fdesc,        // IN
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;

    OK = OK && Kprime_truly(fdesc, "Kprime_adder", PBIGCTX_PASS);

    if (OK) {
        DWORDREG i;
        DWORDREGC elng = fdesc->elng;

        for (i = 0; OK && i != nelmt*elng; i += elng) {
            OK = OK && mod_add(f1 + i, f2 + i, f3 + i,
                               fdesc->modulo, PBIGCTX_PASS);
        }
    }
    return OK;
}  // Kprime_adder


static BOOL WINAPI Kprime_exponentiator1
        (digit_tc      *f1,               // IN
         digit_tc      *exponent,         // IN
         DWORDREGC      lng_exponent,     // IN
         digit_t       *f2,               // OUT
         field_desc_tc *fdesc,            // IN
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;

    OK = OK && Kprime_truly(fdesc, "Kprime_exponentiator1", PBIGCTX_PASS);
    OK = OK && mod_exp(f1, exponent, lng_exponent, f2,
                       fdesc->modulo, PBIGCTX_PASS);
    return OK;
} // Kprime_exponentiator1


static BOOL WINAPI Kprime_freer
        (field_desc_t *fdesc,            // IN/OUT
        PBIGCTX_ARG)
{
    BOOL OK = TRUE;

    OK = OK && Kprime_truly(fdesc, "Kprime_freer", PBIGCTX_PASS);

    if (    OK
         && fdesc->free_modulus
         && fdesc->modulo != mp_modulus_NULL) {
         uncreate_modulus((mp_modulus_t*)fdesc->modulo, PBIGCTX_PASS);
                                             // Remove const attribute
        Free_Temporaries((mp_modulus_t*)fdesc->modulo, PBIGCTX_PASS);
        fdesc->free_modulus = FALSE;
        fdesc->modulo = mp_modulus_NULL;
    }
    return OK;
} // Kprime_freer



static BOOL WINAPI Kprime_immediater
        (sdigit_tc *scalars,               // IN
         digit_t   *f3,                    // OUT
         DWORDREGC  nelmt,                 // IN
         field_desc_tc *fdesc,             // OUT
         PBIGCTX_ARG)
/*
       Convert a signed digit_t value
       (usually a 32-bit signed integer)
       to a field element.

       N.B.  fdesc->one is available to convert a 1.
*/

{
    BOOL OK = TRUE;
    DWORDREG i;
    DWORDREGC elng = fdesc->elng;

    OK = OK && Kprime_truly(fdesc, "Kprime_immediater", PBIGCTX_PASS);

    for (i = 0; OK && i != nelmt; i++) {
        sdigit_tc scalar = scalars[i];
        digit_tc abssc = (digit_t)(scalar >= 0 ? scalar : -scalar);
        digit_t* f3addr = f3 + i*elng;

        OK = OK && to_modular(&abssc, 1, f3addr, fdesc->modulo, PBIGCTX_PASS);
        if (scalar < 0) {
            OK = OK && mod_negate(f3addr, f3addr, fdesc->modulo, PBIGCTX_PASS);
        }
    }
    return OK;
} // end Kprime_immediater


static BOOL WINAPI Kprime_inverter1
        (digit_tc           *f1,        // IN
         digit_t            *f3,        // OUT
         field_desc_tc      *fdesc,     // IN
         digit_tempinfo_tc  *tempinfo,  // IN
         PBIGCTX_ARG)
//
//     Invert one field element f3 = 1/f1.
//     f1 is guaranteed nonzero.

{
    DWORDREGC elng = fdesc->elng;
    digit_t *ftemp = tempinfo->address;   // Length elng
    digit_t *ftemps = ftemp + elng;       // Length MAX(fdesc->ndigtemps_mul,
                                          //            mp_invert_ntemps(elng))
    digit_tc *finp = f1;   // Tentative input location
    mp_modulus_tc *modulo = fdesc->modulo;
    BOOL OK = TRUE;

    OK = OK && Kprime_truly(fdesc, "", PBIGCTX_PASS);

    assert (   tempinfo->address + tempinfo->nelmt
            == ftemps + MAX(fdesc->ndigtemps_mul,
                            mp_invert_ntemps(elng, PBIGCTX_PASS)));

    if (OK && modulo->reddir == FROM_RIGHT) {
        OK = OK && Kmul2000(finp, fdesc->inverse_adjustment,
                            ftemp, fdesc, ftemps, PBIGCTX_PASS);
        finp = ftemp;
    }
    OK = OK && mp_invert(finp, modulo->modulus, elng,
                        f3, "", ftemps, PBIGCTX_PASS);
    return OK;
} // end Kprime_inverter1



static BOOL WINAPI Kprime_mulpower2er
        (digit_tc      *f1,        // IN
         const int      ishift,    // IN
         digit_t       *f3,        // OUT
         DWORDREGC      nelmt,     // IN
         field_desc_tc *fdesc,     // IN
         PBIGCTX_ARG)
/*
      Multiply field elements in f1 by 2^ishift,
      store results in f3.
*/
{
    BOOL OK = TRUE;
    DWORDREGC elng = fdesc->elng;
    DWORDREG i;

    for (i = 0; i != nelmt*elng; i += elng) {
        OK = OK && mod_shift(f1 + i, ishift, f3 + i,
                             fdesc->modulo, PBIGCTX_PASS);
    }
    return OK;
}  // end Kmulpower2er_2


static BOOL WINAPI Kprime_multiplier1
        (digit_tc      *f1,     // IN
         digit_tc      *f2,     // IN
         digit_t       *f3,     // OUT
         field_desc_tc *fdesc,  // IN
         digit_t       *temps,  // IN
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;

    OK = OK && Kprime_truly(fdesc, "Kprime_multiplier1", PBIGCTX_PASS);
    OK = OK && mod_mul(f1, f2, f3, fdesc->modulo, temps, PBIGCTX_PASS);
    return OK;
} // end Kprime_multiplier1


static BOOL WINAPI Kprime_negater
        (digit_tc      *f1,        // IN
         digit_t       *f3,        // OUT
         DWORDREGC      nelmt,     // IN
         field_desc_tc *fdesc,     // IN
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;

    OK = OK && Kprime_truly(fdesc, "Kprime_negater", PBIGCTX_PASS);

    if (OK) {
        DWORDREG i;
        DWORDREGC elng = fdesc->elng;

        for (i = 0; OK && i != nelmt*elng; i += elng) {
            OK = OK && mod_negate(f1 + i, f3 + i, fdesc->modulo, PBIGCTX_PASS);
        }  // for i
    }
    return OK;
}  // Kprime_negater


static BOOL WINAPI Kprime_quad1_solver
        (digit_tc      *f1,                  // IN
         digit_t       *f3,                  // OUT
         DWORDREGC      nelmt,               // IN
         field_desc_tc *fdesc,               // IN
         BOOL          *pall_successful,     // OUT
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;

    (void)f1; (void)f3;  (void)nelmt;  (void)fdesc;   (void)pall_successful;
                       // Avoid warnings for unused arguments
    OK = FALSE;
    SetMpErrno_clue(MP_ERRNO_NOT_IMPLEMENTED,
                    "Kquad1_solver for GF(p)",
                    PBIGCTX_PASS);
    return OK;
} // end Kprimequad1_solver


static BOOL WINAPI Kprime_randomizer
        (digit_t       *f3,         // OUT
         DWORDREGC      nelmt,      // IN
         field_desc_tc *fdesc,      // IN
         PBIGCTX_ARG)
{
    DWORDREG i;
    DWORDREGC elng = fdesc->elng;
    BOOL OK = TRUE;

    OK = OK && Kprime_truly(fdesc, "Kprime_randomizer", PBIGCTX_PASS);

    for (i = 0; OK && i != nelmt*elng; i += elng) {
        OK = OK && random_mod(fdesc->modulo->modulus,
                              f3 + i, elng, PBIGCTX_PASS);
    }  // for i
    return OK;
}  // Kprime_randomizer


static BOOL WINAPI Kprime_sizer
        (digit_t       *size,    // OUT
         field_desc_tc *fdesc,   // IN
         PBIGCTX_ARG)
/*
     Return field size (length elng+1).
     For prime fields, this is the same as its characteristic.
*/
{
    DWORDREGC elng = fdesc->elng;
    BOOL OK = TRUE;

    assert(elng == fdesc->modulo->length);

    mp_extend(fdesc->modulo->modulus, elng, size, elng + 1, PBIGCTX_PASS);

    return OK;
}  // end Kprime_sizer

BOOL WINAPI Kprime_sqrter
        (digit_tc      *f1,        // IN
         digit_t       *f3,        // OUT
         DWORDREGC      nelmt,     // IN
         field_desc_tc *fdesc,     // IN
         BOOL          *psquares,  // OUT
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    DWORDREG i;
    DWORDREGC elng = fdesc->elng;
    BOOL all_squares = TRUE;

    OK = OK && Kprime_truly(fdesc, "Kprime_sqrter", PBIGCTX_PASS);

    for (i = 0; OK && i != nelmt*elng; i += elng) {
        BOOL square_now = FALSE;
        OK = OK && mod_sqrt(f1 + i, f3 + i,
                            fdesc->modulo, &square_now, PBIGCTX_PASS);
        all_squares = all_squares && square_now;
    }
    if (OK) *psquares = all_squares;
    return OK;
}  // Kprime_sqrter

static BOOL WINAPI Kprime_subtracter
        (digit_tc      *f1,     // IN
         digit_tc      *f2,     // IN
         digit_t       *f3,     // OUT
         DWORDREGC      nelmt,  // IN
         field_desc_tc *fdesc,  // IN
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    DWORDREG i;
    DWORDREGC elng = fdesc->elng;

    OK = OK && Kprime_truly(fdesc, "Kprime_subtracter", PBIGCTX_PASS);
    for (i = 0; OK && i != nelmt*elng; i += elng) {
        OK = OK && mod_sub(f1 + i, f2 + i, f3 + i, fdesc->modulo, PBIGCTX_PASS);
    }
    return OK;
}  // Kprime_subtracter


static const field_arithmetic_t prime_arithmetic
= {Kprime_adder,
   Kequaler_default,
   // BEVANS:  removed -- unreferenced Kprime_exponentiator1,
   Kprime_freer,
   Kprime_immediater,
   Kprime_inverter1,
   Kiszeroer_default,
   Kprime_mulpower2er,
   Kprime_multiplier1,
   Kprime_negater,
   Kprime_quad1_solver,
   // BEVANS:  Removed -- unreferenced Kprime_randomizer,
   Kprime_sizer,
   // BEVANS:  Removed -- unreferenced Kprime_sqrter,
   Kprime_subtracter,
   Kzeroizer_default};



BOOL WINAPI Kinitialize_prime
        (mp_modulus_tc *modulo,     // IN
         field_desc_t  *fdesc,      // OUT
         struct bigctx_t      *pbigctxTemp,
         PBIGCTX_ARG)
/*
        Initialize a field descriptor for a prime field.

        CAUTION -- The modulo struct must remain accessible
        (i.e., in scope) as long as the field is being accessed.
        That is, don't use an automatic variable in a function
        for *modulo if the field will be accessed after exiting the function.

        CAUTION -- modulo->modulus should be prime, but we don't check that.
*/

{
    DWORDREGC elng = modulo->length;
    DWORDREGC ninv_temps = mp_invert_ntemps(elng, pbigctxTemp);
    BOOL OK = TRUE;

    fdesc->deallocate = digit_NULL;
    OK = OK && Kfdesc_initialize(fdesc, 0, pbigctxTemp);

    fdesc->arithmetic = &prime_arithmetic;
    fdesc->degree = 1;
    fdesc->elng = elng;
    fdesc->ftype = FIELD_Q_MP;
    fdesc->modulo = modulo;
    fdesc->ndigtemps_mul = modulo->modmul_algorithm_temps;
    fdesc->ndigtemps_invert1 = elng + MAX(fdesc->ndigtemps_mul, ninv_temps);
    fdesc->ndigtemps_arith = fdesc->ndigtemps_invert1 + elng;
    fdesc->one = (digit_t*)modulo->one;  // Remove const attribute
          // Set up multiplier for Kinvert.
          // This is 1 for FROM_LEFT arithmetic.
          // For FROM_RIGHT arithmetic, we twice unscale the
          // constant fdesc->one.
#if 0
     printf("Kinitpr: reddir = %ld, lng = %ld\n",
            (long)modulo->reddir, (long)elng);
#endif
    if (!OK) {
    } else if (modulo->reddir == FROM_LEFT) {
        fdesc->inverse_adjustment = fdesc->one;
    } else {
        digit_t *invadj = digit_allocate(elng,
                                         "Kinitialize_prime", PBIGCTX_PASS);
        if (invadj == digit_NULL) {
            OK = FALSE;
        }
        fdesc->deallocate = invadj;
        fdesc->inverse_adjustment = invadj;
        OK = OK && mod_shift(fdesc->one, -2*modulo->scaling_power2,
                             invadj, modulo, PBIGCTX_PASS);
        if (!OK && invadj != digit_NULL) {
            Free_Temporaries(invadj, PBIGCTX_PASS);
        }
    }
    return OK;
} /* Kinitialize_prime */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\lucas.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"
/*
//      mod_Lucas(base, exponent, lngexpon, answer, modulo) --
//              Compute answer = V_{exponent}(base) mod modulo->modulus,
//              where V_n denotes the n-th Lucas function.
//              V_n is the monic polynomial of degree |n|
//              satisfying V_n(x + 1/x) = x^n + 1/x^n.
//              Other properties are:

//                      V_0(x) = 2
//                      V_1(x) = x
//                      V_2(x) = x^2 - 2
//                      V_3(x) = x^3 - 3*x
//                      V_{-1}(x) = x

//                      V_{m+n}(x) = V_m(x) V_n(x) - V_{m-n}(x)
//                      V_{mn}(x) = V_m(V_n(x))
//
//     mod_LucasUV(C1, C0, exponent, lngexpon, Uout, Vout, modulo) --
//              Compute
//
//                  Vout = alpha^exponent + beta^exponent
//                  Uout = (alpha^exponent - beta^exponent)/(alpha - beta)
//
//              where alpha, beta satisfy X^2 - C1*X + C0 = 0 (mod modulo).
//              Modulus must be odd.
//
//                  Vout[0] = 2     Vout[1] = C1
//                  Uout[0] = 1     Uout[1] = 1
//                  Vout[n+2] = C1*Vout[n+1] - C0*Vout[n]
//                  Uout[n+2] = C1*Uout[n+1] - C0*Uout[n]

*/
/***************************************************************************/
BOOL WINAPI mod_Lucas
        (digit_tc       base[],
         digit_tc       exponent[],
         DWORDREGC      lngexpon,
         digit_t        answer[],
         mp_modulus_tc *modulo,
         PBIGCTX_ARG)
/*
//        Compute Lucas function answer = V_{exponent}(base).
//
//        Use a straightforward, unoptimized, binary algorithm.
*/

#define MULSUB(a, b, c, d) (mod_mul(a, b, vtemp, modulo, modmultemps,\
                                    PBIGCTX_PASS) \
                             && mod_sub(vtemp, c, d, modulo, PBIGCTX_PASS))
                                /* d = a * b - c */
{
    BOOL OK = TRUE;
    DWORDREG bits_left = mp_significant_bit_count(exponent, lngexpon,
                                                  PBIGCTX_PASS);
    DWORDREGC lng = modulo->length;
    digit_t *dtemps = digit_allocate(4*lng + modulo->modmul_algorithm_temps,
                                     "mod_Lucas", PBIGCTX_PASS);

    if (dtemps == digit_NULL) {
        OK = FALSE;
    } else if (bits_left == 0) {       /* If exponent is identically zero */
        OK = OK && mod_add(modulo->one, modulo->one, answer,
                          modulo, PBIGCTX_PASS);
    } else {
        digit_t *two   = dtemps;          // Length lng
        digit_t *Vn    = dtemps + lng;    // Length lng
        digit_t *Vnp1  = dtemps + 2*lng;  // Length lng
        digit_t *vtemp = dtemps + 3*lng;  // Length lng
        digit_t *modmultemps = dtemps + 4*lng;
                       // Length modulo->modmul_algorithm_temps

        OK = OK && mod_add(modulo->one, modulo->one, two,
                           modulo, PBIGCTX_PASS);   /* 2 */

        mp_copy(base, Vn, lng, PBIGCTX_PASS);            /* Vn   = V1 */
        OK = OK && MULSUB(base, base, two, Vnp1);        /* Vnp1 = V2 */

        bits_left--;
        while (OK && bits_left != 0) {
            bits_left--;
            if (mp_getbit(exponent, bits_left, PBIGCTX_PASS) == 0) {
                                                        /* Replace n by 2*n */
                OK = OK && MULSUB(Vn, Vnp1, base, Vnp1);
                OK = OK && MULSUB(Vn, Vn, two, Vn);
            } else {                            /* Replace n by 2*n + 1 */
                OK = OK && MULSUB(Vn, Vnp1, base, Vn);
                OK = OK && MULSUB(Vnp1, Vnp1, two, Vnp1);
            }
        } /* while */
        mp_copy(Vn, answer, lng, PBIGCTX_PASS);
    }
    if (dtemps != digit_NULL) {Free_Temporaries(dtemps, PBIGCTX_PASS);}
    return OK;
} /* mod_Lucas */
#undef MULSUB
/***************************************************************************/
BOOL WINAPI mod_LucasUV
        (digit_tc C1[],
         digit_tc C0[],
         digit_tc exponent[],
         DWORDREGC   lngexpon,
         digit_t  Uout[],
         digit_t  Vout[],
         mp_modulus_tc *modulo,
         PBIGCTX_ARG)
{
/*
       Vout = alpha^exponent + beta^exponent
       Uout = (alpha^exponent - beta^exponent)/(alpha - beta)

    where alpha, beta satisfy X^2 - C1*X + C0 = 0 (mod modulo).
    Modulus must be odd.
*/

    BOOL OK = TRUE;
    DWORDREG bits_left = mp_significant_bit_count(exponent, lngexpon,
                                                  PBIGCTX_PASS);
    DWORDREGC lng = modulo->length;
    digit_t *dtemps = digit_allocate(2*lng + modulo->modmul_algorithm_temps,
                                     "mod_LucasUV", PBIGCTX_PASS);
    if (dtemps == digit_NULL) {
        OK = FALSE;
    } else if (bits_left == 0) {       /* If exponent is identically zero  */
        OK = OK && mod_add(modulo->one, modulo->one, Vout,
                           modulo, PBIGCTX_PASS);  // V = 2
        mp_clear(Uout, lng, PBIGCTX_PASS);                           // U = 0
    } else {
        digit_t *DELTA = dtemps;        // Length lng
        digit_t *temp1 = dtemps + lng;  // Length lng
        digit_t *modmultemps = dtemps + 2*lng;
                                // Length modulo->modmul_algorithm_temps

        mp_copy(C1, Vout, lng, PBIGCTX_PASS);                         // V = C1
        mp_copy(modulo->one, Uout, lng, PBIGCTX_PASS);                // U = 1
        OK = OK && mod_shift(C0, +2, temp1, modulo, PBIGCTX_PASS);    // 4*C0
        OK = OK && mod_mul(C1, C1, DELTA, modulo,
                          modmultemps, PBIGCTX_PASS);                 // C1*C1
        OK = OK && mod_sub(DELTA, temp1, DELTA, modulo, PBIGCTX_PASS);
                                                         // DELTA = C1*C1 - 4*C0

        bits_left--;
        while (OK && bits_left != 0) {
            bits_left--;
                // First replace n by 2*n
            OK = OK && mod_mul(Uout, Uout, temp1, modulo,
                               modmultemps, PBIGCTX_PASS);
            OK = OK && mod_mul(temp1, DELTA, temp1, modulo,
                               modmultemps, PBIGCTX_PASS);
                                                    // DELTA * Uout^2
            OK = OK && mod_mul(Uout, Vout, Uout, modulo,
                               modmultemps, PBIGCTX_PASS);
                                                    // Uout * Vout
            OK = OK && mod_mul(Vout, Vout, Vout, modulo,
                               modmultemps, PBIGCTX_PASS);
                                                    // Vout^2
            OK = OK && mod_add(Vout, temp1, Vout, modulo,
                               PBIGCTX_PASS);
                                                    // Vout^2 + DELTA*Uout^2
            OK = OK && mod_shift(Vout, -1, Vout, modulo,
                               PBIGCTX_PASS);
                                                    // (Vout^2 + DELTA*Uout^2)/2

            if (mp_getbit(exponent, bits_left, PBIGCTX_PASS) != 0) {

                // Replace 2*n by 2*n + 1
                // (U, V) := (C1*U + V, C1*V + DELTA*U)/2

                OK = OK && mod_mul(DELTA, Uout, temp1, modulo,
                                   modmultemps, PBIGCTX_PASS);
                OK = OK && mod_mul(C1, Uout, Uout, modulo,
                                   modmultemps, PBIGCTX_PASS);
                OK = OK && mod_add(Uout, Vout, Uout, modulo, PBIGCTX_PASS);
                OK = OK && mod_shift(Uout, -1, Uout, modulo, PBIGCTX_PASS);

                OK = OK && mod_mul(C1, Vout, Vout, modulo,
                                   modmultemps, PBIGCTX_PASS);
                OK = OK && mod_add(Vout, temp1, Vout, modulo, PBIGCTX_PASS);
                OK = OK && mod_shift(Vout, -1, Vout, modulo, PBIGCTX_PASS);
            }
        } /* while */
    }
    if (dtemps != digit_NULL) {
        Free_Temporaries(dtemps, PBIGCTX_PASS);
    }
    return OK;
} /* mod_LucasUV */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\modular.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"
#ifndef assert
#include <assert.h>
#endif
#include <drmpkcrypto.h>
/*
        File modular.c.  Version 28 November 2002

                create_modulus(a, lnga, reddir, *modulo)
                        Initialize modulo for the modulus a,
                        of length lnga.  reddir can be FROM_LEFT
                        or FROM_RIGHT to specify whether
                        products are reduced from the left or
                        from the right.

                from_modular(a, b, modulo) --
                        The number a (mod modulo) is converted to
                        standard form and stored in b.

                mod_mul(a, b, c, modulo, temps) --
                        Compute c = a * b (mod modulo).

                mod_mul_immediate(a, scalar, c, modulo) --
                        (See modmulim.c)
                        Compute c = a*scalar (mod modulo),
                        where scalar is single precision.
                        Reduction is always from the left.

                mod_shift(a, shiftamt, b, modulo) --
                        Compute b = a * 2^shiftamt (mod modulo).
                        The shift count shiftamt can have either
                        sign, but the modulus must be
                        odd if the shift count is negative.
                        Cost is O(shiftamt) (for fixed modulo),
                        so huge values of shiftamt should be avoided.

               to_modular(a, lnga, b, modulo)  --
                        Convert a (of length lnga) to
                        its modular representation b.

               uncreate_modulus(modulo)
                        Release storage allocated by create_modulus
*/


#if 0
  (December, 1995, note)

       Here is the best way I have found so far to reduce 2048 bits
to 1024 bits.  If the (odd) modulus is N, the method uses two big constants

        Ninv512 = 1/N (mod 2^512)

        N1536 = N * Ninv512 (so N1536 == 1 mod 2^512).

Let the original 2048-bit number be x0.

Step 1)  Reduce to 1536 bits.  Replace x0 by

         x1 = (x0 - N1536 * (lower 512 bits of x0))/2^512.

         (N.B. x1 may be negative).
         Cost: One 512 x 1024-bit multiplication.

Step 2)  Compute q == x1 * Ninv512 (mod 2^512)

         Cost: One 512 x 512-bit multiplication (low half only)

Step 3)  Compute x2 = (x1 - q * N)/2^512.  If negative, add N.

         Cost: One 512 x 1024-bit multiplication,
               where the low 512 bits of the product are known.

In 1) and 3), the 1024-bit operand depends only on N,
         so any additions/subtractions needed to precondition
         the operand for Karatsuba need be done only once.
         The same 512-bit multiplier (bottom of x0, or q)
         is being used for two 512 x 512-bit multiplications,
         and need be preconditioned only once.

In 3), we can do the lower 512 x 512 multiplication with
two 256 x 256 multiplications since the low 512 bits of the product
are known.  Specifically, if we want (a1:a0)*(b1:b0)
where a1, a0, b1, b0 are 256 bits each, then it suffices
to compute a1*b1 and (a1 - a0)*(b1 - b0) if we know the bottom
512 bits of (a1:a0)*(b1:b0).

        The total reduction cost is 6 + 3 + 5 = 14
256 x 256-bit products, whereas the present scheme uses
the equivalent of 16 such products (computed by the classical algorithm).
I estimate the time for a 256 x 256-bit product to be 650 cycles
(on the Pentium), so the total reduction time
(after adding overhead for the additions) will be around 10000 cycles.

        We can do the 512 x 512 low product required by 2)
using 5 full 128 x 128 multiplication and 3 low
128 x 128 multiplications for a slight improvement.
Specifically, we can get the lower half of
(a3:a2:a1:a0) * (b3:b2:b1:b0) if we know
a0*b0, a1*b1, a2*b2, (a1 - a0)*(b1 - b0), (a2 - a0)*(b2 - b0),
and the lower halves of (a2 - a1)*(b2 - b1), a0*b3, a3*b0.

        Or we may skip the first reduction from 2048 to
1536 bits, and compute one 1024-bit q such that
q == x0/N (mod 2^1024) (lower half of 1024 x 1024-bit product).
Then take (x0 - q*N)/2^1024 where the lower half of q*N is known.
The computation of q can be done with eight 256 x 256-bit multiplications,
and q*N with two 512 x 512-bit multiplications, again
for fourteen 256 x 256-bit multiplications.

        If we try to reduce from the left rather than from the right, then
we can do something like 1) (using N1536 = 2^1536 + (number below N)
where N1536 is a multiple of N).  Then we have a 1536-bit remainder,
which we want to further-reduce to 1024 bits.
Define N1280 (slightly above 2^1280) similarly; one 256 x 1024
multiplication will reduce the remainder to 1280 bits.
We can estimate the final quotient at any time, if we
know the reciprocal of the divisor, but this seems to take
more work than working from the right.  It is still desirable to optimize
this case, to avoid the need to convert to/from Montgomery form
when the original exponent is small (e.g., when cubing a number).

        The length 1024 is in the padding table (see kara.c),
as is 512, so nothing is wasted when we pad those operands during
the multiplication.  For an irregular length, such as 608 bits,
the second reduction must be at least 608/2 = 304 bits,
and the first such entry is for 384 bits.  The first reduction
must then be at least 608 - 384 = 224 bits, and we could then
use the entry for 256 bits.  This would require taking
384 x 608 and 256 x 608 products, hence two 384 x 384 products
and three 256 x 256 products.  That is not presently implemented.
Instead, we use 384 bits for both reductions.
When the first padding length is an odd number of words
(namely 1 or 3), the total reduction will exceed the first padding length.

        Question:  Can we do two 2048-bit to 1024-bit
reductions any faster than a single reduction?
If so, we might want to design the exponentiation routine
to allow multiple concurrent exponentiations with same
exponent and modulus.  I am looking for a trick similar to
that used to compute two modular inverses using one
modular inversion and three multiplications:
1/x = y*(1/xy) and 1/y = x*(1/xy).

#endif /* 0 */
/******************************************************************************/
/******************************************************************************/
BOOL WINAPI create_modulus
        (digit_tc       a[],
         DWORDREGC      lnga,
         reddir_tc      reddir,
         mp_modulus_t  *pmodulo,
         PBIGCTX_ARG,
         struct bigctx_t *pbigctxGlobal)
/*
        This routine computes modulus-dependent constants
        for the modulus -a-, and stores them in a
        mp_modulus_t structure.  See the struct declaration
        (in bignum.h) for a description of each field.

        Argument reddir should be FROM_RIGHT if one wants to use
        Montgomery-type reductions (from the right)
        rather than traditional reductions (from the left).
        The FROM_RIGHT option is available only if -a- is odd.
*/
{
    BOOL OK = TRUE;
    DWORDREGC lngred2 = (lnga + 1)/2;

    digit_t *dtemps_longterm
        = digit_allocate(3*lnga + lngred2,        "create_modulus_longterm",
                                                   pbigctxGlobal);
    digit_t *dtemps_shortterm
        = digit_allocate(2*lnga + 2*lngred2 + 1,  "create_modulus_shortterm",
                                                   PBIGCTX_PASS);

    if (dtemps_shortterm == digit_NULL || dtemps_longterm == digit_NULL) {
        OK =  FALSE;
    } else if (lnga == 0 || a[lnga-1] == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "create_modulus leading zero",
                        PBIGCTX_PASS);
    } else {
        digit_t *mptmp1    = dtemps_shortterm;        // Length lnga + lngred2
        digit_t *quotient  = dtemps_shortterm + lnga + lngred2;
                                                      // Length lngred2 + 1
        digit_t *remainder = dtemps_shortterm + 1 + lnga + 2*lngred2;
                                                      // Length lnga
        digit_t mod0inv;
        DWORDREG i;

        pmodulo->modulus           = dtemps_longterm;           // Length lnga
             // N.B. uncreate_modulus assumes modulus comes first
        pmodulo->one               = dtemps_longterm +   lnga;  // Length lnga
        pmodulo->multiplier_first  = dtemps_longterm + 2*lnga;  // Length lnga
        pmodulo->multiplier_second = dtemps_longterm + 3*lnga; // Length lngred2
        pmodulo->cofactor = digit_NULL;

        for( i = 0; i < DRM_PK_MAX_SECRET_ARRAYS; i++ )
        {
            if( (*(g_SetSecretFuncs.secretArray[i]))       != NULL
             && (*(g_SetSecretFuncs.secretArray[i]))[1]    != NULL
             && (*(g_SetSecretFuncs.secretArray[i]))[1]( ) != DRM_SUCCESS )
            {
                OK = FALSE;
            }
            else if( (*(g_SetSecretFuncs.secretArray[i])) != NULL )
            {
                (*(g_SetSecretFuncs.secretArray[i]))[1] = NULL;
            }
        }

        pmodulo->length = lnga;
        pmodulo->lngred2 = lngred2;
        pmodulo->reddir = reddir;
        mp_copy(a, pmodulo->modulus,  lnga, PBIGCTX_PASS);

        OK = OK && divide_precondition_1(a, lnga, &pmodulo->left_reciprocal_1,
                                         PBIGCTX_PASS);

        mod0inv = 0;
        if (IS_ODD(a[0])) {
            OK = OK && two_adic_inverse(a[0], &mod0inv, PBIGCTX_PASS);
        }
        pmodulo->right_reciprocal_1 = mod0inv;
                               /* For use by mod_shift if modulus is odd */

        if (reddir == FROM_LEFT) {
            DWORDREGC shiftamt = pmodulo->left_reciprocal_1.shiftamt;
            DWORDREGC ldividend = lnga + lngred2;

            pmodulo->scaling_power2 = 0;

/*
            Compute constants multiplier_first, multiplier_second so that

               0 <= multiplier_first < modulus
               0 <= multiplier_second < RADIX^lngred2

                  modulus * (multiplier_second + RADIX^lngred2 + 1)
                = RADIX^(length + lngred2) / 2^shiftamt + multiplier_first

            That is, if we divide

                  (RADIX^dividend / 2^shiftamt) - 1

            by modulus, the results will be

                   quotient = multiplier_second + RADIX^lngred2
                   remainder = modulus - 1 - multiplier_first
*/
            for (i = 0; i != ldividend; i++) {
                mptmp1[i] = RADIXM1;
            }
            mptmp1[ldividend-1] = RADIXM1 >> shiftamt;

            OK = OK && divide(mptmp1, ldividend, a, lnga,
                              &pmodulo->left_reciprocal_1,
                              quotient, remainder, PBIGCTX_PASS);

            if (quotient[lngred2] != 1) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                          "create_modulus -- divide error",
                          PBIGCTX_PASS);
                       // quotient should start with 1
            }

            add_immediate(remainder, DIGIT_ONE, remainder, lnga);
            sub_same(pmodulo->modulus, remainder, remainder, lnga);
                           // modulus - 1 - remainder
        } else if (reddir == FROM_RIGHT) {
            pmodulo->scaling_power2 = (int)(RADIX_BITS*lnga);

            if (mod0inv == 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                                "create_modulus FROM_RIGHT even",
                                PBIGCTX_PASS);
            } else {
/*
                Compute multiplier_first, multiplier_second, such that

                    0 <= multipler_first < modulus
                    0 <= multiplier_second < RADIX^lngred2

                       multiplier_second * modulus
                 = 1 + multiplier_first * RADIX^lngred2
*/
                pmodulo->multiplier_second[0] = mod0inv;
                mptmp1[lnga] =
                    multiply_immediate(pmodulo->modulus, mod0inv,
                                       mptmp1, lnga, PBIGCTX_PASS);
                        /* 1 mod RADIX,  0 mod modulo->modulus */
                assert(mptmp1[0] == 1);

                for (i = 1; i != lngred2; i++) {
                    digit_tc mul = 0 - mod0inv*mptmp1[i];     /* mod RADIX */

                    pmodulo->multiplier_second[i] = mul;
                    mptmp1[i + lnga] = accumulate(pmodulo->modulus, mul,
                                          &mptmp1[i], lnga, PBIGCTX_PASS);
                       /* New mptmp1[i] = 0 */
                       /* Sum is 1 mod RADIX^(i+1),  0 mod modulo->modulus */
                    assert (mptmp1[i] == 0);
                }
                mp_copy(mptmp1 + lngred2, pmodulo->multiplier_first,
                        lnga, PBIGCTX_PASS);
                       /* -1/RADIX^lngred2 mod modulus */
            }
        } else {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                         "create_modulus -- neither FROM_LEFT nor FROM_RIGHT",
                         PBIGCTX_PASS);
        }

        for( i = 0; i < DRM_PK_MAX_SECRET_ARRAYS; i++ )
        {
            if( (*(g_SetSecretFuncs.secretArray[i]))       != NULL
             && (*(g_SetSecretFuncs.secretArray[i]))[2]    != NULL
             && (*(g_SetSecretFuncs.secretArray[i]))[2]( ) != DRM_SUCCESS )
            {
		        OK = FALSE;
            }
            else if( (*(g_SetSecretFuncs.secretArray[i])) != NULL )
            {
                (*(g_SetSecretFuncs.secretArray[i]))[2] = NULL;
            }
        }

        {
            digit_tc d1 = 1;
            int modmul_algorithm_index = 0;

            OK = OK && modmul_choices1(pmodulo, &modmul_algorithm_index,
                                       PBIGCTX_PASS);
            if (!OK) {
            } else if (modmul_algorithm_index == 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                    "create_modulus -- no modmul routine found",
                    PBIGCTX_PASS);
                         // No qualifying routine found
            } else {
                modmul_algorithm_index = -modmul_algorithm_index;
                OK = OK && modmul_choices1(pmodulo, &modmul_algorithm_index,
                                           PBIGCTX_PASS);
                assert (modmul_algorithm_index == 0);
            }

/*
                Generate the constant one.
                Its numerical value is 2^scaling_power2 mod modulus.
*/
            OK = OK && to_modular(&d1, 1, pmodulo->one, pmodulo, PBIGCTX_PASS);
        } // local block
    } // if


    if (dtemps_shortterm != digit_NULL) {
        Free_Temporaries(dtemps_shortterm, PBIGCTX_PASS);
    }
    if (!OK) {
        pmodulo->modulus = digit_NULL;

        if (dtemps_longterm != digit_NULL) {
            Free_Temporaries(dtemps_longterm, PBIGCTX_PASS);
        }
    }
    return OK;
}   /* create_modulus */
/******************************************************************************/
BOOL WINAPI from_modular
        (digit_tc        a[],
         digit_t         b[],
         mp_modulus_tc  *pmodulo,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;

    OK = OK && validate_modular_data(a, pmodulo->modulus,
                               pmodulo->length, "from_modular", PBIGCTX_PASS);
    OK = OK && mod_shift(a, -pmodulo->scaling_power2, b, pmodulo, PBIGCTX_PASS);
    return OK;
} /* from_modular */
/******************************************************************************/
BOOL WINAPI mod_mul
        (digit_tc       a[],
         digit_tc       b[],
         digit_t        c[],
         mp_modulus_tc *pmodulo,
         digit_t       *supplied_temps,   // May be digit_NULL
         PBIGCTX_ARG)
/*
        Compute c = a * b / 2^scaling_power2 (mod modulo->modulus).
        Operands should satisfy 0 <= a, b < modulo->modulus.

        supplied_temps should have pmodulo->modmul_algorithm_temps
        temporaries of type digit_t, or be digit_NULL.
*/
{
    BOOL OK = TRUE;
    digit_tempinfo_t tempinfo;

    tempinfo.address = supplied_temps;
    tempinfo.nelmt = pmodulo->modmul_algorithm_temps;
    tempinfo.need_to_free = FALSE;

    OK = OK && validate_modular_data(a, pmodulo->modulus,
                                     pmodulo->length, "mod_mul 1",
                                     PBIGCTX_PASS);
    if (a != b) {
        OK = OK && validate_modular_data(b, pmodulo->modulus,
                                         pmodulo->length, "mod_mul 2",
                                         PBIGCTX_PASS);
    }
    OK = OK && possible_digit_allocate(&tempinfo, "mod_mul", PBIGCTX_PASS);

    OK = OK && (*pmodulo->modmul_algorithm)(a, b, c, pmodulo,
                                            tempinfo.address, PBIGCTX_PASS);

    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }
    return OK;
} /* mod_mul */
/***************************************************************************/
BOOL WINAPI mod_shift
        (digit_tc       a[],
         intc           shiftamt,
         digit_t        b[],
         mp_modulus_tc *modulo,
         PBIGCTX_ARG)
/*
        Compute b = a * 2^shiftamt (mod modulo).
        The shift count, shiftamt, may be positive, negative, or zero.
        If shiftamt < 0, then the modulus must be odd.
        The lengths of a and b should match those of the modulus.
*/
{
    BOOL OK = TRUE;
    DWORDREGC lng = modulo->length;
    int shift_remaining = shiftamt;

    if (a != b) mp_copy(a, b, lng, PBIGCTX_PASS);

    OK = OK && validate_modular_data(a, modulo->modulus, lng,
                                     "mod_shift", PBIGCTX_PASS);

    if (OK && shift_remaining < 0 && IS_EVEN(modulo->modulus[0])) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "mod_shift -- negative count, even modulus",
                        PBIGCTX_PASS);
    }

    while (OK && shift_remaining > 0) {          /* Do left shift, if any */
        intc shift_now = MIN(shift_remaining, RADIX_BITS);
                                /* 1 <= shift_now <= RADIX_BITS */
/*
                Multiply b by 2^shift_now and reduce modulo modulo->modulus.
*/
        digit_t carry_out = 0;

        OK = OK && mp_shift_lost(b, shift_now, b, lng,
                                 &carry_out, PBIGCTX_PASS);
        if (OK) {
            digit_tc qest = estimated_quotient_1(carry_out, b[lng-1],
                                                 (lng >= 2 ? b[lng-2] : 0),
                                                 &modulo->left_reciprocal_1,
                                                 PBIGCTX_PASS);
            carry_out -= decumulate(modulo->modulus, qest, b,
                                    lng, PBIGCTX_PASS);

            if (carry_out != 0 || compare_same(b, modulo->modulus, lng) >= 0) {
                carry_out -= sub_same(b, modulo->modulus, b, lng);
            }
            if (carry_out != 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                    "mod_shift left carry nonzero", PBIGCTX_PASS);
            }
        }
        shift_remaining -= shift_now;
    } /* while shift_remaining > 0 */

    while (OK && shift_remaining < 0) {
        intc shift_now = MIN(-shift_remaining, RADIX_BITS);
                                /* 1 <= shift_now <= RADIX_BITS */
        digit_tc mul =   (0-modulo->right_reciprocal_1 * b[0])
                       & (RADIXM1 >> (RADIX_BITS - shift_now) );
        digit_t carry, low_bits_lost = 0;
/*
                mul has been chosen so that  b + mul * modulo->modulus
                is a multiple of 2^shift_now.
                Replace b by (b + mul * mudulo->modulus)/2^shift_now.
*/
        carry = accumulate(modulo->modulus, mul, b, lng, PBIGCTX_PASS);
        OK = OK && mp_shift_lost(b, -shift_now, b, lng,
                                 &low_bits_lost, PBIGCTX_PASS);
        b[lng-1] |= carry << (RADIX_BITS - shift_now);

        if (OK && low_bits_lost != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "mod_shift -- low bits lost",
                            PBIGCTX_PASS);
        }
        shift_remaining += shift_now;
    } /* while shift_remaining < 0 */
    return OK;
} /* mod_shift */
/****************************************************************************/
BOOL WINAPI to_modular
        (digit_tc      a[],
         DWORDREGC     lnga,
         digit_t       b[],
         mp_modulus_tc *pmodulo,
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    digit_tc *arem;
    DWORDREG lngarem;
    DWORDREGC lngmod = pmodulo->length;
    digit_t *remainder = digit_NULL;   // Length lngmod

    if (compare_diff(a, lnga, pmodulo->modulus, lngmod) >= 0) {
        remainder = digit_allocate(lngmod, "to_modular", PBIGCTX_PASS);
        if (remainder == digit_NULL) OK = FALSE;

        OK = OK && divide(a, lnga, pmodulo->modulus, lngmod,
                         &pmodulo->left_reciprocal_1,
                         digit_NULL, remainder, PBIGCTX_PASS);
        arem = remainder;
        lngarem = lngmod;
    } else {
        arem = a;
        lngarem = lnga;
    }
    if (OK) {
        lngarem = significant_digit_count(a, lngarem);
        mp_extend(arem, lngarem, b, lngmod, PBIGCTX_PASS);
                /* Copy remainder to b */
        OK = OK && mod_shift(b, pmodulo->scaling_power2, b,
                             pmodulo, PBIGCTX_PASS);
                                    // Scale by power of 2
    }
    if (remainder != digit_NULL) {
        Free_Temporaries(remainder, PBIGCTX_PASS);
    }
    return OK;
} /* to_modular */
/******************************************************************************/
void WINAPI uncreate_modulus
        (mp_modulus_t *pmodulo,
         PBIGCTX_ARG)
/*
        Release storage allocated by create_modulus
*/
{
    if (pmodulo->modulus != digit_NULL) {
        Free_Temporaries(pmodulo->modulus, PBIGCTX_PASS);
        pmodulo->modulus = digit_NULL;
    }
} // uncreate_modulus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\modmulch1.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"
#ifndef assert
#include <assert.h>
#endif

/*
       File modmulch1.c.   Version 1 October, 2002.

            This is the first of several modmulchx files with algorithms for
        modular multiplication, both FROM_LEFT and FROM_RIGHT.
        All procedures have an argument list

            (digit_tc *a, *b,           // Two numbers to multiply
                                        // 0 <= a, b < modulus
             digit_t  *c                // Product.  May overlap a or b.
             mp_modulus_tc *pmodulo,    // Struct with information about modulus
             digit_t  *temps,           // Temporaries (length
                                        //     pmodulo->modmul_algorithm_temps)
             PBIGCTX_ARG)

            FROM_LEFT codes return

                c == (a*b) mod modulus

            FROM_RIGHT codes return the Montgomery product

               c == a*b / RADIX^lng  (mod pmodulo->modulus).

        where lng = pmodulo->length.

            This file starts with

                modmul_from_left_default
                modmul_from_right_default

        which work on all architectures and lengths.  It also has

                modmul_from_right_SSE2

        which is specific to X86 hosts with SSE2 instructions (e.g., Pentium 4).
*/
/******************************************************************************/
static BOOL WINAPI modmul_from_left_default
        (digit_tc *a,              // IN
         digit_tc *b,              // IN
         digit_t  *c,              // OUT
         mp_modulus_tc *pmodulo,   // IN
         digit_t  *temps,          // TEMPORARIES, at least 2*lng
         PBIGCTX_ARG)
/*
        This implements ordinary modular multiplication.
    Given inputs a, b with 0 <= a, b < modulus < RADIX^lng,
    and where lng > 0, we form

           c == (a*b) mod modulus.
*/
{
    BOOL OK = TRUE;
    DWORDREGC lng = pmodulo->length;
    digit_t *temp1 = temps;     // Length 2*lng

    assert (pmodulo->modmul_algorithm_temps == 2*lng);
    OK = OK && multiply(a, lng, b, lng,
                        temp1, PBIGCTX_PASS);     // Double-length product
    OK = OK && divide(temp1, 2*lng, pmodulo->modulus, lng,
                    &pmodulo->left_reciprocal_1, digit_NULL, c, PBIGCTX_PASS);
    return OK;
}  // modmul_from_left_default
/******************************************************************************/
static BOOL WINAPI modmul_from_right_default
        (digit_tc *a,              // IN
         digit_tc *b,              // IN
         digit_t  *c,              // OUT
         mp_modulus_tc *pmodulo,   // IN
         digit_t  *temps,          // TEMPORARIES, at least 2*lng
         PBIGCTX_ARG)
/*
        This implements Montgomery (FROM_RIGHT) multiplication.
    Let lng = pmodulo->length > 0.
    Given inputs a, b with 0 <= a, b < pmodulo->modulus < RADIX^lng, we form

           c == a*b / RADIX^lng  (mod pmodulo->modulus).

        At the start of the loop on i, there exists templow
    (formed by the discarded values of
    LOW_DIGIT(prod1) = LOW_DIGIT(prod2)) such that

               0 <= temp1, temp2 < modulus
               temp1*RADIX^j + templow = b[0:j-1] * a
               temp2*RADIX^j + templow == 0 (mod modulus)

    When j = lng, we exit with c == temp1 - temp2 (mod modulus)
*/
{
    BOOL OK = TRUE;
    DWORDREGC lng = pmodulo->length;
    digit_t *temp1 = temps, *temp2 = temps + lng;   // Both length lng
    digit_tc *modulus = pmodulo->modulus;
    digit_tc minv = pmodulo->right_reciprocal_1;
    digit_tc minva0 = minv*a[0];    // mod RADIX
    DWORDREG i, j;
    digit_t carry1, carry2, mul1, mul2;
    dblint_t prod1, prod2;

    assert (pmodulo->modmul_algorithm_temps == 2*lng);
 // Case j = 0 of main loop, with temp1 = temp2 = 0 beforehand.
    mul1 = b[0];
    mul2 = minva0*mul1;   // Modulo RADIX
    carry1 = HPRODUU(mul1,       a[0]);
    carry2 = HPRODUU(mul2, modulus[0]);
    assert (mul1*a[0] == mul2*modulus[0]);     // mod RADIX

    for (i = 1; i != lng; i++) {
        prod1 = MULTIPLY_ADD1(mul1,       a[i], carry1);
        prod2 = MULTIPLY_ADD1(mul2, modulus[i], carry2);
        temp1[i-1] = LOW_DIGIT(prod1);
        temp2[i-1] = LOW_DIGIT(prod2);
        carry1 = HIGH_DIGIT(prod1);
        carry2 = HIGH_DIGIT(prod2);
    }
    temp1[lng-1] = carry1;
    temp2[lng-1] = carry2;

    for (j = 1; j != lng; j++) {
        mul1 = b[j];
        mul2 = minva0*mul1 + minv*(temp1[0] - temp2[0]);  // Modulo RADIX
        prod1 = MULTIPLY_ADD1(mul1, a[0], temp1[0]);
        prod2 = MULTIPLY_ADD1(mul2, modulus[0], temp2[0]);

        // Replace temp1 by (temp1 + b[j]*a - LOW_DIGIT(prod1))/RADIX
        // Replace temp2 by (temp2 + mul2*modulus - LOW_DIGIT(prod2))/RADIX

        assert (LOW_DIGIT(prod1) == LOW_DIGIT(prod2));

        carry1 = HIGH_DIGIT(prod1);
        carry2 = HIGH_DIGIT(prod2);

        for (i = 1; i != lng; i++) {
            prod1 = MULTIPLY_ADD2(mul1,       a[i], temp1[i], carry1);
            prod2 = MULTIPLY_ADD2(mul2, modulus[i], temp2[i], carry2);
            temp1[i-1] = LOW_DIGIT(prod1);
            temp2[i-1] = LOW_DIGIT(prod2);
            carry1 = HIGH_DIGIT(prod1);
            carry2 = HIGH_DIGIT(prod2);
        }
        temp1[lng-1] = carry1;
        temp2[lng-1] = carry2;
    }
    OK = OK && sub_mod(temp1, temp2, c, modulus, lng, PBIGCTX_PASS);
    return OK;
} // modmul_from_right_default;
/******************************************************************************/
#if TARGET == TARGET_IX86 && USESSE2
static BOOL WINAPI modmul_from_right_SSE2
        (digit_tc *a,              // IN
         digit_tc *b,              // IN
         digit_t  *c,              // OUT
         mp_modulus_tc *pmodulo,   // IN
         digit_t  *temps,          // TEMPORARIES, at least 8*lng + 3
         PBIGCTX_ARG)
/*
        With modmul_from_right_default (above), the computations on
    (a, carry1, mul1, prod1, temp1) are very similar to those on
    (modulus, carry2, mul2, prod2, temp2).
    This module takes advantage thereof, using X86 SSE2 instructions.

        The last code often fetches a[i] and modulus[i] together.
    We construct one temporary array with lng 128-bit words (hence 4*lng digit_t
    elements), whose i-th element contains (0, a[i], 0, modulus[i]).
    Another array of this length has (0, temp1[i], 0, temp2[i]).
*/
{
    BOOL OK = TRUE;
    DWORDREGC lng = pmodulo->length;
    digit_tc *modulus = pmodulo->modulus;
    digit_tc minv = pmodulo->right_reciprocal_1;
    digit_tc minva0 = minv*a[0];    // mod RADIX
    const __m128i mask02 = _mm_set_epi32(0, RADIXM1, 0, RADIXM1);
    __m128i *temp12 = ptr_roundup_m128i(temps);  // Length lng
    __m128i *a_modulus = temp12 + lng;           // Length lng
    __m128i carry12, mul12, prod12;
    DWORDREG i, j;

    PBIGCTX_UNUSED;
    assert (pmodulo->modmul_algorithm_temps == 8*lng + 3);

    for (i = 0; i != lng; i++) {
        a_modulus[i] = _mm_set_epi32(0, a[i], 0, modulus[i]);
        temp12[i] = _mm_setzero_si128();
    }
    for (j = 0; j != lng; j++) {
        digit_tc mul1 = b[j];
        digit_tc mul2 = minva0*mul1
               + minv*(SSE2_digit2(temp12[0]) - SSE2_digit0(temp12[0]));
                                                            // Modulo RADIX
        mul12 = _mm_set_epi32(0, mul1, 0, mul2);
        prod12 = _mm_add_epi64(temp12[0], _mm_mul_epu32(mul12, a_modulus[0]));

        // Replace temp1 by (temp1 + b[j]*a - LOW_DIGIT(prod1))/RADIX
        // Replace temp2 by (temp2 + mul2*modulus - LOW_DIGIT(prod2))/RADIX

        assert (SSE2_digit0(prod12) == SSE2_digit2(prod12));
        carry12 = _mm_srli_epi64(prod12, 32);
                // Upper halves of products:  (0, carry1, 0, carry2)

        for (i = 1; i != lng; i++) {
            prod12 = _mm_add_epi64(_mm_add_epi64(carry12, temp12[i]),
                                   _mm_mul_epu32(mul12, a_modulus[i]));
            temp12[i-1] = _mm_and_si128(mask02, prod12);   // Lower halves
            carry12 = _mm_srli_epi64(prod12, 32);          // Upper halves
        }
        temp12[lng-1] = carry12;
    } //for j

//      Do the equivalent of sub_same, but with non-contiguous input.
    {
        digit_t borrow = 0;
        for (i = 0; i != lng; i++) {
            digit_tc ai = SSE2_digit2(temp12[i]);
            digit_tc bi = SSE2_digit0(temp12[i]);
            digit_tc ci = ai - bi - borrow;
            c[i] = ci;
            borrow = ai ^ ((ai ^ bi) | (ai ^ ci));  // MAJORITY(~ai, bi, ci)
            borrow >>= (RADIX_BITS - 1);
        }
        if (borrow != 0) borrow -= add_same(c, modulus, c, lng);
        assert (borrow == 0);
    }
    return OK;
} // modmul_from_right_SSE2
#endif // TARGET_IX86
/******************************************************************************/
BOOL WINAPI modmul_choices1
        (mp_modulus_t *pmodulo,        // IN/OUT
         int          *pindex,         // IN/OUT
         PBIGCTX_ARG)
/*
            This procedure (and any other modmul_choicesX ones it calls)
        looks for a suitable modmul_algorithm.  The selection algorithm
        can look at:

              1)  TARGET, the target architecture (compile-time parameter)
              2)  Instruction-availability flags, such as SSE2_available.
              3)  Fields in the pmodulo struct, such as the length and the
                  FROM_LEFT/FROM_RIGHT flag.  A Karatsuba routine might
                  accept only moduli beyond a specific length.
                  Another routine might accept only Mersenne prime moduli.

            Each modmul_algorithm should be able to do both squarings and
        general multiplications.  It might branch to separate squaring code,
        but that check will be made when the routine is called, not now.

            If *pindex = 5 (say) on entry, then the fifth qualifying routine
        will be used.  During testing, the test routine calls this once
        with *pindex = 0, ending with *pindex = -k where k is the number
        of routines accepting this modulus.  Then it makes one call each with
        *pindex = 1, 2, ..., k, checking that all k procedures
        give consistent results (and perhaps comparing their timings).
        During production, the second call uses *pindex = k, and the
        final qualifying one is chosen.  For this reason, faster codes
        (typically assembly language versions) should appear last.

            Each routine accepting the modulus should save its address,
        its name, and the number of digit_t temporaries it will need.
*/
{
    BOOL OK = TRUE;
    int index = *pindex;
    DWORDREGC lng = pmodulo->length;

    PBIGCTX_UNUSED;
    pmodulo->modmul_algorithm_name = NULL;

    if (pmodulo->reddir == FROM_LEFT) {
        index--;
        if (index >= 0) {
            pmodulo->modmul_algorithm = modmul_from_left_default;
            pmodulo->modmul_algorithm_name
                = _bignum_DEBUG_ARGUMENT("modmul_from_left_default");
            pmodulo->modmul_algorithm_temps = 2*lng;
        }
    } else if (pmodulo->reddir == FROM_RIGHT) {
        index--;
        if (index >= 0) {
            pmodulo->modmul_algorithm = modmul_from_right_default;
            pmodulo->modmul_algorithm_name
                = _bignum_DEBUG_ARGUMENT("modmul_from_right_default");
            pmodulo->modmul_algorithm_temps = 2*lng;
        }
#if TARGET == TARGET_IX86 && USESSE2
        if (SSE2_available) {
            index--;
            if (index >= 0) {
                pmodulo->modmul_algorithm = modmul_from_right_SSE2;
                pmodulo->modmul_algorithm_name
                    = _bignum_DEBUG_ARGUMENT("modmul_from_right_SSE2");
                pmodulo->modmul_algorithm_temps = 8*lng + 3;
            }
        }
#endif
    } else {    // Neither FROM_LEFT nor FROM_RIGHT
    }
    *pindex = index;
 // TBD   modmul_choicesSSE2(pmodulo, pindex);   // SSE2 algorithms
#if 0
    printf("Name = %s\n", (pmodulo->modmul_algorithm_name ?
                           pmodulo->modmul_algorithm_name : "Unknown"));
#endif
    return OK;
} // end modmul_choices1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\modsqrt.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"
#include "mprand.h"
/*
//      BOOL mod_sqrt(base, answer, modulo, psquare) --
//              Compute a square root
//              answer = +- sqrt(base) mod modulo->modulus.
//              modulo->modulus should be a prime.
//              Set *psquare = TRUE if successful, FALSE if unsuccessful
*/
/***************************************************************************/
BOOL WINAPI mod_sqrt
        (digit_tc       base[],           // IN
         digit_t        answer[],         // OUT
         mp_modulus_tc *modulo,           // IN
         BOOL          *pperfect_square,  // OUT
         PBIGCTX_ARG)
/*
        Compute a square root answer = +- sqrt(base) mod modulo->modulus.
        modulo->modulus should be prime.
        Set *perfect_square = TRUE is successful, FALSE if not.

        base and answer must not overlap.
*/
{
    BOOL OK = TRUE;
    BOOL perfect_square = TRUE;
    DWORDREGC elng = modulo->length;
    digit_t *dtemps = digit_allocate(6*elng + modulo->modmul_algorithm_temps,
                                    "mod_sqrt", PBIGCTX_PASS);
    if (dtemps == digit_NULL) {
        OK = FALSE;
    } else if (base == digit_NULL || answer == digit_NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "mod_sqrt", PBIGCTX_PASS);
    } else if (base == answer) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_OVERLAPPING_ARGS, "mod_sqrt", PBIGCTX_PASS);
    } else if (all_zero(base, elng)) {
        perfect_square = TRUE;
        mp_copy(base, answer, elng, PBIGCTX_PASS);      // sqrt(0) = 0
    } else {
        int ntry = 0;
        BOOL verified = FALSE;
        digit_t *C0 = dtemps;
        digit_t *exponent = dtemps + elng;
        digit_t *temp1 = dtemps + 2*elng;
        digit_t *temp2 = dtemps + 3*elng;
        digit_t *U = dtemps + 4*elng;
        digit_t *V = dtemps + 5*elng;
        digit_t *modmultemps = dtemps + 6*elng;

        switch (modulo->modulus[0] & 7) {
        case 0:
        case 2:
        case 4:
        case 6:
            if (compare_immediate(modulo->modulus, 2, elng) == 0) {
                mp_copy(base, answer, elng,
                        PBIGCTX_PASS);  // sqrt(x) == x mod 2
            } else {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                                "mod_sqrt -- not prime",
                                PBIGCTX_PASS);
            }
            break;
        case 3:
        case 7:
                  // p == 3 mod 4
                  // Let answer == base^((p+1)/4)
                  // Then answer^2 == base*((p+1)/2) == base
                  //      if base is a square

            OK = OK && mp_shift(modulo->modulus, -2, exponent,
                                elng, PBIGCTX_PASS);// (p-3)/4
            if (OK) add_immediate(exponent, 1, exponent, elng);      // (p+1)/4
            OK = OK && mod_exp(base, exponent, elng,
                               answer, modulo, PBIGCTX_PASS);
            break;
        case 5:
            // p == 5 mod 8.
            // Let temp1 == (2*base)^((p - 5)/8))
            // answer = base*temp1 * (2*base*temp1^2 - 1)
            // Then
            //      4*base^2 * temp1^4 = (2 * base)^(2 + (p-5)/2)
            //                         = (2 * base)^ ((p-1)/2) == -1
            //      if base is a square, since 2 is a non-residue.
            // Hence
            //      answer^2
            //       = (base*temp1)^2 * (4*base^2*temp1^4 - 4*base*temp1^2 + 1)
            //       == (base^2 * temp1^2) * (-4*base*temp1^2)
            //       == -4 * base^3 * temp1^4
            //       == base

            OK = OK && mp_shift(modulo->modulus, -3, exponent,
                                elng, PBIGCTX_PASS);// (p-5)/8
            OK = OK && mod_add(base, base, temp2,
                               modulo, PBIGCTX_PASS);    // 2*base
            OK = OK && mod_exp(temp2, exponent, elng, temp1,
                               modulo, PBIGCTX_PASS);

            OK = OK && mod_mul(base, temp1, temp2, modulo,
                               modmultemps, PBIGCTX_PASS);
                                    // temp2 = base*temp1
            OK = OK && mod_mul(temp2, temp1, temp1, modulo,
                               modmultemps, PBIGCTX_PASS);
            OK = OK && mod_add(temp1, temp1, temp1, modulo, PBIGCTX_PASS);
            OK = OK && mod_sub(temp1, modulo->one, temp1,
                               modulo, PBIGCTX_PASS);
            OK = OK && mod_mul(temp2, temp1, answer, modulo,
                               modmultemps, PBIGCTX_PASS);
                                   // answer = temp2 * (2*temp2*temp1 - 1)
            break;
        case 1:
            // p == 1 mod 8
            // Let C0 = base/4
            // Choose C1 in GF(p) randomly.
            // Let alpha, beta satisfy C1 = alpha + beta
            //                     and C0 = alpha * beta

            // Compute
            //        V = alpha^((p+1)/2) + beta^((p+1)/2)
            //        U = (alpha^((p+1)/2) - beta^((p+1)/2)) / (alpha - beta)

            // Observe X^2 - C1*X + C0 = (X - alpha) * (X - beta).

            // If alpha, beta in GF(p),
            //        then alpha^p = alpha and beta^p = beta
            //        (alpha*beta)^((p-1)/2) = C0^((p-1)/2) = 1.
            //        alpha^((p-1)/2) = beta^((p-1)/2)) = k, where k = +-1.
            //        U = (alpha^((p+1)/2) - beta^((p+1)/2)) / (alpha - beta)
            //          = (alpha*k - beta*k)/(alpha - beta) = +- 1.

            // Otherwise alpha, beta in GF(p^2) \ GF(p).
            //        Here alpha^p = beta and beta^p = alpha.
            //        Then V^2 = alpha^(p+1) + 2*(alpha*beta)^((p+1)/2)
            //                               + beta^(p+1)
            //                 = 2*alpha*beta + 2*C0^((p+1)/2)) = 4*C0 = base
            //        if base is a square.

            // In other words, either V^2 = base or U = +- 1,
            //        if base is a square.

            OK = OK && mod_shift(base, -2, C0,
                                 modulo, PBIGCTX_PASS);     // C0 = base/4
            OK = OK && mp_shift(modulo->modulus, -1, exponent,
                                elng, PBIGCTX_PASS);
                                                            // (p-1)/2 (even)
            exponent[0] |= 1;                               // (p+1)/2
            ntry = 0;
            while (OK && !verified) {
                ntry++;
                if (ntry > 100) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_TOO_MANY_ITERATIONS,
                                    "mod_sqrt",
                                    PBIGCTX_PASS);
                }
                OK = OK && random_mod(modulo->modulus, temp1,
                                      elng, PBIGCTX_PASS);   // C1
                OK = OK && mod_LucasUV(temp1, C0, exponent,
                                       elng, U, V, modulo, PBIGCTX_PASS);
                OK = OK && mod_mul(V, V, temp2, modulo,
                                   modmultemps, PBIGCTX_PASS);
                if (!OK) {
                } else if (compare_same(temp2, base, elng) == 0) {
                    verified = TRUE;
                    perfect_square = TRUE;
                    mp_copy(V, answer, elng, PBIGCTX_PASS);
                } else {
                    sub_same(modulo->modulus, modulo->one, temp1, elng);  // -1
                    if (OK && compare_same(U, modulo->one, elng) != 0
                           && compare_same(U, temp1, elng) != 0) {
                        verified = TRUE;
                        perfect_square = FALSE;
                                // non-residue or non-prime modulus
                    }
                }
            } // while
            break;
        } /* switch */

        if (!verified) {
            OK = OK && mod_mul(answer, answer, temp2, modulo,
                               modmultemps, PBIGCTX_PASS);
            if (OK && compare_same(temp2, base, elng) != 0) {
                perfect_square = FALSE;
            }
        }
    }
    if (dtemps != digit_NULL) {
        Free_Temporaries(dtemps, PBIGCTX_PASS);
    }
    if (OK) *pperfect_square = perfect_square;
    return OK;
} /* mod_sqrt */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\modexp.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"
/*
        File modexp.c.  Modular_exponentiation routines.

    July, 2001 -- Added checking for base = 2 in mod_exp2000.

        BOOL mod_exp(base, exponent, lngexpon, answer, modulo) --
                        Compute answer = base^exponent mod modulo->modulus.
                        Exponent is multiple-precision, with length
                        lngexpon.  If modulo->reddir == FROM_RIGHT,
                        then inputs should have been pre-scaled
                        and output will be similarly scaled.

                        If answer == DIGIT_NULL, this count is
                        returned but the computations are skipped.


        BOOL mod_exp2000(base, exponent, lngexpon,
                        answer, modulo, stats)
                     -- Compute answer = base^exponent mod modulo->modulus.
                        Similar to mod_exp, but statistics
                        are returned in a struct of type
                        mod_exp_stats_t, which may grow in the future.
                        The 2000 version of the code stores fewer
                        Karatsuba images, to reduce memory requirements
                        and hopefully improve cache utilization.

                        If answer == DIGIT_NULL, the statistics are
                        returned but the computations are skipped.

        mod_exp_immediate(base, exponent, answer, modulo) --
            (see modexpi.c)
                        Special case of mod_exp where exponent
                        is single-precision.

            Function mod_exp (modular exponentiation)
        computes b^e (modulo something).
        Here b and e are multiple precision, typically
        from 512 to 2048 bits.  We strive hard to keep
        the number of multiplications low.

            For a treatise on methods of exponentiation,
        see Section 4.6.3 of Donald E. Knuth, The Art of
        Computer Programming, Volume 2, Seminumerical Algorithms,
        2nd Edition, 1981.

            The classical left-to-right binary method of exponentiation
        (Knuth, p. 441) looks at one bit of the exponent at a
        time, starting from the most significant bit.
        It requires  log2(e) + (number of 1's in e) - 1
        multiplications (or squarings), which averages about
        (3/2)*log2(e) multiplications for a random exponent
        with log2(e)+1 bits.

            When e is large, this cost can be reduced by using
        radix 2^k for suitable k (Knuth, p. 446).
        The cost is 2^k - 2 multiplications to build a table with
        b^0 = 1,  b^1 = b,  b^2,  b^3,  ... ,  b^(2^k - 1).
        After this table is built, there will be about log2(e)/k steps
        consisting of k squarings and a multiplication by a table entry.
        The final multiply can be skipped when the table entry is
        b^0 = 1, which occurs with probability about 2^(-k).
        The approximate cost of the radix 2^k method (Knuth, p. 451) is

                              log2(e)           log2(e)
           2^k + (k+1-2^(-k)) -------  =  2^k + -------(1 - 2^(-k)) + log2(e)
                                 k                 k

            mod_exp1995 (no longer here) usea a modified method with radix
        2^k and cost about

                         log2(e)
(*)            2^(k-1) + -------  + log2(e).
                           k+1

        It resembled that in ``Fast square-and-multiply
        exponentiation for RSA'' by L. C. K. Hui and K.-Y. Lam,
        Electronics Letters, 18 August 1994, Volume 30, No, 17,
        pp. 1396-1397, Electronics Letters Online No. 19940949.

            The upcoming presentation assumes k = 6.
        A recursive formulation of the mod_exp1995 algorithm resembles

                if e is small then
                    Use table look-up for b^e
                else if e is even
                    Compute  b^e  as  (b^(e/2))^2
                else
                    Compute  b^e  as  (b^j)^64 * b^i,
                    where e = 64 * j + i and 0 <= i <= 63
                end if

        Except possibly when initializing the recursion
        (i.e., to compute b^e where e is `small'), the algorithm needs
        only the odd powers  b^1,  b^3,  b^5,  ...,  b^63.
        It costs 32 = 2^(k-1) multiplications to compute
        b^2 and this table.

            Half of the time this value of i
        (i.e., where e = 64*j + i) will be in [0, 31].
        In those cases, we can delay the multiplication by b^i
        for one step, merely replacing x by x^2 at this time
        and awaiting another bit of the exponent.
        This explains the denominator (k+1) in (*).

            The optimal k (i.e., the one requiring the fewest
        multiplications) depends upon the exponent e.
        According to (*), the value k is better than k-1 if

                      log2(e)                           log2(e)
            2^(k-1) + -------  + log2(e)  <   2^(k-2) + ------- + log2(e) .
                        k+1                                k

                                           log2(e)
        This is equivalent to  2^(k-2)  <  -------  and to
                                           k (k+1)

        log2(e) > k (k+1) 2^(k-2)


            k         Approximate log2(e)
                      where k first beats k-1

            2            6
            3           24
            4           80
            5          240
            6          672
            7         1680
            8         4608

        For a 1024-bit exponent, this analysis suggests using k = 6
        since 672 <= 1024 <= 1680.  The estimated costs
        for a 1024-bit exponent are

            k         2^(k-1) + 1024/(k + 1) + 1024

            1         1537
            2         1367.3
            3         1284
            4         1236.8
            5         1210.7
            6         1202.3
            7         1216
            8         1265.8

        The estimated costs for k = 5, 6, 7 vary by less than 1.2%.
        The precise costs will depend upon the bit pattern in
        the exponent.  The code tries multiple values of k,
        determining the cost associated with each radix,
        and selects the one with the smallest cost.

        mod_exp2000 uses a window of width 2^k on the exponent.
        There are bucket_max = 2^k - 1 buckets bucket[1]
        to bucket[bucket_max], all initialized to 1.
        The final result is intended to be

           answer = bucket[1]^1 * bucket[2]^2 * bucket[3]^3 * ...
                                * bucket[bucket_max]^bucket_max

        Except during final processing, all even-numbered buckets
        are empty (i.e., contain 1)


*/

#if TARGET_OS == OS_WCE
         // Opt for less memory under Windows CE
#define MAX_BUCKET_WIDTH 5
#else
#define MAX_BUCKET_WIDTH 6
#endif


typedef struct {         // Temps and interface for mod_exp2000 and helpers
        BOOL             stats_only;
        mod_exp_stats_t *pstats;
        mp_modulus_tc   *modulo;
        BOOL             bucket_occupied[1L << MAX_BUCKET_WIDTH];
        digit_t         *bucket_location[1L << MAX_BUCKET_WIDTH];
        digit_t         *modmultemps;  // Length modmul_algorithm_temps
    } temps2000_t;

#define temps2000_NULL  ((temps2000_t*)0)

/***************************************************************************/

/*
      basepower_squaring and bucket_multiply are helpers to mod_exp2000.

      bucket_multiply multiplies the contents
      of bucket[ibucket] by multiply_by.

      basepower_squaring replaces basepower by basepower^2.

      The temps struct is used to share miscellaneous
      local and malloc-ed data with mod_exp2000.
*/

static BOOL WINAPI basepower_squaring(
        digit_t      *basepower,               // IN/OUT
        temps2000_t  *temps,                   // IN/OUT
        PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    mp_modulus_tc *modulo     = temps->modulo;
    const BOOL     stats_only = temps->stats_only;
    mod_exp_stats_t *pstats   = temps->pstats;

    pstats->cnt_mod_mul++;
    if (!stats_only) {
        OK = OK && mod_mul(basepower, basepower, basepower,
                           modulo, temps->modmultemps, PBIGCTX_PASS);
    }
    return OK;
} // end basepower_squaring



static BOOL bucket_multiply
        (DWORDREGC    ibucket,                  // IN
         digit_tc     multiply_by[],            // IN
         temps2000_t *temps,                    // IN/OUT
         PBIGCTX_ARG)
{
    BOOL OK = TRUE;
    digit_t       *bloc       = temps->bucket_location[ibucket];
    mp_modulus_tc *modulo     = temps->modulo;
    DWORDREGC      elng       = modulo->length;
    const BOOL     stats_only = temps->stats_only;
    mod_exp_stats_t *pstats   = temps->pstats;

    if (temps->bucket_occupied[ibucket]) {
        pstats->cnt_mod_mul++;

        if (!stats_only) {
            mod_mul(bloc, multiply_by, bloc, modulo,
                    temps->modmultemps, PBIGCTX_PASS);
        }
    } else {
        temps->bucket_occupied[ibucket] = TRUE;
        pstats->cnt_mp_copy++;

        if (!stats_only) {
            mp_copy(multiply_by, bloc, elng, PBIGCTX_PASS);
        }
    }
    return OK;
} // end bucket_multiply




BOOL WINAPI mod_exp2000
        (digit_tc         base[],
         digit_tc         exponent[],
         DWORDREGC        lngexpon,
         digit_t          answer[],
         mp_modulus_tc   *modulo,
         mod_exp_stats_t *stats,
         PBIGCTX_ARG)

{
    BOOL OK = TRUE;
    const BOOL stats_only = (answer == digit_NULL);
    DWORDREGC elng = modulo->length;
    DWORDREGC exponent_bits_used
             = mp_significant_bit_count(exponent, lngexpon, PBIGCTX_PASS);
    const unsigned short width_cutoffs[] = {6, 24, 80, 240, 672};
                                           // (k + 2)*(k + 3) * 2^k

    temps2000_t *temps = temps2000_NULL;       // malloc-ed
    digit_t *basepower = answer;           // Same array used for both
    digit_t *bucket_data = digit_NULL;     // malloc-ed

    DWORDREG bucket_mask, bucket_width, carried;
    DWORDREG ibit, ibucket, max_bucket, ndoubling;
    BOOL base2;

    stats->cnt_mp_copy = 0;
    stats->cnt_mod_mul = 0;
    stats->cnt_mod_add = 0;
    stats->cnt_mod_shift = 0;

    bucket_width = 1;
    while (    bucket_width < MAX_BUCKET_WIDTH
            && (DWORD)width_cutoffs[bucket_width-1] < exponent_bits_used) {
        bucket_width++;
    }

    OK = OK && validate_modular_data(base, modulo->modulus, elng,
                                     "mod_exp2000", PBIGCTX_PASS);

    bucket_mask = (DIGIT_ONE << bucket_width) - 1;
    max_bucket = bucket_mask;   // Another name for the variable

    Allocate_Temporaries(temps2000_t, temps, PBIGCTX_PASS);
    bucket_data = digit_allocate(
               elng*max_bucket + modulo->modmul_algorithm_temps,
               "mod_exp2000", PBIGCTX_PASS);

    OK = OK && temps != temps2000_NULL && bucket_data != digit_NULL;

    base2 = FALSE;
    if (OK) {
        temps->stats_only = stats_only;
        temps->modulo = modulo;
        temps->pstats = stats;
        temps->bucket_location[0] = digit_NULL;
        temps->modmultemps = bucket_data + elng*max_bucket;

        //  Check for base = 2.  When base = 2, use alternate algorithm.
        //  (squarings and doublings).

        OK = OK && mod_add(modulo->one, modulo->one,
                           bucket_data, modulo, PBIGCTX_PASS);
                                                        /* bucket_data = 2 */
        base2 = OK && compare_same(base, bucket_data, elng) == 0;
    }
    if (!OK) {
    } else if (base2 && exponent_bits_used != 0) {
        DWORDREGC shift_max = MIN(RADIX_BITS*elng, 1024);
        DWORDREG ibit;
        DWORDREG high_expon_bits = 0;
        BOOL high_bits_processed = FALSE;
        digit_t *dtemp = bucket_data; /* Some convenient temporary */

        /*
             Start at the most significant end of the exponent.
             Accumulate the first few bits in high_expon_bits.
             As long as 2^high_expon_bits is about the
             same size as the modulus, or smaller,
             continue this accumulation.

             While processing the lower bits of the exponent,
             do repeated squaring, plus a doubling
             where the exponent bit is 1.

        */
#if 0 && PRINT_ERROR_MESSAGES
        printf("Doing a base 2 exponentiation\n");
#endif
        for (ibit = exponent_bits_used; OK && (ibit--) != 0; /*null*/) {
            DWORDREGC iexpbit = (DWORDREG)mp_getbit(exponent,
                                                    ibit, PBIGCTX_PASS);

            if (high_bits_processed) {

                stats->cnt_mod_mul++;
                stats->cnt_mod_add += iexpbit;
                if (!stats_only) {
                    OK = OK && mod_mul(dtemp, dtemp, dtemp,
                                       modulo, temps->modmultemps,
                                       PBIGCTX_PASS);
                    if (iexpbit != 0) {
                        OK = OK && mod_add(dtemp, dtemp, dtemp,
                                           modulo, PBIGCTX_PASS);
                    }
                }
            } else {  /* high_bits_processed */
                high_expon_bits = 2*high_expon_bits + iexpbit;
                if (   ibit == 0
                    || 2*high_expon_bits >= shift_max) {

                    high_bits_processed = TRUE;
                    if (!stats_only) {
                        OK = OK && mod_shift(modulo->one,
                                  (int)high_expon_bits,
                                  dtemp, modulo, PBIGCTX_PASS);
                    }
                }
            } /* high_bits_processed */
        } /* for ibit */
        temps->bucket_location[1] = dtemp;  /* For copy into answer */

        if (!high_bits_processed) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "mod_exp2000 -- high_bits_processed = FALSE",
                            PBIGCTX_PASS);
        }
    } else {  /* not base2 */

         // Partition bucket_data array into length-elng
         // pieces for individual buckets.
         // Allocate pieces for odd-numbered buckets
         // contiguously, to lessen cache conflicts.

        for (ibucket = 1; OK && ibucket <= max_bucket; ibucket++) {
            digit_t *bloc = bucket_data
                + elng*(ibucket - 1 + (IS_EVEN(ibucket) ? max_bucket : 0))/2;

            temps->bucket_location[ibucket] = bloc;
            temps->bucket_occupied[ibucket] = FALSE;
            if (stats_only) {
                temps->bucket_location[ibucket] = digit_NULL;
            } else {
                mp_copy(modulo->one, bloc, elng, PBIGCTX_PASS);
                                                      // Set bucket contents = 1
            }
        }  // for ibucket

        stats->cnt_mp_copy += max_bucket + 1;

        if (OK && !stats_only) {
            mp_copy(base, basepower, elng, PBIGCTX_PASS);    // basepower = base
        }
        carried = 0;
        ndoubling = 0;

        for (ibit = 0; OK && ibit != exponent_bits_used; ibit++) {
            digit_tc bit_now = mp_getbit(exponent, ibit, PBIGCTX_PASS);

            // Want bucket[1]^1 * ... * bucket[max_bucket]^max_bucket
            //  * basepower^ (2^ndoublings * remaining exponent bits + carried)
            // 0 <= carried <= 2^(bucket_width + 2) - 1

            if (carried >> (bucket_width + 2) != 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "mod_exp2000 -- carried overflow",
                                PBIGCTX_PASS);
            }

            if (bit_now != 0) {
                while (OK && ndoubling >= bucket_width + 1) {
                    if (IS_ODD(carried)) {
                        ibucket = carried & bucket_mask;
                        carried -= ibucket;
                        OK = OK && bucket_multiply(ibucket, basepower,
                                                   temps, PBIGCTX_PASS);
                    }
                    OK = OK && basepower_squaring(basepower,
                                                  temps, PBIGCTX_PASS);
                    carried /= 2;
                    ndoubling--;
                }
                carried |= (DWORDREG)1 << ndoubling;
            }
            ndoubling++;
        } // for ibit

        while (OK && carried != 0) {
            BOOL square_now = FALSE;

            if (carried <= max_bucket) {
                ibucket = carried;
            } else if (IS_EVEN(carried)) {
                square_now = TRUE;
            } else if (carried <= 3*max_bucket) {
                ibucket = max_bucket;
            } else {
                ibucket = carried & bucket_mask;
            }
            if (square_now) {
                carried /= 2;
                OK = OK && basepower_squaring(basepower,
                                              temps, PBIGCTX_PASS);
            } else {
                carried -= ibucket;

                OK = OK && bucket_multiply(ibucket, basepower,
                                           temps, PBIGCTX_PASS);
            }
        } // while carried

        for (ibucket = max_bucket; OK && ibucket >= 2; ibucket--) {
            if (temps->bucket_occupied[ibucket]) {
                BOOL found = FALSE;
                DWORDREG jbucket, jbucketlargest, kbucket;
                digit_t *bloci;

                // Try to find jbucket, kbucket, such that
                // jbucket+kbucket = ibucket, both occupied.

                if (IS_EVEN(ibucket)) {
                         // Defaults in case no jbucket found below
                    jbucketlargest = ibucket/2;
                } else {
                    jbucketlargest = 1;
                }
                for (jbucket = ibucket >> 1;
                    jbucket != ibucket && !found;
                    jbucket++) {

                    if (temps->bucket_occupied[jbucket]) {
                        jbucketlargest = jbucket;
                        found = temps->bucket_occupied[ibucket - jbucket];
                    }
                }
                jbucket = jbucketlargest;
                kbucket = ibucket - jbucket;

                   // Deposit ibucket contents at jbucket and kbucket.

                bloci = temps->bucket_location[ibucket];

                OK = OK && bucket_multiply(jbucket, bloci, temps, PBIGCTX_PASS);

                OK = OK && bucket_multiply(kbucket, bloci, temps, PBIGCTX_PASS);

            } // if ibucket occupied
        }  // for ibucket
    } // if base 2

    stats->cnt_mp_copy++;
    if (OK && !stats_only) {
        mp_copy(temps->bucket_location[1], answer, elng, PBIGCTX_PASS);
    }
    if (bucket_data != digit_NULL) {
        Free_Temporaries(bucket_data, PBIGCTX_PASS);
    }
    if (temps != temps2000_NULL) {
        Free_Temporaries(temps, PBIGCTX_PASS);
    }
 // printf("mod_exp_2000, OK = %ld\n", (long)OK);
    return OK;
} // end mod_exp2000
/***************************************************************************/
BOOL WINAPI mod_exp
        (digit_tc       base[],
         digit_tc       exponent[],
         DWORDREGC      lngexpon,
         digit_t        answer[],
         mp_modulus_tc *modulo,
         PBIGCTX_ARG)
/*
      Interface routine, no statistics returned to caller.
*/
{
    mod_exp_stats_t stats;
    return mod_exp2000(base, exponent, lngexpon, answer,
                       modulo, &stats, PBIGCTX_PASS);
}   // end mod_exp
/***************************************************************************/
#undef temps2000_NULL
#undef MAX_BUCKET_WIDTH
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\mpalloc.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"
/*
        File mpalloc.c.   Version 20 November, 2002


        This file has helpers for bignum allocation requests.
        The user must provide

             void* bignum_alloc(size_t cblen)
             void  bignum_free(void *pvMem)
             void* bignum_realloc(void * pvMem, size_t cblen)

        with semantics matching the standard C
        routines malloc, free, realloc.
        [bignum_realloc is not used as of November, 2002.]

            In debug mode (ALLOCATION_STATISTICS = TRUE)
        this file keeps track of memory reguests.
        The code herein inserts a pattern after each
        memory block, verifying that the pattern is unchanged
        when the block is later released.

            In debug mode, the Allocate_Temporaries and
        Allocate_Temporaries_Multiple macro expansions
        pass a string with the file name and line number of the caller.
        In digit_allocate and possible_digit_allocate the user
        supplies a string himself.  The allocation helpers
        remember this string, in order to identify problems,
        such as failure to free the memory.

            In debug mode, for every 131072-th memory allocation,
        this identifying string is printed to standard output.
        The purpose is to assist in improving the application,
        by identifying allocation hot spots.  For example,
        if procedure A calls procedure B repeatedly, it may
        improve performance if A can allocate the temporary storage
        B will need rather than have B do it repeatedly.

        BUG -- The (debug mode) code to monitor memory allocations
        does not function in multi-threaded mode.

    Application-callable routines and macros:

            (macro) Allocate_Temporaries(typename, ptr)
            (macro) Allocate_Temporaries_Multiple(DWORDREG nelmt, typename, ptr)

                 Allocate an array with nelmt elements of type typename,
                 storing the result in ptr (which should have type
                 (typename*)).  For Allocate_Temporaries, we use nelmt = 1.

                 If the memory cannot be allocated, we set ptr = NULL and
                 set the error status to MP_ERRNO_NO_MEMORY.

           (macro) Free_Temporaries(ptr)

                 Free a memory block returned by Allocate_Temporaries
                 or Allocate_Temporaries_Multiple or digit_allocate
                 or possible_digit_allocate.  Argument should not be NULL.

          (macro) digit_allocate(DWORDREG nelmt, const char *name)

                 Allocates nelmt elements of type digit_t.
                 In debug mode, -name- will be used to identify this storage.

          (macro) possible_digit_allocate(digit_tempinfo_t *tempinfo,
                                          const char *name)
                 For internal use only.  The tempinfo struct
                 holds the amount of data needed and a possible
                 address supplied (typically be the caller of the user).
                 Use the supplied address if not NULL,
                 but allocate if the supplied address is NULL.

         void WINAPI mp_print_allocation_statistics(FILE *f);

                 In debug mode, writes a summary of allocation
                 activity to file f, including a listing of
                 unreleased memory.

                 Does nothing if library was not compiled in debug mode.

                 It is recommended that an application attempt
                 to explicitly release all storage it acquires.
                 Shortly before termination, in debug mode,
                 call this and confirm there are no memory leaks.
 */


#define ALLOCATION_STATISTICS PRINT_ERROR_MESSAGES
           // Should not be activated in multi-threaded environment.

#if ALLOCATION_STATISTICS
#define ALLOC_PAIRS_REMEMBERED 30
#include <stdio.h>

static DWORDREG alloc_requests = 0;
static DWORDREG alloc_failures = 0;
static DWORDREG active_size_now = 0;
static DWORDREG active_size_maximum = 0;
static DWORDREG active_size_maximum_recently = 0;
static DWORDREG active_count_now = 0;
static DWORDREG active_count_maximum = 0;
static DWORDREG active_count_maximum_recently = 0;
static DWORDREG out_of_sequence_frees = 0;
static DWORDREG overwrites_detected = 0;
static BOOL active_table_has_overflowed = FALSE;


typedef struct {
        void    *ptr;
        charc   *source;
        DWORDREG    size;
} active_info_t;

typedef const active_info_t active_info_tc;

static active_info_t active_info[ALLOC_PAIRS_REMEMBERED];


static charc* WINAPI output_identification(charc *sinfo)
{
    return (sinfo == NULL ? "unknown source" : sinfo);
}


void WINAPI mp_print_allocation_statistics(FILE* fp, PBIGCTX_ARG)
{
    int itab;
    DWORDREG nleft;

    PBIGCTX_UNUSED;
    fprintf(fp, "----bignum heap allocation statistics\n");
    fprintf(fp, "Currently %ld objects allocated, total %ld bytes\n",
                  (long)active_count_now, (long)active_size_now);
    nleft = active_count_now;
    for (itab = 0; itab != ALLOC_PAIRS_REMEMBERED; itab++) {
        active_info_tc *ainfo = &active_info[itab];

        if (ainfo->ptr != 0) {
            nleft--;
            fprintf(fp, "   %ld bytes allocated at location %p by %s\n",
                        (long)ainfo->size, ainfo->ptr,
                        output_identification(ainfo->source));
        }
    }
    if (nleft != 0) {
        fprintf(fp, "WARNING -- Above list is missing %ld entries\n",
                    (long)nleft);
    }
    fprintf(fp, "%lu allocation requests have been made\n",
                (long)alloc_requests);
    fprintf(fp, "%lu of these requests were denied due to inadequate memory\n",
        (long)alloc_failures);
    fprintf(fp, "Maximum size allocated ="
                " %ld bytes (maximum %ld since last call)\n",
         (long)active_size_maximum, (long)active_size_maximum_recently);
    fprintf(fp, "Maximum objects allocated"
                " = %ld (maximum %ld since last call)\n",
         (long)active_count_maximum, (long)active_count_maximum_recently);
    fprintf(fp, "%ld frees were out of sequence\n",
                (long)out_of_sequence_frees);

    fprintf(fp, "%ld memory overwrites were detected\n",
        (long)overwrites_detected);
    active_size_maximum_recently = active_size_now;
    active_count_maximum_recently = active_count_now;
    fflush(fp);
} // end mp_print_allocation_statistics

#define END_PADDING 8
                   // Extra space at end of allocated region,
                   // to check for over-write.

                   // We do not check for under-write.
#else

#define END_PADDING 0

void WINAPI mp_print_allocation_statistics(void *fp, PBIGCTX_ARG)
{
    (void)fp;       // Avoid warning for unused argument
}

#endif    // ALLOCATION_STATISTICS


#if ALLOCATION_STATISTICS && PRINT_ERROR_MESSAGES


static void WINAPI print_memory_layout(FILE *fp)
{
    DWORDREG itab;

    fprintf(fp, " %ld active mp_alloc_temp calls.  Sizes:\n", active_count_now);
    for (itab = 0; itab != ALLOC_PAIRS_REMEMBERED; itab++) {
        active_info_tc *ainfo = &active_info[itab];
        if (ainfo->ptr != 0) {
            fprintf(fp, "     %ld by %s\n",
                    ainfo->size, output_identification(ainfo->source));
        }
    } // for itab
    fprintf(fp, "\n");
    fflush(fp);
} // end print_memory_layout
#endif



void* WINAPI mp_alloc_temp(DWORDREGC nbyte,
                           const char *source_info,
                           PBIGCTX_ARG)
{
    void* ptr = bignum_alloc((size_t)nbyte + END_PADDING, PBIGCTX_PASS);

    (void)source_info;    // Avoid warning for unused argument
#if ALLOCATION_STATISTICS
    alloc_requests++;
#if 1 && PRINT_ERROR_MESSAGES
    if (alloc_requests % 131072 == 0 && mp_errfil != NULL) {
        fprintf(mp_errfil, "Allocation request %lu from %s is for %ld bytes\n",
            (long)alloc_requests, output_identification(source_info),
            (long)nbyte);
    }
#endif
#endif

    if (ptr == 0) {
#if ALLOCATION_STATISTICS
        alloc_failures++;
#endif
#if PRINT_ERROR_MESSAGES
        fprintf(mp_errfil,
              "mp_alloc_temp -- Unable to allocate %ld bytes\n",
                  (long)nbyte);
        fflush(stdout);
#endif
        SetMpErrno_clue(MP_ERRNO_NO_MEMORY,
            (source_info == 0 ? "mp_alloc_temp" : source_info),
            PBIGCTX_PASS);

    } else {
#if ALLOCATION_STATISTICS
        BYTE *bptr = (BYTE*)ptr;
        DWORDREG i, itab;
        BOOL hole_found = FALSE;

        for (i = 0; i != END_PADDING; i++) {
             bptr[i + nbyte] = (BYTE)(100 + i);  // Pattern to check for
        }

        for (itab = 0; itab != ALLOC_PAIRS_REMEMBERED && !hole_found; itab++) {
            active_info_t *ainfo = &active_info[itab];
            if (ainfo->ptr == 0) {
                hole_found = TRUE;
                ainfo->ptr = (void *)ptr;
                ainfo->size = nbyte;
                ainfo->source = source_info;
            }
        }
        active_count_now++;
        active_count_maximum = MAX(active_count_now, active_count_maximum);
        active_count_maximum_recently
                        = MAX(active_count_now, active_count_maximum_recently);
        if (!hole_found) {
            if (!active_table_has_overflowed) {
                active_table_has_overflowed = TRUE;
#if PRINT_ERROR_MESSAGES
                fprintf(mp_errfil,
                     "mp_alloc -- active_pointer table overflow\n");
                print_memory_layout(mp_errfil);
#endif
            }
        } else {
            active_size_now += nbyte;
            active_size_maximum = MAX(active_size_now, active_size_maximum);
            active_size_maximum_recently
                = MAX(active_size_now, active_size_maximum_recently);
        }
#endif // ALLOCATION_STATISTICS
    }
#if 0
    printf("Returning %p to %s\n", ptr,
             output_identification(source_info));
#endif
    return (void *)ptr;
} /* mp_alloc_temp */
/*****************************************************************************/
void WINAPI mp_free_temp(void       *ptr,
                         const char *source_info,
                         PBIGCTX_ARG)
{
 //   printf("freeing %p at %s\n", ptr, output_identification(source_info));
     (void)source_info;     // Avoid warning for unused argument
     PBIGCTX_UNUSED;
    if (ptr == 0) {
#if PRINT_ERROR_MESSAGES
        fprintf(mp_errfil,
                "mp_free_temp -- freeing a null pointer at %s\n",
                output_identification(source_info));
#endif
    } else {
#if ALLOCATION_STATISTICS
        DWORDREG itab;
        BOOL entry_found = FALSE;
        active_count_now--;
        for (itab = 0; !entry_found && itab != ALLOC_PAIRS_REMEMBERED; itab++) {
            active_info_t *ainfo = &active_info[itab];
            if (ainfo->ptr == ptr) {
                BOOL corrupt = FALSE;
                BYTE *bptr = (BYTE*)ptr;
                DWORDREG i;
                DWORDREGC nbyte = ainfo->size;
                charc *whom = ainfo->source;

                entry_found = TRUE;
                active_size_now -= nbyte;
                ainfo->ptr = 0;
                ainfo->size = 0;
                ainfo->source = "nobody";

                if (itab != active_count_now) {
                    out_of_sequence_frees++;
                }
                for (i = 0; i != END_PADDING; i++) {
                    if (bptr[i + nbyte] != (BYTE)(100 + i)) corrupt = TRUE;
                }
                if (corrupt) {
                    fprintf(mp_errfil, "***** mp_free_temp --"
                        " Application before %s overwrote region of %ld\n"
                        " bytes starting at %p and allocated by %s\n",
                        output_identification(source_info),
                        (long)nbyte, ptr, output_identification(whom));
                    overwrites_detected++;
                }
            }
        } // for itab
#if PRINT_ERROR_MESSAGES
        if (!entry_found && !active_table_has_overflowed && mp_errfil != NULL){
            fprintf(mp_errfil, "WARNING -- Free_Temporaries called at %s with "
                               " unrecognized address %p\n",
                               output_identification(source_info), ptr);
            print_memory_layout(mp_errfil);
        }
#endif
#endif  // ALLOCATION_STATISTICS
        bignum_free(ptr, PBIGCTX_PASS);
    }
}  /* mp_free_temp */
/*****************************************************************************/
digit_t* WINAPI digit_allocate_named(DWORDREGC nelmt,
                                     const char *name,
                                     PBIGCTX_ARG)
/*
   Allocate an array with nelmt digit_t elements.
   May return digit_NULL if unsuccessful.

   The digit_allocate(nelmt, name) macro expands to
   digit_allocate_named(nelmt, name) if PRINT_ERROR_MESSAGES is set
   and to digit_allocate_named(nelmt, 0) otherwise.
*/
{
    digit_t *temps;
    temps = (digit_t*)mp_alloc_temp(nelmt*SIZEOF(digit_t), name, PBIGCTX_PASS);
#if 0 && PRINT_ERROR_MESSAGES
    fprintf(mp_errfil, "digit_allocate -- %ld digits requested by %s,"
                       " active_count = %ld\n",
                  (long)nelmt, output_identification(name),
                   active_count_now);
#endif

#if PRINT_ERROR_MESSAGES
    if (temps == digit_NULL) {
        fprintf(mp_errfil,
            "Cannot allocate %ld digit_t entities for %s\n",
            (long)nelmt, output_identification(name));
    }
#endif
    return temps;
} // end digit_allocate_named
/*****************************************************************************/
BOOL WINAPI possible_digit_allocate_named(digit_tempinfo_t *tempinfo,
                                   const char              *name,
                                   PBIGCTX_ARG)
/*
        Look at tempinfo.address.  If this has a non-NULL
        pointer, assume this array has the required space for
        temporaries.  If tempinfo.address is NULL
        and tempinfo.nelmt > 0, then allocate a temporary array,
        storing its address in tempinfo.address, and set tempinfo.need_to_free.
*/
{
    BOOL OK = TRUE;

    if (tempinfo->need_to_free) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "possible_digit_allocate",
                        PBIGCTX_PASS);
               // Caller is required to clear flag this beforehand.
    }

    if (OK && tempinfo->address == digit_NULL
           && tempinfo->nelmt != 0) {

        tempinfo->address = digit_allocate_named(tempinfo->nelmt,
                                                 name, PBIGCTX_PASS);
        if (tempinfo->address == digit_NULL) {
            OK = FALSE;
        } else {
            tempinfo->need_to_free = TRUE;
        }
    }
    return OK;
}  // end possible_digit_allocate_named
/*****************************************************************************/
#undef END_PADDING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\mpgcdex.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"
#ifndef assert
#include <assert.h>
#endif
/*
                File mp_gcdex.  Extended GCD algorithm on positive integers.
*/
static BOOL WINAPI lehmer_mat22(dblint_tc, dblint_tc,
                                digit_t[4], PBIGCTX_ARG); // This file

EXPORTED_INLINE DWORDREG WINAPI mp_gcdex_ntemps
       (DWORDREGC lnga,
        DWORDREGC lngb,
        PBIGCTX_ARG)
/* Return temporary count needed by mp_gcdex */
{
    PBIGCTX_UNUSED;
    return 8*MAX(lnga, lngb) + 6;
} // mp_gcdex_ntemps
/****************************************************************************/
EXPORTED_INLINE DWORDREG WINAPI mp_invert_ntemps(DWORDREGC lng, PBIGCTX_ARG)
/* Return temporary count needed by mp_invert */
{
    return lng + mp_gcdex_ntemps(lng, lng, PBIGCTX_PASS);
} // mp_invert_ntemps
/****************************************************************************/
BOOL WINAPI mp_gcdex
        (digit_tc  a[],             // IN  (nonzero)
         DWORDREGC lnga,            // IN
         digit_tc  b[],             // IN  (nonzero)
         DWORDREGC lngb,            // IN
         digit_t   ainvmodb[],      // OUT
         digit_t   binvmoda[],      // OUT (unless NULL)
         digit_t   gcd[],           // OUT
         digit_t   lcm[],           // OUT (unless NULL)
         DWORDREG  *plgcd,          // OUT -- contains length of GCD
         digit_t   *supplied_temps,
                              // TEMPS -- length mp_gcdex_ntemps(lnga, lngb)
         PBIGCTX_ARG)

/*
        Compute gcd = GCD(a, b) and return its length.
        Also return ainvmodb = gcd/a (mod b)
        and binvmoda = gcd/b (mod a), except that binvmoda
        is not computed if the input argument is digit_NULL.
        The length of ainvmodb will be lngb and
        that of binvmoda will be lnga.

        The gcd array should be dimensioned at least MIN(lnga, lngb).
        The output length will be stored in *plgcd.

        We require that a <> 0 and b <> 0.
        If lcm <> digit_NULL. then return lcm = LCM(a, b)
        (least common multiple); the LCM will have length lnga + lngb
        (possibly with leading zeros).
*/
{
    DWORDREGC lnga_sig = significant_digit_count(a, lnga);
    DWORDREGC lngb_sig = significant_digit_count(b, lngb);
    DWORDREGC max_lngab = MAX(lnga, lngb);
    DWORDREG  lgcd = 0, lngab[2], lngmuls;
    digit_t *ab[2] = {digit_NULL, digit_NULL};
                // Each subscripts -1 to max_lngab (max_lngab + 2 elements)
    BOOL OK = TRUE;
    DWORDREG iterations;
    digit_tempinfo_t tempinfo;

            // Allocated memory

    digit_t *temps_ab0_padded = digit_NULL;    // max_lngab + 2
    digit_t *temps_ab1_padded = digit_NULL;    // max_lngab + 2
    digit_t *temps_mul[2] = {digit_NULL, digit_NULL};   // each max_lngab
    digit_t *temps_prod = digit_NULL;          // 2*max_lngab
    digit_t *temps_quot = digit_NULL;          // max_lngab + 1
    digit_t *temps_temp = digit_NULL;          // max_lngab + 1

    tempinfo.need_to_free = FALSE;
    tempinfo.nelmt = mp_gcdex_ntemps(lnga, lngb, PBIGCTX_PASS);
    tempinfo.address = supplied_temps;
    OK = OK && possible_digit_allocate(&tempinfo, "mp_gcdex", PBIGCTX_PASS);

    lngab[0] = lnga_sig;  lngab[1] = lngb_sig;
    if (!OK) {
    } else if (lnga_sig == 0 || lngb_sig == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_ZERO_OPERAND, "mp_gcdex", PBIGCTX_PASS);
    } else if (    a == digit_NULL || b == digit_NULL
                || gcd == digit_NULL || ainvmodb == digit_NULL) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_NULL_POINTER, "mp_gcdex", PBIGCTX_PASS);
    } else if (a == gcd || b == gcd || a == ainvmodb || b == ainvmodb) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_OVERLAPPING_ARGS, "mp_gcdex", PBIGCTX_PASS);
    } else {
        digit_t *temps_next = tempinfo.address;

        mp_clear(temps_next, tempinfo.nelmt, PBIGCTX_PASS);
        temps_ab0_padded = temps_next; temps_next += max_lngab + 2;
        temps_ab1_padded = temps_next; temps_next += max_lngab + 2;
        temps_mul[0]     = temps_next; temps_next += max_lngab;
        temps_mul[1]     = temps_next; temps_next += max_lngab;
        temps_prod       = temps_next; temps_next += 2*max_lngab;
        temps_quot       = temps_next; temps_next += max_lngab + 1;
        temps_temp       = temps_next; temps_next += max_lngab + 1;

        if (temps_next != tempinfo.address + tempinfo.nelmt) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "mp_gcdex -- alloc",
                            PBIGCTX_PASS);
        } else {
            ab[0] = temps_ab0_padded + 1; // Subscripts -1 to max_lngab
            ab[1] = temps_ab1_padded + 1;
            //    ab[0][-1] = ab[1][-1] = 0;
            //    ab[0][lnga_sig] = ab[1][lngb_sig] = 0

            mp_copy(a, ab[0], lnga_sig, PBIGCTX_PASS);
            mp_copy(b, ab[1], lngb_sig, PBIGCTX_PASS);

           // mp_clear(temps_mul[0], lngb, PBIGCTX_PASS);
           // mp_clear(temps_mul[1], lngb, PBIGCTX_PASS);
            temps_mul[0][0] = 1;  // mul[0] = 1,  mul[1] = 0
        }
    }
    lngmuls = 1;         // Length of temps_mul[0] and temps_mul[1].
                         // One of these may have leading zeros.

    iterations = 0;
    while (OK && lngab[0] != 0 && lngab[1] != 0) {
        DWORDREGC lng0 = lngab[0];
        DWORDREGC lng1 = lngab[1];
        digit_t *pab0top = &ab[0][lng0-1];
        digit_t *pab1top = &ab[1][lng1-1];
        digit_t topword0 = *pab0top;
        digit_t topword1 = *pab1top;
        DWORDREGC topsigbits0 = significant_bit_count(topword0);
        DWORDREGC topsigbits1 = significant_bit_count(topword1);
        DWORDREGC sigbits0 = RADIX_BITS*(lng0 - 1) + topsigbits0;
        DWORDREGC sigbits1 = RADIX_BITS*(lng1 - 1) + topsigbits1;
        DWORDREGC sigbitsmax = MAX(sigbits0, sigbits1);

        // Next was once DWORDC, but that results in
        // unexpected loop bound on IA64.
        // Problem is subscript labmax - 2 = 0x00000000ffffffff
        // when labmax = 1.  Signed arithmetic gives -1 as desired.
        signed long labmax = (long)MAX(lng0, lng1);
        DWORDREGC ibig = (compare_diff(ab[1], lng1, ab[0], lng0) > 0);
                       // identifies which of ab[0], ab[1] is larger
        DWORDREGC ismall = 1 - ibig;
        digit_t mat22[4];

        iterations++;
        if (iterations > RADIX_BITS*(lnga + lngb + 1)) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_TOO_MANY_ITERATIONS,
                            "mp_gcdex",
                            PBIGCTX_PASS);
        }
/*
                        Loop invariants:

                            0 <= ab[ismall] <= ab[ibig]

                            mul[0] and mul[1] have leading zeros to length lngb.

                             {ibig, ismall} = {0, 1}

                            Except possibly on first iteration,
                            mul[ibig] <= mul[ismall].

                            There exist c0 >= 0, c1 > 0 such that

                               ( ab[0] )     ( mul[0]   -c0 )   ( a )
                               (       )  =  (              )   (   ) .
                               ( ab[1] )     (-mul[1]    c1 )   ( b )

                            The 2 x 2 matrix has determinant +1,
                            so GCD(a, b) = GCD(ab[0], ab[1]).

                            Invert the matrix to get

                                a = c1*ab[0] + c0*ab[1]
                                b = mul[1]*ab[0] + mul[0]*ab[1]

                            with everything nonnegative.
                            When, say, ibig = 1 and ab[0] = 0 then
                            a = c0*ab[1] and b = mul[0]*ab[1],
                            The latter implies 0 <= mul[0] <= b.
                            Then mul[ibig] <= mul[ismall] implies
                            0 <= mul[1] <= b
                            (ab[0] cannot vanish on first iteration).

---- Distribution of partial quotients

                Fix a positive integer q0.  Let q be a partial quotient from the
                Euclidean algorithm.  Then (Knuth, Seminumerical Algorithms,
                3rd Edition, Section 4.5.3, Theorem E, p. 368,

                      Prob(q < q0) = log2(2q0/(q0+1))
                      Prob(q = q0) = log2((q0^2 + 2q0 + 1)/(q0^2 + 2q0))
                      Prob(q > q0) = log2((q0+2)/(q0+1))

                where log2 denotes the base-2 logarithm.
                According to this model, small quotients are frequent:

                        q = 1   probability 0.415
                        q = 2   probability 0.170
                        q = 3   probability 0.093
                        q = 4   probability 0.059
                        q = 5   probability 0.041
                        q = 6   probability 0.030
                        q = 7   probability 0.022
                        q >= 8  probability 0.170

                As of 1999, integer division is slow on many processors
                (e.g., Intel Pentium) and non-existent on others
                (e.g., DEC/Compaq Alpha, Intel IA-64).
                We check explicitly for small quotients.
*/

#if 0
        printf("mp_gcdex -- Residuals ");
        mp_decimal_output(stdout, ab[ibig],
                          lngab[ibig], " and ", PBIGCTX_PASS);
        mp_decimal_output(stdout, ab[ismall],
                          lngab[ismall], "\n", PBIGCTX_PASS);
#endif
        if (!OK) {
        } else if (labmax == 1) { // Implies lng0 == lng1 == 1
                                  // Use single-precision hereafter
            digit_t ab0, ab1, m00, m01, m10, m11, carrys[2];

            // To ensure the arguments to mp_mul22u are in range,
            // we check whether topword0 + topword1 < RADIX.
            // Observe that (new topword0) + (new topword1)
            //  = MAX(old topword0, old topword1) < RADIX.

            if (topword0 > RADIXM1 - topword1) {
                digit_t carry;
                if (ibig == 0) {
                    topword0 -= topword1;
                } else {
                    topword1 -= topword0;
                }
#if 0
                printf("***** Sum topword0 + topword1 exceeds RADIX\n");
#endif
                carry = add_same(temps_mul[0], temps_mul[1],
                                 temps_mul[ibig], lngmuls);
                if (!OK) {
                } else if (carry == 0) {
                } else if (lngmuls >= lngb) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "mp_gcdex -- lngmuls overflow 1",
                                PBIGCTX_PASS);
                } else {
                    temps_mul[ibig][lngmuls] = carry;
                    lngmuls++;
                }
            }  // if topword0 + topword1 >= RADIX

            ab0 = topword0;
            ab1 = topword1;
            m00 = 1; m01 = 0; m10 = 0; m11 = 1;

            while (OK && ab1 != 0) {   // Also exit by break if ab0 == 0
                if (ab0 >= ab1) {
                    if ((ab0 >> 2) >= ab1) {     // Quotient >= 4
                        digit_t q = ab0 / ab1;   // truncated
                        ab0 -= q*ab1;
                        m00 += q*m10;
                        m01 += q*m11;
                    } else {
                        do {
                            ab0 -= ab1;
                            m00 += m10;
                            m01 += m11;
                        } while (ab0 >= ab1);
                    }
                } // if ab0 >= ab1

                assert (ab1 > ab0);
                if (ab0 == 0) break;

                if ((ab1 >> 2) >= ab0) {      // Quotient >= 4
                    digit_t q = ab1 / ab0;    // truncated
                    ab1 -= q*ab0;
                    m10 += q*m00;
                    m11 += q*m01;
                } else {
                    do {
                        ab1 -= ab0;
                        m10 += m00;
                        m11 += m01;
                    } while (ab1 >= ab0);
                }
                assert (ab0 > ab1);
            } // while


                   // Now    (ab0)     (  m00  -m01 )   ( topword0 )
                   //               =                 *
                   //        (ab1)     ( -m10   m11 )   ( topword1 )

                   // Invert to get

                   //         ( topword0 )   ( m11  m01 )   ( ab0 )
                   //                      =              *
                   //         ( topword1 )   ( m10  m00 )   ( ab1 )


                   // We want to update

                   //        (new mul[0] }   (  m00  m01 )   (old mul[0] )
                   //                      *               *
                   //        (new mul[1] )   (  m10  m11 )   (old mul[1] )

                   // One of ab0, ab1 is zero.  If, say, ab0 = 0 and
                   // ab1 = GCD(topword0, topword1), then

                   //        topword1 = ab1 * m00
                   //        topword0 = ab1 * m01
                   //        ab1 = m11*topword1 - m10*topword0
                   //        0 <= m10 < m00
                   //        1 <= m11 < m01

                   // Hence m10 + m11 < m00 + m11
                   //                 <= topword1 + topword0 < RADIX
                   // A similar inequality holds when ab1 = 0.

            ab[0][0] = ab0;
            ab[1][0] = ab1;
            lngab[0] = (DWORDREG)(ab0 != 0);
            lngab[1] = (DWORDREG)(ab1 != 0);
            mat22[0] = m00;
            mat22[1] = m01;
            mat22[2] = m10;
            mat22[3] = m11;

            OK = OK && mp_mul22u(mat22, temps_mul[0], temps_mul[1],
                                 lngmuls, carrys, PBIGCTX_PASS);
            if (!OK) {
            } else if (carrys[0] == 0 && carrys[1] == 0) {
            } else if (lngmuls >= lngb) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "mp_gcdex -- lngmuls overflow 2",
                                PBIGCTX_PASS);
            } else {
                temps_mul[0][lngmuls] = carrys[0];
                temps_mul[1][lngmuls] = carrys[1];
                lngmuls++;
            }
        } else if (   sigbits0 > sigbits1 + RADIX_BITS/2
                   || sigbits1 > sigbits0 + RADIX_BITS/2) {
                       // Big difference in bit lengths.
                       // Use multi-precision division.
            DWORDREG  lquot = lngab[ibig] - lngab[ismall] + 1;
            DWORDREGC lngmul_small
                   = significant_digit_count(temps_mul[ismall], lngmuls);
#if 0
            printf("max_lngab = %ld, lngab  %ld %ld, lquot = %ld\n",
                      max_lngab, lngab[0], lngab[1], lquot);
#endif
            OK = OK && divide(ab[ibig], lngab[ibig], ab[ismall], lngab[ismall],
                   reciprocal_1_NULL, temps_quot, temps_prod, PBIGCTX_PASS);

            if (OK) {
                lquot = significant_digit_count(temps_quot, lquot);
                lngab[ibig] = significant_digit_count(temps_prod,
                                                      lngab[ismall]);

                mp_copy(temps_prod, ab[ibig], lngab[ibig], PBIGCTX_PASS);

#if 0
                printf("Quotient = ",
                mp_decimal_output(stdout, temps_quot,
                                  lquot, "\n", PBIGCTX_PASS);
#endif
                OK = OK && multiply(temps_quot, lquot, temps_mul[ismall],
                     lngmul_small, temps_prod, PBIGCTX_PASS);
                if (OK) {
                    DWORDREG ltemp = significant_digit_count(temps_prod,
                                                         lquot + lngmul_small);
                    OK = OK && add_full(temps_prod, ltemp,
                        temps_mul[ibig], lngmuls, temps_mul[ibig],
                        &lngmuls, PBIGCTX_PASS);
#if 0
                    printf("max_lngab = %ld, lquot = %ld, "
                           "lngmul_small = %ld, ltemp = %ld. lngmuls = %ld\n",
                             max_lngab, lquot, lngmul_small, ltemp, lngmuls);
#endif
                }
            }
        } else {  // Not far apart in bit lengths (and at most one word apart)
            DWORDREGC normalize = RADIX_BITS*labmax - sigbitsmax;
            dblint_t lead0, lead1;
#if 0
            printf("sigbits = %ld %ld\n", (long)sigbits0, (long)sigbits1);
            printf("normalize = %ld\n", normalize);
#endif
            pab0top[1] = pab1top[1] = 0;      /* Insert leading zeros */

            assert (labmax >= 2);    // Implies subscripts are -1 or higher

            lead0 = MAKE_DBLINT(DOUBLE_SHIFT_LEFT(ab[0][labmax-1],
                                                  ab[0][labmax-2], normalize),
                                DOUBLE_SHIFT_LEFT(ab[0][labmax-2],
                                                  ab[0][labmax-3], normalize));
            lead1 = MAKE_DBLINT(DOUBLE_SHIFT_LEFT(ab[1][labmax-1],
                                                  ab[1][labmax-2], normalize),
                                DOUBLE_SHIFT_LEFT(ab[1][labmax-2],
                                                  ab[1][labmax-3], normalize));

                   // Find 2 x 2 matrix M such that M*[ab0  ab1]^T is "small"

            OK = OK && lehmer_mat22(lead0, lead1, mat22, PBIGCTX_PASS);

            if (OK && (mat22[1] | mat22[2]) == 0) {
                assert(mat22[0] == 1 && mat22[3] == 1);  // Identity matrix
                mat22[ibig + 1] = 1;        // Set m01 = 1 if ibig = 0,
                                            //     m10 = 1 if ibig = 1
            }
#if 0
            if (OK) {
                digit_out_buf_t buf00, buf01, buf10, buf11;
                printf("mp_gcdex matrix: %s %s %s %s\n",
                       digit_out(mat22[0], buf00, PBIGCTX_PASS),
                       digit_out(mat22[1], buf01, PBIGCTX_PASS),
                       digit_out(mat22[2], buf10, PBIGCTX_PASS),
                       digit_out(mat22[3], buf11, PBIGCTX_PASS));
            }
#endif

                 //  Do 2 x 2 multiplies, where mat22 holds [m00, m01, m10, m11]

                 //     (  m00  -m01 ) ( ab[0] )
                 //     ( -m10   m11 ) ( ab[1] )

                 //     (  m00   m01 ) ( mul[0] )
                 //     (  m10   m11 ) ( mul[1] )

                 // to update the multi-precision [ab[0], ab[1]]
                 // and [mul[0], mul[1]] vectors.

            if (OK) {
                DWORDREGC lab = MAX(lng0, lng1);
                digit_t carrys[2];
                sdigit_t scarrys[2];
                OK = OK && mp_mul22s(mat22, ab[0], ab[1],  lab,
                                     scarrys, PBIGCTX_PASS);
                if (!OK) {
                } else if (scarrys[0] != 0 || scarrys[1] != 0) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                    "mp_gcdex -- scarrys nonzero\n",
                                    PBIGCTX_PASS);
                } else {
                    signed long lng0new = (long)lab, lng1new = (long)lab;
                    // petmon, September, 2000.
                    //         Lower bounds changed from 1 to 0.
                    //         lng0new and lng1new made signed for IA-64.

                    while (lng0new != 0 && ab[0][lng0new-1] == 0) lng0new--;
                    while (lng1new != 0 && ab[1][lng1new-1] == 0) lng1new--;
                    lngab[0] = (DWORDREG)lng0new;
                    lngab[1] = (DWORDREG)lng1new;
                }

                OK = OK && mp_mul22u(mat22, temps_mul[0], temps_mul[1],
                                     lngmuls, carrys, PBIGCTX_PASS);
                if (!OK) {
                } else if (carrys[0] == 0 && carrys[1] == 0) {
                } else if (lngmuls >= lngb) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                               "mp_gcdex -- lngmuls overflow 3",
                               PBIGCTX_PASS);
                } else {
                    temps_mul[0][lngmuls] = carrys[0];
                    temps_mul[1][lngmuls] = carrys[1];
                    lngmuls++;
                }
            } // local block to multiply by 2 x 2 matrix
        } // case where we generate 2 x 2 Lehmer matrix
    } /* while */

    if (OK) {

          // One argument has been reduced to zero (or an error has occurred)

        DWORDREGC igcd = (lngab[0] == 0 ? 1 : 0);
        lgcd = lngab[igcd];
        mp_copy(ab[igcd], gcd, lgcd, PBIGCTX_PASS);
#if 0
        printf("mp_gcdex exiting, igcd = %d\n", igcd);
        fflush(stdout);
#endif

                  // Verify mul[igcd] <= mul[1-igcd] <= b

        if (   compare_same(b, temps_mul[1-igcd], lngb) < 0
            || compare_same(temps_mul[1-igcd], temps_mul[igcd], lngb) < 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                       "mp_gcdex -- multiplier out of range", PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
            if (mp_errfil != NULL) {
                fflush(stdout);
                fprintf(mp_errfil, "mp_gcdex error -- lngb = %ld,"
                                   " lngmuls = %ld\nb=",
                               (long)lngb, (long)lngmuls);
                mp_decimal_output(mp_errfil, b, lngb,
                                  "\nmul2 = ", PBIGCTX_PASS);
                mp_decimal_output(mp_errfil, temps_mul[1-igcd],
                                             lngb, "\nmul1 =", PBIGCTX_PASS);
                mp_decimal_output(mp_errfil, temps_mul[igcd], lngb,
                                             "\n", PBIGCTX_PASS);
                fflush(mp_errfil);
            }
#endif
        }
        if (!OK) {
        } else if (igcd == 0) {
            mp_copy(temps_mul[0], ainvmodb, lngb, PBIGCTX_PASS);
        } else {
            sub_same(temps_mul[0], temps_mul[1], ainvmodb, lngb);
        }

        if (OK && lcm != digit_NULL) {
/*
                Compute LCM(a, b) = a*b/gcd.
                We know mul[1-igcd] = b/ab[igcd] = b/gcd,
                since b = ab[0]*mul[1] + ab[1]*mul[0] and ab[1-igcd] = 0.
                Therefore LCM(a, b) = a*mul[1-igcd].
*/
            OK = OK && multiply(a, lnga, temps_mul[1-igcd],
                                lngb, lcm, PBIGCTX_PASS);
        }

        if (OK && binvmoda != digit_NULL) {
    /*
                Compute binvmoda so that

                   a*ainvmodb + b*binvmoda = lcm + gcd.
                                           = a*mul[1-igcd] + gcd

                We want [a*(mul[1-igcd] - ainvmodb) + gcd]/b.
    */
            sub_same(temps_mul[1-igcd],
                     ainvmodb, temps_mul[1-igcd], lngb);
            OK = OK && multiply(a, lnga, temps_mul[1-igcd], lngb,
                                temps_prod, PBIGCTX_PASS);
            OK = OK && add_diff(temps_prod, lnga + lngb, gcd, lgcd,
                                temps_prod, digit_NULL, PBIGCTX_PASS);
                 /* Cannot overflow -- at most a*b + MAX(a, b) */
            OK = OK && divide(temps_prod, lnga + lngb_sig, b, lngb_sig,
                          reciprocal_1_NULL,
                          temps_quot, temps_mul[1-igcd], PBIGCTX_PASS);
            if (!OK) {
            } else if (!all_zero(temps_mul[1-igcd], lngb_sig)) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "mp_gcdex -- nonzero remainder\n",
                                PBIGCTX_PASS);
            } else {
                mp_copy(temps_quot, binvmoda, lnga, PBIGCTX_PASS);
                          /* truncate from lnga + 1 to lnga */
            }
        }  /* if binvmoda */
    }
    if (tempinfo.need_to_free) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }
    if (OK) *plgcd = lgcd;
    return OK;
} /* mp_gcdex */
/****************************************************************************/
#if 1

static BOOL WINAPI lehmer_mat22
        (dblint_tc   lead0orig,         // IN
         dblint_tc   lead1orig,         // IN
         digit_t     mat22[4],          // OUT
         PBIGCTX_ARG)
/*
            This invokes the Lehmer variant of the extended GCD.
        We are given the 2*RADIX_BITS most significant bits
        lead0orig and lead1orig of ab0 and ab1
        (up to a power-of-2 scale factor).  That is,

                sc*ab0 = lead0orig + eps0
                sc*ab1 = lead1orig + eps1

        where 0 <= eps0, eps1 < 1.  The larger of lead0orig, lead1orig
        has the full 2*RADIX_BITS significant bits.

            Use the continued fraction expansion of lead0orig/lead1orig
        to get the next several partial quotients and a single-precision
        2 x 2 matrix (m00, m01, m10, m11 stored in mat22)

                             ( m00    -m01)
                        M =
                             (-m10     m11)

        of determinant +1 such that  M * [ab0   ab1]^T is `small'.
        The caller uses M to update [ab0 ab1] and [mul0 mul1].
        We promise 0 <= m00, m01, m10, m11 < RADIX/2.

            Invariants:

                    1 <= m00, m11 < RADIX/2
                    0 <= m01, m10 < RADIX/2

                    m00*m11 - m01*m10 = 1

               If lead0 = MAKE_DBLINT(lead0h, lead0l) and
                  lead1 = MAKE_DBLINT(lead1h, lead1l), then

                    ( lead0 )   ( m00   -m01) ( sc*ab0 - eps0)
                              =
                    ( lead1 )   (-m10    m11) ( sc*ab1 - eps1)
        so
                    ( lead0 + m00*eps0 - m01*eps1 )   ( m00  -m01 ) ( sc*ab0 )
                                                    =
                    ( lead1 + m11*eps1 - m10*eps0 )   (-m10   m11 ) ( sc*ab1 )

        The right side of this identity represents the new scaled ab0
        and ab1 if we had perfect precision in intermediate calculations.
        Looking at the left side (with the updated lead0, lead1),
        and knowing 0 <= m00, m01, m10, m11 < RADIX/2,
        along with 0 <= eps0, eps1 < 1, we can get estimates and error
        bounds for the scaled, full-precision, sc0*ab0 and sc1*ab1
        There are the intervals RADIX*(lead0h - 1/2, lead0h + 3/2)
        and RADIX*(lead1h - 1/2, lead1h + 3/2).
        The old sc0*ab0 and ac1*ab1 were around RADIX^2.
        We try to make lead0h and lead1h small, which
        should alos help ab0 and ab1.
        (CAUTION -- lead0h + 1 and lead1h + 1 may overflow.)

            Conceptually lead0, lead1 are double-length (2*RADIX_BITS bits),
        initialized to lead0orig and lead1orig.  However, we manipulate
        the high and low pieces of each separately.

            WARNING.  This may return the identity matrix
        when lead0 and lead1 are very close (or equal).
*/
{
    digit_t lead0h = HIGH_DIGIT(lead0orig), lead0l = LOW_DIGIT(lead0orig);
    digit_t lead1h = HIGH_DIGIT(lead1orig), lead1l = LOW_DIGIT(lead1orig);
    BOOL OK = TRUE, progress = TRUE;
    digit_t m00 = 1, m01 = 0, m10 = 0, m11 = 1;

    if (    lead0h == 0
         || lead1h == 0                      // Matrix entries will be too big
         || ((lead0h | lead1h) & RADIX_HALF) == 0) {  // Neither normalized
             OK = FALSE;
             SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "lehmer_mat22 -- Bad lead0h or lead1h",
                            PBIGCTX_PASS);
    }
    while (progress && OK) {
        progress = FALSE;
#if 0
        printf("lead0h, lead1h = %lu %lu\n", lead0h, lead1h);
#endif
        if (lead0h - 1 > lead1h && lead0h != 0) {
                //  The (updated) quotient ab0 / ab1 is at least
                //  (lead0h - 1/2)/(lead1h + 3/2) >= lead0h/(lead1h + 2) >= 1
                //  The denominator lead1h + 2 cannot overflow.

            if ((lead0h >> 2) >= lead1h + 2) {   // Quotient >= 4
                digit_tc q = lead0h / (lead1h + 2);
                dblint_tc prod10_11 = DPRODUU(q, m10 + m11);
                dblint_tc prod1l = DPRODUU(q, lead1l);
#if 0
                printf("Case 1, q = %ld\n", (long)q);
#endif

                if (q <= 3) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                    "lehmer_mat22 -- small quotient 1",
                                    PBIGCTX_PASS);
                }
                        // Update m00 = m00 + q*m10;
                        //        m01 = m01 + q*m11;
                        //        lead0 -= q*lead1
                        // but only if (new m00) and (mew m01) are < RADIX/2.
                        // Rather than make two tests, we
                        // check whether (new m00) + (new m01) < RADIX/2

                if (   HIGH_DIGIT(prod10_11) == 0
                    && LOW_DIGIT(prod10_11) <= RADIXM1/2 - m00 - m01) {

                    digit_tc prod10 = q*m10;

                    progress = TRUE;
                    lead0h -= q*lead1h + HIGH_DIGIT(prod1l)
                                       + (LOW_DIGIT(prod1l) > lead0l);
                    lead0l -= LOW_DIGIT(prod1l);

                    m00 += prod10;
                    m01 += (LOW_DIGIT(prod10_11) - prod10);

                    if ((m00 | m01) >= RADIX_HALF) {
                        OK = FALSE;
                        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                        "lehmer_mat22 -- m00 or m01 overflow.",
                                        PBIGCTX_PASS);
                    }
                } // if HIGH_DIGIT
            } else {  // Estimated quotient <= 3 (actual may be slightly larger)
                digit_t overflow_test;
                do {
                    m00 += m10;
                    m01 += m11;
                    overflow_test = (m00 | m01) & RADIX_HALF;
                    lead0h -= lead1h + (lead1l > lead0l);
                    lead0l -= lead1l;
                } while (overflow_test == 0 && lead0h >= lead1h + 2);
#if 0
                printf("Small quotient code 1\n");
#endif
                progress = TRUE;
                if (overflow_test != 0) {
                    progress = FALSE;
                    m00 -= m10;
                    m01 -= m11;
                }
            } // large or small quotient?
        }  // lead0h >= lead1h + 2

        if (lead1h - 1 > lead0h && lead1h != 0) {
            if ((lead1h >> 2) >= lead0h + 2) {  // Quotient >= 4
                digit_tc q = lead1h / (lead0h + 2);
                dblint_tc prod00_01 = DPRODUU(q, m00 + m01);
                dblint_tc prod0l = DPRODUU(q, lead0l);
#if 0
                printf("Case 2, q = %ld\n", (long)q);
#endif
                if (q <= 3) {
                    OK = FALSE;
                    SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                    "lehmer_mat22 -- tiny quotient 2",
                                    PBIGCTX_PASS);
                }
                            // Update m10 = m10 + q*m00;
                            //        m11 = m11 + q*m01;
                            //        lead1 -= q*lead0
                            // but only if (new m10) and (mew m11)
                            // are both < RADIX/2.
                            // Rather than make two tests, we
                            // check whether (new m10) + (new m11) < RADIX/2

                if (   HIGH_DIGIT(prod00_01) == 0
                    && LOW_DIGIT(prod00_01) <= RADIXM1/2 - m10 - m11) {

                    digit_tc prod00 = q*m00;

                    progress = TRUE;
                    lead1h -= q*lead0h + HIGH_DIGIT(prod0l)
                                       + (LOW_DIGIT(prod0l) > lead1l);
                    lead1l -= LOW_DIGIT(prod0l);

                    m10 += prod00;
                    m11 += (LOW_DIGIT(prod00_01) - prod00);

                    if ((m10 | m11) >= RADIX_HALF) {
                        OK = FALSE;
                        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                        "lehmer_mat22 -- m10 or m11 overflow.",
                                        PBIGCTX_PASS);
                    }
                } // if prod_00_01
            } else {     // Estimated quotient <= 3 (actual may be more)
                digit_t overflow_test;
                do {
                    m10 += m00;
                    m11 += m01;
                    overflow_test = (m10 | m11) & RADIX_HALF;
                    lead1h -= lead0h + (lead0l > lead1l);
                    lead1l -= lead0l;
                } while (overflow_test == 0 && lead1h >= lead0h + 2);

                progress = TRUE;
                if (overflow_test != 0) {
                    progress = FALSE;
                    m10 -= m00;
                    m11 -= m01;
                }
            } // large or small quotient?
        }  // lead1h >= lead0h + 2
    }  // while (progress && OK)

    if (!OK) {
    } else if ((m00 | m01 | m10 | m11) & RADIX_HALF) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                        "lehmer_mat22 -- matrix element too high",
                        PBIGCTX_PASS);
    } else {
        mat22[0] = m00;
        mat22[1] = m01;
        mat22[2] = m10;
        mat22[3] = m11;
    }
    return OK;
} // lehmer_mat22

#endif

/****************************************************************************/
#if 0
static BOOL WINAPI lehmer_mat22
        (dblint_tc   lead0orig,         // IN
         dblint_tc   lead1orig,         // IN
         digit_t     mat22[4],          // OUT
         PBIGCTX_ARG)
/*
            This invokes the Lehmer variant of the extended GCD.
        We are given the 2*RADIX_BITS most significant bits
        lead0orig and lead1orig of ab0 and ab1
        (up to a power-of-2 scale factor).  That is,

                sc*ab0 = lead0orig + eps0
                sc*ab1 = lead1orig + eps1

        where 0 <= eps0, eps1 < 1.  The larger of lead0orig, lead1orig
        has the full 2*RADIX_BITS significant bits.

            Use the continued fraction expansion of lead0orig/lead1orig
        to get the next several partial quotients and a single-precision
        2 x 2 matrix (m00, m01, m10, m11 stored in mat22)

                             ( m00    -m01)
                        M =
                             (-m10     m11)

        of determinant +1 such that  M * [ab0   ab1]^T is `small'.
        The caller uses M to update [ab0 ab1] and [mul0 mul1].
        We promise 0 <= m00, m01, m10, m11 < RADIX/2.

            Invariants:

                    1 <= m00, m11 < RADIX/2
                    0 <= m01, m10 < RADIX/2

                    m00*m11 - m01*m10 = 1

               If lead0 = MAKE_DBLINT(lead0h, lead0l) and
                  lead1 = MAKE_DBLINT(lead1h, lead1l), then

                    ( lead0 )   ( m00   -m01) ( sc*ab0 - eps0)
                              =
                    ( lead1 )   (-m10    m11) ( sc*ab1 - eps1)
        so
                    ( lead0 + m00*eps0 - m01*eps1 )   ( m00  -m01 ) ( sc*ab0 )
                                                    =
                    ( lead1 + m11*eps1 - m10*eps0 )   (-m10   m11 ) ( sc*ab1 )

        The right side of this identity represents the new scaled ab0
        and ab1 if we had perfect precision in intermediate calculations.
        Looking at the left side (with the updated lead0, lead1),
        and knowing 0 <= m00, m01, m10, m11 < RADIX/2,
        along with 0 <= eps0, eps1 < 1, we can get estimates and error
        bounds for the scaled, full-precision, sc*ab0 and sc*ab1
        There are the intervals RADIX*(lead0h - 1/2, lead0h + 3/2)
        and RADIX*(lead1h - 1/2, lead1h + 3/2).
        The old sc*ab0 and sc*ab1 were around RADIX^2.
        We try to make lead0h and lead1h small, which
        should also help ab0 and ab1.
        (CAUTION -- lead0h + 1 and lead1h + 1 may overflow.)

            Conceptually lead0, lead1 are double-length (2*RADIX_BITS bits),
        initialized to lead0orig and lead1orig.  However, we manipulate
        the high and low pieces of each separately.

            WARNING.  This may return the identity matrix
        when lead0 and lead1 are very close (or equal).
*/
{
    digit_t lead0h = HIGH_DIGIT(lead0orig), lead0l = LOW_DIGIT(lead0orig);
    digit_t lead1h = HIGH_DIGIT(lead1orig), lead1l = LOW_DIGIT(lead1orig);
    BOOL OK = TRUE, progress = TRUE;
    digit_t m00 = 1, m10 = 0, m00_plus_m01 = 1, m10_plus_m11 = 1;
// Think m01 = m00_plus_m01 - m00  and  m11 = m10_plus_m11 - m10 .


    if (    lead0h == 0
         || lead1h == 0                      // Matrix entries will be too big
         || ((lead0h | lead1h) & RADIX_HALF) == 0) {  // Neither normalized
             OK = FALSE;
             SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                            "lehmer_mat22 -- Bad lead0h or lead1h",
                            PBIGCTX_PASS);
    }
    while (progress && OK && lead0h != 0 && lead1h != 0) {
        digit_t lead0h_borrowed = lead0h - (digit_t)(lead1l > lead0l);
        digit_t lead1h_borrowed = lead1h - (digit_t)(lead0l > lead1l);

        progress = FALSE;
#if 0
    if ((m00_plus_m01 | m10_plus_m11) >> 27) {
        printf("partial matrix %08lx %08lx %08lx %08lx\n",
                 (long)m00, (long)(m00_plus_m01 - m00),
                 (long)m10, (long)(m10_plus_m11 - m10));
        printf("intermediate lead0 = %lx %08lx, lead1 = %lx %08lx\n",
                (long)lead0h, (long)lead0l, (long)lead1h, (long)lead1l);
    }
#endif
        assert ((m00_plus_m01 | m10_plus_m11) < RADIX_HALF);
        assert ((digit_t)(               m00 *LOW_DIGIT(lead0orig)
                       + (m00 - m00_plus_m01)*LOW_DIGIT(lead1orig)) == lead0l);
        assert ((digit_t)((m10_plus_m11 - m10)*LOW_DIGIT(lead1orig)
                                        - m10 *LOW_DIGIT(lead0orig)) == lead1l);
#if 0
        printf("lead0h, lead1h = %lu %lu\n", lead0h, lead1h);
#endif

//  Updated scaled ab0 is in interval (lead0 - m01, lead0 + m00)
//  Updated scaled ab1 is in interval (lead1 - m10, lead1 + m11)

        if (lead0h_borrowed > lead1h) {
                             // Is lead0 >= lead1 + RADIX
                //  The (updated) quotient ab0 / ab1 is at least
                //  1 + (new_lead0h - 1/2)/(lead1h + 3/2) >= 1.
                //  Another lower bound for the quotient is
                //  (lead0h - 1/2) >= (lead1h + 3/2) >= lead0h / (lead1h + 2).

            if ((lead0h >> 2) <= lead1h + 1) {   // Estimated quotient <= 3
                digit_t overflow_test;
                do {
                    lead0h = lead0h_borrowed - lead1h;
                    lead0l -= lead1l;
                    m00 += m10;
                    m00_plus_m01 += m10_plus_m11;
                    overflow_test = m00_plus_m01 & RADIX_HALF;
                    lead0h_borrowed = lead0h - (lead1l > lead0l);
                } while (overflow_test == 0 && lead0h_borrowed > lead1h);
#if 0
                printf("Small quotient code 1\n");
#endif
                progress = TRUE;
                if (overflow_test != 0) {

                     // The old m00_plus_m01 was in range,
                     // implying (old and new) m01 is in range.
                     // The updated m00_plus_m01 is >= RADIX_HALF
                     // Check whether the new m00 is in range.

                    progress = FALSE;

#if 0
                    printf("Small overflow 1  %08lx %08lx %08lx %08lx\n",
                          (long)m00, (long)(m00_plus_m01 - m00),
                          (long)m10, (long)(m10_plus_m11 - m10));
#endif
                    if ((m00 | m00_plus_m01 - m00) >= RADIX_HALF) {
                                         // Backtrack if too large
                        m00 -= m10;
                        m00_plus_m01 -= m10_plus_m11;
                    }
                }
            } else {
                //  When (lead0h >> (RADIX_BITS - 8)) == 0 and lead0h > lead1h,
                //  we infer lead1h < lead0h <= 2^(RADIX_BITS - 8) - 1
                //  Looking at (256*lead0/RADIX - 128) /(256*lead1/RADIX + 128)
                //
                //              256*lead0h + (lead0l >> (RADIX_BITS - 8)) - 128
                //        >=    ------------------------------------------------
                //              256*lead1h + (lead1l >> (RADIX_BITS - 8)) + 129

                //  we get more precision in the numerator and denominator.

                digit_t qnum, qden;
                if (lead0h >> (RADIX_BITS - 8) == 0) {
                    qnum = (lead0h << 8) + (lead0l >> (RADIX_BITS - 8)) - 128;
                    qden = (lead1h << 8) + (lead1l >> (RADIX_BITS - 8)) + 129;
                } else {
                    qnum = lead0h;
                    qden = lead1h + 2;
                }
                assert(qden < RADIX_HALF);

                if ( (qnum >> 1) < qden) {  /* Estimated quotient 4 to 63 */
                    digit_t new_m00_plus_m01, overflow_test;
                    int sh;

#if UNIFORM_SIGNIFICANT_BIT_COUNT
                    sh =   significant_bit_count(qnum)
                         - significant_bit_count(qden);
                    if ((qnum >> sh) < qden) sh--;
#else
                    sh = 1;
                    do {
                        sh++;
                    } while ((qnum >> sh) >= (2*qden));
#endif
                    assert (qnum >= (qden << sh));
                    assert(sh >= 2 && sh <= RADIX_BITS - 1);
#if 0
                    printf("Case 1, sh = %ld, q = %ld\n",
                           (long)sh, (long)(qnum/qden));
#endif
                        // Denote q = 2^sh.
                        // Update m00 = m00 + q*m10;
                        //        m01 = m01 + q*m11;
                        //        lead0 -= q*lead1
                        // but only if (new m00) and (mew m01) are < RADIX/2.
                        // Rather than make two tests, we
                        // check whether (new m00) + (new m01) < RADIX/2

                    new_m00_plus_m01 = m00_plus_m01 + (m10_plus_m11 << sh);

                    overflow_test =   (m10_plus_m11 >> (RADIX_BITS - 1 - sh))
                                    | (new_m00_plus_m01 & RADIX_HALF);
                    if (overflow_test == 0) {
                        digit_tc lead1l_shifted = lead1l << sh;
                                              // Discard upper bits
                        progress = TRUE;
                        lead0h -= (lead1h << sh) + (lead1l >> (32 - sh))
                                                 + (lead1l_shifted > lead0l);
                        lead0l -= lead1l_shifted;

                        m00 += m10 << sh;
                        m00_plus_m01 = new_m00_plus_m01;

                        if (m00 > m00_plus_m01 || m00_plus_m01 >= RADIX_HALF) {
                            OK = FALSE;
                            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                        "lehmer_mat22 -- m00 or m01 overflow.",
                                        PBIGCTX_PASS);
                        }
                    } else {
                        progress = FALSE;
                    }
                } else {  // Estimated quotient >= 64
                    digit_tc q = qnum/qden;
                    digit_t overflow_test;
                    dblint_tc q_lead1l = DPRODUU(q, lead1l);
                    dblint_tc q_m10_plus_m11 = DPRODUU(q, m10_plus_m11);

                    digit_tc new_m00_plus_m01
                                = LOW_DIGIT(q_m10_plus_m11) + m00_plus_m01;
#if 0
                    printf("Huge quotient 1 code, q = %ld\n", (long)q);
#endif
                    overflow_test =   HIGH_DIGIT(q_m10_plus_m11)
                                    | (   (LOW_DIGIT(q_m10_plus_m11)
                                        | new_m00_plus_m01) & RADIX_HALF);
                    if (overflow_test == 0) {

                        // Update m00 = m00 + q*m10;
                        //        m01 = m01 + q*m11;
                        //        lead0 -= q*lead1

                        lead0h -= q*lead1h + HIGH_DIGIT(q_lead1l)
                                           + (LOW_DIGIT(q_lead1l) > lead0l);
                        lead0l -= LOW_DIGIT(q_lead1l);
                        m00 += q*m10;
                        m00_plus_m01 = new_m00_plus_m01;
                        progress = TRUE;
                    } else {
                        progress = FALSE;
                    }
                }
            } // small, medium, or large quotient?
        } else if (lead1h_borrowed > lead0h) {
                             // Is lead0 >= lead1 + RADIX
            digit_tc lead0h2 = lead0h + 2;

            if ((lead1h >> 2) <= lead0h + 1) {  // Estimated quotient < 4
                digit_t overflow_test;
                do {
                    lead1h = lead1h_borrowed - lead0h;
                    lead1l -= lead0l;
                    m10 += m00;
                    m10_plus_m11 += m00_plus_m01;
                    overflow_test = m10_plus_m11 & RADIX_HALF;
                    lead1h_borrowed = lead1h - (lead0l > lead1l);
                 } while (overflow_test == 0 && lead1h_borrowed > lead0h);

                progress = TRUE;
                if (overflow_test != 0) {
#if 0
                    printf("Small overflow 2  %08lx %08lx %08lx %08lx\n",
                          (long)m00, (long)(m00_plus_m01 - m00),
                          (long)m10, (long)(m10_plus_m11 - m10));
#endif
                    progress = FALSE;  // Terminate while loop
                    if ((m10 | m10_plus_m11 - m10) & RADIX_HALF) {
                                         // Backtrack if too large
                        m10 -= m00;
                        m10_plus_m11 -= m00_plus_m01;
                    }
                }
            } else if ((lead1h >> 6) < lead0h2) {  // Estimated quotient 4 to 63
                digit_t new_m10_plus_m11, overflow_test;
                int sh;

#if UNIFORM_SIGNIFICANT_BIT_COUNT
                sh =    significant_bit_count(lead0h)
                      - significant_bit_count(lead1h2);
                if ((lead0h >> sh) < lead1h2) sh--;
#else
                sh = 1;
                do {
                    sh++;
                } while ((lead1h >> sh) >= (2*lead0h2));
#endif
#if 0
                printf("Case 2, sh = %ld, q = %ld\n",
                         (long)sh, (long)(lead1h / lead0h2));
#endif
                assert (lead1h >= (lead0h2 << sh));
                assert(sh >= 2 && sh <= RADIX_BITS - 1);

                            // Let q =2^sh
                            // Update m10 = m10 + q*m00;
                            //        m11 = m11 + q*m01;
                            //        lead1 -= q*lead0
                            // but only if (new m10) and (mew m11)
                            // are both < RADIX/2.
                            // Rather than make two tests, we

                            // check whether (new m10) + (new m11) < RADIX/2
                new_m10_plus_m11 = m10_plus_m11 + (m00_plus_m01 << sh);

                overflow_test =  (m00_plus_m01 >> (RADIX_BITS - 1 - sh))
                               | (new_m10_plus_m11 & RADIX_HALF);
                if (overflow_test == 0) {
                    digit_tc lead0l_shifted = lead0l << sh;
                                              // Discard upper bits
                    progress = TRUE;
                    lead1h -= (lead0h << sh) + (lead0l >> (32 - sh))
                                       + (lead0l_shifted > lead1l);
                    lead1l -= lead0l_shifted;

                    m10 += m00 << sh;
                    m10_plus_m11 = new_m10_plus_m11;

                    if (m10 > m10_plus_m11 || m10_plus_m11 >= RADIX_HALF) {
                        OK = FALSE;
                        SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                        "lehmer_mat22 -- m10 or m11 overflow.",
                                        PBIGCTX_PASS);
                    }
                } else {
                    progress = FALSE;
                }
            } else {  // Estimated quotient >= 64
                digit_tc q = lead1h/lead0h2;
                digit_t overflow_test;
                dblint_tc q_lead0l = DPRODUU(q, lead0l);
                dblint_tc q_m00_plus_m01 = DPRODUU(q, m00_plus_m01);

                digit_tc new_m10_plus_m11
                               = LOW_DIGIT(q_m00_plus_m01) + m10_plus_m11;
#if 0
                printf("Huge quotient 2 code, q = %ld\n", (long)q);
#endif
                overflow_test =   HIGH_DIGIT(q_m00_plus_m01)
                                | (   (LOW_DIGIT(q_m00_plus_m01)
                                    | new_m10_plus_m11) & RADIX_HALF);
                if (overflow_test == 0) {

                        // Update m10 = m10 + q*m00;
                        //        m11 = m11 + q*m01;
                        //        lead1 -= q*lead0

                    lead1h -= q*lead0h + HIGH_DIGIT(q_lead0l)
                                       + (LOW_DIGIT(q_lead0l) > lead1l);
                    lead1l -= LOW_DIGIT(q_lead0l);
                    m10 += q*m00;
                    m10_plus_m11 = new_m10_plus_m11;
                    progress = TRUE;
                } else {
                    progress = FALSE;  /* Force exit from while loop */
                }
            } // small, medium, or large quotient?
        }
       assert ((digit_t)(m00*m10_plus_m11 - m10*m00_plus_m01) == 1);
    }  // while (progress && OK)


    if (OK) {
        digit_tc m01 = m00_plus_m01 - m00;
        digit_tc m11 = m10_plus_m11 - m10;

#if 0
        {
            double dlead0orig = F_RADIX*(double)HIGH_DIGIT(lead0orig)
                                      + (double) LOW_DIGIT(lead0orig);
            double dlead1orig = F_RADIX*(double)HIGH_DIGIT(lead1orig)
                                      + (double) LOW_DIGIT(lead1orig);
            double quot_orig = dlead0orig / dlead1orig;

            printf("quotients: %.20f %.20f %.20f\n",
                    (double)m01/(double)m00 - quot_orig, quot_orig,
                    (double)m11/(double)m10 - quot_orig);
        }
#endif
        mat22[0] = m00;
        mat22[1] = m01;
        mat22[2] = m10;
        mat22[3] = m11;
#if 0
        printf("matrix %08lx %08lx %08lx %08lx\n",
                 (long)m00, (long)m01, (long)m10, (long)m11);
        printf("lead0 = %lx %08lx, lead1 = %lx %08lx\n",
                (long)lead0h, (long)lead0l, (long)lead1h, (long)lead1l);
#endif

        if ((m00 | m01 | m10 | m11) & RADIX_HALF) {
#if 0
            printf("matrix %08lx %08lx %08lx %08lx\n",
                 (long)m00, (long)m01, (long)m10, (long)m11);
            printf("lead0 = %lx %08lx, lead1 = %lx %08lx\n",
                (long)lead0h, (long)lead0l, (long)lead1h, (long)lead1l);
#endif
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                        "lehmer_mat22 -- matrix element too high",
                        PBIGCTX_PASS);
        } else if ((digit_t)(m11*m00 - m01*m10) != 1) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                        "lehmer_mat22 -- determinant not +1",
                        PBIGCTX_PASS);
        }
    }
    return OK;
} // lehmer_mat22
#endif
/****************************************************************************/
BOOL WINAPI mp_invert
        (digit_tc    denom[],        // IN
         digit_tc    modulus[],      // IN
         DWORDREGC   lng,            // IN
         digit_t     result[],       // OUT
         const char *caller,         // IN
         digit_t    *supplied_temps, // TEMPS -- length mp_invert_ntemps(lng)
         PBIGCTX_ARG)
/*
     Return result = 1/denom (mod modulus).
     denom, modulus, result all have length lng.
     supplied_temps may be digit_NULL or have length mp_invet_ntemps(lng)
*/
{
    BOOL OK = TRUE;
    digit_tempinfo_t tempinfo;

    tempinfo.address = supplied_temps;
    tempinfo.need_to_free = FALSE;
    tempinfo.nelmt = mp_invert_ntemps(lng, PBIGCTX_PASS);

    OK = OK && possible_digit_allocate(&tempinfo, "mp_invert", PBIGCTX_PASS);
    OK = OK && validate_modular_data(denom, modulus, lng,
                                     "mp_invert", PBIGCTX_PASS);

    if (!OK) {
    } else if (all_zero(denom, lng)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_DIVIDE_ZERO, caller, PBIGCTX_PASS);
    } else {
        DWORDREG lgcd = 0;
        digit_t *gcd         = tempinfo.address;
        digit_t *gcdex_temps = gcd + lng;

        assert(   gcdex_temps + mp_gcdex_ntemps(lng, lng, PBIGCTX_PASS)
               == tempinfo.address + tempinfo.nelmt);

        OK = OK && mp_gcdex(denom, lng, modulus, lng, result,
                            digit_NULL, gcd, digit_NULL,
                            &lgcd, gcdex_temps, PBIGCTX_PASS);
        if (!OK) {
        } else if (lgcd != 1 || gcd[0] != 1) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_NOT_INVERTIBLE, caller, PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
            if (mp_errfil != NULL) {
                fprintf(mp_errfil, "Using data from %s, "
                       "mp_invert got nontrivial GCD = \n", caller);
                (void)mp_decimal_output(mp_errfil, gcd, lgcd,
                                        "\n.", PBIGCTX_PASS);
            }
#endif
        }
    }
    if (tempinfo.need_to_free == TRUE) {
        Free_Temporaries(tempinfo.address, PBIGCTX_PASS);
    }
    return OK;
} // mp_invert
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\mpinit.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"
#include <stdio.h>

#if TARGET == TARGET_IX86
    exportable_var_declaration BOOL MMX_available = FALSE;
    exportable_var_declaration BOOL SSE2_available = FALSE;
#endif

/*
    Other globals:            Where declared:

    mp_errno                  bigerrno.c
    mp_errfil                 bigerrno.c
    allocation statistics     bigalloc.c
    random number seed        bigrand0.c

    test_primality_check_low in primchk.c constructs
    a local table on first call, which is used on later calls.
*/

/*****************************************************************************/
BOOL WINAPI mp_initialization(PBIGCTX_ARG)
/*
        This routine initializes global tables.
        (padinfo_initialization in kara.c is called by find_padinfo).
*/
{
    BOOL OK = TRUE;

         /*
            On Pentiums, check for availability of MMX and SSE2 instructions.
            (We presently omit this test on WinCE.)
            TBD -- Do we want the check on Palladium?
         */

#if TARGET == TARGET_IX86 && TARGET_OS == OS_WNT
    MMX_available = IsProcessorFeaturePresent(PF_MMX_INSTRUCTIONS_AVAILABLE);
    SSE2_available =IsProcessorFeaturePresent(PF_XMMI64_INSTRUCTIONS_AVAILABLE);
#endif

    /*
       IsProcessorFeaturePresent might set the last error if it returns FALSE.
    */

    SetMpErrno(MP_ERRNO_NO_ERROR, PBIGCTX_PASS);  // N.B. no _clue
    return OK;
} /* mp_initialization */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\mprand.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
        File mprand.c.  This file has some routines which
        generate random numbers with special distributions.

        BOOL new_random_bytes(barray, lng, pRNGINFO)

             Generate -lng- random bytes in -barray-, using
             random number generator specified by pRNGINFO.
             Simplifies to random_bytes(barray, lng)
             if pRNGINFO = RNGINFO_NULL.


        BOOL new_random_digit_interval(dlow, dhigh, pdout, pRNGInfo)
        BOOL new_random_dword_interval(dlow, dhigh, pdout, pRNGInfo)
              -- Generate pseudorandom value *pdout, dlow <= *pdout <= dhigh.

        BOOL new_random_mod(n, array, lng, pRNGInfo)
                 -- Generate random multiple-precision
                    value -array-, 0 <= array < n.

        BOOL new_random_mod_nonzero(n, array, lng, pRNGInfo)
                 -- Generate random multiple-precision
                    value -array-, 1 <= array < n.

  Alse see file randminv.c
*/
#define MPRAND_C 1   // Tested in mprand.h

#include "bignum.h"
#include "mprand.h"
#include <stdlib.h>
BOOL WINAPI new_random_bytes
        (BYTE          barray[],    // OUT
        const size_t   lng,         // IN
        RNGINFOC*     pRNGInfo,     // IN
        PBIGCTX_ARG)
{
    BOOL OK = TRUE;

    if (RNGINFO_NULL == pRNGInfo) {
        OK = random_bytes(barray, lng, PBIGCTX_PASS);
    } else {
#if 0
        (*((FARPROC)pRNGInfo->pFuncRNG))
                  (barray, lng, pRNGInfo->pInfo, PBIGCTX_PASS);
#else
        (*(pRNGInfo->pFuncRNG)) (barray, lng, pRNGInfo->pInfo, PBIGCTX_PASS);
    // TBD -- Should this be changed to return BOOL?
#endif
    }
    return OK;
} // new_random_bytes
/****************************************************************************/
BOOL WINAPI new_random_digit_interval
        (digit_tc  dlow,
         digit_tc  dhigh,
         digit_t  *pdout,
         RNGINFOC *pRNGInfo,
         PBIGCTX_ARG)

{                       /* Return random integer in [dlow, dhigh] */
    BOOL OK = TRUE;

    if (dhigh < dlow) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "new_random_digit_interval",
                        PBIGCTX_PASS);
    } else {
        digit_tc spread = dhigh - dlow;
        DWORDREGC shift_count = RADIX_BITS - significant_bit_count(spread | 1);
        digit_t result = 0;
        do {
            OK = OK && new_random_digits(&result, 1, pRNGInfo, PBIGCTX_PASS);
            result >>= shift_count;
        } while (OK && result > spread);
        *pdout = dlow + result;
    }
    return OK;
} /* new_random_digit_interval */
/****************************************************************************/
BOOL WINAPI new_random_dword_interval
        (DWORDC    dlow,
         DWORDC    dhigh,
         DWORD    *pdout,
         RNGINFOC *pRNGInfo,
         PBIGCTX_ARG)

{                       /* Return random integer in [dlow, dhigh] */
    BOOL OK = TRUE;

    if (dhigh < dlow) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "new_random_dword_interval", PBIGCTX_PASS);
    } else {
        DWORD result = 0;
        DWORDC spread = dhigh - dlow;
        DWORDREGC shift_count = RADIX_BITS - significant_bit_count(spread | 1);
#if DWORD_BITS > RADIX_BITS
#error -- digit_t too small
#endif
        do {
            OK = OK && new_random_dwords(&result, 1, pRNGInfo, PBIGCTX_PASS );
            result >>= shift_count;
        } while (OK && result > spread);
        *pdout = dlow + result;
    }
    return OK;
} /* new_random_dword_interval */
/****************************************************************************/
BOOL WINAPI new_random_mod
        (digit_tc   n[],
         digit_t    arr[],
         DWORDREGC  lng,
         RNGINFOC  *pRNGInfo,
         PBIGCTX_ARG)
/*
        Generate pseudorandom value in [0, n - 1].
        n has length lng and must be nonzero.
*/
{
    DWORDREG lngsig = lng;
    BOOL OK = TRUE;

    while (lngsig > 0 && n[lngsig-1] == 0) {
        arr[lngsig-1] = 0;
        lngsig--;
    }

    if (!OK) {
    } else if (n == arr) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_OVERLAPPING_ARGS,
                        "new_random_mod",
                        PBIGCTX_PASS);
    } else if (lngsig == 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_ZERO_OPERAND,
                        "new_random_mod",
                        PBIGCTX_PASS);
    } else {
        digit_tc nlead = n[lngsig-1];
        int ntry = 0;
        do {
            ntry++;
            if (ntry > 100) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_TOO_MANY_ITERATIONS,
                                "new_random_mod", PBIGCTX_PASS);
            }
            OK = OK && new_random_digits(arr, lngsig-1, pRNGInfo, PBIGCTX_PASS);
            OK = OK && new_random_digit_interval(0, nlead,
                                        &arr[lngsig-1], pRNGInfo, PBIGCTX_PASS);
        } while (OK && compare_same(arr, n, lngsig) >= 0);
    }
    return OK;
} /* new_random_mod */
/****************************************************************************/
BOOL WINAPI new_random_mod_nonzero
        (digit_tc   n[],
         digit_t    arr[],
         DWORDREGC  lng,
         RNGINFOC  *pRNGInfo,
         PBIGCTX_ARG)
/*
        Generate pseudorandom value in [1, n-1].  Require n > 1.
*/
{
    BOOL OK = TRUE;

    if (compare_immediate(n, DIGIT_ONE, lng) <= 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "new_random_mod_nonzero",
                        PBIGCTX_PASS);
    } else {
        int ntry = 0;
        do {
            ntry++;
            if (ntry > 100) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_TOO_MANY_ITERATIONS,
                                "new_random_mod_nonzero", PBIGCTX_PASS);
            } else {
                OK = new_random_mod(n, arr, lng, pRNGInfo, PBIGCTX_PASS);
            }
        } while (OK && all_zero(arr, lng));
    }
    return OK;
} /* new_random_mod_nonzero */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\mpmul22.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bignum.h"

#ifndef SELF_TEST
    #define SELF_TEST 0
        /* Use SELF_TEST = 1 when timing and testing assembly code */
#endif

/*
                File mpmul22.c.  Supplement to mpgcdex.c.

        mp_mul22u(mat, vec1, vec2, lvec, carrys) -- Multiplies the
                  multiple-precision numbers vec1 and vec2 (length lvec)
                  by a 2 x 2 matrix of unsigned scalars.

                        (carrys[0], vec1)   (m11  m12)  (vec1)
                                          =
                        (carrys[1], vec2)   (m21  m22)  (vec2)

                  where mat has m11, m12, m21, m22.
                  Require m11 + m12 < RADIX and m21 + m22 < RADIX.


        mp_mul22s(mat, vec1, vec2, lvec, carrys) -- Multiplies the
                  multiple-precision numbers vec1 and vec2 (length lvec)
                  by a 2 x 2 matrix with signed off-diagonal scalars.

                        (carrys[0], vec1)   (m11  -m12)  (vec1)
                                          =
                        (carrys[1], vec2)   (-m21  m22)  (vec2)

                  where mat has m11, m12, m21, m22.
                  Require m11, m12, m21, m22 all in [0, RADIX/2 - 1]

*/


#if USEASM_IX86

#pragma warning(disable: 4100)
            // unreferenced formal parameter

/*
            The following are temporary variables in
            some of the X86 assembly codes.
            The entire struct is stored on the stack
            at the start of each routine.
            Each routine uses the data it needs.
*/

typedef struct {
    digit_t carry1;
    digit_t carry2;
    digit_t mat[4];             // Copy of matrix
    __int32 saved_regs22[4];    // ebp, ebx, edi, esi
} mul22_locals_t;

/*
              Assembly language pseudocode for mp_mul22u
              (mp_mul22s is very similar -- carry1, carry2 are signed,
              and some adds of edx:eax are replaced by subtracts).

    save matrix and registers, in struct on stack
    carry1 = ecx = 0

    esp = adjusted stack pointer
    ebp = remaining loop count
    edi = @vec1[i]
    eii = @vec2[i]

loop
        Save carry2 (in ecx)

        edx:eax = m11*vec1[i]
        ebx:ecx = carry1 (zero extended)
        ebx:ecx += edx:eax

        edx:eac = m12*vec2[i]
        ebx:ecx += edx:eax

        edx:eax = m21*vec1[i]
        update carry1 and vec1[i]
        ecx:ebx = carry2 (zero extended)
        ecx:ebx += edx:eax

        edx:eax = m22*vec2[i]
        ecx:ebx += edx:eax

        update  vec2[i]
        adjust ebp, esi, edi
    branch if more iterations

    load carrys address, carry1 (carry2 is in ecx)
    restore ebp, esi, edi
    save carry1
    return
*/

#define mp_mul22u_asm mp_mul22u
Naked86 BOOL WINAPI mp_mul22u_asm
              (digit_tc mat[4],            // IN  (2 x 2 matrix of scalars)
               digit_t  vec1[],            // INOUT
               digit_t  vec2[],            // INOUT
               DWORDREGC lvec,             // IN
               digit_t  carrys[2],         // OUT  (array of 2 scalars)
               PBIGCTX_ARG)
{
    __asm {
        mov edx,[esp+4]                          ; edx = mat
        sub esp,TYPE mul22_locals_t              ; Allocate space on stack

        xor ecx,ecx                              ; ecx = carry2 = 0
                             ; AGI delay here

        mov [esp].saved_regs22,ebp               ; Save ebp/ebx/edi/esi
        mov [esp+4].saved_regs22,ebx
        mov [esp+8].saved_regs22,edi
        mov [esp+12].saved_regs22,esi

        mov eax,[edx]                            ; Load first two matrix entries
        mov ebx,[edx+4]

        mov ebp,[esp+TYPE mul22_locals_t+4+12]
                                         ; ebp = lvec = remaining loop count
        mov edi,[esp+TYPE mul22_locals_t+4+4]    ; edi = vec1 address

        mov [esp].mat,eax               ; Copy first two matrix entries to stack
        mov [esp+4].mat,ebx

        mov eax,[edx+8]                          ; Load rest of matrix
        mov ebx,[edx+12]

        mov esi,[esp+TYPE mul22_locals_t+4+8]    ; esi = vec2 address
        test ebp,ebp                             ; Check whether loop count == 0

        mov [esp+8].mat,eax                      ; Store rest of matrix
        mov [esp+12].mat,ebx

        mov [esp].carry1,ecx             ; carry1 = 0  (and ecx has carry2 = 0)
        jz mul22u_exit0                          ; Exit if lvec == 0

mul22u_loop1:

        mov edx,[edi]                             ; edx = vec1[i]
        mov eax,[esp].mat                         ; eax = m11

        mov [esp].carry2,ecx                      ; Update carry2
        mov ecx,[esp].carry1

        mul edx                                   ; edx:eax = m11*vec1[i]

        xor ebx,ebx                               ; ebx:ecx = carry1
        add edi,4                                 ; Advance vec1[i] address

        add ecx,eax
        mov eax,[esp+4].mat                       ; eax = m12

        adc ebx,edx                          ; ebx:ecx = m11*vec1[i] + carry1
        mov edx,[esi]                             ; edx = vec2[i]

        mul edx                                   ; edx:eax = m12*vec2[i]

        add ecx,eax
        mov eax,[esp+8].mat                       ; eax = m21

        adc ebx,edx                               ; ebx:ecx += m12*vec2[i]
        mov edx,[edi-4]                           ; edx = vec1[old i]

        mul edx                                   ; edx:eax = m21*vec1[i]

        mov [edi-4],ecx                           ; Update vec1[old i]
        xor ecx,ecx

        mov [esp].carry1,ebx                      ; Update carry1
        mov ebx,[esp].carry2                      ; ecx:ebx = carry2

        add ebx,eax
        mov eax,[esp+12].mat                      ; eax = m22

        adc ecx,edx                           ; ecx:ebx += m21*(old vec1[i])
        mov edx,[esi]                             ; edx = vec2[i]

        mul edx                                   ; edx:eax = m22*vec2[i]

        add esi,4                                 ; Advance vec2[i] address
        add ebx,eax

        adc ecx,edx                               ; ecx:ebx += m22*vec2[i]
        dec ebp                                   ; Decrement loop counter

        mov [esi-4],ebx                           ; Update vec2[old i]
        jnz mul22u_loop1                          ; Continue until ebp == 0

        ; N.B.  ecx = carry2
mul22u_exit0:
        mov eax,[esp+TYPE mul22_locals_t+4+16] ; eax = address of carrys array
        mov edx,[esp].carry1

        mov ebp,[esp].saved_regs22
        mov ebx,[esp+4].saved_regs22

        mov edi,[esp+8].saved_regs22
        mov esi,[esp+12].saved_regs22

        add esp,TYPE mul22_locals_t               ; Remove struct from stack
        mov [eax],edx                             ; carrys[0] = carry1

        mov [eax+4],ecx                           ; carrys[1] = carry2
        mov eax,TRUE
        ret 24                            ; return, remove 6 args from stack

    }  /* end _asm IX86 */
} // mp_mul22u_asm


#define mp_mul22s_asm mp_mul22s
Naked86 BOOL WINAPI mp_mul22s_asm
              (digit_tc mat[4],            // IN  (2 x 2 matrix of scalars)
               digit_t  vec1[],            // INOUT
               digit_t  vec2[],            // INOUT
               DWORDREGC  lvec,            // IN
               sdigit_t scarrys[2],        // OUT  (array of 2 scalars)
               PBIGCTX_ARG)
{
    PBIGCTX_UNUSED;
    __asm {
        mov edx,[esp+4]                          ; edx = mat
        sub esp,TYPE mul22_locals_t              ; Allocate space on stack

        xor ecx,ecx                              ; ecx = carry2 = 0
                             ; AGI delay here

        mov [esp].saved_regs22,ebp               ; Save ebp/ebx/edi/esi
        mov [esp+4].saved_regs22,ebx
        mov [esp+8].saved_regs22,edi
        mov [esp+12].saved_regs22,esi

        mov eax,[edx]                       ; Load first two matrix entries
        mov ebx,[edx+4]

        mov ebp,[esp+TYPE mul22_locals_t+4+12]
                                        ; ebp = lvec = remaining loop count
        mov edi,[esp+TYPE mul22_locals_t+4+4]    ; edi = vec1 address

        mov [esp].mat,eax               ; Copy first two matrix entries to stack
        mov [esp+4].mat,ebx

        mov eax,[edx+8]                          ; Load rest of matrix
        mov ebx,[edx+12]

        mov esi,[esp+TYPE mul22_locals_t+4+8]    ; esi = vec2 address
        test ebp,ebp                          ; Check whether loop count == 0

        mov [esp+8].mat,eax                      ; Store rest of matrix
        mov [esp+12].mat,ebx

        mov [esp].carry1,ecx              ; carry1 = 0  (and ecx has carry2 = 0)
        jz mul22s_exit0                          ; Exit if lvec == 0

mul22s_loop1:

        mov edx,[edi]                             ; edx = vec1[i]
        mov eax,[esp].mat                         ; eax = m11

        mov ebx,[esp].carry1
        mov [esp].carry2,ecx                      ; Update carry2

        mul edx                                   ; edx:eax = m11*vec1[i]

        sar ebx,31
        mov ecx,[esp].carry1                ; ebx:ecx = carry1 (sign extended)

        add ecx,eax
        mov eax,[esp+4].mat                       ; eax = m12

        adc ebx,edx                          ; ebx:ecx = m11*vec1[i] + carry1
        mov edx,[esi]                             ; edx = vec2[i]

        mul edx                                   ; edx:eax = m12*vec2[i]

        sub ecx,eax
        mov eax,[esp+8].mat                       ; eax = m21

        sbb ebx,edx                               ; ebx:ecx -= m12*vec2[i]
        mov edx,[edi]                             ; edx = vec1[i]

        mul edx                                   ; edx:eax = m21*vec1[i]

        mov [esp].carry1,ebx                      ; Update carry1
        mov ebx,[esp].carry2                      ; carry2

        mov [edi],ecx                             ; Update vec1[i]
        mov ecx,ebx                               ; carry2

        sar ecx,31                          ; ecx:ebx = carry2 (sign extended)
        add edi,4                                 ; Advance vec1[i] address

        sub ebx,eax
        mov eax,[esp+12].mat                      ; eax = m22

        sbb ecx,edx                               ; ecx:ebx -= m21*(old vec1[i])
        mov edx,[esi]                             ; edx = vec2[i]

        mul edx                                   ; edx:eax = m22*vec2[i]

        add esi,4                                 ; Advance vec2[i] address
        add ebx,eax

        adc ecx,edx                               ; ecx:ebx += m22*vec2[i]
        dec ebp                                   ; Decrement loop counter

        mov [esi-4],ebx                           ; Update vec2[old i]
        jnz mul22s_loop1                          ; Continue until ebp == 0

        ; N.B.  ecx = carry2
mul22s_exit0:
        mov eax,[esp+TYPE mul22_locals_t+4+16]  ; eax = address of scarrys array
        mov edx,[esp].carry1

        mov ebp,[esp].saved_regs22
        mov ebx,[esp+4].saved_regs22

        mov edi,[esp+8].saved_regs22
        mov esi,[esp+12].saved_regs22

        add esp,TYPE mul22_locals_t               ; Remove struct from stack
        mov [eax],edx                             ; carrys[0] = carry1

        mov [eax+4],ecx                           ; carrys[1] = carry2
        mov eax,TRUE
        ret 24                              ; return, remove 6 args from stack
    }  /* end _asm IX86 */
} // mp_mul22s_asm
#elif USEASM_MIPS
     /* See mips.asm */
#define mp_mul22u_asm mp_mul22u
#define mp_mul22s_asm mp_mul22s


#endif
/*
          No assembly code presently (1999) for non-Intel architectures.
          To add others, write an external procedure mp_mul22u or mp_mul22s,
          Then #define mp_mul22u_asm and/or mp_mul22s_asm to be
          the alternate procedure.
*/

#if !defined(mp_mul22u_asm)
#define mp_mul22u_asm mp_mul22u_c
#define mp_mul22u_c mp_mul22u
#endif

#if defined(mp_mul22u_c) || SELF_TEST == 1

BOOL WINAPI mp_mul22u_c
              (digit_tc mat[4],            // IN  (2 x 2 matrix of scalars)
               digit_t  vec1[],            // INOUT
               digit_t  vec2[],            // INOUT
               DWORDREGC lvec,             // IN
               digit_t  carrys[2],         // OUT  (array of 2 scalars)
               PBIGCTX_ARG)
/*
      This routine is given a 2 x 2 matrix mat with elements m11, m12, m21, m22
      in order.  It is also given two multi-precision numbers vec1 and vec2
      of length lvec.  It does the matrix x vector multiplication

                ( m11  m12 )  ( vec1 )

                ( m21  m22 )  ( vec2 )

      and stores the results back in [vec1, vec2].
      Any carries (beyond lvec words) go into the carrys vector.

      RESTRICTION:  The scalars m11, m12, m21, m22 must be nonnegative
                    and satisfy m11 + m12 < RADIX,  m21 + m22 < RADIX.
                    Given these bounds, it is easy to check by induction
                    that carry1, carry2 are bounded by RADIX - 2.
*/
{
    DWORDREG i;
    BOOL OK = TRUE;
    digit_t carry1 = 0, carry2 = 0;
    digit_tc m11 = mat[0], m12 = mat[1], m21 = mat[2], m22 = mat[3];

    if (m12 > RADIXM1 - m11 || m21 > RADIXM1 - m22) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA, "mp_mul22u", PBIGCTX_PASS);
    }
    if (OK) {
        for (i = 0; i != lvec; i++) {
            dblint_tc prod11 = MULTIPLY_ADD1(m11, vec1[i], carry1);
            dblint_tc prod21 = MULTIPLY_ADD1(m21, vec1[i], carry2);
            dblint_tc prod12 = MULTIPLY_ADD1(m12, vec2[i], LOW_DIGIT(prod11));
            dblint_tc prod22 = MULTIPLY_ADD1(m22, vec2[i], LOW_DIGIT(prod21));
            vec1[i] = LOW_DIGIT(prod12);
            vec2[i] = LOW_DIGIT(prod22);
            carry1 = HIGH_DIGIT(prod11) + HIGH_DIGIT(prod12);
            carry2 = HIGH_DIGIT(prod21) + HIGH_DIGIT(prod22);
        } // for i
    }
    carrys[0] = carry1;
    carrys[1] = carry2;
    return OK;
} // end mp_mul22u

#endif /* if C code compiled */


#if !defined(mp_mul22s_asm)
#define mp_mul22s_asm mp_mul22s_c
#define mp_mul22s_c mp_mul22s
#endif

#if defined(mp_mul22s_c) || SELF_TEST == 1

BOOL WINAPI mp_mul22s_c(
            digit_tc mat[4],            // IN  (2 x 2 matrix of scalars)
            digit_t  vec1[],            // INOUT
            digit_t  vec2[],            // INOUT
            DWORDREGC lvec,             // IN
            sdigit_t carrys[2],         // OUT  (array of 2 scalars)
            PBIGCTX_ARG)
/*
      This routine resembles mp_mul22u except that the off-diagonal
      elements m12, m21 are treated as negative (with their absolute values
      passed in the array).  It does the matrix x vector multiplication

                (  m11  -m12 )  ( vec1 )

                ( -m21   m22 )  ( vec2 )

      and stores the results back in [vec1, vec2].
      Any carries (beyond lvec words) go into the carrys vector.

      Here carrys has type sdigit_t rather than digit_t.

      RESTRICTION:  The scalars m11, m12, m21, m22 must be nonnegative
                    and at most M, where M < RADIX/2.
                    This is more restrictive than mp_mul22u,
                    which checks only m11 + m12 and m21 + m22.
                    It is easy to check by induction that
                    carry1, carry2 are in [-M, M-1].
*/
{
    BOOL OK = TRUE;
    DWORDREG i;
    sdigit_t carry1 = 0, carry2 = 0;
    digit_tc m11 = mat[0], m12 = mat[1], m21 = mat[2], m22 = mat[3];

    if ((m11 | m12 | m21 | m22) & RADIX_HALF) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA, "mp_mul22s\n", PBIGCTX_PASS);
    }
    if (OK) {
        for (i = 0; i != lvec; i++) {
            dblint_tc prod11 = DPRODUU(m11, vec1[i]);
            dblint_tc prod12 = DPRODUU(m12, vec2[i]);
            dblint_tc prod21 = DPRODUU(m21, vec1[i]);
            dblint_tc prod22 = DPRODUU(m22, vec2[i]);
            dblint_t prod1, prod2;

            prod1 = DBLINT_ADD(prod11, SDBLINT(carry1));
            prod2 = DBLINT_ADD(prod22, SDBLINT(carry2));
            prod1 = DBLINT_SUB(prod1, prod12);
            prod2 = DBLINT_SUB(prod2, prod21);
            vec1[i] = LOW_DIGIT(prod1);
            vec2[i] = LOW_DIGIT(prod2);
            carry1 = SHIGH_DIGIT(prod1);
            carry2 = SHIGH_DIGIT(prod2);
        } // for i
    }
    carrys[0] = carry1;
    carrys[1] = carry2;
    return OK;
} // end mp_mul22s

#endif /* if C code compiled */

#if SELF_TEST == 1
/*
        If SELF_TEST == 1, then this source file is self-contained
        (except for #include files). mul22_test
        compares mp_mul22u to mp_mul22u_asm and mp_mul22s to mp_mul22s_asm,
        both in terms of outputs and CPU times.
        Use SELF_TEST == 1 when testing and timing
        assembly code for a new machine.
*/
#include <stdio.h>
#include <stdlib.h>
#include "mprand.h"
#include "whererun.h"

/*
    Access the functions via pointers in the timing test,
    to inhibit inlining one function but not the other
    (inlining might bias the times).
*/

BOOL (WINAPI *m22uptr[2])(digit_tc[4], MP_MODIFIED, MP_MODIFIED,
                   DWORDREGC, digit_t[2], PBIGCTX_ARG)
                = {mp_mul22u_asm, mp_mul22u_c};

BOOL (WINAPI *m22sptr[2])(digit_tc[4], MP_MODIFIED, MP_MODIFIED,
                   DWORDREGC, sdigit_t[2], PBIGCTX_ARG)
                = {mp_mul22s_asm, mp_mul22s_c};

#undef LNGMAX
#undef NREPEAT
#define LNGMAX 50
#define NREPEAT 300000

int mul22_test(PBIGCTX_ARG)   // Output is error count
{

    DWORDREG itest;
    int nerror = 0;
    digit_t vec1a[LNGMAX+1], vec1b[LNGMAX+1], vec1c[LNGMAX+1];
    digit_t vec1d[LNGMAX+1], vec1e[LNGMAX+1];
    digit_t vec2a[LNGMAX+1], vec2b[LNGMAX+1], vec2c[LNGMAX+1];
    digit_t vec2d[LNGMAX+1], vec2e[LNGMAX+1];
    digit_t carrysb[2], carrysc[2], mat[4];
    sdigit_t scarrysd[2], scarryse[2];

    where_running("Selftest for mpmul22.c");
    printf("Times are microseconds\n");

    for (itest = 0; itest < 200 && nerror < 5; itest++) {
        DWORDREG lngnow = (itest % LNGMAX);
        DWORDREG i, ndiffs;
        BOOL OK = TRUE;

        OK = OK && random_digits(vec1a, lngnow+1, PBIGCTX_PASS);
        OK = OK && random_digits(vec2a, lngnow+1, PBIGCTX_PASS);
        for (i = 0; i <= lngnow; i++) {   // Copy the random arrays
            vec1b[i] = vec1c[i] = vec1d[i] = vec1e[i] = vec1a[i];
            vec2b[i] = vec2c[i] = vec2d[i] = vec2e[i] = vec2a[i];
        }
        OK = OK && random_digits(mat, 4, PBIGCTX_PASS);
        for (i = 0; i != 4; i++) {
            mat[i] >>= 1;   // At most RADIX/2 - 1
        }

               // Do computation in assembly and C.  Comapre results

        OK = OK && (*m22uptr[0])(mat, vec1b, vec2b, lngnow,
                                  carrysb, PBIGCTX_PASS);
        OK = OK && (*m22uptr[1])(mat, vec1c, vec2c, lngnow,
                                  carrysc, PBIGCTX_PASS);
        OK = OK && (*m22sptr[0])(mat, vec1d, vec2d, lngnow,
                                 scarrysd, PBIGCTX_PASS);
        OK = OK && (*m22sptr[1])(mat, vec1e, vec2e, lngnow,
                                 scarryse, PBIGCTX_PASS);

        ndiffs = 0;
        for (i = 0; i <= lngnow; i++) {
            digit_out_buf_t dbuf1, dbuf2;
            if (vec1b[i] != vec1c[i] || vec2b[i] !=  vec2c[i]) {
                ndiffs++;
                printf("mp_mul22u discrepancy  lngnow = %ld, i = %ld\n",
                    (long)lngnow, (long)i);
                printf("   vecb = %s %s\n",
                    digit_out(vec1b[i], dbuf1, PBIGCTX_PASS),
                    digit_out(vec2b[i], dbuf2, PBIGCTX_PASS) );
                printf("   vecc = %s %s\n",
                    digit_out(vec1c[i], dbuf1, PBIGCTX_PASS),
                    digit_out(vec2c[i], dbuf2, PBIGCTX_PASS));
            }
            if (vec1d[i] != vec1e[i] || vec2d[i] != vec2e[i]) {
                ndiffs++;
                printf("mp_mul22s discrepancy  lngnow = %ld, i = %ld\n",
                    (long)lngnow, (long)i);
                printf("   vecd = %s %s\n",
                    digit_out(vec1d[i], dbuf1, PBIGCTX_PASS),
                    digit_out(vec2d[i], dbuf2, PBIGCTX_PASS));
                printf("   vece = %s %s\n",
                    digit_out(vec1e[i], dbuf1, PBIGCTX_PASS),
                    digit_out(vec2e[i], dbuf2, PBIGCTX_PASS));
            }
        } /* for i */
        if (ndiffs > 0) nerror++;
        if (carrysb[0] != carrysc[0] || carrysb[1] != carrysc[1]) {
            nerror++;
            printf("mp_mul22u carry arrays differ\n");
        }
        if (scarrysd[0] != scarryse[0] || scarrysd[1] != scarryse[1]) {
            nerror++;
            printf("mp_mul22s scarry arrays differ\n");
        }
        if (itest <= 20 && nerror == 0) {    // Time the codes
            DWORDREG irepeat;
            double to_usec = 1e6 / (double)NREPEAT;
            LARGE_INTEGER t1, t2, t3, t4, t5;
            mat[0] |= 1; mat[3] |= 1;
            mat[1] &= ~1; mat[2] &= ~1;    /* Make an identity matrix, mod 2 */
            QueryPerformanceCounter(&t1);
            for (irepeat = 0; irepeat != NREPEAT; irepeat++) {
                (*m22uptr[0])(mat, vec1b, vec2b, lngnow,
                               carrysb, PBIGCTX_PASS);
            }
            QueryPerformanceCounter(&t2);
            for (irepeat = 0; irepeat != NREPEAT; irepeat++) {
                (*m22uptr[1])(mat, vec1c, vec2c, lngnow,
                               carrysc, PBIGCTX_PASS);
            }
            QueryPerformanceCounter(&t3);
            for (irepeat = 0; irepeat != NREPEAT; irepeat++) {
                (*m22sptr[0])(mat, vec1d, vec2d, lngnow,
                              scarrysd, PBIGCTX_PASS);
            }
            QueryPerformanceCounter(&t4);
            for (irepeat = 0; irepeat != NREPEAT; irepeat++) {
                (*m22sptr[1])(mat, vec1e, vec2e, lngnow,
                              scarryse, PBIGCTX_PASS);
            }
            QueryPerformanceCounter(&t5);

            printf("lng = %3ld, mul22u = %7.3f(asm) %7.3f(C)"
                           ", mul22s = %7.3f(asm) %7.3f(C)\n",
                             (long)lngnow,
                             to_usec*query_diff(&t1, &t2),
                             to_usec*query_diff(&t2, &t3),
                             to_usec*query_diff(&t3, &t4),
                             to_usec*query_diff(&t4, &t5) );
        } // if timing comparison done
    } // for itest
    return nerror;
} // mul22_test
#endif /* SELF_TEST == 1 */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\mpaddsubcmp.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include "bigpriv.h"
#ifndef assert
#include <assert.h>
#endif

/*
        File mpaddsubcmp.c.  Add/subtract/compare routines.
        These are candidates for assembly code when
        porting this package to a new architecture.

        Many of these are low-level routines.
        Many return a carry flag (digit_t) rather than success/failure (BOOL).


OK = add_diff(a, lnga, b, lngb, c, pcarry, PBIGCTX_ARG)
                                           -- c := a + b, where lnga >= lngb.
                                              Return carry in *pcarry).

BOOL add_full(a, lng, b, lngb, c, plngc, PBIGCTX_ARG
                                -- c := a + b, return length of c in *pargc,
                                   without knowing whether a or b is longer.

carry  = add_immediate(a, iadd, lnga, b)
                                    -- b := a + iadd, where iadd is a scalar.

OK = add_mod(a, b, c, modulus, lng, PBIGCTX_ARG);
                                    -- c := a + b (mod modulus), all length lng

carry  = add_same(a, b, c, lng)     -- c := a + b, where all have length lng.

carry  = add_sub_same(a, b, c, d, lng)
                                 -- d := a + b - c, where all have length lng.
                                    N.B.  carry may be negative.

icomp = compare_diff(a, lnga, b, lngb) -- Return sign of a - b, where a and b
                                          are allowed to have different lengths.

icomp = compare_same(a, b, lng)        -- Return sign of a - b, where a and b
                                          both have length lng.
                                          Declared inline in bignum.h.

icomp =  compare_sum_diff(a, lnga, b, lngb, c, lngc)
                    -- Return sign of a + b - c, where lengths are different.

icomp =  compare_sum_same(a, b, c, lng) -- Return sign of a + b - c,
                                          where all have length lng.

OK     = neg_mod(a, b, modulus, lng, PBIGCTX_ARG)   -- b := -a (mod modulus),
                                                             all length lng

OK = sub_diff(a, lnga, b, lngb, c, pborrow, PBIGCTX_ARG)
                                      ) -- c := a - b, where lnga >= lngb.
                                          Return borrow in *pborrow.

borrow = sub_immediate(a, isub, lnga, b)
                                    -- b := a - isub, where isub is a scalar.

OK = sub_mod(a, b, c, modulus, lng, PBIGCTX_ARG);
                                       -- c := a - b (mod modulus),
                                                      all length lng

borrow = sub_same(a, b, c, lng)        -- c := a - b, where all have length lng.

OK = validate_modular_data1(data, modulus, lng, string, PBIGCTX_ARG) --
                                      Validate 0 <= data < modulus, where
                                      data and modulus have length lng.
                                      If not, issue an error and return FALSE.

        Each routine (except multiply_low) returns a carry/borrow flag.
        Those returning TRYE/FALSE error flags have the PBIGCTX_ARG argument,
        which an error handler might need.

Assembly language note:

        If the architecture has fast add/subtract with carry/borrow
        instructions (e.g., ADC/SBB on Intel x86,
        ADDE/SUBE on PowerPC, addxcc/subxcc on 32-bit SPARCs),
        then that is the most natural way to code these routines.
                The Alpha architecture has CMPULT and CMPULE
        instructions to do unsigned compares (returning 0 or 1).
        It also has a conditional move.  A possible inner loop is

                sum = a[i] + carry;
                c[i] = b[i] + sum;
                if (sum != 0) carry = (c[i] < sum);

        for addition (c := a + b) and

                dif = a[i] - b[i];
                c[i] = dif - borrow;
                if (dif != 0) borrow = (a[i] < b[i]);
                                            [ or   a[i] < dif  ]

        for subtraction (c := a - b).  Each loop body has
        two adds/subtracts, one compare, and one conditional move
        (plus loads, stores, and loop control).

                The MIPS 32-bit R2000/R3000 architecture has SLTU
        for unsigned compares but lacks conditional moves
        (although later versions of the architecture have
        conditional moves on zero/nonzero).
        One can emulate the Alpha code, with explicit branches
        when sum == 0 or dif == 0 (and with the store into c[i]
        occupying the delay slot).  Or one can use SLTU twice, computing

                carry = (sum < carry) + (c[i] < sum);
                borrow = (dif < borrow) + (a[i] < b[i]);

        (three adds or subtracts, two SLTU).

                The Pentium IV architecture has ADC and SBB, but they are
        much slower than a regular add or subtract.  One solution inspects the
        upper bits of a[i], b[i], a[i] + b[i] + carry (mod 2^32)
        to identify whether a carry has occurred.  That is,

                ai = a[i];
                bi = b[i];
                sum = ai + bi + carry;
                carry = MAJORITY(ai, bi, ~sum) >> 31;

        The MAJORITY function acts bitwise, returning 1 wherever
        two (or all three) operands have a 1 bit, zero elsewhere.
        On the Pentium, it could expand to

                (ai | bi) ^ ( sum & (ai ^ bi))

        with (ai | bi) expanding as bi | (ai & bi).  Only three registers are
        needed for ai, bi, carry (with sum occupying same register as carry):

                 load ai and bi;
                 carry += ai;
                 ai ^= bi;           // ai ^ bi
                 carry += bi;        // sum = ai + bi + carry
                 bi |= ai;           // bi | (ai ^ bi) = ai | bi
                 store low part of carry
                 carry &= ai;        // sum & (ai ^ bi)
                 carry ^= bi;        // (ai | bi) ^ (sum & (ai ^ bi))
                 carry >>= 31;

        (two adds, four boolean, one shift).  On Pentium IV, the
        adds and boolean operations take 0.5 cycle each; shift takes
        4 cycles; ADC takes 8 cycles.

        Similarly, the inner loop of a subtraction a - b can have

                sum = ai - bi - borrow;
                borrow = MAJORITY(~ai, bi, sum) >> 31;

        with MAJORITY expanding as

                 ai ^ ( (ai ^ bi) | (ai ^ sum))

        These methods will work in SIMD (= MMX or SSE) mode,
        where no carry bit is available.
        They can be used when there are more than two operands,
        such as A + B - C.
*/
/***************************************************************************/
BOOL WINAPI add_diff
        (digit_tc    a[],       // IN
         DWORDREGC   lnga,      // IN
         digit_tc    b[],       // IN
         DWORDREGC   lngb,      // IN
         digit_t     c[],       // OUT
         digit_t    *pcarry,    // OUT
         PBIGCTX_ARG)
/*
        Add c := a + b.
        Arrays a and c have length lnga and array b has length lngb,
        where lnga >= lngb.

        *pcarry is set to 1 if there is a carry out of the left of c.
        Otherwise *pcarry is set to 0.
        The store is suppressed if pcarry = digit_NULL;
*/
{
    BOOL OK = TRUE;

    if (lnga < lngb || ((lnga | lngb) & DWORD_LEFT_BIT)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "add_diff length conflict",
                        PBIGCTX_PASS);
    } else {
        digit_t carry = add_same(a, b, c, lngb);
        carry = add_immediate(a + lngb, carry, c + lngb, lnga - lngb);
        if (pcarry != digit_NULL) {
            *pcarry = carry;
        } else if (carry != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_OVERFLOW,
                            "add_diff overflow",
                            PBIGCTX_PASS);
        }
    }
    return OK;
}  /* add_diff */
/***************************************************************************/
BOOL WINAPI add_full
        (digit_tc  a[],       // IN
         DWORDREGC lnga,      // IN
         digit_tc  b[],       // IN
         DWORDREGC lngb,      // IN
         digit_t   c[],       // OUT
         DWORDREG *plngc,     // OUT
         PBIGCTX_ARG)
/*
        Compute c = a + b, where either a or b may be longer.
        Set *plngc to MAX(lnga, lngb, length of c).

        If lnga and lngb are minimal (i.e., no leading zeros in a or b),
        then *plngc will be minimal too.
*/
{
    digit_t carry = 0;
    DWORDREG lngc;
    BOOL OK = TRUE;

    if (lnga < lngb) {
        OK = OK && add_diff(b, lngb, a, lnga, c, &carry, PBIGCTX_PASS);
        lngc = lngb;
    } else {
        OK = OK && add_diff(a, lnga, b, lngb, c, &carry, PBIGCTX_PASS);
        lngc = lnga;
    }
    if (OK) {
        if (carry != 0) c[lngc++] = carry;
        *plngc = lngc;
    }
    return OK;
} /* add_full */
/***************************************************************************/
EXPORTED_INLINE digit_t WINAPI add_immediate
        (digit_tc   a[],        // IN
         digit_tc   iadd,       // IN
         digit_t    b[],        // IN
         DWORDREGC  lng)        // IN
/*
        Compute b = a + iadd, where iadd has length 1.
        Both a and b have length lng.
        Function value is carry out of leftmost digit in b.
*/
{
    digit_t carry = iadd;
    DWORDREG i;

    for (i = 0; i != lng; i++) {
        digit_tc bi = a[i] + carry;
        b[i] = bi;

        if (bi >= carry) { // No carry propagation
            if (a != b) {
                mp_copy(a + i + 1, b + i + 1, lng - i - 1, PBIGCTX_NULL);
            }
            return 0;
        }
        carry = 1;
    } // for i
    return carry;
}  // end add_immediate
/****************************************************************************/
BOOL WINAPI add_mod
        (digit_tc a[],         // IN
         digit_tc b[],         // IN
         digit_t  c[],         // OUT
         digit_tc modulus[],   // IN
         DWORDREGC lng,        // IN
         PBIGCTX_ARG)
/*
    c := a + b (mod modulus),where 0 <= a, b < modulus
*/
{
    BOOL OK = TRUE;
    sdigit_t carry;

    if (lng == 0) {
        OK = FALSE;
    } else {
        digit_tc alead = a[lng-1], blead = b[lng-1], mlead = modulus[lng-1];
        int itest;     // Sign of a + b - modulus

        if (alead >= mlead) {
            OK = OK && validate_modular_data(a, modulus, lng,
                                             "add_mod arg 1", PBIGCTX_PASS);
        }
        if (blead >= mlead) {
            OK = OK && validate_modular_data(b, modulus, lng,
                                             "add_mod arg 2", PBIGCTX_PASS);
        }

        if (OK) {

               // Try to determine whether a + b >= modulus
               // by looking only at the leading digits.

            if (blead > mlead - alead) {
                itest = +1;      // implies a + b > modulus
            } else if (mlead - alead - blead > 1) {
                itest = -1;      // implies a + b < modulus
            } else {
                itest = compare_sum_same(a, b, modulus, lng);
                                 // Compare a + b to modulus
            }

            if (itest >= 0) {
                carry = add_sub_same(a, b, modulus, c, lng);
                                                 // c = a + b - modulus
            } else {
                carry = (sdigit_t)add_same(a, b, c, lng);     // c = a + b
            }
            if (carry != 0) {
                OK = FALSE;
                SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR,
                                "add_mod",
                                PBIGCTX_PASS);
            }
#if PRINT_ERROR_MESSAGES
            OK = OK && validate_modular_data(c, modulus, lng,
                                              "add_mod result", PBIGCTX_PASS);
#endif
        }
    }
    return OK;
} // end add_mod
/****************************************************************************/
digit_t WINAPI add_same
        (digit_tc a[],     // IN
         digit_tc b[],     // IN
         digit_t  c[],     // OUT          c := a + b
         DWORDREGC lng)    // IN
/*
        c := a + b, where all operands have length lng.

        Function value is 1 if there is a carry out of the
        left of c.  Otherwise function value is zero.
*/
{
    digit_t carry = 0;
    DWORDREG i;

    for (i = 0; i != lng; i++) {
        digit_tc ai = a[i];
        digit_tc bi = b[i];

        carry += ai + bi;
        c[i] = carry;
        carry = (ai | bi) ^ ((ai ^ bi) & carry);  // MAJORITY(ai, bi, ~carry)
        carry >>= (RADIX_BITS - 1);
    } // for i
    return carry;
}  /* add_same */
/****************************************************************************/
sdigit_t WINAPI add_sub_same
        (digit_tc a[],     // IN
         digit_tc b[],     // IN
         digit_tc c[],     // IN
         digit_t  d[],     // OUT
         DWORDREGC   lng)  // IN
/*
        d := a + b - c, where all operands have length lng.

        Function value (0, 1, or -1) reflects any carry or
        borrow out of the left of d.
*/
{
    digit_t carry1 = 0, carry2 = 0;
    DWORDREG i;

    for (i = 0; i != lng; i++) {
        digit_tc ai = a[i];
        digit_tc bi = b[i];
        digit_tc ci = c[i];
        digit_tc sum1 = ai + bi + carry1;
        digit_tc sum2 = sum1 - ci - carry2;

        d[i] = sum2;
        carry1 = sum1 ^ ((sum1 ^ ai) | (sum1 ^ bi));  // MAJORITY(ai, bi, ~sum1)
        carry2 = sum1 ^ ((sum1 ^ ci) | (sum1 ^ sum2));
                                                    // MAJORITY(~sum1, ci, sum2)
        carry1 >>= (RADIX_BITS - 1);
        carry2 >>= (RADIX_BITS - 1);
    } // for i
    return (sdigit_t)carry1 - (sdigit_t)carry2;
}  /* add_sub_same */
/****************************************************************************/
int WINAPI compare_diff
        (digit_tc    a[],   // IN
         DWORDREGC   lnga,  // IN
         digit_tc    b[],   // IN
         DWORDREGC   lngb)  // IN

//        Compare two multiple precision numbers a (of length lnga)
//        and b (of length lngb).  Return the sign of a - b, namely

//                +1  if  a > b
//                 0  if  a = b  (after stripping leading zeros)
//                -1  if  a < b .

{
    DWORDREG la = lnga, lb = lngb;

    while (la > lb) {
        if (a[la-1] != 0) return +1;
        la--;
    }

    while (lb > la) {
        if (b[lb-1] != 0) return -1;
        lb--;
    }
    assert(la == lb);

    while (la != 0) {
        if (a[la-1] != b[la-1]) return (a[la-1] > b[la-1] ? +1 : -1);
        la--;
    }
    return 0;
} // compare_diff
/****************************************************************************/
EXPORTED_INLINE int WINAPI compare_same
        (digit_tc  a[],       // IN
         digit_tc  b[],       // IN
         DWORDREGC lng)       // IN
/*
        Compare two multiple precision numbers a and b each of length lng.
        Function value is the sign of a - b, namely

                          +1 if a > b
                           0 if a = b
                          -1 if a < b
*/
{
    DWORDREG i;
    for (i = lng; (i--) != 0; /*null*/) {
        if (a[i] != b[i]) return (a[i] > b[i] ? +1 : -1);
    }
    return 0;
}  /* compare_same */
/****************************************************************************/
int WINAPI compare_sum_diff
        (digit_tc     a[],
         DWORDREGC    lnga,
         digit_tc     b[],
         DWORDREGC    lngb,
         digit_tc     c[],
         DWORDREGC    lngc)
/*
//        Compare multiple-precision integers a, b, c, of lengths
//        lnga, lngb, lngc, respectively.  Return the sign of a + b - c, namely

//                +1  if  a + b > c
//                 0  if  a + b = c
//                -1  if  a + b < c
*/
{
    DWORDREGC lmax = MAX(MAX(lnga, lngb), lngc);
    DWORDREG i;
    int sum_prev = 0;

    for (i = lmax; (i--) != 0; /*null*/) {
        digit_tc aval = (i >= lnga ? 0 : a[i]);
        digit_tc bval = (i >= lngb ? 0 : b[i]);
        digit_tc cval = (i >= lngc ? 0 : c[i]);
        digit_t  sum_now = aval + bval;

        assert(sum_prev == 0 || sum_prev == -1);
        sum_prev += (sum_now < aval) - (sum_now < cval);  // -2, -1, 0, or +1
        sum_now -= cval;
              // Exit unless sum_now = sum_prev = 0 or -1
        if (   (digit_t)sum_prev != sum_now
            || ((sum_prev + 3) & 2) == 0) {   // If -2 or 1
            return ((sum_prev + 2) & 2) - 1;  // 1 if sum_prev > 0, else -1
        }
    }  // for i
    return sum_prev;     // 0 or -1
} // compare_sum_diff
/****************************************************************************/
EXPORTED_INLINE int WINAPI compare_sum_same
       (digit_tc  a[],      // IN
        digit_tc  b[],      // IN
        digit_tc  c[],      // IN
        DWORDREGC lng)      // IN
/*
//        Compare multiple-precision integers a, b, c, all of length lng.
//        Return the sign of a + b - c, namely

//                +1  if  a + b > c
//                 0  if  a + b = c
//                -1  if  a + b < c
*/
{
    DWORDREG i;
    int sum_prev = 0;

    for (i = lng; (i--) != 0; /*null*/) {
        digit_tc aval = a[i];
        digit_tc bval = b[i];
        digit_tc cval = c[i];
        digit_t  sum_now = aval + bval;

        assert(sum_prev == 0 || sum_prev == -1);

        sum_prev += (sum_now < aval) - (sum_now < cval);  // -2, -1, 0, or +1
        sum_now -= cval;
              // Exit unless sum_now = sum_prev = 0 or -1
        if (   (digit_t)sum_prev != sum_now
            || ((sum_prev + 3) & 2) == 0) {   // If -2 or 1
            return ((sum_prev + 2) & 2) - 1;  // 1 if sum_prev > 0, else -1
        }
    }
    return sum_prev;     // 0 or -1
} // compare_sum_same
/****************************************************************************/
BOOL WINAPI neg_mod
        (digit_tc a[],         // IN
         digit_t  b[],         // OUT
         digit_tc modulus[],   // IN
         DWORDREGC lng,        // IN
         PBIGCTX_ARG)
/* b := -a (mod modulus), where 0 <= a < modulus */
{
    BOOL OK = TRUE;
    DWORDREG i;
    digit_t all_zero = 0;

    for (i = 0; i != lng; i++) {
        all_zero |= a[i];
        b[i] = a[i];
    } // First copy a to b

    if (all_zero != 0) {
        digit_t borrow = sub_same(modulus, b, b, lng);
        if (borrow != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                            "neg_mod input",
                            PBIGCTX_PASS);
        }
    }     // If not identically zero, subtract from modulo->modulus

#if PRINT_ERROR_MESSAGES
    OK = OK && validate_modular_data(b, modulus, lng,
                                     "neg_mod result", PBIGCTX_PASS);
#endif
    return OK;
} // end neg_mod
/****************************************************************************/
BOOL WINAPI sub_diff
        (digit_tc    a[],        // IN
         DWORDREGC   lnga,       // IN
         digit_tc    b[],        // IN
         DWORDREGC   lngb,       // IN
         digit_t     c[],        // OUT
         digit_t     *pborrow,   // OUT
         PBIGCTX_ARG)
/*
        Subtract c := a - b.
        Arrays a and c have length lnga and array b has length lngb,
        where lnga >= lngb.

        *pborrow is set to 1 if there is a borrow out of the left of a.
        Otherwise *pborrow is set to 0.
        This store is suppressed if pborrow = digit_NULL.
*/
{
    BOOL OK = TRUE;

    if (lnga < lngb || ((lnga | lngb) & DWORD_LEFT_BIT)) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA,
                        "sub_diff -- length conflict", PBIGCTX_PASS);
    } else {
        digit_t borrow = sub_same(a, b, c, lngb);
        borrow = sub_immediate(a + lngb, borrow, c + lngb, lnga - lngb);
        if (pborrow != digit_NULL) {
            *pborrow = borrow;
        } else if (borrow != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_OVERFLOW,
                            "sub_diff underflow",
                            PBIGCTX_PASS);
        }
    }
    return OK;
}  /* sub_diff */
/****************************************************************************/
EXPORTED_INLINE digit_t WINAPI sub_immediate
        (digit_tc  a[],   // IN
         digit_tc  isub,  // IN
         digit_t   b[],   // OUT
         DWORDREGC lng)   // IN
/*
        Compute b = a - isub, where isub has length 1.
        Both a and b have length lng.
        Function value is borrow out of leftmost digit in b.
*/
{
    digit_t borrow = isub;
    DWORDREG i;

    for (i = 0; i != lng; i++) {
        digit_tc ai = a[i];

        b[i] = ai - borrow;
        if (ai >= borrow) { // No carry propagation
            if (a != b) {
                mp_copy(a + i + 1, b + i + 1, lng - i - 1, PBIGCTX_NULL);
            }
            return 0;
        }
        borrow = 1;
    }  // for i
    return borrow;
} // end sub_immediate
/****************************************************************************/
BOOL WINAPI sub_mod
        (digit_tc a[],       // IN
         digit_tc b[],       // IN
         digit_t  c[],       // OUT
         digit_tc modulus[], // IN
         DWORDREGC lng,      // IN
         PBIGCTX_ARG)
// c := a - b (mod modulus), where 0 <= a, b < modulus
{
    BOOL OK = TRUE;
    sdigit_t carry;

    if (lng == 0) {
        OK = FALSE;
    } else {
        digit_tc alead = a[lng-1], blead = b[lng-1], mlead = modulus[lng-1];
        int itest;

        if (alead == blead) {
            itest = compare_same(a, b, lng-1);    // Sign of a - b
        } else {
            itest = (alead < blead ? -1 : +1);
        }

        if (itest < 0) {   // a < b, set c = a - b + modulus
            if (blead >= mlead && OK) {
                OK = validate_modular_data(b, modulus, lng,
                                           "sub_mod arg 2", PBIGCTX_PASS);
            }
            carry = add_sub_same(a, modulus, b, c, lng);
        } else {          // b <= a, set c = a - b
            if (alead >= mlead && OK) {
                OK = validate_modular_data(a, modulus, lng,
                                           "sub_mod arg 1", PBIGCTX_PASS);
            }
            carry = -(sdigit_t)sub_same(a, b, c, lng);     // c = a - b
        }
        if (!OK) {
        } else if (carry != 0) {
            OK = FALSE;
            SetMpErrno_clue(MP_ERRNO_INTERNAL_ERROR, "sub_mod", PBIGCTX_PASS);
        } else {
#if PRINT_ERROR_MESSAGES
            OK = OK && validate_modular_data(c, modulus, lng,
                                             "sub_mod output", PBIGCTX_PASS);
#endif
        }
    }
    return OK;
} // end sub_mod
/****************************************************************************/
digit_t WINAPI sub_same
        (digit_tc a[],       // IN
         digit_tc b[],       // IN
         digit_t  c[],       // OUT
         DWORDREGC   lng)    // IN
/*
        c := a - b, where all operands have length lng.

        Function value is 1 if there is a borrow out of the
        left of a.  Otherwise function value is zero.
*/
{
    digit_t borrow = 0;
    DWORDREG i;

    for (i = 0; i != lng; i++) {
        digit_tc ai = a[i];
        digit_tc bi = b[i];
        digit_tc sum = ai - bi - borrow;

        c[i] = sum;
        borrow = ai ^ ((ai ^ bi) | (ai ^ sum));  // MAJORITY(~ai, bi, sum)
        borrow >>= (RADIX_BITS - 1);
    } // for i
    return borrow;
}  /* sub_same */
/****************************************************************************/
BOOL WINAPI validate_modular_data1
        (digit_tc   data[],          // IN
         digit_tc   modulus[],       // IN
         DWORDREGC  lng,             // IN
         const char *hint,           // IN
         PBIGCTX_ARG)
/*
      Issue error if data >= modulus.
      Called by validate_modular_data macro.
*/
{
    BOOL OK = TRUE;
    if (compare_same(data, modulus, lng) >= 0) {
        OK = FALSE;
        SetMpErrno_clue(MP_ERRNO_MODULAR_TOO_BIG, hint, PBIGCTX_PASS);
#if PRINT_ERROR_MESSAGES
        if (mp_errfil != NULL) {
            DWORDREG j;
            for (j = 0; j != lng; j++) {
                digit_out_buf_t buf1, buf2;

                fprintf(mp_errfil, "data[%ld] = %s, modulus[%ld] = %s\n",
                        (long)j, digit_out_hex(data[j], buf1, PBIGCTX_PASS),
                        (long)j, digit_out_hex(modulus[j], buf2, PBIGCTX_PASS));
            } // for j
            fflush(mp_errfil);
        }
#endif
    }
    return OK;
} // validate_modular_data1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\multlow.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
      File multiply_low.c.    Version 10 December 2000
*/      
#include "bignum.h"

#if COMPILER == COMPILER_VC && USEASM
    #pragma warning(disable : 4100)      /* Unreferenced formal parameter */
#endif

/****************************************************************************/
Naked86 void WINAPI multiply_low(digit_tc  a[],
                                    digit_tc  b[],
                                    digit_t   c[],
                                    DWORDREGC lng,
                                    PBIGCTX_ARG)
/*
        This routine multiplies two integers a and b of length lng,
        returning the low half of the product in c.  That is,
        c == a*b (mod RADIX^lng).  The top of c is unchanged.

        If lng = 2n, then this code uses n^2 + 2n multiplications,
        whereas a full Karatsuba multiplication uses about n^1.58.
        This code uses fewer multiplications for lng <= 20.
        This routine has less overhead than the standard Karatsuba
        multiplication (which gets the full product)

                2n      n^2 + 2n         Karatsuba

                 2          3                3
                 4          8                9
                 6         15               18
                 8         24               27
                10         35
                12         48               54
                14         63
                16         80               81
                24        168              162
                32        288              243

        We rewrite (assuming lng = 5)

                (a0 + a1*R + a2*R^2 + a3*R^3 + a4*R^4)
              * (b0 + b1*R + b2*R^2 + b3*R^3 + b4*R^4)
        as
                  (a0*b0 + a1*b1*R + a2*b2*R^2 + a3*b3*R^3 + a4*b4*R^4)
                * (1 + R + R^2 + R^3 + R^4)
              - R*(a1 - a0)*(b1 - b0)
              - R^2*(a2 - a0)*(b2 - b0)
              - R^3*[(a3 - a0)*(b3 - b0) + (a2 - a1)*(b2 - b1)]
              - R^4*[(a4 - a0)*(b4 - b0) + (a3 - a1)*(b3 - b1)]
              - (multiple of R^5)

        The products (ai - aj)*(bi - bj) can be positive or negative.
        We accumulate positive and negative terms in separate arrays.
        Specifically, the even subscripts in the ctemp array
        (i.e., ctemp[0], ctemp[2], ctemp[4], ...)
        contain the positive terms, while
        its odd subscripts (ctemp[1], ctemp[3], ctemp[5])
        contain the negated terms.  At the end,
        we subtract the negated terms from the positive terms
        and store the difference in the c array.

        To obtain

                  (a0*b0 + a1*b1*R + a2*b2*R^2 + a3*b3*R^3 + a4*b4*R^4)
                * (1 + R + R^2 + R^3 + R^4)

        modulo R^5, we note the second term is 1/(1-R) (mod R^5).
        Define absum[k] by

                  a0*b0 + ... + a[k]*b[k]*R^k
                = (c0 + c1*R + ... + c[k]*R^k)*(1 - R)
                  + absum[k]*R^(k+1).

        The recurrence for absum[k] is

                  absum[-1] = c[-1] = 0

                  absum[k]*R^(k+1) + c[k]*R^k*(1 - R)
                = absum[k-1]*R^k + a[k]*b[k]*R^k
        or
                  R*(absum[k] - c[k]) + c[k] = a[k]*b[k] + absum[k-1]

        Given single-words  absum[k-1] - c[k-1]  and  c[k-1],
        we can form the double-word

                a[k]*b[k]  +  (absum[k-1] - c[k-1])  +  c[k-1]

        From this, we extract  absum[k] - c[k]  and c[k].
*/
{
#if USEASM_IX86

    typedef struct {
             digit_t   *addrc;                   /* &c[0] */
             DWORD     lng;                      /* Saved value of lng */
             __int32   saved_regs[4];            /* ebp/ebx,edi/esi */
             digit_t   ctemp[2*MP_LONGEST+2];
             digit_t   acopy[MP_LONGEST | 1];    /* Copy of a array */
             digit_t   bcopy[MP_LONGEST | 1];    /* Copy of b array */
                   } mullow_locals_t;

                       /* Note -- copying the arrays to acopy
                          and bcopy simplifies indexing in inner
                          loops, since there are insufficient
                          registers to save &a[0] and &b[0].
                          The acopy array has an odd length,
                          to ensure bcopy - acopy is not
                          a multiple of 32 bytes.
                       */
  _asm {

                /*
                     Load formal parameters.
                     Modify register ebp last.
                */

    mov   ecx,[esp+4+8]             ; c
    sub   esp,TYPE mullow_locals_t  ; Allocate space for local struct
                                    ; AGI delay (esp)
    mov   [esp].saved_regs,ebp
    mov   [esp+4].saved_regs,ebx
    mov   [esp+8].saved_regs,edi
    mov   [esp+12].saved_regs,esi

    mov   ebp,[esp+TYPE mullow_locals_t+4+12] ; lng
    mov   esi,[esp+TYPE mullow_locals_t+4+0]  ; a
    mov   edi,[esp+TYPE mullow_locals_t+4+4]  ; b
    cmp   ebp,0
    je    mullow_exit               ; Exit if lng = 0

    mov   eax,[esi]                 ; eax = a[0]
    mov   ebx,[edi]                 ; ebx = b[0]
    mov   [esp].acopy,eax           ; Store acopy[0]
    mul   ebx                       ; edx:eax = dsum = a[0]*b[0]

    cmp   ebp,2                     ; Compare lng to 2

    jle    mullow_lng_le_2          ; Branch if lng <= 2
/*
                                Case lng > 2
*/
    mov  [esp].lng,ebp             ; Save ebp = lng
    mov  [esp].addrc,ecx           ; Save ecx = &c[0]
    mov  ebp,1                     ; ebp = i = 1
    mov  [esp].bcopy,ebx           ; Store bcopy[0] = ebx = b[0]
    mov  ebx,eax
    mov  ecx,edx                   ; ecx:ebx = dsum

mullow_loop1:
    mov  [esp+8*ebp-8].ctemp,ebx   ; Store ctemp[2*i - 2] = ebx = LOW(dsum)
    add  ebx,ecx                   ;
    mov  eax,[esi+4*ebp]           ; eax = a[i]
    mov  ecx,0

    mov  edx,[edi+4*ebp]           ; edx = b[i]
                                   ; Possible data cache conflict
    mov  [esp+8*ebp-4].ctemp,ecx   ; Store ctemp[2*i - 1] = 0

    adc  ecx,ecx                   ; ecx:ebx = HIGH(dsum) + LOW(dsum)
    mov  [esp+4*ebp].acopy,eax     ; Store acopy[i] = eax = a[i]
    mov  [esp+4*ebp].bcopy,edx     ; Store bcopy[i] = ebx = b[i]
    inc  ebp                       ; Advance i
    mul  edx                       ; edx:eax = a[i]*b[i]
    add  ebx,eax
    mov  eax,[esp].lng             ; eax = lng = loop bound
    adc  ecx,edx                   ; ecx:ebx = dsum
                                   ;         =   a[i]*b[i]
                                   ;           + HIGH(old dsum)
                                   ;           + LOW(old dsum)
    cmp  ebp,eax                   ; Compare (new i) to lng
    jne  mullow_loop1              ; Continue until i = lng
                                /*
                                        At this point

                                        eax = ebp = lng
                                        ecx:ebx = final dsum
                                */
    xor  esi,esi                   ; esi = 2*i = 0
    mov  [esp+8*ebp-8].ctemp,ebx   ; Store ctemp[2*lng-2] = LOW(dsum)

    mov  ebx,[esp].acopy           ; ebx = acopy[0]
    mov  ecx,[esp].bcopy           ; ecx = bcopy[0]
    lea  edi,[2*ebp-2]             ; edi = 2*((first j) + 1) = 2*(lng - 1)

    mov  [esp+8*ebp-4].ctemp,esi   ; Store ctemp[2*lng-1] = 0
    mov  [esp+8*ebp].ctemp,esi     ;       ctemp[2*lng  ] = 0
    mov  [esp+8*ebp+4].ctemp,esi   ;       ctemp[2*lng+1] = 0

mullow_loopi:
                                /*
                                        Before branching here, set

                                            ebp = lng
                                            ebx = acopy[i]
                                            ecx = bcopy[i]
                                            esi = 2*i
                                            edi = 2*(j+1) = 2*(lng - i - 1)
                                */
    mov  eax,[esp+2*edi].acopy         ; eax = acopy[j+1]
    mov  edx,[esp+2*edi].bcopy         ; edx = bcopy[j+1]
    sub  eax,ebx                       ; eax = adif = acopy[j+1] - acopy[i]
    sub  edx,ecx                       ; edx = bdif = bcopy[j+1] - bcopy[i]

    imul eax,edx                       ; eax = LOW(adif*bdif)

    mov  edx,[esp+8*ebp-4].ctemp       ; edx = ctemp[2*lng-1]
    add  esi,2                         ; Advance 2*i by 2

    add  edx,eax                       ; edx = LOW(adif*bdif + ctemp[2*lng-1])
                                       ; TBD -- poor Pentium P5 pairing here
    mov  [esp+8*ebp-4].ctemp,edx       ; Store new ctemp[2*lng-1]

mullow_loopj:
/*
                        Before branching here, set

                                          ebx = acopy[i]
                                          ecx = bcopy[i]
                                          edi = 2*j + 2
                                          esi = 2*i + 2
*/
    mov  eax,[esp+2*edi-4].acopy        ; eax = acopy[j]
    mov  edx,[esp+2*edi-4].bcopy        ; edx = bcopy[j]
    lea  ebp,[edi+esi-3]                ; ebp = 2*i + 2*j + 1
    sub  eax,ebx                        ; eax = adif = acopy[j] - acopy[i]
    sbb  ebx,ebx                        ; ebx = asgn
    sub  edx,ecx                        ; edx = bdif = bcopy[j] - bcopy[i]
    sbb  ecx,ecx                        ; ecx = bsgn

    add  eax,ebx                        ; eax = adif + asgn
    xor  eax,ebx                        ; eax = | adif |
    xor  ebx,ecx                        ; ebx = absgn = asgn^bsgn

    add  edx,ecx                        ; edx = bdif + bsgn
    add  ebp,ebx                        ; ebp = csub = absgn + 2*i + 2*j + 1
    xor  edx,ecx                        ; edx = | bdif |

    mul  edx                            ; edx:eax = |adif|*|bdif|

    mov  ecx,[esp+4*ebp].ctemp          ; ecx = ctemp[csub]
    mov  ebx,[esp+4*ebp+8].ctemp        ; ebx = ctemp[csub+2]
    add  ecx,eax                        ; ctemp[csub] += eax

    lea  edi,[edi-2]                    ; Decrement 2*j + 2 by 2
    mov  [esp+4*ebp].ctemp,ecx          ; Update ctemp[csub]

mullow_carryprop:
    lea  ebp,[ebp+2]                    ; Advance csub by 2
                                        ; (Note -- this pairs with mov
                                        ;  on first iteration of loop.
                                        ;  Loop executes about 10/9 times)

    adc  ebx,edx                        ; ctemp[(old csub) + 2] += edx + CF
    mov  edx,0                          ; Clear edx for future iterations
    mov  [esp+4*ebp].ctemp,ebx          ; Update ctemp[(old csub) + 2]
    mov  ebx,[esp+4*ebp+8].ctemp        ; ebx = ctemp[(new csub) + 2]
    jc   mullow_carryprop               ; If CF <> 0, continue

    cmp  esi,edi                        ; Compare 2*i + 2 to 2*(new j) + 2
    mov  ebx,[esp+2*esi-4].acopy        ; ebx = acopy[i]
    mov  ecx,[esp+2*esi-4].bcopy        ; ecx = bcopy[i]
    jne  mullow_loopj
/*
                                At this point

                                        esi = edi = 2*i + 2 = 2*(new i)
*/
    mov  ebp,[esp].lng               ; ebp = lng
    xor  edi,-2                      ; edi = -2 - (2*i + 2) = -4 - 2*i

                                     ; (both operands are even)

    mov  ebx,[esp+2*esi].acopy       ; ebx = acopy[new i]
    mov  ecx,[esp+2*esi].bcopy       ; ecx = bcopy[new i]

    lea  edx,[esi+2]                 ; edx = 2*(new i) + 2
    lea  edi,[edi+2*ebp]             ; edi = 2*lng - 2*i - 4
                                     ;     = 2*(lng - 1 - (new i))
    cmp  edx,edi                     ; Compare 2*(new i) + 2
                                     ;      to 2*(lng - 1 - (new i))
    jl   mullow_loopi              ; Continue if (new i) + 1 < lng - 1 - (new i)

    shr  ebp,1                       ; ebp = FLOOR(lng/2); set CF
    lea  esi,[esp].ctemp             ; esi = &ctemp[0]
    mov  edi,[esp].addrc             ; edi = &c[0]
    jnc  mullow_final_even           ; Branch if lng is even



    mov  edx,[esi]                  ; edx = ctemp[0]
    mov  ecx,[esi+4]                ; ecx = ctemp[1]
    sub  edx,ecx                    ; edx = ctemp[0] - ctemp[1]

mullow_final_odd_sub:
    mov  ebx,[esi+8]                ; ebx = ctemp[2*i]
    mov  eax,[esi+12]               ; eax = ctemp[2*i+1]
    mov  [edi],edx                  ; Store c[i-1]
    lea  edi,[edi+8]                ; Advance &c[i-1] by 2 dwords
    mov  edx,[esi+16]               ; edx = ctemp[2*i+2]
    mov  ecx,[esi+20]               ; ecx = ctemp[2*i+3]
    sbb  ebx,eax                    ; ebx = ctemp[2*i] - ctemp[2*i+1] - CF
    lea  esi,[esi+16]               ; Advance &ctemp[2*i-2] by 4 dwords
    sbb  edx,ecx                    ; edx = ctemp[2*i+2] - ctemp[2*i+3] - CF
    dec  ebp                        ; Decrement loop counter
    mov  [edi-4],ebx                ; Store c[i]
    jnz  mullow_final_odd_sub

    mov  [edi],edx                  ; Store c[lng-1]
    jz   mullow_exit                ; Exit


mullow_lng_le_2:                    ; Come here is lng <= 2
    mov   [ecx],eax                 ; Store c[0] = LOW(dsum)
    jne   mullow_exit               ; Exit if lng = 1

                                /*
                                        Case lng = 2
                                */

    mov   eax,[esi+4]               ; eax = a[1]
    mov   esi,[esi]                 ; esi = a[0]

    imul  eax,ebx                   ; eax = LOW(a[1]*b[0])
    mov   ebx,[edi+4]               ; ebx = b[1]
    add   edx,eax                   ; edx = HIGH(dsum) + a[1]*b[0] mod RADIX

    imul  esi,ebx                   ; esi = LOW(a[0]*b[1])
    add   edx,esi
    mov   [ecx+4],edx               ; Store c[1]
    jmp   mullow_exit



mullow_final_even:
                                /*
                                      At this point:

                                          ebp = lng/2
                                          edi = @c[0]
                                          esi = @ctemp[0]
                                          ebx = acopy[lng/2 - 1]
                                          ecx = bcopy[lng/2 - 1]
                                */
    mov  eax,[esp+4*ebp].acopy       ; eax = acopy[lng/2]
    mov  edx,[esp+4*ebp].bcopy       ; edx = bcopy[lng/2]
    sub  eax,ebx                     ; eax = adif
    sub  edx,ecx                     ; edx = bdif
    mov  ebx,[esi]                   ; ebx = ctemp[0]
    mov  ecx,[esi+4]                 ; ecx = ctemp[1]

    imul eax,edx                     ; eax = LOW(adif*bdif)
    mov  edx,[esi+8]                 ; edx = ctemp[2]
    sub  ebx,ecx                     ; ebx = ctemp[0] - ctemp[1]
    mov  ecx,[esi+12]                ; ecx = ctemp[3]
    dec  ebp                         ; ebp = lng/2 - 1 = loop count
    sbb  edx,ecx                     ; edx = ctemp[3] - ctemp[2] - CF
    mov  [edi],ebx                   ; Store c[0] = ebx

mullow_final_even_sub:
    mov  ebx,[esi+16]                ; ebx = ctemp[2*i + 2]
    mov  ecx,[esi+20]                ; ecx = ctemp[2*i + 3]
    mov  [edi+4],edx                 ; Store c[i-1] = edx
    lea  edi,[edi+8]                 ; Advance &c[i-2] by 2 dwords
    sbb  ebx,ecx                     ; ebx = ctemp[2*i + 2] - ctemp[2*i + 3] - CF
    mov  edx,[esi+24]                ; ebx = ctemp[2*i + 4]
    mov  ecx,[esi+28]                ; ecx = ctemp[2*i + 5]
    lea  esi,[esi+16]                ; Advance &ctemp[2*i - 2] by 4 dwords
    sbb  edx,ecx                     ; edx = ctemp[2*i + 4] - ctemp[2*i + 5] - CF
    dec  ebp                         ; Decrement loop counter
    mov  [edi],ebx                   ; Store  c[i] = ebx
    jnz  mullow_final_even_sub

    sub  edx,eax                     ; Subtract LOW(adif*bdif)
    mov  [edi+4],edx                 ; Store c[lng-1]


mullow_exit:
    mov  ebp,[esp].saved_regs
    mov  ebx,[esp+4].saved_regs
    mov  edi,[esp+8].saved_regs
    mov  esi,[esp+12].saved_regs
    add  esp,TYPE mullow_locals_t    ; Restore esp
    ret 16
    } /* asm IX86 */
#else

    dblint_t dsum;

    if (lng == 0) return;

    dsum = DPRODUU(a[0], b[0]);
    if (lng > 2) {
        digit_t borrow;
        DWORDREG i, j;
        digit_t ctemp[2*MP_LONGEST + 2];

        for (i = 1; i != lng; i++) {
            ctemp[2*i-2] = LOW_DIGIT(dsum);
            ctemp[2*i-1] = 0;
            dsum = MULTIPLY_ADD2(a[i], b[i], HIGH_DIGIT(dsum), LOW_DIGIT(dsum));
        }
        ctemp[2*lng-2] = LOW_DIGIT(dsum);
        ctemp[2*lng-1] = 0;
        ctemp[2*lng  ] = 0;
        ctemp[2*lng+1] = 0;  /* So inner loop will terminate */
                             /* (i.e., carries will not propagate beyond here) */

        for (i = 0; 2*i < lng-2; i++) {
            digit_tc ai = a[i];
            digit_tc bi = b[i];

            ctemp[2*lng-1] += (a[lng-1-i] - ai)*(b[lng-1-i] - bi);

            for (j = lng-2-i; j != i; j--) {
                digit_t adif = a[j] - ai;
                digit_t bdif = b[j] - bi;

                digit_tc asgn = -(a[j] < ai);
                digit_tc bsgn = -(b[j] < bi);
                digit_t carry;
                DWORDREG csub;

                adif = (adif + asgn)^asgn;
                bdif = (bdif + bsgn)^bsgn;
                csub = 2*(i + j) + (DWORD)((asgn^bsgn) + 1);
                         /* even subscript if adding, odd if subtracting */
                dsum = MULTIPLY_ADD1(adif, bdif, ctemp[csub]);
                ctemp[csub] = LOW_DIGIT(dsum);
                dsum = DBLINT_SUM(ctemp[csub+2], HIGH_DIGIT(dsum) );
                ctemp[csub+2] = LOW_DIGIT(dsum);
                carry = HIGH_DIGIT(dsum);
                do {
                    ctemp[csub+4] += carry;
                    carry = (ctemp[csub+4] < carry);
                    csub += 2;
                } while (carry != 0);
            } /* for j */

        } /* for i */

        if (IS_EVEN(lng)) {
            DWORDREGC lnghalf = lng >> 1;
            ctemp[2*lng-1] +=   (a[lnghalf] - a[lnghalf-1])
                              * (b[lnghalf] - b[lnghalf-1]);
        }

        borrow = 0;
        for (i = 0; i < lng; i++) {
            digit_tc diff = ctemp[2*i] - ctemp[2*i+1];
            digit_tc new_borrow = (ctemp[2*i] < ctemp[2*i+1]);

            c[i] = diff - borrow;
            if (diff != 0) borrow = new_borrow;
        }
    } else if (lng == 2) {
        c[0] = LOW_DIGIT(dsum);
        c[1] = HIGH_DIGIT(dsum) + a[0]*b[1] + a[1]*b[0];  /* mod RADIX */
    } else if (lng == 1) {
        c[0] = LOW_DIGIT(dsum);
    } else {
#if PRINT_ERROR_MESSAGES
        if (mp_errfil != NULL) {
            fflush(stdout);
            fprintf(mp_errfil, "Unexpected length %ld in multiply_low.\n",
                      (long)lng);
            fflush(mp_errfil);
        }
#endif
// TBD -- Don't presently return error code to caller
        SetMpErrno_clue(MP_ERRNO_INVALID_DATA, "multiply_low", PBIGCTX_PASS);
    }
#endif  /* assembly */
} /* multiply low */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\mprand.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*      File mprand.h */

#ifndef _MPRAND_H
#define _MPRAND_H

#include "bignum.h"

#if (TARGET_OS != OS_ATTILA) && (TARGET_OS != OS_ANSI)
    #include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif


extern BOOL WINAPI random_bytes(BYTE*, const size_t, PBIGCTX_ARG);
         // Procedure to be supplied by application.
         // bigrand0.h and bigrand1.h have possible implementations.


//   The DSA routines let the user have multiple random number generators,
//   rather than be restricted to random_bytes().
//   The RNGINFO struct identifies this alternate generator,
//   which is passed to new_ random number routines.


typedef struct {
        void   *pInfo;      // Data for user function
#if 0
        void   *pFuncRNG;   // Typically a function pointer
#else
        void   (*pFuncRNG)(BYTE*, size_t, void*, PBIGCTX_ARG);
                            // Called with byte arrsy.
                            // array length, and
                            // pointer to pInfo herein

                            // Changed by petmon April, 2002
                            // to eliminate warnings
#endif

} RNGINFO;
#define RNGINFO_NULL ((RNGINFO*)0)
typedef const RNGINFO RNGINFOC;


#if !INLINING_SUPPORTED
// extern BOOL WINAPI new_random_bytes(BYTE*, const size_t, RNGINFO*);

extern BOOL WINAPI     random_digits(digit_t*, DWORDREGC, PBIGCTX_ARG);
extern BOOL WINAPI     random_dwords(DWORD*,   DWORDREGC, PBIGCTX_ARG);
extern BOOL WINAPI new_random_digits(digit_t*, DWORDREGC,
                                     RNGINFOC*, PBIGCTX_ARG);
extern BOOL WINAPI new_random_dwords(DWORD*,   DWORDREGC,
                                     RNGINFOC*, PBIGCTX_ARG);


#endif // INLINING_SUPPORTED

// Macros


#define random_digit_interval(d1, d2, dout, ctx) \
    new_random_digit_interval(d1, d2, dout, RNGINFO_NULL, ctx)
#define random_dword_interval(d1, d2, dout, ctx) \
    new_random_dword_interval(d1, d2, dout, RNGINFO_NULL, ctx)


#define random_mod(n, arr, lng, ctx) \
    new_random_mod(n, arr, lng, RNGINFO_NULL, ctx)

#define random_mod_nonzero(n, arr, lng, ctx) \
    new_random_mod_nonzero(n, arr, lng, RNGINFO_NULL, ctx)
                        /* Generate random value modulo another value */
                        /* new_random_mod_nonzero generates a nonzero value */

#define random_mod_inverse(n, arr, arrinv, ninverse, nrecip, lng, ctx) \
    new_random_mod_inverse(n, arr, arrinv, ninverse, \
                           nrecip, lng, RNGINFO_NULL, ctx)
                  // Generate random values and their multiplicative inverses



// Following are extern on all platforms

extern BOOL WINAPI new_random_bytes(BYTE*, const size_t,
                                    RNGINFOC*, PBIGCTX_ARG);

extern BOOL WINAPI new_random_digit_interval(digit_tc, digit_tc,
                                             digit_t*, RNGINFOC*, PBIGCTX_ARG);
extern BOOL WINAPI new_random_dword_interval(DWORDC, DWORDC, DWORD*,
                                             RNGINFOC*, PBIGCTX_ARG);
          /* Generate random digit_t or DWORD in specified closed interval. */

extern BOOL WINAPI new_random_mod        (MP_INPUT, MP_OUTPUT,
                                          DWORDREGC, RNGINFOC*, PBIGCTX_ARG);
extern BOOL WINAPI new_random_mod_nonzero(MP_INPUT, MP_OUTPUT,
                                          DWORDREGC, RNGINFOC*, PBIGCTX_ARG);
                        // Generate random value modulo another value.
                        // new_random_mod_nonzero generates a nonzero value.

extern BOOL WINAPI new_random_mod_inverse(MP_INPUT, MP_OUTPUT, MP_OUTPUT,
                        DWORDREGC, reciprocal_1_tc*, DWORDREGC,
                        RNGINFOC*, PBIGCTX_ARG);
                        /* Generate random values and
                           their multiplicative inverses. */

#if INLINING_SUPPORTED

// Next four are inline, rather than macros, so compiler can issue
// error when array argument has wrong pointer type.

INLINE BOOL WINAPI random_digits(digit_t array[],
                                      DWORDREGC lng,
                                      PBIGCTX_ARG)
{    /* Generate random multiple-precision number */
     /* It may have a leading zero. */
    return random_bytes((BYTE*)array,
                        (size_t)lng*SIZEOF(digit_t),
                        PBIGCTX_PASS);
} /* random digits */


INLINE BOOL WINAPI new_random_digits(digit_t array[],
                                     DWORDREGC lng,
                                     RNGINFOC* pRNGInfo,
                                     PBIGCTX_ARG)
{    /* Generate random multiple-precision number */
     /* It may have a leading zero. */
    return new_random_bytes((BYTE*)array,
                             (size_t)lng*SIZEOF(digit_t),
                             pRNGInfo, PBIGCTX_PASS);
} /* random digits */


INLINE BOOL WINAPI random_dwords(DWORD array[], DWORDREGC lng, PBIGCTX_ARG)
{    /* Generate random DWORDs */

    return random_bytes((BYTE*)array, (size_t)lng*SIZEOF(DWORD), PBIGCTX_PASS);
} /* random dwords */


INLINE BOOL WINAPI new_random_dwords(DWORD array[], DWORDREGC lng,
                                          RNGINFOC *pRNGInfo, PBIGCTX_ARG)
{    /* Generate random DWORDs */

    return new_random_bytes((BYTE*)array, (size_t)lng*SIZEOF(DWORD),
                            pRNGInfo, PBIGCTX_PASS);
} /* random dwords */


#endif  // INLINING_SUPPORTED

#ifdef __cplusplus
}
#endif

#endif   // _MPRAND_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_wmdrm_bignum_none_12.4.56.0_none_1c0b93d42b4b08bc
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wmdrm_bignum
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2.manifest
XP_MANIFEST_PATH=manifests\x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2.cat
XP_CATALOG_PATH=manifests\x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2.cat
XP_PAYLOAD_PATH=x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wmdrm_bignum,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=x86_wmdrm_bignum_none_12.4.56.0_none_1c0b93d42b4b08bc
ASSEMBLY_IDENTITY_XP_KEY_FORM=x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=wmdrm_bignum
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=x86
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2.manifest
XP_MANIFEST_PATH=manifests\x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2.cat
XP_CATALOG_PATH=manifests\x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2.cat
XP_PAYLOAD_PATH=x86_wmdrm_bignum_no-public-key_12.4.56.0_x-ww_e68f54d2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=wmdrm_bignum,processorArchitecture=x86,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\bignum\whererun.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef _WHERERUN_H
#define _WHERERUN_H 1

#include "bigenv.h"
#include <stdio.h>



#if TARGET_OS == OS_WCE || TARGET_OS == OS_ATTILA

static void where_running(const char *program_id)
{
    printf("%s running on %s\n", program_id, TARGET_NAME);
         // No machine name or time of day under Windows CE
    fflush(stdout);
} // where_running

#else
/*
    This program prints an informative line on
    standard output, describing the program
    being run plus the date and time.
    It is for testing purposes only.
*/
#include <windows.h>
#include <time.h>

static void WINAPI where_running(const char *program_id)
{
    char host_identification[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD lng_buffer = SIZEOF(host_identification);
    time_t tnow;


    host_identification[lng_buffer - 1] = 0;
    GetComputerName(host_identification, &lng_buffer);
    time(&tnow);

    printf("%s running on %s at %s",
            program_id, host_identification, ctime(&tnow));
    fflush(stdout);
} // where_running

#endif // TARGET_OS
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\blackbox.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmpkcrypto.h>
#include <drmcipher.h>
#include <drmsha1.h>
#include <drmmanager.h>
#include <oemimpl.h>


#define HASH_RESIDUAL_LEN 6
#define LEGACY_KID_B64ENC_LEN   24



DRM_VOID compile_time_asserts( DRM_VOID )
{    
    DRMCASSERT( SIZEOF( DRM_MANAGER_DECRYPT_CONTEXT ) == SIZEOF( DRM_CIPHER_CONTEXT ) );    
}

static DRM_RESULT _FindKeyPair(
    IN       DRM_BB_CONTEXT *pcontextBBX,
    IN const PUBKEY         *ppubkey,
       OUT   PRIVKEY        *pprivkey );

static DRM_RESULT _DecryptContentKey( 
    IN const DRM_BINDING_INFO *pBindingInfo,
    IN       DRM_BOOL          fVerifyChecksum, /* Should the checksum portions of the binding info structs be verified */
    IN       DRM_DWORD         dwChainLen,
    IN       DRM_BB_CONTEXT   *pcontextBBX,
    IN       DRM_DWORD         cbKeyBuff,      /* the size of the key buffer */
       OUT   DRM_BYTE         *pbKeyBuff,      /* the key buffer */
       OUT   DRM_DWORD        *pcbKey,         /* the size of the key */
       OUT   PRIVKEY          *f_pprivkey );   /* return the private key that was used to decrypt the content key */

static DRM_RESULT  VerifyChecksum( 
    IN const DRM_BYTE    *pbKey, 
    IN       DRM_DWORD    cbKey, 
    IN const DRM_BYTE    *pbChecksum,
    IN       SHA_CONTEXT *pshaVal);

static DRM_RESULT _GetDevicePrivkey( 
    IN OUT DRM_BB_CONTEXT *f_pcontextBBX,
       OUT PRIVKEY        *f_pDevPrivkey);


DRM_BYTE nBbVerConst[__CB_DECL(VERSION_LEN)] = { TWO_BYTES(2, 3), TWO_BYTES(0, 0)};

static DRM_RESULT DRM_API _TestDeviceKeyPair( 
    DRM_BB_CONTEXT *f_pcontextBBX  )
{
    DRM_RESULT          dr = DRM_SUCCESS;
    PRIVKEY             privkey;
    DRM_BYTE            *pbIn        = NULL;
    DRM_BYTE            *pbOut       = NULL;
    DRM_BYTE            *pbEncrypted = NULL;
    
    
    /* Some basic assumptions about the environment */
    DRMCASSERT( PK_ENC_PLAINTEXT_LEN  <= SIZEOF( f_pcontextBBX->CryptoContext.pubKey2 ) );
    DRMCASSERT( PK_ENC_CIPHERTEXT_LEN <= SIZEOF( f_pcontextBBX->CryptoContext.union_cert.cert    ) );

    ChkDR(_GetDevicePrivkey(f_pcontextBBX, &privkey));
    
    pbIn = ( DRM_BYTE * )&( f_pcontextBBX->CryptoContext.pubKey2 );
    MEMSET(pbIn, 'a', SIZEOF( PUBKEY ) );

    pbEncrypted = (DRM_BYTE *)&(f_pcontextBBX->CryptoContext.union_cert.cert);
    pbOut       = (DRM_BYTE *)&(f_pcontextBBX->CryptoContext.signature);


    ChkDR( DRM_PK_Encrypt( f_pcontextBBX->CryptoContext.rgbCryptoContext,
                          &f_pcontextBBX->cachedCertValues.pubkeyCurrent, 
                           pbIn,
                           pbEncrypted ) );

    ChkDR( DRM_PK_Decrypt( f_pcontextBBX->CryptoContext.rgbCryptoContext, 
                          &privkey,
                           pbEncrypted, 
                           pbOut ) );

    if (MEMCMP(pbIn, pbOut, PK_ENC_PLAINTEXT_LEN) !=0)
    {
        ChkDR ( DRM_E_KEY_MISMATCH );
    }

ErrorExit:
    ZEROMEM( &privkey, SIZEOF(privkey) );
    return dr;
}

DRM_RESULT DRM_API DRM_BBX_Initialize( 
    IN OUT DRM_BB_CONTEXT     *pcontextBBX )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( pcontextBBX != NULL );

#if DBG
    pcontextBBX->fInited = FALSE;
    ChkDR(_TestDeviceKeyPair(pcontextBBX));
#endif

    pcontextBBX->fInited = TRUE;

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_BBX_Shutdown( IN DRM_BB_CONTEXT *pcontextBBX )
{
    pcontextBBX->fInited = TRUE;
    return DRM_SUCCESS;
}

DRM_RESULT DRM_API DRM_BBX_GetClientId(
    OUT    CLIENTID       *pClientId,
    IN OUT DRM_BB_CONTEXT *pcontextBBX )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE rgbRandBuf[__CB_DECL(PK_ENC_PLAINTEXT_LEN)] = {0};    
    RC4_KEYSTRUCT *prc4KS;

    ChkArg( pClientId   != NULL 
         && pcontextBBX != NULL
         && pcontextBBX->fInited );

    MEMCPY( pClientId->version, CLIENT_ID_VER, VERSION_LEN );
    MEMCPY( &(pClientId->pk), &(pcontextBBX->cachedCertValues.m_BBCompatibilityCert), SIZEOF( PKCERT ) );
    
    ChkDR( OEM_GenRandomBytes( rgbRandBuf, SIZEOF( rgbRandBuf ) ) );
    ChkDR( DRM_PK_Encrypt( pcontextBBX->CryptoContext.rgbCryptoContext, 
                          &g_pubkeyLicenseServer, 
                           rgbRandBuf, 
                           pClientId->randNum ) );
    
    prc4KS = (RC4_KEYSTRUCT*)pcontextBBX->CryptoContext.rgbCryptoContext;
    /* Encrypt the other data with RC4 using the random number as the key     */
    DRM_RC4_KeySetup( prc4KS, DRMCIPHERKEYLEN,        rgbRandBuf );
    DRM_RC4_Cipher(   prc4KS, SIZEOF(pClientId->pk), (DRM_BYTE *)&(pClientId->pk) );    

ErrorExit:
    return dr;
}


/*  
    Test whether or not a key is valid and can be used to decrypt
    content.
*/
DRM_BOOL DRM_API DRM_BBX_CanBind( 
    IN const DRM_BINDING_INFO *rgBindingInfo,
    IN       DRM_DWORD         dwChainLength,
    IN       DRM_BB_CONTEXT   *pcontextBBX )
{
    DRM_BYTE  rgbKey [__CB_DECL(DRM_PK_BUFFER_MAX)];   /* 16 BYTES */
    DRM_DWORD cbKey = 0;

    return DRM_SUCCEEDED( _DecryptContentKey( rgBindingInfo,
                                              TRUE,
                                              dwChainLength, 
                                              pcontextBBX, 
                                       SIZEOF(rgbKey), 
                                              rgbKey, 
                                             &cbKey,
                                              NULL ) );
}

/*  Decrypt a content key and place it in the given key buffer. */
static DRM_RESULT _DecryptContentKey( 
    const DRM_BINDING_INFO  *pBindingInfo,
          DRM_BOOL           fVerifyChecksum, /* Should the checksum portions of the binding info structs be verified */
          DRM_DWORD          dwChainLen,
          DRM_BB_CONTEXT    *pcontextBBX,
          DRM_DWORD          cbKeyBuff,       /* the size of the key buffer */
          DRM_BYTE          *pbKeyBuff,       /* the key buffer */
          DRM_DWORD         *pcbKey,          /* the size of the key */
          PRIVKEY           *f_pprivkey )     /* return the private key that was used to decrypt the content key */
{
    DRM_RESULT dr = DRM_SUCCESS;
    PRIVKEY   privkey;
    DRM_BYTE  rgbDecContKey [__CB_DECL(PK_ENC_PLAINTEXT_LEN)];
    DRM_BYTE  bSize    = 0;

    ChkArg( pcbKey != NULL );

    *pcbKey = 0;    

    ChkArg( pcontextBBX  != NULL
         && pBindingInfo != NULL
         && pbKeyBuff    != NULL
         && dwChainLen    > 0
         && pcontextBBX->fInited );

    /* 
    **  Find the private key that corresponds to
    **  the public key used to encrypt the content key.
    **  The last value in the chain *must* be the key encrypted to the machine key.  It *must*
    **  be of type eMSDRM_PK or eMSDRM_SYM
    */
    if( pBindingInfo[dwChainLen-1].m_dwAlgorithm != eMSDRM_PK
     && pBindingInfo[dwChainLen-1].m_dwAlgorithm != eMSDRM_SYM )
    {
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
    }
       
    ChkDR( _FindKeyPair( pcontextBBX, &(pBindingInfo[dwChainLen-1].m_oPublKey), &privkey ) );

    if( pBindingInfo[0].m_dwAlgorithm == eMSDRM_SYM )
    {
        /* Even if this is a license chain, if the leaf license is symmetrically optimized
           we can directly decrypt it */
        dwChainLen = 1;
    }

    /*  Decrypt the content key with that private key. */
    if( pBindingInfo[dwChainLen-1].m_dwAlgorithm == eMSDRM_PK )
    {
        ChkDR( DRM_PK_Decrypt( pcontextBBX->CryptoContext.rgbCryptoContext, 
                              &privkey, 
                               pBindingInfo[dwChainLen-1].m_rgbContentKey, 
                               rgbDecContKey ) );
    }
    else
    {
        
        /*
        ** Also, just decrypt the entire buffer, even if we only want a small portion of it.
        ** We won't know how large the key is until we finish the call and can look at the
        ** first byte.
        */
        DRMCASSERT( SIZEOF( pBindingInfo[dwChainLen-1].m_rgbContentKey ) >= SIZEOF( rgbDecContKey ) );
        ChkDR( DRM_PK_SymmetricCrypt( (DRM_BYTE*)&privkey,
                                       SIZEOF( privkey ),
                                       SIZEOF( rgbDecContKey ),
                                       (DRM_BYTE*)pBindingInfo[dwChainLen-1].m_rgbContentKey,
                                       SIZEOF( rgbDecContKey ),
                                       rgbDecContKey) );
    }

    bSize = GET_BYTE( rgbDecContKey, 0 );
    DRM_BYT_MoveBytes( rgbDecContKey, 0, rgbDecContKey, 1, SIZEOF(rgbDecContKey)-1);
    
    if( fVerifyChecksum )
    {
        ChkDR( VerifyChecksum( rgbDecContKey, 
                               bSize, 
                               pBindingInfo[dwChainLen-1].m_rgbChecksum, 
                               (SHA_CONTEXT*)(pcontextBBX->CryptoContext.rgbCryptoContext) ) );
    }

    /*  Verify the key signature. */
    if( pBindingInfo[dwChainLen-1].m_dwAlgorithm == eMSDRM_PK
     && !DRM_PK_Verify( pcontextBBX->CryptoContext.rgbCryptoContext, 
                       &pBindingInfo[dwChainLen-1].m_oLsPublKey, 
                       rgbDecContKey, 
                       (DRM_DWORD) bSize, 
                       pBindingInfo[dwChainLen-1].m_rgbSignature ) )
    {
        ChkDR(DRM_E_INVALID_SIGNATURE);
    }
   
    for( dwChainLen--; dwChainLen > 0; dwChainLen-- )
    {                
        /* We are now in chained licenses enabling bits.  The algorithm *must* be eMSDRM_CK */
        if( pBindingInfo[dwChainLen-1].m_dwAlgorithm != eMSDRM_CK
         || bSize != DES_KEYSIZE )
        {
            ChkDR(DRM_E_UNSUPPORTEDALGORITHM);
        }

        /* Use the current content key we extracted as a DES key and decrypt the next section */
        DRM_DES_KeySetup( (DESTable*)(pcontextBBX->CryptoContext.rgbCryptoContext), rgbDecContKey );
        
        DRM_DES_Decrypt (pBindingInfo[dwChainLen-1].m_rgbContentKey, 
                         rgbDecContKey, /* output buffer */
                        (DESTable*)(pcontextBBX->CryptoContext.rgbCryptoContext) );
        DRM_DES_Decrypt((pBindingInfo[dwChainLen-1].m_rgbContentKey) + __CB_DECL(DES_BLOCKLEN), 
                        rgbDecContKey + __CB_DECL(DES_BLOCKLEN),
                        (DESTable*)(pcontextBBX->CryptoContext.rgbCryptoContext) );

        bSize = GET_BYTE( rgbDecContKey, 0 );
        DRM_BYT_MoveBytes( rgbDecContKey, 0, rgbDecContKey, 1, SIZEOF(rgbDecContKey)-1);
        if( fVerifyChecksum )
        {
            ChkDR( VerifyChecksum( rgbDecContKey, 
                                   bSize, 
                                   pBindingInfo[dwChainLen-1].m_rgbChecksum, 
                                   (SHA_CONTEXT*)(pcontextBBX->CryptoContext.rgbCryptoContext) ) );
        }

        /*  Verify the key signature. */
        if( !DRM_PK_Verify( pcontextBBX->CryptoContext.rgbCryptoContext, 
                           &pBindingInfo[dwChainLen-1].m_oLsPublKey, 
                           rgbDecContKey, 
                           (DRM_DWORD) bSize, 
                           pBindingInfo[dwChainLen-1].m_rgbSignature ) )
        {
            ChkDR(DRM_E_LIC_SIGNATURE_FAILURE);            
        }

   } /* end-for chainlen */
    
    *pcbKey = (DRM_DWORD) bSize;   

    if( cbKeyBuff < *pcbKey )
    {
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    /*  Everything passed.  Return the key. */

    MEMCPY(pbKeyBuff, rgbDecContKey, *pcbKey);
    if( f_pprivkey != NULL )
    {
        MEMCPY( f_pprivkey, &privkey, SIZEOF( privkey ) );
    }

    dr = DRM_SUCCESS;

ErrorExit:
    ZEROMEM(&privkey, SIZEOF( PRIVKEY ) );
    return( dr );
}

/*  Verify the checksum on a content key. */
static DRM_RESULT VerifyChecksum( 
    const DRM_BYTE    *pbKey, 
          DRM_DWORD    cbKey, 
    const DRM_BYTE     rgbChecksum [__CB_DECL(CHECKSUM_LENGTH)],
          SHA_CONTEXT *pshaVal)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE res[__CB_DECL(SHA_DIGEST_LEN + 1)];
    DRM_LONG lCount;

    if( pbKey == NULL  
     || cbKey == 0  
     || cbKey  > PK_ENC_PLAINTEXT_LEN - 1 )
    {
        dr = DRM_E_CH_BAD_KEY;
        goto ErrorExit;
    }

    /* Run SHA on key SHA_ITERATIONS times. */
    /* First copy key into res. */
    if ( cbKey > (SHA_DIGEST_LEN + 1))
    {
        cbKey = (SHA_DIGEST_LEN + 1); /* Make sure we don't exceed buffer capacity in res. */
    }

    ZEROMEM( res, SIZEOF(res) ); /* Init to 0. */

    MEMCPY(res, pbKey, cbKey);

    for ( lCount = 0; lCount < SHA_ITERATIONS; lCount++)
    {
        DRM_SHA_Init( pshaVal );
        DRM_SHA_Update( res, SHA_DIGEST_LEN+1,pshaVal );
        DRM_SHA_Finalize( pshaVal, res );
    }
    if (MEMCMP(res, rgbChecksum, CHECKSUM_LENGTH) != 0 )
    {
        dr =  DRM_E_CH_BAD_KEY;
        goto ErrorExit;
    }

ErrorExit:
    return dr;
}


/*  
    Decrypt a license that was encryted for privacy reasons (not 
    security reasons) while traveling on the net during license
    acquisition.
*/
DRM_BOOL DRM_API DRM_BBX_DecryptLicense(
    IN OUT DRM_BYTE       *pbEncryptedLicense,
    IN     DRM_DWORD       cbEncryptedLicense,
    OUT    DRM_BYTE       *pbLicense,
    IN     DRM_BB_CONTEXT *pcontextBBX )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    DRM_BYTE   rgbKey[__CB_DECL(PK_ENC_PLAINTEXT_LEN)];
    PRIVKEY    privkey;
    RC4_KEYSTRUCT *prc4KS = NULL;

    ChkArg( pcontextBBX        != NULL
         && cbEncryptedLicense >= PK_ENC_CIPHERTEXT_LEN 
         && pcontextBBX->fInited );

    /* use device privkey to decrypt the license blob */
    ChkDR(_GetDevicePrivkey(pcontextBBX, &privkey));
    ChkDR(DRM_PK_Decrypt(pcontextBBX->CryptoContext.rgbCryptoContext, 
                        &privkey, 
                         pbEncryptedLicense, 
                         rgbKey));

    if( GET_BYTE(rgbKey, 1) != PKSYMM_ALG_TYPE_RC4 )
    {
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
    }

    cbEncryptedLicense -= PK_ENC_CIPHERTEXT_LEN;

    if( pbLicense == NULL )
    {
        /* This means decrypt in place.  Caller must know that decrpyted content starts at pELicense + PK_ENC_CIPHERTEXT_LEN */
        pbLicense = pbEncryptedLicense + __CB_DECL(PK_ENC_CIPHERTEXT_LEN);
    }
    else
    {
        DRM_BYT_CopyBytes( pbLicense, 0, pbEncryptedLicense, PK_ENC_CIPHERTEXT_LEN, cbEncryptedLicense );
    }

    prc4KS = (RC4_KEYSTRUCT*)(pcontextBBX->CryptoContext.rgbCryptoContext);
    DRM_RC4_KeySetup(prc4KS, GET_BYTE(rgbKey, 0), rgbKey + __CB_DECL(2));
    DRM_RC4_Cipher  (prc4KS, cbEncryptedLicense, pbLicense );

ErrorExit:
    ZEROMEM(&privkey, SIZEOF(PRIVKEY));
    return (DRM_SUCCEEDED(dr) ? TRUE : FALSE);
}


/*  Used for computing the secure store password. */
DRM_RESULT DRM_API DRM_BBX_HashValue(
    IN  const DRM_BYTE       *pbValue,
    IN        DRM_DWORD       cbValue,
    OUT       DRM_BYTE        rgbHashValue [__CB_DECL(SHA_DIGEST_LEN)],
    IN        DRM_BB_CONTEXT *pcontextBBX )
{
    DRM_RESULT dr = DRM_SUCCESS;
    PRIVKEY    privkey;
    SHA_CONTEXT *pcontextSHA;

    ChkArg( pbValue      != NULL
         && cbValue       > 0 
         && rgbHashValue != NULL
         && pcontextBBX  != NULL
         && pcontextBBX->fInited );

    /* use device privkey */
    ChkDR(_GetDevicePrivkey(pcontextBBX, &privkey));

    pcontextSHA = (SHA_CONTEXT*)&(pcontextBBX->CryptoContext);
    DRM_SHA_Init( pcontextSHA );
    DRM_SHA_Update((DRM_BYTE*)&privkey, SIZEOF(PRIVKEY), pcontextSHA);    
    DRM_SHA_Finalize( pcontextSHA, rgbHashValue );

    /*  Now hash the given data (pValue). */
    DRM_SHA_Init( pcontextSHA );
    DRM_SHA_Update( rgbHashValue, HASH_RESIDUAL_LEN, pcontextSHA );
    DRM_SHA_Update( pbValue,      cbValue,           pcontextSHA );
    DRM_SHA_Finalize( pcontextSHA, rgbHashValue );

ErrorExit:
    ZEROMEM(&privkey, SIZEOF(PRIVKEY));
    return dr;
}


/*  Key set-up for cipher operations ( decryption or encryption ). */
DRM_RESULT DRM_API DRM_BBX_CipherKeySetup( 
    IN const DRM_BINDING_INFO   *rgBindingInfo,
    IN       DRM_DWORD           dwChainLength,
    OUT      DRM_CIPHER_CONTEXT *pCipherContext,
    IN       DRM_BB_CONTEXT     *pcontextBBX )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbKey = 0;
    DRM_BYTE  rgbKey [__CB_DECL(DRM_PK_BUFFER_MAX)];

    DRM_PROFILING_ENTER_SCOPE(L"DRM_BBX_CipherKeySetup", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    ChkArg( rgBindingInfo  != NULL 
         && pCipherContext != NULL
         && pcontextBBX    != NULL
         && pcontextBBX->fInited   );

    ChkDR( _DecryptContentKey( rgBindingInfo, TRUE, dwChainLength, pcontextBBX, SIZEOF(rgbKey), rgbKey, &cbKey, NULL ) );
    ChkDR( DRM_CPHR_Init( pCipherContext, cbKey, rgbKey ) );
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_BBX_CipherKeySetup", g_pwszLeavingFunction);
    return dr;
}

/******************************************************************************
** Function :   DRM_BBX_InitDecrypt
** Synopsis :   Initializes state for phased decryption
** Arguments :  f_pcontextCipher - Cipher context initialized with DRM_CPHR_Init
**              f_pbLast15    - Last 15 bytes of ciphertext
**              f_cbData      - # of bytes in ENTIRE ciphertext              
******************************************************************************/
DRM_RESULT DRM_API DRM_BBX_InitDecrypt( 
    IN     DRM_CIPHER_CONTEXT *f_pcontextCipher,
    IN     DRM_BYTE           *f_pbLast15,
    IN     DRM_DWORD           f_cbData )
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_cbData          > 0  
         && f_pbLast15       != NULL 
         && f_pcontextCipher != NULL );
    
    ChkDR( DRM_CPHR_InitDecrypt( f_pcontextCipher, f_pbLast15, f_cbData ) );
    
ErrorExit:
    return dr;
}

/******************************************************************************
** Function :   DRM_BBX_Decrypt
** Synopsis :   Decrypts part of the ciphertext. This function must be called 
**              after DRM_BBX_InitDecrypt has been successful
** Arguments :  f_pcontextCipher - Cipher context initialized with DRM_CPHR_Init,
**                                 followed by DRM_BBX_InitDecrypt
**              f_cbData  - # of bytes of data to be decrypted
**              f_pbData  - Pointer to encrypted buffer
** Notes :      IMPORTANT: Phased decrypt should be called on segments of 
**              encrypted data sequentially, i.e. if encrypted data is divided 
**              four segments, the order of decryption should be segment 1,
**              followed by 2, 3, 4.
******************************************************************************/
DRM_RESULT DRM_API DRM_BBX_Decrypt( 
    IN     DRM_DWORD           f_cbData,
    IN OUT DRM_BYTE           *f_pbData,
    IN     DRM_CIPHER_CONTEXT *f_pcontextCipher)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_cbData          > 0  
         && f_pbData         != NULL 
         && f_pcontextCipher != NULL );
    ChkDR( DRM_CPHR_Decrypt( f_pcontextCipher, f_cbData, f_pbData ) );
    
ErrorExit:
    return dr;
}

/*  Encrypt content. */
DRM_RESULT DRM_API DRM_BBX_Encrypt( 
    IN     DRM_DWORD           cbData,
    IN OUT DRM_BYTE           *pbData,
    IN     DRM_CIPHER_CONTEXT *pEncryptContext )
{
    DRM_RESULT dr = DRM_SUCCESS;


    ChkArg( cbData           > 0 
         && pbData          != NULL 
         && pEncryptContext != NULL );

    ChkDR( DRM_CPHR_Encrypt( pEncryptContext, cbData, pbData ) );
ErrorExit:
    return dr;
}

/*  
    Search the current and old keys for a private key
    corresponding to the given public key.
*/
static DRM_RESULT _FindKeyPair(
          DRM_BB_CONTEXT *pcontextBBX,
    const PUBKEY         *pPublKey,
          PRIVKEY        *pPrivKeyOut )
{
    DRM_RESULT dr = DRM_S_FALSE; 
    DRM_DWORD i=0;

    ChkArg( pPrivKeyOut != NULL );

    if (MEMCMP(pPublKey, &(pcontextBBX->cachedCertValues.pubkeyCurrent), SIZEOF( PUBKEY ) ) == 0 )
    {
        ChkDR(_GetDevicePrivkey(pcontextBBX, pPrivKeyOut));
    }
    else
    {
        /* A matching key pair wasn't found */
        dr = DRM_E_UNKNOWN_BINDING_KEY;
    }
ErrorExit:
    return dr;
}

static DRM_RESULT _GetDevicePrivkey( 
    IN OUT DRM_BB_CONTEXT *f_pcontextBBX,
       OUT PRIVKEY        *f_pDevPrivkey)
{
    DRM_RESULT dr = DRM_SUCCESS;
    PRIVKEY    GCPrivkey;

    ChkArg( f_pcontextBBX != NULL 
         && f_pDevPrivkey != NULL);

    ChkDR(OEM_GetGroupCertPrivateKey(&GCPrivkey));

    ChkDR( DRM_PK_SymmetricCrypt( (DRM_BYTE*)&GCPrivkey,
                                   SIZEOF( GCPrivkey ),
                                   SIZEOF(PRIVKEY),
                                   f_pcontextBBX->cachedCertValues.m_blobDevicePrivkey,
                                   SIZEOF(PRIVKEY),
                                   (DRM_BYTE *)f_pDevPrivkey ) );

ErrorExit:
    ZEROMEM((DRM_BYTE*)&GCPrivkey, SIZEOF(PRIVKEY));  /* trash the key in memory */
    return dr;    
}

/*  Decrypt a content key and place it in the given key buffer for legacy source. */
static DRM_RESULT Legacy_DecryptContentKey( 
    const DRM_BINDING_INFO *pBindingInfo,
    DRM_BYTE               *pbKID,
    DRM_DWORD               cbKID,
    DRM_BYTE               *pbSecretData,
    DRM_DWORD               cbSecretData,
    DRM_BB_CONTEXT         *pcontextBBX,
    DRM_DWORD               cbKeyBuff,  /* the size of the key buffer */
    DRM_BYTE               *pbKeyBuff,          /* the key buffer */
    DRM_DWORD              *pcbKey )    /* the size of the key */
{
    DRM_RESULT dr = DRM_SUCCESS;
    PRIVKEY    privkey;
    DRM_BYTE   rgbDecContKey [__CB_DECL(PK_ENC_PLAINTEXT_LEN)];
    DRM_DWORD  cbKey = 0;

    ChkArg( pbKID        != NULL && cbKID        == LEGACY_KID_B64ENC_LEN );
    ChkArg( pbSecretData != NULL && cbSecretData == LEGACY_KID_B64ENC_LEN );
    
    ChkArg( pcontextBBX  != NULL
        &&  pBindingInfo != NULL 
        &&  pbKeyBuff    != NULL
        &&  pcbKey       != NULL
        &&  pcontextBBX->fInited );

    *pcbKey = 0;    

    /* 
    **  Find the private key that corresponds to
    **  the public key used to encrypt the content key.
    **  The last value in the chain *must* be the key encrypted to the machine key.  It *must*
    **  be of type eMSDRM_PK or eMSDRM_SYM
    */
    if( pBindingInfo->m_dwAlgorithm != eMSDRM_PK
     && pBindingInfo->m_dwAlgorithm != eMSDRM_SYM )
    {
        ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
    }
       
    ChkDR( _FindKeyPair( pcontextBBX, &pBindingInfo->m_oPublKey, &privkey ) );

    /*  Decrypt the content key with that private key. */
    if( pBindingInfo->m_dwAlgorithm == eMSDRM_PK )
    {
        ChkDR( DRM_PK_Decrypt( pcontextBBX->CryptoContext.rgbCryptoContext, 
                              &privkey, 
                               pBindingInfo->m_rgbContentKey, 
                               rgbDecContKey ) );
    }
    else
    {
        
        /*
        ** Also, just decrypt the entire buffer, even if we only want a small portion of it.
        ** We won't know how large the key is until we finish the call and can look at the
        ** first byte.
        */
        DRMCASSERT( SIZEOF( pBindingInfo->m_rgbContentKey ) >= SIZEOF( rgbDecContKey ) );
        ChkDR( DRM_PK_SymmetricCrypt( (DRM_BYTE*)&privkey,
                                       SIZEOF( privkey ),
                                       SIZEOF( rgbDecContKey ),
                                       (DRM_BYTE*)pBindingInfo->m_rgbContentKey,
                                       SIZEOF( rgbDecContKey ),
                                       rgbDecContKey) );
    }

    cbKey = GET_BYTE( rgbDecContKey, 0 );
    DRM_BYT_MoveBytes( rgbDecContKey, 0, rgbDecContKey, 1, SIZEOF(rgbDecContKey)-1);
    

    if( cbKeyBuff < cbKey )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /*  Verify the key signature. */
    if( pBindingInfo->m_dwAlgorithm == eMSDRM_PK
     && !DRM_PK_Verify( pcontextBBX->CryptoContext.rgbCryptoContext, 
                       &pBindingInfo->m_oLsPublKey, 
                        rgbDecContKey,
                       *pcbKey, 
                        pBindingInfo->m_rgbSignature ) )
    {
        ChkDR( DRM_E_LIC_SIGNATURE_FAILURE );
    }

    /*  Everything passed.  Return the key. */
    *pcbKey = cbKey;
    MEMCPY( pbKeyBuff, rgbDecContKey, *pcbKey );
    dr = DRM_SUCCESS;

ErrorExit:
    ZEROMEM( &privkey, SIZEOF( PRIVKEY ) );
    return( dr );
}



/*  Key set-up for cipher operations ( decryption or encryption ). for v1 */
DRM_RESULT DRM_API DRM_BBX_LegacyCipherKeySetup( 
    IN  DRM_BINDING_INFO   *pBindInfo, 
    IN  DRM_BYTE           *pbKID,
    IN  DRM_DWORD           cbKID,
    IN  DRM_BYTE           *pbSecretData,
    IN  DRM_DWORD           cbSecretData,
    OUT DRM_CIPHER_CONTEXT *pCipherContext, 
    IN  DRM_BB_CONTEXT     *pcontextBBX )
{
    DRM_RESULT         dr = DRM_SUCCESS;
    DRM_DWORD          cbKey = 0;
    DRM_BYTE           rgbKey           [__CB_DECL(DRM_PK_BUFFER_MAX)];
    DRM_BYTE           rgbDecSecretData [__CB_DECL(LEGACY_KID_B64ENC_LEN)];    
    DRM_BYTE           rgbLast15[__CB_DECL(DRM_CPHR_CB_FOR_INITDECRYPT)];

    DRM_PROFILING_ENTER_SCOPE(L"DRM_BBX_LegacyCipherKeySetup", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
    
    ChkArg( pbKID        != NULL && cbKID        == LEGACY_KID_B64ENC_LEN );
    ChkArg( pbSecretData != NULL && cbSecretData == LEGACY_KID_B64ENC_LEN );
    ChkArg( pCipherContext != NULL
         && pcontextBBX    != NULL
         && pcontextBBX->fInited );
    
    ChkDR( Legacy_DecryptContentKey( pBindInfo, 
                                     pbKID, 
                                     cbKID, 
                                     pbSecretData, 
                                     cbSecretData,
                                     pcontextBBX, 
                                     SIZEOF(rgbKey), 
                                     rgbKey, 
                                    &cbKey ) );

    ChkDR( DRM_CPHR_Init( pCipherContext, cbKey, rgbKey ) );    

    /* Verify the secret data: 
    ** The secret is the encrypted blob of the base64 encoded KID with the content key
    */
    MEMCPY(rgbDecSecretData, pbSecretData, LEGACY_KID_B64ENC_LEN);
    DRM_BYT_CopyBytes( rgbLast15,
                       0,
                       rgbDecSecretData,
                       LEGACY_KID_B64ENC_LEN - DRM_CPHR_CB_FOR_INITDECRYPT,
                       DRM_CPHR_CB_FOR_INITDECRYPT );

    ChkDR( DRM_CPHR_InitDecrypt( pCipherContext,
                                 rgbLast15,
                                 LEGACY_KID_B64ENC_LEN ) );
    
    ChkDR(DRM_CPHR_Decrypt(pCipherContext, LEGACY_KID_B64ENC_LEN, rgbDecSecretData));
    if (MEMCMP(pbKID, rgbDecSecretData, LEGACY_KID_B64ENC_LEN) != 0 )
    {
        ChkDR(DRM_E_CH_BAD_KEY);
    }
    
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_BBX_LegacyCipherKeySetup", g_pwszLeavingFunction);
    return dr;
}

/******************************************************************************
** Function :   DRM_BBX_SignData
** Synopsis :   Sign data with the machine private key 
** Arguments :  f_pcontextBBX       - Blackbox context
**              f_pbData            - Data to be signed
**              f_cbData            - Size of data to be signed
**              f_rgbSignature      - Signature
******************************************************************************/
DRM_RESULT DRM_API DRM_BBX_SignData(
    IN       DRM_BB_CONTEXT *f_pcontextBBX,
    IN const DRM_BYTE       *f_pbData,
    IN       DRM_DWORD       f_cbData,
    IN       DRM_DWORD       f_ePrivKeyType,
       OUT   DRM_BYTE        f_rgbSignature[__CB_DECL(PK_ENC_SIGNATURE_LEN)])
{
    PRIVKEY     privkey;
    DRM_RESULT  dr = DRM_SUCCESS;
    
    ChkArg( f_pcontextBBX  != NULL 
         && f_ePrivKeyType == eBBX_PRIVKEY_MACHINE
         && f_pcontextBBX->fInited );
    
    ChkDR( _GetDevicePrivkey(f_pcontextBBX, &privkey) );

    ChkDR( DRM_PK_Sign( f_pcontextBBX->CryptoContext.rgbCryptoContext, 
                        &privkey, 
                         f_pbData,
                         f_cbData,
                         f_rgbSignature) ); 
        
ErrorExit:
    ZEROMEM(&privkey, SIZEOF(PRIVKEY));
    return dr;
}

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS

/*********************************************************************
**
**  Function:  DRM_BBX_SymmetricSign
**
**  Synopsis:  Creates a symmetric signature (that only the current blackbox can verify) over the data provided 
**             by the caller
**
**  Arguments:  
**     [f_pcontextBBX] -- Pointer to an initialized blackbox context
**     [f_pbData]      -- Pointer to the data to sign
**     [f_cbData]      -- Length of f_pbData in DRM_BYTEs
**     [f_rgbSymSig]   -- Buffer to place the resultant 'symmetric signature'
**
*********************************************************************/

DRM_RESULT DRM_API DRM_BBX_SymmetricSign(
    IN       DRM_BB_CONTEXT *f_pcontextBBX,
    IN const DRM_BYTE       *f_pbData,
    IN       DRM_DWORD       f_cbData,
       OUT   DRM_BYTE        f_rgbSymSig[__CB_DECL( SHA_DIGEST_LEN )] )
{
    PRIVKEY     privkey;
    DRM_RESULT  dr = DRM_SUCCESS;
    
    ChkArg( f_pcontextBBX  != NULL 
         && f_pbData       != NULL
         && f_cbData       != 0
         && f_pcontextBBX->fInited );
    
    ChkDR( _GetDevicePrivkey(f_pcontextBBX, &privkey) );

    ChkDR( DRM_PK_SymmetricSign( (DRM_BYTE*)&privkey, 
                                  SIZEOF( privkey ),
                                  f_pbData,
                                  f_cbData,
                                  f_rgbSymSig) );         
ErrorExit:
    ZEROMEM(&privkey, SIZEOF(PRIVKEY));
    return dr;
}

/*********************************************************************
**
**  Function:  DRM_BBX_SymmetricVerify
**
**  Synopsis:  Verifies a symmetric signtaure that was created by a call to DRM_BBX_SymmetricSign
**
**  Arguments:  
**     [f_pcontextBBX] -- Pointer to an initialized blackbox context
**     [f_pbData]      -- Pointer to the data to sign
**     [f_cbData]      -- Length of f_pbData in DRM_BYTEs
**     [f_pslk]        -- Optional.  If this parameter is provided the caller is asking to verify
**                        the signature with a BBX protected SLK key.
**     [f_rgbSymSig]   -- Buffer containing the signtature to compare against.
**
*********************************************************************/

DRM_RESULT DRM_API DRM_BBX_SymmetricVerify(
    IN       DRM_BB_CONTEXT *f_pcontextBBX,
    IN const DRM_BYTE       *f_pbData,
    IN       DRM_DWORD       f_cbData,
    IN const DRM_SLK        *f_pslk,
    IN const DRM_BYTE        f_rgbSymSig[__CB_DECL( SHA_DIGEST_LEN )] )
{
    PRIVKEY     privkey;
    DRM_RESULT  dr = DRM_SUCCESS;
    
    ChkArg( f_pcontextBBX  != NULL 
         && f_pbData       != NULL
         && f_cbData       != 0
         && f_pcontextBBX->fInited );
    
    ChkDR( _GetDevicePrivkey(f_pcontextBBX, &privkey) );

    if( f_pslk == NULL )
    {
        ChkDR( DRM_PK_SymmetricVerify( (DRM_BYTE*)&privkey,
                                        SIZEOF( privkey ),
                                        f_pbData,
                                        f_cbData,
                                        f_rgbSymSig) );
    }
    else
    {
        DRM_SLK slkClear;

        ChkDR( DRM_PK_SymmetricCrypt( (DRM_BYTE*)&privkey,
                                      SIZEOF( privkey ),                                  
                                      SIZEOF( DRM_SLK ),   /* Only reencrypt the fist decrypt 8 bytes */
                          (DRM_BYTE*) f_pslk,
                               SIZEOF(slkClear),
                          (DRM_BYTE*)&slkClear ) );


        ChkDR( DRM_PK_SymmetricVerify( (DRM_BYTE*)&slkClear,
                                        SIZEOF( slkClear ),
                                        f_pbData,
                                        f_cbData,
                                        f_rgbSymSig) );
    }

ErrorExit:
    ZEROMEM(&privkey, SIZEOF(PRIVKEY));
    return dr;
}

/*********************************************************************
**
**  Function:  DRM_BBX_AsymmetricToSymmetricKey
**
**  Synopsis:  Takes an asymmetrically encrypted content key and symmetrically rebinds it to the current blackbox.
**
**  Arguments:  
**     [f_pcontextBBX]       -- Pointer to an initialized blackbox context
**     [f_pbindinfo]         -- Pointer to the binding info of the license that is being optmized
**     [f_pcbSymmKey]        -- Length of the resultant symmetric content key
**
**  Notes:  The content key will be reencrypted and returned in the same buffer.  The new length of the symmetric key
**          is returned in f_pcbSymmKey
**
*********************************************************************/

DRM_RESULT DRM_API DRM_BBX_AsymmetricToSymmetricKey(
    IN     DRM_BB_CONTEXT   *f_pcontextBBX,
    IN OUT DRM_BINDING_INFO *f_pbindinfo,
       OUT DRM_DWORD        *f_pcbSymmKey )
{
    DRM_RESULT dr = DRM_SUCCESS;
    PRIVKEY          privkey;    
    DRM_BYTE         rgbKey [__CB_DECL(DRM_PK_BUFFER_MAX)];   /* 16 BYTES */
    DRM_DWORD        cbKey = 0;

    ChkArg( f_pcontextBBX              != NULL 
         && f_pbindinfo                != NULL
         && f_pcbSymmKey               != NULL
         && f_pbindinfo->m_dwAlgorithm == eMSDRM_PK /* Must be an assymetric encryption */
         && f_pcontextBBX->fInited );

    ChkDR( _DecryptContentKey( f_pbindinfo, 
                               FALSE,
                               1, 
                               f_pcontextBBX, 
                        SIZEOF(rgbKey), 
                               rgbKey, 
                               f_pcbSymmKey,
                              &privkey ) );

    DRM_BYT_CopyBytes( f_pbindinfo->m_rgbContentKey, 1, rgbKey, 0, *f_pcbSymmKey );
    PUT_BYTE         ( f_pbindinfo->m_rgbContentKey, 0, (DRM_BYTE) *f_pcbSymmKey );

    *f_pcbSymmKey += 1;

    ChkDR( DRM_PK_SymmetricCrypt( (DRM_BYTE*)&privkey,
                                   SIZEOF( privkey ),
                                  *f_pcbSymmKey,
                                   f_pbindinfo->m_rgbContentKey,
                                   0,
                                   NULL) );

ErrorExit:
    ZEROMEM(&privkey, SIZEOF(PRIVKEY));
    return dr;
}


DRM_RESULT DRM_API DRM_BBX_RebindSymmetricKey(
    IN       DRM_BB_CONTEXT *f_pcontextBBX,
    IN const DRM_SLK        *f_pslk,
    IN OUT   DRM_BYTE       *f_pbSymmKey,
       OUT   DRM_DWORD       f_cbSymmKey )
{
    DRM_RESULT dr = DRM_SUCCESS;
    PRIVKEY    privkey;
    DRM_SLK    slkClear;

    ChkArg( f_pcontextBBX  != NULL 
         && f_pslk         != NULL
         && f_pbSymmKey    != NULL
         && f_cbSymmKey    != 0
         && f_pcontextBBX->fInited );

    
    ChkDR( _GetDevicePrivkey(f_pcontextBBX, &privkey) );

    /* First get the SLK key in the clear */
    ChkDR( DRM_PK_SymmetricCrypt( (DRM_BYTE*)&privkey,
                                   SIZEOF( privkey ),                                  
                                   SIZEOF( DRM_SLK ),   /* Only reencrypt the fist decrypt 8 bytes */
                       (DRM_BYTE*) f_pslk,
                            SIZEOF(slkClear),
                       (DRM_BYTE*)&slkClear ) );


    /* Use the clear SLK key to decrypt the content key */
    ChkDR( DRM_PK_SymmetricCrypt( (DRM_BYTE*)&slkClear,
                                  SIZEOF( slkClear ),
                                  f_cbSymmKey,
                                  f_pbSymmKey,
                                  NULL,
                                  NULL ) );

    /* Use the device private key to symmetrically encrypt the clear content key */
    ChkDR( DRM_PK_SymmetricCrypt( (DRM_BYTE*)&privkey,
                                  SIZEOF( privkey ),
                                  f_cbSymmKey,
                                  f_pbSymmKey,
                                  NULL,
                                  NULL ) );

ErrorExit:
    ZEROMEM(&privkey,  SIZEOF(PRIVKEY));
    ZEROMEM(&slkClear, SIZEOF(slkClear));
    return dr;
}

DRM_RESULT DRM_API DRM_BBX_RebindSLK(
    IN       DRM_BB_CONTEXT *f_pcontextBBX,
    IN const DRM_BYTE        f_rgbEncSLK[__CB_DECL(PK_ENC_CIPHERTEXT_LEN)],
       OUT   DRM_SLK        *f_pslk )
{
    DRM_RESULT dr = DRM_SUCCESS;
    PRIVKEY    privkey;
    DRM_BYTE   rgbslk[PK_ENC_PLAINTEXT_LEN];

    ChkArg( f_pcontextBBX  != NULL 
         && f_rgbEncSLK    != NULL
         && f_pslk         != NULL
         && f_pcontextBBX->fInited );

    DRMCASSERT( PK_ENC_PLAINTEXT_LEN/2 == SIZEOF( DRM_SLK ) );

    ChkDR( _GetDevicePrivkey(f_pcontextBBX, &privkey) );

    ChkDR( DRM_PK_Decrypt( f_pcontextBBX->CryptoContext.rgbCryptoContext, 
                          &privkey, 
                           f_rgbEncSLK, 
               (DRM_BYTE*) rgbslk ) );

    ChkDR( DRM_PK_SymmetricCrypt( (DRM_BYTE*)&privkey,
                                  SIZEOF( privkey ),                                  
                                  SIZEOF( DRM_SLK ),   /* Only reencrypt the fist decrypt 8 bytes */
                                  rgbslk,
                          SIZEOF(*f_pslk),
                       (DRM_BYTE*)f_pslk ) );

ErrorExit:
    ZEROMEM(&privkey, SIZEOF(PRIVKEY));
    return dr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\byteorder.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __BYTEORDER_H__
#define __BYTEORDER_H__

#include <drmtypes.h>

#define BITS_PER_STANDARD_BYTE 8

#define BYTES2WORD_LE( word, byte)          DRM_BYT_CopyBytes((DRM_BYTE*)&(word),0,(byte),0,SIZEOF(DRM_WORD));
#define WORD2BYTES_LE( byte, word )         DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(word),0,SIZEOF(DRM_WORD));
#define BYTES2DWORD_LE( dword, byte)        DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),0,SIZEOF(DRM_DWORD));
#define DWORD2BYTES_LE( byte, dword )       DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));
#define BYTES2QWORD_LE( qword, byte)        DRM_BYT_CopyBytes((DRM_BYTE*)&(qword),0,(byte),0,SIZEOF(DRM_UINT64));
#define QWORD2BYTES_LE( byte, qword )       DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(qword),0,SIZEOF(DRM_UINT64));

#define BYTES2WORD_BE( word, byte)          {DRM_BYT_CopyBytes((DRM_BYTE*)&(word),0,(byte),0,SIZEOF(DRM_WORD));FIX_ENDIAN_WORD((word));}
#define WORD2BYTES_BE( byte, word )         {FIX_ENDIAN_WORD((word));DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(word),0,SIZEOF(DRM_WORD));FIX_ENDIAN_WORD((word));}
#define BYTES2DWORD_BE( dword, byte)        {DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),0,SIZEOF(DRM_DWORD));FIX_ENDIAN_DWORD((dword));}
#define DWORD2BYTES_BE( byte, dword )       {FIX_ENDIAN_DWORD((dword));DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));FIX_ENDIAN_DWORD((dword));}
#define BYTES2QWORD_BE( qword, byte)        {DRM_BYT_CopyBytes((DRM_BYTE*)&(qword),0,(byte),0,SIZEOF(DRM_UINT64));FIX_ENDIAN_QWORD((qword));}
#define QWORD2BYTES_BE( byte, qword )       {FIX_ENDIAN_QWORD((qword));DRM_BYT_CopyBytes((byte),0,(DRM_BYTE*)&(qword),0,SIZEOF(DRM_UINT64));FIX_ENDIAN_QWORD((qword));}

#define COPY_WORD(byte, index, word)        DRM_BYT_CopyBytes((byte),(index),(DRM_BYTE*)&(word),0,SIZEOF(DRM_WORD));
#define COPY_DWORD(byte, index, dword)      DRM_BYT_CopyBytes((byte),(index),(DRM_BYTE*)&(dword),0,SIZEOF(DRM_DWORD));
#define COPY_QWORD(byte, index, qword)      DRM_BYT_CopyBytes((byte),(index),(DRM_BYTE*)&(qword),0,SIZEOF(DRM_UINT64));


#define REVERSE_BYTES_WORD(w)               DRM_BYT_ReverseBytes((DRM_BYTE*)&(w),SIZEOF(DRM_WORD))
#define REVERSE_BYTES_DWORD(dw)             DRM_BYT_ReverseBytes((DRM_BYTE*)&(dw),SIZEOF(DRM_DWORD))
#define REVERSE_BYTES_QWORD(qw)             DRM_BYT_ReverseBytes((DRM_BYTE*)&(qw),SIZEOF(DRM_UINT64))

#if TARGET_LITTLE_ENDIAN

#define BYTES_TO_WORD( word, byte )                 BYTES2WORD_LE( word, byte )
#define WORD_TO_BYTES( byte, word )                 WORD2BYTES_LE( byte, word )
#define BYTES_TO_QWORD( qword, byte )               BYTES2QWORD_LE( qword, byte )
#define QWORD_TO_BYTES( byte, qword )               QWORD2BYTES_LE( byte, qword )

#define WORD_TO_NETWORKBYTES(byte, index, word)     {DRM_WORD wTemp = (word);    REVERSE_BYTES_WORD(wTemp);   COPY_WORD((byte), (index), wTemp);}
#define DWORD_TO_NETWORKBYTES(byte, index, dword)   {DRM_DWORD dwTemp = (dword); REVERSE_BYTES_DWORD(dwTemp); COPY_DWORD((byte), (index), dwTemp);}
#define QWORD_TO_NETWORKBYTES(byte, index, qword)   {DRM_UINT64 qwTemp = (qword); REVERSE_BYTES_QWORD(qwTemp); COPY_QWORD((byte), (index), qwTemp);}
#define NETWORKBYTES_TO_WORD(word, byte, index)     {DRM_BYT_CopyBytes((DRM_BYTE*)&(word),0,(byte),(index),SIZEOF(DRM_WORD));  REVERSE_BYTES_WORD((word));}
#define NETWORKBYTES_TO_DWORD(dword, byte, index)   {DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),(index),SIZEOF(DRM_DWORD)); REVERSE_BYTES_DWORD((dword));}
#define NETWORKBYTES_TO_QWORD(qword, byte, index)   {DRM_BYT_CopyBytes((DRM_BYTE*)&(qword),0,(byte),(index),SIZEOF(DRM_UINT64)); REVERSE_BYTES_QWORD((qword));}

#else /* TARGET_LITTLE_ENDIAN */

#define BYTES_TO_WORD( word, byte )                 BYTES2WORD_BE( word, byte )
#define WORD_TO_BYTES( byte, word )                 WORD2BYTES_BE( byte, word )
#define BYTES_TO_QWORD( qword, byte )               BYTES2QWORD_BE( qword, byte )
#define QWORD_TO_BYTES( byte, qword )               QWORD2BYTES_BE( byte, qword )

#define WORD_TO_NETWORKBYTES(byte, index, word)     COPY_WORD(byte, index, word)
#define DWORD_TO_NETWORKBYTES(byte, index, dword)   COPY_DWORD(byte, index, dword)
#define QWORD_TO_NETWORKBYTES(byte, index, qword)   COPY_QWORD(byte, index, qword)
#define NETWORKBYTES_TO_WORD(word, byte, index)     {DRM_BYT_CopyBytes((DRM_BYTE*)&(word),0,(byte),(index),SIZEOF(DRM_WORD)); }
#define NETWORKBYTES_TO_DWORD(dword, byte, index)   {DRM_BYT_CopyBytes((DRM_BYTE*)&(dword),0,(byte),(index),SIZEOF(DRM_DWORD)); }
#define NETWORKBYTES_TO_QWORD(qword, byte, index)   {DRM_BYT_CopyBytes((DRM_BYTE*)&(qword),0,(byte),(index),SIZEOF(DRM_UINT64)); }

#endif /* TARGET_LITTLE_ENDIAN */

#endif /* __BYTEORDER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\cmdlnpars.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcrt.h>
#include <drmutilities.h>
#include <oemimpl.h>

#if DRM_USE_MAIN_WRAPPER

#ifndef _UNICODE
#error _UNICODE not defined with DRM_USE_MAIN_WRAPPER in cmdlnpars.c
#endif

DRM_INT DRM_API main( DRM_INT argc, DRM_CHAR **argv )
{
#if EMBEDDED_WITH_NO_PARAMS
    wmain( 0, NULL );
#else
    DRM_WCHAR **ppwargv = NULL;
    DRM_INT     i       = 0;
    DRM_BOOL    fOK     = TRUE;

    ppwargv = (DRM_WCHAR**)OEM_malloc( argc * SIZEOF( DRM_WCHAR* ) );

    if (ppwargv != NULL)
    {
        for (i = 0; i < argc; i++)
        {
            DRM_SUBSTRING dasstr = { 0 };
            DRM_STRING    dstr   = EMPTY_DRM_STRING;
            
            ppwargv [i] = (DRM_WCHAR *) OEM_malloc (strlen(argv [i]) * SIZEOF(DRM_WCHAR));
            
            if (ppwargv [i] != NULL)
            {
                dstr.pwszString =        ppwargv [i];
                dstr.cchString  = wcslen(ppwargv [i]);
                
                DRM_UTL_PromoteANSItoUNICODE(argv [i], &dasstr, &dstr);
            }
            else
            {
                fOK = FALSE;
            }
        }

        if (fOK)
        {
            wmain(argc, ppwargv);
        }
        
        for (i = 0; i < argc; i++)
        {
            if (ppwargv [i] != NULL)
            {
                free(ppwargv [i]);
            }
        }
        
        free(ppwargv);        
    }
#endif
    
    //leak
    return 0;
}

#endif

DRM_BOOL DRM_API DRM_CMD_ParseCmdLine(
    IN  const DRM_WCHAR  *pwszArgument,
    OUT DRM_WCHAR        *pwchOptionChar,
    OUT DRM_CONST_STRING *pwszParam,
    OUT DRM_CONST_STRING *pwszExtra)
{
    DRM_BOOL fRet = FALSE;
    DRM_DWORD i, 
              dwLen;

    if ( pwszArgument   == NULL || 
         pwchOptionChar == NULL )
    {
        goto ErrorExit;
    }

    dwLen = wcslen( pwszArgument );
    if ( !( pwszArgument[0] == g_wchMinus || pwszArgument[0] == g_wchForwardSlash ) || dwLen < 2 )
    {
        goto ErrorExit;
    }

    *pwchOptionChar = pwszArgument[1];
    if ( pwszParam == NULL )
    {
        fRet = TRUE;
        goto ErrorExit;
    }

    /* parse parameter */    
    pwszParam->cchString = 0;
    pwszParam->pwszString = NULL;
    if ( pwszExtra )
    {
        pwszExtra->cchString = 0;
        pwszExtra->pwszString = NULL;
    }

    if ( dwLen<4 || pwszArgument[2]!=g_wchColon )
    {
        fRet = TRUE;
        goto ErrorExit;
    }
    
    /* parse parameter */
    pwszParam->pwszString = &pwszArgument[3];
    for (i=3; pwszArgument[i]!= g_wchNull && pwszArgument[i]!=g_wchComma; i++)
    {
        ++pwszParam->cchString;
    }

    if ( i==dwLen || !pwszExtra )
    {
        fRet = TRUE;
        goto ErrorExit;
    }

    if ( pwszArgument[i+1] == g_wchNull )
    {
        goto ErrorExit;
    }

    /* parse the extra pameter */
    ++i;
    pwszExtra->pwszString = &pwszArgument[i];
    for (; pwszArgument[i]!=g_wchNull; i++)
    {
        ++pwszExtra->cchString;
    }

    fRet = TRUE;
    
ErrorExit:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\deskey.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmdes.h>
#include "sel.h"
#include "spb.h"


/* Compress bit flags into a WORD as there are 16 of them
   {0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0} = 0x3F7E */
static const DRM_WORD double_shift = 0x3F7E;

#define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
    (b)^=(t),\
    (a)^=((t)<<(n)))

#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
    (a)=(a)^(t)^(t>>(16-(n))))


/******************************************************************************/
DRM_VOID DRM_API DRM_DES_KeySetup(
    OUT       DESTable *pTable,
    IN  const DRM_BYTE  rgbKey[__CB_DECL(DES_KEYSIZE)] )
{
    DRM_DWORD csel,
              dsel,
              t,
              s,
              i;
    
    DRM_DWORD *kp = (DRM_DWORD *)pTable;

    BYTES_TO_DWORD(csel, rgbKey);
    BYTES_TO_DWORD(dsel, rgbKey + __CB_DECL(SIZEOF(DRM_DWORD)) );

    PERM_OP (dsel,csel,t,4,0x0f0f0f0f);
    dsel = dsel & 0xFFFFFFFF;
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;
    HPERM_OP(csel,t,-2,0xcccc0000);
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;
    HPERM_OP(dsel,t,-2,0xcccc0000);
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;
    PERM_OP (dsel,csel,t,1,0x55555555);
    dsel = dsel & 0xFFFFFFFF;
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;
    PERM_OP (csel,dsel,t,8,0x00ff00ff);
    dsel = dsel & 0xFFFFFFFF;
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;
    PERM_OP (dsel,csel,t,1,0x55555555);
    dsel = dsel & 0xFFFFFFFF;
    csel = csel & 0xFFFFFFFF;
    t    = t    & 0xFFFFFFFF;

    dsel=  (((dsel & 0x000000ff) << 16) | (dsel & 0x0000ff00)    |
            ((dsel & 0x00ff0000) >> 16) | ((csel & 0xf0000000)>>4));
    csel &= 0x0fffffff;

    for(i = 0; i < 16; i++)
    {
        DRM_DWORD temp;

        if(double_shift & (1 << (15 - i)))
        {
            csel = ((csel >> 2) | (csel << 26));
            dsel = ((dsel >> 2) | (dsel << 26));
        }
        else
        {
            csel = ((csel >> 1) | (csel << 27));
            dsel = ((dsel >> 1) | (dsel << 27));
        }

        csel &= 0x0fffffff;
        dsel &= 0x0fffffff;

        s =  _DRM_Sel[0][ (csel      )&0x3f                ];
        s |= _DRM_Sel[1][((csel >>  6)&0x03) | ((csel >>  7)&0x3c)];
        s |= _DRM_Sel[2][((csel >> 13)&0x0f) | ((csel >> 14)&0x30)];
        s |= _DRM_Sel[3][((csel >> 20)&0x01) | ((csel >> 21)&0x06)|((csel >> 22)&0x38)];
        t =  _DRM_Sel[4][ (dsel      )&0x3f                ];
        t |= _DRM_Sel[5][((dsel >>  7)&0x03) | ((dsel >>  8)&0x3c)];
        t |= _DRM_Sel[6][ (dsel >> 15)&0x3f                ];
        t |= _DRM_Sel[7][((dsel >> 21)&0x0f) | ((dsel >> 22)&0x30)];

        temp = ((t << 16) | (s & 0x0000ffff)) ;
        temp = temp & 0xFFFFFFFF;
        *(kp++) = ROTATE_LEFT(temp, 2) &0xFFFFFFFF;
        *kp  = *kp & 0xFFFFFFFF;

        temp = ((s >> 16) | (t & 0xffff0000));
        temp = temp & 0xFFFFFFFF;
        *(kp++) = ROTATE_LEFT(temp, 6) & 0xFFFFFFFF;
        *kp  = *kp & 0xFFFFFFFF;
    }
}


/******************************************************************************/

/* Primitive function F.
 * Input is r, subkey array in keys, output is XORed into l.
 * Each round consumes eight 6-bit subkeys, one for
 * each of the 8 S-boxes, 2 longs for each round.
 * Each long contains four 6-bit subkeys, each taking up a byte.
 * The first long contains, from high to low end, the subkeys for
 * S-boxes 1, 3, 5 & 7; the second contains the subkeys for S-boxes
 * 2, 4, 6 & 8 (using the origin-1 S-box numbering in the standard,
 * not the origin-0 numbering used elsewhere in this code)
 * See comments elsewhere about the pre-rotated values of r and Spbox.
 */


#define F(l,r,S) { \
    work = ((DRM_DWORD *)pTable)[S  ]; \
    zork = ((DRM_DWORD *)pTable)[S+1];  \
    work ^= r; \
    zork ^= r; \
    zork = ROTATE_RIGHT(zork, 4); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[0] + __CB_DECL((work      & 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[1] + __CB_DECL((zork      & 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[2] + __CB_DECL(((work>> 8)& 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[3] + __CB_DECL(((zork>> 8)& 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[4] + __CB_DECL(((work>>16)& 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[5] + __CB_DECL(((zork>>16)& 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[6] + __CB_DECL(((work>>24)& 0xfc))); \
    l ^= *(DRM_DWORD *)((DRM_BYTE*)_DRM_Spbox[7] + __CB_DECL(((zork>>24)& 0xfc))); }


/******************************************************************************/
/* Encrypt or decrypt a block of data in ECB mode */
DRM_VOID DRM_API DRM_DES_Cipher(
    const DRM_BYTE  rgbIn [__CB_DECL(DES_BLOCKLEN)],
          DRM_BYTE  rgbOut[__CB_DECL(DES_BLOCKLEN)],
          DESTable *pTable,
          DRM_INT   op)
{
    DRM_DWORD left, 
              work, 
              right, 
              zork;

    /* Read input block and place in left, right */
    BYTES_TO_DWORD( right, rgbIn);
    BYTES_TO_DWORD( left,  rgbIn + __CB_DECL(SIZEOF(DRM_DWORD)) );

    /* Hoey's clever initial permutation algorithm, from Outerbridge
     * (see Schneier p 478)
     *
     * The convention here is the same as Outerbridge: rotate each
     * register left by 1 bit, i.e., so that "left" contains permuted
     * input bits 2, 3, 4, ... 1 and "right" contains 33, 34, 35, ... 32
     * (using origin-1 numbering as in the FIPS). This allows us to avoid
     * one of the two rotates that would otherwise be required in each of
     * the 16 rounds.
     */

    right = ROTATE_LEFT(right, 4) & 0xFFFFFFFF;
    work = right;
    right ^= left;
    right &= 0xf0f0f0f0;
    work ^= right;
    left ^= right;

    left = ROTATE_LEFT(left, 20) & 0xFFFFFFFF;
    right = work;
    work ^= left;
    work &= 0xfff0000f;
    right ^= work;
    left ^= work;

    left = ROTATE_LEFT(left,14) &0xFFFFFFFF;
    work = right;
    right ^= left;
    right &= 0x33333333;
    work ^= right;
    left ^= right;

    work = ROTATE_LEFT(work, 22) & 0xFFFFFFFF;
    right = work;
    work ^= left;
    work &= 0x03fc03fc;
    right ^= work;
    left ^= work;

    right = ROTATE_LEFT(right, 9) & 0xFFFFFFFF;
    work = right;
    right ^= left;
    right &= 0xaaaaaaaa;
    work ^= right;
    left ^= right;

    left = ROTATE_LEFT(left, 1) & 0xFFFFFFFF;
    right = work;


    /* Now do the 16 rounds */
    if(op == DES_DECRYPT)
    {
        F(left, right, 30);
        F(right, left, 28);
        F(left, right, 26);
        F(right, left, 24);
        F(left, right, 22);
        F(right, left, 20);
        F(left, right, 18);
        F(right, left, 16);
        F(left, right, 14);
        F(right, left, 12);
        F(left, right, 10);
        F(right, left, 8);
        F(left, right, 6);
        F(right, left, 4);
        F(left, right, 2);
        F(right, left, 0);

    }
    else
    {
        F(left, right, 0);
        F(right, left, 2);
        F(left, right, 4);
        F(right, left, 6);
        F(left, right, 8);
        F(right, left, 10);
        F(left, right, 12);
        F(right, left, 14);
        F(left, right, 16);
        F(right, left, 18);
        F(left, right, 20);
        F(right, left, 22);
        F(left, right, 24);
        F(right, left, 26);
        F(left, right, 28);
        F(right, left, 30);
    }


    /* Inverse permutation, also from Hoey via Outerbridge and Schneier */

    right = ROTATE_RIGHT(right, 1)& 0xFFFFFFFF;
    work = left;
    work ^= right;
    work &= 0xaaaaaaaa;
    right ^= work;
    left ^= work;

    left = ROTATE_RIGHT(left, 9)& 0xFFFFFFFF;
    work = right;
    right ^= left;
    right &= 0x03fc03fc;
    work ^= right;
    left ^= right;

    left = ROTATE_RIGHT(left, 22)& 0xFFFFFFFF;
    right = work;
    work ^= left;
    work &= 0x33333333;
    right ^= work;
    left ^= work;

    right = ROTATE_RIGHT(right, 14) & 0xFFFFFFFF;
    work = right;
    right ^= left;
    right &= 0xfff0000f;
    work ^= right;
    left ^= right;

    work = ROTATE_RIGHT(work, 20) &0xFFFFFFFF;
    right = work;
    work ^= left;
    work &= 0xf0f0f0f0;
    right ^= work;
    left ^= work;

    left = ROTATE_RIGHT(left, 4)& 0xFFFFFFFF;

    /* Put the block back into the user's buffer with final swap */
    DWORD_TO_BYTES(rgbOut, left);
    DWORD_TO_BYTES(rgbOut+__CB_DECL(SIZEOF(DRM_DWORD)), right);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\devcert.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmxmlparser.h>
#include <drmdevcert.h>
#include <drmdes.h>
#include <drmpkcrypto.h>
#include <oemimpl.h>
#include <drmdevcert.h>

#define DRM_CLOCK_SECURE        2
#define DRM_CLOCK_ANTIROLLBACK  1

/******************************************************************************
** 
** Function :   _DCP_VerifyBasicValues
** Synopsis :   Verify the existence of certain required nodes, as well as 
**              validity of the data supplied
******************************************************************************/
static DRM_RESULT _DCP_VerifyBasicValues(
    IN const DRM_CONST_STRING   *f_pdstrDevCert,
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCrypto  )
{
    DRM_RESULT       dr             = DRM_SUCCESS;
    DRM_CONST_STRING dstrValue      = EMPTY_DRM_STRING;
    DRM_LONG         lValue         = 0;
    DRM_LONG         lMaxSecLevel   = 0;
   
    /*
    **  No need to check args in internal function - always checked
    */
    
    /*
    **  Get max SECURITYLEVEL from DAC
    */
    ChkDR( DRM_DCP_GetAttribute( f_pdstrDevCert, 
                                 DRM_DEVCERT_DACSECURITYLEVEL,
                                 NULL,
                                 &dstrValue ) );    
    ChkDR( wcsntol (dstrValue.pwszString, dstrValue.cchString, &lMaxSecLevel));
   
    /*
    **  Get GC security level
    */
    ChkDR( DRM_DCP_GetAttribute( f_pdstrDevCert, 
                                 DRM_DEVCERT_GROUPSECURITYLEVEL,
                                 NULL,
                                 &dstrValue ) );    
    ChkDR( wcsntol (dstrValue.pwszString, dstrValue.cchString, &lValue));
    if ( lValue > lMaxSecLevel )
    {
        ChkDR( DRM_E_INVALIDDEVICECERTIFICATE );
    }
    
    /*
    **  Do we need to check anything else?
    **  TODO: Confirm with PM whether we want any required values in devcert.
    */

ErrorExit:

    if( DRM_FAILED( dr ) )
    {
        dr = DRM_E_INVALIDDEVICECERTIFICATE;
    }

    return dr;
}


/******************************************************************************
** 
** Function :   _DCP_VerifyCert
** 
** Synopsis :   Verify any particular cert in the devcert
** 
** Arguments :  f_pDevCert -
**              f_pcontextCrypto - 
**              f_pdstrPubkey     - pubkey use to verify cert
**              f_eDataLocation   - Attrib to locate the signed data in devcert
**              f_eSignatureLocation - Attrib to locate the signature over given data            
**
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT _DCP_VerifyCert(
    IN const    DRM_CONST_STRING        *f_pdstrDevCert,
    IN          DRM_CRYPTO_CONTEXT      *f_pcontextCrypto,
    IN  const   DRM_CONST_STRING        *f_pdstrPubkey,
    IN          eDRM_DEVCERT_ATTRIBUTES  f_eDataLocation,
    IN          eDRM_DEVCERT_ATTRIBUTES  f_eSignatureLocation )
{
    DRM_RESULT          dr              =   DRM_SUCCESS;
    DRM_CONST_STRING    dstrData        = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrSignature   = EMPTY_DRM_STRING;
    DRM_DWORD           cbPubkey        = SIZEOF(PUBKEY);
    DRM_DWORD           cbSignature     = SIZEOF(f_pcontextCrypto->signature);
    /*
    **  No need to check args in internal function - always checked
    */
    
    /*
    **  Get the DEVCERT\CERTIFICATE\DATA SECTION
    */
    ChkDR( DRM_DCP_GetAttribute( f_pdstrDevCert, 
                                 f_eDataLocation,
                                 &dstrData, 
                                 NULL ) );
    
    /*
    **  Decode the key and put it in the crypto context
    */
    ChkDR( DRM_B64_DecodeW(f_pdstrPubkey, 
                          &cbPubkey, 
                           f_pcontextCrypto->pubKey.y, 
                           0) ); 

    /*
    **  Get the signature
    */
    ChkDR( DRM_DCP_GetAttribute( f_pdstrDevCert, 
                                 f_eSignatureLocation,
                                 NULL,
                                 &dstrSignature ) );

    /*
    **  Verify the signature
    */
    ChkDR(DRM_B64_DecodeW( &dstrSignature, 
                           &cbSignature, 
                           f_pcontextCrypto->signature, 
                           0 ) );
    
    if( !DRM_PK_Verify( f_pcontextCrypto->rgbCryptoContext, 
                       &f_pcontextCrypto->pubKey,
                        PB_DSTR(&dstrData), 
                        CB_DSTR(&dstrData),
                        f_pcontextCrypto->signature) )
    {       
        dr = DRM_E_INVALID_SIGNATURE;
    }
    
ErrorExit:
    if( DRM_FAILED( dr ) )
    {
        dr = DRM_E_INVALIDDEVICECERTIFICATETEMPLATE;
    }    
    return dr;
}



/******************************************************************************
** Function :   DRM_DCP_GetAttribute
** Synopsis :   Get attribute from given devcert
** Arguments :  f_pdstrDevCert
**              f_eAttribute  - devcert attr to get
**              f_pdstrNode   - extracted attr node with <node> tag 
**              f_pdstrValue  - extracted attr node value              
******************************************************************************/
DRM_RESULT DRM_API DRM_DCP_GetAttribute(
    IN const DRM_CONST_STRING        *f_pdstrDevCert,          /* devcert */
    IN       eDRM_DEVCERT_ATTRIBUTES  f_eAttribute,            /* devcert attr to get */
       OUT   DRM_CONST_STRING        *f_pdstrNode,             /* extracted attr node with <node> tag */
       OUT   DRM_CONST_STRING        *f_pdstrValue)
{
    DRM_RESULT                   dr                 = DRM_SUCCESS;
    const DRM_CONST_STRING      *pdstrPath          = NULL;
    const DRM_CONST_STRING      *pdstrCertType      = NULL;
    const DRM_CONST_STRING      *pdstrTagSubNode    = NULL;
    DRM_CONST_STRING             dstrSubNode        = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_DCP_GetAttribute", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    ChkArg( f_pdstrNode != NULL 
        || f_pdstrValue != NULL );
    ChkDRMString( f_pdstrDevCert );

    switch(f_eAttribute)
    {
        /*
        **  Device Cert attributes
        */
        case DRM_DEVCERT_DEVICEPRIVKEY:
            pdstrCertType   = &g_dstrCertTypeDevice;
            pdstrPath       = &g_dstrXPathDeviceKeydata;
            break;            
        case DRM_DEVCERT_DEVICEDATANODE:
            pdstrCertType   = &g_dstrCertTypeDevice;
            pdstrPath       = &g_dstrTagData;
            break;
        case DRM_DEVCERT_DEVICESIGNATURE:
            pdstrCertType   = &g_dstrCertTypeDevice;
            pdstrPath       = &g_dstrTagMSDRMSignature;
            break;         
        case DRM_DEVCERT_DEVICEPUBKEY:
            pdstrCertType   = &g_dstrCertTypeDevice;
            pdstrPath       = &g_dstrXPathPubkeyData; 
            break;  
        case DRM_DEVCERT_SERIALNUMBER: 
            pdstrCertType   = &g_dstrCertTypeDevice;
            pdstrPath       = &g_dstrXPathDataUniqueID; 
            break;        
                        
        /*
        **  Fallback attributes
        */
        case DRM_DEVCERT_COMPATIBILITYVERSION:
            pdstrTagSubNode = &g_dstrFallBack;
            pdstrCertType   = NULL;
            pdstrPath       = &g_dstrTagSecurityVersion;             
            break;            
        case DRM_DEVCERT_COMPATIBILITYCERT:
            pdstrTagSubNode = &g_dstrFallBack;
            pdstrCertType   = NULL;
            pdstrPath       = &g_dstrTagCertificate; 
            break;

        
        /*
        **  GC Attributes
        */
        case DRM_DEVCERT_SECURECLOCK:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCSecureClock; 
            break;
        case DRM_DEVCERT_SECURECLOCKURL:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCSecureClockURL; 
            break;
        case DRM_DEVCERT_SECURECLOCKPUBKEY:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCSecureClockPubKey; 
            break;
        case DRM_DEVCERT_METERING:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCMetering; 
            break;
        case DRM_DEVCERT_LICENSEACQUISITIONMODE:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCLicenseAcquisitionMode; 
            break;
        case DRM_DEVCERT_LICENSESYNCMODE:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCLicenseSyncMode; 
            break;
        case DRM_DEVCERT_SYMMETRICOPTIMIZATIONS:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCSymmOptsMode; 
            break;
        case DRM_DEVCERT_ENCRYPTION:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCEncryption; 
            break;
        case DRM_DEVCERT_MAXCHAINDEPTH:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCMaxChainDepth; 
            break;
        case DRM_DEVCERT_MAXLICENSESIZE:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCMaxLicenseSize; 
            break;
        case DRM_DEVCERT_MAXHEADERSIZE:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathGCMaxHeaderSize; 
            break;
        case DRM_DEVCERT_GROUPSECURITYLEVEL:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathTagSecurityLevel; 
            break;
        case DRM_DEVCERT_GROUPCERTPUBKEY:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrXPathPubkeyData; 
            break;
        case DRM_DEVCERT_GROUPCERTDATANODE:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrTagData; 
            break;
        case DRM_DEVCERT_GROUPCERTSIGNATURE:
            pdstrCertType   = &g_dstrCerttypeGroup;
            pdstrPath       = &g_dstrTagMSDRMSignature; 
            break;        
            
        /*
        **  DAC attributes
        */
        case DRM_DEVCERT_DACSECURITYLEVEL:
            pdstrCertType   = &g_dstrCerttypeAuth;
            pdstrPath       = &g_dstrXPathTagSecurityLevel; 
            break;
        case DRM_DEVCERT_SUBJECTID:
            pdstrCertType   = &g_dstrCerttypeAuth;
            pdstrPath       = &g_dstrXPathDACAuthID; 
            break;            
        case DRM_DEVCERT_DACPUBKEY:
            pdstrCertType   = &g_dstrCerttypeAuth;
            pdstrPath       = &g_dstrXPathPubkeyData; 
            break;            
        case DRM_DEVCERT_DACDATANODE:
            pdstrCertType   = &g_dstrCerttypeAuth;
            pdstrPath       = &g_dstrTagData; 
            break;            
        case DRM_DEVCERT_DACSIGNATURE:
            pdstrCertType   = &g_dstrCerttypeAuth;
            pdstrPath       = &g_dstrTagMSDRMSignature; 
            break;                     
        case DRM_DEVCERT_DACROOTPUBKEY:
            pdstrCertType   = &g_dstrCerttypeAuthRoot;
            pdstrPath       = &g_dstrXPathPubkeyData; 
            break;            
        case DRM_DEVCERT_AUTHROOTDATANODE:
            pdstrCertType   = &g_dstrCerttypeAuthRoot;
            pdstrPath       = &g_dstrTagData; 
            break;            
        case DRM_DEVCERT_AUTHROOTSIGNATURE:
            pdstrCertType   = &g_dstrCerttypeAuthRoot;
            pdstrPath       = &g_dstrTagMSDRMSignature; 
            break;            
            
        default:
            ChkDR(DRM_E_INVALIDARG);
    }

    if (pdstrCertType != NULL)
    {        
        ChkDR( DRM_XML_GetSubNode( f_pdstrDevCert, 
                                   &g_dstrTagCertificate, 
                                   &g_dstrAttributeType, 
                                   pdstrCertType, 
                                   0,
                                   &dstrSubNode, 
                                   NULL,
                                   1 ) );           
    }
    else
    {
        ChkDR( DRM_XML_GetSubNode( f_pdstrDevCert, 
                                   pdstrTagSubNode, 
                                   NULL, 
                                   NULL, 
                                   0,
                                   &dstrSubNode, 
                                   NULL,
                                   1 ) );         
    }

    ChkDR( DRM_XML_GetSubNodeByPath(&dstrSubNode, 
                                     pdstrPath, 
                                     NULL, 
                                     NULL, 
                                     f_pdstrNode, 
                                     f_pdstrValue, 
                                     g_wchForwardSlash ) );  
        
ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_DCP_GetAttribute", g_pwszLeavingFunction);
    return dr;
}


/******************************************************************************
** Function  :   DRM_DCP_VerifyDeviceCert
** Synopsis  :   
** Arguments : 
******************************************************************************/
DRM_RESULT DRM_API DRM_DCP_VerifyDeviceCert(
    IN const DRM_CONST_STRING   *f_pdstrDevCert,
    IN       DRM_DWORD           f_dwVerifyFlags,
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP )
{
    DRM_RESULT       dr         = DRM_SUCCESS;
    DRM_CONST_STRING dstrPubkey = EMPTY_DRM_STRING;
                                         
    /*
    **  Check input
    */
    ChkArg (f_pcontextCRYP != NULL);
    ChkArg((f_dwVerifyFlags & ~DRM_DCP_VERIFY_ENTIRE_DEVCERT) == 0);

    ChkDRMString( f_pdstrDevCert );

    /* verify basic values */
    ChkDR( _DCP_VerifyBasicValues( f_pdstrDevCert, f_pcontextCRYP ) );
    
    if( f_dwVerifyFlags & DRM_DCP_VERIFY_GROUP_CERT )
    {
        /*
        **  Get the Public Key
        */
        ChkDR( DRM_DCP_GetAttribute( f_pdstrDevCert, 
                                    DRM_DEVCERT_DACPUBKEY,
                                    NULL,
                                   &dstrPubkey ) );
        
        ChkDR( _DCP_VerifyCert( f_pdstrDevCert, 
                                f_pcontextCRYP, 
                               &dstrPubkey,
                                DRM_DEVCERT_GROUPCERTDATANODE, 
                                DRM_DEVCERT_GROUPCERTSIGNATURE ) );
    }
    
    if (f_dwVerifyFlags & DRM_DCP_VERIFY_DEVICE_CERT)
    {    
        DRM_DWORD cb = 0;


        /* Get the compatability certificate */ 
        ChkDR(DRM_DCP_GetAttribute(f_pdstrDevCert, 
                                   DRM_DEVCERT_COMPATIBILITYCERT, 
                                   NULL,
                                  &dstrPubkey));
        cb = SIZEOF(PKCERT);
        if (DRM_FAILED(DRM_B64_DecodeW(&dstrPubkey,
                                       &cb, 
                          (DRM_BYTE *) &f_pcontextCRYP->union_cert.pkcert,
                                        0)))
        {
            dr = DRM_E_INVALIDDEVICECERTIFICATE;
            goto ErrorExit;
        }

        /*
        **  Get the Public Key
        */
        ChkDR( DRM_DCP_GetAttribute( f_pdstrDevCert, 
                                     DRM_DEVCERT_GROUPCERTPUBKEY,
                                     NULL,
                                    &dstrPubkey ) );
        cb = SIZEOF(PUBKEY);
        if (DRM_FAILED(DRM_B64_DecodeW(&dstrPubkey, 
                                       &cb, 
                            (DRM_BYTE*)&f_pcontextCRYP->pubKey, 
                                        0)))
        {
            ChkDR(DRM_E_INVALIDDEVICECERTIFICATE);
        }

        /* Verify the rest of the certificate */
        ChkDR( _DCP_VerifyCert( f_pdstrDevCert, 
                                f_pcontextCRYP, 
                               &dstrPubkey,
                                DRM_DEVCERT_DEVICEDATANODE,
                                DRM_DEVCERT_DEVICESIGNATURE) );

    }
    
    if (f_dwVerifyFlags & DRM_DCP_VERIFY_DAC)
    {
        INIT_DRM_STRING(dstrPubkey);
        
        ChkDR(DRM_DCP_GetAttribute(f_pdstrDevCert, 
                                   DRM_DEVCERT_DACROOTPUBKEY, 
                                   NULL,
                                  &dstrPubkey));
    
        ChkDR( _DCP_VerifyCert    (f_pdstrDevCert, 
                                   f_pcontextCRYP, 
                                  &dstrPubkey, 
                                   DRM_DEVCERT_DACDATANODE, 
                                   DRM_DEVCERT_DACSIGNATURE) );      

        ChkDR( _DCP_VerifyCert    (f_pdstrDevCert, 
                                   f_pcontextCRYP, 
                                  &g_dstrMSRootPubKey, 
                                   DRM_DEVCERT_AUTHROOTDATANODE, 
                                   DRM_DEVCERT_AUTHROOTSIGNATURE)); 
    }

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_DCP_LoadPropertiesCache(
    IN const DRM_CONST_STRING                      *f_pdstrDevCert,
       OUT   DRM_DEVICE_CERTIFICATE_CACHED_VALUES  *f_pcacheDevCert,
    IN       DRM_CRYPTO_CONTEXT                    *f_pcontextCRYP )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrValue = EMPTY_DRM_STRING;
    DRM_DWORD cb     = 0;
    DRM_LONG  lValue = 0;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_DCP_LoadPropertiesCache", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    ChkArg( f_pcacheDevCert != NULL
         && f_pcontextCRYP  != NULL );
    ChkDRMString( f_pdstrDevCert );
    
    /*
    ** First get all the keys and certificates
    */ 

    ChkDR( DRM_DCP_GetAttribute( f_pdstrDevCert, DRM_DEVCERT_DEVICEPUBKEY, NULL, &dstrValue) );
    cb = SIZEOF( PUBKEY );
    if (DRM_FAILED(DRM_B64_DecodeW(&dstrValue, 
                                   &cb, 
                      (DRM_BYTE*)&(f_pcacheDevCert->pubkeyCurrent),
                                    0)))
    {
        ChkDR( DRM_E_INVALIDDEVICECERTIFICATE );
    }
    
    ChkDR( DRM_DCP_GetAttribute( f_pdstrDevCert, DRM_DEVCERT_DEVICEPRIVKEY, NULL, &dstrValue) );
    
    if ( dstrValue.cchString != CCH_BASE64_EQUIV( SIZEOF(PRIVKEY) ) )
    {
        ChkDR( DRM_E_INVALIDDEVICECERTIFICATE );
        goto ErrorExit;
    }

    cb = SIZEOF(PRIVKEY);
    if (DRM_FAILED(DRM_B64_DecodeW(&dstrValue, 
                                   &cb, 
                                   (DRM_BYTE*)f_pcacheDevCert->m_blobDevicePrivkey,
                                    0)))
    {
        ChkDR( DRM_E_INVALIDDEVICECERTIFICATE );
    }    

    /* get the Compatibility cert */
    ChkDR(DRM_DCP_GetAttribute(f_pdstrDevCert, DRM_DEVCERT_COMPATIBILITYCERT, NULL, &dstrValue));
    
    cb = SIZEOF(PKCERT);
    if (DRM_FAILED(DRM_B64_DecodeW(&dstrValue,
                                    &cb, 
                        (DRM_BYTE*)&f_pcacheDevCert->m_BBCompatibilityCert,
                                    0)))
    {
        ChkDR( DRM_E_INVALIDDEVICECERTIFICATE );
    }
    
    /* Get the legacy version */
    if ( DRM_SUCCEEDED( DRM_DCP_GetAttribute( f_pdstrDevCert, 
                                              DRM_DEVCERT_COMPATIBILITYVERSION, 
                                              NULL, 
                                              &dstrValue) ) )
    {
        if( dstrValue.cchString > NO_OF( f_pcacheDevCert->wszLegacyVersion ) - 1 )
        {
            ChkDR( DRM_E_INVALIDDEVICECERTIFICATE );
        }
        wcsncpy( f_pcacheDevCert->wszLegacyVersion, dstrValue.pwszString, dstrValue.cchString);
        f_pcacheDevCert->wszLegacyVersion[dstrValue.cchString] = g_wchNull;
    }
    else
    {
        /* There is no compatability certificate version. */
        ChkDR( DRM_E_INVALIDDEVICECERTIFICATE );
    }
    
    /*
    ** Next populate all the feature flags in the cached structure
    */ 

    f_pcacheDevCert->dwFeatureFlags = 0;

    ChkDR(DRM_DCP_GetAttribute(f_pdstrDevCert, DRM_DEVCERT_GROUPSECURITYLEVEL, NULL, &dstrValue));
    ChkDR(wcsntol( dstrValue.pwszString, dstrValue.cchString, (DRM_LONG *) &f_pcacheDevCert->appSec ) );

    ChkDR(DRM_DCP_GetAttribute( f_pdstrDevCert, DRM_DEVCERT_SUBJECTID, NULL, &dstrValue));
    ChkDR(wcsntol(dstrValue.pwszString, dstrValue.cchString, (DRM_LONG *) &f_pcacheDevCert->appcd_subject));

    /* Get the secure clock from the devcert */    
    if ( DRM_SUCCEEDED( DRM_DCP_GetAttribute( f_pdstrDevCert, DRM_DEVCERT_SECURECLOCK, NULL, &dstrValue) ) )
    {
        ChkDR( wcsntol ( dstrValue.pwszString, dstrValue.cchString, &lValue ) );
        if( lValue == DRM_CLOCK_SECURE )
        {
            /* If the device supports secure clock then there must be a secure clock server public key in the cert */
            ChkDR( DRM_DCP_GetAttribute( f_pdstrDevCert, DRM_DEVCERT_SECURECLOCKPUBKEY, NULL, &dstrValue) );
            cb = SIZEOF( PUBKEY );
            if( DRM_FAILED( DRM_B64_DecodeW( &dstrValue, 
                                             &cb, 
                                  (DRM_BYTE*)&(f_pcacheDevCert->pubkeySecureClockServer),
                                              0)))
            {
                ChkDR( DRM_E_INVALIDDEVICECERTIFICATE );
            }                
            f_pcacheDevCert->dwFeatureFlags |= DRM_FEATURE_SECURE_CLOCK;
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK            
            f_pcacheDevCert->dwFeatureFlags |= DRM_FEATURE_ANTI_ROLLBACK_CLOCK;
#endif
        }

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK            
        if( lValue == DRM_CLOCK_ANTIROLLBACK )
        {
            f_pcacheDevCert->dwFeatureFlags |= DRM_FEATURE_ANTI_ROLLBACK_CLOCK;            
        }
#endif        
    }

    /* Get the Metering from the devcert */
    if ( DRM_SUCCEEDED( DRM_DCP_GetAttribute( f_pdstrDevCert, 
                                              DRM_DEVCERT_METERING, 
                                              NULL,
                                             &dstrValue) ) )
    {
        ChkDR( wcsntol ( dstrValue.pwszString, dstrValue.cchString, &lValue ) );
        if( lValue == 1 )
        {
            f_pcacheDevCert->dwFeatureFlags |= DRM_FEATURE_METERING;
        }
    }

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_DCP_LoadPropertiesCache", g_pwszLeavingFunction);

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\chkhds.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <stdio.h>
#include <drmcommon.h>
#include <drmtypes.h>
#include <oemimpl.h>
#include <drmcmdlnpars.h>
#include <drmhds_impl.h>
#include <drmhds.h>
#include <drmutilities.h>

#define _CHKHDS_ 
#include "../../core/drmhds.c"


#define MAXBUFF  4096
#define MAXSLOT  4096
#define MAXNAMESPACENAMELEN 20
#define DRMGUID_LENGTH 16


typedef enum {
    eDumpRaw=0,
    eDumpHex,
    eDumpChar
} EDumpMode;




static DRM_DWORD _gdwFileSize=0;
static DRM_HDS_CONTEXT oHDS;
const DRM_WORD   wLS_BlockSize = 10240;      /* block size is limited to 64K */
const DRM_WORD   wLS_MaxNumChildren=16;      /* # of child per parent is limited to 64K */
const DRM_HDSBLKNUM eLS_BlkNumType=eDRM_HDSBLKNUM_WORD;
const DRM_DWORD _majorVersion=1;
const DRM_DWORD _minorVersion=0;


static DRM_RESULT _StringToBytes( 
    const DRM_WCHAR *pwszKey,
    DRM_DWORD cch,
    DRM_BYTE *pb,
    DRM_DWORD cb )
{
    DRM_RESULT   dr     = DRM_SUCCESS;
    DRM_DWORD    i      = 0;
    DRM_DWORD    tmp    = 0;
    DRM_CHAR    *pszKey = NULL;
    
    ChkMem( pszKey = OEM_malloc( cch+1 ) );
    ZEROMEM(pszKey, cch+1);
    DRM_UTL_DemoteUNICODEtoANSI( pwszKey, pszKey, cch );

    ZEROMEM(pb, cb);
    for (i=0; i<cch && pszKey[i*2] != '\0' ; i++)
    {
        if ( i >= cb )
        {
            break;
        }
        if ( sscanf(&pszKey[i*2], "%02X", &tmp) == 1 )
        {
            PUT_BYTE(pb,i,(DRM_BYTE)tmp);
        }
    }
    
ErrorExit:    
    OEM_free( pszKey );
    return dr;
}
    
/*************************************************************************/
static DRM_RESULT
_PrepareNamespaceID(
    const DRM_WCHAR *pwKey,
    DRM_DWORD dwLen,
    DRM_HDS_NAMESPACE *pNSID)
{
    return _StringToBytes( pwKey, dwLen, (DRM_BYTE*)pNSID, DRM_HDS_NSNAME_SIZE );
}


/*************************************************************************/
static DRM_RESULT
_PrepareUniqueKey(
    const DRM_WCHAR *pwKey,
    DRM_DWORD dwLen,
    DRM_HDS_UNIQUEKEY *pKey)
{
    return _StringToBytes( pwKey, dwLen, (DRM_BYTE*)pKey, DRM_HDS_UNIQUEKEY_SIZE );
}

/*************************************************************************/
static DRM_RESULT
_PrepareHashKey(
    const DRM_WCHAR *pwKey,
    DRM_DWORD dwLen,
    DRM_HDS_HASHKEY *pKey)
{
    return _StringToBytes( pwKey, dwLen, (DRM_BYTE*)pKey, DRM_HDS_HASHKEY_SIZE );
}



/***********************************************************************/
static DRM_VOID
_PrintHexString(
    DRM_CHAR *pszText1,
    DRM_CHAR *pszText2,
    DRM_BYTE *pbBuff,
    DRM_DWORD cbBuff)
{
    DRM_DWORD nIndex=0;

    printf("%s0x", pszText1);
    for (nIndex=0; nIndex < cbBuff; nIndex++)
    {
        printf("%02X", pbBuff[nIndex]);
    }
    printf("%s", pszText2);
}

/***********************************************************************/
static DRM_VOID
_PrintCharString(
    DRM_CHAR *pszText1,
    DRM_CHAR *pszText2,
    DRM_BYTE *pbBuff,
    DRM_DWORD cbBuff)
{
    DRM_DWORD nIndex=0;
    DRM_DWORD dwRow=0;

    printf("%s", pszText1);
    for (nIndex=0; nIndex < cbBuff; nIndex+=2)
    {
        DRM_WCHAR *pwch = (DRM_WCHAR*)&pbBuff[nIndex];
        DRM_CHAR ch = (DRM_CHAR)*pwch;
        
        if ( pbBuff[nIndex] > 20 )
            printf("%c", ch);
        else
            printf(".");

        ++dwRow;
        if ( dwRow == 80 )
        {
            printf("\n%s", pszText1);
            dwRow = 0;
        }
    }
    printf("%s", pszText2);
}



/***********************************************************************/
static DRM_VOID
_PrintTimestamp(
    DRM_CHAR *pszText1,
    DRM_CHAR *pszText2,
    DRM_UINT64 *pTimestamp)
{
    DRMSYSTEMTIME st;
    DRMFILETIME   ft;
    printf("%s", pszText1);
    UI64_TO_FILETIME( *pTimestamp, ft );
    OEM_FileTimeToSystemTime(&ft, &st);
    printf("%04d/%02d/%02d %02d:%02d:%02d.%03d (UTC)",
        st.wYear,
        st.wMonth,
        st.wDay,
        st.wHour,
        st.wMinute,
        st.wSecond,
        st.wMilliseconds);
    printf("%s", pszText2);
}


/***********************************************************************/
static DRM_RESULT _OpenStore(
    DRM_CONST_STRING *pPathname,
    DRM_HDS_CONTEXT *pbHDS )
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_WCHAR wszDeviceStoreName[DRM_MAX_PATH] = {0};
    _HdsContext *pHDS = (_HdsContext*)pbHDS;

    ZEROMEM(wszDeviceStoreName, DRM_MAX_PATH*SIZEOF(DRM_WCHAR));
    wcsncpy(wszDeviceStoreName, pPathname->pwszString, pPathname->cchString);

    printf("Accessing data store: %S\n", wszDeviceStoreName);
    ChkDR(DRM_HDS_Init(pbHDS));
    dr = DRM_HDS_OpenStore(wszDeviceStoreName, pbHDS);
    if ( DRM_SUCCEEDED(dr) || dr==DRM_E_HASHMISMATCH )
    {
        /* get file size */
        if (!OEM_GetFileSize(pHDS->fp, &_gdwFileSize))
        {
            ChkDR(DRM_E_FILEREADERROR);
        }
    }
    
ErrorExit:

    return dr;
}


static DRM_VOID
_PrintHexFormated(
    DRM_BYTE *pbBuff,
    DRM_DWORD cbBuff)
{
    DRM_DWORD i=0;
    DRM_DWORD j=0;
    
    for (i=0; i<cbBuff; i+=j)
    {
        printf("\t %05d: ", i);
        for (j=0; j<16; j++)
        {
            if ( (j % 4) == 0 )
                printf(" ");

            if ( (i+j) < cbBuff )
                printf("%02X ", pbBuff[i+j]);
            else
                printf("   ");
        }

        printf(" |");
        for (j=0; j<16; j++)
        {
            if ( (i+j) >= cbBuff )
                printf(" ");
            else if ( pbBuff[i+j] <= 20 )
                printf(".");
            else
                printf("%c", pbBuff[i+j]);
        }

        printf("|\n");
    }
}


/*
**
*/
static DRM_VOID
_PrintSlots(
    _HdsContext *pHDS,
    DRM_DWORD dwBlocknum,
    DRM_BYTE *pbPayload,
    DRM_DWORD cbPayload,
    DRM_DWORD dwFreeMem,
    EDumpMode eMode)
{
    DRM_DWORD i=0;
    DRM_DWORD dwSearch=0;
    DRM_DWORD dwBytesToSkip=0;
    _SlotHeader *pSlotHdr=NULL;
    DRM_DWORD dwFilePos=0;

    DRMASSERT(dwBlocknum>0);
    _HdsBlockNum2FilePos(pHDS, dwBlocknum, &dwFilePos);
    dwFilePos += pHDS->oSRN.dwBlockSize - cbPayload;

    printf("\n");
    for (dwSearch=0; dwSearch<(cbPayload-dwFreeMem); dwSearch+=dwBytesToSkip)
    {
        DRM_DWORD dwAttributes = 0;
        pSlotHdr = (_SlotHeader*)&pbPayload[dwSearch];
        if ( pSlotHdr->dwSlotSize == 0 )
        {
            break;
        }

        printf("\t[File Pos]\t%d\n", dwFilePos+dwSearch);
        printf("\t[Slot size]\t%d\n", pSlotHdr->dwSlotSize);
        _PrintHexString("\t[Hashkey]\t", "\n", pSlotHdr->oHashkey.rgb, DRM_HDS_HASHKEY_SIZE);
        _PrintHexString("\t[Uniquekey]\t", "\n", pSlotHdr->oUniquekey.rgb, DRM_HDS_UNIQUEKEY_SIZE);
        printf("\t[Namespace]\t%s\n", (pSlotHdr->dwAttributes & eSlotIsNamespace)? "Yes" : "No");
        printf("\t[Hidden]\t%s\n", (pSlotHdr->dwAttributes & eSlotIsHidden)? "Yes" : "No");
        dwAttributes = pSlotHdr->dwAttributes & (~(eSlotIsHidden|eSlotIsNamespace));
        printf("\t[Attributes]\t0x%04X\n", dwAttributes);

        if ( (SIZEOF(_SlotHeader)+(pSlotHdr->dwSlotSize)) > cbPayload )
        {
            DRM_DWORD *pdwDatablocknum = (DRM_DWORD*)(&pbPayload[dwSearch] + SIZEOF(_SlotHeader));
            printf("\t[Datablock#]\t%d\n", *pdwDatablocknum);
            dwBytesToSkip = SIZEOF(_SlotHeader)+SIZEOF(DRM_DWORD);
        }
        else
        {
            printf("\t[Payload]\n");
            if ( eMode == eDumpChar )
                _PrintCharString("\t ", "\n", (&pbPayload[dwSearch] + SIZEOF(_SlotHeader)), pSlotHdr->dwSlotSize);
            else
                _PrintHexFormated((&pbPayload[dwSearch] + SIZEOF(_SlotHeader)), pSlotHdr->dwSlotSize);
            
            dwBytesToSkip = SIZEOF(_SlotHeader)+(DRM_WORD)pSlotHdr->dwSlotSize;
        }

        printf("\n");
    }
}


/*
**
*/
static DRM_BOOL
_ParseChildBlock(
    _HdsContext *pHDS,
    DRM_BYTE *pBlockBuff,
    DRM_DWORD *pdwPayloadBeg,
    DRM_DWORD *pdwPayloadSize,
    DRM_DWORD *pdwNumChildren,
    DRM_DWORD  cbCommonBlockHdr)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD i=0;
    DRM_DWORD dwPayloadSize = 0;
    DRM_DWORD dwPayloadBeg = 0;
    DRM_DWORD dwSearch=0;
    DRM_DWORD dwBytesToSkip=0;
    DRM_DWORD dwRemainingBytes=0;
    _ChildBlockFileHDR *pChildBlockHeader=(_ChildBlockFileHDR*)(pBlockBuff + cbCommonBlockHdr);
    _SlotHeader *pSlotHdr=NULL;


    for (i=DRM_HDS_MAXIMUM_CHILDREN; i>0; i--)
    {
        dwPayloadBeg = cbCommonBlockHdr + (SIZEOF(DRM_DWORD) + SIZEOF(DRM_BYTE) + i * pHDS->oSRN.eBlockNumType);
        dwPayloadSize = pHDS->oSRN.dwBlockSize - dwPayloadBeg;

        /* the following must be _SlotHeader's */
        dwRemainingBytes = 0;
        for (dwSearch=dwPayloadBeg; dwSearch<pHDS->oSRN.dwBlockSize; dwSearch+=dwBytesToSkip)
        {
            _SlotHeader oTmpSlotHdr;

            /* determine end of slots */
            dwRemainingBytes = pHDS->oSRN.dwBlockSize - dwSearch;

            DRM_BYT_CopyBytes((DRM_BYTE*)&oTmpSlotHdr, 0, pBlockBuff, dwSearch, SIZEOF(_SlotHeader));

            /* determine end of slots: _SlotHeader + DWORD is the minimum size */
            if ( dwRemainingBytes < (pChildBlockHeader->nFreeMem + SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD)) )
            {
                break;
            }

            /* walk the slot */

            /* check if the slot's content is in DATA blocks */
            if ( (SIZEOF(_SlotHeader)+(oTmpSlotHdr.dwSlotSize)) > dwPayloadSize )
            {
                DRM_DWORD dwBN=0;
                DRM_DWORD dwFilePos=0;
                DRM_BYT_CopyBytes((DRM_BYTE*)&dwBN, 0, pBlockBuff, dwSearch + SIZEOF(_SlotHeader), SIZEOF(DRM_DWORD));

                _HdsBlockNum2FilePos(pHDS, dwBN, &dwFilePos);
                if ( dwFilePos < _gdwFileSize )
                {
                    dwBytesToSkip = SIZEOF(_SlotHeader)+SIZEOF(DRM_DWORD);
                    continue;
                }
            }
            
            /* nope, let's see if the block size > 0 */
            else if ( oTmpSlotHdr.dwSlotSize > 0 )
            {
                dwBytesToSkip = SIZEOF(_SlotHeader)+(DRM_DWORD)oTmpSlotHdr.dwSlotSize;
                continue;
            }

            break;  /* forget it. */
        }

        /* stop if we have a match */
        if ( dwRemainingBytes == pChildBlockHeader->nFreeMem )
            break;
    }

    if ( dwRemainingBytes != pChildBlockHeader->nFreeMem )
        return FALSE;

    *pdwPayloadBeg = dwPayloadBeg;
    *pdwNumChildren = i;
    *pdwPayloadSize = dwPayloadSize;
    return TRUE;    
}


/*
**
*/
static DRM_DWORD
_GetChildBlockNum(
    _HdsContext *pHDS,
    DRM_BYTE *pbChildAllocTable,
    DRM_DWORD nIndex)
{
    switch (pHDS->oSRN.eBlockNumType)
    {
        case eDRM_HDSBLKNUM_DWORD:
            return ((DRM_DWORD*)pbChildAllocTable)[nIndex];
            break;
        case eDRM_HDSBLKNUM_WORD:
            {
            DRM_WORD wNum=((DRM_WORD*)pbChildAllocTable)[nIndex];
            return  (DRM_DWORD)wNum;
            }
            break;
        default:    /* eDRMLIC_NUMBLOCKS_BYTE */
            return (DRM_DWORD)(pbChildAllocTable[nIndex]);
            break;
    }
}


/**********************************************************************
** Function:    _HdsTraverseBlocksInPreOrder
** Synopsis:    
** Arguments:   [pCFG] -- 
**              [pCurrBlock] -- 
**              [pNextBlock] -- 
**              [pResult] 
** Returns:     DRM_SUCCESS on success
** Notes:       From the given current block, traverse the tree in PRE ORDER fashion.
** Algorithm:
**    PreOrder(CFG, Current, Next, *pLevels)
**    {
**        *pLevels = 0;
**        if ( Current == NULL )
**        {
**            Next = CFG->Root;
**            return TRUE;
**        }
**        else
**        {
**            Next = LeftmostChildren(Current);
**            if ( Next != NULL )
**            {
**                ++*pLevels;
**                return TRUE;
**            }
**
**            while (TRUE)
**            {
**                Next = NextRightSibling(Current);
**                if ( Next != NULL )
**                    return TRUE;
**
**                Current = Parentof(Current);
**                if (Current == NULL)
**                    return FALSE;  // this's it 
**
**                --*pLevels;
**            }
**        }
**    }
**
***********************************************************************
*/
static DRM_RESULT
_HdsTraverseBlocksInPreOrder(
    IN _NsContext *pCFG,
    IN _CommBlockHDR *pCurrBlock,
    OUT _CommBlockHDR *pNextBlock,
    OUT DRM_INT *pdwLevelsVisited,
    OUT DRM_BOOL *pResult)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nBlockNum=0;
    DRM_DWORD nIndex;
    
    ChkArg( pCFG && pNextBlock && pdwLevelsVisited && pResult);
    *pResult = FALSE;

    if ( pCurrBlock == NULL )   /* start from Root of current Namespace */
        nBlockNum = pCFG->nCfgRootBlockNum;
    else
    {
        /* search index of the current child in parent's ChildAlloc table */
        for (nIndex=0; nIndex<(DRM_DWORD)pCFG->wMaxNumChildren; nIndex++)
        {
            ChkDR(_HdsGetPutChildBlockNum(pCFG, ((_ChildBlockHDR*)pCurrBlock)->File._image.bChildAllocTable,
                nIndex, &nBlockNum, TRUE));
            if ( nBlockNum != 0 )
            {
                ++*pdwLevelsVisited;
                goto PrepareReturn;
            }
        }

        ChkDR(_HdsTraverseNextRightSiblingBlock(pCFG, pCurrBlock, &nBlockNum));
        if ( nBlockNum != 0 )   /* Next sibling found */
            goto PrepareReturn;
        if ( pCurrBlock->File._image.nParentBlockNum == ROOTPARENTNUM )
        {
            *pResult = FALSE;   /* current block is the root, that's it */
            goto ErrorExit;
        }

        nBlockNum = pCurrBlock->File._image.nParentBlockNum;
        while (TRUE)    /* traverse up */
        {
            --*pdwLevelsVisited;
            ChkDR(_HdsLoadBlockHDR(pCFG, nBlockNum, &pNextBlock));
            ChkDR(_HdsTraverseNextRightSiblingBlock(pCFG, pNextBlock, &nBlockNum));

            if ( nBlockNum != 0 )   /* no more sibling found */
                goto PrepareReturn;
            if ( pNextBlock->File._image.nParentBlockNum == ROOTPARENTNUM )
            {
                *pResult = FALSE;   /* current block is the root */
                goto ErrorExit;
            }
            nBlockNum = pNextBlock->File._image.nParentBlockNum;
        }
    }

PrepareReturn:

    ChkDR(_HdsLoadBlockHDR(pCFG, nBlockNum, &pNextBlock));
    *pResult = TRUE;
    
ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    DRM_HDS_InitSlotEnum
** Synopsis:    
** Arguments:   [pbNsContext] -- 
**              [pEnumContext] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
DoNamespaceTreeSketch(
    DRM_HDS_CONTEXT *pContext,
    DRM_HDS_NAMESPACE *pNSID)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HdsContext *pHDS=(_HdsContext*)pContext;
    DRM_HDS_NAMESPACE_CONTEXT NsContext;
    _NsContext *pCFG=NULL;
    DRM_BOOL fResult=FALSE;
    _CommBlockHDR *pCurrBlock=NULL;
    DRM_INT dwLevelsVisited=0;
    DRM_INT dwCurrLevel=0;
    DRM_INT i;

    ChkArg(pContext && pNSID);

    /* open the namespace */
    dr = DRM_HDS_OpenNamespace( pContext, 
                                pNSID, 
                                eDRM_HDS_OPEN_EXISTING,
                                0,
                                &NsContext );
    if ( dr == DRM_E_HDSNAMESPACENOTFOUND )
        printf("\tNamespace not found.\n");

    ChkDR(dr);
    pCFG = (_NsContext*)&NsContext;
    ChkDR(_HdsAllocBlockBuffer(pCFG, eCHILDBLOCK, &pCurrBlock));

    /* find the first node in postorder */
    ChkDR(_HdsTraverseBlocksInPreOrder(pCFG, NULL, pCurrBlock, &dwLevelsVisited, &fResult));
    if ( !fResult )
    {
        printf("\tNo CHILD block found.\n");
        goto ErrorExit;
    }

    printf("\t");
    printf("[Root#%2d]\n", pCurrBlock->nBlockNum);
        
    dwLevelsVisited = 0;
    ChkDR(_HdsTraverseBlocksInPreOrder(pCFG, pCurrBlock, pCurrBlock, &dwLevelsVisited, &fResult));
    while (fResult)
    {
        dwCurrLevel += dwLevelsVisited;

        printf("\t");
        for (i=0; i<dwCurrLevel; i++)
            printf("  ");
        printf(" |\n");

        printf("\t");
        for (i=0; i<dwCurrLevel; i++)
            printf("  ");
        printf(" +");

        if ( pCurrBlock->nBlockNum < 10 )
            printf("[Block#%2d, Level:%d]\n", pCurrBlock->nBlockNum, dwCurrLevel);
        else
            printf("[Block#%3d, Level:%d]\n", pCurrBlock->nBlockNum, dwCurrLevel);
            
        dwLevelsVisited = 0;
        ChkDR(_HdsTraverseBlocksInPreOrder(pCFG, pCurrBlock, pCurrBlock, &dwLevelsVisited, &fResult));
    }


ErrorExit:        

    if ( pCurrBlock )
        _Hds_free(pHDS, pCurrBlock);

    return dr;
}




/**********************************************************************
** Function:    DoDumpNamespaces
** Synopsis:    
** Arguments:   [pHDS] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT DoDumpNamespaces(
    DRM_HDS_CONTEXT *pContext,
    EDumpMode        eMode)
{
    DRM_RESULT                dr=DRM_SUCCESS;
    _HdsContext              *pHDS=(_HdsContext*)pContext;
    DRM_HDS_ENUM_CONTEXT      EnumContext;
    DRM_HDS_NAMESPACE_CONTEXT oNsStoreCFG;
    DRM_DWORD                 dwCount=0;

    /* no namespace store exist ==> no namespace found */
    if ( pHDS->oSRN.nNsStoreRootBlockNum == 0 )     
    {
        printf("No Namespace(s) found.\n");
        goto ErrorExit;
    }

    ChkDR(_HdsInitNsContext(pHDS, (_NsContext *)&oNsStoreCFG, NULL, 
        pHDS->oSRN.nNsStoreRootBlockNum, NsStoreNumofChildren));
    ChkDR(DRM_HDS_InitSlotEnum(&oNsStoreCFG, NULL, eDRM_HDS_LOCKSHARED, &EnumContext));

    while (TRUE)
    {
        DRM_HDS_SLOT_CONTEXT SlotContext;
        _NSEntry *pNsStoreEntry;
        DRM_DWORD cbEntry;
        DRM_DWORD cbRead=0;

        dr = DRM_HDS_SlotEnumNext(&EnumContext, &SlotContext, NULL, NULL, &cbEntry);
        if (dr == DRM_E_NOMORE)
        {
            dr = DRM_SUCCESS;
            break;
        }
        ChkDR(dr);

        dwCount++;
        if (dwCount==1)
        {
            printf("\t[Namespace]\n\n");
        }            

        pNsStoreEntry = (_NSEntry*)OEM_malloc(cbEntry);
        ChkDR(DRM_HDS_SlotRead(&SlotContext, cbEntry, (DRM_BYTE *)pNsStoreEntry, &cbRead));
        if ( cbRead != cbEntry )
        {
            ChkDR(DRM_E_FILEREADERROR);
        }

        if (eMode == eDumpRaw )
        {
            _PrintHexString("\t[Namespace ID]\t", "\n", pNsStoreEntry->bNSName, 
                cbEntry - SIZEOF(_NSEntry));
        }
        else
        {
            printf("\t[Namespace ID]\n");
            _PrintHexFormated(pNsStoreEntry->bNSName, cbEntry - SIZEOF(_NSEntry));
        }
        
        printf("\t[# of Children blocks]\t%d\n", pNsStoreEntry->wMaxNumChildren);
        printf("\t[Root block#]\t%d\n\n", pNsStoreEntry->nNSRBlockNum);
        OEM_free(pNsStoreEntry);
    }

    if (dwCount==0)
    {
        printf("No Namespace(s) found.\n");
    }
    
ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    DoDumpChildblock
** Synopsis:    
** Arguments:   [pContext] -- 
**              [dwBlocknum] 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
DoDumpChildblock(
    _HdsContext   *pHDS,
    DRM_DWORD      dwBlocknum,
    DRM_BYTE      *pBlockBuff,
    _CommBlockHDR *pCcommonBlockHdr,
    DRM_DWORD      cbCommonBlockHdr,
    EDumpMode      eMode)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _CommBlockHDR *pChildBlock=NULL; 
    DRM_BOOL fValidBlock=FALSE;
    DRM_DWORD dwPayloadBeg=0;
    DRM_DWORD dwPayloadSize=0;
    DRM_DWORD dwNumChildren=0;
    DRM_DWORD i=0;
    _ChildBlockFileHDR *pChildBlockHeader=(_ChildBlockFileHDR*)(pBlockBuff + cbCommonBlockHdr);

    ChkArg(pHDS && pBlockBuff);
    
    printf("\t[Free payload size] \t%d\n", pChildBlockHeader->nFreeMem);

    fValidBlock = _ParseChildBlock(pHDS, pBlockBuff, &dwPayloadBeg, &dwPayloadSize, &dwNumChildren, cbCommonBlockHdr);
    if ( !fValidBlock )
    {
        printf("\n\t*** Corrupted block ***\n\n");
        printf("\t[Child Block (Header & Payload]\n");
         _PrintHexFormated(&pBlockBuff[cbCommonBlockHdr], pHDS->oSRN.dwBlockSize - cbCommonBlockHdr);    

         return DRM_SUCCESS;
    }

    /* verify the block hash value */
    {
        DRM_RESULT dr2=DRM_SUCCESS;
        _NsContext Cfg;

        ChkDR(_HdsInitNsContext(pHDS, &Cfg, NULL, 0, (DRM_WORD)dwNumChildren));  /* some parameters are misiing, but it's okay here */
        ChkDR(_HdsAllocBlockBuffer(&Cfg, eCHILDBLOCK, &pChildBlock));
        dr2 = _HdsLoadBlockHDR(&Cfg, dwBlocknum, &pChildBlock);
        if ( dr2 == DRM_E_HASHMISMATCH )
            printf("\n\t** Block hash value mismatched **\n\n");
    }

    /* dump the child alloctable */
    printf("\t[Child AllocTable]\n\t ");
    for (i=0; i<dwNumChildren; i++)
    {
        printf("%5d ", i);
    }
    printf("\n\t ");
    for (i=0; i<dwNumChildren; i++)
    {
        printf("%5d ", _GetChildBlockNum(pHDS, pChildBlockHeader->bChildAllocTable, i));
    }
    printf("\n");

    /* dump payload */
    printf("\t[Payload]\n");
    switch (eMode )
    {
        case eDumpRaw:
            /* dump the payload in raw hex */
            _PrintHexFormated(&pBlockBuff[dwPayloadBeg], dwPayloadSize);    
            break;

        case eDumpChar:
        case eDumpHex:
            /* parse the payload and dump it per slot in char or hex */
            _PrintSlots(pHDS, dwBlocknum, &pBlockBuff[dwPayloadBeg], dwPayloadSize, 
                pChildBlockHeader->nFreeMem, eMode); 
            break;
        default:
            break;
    }

    printf("\n");

ErrorExit:
    if ( pChildBlock )
        _Hds_free(pHDS, pChildBlock);

    return dr;
}

/**********************************************************************
** Function:    DoDumpDatablock
** Synopsis:    
** Arguments:   [pContext] -- 
**              [dwBlocknum] 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
DoDumpDatablock(
    IN _HdsContext *pHDS,
    DRM_DWORD       dwBlocknum,
    IN DRM_BYTE    *pBlockBuff,
    _CommBlockHDR  *pCcommonBlockHdr,
    DRM_DWORD       cbCommonBlockHdr,
    IN EDumpMode    eMode,
    OUT DRM_DWORD  *pdwCascadingBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _CommBlockHDR *pDataBlock=NULL; 
    DRM_DWORD dwPayloadBeg=0;
    DRM_DWORD dwPayloadSize=0;
    _DataBlockFileHDR *pDataBlockHeader=(_DataBlockFileHDR*)(pBlockBuff + cbCommonBlockHdr);

    ChkArg(pHDS && pBlockBuff);
    
    printf("\t[Cascading Block#]\t%d\n", pDataBlockHeader->nCascadingBlockNum);

    /* dump payload */
    dwPayloadBeg = cbCommonBlockHdr + SIZEOF(_DataBlockFileHDR);
    dwPayloadSize = pHDS->oSRN.dwBlockSize - dwPayloadBeg;

    /* verify the block hash value */
    {
        DRM_RESULT dr2=DRM_SUCCESS;
        _NsContext Cfg;

        ChkDR(_HdsInitNsContext(pHDS, &Cfg, NULL, 0, 0));  /* some parameters are misiing, but it's okay here */
        ChkDR(_HdsAllocBlockBuffer(&Cfg, eDATABLOCK, &pDataBlock));
        dr2 = _HdsLoadBlockHDR(&Cfg, dwBlocknum, &pDataBlock);
        if ( dr2 == DRM_E_HASHMISMATCH )
            printf("\n\t** Block hash value mismatched **\n\n");
    }
    
    printf("\t[Payload]\n");
    switch (eMode )
    {
        case eDumpRaw:
        case eDumpHex:
            /* dump the payload in raw hex */
            _PrintHexFormated(&pBlockBuff[dwPayloadBeg], dwPayloadSize);    
            break;

        case eDumpChar:
            _PrintCharString("\t ", "\n", &pBlockBuff[dwPayloadBeg], dwPayloadSize);
            break;
        default:
            break;
    }

    printf("\n");

    if ( pdwCascadingBlock )
        *pdwCascadingBlock = pDataBlockHeader->nCascadingBlockNum;

ErrorExit:
    if ( pDataBlock )
        _Hds_free(pHDS, pDataBlock);

    return dr;
}


/**********************************************************************
** Function:    DoDumpBlock
** Synopsis:    
** Arguments:   [pContext] -- 
**              [dwBlocknum] 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
DoDumpBlock(
    DRM_HDS_CONTEXT *pContext,
    DRM_DWORD dwBlocknum,
    EDumpMode eMode)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HdsContext *pHDS = (_HdsContext *)pContext;
    DRM_BYTE *pBlockBuff=NULL;
    DRM_DWORD dwFilePos;
    DRM_DWORD dwNumberBytesIO;
    _CommBlockHDR commonBlockHdr;
    DRM_DWORD     cbCommonBlockHdr=0;

    ChkArg(pContext);
    ChkMem(pBlockBuff = OEM_malloc(pHDS->oSRN.dwBlockSize));
    
    /* check block# */
    {
        DRM_DWORD nMaxBlockNum=0;

        ChkDR(_HdsFilePos2BlockNum(pHDS, _gdwFileSize, &nMaxBlockNum));
        if ( dwBlocknum >= nMaxBlockNum )
        {
            printf("\n\t** Invalid block#\n");
            printf("\t** Max block#: %d\n", nMaxBlockNum-1);
            goto ErrorExit;
        }
    }

    /* Load the file block in memory */
    ChkDR(_HdsBlockNum2FilePos(pHDS, dwBlocknum, &dwFilePos));

    if (!OEM_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
    {
        ChkDR(DRM_E_FILESEEKERROR);
    }
    if (!_ReadCommonBlockHeader(pHDS->fp, &commonBlockHdr, pHDS->nImagesize_FileBlockHDR, &cbCommonBlockHdr ))
    {
        ChkDR(DRM_E_FILESEEKERROR);
    }

    /* reset file position to read the whole block at a time */
    if (!OEM_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
    {
        ChkDR(DRM_E_FILESEEKERROR);
    }
    if (!OEM_ReadFile(pHDS->fp, pBlockBuff, pHDS->oSRN.dwBlockSize, &dwNumberBytesIO) ||
        dwNumberBytesIO != pHDS->oSRN.dwBlockSize)
    {
        ChkDR(DRM_E_FILEREADERROR);
    }

    printf("\n\t[Block#]\t%d\n", dwBlocknum);
    printf("\t[File pos]\t%d\n", dwFilePos);
    printf("\t[Parent block#]\t%d\n", commonBlockHdr.File._image.nParentBlockNum);
    _PrintTimestamp("\t[Timestamp]\t", "\n", &commonBlockHdr.File._image.ui64TimeStamp);
    _PrintHexString("\t[Hash value]\t", "\n", commonBlockHdr.File._image.bBlockHash, SHA_DIGEST_LEN);
    printf("\t[Block type]\t");

    switch(GET_BYTE( &commonBlockHdr.File._image.bBlockType,0))
    {
        case eCHILDBLOCK:
            printf("CHILD\n");
            DoDumpChildblock(pHDS, dwBlocknum, pBlockBuff, &commonBlockHdr, cbCommonBlockHdr, eMode);
            break;
        case eDATABLOCK:
            printf("DATA\n");
            DoDumpDatablock(pHDS, dwBlocknum, pBlockBuff, &commonBlockHdr, cbCommonBlockHdr, eMode, NULL);
            break;
        case eFREEBLOCK:
            printf("FREE\n");
            DoDumpDatablock(pHDS, dwBlocknum, pBlockBuff, &commonBlockHdr, cbCommonBlockHdr, eMode, NULL);
            break;
        default:
            printf("UNKNOWN\n");
            /* DoDumpRawblock(pHDS, pBlockBuff, eMode); */
            _PrintHexFormated(&pBlockBuff[cbCommonBlockHdr], 
                pHDS->oSRN.dwBlockSize - cbCommonBlockHdr);    
            break;
    }

ErrorExit:

    if ( pBlockBuff )
        OEM_free(pBlockBuff);

    return dr;
}


/*
**
*/
static const DRM_WCHAR *
_FindChar(
    const DRM_WCHAR *pwszString,
    DRM_WCHAR wch)
{
    DRM_DWORD i=0;

    while (*pwszString != wch && *pwszString != g_wchNull)
        ++pwszString;

    if (*pwszString == wch)
        return pwszString;
    else
        return NULL;
}
   

/**********************************************************************
** Function:    DoSlotTrace
** Synopsis:    
** Arguments:   [pContext] -- 
**              [pbNSID] --
**              [pHashkey] -- 
**              [pUniquekey] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
DoSlotTrace(
    DRM_HDS_CONTEXT *pContext,
    DRM_CONST_STRING *pwszParam,
    EDumpMode eMode)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HdsContext *pHDS=(_HdsContext*)pContext;
    DRM_HDS_NAMESPACE_CONTEXT NsContext;
    DRM_DWORD cbData=0;
    DRM_BYTE *pbData = NULL;
    DRM_HDS_SLOT_CONTEXT SlotContext;
    DRM_DWORD cbRead=0;
    _SlotContext *pSlotCtx;
    DRM_BYTE *pBlockBuff=NULL;
    DRM_DWORD dwDatablock=0;
    DRM_HDS_NAMESPACE NSID;
    DRM_HDS_HASHKEY Hashkey;
    DRM_HDS_UNIQUEKEY Uniquekey;
    const DRM_WCHAR *pParam = pwszParam->pwszString;
    const DRM_WCHAR *pDelimiter=NULL;
    DRM_DWORD dwNumberBytesIO;

    ChkArg(pContext && pwszParam);

    /* parse namespaceID */
    pDelimiter = _FindChar(pParam, g_wchForwardSlash);
    if (pDelimiter==NULL)
    {
        printf("Invalid argument.\n");
        ChkArg(FALSE);
    }
    ChkDR( _PrepareNamespaceID(pParam, (DRM_DWORD)(pDelimiter - pParam), &NSID) );

    /* parse KID */
    pParam = pDelimiter+1;
    pDelimiter = _FindChar(pParam, g_wchForwardSlash);
    if (pDelimiter==NULL)
    {
        printf("Invalid argument.\n");
        ChkArg(FALSE);
    }
    ChkDR( _PrepareHashKey(pParam, (DRM_DWORD)(pDelimiter - pParam), &Hashkey) );

    /* parse KID */
    pParam = pDelimiter+1;
    if ( wcslen(pParam) == 0 )
    {
        printf("Invalid argument.\n");
        ChkArg(FALSE);
    }
    ChkDR( _PrepareUniqueKey(pParam, wcslen(pParam), &Uniquekey) );

    /* trace opening the namespace */
    printf("\n\t[Namespace Hashpath]\n");
    dr = DRM_HDS_OpenNamespace( pContext, 
                                &NSID, 
                                eDRM_HDS_OPEN_EXISTING,
                                0,
                                &NsContext);
    if ( DRM_FAILED(dr) )
        goto ErrorExit;

    /* trace opening the slot */
    printf("\n\t[Slot Hashpath]\n");
    dr = DRM_HDS_OpenSlot(&NsContext, eDRM_HDS_OPEN_EXISTING, &Hashkey, 
       &Uniquekey, NULL, &cbData, &SlotContext);
    if ( DRM_FAILED(dr) )
        goto ErrorExit;
    
    /* display the slot */
    pbData = OEM_malloc(cbData);
    dr = DRM_HDS_SlotRead(&SlotContext, cbData, pbData, &cbRead);
    if ( DRM_FAILED(dr) )
        goto ErrorExit;

    pSlotCtx = (_SlotContext *)&SlotContext;
    printf("\n\t[Slot Info]\n");
    printf("\t[Size]\t\t\t%d\n", cbData);
    printf("\t[Pos in CHILD block]\t%d\n", pSlotCtx->dwSlotPosInBlock);
    if ( pSlotCtx->dwFirstDataBlockNum == 0 )
    {
        printf("\t[Payload]\n");
        if ( eMode == eDumpChar )
            _PrintCharString("\t ", "\n", pbData, cbData);
        else
            _PrintHexFormated(pbData, cbData);
    }
    else
    {
        printf("\t[First DATA Block#]\t%d\n\n", pSlotCtx->dwFirstDataBlockNum);

        /* load and display the content in DATA blocks */
        dwDatablock = pSlotCtx->dwFirstDataBlockNum;
        pBlockBuff = OEM_malloc(pHDS->oSRN.dwBlockSize);
        while (dwDatablock)
        {
            DRM_DWORD dwFilePos;
            _CommBlockHDR commonBlockHdr;
            DRM_DWORD     cbCommonBlockHdr=0;
            
            /* Load the file block in memory */
            ChkDR(_HdsBlockNum2FilePos(pHDS, dwDatablock, &dwFilePos));
            if (!OEM_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
            {
                ChkDR(DRM_E_FILESEEKERROR);
            }
            if (!_ReadCommonBlockHeader(pHDS->fp, &commonBlockHdr, pHDS->nImagesize_FileBlockHDR, &cbCommonBlockHdr ))
            {
                ChkDR(DRM_E_FILESEEKERROR);
            }

            /* reset file position to load the whole block at a time */
            if (!OEM_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
            {
                printf("\n** File IO error ** \n");
                ChkDR(DRM_E_FILEREADERROR);
            }
            if (!OEM_ReadFile(pHDS->fp, pBlockBuff, pHDS->oSRN.dwBlockSize, &dwNumberBytesIO) ||
                dwNumberBytesIO != pHDS->oSRN.dwBlockSize)
            {
                printf("\n** File IO error ** \n");
                ChkDR(DRM_E_FILEREADERROR);
            }
        
            printf("\t[DATA Block#]\t%d\n", dwDatablock);
            printf("\t[Parent block#]\t%d\n", commonBlockHdr.File._image.nParentBlockNum);
            _PrintTimestamp("\t[Timestamp]\t", "\n", &commonBlockHdr.File._image.ui64TimeStamp);
            _PrintHexString("\t[Hash value]\t", "\n", commonBlockHdr.File._image.bBlockHash, SHA_DIGEST_LEN);

            switch(GET_BYTE(&commonBlockHdr.File._image.bBlockType,0))
            {
                case eDATABLOCK:
                    DoDumpDatablock(pHDS, dwDatablock, pBlockBuff, &commonBlockHdr, cbCommonBlockHdr, eMode, &dwDatablock);
                    break;
                case eCHILDBLOCK:
                    printf("\n** Incorrect block type: CHILD **\n** Aborting **\n");
                    goto ErrorExit;
                case eFREEBLOCK:
                    printf("\n** Incorrect block type: FREE **\n** Aborting **\n");
                    goto ErrorExit;
                default:
                    printf("UNKNOWN\n");
                    goto ErrorExit;
            }
        }
    }
    
ErrorExit:
    if ( pBlockBuff )
        OEM_free(pBlockBuff);
    if ( pbData )
        OEM_free(pbData);

    return dr;
}


/**********************************************************************
** Function:    DoDumpSRN
** Synopsis:    
** Arguments:   [pHDS] -- 
**              [dwDumpFreeBlocks] 0 = no, 1=brief, 2=detail
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
DoDumpSRN(
    DRM_CONST_STRING *pStoreName,
    DRM_BOOL fFreeBlockDetail)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_RESULT dr2=DRM_SUCCESS;
    DRM_HDS_CONTEXT oContext;
    DRM_DWORD dwStoreVersion;
    DRM_DWORD dwFreeBlocknum;
    DRM_BYTE *pBlockBuff=NULL;
    DRM_WCHAR wszDeviceStoreName[DRM_MAX_PATH] = {0};
    OEM_FILEHDL fp = OEM_INVALID_HANDLE_VALUE;
    _HdsContext *pHDS = (_HdsContext *)&oContext;
    DRM_DWORD nBlockNum=0;
    DRM_DWORD dwNumberOfBytesIO;

    ZEROMEM(wszDeviceStoreName, SIZEOF(wszDeviceStoreName));
    wcsncpy(wszDeviceStoreName, pStoreName->pwszString, pStoreName->cchString);

    /* read the version # */
    fp = OEM_OpenFile(wszDeviceStoreName, OEM_GENERIC_READ,OEM_FILE_SHARE_READ, 
        OEM_OPEN_EXISTING, OEM_ATTRIBUTE_NORMAL);
    if (fp != OEM_INVALID_HANDLE_VALUE)
    {
        if (OEM_ReadFile (fp, &dwStoreVersion, SIZEOF (DRM_DWORD), &dwNumberOfBytesIO)
        &&  dwNumberOfBytesIO == SIZEOF (DRM_DWORD))
        {
        }
        else
        {
            ChkDR (DRM_E_FILEREADERROR);
        }
        
        OEM_CloseFile (fp);
    }
    else
    {
        ChkDR (DRM_E_FILEREADERROR);
    }
    
    dr2 = _OpenStore(pStoreName, &oContext);
    if ( DRM_FAILED(dr2) && dr2!=DRM_E_HASHMISMATCH )
    {
        ChkDR(dr2);
    }

    if ( !fFreeBlockDetail )
    {
        /* dump the details in SRN */
        printf("Super Root Node:\n\n");
        printf("\t[Store version] \t%X\n", dwStoreVersion);

        ChkDR(_HdsFilePos2BlockNum(pHDS, _gdwFileSize, &nBlockNum));
        printf("\t[# of Blocks]\t\t%d\n", nBlockNum-1);
        
        _PrintHexString("\t[Hash value] \t\t", "\n", pHDS->oSRN.bSRNHash, SHA_DIGEST_LEN);
        printf("\t[SRN size] \t\t%d\n", pHDS->oSRN.dwSRNSize);
        printf("\t[Block size] \t\t%d\n", pHDS->oSRN.dwBlockSize);
        printf("\t[Block num type] \t");
        switch(pHDS->oSRN.eBlockNumType)
        {
            case eDRM_HDSBLKNUM_WORD:
                printf("WORD (0 - 65,535)\n");
                break;
            case eDRM_HDSBLKNUM_DWORD:
                printf("DWORD (0 - 4,294,967,295)\n");
                break;
            default:
                printf("UNKNOWN\n");
                break;
        }

        _PrintTimestamp("\t[Timestamp] \t\t", "\n", &pHDS->oSRN.ui64Timestamp);
        if ( pHDS->oSRN.nFreeListHead == 0 )
            printf("\t[First free block] \tnone\n");
        else
            printf("\t[First free block] \t%d\n", pHDS->oSRN.nFreeListHead);
            
        printf("\t[NS store block#] \t%d\n\n", pHDS->oSRN.nNsStoreRootBlockNum);
    }

    else if ( fFreeBlockDetail && pHDS->oSRN.nFreeListHead==0 )
    {
        printf("\t[First free block] \tnone\n");
    }
    
    else    
    {
        DRM_DWORD dwNumberBytesIO;
        printf("\t[First free block#]\t%d\n\n", pHDS->oSRN.nFreeListHead);
    
        /* load and display the content in DATA blocks */
        dwFreeBlocknum = pHDS->oSRN.nFreeListHead;
        pBlockBuff = OEM_malloc(pHDS->oSRN.dwBlockSize);
        
        while (dwFreeBlocknum)
        {
            DRM_DWORD dwFilePos;
            _CommBlockHDR commonBlockHdr;
            DRM_DWORD     cbCommonBlockHdr=0;
            
            /* Load the file block in memory */
            ChkDR(_HdsBlockNum2FilePos(pHDS, dwFreeBlocknum, &dwFilePos));
            if (!OEM_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
            {
                ChkDR(DRM_E_FILESEEKERROR);
            }
            if (!_ReadCommonBlockHeader(pHDS->fp, &commonBlockHdr, pHDS->nImagesize_FileBlockHDR, &cbCommonBlockHdr ))
            {
                ChkDR(DRM_E_FILESEEKERROR);
            }

            /* reset file position to load the whole block at a time */
            if (!OEM_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
            {
                printf("\n** File IO error ** \n");
                ChkDR(DRM_E_FILESEEKERROR);
            }
            if (!OEM_ReadFile(pHDS->fp, pBlockBuff, pHDS->oSRN.dwBlockSize, &dwNumberBytesIO) ||
                dwNumberBytesIO!=pHDS->oSRN.dwBlockSize)
            {
                printf("\n** File IO error ** \n");
                ChkDR(DRM_E_FILEREADERROR);
            }
        
            printf("\t[Free block#]\t%d\n", dwFreeBlocknum);
            printf("\t[Parent block#]\t%d\n", commonBlockHdr.File._image.nParentBlockNum);
            _PrintTimestamp("\t[Timestamp]\t", "\n", &commonBlockHdr.File._image.ui64TimeStamp);
            _PrintHexString("\t[Hash value]\t", "\n", commonBlockHdr.File._image.bBlockHash, SHA_DIGEST_LEN);
            
            switch(GET_BYTE(&commonBlockHdr.File._image.bBlockType,0))
            {
                case eFREEBLOCK:
                    DoDumpDatablock(pHDS, dwFreeBlocknum, pBlockBuff, &commonBlockHdr, cbCommonBlockHdr, eDumpRaw, &dwFreeBlocknum);
                    break;
                case eCHILDBLOCK:
                    printf("\n** Incorrect block type: CHILD **\n** Aborting **\n");
                    goto ErrorExit;
                case eDATABLOCK:
                    printf("\n** Incorrect block type: DATA **\n** Aborting **\n");
                    goto ErrorExit;
                default:
                    printf("UNKNOWN\n");
                    goto ErrorExit;
            }
        }
    }

    if ( dr2 == DRM_E_HASHMISMATCH )
    {
        printf("\n\t** Hash value mismatched. **\n\n");
    }
    
    ChkDR(DRM_HDS_CloseStore(&oContext));
    ChkDR(DRM_HDS_Uninit(&oContext));

ErrorExit:
    if ( pBlockBuff )
        OEM_free(pBlockBuff);
    
    return dr;
}


/*************************************************************************/
void
DoMenu()
{
    printf("usage: chkhds -option -s:DataStore\n\n");
    printf("Options: \n");
    printf("  -?                  display this help menu\n");
    printf("  -r                  display the store root node\n");
    printf("  -f                  display the details of free block list\n");
    printf("  -d[:r|h]            display a directory of namespace(s) found in the store.\n");
    printf("                      Optional parameters:\n");
    printf("                          r: dump payload in raw format.\n");
    printf("                          h: dump payload by slot in hex format.\n");
    printf("  -b:##[,r|h|c]       display content of a specific block.\n");
    printf("                      Optional parameters:\n");
    printf("                          r: dump payload in raw format.\n");
    printf("                          h: dump payload by slot in hex format.\n");
    printf("                          c: dump payload by slot in char format.\n");
    printf("  -t:NamespaceID/Hashkey/Uniquekey[,r|h|c]\n");
    printf("                      Trace how a slot is located along the hash path.\n");
    printf("                      Namespace ID, Hashkey and Uniquekey must be \n");
    printf("                      specified in Hex and separated using a slash(/).\n");
    printf("                      Optional parameters:\n");
    printf("                          r: dump payload in raw format.\n");
    printf("                          h: dump payload by slot in hex format.\n");
    printf("                          c: dump payload by slot in char format.\n");
    printf("  -n:NamespaceID      display the namespace in a tree format. \n");
    printf("                      Namespace ID must be specified in Hex format\n");
    printf("  -s:DataStore        specify the Data Store to use. If not given, \n");
    printf("                      the default file name is used.\n");
}


/*************************************************************************/
static DRM_RESULT
Dispatch(
    DRM_INT argc, 
    DRM_WCHAR *argv[])
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_WCHAR wchOptionChar, wchDataStoreOption;
    DRM_CONST_STRING wszParam, wszDataStore={0,0};
    DRM_CONST_STRING wszExtra, wszExtra2;
    DRM_HDS_CONTEXT oContext;
    DRM_DWORD dwBlocknum=0;
    
    if ( argc == 1 )
    {
        goto ShowMenu;
    }

    /* parse the option */
    if (!DRM_CMD_ParseCmdLine(argv[1], &wchOptionChar, &wszParam, &wszExtra))
    {
        goto ShowMenu;
    }

    /* parse the DataStore path */
    if ( argc >= 3 )
    {
        if ( !DRM_CMD_ParseCmdLine(argv[2], &wchDataStoreOption, &wszDataStore, &wszExtra2))
        {
            goto ShowMenu;
        }
            
        if ( (wchDataStoreOption != WCHAR_CAST('s') && wchDataStoreOption != WCHAR_CAST('S'))
          || wszExtra2.cchString != 0 
          || wszDataStore.pwszString == NULL )
        {
            goto ShowMenu;
        }
    }

    /* dispatch the option */
    switch(towlower(wchOptionChar))
    {
        /* "-?": Show help text */
        case WCHAR_CAST('?'):
            goto ShowMenu;

        /* "-r": Dump SRN */
        case WCHAR_CAST('r'):
            if ( wszParam.cchString > 0 )
            {
                goto ShowMenu;
            }
            
            ChkDR(DoDumpSRN(&wszDataStore, FALSE));
            break;

        /* "-f": Dump Free block list */
        case WCHAR_CAST('f'):
            if ( wszParam.cchString > 0 )
            {
                goto ShowMenu;
            }

            ChkDR(DoDumpSRN(&wszDataStore, TRUE));
            break;

        /* "-n[:r|h]": Dump namespaces */
        case WCHAR_CAST('d'):
            ChkDR(_OpenStore(&wszDataStore, &oContext));
            if ( wszParam.cchString == 0 )
            {
                ChkDR(DoDumpNamespaces(&oContext, eDumpRaw));
            }
            else if ( wszParam.cchString == 1 )
            {
                if ( towlower(wszParam.pwszString[0]) == WCHAR_CAST('h') )
                {
                    ChkDR(DoDumpNamespaces(&oContext, eDumpHex));
                }
                else if ( towlower(wszParam.pwszString[0]) == WCHAR_CAST('r') )
                {
                    ChkDR(DoDumpNamespaces(&oContext, eDumpRaw));
                }
                else
                {
                    goto ShowMenu;
                }
            }
            else
            {
                goto ShowMenu;
            }

            ChkDR(DRM_HDS_CloseStore(&oContext));
            ChkDR(DRM_HDS_Uninit(&oContext));
            break;

        /* "-b:##[,r|h|c]": Dump block */
        case WCHAR_CAST('b'):
            if (wszParam.cchString==0)
            {
                goto ShowMenu;
            }

            ChkDR(_OpenStore(&wszDataStore, &oContext));
            wcsntol(wszParam.pwszString, wszParam.cchString, (DRM_LONG *) &dwBlocknum);
            if ( wszExtra.cchString == 0 )
            {
                ChkDR(DoDumpBlock(&oContext, dwBlocknum, eDumpRaw));
            }
            else if ( wszExtra.cchString == 1 )
            {
                if ( towlower(wszExtra.pwszString[0]) == WCHAR_CAST('h'))
                {
                    ChkDR(DoDumpBlock(&oContext, dwBlocknum, eDumpHex));
                }
                else if (towlower(wszExtra.pwszString[0]) == WCHAR_CAST('r'))
                {
                    ChkDR(DoDumpBlock(&oContext, dwBlocknum, eDumpRaw));
                }
                else if (towlower(wszExtra.pwszString[0]) == WCHAR_CAST('c'))
                {
                    ChkDR(DoDumpBlock(&oContext, dwBlocknum, eDumpChar));
                }
                else
                {
                    goto ShowMenu;
                }
            }
            else
            {
                goto ShowMenu;
            }

            ChkDR(DRM_HDS_CloseStore(&oContext));
            ChkDR(DRM_HDS_Uninit(&oContext));
            break;

        /* "-t:NamespaceID/Hashkey/Uniquekey[,r|h|c]": Trace slot */
        case WCHAR_CAST('t'):
            if (wszParam.cchString==0)
            {
                goto ShowMenu;
            }

            ChkDR(_OpenStore(&wszDataStore, &oContext));
            if ( wszExtra.cchString == 0 )
            {
                ChkDR(DoSlotTrace(&oContext, &wszParam, eDumpRaw));
            }
            else if ( wszExtra.cchString == 1 )
            {
                if (towlower(wszExtra.pwszString[0]) == WCHAR_CAST('h'))
                {
                    ChkDR(DoSlotTrace(&oContext, &wszParam, eDumpHex));
                }
                else if (towlower(wszExtra.pwszString[0]) == WCHAR_CAST('r'))
                {
                    ChkDR(DoSlotTrace(&oContext, &wszParam, eDumpRaw));
                }
                else if (towlower(wszExtra.pwszString[0]) == WCHAR_CAST('c'))
                {
                    ChkDR(DoSlotTrace(&oContext, &wszParam, eDumpChar));
                }
                else
                {
                    goto ShowMenu;
                }
            }
            else
            {
                goto ShowMenu;
            }

            ChkDR(DRM_HDS_CloseStore(&oContext));
            ChkDR(DRM_HDS_Uninit(&oContext));
            break;

        /* "-s:NamespaceID": Sketch namespace tree */
        case WCHAR_CAST('n'):
            if (wszParam.cchString==0 || wszExtra.cchString!=0)
            {
                goto ShowMenu;
            }
            else
            {
                DRM_HDS_NAMESPACE NSID;

                ChkDR(_OpenStore(&wszDataStore, &oContext));
                ChkDR( _PrepareNamespaceID(wszParam.pwszString, wszParam.cchString, &NSID) );
                ChkDR(DoNamespaceTreeSketch(&oContext, &NSID));
                ChkDR(DRM_HDS_CloseStore(&oContext));
                ChkDR(DRM_HDS_Uninit(&oContext));
            }
            break;

        default:
            goto ShowMenu;
    }

    goto ErrorExit;

ShowMenu:
    DoMenu();

ErrorExit:
    if ( DRM_FAILED(dr) )
        printf("Error: 0x%08X\n", dr);
    
    return dr;
}


/*************************************************************************
*   
*   Console Program Main Entry  Point
*
**************************************************************************/

DRM_INT DRM_API wmain(int argc, DRM_WCHAR* argv[])
{
    printf("Microsoft (R) Hashed Data Store Checker version %d.%d\n", _majorVersion, _minorVersion);
    printf("Copyright (C) Microsoft Corporation. All rights reserved.\n\n");
    
    DRMSIZEASSERT( SIZEOF(DRM_HDS_ENUM_CONTEXT), CALC_MAXENUMCONTEXTLEN );
    DRMSIZEASSERT( SIZEOF( _NsContext ), SIZEOF( DRM_HDS_NAMESPACE_CONTEXT ) );

    Dispatch(argc, argv);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\devicedevcert.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcontextsizes.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmxmlparser.h>
#include <drmdevcert.h>
#include <drmpkcrypto.h>
#include <oemimpl.h>


#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS

/*********************************************************************
**
**  Function:  _VerifySymmerticSignature
**
**  Synopsis:  Verifies the symmtric signature of the device.  This uses the GCPrivkey.
**
**  Arguments:  
**     [f_pdstrCert] -- Certificate to verify
*********************************************************************/
static DRM_RESULT _VerifySymmerticSignature( IN DRM_CONST_STRING *f_pdstrCert )
{
    DRM_RESULT       dr               = DRM_SUCCESS;
    PRIVKEY          GCPrivKey        = { 0 };
    DRM_CONST_STRING dstrCertNodeData = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataNodeData = EMPTY_DRM_STRING; 
    DRM_CONST_STRING dstrInsert       = EMPTY_DRM_STRING;
    DRM_BYTE         rgbSymmSig[__CB_DECL(SHA_DIGEST_LEN)] = {0};
    DRM_DWORD        cbSymmSig = SIZEOF( rgbSymmSig );

    /* Extract the symmertic signature and verify it */
    ChkDR( DRM_XML_GetSubNode( f_pdstrCert, 
                              &g_dstrTagCertificate, 
                              &g_dstrAttributeType, 
                              &g_dstrTagDevice, 
                               0, 
                               NULL, 
                              &dstrCertNodeData, 
                               1) );
    
    ChkDR( DRM_XML_GetNode( &dstrCertNodeData, 
                            &g_dstrTagData, 
                             NULL, 
                             NULL, 
                             0, 
                            &dstrDataNodeData, 
                             NULL) );

    ChkDR( DRM_XML_GetNode( &dstrCertNodeData, 
                            &g_dstrTagSymSig, 
                             NULL, 
                             NULL, 
                             0, 
                             NULL, 
                            &dstrInsert));


    ChkDR( DRM_B64_DecodeW( &dstrInsert, &cbSymmSig, rgbSymmSig, 0 ) );
                
    ChkDR( OEM_GetGroupCertPrivateKey( &GCPrivKey ) );
    ChkDR( DRM_PK_SymmetricVerify( (DRM_BYTE*)&GCPrivKey,
                                    SIZEOF( GCPrivKey ),
                                    PB_DSTR(&dstrDataNodeData),
                                    CB_DSTR(&dstrDataNodeData),
                                    rgbSymmSig ) );
    dr = DRM_SUCCESS;
ErrorExit:
    ZEROMEM( &GCPrivKey, sizeof( PRIVKEY ) );
    return dr;
}

#endif /* DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS */

/* =============================================================================
** Function:    DRM_DC_CreateDevcert
** Synopsis:    Create Devcert from given DevcertTemplate
** Arguments:   [pDevCertTemplate] -- devcert template string
**              [f_pcontextCRYP]   -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
** =============================================================================
*/
DRM_RESULT DRM_API DRM_DDC_GetDeviceCertificate(
    IN OUT DRM_STRING         *f_pdstrDevCert,
    IN     DRM_DWORD           f_dwFlags,
    IN OUT DRM_CRYPTO_CONTEXT *f_pcontextCRYP )
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_DWORD        cbDevCert     = 0;
    DRM_DWORD        cchMaxDevCert = 0;
    DRM_DWORD        cchUniqueID   = 0;
    PRIVKEY          GCPrivKey     = { 0 };
    PRIVKEY          FBSigningKey  = { 0 };
    DRM_CONST_STRING dstrCertNodeData = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrDataNodeData = EMPTY_DRM_STRING; 
    DRM_CONST_STRING dstrInsert       = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_DDC_GetDeviceCertificate", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    ChkArg( f_pcontextCRYP != NULL);
    ChkDRMString( f_pdstrDevCert );

    cchMaxDevCert = f_pdstrDevCert->cchString;
    cbDevCert     = CB_DSTR( f_pdstrDevCert );    

    /*First try to get device certificate*/
    dr = OEM_GetDeviceCert( PB_DSTR( f_pdstrDevCert ), &cbDevCert ) ;
    if( DRM_SUCCEEDED( dr ) )
    {
        f_pdstrDevCert->cchString = cbDevCert / SIZEOF( DRM_WCHAR );

        /* return if flag not set */
        if ( !(f_dwFlags & DRM_DCP_VERIFY_DEVCERT ) )
        {
            goto ErrorExit;
        }

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
        dr = _VerifySymmerticSignature( (DRM_CONST_STRING*) f_pdstrDevCert );
#else
        dr = DRM_DCP_VerifyDeviceCert((DRM_CONST_STRING*)f_pdstrDevCert,
                                       DRM_DCP_VERIFY_DEVICE_CERT,
                                       f_pcontextCRYP);
#endif

        if ( DRM_SUCCEEDED(dr) )
        {
            goto ErrorExit;
        }

        /* if we reach here, the devcert is no good and we need to create a new one from template */
    }

    if( !(f_dwFlags & DRM_DCP_CREATE_DEVCERT_IF_NOT_EXISTING) )
    {
        ChkDR( DRM_E_DEVCERTREADERROR );
    }

    /* Certificate didn't exist or no good.  Create one. */

    /* 
    ** Get devcert template. And check the size. If size of Template is 
    ** greater than MAX_DEVICE_CERT_TEMPLATE_SIZE, return error
    */
    cbDevCert = min(MAX_DEVICE_CERT_TEMPLATE_SIZE, cchMaxDevCert * SIZEOF(DRM_WCHAR));
    dr = OEM_GetDeviceCertTemplate( PB_DSTR( f_pdstrDevCert ),  &cbDevCert );
    if( dr == DRM_E_BUFFERTOOSMALL )
    {
        ChkDR( DRM_E_INVALIDDEVICECERTIFICATETEMPLATE );
    }
    else if( DRM_FAILED( dr ) )
    {
        /*Its a fatal error.*/
        ChkDR( DRM_E_DEVCERTREADERROR );
    }
    
    f_pdstrDevCert->cchString = cbDevCert / SIZEOF( DRM_WCHAR );

    /* 
    ** Don't bother to verify the signature of the DAC and GC certificates.
    ** If they are bad there is no recovery anyway.  Upstream applications will 
    ** (PC and WMRM) will validate this before issuing licenses anyway.
    */
    
    /* calc size needed */
    dr = OEM_GetUniqueID(NULL, &cchUniqueID);
    if (dr != DRM_E_BUFFERTOOSMALL)
    {
        ChkDR(dr);
    }
    f_pdstrDevCert->cchString = f_pdstrDevCert->cchString
                              + cchUniqueID                                               /* size of B64 encoded unique id */
                              + CCH_BASE64_EQUIV(PK_ENC_PUBLIC_KEY_LEN)                   /* size of B64 encoded Device Pubkey */
                              + CCH_BASE64_EQUIV(SIZEOF(PRIVKEY) + PK_ENC_CIPHERTEXT_LEN) /* size of B64 encoded encrypted Device Privkey */
                              + CCH_BASE64_EQUIV(SIZEOF(PKCERT))                          /* size of B64 encoded PKCERT */
#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
                              + CCH_BASE64_EQUIV(SHA_DIGEST_LEN)                          /* size of B64 encoded symmetric signature of device/data node */
#endif
                              + CCH_BASE64_EQUIV(PK_ENC_SIGNATURE_LEN);                   /* size of B64 encoded signature of device/data node */
                              
    if ( cchMaxDevCert < f_pdstrDevCert->cchString )
    {
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    /* 
    ** Generate device unique ID and
    ** fill in uniqueID in "DEVCERT/CERTIFICATE type="DEVICE"/DATA/UNIQUEID" 
    */
    ChkDR(DRM_DCP_GetAttribute((DRM_CONST_STRING*)f_pdstrDevCert, DRM_DEVCERT_SERIALNUMBER, NULL, &dstrInsert));
    ChkDR(DRM_UTL_StringRemoveSubString(f_pdstrDevCert, &dstrInsert));
    ChkDR(DRM_UTL_StringInsertBlankSubString( f_pdstrDevCert,
            (DRM_DWORD)(dstrInsert.pwszString - f_pdstrDevCert->pwszString),
            cchUniqueID));
    ChkDR(OEM_GetUniqueID((DRM_WCHAR*)dstrInsert.pwszString, &cchUniqueID));


    /* 
    ** Fill in Pubkey in DEVCERT/CERTIFICATE type="DEVICE"/DATA/PUBLICKEY 
    */
    {
        PUBKEY           GCPubkey = { 0 };       /* parse from GC <DATA>/<PUBLICKEY> */
        DRM_CONST_STRING dstrPubkey  = EMPTY_DRM_STRING; 
        DRM_CONST_STRING dstrPrivkey = EMPTY_DRM_STRING; 
        DRM_DWORD        cbDestination = SIZEOF(GCPubkey);
        DRM_BYTE        *pbTmp = NULL;

        /* locate GC Pubkey */
        ChkDR(DRM_DCP_GetAttribute((DRM_CONST_STRING*)f_pdstrDevCert, DRM_DEVCERT_GROUPCERTPUBKEY, NULL, &dstrInsert));
        DRM_B64_DecodeW(&dstrInsert, &cbDestination, (DRM_BYTE*)&GCPubkey, 0);

        /* Make room for Device Pubkey in DEVCERT/CERTIFICATE type="DEVICE"/DATA/PUBKEY*/
        ChkDR(DRM_DCP_GetAttribute((DRM_CONST_STRING*)f_pdstrDevCert, DRM_DEVCERT_DEVICEPUBKEY, NULL, &dstrPubkey));
        ChkDR(DRM_UTL_StringRemoveSubString(f_pdstrDevCert, &dstrPubkey));        
        ChkDR(DRM_UTL_StringInsertBlankSubString(
                f_pdstrDevCert,
                (DRM_DWORD)(dstrPubkey.pwszString - f_pdstrDevCert->pwszString), 
                CCH_BASE64_EQUIV(PK_ENC_PUBLIC_KEY_LEN)));

        dstrPubkey.cchString = CCH_BASE64_EQUIV(PK_ENC_PUBLIC_KEY_LEN);

        /* Make room for Device Privkey in DEVCERT/CERTIFICATE type="DEVICE"/DATA/KEYDATA */
        ChkDR(DRM_DCP_GetAttribute((DRM_CONST_STRING*)f_pdstrDevCert, DRM_DEVCERT_DEVICEPRIVKEY, NULL, &dstrPrivkey));
        ChkDR(DRM_UTL_StringRemoveSubString(f_pdstrDevCert, &dstrPrivkey));

        dstrPrivkey.cchString = CCH_BASE64_EQUIV(SIZEOF(PRIVKEY));              
        ChkDR(DRM_UTL_StringInsertBlankSubString(
                f_pdstrDevCert,
                (DRM_DWORD)(dstrPrivkey.pwszString - f_pdstrDevCert->pwszString),
                dstrPrivkey.cchString ) );

        /* generate key pair */    
        ChkDR(DRM_PK_GenKeyPair(f_pcontextCRYP->rgbCryptoContext, (PUBKEY*)(dstrPubkey.pwszString), (PRIVKEY*)(dstrPrivkey.pwszString)));
        
        /* Save Device Pubkey in fallback cert
        */
        {
            PKCERT cert={0};
            DRM_CONST_STRING dstrSecurityVersion = EMPTY_DRM_STRING;

            /* locate FALLBACK/SECURITYVERSION */
            ChkDR(DRM_XML_GetSubNode((DRM_CONST_STRING*)f_pdstrDevCert, &g_dstrFallBack, NULL, NULL, 0, NULL, &dstrCertNodeData, 1));
            ChkDR(DRM_XML_GetNode( 
                    &dstrCertNodeData, 
                    &g_dstrTagDataSecVer, 
                    NULL, 
                    NULL,
                    0, 
                    NULL, 
                    &dstrInsert));
            {
                DRM_WORD rgwVersion[VERSION_LEN];
                DRM_INT  i = 0;
                ChkDR( DRM_UTL_GetVersionFromString( dstrInsert.pwszString, dstrInsert.cchString, rgwVersion ) );
                for( i=0; i < VERSION_LEN; i++ )
                {
                    PUT_BYTE(cert.pk.version, i, (DRM_BYTE)rgwVersion[i] );
                }
            }

            /* Make room and sign the data node with GC Privkey */
            ChkDR(DRM_XML_GetSubNode( 
                    (DRM_CONST_STRING*)f_pdstrDevCert, 
                    &g_dstrFallBack, 
                    NULL, 
                    NULL, 
                    0, 
                    NULL, 
                    &dstrCertNodeData, 
                    1));

            ChkDR(DRM_XML_GetNode( 
                    &dstrCertNodeData, 
                    &g_dstrTagCertificate, 
                    &g_dstrRootSigValueVersionTag, 
                    &g_dstrRootSigValueVersionVal, 
                    0, 
                    NULL, 
                    &dstrInsert));

            ChkDR(DRM_UTL_StringRemoveSubString(f_pdstrDevCert, &dstrInsert));
            ChkDR(DRM_UTL_StringInsertBlankSubString(
                    f_pdstrDevCert,
                    (DRM_DWORD)(dstrInsert.pwszString - f_pdstrDevCert->pwszString),
                    CCH_BASE64_EQUIV(SIZEOF(PKCERT))));
            dstrInsert.cchString = CCH_BASE64_EQUIV(PK_ENC_SIGNATURE_LEN);

            MEMCPY(&cert.pk.pk, PB_DSTR(&dstrPubkey), SIZEOF(PUBKEY));
            ChkDR(OEM_GetFallbackSigningKey(&FBSigningKey));

            ChkDR(DRM_PK_Sign( 
                    f_pcontextCRYP->rgbCryptoContext, 
                    &FBSigningKey,
                    (DRM_BYTE *)&cert.pk, 
                    SIZEOF(PK), 
                    cert.sign));
            ZEROMEM((DRM_BYTE*)&FBSigningKey, SIZEOF(PRIVKEY));

            MEMCPY( PB_DSTR(&dstrInsert), &cert, SIZEOF(PKCERT));

            /* B64 encode in place */
            dstrInsert.cchString = CCH_BASE64_EQUIV(SIZEOF(PKCERT));
            ChkDR(DRM_B64_EncodeW( 
                    PB_DSTR(&dstrInsert), 
                    SIZEOF(PKCERT), 
                    (DRM_WCHAR*)dstrInsert.pwszString, 
                    &dstrInsert.cchString, 
                    0));
        }

        /* B64 encode pubkey in place */
        ChkDR(DRM_B64_EncodeW( 
                PB_DSTR(&dstrPubkey), 
                SIZEOF(PUBKEY), 
                (DRM_WCHAR*)dstrPubkey.pwszString,
                &dstrPubkey.cchString,
                0) );
        
        ChkDR(OEM_GetGroupCertPrivateKey(&GCPrivKey));
        ChkDR( DRM_PK_SymmetricCrypt( (DRM_BYTE*)&GCPrivKey, 
                                      SIZEOF(PRIVKEY),
                                      SIZEOF(PRIVKEY),
                                      PB_DSTR(&dstrPrivkey), 
                                      0,
                                      NULL ) );

        ChkDR(DRM_B64_EncodeW(
                PB_DSTR(&dstrPrivkey), 
                SIZEOF(PRIVKEY),
                (DRM_WCHAR*)dstrPrivkey.pwszString, 
                &dstrPrivkey.cchString, 
                0));        

        /* Make room and sign the data node with GC Privkey */
        ChkDR(DRM_XML_GetSubNode( 
                (DRM_CONST_STRING*)f_pdstrDevCert, 
                &g_dstrTagCertificate, 
                &g_dstrAttributeType, 
                &g_dstrTagDevice, 
                0, 
                NULL, 
                &dstrCertNodeData, 
                1));
        
        ChkDR(DRM_XML_GetNode( 
                &dstrCertNodeData, 
                &g_dstrTagMSDRMSignature, 
                NULL, 
                NULL, 
                0, 
                NULL, 
                &dstrInsert));

        ChkDR(DRM_UTL_StringRemoveSubString(f_pdstrDevCert, &dstrInsert));
        ChkDR(DRM_UTL_StringInsertBlankSubString(
                f_pdstrDevCert,
                (DRM_DWORD)(dstrInsert.pwszString - f_pdstrDevCert->pwszString), 
                CCH_BASE64_EQUIV(PK_ENC_SIGNATURE_LEN)));
        dstrInsert.cchString = CCH_BASE64_EQUIV(PK_ENC_SIGNATURE_LEN);

        /* sign the devcert with GC privkey */
        ChkDR(DRM_XML_GetNode(&dstrCertNodeData, &g_dstrTagData, NULL, NULL, 0, &dstrDataNodeData, NULL));

        ChkDR(DRM_PK_Sign( 
                f_pcontextCRYP->rgbCryptoContext,
                &GCPrivKey,
                PB_DSTR(&dstrDataNodeData),
                CB_DSTR(&dstrDataNodeData),
                PB_DSTR(&dstrInsert)));        

        /* B64 encode the signature in place */
        ChkDR(DRM_B64_EncodeW( 
                PB_DSTR(&dstrInsert), 
                PK_ENC_SIGNATURE_LEN, 
                (DRM_WCHAR*)dstrInsert.pwszString, 
                &dstrInsert.cchString, 
                0));

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
        /*
        ** Create the symmetric signature for the device to use 
        */
        ChkDR(DRM_XML_GetSubNode( (DRM_CONST_STRING*)f_pdstrDevCert, 
                                  &g_dstrTagCertificate, 
                                  &g_dstrAttributeType, 
                                  &g_dstrTagDevice, 
                                   0, 
                                   NULL, 
                                  &dstrCertNodeData, 
                                  1));

        ChkDR(DRM_XML_GetNode( &dstrCertNodeData,
                               &g_dstrTagSymSig, 
                                NULL, 
                                NULL, 
                                0, 
                                NULL, 
                               &dstrInsert));

        ChkDR(DRM_UTL_StringRemoveSubString(f_pdstrDevCert, &dstrInsert));
        ChkDR(DRM_UTL_StringInsertBlankSubString( f_pdstrDevCert,
                                      (DRM_DWORD)(dstrInsert.pwszString - f_pdstrDevCert->pwszString), 
                                                 CCH_BASE64_EQUIV(SHA_DIGEST_LEN) ) );
        
        dstrInsert.cchString = CCH_BASE64_EQUIV(SHA_DIGEST_LEN);

        ChkDR(DRM_PK_SymmetricSign( (DRM_BYTE*)&GCPrivKey,
                                    SIZEOF( GCPrivKey ),
                                    PB_DSTR(&dstrDataNodeData),
                                    CB_DSTR(&dstrDataNodeData),
                                    PB_DSTR(&dstrInsert) ) );

        /* B64 encode the signature in place */
        ChkDR(DRM_B64_EncodeW( PB_DSTR(&dstrInsert), 
                               SHA_DIGEST_LEN, 
                   (DRM_WCHAR*)dstrInsert.pwszString, 
                              &dstrInsert.cchString, 
                               0));
#endif
    }

    /* save the devcert on device */
    ChkDR( OEM_SetDeviceCert( 
            PB_DSTR( f_pdstrDevCert ),
            CB_DSTR( f_pdstrDevCert ) ) );
        
ErrorExit:    
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_DDC_GetDeviceCertificate", g_pwszLeavingFunction);

    ZEROMEM(&GCPrivKey,    SIZEOF(PRIVKEY));
    ZEROMEM(&FBSigningKey, SIZEOF(PRIVKEY));

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmbase64.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>

#define CCH_B64_IN_QUARTET  4
#define CB_B64_OUT_TRIO     3

DRM_BYTE g_rgbBase64Decode [] = 
{ 
    /* Note we also accept ! and + interchangably. */
    /* Note we also accept * and / interchangably. */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*   0 -   7 */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*   8 -  15 */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*  16 -  23 */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*  24 -  31 */
    TWO_BYTES(0x00, 0x3E), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*  32 -  39 */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x3f, 0x3e), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x3f), /*  40 -  47 */
    TWO_BYTES(0x34, 0x35), TWO_BYTES(0x36, 0x37), TWO_BYTES(0x38, 0x39), TWO_BYTES(0x3a, 0x3b), /*  48 -  55 */
    TWO_BYTES(0x3c, 0x3d), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*  56 -  63 */
    TWO_BYTES(0x00, 0x00), TWO_BYTES(0x01, 0x02), TWO_BYTES(0x03, 0x04), TWO_BYTES(0x05, 0x06), /*  64 -  71 */
    TWO_BYTES(0x07, 0x08), TWO_BYTES(0x09, 0x0a), TWO_BYTES(0x0b, 0x0c), TWO_BYTES(0x0d, 0x0e), /*  72 -  79 */
    TWO_BYTES(0x0f, 0x10), TWO_BYTES(0x11, 0x12), TWO_BYTES(0x13, 0x14), TWO_BYTES(0x15, 0x16), /*  80 -  87 */
    TWO_BYTES(0x17, 0x18), TWO_BYTES(0x19, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00), /*  88 -  95 */
    TWO_BYTES(0x00, 0x1a), TWO_BYTES(0x1b, 0x1c), TWO_BYTES(0x1d, 0x1e), TWO_BYTES(0x1f, 0x20), /*  96 - 103 */
    TWO_BYTES(0x21, 0x22), TWO_BYTES(0x23, 0x24), TWO_BYTES(0x25, 0x26), TWO_BYTES(0x27, 0x28), /* 104 - 111 */
    TWO_BYTES(0x29, 0x2a), TWO_BYTES(0x2b, 0x2c), TWO_BYTES(0x2d, 0x2e), TWO_BYTES(0x2f, 0x30), /* 112 - 119 */
    TWO_BYTES(0x31, 0x32), TWO_BYTES(0x33, 0x00), TWO_BYTES(0x00, 0x00), TWO_BYTES(0x00, 0x00)  /* 120 - 127 */
};

/* when decode in-place, the decoded string will be the start of the input buffer */

const DRM_DWORD g_fDecodeAllowed = DRM_BASE64_DECODE_IN_PLACE; /* OR in any new supported flags */

DRM_RESULT DRM_API DRM_B64_DecodeW(
    IN const DRM_CONST_STRING *f_pdstrSource,
    IN OUT   DRM_DWORD        *f_pcbDestination, 
       OUT   DRM_BYTE         *f_pbDestination,
    IN       DRM_DWORD         f_fFlags)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchDecode = 0;    
    DRM_DWORD  ichSource = 0;
    DRM_DWORD  ibInsert  = 0;
    DRM_DWORD  ibDest    = 0;
    
    ChkDRMString(f_pdstrSource);    
    ChkArg     ((f_pdstrSource->cchString  % CCH_B64_IN_QUARTET) == 0);
    ChkArg      (f_pcbDestination != NULL);
    ChkArg     ((f_fFlags & ~g_fDecodeAllowed) == 0);

    /* Maximum buffer size needed.     */

    cchDecode = (DRM_DWORD) (((f_pdstrSource->cchString + (CCH_B64_IN_QUARTET - 1)) / CCH_B64_IN_QUARTET) * CB_B64_OUT_TRIO); 

    if (f_pdstrSource->pwszString [f_pdstrSource->cchString  - 1] == g_wchEqual)
    {
        cchDecode--;
        if (f_pdstrSource->pwszString [f_pdstrSource->cchString  - 2] == g_wchEqual)
        {
            cchDecode--;
        }
    }

    if (((cchDecode > *f_pcbDestination) 
       || f_pbDestination == NULL) 
    && (f_fFlags & DRM_BASE64_DECODE_IN_PLACE) == 0)
    {
        *f_pcbDestination = cchDecode;
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }    

    if (f_fFlags & DRM_BASE64_DECODE_IN_PLACE )
    {
        f_pbDestination = (DRM_BYTE *) f_pdstrSource->pwszString;
        ibInsert        = (f_pdstrSource->cchString * SIZEOF(DRM_WCHAR)) - cchDecode;
    }

    *f_pcbDestination = cchDecode;

    for (ichSource  = f_pdstrSource->cchString; 
         ichSource  > 0; 
         ichSource -= CCH_B64_IN_QUARTET)
    {   
        DRM_BYTE rgbOutput [__CB_DECL(CB_B64_OUT_TRIO + 1)] = { 0 };
        
        for (ibDest = 0; 
             ibDest < CB_B64_OUT_TRIO + 1; 
             ibDest++ )
        {
            if (f_pdstrSource->pwszString [ichSource + ibDest - CCH_B64_IN_QUARTET] == g_wchEqual)
            {
                if (ibDest     < 2 
                 || ichSource != f_pdstrSource->cchString)
                {
                    ChkDR (DRM_E_INVALIDARG);
                }
                break;
            }

            PUT_BYTE(rgbOutput, 
                     ibDest,  
                     GET_BYTE(g_rgbBase64Decode, 
                             (DRM_DWORD) NATIVE_WCHAR(f_pdstrSource->pwszString [((ichSource - CCH_B64_IN_QUARTET) + ibDest)])));
        }

        switch (ibDest)
        {
        default: 
            PUT_BYTE(f_pbDestination, 
                     ibInsert  + --cchDecode, 
                     ((GET_BYTE(rgbOutput, 2) & 0x03) << 6) |   GET_BYTE(rgbOutput, 3));
            
            /*fall through*/
            
        case 3:  
            PUT_BYTE(f_pbDestination, 
                     ibInsert  + --cchDecode, 
                     ((GET_BYTE(rgbOutput, 1) & 0x0F) << 4) | ((GET_BYTE(rgbOutput, 2) & 0x3C) >> 2));
            
            /*fall through*/
            
        case 2:  
            PUT_BYTE(f_pbDestination, 
                     ibInsert  + --cchDecode, 
                      (GET_BYTE(rgbOutput, 0)         << 2) | ((GET_BYTE(rgbOutput, 1) & 0x30) >> 4));
        }
    }

    /* move the buffer to start of input buffer */
    if (f_fFlags & DRM_BASE64_DECODE_IN_PLACE)
    {
        DRM_BYT_MoveBytes((DRM_BYTE *) f_pdstrSource->pwszString, 
                           0,
                           f_pbDestination,
                           ibInsert,
                          *f_pcbDestination);
    }

    dr = DRM_SUCCESS;
    
ErrorExit:
    return dr;
}  

DRM_RESULT DRM_API DRM_B64_DecodeA(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrSource,
    IN OUT   DRM_DWORD             *f_pcbDestination, 
       OUT   DRM_BYTE              *f_pbDestination,
    IN       DRM_DWORD              f_fFlags)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cchDecode = 0;    
    DRM_DWORD  ichSource = 0; 
    DRM_DWORD  ichDest   = 0;
    DRM_DWORD  ibDest    = 0;
    
    ChkArg (f_pdasstrSource  != NULL);    
    ChkArg (f_pcbDestination != NULL);
    ChkArg((f_pdasstrSource->m_cch % CCH_B64_IN_QUARTET) == 0);
    ChkArg((f_fFlags & ~g_fDecodeAllowed) == 0);

    cchDecode = (DRM_DWORD) (((f_pdasstrSource->m_cch + (CCH_B64_IN_QUARTET - 1)) / CCH_B64_IN_QUARTET) * CB_B64_OUT_TRIO); /* Maximum buffer size needed.     */

    if (GET_CHAR(f_pszBase,     f_pdasstrSource->m_ich + f_pdasstrSource->m_cch  - 1) == '=')
    {
        cchDecode--;
        if (GET_CHAR(f_pszBase, f_pdasstrSource->m_ich + f_pdasstrSource->m_cch  - 2) == '=')
        {
            cchDecode--;
        }
    }

    if (((cchDecode > *f_pcbDestination) 
       || f_pbDestination == NULL) 
    && (f_fFlags & DRM_BASE64_DECODE_IN_PLACE) == 0)
    {
        *f_pcbDestination = cchDecode;
        ChkDR (DRM_E_BUFFERTOOSMALL);
    }    

    if (f_fFlags & DRM_BASE64_DECODE_IN_PLACE )
    {
        ichDest = f_pdasstrSource->m_ich
                + f_pdasstrSource->m_cch
                - cchDecode;
        
        f_pbDestination = (DRM_BYTE *) f_pszBase;
    }

    *f_pcbDestination = cchDecode;

    for (ichSource  = f_pdasstrSource->m_cch; 
         ichSource  > 0; 
         ichSource -= CCH_B64_IN_QUARTET)
    {   
        DRM_BYTE rgbOutput [__CB_DECL(CB_B64_OUT_TRIO + 1)] = { 0 };
        
        for (ibDest = 0; 
             ibDest < CB_B64_OUT_TRIO + 1; 
             ibDest++ )
        {
            DRM_DWORD ichGet = f_pdasstrSource->m_ich + ichSource + ibDest - CCH_B64_IN_QUARTET;
            if (GET_CHAR(f_pszBase, ichGet) == '=')
            {
                if (ibDest     < 2 
                ||  ichSource != f_pdasstrSource->m_cch)
                {
                    ChkDR (DRM_E_INVALIDARG);
                }
                break;
            }

            PUT_BYTE(rgbOutput, 
                     ibDest,  
                     GET_BYTE(g_rgbBase64Decode, (DRM_DWORD) GET_CHAR(f_pszBase, ichGet)));
        }

        switch (ibDest)
        {
        default: 
            PUT_BYTE(f_pbDestination, 
                     ichDest + --cchDecode, 
                     ((GET_BYTE(rgbOutput, 2) & 0x03) << 6) | GET_BYTE(rgbOutput, 3));
            
            /*fall through*/
            
        case 3:  
            PUT_BYTE(f_pbDestination, 
                     ichDest + --cchDecode, 
                     ((GET_BYTE(rgbOutput, 1) & 0x0F) << 4) | ((GET_BYTE(rgbOutput, 2) &0x3C) >> 2));
            
            /*fall through*/
            
        case 2:  
            PUT_BYTE(f_pbDestination, 
                     ichDest + --cchDecode, 
                     (GET_BYTE(rgbOutput, 0) << 2) | ((GET_BYTE(rgbOutput, 1) & 0x30) >> 4));
        }
    }

    /* move the buffer to start of input buffer */
    if( f_fFlags & DRM_BASE64_DECODE_IN_PLACE )
    {
        DRM_BYT_MoveBytes(f_pbDestination, f_pdasstrSource->m_ich, f_pbDestination, ichDest, *f_pcbDestination);
    }

    dr = DRM_SUCCESS;
    
ErrorExit:
    return dr;
}  


static const DRM_CHAR s_rgchBase64Encoding[] = {
    TWO_BYTES('A', 'B'), TWO_BYTES('C', 'D'), TWO_BYTES('E', 'F'), TWO_BYTES('G', 'H'), TWO_BYTES('I', 'J'), TWO_BYTES('K', 'L'), /* 12 */
    TWO_BYTES('M', 'N'), TWO_BYTES('O', 'P'), TWO_BYTES('Q', 'R'), TWO_BYTES('S', 'T'), TWO_BYTES('U', 'V'), TWO_BYTES('W', 'X'), /* 24 */
    TWO_BYTES('Y', 'Z'), TWO_BYTES('a', 'b'), TWO_BYTES('c', 'd'), TWO_BYTES('e', 'f'), TWO_BYTES('g', 'h'), TWO_BYTES('i', 'j'), /* 36 */
    TWO_BYTES('k', 'l'), TWO_BYTES('m', 'n'), TWO_BYTES('o', 'p'), TWO_BYTES('q', 'r'), TWO_BYTES('s', 't'), TWO_BYTES('u', 'v'), /* 48 */
    TWO_BYTES('w', 'x'), TWO_BYTES('y', 'z'), TWO_BYTES('0', '1'), TWO_BYTES('2', '3'), TWO_BYTES('4', '5'), TWO_BYTES('6', '7'), /* 60 */
    TWO_BYTES('8', '9'), TWO_BYTES('!', '*')            /* 64 */
};

static const DRM_CHAR s_rgchBase64EncodingStandard[] = {
    TWO_BYTES('A', 'B'), TWO_BYTES('C', 'D'), TWO_BYTES('E', 'F'), TWO_BYTES('G', 'H'), TWO_BYTES('I', 'J'), TWO_BYTES('K', 'L'), /* 12 */
    TWO_BYTES('M', 'N'), TWO_BYTES('O', 'P'), TWO_BYTES('Q', 'R'), TWO_BYTES('S', 'T'), TWO_BYTES('U', 'V'), TWO_BYTES('W', 'X'), /* 24 */
    TWO_BYTES('Y', 'Z'), TWO_BYTES('a', 'b'), TWO_BYTES('c', 'd'), TWO_BYTES('e', 'f'), TWO_BYTES('g', 'h'), TWO_BYTES('i', 'j'), /* 36 */
    TWO_BYTES('k', 'l'), TWO_BYTES('m', 'n'), TWO_BYTES('o', 'p'), TWO_BYTES('q', 'r'), TWO_BYTES('s', 't'), TWO_BYTES('u', 'v'), /* 48 */
    TWO_BYTES('w', 'x'), TWO_BYTES('y', 'z'), TWO_BYTES('0', '1'), TWO_BYTES('2', '3'), TWO_BYTES('4', '5'), TWO_BYTES('6', '7'), /* 60 */
    TWO_BYTES('8', '9'), TWO_BYTES('+', '/')            /* 64 */
};

/*
**
*/
DRM_RESULT DRM_API DRM_B64_EncodeA( 
    IN const DRM_BYTE  *f_pbSource,  /* input buffer */
    IN       DRM_DWORD  f_cbSource,  /* input len */
       OUT   DRM_CHAR  *f_pszB64,    /* output char */
    IN OUT   DRM_DWORD *f_pcchEncoded, /* output ch len */
    IN       DRM_DWORD  f_fFlags )
{
    DRM_DWORD cchRequired = 0;
    DRM_DWORD iInput      = 0;
    DRM_DWORD iOutput     = 0;
    DRM_RESULT dr         = DRM_SUCCESS;
    const DRM_CHAR *pszMapping = NULL;

    /*
    ** Null input buffer, null output size pointer, and a nonzero
    ** encoded size with a null output buffer are all invalid
    ** parameters.
    **
    ** Check the size first so that caller can allocate enough output buffer before generating 
    ** the input buffer.
    */

    ChkArg(f_cbSource     > 0
        && f_pbSource    != NULL
        && f_pcchEncoded != NULL);

    if (f_fFlags == 0)
    {
        pszMapping = s_rgchBase64EncodingStandard;
    }
    else if (f_fFlags & DRM_BASE64_ENCODE_WMDRM)
    {
        pszMapping = s_rgchBase64Encoding;
    }
    else
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    cchRequired = CCH_BASE64_EQUIV(f_cbSource);
    
    /* if the buffer is too small or both buffers are NULL, we return the required buffer size */
    
    if ((*f_pcchEncoded < cchRequired) 
    ||    f_pszB64     == NULL)
    {
        *f_pcchEncoded = cchRequired;
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    *f_pcchEncoded = cchRequired;

    /* encoding starts from end of string */

    /*
    ** Convert the input buffer bytes through the encoding table and
    ** out into the output buffer.
    */
    iInput  = (cchRequired / CCH_B64_IN_QUARTET) * CB_B64_OUT_TRIO - CB_B64_OUT_TRIO;
    iOutput =  cchRequired - CCH_B64_IN_QUARTET;

    while (TRUE) 
    {
        const DRM_BYTE uc0 =                               GET_BYTE(f_pbSource, iInput);
        const DRM_BYTE uc1 = ((iInput + 1) < f_cbSource) ? GET_BYTE(f_pbSource, iInput + 1) : 0;
        const DRM_BYTE uc2 = ((iInput + 2) < f_cbSource) ? GET_BYTE(f_pbSource, iInput + 2) : 0;

        PUT_BYTE(f_pszB64, iOutput,     GET_BYTE(pszMapping,   uc0 >> 2));
        PUT_BYTE(f_pszB64, iOutput + 1, GET_BYTE(pszMapping, ((uc0 << 4) & 0x30) | ((uc1 >> 4) & 0xf)));
        PUT_BYTE(f_pszB64, iOutput + 2, GET_BYTE(pszMapping, ((uc1 << 2) & 0x3c) | ((uc2 >> 6) & 0x3)));
        PUT_BYTE(f_pszB64, iOutput + 3, GET_BYTE(pszMapping,                               uc2 & 0x3f));
        
        if (iInput ==0)
        {
            break;
        }

        iOutput -= CCH_B64_IN_QUARTET;
        iInput  -= CB_B64_OUT_TRIO;
    }

    /*
    ** Fill in leftover bytes at the end
    */
    switch (f_cbSource % CB_B64_OUT_TRIO) 
    {
        /*
        ** One byte out of three, add padding and fall through
        */
        case 1:
            PUT_CHAR(f_pszB64, cchRequired - 2,  '=');
        /*
        ** Two bytes out of three, add padding.
        */
        case 2:
            PUT_CHAR(f_pszB64, cchRequired - 1,  '=');
            
            break;
        case 0:
        default:
            break;
    }

    dr = DRM_SUCCESS;
    
ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_B64_EncodeW( 
    IN const DRM_BYTE  *f_pbSource,  /* input buffer */
    IN       DRM_DWORD  f_cbSource,  /* input len */
       OUT   DRM_WCHAR *f_pwszB64,   /* output WCHAR */
    IN OUT   DRM_DWORD *f_pcchEncoded, /* output ch len */
    IN       DRM_DWORD  f_fFlags )
{
    DRM_DWORD cchRequired = 0;
    DRM_DWORD iInput      = 0;
    DRM_DWORD iOutput     = 0;
    DRM_RESULT dr         = DRM_SUCCESS;
    const DRM_CHAR *pszMapping = NULL;

    /*
    ** Null input buffer, null output size pointer, and a nonzero
    ** encoded size with a null output buffer are all invalid
    ** parameters.
    **
    ** Check the size first so that caller can allocate enough output buffer before generating 
    ** the input buffer.
    */

    ChkArg(f_cbSource     > 0
        && f_pbSource    != NULL
        && f_pcchEncoded != NULL);

    if (f_fFlags == 0)
    {
        pszMapping = s_rgchBase64EncodingStandard;
    }
    else if (f_fFlags & DRM_BASE64_ENCODE_WMDRM)
    {
        pszMapping = s_rgchBase64Encoding;
    }
    else
    {
        ChkDR(DRM_E_INVALIDARG);
    }

    cchRequired = CCH_BASE64_EQUIV(f_cbSource);
    
    /* if the buffer is too small or both buffers are NULL, we return the required buffer size */
    
    if ((*f_pcchEncoded < cchRequired) 
    ||    f_pwszB64 == NULL)
    {
        *f_pcchEncoded = cchRequired;
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    *f_pcchEncoded = cchRequired;

    /* encoding starts from end of string */

    /*
    ** Convert the input buffer bytes through the encoding table and
    ** out into the output buffer.
    */
    iInput  = (cchRequired / CCH_B64_IN_QUARTET) * CB_B64_OUT_TRIO - CB_B64_OUT_TRIO;
    iOutput =  cchRequired - CCH_B64_IN_QUARTET;

    while (TRUE) 
    {
        const DRM_BYTE uc0 =                               GET_BYTE(f_pbSource, iInput);
        const DRM_BYTE uc1 = ((iInput + 1) < f_cbSource) ? GET_BYTE(f_pbSource, iInput + 1) : 0;
        const DRM_BYTE uc2 = ((iInput + 2) < f_cbSource) ? GET_BYTE(f_pbSource, iInput + 2) : 0;

        f_pwszB64[iOutput]     = WCHAR_CAST(GET_BYTE(pszMapping,   uc0 >> 2));
        f_pwszB64[iOutput + 1] = WCHAR_CAST(GET_BYTE(pszMapping, ((uc0 << 4) & 0x30) | ((uc1 >> 4) & 0xf)));
        f_pwszB64[iOutput + 2] = WCHAR_CAST(GET_BYTE(pszMapping, ((uc1 << 2) & 0x3c) | ((uc2 >> 6) & 0x3)));
        f_pwszB64[iOutput + 3] = WCHAR_CAST(GET_BYTE(pszMapping,                               uc2 & 0x3f));

        if (iInput ==0)
        {
            break;
        }

        iOutput -= CCH_B64_IN_QUARTET;
        iInput  -= CB_B64_OUT_TRIO;
    }

    /*
    ** Fill in leftover bytes at the end
    */
    switch (f_cbSource % CB_B64_OUT_TRIO) 
    {
        /*
        ** One byte out of three, add padding and fall through
        */
        case 1:
            f_pwszB64 [cchRequired - 2] = g_wchEqual;
            
        /*
        ** Two bytes out of three, add padding.
        */
        case 2:
            f_pwszB64 [cchRequired - 1] = g_wchEqual;
            
            break;
        case 0:
        default:
            break;
    }

    dr = DRM_SUCCESS;
    
ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmblackbox.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBLACKBOX_H__
#define __DRMBLACKBOX_H__


#ifdef __cplusplus
extern "C" {
#endif

#define DRM_PK_BUFFER_MAX   PK_ENC_PLAINTEXT_LEN
#define DRM_MAX_DRMOLDKEYS 20
#define DRMKEYPAIRSIZE (SIZEOF( PUBKEY ) + SIZEOF( PRIVKEY )) 

typedef struct __tagDRM_BB_CONTEXT
{
    /* Make sure the crypto context is the first member in this struct */
    DRM_CRYPTO_CONTEXT                   CryptoContext;
    DRM_DEVICE_CERTIFICATE_CACHED_VALUES cachedCertValues;
    DRM_BOOL                             fInited;
} DRM_BB_CONTEXT;

typedef enum _BB_SUPPORTED_ALGORITHMS
{
    eMSDRM_PK  = 1,  /* The key is encrypted with a ECC public key */
    eMSDRM_CK  = 2,  /* This is a chained license key algorithm. ( DES encrypted ) */
    eMSDRM_SYM = 3   /* The license is symmetrically bound.  This means that is was actually rebound to a symmetric key once is was stored on the device */
} BB_SUPPORTED_ALGORITHMS;

typedef struct __tagDRM_BINDING_INFO
{
    DRM_BYTE   m_rgbContentKey[__CB_DECL(PK_ENC_CIPHERTEXT_LEN)];
    DRM_BYTE   m_rgbChecksum[__CB_DECL(CHECKSUM_LENGTH)];
    DRM_BYTE   m_rgbSignature[__CB_DECL(PK_ENC_SIGNATURE_LEN)];
    PUBKEY     m_oPublKey;
    PUBKEY     m_oLsPublKey;
    DRM_DWORD  m_dwAlgorithm;
} DRM_BINDING_INFO;

DRM_RESULT DRM_API DRM_BBX_Initialize( 
    IN OUT DRM_BB_CONTEXT     *pcontextBB );

DRM_RESULT DRM_API DRM_BBX_GetClientId(
    OUT    CLIENTID       *pClientId,
    IN OUT DRM_BB_CONTEXT *pcontextBB );

DRM_RESULT DRM_API DRM_BBX_Shutdown( 
    IN DRM_BB_CONTEXT *pcontextBB );

DRM_BOOL DRM_API DRM_BBX_CanBind( 
    IN const DRM_BINDING_INFO *rgBindingInfo ,
    IN       DRM_DWORD         dwChainLength,
    IN       DRM_BB_CONTEXT   *pcontextBB );

DRM_RESULT DRM_API DRM_BBX_HashValue(
    IN  const DRM_BYTE       *pbValue,
    IN        DRM_DWORD       cbValue,
    OUT       DRM_BYTE        rgbHashValue [__CB_DECL(SHA_DIGEST_LEN)],
    IN        DRM_BB_CONTEXT *pcontextBB );
    
DRM_BOOL DRM_API DRM_BBX_DecryptLicense(
    IN OUT DRM_BYTE       *pbEncryptedLicense,
    IN     DRM_DWORD       cbEncryptedLicense,
    OUT    DRM_BYTE       *pbLicense,
    IN     DRM_BB_CONTEXT *pcontextBB );

DRM_RESULT DRM_API DRM_BBX_CipherKeySetup( 
    IN const DRM_BINDING_INFO   *rgBindingInfo,
    IN       DRM_DWORD           dwChainLength,
    OUT      DRM_CIPHER_CONTEXT *pCipherContext,
    IN       DRM_BB_CONTEXT     *pcontextBB );

DRM_RESULT DRM_API DRM_BBX_InitDecrypt( 
    IN     DRM_CIPHER_CONTEXT *f_pcontextCipher,
    IN     DRM_BYTE           *f_pbLast15,
    IN     DRM_DWORD           f_cbData );

DRM_RESULT DRM_API DRM_BBX_Decrypt( 
    IN     DRM_DWORD           cbData,
    IN OUT DRM_BYTE           *pbData,
    IN     DRM_CIPHER_CONTEXT *pDecryptContext);

DRM_RESULT DRM_API DRM_BBX_Encrypt( 
    IN     DRM_DWORD           cbData,
    IN OUT DRM_BYTE           *pbData,
    IN     DRM_CIPHER_CONTEXT *pEncryptContext );

DRM_RESULT DRM_API DRM_BBX_LegacyCipherKeySetup( 
    IN  DRM_BINDING_INFO   *pBindInfo, 
    IN  DRM_BYTE           *pbKID,
    IN  DRM_DWORD           cbKID,
    IN  DRM_BYTE           *pbSecretData,
    IN  DRM_DWORD           cbSecretData,
    OUT DRM_CIPHER_CONTEXT *pCipherContext, 
    IN  DRM_BB_CONTEXT     *pcontextBB);


typedef enum
{
    eBBX_PRIVKEY_MACHINE               = 1,
    eBBX_PRIVKEY_RESTORELICENSESIGNER  = 2,
    eBBX_PRIVKEY_TRANSFERLICENSESIGNER = 3
} eBBX_SIGNING_KEY_TYPES;

DRM_RESULT DRM_API DRM_BBX_SignData(
    IN       DRM_BB_CONTEXT *f_pcontextBBX,
    IN const DRM_BYTE       *f_pbData,
    IN       DRM_DWORD       f_cbData,
    IN       DRM_DWORD       f_ePrivKeyType,
       OUT   DRM_BYTE        f_rgbSignature[PK_ENC_SIGNATURE_LEN] );
#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS

DRM_RESULT DRM_API DRM_BBX_SymmetricSign(
    IN       DRM_BB_CONTEXT *f_pcontextBBX,
    IN const DRM_BYTE       *f_pbData,
    IN       DRM_DWORD       f_cbData,
       OUT   DRM_BYTE        f_rgbSymSig[__CB_DECL( SHA_DIGEST_LEN )] );

DRM_RESULT DRM_API DRM_BBX_SymmetricVerify(
    IN       DRM_BB_CONTEXT *f_pcontextBBX,
    IN const DRM_BYTE       *f_pbData,
    IN       DRM_DWORD       f_cbData,
    IN const DRM_SLK        *f_pslk,
    IN const DRM_BYTE        f_rgbSymSig[__CB_DECL( SHA_DIGEST_LEN )] );

DRM_RESULT DRM_API DRM_BBX_AsymmetricToSymmetricKey(
    IN     DRM_BB_CONTEXT   *f_pcontextBBX,
    IN OUT DRM_BINDING_INFO *f_pbindinfo,
       OUT DRM_DWORD        *f_pcbSymmKey );

DRM_RESULT DRM_API DRM_BBX_RebindSymmetricKey(
    IN       DRM_BB_CONTEXT *f_pcontextBBX,
    IN const DRM_SLK        *f_pslk,
    IN OUT   DRM_BYTE       *f_pbSymmKey,
       OUT   DRM_DWORD       f_cbSymmKey );

DRM_RESULT DRM_API DRM_BBX_RebindSLK(
    IN       DRM_BB_CONTEXT *f_pcontextBBX,
    IN const DRM_BYTE        f_rgbEncSLK[__CB_DECL(PK_ENC_CIPHERTEXT_LEN)],
       OUT   DRM_SLK        *f_pslk );

#endif

#ifdef __cplusplus
}
#endif

#endif /* __DRMBLACKBOX_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmbase64.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMBASE64_H__
#define __DRMBASE64_H__

#ifdef __cplusplus
extern "C" {
#endif
/* 
   Using decode in place will cause the decoder to place the decoded output in the 
   last *pcbDestination bytes of pwszSource->pwszString
*/
#define DRM_BASE64_DECODE_IN_PLACE 1


/* DRM normally uses a special base64 encoding.  Use this flag to get standard encoding */
#define DRM_BASE64_ENCODE_WMDRM 2


/* characters required for a binary of size cb expressed as base64*/

#define CCH_BASE64_EQUIV(cb)          ((((cb)/3)+(((cb)%3)?1:0))*4)
#define CB_BASE64_DECODE(cch)           (((cch)*3)/4)
#define CCH_BASE64_ENC_LARGE(cb)      CCH_BASE64_EQUIV(cb+PK_ENC_CIPHERTEXT_LEN)
#define CCH_BASE64_ENC_LARGE_WCH(cch) CCH_BASE64_ENC_LARGE((cch)*SIZEOF(DRM_WCHAR))

DRM_RESULT DRM_API DRM_B64_DecodeA(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrSource,
    IN OUT   DRM_DWORD             *pcbDestination, 
       OUT   DRM_BYTE              *pbDestination,
    IN       DRM_DWORD              dwFlags);

DRM_RESULT DRM_API DRM_B64_DecodeW(
    IN const DRM_CONST_STRING      *pdstrSource,
    IN OUT   DRM_DWORD             *pcbDestination, 
       OUT   DRM_BYTE              *pbDestination,
    IN       DRM_DWORD              dwFlags);

DRM_RESULT DRM_API DRM_B64_EncodeA( 
    IN const DRM_BYTE  *pvBuffer,    /* input buffer */
    IN       DRM_DWORD  cbBuffer,    /* input len */
       OUT   DRM_CHAR  *pszEncoded,  /* output char */
    IN OUT   DRM_DWORD *pcchEncoded, /* output ch len */
    IN       DRM_DWORD  dwFlags );

DRM_RESULT DRM_API DRM_B64_EncodeW( 
    IN const DRM_BYTE  *pvBuffer,    /* input buffer */
    IN       DRM_DWORD  cbBuffer,    /* input len */
       OUT   DRM_WCHAR *pwszEncoded, /* output WCHAR */
    IN OUT   DRM_DWORD *pcchEncoded, /* output ch len */
    IN       DRM_DWORD  dwFlags );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmbytemanip.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmbytemanip.h>
#include <drmcrt.h>


DRM_VOID DRM_API DRM_BYT_ReverseBytes(
    IN OUT DRM_BYTE *pbData,
    IN     DRM_DWORD cbData )
{
    DRM_BYTE bTemp;
    DRM_DWORD i;
    
    if( cbData < 2 )
    {
        return;
    }
    
    cbData--;
    for( i=0; i<cbData; i++,cbData-- )
    {
        bTemp = GET_BYTE(pbData, i);
        PUT_BYTE(pbData, i, GET_BYTE(pbData, cbData));
        PUT_BYTE(pbData, cbData, bTemp);
    }
}

#if SIXTEEN_BIT_ADDRESSING

DRM_VOID DRM_API DRM_BYT_CopyBytes( 
       OUT   DRM_VOID *f_pbTo, 
    IN       DRM_DWORD f_ibTo, 
    IN const DRM_VOID *f_pbFrom,
    IN       DRM_DWORD f_ibFrom,
    IN       DRM_DWORD f_cb )
{
    DRM_BYTE *pbTo   = (DRM_BYTE*) f_pbTo;
    DRM_BYTE *pbFrom = (DRM_BYTE*) f_pbFrom;

    if( !ISODD(f_ibTo)
     && !ISODD(f_ibFrom) )
    {
        /*
        ** Offsets are both even just use memcpy
        */
        memcpy( pbTo   + (f_ibTo   / CB_NATIVE_BYTE), 
                pbFrom + (f_ibFrom / CB_NATIVE_BYTE), 
                f_cb / CB_NATIVE_BYTE );
        if( ISODD(f_cb) )
        {
            /*
            ** Copy the last odd byte
            */
            PUT_BYTE(pbTo, f_ibTo+(f_cb-1), GET_BYTE( pbFrom, f_ibFrom+(f_cb-1) ) );
        }
    }
    else if( ISODD(f_ibTo)
          && ISODD(f_ibFrom) )
    {
        /*
        ** Offsets are both odd.  
        ** 1. Put the first byte in the right place
        ** 2. Use memcpy for all bytes 1 to f_cb/2
        ** 3. If there is a dangling byte write that at the end
        */
        PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom) );
        f_cb--;
        if( f_cb >= CB_NATIVE_BYTE )
        {
            memcpy( pbTo   + ((f_ibTo+1)   / CB_NATIVE_BYTE), 
                    pbFrom + ((f_ibFrom+1) / CB_NATIVE_BYTE), 
                    f_cb / CB_NATIVE_BYTE );
        }
        if( ISODD(f_cb) )
        {
            /*
            ** Copy the last odd byte (note that f_cp has previously been decremented)
            */
            PUT_BYTE(pbTo, f_ibTo+f_cb, GET_BYTE( pbFrom, f_ibFrom+f_cb ) );
        }
    }
    else
    {
        /*
        ** The input offset and output offset are unfortuantly not both even or both odd.
        ** This means that each byte must be independantly shifted from one to another
        */
        for( ; f_cb > 0; f_cb--, f_ibTo++, f_ibFrom++ )
        {
            PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom ) );
        }
    }
}

DRM_VOID DRM_API DRM_BYT_MoveBytes( 
       OUT   DRM_VOID *f_pbTo, 
    IN       DRM_DWORD f_ibTo, 
    IN const DRM_VOID *f_pbFrom,
    IN       DRM_DWORD f_ibFrom,
    IN       DRM_DWORD f_cb )
{
    DRM_BYTE *pbTo   = (DRM_BYTE*) f_pbTo;
    DRM_BYTE *pbFrom = (DRM_BYTE*) f_pbFrom;

    if( ( ((DRM_DWORD)f_pbTo * CB_NATIVE_BYTE) + f_ibTo )
        - ( ((DRM_DWORD)f_pbFrom * CB_NATIVE_BYTE) + f_ibFrom ) < f_cb )
    {
        /* The source and destination overlap, */
        /* and the destination is later in memory than the source */

        f_ibTo += f_cb - 1;
        f_ibFrom += f_cb - 1;

        for( ; f_cb > 0; f_cb--, f_ibTo--, f_ibFrom-- )
        {
            PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom ) );
        }
    }
    else if( ( ((DRM_DWORD)f_pbFrom * CB_NATIVE_BYTE) + f_ibFrom )
        - ( ((DRM_DWORD)f_pbTo * CB_NATIVE_BYTE) + f_ibTo ) < f_cb )
    {
        /* The source and destination overlap, */
        /* and the source is later in memory than the destination */
		
        for( ; f_cb > 0; f_cb--, f_ibTo++, f_ibFrom++ )
        {
            PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom ) );
        }
    }
    else if( !ISODD(f_ibTo)
     && !ISODD(f_ibFrom) )
    {
        /*
        ** Offsets are both even just use memcpy
        */
        memmove(pbTo   + (f_ibTo   / CB_NATIVE_BYTE), 
                pbFrom + (f_ibFrom / CB_NATIVE_BYTE), 
                f_cb / CB_NATIVE_BYTE );
        if( ISODD(f_cb) )
        {
            /*
            ** Copy the last odd byte
            */
            PUT_BYTE(pbTo, f_ibTo+(f_cb-1), GET_BYTE( pbFrom, f_ibFrom+(f_cb-1) ) );
        }
    }
    else if( ISODD(f_ibTo)
          && ISODD(f_ibFrom) )
    {
        /*
        ** Offsets are both odd.  
        ** 1. Put the first byte in the right place
        ** 2. Use memcpy for all bytes 1 to f_cb/2
        ** 3. If there is a dangling byte write that at the end
        */
        PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom) );
        f_cb--;
        if( f_cb >= CB_NATIVE_BYTE )
        {
            memmove( pbTo   + ((f_ibTo+1)   / CB_NATIVE_BYTE), 
                     pbFrom + ((f_ibFrom+1) / CB_NATIVE_BYTE), 
                     f_cb / CB_NATIVE_BYTE  );
        }
        if( ISODD(f_cb) )
        {
            /*
            ** Copy the last odd byte (note that f_cp has previously been decremented)
            */
            PUT_BYTE(pbTo, f_ibTo+f_cb, GET_BYTE( pbFrom, f_ibFrom+f_cb ) );
        }
    }
    else
    {
        /*
        ** The input offset and output offset are unfortuantly not both even or both odd.
        ** This means that each byte must be independantly shifted from one to another
        */
        for( ; f_cb > 0; f_cb--, f_ibTo++, f_ibFrom++ )
        {
            PUT_BYTE(pbTo, f_ibTo, GET_BYTE( pbFrom, f_ibFrom ) );
        }
    }
}

DRM_VOID DRM_API DRM_BYT_SetBytes(
       OUT DRM_VOID *f_pb,
    IN     DRM_DWORD f_ib,
    IN     DRM_DWORD f_cb,
    IN     DRM_BYTE  f_b )
{
    DRM_BYTE *pb = (DRM_BYTE*) f_pb;
    DRM_DWORD cb = 0;
    if( ISODD(f_ib) )
    {
        /*
        ** Offset is odd.  Set the first bit before calling memset
        */
        PUT_BYTE( pb, f_ib, f_b );
        f_cb--;
        f_ib++;
    }
    
    cb = f_cb / CB_NATIVE_BYTE;
    
    memset( pb + (f_ib / CB_NATIVE_BYTE), MAKE_MACHINE_BYTE(f_b,f_b), cb );
    
    f_ib += cb * CB_NATIVE_BYTE;
    if( ISODD(f_cb) )
    {
        /*
        ** Copy the last odd byte
        */
        PUT_BYTE(pb, f_ib, f_b );
    }
}

DRM_INT DRM_API DRM_BYT_CompareBytes(
    IN const DRM_VOID *f_pbA,
    IN       DRM_DWORD f_ibA,
    IN const DRM_VOID *f_pbB,
    IN       DRM_DWORD f_ibB,
    IN       DRM_DWORD f_cb )
{
    DRM_INT iResult = 0;
    DRM_NATIVE_BYTE bA     = 0;
    DRM_NATIVE_BYTE bB     = 0;
    DRM_BYTE *pbA = (DRM_BYTE*) f_pbA;
    DRM_BYTE *pbB = (DRM_BYTE*) f_pbB;

    if( !ISODD(f_ibA)
     && !ISODD(f_ibB) )
    {
        /*
        ** Offsets are both even just use memcmp
        */
        iResult = memcmp( pbA + (f_ibA / CB_NATIVE_BYTE), 
                          pbB + (f_ibB / CB_NATIVE_BYTE), 
                          f_cb / CB_NATIVE_BYTE );
        if( iResult == 0 
         && ISODD(f_cb) )
        {
            /*
            ** Compare the last odd bytes if needed
            */
            bA = GET_BYTE( pbA, f_ibA+(f_cb-1) );
            bB = GET_BYTE( pbB, f_ibB+(f_cb-1) );
            if( bA == bB )
            {
                iResult = 0;
            }
            else if( bA > bB )
            {
                iResult = 1;
            }
            else
            {
                iResult = -1;
            }
        }
    }
    else if( ISODD(f_ibA)
          && ISODD(f_ibB) )
    {
        /*
        ** Offsets are both odd.  
        ** 1. Compare the first byte
        ** 2. Use memcmp for all bytes 1 to f_cb/2
        ** 3. If there is a dangling byte at the end compare that one
        */
        bA = GET_BYTE( pbA, f_ibA);
        bB = GET_BYTE( pbB, f_ibB);

        if( bA == bB )
        {
            iResult = 0;
        }
        else if( bA > bB )
        {
            iResult = 1;
        }
        else
        {
            iResult = -1;
        }

        if( iResult == 0 )
        {
            f_cb--;
            if( f_cb >= CB_NATIVE_BYTE )
            {
                iResult = memcmp( pbA + ((f_ibA+1) / CB_NATIVE_BYTE),
                                  pbB + ((f_ibB+1) / CB_NATIVE_BYTE),
                                  f_cb / CB_NATIVE_BYTE );
            }
            if( iResult == 0
             && ISODD(f_cb) )
            {
                /*
                ** Compare the last odd byte (note that f_cp has previously been decremented)
                */
                bA = GET_BYTE( pbA, f_ibA+f_cb );
                bB = GET_BYTE( pbB, f_ibB+f_cb );
                if( bA == bB )
                {
                    iResult = 0;
                }
                else if( bA > bB )
                {
                    iResult = 1;
                }
                else
                {
                    iResult = -1;
                }
            }
        }
    }
    else
    {
        /*
        ** The input offset and output offset are unfortuantly not both even or both odd.
        ** This means that each byte must be independantly compared
        */
        for( ; f_cb > 0; f_cb--, f_ibA++, f_ibB++ )
        {
            bA = GET_BYTE( pbA, f_ibA );
            bB = GET_BYTE( pbB, f_ibB );
            if( bA == bB )
            {
                iResult = 0;
            }
            else if( bA > bB )
            {
                iResult = 1;
                break;
            }
            else
            {
                iResult = -1;
                break;
            }
        }
    }

    return iResult;
}



/*********************************************************************
**  Function: DRM_16B_Read8BitByte
**              
**  Synopsis:  allow one-byte quantities to by read on
**             architectures that cannot address them.  
**
**  Arguments:  
**     [f_pv]  -- buffer to read with 8-bit bytes
**     [f_ib]  -- index of the 8-bit byte to read
*********************************************************************/

DRM_NATIVE_BYTE DRM_API DRM_16B_Read8BitByte(
    IN  const DRM_VOID  *f_pv,
    IN        DRM_DWORD  f_ib)
{
    DRM_NATIVE_BYTE bNative = 0;
    
    DRMCASSERT(CB_NATIVE_BYTE == 2);

    /* read the MB-sized word containing the sought byte */

    bNative = ((DRM_NATIVE_BYTE *) f_pv) [f_ib / CB_NATIVE_BYTE];

    /* shift the sought byte into the LSB */

    bNative >>= (8 * ( (f_ib+1) % CB_NATIVE_BYTE));
    
    /* mask off the other bytes */
    
    bNative &= ((DRM_NATIVE_BYTE) 0xFF);

    return bNative;
}

/*********************************************************************
**  Function: DRM_16B_Write8BitByte
**              
**  Synopsis:  allow one-byte quantities to by written on
**             architectures that cannot address them.  
**
**  Arguments:  
**     [f_pv]  -- buffer to write with 8-bit bytes
**     [f_ib]  -- index of the byte to write
**     [f_mb]  -- machine byte to write into the address
**
** Note: the other 8-bit byte in the 16-bit byte being written is
**       preserved
*********************************************************************/

DRM_VOID DRM_API DRM_16B_Write8BitByte(
    OUT DRM_VOID        *f_pv,
    IN  DRM_DWORD        f_ib,
    IN  DRM_NATIVE_BYTE  f_mb)
{
    DRM_NATIVE_BYTE bNative = 0;
    DRM_NATIVE_BYTE bMask   = 0xFF;

    DRMCASSERT((CB_NATIVE_BYTE == 2));

    /* shift the LSB into the target position in the machine word: |0|C| --> |C|0| */

    f_mb  <<= (8 * ((f_ib+1) % CB_NATIVE_BYTE));
    bMask <<= (8 * ((f_ib+1) % CB_NATIVE_BYTE));
    
    /* read to the MB-sized word containing the sought byte: |A|B| */

    bNative = ((DRM_NATIVE_BYTE *) f_pv) [f_ib / CB_NATIVE_BYTE];

    /* mask off the position where the new byte will be written: |A|0| */
    /* compose the two MBs to the new one: |A|0| | |0|C| --> |A|C| */

    bNative &= ~bMask;
    bNative |= f_mb;

    /* write the composed MB */

    ((DRM_NATIVE_BYTE *) f_pv) [f_ib / CB_NATIVE_BYTE] = bNative;
}

/*********************************************************************
**  Functions:  DRM_16B_Read8BitChar
**              DRM_16B_Write8BitChar
**              
**  Synopsis:  signed-char versions of the above
*********************************************************************/

DRM_NATIVE_CHAR DRM_API DRM_16B_Read8BitChar(
    IN  DRM_VOID *f_pch,
    IN  DRM_DWORD f_ich)
{
    return (DRM_NATIVE_CHAR) DRM_16B_Read8BitByte(f_pch, f_ich);
}

DRM_VOID DRM_API DRM_16B_Write8BitChar(
    OUT DRM_VOID        *f_pch,
    IN  DRM_DWORD        f_ich,
    IN  DRM_NATIVE_CHAR  f_mch)
{
    DRM_16B_Write8BitByte(f_pch, f_ich, (DRM_NATIVE_BYTE) f_mch);
}

/*********************************************************************
**  Functions:  DRM_16B_Read8BitBytes
**              DRM_16B_Write8BitBytes
**              
**  Synopsis:  allow one-byte streams to by read and written on
**             architectures that cannot read and write them.  
**
**  Arguments:  
**     [f_pv]  -- buffer to read/write with 8-bit bytes
**     [f_cb]  -- number of the bytes to read/write
**     [f_pb]  -- buffer of native machine bytes to read to/write from
*********************************************************************/

DRM_VOID DRM_API DRM_16B_Read8BitBytes(
    IN  DRM_VOID        *f_pv,
    IN  DRM_DWORD        f_cb,
    OUT DRM_NATIVE_BYTE *f_pb)
{
    DRM_DWORD ib8In       = 0;
    DRM_DWORD ibNativeOut = 0;

    /* read a machine-byte chunk from the 8-bit input stream */

    for (ib8In  = 0; 
         ib8In  < f_cb; 
         ib8In += CB_NATIVE_BYTE)
    {
        DRM_NATIVE_BYTE bNative = ((DRM_NATIVE_BYTE *) f_pv) [ib8In / CB_NATIVE_BYTE];
        
        f_pb [ibNativeOut++] = (bNative & 0x00FF);        

        if (ibNativeOut >= f_cb)
        {
            break;
        }

        f_pb [ibNativeOut++] = (bNative >> 8);        
    }
}

DRM_VOID DRM_API DRM_16B_Write8BitBytes(
    OUT DRM_VOID *f_pv,
    IN  DRM_DWORD f_cb,
    IN  DRM_NATIVE_BYTE *f_pb)
{
    DRM_DWORD ibNativeIn = 0;

    for (ibNativeIn  = 0; 
         ibNativeIn  < f_cb; 
         ibNativeIn += CB_NATIVE_BYTE)
    {
        DRM_NATIVE_BYTE bOut = 0;
        
        bOut  = f_pb [ibNativeIn] & 0xFF;
        bOut |= f_pb [ibNativeIn  + 1] << 8;

        ((DRM_NATIVE_BYTE *) f_pv) [ibNativeIn / 2] = bOut;
    }
}

DRM_VOID DRM_API DRM_16B_Read8BitString(
    IN  DRM_VOID *f_pv,
    IN  DRM_DWORD f_cch,
    OUT DRM_NATIVE_CHAR *f_pch)
{
    DRM_16B_Read8BitBytes(f_pv, f_cch, (DRM_NATIVE_BYTE *) f_pch);
}    

DRM_VOID DRM_API DRM_16B_Write8BitString(
    OUT DRM_VOID *f_pv,
    IN  DRM_DWORD f_cch,
    IN  DRM_NATIVE_CHAR *f_pch)
{
    DRM_16B_Write8BitBytes(f_pv, f_cch, (DRM_NATIVE_BYTE *) f_pch);
}

/*****************************************************************************
** Function: DRM_16B_Pack8BitBytes
**
** Synopsis: Convert an array of 16-bit bytes into an array of 8-bit bytes 
**           packed into the nibbles of a 16-bit array
**
** Arguments:
**           [f_pbNative] -- buffer of 16-bit bytes
**           [f_cbNative] -- size of f_pbNative
**           [f_pvPacked]  -- recipient buffer for packed bytes, NULL to
**                            pack in place
**           [f_fOptions]  -- flags.  The following are supported:
**
**                            DRM_PACK_BYTES_IN_PLACE - use f_pbNative as   
**                                                      the output buffer
*****************************************************************************/

DRM_VOID *DRM_API DRM_16B_Pack8BitBytes(
    DRM_NATIVE_BYTE *f_pbNative,
    DRM_DWORD        f_cbNative,
    DRM_VOID        *f_pvPacked,
    DRM_DWORD        f_fOptions)
{
    DRM_DWORD ib     = 0;
    DRM_NATIVE_BYTE *pbOut = NULL;
    
    if (f_pvPacked != NULL)
    {
        DRMASSERT((f_fOptions & DRM_PACK_BYTES_IN_PLACE) == 0);
        
        pbOut = (DRM_NATIVE_BYTE *) f_pvPacked;
    }
    else
    {
        DRMASSERT((f_fOptions & DRM_PACK_BYTES_IN_PLACE) != 0);
        
        pbOut = f_pbNative;
    }
        
    for (ib = 0; ib < f_cbNative; ib += CB_NATIVE_BYTE)
    {
        pbOut [ib / 2] = ((f_pbNative [ib + 1] << 8) | (f_pbNative [ib] & 0xFF));
    }
    
    return (DRM_VOID *) pbOut;
}                                        

/*****************************************************************************
** Function: DRM_16B_IncrementPackedPointer
**
** Synopsis: moves an array of 16-bit byte one nibble to the left, effectively
**           executing a psz++
**
**  |a'b|c'd|e'f| --> |b'c|d'e|f'0| with 'a' returned in f_pbHead
**
** Arguments:
**           [f_pbNative] -- buffer of 16-bit bytes
**           [f_cbNative] -- size of f_pbNative
**           [f_pbHead]    -- optional pointer to BYTE to receive value 
**                            overwritten by the left-shift
**
** Notes: this function changes data and should be reversed with 
**        DRM_16B_DecrementPackedPointer 
*****************************************************************************/

DRM_VOID *DRM_API DRM_16B_IncrementPackedPointer(
    IN OUT DRM_NATIVE_BYTE *f_pbNative,
    IN     DRM_DWORD        f_cbNative,
       OUT DRM_NATIVE_BYTE *f_pbHead)
{
    DRM_DWORD ib = 0;
    
    DRMASSERT(f_pbNative != NULL
           && f_cbNative != 0);
    
    if (f_pbHead != NULL)
    {
        *f_pbHead = GET_BYTE(f_pbNative, 0);
    }
    
    /* repack the remaining string to align with the pointer */
    
    for (ib  = 0; 
         ib  < f_cbNative; 
         ib += CB_NATIVE_BYTE)
    {
        f_pbNative [ib / CB_NATIVE_BYTE] = MAKE_MACHINE_BYTE(GET_BYTE(f_pbNative, ib + 1), 
                                                             GET_BYTE(f_pbNative, ib + 2));
    }
    
    f_pbNative [f_cbNative / CB_NATIVE_BYTE] = MAKE_MACHINE_BYTE(GET_BYTE(f_pbNative, ib + 1), 0);

    return f_pbNative;
}       

/*****************************************************************************
** Function: DRM_16B_DecrementPackedPointer
**
** Synopsis: moves an array of 16-bit byte one nibble to the right, effectively
**           executing a psz--
**
**  |a'b|c'd|e'f| --> |X'a|b'c|d'e| where X is passed in as f_bHead
**
** Arguments:
**           [f_pbNative] -- buffer of 16-bit bytes
**           [f_cbNative] -- size of f_pbNative
**           [f_bHead]     -- BYTE to place at the new first nibble
**
** Notes: this function reverses DRM_16B_IncrementPackedPointer 
*****************************************************************************/

DRM_VOID *DRM_API DRM_16B_DecrementPackedPointer(
    IN OUT DRM_NATIVE_BYTE *f_pbNative,
    IN     DRM_DWORD        f_cbNative,
    IN     DRM_NATIVE_BYTE  f_bHead)
{
    DRM_DWORD        ibNative = 0;
    DRM_NATIVE_BYTE  bCarry   = f_bHead;
    
    DRMASSERT(f_pbNative != NULL
           && f_cbNative != 0);

    /*  |b'c|d'e| and a ---> |a'b|c'd|e'0| */
    
    /* repack the remaining string to align with the pointer */
    
    for (ibNative  = 0; 
         ibNative  < f_cbNative; 
         ibNative += CB_NATIVE_BYTE)
    {
        DRM_NATIVE_BYTE b1 = GET_BYTE(f_pbNative, ibNative + 1);

        f_pbNative [ibNative / CB_NATIVE_BYTE] = MAKE_MACHINE_BYTE(bCarry, 
                                                                   GET_BYTE(f_pbNative, ibNative));
        
        bCarry = b1;
    }
    
    f_pbNative [f_cbNative / CB_NATIVE_BYTE] = MAKE_MACHINE_BYTE(bCarry, 0);

    return f_pbNative;
}       


#endif /* SIXTEEN_BIT_ADDRESSING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcbc.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

/*
chain-sum MAC scheme 4.5: multiply-&-swap rounds plus sum (reversible -- reversal code included)
*/
#include <drmcommon.h>
#include <drmcrt.h>
#include <drmcbc.h>

/* pairwise independent function and summing step */
#define MP_C_STEP_P(pbData,L1, L2, L3, L4, L5, L6, t, sum) \
{\
    DRM_DWORD   dwTemp = 0;\
    BYTES_TO_DWORD( dwTemp, pbData );\
    pbData += __CB_DECL(SIZEOF(DRM_DWORD));\
    t += dwTemp; \
    t *= L1; \
    t = WORDSWAP(t); \
    t *= L2; \
    t = WORDSWAP(t); \
    t *= L3; \
    t = WORDSWAP(t); \
    t *= L4; \
    t = WORDSWAP(t); \
    t *= L5; \
    t += L6; \
    sum += t; \
}


#define MP_C_STEP(Data,L1, L2, L3, L4, L5, L6, t, sum) \
    t += Data; \
    t *= L1; \
    t = WORDSWAP(t); \
    t *= L2; \
    t = WORDSWAP(t); \
    t *= L3; \
    t = WORDSWAP(t); \
    t *= L4; \
    t = WORDSWAP(t); \
    t *= L5; \
    t += L6; \
    sum += t;

DRM_VOID DRM_API DRM_CBC_Mac(
    IN        DRM_BYTE      *pbData,
    IN        DRM_DWORD      cBlocks,
    OUT       DRM_DWORD      rgdwKeys[2],
    IN  const DRM_CBCKey    *pCBCkey )
{    
    rgdwKeys[0] = rgdwKeys[1] = 0;
    while ( cBlocks > 0)
    {
        DRM_DWORD dw = 0;
        BYTES_TO_DWORD( dw, pbData );
        pbData += __CB_DECL(SIZEOF( DRM_DWORD ));
        MP_C_STEP(dw, pCBCkey->a1, pCBCkey->b1, pCBCkey->c1, pCBCkey->d1, pCBCkey->e1, pCBCkey->f1, rgdwKeys[1], rgdwKeys[0]);
        BYTES_TO_DWORD( dw, pbData );
        pbData += __CB_DECL(SIZEOF( DRM_DWORD ));
        MP_C_STEP(dw, pCBCkey->a2, pCBCkey->b2, pCBCkey->c2, pCBCkey->d2, pCBCkey->e2, pCBCkey->f2, rgdwKeys[1], rgdwKeys[0]);
        cBlocks -= 2;
    }
    return;
}

/*******************************************************************/
DRM_UINT DRM_API DRM_MAC_inv32( DRM_UINT n )
{
    DRM_INT x = n;
    DRM_INT i = 0;

    for (i = 0; i < 30; i++)
    {
        x *= x * n;
    }

    return (DRM_UINT)x;
}


/* step to reverse action of multiply-&-swap rounds */
#define INV_STEP_C(iL1, iL2, iL3, iL4, iL5) \
    tmp *= iL5; \
    tmp = WORDSWAP(tmp); \
    tmp *= iL4; \
    tmp = WORDSWAP(tmp); \
    tmp *= iL3; \
    tmp = WORDSWAP(tmp); \
    tmp *= iL2; \
    tmp = WORDSWAP(tmp); \
    tmp *= iL1;

DRM_VOID DRM_API DRM_CBC_InverseMac(
    IN OUT   DRM_BYTE   *pbData,
    IN       DRM_DWORD   cBlocks,
    IN const DRM_CBCKey *key,
    IN const DRM_CBCKey *ikey )
{
    DRM_UINT tmp = 0,tmp2 = 0;
    DRM_DWORD sum64[2];


    /* 
        Invert last two blocks (sum and 32-bit MAC).  This requires the encrypted last two
        blocks and the (dwNumBlocks-2) plaintext blocks. 
    */
    DRM_CBC_Mac(pbData, cBlocks - 2, sum64, key);
    BYTES_TO_DWORD( tmp, pbData + ((SIZEOF( DRM_UINT)*(cBlocks - 1))/CB_NATIVE_BYTE));
    sum64[0] += tmp;

    /* last word */    
    tmp -= key->f2;
    INV_STEP_C(ikey->a2, ikey->b2, ikey->c2, ikey->d2, ikey->e2);
    BYTES_TO_DWORD( tmp2, pbData + ((SIZEOF( DRM_UINT)*(cBlocks - 2))/CB_NATIVE_BYTE));
    tmp -= ( tmp2 - sum64[0] );
    DWORD_TO_BYTES( pbData + ((SIZEOF( DRM_UINT)*(cBlocks - 1)/CB_NATIVE_BYTE)), tmp );

    /* next-to-last word */
    tmp = (tmp2 - sum64[0]) - key->f1;
    INV_STEP_C(ikey->a1, ikey->b1, ikey->c1, ikey->d1, ikey->e1);
    tmp -= sum64[1];
    DWORD_TO_BYTES( pbData + ((SIZEOF( DRM_UINT)*(cBlocks - 2)/CB_NATIVE_BYTE)), tmp );
        
    return;
}

DRM_VOID DRM_API DRM_CBC64InitState( DRM_CBCState *cbcstate ) {
  cbcstate->sum = 0; cbcstate->t = 0; cbcstate->dwBufLen = 0;
}


DRM_VOID DRM_API DRM_CBC64Init( DRM_CBCKey *cbckey, DRM_CBCState *cbcstate, DRM_BYTE *pKey ) {
  DRM_UINT *p = NULL;

  cbcstate->sum = 0; cbcstate->t = 0; cbcstate->dwBufLen = 0;
  p = (DRM_UINT *)pKey;
  cbckey->a1 = *p++ | 0x00000001;
  cbckey->b1 = *p++ | 0x00000001;
  cbckey->c1 = *p++ | 0x00000001;
  cbckey->d1 = *p++ | 0x00000001;
  cbckey->e1 = *p++ | 0x00000001;
  cbckey->f1 = *p++ | 0x00000001;
  cbckey->a2 = *p++ | 0x00000001;
  cbckey->b2 = *p++ | 0x00000001;
  cbckey->c2 = *p++ | 0x00000001;
  cbckey->d2 = *p++ | 0x00000001;
  cbckey->e2 = *p++ | 0x00000001;
  cbckey->f2 = *p++ | 0x00000001;
}

DRM_VOID DRM_API DRM_CBC64InvKey( DRM_CBCKey *cbckey, DRM_CBCKey *cbcInvKey ) {

  cbcInvKey->a1 = DRM_MAC_inv32( cbckey->a1 );
  cbcInvKey->a2 = DRM_MAC_inv32( cbckey->a2 );
  cbcInvKey->b1 = DRM_MAC_inv32( cbckey->b1 );
  cbcInvKey->b2 = DRM_MAC_inv32( cbckey->b2 );
  cbcInvKey->c1 = DRM_MAC_inv32( cbckey->c1 );
  cbcInvKey->c2 = DRM_MAC_inv32( cbckey->c2 );
  cbcInvKey->d1 = DRM_MAC_inv32( cbckey->d1 );
  cbcInvKey->d2 = DRM_MAC_inv32( cbckey->d2 );
  cbcInvKey->e1 = DRM_MAC_inv32( cbckey->e1 );
  cbcInvKey->e2 = DRM_MAC_inv32( cbckey->e2 );
  cbcInvKey->f1 = DRM_MAC_inv32( cbckey->f1 );
  cbcInvKey->f2 = DRM_MAC_inv32( cbckey->f2 );

}

DRM_VOID DRM_API DRM_CBC64Update( 
    IN      DRM_CBCKey  *key, 
    IN  OUT DRM_CBCState    *cbcstate,
    IN      DRM_DWORD    cbData, 
    IN      DRM_BYTE    *pbData )
{
    DRM_DWORD    iData  = 0;
    DRM_DWORD    cbCopy = 0;
    DRM_DWORD    cbTemp  = 0;
    DRM_BYTE    *pbTemp = NULL;
    
    if ( cbcstate->dwBufLen > 0 ) 
    {
        cbCopy = min( cbData, 8 - cbcstate->dwBufLen );
        
        for ( iData=0; iData < cbCopy; iData++ )
        {
            PUT_BYTE( cbcstate->buf, 
                      cbcstate->dwBufLen + iData, 
                      GET_BYTE(pbData, iData) );
        }
        
        cbcstate->dwBufLen += cbCopy;
        if ( cbcstate->dwBufLen == 8 ) 
        {
            pbTemp = cbcstate->buf;
            MP_C_STEP_P( pbTemp, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1, cbcstate->t, cbcstate->sum );
            MP_C_STEP_P( pbTemp, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2, cbcstate->t, cbcstate->sum );
            cbcstate->dwBufLen = 0;
        }
    }

    cbTemp = (cbData - cbCopy) / 8;
    pbTemp = pbData + __CB_DECL(cbCopy);

    while (cbTemp > 0) 
    {
        MP_C_STEP_P( pbTemp, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1, cbcstate->t, cbcstate->sum );
        MP_C_STEP_P( pbTemp, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2, cbcstate->t, cbcstate->sum );
        cbTemp--;
    }

    cbTemp = cbCopy + ((cbData-cbCopy) / 8) * 8;
    if ( cbTemp < cbData ) 
    {
        for ( iData=cbTemp; iData<cbData; iData++ )
        {
            PUT_BYTE( cbcstate->buf, iData - cbTemp, GET_BYTE( pbData, iData ) );
        }
        cbcstate->dwBufLen = cbData - cbTemp;
    }
}

DRM_UINT DRM_API DRM_CBC64Finalize( DRM_CBCKey *key, DRM_CBCState *cbcstate, DRM_UINT *pKey2 ) {
    DRM_DWORD   i = 0;
    DRM_BYTE    *p = NULL;

    if ( cbcstate->dwBufLen > 0 ) 
    {
        for ( i=cbcstate->dwBufLen; i<8; i++ )
        {
            PUT_BYTE( cbcstate->buf, i, 0);
        }
        p = cbcstate->buf;
        MP_C_STEP_P( p, key->a1, key->b1, key->c1, key->d1, key->e1, key->f1, cbcstate->t, cbcstate->sum );
        MP_C_STEP_P( p, key->a2, key->b2, key->c2, key->d2, key->e2, key->f2, cbcstate->t, cbcstate->sum );
        cbcstate->dwBufLen = 0;
    }

    *pKey2 = cbcstate->t;
    return cbcstate->sum;
}



DRM_UINT DRM_API DRM_CBC64Invert( DRM_CBCKey *key, DRM_CBCKey *ikey, DRM_UINT MacA1, DRM_UINT MacA2,
        DRM_UINT MacB1, DRM_UINT MacB2, DRM_UINT *pInvKey2 )
{
    DRM_UINT tmp = 0;
    DRM_UINT yn = 0, yn1 = 0, xn = 0, xn1 = 0;

    MacA1 += MacB2;
    yn = MacB2;
    yn1 = MacB1 - MacA1;

    /* last word */
    tmp = yn - key->f2;
    INV_STEP_C(ikey->a2, ikey->b2, ikey->c2, ikey->d2, ikey->e2);
    xn = tmp - yn1;

    /* next-to-last word */
    tmp = yn1 - key->f1;
    INV_STEP_C(ikey->a1, ikey->b1, ikey->c1, ikey->d1, ikey->e1);
    xn1 = tmp - MacA2;

    *pInvKey2 = (DRM_UINT) xn1;
    return (DRM_UINT) xn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcbc.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCBCMAC_H__
#define __DRMCBCMAC_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _CBCKey 
{
    DRM_UINT a1, b1, c1, d1, e1, f1, a2, b2, c2, d2, e2, f2;
} DRM_CBCKey;

/*********************************************************************
**
**  Function:  DRM_CBC_Mac
**
**  Synopsis:  Create a 64-bit MAC
**
**  Arguments:  
**     [pbData] -- Byte pointer to DWORD blocks that are to be MAC'd
**     [cBlocks] -- Length of pbData in DWORD's
**     [rgdwKey2] -- 2 DWORD array to hold the 64-bit result
**     [pCBCkey] -- Key structure filled by the caller.
**
**  Returns:  None
** Notes: dwNumBlocks must be in DWORDS and it should be multiple of 
**        DWORD. Suppose if length is 8 bytes, dwNumBlocks should be 2
*********************************************************************/
DRM_VOID DRM_API DRM_CBC_Mac(
    IN        DRM_BYTE  *pbData,
    IN        DRM_DWORD  cBlocks,
    OUT       DRM_DWORD  rgdwKeys[2],
    IN  const DRM_CBCKey *pCBCkey );

/*********************************************************************
**
**  Function:  DRM_CBC_InverseMac
**
**  Synopsis:  Inverse MAC function.  It decrypts the last two bloacks of pdwData
**              ( replaces 64-bit ciphertext pdwData[dwNumBlocks-1] and pdwData[dwNumBlocks-2]
**              with plaintext ).
**
**  Arguments:  
**     [pbData] -- Byte pointer to DWORD blocks that are to be MAC'd( inverse MAC )
**     [cBlocks] -- Length of pbData in DWORD's
**     [key] -- Key structure filled by caller
**     [ikey] -- Inverse key structure filled by caller.
**
**  Returns:  
**
** Notes: dwNumBlocks must be in DWORDS and it should be multiple of 
**        DWORD. Suppose if length is 8 bytes, dwNumBlocks should be 2
**
*********************************************************************/
DRM_VOID DRM_API DRM_CBC_InverseMac(
    IN OUT   DRM_BYTE  *pbData,
    IN       DRM_DWORD  cBlocks,
    IN const DRM_CBCKey *key,
    IN const DRM_CBCKey *ikey );

/*********************************************************************
**
**  Function:  DRM_MAC_inv32
**
**  Synopsis:  Returns the inverse of n ( inverse in terms of what the CBC Mac inverse code wants ).
**
**  Arguments:  
**     [n] -- Value of n to compute inverse of.
**
**  Returns:  Inverse of n
**
*********************************************************************/
DRM_UINT DRM_API DRM_MAC_inv32( DRM_UINT n );

typedef struct __tagCBCState
{
    DRM_UINT sum,t;
    DRM_BYTE buf[__CB_DECL(8)];
    DRM_DWORD dwBufLen;
} DRM_CBCState;

DRM_VOID DRM_API DRM_CBC64Init( DRM_CBCKey *cbckey, DRM_CBCState *cbcstate, DRM_BYTE *pKey );

#define DRMV2_MAC_LENGTH 8

DRM_VOID DRM_API DRM_CBC64Update( DRM_CBCKey *key, DRM_CBCState *cbcstate,DRM_DWORD dwLen, DRM_BYTE *pData );
DRM_UINT DRM_API DRM_CBC64Finalize( DRM_CBCKey *key, DRM_CBCState *cbcstate, DRM_UINT *pKey2 );
DRM_UINT DRM_API DRM_CBC64Invert( 
    DRM_CBCKey  *key, 
    DRM_CBCKey  *ikey, 
    DRM_UINT     MacA1, 
    DRM_UINT     MacA2,
    DRM_UINT     MacB1, 
    DRM_UINT     MacB2, 
    DRM_UINT    *pInvKey2 );

DRM_VOID DRM_API DRM_CBC64InitState( DRM_CBCState *cbcstate );

#ifdef __cplusplus
}
#endif

#endif /* __DRMCBCKEY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcert.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef _DRM_CERT_H_
#define _DRM_CERT_H_

#ifdef  __cplusplus
extern "C"
{
#endif

#define DRM_CERTIFICATE_COLLECTION_MIN 1
#define DRM_CERTIFICATE_COLLECTION_MAX 6
#define DRM_RSA_EXPONENT_VER_2_6_0_0   0x00010001
#define DRM_RSA_EXPONENT_VER_3_0_0_0   0x00010001
#define DRM_RSA_MODULUS_BITCOUNT 1024
#define DRM_CB_RSA_PUBLIC_MOD_1024       (DRM_RSA_MODULUS_BITCOUNT/8)
#define DRM_CB_RSA_PUBLIC_KEY_1024  156
#define DRM_CB_RSA_PRIVATE_KEY_1024 700
#define DRM_CB_RSA_PRIVATE_MOD_1024 (DRM_CB_RSA_PRIVATE_KEY_1024-DRM_CB_RSA_PUBLIC_KEY_1024) /* 'undocumented; secret key at the tail of a DRM_RSA_PRIVATE_KEY */

#define DRM_DSIG_TYPE_STANDARD FALSE
#define DRM_DSIG_TYPE_WMDRMNET TRUE

typedef enum 
{
    DRM_WMDRM_CERT_ATTR_SECURITY_LEVEL,
    DRM_WMDRM_CERT_ATTR_KEY_USAGE,
    DRM_WMDRM_CERT_ATTR_FEATURES,
    DRM_WMDRM_CERT_ATTR_DIGEST_VALUE,

    /* parser only */

    DRM_WMDRM_CERT_ATTR_SECURITY_VERSION,
    DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SELF_RSA,
    DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SIGNER_RSA
} DRM_WMDRM_CERT_ATTRIBUTE;

typedef enum
{
    DRM_WMDRM_CERT_KEYUSAGE_SIGNCRL     = 0x01,
    DRM_WMDRM_CERT_KEYUSAGE_SIGNCERT    = 0x02,
    DRM_WMDRM_CERT_KEYUSAGE_ENCRYPTKEY  = 0x04
} DRM_WMDRM_CERT_KEYUSAGE;

typedef enum
{
    DRM_WMDRM_CERT_FEATURES_TRUSTEDTRANSMITTER     = 0x01,
    DRM_WMDRM_CERT_FEATURES_TRUSTEDRECEIVER        = 0x02
} DRM_WMDRM_CERT_FEATURES;

#ifdef  __cplusplus
}
#endif

#endif /* _DRM_CERT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmbytemanip.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_BYTEMANIP_H__ 
#define __DRM_BYTEMANIP_H__ 

#ifdef __cplusplus
extern "C" {
#endif

DRM_VOID DRM_API DRM_BYT_ReverseBytes(
    IN OUT DRM_BYTE *pbData,
    IN     DRM_DWORD cbData );

#if SIXTEEN_BIT_ADDRESSING

/* the distinction between BYTE and NATIVE_BYTE is an artificial one solely for
   testing under x86 and other environments capable of addressing 8-bit quantities.
   Redefining a BYTE to be a WORD allows simulation of 16-bit addressing 
   
   For practical reasons it serves as a reminder that what looks like a BYTE isn't
   necessarily the familiar 8 bits */

typedef DRM_BYTE DRM_NATIVE_BYTE;
typedef DRM_CHAR DRM_NATIVE_CHAR;

DRM_VOID DRM_API DRM_BYT_CopyBytes( 
       OUT   DRM_VOID *f_pbTo, 
    IN       DRM_DWORD f_ibTo, 
    IN const DRM_VOID *f_pbFrom,
    IN       DRM_DWORD f_ibFrom,
    IN       DRM_DWORD f_cb );

DRM_VOID DRM_API DRM_BYT_MoveBytes( 
       OUT   DRM_VOID *f_pbTo, 
    IN       DRM_DWORD f_ibTo, 
    IN const DRM_VOID *f_pbFrom,
    IN       DRM_DWORD f_ibFrom,
    IN       DRM_DWORD f_cb );

DRM_VOID DRM_API DRM_BYT_SetBytes(
       OUT DRM_VOID *f_pb,
    IN     DRM_DWORD f_ib,
    IN     DRM_DWORD f_cb,
    IN     DRM_BYTE  f_b );

DRM_INT DRM_API DRM_BYT_CompareBytes(
    IN const DRM_VOID *f_pbA,
    IN       DRM_DWORD f_ibA,
    IN const DRM_VOID *f_pbB,
    IN       DRM_DWORD f_ibB,
    IN       DRM_DWORD f_cb );



DRM_NATIVE_BYTE DRM_API DRM_16B_Read8BitByte(
    IN  const DRM_VOID *f_pv,
    IN        DRM_DWORD f_ib);

DRM_NATIVE_CHAR DRM_API DRM_16B_Read8BitChar(
    IN  DRM_VOID *f_pv,
    IN  DRM_DWORD f_ich);

DRM_VOID DRM_API DRM_16B_Write8BitByte(
    OUT DRM_VOID        *f_pv,
    IN  DRM_DWORD        f_ib,
    IN  DRM_NATIVE_BYTE  f_b);

DRM_VOID DRM_API DRM_16B_Write8BitChar(
    OUT DRM_VOID        *f_pv,
    IN  DRM_DWORD        f_ich,
    IN  DRM_NATIVE_CHAR  f_ch);

DRM_VOID DRM_API DRM_16B_Read8BitBytes(
    IN  DRM_VOID        *f_pv,
    IN  DRM_DWORD        f_cb,
    OUT DRM_NATIVE_BYTE *f_pb);

DRM_VOID DRM_API DRM_16B_Write8BitBytes(
    OUT DRM_VOID        *f_pv,
    IN  DRM_DWORD        f_cb,
    IN  DRM_NATIVE_BYTE *f_pb);

DRM_VOID DRM_API DRM_16B_Read8BitString(
    IN  DRM_VOID        *f_pv,
    IN  DRM_DWORD        f_cch,
    OUT DRM_NATIVE_CHAR *f_pch);

DRM_VOID DRM_API DRM_16B_Write8BitString(
    OUT DRM_VOID        *f_pv,
    IN  DRM_DWORD        f_cch,
    IN  DRM_NATIVE_CHAR *f_pch);

#define DRM_PACK_BYTES_IN_PLACE 0x00000001

DRM_VOID *DRM_API DRM_16B_Pack8BitBytes(
    DRM_NATIVE_BYTE *f_pbMachine,
    DRM_DWORD        f_cbMachine,
    DRM_VOID        *f_pvPacked,
    DRM_DWORD        f_fOptions);

DRM_VOID *DRM_API DRM_16B_IncrementPackedPointer(
    IN OUT DRM_NATIVE_BYTE *f_pbMachine,
    IN     DRM_DWORD        f_cbMachine,
       OUT DRM_NATIVE_BYTE *f_pbHead);

DRM_VOID *DRM_API DRM_16B_DecrementPackedPointer(
    IN OUT DRM_NATIVE_BYTE  *f_pbMachine,
    IN     DRM_DWORD         f_cbMachine,
    IN     DRM_NATIVE_BYTE   f_bHead);

#define GET_BYTE(pb,ib)              DRM_16B_Read8BitByte((pb),(ib))
#define PUT_BYTE(pb,ib,b)            DRM_16B_Write8BitByte((pb),(ib),(b))
#define GET_CHAR(pch,ich)            DRM_16B_Read8BitByte((pch),(ich))
#define PUT_CHAR(pch,ich,ch)         DRM_16B_Write8BitByte((pch),(ich),(ch))

#define MAKE_MACHINE_BYTE(b0,b1)   ((DRM_NATIVE_BYTE)(((b0)<<8)|((b1)&0x00FF)))

#define TWO_BYTES(b0,b1)             MAKE_MACHINE_BYTE(b0,b1)
#define ONE_WCHAR(ch0,ch1)           TWO_BYTES(ch0,ch1)

#else /* 8-bit addressing */


#define DRM_BYT_CopyBytes(to,tooffset,from,fromoffset,count) memcpy(&((to)[(tooffset)]),&((from)[(fromoffset)]),(count))
#define DRM_BYT_MoveBytes(to,tooffset,from,fromoffset,count) memmove(&((to)[(tooffset)]),&((from)[(fromoffset)]),(count))
#define DRM_BYT_SetBytes(pb,ib,cb,b) memset(&((pb)[(ib)]),b,cb)
#define DRM_BYT_CompareBytes(pbA,ibA,pbB,ibB,cb) memcmp(&((pbA)[(ibA)]),&((pbB)[(ibB)]),(cb))

#define GET_BYTE(pb,ib)             (pb)[(ib)]
#define PUT_BYTE(pb,ib,b)           (pb)[(ib)]=(b)
#define GET_CHAR(pch,ich)           (pch)[(ich)]
#define PUT_CHAR(pch,ich,ch)        (pch)[(ich)]=(ch)

#if TARGET_LITTLE_ENDIAN
#define MAKE_MACHINE_WCHAR(ch0,ch1)  ( ((ch1)<<8) | ((ch0) & 0x00FF) )
#else
#define MAKE_MACHINE_WCHAR(ch0,ch1)  ( ((ch0)<<8) | ((ch1) & 0x00FF) )
#endif

#define TWO_BYTES(b0,b1)             b0,b1
#define ONE_WCHAR(ch0,ch1)           MAKE_MACHINE_WCHAR(ch0,ch1)

#endif /* 16/8 bit addressing */

#define MEMSET(pb,ch,cb) DRM_BYT_SetBytes((pb),0,(cb),(ch))
#define ZEROMEM(pb,cb)   DRM_BYT_SetBytes((pb),0,(cb),0)
#define MEMCPY(pbTo,pbFrom,cb)  DRM_BYT_CopyBytes(   (pbTo),0,(pbFrom),0,(cb))
#define MEMMOVE(pbTo,pbFrom,cb) DRM_BYT_MoveBytes(   (pbTo),0,(pbFrom),0,(cb))
#define MEMCMP(pbA,pbB,cb)      DRM_BYT_CompareBytes((pbA) ,0,(pbB),   0,(cb))

#ifdef __cplusplus
}
#endif

#endif /* __DRM_BYTEMANIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcipher.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcipher.h>


DRM_RESULT DRM_API DRM_CPHR_Init(
    OUT       DRM_CIPHER_CONTEXT *pContext,
    IN        DRM_DWORD           cbContKey,
    IN  const DRM_BYTE           *pbContKey )
{
    DRM_RESULT  dr = DRM_E_LOGICERR;
    DRM_UINT    rnd_bytes[16];    
    DRM_UINT    rnd_bytes2[16];
    DRM_INT i=0;
    
    DRMCASSERT( SIZEOF( SHA_CONTEXT ) < SIZEOF( RC4_KEYSTRUCT ) );

    ChkArg (pbContKey  != NULL
        &&  cbContKey   > 0 
        &&  pContext   != NULL);

    ZEROMEM( pContext, SIZEOF( DRM_CIPHER_CONTEXT ) );
    /* hash to song key to 20 bytes length. first 12 bytes used as a MAC key, the following */
    /* 8 (7) bytes as a DES key */
    DRM_SHA_Init( (SHA_CONTEXT*)&pContext->m_rc4ks );
    DRM_SHA_Update( pbContKey, cbContKey, (SHA_CONTEXT*)&pContext->m_rc4ks );
    DRM_SHA_Finalize( (SHA_CONTEXT*)&pContext->m_rc4ks, pContext->m_shaOut );

    ZEROMEM( rnd_bytes2, SIZEOF( rnd_bytes ) );

    DRM_RC4_KeySetup( &pContext->m_rc4ks, 12, pContext->m_shaOut );
    DRM_RC4_Cipher( &pContext->m_rc4ks, SIZEOF( rnd_bytes2 ), (DRM_BYTE *)rnd_bytes2 );

    for( i=0; i<NO_OF(rnd_bytes2); i++)
    {
        BYTES_TO_DWORD( rnd_bytes[i], ((DRM_BYTE*)(rnd_bytes2 + i) ) );
    }
    
    pContext->m_mackey.a1 = rnd_bytes[0]  | 0x00000001;
    pContext->m_mackey.b1 = rnd_bytes[1]  | 0x00000001;
    pContext->m_mackey.c1 = rnd_bytes[2]  | 0x00000001;
    pContext->m_mackey.d1 = rnd_bytes[3]  | 0x00000001;
    pContext->m_mackey.e1 = rnd_bytes[4]  | 0x00000001;
    pContext->m_mackey.f1 = rnd_bytes[5]  | 0x00000001;
    pContext->m_mackey.a2 = rnd_bytes[6]  | 0x00000001;
    pContext->m_mackey.b2 = rnd_bytes[7]  | 0x00000001;
    pContext->m_mackey.c2 = rnd_bytes[8]  | 0x00000001;
    pContext->m_mackey.d2 = rnd_bytes[9]  | 0x00000001;
    pContext->m_mackey.e2 = rnd_bytes[10] | 0x00000001;
    pContext->m_mackey.f2 = rnd_bytes[11] | 0x00000001;

    pContext->m_invmackey.a1 = DRM_MAC_inv32( pContext->m_mackey.a1 );
    pContext->m_invmackey.a2 = DRM_MAC_inv32( pContext->m_mackey.a2 );
    pContext->m_invmackey.b1 = DRM_MAC_inv32( pContext->m_mackey.b1 );
    pContext->m_invmackey.b2 = DRM_MAC_inv32( pContext->m_mackey.b2 );
    pContext->m_invmackey.c1 = DRM_MAC_inv32( pContext->m_mackey.c1 );
    pContext->m_invmackey.c2 = DRM_MAC_inv32( pContext->m_mackey.c2 );
    pContext->m_invmackey.d1 = DRM_MAC_inv32( pContext->m_mackey.d1 );
    pContext->m_invmackey.d2 = DRM_MAC_inv32( pContext->m_mackey.d2 );
    pContext->m_invmackey.e1 = DRM_MAC_inv32( pContext->m_mackey.e1 );
    pContext->m_invmackey.e2 = DRM_MAC_inv32( pContext->m_mackey.e2 );

    pContext->m_desS1[0] = rnd_bytes[12]; 
    pContext->m_desS1[1] = rnd_bytes[13];
    pContext->m_desS2[0] = rnd_bytes[14]; 
    pContext->m_desS2[1] = rnd_bytes[15];

    DRM_DES_KeySetup( &pContext->m_destable, pContext->m_shaOut + __CB_DECL(12) );  
    pContext->m_fInited = TRUE;

    dr = DRM_SUCCESS;
ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_CPHR_InitDecrypt
** 
** Synopsis :   Initializes state for phased decryption
** 
** Arguments :  f_pcontextCipher - Cipher context initialized with DRM_CPHR_Init
**              f_pbLast15    - Last 15 bytes of ciphertext
**              f_cbData      - # of bytes in ENTIRE ciphertext              
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_CPHR_InitDecrypt(
    IN  DRM_CIPHER_CONTEXT  *f_pcontextCipher,
    IN  DRM_BYTE            *f_pbLast15,
    IN  DRM_DWORD            f_cbData )
{
    DRM_DWORD  cbClear = 0;
    DRM_RESULT dr      = DRM_SUCCESS;    
        
    ChkArg( f_pcontextCipher != NULL
         && f_pbLast15       != NULL );

    if (!f_pcontextCipher->m_fInited)
    {
        ChkDR(DRM_E_CIPHER_NOTINITIALIZED);
    }
    
    /*
    **  Initialize data required for phased decryption
    */
    f_pcontextCipher->m_cbPacket       = f_cbData;
    f_pcontextCipher->m_iPacket        = 0;
    f_pcontextCipher->m_fDecryptInited = TRUE;
        
    if ( f_cbData < 16 )
    {        
        /* No need to do any other intialization  */
        goto ErrorExit;
    }

    /*
    **  Find Number of clear bytes
    */
    cbClear = f_cbData % 8;

    /*
    **  Extract the last 8 bytes before the clear content
    ** (To find these bytes start at the end of the last 15 bytes,
    **  subtract the number of clear bytes, then move 8 more bytes back,
    **  i.e. 15 - (cbClear + 8) ).
    */
    DRM_BYT_CopyBytes( (DRM_BYTE*)f_pcontextCipher->m_rguiLast8, 
                       0, 
                       f_pbLast15,
                       15 - ( cbClear + 8 ),
                       2 * SIZEOF(DRM_UINT) );    
    
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rguiLast8[0] );
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rguiLast8[1] );   

    /*    
    **  XOR the last 8 bytes(right before the clear content) with the DES key
    */    
    f_pcontextCipher->m_rguiLast8[0] ^= f_pcontextCipher->m_desS2[0];
    f_pcontextCipher->m_rguiLast8[1] ^= f_pcontextCipher->m_desS2[1];
    
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rguiLast8[0] );
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rguiLast8[1] );   
    
    /*
    **  Use the DES key to decrypt the 8 bytes. The result is the XOR'd RC4 
    **  content encryption key for the payload.
    */                
    DRM_DES_Decrypt( (DRM_BYTE *)f_pcontextCipher->m_rguiLast8, 
                     (DRM_BYTE *)f_pcontextCipher->m_rc4key, 
                     &f_pcontextCipher->m_destable );
    
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rguiLast8[0] );
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rguiLast8[1] );
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rc4key[0] );
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rc4key[1] );

    /*
    **  XOR the 8 bytes resulting from the DES decryption with the DES key. 
    **  The result is the RC4 content key for the packet
    */
    f_pcontextCipher->m_rc4key[0] ^= f_pcontextCipher->m_desS1[0];
    f_pcontextCipher->m_rc4key[1] ^= f_pcontextCipher->m_desS1[1];

    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rc4key[0] );
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rc4key[1] );
    
    /*
    **  Setup the RC4 key to decrypt content
    */
    DRM_RC4_KeySetup( &f_pcontextCipher->m_rc4ks, 
                      8, 
                      (DRM_BYTE *)f_pcontextCipher->m_rc4key ); 
    
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rc4key[0] );
    FIX_ENDIAN_DWORD( f_pcontextCipher->m_rc4key[1] );

    /*
    **  Initialize cbc state
    */
    DRM_CBC64InitState( &(f_pcontextCipher->m_cbcstate) );
           
ErrorExit:
    return dr;
}
    
/******************************************************************************
** 
** Function :   DRM_CPHR_Decrypt
** 
** Synopsis :   Decrypts part of the ciphertext. This function must be called 
**              after DRM_CPHR_InitDecrypt has been successful
** 
** Arguments :  f_pcontextCipher - Cipher context initialized with DRM_CPHR_Init,
**                                 followed by DRM_CPHR_InitDecrypt
**              f_cbData  - # of bytes of data to be decrypted
**              f_pbData  - Pointer to encrypted buffer
** 
** Notes :      IMPORTANT: Phased decrypt should be called on segments of 
**              encrypted data sequentially, i.e. if encrypted data is divided 
**              four segments, the order of decryption should be segment 1,
**              followed by 2, 3, 4.
**              To remove complexity we do not handle the case where
**              a packet is split somewhere in the middle of the last 15 bytes.
**              The caller is responsible to ensure that the last 15 bytes never
**              straddle multiple calls to Decrypt.
******************************************************************************/
DRM_RESULT DRM_API DRM_CPHR_Decrypt(
    IN     DRM_CIPHER_CONTEXT *f_pcontextCipher,
    IN     DRM_DWORD           f_cbData, 
    IN OUT DRM_BYTE           *f_pbData )
{
    DRM_RESULT  dr = DRM_SUCCESS;
    DRM_DWORD   imac_start        = 0, 
                imac_end          = 0, 
                segment_end       = 0, 
                imac_in_seg_start = 0, 
                imac_in_seg_end   = 0;    
    
    ChkArg( f_pbData            != NULL
         && f_pcontextCipher    != NULL
         && (f_pcontextCipher->m_iPacket + f_cbData) <= f_pcontextCipher->m_cbPacket );

    if (!f_pcontextCipher->m_fInited)
    {
        ChkDR(DRM_E_CIPHER_NOTINITIALIZED);
    }

    if (!f_pcontextCipher->m_fDecryptInited)
    {
        ChkDR(DRM_E_DECRYPT_NOTINITIALIZED);
    }

    if (f_cbData == 0)
    {
        goto ErrorExit;
    }
    
    /*
    **  small packet case: MAC does not handle it
    */
    if ( f_pcontextCipher->m_cbPacket < 16 )
    {
        DRM_DWORD iData = 0;
        for ( iData = 0; iData < f_cbData; iData++)
        {
            DRM_BYTE bSHA = GET_BYTE( f_pcontextCipher->m_shaOut,
                                      iData + f_pcontextCipher->m_iPacket );
            DRM_BYTE bData = GET_BYTE( f_pbData, iData);

            PUT_BYTE( f_pbData, iData, bData ^ bSHA);
        }
        
        f_pcontextCipher->m_iPacket += f_cbData;
        goto ErrorExit;
    }   

    imac_end    = (f_pcontextCipher->m_cbPacket / 8) * 8;
    imac_start  = imac_end - 8;
    segment_end = f_pcontextCipher->m_iPacket + f_cbData;

    if ( segment_end > imac_start ) 
    {
        /* NOTE:  To remove complexity we do not handle the case where
           a packet is split somewhere in the middle of the last 15 bytes */
        DRMASSERT( segment_end == f_pcontextCipher->m_cbPacket );

        /* Set the last 8 bytes correctly */
        DRM_BYT_CopyBytes( f_pbData,
                           imac_start - f_pcontextCipher->m_iPacket,
                           (DRM_BYTE*)f_pcontextCipher->m_rguiLast8, 
                           0, 
                           2 * SIZEOF(DRM_UINT) );
    }

    /*
    **  RC4 decrypt the content
    */
    DRM_RC4_Cipher( &f_pcontextCipher->m_rc4ks, f_cbData, f_pbData );
    
    if ( f_pcontextCipher->m_iPacket < imac_start ) 
    {
        if ( f_pcontextCipher->m_iPacket + f_cbData >= imac_start ) 
        {
            DRM_UINT mac1 = 0;
            DRM_UINT mac2 = 0;
            DRM_UINT macInverse1 = 0;
            DRM_UINT macInverse2 = 0;

            /*
            **  First update MAC with data from this segment
            */            
            DRM_CBC64Update( &f_pcontextCipher->m_mackey, 
                         &f_pcontextCipher->m_cbcstate, 
                         imac_start - f_pcontextCipher->m_iPacket, 
                         f_pbData );
            
            /*
            **  Finalize MAC to decipher last 8 bytes of encrypted data 
            */
            mac1 = DRM_CBC64Finalize( &f_pcontextCipher->m_mackey, 
                                  &f_pcontextCipher->m_cbcstate, 
                                  &mac2 );
            macInverse2 = DRM_CBC64Invert( &f_pcontextCipher->m_mackey, 
                                       &f_pcontextCipher->m_invmackey, 
                                       mac1, 
                                       mac2, 
                                       f_pcontextCipher->m_rc4key[0], 
                                       f_pcontextCipher->m_rc4key[1], 
                                       &macInverse1 );
            f_pcontextCipher->m_rc4key[0] = macInverse1; 
            f_pcontextCipher->m_rc4key[1] = macInverse2;
        }
        else 
        {
            /*
            **  Update MAC with data from this segment
            */             
            DRM_CBC64Update( &f_pcontextCipher->m_mackey, 
                         &f_pcontextCipher->m_cbcstate, 
                         f_cbData, 
                         f_pbData );
        }
    }
         
    if ( f_pcontextCipher->m_iPacket < imac_end 
      && segment_end                 > imac_start ) 
    {
        /*
        **  Insert last 8 bytes of data deciphered
        */        
        DRM_BYTE  rgbMac[__CB_DECL(8)];
        DRM_DWORD iData = 0;
        
        DWORD_TO_BYTES( rgbMac,                f_pcontextCipher->m_rc4key[0] );
        DWORD_TO_BYTES( rgbMac + __CB_DECL(4), f_pcontextCipher->m_rc4key[1] );

        imac_in_seg_start = (imac_start >= f_pcontextCipher->m_iPacket) ? 
                                            imac_start : f_pcontextCipher->m_iPacket;
        imac_in_seg_end = (imac_end <= segment_end) ? imac_end:segment_end;
        
        for ( iData = imac_in_seg_start; iData < imac_in_seg_end; iData++ ) 
        {
            PUT_BYTE( f_pbData, 
                      iData - f_pcontextCipher->m_iPacket, 
                      GET_BYTE( rgbMac, iData - imac_start ) );
        }
    }    

    f_pcontextCipher->m_iPacket += f_cbData;
    if ( f_pcontextCipher->m_iPacket >= f_pcontextCipher->m_cbPacket )
    {
        f_pcontextCipher->m_fDecryptInited = FALSE;
    }


ErrorExit:
    return dr;
}

/*****************************************************************************/
DRM_RESULT DRM_API DRM_CPHR_Encrypt(
    IN     DRM_CIPHER_CONTEXT *pContext,
    IN     DRM_DWORD           cbData,
    IN OUT DRM_BYTE           *pbData )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_UINT   macLength4; /* mac length in four byte blocks */
    DRM_DWORD  rc4key    [2];
    DRM_DWORD  rguiLast8 [2];    

    ChkArg( pbData   != NULL 
         && pContext != NULL );
    
    if (!pContext->m_fInited)
    {
        ChkDR(DRM_E_CIPHER_NOTINITIALIZED);
    }
    
    /* small packet case: MAC does not handle it */
    if ( cbData < 16 )
    {        
        for ( rc4key[0]=0; rc4key[0] < cbData; rc4key[0]++ )
        {
            DRM_BYTE bTemp = GET_BYTE( pbData, rc4key[0] );
            bTemp ^= GET_BYTE( pContext->m_shaOut, rc4key[0] );
            PUT_BYTE( pbData, rc4key[0], bTemp );
        }        
    }
    else
    {
        /* making sure block number is even */
        macLength4 = (cbData / 8) * 2; 
        MEMCPY( rguiLast8, (pbData + __CB_DECL(4 * macLength4 - 8)), NO_OF(rguiLast8) * SIZEOF(DRM_UINT) );
        
        /* run MAC over data */
        DRM_CBC_Mac( pbData, macLength4, rc4key, &(pContext->m_mackey) );

        /* RC4 encrypt content */
        FIX_ENDIAN_DWORD( rc4key[0] );
        FIX_ENDIAN_DWORD( rc4key[1] );

        DRM_RC4_KeySetup( &pContext->m_rc4ks, 8, (DRM_BYTE *)rc4key );                
        DRM_RC4_Cipher(   &pContext->m_rc4ks, cbData, pbData );
        FIX_ENDIAN_DWORD( rc4key[0] );
        FIX_ENDIAN_DWORD( rc4key[1] );
        
        /* DES encrypt MAC and put it in the right place */
        rc4key[0] ^= pContext->m_desS1[0];
        rc4key[1] ^= pContext->m_desS1[1];
        
        FIX_ENDIAN_DWORD( rc4key[0] );
        FIX_ENDIAN_DWORD( rc4key[1] );
        DRM_DES_Encrypt( (DRM_BYTE *)rc4key, (DRM_BYTE*)rguiLast8, &pContext->m_destable);
        
        FIX_ENDIAN_DWORD( rguiLast8[0] );
        FIX_ENDIAN_DWORD( rguiLast8[1] );
        rguiLast8[0] ^= pContext->m_desS2[0];
        rguiLast8[1] ^= pContext->m_desS2[1];
        DWORD_TO_BYTES( (pbData + __CB_DECL(4 * macLength4 - 8)), rguiLast8[0] );
        DWORD_TO_BYTES( (pbData + __CB_DECL(4 * macLength4 - 4)), rguiLast8[1] );
    }
    dr = DRM_SUCCESS;
ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmchain.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_CHAIN_H__
#define __DRM_CHAIN_H__

#ifdef __cplusplus
extern "C" {
#endif

#define DRM_MAX_COPY_OPL_DATA_SIZE (1024*4)
#define DRM_MAX_PLAY_OPL_DATA_SIZE (128)

typedef DRM_RESULT (DRM_API *pfnCheckDeviceRevocation)(DRM_LICEVAL_CONTEXT* pLicEvalContext, DRM_VOID *pv );

#define DRM_POLICY_FLAG_ONLINE_DISABLED              0x00000001
#define DRM_POLICY_FLAG_METERING_DISABLED_ENTERPRISE 0x00000002

#if DRM_SUPPORT_COPY_OPL
typedef struct __tagCOPY_OPL_CHAIN
{
    DRM_BYTE     rgbCopyOPLBuffer[__CB_DECL(DRM_MAX_COPY_OPL_DATA_SIZE)];
    DRM_COPY_OPL oplCopy;
} COPY_OPL_CHAIN;
#endif

typedef struct __tagPLAY_OPL_CHAIN
{
    DRM_BYTE     rgbPlayOPLBuffer[__CB_DECL(DRM_MAX_PLAY_OPL_DATA_SIZE)];
    DRM_PLAY_OPL oplPlay;
} PLAY_OPL_CHAIN;


typedef struct _FFLICENSE
{
    IN     DRM_LICSTORE_CONTEXT     *pLicStore; /* Context to an Open license store */
           DRM_LICSTOREENUM_CONTEXT *pLicStoreEnum; /* Enumerators for all depths, [0] should be initialized */
    IN OUT DRM_SECSTORE_CONTEXT     *pSecStoreLicense;
    IN     DRM_LICEVAL_CONTEXT      *pLicEval;
    IN     DRM_V1Header             *pV1Header;
       OUT DRM_BINDING_INFO         *pBindingInfo; /* This should point to an array of DRM_MAX_LICENSE_CHAIN_DEPTH binding infos. */
    IN     DRM_BYTE                 *pbBuffer;     /* Working buffer */
    IN     DRM_DWORD                 cbBuffer;
    IN     DRM_DWORD                 dwChainDepth; /* The current depth of the chain.  If we are looking for the first license this is 0 */
    IN     DRM_DWORD                 dwPolicyFlags; /* bitmask of policy flags */
    IN     DRM_BYTE                  rgbRevocationPassword [__CB_DECL(SHA_DIGEST_LEN)];
           DRM_BYTE                  rgbLicensePassword    [__CB_DECL(SHA_DIGEST_LEN)];    
       OUT DRM_BOOL                  fSecStoreOpen         [DRM_MAX_LICENSE_CHAIN_DEPTH]; /* On function exit the caller should close the stores if they are open */
       OUT DRM_BOOL                  rgfDeleteLicense      [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_KID                   rgkid                 [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_LID                   rglid                 [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_HDS_SLOT_HINT         rgslotHint            [DRM_MAX_LICENSE_CHAIN_DEPTH];
#if DRM_SUPPORT_METERING
       OUT DRM_MID                   rgmid                 [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_BOOL                  rgfHasMetering        [DRM_MAX_LICENSE_CHAIN_DEPTH]; /* On function exit the caller should close the stores if they are open */
#endif

#if DRM_SUPPORT_COPY_OPL
       OUT COPY_OPL_CHAIN            rgCopyOpl             [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_BOOL                  rgfCopyOplValid       [DRM_MAX_LICENSE_CHAIN_DEPTH];
#endif
       OUT PLAY_OPL_CHAIN            rgPlayOpl             [DRM_MAX_LICENSE_CHAIN_DEPTH];
       OUT DRM_BOOL                  rgfPlayOplValid       [DRM_MAX_LICENSE_CHAIN_DEPTH];

#if DRM_SUPPORT_WMDRMNET       
       OUT DRM_DWORD                 dwMinimumRequiredAppSec;
#endif
#if DRM_SUPPORT_REVOCATION
    IN      DRM_REVLIST_ID_VALUES    idCRLsCurrent;   
        OUT DRM_DWORD                fUpdatedRevocationList;
#endif
    IN      DRM_BOOL                 fCanBind;
        OUT DRM_DWORD                dwSourceid;
} DRM_FFLICENSE;

/* This function is recursive!!! 
   INPUTS -- stuff in DRM_FFLICENSE struct
   OUTPUT -- array of binding info structures to pass to CreateDecryptor
             Array of open secure store contexts 
             Array of KID/LID pairs that were used in the chain
  Caller should call CreateDecryptor when ready 
  Will have to read the license in again. 
  Caller should then read each license in and do the DoneWithOperation for each license
  Caller should then update metering data for each license */

DRM_RESULT DRM_API DRM_LIC_CompleteLicenseChain(
    IN OUT   DRM_FFLICENSE              *pFFLicense,
    IN const DRM_CONST_STRING           *rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD                   cRights,
       OUT   DRM_DWORD                  *pdwChainDepth,
    IN       DRM_HDS_CONTEXT            *pcontextHDS,
    IN       DRMPFNOUTPUTLEVELSCALLBACK  pfnOutputRestrictionsCallback,
    IN const DRM_VOID                   *pv );

DRM_RESULT DRM_API DRM_LIC_ReportActions(
    IN OUT   DRM_FFLICENSE         *pFFLicense,
    IN const DRM_CONST_STRING      *rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD              cRights,
    IN       DRM_DWORD              dwChainDepth,
    IN       DRM_HDS_CONTEXT       *pcontextHDS);

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK

DRM_RESULT DRM_API DRM_LIC_CheckClockRollback(  
    IN DRM_LICEVAL_CONTEXT      *pLicEval,
    IN DRM_LICSTORE_CONTEXT     *pLicStore,
    IN DRM_LICSTOREENUM_CONTEXT *pLicEnum,
    IN DRM_BYTE                 *pbBuffer,
    IN DRM_DWORD                 cbBuffer,
    IN DRM_HDS_CONTEXT          *pcontextHDS);

#endif /* DRM_SUPPORT_ANTIROLLBACK_CLOCK  */

#ifdef __cplusplus
}
#endif

#endif  /* __DRM_CHAIN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcipher.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMCIPHER_H__
#define __DRMCIPHER_H__


#include <drmsha1.h>
#include <drmdes.h>
#include <drmrc4.h>
#include <drmcbc.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct __tagDRM_CIPHER_CONTEXT
{
    DRM_BYTE      m_shaOut [__CB_DECL(SHA_DIGEST_LEN)];
    DRM_UINT      m_desS1  [2],
                  m_desS2  [2];
    DESTable      m_destable;
    DRM_CBCKey    m_mackey,
                  m_invmackey;    
    RC4_KEYSTRUCT m_rc4ks;
    DRM_BOOL      m_fInited;
    DRM_BOOL      m_fDecryptInited;
    DRM_CBCState  m_cbcstate;                   
    DRM_DWORD     m_rc4key[2]; 
    DRM_UINT      m_rguiLast8[2];
    DRM_DWORD     m_cbPacket;            
    DRM_DWORD     m_iPacket;                                  
} DRM_CIPHER_CONTEXT;

#define DRM_CPHR_CB_FOR_INITDECRYPT     15

/*********************************************************************
**
**  Function:  DRM_CPHR_Init
**
**  Synopsis:  Initializes a content cipher context.  This must be done prior to using DRM_CPHR_Encrypt or
**             DRM_CHPR_Decrypt.
**
**  Arguments:  
**     [pContext] -- The cipher content to be initialized
**     [cbContKey] -- The length of pbContKey in bytes
**     [pbContKey] -- The content key
**
**  Notes:  For most DRM content cbContKey should be DRMCIPHERKEYLEN
**
*********************************************************************/
DRM_RESULT DRM_API DRM_CPHR_Init(
    OUT       DRM_CIPHER_CONTEXT *pContext,
    IN        DRM_DWORD           cbContKey,
    IN  const DRM_BYTE           *pbContKey );

/*********************************************************************
**
**  Function:  DRM_CPHR_Encrypt
**
**  Synopsis:  Encrypts an array of bytes using the DRM content cipher algorithm
**
**  Arguments:  
**     [pContext] -- Cipher context initialized with DRM_CPHR_Init
**     [cbData] -- Length of pbData in bytes
**     [pbData] -- Array of bytes to encrypt
**
**  Notes:  Encryption is done in place.
**
*********************************************************************/
DRM_RESULT DRM_API DRM_CPHR_Encrypt(
    IN     DRM_CIPHER_CONTEXT *pContext,
    IN     DRM_DWORD           cbData,
    IN OUT DRM_BYTE           *pbData );

/******************************************************************************
** 
** Function :   DRM_CPHR_InitDecrypt
** 
** Synopsis :   Initializes state for phased decryption
** 
** Arguments :  f_pcontextCipher - Cipher context initialized with DRM_CPHR_Init,
**                                 followed by DRM_CPHR_InitDecrypt
**              f_pbLast15    - Last 15 bytes of ciphertext
**              f_cbData      - # of bytes in ENTIRE ciphertext              
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_CPHR_InitDecrypt(
    IN  DRM_CIPHER_CONTEXT  *pcontextCipher,
    IN  DRM_BYTE            *pbLast15,
    IN  DRM_DWORD            cbData );

/******************************************************************************
** 
** Function :   DRM_CPHR_Decrypt
** 
** Synopsis :   Decrypts part of the ciphertext. This function must be called 
**              after DRM_CPHR_InitDecrypt has been successful
** 
** Arguments :  f_pcontextCipher - Cipher context initialized with DRM_CPHR_Init,
**                                 followed by DRM_CPHR_InitDecrypt
**              f_cbData  - # of bytes of data to be decrypted
**              f_pbData  - Pointer to encrypted buffer
** 
** Returns :    
** 
** Notes :      IMPORTANT: Phased decrypt should be called on segments of 
**              encrypted data sequentially, i.e. if encrypted data is divided 
**              four segments, the order of decryption should be segment 1,
**              followed by 2, 3, 4.
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_CPHR_Decrypt(
    IN     DRM_CIPHER_CONTEXT *pContext,
    IN     DRM_DWORD           cbData, 
    IN OUT DRM_BYTE           *pbData );

#ifndef DRMCIPHERKEYLEN
#define DRMCIPHERKEYLEN   7
#endif


#ifdef __cplusplus
}
#endif

#endif /* __DRMCIPHER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcertparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmxmlparser.h>
#include <drmdevcert.h>
#include <drmdes.h>
#include <drmpkcrypto.h>
#include <oemimpl.h>
#include <drmrsaex.h>
#include <drmdevcert.h>
#include <drmcert.h>
#include <drmxmlbuilder.h>
#include <drmcertparser.h>
#include <drmbase64.h>


#if DRM_SUPPORT_REVOCATION
/******************************************************************************
** Function :   DRM_WCP_GetCertificateType
** Synopsis :   determine the 'level' of a certificate (CertificateAuthority,
**              BlackBox, etc).
** Arguments :  [f_pszBase]     : base of buffer
**              [f_pdasstrCert] : SUBSTRING pointing to the entire certificate
**              [f_pcerttype]   : variable to receive the type
******************************************************************************/

DRM_RESULT DRM_API DRM_WCP_GetCertificateType(
  IN    const DRM_CHAR             *f_pszBase,
  IN    const DRM_SUBSTRING        *f_pdasstrCert,
  OUT   enum  DRM_CERTIFICATE_TYPE *f_pcerttype)
{
    DRM_RESULT    dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrData     = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrBody     = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrSecurity = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrManufacturerData    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrModel    = EMPTY_DRM_SUBSTRING;

    ChkArg(f_pszBase       != NULL
        && f_pdasstrCert   != NULL
        && f_pcerttype     != NULL);

    ChkDR(DRM_XML_GetNodeA(f_pszBase,  
                           f_pdasstrCert, 
                          &g_dastrTagWMDRMCertificate, 
                           NULL, 
                           NULL, 
                           0, 
                           NULL,
                          &dasstrBody));

    /* HWID is one of 2 tags only found in machine certs */

    ChkDR(DRM_XML_GetNodeA(f_pszBase,  
                          &dasstrBody, 
                          &g_dastrTagWMDRMData, 
                           NULL, 
                           NULL, 
                           0, 
                           NULL,
                          &dasstrData));

    dr = DRM_XML_GetNodeA(f_pszBase,  
                          &dasstrData, 
                          &g_dastrTagHardwareID, 
                           NULL, 
                           NULL, 
                           0, 
                          &dasstrSecurity,
                           NULL);

    /* the distinction between machine and other certs is the only one that matters here */

    if (dr == DRM_SUCCESS)
    {
        *f_pcerttype = certtypeMachine;
    }
    else
    {
        DRM_SUBSTRING dasstrDataNodes = EMPTY_DRM_SUBSTRING;
        DRM_SUBSTRING dasstrFeature   = EMPTY_DRM_SUBSTRING;
        DRM_SUBSTRING dasstrOne       = EMPTY_DRM_SUBSTRING;

        /* It's one of the leafmost certificate types; narrow it down */
        /* can't use GetAttribute here, it calls this function */

        ChkDR(DRM_XML_GetNodeA (f_pszBase, &dasstrBody,      &g_dastrTagWMDRMData,         NULL, NULL, 0, NULL, &dasstrDataNodes));
        dr =  DRM_XML_GetNodeA (f_pszBase, &dasstrDataNodes, &g_dastrTagWMDRMCertFeatures, NULL, NULL, 0, NULL, &dasstrDataNodes);

        if (DRM_SUCCEEDED(dr))
        {
            ChkDR(DRM_XML_EnumNextNodeA(f_pszBase, &dasstrDataNodes, 0, &dasstrFeature,               NULL, &dasstrOne, NULL,  NULL));

            if (DRM_UTL_DASSTRStringsEqual    (f_pszBase, &dasstrFeature, &g_dastrFeatureExport))
            {
                *f_pcerttype = certtypeExport;
            }
            else if (DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrFeature, &g_dastrFeatureExportIncl))
            {
                *f_pcerttype = certtypeExportIncl;
            }
            else if (DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrFeature, &g_dastrFeatureSampleProtection))
            {
                *f_pcerttype = certtypeSampleProtection;
            }
            else 
            {
                /* If the cert has a ManufacturerData->ModelNumber tag, it must be a non-machine, device cert.
                 * Every cert MUST have a ManufacturerData node 
                 */
                dr = DRM_XML_GetNodeA(f_pszBase, &dasstrData, &g_dastrTagManufacturerData, NULL, NULL, 0, NULL, &dasstrManufacturerData );
                ChkDR( dr );
                
                dr = DRM_XML_GetNodeA(f_pszBase, &dasstrManufacturerData, &g_dastrTagModelNumber, NULL, NULL, 0, &dasstrModel, NULL);
                if( dr == DRM_SUCCESS )
                {
                    *f_pcerttype = certtypeDevice; 
                }
                else
                {
                    *f_pcerttype = certtypeCertAuthority; 
                    dr = DRM_SUCCESS;
                }
            }
        }
        else
        {
            /* This code is reached when a CRL signing cert is being parsed */
            *f_pcerttype = certtypeCertAuthority; 
            dr = DRM_SUCCESS;
        }
    }

    ErrorExit:
        return dr;
} /* DRM_WCP_GetCertificateType */

/******************************************************************************
** Function :   
** Synopsis :   
** Arguments :  [f_pszBase]     : base of buffer
**              [f_pdasstrCert] : SUBSTRING pointing to the entire certificate
**
******************************************************************************/

DRM_RESULT DRM_API DRM_WCP_GetAttribute(
  IN const DRM_CHAR              *f_pszBase,
  IN const DRM_SUBSTRING         *f_pdasstrCert,
  IN     DRM_WMDRM_CERT_ATTRIBUTE f_attribute,
     OUT DRM_SUBSTRING            f_rgdasstrValue [],
  IN OUT DRM_DWORD               *f_pcEntries)
{
    DRM_RESULT    dr                = DRM_SUCCESS;
    DRM_DWORD     iNode             = 0;
    DRM_DWORD     cNodes            = 0;
    DRM_ANSI_CONST_STRING dastrCert = EMPTY_DRM_STRING;
    DRM_SUBSTRING dasstrData        = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDataNodes   = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrUsage       = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstr0           = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstr1           = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstr2           = EMPTY_DRM_SUBSTRING;
    enum DRM_CERTIFICATE_TYPE certtype = certtypeUnknown;

    ChkArg(f_pszBase       != NULL
        && f_pdasstrCert   != NULL
        && f_pcEntries     != NULL
        && f_pdasstrCert->m_cch > 0);

    ChkDR(DRM_WCP_GetCertificateType(f_pszBase,
                                     f_pdasstrCert,
                                    &certtype));

    /* only machine certs have a security level attribute */

    if (certtype == certtypeMachine)
    {
        ChkArg(f_attribute  == DRM_WMDRM_CERT_ATTR_SECURITY_LEVEL
            || f_attribute  == DRM_WMDRM_CERT_ATTR_KEY_USAGE
            || f_attribute  == DRM_WMDRM_CERT_ATTR_FEATURES
            || f_attribute  == DRM_WMDRM_CERT_ATTR_SECURITY_VERSION
            || f_attribute  == DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SELF_RSA
            || f_attribute  == DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SIGNER_RSA
            || f_attribute  == DRM_WMDRM_CERT_ATTR_DIGEST_VALUE );
    }
    else if (certtype == certtypeDevice)
    {
        ChkArg(f_attribute  == DRM_WMDRM_CERT_ATTR_SECURITY_LEVEL
            || f_attribute  == DRM_WMDRM_CERT_ATTR_KEY_USAGE
            || f_attribute  == DRM_WMDRM_CERT_ATTR_FEATURES
            || f_attribute  == DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SELF_RSA
            || f_attribute  == DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SIGNER_RSA
            || f_attribute  == DRM_WMDRM_CERT_ATTR_DIGEST_VALUE );
    }
    else
    {
        ChkArg(f_attribute  == DRM_WMDRM_CERT_ATTR_KEY_USAGE
            || f_attribute  == DRM_WMDRM_CERT_ATTR_FEATURES
            || f_attribute  == DRM_WMDRM_CERT_ATTR_SECURITY_VERSION
            || f_attribute  == DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SELF_RSA
            || f_attribute  == DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SIGNER_RSA
            || f_attribute  == DRM_WMDRM_CERT_ATTR_DIGEST_VALUE );
    }

    ChkDR(DRM_XML_GetNodeA(f_pszBase, f_pdasstrCert, &g_dastrTagWMDRMCertificate, NULL, NULL, 0, NULL, &dasstrData));

    /* this attribute is retrieved from the <Signature> node, not from <c:Data> */

    if (f_attribute != DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SIGNER_RSA)
    {
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrData,   &g_dastrTagWMDRMData,        NULL, NULL, 0, NULL, &dasstrDataNodes));
    }

    switch (f_attribute)
    {
    case DRM_WMDRM_CERT_ATTR_KEY_USAGE:
        /*    
        ** <c:KeyUsage>
        **    <c:SignCertificate/>
        **    <c:SignCRL/>
        **    <c:EncryptKey/>
        ** </c:KeyUsage>
        */

        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrDataNodes, &g_dastrTagWMDRMCertKeyUsage, NULL, NULL, 0, NULL, &dasstrUsage));

        ChkDR(DRM_XML_CountMatchingNodesA(f_pszBase, &dasstrUsage, NULL, NULL, NULL, &cNodes));

        if (f_rgdasstrValue == NULL
        || *f_pcEntries      < cNodes)
        {
            *f_pcEntries = cNodes;
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
        
        *f_pcEntries = cNodes;

        for (iNode = 0; iNode < cNodes; iNode++)
        {
            DRM_SUBSTRING dasstrTag = EMPTY_DRM_SUBSTRING;

            ChkDR(DRM_XML_EnumNextNodeA(f_pszBase,
                                       &dasstrUsage, 
                                        iNode,
                                        f_rgdasstrValue + iNode, /* strings are in the <Tag> */
                                        NULL,
                                       &dasstrTag,
                                        NULL,
                                        NULL));

        }
        break;
    
    case DRM_WMDRM_CERT_ATTR_SECURITY_LEVEL:
        if (f_rgdasstrValue == NULL
        || *f_pcEntries      < 1)
        {
            *f_pcEntries = 1;
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

       *f_pcEntries = 1;

       ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrDataNodes, &g_dastrTagWMDRMCertSecurityLevel, NULL, NULL, 0, NULL, f_rgdasstrValue));
        break;

    case DRM_WMDRM_CERT_ATTR_SECURITY_VERSION:
        if (f_rgdasstrValue == NULL
        || *f_pcEntries      < 1)
        {
            *f_pcEntries = 1;
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }

       *f_pcEntries = 1;

        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrDataNodes, &g_dastrTagWMDRMCertSecurityVersion, NULL, NULL, 0, NULL, f_rgdasstrValue));
        break;

    case DRM_WMDRM_CERT_ATTR_FEATURES:
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrDataNodes, &g_dastrTagWMDRMCertFeatures,        NULL, NULL, 0, NULL, &dasstrDataNodes));

        ChkDR(DRM_XML_CountMatchingNodesA(f_pszBase,
                                         &dasstrDataNodes, 
                                          NULL,
                                          NULL,
                                          NULL,
                                         &cNodes));

        if (f_rgdasstrValue == NULL
        || *f_pcEntries      < cNodes)
        {
            *f_pcEntries = cNodes;
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
        
        *f_pcEntries = cNodes;

        for (iNode = 0; iNode < cNodes; iNode++)
        {
            DRM_SUBSTRING dasstrTag = EMPTY_DRM_SUBSTRING;
            DRM_SUBSTRING dasstrOne = EMPTY_DRM_SUBSTRING;

            ChkDR(DRM_XML_EnumNextNodeA(f_pszBase,
                                       &dasstrDataNodes, 
                                        iNode,
                                       &dasstrTag,
                                        f_rgdasstrValue + iNode,     
                                       &dasstrOne,
                                        NULL,
                                        NULL));

            /* only a string "1" is allowed for the data */

            ChkArg(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrOne, &g_dastrOne));
        }
        break;

    case DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SELF_RSA:
        if (f_rgdasstrValue == NULL
        || *f_pcEntries      < 2)
        {
            *f_pcEntries = 2;
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
        
        *f_pcEntries = 2;

        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrDataNodes, &g_dastrTagWMDRMCertPublicKey, NULL, NULL, 0, NULL, &dasstr0));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr0,         &g_dastrTagKeyValue,           NULL, NULL, 0, NULL, &dasstr1));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr1,         &g_dastrTagRSAKeyValue,        NULL, NULL, 0, NULL, &dasstr2));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr2,         &g_dastrTagExponent,           NULL, NULL, 0, NULL, f_rgdasstrValue));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr2,         &g_dastrTagModulus,            NULL, NULL, 0, NULL, f_rgdasstrValue + 1));
        break;

    case DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SIGNER_RSA:
        if (f_rgdasstrValue == NULL
        || *f_pcEntries      < 2)
        {
            *f_pcEntries = 2;
            ChkDR(DRM_E_BUFFERTOOSMALL);
        }
        
        *f_pcEntries = 2;

        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrData, &g_dastrTagSignature,   NULL, NULL, 0, NULL, &dasstr0));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr0,    &g_dastrTagKeyInfo,     NULL, NULL, 0, NULL, &dasstr1));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr1,    &g_dastrTagKeyValue,    NULL, NULL, 0, NULL, &dasstr2));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr2,    &g_dastrTagRSAKeyValue, NULL, NULL, 0, NULL, &dasstr0));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr0,    &g_dastrTagExponent,    NULL, NULL, 0, NULL, f_rgdasstrValue));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr0,    &g_dastrTagModulus,     NULL, NULL, 0, NULL, f_rgdasstrValue + 1));
        break;

    case DRM_WMDRM_CERT_ATTR_DIGEST_VALUE:
        if (f_rgdasstrValue == NULL 
        || *f_pcEntries < 1)
        {
            *f_pcEntries = 1;
            ChkDR( DRM_E_BUFFERTOOSMALL);
        }

        *f_pcEntries = 1;

        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrData, &g_dastrTagSignature,   NULL, NULL, 0, NULL, &dasstr0));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr0,    &g_dastrTagSignedInfo,  NULL, NULL, 0, NULL, &dasstr1));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr1,    &g_dastrTagReference,   NULL, NULL, 0, NULL, &dasstr2));
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstr2,    &g_dastrTagDigestValue, NULL, NULL, 0, NULL, f_rgdasstrValue));
        break;

    default:
        ChkDR(DRM_E_INVALIDARG);
        break;
    } /* end switch f_attribute*/
    
    ErrorExit:
        return dr;
} /* DRM_WCP_GetAttribute */

/******************************************************************************
** Function :   
** Synopsis :   
** Arguments :  
**              
**              
**              
** 
******************************************************************************/

DRM_RESULT DRM_API DRM_WCP_GetHardwareID(
  IN const DRM_CHAR      *f_pszBase,
  IN const DRM_SUBSTRING *f_pdasstrCert,
     OUT   DRM_BYTE       f_rgbHardwareID [SHA_DIGEST_LEN])
{
    DRM_RESULT    dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrData        = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDataNodes   = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrHardwareID  = EMPTY_DRM_SUBSTRING;
    DRM_DWORD     cbHardwareID      = SHA_DIGEST_LEN;
    enum DRM_CERTIFICATE_TYPE certtype = certtypeUnknown;

    ChkArg(f_pszBase       != NULL
        && f_pdasstrCert   != NULL
        && f_rgbHardwareID != NULL);

    /* only machine certs have a HardwareID */

    ChkDR(DRM_WCP_GetCertificateType(f_pszBase,
                                     f_pdasstrCert,
                                    &certtype));

    ChkArg(certtype == certtypeMachine);

    ChkDR(DRM_XML_GetNodeA(f_pszBase,  f_pdasstrCert,    &g_dastrTagWMDRMCertificate, NULL, NULL, 0, NULL, &dasstrData));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrData,       &g_dastrTagWMDRMData,        NULL, NULL, 0, NULL, &dasstrDataNodes));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrDataNodes,  &g_dastrTagHardwareID,       NULL, NULL, 0, NULL, &dasstrHardwareID));

    ChkDR(DRM_B64_DecodeA (f_pszBase, &dasstrHardwareID, &cbHardwareID, f_rgbHardwareID, 0));

    ErrorExit:
        return dr;
}


/******************************************************************************
** Function :   DRM_WCP_GetSignatureDigest
** Synopsis :   retrieve the certificate's SHA digest from the signature
** Arguments :  [f_pszBase]     : base of buffer
**              [f_pdasstrCert] : SUBSTRING pointing to the entire certificate
**              [f_rgbDigest]   : buffer to receive the SHA digest
******************************************************************************/

DRM_RESULT DRM_API DRM_WCP_GetSignatureDigest(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT   DRM_BYTE                 f_rgbDigest [SHA_DIGEST_LEN])
{
    DRM_RESULT    dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrData         = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrSignature    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrSignedInfo   = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrReference    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDigestValue  = EMPTY_DRM_SUBSTRING;
    DRM_DWORD     cbDigestValue      = SHA_DIGEST_LEN;

    ChkArg(f_pszBase     != NULL
        && f_pdasstrCert != NULL
        && f_rgbDigest   != NULL);

    ChkDR(DRM_XML_GetNodeA(f_pszBase,  f_pdasstrCert,    &g_dastrTagWMDRMCertificate, NULL, NULL, 0, NULL, &dasstrData));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrData,       &g_dastrTagSignature,        NULL, NULL, 0, NULL, &dasstrSignature));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrSignature,  &g_dastrTagSignedInfo,       NULL, NULL, 0, NULL, &dasstrSignedInfo));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrSignedInfo, &g_dastrTagReference,        NULL, NULL, 0, NULL, &dasstrReference));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrReference,  &g_dastrTagDigestValue,      NULL, NULL, 0, NULL, &dasstrDigestValue));

    ChkDR(DRM_B64_DecodeA (f_pszBase, &dasstrDigestValue, &cbDigestValue, f_rgbDigest, 0));

    ErrorExit:
        return dr;
}


/******************************************************************************
** Function :   
** Synopsis :   
** Arguments :  
**              
**              
**              
** 
******************************************************************************/

DRM_RESULT DRM_API DRM_WCP_GetManufacturerNodes(
IN const DRM_CHAR      *f_pszBase,
IN const DRM_SUBSTRING *f_pdasstrCertificate,
     OUT DRM_SUBSTRING *f_pdasstrNamespace,
     OUT DRM_SUBSTRING  f_rgdastrTag        [],
     OUT DRM_SUBSTRING  f_rgdasstrAttrLabel [],
     OUT DRM_SUBSTRING  f_rgdasstrAttrValue [],
     OUT DRM_SUBSTRING  f_rgdasstrValue     [],
     OUT DRM_DWORD     *f_pcEntries)
{
    DRM_RESULT    dr                = DRM_SUCCESS;
    DRM_DWORD     cNodes            = 0;
    DRM_DWORD     iNode             = 0;
    DRM_ANSI_CONST_STRING dastrCert = EMPTY_DRM_STRING;
    DRM_SUBSTRING dasstrData        = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDataNodes   = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrNode        = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrEntries     = EMPTY_DRM_SUBSTRING;
    enum DRM_CERTIFICATE_TYPE certtype = certtypeUnknown;

    ChkArg(f_pszBase            != NULL
        && f_pdasstrCertificate  > 0
        && f_rgdasstrValue      != NULL
        && f_pcEntries          != NULL);

    /* only machine certs have ManufacturerData */

    ChkDR(DRM_WCP_GetCertificateType(f_pszBase,
                                     f_pdasstrCertificate,
                                    &certtype));

    ChkDR(DRM_XML_GetNodeA(f_pszBase,  f_pdasstrCertificate, &g_dastrTagWMDRMCertificate, NULL, NULL, 0, NULL,        &dasstrData));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrData,           &g_dastrTagWMDRMData,        NULL, NULL, 0, NULL,        &dasstrDataNodes));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrDataNodes,      &g_dastrTagManufacturerData, NULL, NULL, 0, &dasstrNode, &dasstrEntries));

    if (f_pdasstrNamespace != NULL)
    {
        f_pdasstrNamespace->m_ich = 0;
        f_pdasstrNamespace->m_cch = 0;

        /*
        ** return code ignored because absence of a namespace is OK
        */

        DRM_XML_GetNodeAttributeA(f_pszBase, &dasstrNode, &g_dastrPrefixManufacturer, f_pdasstrNamespace);
    }

    /* count the nodes */
    
    ChkDR(DRM_XML_CountMatchingNodesA(f_pszBase, &dasstrEntries, NULL, NULL, NULL, &cNodes));

    if (*f_pcEntries < cNodes)
    {
        *f_pcEntries = cNodes;
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }
    
    *f_pcEntries = cNodes;

    for (iNode = 0; iNode < cNodes; iNode++)
    {
        ChkDR(DRM_XML_EnumNextNodeA(f_pszBase,
                                    &dasstrEntries, 
                                    iNode,
                                    f_rgdastrTag + iNode,
                                    NULL,
                                  ((f_rgdasstrValue     == NULL) ? NULL : f_rgdasstrValue     + iNode),
                                  ((f_rgdasstrAttrLabel == NULL) ? NULL : f_rgdasstrAttrLabel + iNode),
                                  ((f_rgdasstrAttrValue == NULL) ? NULL : f_rgdasstrAttrValue + iNode)));
    }
    
    ErrorExit:
        return dr;
}

static DRM_RESULT _VerifyCertificateMethods(const DRM_CHAR      *f_pszBase,
                                            const DRM_SUBSTRING *f_pdasstrCert,
                                            const DRM_BOOL       f_fWMDRMNET)
{
    DRM_RESULT    dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrSignature      = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrReference      = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrSignedInfo     = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrElements       = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrTransforms     = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDummy          = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrTag            = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrNodeData       = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrAttributeName  = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrAttributeValue = EMPTY_DRM_SUBSTRING;

    /* descend into the <c:Certificate>/<Signature> node */

    ChkDR(DRM_XML_GetNodeA(f_pszBase, f_pdasstrCert,     &g_dastrTagWMDRMCertificate,  NULL, NULL, 0, NULL, &dasstrElements));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrElements,   &g_dastrTagSignature,         NULL, NULL, 0, NULL, &dasstrSignature));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrSignature,  &g_dastrTagSignedInfo,        NULL, NULL, 0, NULL, &dasstrSignedInfo));

    /* verify both the presence and the correct values of signature parameters */

    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrSignedInfo, &g_dastrTagCanonicalization, &g_dastrAttributeAlgorithm, &g_dastrURIC14N,        0, NULL, &dasstrDummy));

    if (f_fWMDRMNET == DRM_DSIG_TYPE_WMDRMNET)
    {
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrSignedInfo, &g_dastrTagSignatureMethod,  &g_dastrAttributeAlgorithm, &g_dastrURIRSASHA1_Old, 0, NULL, &dasstrDummy));
    }
    else
    {
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrSignedInfo, &g_dastrTagSignatureMethod,  &g_dastrAttributeAlgorithm, &g_dastrURIRSASHA1,     0, NULL, &dasstrDummy));
    }

    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrSignedInfo, &g_dastrTagReference,         NULL,                       NULL,                  0, NULL, &dasstrReference));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrReference,  &g_dastrTagDigestMethod,     &g_dastrAttributeAlgorithm, &g_dastrURIDSigSHA1,    0, NULL, &dasstrDummy));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrReference,  &g_dastrTagTransforms,        NULL,                       NULL,                  0, NULL, &dasstrTransforms));
    
    /*
    ** <Transform Algorithm="http://www.microsoft.com/DRM/CERT/v2/Data"/>
    ** <Transform Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315"/>
    **
    ** must both be present and in the given order
    */

    ChkDR(DRM_XML_EnumNextNodeA(f_pszBase, &dasstrTransforms, 0, &dasstrTag, NULL, &dasstrNodeData, &dasstrAttributeName, &dasstrAttributeValue));

    ChkArg(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrTag,            &g_dastrTagTransform));
    ChkArg(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrAttributeName,  &g_dastrAttributeAlgorithm));

    if (f_fWMDRMNET == DRM_DSIG_TYPE_WMDRMNET)
    {
        ChkArg(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrAttributeValue, &g_dastrURITransformMSCert_Old));
    }
    else
    {
        ChkArg(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrAttributeValue, &g_dastrURITransformMSCert));
    }
    ChkDR(DRM_XML_EnumNextNodeA(f_pszBase, &dasstrTransforms, 1, &dasstrTag, NULL, &dasstrNodeData, &dasstrAttributeName, &dasstrAttributeValue));

    ChkArg(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrTag,            &g_dastrTagTransform));
    ChkArg(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrAttributeName,  &g_dastrAttributeAlgorithm));
    ChkArg(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrAttributeValue, &g_dastrURITransformC14N));

ErrorExit:
    if (DRM_FAILED(dr))
    {
        dr = DRM_E_VERIFICATION_FAILURE;
    }
    
    return dr;
}


static DRM_RESULT _VerifyCertificateSignature(
    IN  const DRM_CHAR            *f_pszBase,
    IN  const DRM_SUBSTRING       *f_pdasstrCert,
    IN  const DRM_BOOL             f_fWMDRMNET,
    IN  const WMDRMNET_CRL_ENTRY  *f_pRevocationEntries,
    IN        DRM_DWORD            f_cRevocationEntries,
        OUT   DRM_SUBSTRING       *f_pdasstrPubkeySigner)
{
    DRM_RESULT   dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrElements       = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrSignatureIncl  = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDataIncl       = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING rgdasstrPubKey [2]   = { 0 };
    DRM_DWORD     cEntries             = NO_OF(rgdasstrPubKey);

    ChkArg( f_pszBase != NULL );
    
    /* cache some nodes to parse further below */

    ChkDR(DRM_XML_GetNodeA(f_pszBase,  f_pdasstrCert,   &g_dastrTagWMDRMCertificate, NULL, NULL, 0,  NULL,                 &dasstrElements));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrElements,  &g_dastrTagSignature,        NULL, NULL, 0, &dasstrSignatureIncl,   NULL));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrElements,  &g_dastrTagWMDRMData,        NULL, NULL, 0, &dasstrDataIncl,        NULL));

    /* get the signer's public key */

    ChkDR(DRM_WCP_GetAttribute(f_pszBase,
                               f_pdasstrCert,
                               DRM_WMDRM_CERT_ATTR_PUBLIC_KEY_SIGNER_RSA,
                               rgdasstrPubKey,
                              &cEntries));

    /* verify that the exponent matches the certificate version */

    ChkBOOL(DRM_UTL_DASSTRStringsEqual(f_pszBase, rgdasstrPubKey, &g_dastrWMDRMCertExponent), DRM_E_VERIFICATION_FAILURE);

    /* pass out the modulus if requested */

    if (f_pdasstrPubkeySigner != NULL)
    {
        *f_pdasstrPubkeySigner = rgdasstrPubKey [1];
    }

    ChkDR(DRM_WCP_VerifyDigitalSignature(f_pszBase, 
                                        &dasstrDataIncl, 
                                        &dasstrSignatureIncl, 
                                         f_fWMDRMNET,
                                         f_pRevocationEntries,
                                         f_cRevocationEntries));
ErrorExit:
    return dr;
}



static DRM_RESULT _VerifyCertificateRequiredTags(const DRM_CHAR      *f_pszBase,
                                                 const DRM_SUBSTRING *f_pdasstrCert)
{
    DRM_RESULT   dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrNode     = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrData     = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDataNodes= EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrDummy    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstrElements = EMPTY_DRM_SUBSTRING;
    DRM_DWORD     iNode          = 0;
    enum DRM_CERTIFICATE_TYPE certtype = certtypeUnknown;
    
    ChkDR(DRM_WCP_GetCertificateType(f_pszBase,
                                     f_pdasstrCert,
                                    &certtype));

    ChkDR  (DRM_XML_GetNodeA          (f_pszBase,  f_pdasstrCert, &g_dastrTagWMDRMCertificate,     NULL, NULL, 0, &dasstrNode, &dasstrElements));

    if (DRM_SUCCEEDED(DRM_XML_GetNodeAttributeA (f_pszBase, &dasstrNode,    &g_dastrAttributeVersionWMDRM,  &dasstrData)))
    {
        /* If there is a c:Version attribute validate that it is 2.0 */
        ChkBOOL(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrData,    &g_dastrVersionWMDRM),           DRM_E_FAIL);
    }

    if (DRM_SUCCEEDED(DRM_XML_GetNodeAttributeA (f_pszBase, &dasstrNode,    &g_dastrPrefixMicrosoftCert,    &dasstrData)))
    {
        /* If there is a xmlns:c attribute validate that it is what we expect */
        ChkBOOL(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrData,    &g_dastrURITransformMSCertColl), DRM_E_FAIL);
    }

    ChkDR(DRM_XML_GetNodeA            (f_pszBase, &dasstrElements,  &g_dastrTagWMDRMData,          NULL, NULL, 0, NULL, &dasstrDataNodes));

    /* cert public key node */

    ChkDR  (DRM_XML_GetNodeA          (f_pszBase, &dasstrDataNodes, &g_dastrTagWMDRMCertPublicKey,   NULL, NULL, 0, NULL, &dasstrDummy));
    ChkDR  (DRM_XML_GetNodeA          (f_pszBase, &dasstrDummy,     &g_dastrTagKeyValue,             NULL, NULL, 0, NULL, &dasstrDummy));
    ChkDR  (DRM_XML_GetNodeA          (f_pszBase, &dasstrDummy,     &g_dastrTagRSAKeyValue,          NULL, NULL, 0, NULL, &dasstrDummy));
    ChkDR  (DRM_XML_GetNodeA          (f_pszBase, &dasstrDummy,     &g_dastrTagExponent,             NULL, NULL, 0, NULL, &dasstrData));
    ChkBOOL(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrData,      &g_dastrWMDRMCertExponent),      DRM_E_BAD_RSA_EXPONENT);
    ChkDR  (DRM_XML_GetNodeA          (f_pszBase, &dasstrDummy,     &g_dastrTagModulus,              NULL, NULL, 0, NULL, &dasstrData));
    ChkBOOL(dasstrData.m_cch > 0, DRM_E_FAIL);

    /* <KeyUsage> */

    ChkDR(DRM_XML_GetNodeA            (f_pszBase, &dasstrDataNodes, &g_dastrTagWMDRMCertKeyUsage,  NULL, NULL, 0, NULL, &dasstrDummy));
    
    /* verify legal values */
    
    for (iNode = 0; ; iNode++)
    {
        dr = DRM_XML_EnumNextNodeA    (f_pszBase, &dasstrDummy, iNode, &dasstrData, &dasstrDummy, NULL, NULL, NULL);
        
        if (dr == DRM_E_XMLNOTFOUND)
        {
            dr = DRM_SUCCESS;
            break;
        }
        else
        {
            ChkDR(dr);
 
            if (certtype == certtypeMachine
            ||  certtype == certtypeExport
            ||  certtype == certtypeExportIncl
            ||  certtype == certtypeDevice
            ||  certtype == certtypeSampleProtection)
            {
                if (! DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrData, &g_dastrKeyUsageEncryptKey))
                {
                    ChkDR(DRM_E_FAIL);
                }
            }
            else
            {
                if (! DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrData, &g_dastrKeyUsageSignCert)
                &&  ! DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrData, &g_dastrKeyUsageSignCRL))
                {
                    ChkDR(DRM_E_FAIL);
                }
            }

        }
    } /* end-for KeyUsage nodes */
    
    /* <SecurityLevel> */

    dr = DRM_XML_GetNodeA(f_pszBase, &dasstrDataNodes, &g_dastrTagWMDRMCertSecurityLevel, NULL, NULL, 0, NULL, &dasstrDummy);

    if (certtype == certtypeMachine
    ||  certtype == certtypeExport
    ||  certtype == certtypeExportIncl
    ||  certtype == certtypeDevice
    ||  certtype == certtypeSampleProtection)
    {
        ChkDR(dr);

        /*   BUGBUG:  Let's not force this value right now.
        ** 
        if (certtype == certtypeMachine 
        && ! DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrDummy, &g_dastrSecurityLevel))
        {
            ChkDR(DRM_E_FAIL);
        }
        */
    }
    else
    {
        /* TODO:  
        **  We should really be validating that each certificiate in the chain has a sec level <= the next one up in the chain
        **
        ** ChkFAIL(dr == DRM_E_XMLNOTFOUND);
        */

        dr = DRM_SUCCESS;
    }

    /* <SecurityVersion> */

    dr = DRM_XML_GetNodeA(f_pszBase, &dasstrDataNodes, &g_dastrTagWMDRMCertSecurityVersion, NULL, NULL, 0, NULL, &dasstrDummy);

    if (certtype == certtypeMachine
    ||  certtype == certtypeExport
    ||  certtype == certtypeExportIncl)
    {
        /* Enforce that all machine certs have this value */
        ChkDR(dr);    
    }
        
    /* if <ManufacturerData> is present then it must follow the scheme */

    dr =  DRM_XML_GetNodeA(f_pszBase, &dasstrDataNodes, &g_dastrTagManufacturerData, NULL, NULL, 0, NULL, &dasstrNode);
    
    if (dr == DRM_E_XMLNOTFOUND)
    {
        dr = DRM_SUCCESS;
    }
    else
    {
        ChkDR(dr);
    
        ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrNode, &g_dastrTagManufacturerName,      NULL, NULL, 0, NULL, &dasstrDummy));
    }
    
ErrorExit:
    if (DRM_FAILED(dr))
    {
        dr = DRM_E_VERIFICATION_FAILURE;
    }
    
    return dr;
}

/******************************************************************************
** Function :   
** Synopsis :   
** Arguments :  
**              
**              
**              
** 
******************************************************************************/

DRM_RESULT DRM_API DRM_WCP_VerifyCertificate(
    IN const DRM_CHAR            *f_pszBase,
    IN const DRM_SUBSTRING       *f_pdasstrCert,
    IN       DRM_DWORD            f_fVerify,
    IN       DRM_BOOL             f_fWMDRMNET,
    IN const WMDRMNET_CRL_ENTRY  *f_pRevocationEntries,
    IN       DRM_DWORD            f_cRevocationEntries,
       OUT   DRM_SUBSTRING       *f_pdasstrPublicRSA)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg(f_pdasstrCert           != NULL
        && f_pszBase               != NULL
        && f_pdasstrCert->m_cch    != 0);

    if (f_cRevocationEntries > 0)
    {
        ChkArg(f_pRevocationEntries != NULL);
    }

    ChkArg((f_fVerify &  DRM_WCP_VERIFY_CERT_ALL) != 0);
    ChkArg((f_fVerify & ~DRM_WCP_VERIFY_CERT_ALL) == 0);

    if ((f_fVerify & DRM_WCP_VERIFY_CERT_REQUIRED_TAGS) != 0)
    {
        ChkDR(_VerifyCertificateRequiredTags(f_pszBase, f_pdasstrCert));
    }
 
    if ((f_fVerify & DRM_WCP_VERIFY_CERT_METHODS) != 0)
    {
        ChkDR(_VerifyCertificateMethods(f_pszBase, f_pdasstrCert, f_fWMDRMNET));
    }
            
    if ((f_fVerify & DRM_WCP_VERIFY_CERT_SIGNATURE) != 0)
    {
        ChkDR(_VerifyCertificateSignature(f_pszBase, f_pdasstrCert, f_fWMDRMNET, f_pRevocationEntries, f_cRevocationEntries, f_pdasstrPublicRSA))
    }
 
ErrorExit:
    return dr;
}

static DRM_RESULT _GetPublicKey(const DRM_CHAR *f_pszBase,
                                DRM_SUBSTRING  *f_pdasstrCert,
                                DRM_SUBSTRING  *f_pdasstrPubkey)
{
    DRM_RESULT    dr = DRM_SUCCESS;
    DRM_SUBSTRING dasstrData = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstr0    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstr1    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING dasstr2    = EMPTY_DRM_SUBSTRING;

    
    ChkDR(DRM_XML_GetNodeA   (f_pszBase,  f_pdasstrCert, &g_dastrTagWMDRMCertificate,   NULL, NULL, 0, NULL, &dasstrData));
    ChkDR(DRM_XML_GetSubNodeA(f_pszBase, &dasstrData,    &g_dastrTagWMDRMCertPublicKey, NULL, NULL, 0, NULL, &dasstr0,    1));
    ChkDR(DRM_XML_GetNodeA   (f_pszBase, &dasstr0,       &g_dastrTagKeyValue,           NULL, NULL, 0, NULL, &dasstr1));
    ChkDR(DRM_XML_GetNodeA   (f_pszBase, &dasstr1,       &g_dastrTagRSAKeyValue,        NULL, NULL, 0, NULL, &dasstr2));
    ChkDR(DRM_XML_GetNodeA   (f_pszBase, &dasstr2,       &g_dastrTagModulus,            NULL, NULL, 0, NULL,  f_pdasstrPubkey));

ErrorExit:
    return dr;
}


static DRM_RESULT _ExtractPublicKey(DRM_CHAR            *f_pszBase, 
                                    DRM_SUBSTRING       *f_pdasstrKeyInfo, 
                                    DRM_RSA_PUBLIC_KEY **f_pppubkeyRSA)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_RSA_PUBLIC_KEY *ppubkeyRSA = NULL;
    DRM_BYTE            rgbModulus [__CB_DECL(DRM_CB_RSA_PUBLIC_MOD_1024)];
    DRM_DWORD           cbModulus = SIZEOF(rgbModulus);
    DRM_SUBSTRING       dasstrKeyValue    = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING       dasstrRSAKeyValue = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING       dasstrModulus     = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING       dasstrExponent    = EMPTY_DRM_SUBSTRING;

     ChkArg( f_pszBase != NULL );
    
    ChkDR(DRM_XML_GetNodeA(f_pszBase,  f_pdasstrKeyInfo,  &g_dastrTagKeyValue,    NULL, NULL, 0, NULL, &dasstrKeyValue));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrKeyValue,    &g_dastrTagRSAKeyValue, NULL, NULL, 0, NULL, &dasstrRSAKeyValue));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrRSAKeyValue, &g_dastrTagModulus,     NULL, NULL, 0, NULL, &dasstrModulus));
    ChkDR(DRM_XML_GetNodeA(f_pszBase, &dasstrRSAKeyValue, &g_dastrTagExponent,    NULL, NULL, 0, NULL, &dasstrExponent));

    ChkArg(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrExponent, &g_dastrWMDRMCertExponent));

    ChkDR(DRM_WCP_ReadPubKeyModulus( f_pszBase,
                                    &dasstrModulus,
                                     rgbModulus,
                                    &cbModulus ) );

    ChkDR(OEM_DrmRsaSetPublicKey(DRM_RSA_EXPONENT_VER_3_0_0_0, rgbModulus, cbModulus, &ppubkeyRSA));

    *f_pppubkeyRSA = ppubkeyRSA;

ErrorExit:
    return dr;
}


/******************************************************************************
** Function :   DRM_WCP_VerifyCertificateCollection
** Synopsis :   
** Arguments :  [f_pszBase]              :
**              [f_pdasstrCollection]    :   Secure store context for opened slot
**              [f_pdasstrPubkeyMachin ] :   (Optional - can be NULL)If slot already 
**                                  exists, on return it contains slot size
** 
******************************************************************************/

DRM_RESULT DRM_API DRM_WCP_VerifyCertificateCollection(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrCollection,
    IN const DRM_BOOL               f_fWMDRMNET,
    IN const DRM_ANSI_CONST_STRING *f_pdastrRootPubKey,
    IN const WMDRMNET_CRL_ENTRY    *f_pRevocationEntries,
    IN       DRM_DWORD              f_cRevocationEntries,
       OUT   DRM_SUBSTRING         *f_pdasstrLeafCertificate,
       OUT   DRM_SUBSTRING         *f_pdasstrPubkeyMachine)
{
    DRM_RESULT      dr                   = DRM_SUCCESS;
    DRM_DWORD       iNode                = 0;
    DRM_DWORD       cNodes               = 0;
    DRM_DWORD       cMatch               = 0;
    const DRM_CHAR *pszBase              = NULL;
    DRM_SUBSTRING   dasstrPubkeyCertCurr = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING   dasstrCertCurr       = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING   dasstrData           = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING   dasstrNode           = EMPTY_DRM_SUBSTRING;
    DRM_SUBSTRING   dasstrCollectionVersion = EMPTY_DRM_SUBSTRING;
    DRM_DWORD       dwSecurityLevel = (DRM_DWORD) MAX_UNSIGNED_TYPE( DRM_DWORD ); 

    enum DRM_CERTIFICATE_TYPE certtype = certtypeUnknown;

    struct 
    {
        DRM_SUBSTRING   dasstrCertificate;
        DRM_SUBSTRING   dasstrPubKeyCert;
        DRM_SUBSTRING   dasstrPubKeySigner;
    } rgcertInfo [DRM_CERTIFICATE_COLLECTION_MAX] = { 0 };

    DRM_DWORD   rgSecurityLevels[DRM_CERTIFICATE_COLLECTION_MAX] = { 0 };

    ChkArg(f_pdastrRootPubKey != NULL
        && f_pszBase          != NULL);

    ChkDR(DRM_XML_GetNodeA(f_pszBase,
                           f_pdasstrCollection, 
                          &g_dastrTagCertificateCollection, 
                           NULL, 
                           NULL, 
                           0, 
                          &dasstrNode,
                          &dasstrData));

    /* check for certificate collection c:Version attribute */

    if( DRM_SUCCEEDED( DRM_XML_GetNodeAttributeA (f_pszBase, &dasstrNode, &g_dastrAttributeVersionWMDRM, &dasstrCollectionVersion ) ) )
    {
        ChkBOOL(DRM_UTL_DASSTRStringsEqual(f_pszBase, &dasstrCollectionVersion, &g_dastrVersionWMDRM), DRM_E_FAIL);
    }

    /* enumerate c:Certificate nodes */

    ChkDR(DRM_XML_CountMatchingNodesA(f_pszBase,
                                     &dasstrData,
                                     &g_dastrTagWMDRMCertificate,
                                      NULL,
                                      NULL,
                                     &cNodes));

    ChkArg(cNodes >= 1 
        && cNodes <= DRM_CERTIFICATE_COLLECTION_MAX);

    /* Collect public keys and verify certificates */

    for (iNode = 0; iNode < cNodes; iNode++)
    {
        DRM_SUBSTRING dasstrTag         = EMPTY_DRM_STRING;
        DRM_DWORD     cEntries          = 1;
        
        ChkDR(DRM_XML_EnumNextNodeA(f_pszBase,
                                   &dasstrData,
                                    iNode,
                                   &dasstrTag,
                                   &rgcertInfo[iNode].dasstrCertificate,
                                    NULL,
                                    NULL,
                                    NULL));

        /* there should be nothing but <c:Certificate>s in <CertificateCollection> */
        
        ChkArg(DRM_UTL_DASSTRStringsEqual(f_pszBase,
                                         &dasstrTag,
                                         &g_dastrTagWMDRMCertificate));

        ChkDR(DRM_WCP_VerifyCertificate(f_pszBase,
                                       &rgcertInfo[iNode].dasstrCertificate,
                                        DRM_WCP_VERIFY_CERT_ALL,
                                        f_fWMDRMNET,
                                        f_pRevocationEntries,
                                        f_cRevocationEntries,
                                       &rgcertInfo [iNode].dasstrPubKeySigner));

        ChkDR(_GetPublicKey(f_pszBase,
                           &rgcertInfo[iNode].dasstrCertificate,
                           &rgcertInfo[iNode].dasstrPubKeyCert));
    }

    /* 
    ** now we have the public keys parsed out; hook them up 
    ** first find the certificate signed by the MS root cert
    */
    
    dasstrPubkeyCertCurr.m_ich = 0;
    dasstrPubkeyCertCurr.m_cch = f_pdastrRootPubKey->cchString;
    pszBase       = (DRM_CHAR *) f_pdastrRootPubKey->pszString;
    cMatch  = 0;
    iNode   = 0;

    /* loop until we find a match for dasstrPubkeyCertCurr */
    
    while (iNode < cNodes)
    {
        /* skip entries that have already been matched */
        
        if (rgcertInfo [iNode].dasstrPubKeyCert.m_cch > 0)
        {
            if (DRM_UTL_DASSSTRStringsEqual(pszBase, 
                                           &dasstrPubkeyCertCurr, 
                                            f_pszBase,
                                           &rgcertInfo [iNode].dasstrPubKeySigner))
            {
                /* on the first pass we're comparing to a string constant; subsequently we
                ** are comparing within the Collection
                */
                
                if (pszBase != f_pszBase)
                {
                    pszBase = f_pszBase;
                }

                /* we have a match; cache the new signer's pubkey and
                ** zero out this entry to indicate that it's done
                */

                dasstrPubkeyCertCurr = rgcertInfo[iNode].dasstrPubKeyCert;
                dasstrCertCurr       = rgcertInfo[iNode].dasstrCertificate;
                ZEROMEM(&rgcertInfo [iNode], SIZEOF(rgcertInfo [0]));
                
                /* Ensure signer's security level is not less than cert */
                if( dwSecurityLevel < rgSecurityLevels[iNode] )
                {
                    ChkDR( DRM_E_VERIFICATION_FAILURE );
                }
                else
                {
                    dwSecurityLevel = rgSecurityLevels[iNode];
                }

                /* restart the loop */
                
                iNode  = 0;
                cMatch = 0;
            }
            else
            {
                iNode++;
            }
        }
        else
        {
            cMatch++;
            iNode++;
        }
    }    

    if (cMatch != cNodes)
    {
        ChkDR(DRM_E_VERIFICATION_FAILURE);
    }

    /* optionally pass out the pubkey of the leafmost node */
    
    else
    {
        if (f_pdasstrPubkeyMachine != NULL)
        {
            *f_pdasstrPubkeyMachine = dasstrPubkeyCertCurr;
        }

        if (f_pdasstrLeafCertificate != NULL)
        {
            *f_pdasstrLeafCertificate = dasstrCertCurr;
        }
    }
    
ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_WCP_ReadPubKeyModulus(
    IN                        DRM_CHAR      *f_rgchB64,
    IN                        DRM_SUBSTRING *f_pdasstrB64,
    OUT                       DRM_BYTE      *f_pbMod,
    OUT                       DRM_DWORD     *f_pcbMod)
{
    DRM_RESULT dr = DRM_SUCCESS;

    ChkArg( f_rgchB64 && f_pdasstrB64 && f_pbMod && f_pcbMod );

    ChkDR( DRM_B64_DecodeA( f_rgchB64, f_pdasstrB64, f_pcbMod, f_pbMod, 0 ) );

ErrorExit:
    return dr;
}



DRM_RESULT DRM_API DRM_WCP_VerifyDigitalSignature(
    IN const DRM_CHAR             *f_pszBase,
    IN const DRM_SUBSTRING        *f_pdasstrData,      /* inclusive */
    IN const DRM_SUBSTRING        *f_pdasstrSignature, /* inclusive */
    IN const DRM_BOOL              f_fWMDRMNET,
    IN const WMDRMNET_CRL_ENTRY   *f_pRevocationEntries,
    IN       DRM_DWORD             f_cRevocationEntries)
{
    DRM_RESULT          dr                   = DRM_SUCCESS;
    SHA_CONTEXT         contextSHA           = { 0 };
    DRM_SUBSTRING       dasstrSignedInfo     = EMPTY_DRM_STRING;
    DRM_SUBSTRING       dasstrSignatureInner = EMPTY_DRM_STRING;
    DRM_SUBSTRING       dasstrReference      = EMPTY_DRM_STRING;
    DRM_SUBSTRING       dasstrSignatureValue = EMPTY_DRM_STRING;
    DRM_SUBSTRING       dasstrSignedInfoIncl = EMPTY_DRM_STRING;
    DRM_SUBSTRING       dasstrDigestValue    = EMPTY_DRM_STRING;
    DRM_SUBSTRING       dasstrKeyInfo        = EMPTY_DRM_STRING;
    DRM_BYTE            rgbSHAEncoded    [__CB_DECL(SHA_DIGEST_LEN)];
    DRM_BYTE            rgbSHACalculated [__CB_DECL(SHA_DIGEST_LEN)];
    DRM_BYTE            rgbSignature     [__CB_DECL(CB_SIGNATURE_RSA)];
    DRM_DWORD           cbSHAEncoded         = SIZEOF(rgbSHAEncoded);
    DRM_DWORD           cbSignature          = SIZEOF(rgbSignature);
    DRM_RSA_PUBLIC_KEY *ppubkeyRSA           = NULL;

    ChkArg( f_pszBase          != NULL 
        &&  f_pdasstrData      != NULL
        &&  f_pdasstrSignature != NULL );

    ChkDR( DRM_XML_GetNodeA( f_pszBase, 
                             f_pdasstrSignature,    
                            &g_dastrTagSignature,  
                             NULL, 
                             NULL, 
                             0, 
                             NULL,                  
                            &dasstrSignatureInner ) );
    ChkDR( DRM_XML_GetNodeA( f_pszBase, 
                            &dasstrSignatureInner, 
                            &g_dastrTagSignedInfo, 
                             NULL, 
                             NULL, 
                             0, 
                            &dasstrSignedInfoIncl, 
                            &dasstrSignedInfo ) );

    /* extract and decode the DigestValue */

    ChkDR( DRM_XML_GetNodeA( f_pszBase, 
                            &dasstrSignedInfo,  
                            &g_dastrTagReference,   
                            NULL,  
                            NULL,   
                            0, 
                            NULL, 
                           &dasstrReference ) );
    ChkDR( DRM_XML_GetNodeA( f_pszBase, 
                            &dasstrReference,   
                            &g_dastrTagDigestValue, 
                            NULL,  
                            NULL,   
                            0, 
                            NULL, 
                           &dasstrDigestValue ) );
    ChkDR( DRM_B64_DecodeA( f_pszBase, 
                           &dasstrDigestValue, 
                           &cbSHAEncoded,          
                           rgbSHAEncoded, 
                           0 ) );

    /*
    **  Search the revocation entries for this digest value to check if the certificate is revoked.
    */
    while(f_cRevocationEntries > 0)
    {
        f_cRevocationEntries--;
        if ( MEMCMP( &f_pRevocationEntries[f_cRevocationEntries], 
                      rgbSHAEncoded, 
                      SIZEOF(rgbSHAEncoded) ) == 0 )
        {
            /* matched a revocation entry */
            ChkDR( DRM_E_APPCERT_REVOKED );            
        }
    }

    /* calculate the SHA hash from the Data node  */

    DRM_SHA_Init    ( &contextSHA );
    DRM_SHA_UpdateOffset( (const DRM_BYTE*)f_pszBase, 
                           f_pdasstrData->m_ich, 
                           f_pdasstrData->m_cch, 
                          &contextSHA ); 
    DRM_SHA_Finalize( &contextSHA, rgbSHACalculated );

    /* compare them */

    ChkBOOL( MEMCMP( rgbSHAEncoded, 
                     rgbSHACalculated, 
                     SHA_DIGEST_LEN ) == 0, 
                     DRM_E_INVALID_SIGNATURE );

    /* get the signature value */

    ChkDR( DRM_XML_GetNodeA( f_pszBase, 
                            &dasstrSignatureInner, 
                            &g_dastrTagSignatureValue, 
                             NULL, 
                             NULL,   
                             0, 
                             NULL, 
                            &dasstrSignatureValue ) );
    ChkDR( DRM_XML_GetNodeA( f_pszBase, 
                            &dasstrSignatureInner, 
                            &g_dastrTagKeyInfo,        
                             NULL, 
                             NULL,   
                             0, 
                             NULL, 
                            &dasstrKeyInfo ) );
    
    ChkDR( DRM_B64_DecodeA ( f_pszBase, 
                            &dasstrSignatureValue, 
                            &cbSignature,              
                            rgbSignature, 
                            0 ) );

    ChkDR( _ExtractPublicKey( (DRM_CHAR *) f_pszBase, 
                           (DRM_SUBSTRING *) &dasstrKeyInfo, 
                           &ppubkeyRSA ) );

    if (f_fWMDRMNET == DRM_DSIG_TYPE_WMDRMNET)
    {
        ChkDR( DrmRsaVerify( f_pszBase, 
                             (DRM_SUBSTRING *) f_pdasstrData,
                             ppubkeyRSA,
                             rgbSignature,
                             cbSignature ) );
    }
    else
    {
        ChkDR( DrmRsaVerify( f_pszBase, 
                            &dasstrSignedInfoIncl,
                             ppubkeyRSA,
                             rgbSignature,
                             cbSignature ) );
    }

ErrorExit:
    if (ppubkeyRSA != NULL)
    {
        OEM_DrmRsaReleaseKey( ppubkeyRSA );
    }

    return dr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmchain.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmlicenseparser.h>
#if DRM_SUPPORT_APP_REVOCATION || DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_REVOCATION
#include <drmrevocation.h>
#endif
#include <drmchain.h>
#include <oemimpl.h>
#include <drmsecureclock.h>
#include <drmxmlparser.h>
#include <drmlicreason.h>

/******************************************************************************
** 
** Function :   _ParseLicenseAttributes
** 
** Synopsis :   Parse the license for frequently used attributes
** 
** Arguments :  f_pdstrLicense  - License string
**              f_rgpdstrEvents - Array of events to parse
**              f_cEvents       - Count of events to parse
**              f_rgdstrCachedAttribs - Cached attribs
**              f_rgCachedEvents- Cached events
** 
** Returns :    
** 
** Notes :      We can parse the license more optimally if needed. 
** 
******************************************************************************/
static DRM_RESULT _ParseLicenseAttributes(
    IN          DRM_CONST_STRING    *f_pdstrLicense,
    IN  const   DRM_CONST_STRING    *f_rgpdstrEvents[],
    IN          DRM_DWORD            f_cEvents,
        OUT     DRM_CONST_STRING     f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_LAST],
        OUT     DRM_CACHED_EVENT     f_rgCachedEvents[DRM_MAX_ACTIONS] )
{
    DRM_RESULT          dr          = DRM_SUCCESS;
    DRM_CONST_STRING    dstrLIData  = EMPTY_DRM_STRING;
    DRM_DWORD           iEvents     = 0;
    
    /*
    **  If need be we can try to do better here by doing a single scan of the XML
    */
    ChkDR( DRM_LIC_GetAttribute( f_pdstrLicense, 
                                 NULL, 
                                 DRM_LICENSE_ATTRIB_KID, 
                                 &dstrLIData,
                                 &f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_KID], 
                                 0 ) );
    
    ChkDR( DRM_LIC_GetAttribute( f_pdstrLicense, 
                                 NULL, 
                                 DRM_LICENSE_ATTRIB_LID, 
                                 &dstrLIData,
                                 &f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_LID], 
                                 0 ) );
    
    dr = DRM_LIC_GetAttribute( f_pdstrLicense, 
                               NULL, 
                               DRM_LICENSE_ATTRIB_CONTENTPUBKEY, 
                               &dstrLIData,
                               &f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY], 
                               0 );
    if ( DRM_FAILED(dr) )
    {
        INIT_DRM_STRING(f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY]);
        dr = DRM_SUCCESS;
    }
    
    dr = DRM_LIC_GetAttribute( f_pdstrLicense, 
                               NULL, 
                               DRM_LICENSE_ATTRIB_METERING_ID, 
                               &dstrLIData,
                               &f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_METERING_ID], 
                               0 );
    if ( DRM_FAILED(dr) )
    {
        INIT_DRM_STRING(f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_METERING_ID]);
        dr = DRM_SUCCESS;
    }
    
    dr = DRM_LIC_GetAttribute( f_pdstrLicense, 
                               NULL, 
                               DRM_LICENSE_ATTRIB_CHAINEDKID, 
                               &dstrLIData,
                               &f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CHAINEDKID], 
                               0 );  
    if ( DRM_FAILED(dr) )
    {
        INIT_DRM_STRING(f_rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CHAINEDKID]);
        dr = DRM_SUCCESS;        
    }

    for ( iEvents = 0; (iEvents < f_cEvents) && (iEvents < DRM_MAX_ACTIONS); iEvents++)
    {
        ASSIGN_DRM_STRING( f_rgCachedEvents[iEvents].dstrType, *(f_rgpdstrEvents[iEvents]) );
        dr = DRM_LIC_GetEvent( f_pdstrLicense, 
                               &g_dstrLicEvalOnAction,
                               f_rgpdstrEvents[iEvents], 
                               &dstrLIData,
                               &f_rgCachedEvents[iEvents].dstrCondition,
                               &f_rgCachedEvents[iEvents].dstrAction,
                               &f_rgCachedEvents[iEvents].dstrRestriction);
        if ( DRM_FAILED(dr) )
        {
            INIT_DRM_STRING(f_rgCachedEvents[iEvents].dstrCondition);
            INIT_DRM_STRING(f_rgCachedEvents[iEvents].dstrAction);
            INIT_DRM_STRING(f_rgCachedEvents[iEvents].dstrRestriction);
            dr = DRM_SUCCESS;
        }
    }
    
    
ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   _LoadLicenseAttributes
** 
** Synopsis :   Load some of those attributes from a license which are
**              frequently used.
** 
** Arguments :  rgpdstrRights : Array of pointers to rights requested
**              f_pLicEval    : License eval context
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT _LoadLicenseAttributes(
    IN  const   DRM_CONST_STRING    *f_rgpdstrEvents[], 
    IN          DRM_DWORD            f_cRights,
    IN  OUT     DRM_LICEVAL_CONTEXT *f_pLicEval )
{
    DRM_RESULT          dr          = DRM_SUCCESS;
    DRM_CONST_STRING    dstrLIData  = EMPTY_DRM_STRING;
    DRM_CONST_STRING    dstrTemp    = EMPTY_DRM_STRING;
    
    
    ChkDR( _ParseLicenseAttributes( &f_pLicEval->dstrContentLicense,
                                    f_rgpdstrEvents,
                                    f_cRights,
                                    f_pLicEval->rgdstrCachedAttribs, 
                                    f_pLicEval->rgCachedEvents ) ); 
    f_pLicEval->cCachedEvents = f_cRights;

    /*
    **  Cache the binary LID
    */
    ChkDR( DRM_UTL_StringToGuid( &f_pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_LID], 
                                 (DRM_GUID*) &(f_pLicEval->LID) ) );

    /*
    **  Cache the binary KID
    */
    ChkDR( DRM_UTL_DecodeKID( &f_pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_KID],
                              &f_pLicEval->KID ) );
    
    f_pLicEval->fUseCachedAttribs = TRUE;
    
ErrorExit:
    return dr;  
}



/******************************************************************************
** 
** Function :   _PerformActions
** 
** Synopsis :   The license is selectable -- Can I perform the actions on it?
**              Loop through all the request actions and ask if we can do them
**              If we can do them all the report them all             
** 
** Arguments :  
**              
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT _PerformActions(
    IN OUT   DRM_FFLICENSE               *f_pFFLicense,
    IN OUT   DRM_STACK_ALLOCATOR_CONTEXT *f_pstack,
    IN const DRM_CONST_STRING            *f_rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD                    f_cRights,
    IN       DRM_HDS_CONTEXT             *f_pcontextHDS,
    IN       DRMPFNOUTPUTLEVELSCALLBACK   f_pfnOutputLevelsCallback)
{
    DRM_RESULT       dr     = DRM_SUCCESS;
    DRM_DWORD        iRight = f_cRights;
    DRM_CONST_STRING dstrLIData  = EMPTY_DRM_STRING;
    
    DRM_PROFILING_ENTER_SCOPE(L"_PerformActions", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
    
    /* internal function. no need to validate arguments 
    */

    for( ; iRight > 0; )
    {
        DRM_BOOL fExisted    = FALSE;
        DRM_BOOL fEvalResult = FALSE;        

        iRight--;
        ChkDR( DRM_LEVL_PerformOperations( f_pFFLicense->pLicEval,
                                           DRM_LICENSE_EVAL_ACTION,
                                           DRM_LICENSE_EVAL_CAN_DO_OPERATION,
                                           f_rgpdstrRights[iRight],
                                           &fEvalResult, 
                                           &fExisted,
                                           f_pcontextHDS) );
        if ( !fEvalResult )
        {
            dr = DRM_E_RIGHTSNOTAVAILABLE;
            goto ErrorExit;
        }

        if( fExisted )
        {
            /* Check if there are any output levels on this right */
            if ( f_pFFLicense->pLicEval->rgCachedEvents[iRight].dstrRestriction.cchString == 0 )
            {
                continue;
            }

            if ( f_pfnOutputLevelsCallback == NULL)  /* There were output restrictions and no callback function was supplied */
            {
                ChkDR(DRM_E_RIGHTSNOTAVAILABLE);
            }

            /* Reset the stack context */
            ZEROMEM( f_pstack, SIZEOF( DRM_STACK_ALLOCATOR_CONTEXT ) );                        

            if( DRM_UTL_DSTRStringsEqual( f_rgpdstrRights[iRight], &g_dstrWMDRM_RIGHT_PLAYBACK ) )
            {
                f_pstack->pbStack  =         f_pFFLicense->rgPlayOpl[f_pFFLicense->dwChainDepth].rgbPlayOPLBuffer;
                f_pstack->cbStack  = SIZEOF( f_pFFLicense->rgPlayOpl[f_pFFLicense->dwChainDepth].rgbPlayOPLBuffer );

                ChkDR( DRM_OPL_ProcessPlayOutputLevelData( &f_pFFLicense->pLicEval->rgCachedEvents[iRight].dstrRestriction,
                                                           &f_pFFLicense->rgPlayOpl[f_pFFLicense->dwChainDepth].oplPlay,
                                                            f_pstack ) );
                f_pFFLicense->rgfPlayOplValid[f_pFFLicense->dwChainDepth] = TRUE;
            }

            else if( DRM_UTL_DSTRStringsEqual( f_rgpdstrRights[iRight], &g_dstrWMDRM_RIGHT_COPY ) )
            {
#if DRM_SUPPORT_COPY_OPL
                f_pstack->pbStack  =         f_pFFLicense->rgCopyOpl[f_pFFLicense->dwChainDepth].rgbCopyOPLBuffer;
                f_pstack->cbStack  = SIZEOF( f_pFFLicense->rgCopyOpl[f_pFFLicense->dwChainDepth].rgbCopyOPLBuffer );

                ChkDR( DRM_OPL_ProcessCopyOutputLevelData( &f_pFFLicense->pLicEval->rgCachedEvents[iRight].dstrRestriction,
                                                           &f_pFFLicense->rgCopyOpl[f_pFFLicense->dwChainDepth].oplCopy,
                                                            f_pstack ) );
                f_pFFLicense->rgfCopyOplValid[f_pFFLicense->dwChainDepth] = TRUE;
#else
                ChkDR( DRM_E_RIGHTSNOTAVAILABLE );
#endif
            }

        }

    } /* end for rights */

ErrorExit:
    
    DRM_PROFILING_LEAVE_SCOPE(L"_PerformActions", g_pwszLeavingFunction);
    
    return dr;
} /* unconditional brace to create a scope */


#if DRM_SUPPORT_REVOCATION

/******************************************************************************
** 
** Function :   _ValidateRevocationVersions
** 
** Synopsis :   This will check the revocation list versions in the license versus the current 
**              list versions to ensure they are adequate.  The current version numbers should 
**              be pre-cached for this check
**              
** 
******************************************************************************/
static DRM_RESULT _ValidateRevocationVersions( 
    IN OUT DRM_FFLICENSE    *f_pFFLicense,
    IN     DRM_HDS_CONTEXT  *f_pcontextHDS)
{
    DRM_RESULT          dr                    = DRM_SUCCESS;
    DRM_DWORD           idCRLAppRequired      = 0;
    DRM_DWORD           idCRLDeviceRequired   = 0;
    DRM_DWORD           idCRLWMDRMNETRequired = 0;
    DRM_CONST_STRING    dstrValue             = EMPTY_DRM_STRING;
    DRM_LONG            lValue                = 0;

    ChkArg( f_pFFLicense != NULL 
         && f_pcontextHDS != NULL );


    /* Extract required versions from an XML license */
#if DRM_SUPPORT_APP_REVOCATION
    idCRLAppRequired = f_pFFLicense->idCRLsCurrent.app;
    f_pFFLicense->pLicEval->idCRLsCurrent.app = f_pFFLicense->idCRLsCurrent.app;

    ChkDR(DRM_RVK_PerformAppRevocationCheck(f_pFFLicense->pLicEval, f_pcontextHDS));     
#endif

#if DRM_SUPPORT_DEVICE_REVOCATION
    dr = DRM_LIC_GetAttribute( &f_pFFLicense->pLicEval->dstrContentLicense,
                               &g_dstrDeviceRevocationLicenseTag, 
                                DRM_LICENSE_ATTRIB_REVOCATION,
                                NULL,
                               &dstrValue,
                                0 );
    if( DRM_SUCCEEDED( dr ) )
    {
        ChkDR( wcsntol( dstrValue.pwszString, dstrValue.cchString, &lValue ) );
        idCRLDeviceRequired = (DRM_DWORD)lValue;
    }
#endif

#if DRM_SUPPORT_WMDRMNET
    dr = DRM_LIC_GetAttribute( &f_pFFLicense->pLicEval->dstrContentLicense,
                               &g_dstrWMDRMNETRevocationLicenseTag, 
                                DRM_LICENSE_ATTRIB_REVOCATION,
                                NULL,
                               &dstrValue,
                                0 );
    if( DRM_SUCCEEDED( dr ) )
    {
        ChkDR( wcsntol( dstrValue.pwszString, dstrValue.cchString, &lValue ) );
        idCRLWMDRMNETRequired = (DRM_DWORD)lValue;
    }
#endif


    /* Compare the required values to the cached values */
    if( idCRLAppRequired      > f_pFFLicense->idCRLsCurrent.app
     || idCRLDeviceRequired   > f_pFFLicense->idCRLsCurrent.device
     || idCRLWMDRMNETRequired > f_pFFLicense->idCRLsCurrent.wmdrmnet )
    {        
        /* Although we're failing here, the caller should update
        *  the revocation version cache and try again. This is in
        *  case there have been any updates to the revocation lists.
        */
        ChkDR( DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE );
    }


    /*
    **Compare license RIV with HDS RIV if higher return DRM_E_RIV_TOO_SMALL error
    */
    dr = DRM_LIC_GetAttribute(  &f_pFFLicense->pLicEval->dstrContentLicense, 
                                NULL, 
                                DRM_LICENSE_ATTRIB_REVINFO, 
                                NULL, 
                                &dstrValue, 
                                0 );
    if( DRM_SUCCEEDED( dr ) )
    {
        ChkDR( wcsntol( dstrValue.pwszString, dstrValue.cchString, (DRM_LONG *) &lValue) );
        if( (DRM_DWORD)lValue > f_pFFLicense->idCRLsCurrent.riv )
        {
            /* Although we're failing here, the caller should update
            *  the revocation version cache and try again. This is in
            *  case there have been any updates to the revocation lists.
            */
            ChkDR( DRM_E_RIV_TOO_SMALL );
        }
    }

    dr = DRM_SUCCESS;

ErrorExit:
    
    return dr;
}

#endif /*DRM_SUPPORT_REVOCATION*/


/******************************************************************************
** 
** Function :   _GetLicenseInfoAndSetup
** 
** Synopsis :   Load the license in memory and setup
**              
** 
** Arguments :  
**              
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT _GetLicenseInfoAndSetup(
    IN OUT   DRM_FFLICENSE    *f_pFFLicense,
    IN const DRM_CONST_STRING *f_rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD         f_cRights,
    IN       DRM_HDS_CONTEXT  *f_pcontextHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbLicSize  = 0;
    DRM_BYTE  *pbChecksum = NULL;

    /* internal function. no need to validate arguments 
    */
    
    cbLicSize = f_pFFLicense->cbBuffer;
    ChkDR( DRM_LST_GetLicense( f_pFFLicense->pLicStore, 
                              &f_pFFLicense->rgkid      [f_pFFLicense->dwChainDepth], 
                              &f_pFFLicense->rglid      [f_pFFLicense->dwChainDepth],
                              &(f_pFFLicense->rgslotHint[f_pFFLicense->dwChainDepth]),
                               f_pFFLicense->pbBuffer,
                              &cbLicSize) );

    DSTR_FROM_PB( &(f_pFFLicense->pLicEval->dstrContentLicense), f_pFFLicense->pbBuffer, cbLicSize );
    f_pFFLicense->pLicEval->fUseCachedAttribs = FALSE;
    
    /*
    **  Load the necessary License Attribs
    */
    ChkDR( _LoadLicenseAttributes( f_rgpdstrRights, f_cRights, f_pFFLicense->pLicEval ) );
                 
    /* see if we have a global policy forbidding metering */
    
    if ((f_pFFLicense->dwPolicyFlags & DRM_POLICY_FLAG_METERING_DISABLED_ENTERPRISE) != 0)
    {
        if ( f_pFFLicense->pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_METERING_ID].cchString != 0 )
        {
            /* we have a MID */
            ChkDR(DRM_E_POLICY_METERING_DISABLED);
        }
    }
#if DRM_SUPPORT_METERING
    else
    {
        if ( f_pFFLicense->pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_METERING_ID].cchString != 0 )
        {
            DRM_DWORD cbMID = SIZEOF(DRM_MID);
            
            f_pFFLicense->rgfHasMetering [f_pFFLicense->dwChainDepth] = TRUE;
   
            ChkDR(DRM_B64_DecodeW( &f_pFFLicense->pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_METERING_ID], 
                                   &cbMID, 
                                   (DRM_BYTE *) &f_pFFLicense->rgmid[f_pFFLicense->dwChainDepth], 
                                   0 ) );
        }                               
    }
    
#endif  

                                       
    cbLicSize = SIZEOF( f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_rgbContentKey );
    if( f_pFFLicense->dwChainDepth == DRM_MAX_LICENSE_CHAIN_DEPTH-1 )
    {
        /* If we are on the last level that a chain could be pass in NULL */
        pbChecksum = NULL;
    }
    else
    {
        /* Otherwise get the checksum for the next license up the chain */
        pbChecksum = f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth+1].m_rgbChecksum;
    }

    ChkDR( DRM_LIC_GetEnablingBits( &(f_pFFLicense->pLicEval->dstrContentLicense),
                                     0, /* Get the first enabling bit */
                                    &f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_dwAlgorithm,
                                    &f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_oPublKey,
                                     f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_rgbContentKey, 
                                    &cbLicSize, 
                                    &f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_oLsPublKey,
                                     f_pFFLicense->pBindingInfo[f_pFFLicense->dwChainDepth].m_rgbSignature,
                                     pbChecksum,
                                    &f_pFFLicense->pLicEval->pcontextBBX->CryptoContext ) );

    if( f_pFFLicense->fSecStoreOpen[f_pFFLicense->dwChainDepth] )
    {
        f_pFFLicense->fSecStoreOpen[f_pFFLicense->dwChainDepth] = FALSE;
        ZEROMEM(&(f_pFFLicense->pSecStoreLicense[f_pFFLicense->dwChainDepth]), 
                SIZEOF( &f_pFFLicense->pSecStoreLicense[f_pFFLicense->dwChainDepth] ) );
    }

    f_pFFLicense->pLicEval->fSecureTimeDataValid = FALSE;      /* Must be done */
    f_pFFLicense->pLicEval->fInGracePeriod       = FALSE;      /* Must be done */
    f_pFFLicense->pLicEval->u64GPStartTime       = DRM_UI64( 0 );  /* Must be done */

#if DRM_SUPPORT_SECURE_CLOCK
    /* Never fail here for secure clock stuff */

    dr = DRM_SST_CreateGlobalStorePassword( f_pFFLicense->rgbLicensePassword, 
                                (DRM_BYTE *)f_pFFLicense->pLicEval->pcontextBBX ); 
    if( DRM_SUCCESS == dr )
    {
        DRM_DWORD dwSecureData = 0;
        DRM_SECSTORE_CLOCK_DATA oClkData;

        ZEROMEM(&oClkData, SIZEOF(oClkData));
        dwSecureData = SIZEOF(oClkData);

        dr = DRM_SST_GetData( &(f_pFFLicense->pSecStoreLicense[f_pFFLicense->dwChainDepth]), 
                              &g_idSData, 
                              &g_idSDataPrev, 
                               f_pFFLicense->rgbLicensePassword, 
                               SECURE_STORE_GLOBAL_DATA,
                               f_pcontextHDS,
                              (DRM_BYTE *) &oClkData, 
                              &dwSecureData );

        if( DRM_SUCCESS == dr )
        {
            _PrepareSecureClockDataForReading( &oClkData );
            /* Now Test the Values */
            if( ( oClkData.flag&CLK_LK_GP_VALID ) && ( oClkData.flag&CLK_IN_GP_VALID ) )
            {
                f_pFFLicense->pLicEval->fSecureTimeDataValid = TRUE;
                if( oClkData.fInGracePeriod )
                {
                    f_pFFLicense->pLicEval->fInGracePeriod = TRUE;
                }
                f_pFFLicense->pLicEval->u64GPStartTime = oClkData.LastKnownGracePeriodStartTime;
            }
        }
    }
    dr = DRM_SUCCESS;
#endif
        
ErrorExit:
    
    return dr;
}



/******************************************************************************
** 
** Function :   _ProcessEndOfChain
** 
** Synopsis :   Process end of the liense chain and return
**              
** 
** Arguments :  
**              
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
static DRM_RESULT _ProcessEndOfChain(
    IN OUT   DRM_FFLICENSE               *f_pFFLicense,
    IN       DRMPFNOUTPUTLEVELSCALLBACK   f_pfnOutputLevelsCallback,
    IN const DRM_VOID                    *f_pv)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_PROFILING_ENTER_SCOPE(L"_ProcessEndOfChain", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    /* internal function. no need to validate arguments 
    */

    if ( f_pFFLicense->pV1Header )
    {
        /* use legacy (v1) header */
        if( SIZEOF( DRM_CIPHER_CONTEXT ) > f_pFFLicense->cbBuffer )
        {
            ChkDR( DRM_E_BUFFERTOOSMALL );
        }
        if( DRM_SUCCEEDED( DRM_BBX_LegacyCipherKeySetup( f_pFFLicense->pBindingInfo,
                                                         f_pFFLicense->pV1Header->pbKeyID,
                                                         f_pFFLicense->pV1Header->cbKeyID,
                                                         f_pFFLicense->pV1Header->pbSecretData,
                                                         f_pFFLicense->pV1Header->cbSecretData, 
                                                         (DRM_CIPHER_CONTEXT*)f_pFFLicense->pbBuffer,
                                                         f_pFFLicense->pLicEval->pcontextBBX ) ) )
        {
            dr = DRM_SUCCESS;
        }
        else
        {
            dr = DRM_E_LIC_KEY_DECODE_FAILURE;
        }            
    }
    else
    {
        if( DRM_BBX_CanBind( f_pFFLicense->pBindingInfo,
                             f_pFFLicense->dwChainDepth + 1,
                             f_pFFLicense->pLicEval->pcontextBBX ) )
        {
            dr = DRM_SUCCESS;
        }
        else
        {
            dr = DRM_E_LIC_KEY_DECODE_FAILURE;
        }
    }

    if( DRM_SUCCEEDED( dr ) )
    {
        if( f_pfnOutputLevelsCallback != NULL )
        {
            DRM_DWORD i = 0;
            
            for( i = f_pFFLicense->dwChainDepth + 1; i > 0; )
            {
                /* Find and return the root most OPL for the license chain. */
                i--;
                if( f_pFFLicense->rgfPlayOplValid[i] )
                {
                    dr = f_pfnOutputLevelsCallback( &f_pFFLicense->rgPlayOpl[i].oplPlay, DRM_PLAY_OPL_CALLBACK, f_pv );
                    break;
                }
            }
            
#if DRM_SUPPORT_COPY_OPL
            for( i = f_pFFLicense->dwChainDepth + 1; i > 0; )
            {
                i--;
                /* Find and return the root most OPL for the license chain. */                
                if( f_pFFLicense->rgfCopyOplValid[i] )
                {
                    dr = f_pfnOutputLevelsCallback( &f_pFFLicense->rgCopyOpl[i].oplCopy, DRM_COPY_OPL_CALLBACK, f_pv );
                    break;
                }
            }
#endif
        }
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"_ProcessEndOfChain", g_pwszLeavingFunction);
    return dr;
}


/*****************************************************************************
** Function: _GetSourceIDFromLicense
**
** Synopsis: Checks of the <SOURCEID> tag in the XML license and updates the
**           the dwSourceid in DRM_FFLICENSE if found.
**           Source ID should be specified only in leaf license. We will ignore 
**           the sourceID if specified in the root license.
** Arguments:
**           IN f_pFFLicense   -- DRM_FFLICENSE the license
** Returns:
**           DRM_SUCCESS           -- On success
*****************************************************************************/
DRM_RESULT _GetSourceIDFromLicense ( 
    IN DRM_FFLICENSE *f_pFFLicense )
{
    DRM_RESULT       dr        = DRM_SUCCESS;
    DRM_CONST_STRING dstrValue = EMPTY_DRM_STRING;
    
    
    ChkArg( f_pFFLicense != NULL 
         && f_pFFLicense->pLicEval != NULL 
         && f_pFFLicense->pLicEval->dstrContentLicense.pwszString != NULL );

    f_pFFLicense->dwSourceid = 0;
    
    dr = DRM_LIC_GetAttribute(  &f_pFFLicense->pLicEval->dstrContentLicense, 
                                NULL, 
                                DRM_LICENSE_ATTRIB_SOURCEID, 
                                NULL, 
                                &dstrValue, 
                                0 );
    if( DRM_SUCCEEDED( dr ) )
    {
        ChkDR( wcsntol( dstrValue.pwszString, 
                        dstrValue.cchString, 
             (DRM_LONG*)&f_pFFLicense->dwSourceid ) );        
    }

    dr = DRM_SUCCESS;
ErrorExit:

    return dr;
}


DRM_RESULT DRM_API DRM_LIC_CompleteLicenseChain(
    IN OUT   DRM_FFLICENSE               *pFFLicense,
    IN const DRM_CONST_STRING            *rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD                    cRights,
       OUT   DRM_DWORD                   *pdwChainDepth,
    IN       DRM_HDS_CONTEXT             *pcontextHDS,
    IN       DRMPFNOUTPUTLEVELSCALLBACK   pfnOutputLevelsCallback,
    IN const DRM_VOID                    *pv )
{
    DRM_RESULT       dr             = DRM_SUCCESS;
    DRM_CONST_STRING dstrMID        = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrLID        = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrLIData     = EMPTY_DRM_STRING;
    DRM_BYTE        *pbChecksum     = NULL;
    DRM_BOOL         fEvalResult    = FALSE;
    DRM_STACK_ALLOCATOR_CONTEXT stack = { 0, 0, NULL };

    DRM_PROFILING_ENTER_SCOPE(L"DRM_LIC_CompleteLicenseChain", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
    
    DRMCASSERT( DRM_MAX_LICENSE_CHAIN_DEPTH > 0 );

    ChkArg( pFFLicense                != NULL
         && pFFLicense->pLicStore     != NULL
         && pFFLicense->pbBuffer      != NULL
         && pFFLicense->cbBuffer       > 0 
         && pFFLicense->pBindingInfo  != NULL
         && pFFLicense->pLicStoreEnum != NULL
         && pdwChainDepth             != NULL
         && pcontextHDS               != NULL 
         && cRights                   <= DRM_MAX_ACTIONS
         && pFFLicense->pLicEval      != NULL
         && pFFLicense->pLicEval->pcontextBBX    != NULL);
    pFFLicense->pLicEval->fDeleteLicense = FALSE;

    *pdwChainDepth = 0;
    if( pFFLicense->dwChainDepth >= DRM_MAX_LICENSE_CHAIN_DEPTH )
    {
        ChkDR ( DRM_E_LICENSENOTFOUND );
    }
    else if( pFFLicense->dwChainDepth == 0 )
    {
        DRM_DWORD i;
        for( i = 0; i < DRM_MAX_LICENSE_CHAIN_DEPTH; i++ )
        {
#if DRM_SUPPORT_COPY_OPL
            pFFLicense->rgfCopyOplValid[i] = FALSE;
#endif
            pFFLicense->rgfPlayOplValid[i] = FALSE;
        }
#if DRM_SUPPORT_WMDRMNET
        pFFLicense->dwMinimumRequiredAppSec = 0;
#endif
    }

#if DRM_SUPPORT_APP_REVOCATION
    pFFLicense->fUpdatedRevocationList = FALSE;
#endif

#if DRM_SUPPORT_METERING
    pFFLicense->rgfHasMetering [pFFLicense->dwChainDepth] = FALSE;
#endif

    ChkDR(_GetLicenseInfoAndSetup(pFFLicense, rgpdstrRights, cRights, pcontextHDS));

#if DRM_SUPPORT_REVOCATION
    /*
    *  Compare license RIV and CRL versions, 
    *  then return DRM_E_RIV_TOO_SMALL 
    *  or DRM_E_LICEVAL_REQUIRED_REVOCATION_LIST_NOT_AVAILABLE error
    *
    */
    ChkDR( _ValidateRevocationVersions( pFFLicense, pcontextHDS ) );
#endif /*DRM_SUPPORT_REVOCATION*/

    /* 
    ** Check if the license has source id >0 and update the dwSourceid in
    ** DRM_FFLICENSE. The source ID should be specified only in leaf license.
    */
    if( pFFLicense->dwChainDepth == 0 )
    {
        ChkDR( _GetSourceIDFromLicense( pFFLicense ) );  
    }

    /* Talk to blackbox to get the secure store password for this license */
    ChkDR( DRM_BBX_HashValue( pFFLicense->pLicEval->LID.rgb, 
                              SIZEOF( pFFLicense->pLicEval->LID.rgb ),
                              pFFLicense->rgbLicensePassword, 
                              pFFLicense->pLicEval->pcontextBBX ) );

    ChkDR( DRM_SST_OpenKeyTokens( &(pFFLicense->pSecStoreLicense[pFFLicense->dwChainDepth]),
                                  &pFFLicense->pLicEval->LID,
                                  NULL,
                                  pFFLicense->rgbLicensePassword, 
                                  0, 
                                  SECURE_STORE_LICENSE_DATA, 
                                  pcontextHDS ) );

    pFFLicense->fSecStoreOpen[pFFLicense->dwChainDepth] = TRUE;

    pFFLicense->pLicEval->pcontextSSTLicense       = &(pFFLicense->pSecStoreLicense[pFFLicense->dwChainDepth]);
    pFFLicense->pLicEval->fGlobalSecStoreWritable  = FALSE;

    pFFLicense->pLicEval->dwFlags              = LICEVAL_OPEN_CHECK_SETTINGS;
    pFFLicense->pLicEval->fReserved            = 0;
    pFFLicense->pLicEval->pLicStoreEnumContext = &(pFFLicense->pLicStoreEnum[pFFLicense->dwChainDepth]);
    pFFLicense->pLicEval->dwChainDepth         = pFFLicense->dwChainDepth;
    pFFLicense->pLicEval->pcontextHDS          = pcontextHDS;
    pFFLicense->pLicEval->eTimeBasedState      = LICEVAL_NOREFERENECE;
    
    ChkDR( DRM_LEVL_PerformOperations( pFFLicense->pLicEval,
                                       DRM_LICENSE_EVAL_SELECT, 
                                       DRM_LICENSE_EVAL_CAN_DO_OPERATION, 
                                       NULL,
                                       &fEvalResult,
                                       NULL,
                                       pcontextHDS) );
    if( !fEvalResult )
    {
        dr = DRM_E_RIGHTSNOTAVAILABLE;
        goto ErrorExit;
    }

#if DRM_SUPPORT_SECURE_CLOCK
    if (pFFLicense->pLicEval->eTimeBasedState == LICEVAL_MACHINEDATETIMEREFERENCED 
     && pFFLicense->pLicEval->fInGracePeriod )
    {
        pFFLicense->pLicEval->lReasonForFail = LR_LICENSE_CLOCK_NOT_SET;
        dr = DRM_E_RIGHTSNOTAVAILABLE;
        goto ErrorExit;
    }

#endif
    ChkDR( _PerformActions( pFFLicense,
                           &stack,
                            rgpdstrRights,
                            cRights,
                            pcontextHDS,
                            pfnOutputLevelsCallback ) );

#if DRM_SUPPORT_WMDRMNET
    {
        DRM_DWORD dwMinimumRequiredAppSec = 0;
        
        ChkDR( DRM_ASD_ParseV2License(&pFFLicense->pLicEval->dstrContentLicense, 
                                      &g_dstrDRM_LS_APPSEC_ATTR, 
                                      &dwMinimumRequiredAppSec,
                                       NULL));
        
        if( dwMinimumRequiredAppSec > pFFLicense->dwMinimumRequiredAppSec )
        {
            pFFLicense->dwMinimumRequiredAppSec = dwMinimumRequiredAppSec;
        }
    }
#endif

    /* Get the KID for the chained license */
    if( (pFFLicense->pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CHAINEDKID]).cchString != 0 )
    {
        DRM_KID oChainKID;

        if( pFFLicense->pV1Header )
        {
            /* We don't support chained licenses from V1 content */
            ChkDR( DRM_E_V1_LICENSE_CHAIN_NOT_SUPPORTED );
        }

        if( pFFLicense->dwChainDepth + 1 >= DRM_MAX_LICENSE_CHAIN_DEPTH )
        {
            /* We're at the maximum chain depth that we support */
            ChkDR ( DRM_E_LICENSENOTFOUND );
        }

        ChkDR( DRM_UTL_DecodeKID( &(pFFLicense->pLicEval->rgdstrCachedAttribs[eDRM_LIC_CACHED_ATTRIB_CHAINEDKID]),
                                  &oChainKID) );

        /* Open an enumerator for the KID, increment the chain depth and recurse */                    
        /* Don't recurse if the dependent kid is a kid already in the chain   */
        ChkDR( DRM_LST_InitEnum( pFFLicense->pLicStore, 
                                &oChainKID, 
                                 TRUE, 
                                &(pFFLicense->pLicStoreEnum[pFFLicense->dwChainDepth+1]) ) );
        while( TRUE )
        {
            dr = DRM_LST_EnumNext(&(pFFLicense->pLicStoreEnum [pFFLicense->dwChainDepth + 1]), 
                                  &pFFLicense->rgkid          [pFFLicense->dwChainDepth + 1], 
                                  &pFFLicense->rglid          [pFFLicense->dwChainDepth + 1], 
                                  &(pFFLicense->rgslotHint    [pFFLicense->dwChainDepth + 1]),
                                  NULL);
            if( dr == DRM_E_NOMORE )
            {
                dr = DRM_E_LICENSENOTFOUND;
                goto ErrorExit;
            }
            ChkDR( dr );
            pFFLicense->dwChainDepth++;
            dr = DRM_LIC_CompleteLicenseChain( pFFLicense, 
                                               rgpdstrRights, 
                                               cRights, 
                                               pdwChainDepth, 
                                               pcontextHDS, 
                                               pfnOutputLevelsCallback, 
                                               pv );
            pFFLicense->dwChainDepth--;
            if( DRM_SUCCEEDED( dr ) )
            {
                goto ErrorExit;
            }
        }
    }
    else
    {
        /* 
        Yeah!  We can use this license.  Now try to set up a decryptor. 
        Only setup a decryptor is this is either a simple license ( no chain ),
        or the last link in the chain
        */

        if (!pFFLicense->fCanBind )
        {
            ChkDR(_ProcessEndOfChain(pFFLicense, pfnOutputLevelsCallback, pv));
        }
    }

    *pdwChainDepth = pFFLicense->dwChainDepth + 1;

ErrorExit:
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_LIC_CompleteLicenseChain", g_pwszLeavingFunction);
    return dr;
}



DRM_RESULT DRM_API DRM_LIC_ReportActions(
    IN OUT   DRM_FFLICENSE         *pFFLicense,
    IN const DRM_CONST_STRING      *rgpdstrRights[], /* Array of DRM_CONST_STRING pointers */
    IN       DRM_DWORD              cRights,
    IN       DRM_DWORD              dwChainDepth,
    IN       DRM_HDS_CONTEXT       *pcontextHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD cbLicSize = 0;
    DRM_DWORD iCount = 0;
    DRM_DWORD iRights = 0;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_LIC_ReportActions", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    /* Report actions and update metering info */        
    for( ; iCount < dwChainDepth ; iCount++ )
    {
        pFFLicense->rgfDeleteLicense[iCount] = FALSE;
        /*
        ** Read the licenses from the license store again.  It will need 
        **  refreshing if it was a chained license 
        */
        {
            cbLicSize = pFFLicense->cbBuffer;
            ChkDR( DRM_LST_GetLicense( pFFLicense->pLicStore, 
                                      &pFFLicense->rgkid[iCount],
                                      &pFFLicense->rglid[iCount], 
                                      &(pFFLicense->rgslotHint[iCount]),
                                       pFFLicense->pbBuffer, &cbLicSize ) );

            DSTR_FROM_PB( &(pFFLicense->pLicEval->dstrContentLicense), 
                            pFFLicense->pbBuffer, 
                            cbLicSize );
            pFFLicense->pLicEval->fUseCachedAttribs = FALSE;
            
            /*
            **  Load the necessary License Attribs
            */
            ChkDR( _LoadLicenseAttributes( rgpdstrRights, cRights, pFFLicense->pLicEval ) );
            
        }

        pFFLicense->pLicEval->pcontextSSTLicense      = &(pFFLicense->pSecStoreLicense[iCount]);
        pFFLicense->pLicEval->fGlobalSecStoreWritable = FALSE;
        pFFLicense->pLicEval->fReserved               = 0;
        pFFLicense->pLicEval->pLicStoreEnumContext    = &(pFFLicense->pLicStoreEnum[iCount]);
        pFFLicense->pLicEval->dwChainDepth            = iCount;

        pFFLicense->pLicEval->fDeleteLicense = FALSE;
        iRights = cRights;
        for( ; iRights > 0; )
        {
            DRM_BOOL fEvalResult = FALSE,
                     fExisted    = FALSE;

            iRights--;
            ChkDR( DRM_LEVL_PerformOperations( pFFLicense->pLicEval, 
                                               DRM_LICENSE_EVAL_ACTION,
                                               DRM_LICENSE_EVAL_DONE_WITH_OPERATION, 
                                               rgpdstrRights[iRights],
                                              &fEvalResult, 
                                              &fExisted,
                                               pcontextHDS) );
            if( fExisted && !fEvalResult )
            {
                /* This Right is not allowed.  Move to the next license */
                ChkDR( DRM_E_RIGHTSNOTAVAILABLE );
            }                        
        }
        pFFLicense->rgfDeleteLicense[iCount] = pFFLicense->pLicEval->fDeleteLicense;
    }
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_LIC_ReportActions", g_pwszLeavingFunction);
    return dr;
}


#if DRM_SUPPORT_ANTIROLLBACK_CLOCK

DRM_RESULT DRM_API DRM_LIC_CheckClockRollback(  
    IN DRM_LICEVAL_CONTEXT      *pLicEval,
    IN DRM_LICSTORE_CONTEXT     *pLicStore,
    IN DRM_LICSTOREENUM_CONTEXT *pLicEnum,
    IN DRM_BYTE                 *pbBuffer,
    IN DRM_DWORD                 cbBuffer,
    IN DRM_HDS_CONTEXT          *pcontextHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BOOL fEvalResult = TRUE;
    DRM_BYTE rgbPassword [__CB_DECL(SHA_DIGEST_LEN)];
    const DRM_CONST_STRING *pdstrSetClockString = &g_dstrSetSavedDateTime;

    if( DRM_FAILED( DRM_LEVL_EvaluateExpression( pLicEval,
                                                &g_dstrCheckClockRollback,
                                                &fEvalResult ) ) 
     || fEvalResult )
    {
        DRM_KID oKID;
        DRM_LID oLID;

        /* The clock set string in this case will set the saved date time to the current time */
        /* If this code path isn't executed the expression logic will only set the clock to a time forward from
           what the current saved date time is */
        pdstrSetClockString = &g_dstrResetRollbackedClock;

        /* There was a failure or the clock was roll back.  In either case we report that as clock rollback */
        ChkDR( DRM_LST_InitEnum( pLicStore, NULL, FALSE, pLicEnum ) );    

        while( TRUE ) /* Loop will break when DRM_E_NOMORE is hit */
        {
            DRM_DWORD cbLicSize=0;
            DRM_CONST_STRING dstrLID = EMPTY_DRM_STRING;
            DRM_HDS_SLOT_HINT slotHint = {0};

            cbLicSize = cbBuffer;
            dr = DRM_LST_EnumNext( pLicEnum, &oKID, &oLID, &slotHint, &cbLicSize);
            if ( dr == DRM_E_NOMORE )
            {
                dr = DRM_SUCCESS;
                break;
            }
            ChkDR( dr );

            if ( cbLicSize > cbBuffer )  /* We could fail because the buffer isn't big enough. */
            {                
                ChkDR(DRM_E_OUTOFMEMORY);       
            }

            ChkDR(DRM_LST_GetLicense(pLicStore, &oKID, &oLID, &slotHint, pbBuffer, &cbLicSize ) );

            DSTR_FROM_PB( &(pLicEval->dstrContentLicense), pbBuffer, cbLicSize );
            pLicEval->fUseCachedAttribs = FALSE;
            
            /* Get the LID for the license */
            ChkDRContinue( DRM_LIC_GetAttribute( &pLicEval->dstrContentLicense, 
                                                  NULL, 
                                                  DRM_LICENSE_ATTRIB_LID, 
                                                  NULL,
                                                  &dstrLID,
                                                  0 ) );
            ChkDRContinue( DRM_UTL_StringToGuid( &dstrLID, (DRM_GUID*) &pLicEval->LID ) );

            ChkDRContinue( DRM_BBX_HashValue( pLicEval->LID.rgb, 
                                              SIZEOF( pLicEval->LID.rgb ),
                                              rgbPassword, 
                                              pLicEval->pcontextBBX ) );

            ChkDRContinue( DRM_SST_OpenKeyTokens( pLicEval->pcontextSSTLicense, 
                                                 &pLicEval->LID, 
                                                  NULL,
                                                  rgbPassword, 
                                                  0,
                                                  SECURE_STORE_LICENSE_DATA,
                                                  pcontextHDS ) );

            pLicEval->fGlobalSecStoreWritable = FALSE;
            pLicEval->dwFlags                 = LICEVAL_OPEN_CHECK_SETTINGS;
            pLicEval->fReserved               = 0;
            pLicEval->pLicStoreEnumContext    = pLicEnum;
            dr = DRM_LEVL_PerformOperations( pLicEval, 
                                             DRM_LICENSE_EVAL_REPORTCLOCK_ROLLBACK, 
                                             DRM_LICENSE_EVAL_DONE_WITH_OPERATION, 
                                             NULL,
                                             &fEvalResult, 
                                             NULL,
                                             pcontextHDS);
            
            DRM_SST_CloseKey( pLicEval->pcontextSSTLicense, pcontextHDS );
        }
    }

    /* update the saveddatetime -- ignore errors here */
    pLicEval->fGlobalSecStoreWritable = TRUE;
    DRM_LEVL_EvaluateExpression( pLicEval, pdstrSetClockString, &fEvalResult );
ErrorExit:
    return dr;
}


#endif  /* DRM_SUPPORT_ANTIROLLBACK_CLOCK  */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcmdlnpars.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __CMDLNPARS_H__
#define __CMDLNPARS_H__

#ifdef __cplusplus
extern "C" {
#endif

/*********************************************************************
**
**  Function:  DRM_CMD_ParseCmdLine
**
**  Synopsis:  Parse a string for command line arguments.
**
**  Arguments:  
**     [pwszArgument] -- Source string
**     [pwchOptionChar] -- A substring within pwszString
**     [pwszParam] -- The parameter value associated with the option character
**     [pwszExtra] -- Extra data 
**
**  Returns:  
**
**  Notes:  Argument syntax is -c[:param[,extra]]
**
*********************************************************************/

DRM_BOOL DRM_API DRM_CMD_ParseCmdLine(
    IN  const DRM_WCHAR        *pwszArgument,
    OUT       DRM_WCHAR        *pwchOptionChar,
    OUT       DRM_CONST_STRING *pdstrParam,
    OUT       DRM_CONST_STRING *pdstrExtra);

#ifdef __cplusplus
}
#endif

#endif /* __CMDLNPARS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcertparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCERTPARSER_H__
#define __DRMCERTPARSER_H__


#include "drmbase64.h"
#include "drmrevocation.h"

#ifdef __cplusplus
extern "C" {
#endif

#if DRM_SUPPORT_REVOCATION

enum DRM_CERTIFICATE_TYPE
{
    certtypeUnknown = -1,
    certtypeRoot    =  0,
    certtypeCertAuthority,
    certtypeBlackBox,
    certtypeBlackBoxVersion,
    certtypeMachine,
    certtypeIndivBox,
    certtypeExport,
    certtypeExportIncl,
    certtypeDevice,
    certtypeSampleProtection
};

DRM_RESULT DRM_API DRM_WCP_GetCertificateType(
  IN  const DRM_CHAR             *f_pszBase,
  IN  const DRM_SUBSTRING        *f_pdasstrCert,
  OUT enum DRM_CERTIFICATE_TYPE *f_pcerttype);

DRM_RESULT DRM_API DRM_WCP_GetAttribute(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
  IN       DRM_WMDRM_CERT_ATTRIBUTE f_attribute,
     OUT   DRM_SUBSTRING            f_rgdasstrValue [],
  IN OUT   DRM_DWORD               *f_pcEntries);

DRM_RESULT DRM_API DRM_WCP_GetKeyUsage(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT DRM_DWORD                 *f_dwKeyUsage);

DRM_RESULT DRM_API DRM_WCP_GetFeatures(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT DRM_DWORD                 *f_dwFeatures);

DRM_RESULT DRM_API DRM_WCP_GetSecurityLevel(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT DRM_DWORD                 *f_dwSecurityLevel);

DRM_RESULT DRM_API DRM_WCP_GetPublicKey(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT DRM_DWORD                 *f_pdwExponent,
     OUT DRM_BYTE                  *f_pbModulus,
     OUT DRM_DWORD                 *f_pcbModulus );

DRM_RESULT DRM_API DRM_WCP_GetHardwareID(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT   DRM_BYTE                 f_rgbHardwareID [SHA_DIGEST_LEN]);

DRM_RESULT DRM_API DRM_WCP_GetSignatureDigest(
  IN const DRM_CHAR                *f_pszBase,
  IN const DRM_SUBSTRING           *f_pdasstrCert,
     OUT   DRM_BYTE                 f_rgbDigest [SHA_DIGEST_LEN]);

DRM_RESULT DRM_API DRM_WCP_GetPKCert(
  IN const DRM_CHAR      *f_pszBase,
  IN const DRM_SUBSTRING *f_pdasstrCert,
     OUT   PKCERT        *f_ppkcert);

DRM_RESULT DRM_API DRM_WCP_GetManufacturerNodes(
  IN const DRM_CHAR      *f_pszBase,
  IN const DRM_SUBSTRING *f_pdasstrCert,
     OUT   DRM_SUBSTRING *f_pdastrNamespace,
     OUT   DRM_SUBSTRING  f_rgdastrTag       [],
     OUT   DRM_SUBSTRING  f_rgdastrAttrLabel [],
     OUT   DRM_SUBSTRING  f_rgdastrAttrValue [],
     OUT   DRM_SUBSTRING  f_rgdastrValue     [],
  IN OUT   DRM_DWORD     *f_pcEntries);

#define DRM_WCP_VERIFY_CERT_SIGNATURE     0x00000001
#define DRM_WCP_VERIFY_CERT_REQUIRED_TAGS 0x00000002
#define DRM_WCP_VERIFY_CERT_METHODS       0x00000004
#define DRM_WCP_VERIFY_CERT_ALL      (DRM_WCP_VERIFY_CERT_SIGNATURE|DRM_WCP_VERIFY_CERT_REQUIRED_TAGS|DRM_WCP_VERIFY_CERT_METHODS)

DRM_RESULT DRM_API DRM_WCP_VerifyCertificate(
    IN const DRM_CHAR            *f_pszBase,
    IN const DRM_SUBSTRING       *f_pdasstrCert,
    IN       DRM_DWORD            f_fVerify,
    IN       DRM_BOOL             f_fWMDRMNET,
    IN const WMDRMNET_CRL_ENTRY  *f_pRevocationEntries,
    IN       DRM_DWORD            f_cRevocationEntries,
       OUT   DRM_SUBSTRING       *f_pdasstrPublicRSA);

DRM_RESULT DRM_API DRM_WCP_VerifyCertificateCollection(
    IN const DRM_CHAR              *f_pszBase,
    IN const DRM_SUBSTRING         *f_pdasstrCert,
    IN const DRM_BOOL               f_fWMDRMNET,
    IN const DRM_ANSI_CONST_STRING *f_pdastrRootPubKey,
    IN const WMDRMNET_CRL_ENTRY    *f_pRevocationEntries,
    IN       DRM_DWORD              f_cRevocationEntries,
       OUT   DRM_SUBSTRING         *f_pdasstrLeafCertificate,
       OUT   DRM_SUBSTRING         *f_pdasstrPubkeyLeafmost);

DRM_RESULT DRM_API DRM_WCP_ReadPubKeyModulus(
    IN                        DRM_CHAR      *f_rgchB64,
    IN                        DRM_SUBSTRING *f_pdasstrB64,
    OUT                       DRM_BYTE      *f_pbMod,
    OUT                       DRM_DWORD     *f_pcbMod);

DRM_RESULT DRM_API DRM_WCP_GetCertificates(
    IN                              const DRM_ANSI_CONST_STRING *f_pdastrKeyFile,
    OUT                                   DRM_SUBSTRING          f_rgdasstrCollection [],
    IN OUT                                DRM_DWORD             *f_pcCertificates,
    OUT                                   DRM_SUBSTRING         *f_pdasstrCollection);

#define DRM_WCP_VERIFY_KEYFILE_SIGNATURE   0x00000001
#define DRM_WCP_VERIFY_KEYFILE_HISTORY     0x00000002
#define DRM_WCP_VERIFY_KEYFILE_ALL         (DRM_WCP_VERIFY_KEYFILE_SIGNATURE | DRM_WCP_VERIFY_KEYFILE_HISTORY)

DRM_RESULT DRM_API DRM_WCP_VerifyDigitalSignature(
    IN   const DRM_CHAR             *f_pszBase,
    IN   const DRM_SUBSTRING        *f_pdasstrDataInclusive,
    IN   const DRM_SUBSTRING        *f_pdasstrSignatureInclusive,
    IN   const DRM_BOOL              f_fWMDRMNET,
    IN   const WMDRMNET_CRL_ENTRY   *f_pRevocationEntries,
    IN         DRM_DWORD             f_cRevocationEntries);
#endif

#ifdef __cplusplus
}
#endif

#endif /* __DRMCERTPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcleanstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmsyncstore.h>
#include <drmlicstore.h>
#include <drmhds.h>

#if DRM_SUPPORT_CLEANUP 
static const DRM_DWORD g_dwPercentageTimeForDefrag = 10;

#define _REPORT_STATUS \
{\
    ++iLicense;\
    if ( pfnCallback && (iLicense % cLicBetweenCBInterval) == 0 ) \
    {\
        ChkDR( pfnCallback( pvCallerData, iLicense, cLicenses));\
    }\
}
#endif

/******************************************************************************
** 
** Function :   DRM_LST_Clean
** 
** Synopsis :   For PC (if DRM_SUPPORT_CLEANUP is defined), it will remove 
**              unusable licenses from the License store, and then "defrag" the 
**              store. For devices, it will only defrag the store
** 
** Arguments :  pbLicEvalCtxt
**              pbLicStoreCtxt
**              pbBuffer    - User supplied buffer for storing license
**              cbBuffer    - # of bytes in license buffer
**              pvCallerData- Caller data to be passed in the ReportProgress 
**                            callback
**              dwCallbackInterval - % completion after which 
**                  Callback (if any) should be invoked. 
**                  e.g. if dwCallbackInterval = 5, callback will be 
**                  invoked after 5%, 10%, 15%...completion
**              pfnCallback - Callback function to report progress
**              poHdsContext- HDS context
**
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_LST_Clean (
    IN       DRM_BYTE                *pbLicEvalCtxt,
    IN       DRM_BYTE                *pbLicStoreCtxt,
    IN       DRM_BYTE                *pbBuffer,
    IN       DRM_DWORD                cbBuffer,
    IN const DRM_VOID                *pvCallerData,
    IN       DRM_DWORD                dwCallbackInterval,
    IN       pfnStoreCleanupProgress  pfnCallback,
    IN       DRM_HDS_CONTEXT         *poHdsContext)
{
    DRM_RESULT                  dr = DRM_SUCCESS;
    
#if DRM_SUPPORT_CLEANUP    
    DRM_KID                     oKID;
    DRM_LID                     oLID;
    DRM_BOOL                    fDelete = FALSE;
    DRM_DWORD                   cLicenses = 0;  
    DRM_DWORD                   iLicense = 0;
    DRM_DWORD                   cLicBetweenCBInterval = 0;
    DRM_DWORD                   cbLicense = 0;
    DRM_LICEVAL_CONTEXT*        pLicEvalCtxt = (DRM_LICEVAL_CONTEXT *)
                                                    pbLicEvalCtxt;
#endif

    /*  Check input */
    ChkArg(pbLicEvalCtxt && pbLicStoreCtxt && pbBuffer && poHdsContext);

#if DRM_SUPPORT_CLEANUP     
    /*  Query for all licenses  */
    ChkDR( DRM_LST_InitEnum( 
            (DRM_LICSTORE_CONTEXT *)pbLicStoreCtxt, 
            NULL, 
            FALSE, 
            pLicEvalCtxt->pLicStoreEnumContext
            ) );

    if (pfnCallback)
    {
        /*  Count the number of licenses in the store   */
        ChkDR(DRM_LST_LicCount(
                pLicEvalCtxt->pLicStoreEnumContext,
                &cLicenses
                ));

        /*  Callback to confirm whether cleanup should be started */
        /*  Caller returns an error to indicate that cleanup should */
        /*  be aborted  */
        ChkDR( pfnCallback( pvCallerData, 0, cLicenses ) );
        
        cLicBetweenCBInterval = 
            (dwCallbackInterval * cLicenses * 
                    (100 + g_dwPercentageTimeForDefrag)) / (100*100);

        /*  For certain values of callbackinterval and size of the  */
        /*  store, this value might become zero                     */
        /*  Make sure that this value is reset to 1                 */
        if (0 == cLicBetweenCBInterval)
        {
            cLicBetweenCBInterval = 1;  
        }
        
        /*  Query for all licenses  */
        ChkDR( DRM_LST_InitEnum( 
                (DRM_LICSTORE_CONTEXT *)pbLicStoreCtxt, 
                NULL, 
                FALSE, 
                pLicEvalCtxt->pLicStoreEnumContext
                ) );        
    }
    
    while( TRUE ) /*    Loop will break when DRM_E_NOMORE is hit */
    {
        DRM_HDS_SLOT_HINT slotHint;

        cbLicense = 0;
        dr = DRM_LST_EnumNext( 
                pLicEvalCtxt->pLicStoreEnumContext,
                &oKID, &oLID, 
                &slotHint,
                &cbLicense
                ); 
        if( DRM_E_NOMORE == dr )
        {
            dr = DRM_SUCCESS;
            break;
        }
        ChkDR(dr);

        if (cbLicense > cbBuffer)
        {
            /*
            **  License size is greater than size of buffer available
            **  Ignore this license 
            */
            continue;           
        }

        /*  Use buffer provided by user */ 
        dr =  DRM_LST_GetLicense( (DRM_LICSTORE_CONTEXT *)pbLicStoreCtxt,
                                  &oKID, 
                                  &oLID, 
                                  &slotHint,
                                  pbBuffer, 
                                  &cbLicense );  
        if ( DRM_FAILED(dr) )
        {
            /*  Nevermind - continue deleting other licenses  */
            dr = DRM_SUCCESS;
            _REPORT_STATUS;
            continue;
        }

        /* Add info about this license to the license evaluator obj */
        DSTR_FROM_PB( &pLicEvalCtxt->dstrContentLicense, pbBuffer, cbLicense );
        pLicEvalCtxt->fUseCachedAttribs = FALSE;
        
        /* Talk to BB to get the secstore password for this license */
        ChkDR( DRM_SST_CreateLicenseStatePassword( &oLID, pbBuffer, (DRM_BYTE*)pLicEvalCtxt->pcontextBBX ) );

        dr = DRM_SST_OpenKeyTokens( pLicEvalCtxt->pcontextSSTLicense,
                                    &oLID,
                                    NULL,
                                    pbBuffer,
                                    0,
                                    SECURE_STORE_LICENSE_DATA,
                                    poHdsContext );     
        /*  
        **  Note there is no need to close this store.  
        **  We don't care to report actions we just peek inside 
        */

        if ( dr == DRM_E_FILENOTFOUND )
        {
            /* Data corruption - delete this license    */
            dr = DRM_SUCCESS;
            (void)DRM_LST_EnumDelete( pLicEvalCtxt->pLicStoreEnumContext );
            _REPORT_STATUS;
            continue;
        } 
        else if ( DRM_FAILED(dr) )
        {
            /*  Ignore this license */
            dr = DRM_SUCCESS;
            _REPORT_STATUS;
            continue;
        }

        /*  Save the store context  */
        pLicEvalCtxt->pcontextHDS = poHdsContext;                
               
        fDelete = FALSE;
        dr = DRM_LEVL_IsLicenseReadyForDeletion( pLicEvalCtxt, &fDelete );
        if ( !fDelete || DRM_FAILED(dr) )
        {
            /* Ignore this license    */
            dr = DRM_SUCCESS;
            _REPORT_STATUS;
            continue;
        }
        
        (void)DRM_LST_EnumDelete( pLicEvalCtxt->pLicStoreEnumContext );
        _REPORT_STATUS;                        
        
    }   /*  End of while(TRUE) loop   */   

#endif 

    /*  Defrag the license store    */
    ChkDR( DRM_HDS_CleanupStore(poHdsContext, TRUE) );    
                 
ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcommon.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCOMMON_H__
#define __DRMCOMMON_H__

#define DRM_MAX_ACTIONS 10

#define VERSION_LEN          4
#define DRM_MAX_PATH         256

/*Temporary holding place for these constants */
#ifndef TRUE
    #define TRUE 1
#endif

#ifndef FALSE
    #define FALSE 0
#endif

#ifndef NULL
    #define NULL 0
#endif

#ifndef NO_OF
    #define NO_OF( x )  ( SIZEOF( (x) ) / SIZEOF( (x)[0] ) )
#endif

#ifndef ISODD
    #define ISODD(x) ((x)&1)
#endif

#define DRM_SAFE_INT (int)0x0fffffff
#define DRM_SAFE_UINT (unsigned int)0x0fffffff
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
#define ROTATE_RIGHT(x, n) (((x) >> (n)) | ((x) << (32-(n))))
#define WORDSWAP(d) ( ( (d) >> 16 ) + ( (d) << 16 ) )

/* for good parameter documentation */
#define IN
#define OUT

#include <limits.h>
#include "drmtypes.h"       /*  core DRM types                                      */
#include "drmresults.h"     /*  return codes that DRM APIs can return               */
#include "drmerr.h"
#include "drmdebug.h"       /*  debug macros & functions                            */
#include "drmstrings.h"

#include "oemimpl.h"
#include "drmprofile.h"

#endif  /* __DRMCOMMON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmdebug.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <stdlib.h>
#include <drmcommon.h>

DRM_VOID drmtype_asserts(void)
{
    DRMSIZEASSERT(sizeof(DRM_BYTE), 1);
    DRMSIZEASSERT(sizeof(DRM_CHAR), 1);
#if SIXTEEN_BIT_ADDRESSING
    DRMSIZEASSERT(sizeof (DRM_SHORT), 1);
    DRMSIZEASSERT(sizeof (DRM_WORD),  1);
    DRMSIZEASSERT(sizeof (DRM_UINT),  2);
    DRMSIZEASSERT(sizeof (DRM_INT),   2);
    DRMSIZEASSERT(sizeof (DRM_LONG),  2);
    DRMSIZEASSERT(sizeof (DRM_DWORD), 2);
    DRMSIZEASSERT(sizeof (DRM_INT64), 4);
#else
    DRMSIZEASSERT(sizeof (DRM_SHORT), 2);
    DRMSIZEASSERT(sizeof (DRM_WORD),  2);
    DRMSIZEASSERT(sizeof (DRM_UINT),  4);
    DRMSIZEASSERT(sizeof (DRM_INT),   4);
    DRMSIZEASSERT(sizeof (DRM_LONG),  4);
    DRMSIZEASSERT(sizeof (DRM_DWORD), 4);
    DRMSIZEASSERT(sizeof (DRM_INT64), 8);
#endif    
}

#if DBG
extern DRM_VOID DRM_API 
_oem_trace(IN DRM_CHAR* szFmt, ...);


/*****************************************************************************/
fncdrmtrace g_TraceCallback = _oem_trace;

/*****************************************************************************/
DRM_VOID DRM_API DrmDebugHookTrace(IN fncdrmtrace pNewAssertFcn)
{
	if(NULL == pNewAssertFcn)
	{
        g_TraceCallback = _oem_trace;
	}
    else
    {
	    g_TraceCallback = pNewAssertFcn;
    }
}

/*****************************************************************************/
DRM_VOID DRM_API __drmassert(
    IN DRM_BOOL  fAssert, 
    IN DRM_CHAR *assertcmd, 
    IN DRM_CHAR *file, 
    IN DRM_INT   line)
{

	if(!fAssert) 
	{ 
		g_TraceCallback("DRMASSERT %s failed.  File %s. Line %d.\n",assertcmd,file,line);        
        if( g_OEMAssertCallback != NULL )
        {
            g_OEMAssertCallback( fAssert, assertcmd, file, line );
        }
	}	
} 


/*****************************************************************************/
/* Set the global assert handler to the above function */
fncdrmassert g_AssertCallback = __drmassert;

/*****************************************************************************/
DRM_VOID DRM_API DrmDebugHookAssert(IN fncdrmassert pNewAssertFcn)
{
	if(NULL == pNewAssertFcn)
	{
        g_AssertCallback = __drmassert;
	}
    else
    {
	    g_AssertCallback = pNewAssertFcn;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmdebug.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMDEBUG_H__
#define __DRMDEBUG_H__

#ifdef __cplusplus
extern "C" {
#endif


/*************************************************************************
*
*   debug printf macro
*   Sample calling seq:  -- NOTE double paranthesis for printf args. --
*   TRACE(("My name is %s\n", "DRM"));
*
*************************************************************************/
#if DBG

    #undef TRACE
    #define TRACE(x) g_TraceCallback x     

#else  // DBG

    #ifndef TRACE
    #define TRACE(x) 
    #endif

#endif  // DBG


typedef void (DRM_API *fncdrmtrace)(DRM_CHAR*, ... );
extern fncdrmtrace g_TraceCallback;

/* This type is to allow the ASSERT macro to have another implementation
	defined by the caller of DrmDebugHookAssert */
		
typedef void (DRM_API *fncdrmassert)(DRM_BOOL,DRM_CHAR*, DRM_CHAR*,DRM_INT);


/* The global current assert funtion pointer. */
extern fncdrmassert g_AssertCallback;
extern fncdrmassert g_OEMAssertCallback;

/**********************************************************************
** Function:	DrmDebugHookAssert
**
** Synopsis:	Change the global assert handler to one of the callers choosing.
**
** Arguments:	[pNewAssertFcn] -- Ptr to a function that handles asserts.
**
** Returns:		None
**
** Notes:		
**
***********************************************************************/
DRM_VOID DRM_API DrmDebugHookAssert(IN fncdrmassert pNewAssertFcn);

/**********************************************************************
** Function:	DrmDebugHookTrace
**
** Synopsis:	Change the global trace handler to one of the callers choosing.
**
** Arguments:	[pNewTraceFcn] -- Ptr to a function that handles traces.
**
** Returns:		None
**
** Notes:		
**
***********************************************************************/
DRM_VOID DRM_API DrmDebugHookTrace(IN fncdrmtrace pNewTraceFcn);

#define DRMSIZEASSERT(x,y)  \
    {switch(0){case ((x)==(y)?0:(y)):case (y):;}} \
    {switch(0){case ((y)==(x)?0:(x)):case (x):;}} \


#define DRM_OFFSET_OF(struc,member)   (DRM_DWORD)&(((struc *)0)->member)
#define ENSURE_MEMBERS_ADJACENT(struc,member1,member2)  ((DRM_OFFSET_OF(struc,member1)+(DRM_DWORD)(SIZEOF(((struc *)0)->member1))) == DRM_OFFSET_OF(struc,member2))

/* Always use compile time asserts */
#define DRMCASSERT( x ) switch(0){case 0:case (x):;}

#if DBG
    #undef DRMASSERT
    /* Call the global assert handler function. */
    #define DRMASSERT(x) g_AssertCallback((x), #x, __FILE__, __LINE__)
    
#else
    #ifndef DRMASSERT
        #define DRMASSERT
    #endif
    #ifndef DRMCASSERT
        #define DRMCASSERT
    #endif
#endif

#ifdef __cplusplus
}
#endif


#endif  /* __DRMDEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcontextsizes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCONTEXTSIZES_H__
#define __DRMCONTEXTSIZES_H__

#ifndef DRM_MAX_LICENSE_CHAIN_DEPTH
#define DRM_MAX_LICENSE_CHAIN_DEPTH   2                                /* Total number of licenses in a chain support by this DRM implementation */
#endif
#define MAX_DEVICE_CERT_SIZE          (10*1024)                        /* Device cert and licenses will be staged to share the same buffer       */
#define MAX_DEVICE_CERT_TEMPLATE_SIZE ((MAX_DEVICE_CERT_SIZE*6)/10)    /* 60% of the max devcert                                                 */
#define DRM_MAX_HEADERDATASIZE        (5*1024)                         /* 5K of header data                                                      */
#define DRM_MAX_LICENSESIZE           MAX_DEVICE_CERT_SIZE             /* 10K max license size                                                   */
#define MAX_ACTIONS_LENGTH            150
#define MAX_REVOCATION_LIST_SIZE      (30*1024)                        /* Revocation not supported in the Porting kit */

#include <drmcommon.h>
#include <drmlicense.h>
#include <drmsha1.h>
#include <drmhmac.h>
#include <drmrc4.h>
#include <drmcipher.h>
#include <drmstkalloc.h>
#include <drmdevcert.h>
#include <drmhds_impl.h>
#include <drmhds.h>
#include <drmsecurestore.h>
#include <drmexpreval.h>
#include <drmliceval.h>
#include <drmutilities.h>
#include <drmmetering.h>
#include <drmblackbox.h>
#include <drmlicstore.h>
#include <drmlicacq.h>
#include <drmoutputleveltypes.h>
#include <drmoutputlevels.h>
#include <drmchain.h>


typedef enum __EHeaderInContext
{
    eHeaderNotSet=0,
    eHeaderIsV1,
    eHeaderIsV2,
    eKidOnly
} EHeaderInContext;

typedef struct __tagDRM_MANAGER_CONTEXT_INTERNAL
{
    DRM_DWORD cbHeaderData;
    DRM_DWORD cbKID;

    DRM_BOOL fLicStoreOpen;
    DRM_BOOL fSecStoreGlobalContextOpen;
    EHeaderInContext eHeaderInContext;  

    DRM_KID KID;
    DRM_WCHAR wszBBVerString[VER_STRING_MAX_LEN];

    DRM_BB_CONTEXT oBlackBoxContext;
    DRM_BINDING_INFO oBindInfo[DRM_MAX_LICENSE_CHAIN_DEPTH];

    DRM_LICSTORE_CONTEXT oLicStoreContext;
    DRM_LICSTOREENUM_CONTEXT oLicEnum[DRM_MAX_LICENSE_CHAIN_DEPTH];

    DRM_VIEW_RIGHTS_CONTEXT oViewRightsContext;
    DRM_LICEVAL_CONTEXT     oLicEvalContext;    
    DRM_SECSTORE_CONTEXT    oSecStoreGlobalContext;
    
    DRM_DWORD            dwChainDepth;
    DRM_SECSTORE_CONTEXT rgcontextSST   [DRM_MAX_LICENSE_CHAIN_DEPTH];
#if DRM_SUPPORT_CERTIFICATE_CACHING
    DRM_SECSTORE_CONTEXT contextSSTCertCache;
#endif

#if DRM_SUPPORT_LICENSE_SYNC
    DRM_SYNC_CONTEXT contextSync;
#endif

#if DRM_SUPPORT_REVOCATION
    DRM_REVLIST_ID_VALUES        idCRLsCurrent;
#endif
    DRM_BYTE            *pbRevocationBuffer;
    DRM_DWORD            cbRevocationBuffer;

    DRM_FFLICENSE        oFFLicense;
#if DRM_SUPPORT_DLA
    DRM_LICENSE_CHALLENGE licensechallenge;
#endif
    DRM_HDS_CONTEXT oHdsContext;
    DRM_BOOL        fStoreOpened;
    DRM_DWORD       cchDeviceStoreName;
    /* These next 4 buffers can be used independently or together in pieces.  Keep them flush so they
       have maximum raw bytes usuable.  See ProcessResponse */
    DRM_BYTE        rgbDRMHeaderData[__CB_DECL(DRM_MAX_HEADERDATASIZE)];
    DRM_BYTE        rgbDRMLicense   [__CB_DECL(DRM_MAX_LICENSESIZE)];
    DRM_BOOL        fClockSet;
    DRM_BOOL        fBindThenCommit;
    DRM_DWORD       dwSourceid;
} DRM_MANAGER_CONTEXT_INTERNAL;

#define DRM_DRMMANAGER_CONTEXT_BUFFER_SIZE SIZEOF(DRM_MANAGER_CONTEXT_INTERNAL)
#define DRM_BINDCONDITIONS_BUFFER_SIZE     SIZEOF(DRM_BIND_CONDITIONS_INTERNAL)      

#endif /* __DRMCONTEXTSIZES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcrt.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMCRT_H__
#define __DRMCRT_H__

#ifdef __cplusplus
extern "C" {
#endif

/* String CRT functions */

DRM_BOOL  DRM_API DRMCRT_iswspace  (DRM_WCHAR wch);
DRM_BOOL  DRM_API DRMCRT_iswxdigit (DRM_WCHAR wch);
DRM_BOOL  DRM_API DRMCRT_iswdigit  (DRM_WCHAR wch);
DRM_BOOL  DRM_API DRMCRT_iswalpha  (DRM_WCHAR wch);
DRM_WCHAR DRM_API DRMCRT_towlower  (DRM_WCHAR wch);

DRM_INT DRM_API DRMCRT_memcmp(
    IN const DRM_VOID  *src1,
    IN const DRM_VOID  *src2,
    IN       DRM_DWORD  count );

DRM_VOID DRM_API DRMCRT_memset(
       OUT   DRM_VOID  *dst,
    IN       DRM_BYTE   b,
    IN       DRM_DWORD  count );

DRM_VOID DRM_API DRMCRT_memcpy(
       OUT   DRM_VOID  *dst,
    IN const DRM_VOID  *src,
    IN       DRM_DWORD  count );

DRM_VOID * DRM_API DRMCRT_memmove (
    OUT      DRM_VOID  *dst,
    IN const DRM_VOID  *src,
    IN       DRM_DWORD count );

DRM_RESULT DRM_API DRMCRT_wcsntol( 
    IN const DRM_WCHAR *pwszStringInput,
    IN       DRM_DWORD  cchStringInput,
    OUT      DRM_LONG  *plValue );

DRM_INT DRM_API DRMCRT_wcsncmp(
    IN const DRM_WCHAR *first,
    IN const DRM_WCHAR *last,
    IN       DRM_DWORD  count );

DRM_DWORD DRM_API DRMCRT_wcslen(
    IN const DRM_WCHAR *wsz );

DRM_WCHAR* DRM_API DRMCRT_wcsncpy( 
    OUT      DRM_WCHAR *wszDestination,
    IN const DRM_WCHAR *wszSource,
    IN       DRM_DWORD  cchMax );

DRM_INT DRM_API DRMCRT_strncmp (
    IN const DRM_CHAR  *first,
    IN const DRM_CHAR  *last,
    IN       DRM_DWORD  count);

DRM_INT DRM_API DRMCRT_abs( DRM_INT number );

#if NO_DRM_CRT
#include <string.h>
#include <stdlib.h>
#if !defined(__arm) && !defined(__TMS320C55X__)
#include <wchar.h>
#endif
#else
#define iswspace DRMCRT_iswspace
#define iswxdigit DRMCRT_iswxdigit
#define iswdigit DRMCRT_iswdigit
#define iswalpha DRMCRT_iswalpha
#define towlower DRMCRT_towlower
#define wcsncmp DRMCRT_wcsncmp
#define wcslen DRMCRT_wcslen
#define wcsncpy DRMCRT_wcsncpy
#define strncmp DRMCRT_strncmp
#define memmove DRMCRT_memmove
#define memcmp DRMCRT_memcmp
#define memset DRMCRT_memset
#define memcpy DRMCRT_memcpy
#define abs DRMCRT_abs
#endif

#define wcsntol DRMCRT_wcsntol

#if !defined( min )
    #define min( a, b) ( (a)<(b)?(a):(b))
#endif

#if !defined( max )
    #define max( a, b ) ( (a) < (b) ? (b):(a) )
#endif
#ifdef __cplusplus
}
#endif

#endif /* __DRMCRT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmcrt.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmcrt.h>

/* String CRT functions */
DRM_INT DRM_API DRMCRT_wcsncmp(
    IN const DRM_WCHAR *first,
    IN const DRM_WCHAR *last,
    IN       DRM_DWORD  count )
{
    if (!count)
    {
        return(0);
    }

    while (--count && *first && *first == *last)
    {
        first++;
        last++;
    }

    return((DRM_INT)(*first - *last));
}

/* BUGBUG:  Should anyone ever call strncmp?  They should always use DRM_CompareBytes I think.  Remove this function... */
DRM_INT DRM_API DRMCRT_strncmp (
    IN const DRM_CHAR  *first,
    IN const DRM_CHAR  *last,
    IN       DRM_DWORD  count)
{
    if (!count)
    {
        return(0);
    }

    while (--count && *first && *first == *last)
    {
        first++;
        last++;
    }

    return((DRM_INT)(*first - *last));
}


DRM_BOOL DRM_API DRMCRT_iswxdigit (DRM_WCHAR f_wch)
{
    DRM_WCHAR wch = NATIVE_WCHAR( f_wch );
    return ((wch >= NATIVE_WCHAR(g_wch0) && wch <= NATIVE_WCHAR(g_wch9))   /* A digit */ 
        ||  (wch >= NATIVE_WCHAR(g_wchA) && wch <= NATIVE_WCHAR(g_wchF))   /* Upper case hex char */ 
        ||  (wch >= NATIVE_WCHAR(g_wcha) && wch <= NATIVE_WCHAR(g_wchf))); /* lower case hex char */
}

DRM_BOOL DRM_API DRMCRT_iswdigit( DRM_WCHAR wch )
{
    return ( NATIVE_WCHAR(wch) >= NATIVE_WCHAR(g_wch0) 
          && NATIVE_WCHAR(wch) <= NATIVE_WCHAR(g_wch9) ); /* A digit */
}
DRM_BOOL DRM_API DRMCRT_iswalpha (DRM_WCHAR wch)
{
    return ((NATIVE_WCHAR(wch) >= NATIVE_WCHAR(g_wchA) && NATIVE_WCHAR(wch) <= NATIVE_WCHAR(g_wchZ))   /* Upper case char */
         || (NATIVE_WCHAR(wch) >= NATIVE_WCHAR(g_wcha) && NATIVE_WCHAR(wch) <= NATIVE_WCHAR(g_wchz))); /* lower case char */
}

DRM_WCHAR DRM_API DRMCRT_towlower (DRM_WCHAR wch)
{
    if (iswalpha (wch)
    &&   NATIVE_WCHAR(wch) < NATIVE_WCHAR(g_wcha))
    {
        DRM_WCHAR wchTemp = NATIVE_WCHAR(g_wcha) - NATIVE_WCHAR(g_wchA);
        wch = NATIVE_WCHAR(wch) + wchTemp;
        wch = WCHAR_CAST( wch );
    }

    return wch;
}

DRM_RESULT DRM_API DRMCRT_wcsntol( 
    IN const DRM_WCHAR *pwszStringInput,
    IN       DRM_DWORD  cchStringInput,
    OUT      DRM_LONG  *plValue )
{    
    DRM_CONST_STRING wszString;
    DRM_DWORD lMaxVal    = ULONG_MAX / 10;
    DRM_DWORD lNextDigit = 0;
    DRM_DWORD lValue     = 0;
    DRM_BOOL fPositive   = TRUE;

    if( NULL == plValue || 
        NULL == pwszStringInput ||
        0 == cchStringInput )
    {
        return DRM_E_INVALIDARG;
    }

    if( pwszStringInput[0] == g_wchMinus || pwszStringInput[0] == g_wchPlus )
    {
        if( pwszStringInput[0] == g_wchMinus )
        {
            fPositive = FALSE;
        }
        pwszStringInput++;
        cchStringInput--;
    }

    wszString.pwszString = pwszStringInput;
    wszString.cchString = cchStringInput;    
    *plValue = 0;

    while( wszString.cchString > 0 && iswdigit( *( wszString.pwszString ) ) )
    {

        lNextDigit = (NATIVE_WCHAR(*(wszString.pwszString)) - NATIVE_WCHAR(g_wch0));
        if( lValue < lMaxVal || 
            ( lValue == lMaxVal && lNextDigit <= ULONG_MAX % 10 ) )
        {
            lValue = lValue * 10 + lNextDigit;            
        }
        else
        {            
            return DRM_E_ARITHMETIC_OVERFLOW;
        }
        wszString.pwszString++;
        wszString.cchString--;
    }

    if( lValue & 0x80000000 )
    {
        /* The high bit is set.  */
        if( lValue == 0x80000000 && !fPositive )
        {
            /* Special case */
            *plValue = lValue;
        }
        else
        {
            /* This is fine for an unsigned long, but means we really have overflowed to return a signed long */
            return DRM_E_ARITHMETIC_OVERFLOW;
        }       
    }
    else    
    {
        *plValue = lValue;
        if( !fPositive )
        {
           *plValue *= -1;
        }
    }

    return DRM_SUCCESS;
}

DRM_BOOL DRM_API DRMCRT_iswspace (DRM_WCHAR wch)
{
    return (NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchTab)
         || NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchLineFeed)
         || NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchVerticalTab)
         || NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchFormFeed)
         || NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchCarriageReturn)
         || NATIVE_WCHAR(wch) == NATIVE_WCHAR(g_wchSpace));
}

DRM_DWORD DRM_API DRMCRT_wcslen(
    IN const DRM_WCHAR *wsz )
{
    const DRM_WCHAR *eos = wsz;
    while( *eos++ ) ;
    return( (DRM_DWORD)(eos - wsz - 1) );
}

DRM_WCHAR* DRM_API DRMCRT_wcsncpy( 
    OUT      DRM_WCHAR *wszDestination,
    IN const DRM_WCHAR *wszSource,
    IN       DRM_DWORD  cchMax )
{
    DRM_WCHAR *ret = wszDestination;    

    while (cchMax > 0) 
    {
        /* copy string */
        *wszDestination++ = *wszSource++;

        if ( *(wszDestination - 1) == 0)
        {
            break;
        }
        
        cchMax--;
    }

    if (cchMax > 0)
    {
        /* pad out with zeroes */
        while (--cchMax)
        {
            *wszDestination++ = g_wchNull;
        }
    }
    return ret;
}


/***
*memmove - Copy source buffer to destination buffer
*
*Purpose:
*       memmove() copies a source memory buffer to a destination memory buffer.
*       This routine recognize overlapping buffers to avoid propogation.
*       For cases where propogation is not a problem, memcpy() can be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

DRM_VOID * DRM_API DRMCRT_memmove (
    OUT      DRM_VOID  *dst,
    IN const DRM_VOID  *src,
    IN       DRM_DWORD count )
{
        DRM_VOID * ret = dst;

        if (dst <= src || (DRM_CHAR *)dst >= ((DRM_CHAR *)src + count)) {
                /*
                 * Non-Overlapping Buffers
                 * copy from lower addresses to higher addresses
                 */
                while (count--) {
                        *(DRM_CHAR *)dst = *(DRM_CHAR *)src;
                        dst = (DRM_CHAR *)dst + 1;
                        src = (DRM_CHAR *)src + 1;
                }
        }
        else {
                /*
                 * Overlapping Buffers
                 * copy from higher addresses to lower addresses
                 */
                dst = (DRM_CHAR *)dst + count - 1;
                src = (DRM_CHAR *)src + count - 1;

                while (count--) {
                        *(DRM_CHAR *)dst = *(DRM_CHAR *)src;
                        dst = (DRM_CHAR *)dst - 1;
                        src = (DRM_CHAR *)src - 1;
                }
        }

        return(ret);
}

DRM_VOID DRM_API DRMCRT_memcpy(
       OUT   DRM_VOID  *dst,
    IN const DRM_VOID  *src,
    IN       DRM_DWORD  count )
{
    while( count > 0 )
    {
        *(DRM_BYTE*)dst = *(DRM_BYTE*)src;
        dst = (DRM_CHAR *)dst + 1;
        src = (DRM_CHAR *)src + 1;
        count--;
    }
}

DRM_VOID DRM_API DRMCRT_memset(
       OUT   DRM_VOID  *dst,
    IN       DRM_BYTE   b,
    IN       DRM_DWORD  count )
{
    while( count > 0 )
    {
        *(DRM_BYTE*)dst = b;
        dst = (DRM_CHAR *)dst + 1;
        count--;
    }
}

DRM_INT DRM_API DRMCRT_memcmp(
    IN const DRM_VOID  *src1,
    IN const DRM_VOID  *src2,
    IN       DRM_DWORD  count )
{
    while( count > 0 )
    {
        if( *(DRM_BYTE*)src1 > *(DRM_BYTE*)src2 )
        {
            return 1;
        }
        else if( *(DRM_BYTE*)src1 < *(DRM_BYTE*)src2 )
        {
            return -1;
        }
        src1 = (DRM_CHAR *)src1 + 1;
        src2 = (DRM_CHAR *)src2 + 1;
        count--;
    }
    return 0;
}

DRM_INT DRM_API DRMCRT_abs( DRM_INT number )
{
    return (number>=0 ? number : -number);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmconstants.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>
#include <drmlicense.h>

/* Define all constants here.  If we put it in an include file we will have multiple defines when linking */

const PUBKEY g_pubkeyLicenseServer = 
{
    {
         TWO_BYTES(0x52, 0xF5), TWO_BYTES(0x5A, 0x8A), TWO_BYTES(0x8A, 0x7F), TWO_BYTES(0xEA, 0x57), 
         TWO_BYTES(0x55, 0x24), TWO_BYTES(0x93, 0xA9), TWO_BYTES(0x8C, 0x11), TWO_BYTES(0x06, 0x58), 
         TWO_BYTES(0x37, 0xAD), TWO_BYTES(0x9F, 0x66), TWO_BYTES(0x68, 0xC1), TWO_BYTES(0x1C, 0x16), 
         TWO_BYTES(0x2D, 0x4A), TWO_BYTES(0x57, 0xBA), TWO_BYTES(0x7B, 0x6C), TWO_BYTES(0xA4, 0x24), 
         TWO_BYTES(0x14, 0x2B), TWO_BYTES(0x4E, 0x2E), TWO_BYTES(0x89, 0xF1), TWO_BYTES(0x39, 0x4E) 
    }
};

/* Some of these must be kept in sync with what is in license.h */
const DRM_LID g_rgbSecStoreGlobalName =
{
    TWO_BYTES('g', 'l'),  TWO_BYTES('o', 'b'),  TWO_BYTES('a', 'l'),  
    TWO_BYTES('.', 's'),  TWO_BYTES('e', 'c'),  TWO_BYTES('s', 't'),  
    TWO_BYTES('a', 't'),  TWO_BYTES('e', '\0')
};

#if DRM_SUPPORT_REVOCATION
const DRM_LID g_lidRevocationInfo =
{
    TWO_BYTES('R', 'E'),  TWO_BYTES('V', 'O'),  TWO_BYTES('C', 'A'),
    TWO_BYTES('T', 'I'),  TWO_BYTES('O', 'N'),  TWO_BYTES('I', 'N'),
    TWO_BYTES('F', 'O'),  TWO_BYTES('\0', '\0')
};
#if DRM_SUPPORT_DEVICE_REVOCATION
/* DeviceRevocation */
const DRM_LID g_lidDeviceRevocation =
{
    TWO_BYTES('D', 'e'),  TWO_BYTES('v', 'i'),  TWO_BYTES('c', 'e'),
    TWO_BYTES('R', 'e'),  TWO_BYTES('v', 'o'),  TWO_BYTES('c', 'a'),
    TWO_BYTES('t', 'i'),  TWO_BYTES('o', 'n')
};
#endif               

#if DRM_SUPPORT_WMDRMNET
/* WMDRMNET_RVK */
const DRM_LID g_lidWMDRMNET_Revocation =
{
    TWO_BYTES('W', 'M'),   TWO_BYTES('D', 'R'),  TWO_BYTES('M', 'N'),
    TWO_BYTES('E', 'T'),   TWO_BYTES('_', 'R'),  TWO_BYTES('V', 'K'),
    TWO_BYTES('\0', '\0'), TWO_BYTES('\0', '\0')
};
#endif

#if DRM_SUPPORT_APP_REVOCATION
/* RevocationList */
const DRM_LID g_lidAppRevocation =
{
    TWO_BYTES('R', 'e'),  TWO_BYTES('v', 'o'),  TWO_BYTES('c', 'a'),
    TWO_BYTES('t', 'i'),  TWO_BYTES('o', 'n'),  TWO_BYTES('L', 'i'),
    TWO_BYTES('s', 't'),  TWO_BYTES('\0', '\0')
};
#endif /* DRM_SUPPORT_APP_REVOCATION */
#endif

/* DRM Version. Keep this in sync with DRM_VERSION_STRING above. */
const DRM_WCHAR             g_rgwchDRM_VERSION_STRING                  []= { ONE_WCHAR('2', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_CONST_STRING      g_dstrDRM_VERSION_STRING                     = CREATE_DRM_STRING( g_rgwchDRM_VERSION_STRING );

const DRM_BYTE              DRM_VERSION [__CB_DECL(VERSION_LEN)]         =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 

/* Indicates the version of the pubkey to be used for verification of PK CERT. */
const DRM_BYTE              PK_VER [__CB_DECL(VERSION_LEN)]              =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 

/* Version of the key file. */
const DRM_BYTE              KEYFILE_VER [__CB_DECL(VERSION_LEN)]         =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 


const DRM_BYTE              LICREQUEST_VER [__CB_DECL(VERSION_LEN)]    =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
};

/* Indicates the public root key needed to verify the license server certificates. */
const DRM_BYTE              CERT_VER [__CB_DECL(VERSION_LEN)]          =
{
    TWO_BYTES(0, 1), TWO_BYTES(0, 0)
};

/* Indicates the license version delivered. */
const DRM_BYTE              LICENSE_VER [__CB_DECL(VERSION_LEN)]       =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 

/* The version for client id. */
const DRM_BYTE              CLIENT_ID_VER [__CB_DECL(VERSION_LEN)]      =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 

/* Content Version. Keep this in sync with CONTENT_VERSION_STRING above. */
const DRM_BYTE              CONTENT_VERSION [__CB_DECL(VERSION_LEN)]    =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
}; 



/* v1 rights bits */
const DRM_BYTE              RIGHT_PLAY_ON_PC [__CB_DECL(RIGHTS_LEN)]     =
{
    TWO_BYTES(1, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_COPY_TO_NONSDMI_DEVICE [__CB_DECL(RIGHTS_LEN)]    =
{
    TWO_BYTES(2, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_NO_RESTORE [__CB_DECL(RIGHTS_LEN)]                =
{
    TWO_BYTES(4, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_BURN_TO_CD [__CB_DECL(RIGHTS_LEN)]                =
{
    TWO_BYTES(8, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_COPY_TO_SDMI_DEVICE [__CB_DECL(RIGHTS_LEN)]       =
{
    TWO_BYTES(0x10, 0), TWO_BYTES(0, 0)
};
const DRM_BYTE              RIGHT_ONE_TIME [__CB_DECL(RIGHTS_LEN)]                  =
{
    TWO_BYTES(0x20, 0), TWO_BYTES(0, 0)
};

/* Character constants */
const DRM_WCHAR             g_wchPathSeperator                          = WCHAR_CAST('\\');
const DRM_WCHAR             g_wchNull                                   = WCHAR_CAST('\0');
const DRM_WCHAR             g_wchMinus                                  = WCHAR_CAST('-');
const DRM_WCHAR             g_wchPlus                                   = WCHAR_CAST('+');
const DRM_WCHAR             g_wchForwardSlash                           = WCHAR_CAST('/');
const DRM_WCHAR             g_wchColon                                  = WCHAR_CAST(':');
const DRM_WCHAR             g_wchComma                                  = WCHAR_CAST(',');
const DRM_WCHAR             g_wchQuote                                  = WCHAR_CAST('\"');
const DRM_WCHAR             g_wchSingleQuote                            = WCHAR_CAST('\'');
const DRM_WCHAR             g_wchNewLine                                = WCHAR_CAST('\n');
const DRM_WCHAR             g_wchBackSlash                              = WCHAR_CAST('\\');
const DRM_WCHAR             g_wch0                                      = WCHAR_CAST('0');
const DRM_WCHAR             g_wch1                                      = WCHAR_CAST('1');
const DRM_WCHAR             g_wch2                                      = WCHAR_CAST('2');
const DRM_WCHAR             g_wch9                                      = WCHAR_CAST('9');
const DRM_WCHAR             g_wcha                                      = WCHAR_CAST('a');
const DRM_WCHAR             g_wchd                                      = WCHAR_CAST('d');
const DRM_WCHAR             g_wchf                                      = WCHAR_CAST('f');
const DRM_WCHAR             g_wchh                                      = WCHAR_CAST('h');
const DRM_WCHAR             g_wchm                                      = WCHAR_CAST('m');
const DRM_WCHAR             g_wchn                                      = WCHAR_CAST('n');
const DRM_WCHAR             g_wchs                                      = WCHAR_CAST('s');
const DRM_WCHAR             g_wchy                                      = WCHAR_CAST('y');
const DRM_WCHAR             g_wchA                                      = WCHAR_CAST('A');
const DRM_WCHAR             g_wchF                                      = WCHAR_CAST('F');
const DRM_WCHAR             g_wchx                                      = WCHAR_CAST('x');
const DRM_WCHAR             g_wchX                                      = WCHAR_CAST('X');
const DRM_WCHAR             g_wchUnderscore                             = WCHAR_CAST('_');
const DRM_WCHAR             g_wchz                                      = WCHAR_CAST('z');
const DRM_WCHAR             g_wchZ                                      = WCHAR_CAST('Z');
const DRM_WCHAR             g_wchPeriod                                 = WCHAR_CAST('.');
const DRM_WCHAR             g_wchQuestionMark                           = WCHAR_CAST('?');
const DRM_WCHAR             g_wchExclamationMark                        = WCHAR_CAST('!');
const DRM_WCHAR             g_wchOpenParen                              = WCHAR_CAST('(');
const DRM_WCHAR             g_wchCloseParen                             = WCHAR_CAST(')');
const DRM_WCHAR             g_wchPound                                  = WCHAR_CAST('#');
const DRM_WCHAR             g_wchSpace                                  = WCHAR_CAST(' ');
const DRM_WCHAR             g_wchTab                                    = WCHAR_CAST('\x9');
const DRM_WCHAR             g_wchLineFeed                               = WCHAR_CAST('\xA');
const DRM_WCHAR             g_wchVerticalTab                            = WCHAR_CAST('\xB');
const DRM_WCHAR             g_wchFormFeed                               = WCHAR_CAST('\xC');
const DRM_WCHAR             g_wchCarriageReturn                         = WCHAR_CAST('\xD');
const DRM_WCHAR             g_wchEqual                                  = WCHAR_CAST('=');
const DRM_WCHAR             g_wchOpenCurly                              = WCHAR_CAST('{');
const DRM_WCHAR             g_wchCloseCurly                             = WCHAR_CAST('}');
const DRM_WCHAR             g_wchLessThan                               = WCHAR_CAST('<');
const DRM_WCHAR             g_wchGreaterThan                            = WCHAR_CAST('>');
const DRM_WCHAR             g_wchLeftBracket                            = WCHAR_CAST('[');
const DRM_WCHAR             g_wchRightBracket                           = WCHAR_CAST(']');
const DRM_WCHAR             g_wchAsterisk                               = WCHAR_CAST('*');
const DRM_WCHAR             g_wchPercent                                = WCHAR_CAST('%');
const DRM_WCHAR             g_wchSemiColon                              = WCHAR_CAST(';');
const DRM_WCHAR             g_wchAmpersand                              = WCHAR_CAST('&');
const DRM_WCHAR             g_wchPipe                                   = WCHAR_CAST('|');



const DRM_WCHAR      g_rgwchWMDRM_RIGHT_PLAYBACK                  [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_COLLABORATIVE_PLAY        [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_COPY_TO_CD                [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('k', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_COPY                      [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('\0', '\0')};

#if DRM_SUPPORT_PMLICENSE
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_COPY_TO_SDMI_DEVICE       [] =  { ONE_WCHAR('T', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE   [] =  { ONE_WCHAR('T', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('\0', '\0')};
#endif

#if DRM_BACKUP_RESTORE_SUPPORT
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_BACKUP                    [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('k', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('\0', '\0')};
#endif

#if DRM_SUPPORT_PLAYLIST_BURN
const DRM_WCHAR      g_rgwchPlaylistBurnCount                     [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRM_RIGHT_PLAYLIST_BURN             [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
#endif



/* String constants */
const DRM_CHAR       g_rgchAttributeVersion                       [] =  { TWO_BYTES('v', 'e'),  TWO_BYTES('r', 's'),  TWO_BYTES('i', 'o'),  TWO_BYTES('n', '\0'),  TWO_BYTES('\0', '\0')};         /* ODD count */
const DRM_CHAR       g_rgchAttributeEncrypted                     [] =  { TWO_BYTES('e', 'n'),  TWO_BYTES('c', 'r'),  TWO_BYTES('y', 'p'),  TWO_BYTES('t', 'e'),  TWO_BYTES('d', '\0'),  TWO_BYTES('\0', '\0')};       /* ODD count */
const DRM_CHAR       g_rgchLicVerAttrValue                        [] =  { TWO_BYTES('2', '.'),  TWO_BYTES('0', '.'),  TWO_BYTES('0', '.'),  TWO_BYTES('0', '\0'),  TWO_BYTES('\0', '\0')};         /* ODD count */
const DRM_CHAR       g_rgchLicenseTag                             [] =  { TWO_BYTES('L', 'I'),  TWO_BYTES('C', 'E'),  TWO_BYTES('N', 'S'),  TWO_BYTES('E', '\0'),  TWO_BYTES('\0', '\0')};         /* ODD count */
const DRM_CHAR       g_rgchLicenseRespTag                         [] =  { TWO_BYTES('L', 'I'),  TWO_BYTES('C', 'E'),  TWO_BYTES('N', 'S'),  TWO_BYTES('E', 'R'),  TWO_BYTES('E', 'S'),  TWO_BYTES('P', 'O'),  TWO_BYTES('N', 'S'),  TWO_BYTES('E', '\0'),  TWO_BYTES('\0', '\0')}; /* ODD count */
const DRM_CHAR       g_rgchAttributeFALSE                         [] =  { TWO_BYTES('F', 'A'),  TWO_BYTES('L', 'S'),  TWO_BYTES('E', '\0'),  TWO_BYTES('\0', '\0')};           /* ODD count */

const DRM_WCHAR      g_rgwchAttributeVersion                      [] =  { ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAttributeEncrypted                    [] =  { ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicVerAttrValue                       [] =  { ONE_WCHAR('2', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicenseRespTag                        [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicenseTag                            [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAttributeFALSE                        [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};

/* Script varibles used for license properties. */
const DRM_WCHAR      g_rgwchDRM_LS_BEGIN_ATTR                     [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_COUNT_ATTR                     [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchDRM_LS_BEGDATE_ATTR                   [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_ENDDATE_ATTR                   [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_FIRSTUSE_ATTR                  [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_EXPIRATION_AFTER_FIRSTUSE_ATTR [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_MINAPPSECLEVEL_ATTR            [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_APPSEC_ATTR                    [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_BURNTOCDCOUNT_ATTR             [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_TRANSFERCOUNT_ATTR             [] =  { ONE_WCHAR('T', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_PLAYCOUNT_ATTR                 [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_BEGINBURNTOCDCOUNT_ATTR        [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_BEGINTRANSFERCOUNT_ATTR        [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_BEGINPLAYCOUNT_ATTR            [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchDRM_LS_MACHINE_DATETIME_GE            [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('>', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('#', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_MACHINE_DATETIME_LE            [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('<', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('#', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRM_LS_APP_MINSECLEVEL_GE             [] =  { ONE_WCHAR('a', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('>', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchEqual                                 [] =  { ONE_WCHAR('=', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchDrmRestoreInfo                        [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagData                               [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagLID                                [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagIndex                              [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagEnablingbits                       [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSymValue                           [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSymSig                             [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagHashAlgorithm                      [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagPubkey                             [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagValue                              [] =  { ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSignature                          [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagHashAlg                            [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSignAlg                            [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSHA                                   [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMSDRM                                 [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMSDRM_CK                              [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchAttributeType                          [] =  { TWO_BYTES('t', 'y'),   TWO_BYTES('p', 'e'),   TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchAttributeType                         [] =  { ONE_WCHAR('t', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSavedDateTime                         [] =  { ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
const DRM_WCHAR      g_rgwchCheckClockRollback                    [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('>', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchResetRollbackedClock                  [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
#endif

const DRM_WCHAR      g_rgwchSetSavedDateTime                      [] =  { ONE_WCHAR('(', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('>', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(')', '\0'),  ONE_WCHAR('?', '\0'),  ONE_WCHAR('(', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR(')', '\0'),  ONE_WCHAR(':', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR(';', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCreatePMLicense                       [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchVersion_1_0                           [] =  { ONE_WCHAR('1', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagDevinfo                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagFallback                           [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagError                              [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathSigValue                         [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFeatureIndivURL                       [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCompatCert                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCompatSecVersion                      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSubjectId                             [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMaxSecLevel                           [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthSecVer                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthPubKey                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathTagSignature                     [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSignatureVal                       [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathTagCertificateChain              [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthData                              [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthHashAlg                           [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthSignAlg                           [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFallback                              [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};


const DRM_WCHAR      g_rgwchXPathTagSecurityLevel                 [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchXPathTagCertificate                   [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathDataUniqueID                     [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchXPathManufacturer                     [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathMake                             [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathModel                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathDistributor                      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathHardwareMajor                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathHardwareMinor                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathFirmwareMajor                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathFirmwareMinor                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathFeatureTemplate                  [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathClientOldKeys                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathClientEscrowKeys                 [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathClientEscrowKey                  [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathIndivServerEscrowKey             [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathDevicePublicKey                  [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathOldKeysData                      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathIndivSvrPubKey                   [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathSecureClock                      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathIndivType                        [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathSecureStore                      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathMetering                         [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathLicenseChain                     [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};


const DRM_WCHAR      g_rgwchTagDevCert                            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagWrmHeader                          [] =  { ONE_WCHAR('W', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAttributeVersionValue                 [] =  { ONE_WCHAR('2', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagLAINFO                             [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagKID                                [] =  { ONE_WCHAR('K', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagChecksum                           [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathHeaderUplinks                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagUplink                             [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagUplinks                            [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagLicenseRequest                     [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagAction                             [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagV1Challenge                        [] =  { ONE_WCHAR('V', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDefaultV1Data                         [] =  { ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagActionList                         [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSecurityVersion                    [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};

/*
**  Devcert Non-indiv Tags
*/
const DRM_WCHAR      g_rgwchTagDNIUniqueID        [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagMSDRMSignature     [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPrivateKeys           [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCertTypeDevice        [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCerttypeGroup         [] =  { ONE_WCHAR('G', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCerttypeAuth          [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCerttypeAuthRoot      [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};

/*
**  Devcert Non-indiv XPaths
*/






const DRM_WCHAR      g_rgwchXPathPubkeyData         [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCSecureClock      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCSecureClockURL   [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCSecureClockPubKey[] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCMetering         [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCLicenseAcquisitionMode[] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCLicenseSyncMode  [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCSymmOpts         [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCEncryption       [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCMaxChainDepth    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCMaxLicenseSize   [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathGCMaxHeaderSize    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathDeviceKeydata      [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathDACAuthID          [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};



const DRM_WCHAR      g_rgwchReqTagClientInfo                      [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagClientID                        [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagClientVersion                   [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagAppSecurity                     [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagSubjectID1                      [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagSubjectID2                      [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('2', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagDrmkVersion                     [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagClientVersionData               [] =  { ONE_WCHAR('9', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('2', '\0'),  ONE_WCHAR('7', '\0'),  ONE_WCHAR('7', '\0'),  ONE_WCHAR('8', '\0'),  ONE_WCHAR('\0', '\0')}; /* BUGBUG */
const DRM_WCHAR      g_rgwchReqTagSubjectID2Data                  [] =  { ONE_WCHAR(' ', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReqTagDrmkData                        [] =  { ONE_WCHAR(' ', '\0'),  ONE_WCHAR('\0', '\0')};

/* Xml tags used in parsing licenses */
const DRM_WCHAR      g_rgwchLicense                               [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicensorInfoNode                      [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLIData                                [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMeta                                  [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_CHAR       g_rgchTagRevocation                          [] =  { TWO_BYTES('R', 'E'),  TWO_BYTES('V', 'O'),  TWO_BYTES('C', 'A'),  TWO_BYTES('T', 'I'),  TWO_BYTES('O', 'N'),  TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRevocation                         [] =  { ONE_WCHAR('R', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchTagRevocationInfo                      [] =  { TWO_BYTES('R', 'E'),  TWO_BYTES('V', 'O'),  TWO_BYTES('C', 'A'),  TWO_BYTES('T', 'I'),  TWO_BYTES('O', 'N'),  TWO_BYTES('I', 'N'),  TWO_BYTES('F', 'O'),  TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRevocationInfo                     [] =  { ONE_WCHAR('R', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAppRevocation                         [] =  { ONE_WCHAR('R', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('c', '\0'), ONE_WCHAR('a', '\0'), ONE_WCHAR('t', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('n', '\0'), ONE_WCHAR('L', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDeviceRevocation                      [] =  { ONE_WCHAR('D', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('c', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('c', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchDeviceRevocation                       [] =  { TWO_BYTES('D', 'e'),  TWO_BYTES('v', 'i'),  TWO_BYTES('c', 'e'),  TWO_BYTES('R', 'e'),  TWO_BYTES('v', 'o'),  TWO_BYTES('c', 'a'),  TWO_BYTES('t', 'i'),  TWO_BYTES('o', 'n'),  TWO_BYTES('L', 'i'),  TWO_BYTES('s', 't'),  TWO_BYTES('\0', '\0')}; /* ODD count */
const DRM_WCHAR      g_rgwchDeviceRevocationList                  [] =  { ONE_WCHAR('D', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('c', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('o', '\0'), ONE_WCHAR('c', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchWMDRMNET_Revocation                   [] =  { ONE_WCHAR('W', '\0'), ONE_WCHAR('M', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('M', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('T', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchWMDRMNET_Revocation                    [] =  { TWO_BYTES('W', 'M'),  TWO_BYTES('D', 'R'),  TWO_BYTES('M', 'N'),  TWO_BYTES('E', 'T'),  TWO_BYTES('\0', '\0')};
const DRM_CHAR       g_rgchTagSLK                                 [] =  { TWO_BYTES('S', 'L'),  TWO_BYTES('K', '\0'), TWO_BYTES('\0', '\0')};
const DRM_CHAR       g_rgchTagSLKID                               [] =  { TWO_BYTES('S', 'L'),  TWO_BYTES('K', 'I'),  TWO_BYTES('D', '\0'), TWO_BYTES('\0', '\0')};
const DRM_CHAR       g_rgchTagSLKDATA                             [] =  { TWO_BYTES('S', 'L'),  TWO_BYTES('K', 'D'),  TWO_BYTES('A', 'T'),  TWO_BYTES('A', '\0'),  TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRevInfoVersion                     [] =  { ONE_WCHAR('R', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('V', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('S', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('N', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchTagRevInfoVersion                      [] =  { TWO_BYTES('R', 'E'),  TWO_BYTES('V', 'I'),  TWO_BYTES('N', 'F'),  TWO_BYTES('O', 'V'),  TWO_BYTES('E', 'R'),  TWO_BYTES('S', 'I'),  TWO_BYTES('O', 'N'),  TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSourceID                           [] =  { ONE_WCHAR('S', '\0'), ONE_WCHAR('O', '\0'), ONE_WCHAR('U', '\0'), ONE_WCHAR('R', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('I', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchTagSourceID                            [] =  { TWO_BYTES('S', 'O'),  TWO_BYTES('U', 'R'),  TWO_BYTES('C', 'E'),  TWO_BYTES('I', 'D'),  TWO_BYTES('\0', '\0')};


#if DRM_SUPPORT_REVOCATION
    
#if DRM_SUPPORT_WMDRMNET
/* {CD75E604-543D-4A9C-9F09-FE6D24E8BF90} */
const DRM_WCHAR      g_rgwchRevocationGuidWMDRMNET                [] = { ONE_WCHAR('{', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('7', '\0'), ONE_WCHAR('5', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('6', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('5', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('6', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('2', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('8', '\0'), ONE_WCHAR('B', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('}', '\0'), };

/* {CD75E604-543D-4A9C-9F09-FE6D24E8BF90} */
const DRM_CHAR       g_rgchRevocationGuidWMDRMNET                 [] = { TWO_BYTES('{', 'C'), TWO_BYTES('D', '7'), TWO_BYTES('5', 'E'), TWO_BYTES('6', '0'), TWO_BYTES('4', '-'), TWO_BYTES('5', '4'), TWO_BYTES('3', 'D'), TWO_BYTES('-', '4'), TWO_BYTES('A', '9'), TWO_BYTES('C', '-'), TWO_BYTES('9', 'F'), TWO_BYTES('0', '9'), TWO_BYTES('-', 'F'), TWO_BYTES('E', '6'), TWO_BYTES('D', '2'), TWO_BYTES('4', 'E'), TWO_BYTES('8', 'B'), TWO_BYTES('F', '9'), TWO_BYTES('0', '}'), };
#endif /* DRM_SUPPORT_WMDRMNET */

#if DRM_SUPPORT_DEVICE_REVOCATION
/* {3129E375-CEB0-47D5-9CCA-9DB74CFD4332} */
const DRM_WCHAR      g_rgwchRevocationGuidDevice                  [] = { ONE_WCHAR('{', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('2', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('7', '\0'), ONE_WCHAR('5', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('B', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('7', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('5', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('B', '\0'), ONE_WCHAR('7', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('D', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('2', '\0'), ONE_WCHAR('}', '\0'), };

/* {3129E375-CEB0-47D5-9CCA-9DB74CFD4332} */
const DRM_CHAR       g_rgchRevocationGuidDevice                   [] = { TWO_BYTES('{', '3'), TWO_BYTES('1', '2'), TWO_BYTES('9', 'E'), TWO_BYTES('3', '7'), TWO_BYTES('5', '-'), TWO_BYTES('C', 'E'), TWO_BYTES('B', '0'), TWO_BYTES('-', '4'), TWO_BYTES('7', 'D'), TWO_BYTES('5', '-'), TWO_BYTES('9', 'C'), TWO_BYTES('C', 'A'), TWO_BYTES('-', '9'), TWO_BYTES('D', 'B'), TWO_BYTES('7', '4'), TWO_BYTES('C', 'F'), TWO_BYTES('D', '4'), TWO_BYTES('3', '3'), TWO_BYTES('2', '}'), };
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_APP_REVOCATION
/* {90A37313-0ECF-4CAA-A906-B188F6129300} */
const DRM_WCHAR      g_rgwchRevocationGuidApp                     [] = { ONE_WCHAR('{', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('7', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('E', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('4', '\0'), ONE_WCHAR('C', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('A', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('6', '\0'), ONE_WCHAR('-', '\0'), ONE_WCHAR('B', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('8', '\0'), ONE_WCHAR('8', '\0'), ONE_WCHAR('F', '\0'), ONE_WCHAR('6', '\0'), ONE_WCHAR('1', '\0'), ONE_WCHAR('2', '\0'), ONE_WCHAR('9', '\0'), ONE_WCHAR('3', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('0', '\0'), ONE_WCHAR('}', '\0'), };

/* {90A37313-0ECF-4CAA-A906-B188F6129300} */
const DRM_CHAR       g_rgchRevocationGuidApp                      [] = { TWO_BYTES('{', '9'), TWO_BYTES('0', 'A'), TWO_BYTES('3', '7'), TWO_BYTES('3', '1'), TWO_BYTES('3', '-'), TWO_BYTES('0', 'E'), TWO_BYTES('C', 'F'), TWO_BYTES('-', '4'), TWO_BYTES('C', 'A'), TWO_BYTES('A', '-'), TWO_BYTES('A', '9'), TWO_BYTES('0', '6'), TWO_BYTES('-', 'B'), TWO_BYTES('1', '8'), TWO_BYTES('8', 'F'), TWO_BYTES('6', '1'), TWO_BYTES('2', '9'), TWO_BYTES('3', '0'), TWO_BYTES('0', '}'), };
#endif /* DRM_SUPPORT APP_REVOCATION */

#endif /* DRM_SUPPORT_REVOCATION */

const DRM_WCHAR       g_rgwchTagSLK                               [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR       g_rgwchTagSLKID                             [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR       g_rgwchTagSLKDATA                           [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchDeviceRevocationLicenseTag            [] =  { ONE_WCHAR('d', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('v', '\0'), ONE_WCHAR('i', '\0'), ONE_WCHAR('c', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('\0', '\0') };
const DRM_WCHAR      g_rgwchWMDRMNETRevocationLicenseTag          [] =  { ONE_WCHAR('w', '\0'), ONE_WCHAR('m', '\0'), ONE_WCHAR('d', '\0'), ONE_WCHAR('r', '\0'), ONE_WCHAR('m', '\0'), ONE_WCHAR('n', '\0'), ONE_WCHAR('e', '\0'), ONE_WCHAR('t', '\0') };

const DRM_WCHAR      g_rgwchMeteringId                            [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPriority                              [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchIssueDate                             [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchContentPubKey                         [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchContentRevocation                     [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCondition                             [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAction                                [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchRestrictions                          [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchChainedEnablingBits                   [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDrmRestoreInfoEnablingBits            [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCertChain                             [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCertificate                        [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLISigHashAlgo                         [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLISigAlgo                             [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLISigValue                            [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchOnActionPath                          [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathSymSig                           [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathSymValue                         [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchSequenceNumber                        [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLSPubKey                              [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchUplinkKid                             [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchChainedCheckSum                       [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPMLicenseVersionString                [] =  { ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchPMLicenseVersionString                 [] =   { TWO_BYTES('0', '.'),  TWO_BYTES('1', '.'),  TWO_BYTES('0', '.'),  TWO_BYTES('0', '\0'),  TWO_BYTES('\0', '\0')}; /* ODD count */
const DRM_WCHAR      g_rgwchRevAttribute                          [] =  { ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDerivedLicTemplate                    [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicDataDerivedTmpl                    [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};


/* XML tags used in writing Challenge and parsing Response for metering */
const DRM_WCHAR      g_rgwchTagMetering                           [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagHash                               [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchXPathMID                              [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};                      
const DRM_WCHAR      g_rgwchTagMID                                [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};                      
const DRM_WCHAR      g_rgwchTagTID                                [] =  { ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCmd                                [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagPassword                           [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRecords                            [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagURL                                [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagPartialData                        [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLabelValue                            [] =  { ONE_WCHAR('v', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchHMAC                                  [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchChallenge                             [] =  { ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwch1                                     [] =  { ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchReset                                 [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_CHAR       g_rgchTagMeterCert                           [] =  { TWO_BYTES('M', 'E'),  TWO_BYTES('T', 'E'),  TWO_BYTES('R', 'C'),  TWO_BYTES('E', 'R'),  TWO_BYTES('T', '\0'),  TWO_BYTES('\0', '\0')}; /* ODD count */

const DRM_WCHAR      g_rgwchTagMeterCert                          [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagCertificateChain                   [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};

/* tags used for sync lists */
const DRM_WCHAR      g_rgwchTagPrivateKey                         [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagDevice                             [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchKeyDataTag                            [] =  { ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchGroupTag                              [] =  { ONE_WCHAR('G', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('\0', '\0')};

const DRM_WCHAR      g_rgwchTagSyncList                           [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
                                                                                                          
const DRM_WCHAR      g_rgwchBackup                                [] =  { ONE_WCHAR('B', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('k', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchRestore                               [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchRootSigValueVersionTag                [] =  { ONE_WCHAR('p', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchRootSigValueVersionVal                [] =  { ONE_WCHAR('1', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPFRootTag                             [] =  { ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDACPubKeyTag                          [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAuthRoot                              [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagNameValue                          [] =  { ONE_WCHAR('W', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR(' ', '\0'),  ONE_WCHAR('2', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('3', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('0', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagSecurityLevel                      [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagDataId                             [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagDataPubKey                         [] =  { ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFallBack                              [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagName                               [] =  { ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchManufacturer                          [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchModel                                 [] =  { ONE_WCHAR('M', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchHwMajor                               [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchHwMinor                               [] =  { ONE_WCHAR('H', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFwMajor                               [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFwMinor                               [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFeatures                              [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSecClockNotSet                        [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSecClockSet                           [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSecClockNeedsRefresh                  [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTemplate                              [] =  { ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchIndivPubKey                           [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('_', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchUniqueId                              [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchUnsignedtemplate                      [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};

/* This data is used explicitly in the gen tools */
const DRM_WCHAR      g_rgwchTagDataSecVer                         [] =  { ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};

/* Strings for the expression evaluator functions */
const DRM_WCHAR      g_rgwchExprFuncDateAdd                       [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncDateDiff                      [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('f', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncMin                           [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncMax                           [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncDatePart                      [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncVersionCompare                [] =  { ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncDeleteLicense                 [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprFuncExists                        [] =  { ONE_WCHAR('e', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('\0', '\0')};

/* Strings for license evaluator well known actions */
const DRM_WCHAR      g_rgwchLicEvalOnSelect                       [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicEvalOnDelete                       [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicEvalOnStore                        [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLicEvalOnAction                       [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK 
const DRM_WCHAR      g_rgwchLicEvalOnClockRollback                [] =  { ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
#endif

/* Strings for expression evaluator variable evaluation */
const DRM_WCHAR      g_rgwchDRM_PREFIX                            [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDRMK_PREFIX                           [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('k', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMACHINE_PREFIX                        [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchAPP_PREFIX                            [] =  { ONE_WCHAR('a', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSECSTATE_PREFIX                       [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLICENSE_PREFIX                        [] =  { ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCONTENT_PREFIX                        [] =  { ONE_WCHAR('c', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchDEVICE_PREFIX                         [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPMLICENSE_PREFIX                      [] =  { ONE_WCHAR('p', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSECURETIME_PREFIX                     [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchPLAYLISTBURN_PREFIX                   [] =  { ONE_WCHAR('p', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};

#if DRM_SUPPORT_SST_REDUNANCY
const DRM_WCHAR      g_rgwchSSTREDUNDANCY_PREFIX                  [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
#endif

const DRM_WCHAR      g_rgwchExprVarVersion                        [] =  { ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarParameter                      [] =  { ONE_WCHAR('p', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarReason                         [] =  { ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarBBMSDRMVersion                 [] =  { ONE_WCHAR('b', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarDateTime                       [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarCount                          [] =  { ONE_WCHAR('c', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarMinSecLevel                    [] =  { ONE_WCHAR('m', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarSecLevel                       [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarAppSecLevel                    [] =  { ONE_WCHAR('a', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarSubjID                         [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('j', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarAppSubjID                      [] =  { ONE_WCHAR('a', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('j', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarGlobal                         [] =  { ONE_WCHAR('g', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('b', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('.', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarSaveDateTime                   [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarSavedDateTime                  [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarDRMReason                      [] =  { ONE_WCHAR('d', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarRights                         [] =  { ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarExpiryDate                     [] =  { ONE_WCHAR('e', '\0'),  ONE_WCHAR('x', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarInGracePeriod                  [] =  { ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarGpStartTime                    [] =  { ONE_WCHAR('g', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarIncrementCount                 [] =  { ONE_WCHAR('i', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('m', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchExprVarDevReg                         [] =  { ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};

/* XML tags */
const DRM_WCHAR      g_rgwchTagCDATA                              [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCDATAOpenBracket                   [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('[', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_CHAR       g_rgchTagCDATAOpenBracket                    [] =   { TWO_BYTES('C', 'D'),  TWO_BYTES('A', 'T'),  TWO_BYTES('A', '['),  TWO_BYTES('\0', '\0')};
const DRM_WCHAR      g_rgwchOpenTag                               [] =  { ONE_WCHAR('<', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchSpace                                 [] =  { ONE_WCHAR(' ', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchOpenEndTag                            [] =  { ONE_WCHAR('<', '\0'),  ONE_WCHAR('/', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCloseTag                              [] =  { ONE_WCHAR('>', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchEqualQuote                            [] =  { ONE_WCHAR('=', '\0'),  ONE_WCHAR('\"', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchQuote                                 [] =  { ONE_WCHAR('\"', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchOpenCDATATag                          [] =  { ONE_WCHAR('<', '\0'),  ONE_WCHAR('!', '\0'),  ONE_WCHAR('[', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('[', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchCloseCDATATag                         [] =  { ONE_WCHAR(']', '\0'),  ONE_WCHAR(']', '\0'),  ONE_WCHAR('>', '\0'),  ONE_WCHAR('\0', '\0')};


const DRM_CHAR  g_rgchAttributeAlgorithm        [] = { TWO_BYTES('A', 'l'), TWO_BYTES('g', 'o'), TWO_BYTES('r', 'i'), TWO_BYTES('t', 'h'), TWO_BYTES('m', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchAttributeAlgorithm_LEN 9
const DRM_CHAR  g_rgchAttributeVersionWMDRM     [] = { TWO_BYTES('c', ':'), TWO_BYTES('V', 'e'), TWO_BYTES('r', 's'), TWO_BYTES('i', 'o'), TWO_BYTES('n', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchAttributeVersionWMDRM_LEN 9
const DRM_CHAR  g_rgchTagEscrowedKeys           [] = { TWO_BYTES('E', 's'), TWO_BYTES('c', 'r'), TWO_BYTES('o', 'w'), TWO_BYTES('e', 'd'), TWO_BYTES('K', 'e'), TWO_BYTES('y', 's'), TWO_BYTES('\0', '\0') };
#define g_rgchTagEscrowedKeys_LEN 12
const DRM_CHAR  g_rgchKeyUsageSignCert          [] = { TWO_BYTES('c', ':'), TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('C', 'e'), TWO_BYTES('r', 't'), TWO_BYTES('i', 'f'), TWO_BYTES('i', 'c'), TWO_BYTES('a', 't'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchKeyUsageSignCert_LEN 17
const DRM_CHAR  g_rgchKeyUsageSignCRL           [] = { TWO_BYTES('c', ':'), TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('C', 'R'), TWO_BYTES('L', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchKeyUsageSignCRL_LEN 9
const DRM_CHAR  g_rgchKeyUsageEncryptKey        [] = { TWO_BYTES('c', ':'), TWO_BYTES('E', 'n'), TWO_BYTES('c', 'r'), TWO_BYTES('y', 'p'), TWO_BYTES('t', 'K'), TWO_BYTES('e', 'y'), TWO_BYTES('\0', '\0') };
#define g_rgchKeyUsageEncryptKey_LEN 12
const DRM_CHAR  g_rgchOne                       [] = { TWO_BYTES('1', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchOne_LEN 1
const DRM_CHAR  g_rgchPrefixManufacturer        [] = { TWO_BYTES('x', 'm'), TWO_BYTES('l', 'n'), TWO_BYTES('s', ':'), TWO_BYTES('f', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchPrefixManufacturer_LEN 7
const DRM_CHAR  g_rgchTagCanonicalization       [] = { TWO_BYTES('C', 'a'), TWO_BYTES('n', 'o'), TWO_BYTES('n', 'i'), TWO_BYTES('c', 'a'), TWO_BYTES('l', 'i'), TWO_BYTES('z', 'a'), TWO_BYTES('t', 'i'), TWO_BYTES('o', 'n'), TWO_BYTES('M', 'e'), TWO_BYTES('t', 'h'), TWO_BYTES('o', 'd'), TWO_BYTES('\0', '\0') };
#define g_rgchTagCanonicalization_LEN 22
const DRM_CHAR  g_rgchTagCertificateCollection  [] = { TWO_BYTES('c', ':'), TWO_BYTES('C', 'e'), TWO_BYTES('r', 't'), TWO_BYTES('i', 'f'), TWO_BYTES('i', 'c'), TWO_BYTES('a', 't'), TWO_BYTES('e', 'C'), TWO_BYTES('o', 'l'), TWO_BYTES('l', 'e'), TWO_BYTES('c', 't'), TWO_BYTES('i', 'o'), TWO_BYTES('n', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagCertificateCollection_LEN 23
const DRM_CHAR  g_rgchTagDigestMethod           [] = { TWO_BYTES('D', 'i'), TWO_BYTES('g', 'e'), TWO_BYTES('s', 't'), TWO_BYTES('M', 'e'), TWO_BYTES('t', 'h'), TWO_BYTES('o', 'd'), TWO_BYTES('\0', '\0') };
#define g_rgchTagDigestMethod_LEN 12
const DRM_CHAR  g_rgchURIDSigSHA1               [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 'w'), TWO_BYTES('w', 'w'), TWO_BYTES('.', 'w'), TWO_BYTES('3', '.'), TWO_BYTES('o', 'r'), TWO_BYTES('g', '/'), TWO_BYTES('2', '0'), TWO_BYTES('0', '0'), TWO_BYTES('/', '0'), TWO_BYTES('9', '/'), TWO_BYTES('x', 'm'), TWO_BYTES('l', 'd'), TWO_BYTES('s', 'i'), TWO_BYTES('g', '#'), TWO_BYTES('s', 'h'), TWO_BYTES('a', '1'), TWO_BYTES('\0', '\0') };
#define g_rgchURIDSigSHA1_LEN 38
const DRM_CHAR  g_rgchTagDigestValue            [] = { TWO_BYTES('D', 'i'), TWO_BYTES('g', 'e'), TWO_BYTES('s', 't'), TWO_BYTES('V', 'a'), TWO_BYTES('l', 'u'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagDigestValue_LEN 11
const DRM_CHAR  g_rgchTagSignatureValue         [] = { TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('a', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', 'V'), TWO_BYTES('a', 'l'), TWO_BYTES('u', 'e'), TWO_BYTES('\0', '\0') };
#define g_rgchTagSignatureValue_LEN 14
const DRM_CHAR  g_rgchTagKeyInfo                [] = { TWO_BYTES('K', 'e'), TWO_BYTES('y', 'I'), TWO_BYTES('n', 'f'), TWO_BYTES('o', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagKeyInfo_LEN 7
const DRM_CHAR  g_rgchTagSymmetricKey           [] = { TWO_BYTES('S', 'y'), TWO_BYTES('m', 'm'), TWO_BYTES('K', 'e'), TWO_BYTES('y', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagSymmetricKey_LEN 7
const DRM_CHAR  g_rgchTagPublicKey              [] = { TWO_BYTES('P', 'u'), TWO_BYTES('b', 'l'), TWO_BYTES('i', 'c'), TWO_BYTES('K', 'e'), TWO_BYTES('y', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagPublicKey_LEN 9
const DRM_CHAR  g_rgchTagPrivateKey             [] = { TWO_BYTES('P', 'r'), TWO_BYTES('i', 'v'), TWO_BYTES('a', 't'), TWO_BYTES('e', 'K'), TWO_BYTES('e', 'y'), TWO_BYTES('\0', '\0') };
#define g_rgchTagPrivateKey_LEN 10
const DRM_CHAR  g_rgchTagKeyValue               [] = { TWO_BYTES('K', 'e'), TWO_BYTES('y', 'V'), TWO_BYTES('a', 'l'), TWO_BYTES('u', 'e'), TWO_BYTES('\0', '\0') };
#define g_rgchTagKeyValue_LEN 8
const DRM_CHAR  g_rgchTagRSAKeyValue            [] = { TWO_BYTES('R', 'S'), TWO_BYTES('A', 'K'), TWO_BYTES('e', 'y'), TWO_BYTES('V', 'a'), TWO_BYTES('l', 'u'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagRSAKeyValue_LEN 11
const DRM_CHAR  g_rgchTagModulus                [] = { TWO_BYTES('M', 'o'), TWO_BYTES('d', 'u'), TWO_BYTES('l', 'u'), TWO_BYTES('s', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagModulus_LEN 7
const DRM_CHAR  g_rgchTagExponent               [] = { TWO_BYTES('E', 'x'), TWO_BYTES('p', 'o'), TWO_BYTES('n', 'e'), TWO_BYTES('n', 't'), TWO_BYTES('\0', '\0') };
#define g_rgchTagExponent_LEN 8

const DRM_CHAR  g_rgchTagManufacturerName       [] = { TWO_BYTES('c', ':'), TWO_BYTES('M', 'a'), TWO_BYTES('n', 'u'), TWO_BYTES('f', 'a'), TWO_BYTES('c', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', 'r'), TWO_BYTES('N', 'a'), TWO_BYTES('m', 'e'), TWO_BYTES('\0', '\0') };
#define g_rgchTagManufacturerName_LEN 18
const DRM_CHAR  g_rgchTagManufacturerData       [] = { TWO_BYTES('c', ':'), TWO_BYTES('M', 'a'), TWO_BYTES('n', 'u'), TWO_BYTES('f', 'a'), TWO_BYTES('c', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', 'r'), TWO_BYTES('D', 'a'), TWO_BYTES('t', 'a'), TWO_BYTES('\0', '\0') }; 
#define g_rgchTagManufacturerData_LEN 18
const DRM_CHAR  g_rgchTagModelName              [] = { TWO_BYTES('c', ':'), TWO_BYTES('M', 'o'), TWO_BYTES('d', 'e'), TWO_BYTES('l', 'N'), TWO_BYTES('a', 'm'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagModelName_LEN 11
const DRM_CHAR  g_rgchTagModelNumber            [] = { TWO_BYTES('c', ':'), TWO_BYTES('M', 'o'), TWO_BYTES('d', 'e'), TWO_BYTES('l', 'N'), TWO_BYTES('u', 'm'), TWO_BYTES('b', 'e'), TWO_BYTES('r', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagModelNumber_LEN 13
const DRM_CHAR  g_rgchTagHardwareID               [] = { TWO_BYTES('c', ':'), TWO_BYTES('H', 'a'), TWO_BYTES('r', 'd'), TWO_BYTES('w', 'a'), TWO_BYTES('r', 'e'), TWO_BYTES('I', 'D'), TWO_BYTES('\0', '\0') };
#define g_rgchTagHardwareID_LEN 12
const DRM_CHAR  g_rgchURIRSASHA1                [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 'w'), TWO_BYTES('w', 'w'), TWO_BYTES('.', 'w'), TWO_BYTES('3', '.'), TWO_BYTES('o', 'r'), TWO_BYTES('g', '/'), TWO_BYTES('2', '0'), TWO_BYTES('0', '0'), TWO_BYTES('/', '0'), TWO_BYTES('9', '/'), TWO_BYTES('x', 'm'), TWO_BYTES('l', 'd'), TWO_BYTES('s', 'i'), TWO_BYTES('g', '#'), TWO_BYTES('r', 's'), TWO_BYTES('a', '-'), TWO_BYTES('s', 'h'), TWO_BYTES('a', '1'), TWO_BYTES('\0', '\0') };
#define g_rgchURIRSASHA1_LEN 42
const DRM_CHAR  g_rgchURIRSASHA1_Old            [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 's'), TWO_BYTES('c', 'h'), TWO_BYTES('e', 'm'), TWO_BYTES('a', 's'), TWO_BYTES('.', 'm'), TWO_BYTES('i', 'c'), TWO_BYTES('r', 'o'), TWO_BYTES('s', 'o'), TWO_BYTES('f', 't'), TWO_BYTES('.', 'c'), TWO_BYTES('o', 'm'), TWO_BYTES('/', 'D'), TWO_BYTES('R', 'M'), TWO_BYTES('/', '2'), TWO_BYTES('0', '0'), TWO_BYTES('4', '/'), TWO_BYTES('0', '2'), TWO_BYTES('/', 'C'), TWO_BYTES('E', 'R'), TWO_BYTES('T', '/'), TWO_BYTES('R', 's'), TWO_BYTES('a', '-'), TWO_BYTES('s', 'h'), TWO_BYTES('a', '1'), TWO_BYTES('\0', '\0') };
#define g_rgchURIRSASHA1_Old_LEN 54
const DRM_CHAR  g_rgchTagReference              [] = { TWO_BYTES('R', 'e'), TWO_BYTES('f', 'e'), TWO_BYTES('r', 'e'), TWO_BYTES('n', 'c'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagReference_LEN 9
const DRM_CHAR  g_rgchTagTransforms             [] = { TWO_BYTES('T', 'r'), TWO_BYTES('a', 'n'), TWO_BYTES('s', 'f'), TWO_BYTES('o', 'r'), TWO_BYTES('m', 's'), TWO_BYTES('\0', '\0') };
#define g_rgchTagTransforms_LEN 10
const DRM_CHAR  g_rgchTagTransform              [] = { TWO_BYTES('T', 'r'), TWO_BYTES('a', 'n'), TWO_BYTES('s', 'f'), TWO_BYTES('o', 'r'), TWO_BYTES('m', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagTransform_LEN 9
const DRM_CHAR  g_rgchURITransformMSCert        [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 'w'), TWO_BYTES('w', 'w'), TWO_BYTES('.', 'm'), TWO_BYTES('i', 'c'), TWO_BYTES('r', 'o'), TWO_BYTES('s', 'o'), TWO_BYTES('f', 't'), TWO_BYTES('.', 'c'), TWO_BYTES('o', 'm'), TWO_BYTES('/', 'D'), TWO_BYTES('R', 'M'), TWO_BYTES('/', 'C'), TWO_BYTES('E', 'R'), TWO_BYTES('T', '/'), TWO_BYTES('v', '2'), TWO_BYTES('/', 'D'), TWO_BYTES('a', 't'), TWO_BYTES('a', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchURITransformMSCert_LEN 41
const DRM_CHAR  g_rgchURITransformMSCertColl    [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 's'), TWO_BYTES('c', 'h'), TWO_BYTES('e', 'm'), TWO_BYTES('a', 's'), TWO_BYTES('.', 'm'), TWO_BYTES('i', 'c'), TWO_BYTES('r', 'o'), TWO_BYTES('s', 'o'), TWO_BYTES('f', 't'), TWO_BYTES('.', 'c'), TWO_BYTES('o', 'm'), TWO_BYTES('/', 'D'), TWO_BYTES('R', 'M'), TWO_BYTES('/', '2'), TWO_BYTES('0', '0'), TWO_BYTES('4', '/'), TWO_BYTES('0', '2'), TWO_BYTES('/', 'c'), TWO_BYTES('e', 'r'), TWO_BYTES('t', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchURITransformMSCertColl_LEN 45
const DRM_CHAR  g_rgchURITransformMSCert_Old    [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 's'), TWO_BYTES('c', 'h'), TWO_BYTES('e', 'm'), TWO_BYTES('a', 's'), TWO_BYTES('.', 'm'), TWO_BYTES('i', 'c'), TWO_BYTES('r', 'o'), TWO_BYTES('s', 'o'), TWO_BYTES('f', 't'), TWO_BYTES('.', 'c'), TWO_BYTES('o', 'm'), TWO_BYTES('/', 'D'), TWO_BYTES('R', 'M'), TWO_BYTES('/', '2'), TWO_BYTES('0', '0'), TWO_BYTES('4', '/'), TWO_BYTES('0', '2'), TWO_BYTES('/', 'C'), TWO_BYTES('E', 'R'), TWO_BYTES('T', '/'), TWO_BYTES('D', 'a'), TWO_BYTES('t', 'a'), TWO_BYTES('\0', '\0') };
#define g_rgchURITransformMSCert_Old_LEN 50
const DRM_CHAR  g_rgchURITransformC14N          [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 'w'), TWO_BYTES('w', 'w'), TWO_BYTES('.', 'w'), TWO_BYTES('3', '.'), TWO_BYTES('o', 'r'), TWO_BYTES('g', '/'), TWO_BYTES('T', 'R'), TWO_BYTES('/', '2'), TWO_BYTES('0', '0'), TWO_BYTES('1', '/'), TWO_BYTES('R', 'E'), TWO_BYTES('C', '-'), TWO_BYTES('x', 'm'), TWO_BYTES('l', '-'), TWO_BYTES('c', '1'), TWO_BYTES('4', 'n'), TWO_BYTES('-', '2'), TWO_BYTES('0', '0'), TWO_BYTES('1', '0'), TWO_BYTES('3', '1'), TWO_BYTES('5', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchURITransformC14N_LEN 47
const DRM_CHAR  g_rgchTagWMDRMCertificate       [] = { TWO_BYTES('c', ':'), TWO_BYTES('C', 'e'), TWO_BYTES('r', 't'), TWO_BYTES('i', 'f'), TWO_BYTES('i', 'c'), TWO_BYTES('a', 't'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertificate_LEN 13
const DRM_CHAR  g_rgchTagWMDRMCertSecurityVersion[]= { TWO_BYTES('c', ':'), TWO_BYTES('S', 'e'), TWO_BYTES('c', 'u'), TWO_BYTES('r', 'i'), TWO_BYTES('t', 'y'), TWO_BYTES('V', 'e'), TWO_BYTES('r', 's'), TWO_BYTES('i', 'o'), TWO_BYTES('n', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertSecurityVersion_LEN 17
const DRM_CHAR  g_rgchTagWMDRMCertSecurityLevel [] = { TWO_BYTES('c', ':'), TWO_BYTES('S', 'e'), TWO_BYTES('c', 'u'), TWO_BYTES('r', 'i'), TWO_BYTES('t', 'y'), TWO_BYTES('L', 'e'), TWO_BYTES('v', 'e'), TWO_BYTES('l', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertSecurityLevel_LEN 15
const DRM_CHAR  g_rgchTagWMDRMCertSerialNumber  [] = { TWO_BYTES('c', ':'), TWO_BYTES('S', 'e'), TWO_BYTES('r', 'i'), TWO_BYTES('a', 'l'), TWO_BYTES('N', 'u'), TWO_BYTES('m', 'b'), TWO_BYTES('e', 'r'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertSerialNumber_LEN 14
const DRM_CHAR  g_rgchTagWMDRMCertFeatures      [] = { TWO_BYTES('c', ':'), TWO_BYTES('F', 'e'), TWO_BYTES('a', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', 's'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertFeatures_LEN 10
const DRM_CHAR  g_rgchTagWMDRMCertKeyUsage      [] = { TWO_BYTES('c', ':'), TWO_BYTES('K', 'e'), TWO_BYTES('y', 'U'), TWO_BYTES('s', 'a'), TWO_BYTES('g', 'e'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertKeyUsage_LEN 10
const DRM_CHAR  g_rgchTagWMDRMCertPublicKey     [] = { TWO_BYTES('c', ':'), TWO_BYTES('P', 'u'), TWO_BYTES('b', 'l'), TWO_BYTES('i', 'c'), TWO_BYTES('K', 'e'), TWO_BYTES('y', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagWMDRMCertPublicKey_LEN 11
const DRM_CHAR  g_rgchTagDataWMDRM              [] = { TWO_BYTES('c', ':'), TWO_BYTES('D', 'a'), TWO_BYTES('t', 'a'), TWO_BYTES('\0', '\0') };
#define g_rgchTagDataWMDRM_LEN 6
const DRM_CHAR  g_rgchTagSignature              [] = { TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('a', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagSignature_LEN 9
const DRM_CHAR  g_rgchTagSignatureMethod        [] = { TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('a', 't'), TWO_BYTES('u', 'r'), TWO_BYTES('e', 'M'), TWO_BYTES('e', 't'), TWO_BYTES('h', 'o'), TWO_BYTES('d', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchTagSignatureMethod_LEN 15
const DRM_CHAR  g_rgchTagSignedInfo             [] = { TWO_BYTES('S', 'i'), TWO_BYTES('g', 'n'), TWO_BYTES('e', 'd'), TWO_BYTES('I', 'n'), TWO_BYTES('f', 'o'), TWO_BYTES('\0', '\0') };
#define g_rgchTagSignedInfo_LEN 10
const DRM_CHAR  g_rgchURIC14N                   [] = { TWO_BYTES('h', 't'), TWO_BYTES('t', 'p'), TWO_BYTES(':', '/'), TWO_BYTES('/', 'w'), TWO_BYTES('w', 'w'), TWO_BYTES('.', 'w'), TWO_BYTES('3', '.'), TWO_BYTES('o', 'r'), TWO_BYTES('g', '/'), TWO_BYTES('T', 'R'), TWO_BYTES('/', '2'), TWO_BYTES('0', '0'), TWO_BYTES('1', '/'), TWO_BYTES('R', 'E'), TWO_BYTES('C', '-'), TWO_BYTES('x', 'm'), TWO_BYTES('l', '-'), TWO_BYTES('c', '1'), TWO_BYTES('4', 'n'), TWO_BYTES('-', '2'), TWO_BYTES('0', '0'), TWO_BYTES('1', '0'), TWO_BYTES('3', '1'), TWO_BYTES('5', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchURIC14N_LEN 47
const DRM_CHAR  g_rgchVersionWMDRM              [] = { TWO_BYTES('2', '.'), TWO_BYTES('0', '\0'), TWO_BYTES('\0', '\0') };
#define g_rgchVersionWMDRM_LEN 3
const DRM_CHAR  g_rgchWMDRMCertExponent         [] = { TWO_BYTES('A', 'Q'), TWO_BYTES('A', 'B'), TWO_BYTES('\0', '\0') };
#define g_rgchWMDRMCertExponent_LEN 4


const DRM_CHAR  g_rgchFeatureSampleProtection   [] = { TWO_BYTES('m', ':'), TWO_BYTES('W', 'M'), TWO_BYTES('D', 'R'), TWO_BYTES('M', 'S'), TWO_BYTES('a', 'm'), TWO_BYTES('p', 'l'), TWO_BYTES('e', 'P'), TWO_BYTES('r', 'o'), TWO_BYTES('t', 'e'), TWO_BYTES('c', 't'), TWO_BYTES('i', 'o'), TWO_BYTES('n', '\0') };
#define g_rgchFeatureSampleProtection_LEN 23
const DRM_CHAR  g_rgchFeatureExport                 [] = { TWO_BYTES('m', ':'), TWO_BYTES('W', 'M'), TWO_BYTES('D', 'R'), TWO_BYTES('M', 'E'), TWO_BYTES('x', 'p'), TWO_BYTES('o', 'r'), TWO_BYTES('t', '\0') };
#define g_rgchFeatureExport_LEN 13
const DRM_CHAR  g_rgchFeatureExportIncl             [] = { TWO_BYTES('m', ':'), TWO_BYTES('W', 'M'), TWO_BYTES('D', 'R'), TWO_BYTES('M', 'E'), TWO_BYTES('x', 'p'), TWO_BYTES('o', 'r'), TWO_BYTES('t', 'I'), TWO_BYTES('n', 'c'), TWO_BYTES('l', '\0') };
#define g_rgchFeatureExportIncl_LEN 17

const DRM_CHAR  g_rgchPrefixMicrosoftCert              [] = { TWO_BYTES('x', 'm'), TWO_BYTES('l', 'n'), TWO_BYTES('s', ':'), TWO_BYTES('c', '\0') };
#define g_rgchPrefixMicrosoftCert_LEN 7

const DRM_CHAR  g_rgchMSRootPubKey              [] =  { TWO_BYTES('p', 'j'), TWO_BYTES('o', 'e'), TWO_BYTES('W', 'L'), TWO_BYTES('S', 'T'), TWO_BYTES('L', 'D'), TWO_BYTES('o', 'n'), TWO_BYTES('Q', 'G'), TWO_BYTES('8', 'S'), TWO_BYTES('h', 'e'), TWO_BYTES('6', 'Q'), TWO_BYTES('h', 'k'), TWO_BYTES('Y', 'b'), TWO_BYTES('Y', 'o'), TWO_BYTES('t', 't'), TWO_BYTES('9', 'f'), TWO_BYTES('P', 'Z'), TWO_BYTES('8', 't'), TWO_BYTES('H', 'd'), TWO_BYTES('B', '1'), TWO_BYTES('2', '8'), TWO_BYTES('Z', 'E'), TWO_BYTES('T', 'c'), TWO_BYTES('g', 'h'), TWO_BYTES('n', '5'), TWO_BYTES('K', 'H'), TWO_BYTES('o', 'y'), TWO_BYTES('i', 'n'), TWO_BYTES('7', 'H'), TWO_BYTES('k', 'J'), TWO_BYTES('E', 'c'), TWO_BYTES('P', 'J'), TWO_BYTES('0', 'E'), TWO_BYTES('g', '4'), TWO_BYTES('U', 'd'), TWO_BYTES('S', 'v'), TWO_BYTES('a', '0'), TWO_BYTES('K', 'D'), TWO_BYTES('I', 'Y'), TWO_BYTES('D', 'j'), TWO_BYTES('A', '3'), TWO_BYTES('E', 'X'), TWO_BYTES('d', '6'), TWO_BYTES('9', 'R'), TWO_BYTES('3', 'C'), TWO_BYTES('N', '2'), TWO_BYTES('W', 'p'), TWO_BYTES('/', 'Q'), TWO_BYTES('y', 'O'), TWO_BYTES('o', '0'), TWO_BYTES('Z', 'P'), TWO_BYTES('Y', 'W'), TWO_BYTES('Y', 'p'), TWO_BYTES('3', 'N'), TWO_BYTES('X', 'p'), TWO_BYTES('J', '7'), TWO_BYTES('0', '0'), TWO_BYTES('t', 'K'), TWO_BYTES('P', 'g'), TWO_BYTES('I', 'p'), TWO_BYTES('l', 'z'), TWO_BYTES('o', '5'), TWO_BYTES('w', 'V'), TWO_BYTES('d', '/'), TWO_BYTES('6', '9'), TWO_BYTES('g', '7'), TWO_BYTES('j', '+'), TWO_BYTES('j', '8'), TWO_BYTES('M', '6'), TWO_BYTES('6', 'W'), TWO_BYTES('7', 'V'), TWO_BYTES('N', 'm'), TWO_BYTES('D', 'w'), TWO_BYTES('a', 'N'), TWO_BYTES('s', '9'), TWO_BYTES('m', 'D'), TWO_BYTES('c', '1'), TWO_BYTES('p', '2'), TWO_BYTES('+', 'V'), TWO_BYTES('V', 'M'), TWO_BYTES('s', 'D'), TWO_BYTES('h', 'O'), TWO_BYTES('s', 'V'), TWO_BYTES('/', 'A'), TWO_BYTES('u', '6'), TWO_BYTES('E', '+'), TWO_BYTES('E', '='), TWO_BYTES('\0', '\0') };
#define g_rgchMSRootPubKey_LEN 172


/* Secure clock Challenge\response XML tags */
const DRM_WCHAR      g_rgwchTagDRMReqRoot                         [] =  { ONE_WCHAR('D', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchResponse                              [] =  { ONE_WCHAR('r', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('p', '\0'),  ONE_WCHAR('o', '\0'),  ONE_WCHAR('n', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchStatus                                [] =  { ONE_WCHAR('s', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('a', '\0'),  ONE_WCHAR('t', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchFlag                                  [] =  { ONE_WCHAR('F', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagGmtTime                            [] =  { ONE_WCHAR('G', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRefreshDate                        [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('F', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};

/* Output Level strings */
const DRM_WCHAR      g_rgwchLabelGuid                             [] =  { ONE_WCHAR('g', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('d', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchLabelLevel                            [] =  { ONE_WCHAR('l', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('e', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagUncompressedDigitalVideo           [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCompressedDigitalVideo             [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagUncompressedDigitalAudio           [] =  { ONE_WCHAR('U', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCompressedDigitalAudio             [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('M', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagAnalogVideo                        [] =  { ONE_WCHAR('A', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCopy                               [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagExtensionList                      [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagExtension                          [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagIncludeList                        [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagInclude                            [] =  { ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagExcludeList                        [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagExclude                            [] =  { ONE_WCHAR('E', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('L', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchMSRootPubKey                          [] =  { ONE_WCHAR('0', '\0'),  ONE_WCHAR('X', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('s', '\0'),  ONE_WCHAR('V', '\0'),  ONE_WCHAR('w', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('H', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('R', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('w', '\0'),  ONE_WCHAR('3', '\0'),  ONE_WCHAR('w', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('1', '\0'),  ONE_WCHAR('v', '\0'),  ONE_WCHAR('q', '\0'),  ONE_WCHAR('j', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('4', '\0'),  ONE_WCHAR('6', '\0'),  ONE_WCHAR('Q', '\0'),  ONE_WCHAR('k', '\0'),  ONE_WCHAR('W', '\0'),  ONE_WCHAR('q', '\0'),  ONE_WCHAR('5', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('g', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('r', '\0'),  ONE_WCHAR('u', '\0'),  ONE_WCHAR('q', '\0'),  ONE_WCHAR('w', '\0'),  ONE_WCHAR('*', '\0'),  ONE_WCHAR('J', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('Z', '\0'),  ONE_WCHAR('l', '\0'),  ONE_WCHAR('c', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('!', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('i', '\0'),  ONE_WCHAR('y', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('3', '\0'),  ONE_WCHAR('6', '\0'),  ONE_WCHAR('h', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('w', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR('=', '\0'),  ONE_WCHAR('\0', '\0')};

/* License State strings */
const DRM_WCHAR      g_rgwchTagLicenseStateRequestRoot            [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('C', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('T', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagCanBind                            [] =  { ONE_WCHAR('C', '\0'),  ONE_WCHAR('A', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('I', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('D', '\0'),  ONE_WCHAR('\0', '\0')};

/*Device License Revocation Blob Strings*/

const DRM_WCHAR      g_rgwchTagDeviceLicenseRevocationRoot        [] =  { ONE_WCHAR('R', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('O', '\0'),  ONE_WCHAR('N', '\0'),  ONE_WCHAR('S', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('\0', '\0')};
const DRM_WCHAR      g_rgwchTagRevocationPubKey                   [] =  { ONE_WCHAR('L', '\0'),  ONE_WCHAR('G', '\0'),  ONE_WCHAR('P', '\0'),  ONE_WCHAR('U', '\0'),  ONE_WCHAR('B', '\0'),  ONE_WCHAR('K', '\0'),  ONE_WCHAR('E', '\0'),  ONE_WCHAR('Y', '\0'),  ONE_WCHAR('\0', '\0')};

/* Strings to be used from DRMManager */
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_PLAYBACK                   = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_PLAYBACK );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COLLABORATIVE_PLAY         = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_COLLABORATIVE_PLAY );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_CD                 = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_COPY_TO_CD );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY                       = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_COPY );

#if DRM_SUPPORT_PMLICENSE
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_SDMI_DEVICE        = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_COPY_TO_SDMI_DEVICE );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE    = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_COPY_TO_NON_SDMI_DEVICE );
#endif

#if DRM_BACKUP_RESTORE_SUPPORT
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_BACKUP                     = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_BACKUP );
#endif

#if DRM_SUPPORT_PLAYLIST_BURN
const DRM_CONST_STRING      g_dstrPlaylistBurnCount                     = CREATE_DRM_STRING( g_rgwchPlaylistBurnCount );
const DRM_CONST_STRING      g_dstrWMDRM_RIGHT_PLAYLIST_BURN             = CREATE_DRM_STRING( g_rgwchWMDRM_RIGHT_PLAYLIST_BURN );
#endif


/* String constants */
const DRM_ANSI_CONST_STRING g_adstrAttributeVersion                     = { g_rgchAttributeVersion,   7 }; /* Special case these odd length ANSI strings */
const DRM_ANSI_CONST_STRING g_dastrTagLicense                           = { g_rgchLicenseTag,         7 };
const DRM_ANSI_CONST_STRING g_adstrLicenseRespTag                       = { g_rgchLicenseRespTag,    15 };
const DRM_ANSI_CONST_STRING g_adstrAttributeEncrypted                   = { g_rgchAttributeEncrypted, 9 };
const DRM_ANSI_CONST_STRING g_dastrAttributeFALSE                       = { g_rgchAttributeFALSE,     5 };

const DRM_ANSI_CONST_STRING g_dastrTagSLK                               = { g_rgchTagSLK,     3 };
const DRM_ANSI_CONST_STRING g_dastrTagSLKID                             = { g_rgchTagSLKID,   5 };
const DRM_ANSI_CONST_STRING g_dastrTagSLKDATA                           = { g_rgchTagSLKDATA, 7 };

const DRM_CONST_STRING      g_dstrTagSLK                                = CREATE_DRM_STRING( g_rgwchTagSLK    );
const DRM_CONST_STRING      g_dstrTagSLKID                              = CREATE_DRM_STRING( g_rgwchTagSLKID  );
const DRM_CONST_STRING      g_dstrTagSLKDATA                            = CREATE_DRM_STRING( g_rgwchTagSLKDATA);

const DRM_CONST_STRING      g_dstrAttributeVersion                      = CREATE_DRM_STRING( g_rgwchAttributeVersion );
const DRM_CONST_STRING      g_dstrAttributeEncrypted                    = CREATE_DRM_STRING( g_rgwchAttributeEncrypted );
const DRM_CONST_STRING      g_dstrAttributeFALSE                        = CREATE_DRM_STRING( g_rgwchAttributeFALSE );
const DRM_CONST_STRING      g_dstrLicVerAttrValue                       = CREATE_DRM_STRING( g_rgwchLicVerAttrValue );
const DRM_CONST_STRING      g_dstrLicenseRespTag                        = CREATE_DRM_STRING( g_rgwchLicenseRespTag );
const DRM_CONST_STRING      g_dstrTagLicense                            = CREATE_DRM_STRING( g_rgwchLicenseTag );

/* Script varibles used for license properties. */
const DRM_CONST_STRING      g_dstrDRM_LS_BEGIN_ATTR                     = CREATE_DRM_STRING( g_rgwchDRM_LS_BEGIN_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_COUNT_ATTR                     = CREATE_DRM_STRING( g_rgwchDRM_LS_COUNT_ATTR );

const DRM_CONST_STRING      g_dstrDRM_LS_BEGDATE_ATTR                   = CREATE_DRM_STRING( g_rgwchDRM_LS_BEGDATE_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_ENDDATE_ATTR                   = CREATE_DRM_STRING( g_rgwchDRM_LS_ENDDATE_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_FIRSTUSE_ATTR                  = CREATE_DRM_STRING( g_rgwchDRM_LS_FIRSTUSE_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_EXPIRATION_AFTER_FIRSTUSE_ATTR = CREATE_DRM_STRING( g_rgwchDRM_LS_EXPIRATION_AFTER_FIRSTUSE_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_MINAPPSECLEVEL_ATTR            = CREATE_DRM_STRING( g_rgwchDRM_LS_MINAPPSECLEVEL_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_APPSEC_ATTR                    = CREATE_DRM_STRING( g_rgwchDRM_LS_APPSEC_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_BURNTOCDCOUNT_ATTR             = CREATE_DRM_STRING( g_rgwchDRM_LS_BURNTOCDCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_TRANSFERCOUNT_ATTR             = CREATE_DRM_STRING( g_rgwchDRM_LS_TRANSFERCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_PLAYCOUNT_ATTR                 = CREATE_DRM_STRING( g_rgwchDRM_LS_PLAYCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_BEGINBURNTOCDCOUNT_ATTR        = CREATE_DRM_STRING( g_rgwchDRM_LS_BEGINBURNTOCDCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_BEGINTRANSFERCOUNT_ATTR        = CREATE_DRM_STRING( g_rgwchDRM_LS_BEGINTRANSFERCOUNT_ATTR );
const DRM_CONST_STRING      g_dstrDRM_LS_BEGINPLAYCOUNT_ATTR            = CREATE_DRM_STRING( g_rgwchDRM_LS_BEGINPLAYCOUNT_ATTR );

const DRM_CONST_STRING      g_dstrDRM_LS_MACHINE_DATETIME_GE            = CREATE_DRM_STRING( g_rgwchDRM_LS_MACHINE_DATETIME_GE );
const DRM_CONST_STRING      g_dstrDRM_LS_MACHINE_DATETIME_LE            = CREATE_DRM_STRING( g_rgwchDRM_LS_MACHINE_DATETIME_LE );
const DRM_CONST_STRING      g_dstrDRM_LS_APP_MINSECLEVEL_GE             = CREATE_DRM_STRING( g_rgwchDRM_LS_APP_MINSECLEVEL_GE );
const DRM_CONST_STRING      g_dstrEqual                                 = CREATE_DRM_STRING( g_rgwchEqual );

const DRM_CONST_STRING      g_dstrDrmRestoreInfo                        = CREATE_DRM_STRING( g_rgwchDrmRestoreInfo );
const DRM_CONST_STRING      g_dstrTagData                               = CREATE_DRM_STRING( g_rgwchTagData );
const DRM_CONST_STRING      g_dstrTagLID                                = CREATE_DRM_STRING( g_rgwchTagLID );

const DRM_CONST_STRING      g_dstrTagIndex                              = CREATE_DRM_STRING( g_rgwchTagIndex );
const DRM_CONST_STRING      g_dstrTagEnablingbits                       = CREATE_DRM_STRING( g_rgwchTagEnablingbits );
const DRM_CONST_STRING      g_dstrTagSymValue                           = CREATE_DRM_STRING( g_rgwchTagSymValue );
const DRM_CONST_STRING      g_dstrTagSymSig                             = CREATE_DRM_STRING( g_rgwchTagSymSig );
const DRM_CONST_STRING      g_dstrTagHashAlgorithm                      = CREATE_DRM_STRING( g_rgwchTagHashAlgorithm );
const DRM_CONST_STRING      g_dstrTagPubkey                             = CREATE_DRM_STRING( g_rgwchTagPubkey );
const DRM_CONST_STRING      g_dstrTagValue                              = CREATE_DRM_STRING( g_rgwchTagValue );
const DRM_CONST_STRING      g_dstrTagSignature                          = CREATE_DRM_STRING( g_rgwchTagSignature );
const DRM_CONST_STRING      g_dstrTagHashAlg                            = CREATE_DRM_STRING( g_rgwchTagHashAlg );
const DRM_CONST_STRING      g_dstrTagSignAlg                            = CREATE_DRM_STRING( g_rgwchTagSignAlg );
const DRM_CONST_STRING      g_dstrSHA                                   = CREATE_DRM_STRING( g_rgwchSHA );
const DRM_CONST_STRING      g_dstrMSDRM                                 = CREATE_DRM_STRING( g_rgwchMSDRM );
const DRM_CONST_STRING      g_dstrMSDRM_CK                              = CREATE_DRM_STRING( g_rgwchMSDRM_CK );
const DRM_ANSI_CONST_STRING g_dastrAttributeType                        = { g_rgchAttributeType, 4 };
const DRM_CONST_STRING      g_dstrAttributeType                         = CREATE_DRM_STRING( g_rgwchAttributeType );
const DRM_CONST_STRING      g_dstrSavedDateTime                         = CREATE_DRM_STRING( g_rgwchSavedDateTime );

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
const DRM_CONST_STRING      g_dstrCheckClockRollback                    = CREATE_DRM_STRING( g_rgwchCheckClockRollback );
const DRM_CONST_STRING      g_dstrResetRollbackedClock                  = CREATE_DRM_STRING( g_rgwchResetRollbackedClock );
#endif

const DRM_CONST_STRING      g_dstrSetSavedDateTime                      = CREATE_DRM_STRING( g_rgwchSetSavedDateTime );
const DRM_CONST_STRING      g_dstrCreatePMLicense                       = CREATE_DRM_STRING( g_rgwchCreatePMLicense );
const DRM_CONST_STRING      g_dstrVersion_1_0                           = CREATE_DRM_STRING( g_rgwchVersion_1_0 );
const DRM_CONST_STRING      g_dstrTagDevinfo                            = CREATE_DRM_STRING( g_rgwchTagDevinfo );
const DRM_CONST_STRING      g_dstrTagFallback                           = CREATE_DRM_STRING( g_rgwchTagFallback );
const DRM_CONST_STRING      g_dstrTagError                              = CREATE_DRM_STRING( g_rgwchTagError );
const DRM_CONST_STRING      g_dstrXPathSigValue                         = CREATE_DRM_STRING( g_rgwchXPathSigValue );
const DRM_CONST_STRING      g_dstrCompatCert                            = CREATE_DRM_STRING( g_rgwchCompatCert );
const DRM_CONST_STRING      g_dstrCompatSecVersion                      = CREATE_DRM_STRING( g_rgwchCompatSecVersion );
const DRM_CONST_STRING      g_dstrSubjectId                             = CREATE_DRM_STRING( g_rgwchSubjectId );
const DRM_CONST_STRING      g_dstrMaxSecLevel                           = CREATE_DRM_STRING( g_rgwchMaxSecLevel );
const DRM_CONST_STRING      g_dstrAuthSecVer                            = CREATE_DRM_STRING( g_rgwchAuthSecVer );
const DRM_CONST_STRING      g_dstrAuthPubKey                            = CREATE_DRM_STRING( g_rgwchAuthPubKey );
const DRM_CONST_STRING      g_dstrXPathTagSignature                     = CREATE_DRM_STRING( g_rgwchXPathTagSignature );
const DRM_CONST_STRING      g_dstrTagSignatureVal                       = CREATE_DRM_STRING( g_rgwchTagSignatureVal );
const DRM_CONST_STRING      g_dstrXPathTagCertificateChain              = CREATE_DRM_STRING( g_rgwchXPathTagCertificateChain );
const DRM_CONST_STRING      g_dstrAuthData                              = CREATE_DRM_STRING( g_rgwchAuthData );
const DRM_CONST_STRING      g_dstrAuthHashAlg                           = CREATE_DRM_STRING( g_rgwchAuthHashAlg );
const DRM_CONST_STRING      g_dstrAuthSignAlg                           = CREATE_DRM_STRING( g_rgwchAuthSignAlg );
const DRM_CONST_STRING      g_dstrFallback                              = CREATE_DRM_STRING( g_rgwchFallback );


const DRM_CONST_STRING      g_dstrXPathTagSecurityLevel                 = CREATE_DRM_STRING( g_rgwchXPathTagSecurityLevel );

const DRM_CONST_STRING      g_dstrXPathTagCertificate                   = CREATE_DRM_STRING( g_rgwchXPathTagCertificate );
const DRM_CONST_STRING      g_dstrXPathDataUniqueID                     = CREATE_DRM_STRING( g_rgwchXPathDataUniqueID );

const DRM_CONST_STRING      g_dstrXPathManufacturer                     = CREATE_DRM_STRING( g_rgwchXPathManufacturer );
const DRM_CONST_STRING      g_dstrXPathMake                             = CREATE_DRM_STRING( g_rgwchXPathMake );
const DRM_CONST_STRING      g_dstrXPathModel                            = CREATE_DRM_STRING( g_rgwchXPathModel );
const DRM_CONST_STRING      g_dstrXPathDistributor                      = CREATE_DRM_STRING( g_rgwchXPathDistributor );
const DRM_CONST_STRING      g_dstrXPathHardwareMajor                    = CREATE_DRM_STRING( g_rgwchXPathHardwareMajor );
const DRM_CONST_STRING      g_dstrXPathHardwareMinor                    = CREATE_DRM_STRING( g_rgwchXPathHardwareMinor );
const DRM_CONST_STRING      g_dstrXPathFirmwareMajor                    = CREATE_DRM_STRING( g_rgwchXPathFirmwareMajor );
const DRM_CONST_STRING      g_dstrXPathFirmwareMinor                    = CREATE_DRM_STRING( g_rgwchXPathFirmwareMinor );
const DRM_CONST_STRING      g_dstrXPathFeatureTemplate                  = CREATE_DRM_STRING( g_rgwchXPathFeatureTemplate );
const DRM_CONST_STRING      g_dstrXPathClientOldKeys                    = CREATE_DRM_STRING( g_rgwchXPathClientOldKeys );
const DRM_CONST_STRING      g_dstrXPathClientEscrowKeys                 = CREATE_DRM_STRING( g_rgwchXPathClientEscrowKeys );
const DRM_CONST_STRING      g_dstrXPathClientEscrowKey                  = CREATE_DRM_STRING( g_rgwchXPathClientEscrowKey );
const DRM_CONST_STRING      g_dstrXPathIndivServerEscrowKey             = CREATE_DRM_STRING( g_rgwchXPathIndivServerEscrowKey );
const DRM_CONST_STRING      g_dstrXPathDevicePublicKey                  = CREATE_DRM_STRING( g_rgwchXPathDevicePublicKey );
const DRM_CONST_STRING      g_dstrXPathOldKeysData                      = CREATE_DRM_STRING( g_rgwchXPathOldKeysData );
const DRM_CONST_STRING      g_dstrXPathIndivSvrPubKey                   = CREATE_DRM_STRING( g_rgwchXPathIndivSvrPubKey );
const DRM_CONST_STRING      g_dstrXPathSecureClock                      = CREATE_DRM_STRING( g_rgwchXPathSecureClock );
const DRM_CONST_STRING      g_dstrXPathIndivType                        = CREATE_DRM_STRING( g_rgwchXPathIndivType );
const DRM_CONST_STRING      g_dstrXPathSecureStore                      = CREATE_DRM_STRING( g_rgwchXPathSecureStore );
const DRM_CONST_STRING      g_dstrXPathMetering                         = CREATE_DRM_STRING( g_rgwchXPathMetering );
const DRM_CONST_STRING      g_dstrXPathLicenseChain                     = CREATE_DRM_STRING( g_rgwchXPathLicenseChain );


const DRM_CONST_STRING      g_dstrTagDevCert                            = CREATE_DRM_STRING( g_rgwchTagDevCert );
const DRM_CONST_STRING      g_dstrTagWrmHeader                          = CREATE_DRM_STRING( g_rgwchTagWrmHeader );
const DRM_CONST_STRING      g_dstrAttributeVersionValue                 = CREATE_DRM_STRING( g_rgwchAttributeVersionValue );
const DRM_CONST_STRING      g_dstrTagLAINFO                             = CREATE_DRM_STRING( g_rgwchTagLAINFO );
const DRM_CONST_STRING      g_dstrTagKID                                = CREATE_DRM_STRING( g_rgwchTagKID );
const DRM_CONST_STRING      g_dstrTagChecksum                           = CREATE_DRM_STRING( g_rgwchTagChecksum );
const DRM_CONST_STRING      g_dstrXPathHeaderUplinks                    = CREATE_DRM_STRING( g_rgwchXPathHeaderUplinks );
const DRM_CONST_STRING      g_dstrTagUplink                             = CREATE_DRM_STRING( g_rgwchTagUplink );
const DRM_CONST_STRING      g_dstrTagUplinks                            = CREATE_DRM_STRING( g_rgwchTagUplinks );

const DRM_CONST_STRING      g_dstrTagLicenseRequest                     = CREATE_DRM_STRING( g_rgwchTagLicenseRequest );
const DRM_CONST_STRING      g_dstrTagAction                             = CREATE_DRM_STRING( g_rgwchTagAction );

const DRM_CONST_STRING      g_dstrTagV1Challenge                        = CREATE_DRM_STRING( g_rgwchTagV1Challenge );
const DRM_CONST_STRING      g_dstrDefaultV1Data                         = CREATE_DRM_STRING( g_rgwchDefaultV1Data );
const DRM_CONST_STRING      g_dstrTagActionList                         = CREATE_DRM_STRING( g_rgwchTagActionList );
const DRM_CONST_STRING      g_dstrTagSecurityVersion                    = CREATE_DRM_STRING( g_rgwchTagSecurityVersion );


/*
**  Devcert Non-indiv Tags
*/
const DRM_CONST_STRING      g_dstrTagDNIUniqueID                        = CREATE_DRM_STRING( g_rgwchTagDNIUniqueID );
const DRM_CONST_STRING      g_dstrTagMSDRMSignature                     = CREATE_DRM_STRING( g_rgwchTagMSDRMSignature );
const DRM_CONST_STRING      g_dstrPrivateKeys                           = CREATE_DRM_STRING( g_rgwchPrivateKeys );
const DRM_CONST_STRING      g_dstrCertTypeDevice                        = CREATE_DRM_STRING( g_rgwchCertTypeDevice );
const DRM_CONST_STRING      g_dstrCerttypeGroup                         = CREATE_DRM_STRING( g_rgwchCerttypeGroup );
const DRM_CONST_STRING      g_dstrCerttypeAuth                          = CREATE_DRM_STRING( g_rgwchCerttypeAuth );
const DRM_CONST_STRING      g_dstrCerttypeAuthRoot                      = CREATE_DRM_STRING( g_rgwchCerttypeAuthRoot );

/*
**  Devcert Non-indiv XPaths
*/
const DRM_CONST_STRING      g_dstrXPathPubkeyData                       = CREATE_DRM_STRING( g_rgwchXPathPubkeyData );
const DRM_CONST_STRING      g_dstrXPathGCSecureClock                    = CREATE_DRM_STRING( g_rgwchXPathGCSecureClock );
const DRM_CONST_STRING      g_dstrXPathGCSecureClockURL                 = CREATE_DRM_STRING( g_rgwchXPathGCSecureClockURL );
const DRM_CONST_STRING      g_dstrXPathGCSecureClockPubKey              = CREATE_DRM_STRING( g_rgwchXPathGCSecureClockPubKey );
const DRM_CONST_STRING      g_dstrXPathGCMetering                       = CREATE_DRM_STRING( g_rgwchXPathGCMetering );
const DRM_CONST_STRING      g_dstrXPathGCLicenseAcquisitionMode         = CREATE_DRM_STRING( g_rgwchXPathGCLicenseAcquisitionMode );
const DRM_CONST_STRING      g_dstrXPathGCLicenseSyncMode                = CREATE_DRM_STRING( g_rgwchXPathGCLicenseSyncMode );
const DRM_CONST_STRING      g_dstrXPathGCSymmOptsMode                   = CREATE_DRM_STRING( g_rgwchXPathGCSymmOpts );
const DRM_CONST_STRING      g_dstrXPathGCEncryption                     = CREATE_DRM_STRING( g_rgwchXPathGCEncryption );
const DRM_CONST_STRING      g_dstrXPathGCMaxChainDepth                  = CREATE_DRM_STRING( g_rgwchXPathGCMaxChainDepth );
const DRM_CONST_STRING      g_dstrXPathGCMaxLicenseSize                 = CREATE_DRM_STRING( g_rgwchXPathGCMaxLicenseSize );
const DRM_CONST_STRING      g_dstrXPathGCMaxHeaderSize                  = CREATE_DRM_STRING( g_rgwchXPathGCMaxHeaderSize );
const DRM_CONST_STRING      g_dstrXPathDeviceKeydata                    = CREATE_DRM_STRING( g_rgwchXPathDeviceKeydata );
const DRM_CONST_STRING      g_dstrXPathDACAuthID                        = CREATE_DRM_STRING( g_rgwchXPathDACAuthID );

const DRM_CONST_STRING      g_dstrReqTagClientInfo                      = CREATE_DRM_STRING( g_rgwchReqTagClientInfo );
const DRM_CONST_STRING      g_dstrReqTagClientID                        = CREATE_DRM_STRING( g_rgwchReqTagClientID );
const DRM_CONST_STRING      g_dstrReqTagClientVersion                   = CREATE_DRM_STRING( g_rgwchReqTagClientVersion );
const DRM_CONST_STRING      g_dstrReqTagAppSecurity                     = CREATE_DRM_STRING( g_rgwchReqTagAppSecurity );
const DRM_CONST_STRING      g_dstrReqTagSubjectID1                      = CREATE_DRM_STRING( g_rgwchReqTagSubjectID1 );
const DRM_CONST_STRING      g_dstrReqTagSubjectID2                      = CREATE_DRM_STRING( g_rgwchReqTagSubjectID2 );
const DRM_CONST_STRING      g_dstrReqTagDrmkVersion                     = CREATE_DRM_STRING( g_rgwchReqTagDrmkVersion );
const DRM_CONST_STRING      g_dstrReqTagClientVersionData               = CREATE_DRM_STRING( g_rgwchReqTagClientVersionData );
const DRM_CONST_STRING      g_dstrReqTagSubjectID2Data                  = CREATE_DRM_STRING( g_rgwchReqTagSubjectID2Data );
const DRM_CONST_STRING      g_dstrReqTagDrmkData                        = CREATE_DRM_STRING( g_rgwchReqTagDrmkData );

/* Xml tags used in parsing licenses */
const DRM_CONST_STRING      g_dstrLicense                               = CREATE_DRM_STRING( g_rgwchLicense );
const DRM_CONST_STRING      g_dstrLicensorInfoNode                      = CREATE_DRM_STRING( g_rgwchLicensorInfoNode );
const DRM_CONST_STRING      g_dstrLIData                                = CREATE_DRM_STRING( g_rgwchLIData );
const DRM_CONST_STRING      g_dstrMeta                                  = CREATE_DRM_STRING( g_rgwchMeta );

const DRM_ANSI_CONST_STRING g_dastrTagRevocation                        = { g_rgchTagRevocation, 10 };
const DRM_CONST_STRING      g_dstrTagRevocation                         = CREATE_DRM_STRING( g_rgwchTagRevocation );
const DRM_CONST_STRING      g_dstrAppRevocation                         = CREATE_DRM_STRING( g_rgwchAppRevocation );
const DRM_CONST_STRING      g_dstrDeviceRevocation                      = CREATE_DRM_STRING( g_rgwchDeviceRevocation );
const DRM_ANSI_CONST_STRING g_dastrTagRevocationInfo                    = { g_rgchTagRevocationInfo, 14 };
const DRM_CONST_STRING      g_dstrTagRevocationInfo                     = CREATE_DRM_STRING( g_rgwchTagRevocationInfo );
const DRM_ANSI_CONST_STRING g_dastrDeviceRevocation                     = CREATE_DRM_ANSI_STRING( g_rgchDeviceRevocation );
const DRM_CONST_STRING      g_dstrDeviceRevocationList                  = CREATE_DRM_STRING( g_rgwchDeviceRevocationList );
const DRM_CONST_STRING      g_dstrWMDRMNET_Revocation                   = CREATE_DRM_STRING( g_rgwchWMDRMNET_Revocation );
const DRM_ANSI_CONST_STRING g_dastrWMDRMNET_Revocation                  = CREATE_DRM_ANSI_STRING(  g_rgchWMDRMNET_Revocation );
const DRM_CONST_STRING      g_dstrTagRevInfoVersion                     = CREATE_DRM_STRING( g_rgwchTagRevInfoVersion );
const DRM_ANSI_CONST_STRING g_dastrTagRevInfoVersion                    = CREATE_DRM_ANSI_STRING( g_rgchTagRevInfoVersion );
const DRM_CONST_STRING      g_dstrTagSourceID                           = CREATE_DRM_STRING( g_rgwchTagSourceID );
const DRM_ANSI_CONST_STRING g_dastrTagSourceID                          = CREATE_DRM_ANSI_STRING( g_rgchTagSourceID );


const DRM_CONST_STRING      g_dstrDeviceRevocationLicenseTag            = CREATE_DRM_STRING( g_rgwchDeviceRevocationLicenseTag );
const DRM_CONST_STRING      g_dstrWMDRMNETRevocationLicenseTag          = CREATE_DRM_STRING( g_rgwchWMDRMNETRevocationLicenseTag );

#if DRM_SUPPORT_REVOCATION

#if DRM_SUPPORT_WMDRMNET
const DRM_CONST_STRING      g_dstrRevocationGuidWMDRMNET                = CREATE_DRM_STRING( g_rgwchRevocationGuidWMDRMNET );
const DRM_ANSI_CONST_STRING g_dastrRevocationGuidWMDRMNET               = { g_rgchRevocationGuidWMDRMNET, 38 };
#endif /* DRM_SUPPORT_WMDRMNET */

#if DRM_SUPPORT_DEVICE_REVOCATION
const DRM_CONST_STRING      g_dstrRevocationGuidDevice                  = CREATE_DRM_STRING( g_rgwchRevocationGuidDevice   );
const DRM_ANSI_CONST_STRING g_dastrRevocationGuidDevice                 = { g_rgchRevocationGuidDevice  , 38 };
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_APP_REVOCATION
const DRM_CONST_STRING      g_dstrRevocationGuidApp                     = CREATE_DRM_STRING( g_rgwchRevocationGuidApp      );
const DRM_ANSI_CONST_STRING g_dastrRevocationGuidApp                    = { g_rgchRevocationGuidApp     , 38 };
#endif /* DRM_SUPPORT_APP_REVOCATION */

#endif /*DRM_SUPPORT_REVOCATION */

const DRM_CONST_STRING      g_dstrPriority                              = CREATE_DRM_STRING( g_rgwchPriority );
const DRM_CONST_STRING      g_dstrIssueDate                             = CREATE_DRM_STRING( g_rgwchIssueDate );
const DRM_CONST_STRING      g_dstrContentPubKey                         = CREATE_DRM_STRING( g_rgwchContentPubKey );
const DRM_CONST_STRING      g_dstrContentRevocation                     = CREATE_DRM_STRING( g_rgwchContentRevocation );
const DRM_CONST_STRING      g_dstrCondition                             = CREATE_DRM_STRING( g_rgwchCondition );
const DRM_CONST_STRING      g_dstrAction                                = CREATE_DRM_STRING( g_rgwchAction );
const DRM_CONST_STRING      g_dstrRestrictions                          = CREATE_DRM_STRING( g_rgwchRestrictions );
const DRM_CONST_STRING      g_dstrChainedEnablingBits                   = CREATE_DRM_STRING( g_rgwchChainedEnablingBits );
const DRM_CONST_STRING      g_dstrDrmRestoreInfoEnablingBits            = CREATE_DRM_STRING( g_rgwchDrmRestoreInfoEnablingBits );
const DRM_CONST_STRING      g_dstrCertChain                             = CREATE_DRM_STRING( g_rgwchCertChain );
const DRM_CONST_STRING      g_dstrTagCertificate                        = CREATE_DRM_STRING( g_rgwchTagCertificate );
const DRM_CONST_STRING      g_dstrLISigHashAlgo                         = CREATE_DRM_STRING( g_rgwchLISigHashAlgo );
const DRM_CONST_STRING      g_dstrLISigAlgo                             = CREATE_DRM_STRING( g_rgwchLISigAlgo );
const DRM_CONST_STRING      g_dstrLISigValue                            = CREATE_DRM_STRING( g_rgwchLISigValue );
const DRM_CONST_STRING      g_dstrOnActionPath                          = CREATE_DRM_STRING( g_rgwchOnActionPath );
const DRM_CONST_STRING      g_dstrXPathSymSig                           = CREATE_DRM_STRING( g_rgwchXPathSymSig );
const DRM_CONST_STRING      g_dstrXPathSymValue                         = CREATE_DRM_STRING( g_rgwchXPathSymValue );

const DRM_CONST_STRING      g_dstrSequenceNumber                        = CREATE_DRM_STRING( g_rgwchSequenceNumber );
const DRM_CONST_STRING      g_dstrLSPubKey                              = CREATE_DRM_STRING( g_rgwchLSPubKey );
const DRM_CONST_STRING      g_dstrUplinkKid                             = CREATE_DRM_STRING( g_rgwchUplinkKid );
const DRM_CONST_STRING      g_dstrChainedCheckSum                       = CREATE_DRM_STRING( g_rgwchChainedCheckSum );
const DRM_CONST_STRING      g_dstrPMLicenseVersionString                = CREATE_DRM_STRING( g_rgwchPMLicenseVersionString );
const DRM_ANSI_CONST_STRING g_dastrPMLicenseVersionString               = { g_rgchPMLicenseVersionString, 7 }; /* Special case this odd length ANSI string */
const DRM_CONST_STRING      g_dstrRevAttribute                          = CREATE_DRM_STRING( g_rgwchRevAttribute );
const DRM_CONST_STRING      g_dstrDerivedLicTemplate                    = CREATE_DRM_STRING( g_rgwchDerivedLicTemplate );
const DRM_CONST_STRING      g_dstrLicDataDerivedTmpl                    = CREATE_DRM_STRING( g_rgwchLicDataDerivedTmpl );


/* XML tags used in writing Challenge and parsing Response for metering */
const DRM_CONST_STRING      g_dstrTagMetering                           = CREATE_DRM_STRING( g_rgwchTagMetering );
const DRM_CONST_STRING      g_dstrTagHash                               = CREATE_DRM_STRING( g_rgwchTagHash );
const DRM_CONST_STRING      g_dstrXPathMID                              = CREATE_DRM_STRING( g_rgwchXPathMID );                      
const DRM_CONST_STRING      g_dstrTagMID                                = CREATE_DRM_STRING( g_rgwchTagMID );                      
const DRM_CONST_STRING      g_dstrTagTID                                = CREATE_DRM_STRING( g_rgwchTagTID );
const DRM_CONST_STRING      g_dstrTagCmd                                = CREATE_DRM_STRING( g_rgwchTagCmd );
const DRM_CONST_STRING      g_dstrTagPassword                           = CREATE_DRM_STRING( g_rgwchTagPassword );
const DRM_CONST_STRING      g_dstrTagRecords                            = CREATE_DRM_STRING( g_rgwchTagRecords );
const DRM_CONST_STRING      g_dstrTagURL                                = CREATE_DRM_STRING( g_rgwchTagURL );
const DRM_CONST_STRING      g_dstrTagPartialData                        = CREATE_DRM_STRING( g_rgwchTagPartialData );
const DRM_CONST_STRING      g_dstrLabelValue                            = CREATE_DRM_STRING( g_rgwchLabelValue );
const DRM_CONST_STRING      g_dstrHMAC                                  = CREATE_DRM_STRING( g_rgwchHMAC );
const DRM_CONST_STRING      g_dstrChallenge                             = CREATE_DRM_STRING( g_rgwchChallenge );
const DRM_CONST_STRING      g_dstr1                                     = CREATE_DRM_STRING( g_rgwch1 );
const DRM_CONST_STRING      g_dstrReset                                 = CREATE_DRM_STRING( g_rgwchReset );

const DRM_ANSI_CONST_STRING g_dastrTagMeterCert                         = CREATE_DRM_ANSI_STRING( g_rgchTagMeterCert );

const DRM_CONST_STRING      g_dstrTagMeterCert                          = CREATE_DRM_STRING( g_rgwchTagMeterCert );

const DRM_CONST_STRING      g_dstrTagCertificateChain                   = CREATE_DRM_STRING( g_rgwchTagCertificateChain );

/* tags used for sync lists */
const DRM_CONST_STRING      g_dstrTagPrivateKey                         = CREATE_DRM_STRING( g_rgwchTagPrivateKey );
const DRM_CONST_STRING      g_dstrTagDevice                             = CREATE_DRM_STRING( g_rgwchTagDevice );
const DRM_CONST_STRING      g_dstrKeyDataTag                            = CREATE_DRM_STRING( g_rgwchKeyDataTag );
const DRM_CONST_STRING      g_dstrGroupTag                              = CREATE_DRM_STRING( g_rgwchGroupTag );

const DRM_CONST_STRING      g_dstrTagSyncList                           = CREATE_DRM_STRING( g_rgwchTagSyncList );
                                                                                                          
const DRM_CONST_STRING      g_dstrBackup                                = CREATE_DRM_STRING( g_rgwchBackup );
const DRM_CONST_STRING      g_dstrRestore                               = CREATE_DRM_STRING( g_rgwchRestore );
const DRM_CONST_STRING      g_dstrRootSigValueVersionTag                = CREATE_DRM_STRING( g_rgwchRootSigValueVersionTag );
const DRM_CONST_STRING      g_dstrRootSigValueVersionVal                = CREATE_DRM_STRING( g_rgwchRootSigValueVersionVal );
const DRM_CONST_STRING      g_dstrPFRootTag                             = CREATE_DRM_STRING( g_rgwchPFRootTag );
const DRM_CONST_STRING      g_dstrDACPubKeyTag                          = CREATE_DRM_STRING( g_rgwchDACPubKeyTag );
const DRM_CONST_STRING      g_dstrAuthRoot                              = CREATE_DRM_STRING( g_rgwchAuthRoot );
const DRM_CONST_STRING      g_dstrTagNameValue                          = CREATE_DRM_STRING( g_rgwchTagSecurityLevel );
const DRM_CONST_STRING      g_dstrTagSecurityLevel                      = CREATE_DRM_STRING( g_rgwchTagSecurityLevel );
const DRM_CONST_STRING      g_dstrTagDataId                             = CREATE_DRM_STRING( g_rgwchTagDataId );
const DRM_CONST_STRING      g_dstrTagDataPubKey                         = CREATE_DRM_STRING( g_rgwchTagDataPubKey );
const DRM_CONST_STRING      g_dstrFallBack                              = CREATE_DRM_STRING( g_rgwchFallBack );
const DRM_CONST_STRING      g_dstrTagName                               = CREATE_DRM_STRING( g_rgwchTagName );
const DRM_CONST_STRING      g_dstrManufacturer                          = CREATE_DRM_STRING( g_rgwchManufacturer );
const DRM_CONST_STRING      g_dstrModel                                 = CREATE_DRM_STRING( g_rgwchModel );
const DRM_CONST_STRING      g_dstrHwMajor                               = CREATE_DRM_STRING( g_rgwchHwMajor );
const DRM_CONST_STRING      g_dstrHwMinor                               = CREATE_DRM_STRING( g_rgwchHwMinor );
const DRM_CONST_STRING      g_dstrFwMajor                               = CREATE_DRM_STRING( g_rgwchFwMajor );
const DRM_CONST_STRING      g_dstrFwMinor                               = CREATE_DRM_STRING( g_rgwchFwMinor );
const DRM_CONST_STRING      g_dstrFeatures                              = CREATE_DRM_STRING( g_rgwchFeatures );
const DRM_CONST_STRING      g_dstrSecureClockNotSet                     = CREATE_DRM_STRING( g_rgwchSecClockNotSet );
const DRM_CONST_STRING      g_dstrSecureClockSet                        = CREATE_DRM_STRING( g_rgwchSecClockSet );
const DRM_CONST_STRING      g_dstrSecureClockNeedsRefresh               = CREATE_DRM_STRING( g_rgwchSecClockNeedsRefresh );
const DRM_CONST_STRING      g_dstrTemplate                              = CREATE_DRM_STRING( g_rgwchTemplate );
const DRM_CONST_STRING      g_dstrIndivPubKey                           = CREATE_DRM_STRING( g_rgwchIndivPubKey );
const DRM_CONST_STRING      g_dstrUniqueId                              = CREATE_DRM_STRING( g_rgwchUniqueId );
const DRM_CONST_STRING      g_dstrUnsignedtemplate                      = CREATE_DRM_STRING( g_rgwchUnsignedtemplate );

/* This data is used explicitly in the gen tools */
const DRM_CONST_STRING      g_dstrTagDataSecVer                         = CREATE_DRM_STRING( g_rgwchTagDataSecVer );

/* Strings for the expression evaluator functions */
const DRM_CONST_STRING      g_dstrExprFuncDateAdd                       = CREATE_DRM_STRING( g_rgwchExprFuncDateAdd );
const DRM_CONST_STRING      g_dstrExprFuncDateDiff                      = CREATE_DRM_STRING( g_rgwchExprFuncDateDiff );
const DRM_CONST_STRING      g_dstrExprFuncMin                           = CREATE_DRM_STRING( g_rgwchExprFuncMin );
const DRM_CONST_STRING      g_dstrExprFuncMax                           = CREATE_DRM_STRING( g_rgwchExprFuncMax );
const DRM_CONST_STRING      g_dstrExprFuncDatePart                      = CREATE_DRM_STRING( g_rgwchExprFuncDatePart );
const DRM_CONST_STRING      g_dstrExprFuncVersionCompare                = CREATE_DRM_STRING( g_rgwchExprFuncVersionCompare );
const DRM_CONST_STRING      g_dstrExprFuncDeleteLicense                 = CREATE_DRM_STRING( g_rgwchExprFuncDeleteLicense );
const DRM_CONST_STRING      g_dstrExprFuncExists                        = CREATE_DRM_STRING( g_rgwchExprFuncExists );

/* Strings for license evaluator well known actions */
const DRM_CONST_STRING      g_dstrLicEvalOnSelect                       = CREATE_DRM_STRING( g_rgwchLicEvalOnSelect );
const DRM_CONST_STRING      g_dstrLicEvalOnDelete                       = CREATE_DRM_STRING( g_rgwchLicEvalOnDelete );
const DRM_CONST_STRING      g_dstrLicEvalOnStore                        = CREATE_DRM_STRING( g_rgwchLicEvalOnStore );
const DRM_CONST_STRING      g_dstrLicEvalOnAction                       = CREATE_DRM_STRING( g_rgwchLicEvalOnAction );
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK 
const DRM_CONST_STRING      g_dstrLicEvalOnClockRollback                = CREATE_DRM_STRING( g_rgwchLicEvalOnClockRollback );
#endif

/* Strings for expression evaluator variable evaluation */
const DRM_CONST_STRING      g_dstrDRM_PREFIX                            = CREATE_DRM_STRING( g_rgwchDRM_PREFIX );
const DRM_CONST_STRING      g_dstrDRMK_PREFIX                           = CREATE_DRM_STRING( g_rgwchDRMK_PREFIX );
const DRM_CONST_STRING      g_dstrMACHINE_PREFIX                        = CREATE_DRM_STRING( g_rgwchMACHINE_PREFIX );
const DRM_CONST_STRING      g_dstrAPP_PREFIX                            = CREATE_DRM_STRING( g_rgwchAPP_PREFIX );
const DRM_CONST_STRING      g_dstrSECSTATE_PREFIX                       = CREATE_DRM_STRING( g_rgwchSECSTATE_PREFIX );
const DRM_CONST_STRING      g_dstrLICENSE_PREFIX                        = CREATE_DRM_STRING( g_rgwchLICENSE_PREFIX );
const DRM_CONST_STRING      g_dstrCONTENT_PREFIX                        = CREATE_DRM_STRING( g_rgwchCONTENT_PREFIX );
const DRM_CONST_STRING      g_dstrDEVICE_PREFIX                         = CREATE_DRM_STRING( g_rgwchDEVICE_PREFIX );
const DRM_CONST_STRING      g_dstrPMLICENSE_PREFIX                      = CREATE_DRM_STRING( g_rgwchPMLICENSE_PREFIX );
const DRM_CONST_STRING      g_dstrSECURETIME_PREFIX                     = CREATE_DRM_STRING( g_rgwchSECURETIME_PREFIX );
const DRM_CONST_STRING      g_dstrPLAYLISTBURN_PREFIX                   = CREATE_DRM_STRING( g_rgwchPLAYLISTBURN_PREFIX );

#if DRM_SUPPORT_SST_REDUNANCY
const DRM_CONST_STRING      g_dstrSSTREDUNDANCY_PREFIX                  = CREATE_DRM_STRING( g_rgwchSSTREDUNDANCY_PREFIX );
#endif

const DRM_CONST_STRING      g_dstrExprVarVersion                        = CREATE_DRM_STRING( g_rgwchExprVarVersion );
const DRM_CONST_STRING      g_dstrExprVarParameter                      = CREATE_DRM_STRING( g_rgwchExprVarParameter );
const DRM_CONST_STRING      g_dstrExprVarReason                         = CREATE_DRM_STRING( g_rgwchExprVarReason );
const DRM_CONST_STRING      g_dstrExprVarBBMSDRMVersion                 = CREATE_DRM_STRING( g_rgwchExprVarBBMSDRMVersion );
const DRM_CONST_STRING      g_dstrExprVarDateTime                       = CREATE_DRM_STRING( g_rgwchExprVarDateTime );
const DRM_CONST_STRING      g_dstrExprVarCount                          = CREATE_DRM_STRING( g_rgwchExprVarCount );
const DRM_CONST_STRING      g_dstrExprVarMinSecLevel                    = CREATE_DRM_STRING( g_rgwchExprVarMinSecLevel );
const DRM_CONST_STRING      g_dstrExprVarSecLevel                       = CREATE_DRM_STRING( g_rgwchExprVarSecLevel );
const DRM_CONST_STRING      g_dstrExprVarAppSecLevel                    = CREATE_DRM_STRING( g_rgwchExprVarAppSecLevel );
const DRM_CONST_STRING      g_dstrExprVarSubjID                         = CREATE_DRM_STRING( g_rgwchExprVarSubjID );
const DRM_CONST_STRING      g_dstrExprVarAppSubjID                      = CREATE_DRM_STRING( g_rgwchExprVarAppSubjID );
const DRM_CONST_STRING      g_dstrExprVarGlobal                         = CREATE_DRM_STRING( g_rgwchExprVarGlobal );
const DRM_CONST_STRING      g_dstrExprVarSaveDateTime                   = CREATE_DRM_STRING( g_rgwchExprVarSaveDateTime );
const DRM_CONST_STRING      g_dstrExprVarSavedDateTime                  = CREATE_DRM_STRING( g_rgwchExprVarSavedDateTime );
const DRM_CONST_STRING      g_dstrExprVarDRMReason                      = CREATE_DRM_STRING( g_rgwchExprVarDRMReason );
const DRM_CONST_STRING      g_dstrExprVarRights                         = CREATE_DRM_STRING( g_rgwchExprVarRights );
const DRM_CONST_STRING      g_dstrExprVarExpiryDate                     = CREATE_DRM_STRING( g_rgwchExprVarExpiryDate );
const DRM_CONST_STRING      g_dstrExprVarInGracePeriod                  = CREATE_DRM_STRING( g_rgwchExprVarInGracePeriod );
const DRM_CONST_STRING      g_dstrExprVarGpStartTime                    = CREATE_DRM_STRING( g_rgwchExprVarGpStartTime );
const DRM_CONST_STRING      g_dstrExprVarIncrementCount                 = CREATE_DRM_STRING( g_rgwchExprVarIncrementCount );
const DRM_CONST_STRING      g_dstrExprVarDevReg                         = CREATE_DRM_STRING( g_rgwchExprVarDevReg );

/* XML tags */
const DRM_CONST_STRING      g_dstrTagCDATA                              = CREATE_DRM_STRING( g_rgwchTagCDATA );
const DRM_CONST_STRING      g_dstrTagCDATAOpenBracket                   = CREATE_DRM_STRING( g_rgwchTagCDATAOpenBracket );
const DRM_ANSI_CONST_STRING g_dastrTagCDATAOpenBracket                  = CREATE_DRM_ANSI_STRING( g_rgchTagCDATAOpenBracket );
const DRM_CONST_STRING      g_dstrOpenTag                               = CREATE_DRM_STRING( g_rgwchOpenTag );
const DRM_CONST_STRING      g_dstrSpace                                 = CREATE_DRM_STRING( g_rgwchSpace );
const DRM_CONST_STRING      g_dstrOpenEndTag                            = CREATE_DRM_STRING( g_rgwchOpenEndTag );
const DRM_CONST_STRING      g_dstrCloseTag                              = CREATE_DRM_STRING( g_rgwchCloseTag );
const DRM_CONST_STRING      g_dstrEqualQuote                            = CREATE_DRM_STRING( g_rgwchEqualQuote );
const DRM_CONST_STRING      g_dstrQuote                                 = CREATE_DRM_STRING( g_rgwchQuote );
const DRM_CONST_STRING      g_dstrOpenCDATATag                          = CREATE_DRM_STRING( g_rgwchOpenCDATATag );
const DRM_CONST_STRING      g_dstrCloseCDATATag                         = CREATE_DRM_STRING( g_rgwchCloseCDATATag );


const DRM_ANSI_CONST_STRING  g_dastrAttributeAlgorithm                  = { g_rgchAttributeAlgorithm, g_rgchAttributeAlgorithm_LEN };
const DRM_ANSI_CONST_STRING  g_dastrAttributeVersionWMDRM               = { g_rgchAttributeVersionWMDRM, g_rgchAttributeVersionWMDRM_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagEscrowedKeys                     = { g_rgchTagEscrowedKeys, g_rgchTagEscrowedKeys_LEN };
const DRM_ANSI_CONST_STRING  g_dastrKeyUsageSignCert                    = { g_rgchKeyUsageSignCert, g_rgchKeyUsageSignCert_LEN };
const DRM_ANSI_CONST_STRING  g_dastrKeyUsageSignCRL                     = { g_rgchKeyUsageSignCRL, g_rgchKeyUsageSignCRL_LEN };
const DRM_ANSI_CONST_STRING  g_dastrKeyUsageEncryptKey                  = { g_rgchKeyUsageEncryptKey, g_rgchKeyUsageEncryptKey_LEN };
const DRM_ANSI_CONST_STRING  g_dastrOne                                 = { g_rgchOne, g_rgchOne_LEN };
const DRM_ANSI_CONST_STRING  g_dastrPrefixManufacturer                  = { g_rgchPrefixManufacturer, g_rgchPrefixManufacturer_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagCanonicalization                 = { g_rgchTagCanonicalization, g_rgchTagCanonicalization_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagCertificateCollection            = { g_rgchTagCertificateCollection, g_rgchTagCertificateCollection_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagDigestMethod                     = { g_rgchTagDigestMethod, g_rgchTagDigestMethod_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURIDSigSHA1                         = { g_rgchURIDSigSHA1, g_rgchURIDSigSHA1_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagDigestValue                      = { g_rgchTagDigestValue, g_rgchTagDigestValue_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagSignatureValue                   = { g_rgchTagSignatureValue, g_rgchTagSignatureValue_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagKeyInfo                          = { g_rgchTagKeyInfo, g_rgchTagKeyInfo_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagSymmetricKey                     = { g_rgchTagSymmetricKey, g_rgchTagSymmetricKey_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagPublicKey                        = { g_rgchTagPublicKey, g_rgchTagPublicKey_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagPrivateKey                       = { g_rgchTagPrivateKey, g_rgchTagPrivateKey_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagKeyValue                         = { g_rgchTagKeyValue, g_rgchTagKeyValue_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagRSAKeyValue                      = { g_rgchTagRSAKeyValue, g_rgchTagRSAKeyValue_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagModulus                          = { g_rgchTagModulus, g_rgchTagModulus_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagExponent                         = { g_rgchTagExponent, g_rgchTagExponent_LEN };

const DRM_ANSI_CONST_STRING  g_dastrTagManufacturerName                 = { g_rgchTagManufacturerName, g_rgchTagManufacturerName_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagManufacturerData                 = { g_rgchTagManufacturerData, g_rgchTagManufacturerData_LEN }; 
const DRM_ANSI_CONST_STRING  g_dastrTagModelName                        = { g_rgchTagModelName, g_rgchTagModelName_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagModelNumber                      = { g_rgchTagModelNumber, g_rgchTagModelNumber_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagHardwareID                         = { g_rgchTagHardwareID, g_rgchTagHardwareID_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURIRSASHA1                          = { g_rgchURIRSASHA1, g_rgchURIRSASHA1_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURIRSASHA1_Old                      = { g_rgchURIRSASHA1_Old, g_rgchURIRSASHA1_Old_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagReference                        = { g_rgchTagReference, g_rgchTagReference_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagTransforms                       = { g_rgchTagTransforms, g_rgchTagTransforms_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagTransform                        = { g_rgchTagTransform, g_rgchTagTransform_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCert                  = { g_rgchURITransformMSCert, g_rgchURITransformMSCert_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCertColl              = { g_rgchURITransformMSCertColl, g_rgchURITransformMSCertColl_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURITransformMSCert_Old              = { g_rgchURITransformMSCert_Old, g_rgchURITransformMSCert_Old_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURITransformC14N                    = { g_rgchURITransformC14N, g_rgchURITransformC14N_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertificate                 = { g_rgchTagWMDRMCertificate, g_rgchTagWMDRMCertificate_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMData                        = { g_rgchTagDataWMDRM, g_rgchTagDataWMDRM_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertPublicKey               = { g_rgchTagWMDRMCertPublicKey, g_rgchTagWMDRMCertPublicKey_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSecurityVersion         = { g_rgchTagWMDRMCertSecurityVersion, g_rgchTagWMDRMCertSecurityVersion_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSecurityLevel           = { g_rgchTagWMDRMCertSecurityLevel, g_rgchTagWMDRMCertSecurityLevel_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertSerialNumber            = { g_rgchTagWMDRMCertSerialNumber, g_rgchTagWMDRMCertSerialNumber_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertFeatures                = { g_rgchTagWMDRMCertFeatures, g_rgchTagWMDRMCertFeatures_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagWMDRMCertKeyUsage                = { g_rgchTagWMDRMCertKeyUsage, g_rgchTagWMDRMCertKeyUsage_LEN };

const DRM_ANSI_CONST_STRING  g_dastrTagSignature                        = { g_rgchTagSignature, g_rgchTagSignature_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagSignatureMethod                  = { g_rgchTagSignatureMethod, g_rgchTagSignatureMethod_LEN };
const DRM_ANSI_CONST_STRING  g_dastrTagSignedInfo                       = { g_rgchTagSignedInfo, g_rgchTagSignedInfo_LEN };
const DRM_ANSI_CONST_STRING  g_dastrURIC14N                             = { g_rgchURIC14N, g_rgchURIC14N_LEN };
const DRM_ANSI_CONST_STRING  g_dastrVersionWMDRM                        = { g_rgchVersionWMDRM, g_rgchVersionWMDRM_LEN };
const DRM_ANSI_CONST_STRING  g_dastrWMDRMCertExponent                   = { g_rgchWMDRMCertExponent, g_rgchWMDRMCertExponent_LEN };


const DRM_ANSI_CONST_STRING  g_dastrFeatureSampleProtection             = { g_rgchFeatureSampleProtection, g_rgchFeatureSampleProtection_LEN };
const DRM_ANSI_CONST_STRING  g_dastrFeatureExport                       = { g_rgchFeatureExport, g_rgchFeatureExport_LEN };
const DRM_ANSI_CONST_STRING  g_dastrFeatureExportIncl                   = { g_rgchFeatureExportIncl, g_rgchFeatureExportIncl_LEN};

const DRM_ANSI_CONST_STRING  g_dastrPrefixMicrosoftCert                 = { g_rgchPrefixMicrosoftCert, g_rgchPrefixMicrosoftCert_LEN };

const DRM_ANSI_CONST_STRING  g_dastrMSRootPubKey                        = { g_rgchMSRootPubKey, g_rgchMSRootPubKey_LEN };

/* Secure clock Challenge\response XML tags */
const DRM_CONST_STRING      g_dstrTagDRMReqRoot                         = CREATE_DRM_STRING( g_rgwchTagDRMReqRoot );
const DRM_CONST_STRING      g_dstrResponse                              = CREATE_DRM_STRING( g_rgwchResponse );
const DRM_CONST_STRING      g_dstrStatus                                = CREATE_DRM_STRING( g_rgwchStatus );
const DRM_CONST_STRING      g_dstrFlag                                  = CREATE_DRM_STRING( g_rgwchFlag );
const DRM_CONST_STRING      g_dstrTagGmtTime                            = CREATE_DRM_STRING( g_rgwchTagGmtTime );
const DRM_CONST_STRING      g_dstrTagRefreshDate                        = CREATE_DRM_STRING( g_rgwchTagRefreshDate );

/* Output Level strings */
const DRM_CONST_STRING      g_dstrLabelGuid                             = CREATE_DRM_STRING( g_rgwchLabelGuid );
const DRM_CONST_STRING      g_dstrLabelLevel                            = CREATE_DRM_STRING( g_rgwchLabelLevel );
const DRM_CONST_STRING      g_dstrTagUncompressedDigitalVideo           = CREATE_DRM_STRING( g_rgwchTagUncompressedDigitalVideo );
const DRM_CONST_STRING      g_dstrTagCompressedDigitalVideo             = CREATE_DRM_STRING( g_rgwchTagCompressedDigitalVideo );
const DRM_CONST_STRING      g_dstrTagUncompressedDigitalAudio           = CREATE_DRM_STRING( g_rgwchTagUncompressedDigitalAudio );
const DRM_CONST_STRING      g_dstrTagCompressedDigitalAudio             = CREATE_DRM_STRING( g_rgwchTagCompressedDigitalAudio );
const DRM_CONST_STRING      g_dstrTagAnalogVideo                        = CREATE_DRM_STRING( g_rgwchTagAnalogVideo );
const DRM_CONST_STRING      g_dstrTagCopy                               = CREATE_DRM_STRING( g_rgwchTagCopy );
const DRM_CONST_STRING      g_dstrTagExtensionList                      = CREATE_DRM_STRING( g_rgwchTagExtensionList );
const DRM_CONST_STRING      g_dstrTagExtension                          = CREATE_DRM_STRING( g_rgwchTagExtension );
const DRM_CONST_STRING      g_dstrTagIncludeList                        = CREATE_DRM_STRING( g_rgwchTagIncludeList );
const DRM_CONST_STRING      g_dstrTagInclude                            = CREATE_DRM_STRING( g_rgwchTagInclude );
const DRM_CONST_STRING      g_dstrTagExcludeList                        = CREATE_DRM_STRING( g_rgwchTagExcludeList );
const DRM_CONST_STRING      g_dstrTagExclude                            = CREATE_DRM_STRING( g_rgwchTagExclude );

const DRM_CONST_STRING      g_dstrMSRootPubKey                          = CREATE_DRM_STRING( g_rgwchMSRootPubKey );


/* License State strings */
const DRM_CONST_STRING      g_dstrTagLicenseStateRequestRoot            = CREATE_DRM_STRING( g_rgwchTagLicenseStateRequestRoot );
const DRM_CONST_STRING      g_dstrTagCanBind                            = CREATE_DRM_STRING( g_rgwchTagCanBind );


/*Device License Revocation Blob Strings*/

const DRM_CONST_STRING      g_dstrTagDeviceLicenseRevocationRoot        = CREATE_DRM_STRING( g_rgwchTagDeviceLicenseRevocationRoot );
const DRM_CONST_STRING      g_dstrTagRevocationPubKey                   = CREATE_DRM_STRING( g_rgwchTagRevocationPubKey );


#if DRM_SUPPORT_REVOCATION
/* Revocation GUIDs */

const DRM_GUID g_guidRevocationTypeRevInfo = {
    0xCCDE5A55, 
    0xA688, 
    0x4405, 
    { 
        TWO_BYTES( 0xA8, 0x8B ), TWO_BYTES( 0xD1, 0x3F ),
        TWO_BYTES( 0x90, 0xD5 ), TWO_BYTES( 0xBA, 0x3E )
    }
};

#if DRM_SUPPORT_WMDRMNET
const DRM_GUID g_guidRevocationTypeWMDRMNET = {
    0xCD75E604, 
    0x543D, 
    0x4A9C, 
    { 
        TWO_BYTES( 0x9F, 0x09 ), TWO_BYTES( 0xFE, 0x6D ),
        TWO_BYTES( 0x24, 0xE8 ), TWO_BYTES( 0xBF, 0x90 )
    }
};
#endif /* DRM_SUPPORT_WMDRMNET */ 

#if DRM_SUPPORT_DEVICE_REVOCATION
const DRM_GUID g_guidRevocationTypeDevice = {
    0x3129E375, 
    0xCEB0, 
    0x47D5, 
    { 
        TWO_BYTES( 0x9C, 0xCA ), TWO_BYTES( 0x9D, 0xB7 ),
        TWO_BYTES( 0x4C, 0xFD ), TWO_BYTES( 0x43, 0x32 )
    }
};
#endif /* DRM_SUPPORT_DEVICE_REVOCATION */

#if DRM_SUPPORT_APP_REVOCATION
const DRM_GUID g_guidRevocationTypeApp = {
    0x90A37313, 
    0x0ECF, 0x4CAA, 
    {
        TWO_BYTES( 0xA9, 0x06 ), TWO_BYTES( 0xB1, 0x88 ),
        TWO_BYTES( 0xF6, 0x12 ), TWO_BYTES( 0x93, 0x00 )
    }
};
#endif /* DRM_SUPPORT_APP_REVOCATION */

#endif /* DRM_SUPPORT_REVOCATION */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmdes.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMDES_H__
#define __DRMDES_H__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _destable
{
	DRM_DWORD keytab[16][2];
} DESTable;

#define DES_TABLESIZE	SIZEOF(DESTable)
#define DES_BLOCKLEN	8
#define DES_KEYSIZE		8

#define DES_ENCRYPT     1
#define DES_DECRYPT     0


/*********************************************************************
**
**  Function:  deskey
**
**  Synopsis:  Fill in the DESTable struct with the decrypt and encrypt
**	           key expansions.
**
**	           Assumes that the second parameter points to DES_KEYSIZE
**             bytes of key.
**
**  Arguments:  
**     [pTable] -- A DESTable structure that will be filled according to the DES key-schedule algorithm.
**     [rgbKey] -- The DES symmetric key to be used.
**
**  Returns:  None
**
*********************************************************************/

DRM_VOID DRM_API DRM_DES_KeySetup(
    OUT       DESTable *pTable,
    IN  const DRM_BYTE  rgbKey[__CB_DECL(DES_KEYSIZE)] );


/*********************************************************************
**
**  Function:  DRM_DES_Cipher
**
**  Synopsis:  
**
**  Arguments:  
**     [rgbIn] -- Array of bytes to encrypt
**     [rgbOut] -- Encrypted array of bytes
**     [pTable] -- DES table initialized by DRM_DES_KeySetup
**     [op] -- Operation to perform ( DES_ENCRYPT or DES_DECRYPT )
**
**  Returns:  None
**
*********************************************************************/

DRM_VOID DRM_API DRM_DES_Cipher(
    IN const DRM_BYTE  rgbIn [__CB_DECL(DES_BLOCKLEN)],
    OUT      DRM_BYTE  rgbOut[__CB_DECL(DES_BLOCKLEN)],
    IN       DESTable *pTable,
    IN       DRM_INT   op);


#define DRM_DES_Encrypt( x, y, z ) \
    DRM_DES_Cipher( (x), (y), (z), DES_ENCRYPT )

#define DRM_DES_Decrypt( x, y, z ) \
    DRM_DES_Cipher( (x), (y), (z), DES_DECRYPT )

#ifdef __cplusplus
}
#endif

#endif /* __DRMDES_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmdevcert.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMDEVCERTPARSER_H__
#define __DRMDEVCERTPARSER_H__


#include <drmbase64.h>

#ifdef __cplusplus
extern "C" {
#endif


typedef enum
{
    DRM_DEVCERT_SERIALNUMBER = 1,       /* CERTIFICATE type="DEVICE"/DATA/UNIQUEID */
    DRM_DEVCERT_DEVICEPUBKEY,           /* CERTIFICATE type="DEVICE"/DATA/PUBLICKEY */
    DRM_DEVCERT_DEVICEPRIVKEY,          /* CERTIFICATE type="DEVICE"/DATA/PRIVATEKEY */
    DRM_DEVCERT_DEVICEDATANODE,         /* CERTIFICATE type="DEVICE"/DATA */ 
    DRM_DEVCERT_DEVICESIGNATURE,        /* CERTIFICATE type="DEVICE"/MSDRM_SIGNATURE_VALUE */
    DRM_DEVCERT_COMPATIBILITYVERSION,   /* FALLBACK/SECURITYVERSION */
    DRM_DEVCERT_COMPATIBILITYCERT,      /* FALLBACK/CERTIFICATE */
    DRM_DEVCERT_SECURECLOCK,            /* CERTIFICATE type="GROUP"/DATA/FEATURE/CLOCK */
    DRM_DEVCERT_SECURECLOCKURL,         /* CERTIFICATE type="GROUP"/DATA/FEATURE/SECURECLOCK/URL */
    DRM_DEVCERT_SECURECLOCKPUBKEY,      /* CERTIFICATE type="GROUP"/DATA/FEATURE/SECURECLOCK/PUBLICKEY */
    DRM_DEVCERT_METERING,               /* CERTIFICATE type="GROUP"/DATA/FEATURE/METERING */
    DRM_DEVCERT_LICENSEACQUISITIONMODE, /* CERTIFICATE type="GROUP"/DATA/FEATURE/LICENSE_ACQ */
    DRM_DEVCERT_LICENSESYNCMODE,        /* CERTIFICATE type="GROUP"/DATA/FEATURE/LICENSE_SYNC */
    DRM_DEVCERT_SYMMETRICOPTIMIZATIONS, /* CERTIFICATE type="GROUP"/DATA/FEATURE/SYMMETRIC_OPT */
    DRM_DEVCERT_ENCRYPTION,             /* CERTIFICATE type="GROUP"/DATA/FEATURE/ENCRYPTION */
    DRM_DEVCERT_MAXCHAINDEPTH,          /* CERTIFICATE type="GROUP"/DATA/LIMITS/MAXCHAINDEPTH */
    DRM_DEVCERT_MAXLICENSESIZE,         /* CERTIFICATE type="GROUP"/DATA/LIMITS/MAXLICENSESIZE */
    DRM_DEVCERT_MAXHEADERSIZE,          /* CERTIFICATE type="GROUP"/DATA/LIMITS/MAXHEADERSIZE */
    DRM_DEVCERT_GROUPSECURITYLEVEL,     /* CERTIFICATE type="GROUP"/DATA/SECURITYLEVEL */
    DRM_DEVCERT_GROUPCERTPUBKEY,        /* CERTIFICATE type="GROUP"/DATA/PUBLICKEY */
    DRM_DEVCERT_GROUPCERTDATANODE,      /* CERTIFICATE type="GROUP"/DATA */ 
    DRM_DEVCERT_GROUPCERTSIGNATURE,     /* CERTIFICATE type="GROUP"/MSDRM_SIGNATURE_VALUE */
    DRM_DEVCERT_DACSECURITYLEVEL,       /* CERTIFICATE type="AUTHORIZATION"/DATA/SECURITYLEVEL */
    DRM_DEVCERT_SUBJECTID,              /* CERTIFICATE type="AUTHORIZATION"/DATA/AUTH_ID */
    DRM_DEVCERT_DACPUBKEY,              /* CERTIFICATE type="AUTHORIZATION"/DATA/PUBLICKEY */
    DRM_DEVCERT_DACDATANODE,            /* CERTIFICATE type="AUTHORIZATION"/DATA */
    DRM_DEVCERT_DACSIGNATURE,           /* CERTIFICATE type="AUTHORIZATION"/MSDRM_SIGNATURE_VALUE */
    DRM_DEVCERT_DACROOTPUBKEY,          /* CERTIFICATE type="AUTHORIZATION_ROOT"/DATA/PUBLICKEY */
    DRM_DEVCERT_AUTHROOTDATANODE,       /* CERTIFICATE type="AUTHORIZATION_ROOT"/DATA */
    DRM_DEVCERT_AUTHROOTSIGNATURE,      /* CERTIFICATE type="AUTHORIZATION_ROOT"/MSDRM_SIGNATURE_VALUE */
    DRM_DEVCERT_ATTRIB_OTHER
} eDRM_DEVCERT_ATTRIBUTES;


#define DRM_FEATURE_METERING                0x1
#define DRM_FEATURE_ANTI_ROLLBACK_CLOCK     0x2
#define DRM_FEATURE_SECURE_CLOCK            0x4


typedef struct __tagDRM_DEVICE_CERTIFICATE_CACHED_VALUES
{
    DRM_DWORD appSec;
    DRM_DWORD appcd_subject;
    DRM_DWORD dwFeatureFlags;
    PUBKEY    pubkeyCurrent;
    PUBKEY    pubkeySecureClockServer;
    PKCERT    m_BBCompatibilityCert;
    DRM_BYTE  m_blobDevicePrivkey[__CB_DECL( SIZEOF(PRIVKEY) )];
    DRM_WCHAR wszLegacyVersion[VER_STRING_MAX_LEN];    /* If this device supports a legacy blackbox number and key.  This will be filled in from the devcert */
} DRM_DEVICE_CERTIFICATE_CACHED_VALUES;


/* Get attribute from given devcert */
DRM_RESULT DRM_API DRM_DCP_GetAttribute(
    IN const DRM_CONST_STRING        *f_pdstrDevCert,          /* devcert */
    IN       eDRM_DEVCERT_ATTRIBUTES  f_eAttribute,            /* devcert attr to get */
       OUT   DRM_CONST_STRING        *f_pdstrNode,             /* extracted attr node with <node> tag */
       OUT   DRM_CONST_STRING        *f_pdstrValue);

#define DRM_DCP_VERIFY_DEVICE_CERT  1
#define DRM_DCP_VERIFY_GROUP_CERT   2
#define DRM_DCP_VERIFY_DAC          4

#define DRM_DCP_VERIFY_ENTIRE_DEVCERT (DRM_DCP_VERIFY_DEVICE_CERT \
                                     | DRM_DCP_VERIFY_GROUP_CERT  \
                                     | DRM_DCP_VERIFY_DAC)

DRM_RESULT DRM_API DRM_DCP_VerifyDeviceCert(
    IN const DRM_CONST_STRING   *f_pdstrDevCert,
    IN       DRM_DWORD           f_dwVerifyFlags,
    IN       DRM_CRYPTO_CONTEXT *f_pcontextCRYP );

DRM_RESULT DRM_API DRM_DCP_LoadPropertiesCache(
    IN const DRM_CONST_STRING                      *f_pdstrDevCert,
       OUT   DRM_DEVICE_CERTIFICATE_CACHED_VALUES  *f_pcacheDevCert,
    IN       DRM_CRYPTO_CONTEXT                    *f_pcontextCRYP );

#define DRM_DCP_CREATE_DEVCERT_IF_NOT_EXISTING  1
#define DRM_DCP_VERIFY_DEVCERT                  2


DRM_RESULT DRM_API DRM_DDC_GetDeviceCertificate(
    IN OUT DRM_STRING         *f_pdstrDevCert,
    IN     DRM_DWORD           f_dwFlags,
    IN OUT DRM_CRYPTO_CONTEXT *f_pcontextCRYP );

#ifdef __cplusplus
}
#endif


#endif /* __DRMDEVCERTPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmdevcertacq.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMDEVCERTACQ_H__
#define __DRMDEVCERTACQ_H__


#ifdef __cplusplus
extern "C" {
#endif


/**********************************************************************
** Function:    DRM_DevCert_ProcessResponse
** Synopsis:    Process devcert request response received from server
** Arguments:   [pbResponse] -- Response string received from server
**              [cbResponse] -- size of pbResponse in bytes.
**              [pResult] --pointer to DRM_RESULT to get error from server included in response
**              [pcontextCrypto] --pointer to the DRM_CRYPTO_CONTEXT
** Returns:     DRM_SUCCESS on success, or failed with 
**              DRM_E_INVALIDARG,
**              DRM_E_INVALIDDEVICECERTIFICATE.
**
***********************************************************************/
DRM_RESULT DRM_API DRM_DCA_ProcessResponse(
    IN  DRM_BYTE           *pbResponse,
    IN  DRM_DWORD           cbResponse,
    OUT DRM_RESULT         *pResult,
    IN  DRM_CRYPTO_CONTEXT *pcontextCrypto );

/**********************************************************************
** Function:    DRM_DevCert_CreateChallenge
** Synopsis:    Creates a devcert challenge.
** Arguments:   
**              [pdstrDevCertTemplate] -- pointer to Signed DevCert Template drm string
**              [poSignKey] -- pointer to a Bootstrap private key to sign challenge.
**              [pcontextCrypto] -- pointer to DRM_CRYPTO_CONTEXT
**              [pwszUrl] -- user allocated buffer to get URL in WCHAR
**              [pcchUrl] -- pointer to get size of URL. Can be NULL if URL is not required.
**              [pbData] -- user allocated buffer to be used as output buffer
**              [pcbData] -- size of pbData
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL
** Notes:       To get the minimum size required, first call with pbData=NULL and
**              pcbData points to value 0. This will return DRM_E_BUFFERTOOSMALL 
**              and pcbData will point to a value of minimum context size.
***********************************************************************/
DRM_RESULT DRM_API DRM_DCA_CreateChallenge(
    IN const DRM_CONST_STRING   *pdstrDevCertTemplate,
    IN const PRIVKEY            *poSignKey,
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto, 
       OUT   DRM_WCHAR          *pwszUrl,
    IN OUT   DRM_DWORD          *pcchUrl,
       OUT   DRM_BYTE           *pbData,
    IN OUT   DRM_DWORD          *pcbData );


#ifdef __cplusplus
}
#endif


#endif /* __DRMDEVCERTACQ_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmerr.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMERR_H__
#define __DRMERR_H__

#define ChkDR(expr) {               \
            dr = (expr);            \
            if ( DRM_FAILED(dr) )   \
            {                       \
                goto ErrorExit;     \
            }                       \
        }

#define ChkMem(expr) {               \
            if ( NULL == (expr) )    \
            {                        \
                TRACE( ("Allocation failure at %s : %d.\n%s\n", __FILE__, __LINE__, #expr) ); \
                dr = DRM_E_OUTOFMEMORY; \
                goto ErrorExit;     \
            }                       \
        }

#define ChkArg(expr) {               \
            if ( !(expr) )       \
            {                       \
                TRACE( ("Invalid argument at %s : %d.\n%s\n", __FILE__, __LINE__, #expr) ); \
                dr = DRM_E_INVALIDARG; \
                goto ErrorExit;     \
            }                       \
        }

#define ChkDRMString(s) {    \
            if ( !(s) || (s)->pwszString==NULL || (s)->cchString==0 )   \
            {                       \
                TRACE( ("Invalid argument at %s : %d.\n%s\n", __FILE__, __LINE__, #s) ); \
                dr = DRM_E_INVALIDARG; \
                goto ErrorExit;     \
            }                       \
        }

#define ChkWR(expr) {               \
            if (!(expr))            \
            {\
                dr = HRESULT_FROM_WIN32(GetLastError());\
                goto ErrorExit;     \
            }\
        }

#define ChkBOOL(fExpr,err){  \
            if (!(fExpr))            \
            {\
                dr = (err);\
                goto ErrorExit;     \
            }\
        }

#define ChkFAIL(expr) ChkBOOL(expr,DRM_E_FAIL)

#define ChkDRContinue(exp) \
{                          \
    dr=(exp);              \
    if (DRM_FAILED (dr))   \
    {                      \
        continue;          \
    }                      \
}    

#define SAFE_CHKDR_GETLASTERROR                         \
    {                                                   \
        ChkDR( HRESULT_FROM_WIN32( GetLastError( ) ) ); \
        ChkDR( E_UNEXPECTED );                          \
    }

#endif /* __DRMERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmexpreval.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmexpreval.h>
#include <oemimpl.h>
#include "drmexprfunc.h"

/* Operators we don't care to support anymore: */
/* ++, --, %, unary +, unary - */
/* maybe ! */

/* Supported functions */
/* exists, dateadd, datediff, datepart, min, max, long */
/* string, versioncompare, datetime, index, length, deletelicense */

#define DRM_E_NO_MORE_TOKENS DRM_RESULT_FROM_WIN32( 259L )


static DRM_RESULT PerformOperation(
    TOKEN             *pOperator,
    EXPR_EVAL_CONTEXT *pEEContext);

/* Stub'd functions */
static DRM_RESULT EvalVariable(
    TOKEN             *pToken,
    EXPR_EVAL_CONTEXT *pEEContext)
{
    TOKEN Token;
    DRM_RESULT dr = DRM_SUCCESS;

    ChkDR( pEEContext->GetVariable( &(pToken->val.stringValue), &Token, pEEContext->pvOpaqueData ) );
    MEMCPY( pToken, &Token, SIZEOF( TOKEN ) );

ErrorExit:
    return dr;
}

static DRM_BOOL IsOperand(DRM_EXPR_TOKEN_TYPE TokenType)
{
    return ( 
        TokenType == TOKEN_VARIABLE ||
        TokenType == TOKEN_STRING   ||
        TokenType == TOKEN_LONG     ||
        TokenType == TOKEN_DATETIME
        );
}

static DRM_BOOL IsPreUnaryOp(DRM_EXPR_TOKEN_TYPE TokenType)
{
    return ( 
        TokenType == TOKEN_PLUS     ||
        TokenType == TOKEN_MINUS    ||
        TokenType == TOKEN_NOT      ||
        TokenType == TOKEN_PREINCR  ||
        TokenType == TOKEN_PREDECR  ||
        TokenType == TOKEN_FUNCTION
        );
}

static DRM_BOOL IsBinaryOp( DRM_EXPR_TOKEN_TYPE TokenType)
{
    return ( 
        TokenType == TOKEN_ADD     ||
        TokenType == TOKEN_SUB     ||
        TokenType == TOKEN_MUL     ||
        TokenType == TOKEN_DIV     ||
        TokenType == TOKEN_MOD     ||
        TokenType == TOKEN_ASSIGN  ||
        TokenType == TOKEN_LESS    ||
        TokenType == TOKEN_LESSEQ  ||
        TokenType == TOKEN_GREAT   ||
        TokenType == TOKEN_GREATEQ ||
        TokenType == TOKEN_NOTEQ   ||
        TokenType == TOKEN_EQ      ||
        TokenType == TOKEN_AND     ||
        TokenType == TOKEN_OR      ||
        TokenType == TOKEN_IF      ||
        TokenType == TOKEN_COLON   ||
        TokenType == TOKEN_COMMA   ||
        TokenType == TOKEN_SEMICOLON
        );
}

DRM_RESULT DRM_API ExtractStringToken( 
    DRM_CONST_STRING *pdstrExpression,
    TOKEN            *pToken )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    const DRM_WCHAR* pwcStart = NULL;

    pwcStart = pdstrExpression->pwszString;       /* Now we are at the start of a token. */
    /* Loop until matching one is found. Don't forget escape symbol \. */
    /* First we need to keep track of the count to allocate space.         */
    while( pdstrExpression->cchString && *(pdstrExpression->pwszString) != g_wchQuote && *(pdstrExpression->pwszString) != g_wchNewLine ) 
    { 

        if (*(pdstrExpression->pwszString) == g_wchBackSlash && pdstrExpression->cchString > 1)
        {
            /* Escape character followed by a non-null character. */
            pdstrExpression->pwszString += 2;
            pdstrExpression->cchString  -= 2;
        }
        else
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString --;            
        }
    }
    if ( *(pdstrExpression->pwszString) != g_wchQuote)
    {
        dr = CPRMEXP_STRING_UNTERMINATED;
        goto ErrorExit;
    }

    /* Skip the ending quote.          */
    pToken->val.stringValue.pwszString = pwcStart;
    pToken->val.stringValue.cchString = (DRM_DWORD) ( pdstrExpression->pwszString - pwcStart );

    pdstrExpression->pwszString++;
    pdstrExpression->cchString--;

ErrorExit:
    return dr;

}

DRM_RESULT DRM_API ExtractLongToken( 
    DRM_CONST_STRING *pdstrExpression, 
    TOKEN            *pToken )
{
    DRM_RESULT  dr           = DRM_SUCCESS;
    DRM_BOOL    bSkipRest    = FALSE;
    DRM_BOOL    bHexNumber   = FALSE;
    DRM_LONG    lBase        = 10;
    DRM_LONG    lNextDigit   = 0;
    DRM_UINT    iHexCount    = 0;    

    pToken->TokenType = TOKEN_LONG;
    
    if ( *(pdstrExpression->pwszString) == g_wch0 )
    {
        /* Check if it is a hex number. */
        if ( pdstrExpression->cchString > 1 && 
            ( *(pdstrExpression->pwszString +1 ) == g_wchx || *(pdstrExpression->pwszString +1 ) == g_wchX ) )
        {
            lBase = 16;
            bHexNumber = TRUE;
            pdstrExpression->pwszString += 2;
            pdstrExpression->cchString -= 2;
            pToken->val.lValue = 0;
            if ( pdstrExpression->cchString > 0 && !iswxdigit( *( pdstrExpression->pwszString ) ) )
            {
                dr = CPRMEXP_INVALID_CONSTANT;
                goto ErrorExit;
            }
        }
        else
        {
            pToken->val.lValue = 0;
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
        }
    }
    else if ( !iswdigit( *( pdstrExpression->pwszString ) ) )
    {
        dr = CPRMEXP_INVALID_CONSTANT;
        goto ErrorExit;
    }
    else
    {
        pToken->val.lValue = ( NATIVE_WCHAR(*(pdstrExpression->pwszString)) - NATIVE_WCHAR(g_wch0));
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }

    while( pdstrExpression->cchString > 0 && 
            ( iswdigit( *( pdstrExpression->pwszString ) ) || 
                ( bHexNumber && iswxdigit( *(pdstrExpression->pwszString) ) ) 
            ) 
         )
    {

        if (iswdigit( *(pdstrExpression->pwszString) ) )
        {
            lNextDigit = (NATIVE_WCHAR(*(pdstrExpression->pwszString)) - NATIVE_WCHAR(g_wch0));
        }
        else
        {
            lNextDigit = (NATIVE_WCHAR(towlower(*(pdstrExpression->pwszString))) - NATIVE_WCHAR(g_wcha)) + 10;
        }
        if (!bSkipRest && bHexNumber && iHexCount < (SIZEOF(DRM_LONG)*CHAR_BIT)/4)
        {
            iHexCount++;
            pToken->val.lValue = (pToken->val.lValue << 4) | lNextDigit; 
        }
        else if (!bSkipRest && !bHexNumber && pToken->val.lValue <= ((LONG_MAX - lNextDigit) / lBase) )
        {
            pToken->val.lValue = lBase * pToken->val.lValue + lNextDigit;
        }
        else if (!bSkipRest)
        {
            bSkipRest = TRUE; /* To ensure that this part is done only once per integer. */
            /* Must be overflow. Flag it for error. */
            dr = CPRMEXP_OVERFLOW;
            /* Continue to process the integer to consume the rest of the digits. */
        }
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }

    if( pdstrExpression->cchString == 0 && bHexNumber )
    {
        /* 
           There is a case that if the entire string ends with "... 0x" we could let 0x be treated as a valid number 0.  
           Just make sure this doesn't happen
        */
        /* It is also safe to reference the string pointer -1 because we know we have seen at least the 0x characters */
        if( *(pdstrExpression->pwszString - 1 ) == g_wchx || 
            *(pdstrExpression->pwszString - 1 ) == g_wchX   )
        {
            /* The last character was an x or X */
            dr = CPRMEXP_INVALID_CONSTANT;
            goto ErrorExit;
        }
    }

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API ExtractSymbolToken( 
    DRM_CONST_STRING *pdstrExpression,
    TOKEN            *pToken )
{
    const DRM_WCHAR* pwcStart    = NULL;
    DRM_RESULT dr = DRM_SUCCESS;

    pwcStart = pdstrExpression->pwszString;
    while ( pdstrExpression->cchString > 0 &&
            ( iswalpha( *(pdstrExpression->pwszString) ) || 
            iswdigit( *(pdstrExpression->pwszString) ) || 
            *(pdstrExpression->pwszString)== g_wchPeriod || 
            *(pdstrExpression->pwszString)== g_wchUnderscore) )
    {
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }

    pToken->val.stringValue.pwszString = pwcStart;
    pToken->val.stringValue.cchString = (DRM_DWORD) ( pdstrExpression->pwszString - pwcStart );

    /* Check if it is a function symbol or a variable */
    /* Function symbol must follow (. Look ahead for (.     */
    while ( pdstrExpression->cchString > 0 &&
            iswspace(*(pdstrExpression->pwszString ) ) )
    {
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }
    if ( pdstrExpression->cchString > 0 && *(pdstrExpression->pwszString) == g_wchOpenParen )
    {        
        if (IsValidFunction(&(pToken->val.stringValue), &( pToken->val.fnValue ) ) )
        {
            pToken->TokenType = TOKEN_FUNCTION;     
        }
        else
        {
            dr = CPRMEXP_INVALID_FUNCTION;                
        }
    }
    else
    {
        pToken->TokenType = TOKEN_VARIABLE;
    }

    return dr;
}


DRM_RESULT DRM_API ExtractDateToken( 
    DRM_CONST_STRING *pdstrExpression,
    TOKEN            *pToken)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRMSYSTEMTIME Date;
    DRMFILETIME   filetime;

    ZEROMEM(&Date, SIZEOF(Date));
    if( pdstrExpression->cchString < 11 ) /* Minimum of 11 characters */
    {
        return DRM_E_INVALIDARG;
    }

    pToken->TokenType = TOKEN_DATETIME;

    if ( *(pdstrExpression->pwszString) != g_wchPound)
    {
        dr = CPRMEXP_INVALID_CONSTANT;
        goto ErrorExit;
    }    
    
    pdstrExpression->pwszString++; /*Consume # */
    pdstrExpression->cchString--;

    if ( iswdigit(*(pdstrExpression->pwszString)) && 
         iswdigit(*(pdstrExpression->pwszString+1)) && 
         iswdigit(*(pdstrExpression->pwszString+2)) && 
         iswdigit(*(pdstrExpression->pwszString+3)) )
    {
        /* We got YYYY             */
        Date.wYear = ( NATIVE_WCHAR(*(pdstrExpression->pwszString  )) - NATIVE_WCHAR(g_wch0)) * 1000 + 
                     ( NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0)) * 100 + 
                     ( NATIVE_WCHAR(*(pdstrExpression->pwszString+2)) - NATIVE_WCHAR(g_wch0)) * 10 +
                     ( NATIVE_WCHAR(*(pdstrExpression->pwszString+3)) - NATIVE_WCHAR(g_wch0));
        pdstrExpression->pwszString += 4;
        pdstrExpression->cchString -= 4;
    }
    else
    {
        dr = CPRMEXP_INVALID_CONSTANT;
        goto ErrorExit;
    }

    /* Next we should have MM */
    if ( iswdigit( *(pdstrExpression->pwszString) ) && iswdigit( *(pdstrExpression->pwszString+1) ) )
    {
        /* We got MM */
        Date.wMonth = ( NATIVE_WCHAR(*(pdstrExpression->pwszString  )) - NATIVE_WCHAR(g_wch0) ) * 10 +
                      ( NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0) );
        pdstrExpression->pwszString += 2;
        pdstrExpression->cchString -= 2;
    }
    else
    {
        dr = CPRMEXP_INVALID_CONSTANT;
        goto ErrorExit;
    }
    /* Next we should have DD */
    if ( iswdigit( *(pdstrExpression->pwszString) ) && iswdigit( *(pdstrExpression->pwszString+1) ) )
    {
        /* We got DD */
        Date.wDay = ( NATIVE_WCHAR(*(pdstrExpression->pwszString  )) - NATIVE_WCHAR(g_wch0) ) * 10 + 
                    ( NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0) );            
        pdstrExpression->pwszString += 2;
        pdstrExpression->cchString -= 2;
    }
    else
    {
        dr = CPRMEXP_INVALID_CONSTANT;
        goto ErrorExit;
    }
    /* Now we expect a space or Z */
    if ( *(pdstrExpression->pwszString) != g_wchSpace && *(pdstrExpression->pwszString) != g_wchZ )
    {
        dr = CPRMEXP_INVALID_CONSTANT;
    }
    else
    {
        if (*(pdstrExpression->pwszString) == g_wchSpace)
        {            
            pdstrExpression->pwszString++; /* If it was a space, skip. */
            pdstrExpression->cchString--;
        }
        /* Now we expect optional time fields */
        if ( pdstrExpression->cchString > 2 &&
            iswdigit(*(pdstrExpression->pwszString)) && 
            iswdigit(*(pdstrExpression->pwszString+1)) )
        {
            /* We got HH. */
            Date.wHour =  (NATIVE_WCHAR(*(pdstrExpression->pwszString  )) - NATIVE_WCHAR(g_wch0)) * 10 
                         +(NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0));            
            pdstrExpression->pwszString += 2;
            pdstrExpression->cchString -= 2;
            /* We look for :MM only if we got HH */
            if ( pdstrExpression->cchString >3 &&
                *(pdstrExpression->pwszString) == g_wchColon && 
                iswdigit(*(pdstrExpression->pwszString+1)) && 
                iswdigit(*(pdstrExpression->pwszString+2)) )
            {
                Date.wMinute = (NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0)) * 10 
                             + (NATIVE_WCHAR(*(pdstrExpression->pwszString+2)) - NATIVE_WCHAR(g_wch0));
                pdstrExpression->pwszString += 3;
                pdstrExpression->cchString -=3;
                /* We look for :SS only if we got MM */
                if (pdstrExpression->cchString >3 &&
                    *(pdstrExpression->pwszString) == g_wchColon && 
                    iswdigit(*(pdstrExpression->pwszString+1)) && 
                    iswdigit(*(pdstrExpression->pwszString+2)) )
                {
                    Date.wSecond = (NATIVE_WCHAR(*(pdstrExpression->pwszString+1)) - NATIVE_WCHAR(g_wch0)) * 10 
                                 + (NATIVE_WCHAR(*(pdstrExpression->pwszString+2)) - NATIVE_WCHAR(g_wch0));
                    pdstrExpression->pwszString += 3;
                    pdstrExpression->cchString -=3;
                }                
            }
        }
        /* Now we must see the closing Z# symbols */
        if ( pdstrExpression->cchString <2 || *(pdstrExpression->pwszString) != g_wchZ)
        {
            dr = CPRMEXP_INVALID_CONSTANT;
            goto ErrorExit;
        }
        pdstrExpression->pwszString++; /* Consume Z */
        pdstrExpression->cchString--;
        if (*(pdstrExpression->pwszString) != g_wchPound)
        {
            dr = CPRMEXP_INVALID_CONSTANT;
            goto ErrorExit;
        }
        pdstrExpression->pwszString++; /* Consume # */
        pdstrExpression->cchString--;
    }
    if (!OEM_SystemTimeToFileTime(&Date, &filetime))
    {
        dr = CPRMEXP_INVALID_CONSTANT; /* One or more fields in the date must be invalid. */
        goto ErrorExit;
    }
    FILETIME_TO_UI64( filetime, pToken->val.u64DateTime );
ErrorExit:
    return dr;
}

static DRM_RESULT GetToken( 
    DRM_CONST_STRING    *pdstrExpression,
    TOKEN               *pToken, 
    DRM_EXPR_TOKEN_TYPE *psLastToken)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BOOL fFound;    

    /* Skip whitespace */
    while ( pdstrExpression->cchString && iswspace(*(pdstrExpression->pwszString)))
    {
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }

    if ( pdstrExpression->cchString == 0 )
    {
        /* We are at the end of buffer. No more args. */
        dr = DRM_E_NO_MORE_TOKENS;
        goto ErrorExit;
    }

    fFound = TRUE;
    if( *(pdstrExpression->pwszString) == g_wchOpenParen )
    {
        (*pToken).TokenType = TOKEN_OPEN;
    }
    else if( *(pdstrExpression->pwszString) == g_wchCloseParen )
    {
        (*pToken).TokenType = TOKEN_CLOSE;
    }
    else if( *(pdstrExpression->pwszString) == g_wchComma )
    {
        (*pToken).TokenType = TOKEN_COMMA;
    }
    else if( *(pdstrExpression->pwszString) == g_wchAsterisk)
    {
        (*pToken).TokenType = TOKEN_MUL;
    }
    else if( *(pdstrExpression->pwszString) == g_wchForwardSlash )
    {
        (*pToken).TokenType = TOKEN_DIV;
    }
    else if( *(pdstrExpression->pwszString) == g_wchPercent )
    {
        (*pToken).TokenType = TOKEN_MOD;
    }
    else if( *(pdstrExpression->pwszString) == g_wchColon )
    {
        (*pToken).TokenType = TOKEN_COLON;
    }
    else if( *(pdstrExpression->pwszString) == g_wchQuestionMark )
    {
        (*pToken).TokenType = TOKEN_IF;
    }
    else if( *(pdstrExpression->pwszString) == g_wchSemiColon )
    {
        (*pToken).TokenType = TOKEN_SEMICOLON;
    }
    else if( *(pdstrExpression->pwszString) == g_wchExclamationMark )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchEqual )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_NOTEQ;
        }
        else
        {
            (*pToken).TokenType = TOKEN_NOT;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchEqual )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchEqual )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_EQ;
        }
        else
        {
            (*pToken).TokenType = TOKEN_ASSIGN;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchLessThan )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchEqual )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_LESSEQ;
        }
        else
        {
            (*pToken).TokenType = TOKEN_LESS;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchGreaterThan )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchEqual )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_GREATEQ;
        }
        else
        {
            (*pToken).TokenType = TOKEN_GREAT;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchAmpersand )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchAmpersand )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_AND;
        }
        else
        {
            (*pToken).TokenType = TOKEN_UNKNOWN;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchPipe )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchPipe )
        {
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            (*pToken).TokenType = TOKEN_OR;
        }
        else
        {
            (*pToken).TokenType = TOKEN_UNKNOWN;
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchPlus )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchPlus )
        {
            /* It is an increment operator. Determine if it is pre or post. */
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            if (*psLastToken == TOKEN_VARIABLE || *psLastToken == TOKEN_CLOSE) 
            {
                (*pToken).TokenType = TOKEN_POSTINCR;
            }
            else
            {
                (*pToken).TokenType = TOKEN_PREINCR;
            }					 
        }
        else if (*psLastToken == TOKEN_LONG || *psLastToken == TOKEN_STRING || *psLastToken == TOKEN_DATETIME || 
            *psLastToken == TOKEN_VARIABLE || *psLastToken == TOKEN_CLOSE ||
            *psLastToken == TOKEN_POSTINCR || *psLastToken == TOKEN_POSTDECR)
        {
            (*pToken).TokenType = TOKEN_ADD;	/* Binary operator */
        }
        else
        {
            (*pToken).TokenType = TOKEN_PLUS; /*Unary operator */
        }
    }
    else if( *(pdstrExpression->pwszString) == g_wchMinus )
    {
        if( pdstrExpression->cchString > 1 &&
            pdstrExpression->pwszString[1] == g_wchMinus )
        {
            /* It is an increment operator. Determine if it is pre or post. */
            pdstrExpression->pwszString++;
            pdstrExpression->cchString--;
            if (*psLastToken == TOKEN_VARIABLE || *psLastToken == TOKEN_CLOSE) 
            {
                (*pToken).TokenType = TOKEN_POSTDECR;
            }
            else
            {
                (*pToken).TokenType = TOKEN_PREDECR;
            }					 
        }
        else if (*psLastToken == TOKEN_LONG || *psLastToken == TOKEN_STRING || *psLastToken == TOKEN_DATETIME || 
            *psLastToken == TOKEN_VARIABLE || *psLastToken == TOKEN_CLOSE ||
            *psLastToken == TOKEN_POSTINCR || *psLastToken == TOKEN_POSTDECR)
        {
            (*pToken).TokenType = TOKEN_SUB;	/* Binary operator */
        }
        else
        {
            (*pToken).TokenType = TOKEN_MINUS; /*Unary operator */
        }
    }
    else
    {
        fFound = FALSE;
    }

    if( fFound )
    {
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
        goto ErrorExit;
    }

    /* We have not identified this token yet -- it's obviously not an operator.  Let's see if we can figure 
    it out */   

    if (*(pdstrExpression->pwszString) == g_wchQuote) 
    { 
        /* String Constant */
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
        dr = ExtractStringToken( pdstrExpression, pToken );
        (*pToken).TokenType = TOKEN_STRING;
    } 
    else if (iswdigit(*(pdstrExpression->pwszString)))
    {
        (*pToken).TokenType = TOKEN_LONG;
        dr = ExtractLongToken( pdstrExpression, pToken );
    }
    else if (iswalpha(*(pdstrExpression->pwszString)))
    {
        /* This could be either a function or a variable */
        dr = ExtractSymbolToken( pdstrExpression, pToken );
    }
    else if (*(pdstrExpression->pwszString) == g_wchPound)
    {		
        dr = ExtractDateToken( pdstrExpression, pToken);
        (*pToken).TokenType = TOKEN_DATETIME;
    }
    else
    {
        /* This must be an invalid character. */
        dr = CPRMEXP_INVALID_TOKEN;
        pdstrExpression->pwszString++;
        pdstrExpression->cchString--;
    }

ErrorExit:
    *psLastToken = (*pToken).TokenType;
    return (dr);
}


static DRM_LONG InputPrecedence(DRM_EXPR_TOKEN_TYPE tokenType)
{
    switch(tokenType)
    {
    case TOKEN_OPEN:
        return(1000);
    case TOKEN_CLOSE:
        return(0);
    case TOKEN_FUNCTION:
        return(300);
    case TOKEN_POSTINCR:
    case TOKEN_POSTDECR:
        return(220);
    case TOKEN_NOT:
    case TOKEN_PREINCR:
    case TOKEN_PREDECR:
    case TOKEN_PLUS:
    case TOKEN_MINUS:
        return(200);
    case TOKEN_MUL:
    case TOKEN_DIV:
    case TOKEN_MOD:
        return(180);
    case TOKEN_ADD:
    case TOKEN_SUB:
        return(160);
    case TOKEN_LESS:
    case TOKEN_GREAT:
    case TOKEN_LESSEQ:
    case TOKEN_GREATEQ:
        return(140);
    case TOKEN_EQ:
    case TOKEN_NOTEQ:
        return(120);
    case TOKEN_AND:
        return(100);
    case TOKEN_OR:
        return(80);
    case TOKEN_IF:
        return(60);
    case TOKEN_COLON:
        return(25);               
    case TOKEN_ASSIGN:
        return(50);
    case TOKEN_SEMICOLON:
        return(20);
    case TOKEN_COMMA:
        return(10);
    }
    return (-1000); /* Should not happen. */
}

static DRM_LONG StackPrecedence(DRM_EXPR_TOKEN_TYPE tokenType)
{

    switch(tokenType)
    {
    case TOKEN_OPEN:
        return(-1);
    case TOKEN_CLOSE:
        return(0);
    case TOKEN_FUNCTION:
        return(300);
    case TOKEN_POSTINCR:
    case TOKEN_POSTDECR:
        return(220);
    case TOKEN_NOT:
    case TOKEN_PREINCR:
    case TOKEN_PREDECR:
    case TOKEN_PLUS:
    case TOKEN_MINUS:
        return(190);
    case TOKEN_MUL:
    case TOKEN_DIV:
    case TOKEN_MOD:
        return(180);
    case TOKEN_ADD:
    case TOKEN_SUB:
        return(160);
    case TOKEN_LESS:
    case TOKEN_GREAT:
    case TOKEN_LESSEQ:
    case TOKEN_GREATEQ:
        return(140);
    case TOKEN_EQ:
    case TOKEN_NOTEQ:
        return(120);
    case TOKEN_AND:
    case TOKEN_ANDSKIP:
        return(100);
    case TOKEN_OR:
    case TOKEN_ORSKIP:
        return(80);
    case TOKEN_IF:
    case TOKEN_IFSKIP:
        return(22);
    case TOKEN_COLON:
    case TOKEN_COLONSKIP:
        return(25);
    case TOKEN_ASSIGN:
        return(30);
    case TOKEN_SEMICOLON:
        return(20);
    case TOKEN_COMMA:
        return(10);
    }
    return(-1000); /* Should not happen. */
}

static DRM_RESULT TokenStackPush( 
    TOKEN      rgTokenStack[],
    DRM_DWORD *pdwStackHead, 
    TOKEN     *pNewToken )
{
    if( *pdwStackHead == DRM_EXPR_EVAL_MAX_TOKEN_STACK_SIZE )
    {
        /* The stack is full.  Fail */
        return DRM_E_OUTOFMEMORY;
    }
    MEMCPY( &(rgTokenStack[*pdwStackHead]), pNewToken, SIZEOF( TOKEN ) );
    *pdwStackHead += 1;
    return DRM_SUCCESS;
}

static DRM_RESULT TokenStackPop( 
    TOKEN      rgTokenStack[],
    DRM_DWORD *pdwStackHead, 
    TOKEN     *pNewToken )
{
    if( *pdwStackHead == 0 )
    {
        return CPRMEXP_MISSING_OPERAND;
    }
    *pdwStackHead -= 1;
    MEMCPY( pNewToken, &(rgTokenStack[*pdwStackHead]), SIZEOF( TOKEN ) );
    return DRM_SUCCESS;
}

DRM_RESULT DRM_API DRM_EXPR_EvaluateExpression(
    IN const DRM_CONST_STRING  *pdstrExpression, 
    IN OUT   EXPR_EVAL_CONTEXT *pEEContext, 
       OUT   TOKEN             *ptResult )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrExpression = EMPTY_DRM_STRING;
    TOKEN Token, newToken;
    DRM_EXPR_TOKEN_TYPE sLastToken = TOKEN_UNKNOWN;
    DRM_LONG lRank = 0;		/* Rank will tell us if we have operands to gether without operators or operators that are stranded */
    DRM_LONG lInputPrecedence = 0;   
    
    ChkDRMString( pdstrExpression );
    ChkArg( pEEContext && ptResult );

    ZEROMEM( &(pEEContext->ExprEvalData), SIZEOF( pEEContext->ExprEvalData ) );
    ASSIGN_DRM_STRING( dstrExpression, *pdstrExpression );    
    for( dr = GetToken( &dstrExpression, &Token, &sLastToken ); DRM_SUCCEEDED( dr ); dr = GetToken( &dstrExpression, &Token, &sLastToken ) )
    {		
        if (Token.TokenType == TOKEN_UNKNOWN)
        {
            dr = CPRMEXP_INVALID_TOKEN;
            goto ErrorExit;
        }

        if (IsOperand(Token.TokenType))
        {
            lRank++;
        }
        else if (IsBinaryOp(Token.TokenType))
        {
            lRank--;
        }
        /* Now check the rank. It should always be 0 or 1 */
        if (lRank != 0 && lRank != 1)
        {            
            dr = CPRMEXP_ISOLATED_OPERAND_OR_OPERATOR;
            goto ErrorExit;
        }

        /* If it is an operand, push onto the operand stack. */
        if (IsOperand(Token.TokenType))
        {
            ChkDR( TokenStackPush( pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &Token ) );
            ZEROMEM( &Token, SIZEOF( Token ) );
            continue;		
        }
        /* If it is ), then pop all operators of higher precedence in stack and perform operation. */
        if (Token.TokenType == TOKEN_CLOSE)
        {
            lInputPrecedence = InputPrecedence(TOKEN_CLOSE);
            while ( 0 < pEEContext->ExprEvalData.dwOperatorStack && 
                StackPrecedence(pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType) >= lInputPrecedence)	/* Loop through operators in the stack and perform the operations if their precedence is right */
            {
                
                ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperatorTokenStack, &( pEEContext->ExprEvalData.dwOperatorStack ), &newToken ) );
                ChkDR( PerformOperation(&newToken, pEEContext ) );
                /* &pEEContext->ExprEvalData.rgOperandTokenStack, &pEEContext->ExprEvalData.rgOperatorTokenStack, &fShortCircuit, pEEContext->pvOpaqueData); */
                if (newToken.TokenType == TOKEN_FUNCTION)
                {
                    /* It was a function call. Rand must be 0 or 1. It will be 0 if it was a function call with 0 args.  */
                    /* We need to set rank to 1. */
                    if (Arity(newToken.val.fnValue) == 0)
                    {
                        lRank++;
                    }					
                }
            }
            if (0 == pEEContext->ExprEvalData.dwOperatorStack || 
                pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_OPEN)
            {
                dr = CPRMEXP_UNMATCHED;
                goto ErrorExit;
            }

            /* Pop and discard the token TOPEN. Here the stack must be non-empty and has TOPEN. */
            ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperatorTokenStack, &( pEEContext->ExprEvalData.dwOperatorStack ), &newToken ) );

            /* Check if the ) we are processing corresponds to the one closing a function call. If so, execute the function. */
            if ( 0 != pEEContext->ExprEvalData.dwOperatorStack)
            {				
                if (pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType == TOKEN_FUNCTION)
                {
                    ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperatorTokenStack, &( pEEContext->ExprEvalData.dwOperatorStack ), &newToken ) );
                    dr = PerformOperation(&newToken, pEEContext );
                     /*&pEEContext->ExprEvalData.rgOperandTokenStack, &pEEContext->ExprEvalData.rgOperatorTokenStack, &fShortCircuit, pEEContext->pvOpaqueData); */
                    if( DRM_FAILED( dr ) )
                    {
                        goto ErrorExit;
                    }
                    /* It was a function call. Rank must be 0 or 1. It will be 0 if it was a function call with 0 args.  */
                    /* We need to set rank to 1. */
                    if (Arity(newToken.val.fnValue) == 0)
                    {
                        lRank++;
                    }					
                }
            }
            ZEROMEM( &Token, SIZEOF( Token ) );
            continue;
        }

        /* It must be an operator or TOKEN_OPEN. Pop all operators of higher precedence and perform op.                 */
        lInputPrecedence = InputPrecedence(Token.TokenType);
        while (0 != pEEContext->ExprEvalData.dwOperatorStack && 
            StackPrecedence(pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType) >= lInputPrecedence)
        {
            ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperatorTokenStack, &( pEEContext->ExprEvalData.dwOperatorStack ), &newToken ) );
            dr = PerformOperation(&newToken, pEEContext );
            if( DRM_FAILED( dr ) )
            {
                goto ErrorExit;
            }
            /* The stackOp cannot be a function symbol here. No need to check for it like in other places. */
        }

        /* Push the new operator onto the stack. Do not delete the token as it lives in stack. */
        /* Take care of && || ? and :.  */
        if ( pEEContext->ExprEvalData.fShortCircuit )
        {
            /* We are in skip mode in this section. */
            /* Simply push the corresponding token. */
            switch(Token.TokenType)
            {
            case TOKEN_AND:
                Token.TokenType = TOKEN_ANDSKIP;
                break;
            case TOKEN_OR:
                Token.TokenType = TOKEN_ORSKIP;
                break;
            case TOKEN_IF:
                Token.TokenType = TOKEN_IFSKIP;
                break;
            case TOKEN_COLON:
                if ( 0 == pEEContext->ExprEvalData.dwOperatorStack || 
                    ( pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_IF && 
                    pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_IFSKIP 
                    ) 
                    )
                {                    
                    dr = CPRMEXP_UNMATCHED;
                    goto ErrorExit;
                }
                if (pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType == TOKEN_IF)
                {
                    pEEContext->ExprEvalData.fShortCircuit = FALSE; /* Then part skipping is over. We are at the begining of else part. Turn eval on. */
                    Token.TokenType = TOKEN_COLON;
                }
                else
                {
                    Token.TokenType = TOKEN_COLONSKIP;    /* The matching ? was found in skip mode. */
                }                          
            }
        }
        else
        {
            /* We are in evaluation mode in this section. */
            if (Token.TokenType == TOKEN_AND ||
                Token.TokenType == TOKEN_OR  ||
                Token.TokenType == TOKEN_IF)
            {
                /* Pop an operand and evaluate before proceeding. This is for shortcut or conditional evaluation. */
                dr = TokenStackPop( pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &newToken );
                if ( DRM_FAILED( dr ) )
                {
                    dr = CPRMEXP_MISSING_OPERAND;
                    goto ErrorExit;
                }
                if ( newToken.TokenType == TOKEN_VARIABLE)
                {
                    dr = EvalVariable(&newToken, pEEContext);    /* This can change the type of NODE after evaluation */
                    if( DRM_FAILED( dr ) )
                    {
                        goto ErrorExit;
                    }
                }
                if ( newToken.TokenType != TOKEN_LONG )
                {
                    dr = CPRMEXP_WRONG_TYPE_OPERAND;
                    goto ErrorExit;
                }
                if ( ( Token.TokenType == TOKEN_AND && newToken.val.lValue == 0 ) ||
                     ( Token.TokenType == TOKEN_OR  && newToken.val.lValue == 1  ) ||
                     ( Token.TokenType == TOKEN_IF  && newToken.val.lValue == 0  ) )
                {
                    pEEContext->ExprEvalData.fShortCircuit = TRUE;
                }
                ChkDR( TokenStackPush( pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &newToken) );
            }
            else if (Token.TokenType == TOKEN_COLON)
            {
                /* It is ':'. The stack must have matching ?.  */
                if (0 == pEEContext->ExprEvalData.dwOperatorStack || 
                    pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_IF)
                {					
                    dr = CPRMEXP_UNMATCHED;
                    goto ErrorExit;
                }
                pEEContext->ExprEvalData.fShortCircuit = TRUE; /* fShortCircuit is FALSE currently. Which means we got then part. We need to skip else part.                 */
            }
        }

        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperatorTokenStack, &( pEEContext->ExprEvalData.dwOperatorStack ), &Token) );
        
        if (Token.TokenType == TOKEN_FUNCTION)
        {
            /* Push TOKEN_FUNCTIONSYNC token into the operand stack.             */
            ZEROMEM( &Token, SIZEOF( TOKEN ) );
            Token.TokenType = TOKEN_FUNCTIONSYNC;
            ChkDR( TokenStackPush( pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Token) );
        }
        else if (IsPreUnaryOp(Token.TokenType))
        {
            /* Push TUNARYSYNC token into the operand stack. */
            ZEROMEM( &Token, SIZEOF( TOKEN ) );
            Token.TokenType = TOKEN_UNARYSYNC;
            ChkDR( TokenStackPush( pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Token) );
        }
        ZEROMEM( &Token, SIZEOF( Token ) );
    } /* for loop */


    if (dr == DRM_E_NO_MORE_TOKENS)
    {
        /* We have a valid expression. Clean up stack and return the result. */
        dr = DRM_SUCCESS; /* Reset dr value as it is now non-zero. */
        while (0 != pEEContext->ExprEvalData.dwOperatorStack )
        {
            ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperatorTokenStack, &(pEEContext->ExprEvalData.dwOperatorStack), &Token) );
            ChkDR( PerformOperation(&Token, pEEContext ) );
            /* ->ExprEvalData.rgOperandTokenStack, &pEEContext->ExprEvalData.rgOperatorTokenStack, &fShortCircuit, pEEContext->pvOpaqueData)); */
            if ( Token.TokenType == TOKEN_FUNCTION )
            {
                /* It was a function call. Rand must be 0 or 1. It will be 0 if it was a function call with 0 args.  */
                /* We need to set rank to 1. */
                if (Arity(Token.val.fnValue) == 0)
                {
                    lRank++;
                }					
            }
        }
        if ( 0 == pEEContext->ExprEvalData.dwOperandStack )
        {
            dr = CPRMEXP_NO_OPERANDS_IN_EXPRESSION;
            goto ErrorExit;
        }

        ChkDR( TokenStackPop( pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Token) );        

        if ( 0 != pEEContext->ExprEvalData.dwOperandStack )
        {
            dr = CPRMEXP_TOO_MANY_OPERANDS;
            goto ErrorExit;
        }

        /* At the end, lRank should be 1 for a valid expression. */
        if (lRank != 1)
        {
            dr = CPRMEXP_ISOLATED_OPERAND_OR_OPERATOR;
            goto ErrorExit;
        }

        /* At the end if the token is a variable, evaluate it and return that value */
        if (Token.TokenType == TOKEN_VARIABLE)
        {
            ChkDR( EvalVariable( &Token, pEEContext ) );
        }

        /* Examine the value of the node at this point.         */
        MEMCPY( ptResult, &Token, SIZEOF( TOKEN ) );
    }

ErrorExit:
    return dr;
}


/* PerformOperation & EvalVariable ( this is a big one with the different types of variables we might have. ) */

/* Peform the operation passed in the token. Do not delete the token. */
/* Stack of operands gets affected. Stack of operators may also get affected. */
/* This function can change operand stack, operator stack, state of fShortCircuit, will also need access to the expression string. */
DRM_RESULT PerformOperation(TOKEN *pOperator, EXPR_EVAL_CONTEXT* pEEContext)
{
    DRM_RESULT dr = DRM_SUCCESS;/*vinceyu:replaced CPRMEXP_NOERROR */
    TOKEN Operand1;
    TOKEN Operand2;    
    TOKEN OperandResult;    
    DRM_INT64 i64Value;
    
    ZEROMEM( &OperandResult, SIZEOF( TOKEN ) );
    OperandResult.TokenType = TOKEN_LONG;        
    switch(pOperator->TokenType)
    {
    case TOKEN_PLUS:
    case TOKEN_MINUS:
    case TOKEN_NOT:
        /* Unary operator. Pop one operand, perform operation, and push result back. */
        /* We should have TUNARYSYNC followed by operand. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );
        if (Operand1.TokenType == TOKEN_UNARYSYNC || Operand1.TokenType == TOKEN_FUNCTIONSYNC)
        {
            dr = CPRMEXP_MISSING_OPERAND;
            goto ErrorExit;
        }

        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
        if (Operand2.TokenType != TOKEN_UNARYSYNC)
        {
            dr = CPRMEXP_UNKNOWN_PARSE_ERROR; /* This should not really happen. */
            goto ErrorExit;        
        }

        if (!pEEContext->ExprEvalData.fShortCircuit)
        {
            /* Do the actual evaluation */
            if (Operand1.TokenType == TOKEN_VARIABLE)
            {
                ChkDR( EvalVariable( &Operand1, pEEContext) );
            }
            if ( Operand1.TokenType != TOKEN_LONG)
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }

            OperandResult.val.lValue = Operand1.val.lValue;
            if (pOperator->TokenType == TOKEN_MINUS)
            {
                i64Value = DRM_I64Sub(DRM_I64(0), DRM_I64(OperandResult.val.lValue) );

                if ( DRM_I64Les( DRM_I64(LONG_MAX), i64Value ) )
                {
                    dr = CPRMEXP_OVERFLOW;
                    goto ErrorExit;
                }
                else if ( DRM_I64Les( i64Value, DRM_I64(LONG_MIN)) )
                {
                    dr = CPRMEXP_UNDERFLOW;
                    goto ErrorExit;
                }
                OperandResult.val.lValue = DRM_I64ToUI32(i64Value);
            }
            else if (pOperator->TokenType == TOKEN_NOT)
            {
                OperandResult.val.lValue = !(OperandResult.val.lValue != 0);
            }
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_ADD:
    case TOKEN_SUB:
    case TOKEN_MUL:
    case TOKEN_DIV:
    case TOKEN_MOD:
        /* Binary arithmetic operators. TADD can also be used for strings. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );

        if (!pEEContext->ExprEvalData.fShortCircuit)
        {
            /* Perform the operation on the two operands and produce result. */
            if (Operand1.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand1, pEEContext));
            }
            if (Operand2.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand2, pEEContext));
            }
            if ( pOperator->TokenType != TOKEN_ADD && 
                ( Operand2.TokenType != TOKEN_LONG || Operand1.TokenType != TOKEN_LONG) )
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            else if (pOperator->TokenType == TOKEN_ADD && 
                !(
                (Operand2.TokenType == TOKEN_LONG && Operand1.TokenType == TOKEN_LONG) ||
                (Operand2.TokenType == TOKEN_STRING && Operand1.TokenType == TOKEN_STRING)
                )
                )

            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            switch(pOperator->TokenType)
            {
            case TOKEN_ADD:
                if (Operand2.TokenType == TOKEN_LONG)
                {
                    i64Value = DRM_I64Add( DRM_I64(Operand1.val.lValue), DRM_I64(Operand2.val.lValue) );

                    if ( DRM_I64Les( DRM_I64(LONG_MAX), i64Value ) )
                    {
                        dr = CPRMEXP_OVERFLOW;
                        goto ErrorExit;
                    }
                    else if ( DRM_I64Les( i64Value, DRM_I64(LONG_MIN) ) )
                    {
                        dr = CPRMEXP_UNDERFLOW;
                        goto ErrorExit;
                    }
                    OperandResult.val.lValue = DRM_I64ToUI32(i64Value);
                }
                else
                {
                    dr = CPRMEXP_WRONG_TYPE_OPERAND;
                    goto ErrorExit;
                }

                break;
            case TOKEN_SUB:
                i64Value = DRM_I64Sub( DRM_I64(Operand1.val.lValue), DRM_I64(Operand2.val.lValue) );
                if ( DRM_I64Les( DRM_I64(LONG_MAX), i64Value ) )
                {
                    dr = CPRMEXP_OVERFLOW;
                    goto ErrorExit;
                }
                else if ( DRM_I64Les( i64Value, DRM_I64(LONG_MIN) ) )
                {
                    dr = CPRMEXP_UNDERFLOW;
                    goto ErrorExit;
                }
                OperandResult.val.lValue = DRM_I64ToUI32(i64Value);
                break;
            case TOKEN_MUL:
                i64Value = DRM_I64Mul( DRM_I64(Operand1.val.lValue), DRM_I64(Operand2.val.lValue) );
                if ( DRM_I64Les( DRM_I64(LONG_MAX), i64Value ) )
                {
                    dr = CPRMEXP_OVERFLOW;
                    goto ErrorExit;
                }
                else if ( DRM_I64Les( i64Value, DRM_I64(LONG_MIN) ) )
                {
                    dr = CPRMEXP_UNDERFLOW;
                    goto ErrorExit;
                }
                OperandResult.val.lValue = DRM_I64ToUI32(i64Value);
                break;
            case TOKEN_DIV:
                if (Operand2.val.lValue == 0)
                {
                    dr = CPRMEXP_OVERFLOW;
                    goto ErrorExit;
                }
                OperandResult.val.lValue = Operand1.val.lValue / Operand2.val.lValue;
                break;
            case TOKEN_MOD:
                if (Operand2.val.lValue == 0)
                {
                    dr = CPRMEXP_OVERFLOW;
                    goto ErrorExit;
                }
                OperandResult.val.lValue = Operand1.val.lValue % Operand2.val.lValue;
            }
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_PREINCR:
    case TOKEN_POSTINCR:
    case TOKEN_PREDECR:
    case TOKEN_POSTDECR:
        /* Unary increment or decrement operator. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );

        if (pOperator->TokenType == TOKEN_PREINCR || pOperator->TokenType == TOKEN_PREDECR)
        {
            if (pOperator->TokenType == TOKEN_UNARYSYNC || pOperator->TokenType == TOKEN_FUNCTIONSYNC)
            {
                dr = CPRMEXP_MISSING_OPERAND;
                goto ErrorExit;
            }
            ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
            if (Operand2.TokenType != TOKEN_UNARYSYNC)
            {
                dr = CPRMEXP_UNKNOWN_PARSE_ERROR;
                goto ErrorExit;        
            }
        }

        if (!pEEContext->ExprEvalData.fShortCircuit)
        {
            /* The operand must be a varialble that can be set. */
            if (Operand1.TokenType != TOKEN_VARIABLE)
            {
                dr = CPRMEXP_VARIABLE_EXPECTED;
                goto ErrorExit;
            }            
            
            ZEROMEM( &Operand2, SIZEOF( TOKEN ) );

            ChkDR( pEEContext->GetVariable( &(Operand1.val.stringValue), &Operand2, pEEContext->pvOpaqueData ) );
            if (Operand2.TokenType != TOKEN_LONG)
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }          
            OperandResult.val.lValue = Operand2.val.lValue; /* For preincr or predecr. */
            /* Perform the incr or decr operation on the variable. */
            if (pOperator->TokenType == TOKEN_PREINCR || pOperator->TokenType == TOKEN_POSTINCR)
            {
                i64Value = DRM_I64Add( DRM_I64(Operand2.val.lValue), DRM_I64(1) );
            }
            else
            {
                i64Value = DRM_I64Sub( DRM_I64(Operand2.val.lValue), DRM_I64(1) );
            }
            if ( DRM_I64Les( DRM_I64(LONG_MAX), i64Value ) )
            {
                dr = CPRMEXP_OVERFLOW;
                goto ErrorExit;
            }
            else if ( DRM_I64Les( i64Value, DRM_I64(LONG_MIN) ) )
            {
                dr = CPRMEXP_UNDERFLOW;
                goto ErrorExit;
            }
            Operand2.val.lValue = DRM_I64ToUI32(i64Value);
            if (pOperator->TokenType == TOKEN_PREINCR || pOperator->TokenType == TOKEN_PREDECR)
            {
                OperandResult.val.lValue = Operand2.val.lValue;
            }
            ChkDR( pEEContext->SetVariable( &(Operand1.val.stringValue), &Operand2, NULL, pEEContext->pvOpaqueData) );
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_ASSIGN:
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );  /* The right side operand of = */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );  /* The left side operand (i.e variable) of = */

        /* The operand must be a varialble that can be set. */
        if (Operand1.TokenType != TOKEN_VARIABLE)
        {
            dr = CPRMEXP_VARIABLE_EXPECTED;
            goto ErrorExit;
        }        
        if (!pEEContext->ExprEvalData.fShortCircuit)
        {
            if (Operand2.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand2, pEEContext));
            }

            ZEROMEM( &OperandResult, SIZEOF( TOKEN ) );
            ChkDR( pEEContext->SetVariable( &(Operand1.val.stringValue), &Operand2, &OperandResult, pEEContext->pvOpaqueData ) );            
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_LESS:
    case TOKEN_GREAT:
    case TOKEN_LESSEQ:
    case TOKEN_GREATEQ:
    case TOKEN_NOTEQ:
    case TOKEN_EQ:
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );  /* The right side operand of comparison */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );  /* The left side operand of comparison */
        if (!pEEContext->ExprEvalData.fShortCircuit)
        {
            /* Perform the operation on the two operands and produce result. */
            if (Operand1.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand1, pEEContext));
            }
            if (Operand2.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand2, pEEContext));
            }
            if (Operand1.TokenType != Operand2.TokenType)
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            switch(pOperator->TokenType)
            {
            case TOKEN_LESS:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue < Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) < 0;
                }
                else
                {
                    OperandResult.val.lValue = DRM_UI64Les( Operand1.val.u64DateTime, Operand2.val.u64DateTime );
                }
                break;
            case TOKEN_GREAT:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue > Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) > 0;
                }
                else
                {
                    OperandResult.val.lValue = DRM_UI64Les( Operand2.val.u64DateTime, Operand1.val.u64DateTime );
                }
                break;
            case TOKEN_LESSEQ:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue <= Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) <= 0;
                }
                else
                {
                    OperandResult.val.lValue =   DRM_UI64Les( Operand1.val.u64DateTime, Operand2.val.u64DateTime ) 
                                              || DRM_UI64Eql( Operand1.val.u64DateTime, Operand2.val.u64DateTime );
                }
                break;
            case TOKEN_GREATEQ:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue >= Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) >= 0;
                }
                else
                {
                    OperandResult.val.lValue =   DRM_UI64Les( Operand2.val.u64DateTime, Operand1.val.u64DateTime ) 
                                              || DRM_UI64Eql( Operand1.val.u64DateTime, Operand2.val.u64DateTime );
                }
                break;
            case TOKEN_EQ:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue == Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) == 0;
                }
                else
                {
                    OperandResult.val.lValue =  DRM_UI64Eql( Operand1.val.u64DateTime, Operand2.val.u64DateTime );
                }
                break;
            case TOKEN_NOTEQ:
                if (Operand1.TokenType == TOKEN_LONG)
                {
                    OperandResult.val.lValue = Operand1.val.lValue != Operand2.val.lValue;
                }
                else if (Operand2.TokenType == TOKEN_STRING)
                {
                    OperandResult.val.lValue =  wcsncmp( Operand1.val.stringValue.pwszString, 
                                                         Operand2.val.stringValue.pwszString,
                                                         min( Operand1.val.stringValue.cchString, Operand2.val.stringValue.cchString) ) != 0;
                }
                else
                {
                    OperandResult.val.lValue =  !DRM_UI64Eql( Operand1.val.u64DateTime, Operand2.val.u64DateTime );
                }
                break;
            }
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_COMMA:
        /* It can occur only inside a function argument list.  */
        /* We define comma to be a no-op. Thus 2,3 will end up 2 3 on operand stack. */
        /* A comma has the lowest precedence just above ; and hence the expression */
        /* before comma is evaluated before proceeding. */
        /* Just make sure there are at least 2 operands for so we know they exist. */
        if( pEEContext->ExprEvalData.dwOperandStack < 2 )
        {
            ChkDR( CPRMEXP_MISSING_OPERAND );
        }
        break;        
    case TOKEN_FUNCTION:
        {
            /* Pop the number from arity stack to determine actual number of arguments. */
            DRM_DWORD dwIndex;
            DRM_LONG  lNumArgs = 0, lExpectedArgs = Arity(pOperator->val.fnValue);

            /* Search the stack array for the TOKEN_FUNCTIONSYNC token.               */
            for( dwIndex = pEEContext->ExprEvalData.dwOperandStack; dwIndex > 0; dwIndex-- )
            {
                if ( pEEContext->ExprEvalData.rgOperandTokenStack[dwIndex-1].TokenType == TOKEN_UNARYSYNC)
                {
                    dr = CPRMEXP_INCORRECT_NUM_ARGS;
                    goto ErrorExit;
                }

                if( pEEContext->ExprEvalData.rgOperandTokenStack[dwIndex-1].TokenType == TOKEN_FUNCTIONSYNC )
                {
                    /* We got all the arguments. Exit */
                    break;
                }

                lNumArgs++;
            }
            if (lNumArgs != lExpectedArgs)
            {
                /* Mismatch in # of expected and actual arguments. */
                dr = CPRMEXP_INCORRECT_NUM_ARGS;
                goto ErrorExit;
            }
            
            if (!pEEContext->ExprEvalData.fShortCircuit)
            {                
                dr = FunctionGetValue(pOperator, lNumArgs, &(pEEContext->ExprEvalData.rgOperandTokenStack[dwIndex]), &OperandResult, pEEContext );
                if ( DRM_FAILED( dr ) )
                {
                    goto ErrorExit; /* dr should indicate the reason for the failure. */
                }
            }
            /* Now pop all of the operands off the stack. */
            /* We could short circuit the stack logic and just overwrite the OperandStack counter variable */
            /* pEEContext->ExprEvalData.dwOperandStack -= (lNumArgs + 1); */
            for( ;lNumArgs > 0; lNumArgs-- )
            {
                ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
            }
            /* All function arguments have been poped.  Now pop the TOKEN_FUNCTIONSYNC */
            ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );

            ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
        }
    case TOKEN_AND:
    case TOKEN_OR:
        /* we turn the mode back on. */
        pEEContext->ExprEvalData.fShortCircuit = FALSE;
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );  /* The right side operand of comparison */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );  /* The left side operand of comparison */
        if (Operand1.TokenType != TOKEN_LONG)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        if (pOperator->TokenType == TOKEN_AND && Operand1.val.lValue == 0)
        {
            OperandResult.val.lValue = 0;
        }
        else if (pOperator->TokenType == TOKEN_OR && Operand1.val.lValue != 0)
        {
            OperandResult.val.lValue = 1;
        }
        else
        {
            if (Operand2.TokenType == TOKEN_VARIABLE)
            {
                ChkDR(EvalVariable(&Operand2, pEEContext));
            }
            if (Operand2.TokenType != TOKEN_LONG)
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            OperandResult.val.lValue = Operand2.val.lValue != 0;
        }
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );
        break;
    case TOKEN_ANDSKIP:
    case TOKEN_ORSKIP:
        /* We pop two operands. We should be in skip mode now. We don't turn it on. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );  /* The right side operand of comparison */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );  /* The left side operand of comparison */

        /* Popping both operands verify that there are two operands on stack. */
        /* We simply ignore the operands. We don't check the type for skipped section. */
        /* We can't check the type anyway without evaluating it and we don't want to evaluate. */
        /* For example, 1 || securestate.playcount. We don't know the type of variable until */
        /* evaluated. */
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Operand1) );
        break;
    case TOKEN_COLONSKIP:
        /* We need matchig TIF */
        if (pEEContext->ExprEvalData.dwOperatorStack == 0
         || pEEContext->ExprEvalData.rgOperatorTokenStack [pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_IFSKIP)
        {
            dr = CPRMEXP_UNMATCHED;
            goto ErrorExit;
        }
        /* Discard the operator */
        ChkDR(TokenStackPop (pEEContext->ExprEvalData.rgOperatorTokenStack,&(pEEContext->ExprEvalData.dwOperatorStack), &Operand1 ) );

        ChkDR(TokenStackPop (pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &OperandResult ) );
        ChkDR(TokenStackPop (pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
        ChkDR(TokenStackPop (pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );
        ChkDR(TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &(pEEContext->ExprEvalData.dwOperandStack), &Operand1) );
        break;
    case TOKEN_IFSKIP:
    case TOKEN_IF:
        dr = CPRMEXP_UNMATCHED; 
        break;
    case TOKEN_COLON:
        /* We need matchig TOKEN_IF */
        if (0 == pEEContext->ExprEvalData.dwOperatorStack || 
            pEEContext->ExprEvalData.rgOperatorTokenStack[pEEContext->ExprEvalData.dwOperatorStack - 1].TokenType != TOKEN_IF)
        {
            dr = CPRMEXP_UNMATCHED;
            goto ErrorExit;
        }
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperatorTokenStack,&(pEEContext->ExprEvalData.dwOperatorStack), &Operand1 ) );
        /* We pop three operands and do the right thing. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &OperandResult ) );
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );

        /* Operand1 should be an integer. Other two can be any type. */
        if (Operand1.TokenType == TOKEN_VARIABLE)
        {
            ChkDR(EvalVariable(&Operand1, pEEContext));
        }
        if (Operand1.TokenType != TOKEN_LONG)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }

        if (Operand1.val.lValue == 0)
        {
            /* Use the else part, which is oprnd3. */
            ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &OperandResult) );            
        }
        else
        {
            ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Operand2) );
        }
        pEEContext->ExprEvalData.fShortCircuit = FALSE; /* We are getting out of conditional expression. Turn back evaluation on. */
        break;
    case TOKEN_SEMICOLON:
        /* Pop the two operands and push the second operand back. */
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand2 ) );
        ChkDR( TokenStackPop(pEEContext->ExprEvalData.rgOperandTokenStack,&(pEEContext->ExprEvalData.dwOperandStack), &Operand1 ) );
        ChkDR( TokenStackPush(pEEContext->ExprEvalData.rgOperandTokenStack, &( pEEContext->ExprEvalData.dwOperandStack ), &Operand2) );
        break;
    case TOKEN_OPEN:
        dr = CPRMEXP_UNMATCHED; 
        break;
    default:
        ;
    }

ErrorExit:
    return(dr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmexprfunc.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_EXPR_FUNCTION_H__
#define __DRM_EXPR_FUNCTION_H__

#ifdef __cplusplus
extern "C" {
#endif

/* The public entry point */
DRM_RESULT DRM_API FunctionGetValue(
    IN  TOKEN             *pOperator, 
    IN  DRM_LONG           cArgs, 
    IN  TOKEN              rgArgs[], 
    OUT TOKEN             *pOperandResult, 
    IN  EXPR_EVAL_CONTEXT *pEEContext );

DRM_LONG DRM_API Arity(DRM_EXPR_FUNCTION_TYPE fnType);

DRM_BOOL DRM_API IsValidFunction(
    IN const DRM_CONST_STRING       *pdstrToken, 
    IN       DRM_DWORD              *pfnType);


#ifdef __cplusplus
}
#endif

#endif /*__DRM_EXPR_FUNCTION_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmgensyncchallenge.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmlicense.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmsyncstore.h>
#include <drmlicstore.h>
#include <drmxmlbuilder.h>
#include <drmcrt.h>
#include <oemimpl.h>

/* criteria of license search */

const DRM_CONST_STRING *g_apdstrActions [1] = { &g_dstrWMDRM_RIGHT_PLAYBACK };
       
extern DRM_RESULT _GetKIDStoreData(
    IN       DRM_SYNC_CONTEXT       *f_pcontextSYN,
    IN const DRM_KID                *f_pkid,
    IN       DRM_HDS_SLOT_HINT      *f_pslotHint,
       OUT   DRM_LICENSE_STATE_DATA *f_plsd);

extern DRM_RESULT _SetKIDStoreData(
    IN       DRM_SYNC_CONTEXT       *f_pcontextSYN,
    IN const DRM_KID                *f_pkid,
    IN       DRM_HDS_SLOT_HINT      *f_pslotHint,
    IN const DRM_LICENSE_STATE_DATA *f_plsd,
    IN       DRM_BOOL                f_fCreateIfNotExisting );

/*********************************************************************
 *            PRIVATE FUNCTION _RequiredCharsForChallenge
 *                                                                   
 *      function: determines required chars for challenge XML   
 ********************************************************************/

static DRM_DWORD
_RequiredCharsForChallenge(DRM_DWORD cKIDsIn)
{
    DRM_DWORD cchRequired = g_cbXMLBuilderMinimum;
    DRM_DWORD cchKID      = 0;

    /* <DRMSYNCLIST type="challenge"> */

    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagSyncList.cchString,  
                                               0, 
                                               g_dstrAttributeType.cchString,  
                                               g_dstrChallenge.cchString); 

    /* <RECORDS> */

    cchRequired += DRM_XMB_RequiredCharsForTag(g_dstrTagRecords.cchString,   
                                               0,  
                                               0,
                                               0);

    /* <KID value="base64"> */

    cchKID = DRM_XMB_RequiredCharsForTag(g_dstrTagSyncList.cchString, 
                                         0, 
                                         g_dstrLabelValue.cchString, 
                                         CCH_BASE64_EQUIV (SIZEOF (DRM_KID)));

    cchRequired += cKIDsIn * cchKID;

    return cchRequired;
} /* _RequiredCharsForChallenge */

/*********************************************************************
 *                    PRIVATE FUNCTION SyncCountTest
 *
 * purpose: compare license count to threshold criterion
 *********************************************************************/

static DRM_RESULT SyncCountTest(DRM_DWORD               cMaxCount, 
                                DRM_LICENSE_STATE_DATA *plsd,
                                DRM_BOOL               *pfRequired)
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg(plsd       != NULL
        && pfRequired != NULL);

    ChkArg(plsd->dwNumCounts >= 1);
    
    *pfRequired = (cMaxCount         == DRM_SYNC_IGNORE_THRESHOLD_PARAMETER
               ||  plsd->dwCount [0]  < cMaxCount);
         
ErrorExit:         
    return dr;         
}

/*********************************************************************
 *                    PRIVATE FUNCTION SyncExpirationTest
 *
 * purpose: compare indicated license date to threshold criterion
 *    note: iDate is an index into the LICENSE_STATE_DATA's array
 *          of date structures; the number of valid array member
 *          (and the interpretation of them) depends on the license
 *          state value
 *********************************************************************/

static DRM_RESULT SyncExpirationTest(DRM_DWORD               oHoursFromNow, 
                                     DRM_LICENSE_STATE_DATA *plsd,
                                     DRM_DWORD               iDate,
                                     DRM_BOOL               *pfSyncRequired,
                                     DRM_UINT64             *pui64ThresholdTime )
{        
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg(plsd != NULL);
    
    ChkArg(iDate <        plsd->dwNumDates
        && iDate < NO_OF (plsd->datetime)
        && pui64ThresholdTime != NULL )

    if (oHoursFromNow == DRM_SYNC_IGNORE_THRESHOLD_PARAMETER)
    {
        *pfSyncRequired = TRUE;
    }
    else if (plsd->dwNumDates >= (iDate + 1))
    {
        DRM_UINT64 ui64Zero = DRM_UI64LITERAL( 0, 0 );
        DRM_UINT64  u64lsdTime;

        /* 
        ** This calculation is cached between calls.  If the current value is 
        ** 0 calculate the correct value, otherwise we assume it is valid 
        */

        if (DRM_UI64Eql(*pui64ThresholdTime, ui64Zero))
        {
            DRMFILETIME filetime;

            OEM_GetDeviceTime(&filetime);
            FILETIME_TO_UI64(filetime, *pui64ThresholdTime);
            
            if (oHoursFromNow > 0)
            {
                /* one FILETIME tick is 10^-7 seconds */

                *pui64ThresholdTime = DRM_UI64Add(*pui64ThresholdTime, 
                                                   DRM_UI64Mul(DRM_UI64Mul(DRM_UI64(oHoursFromNow), DRM_UI64(3600)), 
                                                               DRM_UI64(10000000)));
            }                                                            
        }

        FILETIME_TO_UI64(plsd->datetime [iDate], u64lsdTime );
        if (DRM_UI64Les(u64lsdTime, *pui64ThresholdTime))
        {
            *pfSyncRequired = TRUE;
        }
    }

ErrorExit:
    return dr;
}

/*********************************************************************
 *                    PRIVATE FUNCTION _SyncRequired
 *
 * purpose: compare license data to threshold criteria
 *********************************************************************/

static DRM_BOOL _SyncRequired(DRM_DWORD               cMaxCountIn,
                              DRM_DWORD               cMaxHoursIn,
                              DRM_LICENSE_STATE_DATA *plsd,
                              DRM_UINT64             *pui64ThreshholdTime)
{
    DRM_BOOL   fSyncRequired = FALSE;
    DRM_RESULT dr            = DRM_SUCCESS;

    /* In theory we will never see this but it costs nothing to check for it */

    if (plsd->dwCategory == WM_DRM_LICENSE_STATE_UNLIM)
    {
        fSyncRequired =  FALSE;
    }
    else if (cMaxCountIn == DRM_SYNC_IGNORE_THRESHOLD_PARAMETER
         &&  cMaxHoursIn == DRM_SYNC_IGNORE_THRESHOLD_PARAMETER)
    {
        fSyncRequired =  TRUE;
    }
    else 
    {
        switch (plsd->dwCategory)
        {
        /* single-criterion cases */

        case WM_DRM_LICENSE_STATE_COUNT:
            ChkDR(SyncCountTest (cMaxCountIn, plsd, &fSyncRequired));
            break;

        case WM_DRM_LICENSE_STATE_UNTIL:
            ChkDR(SyncExpirationTest (cMaxHoursIn, plsd, 0, &fSyncRequired, pui64ThreshholdTime));
            break;

        /* don't sync yet if a license's FROM time hasn't started yet */

        case WM_DRM_LICENSE_STATE_FROM_UNTIL:
            ChkDR(SyncExpirationTest (cMaxHoursIn, plsd, 1, &fSyncRequired, pui64ThreshholdTime));
            break;

        case WM_DRM_LICENSE_STATE_COUNT_FROM: 
            ChkDR(SyncCountTest (cMaxCountIn, plsd, &fSyncRequired));
            break;

        case WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL:
                
            ChkDR(SyncCountTest (cMaxCountIn, plsd, &fSyncRequired));

            if (fSyncRequired == FALSE)
            {
                ChkDR(SyncExpirationTest (cMaxHoursIn, plsd, 1, &fSyncRequired, pui64ThreshholdTime));
            }
            break;

        /* count until: sync on either criterion */

        case WM_DRM_LICENSE_STATE_COUNT_UNTIL: 
            ChkDR(SyncExpirationTest (cMaxHoursIn, plsd, 0, &fSyncRequired, pui64ThreshholdTime));
            
            if (fSyncRequired == FALSE)
            {
                ChkDR(SyncCountTest (cMaxCountIn, plsd, &fSyncRequired));
            }
            break;

        /* on a one-use license, sync if that one use has happened */

        case WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE: 
            if (plsd->dwNumDates > 0)
            {
                ChkDR(SyncExpirationTest (cMaxHoursIn, plsd, 0, &fSyncRequired, pui64ThreshholdTime));
            }
            else
            {
                fSyncRequired = FALSE;
            }
            break;

        case WM_DRM_LICENSE_STATE_NORIGHT: 
            fSyncRequired = TRUE;
            break;

        case WM_DRM_LICENSE_STATE_FROM: 
            fSyncRequired = FALSE;
            break;
        }
    }
    
ErrorExit:
    return fSyncRequired;
} /* _SyncRequired */

static DRM_RESULT _GetKIDLicenseData (IN  DRM_HDS_CONTEXT         *f_pcontextHDSSlot,
                                      IN  DRM_VIEW_RIGHTS_CONTEXT *f_pcontextViewRightsIn,
                                      OUT DRM_LICENSE_STATE_DATA  *f_plsd)
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    ChkArg(f_pcontextHDSSlot      != NULL
        && f_pcontextViewRightsIn != NULL
        && f_plsd                 != NULL);
        
    ChkDR(DRM_ASD_GetLicenseAggregateData(g_apdstrActions, 
                                          f_plsd, 
                                          NO_OF (g_apdstrActions), 
                                          f_pcontextViewRightsIn, 
                                          f_pcontextHDSSlot,
                                          TRUE)); /* clean license store of expireds */
ErrorExit:
    return dr;
}

/*********************************************************************
 *                    PRIVATE FUNCTIONS _StoreRefreshRequired
 *
 * purpose: if this license is count-based, we will need to refresh 
 *          its data from the license store; counts can be decremented
 *          outside the control of the license store
 *********************************************************************/

static DRM_BOOL _StoreRefreshRequired (IN DRM_LICENSE_STATE_DATA *f_plsd)
{
    DRM_BOOL   fSyncRequired     = FALSE;
    DRM_UINT64 ui64ThresholdTime = DRM_UI64LITERAL(0, 0);
    
    if (f_plsd->dwCategory == WM_DRM_LICENSE_STATE_COUNT
    ||  f_plsd->dwCategory == WM_DRM_LICENSE_STATE_COUNT_FROM
    ||  f_plsd->dwCategory == WM_DRM_LICENSE_STATE_COUNT_FROM_UNTIL
    ||  f_plsd->dwCategory == WM_DRM_LICENSE_STATE_COUNT_UNTIL
    ||  f_plsd->dwCategory == WM_DRM_LICENSE_STATE_FORCE_SYNC)
    {
        fSyncRequired = TRUE;
    }
    else 
    {
        /* must refresh from the license store if it's expired */

        switch (f_plsd->dwCategory)
        {
        case WM_DRM_LICENSE_STATE_UNTIL:
            SyncExpirationTest (0, f_plsd, 0, &fSyncRequired, &ui64ThresholdTime);
            break;

        /* don't sync yet if a license's FROM time hasn't started yet */

        case WM_DRM_LICENSE_STATE_FROM_UNTIL:
            SyncExpirationTest (0, f_plsd, 1, &fSyncRequired, &ui64ThresholdTime);
            break;

        /* on a one-use license, sync if that one use has happened */

        case WM_DRM_LICENSE_STATE_EXPIRATION_AFTER_FIRSTUSE: 
            if (f_plsd->dwNumDates > 0)
            {
                SyncExpirationTest (0, f_plsd, 0, &fSyncRequired, &ui64ThresholdTime);
            }
            else
            {
                fSyncRequired = FALSE;
            }
            break;
        }
    }
    
    return fSyncRequired;
} /* _StoreRefreshRequired */


static DRM_RESULT _WriteKIDToList(
    IN const DRM_KID  *f_pkid,
    IN OUT   DRM_BYTE *f_pcontextXMB )
{
    DRM_RESULT       dr      = DRM_SUCCESS;
    DRM_WCHAR        awchKID [CCH_BASE64_EQUIV (SIZEOF (DRM_KID))];
    DRM_CONST_STRING dstrKID = EMPTY_DRM_STRING;
                
    dstrKID.pwszString =        awchKID;
    dstrKID.cchString  = NO_OF (awchKID);                        
                
    ChkDR(DRM_B64_EncodeW( (DRM_BYTE*)f_pkid, 
                   SIZEOF (DRM_KID), 
            (DRM_WCHAR *) dstrKID.pwszString, 
                         &dstrKID.cchString,
                          0));

    /* <KID value="base64"></KID> */

    ChkDR(DRM_XMB_WriteTag(f_pcontextXMB, 
                          &g_dstrTagKID, 
                           NULL, 
                          &g_dstrLabelValue, 
                          &dstrKID, 
                           wttClosed));
ErrorExit:
    return dr;
}


/******************************************************************************
** Function :   DRM_SNC_GenerateSyncChallenge
** 
** Synopsis :   two-step challenge generation
** 
** Arguments :  
** 
** [f_pcontextViewRights] - initialized view rights context
** [f_pcontextHDS]        - initialized HDS context context
** [f_pcontextStack]      - stack context
** [f_cMaxCount]          - maximum remaining playcount of licenses to include
** [f_cMaxHours]          - maximum remaining time before expiration to include
** [f_iKIDStart]          - index in the sync store to begin, 0-based
** [f_cKIDs]              - max number of KIDs to return
** [f_piKIDNext]          - points to DWORD to receive index of next KID in store
** [f_pcKIDs]             - points to DWORD to receive number of KIDs returned
** [f_pbChallenge]        - buffer for challenge
** [f_pcbChallenge]       - size of challenge buffer
******************************************************************************/

DRM_RESULT DRM_API DRM_SNC_GenerateSyncChallenge(
    IN     DRM_VIEW_RIGHTS_CONTEXT     *f_pcontextViewRights,
    IN     DRM_HDS_CONTEXT             *f_pcontextHDS,
    IN     DRM_STACK_ALLOCATOR_CONTEXT *f_pcontextStack,
    IN     DRM_DWORD                    f_cMaxCount,
    IN     DRM_DWORD                    f_cMaxHours,
    IN     DRM_DWORD                    f_iKIDStart,
    IN     DRM_DWORD                    f_cKIDs,
       OUT DRM_DWORD                   *f_piKIDNext,
       OUT DRM_DWORD                   *f_pcKIDs,
       OUT DRM_BYTE                    *f_pbChallenge,
    IN OUT DRM_DWORD                   *f_pcbChallenge)
{
    DRM_SYNC_CONTEXT       *pcontextSync       = NULL;
    DRM_SYNC_ENUM_CONTEXT  *pcontextSyncEnum   = NULL;
    DRM_UINT64              ui64ThreshholdTime = DRM_UI64LITERAL( 0, 0 );
    DRM_BYTE  *pbData        = NULL;             
    DRM_DWORD  cbAdjustment  = 0;    
    DRM_DWORD  iKIDCurrent   = 0;    
    DRM_DWORD  cchToClose    = 0;    
    DRM_DWORD  cchKID        = 0;    
    DRM_DWORD  cKIDs         = 0;    
    DRM_RESULT dr            = DRM_SUCCESS;
    DRM_BOOL   fOpenStoreSNC = FALSE;
    DRM_BOOL   fBuildList    = FALSE;
    DRM_BOOL   fContinue     = TRUE;
    DRM_BOOL   fOpenStoreLCS = FALSE;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_SNC_GenerateSyncChallenge", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
        
    ChkArg(f_pcontextViewRights != NULL
        && f_pcontextHDS        != NULL
        && f_pcbChallenge       != NULL
        && f_pcontextStack      != NULL);

    if (f_pcKIDs != NULL)
    {
        *f_pcKIDs = 0;
    }
    
    if (f_piKIDNext != NULL)
    {
        *f_piKIDNext = 0;
    }
    
#ifdef SIXTEEN_BIT_ADDRESSING
	pbData = f_pbChallenge;
#else
    /* some processors require WORD-alignment */

    if (f_pbChallenge != NULL)
    {
        ChkDR(DRM_UTL_EnsureDataAlignment(f_pbChallenge, 
                                         *f_pcbChallenge, 
                                         &pbData, 
                                          f_pcbChallenge, 
                                          SIZEOF (DRM_DWORD),
                                         &cbAdjustment));
    }
#endif
    
    /* allocate large variables */
    /* NOTE: stack in DRM_MGR call has been set to exactly this much stack and no more */

    ChkDR(DRM_STK_Alloc(f_pcontextStack, SIZEOF (DRM_SYNC_CONTEXT),      (DRM_VOID **) &pcontextSync));
    ChkDR(DRM_STK_Alloc(f_pcontextStack, SIZEOF (DRM_SYNC_ENUM_CONTEXT), (DRM_VOID **) &pcontextSyncEnum));

    ChkDR(DRM_LST_Open(f_pcontextViewRights->pbLicenseStore, f_pcontextHDS));

    fOpenStoreLCS = TRUE;
    
    ChkDR(DRM_SNC_OpenStore(f_pcontextHDS, pcontextSync));

    fOpenStoreSNC = TRUE;

    /* update any needed data from the license store and determine how many
       entries will be returned in XML */

/* enumerate the Key IDs in the sync store */

    ChkDR(DRM_SNC_InitEnum(pcontextSync, 
                           pcontextSyncEnum));

    /* enumerate the Key IDs in the synclist store and check them against 
       aggregated license data */

    if (*f_pcbChallenge  > 0
    &&   f_pbChallenge  != NULL)
    {
        /* <DRMSYNCLIST type="challenge"> */

        if (DRM_SUCCEEDED( DRM_XMB_CreateDocument(*f_pcbChallenge - cbAdjustment, pbData, &g_dstrTagSyncList) )
         && DRM_SUCCEEDED( DRM_XMB_AddAttribute  ( pbData, &g_dstrAttributeType, &g_dstrChallenge) )
         && DRM_SUCCEEDED( DRM_XMB_WriteTag      ( pbData, &g_dstrTagRecords, NULL, NULL, NULL, wttOpen) ) )
        {
            /* 3 = </> */
        
            cchToClose = g_dstrTagSyncList.cchString + 3
                       + g_dstrTagRecords .cchString + 3;

            cchKID     = DRM_XMB_RequiredCharsForTag(g_dstrTagKID.cchString, 
                                                     0, 
                                                     g_dstrLabelValue.cchString, 
                                                     CCH_BASE64_EQUIV(SIZEOF(DRM_KID)));
                       
            fBuildList = TRUE;
        }
    }

    while (fContinue)
    {
        DRM_LICENSE_STATE_DATA  lsd;
        DRM_HDS_SLOT_HINT       slotHint = {0};

        if (pbData != NULL)
        {
            DRM_DWORD cbRemaining = 0;
            
            ChkDR(DRM_XMB_RemainingBuffer(pbData, &cbRemaining));

            /* if we don't have enough buffer left for closing the challenge and one more KID, break the loop */

            if (cbRemaining < ((cchToClose + cchKID) * SIZEOF(DRM_WCHAR)))
            {
                break;
            }
        }
        
        dr = DRM_SNC_EnumNext(pcontextSyncEnum, 
                             &f_pcontextViewRights->KID,
                             &slotHint);

        if (dr == DRM_E_NOMORE)
        {
            dr = DRM_SUCCESS;
            break;
        }
        else
        {
            ChkDR(dr);
        }

        /* if we have not yet reached the first requested KID then proceed directly to the next enumeration */

        if (iKIDCurrent < f_iKIDStart)
        {
            iKIDCurrent++;
            continue;
        }

        if (iKIDCurrent >= (f_iKIDStart + f_cKIDs))
        {
            break;
        }

        iKIDCurrent++;

        /* get the current entry from the license store */

        ChkDR(_GetKIDStoreData(pcontextSync,
                              &f_pcontextViewRights->KID,
                              &slotHint,
                              &lsd));

        /* if this KID has count-based licenses we must refresh its data from the
        license store; date-based data will be updated along with licenses */

        if (_StoreRefreshRequired(&lsd))
        {
            ZEROMEM(&lsd, SIZEOF (lsd));

            if (DRM_FAILED(_GetKIDLicenseData(f_pcontextHDS,
                                              f_pcontextViewRights,
                                             &lsd)))
            {
                /* this license is probably deleted and so must be synced */

                if (fBuildList )
                {
                    if (DRM_FAILED( _WriteKIDToList( &f_pcontextViewRights->KID, f_pbChallenge ) ) )
                    {
                        fContinue = FALSE;
                    }
                }

                cKIDs++;
                continue;
            }
            else
            {
                ChkDR(_SetKIDStoreData  (pcontextSync,
                                        &f_pcontextViewRights->KID,
                                        &slotHint,
                                        &lsd,
                                        FALSE));
            }                                    
        }                                 

        /* determine if this requires a sync */

        if (_SyncRequired(f_cMaxCount, f_cMaxHours, &lsd, &ui64ThreshholdTime))
        {
            cKIDs++;

            if (fBuildList)
            {
                if (DRM_FAILED (_WriteKIDToList(&f_pcontextViewRights->KID, f_pbChallenge)))
                {
                    fContinue  = FALSE;
                    fBuildList = FALSE;
                }
            }
        }

    } /* end while more KIDs */

    if (fBuildList)
    {
        DRM_STRING strXML = EMPTY_DRM_STRING;

        if (cKIDs == 0
        ||   DRM_FAILED(DRM_XMB_CloseCurrNode(pbData,  NULL))    /* </RECORDS> */
        ||   DRM_FAILED(DRM_XMB_CloseDocument(pbData, &strXML))) /* </DRMSYNCLIST> */
        {
            fBuildList = FALSE;
        }
        else
        {
            strXML.pwszString [strXML.cchString] = g_wchNull;

            /* save the results in output buffers */

            *f_pcbChallenge = CB_DSTR(&strXML);

            MEMMOVE(f_pbChallenge, strXML.pwszString, *f_pcbChallenge + SIZEOF (DRM_WCHAR));
        }
    }

    if (f_pcKIDs != NULL)
    {
        *f_pcKIDs = cKIDs;
    }
    
    if (f_piKIDNext != NULL)
    {
        *f_piKIDNext = iKIDCurrent;
    }

    if (cKIDs == 0)
    {
        ChkDR(DRM_E_NOMORE);
    }
    else if (! fBuildList)
    {
        /* We reached this point because the output buffers are NULL or 
           they weren't big enough */
        *f_pcbChallenge = _RequiredCharsForChallenge(cKIDs) * SIZEOF (DRM_WCHAR)
                        + cbAdjustment;

        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_SNC_GenerateSyncChallenge", g_pwszLeavingFunction);

    if (fOpenStoreLCS)
    {
        DRM_LST_Close(f_pcontextViewRights->pbLicenseStore);
    }

    if (fOpenStoreSNC)
    {
        DRM_SNC_CloseStore(pcontextSync);
    }

    SAFE_STK_FREE(f_pcontextStack, pcontextSyncEnum);
    SAFE_STK_FREE(f_pcontextStack, pcontextSync);

    return dr;
} /* DRM_SNC_GenerateSyncChallenge */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmhdrbuilder.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmtypes.h>
#include <drmutilities.h>
#include <drmxmlbuilder.h>
#include <drmsha1.h>
#include <drmlicense.h>
#include <drmhdrbuilder.h>
#include <drmkeygenerator.h>


/*************************************************************************
** Macros
**************************************************************************/
#define LOCALSTACKSIZE  200
#define Tracked_N_ChkDR(hb,expr) {                         \
    if ( (hb)->dwItemsTracked == (hb)->dwItemsAdded ) \
    {                          \
        ChkDR((expr));         \
        ++(hb)->dwItemsAdded;  \
    }                          \
    ++(hb)->dwItemsTracked;    \
}


/*************************************************************************
** Local data structures
**************************************************************************/
typedef enum 
{
    eHBCreating=0x0,
    eHBInited, 
    eHBAddingData,
    eHBAddedData,
    eHBSigning,
    eHBCreated
} _EHBContextState;

/*
** Header Builder context stucture. This structure contains the following:
** - A Local stack
** - XML Builder context
** The XML Builder context is physically located at end of the buffer after init - for easier
** realloc a bigger size when necessary.
*/
typedef struct _tag_HBContext
{
    DRM_DWORD wContextSize;
    _EHBContextState eState;
    DRM_DWORD dwItemsAdded;     /* copied from old context when DRM_LA_ReallocRequest() is called */
    DRM_DWORD dwItemsTracked;       /* 0 when DRM_LA_ReallocRequest() is called */
    DRM_STRING szXMLString;
    DRM_BOOL fKIDAdded;
    DRM_BOOL fLAINFOAdded;
    DRM_BOOL fChecksumAdded;
    DRM_BYTE rgbLocalStack[__CB_DECL(LOCALSTACKSIZE)];     /* local stack buffer */
    DRM_BYTE  *pbXmlContext;
    DRM_BYTE   rgbXmlContext [1];
} _HBContext;


/*************************************************************************
** local constants
**************************************************************************/
/* default tag data */

static const DRM_WORD _cbXmlBuilderCtx=8192;    /* initial XML builder context size */

/*************************************************************************
** static functions
**************************************************************************/


/* 
**
*/
static DRM_VOID
_ChangeState(
    _HBContext *pHB,
    _EHBContextState eState)
{
    pHB->eState = eState;
    pHB->dwItemsAdded = pHB->dwItemsTracked = 0;
}


/*
** Add the following node/subnode to the request:
**
**  <SIGNATURE>
**    <HASHALGORITHM type=\"SHA\"></HASHALGORITHM>
**    <SIGNALGORITHM type=\"MSDRM\"></SIGNALGORITHM>
**    <VALUE>QrUgBBheJVzAOOw2kbo*1sqJkwft4oXKNBPv56PpUhho5fS6XK6sTg==</VALUE>
**  </SIGNATURE>
*/
static DRM_RESULT _SignTheHeader(
    _HBContext         *pHB,
    DRM_CRYPTO_CONTEXT *pCryptoContext,
    DRM_CONST_STRING   *pdstrPrivKey,
    DRM_STRING         *pdstrDataNodeFragment)
{
    DRM_RESULT dr=DRM_SUCCESS;

    ChkArg(pHB);

    /* open <SIGNATURE> node */
    Tracked_N_ChkDR(pHB, DRM_XMB_OpenNode(pHB->pbXmlContext, &g_dstrTagSignature));
        
    /* add <HASHALGORITHM> node */
    Tracked_N_ChkDR(pHB, DRM_XMB_OpenNode(pHB->pbXmlContext, &g_dstrTagHashAlg));
    Tracked_N_ChkDR(pHB, DRM_XMB_AddAttribute(pHB->pbXmlContext, &g_dstrAttributeType, &g_dstrSHA));
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, NULL));

    /* add <SIGNALGORITHM> node */
    Tracked_N_ChkDR(pHB, DRM_XMB_OpenNode(pHB->pbXmlContext, &g_dstrTagSignAlg));
    Tracked_N_ChkDR(pHB, DRM_XMB_AddAttribute(pHB->pbXmlContext, &g_dstrAttributeType, &g_dstrMSDRM));
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, NULL));

    /* add <VALUE> node */
    {
        DRM_BYTE    rgbSignature [__CB_DECL(PK_ENC_SIGNATURE_LEN)];
        DRM_DWORD   cchEncoded;
        PRIVKEY oPrivKey;
        DRM_DWORD dwPrivKey=SIZEOF(PRIVKEY);
        DRM_CONST_STRING dstrSignature = EMPTY_DRM_STRING;

        /* decode the signing key */
        ChkDR(DRM_B64_DecodeW(pdstrPrivKey, &dwPrivKey, (DRM_BYTE *)&oPrivKey, 0));

        /* sign the <DATA> node */        
        ChkDR(DRM_PK_Sign( pCryptoContext->rgbCryptoContext, 
                          &oPrivKey, 
                           PB_DSTR( pdstrDataNodeFragment ),
                           CB_DSTR( pdstrDataNodeFragment ),
                           rgbSignature));

        /* Base64 encode the signature */

        cchEncoded = CCH_BASE64_EQUIV( PK_ENC_SIGNATURE_LEN );
        if ( (cchEncoded + 1) * SIZEOF(DRM_WCHAR) > SIZEOF( pHB->rgbLocalStack ) )
        {
            ChkDR(DRM_E_OUTOFMEMORY);       /* LOCALSTACKSIZE too small */
        }
        ZEROMEM(pHB->rgbLocalStack, (cchEncoded+1) * SIZEOF(DRM_WCHAR) );
        ChkDR(DRM_B64_EncodeW( rgbSignature, 
                               PK_ENC_SIGNATURE_LEN, 
                  (DRM_WCHAR *)pHB->rgbLocalStack, 
                              &cchEncoded, 
                              0));
        dstrSignature.pwszString = (DRM_WCHAR *)pHB->rgbLocalStack;
        dstrSignature.cchString = cchEncoded;

        Tracked_N_ChkDR(pHB, DRM_XMB_OpenNode(pHB->pbXmlContext, &g_dstrTagValue));
        Tracked_N_ChkDR(pHB, DRM_XMB_AddData(pHB->pbXmlContext, &dstrSignature));
        Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, NULL));
    }

    /* close SIGNATURE node */
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, NULL));

ErrorExit:
    return dr;
}



DRM_RESULT DRM_API DRM_HB_CreateHeader(
    IN     DRM_BYTE  *pbHBContext,
    IN OUT DRM_DWORD *pcbHBContext)
{
    DRM_RESULT  dr        = DRM_SUCCESS;
    _HBContext *pHB       = NULL;
    DRM_DWORD   cbContext = 0;
    DRM_DWORD   cbTotal   = 0;
    DRM_DWORD   cbAligned = 0;
    DRM_DWORD   cbAdjust  = 0;

    ChkArg(pcbHBContext);

    /* check given context size */
    cbContext = SIZEOF(_HBContext) - 1 + _cbXmlBuilderCtx;
    if ( pbHBContext == NULL || *pcbHBContext < cbContext )
    {
        /* minimum context size to start with */
        *pcbHBContext= cbContext;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }

    /* Initialize Context 
    ** note: pbXmlContext is physically located at end of pbBlackboxContext.
    */
    ZEROMEM(pbHBContext, *pcbHBContext);
    pHB = (_HBContext*)pbHBContext;
    pHB->wContextSize = (DRM_WORD)*pcbHBContext;

    /* init initial state */
    _ChangeState(pHB, eHBCreating);

    cbTotal = *pcbHBContext - SIZEOF(_HBContext) + 1;

    ChkDR(DRM_UTL_EnsureDataAlignment(pHB->rgbXmlContext, 
                                      cbTotal, 
                                     &pHB->pbXmlContext, 
                                     &cbAligned, 
                                      SIZEOF(DRM_DWORD), 
                                     &cbAdjust));

    pHB->wContextSize -= cbAdjust;
    
    /* Init XML Builder 
    ** Add document root tag: <WRMHEADER version=2.0.0.0"> 
    */
    ChkDR(DRM_XMB_CreateDocument(cbAligned, 
                                 pHB->pbXmlContext, 
                                &g_dstrTagWrmHeader));
                                 
    ChkDR(DRM_XMB_AddAttribute(pHB->pbXmlContext, &g_dstrAttributeVersion, &g_dstrAttributeVersionValue));

    /* open <DATA> node to the root node  */
    ChkDR(DRM_XMB_OpenNode(pHB->pbXmlContext, &g_dstrTagData));

    /* change state */
    _ChangeState(pHB, eHBInited);

ErrorExit:
    return dr;
}


/*
**
*/
DRM_RESULT DRM_API DRM_HB_ReallocHeader(
    IN DRM_BYTE *pbOldHBContext,
    IN DRM_DWORD cbNewHBContext,
    IN DRM_BYTE *pbNewHBContext)
{
    DRM_RESULT  dr     = DRM_SUCCESS;
    _HBContext *pOldHB = (_HBContext*)pbOldHBContext;
    _HBContext *pNewHB = (_HBContext*)pbNewHBContext;

    ChkArg(pbOldHBContext && pbNewHBContext  && pOldHB->eState!=eHBCreating
        && cbNewHBContext > pOldHB->wContextSize);

    /* copy old context to new buffer */
    ZEROMEM(pbNewHBContext,  cbNewHBContext);
    pNewHB->wContextSize   = cbNewHBContext;
    pNewHB->dwItemsAdded   = pOldHB->dwItemsAdded;
    pNewHB->eState         = pOldHB->eState;
    pNewHB->fKIDAdded      = pOldHB->fKIDAdded;
    pNewHB->fLAINFOAdded   = pOldHB->fLAINFOAdded;
    pNewHB->fChecksumAdded = pOldHB->fChecksumAdded;
    
    ChkDR(DRM_XMB_ReallocDocument(pOldHB->pbXmlContext, 
        cbNewHBContext-SIZEOF(_HBContext)+1, pNewHB->pbXmlContext));

ErrorExit:
    return dr;
}


/*
**
*/
DRM_RESULT DRM_API DRM_HB_GetContextSize(
    IN  DRM_BYTE  *pbHBContext,
    OUT DRM_DWORD *pcbHBContext)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HBContext *pHB=(_HBContext*)pbHBContext;
    
    ChkArg(pbHBContext && pcbHBContext);  /* && pHB->eState!=eHBCreating); */

    /* current context size */
    *pcbHBContext = pHB->wContextSize;

ErrorExit:
    return dr;
}


/*
** 
*/
DRM_RESULT DRM_API DRM_HB_SignHeader(
    IN  DRM_BYTE           *pbHBContext,
    IN  DRM_CRYPTO_CONTEXT *pCryptoContext,
    IN  DRM_CONST_STRING   *pdstrPrivKey,      /* base64 encoded */
    OUT DRM_BYTE          **ppbHeaderXML,
    OUT DRM_DWORD          *pcbHeaderXML)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HBContext *pHB=(_HBContext*)pbHBContext;    
    DRM_STRING dstrDataNodeFragment;

    ChkArg(pbHBContext && pcbHeaderXML && ppbHeaderXML);
    ChkDRMString(pdstrPrivKey);
    if (pHB->eState!=eHBAddedData && pHB->eState!=eHBSigning)
    {
        if (!pHB->fKIDAdded)
        {
            ChkDR(DRM_E_NOKIDINHEADER);
        }
        else if (!pHB->fLAINFOAdded)
        {
            ChkDR(DRM_E_NOLAINFOINHEADER);
        }
        else if (!pHB->fChecksumAdded)
        {
            ChkDR(DRM_E_NOCHECKSUMINHEADER);
        }
        else
        {
            ChkDR(DRM_E_CH_INVALID_HEADER);
        }
    }

    if ( pHB->eState!= eHBSigning )
    {
        _ChangeState(pHB, eHBSigning);
    }

    /* close <DATA> node and get the XML fragment of it */
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, &dstrDataNodeFragment));
    /* Sign the <DATA> node */
    ChkDR(_SignTheHeader(pHB, pCryptoContext, pdstrPrivKey, &dstrDataNodeFragment));
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseDocument(pHB->pbXmlContext, &pHB->szXMLString));

    *ppbHeaderXML = PB_DSTR( &pHB->szXMLString );
    *pcbHeaderXML = CB_DSTR( &pHB->szXMLString );
    
    /* make sure the context will not be used to call the API again */
    _ChangeState(pHB, eHBCreated);
    
ErrorExit:
    return dr;
}


/*
**
*/
DRM_RESULT DRM_API DRM_HB_SetAttribute(
    IN       DRM_BYTE         *pbHBContext,
    IN const DRM_CONST_STRING *pdstrAttrName,
    IN const DRM_CONST_STRING *pdstrAttrValue)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HBContext *pHB=(_HBContext*)pbHBContext;
    
    ChkArg(pbHBContext);
    ChkDRMString(pdstrAttrName);
    ChkDRMString(pdstrAttrValue);
    if ( pHB->eState != eHBInited &&
        pHB->eState != eHBAddingData&&
        pHB->eState != eHBAddedData )
    {
        ChkArg(FALSE);
    }

    /* Add <ACTION> node */
    if ( pHB->eState!=eHBAddingData )
    {
        _ChangeState(pHB, eHBAddingData);
    }

    Tracked_N_ChkDR(pHB, DRM_XMB_OpenNode(pHB->pbXmlContext, pdstrAttrName));
    Tracked_N_ChkDR(pHB, DRM_XMB_AddData(pHB->pbXmlContext, pdstrAttrValue));
    Tracked_N_ChkDR(pHB, DRM_XMB_CloseCurrNode(pHB->pbXmlContext, NULL));

    _ChangeState(pHB, eHBAddedData);
    
ErrorExit:
    return dr;
}

/*
**
*/
DRM_RESULT DRM_API DRM_HB_SetKeyID(
    IN       DRM_BYTE         *pbHBContext,
    IN const DRM_CONST_STRING *pdstrKID)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HBContext *pHB=(_HBContext*)pbHBContext;
    
    ChkArg(pbHBContext);
    ChkDRMString(pdstrKID);
    ChkArg ( pHB->eState == eHBInited || pHB->eState == eHBAddingData ||
        pHB->eState == eHBAddedData );

    if ( pHB->fKIDAdded )
    {
        ChkDR(DRM_E_DUPLICATEDHEADERATTRIBUTE);
    }

    /* set the attribute */
    ChkDR(DRM_HB_SetAttribute(pbHBContext, &g_dstrTagKID, pdstrKID));
    pHB->fKIDAdded = TRUE;

ErrorExit:
    return dr;
}

/*
**
*/
DRM_RESULT DRM_API DRM_HB_SetLicAcqUrl(
    IN       DRM_BYTE         *pbHBContext,
    IN const DRM_CONST_STRING *pdstrURL)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _HBContext *pHB=(_HBContext*)pbHBContext;
    
    ChkArg(pbHBContext);
    ChkDRMString(pdstrURL);
    ChkArg ( pHB->eState == eHBInited || pHB->eState == eHBAddingData ||
        pHB->eState == eHBAddedData );

    if ( pHB->fLAINFOAdded )
    {
        ChkDR(DRM_E_DUPLICATEDHEADERATTRIBUTE);
    }
    ChkDR(DRM_HB_SetAttribute(pbHBContext, &g_dstrTagLAINFO, pdstrURL));
    pHB->fLAINFOAdded = TRUE;
    
ErrorExit:
    return dr;
}


/*
** Perform checksum algo to the given content key and set the check to header
*/
DRM_RESULT DRM_API DRM_HB_SetChecksum(
    IN       DRM_BYTE         *pbHBContext,
    IN const DRM_CONST_STRING *pdstrContentKey)
{
    DRM_RESULT dr = DRM_SUCCESS;
    _HBContext      *pHB        = (_HBContext*)pbHBContext;
    DRM_DWORD        cchEncoded = 0;
    DRM_INT          lCount     = 0;
    SHA_CONTEXT      shaVal     = { 0 };
    DRM_BYTE         res           [__CB_DECL(SHA_DIGEST_LEN + 1)]     = { 0 };
    DRM_BYTE         rgbKeyContent [__CB_DECL(DRM_CONTENT_KEY_LENGTH)] = { 0 };
    DRM_DWORD        cbContentKey = DRM_CONTENT_KEY_LENGTH;
    DRM_CONST_STRING dstrChecksum = EMPTY_DRM_STRING;
    
    ChkArg(pbHBContext);
    ChkDRMString(pdstrContentKey);
    ChkArg ( pHB->eState == eHBInited || pHB->eState == eHBAddingData ||
        pHB->eState == eHBAddedData );

    if ( pHB->fChecksumAdded )
    {
        ChkDR(DRM_E_DUPLICATEDHEADERATTRIBUTE);
    }

    ChkDR(DRM_B64_DecodeW(pdstrContentKey, &cbContentKey, rgbKeyContent, 0));


    /* Run SHA on key SHA_ITERATIONS times. */
    /* First copy key into res. */
    
    DRMCASSERT ( DRM_CONTENT_KEY_LENGTH < SHA_DIGEST_LEN+1 ); /* Make sure we don't exceed buffer capacity in res. */    
    ZEROMEM(res, SHA_DIGEST_LEN+1);
    MEMCPY (res, rgbKeyContent, cbContentKey);
    for (lCount = 0; lCount < SHA_ITERATIONS; lCount++)
    {
        DRM_SHA_Init(&shaVal);
        DRM_SHA_Update(res, SHA_DIGEST_LEN+1, &shaVal);
        DRM_SHA_Finalize(&shaVal, res);
    }

    /* take first CHECKSUM_LENGTH bytes of res and use it to encode. */
    cchEncoded = CCH_BASE64_EQUIV( CHECKSUM_LENGTH );
    if ( (cchEncoded * SIZEOF(DRM_WCHAR)) >= LOCALSTACKSIZE )
    {
        ChkDR(DRM_E_OUTOFMEMORY);       /* LOCALSTACKSIZE too small */
    }
    ZEROMEM(pHB->rgbLocalStack, cchEncoded * SIZEOF(DRM_WCHAR));
    ChkDR(DRM_B64_EncodeW(res, CHECKSUM_LENGTH, (DRM_WCHAR*)pHB->rgbLocalStack, &cchEncoded, 0));

    /* set the attribute */   
    dstrChecksum.pwszString = (DRM_WCHAR*)pHB->rgbLocalStack;
    dstrChecksum.cchString = cchEncoded;
    ChkDR(DRM_HB_SetAttribute(pbHBContext, &g_dstrTagChecksum, &dstrChecksum));
    pHB->fChecksumAdded = TRUE;

ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmexprvariable.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmexpreval.h>
#include <drmliceval.h>
#include <drmlicenseparser.h>
#include <drmheaderparser.h>
#include <oemimpl.h>
#include <drmlicreason.h>

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
    #define C_SECONDS_IN_ROLLBACK_GRACE_PERIOD 30
#endif
#define C_TICS_PER_SECOND 10000000

DRM_RESULT DRM_API VariableDRMGetorSet       (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_RESULT DRM_API VariableDRMKGetorSet      (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_RESULT DRM_API VariableMachineGetorSet   (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_RESULT DRM_API VariableAPPGetorSet       (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_RESULT DRM_API VariableSecStateGetorSet  (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_RESULT DRM_API VariableLicenseGetorSet   (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_RESULT DRM_API VariableContentGetorSet   (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_RESULT DRM_API VariableDeviceGetorSet    (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
DRM_RESULT DRM_API VariablePMLicenseGetorSet (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);

#if DRM_SUPPORT_SECURE_CLOCK
DRM_RESULT DRM_API VariableSecureTimeGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
#endif

#if DRM_SUPPORT_PLAYLIST_BURN
DRM_RESULT DRM_API VariablePlaylistBurnGetorSet  (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
#endif

#if DRM_SUPPORT_SST_REDUNANCY
DRM_RESULT DRM_API VariableSSTRedundancyGetorSet (const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);
#endif

typedef DRM_RESULT  ( DRM_API *pfnGetorSetVariable)(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet);

typedef struct tagDRM_VARIABLE_NAMESPACES
{
    const DRM_CONST_STRING *pdstrNamespace;
    pfnGetorSetVariable GetorSetVariable;    
} DRM_VARIABLE_NAMESPACES;

DRM_VARIABLE_NAMESPACES g_VariableNamespaces[] = 
{
    { &g_dstrDRM_PREFIX,          VariableDRMGetorSet       },
    { &g_dstrDRMK_PREFIX,         VariableDRMKGetorSet      },
    { &g_dstrMACHINE_PREFIX,      VariableMachineGetorSet   },
    { &g_dstrAPP_PREFIX,          VariableAPPGetorSet       },
    { &g_dstrSECSTATE_PREFIX,     VariableSecStateGetorSet  },
    { &g_dstrLICENSE_PREFIX,      VariableLicenseGetorSet   },
    { &g_dstrCONTENT_PREFIX,      VariableContentGetorSet   },
    { &g_dstrDEVICE_PREFIX,       VariableDeviceGetorSet    },
    { &g_dstrPMLICENSE_PREFIX,    VariablePMLicenseGetorSet },

#if DRM_SUPPORT_SECURE_CLOCK
    { &g_dstrSECURETIME_PREFIX,   VariableSecureTimeGetorSet },
#endif

#if DRM_SUPPORT_PLAYLIST_BURN
    { &g_dstrPLAYLISTBURN_PREFIX, VariablePlaylistBurnGetorSet },
#endif

#if DRM_SUPPORT_SST_REDUNANCY
    { &g_dstrSSTREDUNDANCY_PREFIX, VariableSSTRedundancyGetorSet },
#endif

};

DRM_RESULT DRM_API GlobalSetVariable(
    const DRM_CONST_STRING *pdstrToken, 
    TOKEN            *pNewValue, 
    TOKEN            *pResult, 
    DRM_VOID         *pvOpaqueData)
{
    DRM_UINT i,j;    

    /* Find the period first and use that to  */
    for( j=0; j<pdstrToken->cchString; j++ )
    {
        if( pdstrToken->pwszString[j] == g_wchPeriod )
        {
            j++;
            break;
        }
    }
    if( j < pdstrToken->cchString )
    {
        DRM_CONST_STRING dstrToken;
        
        dstrToken.pwszString = pdstrToken->pwszString + j;
        dstrToken.cchString  = pdstrToken->cchString  - j;
        for( i = 0; i < NO_OF( g_VariableNamespaces ); i++ )
        {
            if( j == g_VariableNamespaces[i].pdstrNamespace->cchString &&
                0 == wcsncmp(pdstrToken->pwszString, g_VariableNamespaces[i].pdstrNamespace->pwszString, j) )
            {                
                return g_VariableNamespaces[i].GetorSetVariable(&dstrToken, pNewValue, pResult, pvOpaqueData, TRUE ) ;
            }
        }
    }
    return CPRMEXP_INVALID_VARIABLE;
}

DRM_RESULT DRM_API GlobalGetVariable(const DRM_CONST_STRING* pdstrToken, TOKEN* pResult, DRM_VOID* pvOpaqueData)
{
    DRM_UINT i,j;    

    /* Find the g_wchPeriod first and use that to  */
    for( j=0; j<pdstrToken->cchString; j++ )
    {
        if( pdstrToken->pwszString[j] == g_wchPeriod )
        {
            j++;
            break;
        }
    }
    if( j < pdstrToken->cchString )
    {
        DRM_CONST_STRING dstrToken;
        dstrToken.pwszString = pdstrToken->pwszString + j;
        dstrToken.cchString = pdstrToken->cchString - j;
        for( i = 0; i < NO_OF( g_VariableNamespaces ); i++ )
        {
            if( j == g_VariableNamespaces[i].pdstrNamespace->cchString &&
                0 == wcsncmp(pdstrToken->pwszString, g_VariableNamespaces[i].pdstrNamespace->pwszString, j) )
            {                
                return g_VariableNamespaces[i].GetorSetVariable(&dstrToken, NULL, pResult, pvOpaqueData, FALSE ) ;
            }
        }
    }
    return CPRMEXP_INVALID_VARIABLE;
}


DRM_RESULT DRM_API VariableDRMKGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    if ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarVersion, pdstrToken ) )
    {
        if( fSet )
        {
            return CPRMEXP_UPDATE_UNSUPPORTED;
        }
        if( pLicEval->dstrDRMKVer.pwszString && pLicEval->dstrDRMKVer.cchString )
        {
            pResult->TokenType = TOKEN_STRING;
            pResult->val.stringValue.pwszString = pLicEval->dstrDRMKVer.pwszString;
            pResult->val.stringValue.cchString = pLicEval->dstrDRMKVer.cchString;
        }
        else
        {
            return CPRMEXP_RETRIEVAL_FAILURE;
        }
    }
    else if ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarParameter, pdstrToken ) )
    {
        if( fSet )
        {
            if( pNewValue->TokenType != TOKEN_STRING )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;
            }
            pLicEval->wszDRMKParam.pwszString = pNewValue->val.stringValue.pwszString;
            pLicEval->wszDRMKParam.cchString  = pNewValue->val.stringValue.cchString;
        }
        else if( NULL == pLicEval->wszDRMKParam.pwszString || 0 == pLicEval->wszDRMKParam.cchString )
        {
            return CPRMEXP_RETRIEVAL_FAILURE;
        }

        pResult->TokenType = TOKEN_STRING;
        pResult->val.stringValue.pwszString = pLicEval->wszDRMKParam.pwszString;
        pResult->val.stringValue.cchString = pLicEval->wszDRMKParam.cchString;
    }
    else
    {        
        return CPRMEXP_INVALID_VARIABLE;
    }

    return DRM_SUCCESS;
}


DRM_RESULT DRM_API VariableDRMGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarReason, pdstrToken ) )
    {
        if( !fSet )
        {
            return CPRMEXP_RETRIEVAL_FAILURE;
        }
        if( pNewValue->TokenType != TOKEN_LONG )
        {
            return CPRMEXP_WRONG_TYPE_OPERAND;
        }

        pResult->TokenType = TOKEN_LONG;
        pLicEval->lReasonForFail = pResult->val.lValue = pNewValue->val.lValue;
    }
    else if ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarVersion, pdstrToken ) )
    {
        if( fSet )
        {
            return CPRMEXP_UPDATE_UNSUPPORTED;
        }
        if( pLicEval->dstrDRMVer.pwszString && pLicEval->dstrDRMVer.cchString )
        {
            pResult->TokenType = TOKEN_STRING;
            pResult->val.stringValue.pwszString = pLicEval->dstrDRMVer.pwszString;
            pResult->val.stringValue.cchString = pLicEval->dstrDRMVer.cchString;
        }
        else
        {
            return CPRMEXP_RETRIEVAL_FAILURE;
        }

    }
    else if ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarBBMSDRMVersion, pdstrToken ) )
    {
        if( fSet )
        {
            return CPRMEXP_UPDATE_UNSUPPORTED;
        }
        if( pLicEval->dstrBBVer.pwszString && pLicEval->dstrBBVer.cchString )
        {
            pResult->TokenType = TOKEN_STRING;
            pResult->val.stringValue.pwszString = pLicEval->dstrBBVer.pwszString;
            pResult->val.stringValue.cchString = pLicEval->dstrBBVer.cchString;
        }
        else
        {
            return CPRMEXP_RETRIEVAL_FAILURE;
        }
    }
    else
    {
        return CPRMEXP_INVALID_VARIABLE;
    }

    return DRM_SUCCESS;
}

DRM_RESULT DRM_API VariableMachineGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    if( fSet )
    {
        return CPRMEXP_UPDATE_UNSUPPORTED;
    }

    if ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarDateTime, pdstrToken ) )
    {
        TOKEN token;
        DRMFILETIME filetime = {0};

        if ( pLicEval->fIgnoreTimeBoundLicense )
        {
            pLicEval->lReasonForFail = LR_LICENSE_CLOCK_NOT_SET;
            return CPRMEXP_CLOCK_REQUIRED;
        }

        if (pLicEval->eTimeBasedState != LICEVAL_GRACEPERIODREFERENCED )
        {
            pLicEval->eTimeBasedState = LICEVAL_MACHINEDATETIMEREFERENCED;
        }
        
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
        dr = VariableSecStateGetorSet( &g_dstrSavedDateTime, NULL, &token, pvOpaqueData, FALSE );
#endif
        pResult->TokenType = TOKEN_DATETIME;
        OEM_GetDeviceTime(&filetime);
        FILETIME_TO_UI64( filetime, pResult->val.u64DateTime );
#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
        if( dr == DRM_SUCCESS )
        {
            /* Compare for the grace period */
            if( DRM_UI64Les( pResult->val.u64DateTime, token.val.u64DateTime ) )
            {
                pResult->val.u64DateTime = DRM_UI64Sub( token.val.u64DateTime, pResult->val.u64DateTime );

                if( DRM_UI64Les( pResult->val.u64DateTime, DRM_UI64(C_SECONDS_IN_ROLLBACK_GRACE_PERIOD * C_TICS_PER_SECOND) ) )
                {
                    pResult->TokenType       = TOKEN_DATETIME;
                    pResult->val.u64DateTime = token.val.u64DateTime;
                }
            }
        }
#endif
    }
    else
    {
        return CPRMEXP_INVALID_VARIABLE;
    }
    return DRM_SUCCESS;
}

DRM_RESULT DRM_API VariableAPPGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    DRM_RESULT dr                 = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    pResult->TokenType = TOKEN_LONG;

    if( fSet )
    {
        /* Set not allowed */
        dr = CPRMEXP_UPDATE_UNSUPPORTED;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarCount, pdstrToken ) )
    {
        if( pLicEval->fAppInfoValid )
        {
            pResult->val.lValue = 2;
        }
        else
        {
            pResult->val.lValue = 1;
        }            
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarMinSecLevel, pdstrToken ) )
    {
        pResult->val.lValue = pLicEval->certinfoSDK.appSec;
        if( pLicEval->fAppInfoValid )
        {
            if( pLicEval->certinfoApp.appSec < pLicEval->certinfoSDK.appSec )
            {
                pResult->val.lValue = pLicEval->certinfoApp.appSec;
            }
        }
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarSecLevel, pdstrToken ) )
    {
        pResult->val.lValue = pLicEval->certinfoSDK.appSec;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarAppSecLevel, pdstrToken ) )
    {
        if( pLicEval->fAppInfoValid )
        {
            pResult->val.lValue = pLicEval->certinfoApp.appSec;
        }
        else
        {
            pResult->val.lValue = pLicEval->certinfoSDK.appSec;
        }
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarSubjID, pdstrToken ) )
    {
        pResult->val.lValue = pLicEval->certinfoSDK.appcd_subject;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarAppSubjID, pdstrToken ) )
    {
        if( pLicEval->fAppInfoValid )
        {
            pResult->val.lValue = pLicEval->certinfoApp.appcd_subject;
        }
        else
        {
            pResult->val.lValue = pLicEval->certinfoSDK.appcd_subject;
        }        
    }
    else
    {
        dr  = CPRMEXP_RETRIEVAL_FAILURE;
    }

    return dr;
}

DRM_RESULT DRM_API VariableSecStateGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT  *pLicEval  = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;
    DRM_SECSTORE_CONTEXT *pbContext = NULL;
    DRM_CONST_STRING      dstrToken = EMPTY_DRM_STRING;

    dstrToken.pwszString = pdstrToken->pwszString;
    dstrToken.cchString  = pdstrToken->cchString;

    if( g_dstrExprVarGlobal.cchString < dstrToken.cchString &&
        wcsncmp( g_dstrExprVarGlobal.pwszString, dstrToken.pwszString, g_dstrExprVarGlobal.cchString ) == 0 )
    {
        /* Move the pointer past the globalstate string */
        dstrToken.pwszString += g_dstrExprVarGlobal.cchString;
        dstrToken.cchString  -= g_dstrExprVarGlobal.cchString;
        
        
        /* Look for both savedatetime and saveddatetime due to a bug in older WMRM versions */
        if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarSaveDateTime, &dstrToken ) )
        {
            dstrToken.pwszString = g_dstrExprVarSavedDateTime.pwszString;
            dstrToken.cchString = g_dstrExprVarSavedDateTime.cchString;
        }

        /* It is a global state variable.  If this is a set call we have to check to see if set is available right now */
        if( fSet )
        {
            if( !pLicEval->fGlobalSecStoreWritable )
            {
                dr = CPRMEXP_UPDATE_FAILURE;
                goto ErrorExit;
            }
            else if( ( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarSavedDateTime, &dstrToken ) )&&
                    pNewValue->TokenType != TOKEN_DATETIME )
            {
                /* saveddatetime MUST be a DATE token */
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
        }
        pbContext = pLicEval->pcontextSSTGlobal;
    }
#if DRM_SUPPORT_SECURE_CLOCK
    else if( g_dstrSECURETIME_PREFIX.cchString < dstrToken.cchString 
          && wcsncmp( g_dstrSECURETIME_PREFIX.pwszString, dstrToken.pwszString, g_dstrSECURETIME_PREFIX.cchString ) == 0 )

    {
        /* Move the pointer past the securetime string */
        dstrToken.pwszString += g_dstrSECURETIME_PREFIX.cchString;
        dstrToken.cchString  -= g_dstrSECURETIME_PREFIX.cchString;
        dr = VariableSecureTimeGetorSet( &dstrToken, pNewValue, pResult, pvOpaqueData, fSet);
        goto ErrorExit;
    }
#endif
    else
    {
        pbContext = pLicEval->pcontextSSTLicense;
    }

    if( NULL == pbContext )
    {
        dr = CPRMEXP_RETRIEVAL_FAILURE;
    }
    else if( fSet )
    {
        TOKEN tempToken;

        if( pNewValue->TokenType == TOKEN_STRING )
        {
            /* String types can not be assigned to secure store variables */
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        MEMCPY( &tempToken, pNewValue, SIZEOF( TOKEN ) );

        if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarDRMReason, &dstrToken ) )
        {
            pLicEval->lReasonForFail = pNewValue->val.lValue;
        }
        else
        {
            dr = DRM_SST_SetTokenValue( pbContext, &dstrToken, &tempToken);
            if( DRM_FAILED( dr ) )
            {
                dr = CPRMEXP_UPDATE_FAILURE;
                goto ErrorExit;
            }
        }
        if( pResult )
        {
            MEMCPY( pResult, pNewValue, SIZEOF( TOKEN ) );
        }
    }
    else
    {
        dr = DRM_SST_GetTokenValue( pbContext, &dstrToken, pResult);
        if( DRM_FAILED(dr) || dr == DRM_S_FALSE )
        {
            dr = CPRMEXP_RETRIEVAL_FAILURE;
            goto ErrorExit;
        }
    }
    
ErrorExit:
    return dr;
}

DRM_RESULT DRM_API VariableLicenseGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    if( fSet )
    {
        /* Set not allowed */
        return CPRMEXP_UPDATE_UNSUPPORTED;
    }
    pResult->TokenType = TOKEN_STRING;
    if( NULL == pLicEval->dstrContentLicense.pwszString ||
        0 == pLicEval->dstrContentLicense.cchString ||
        DRM_FAILED( DRM_LIC_GetAttribute( &(pLicEval->dstrContentLicense), pdstrToken, DRM_LICENSE_ATTRIB_OTHER, NULL, &(pResult->val.stringValue), g_wchPeriod ) )
        )
    {
        dr = CPRMEXP_RETRIEVAL_FAILURE;
    }
    
    return dr;
}

DRM_RESULT DRM_API VariableContentGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    /* Use content header parsing to extract a property */
    if( fSet )
    {        
        return CPRMEXP_UPDATE_UNSUPPORTED;
    }
    pResult->TokenType = TOKEN_STRING;
    if( NULL == pLicEval->dstrContentHeader.pwszString ||
        0 == pLicEval->dstrContentHeader.cchString ||
        DRM_FAILED( DRM_HDR_GetAttribute( &(pLicEval->dstrContentHeader), pdstrToken, DRM_HEADER_ATTRIB_OTHER, &(pResult->val.stringValue), g_wchPeriod ) )
        )    
    {
        dr = CPRMEXP_RETRIEVAL_FAILURE;
    }
    
    return dr;
}

DRM_RESULT DRM_API VariableDeviceGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    /* We are depricating the device namespace */
#if !DRM_SUPPORT_DEVICE_NAMESPACE
    return DRM_E_NOTIMPL;
#else

    DRM_LICEVAL_CONTEXT* pContext = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    DRMASSERT( pContext != NULL );

    /* device-registered flag */
    if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarDevReg, pdstrToken ) )
    {
        if( fSet )
        {
            if( pNewValue->TokenType != TOKEN_LONG )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;                
            }
            pContext->fDeviceRegistered = pNewValue->val.lValue;
        }
        pResult->TokenType  = TOKEN_LONG;
        pResult->val.lValue = pContext->fDeviceRegistered;
    }
    else
    {
        return CPRMEXP_RETRIEVAL_FAILURE;
    }

    return DRM_SUCCESS;

#endif

}

DRM_RESULT DRM_API VariablePMLicenseGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
#if !DRM_SUPPORT_PMLICENSE
    return DRM_E_NOTIMPL;
#else
    DRM_LICEVAL_CONTEXT* pContext = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    DRMASSERT( pContext != NULL );

    if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarRights, pdstrToken ) )
    {
        if( fSet )
        {
            if( pNewValue->TokenType != TOKEN_LONG )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;                
            }
            pContext->lPMRights = pNewValue->val.lValue;
        }
        pResult->TokenType = TOKEN_LONG;
        pResult->val.lValue    = pContext->lPMRights;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarExpiryDate, pdstrToken ) )
    {
        DRMFILETIME filetime;
        if( fSet )
        {            
            if( pNewValue->TokenType != TOKEN_DATETIME )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;                
            }
            UI64_TO_FILETIME( pNewValue->val.u64DateTime, filetime );
            if (!OEM_FileTimeToSystemTime(&filetime, &pContext->PMExpiryDate))
            {
                return CPRMEXP_UPDATE_FAILURE;
            }            
        }
        pResult->TokenType = TOKEN_DATETIME;
        if (!OEM_SystemTimeToFileTime(&pContext->PMExpiryDate, &filetime))
        {
            return CPRMEXP_RETRIEVAL_FAILURE; /* Should not happen. */            
        }
        FILETIME_TO_UI64(filetime, pResult->val.u64DateTime)
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarAppSecLevel, pdstrToken ) )
    {
        if( fSet )
        {
            if( pNewValue->TokenType != TOKEN_LONG )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;                
            }
            pContext->lPMAppSec = pNewValue->val.lValue;
        }
        pResult->TokenType = TOKEN_LONG;
        pResult->val.lValue    = pContext->lPMAppSec;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarVersion, pdstrToken ) )
    {
        if( fSet )
        {
            return CPRMEXP_UPDATE_UNSUPPORTED;
        }

        if (pContext->pwszPMLicVersion && pContext->pwszPMLicVersion->cchString > 0)
        {
            pResult->TokenType = TOKEN_STRING;
            pResult->val.stringValue.cchString = pContext->pwszPMLicVersion->cchString;
            pResult->val.stringValue.pwszString = pContext->pwszPMLicVersion->pwszString;
        }
        else
        {
            return CPRMEXP_RETRIEVAL_FAILURE;             
        }
    }

    else
    {
        return CPRMEXP_RETRIEVAL_FAILURE;
    }

    return DRM_SUCCESS;
#endif
}

#if DRM_SUPPORT_SECURE_CLOCK
DRM_RESULT DRM_API VariableSecureTimeGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_LICEVAL_CONTEXT* pLicEval = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;


    if( fSet )
    {        
        return CPRMEXP_UPDATE_UNSUPPORTED;
    }
    if( NULL == pLicEval )
    {
        dr = CPRMEXP_RETRIEVAL_FAILURE;
    }

    if( !pLicEval->fSecureTimeDataValid )
    {        
        return CPRMEXP_RETRIEVAL_FAILURE;
    }

    /* fInGracePeriod variable*/
    /*Set the flag in lic Eval context if this function was ever called, to know that if Grace period expression exists in license.
     * It is called before validation of variables, but it is fine since the function will error out if variables doesnt match.
    */
    pLicEval->eTimeBasedState = LICEVAL_GRACEPERIODREFERENCED;

    if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarInGracePeriod, pdstrToken ) )
    {
        pResult->TokenType  = TOKEN_LONG;
        pResult->val.lValue = (DRM_LONG)pLicEval->fInGracePeriod;
    }
    else if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarGpStartTime, pdstrToken ) )
    {
        pResult->TokenType  = TOKEN_DATETIME;
        MEMCPY(&pResult->val.u64DateTime, &pLicEval->u64GPStartTime, SIZEOF( pResult->val.u64DateTime ) ) ;
    }
    else
    {
        return CPRMEXP_RETRIEVAL_FAILURE;
    }

    return DRM_SUCCESS;
  
}
#endif


#if DRM_SUPPORT_PLAYLIST_BURN
DRM_RESULT DRM_API VariablePlaylistBurnGetorSet(const DRM_CONST_STRING* pdstrToken, TOKEN* pNewValue, TOKEN* pResult, DRM_VOID* pvOpaqueData, DRM_BOOL fSet)
{
    DRM_LICEVAL_CONTEXT* pContext = (DRM_LICEVAL_CONTEXT*) pvOpaqueData;

    DRMASSERT( pContext != NULL );

    if( DRM_UTL_DSTRStringsEqual( &g_dstrExprVarIncrementCount, pdstrToken ) )
    {
        if( fSet )
        {
            if( pNewValue->TokenType != TOKEN_LONG )
            {
                return CPRMEXP_WRONG_TYPE_OPERAND;                
            }
            pContext->cPlaylistBurnIncrement = pNewValue->val.lValue;
        }
        pResult->TokenType  = TOKEN_LONG;
        pResult->val.lValue = pContext->cPlaylistBurnIncrement;
    }
    else
    {
        return CPRMEXP_RETRIEVAL_FAILURE;
    }

    return DRM_SUCCESS;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmhdrbuilder.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMHEADERBUILDER_H__
#define __DRMHEADERBUILDER_H__


#ifdef __cplusplus
extern "C" {
#endif



/* 
** Header Builder
*/

/**********************************************************************
** Function:    DRM_HB_CreateHeader
** Synopsis:    
** Arguments:   [pbContext] -- 
** Returns:     
** Notes:
***********************************************************************/
DRM_RESULT DRM_API DRM_HB_CreateHeader(
    IN     DRM_BYTE  *pbHBContext,
    IN OUT DRM_DWORD *pcbHBContext);

DRM_RESULT DRM_API DRM_HB_SignHeader(
    IN  DRM_BYTE           *pbHBContext,
    IN  DRM_CRYPTO_CONTEXT *pCryptoContext,
    IN  DRM_CONST_STRING   *pdstrPrivKey,      /* base64 encoded */
    OUT DRM_BYTE          **ppbHeaderXML,
    OUT DRM_DWORD          *pcbHeaderXML);

DRM_RESULT DRM_API DRM_HB_ReallocHeader(
    IN DRM_BYTE *pbOldHBContext,
    IN DRM_DWORD cbNewHBContext,
    IN DRM_BYTE *pbNewHBContext);

DRM_RESULT DRM_API DRM_HB_GetContextSize(
    IN  DRM_BYTE  *pbHBContext,
    OUT DRM_DWORD *pcbContext);

DRM_RESULT DRM_API DRM_HB_SetKeyID(
    IN       DRM_BYTE         *pbHBContext,
    IN const DRM_CONST_STRING *pdstrKID);      /* base64 encoded */

DRM_RESULT DRM_API DRM_HB_SetLicAcqUrl(
    IN       DRM_BYTE         *pbHBContext,
    IN const DRM_CONST_STRING *pdstrURL);

/*
** Perform checksum algo to the given content key and set the check to header
*/
DRM_RESULT DRM_API DRM_HB_SetChecksum(
    IN       DRM_BYTE         *pbHBContext,
    IN const DRM_CONST_STRING *pdstrContentKey);     /* base64 encoded */

DRM_RESULT DRM_API DRM_HB_SetAttribute(
    IN       DRM_BYTE         *pbHBContext,
    IN const DRM_CONST_STRING *pdstrAttrName,
    IN const DRM_CONST_STRING *pdstrAttrValue);


#ifdef __cplusplus
}
#endif

#endif /* __DRMHEADERBUILDER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmexpreval.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRM_EXPR_EVAL_H__
#define __DRM_EXPR_EVAL_H__

#include <drmlicstore.h>
#include <drmtoken.h>

#ifdef __cplusplus
extern "C" {
#endif


/* In the following Extract*Token functions if cchExpression == 0 it is assumed that the string is NULL termintated. */
/* Note: These functions modify the pointer they are given. */

DRM_RESULT DRM_API ExtractStringToken( DRM_CONST_STRING* pdstrExpression, TOKEN* pToken );
DRM_RESULT DRM_API ExtractLongToken  ( DRM_CONST_STRING* pdstrExpression, TOKEN* pToken );
DRM_RESULT DRM_API ExtractSymbolToken( DRM_CONST_STRING* pdstrExpression, TOKEN* pToken );
DRM_RESULT DRM_API ExtractDateToken  ( DRM_CONST_STRING* pdstrExpression, TOKEN *pToken );


typedef DRM_RESULT (DRM_API *pfnGetVariable)(const DRM_CONST_STRING*, TOKEN*, DRM_VOID*);
typedef DRM_RESULT (DRM_API *pfnSetVariable)(const DRM_CONST_STRING*, const TOKEN*, TOKEN*, DRM_VOID*);

#define DRM_EXPR_EVAL_MAX_TOKEN_STACK_SIZE 15

typedef struct tagEXPR_EVAL_INTERNAL_DATA
{
    TOKEN rgOperandTokenStack[DRM_EXPR_EVAL_MAX_TOKEN_STACK_SIZE];
    TOKEN rgOperatorTokenStack[DRM_EXPR_EVAL_MAX_TOKEN_STACK_SIZE];
    DRM_DWORD dwOperandStack;
    DRM_DWORD dwOperatorStack;
    DRM_BOOL fShortCircuit;
} EXPR_EVAL_INTERNAL_DATA;

typedef struct tagEXPR_EVAL_CONTEXT
{
    /* Data the caller must set  */
    pfnGetVariable GetVariable; /* Function pointers so variables can be fetched/set */
    pfnSetVariable SetVariable;
    DRM_VOID* pvOpaqueData;         /* Pointer to be passed into GetVariable() and SetVariable() */
    DRM_KID KID;
    DRM_LID LID;
    DRM_LICSTOREENUM_CONTEXT *pLicStoreEnumContext;    /* ExprEval needs an open license store enum context in case the license calls delete license */

    /* Internal memory sandbox for ExprEval to use.  Caller doesn't set this memory */
    EXPR_EVAL_INTERNAL_DATA ExprEvalData;
} EXPR_EVAL_CONTEXT;


DRM_RESULT DRM_API DRM_EXPR_EvaluateExpression(
    IN const DRM_CONST_STRING  *pdstrExpression, 
    IN OUT   EXPR_EVAL_CONTEXT *pEEContext, 
       OUT   TOKEN             *ptResult );


#ifdef __cplusplus
}
#endif

#endif /* __DRM_EXPR_EVAL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmexprfunc.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmexpreval.h>
#include <drmlicstore.h>
#include <drmsyncstore.h>
#include <oemimpl.h>
#include "drmexprfunc.h"

/* Put the function names in a table with arity values */
typedef struct tagDRM_EXPR_FUNCTIONS
{
    const DRM_CONST_STRING *pdstrFunction;
    DRM_LONG Arity;
    DRM_EXPR_FUNCTION_TYPE FnType;
} DRM_EXPR_FUNCTIONS;

DRM_EXPR_FUNCTIONS g_FncsArity[] = 
{
    { &g_dstrExprFuncDateAdd,        3, FN_DATEADD        },
    { &g_dstrExprFuncDateDiff,       3, FN_DATEDIFF       },
    { &g_dstrExprFuncMin,            2, FN_MIN            },
    { &g_dstrExprFuncMax,            2, FN_MAX            },    
    { &g_dstrExprFuncDatePart,       2, FN_DATEPART       },
    { &g_dstrExprFuncVersionCompare, 2, FN_VERSIONCOMPARE },
    { &g_dstrExprFuncDeleteLicense,  0, FN_DELETELICENSE  },
    { &g_dstrExprFuncExists,         1, FN_EXISTS         },
};

DRM_BOOL DRM_API IsValidFunction(
    const DRM_CONST_STRING *pStringToken,
          DRM_DWORD        *pfnType)
{    
    DRM_UINT i;
    for( i = 0; i < NO_OF( g_FncsArity ); i++ )
    {
        if( DRM_UTL_DSTRStringsEqual( pStringToken, g_FncsArity[i].pdstrFunction ) )
        {
            *pfnType = g_FncsArity[i].FnType;
            return TRUE;
        }
    }
    return FALSE;
}


DRM_LONG DRM_API Arity(DRM_EXPR_FUNCTION_TYPE fnType)
{
    DRM_UINT i;
    for( i = 0; i < NO_OF( g_FncsArity ); i++ )
    {
        if( g_FncsArity[i].FnType == fnType )
        {
            return g_FncsArity[i].Arity;
        }
    }
    /* We shouldn't get here -- if we did then this wasn't a valid function. 
    Callers should call IsValidFunction to validate the name first */
    /* ASSERT( 0 ) */
    return -1;    
}


DRM_RESULT DRM_API FunctionGetValue(
    TOKEN*             pOperator,
    DRM_LONG           cArgs,
    TOKEN              rgArgs[],
    TOKEN             *pOperandResult,
    EXPR_EVAL_CONTEXT *pEEContext )
{
    DRM_RESULT           dr              = DRM_SUCCESS;
    DRM_LONG             lArity          = 0;    
    DRMSYSTEMTIME        date;
    DRMFILETIME          filetime;
#if DRM_SUPPORT_LICENSE_SYNC
    DRM_LICEVAL_CONTEXT *pcontextLicEval = (DRM_LICEVAL_CONTEXT *) pEEContext->pvOpaqueData;
#endif
    DRM_LONG             lCounter        = 0;
    DRM_INT64            i64Temp;

    DRMASSERT( pOperator->TokenType == TOKEN_FUNCTION );    
    lArity = Arity(pOperator->val.fnValue);
    if (lArity != cArgs)
    {
        dr = CPRMEXP_INCORRECT_NUM_ARGS;
        goto ErrorExit;
    }

    if( pOperator->val.fnValue != FN_EXISTS )
    {
        /* For all functions other than FN_EXISTS we have to ensure that all varibles used actually do exist */
        /* Evaluate arguments that are variables before applying the function. */
        for (lCounter = 0; lCounter < lArity; lCounter++)
        {
            if (rgArgs[lCounter].TokenType == TOKEN_VARIABLE)
            {
                /* Get the variable and replace current rgArgs with it. */
                TOKEN Token = { TOKEN_VARIABLE };
                ChkDR( pEEContext->GetVariable( &(rgArgs[lCounter].val.stringValue), &(Token), pEEContext->pvOpaqueData ) );
                rgArgs[lCounter] = Token;
            }
        }
    }

    /* Everything looks ok. Now, write code for each function. */
    switch( pOperator->val.fnValue )
    {
    case FN_EXISTS:
        {
            TOKEN Token = { TOKEN_VARIABLE };
            if (rgArgs[lCounter].TokenType != TOKEN_VARIABLE)
            {
                dr = CPRMEXP_VARIABLE_EXPECTED;
                goto ErrorExit;
            }
            pOperandResult->TokenType = TOKEN_LONG;
            if( DRM_FAILED( pEEContext->GetVariable( &(rgArgs[lCounter].val.stringValue), &(Token), pEEContext->pvOpaqueData ) ) )
            {
                pOperandResult->val.lValue = 0;
            }
            else
            {
                pOperandResult->val.lValue = 1;
            }
        }
        dr = DRM_SUCCESS;
        break;
    case FN_DATEADD:
        if (rgArgs[0].TokenType != TOKEN_STRING || rgArgs[1].TokenType != TOKEN_LONG ||
            rgArgs[2].TokenType != TOKEN_DATETIME)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        pOperandResult->TokenType = TOKEN_DATETIME;
        if( rgArgs[0].val.stringValue.cchString > 1 )
        {
            dr = CPRMEXP_INVALID_ARGUMENT;
            goto ErrorExit;
        }
        if( rgArgs[0].val.stringValue.pwszString[0] == g_wchd )
        {
            i64Temp = DRM_I64(10000000);
            i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 24uL * 60uL * 60uL ) );
        }
        else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchh )
        {
            i64Temp = DRM_I64(10000000);
            i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 60 * 60 ) );
        }
        else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchn )
        {
            i64Temp = DRM_I64(10000000);
            i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 60 ) );
	    }
        else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchs )
        {
            i64Temp = DRM_I64( 10000000 );
        }
        else
        {
            dr = CPRMEXP_INVALID_ARGUMENT;
            goto ErrorExit;
        }
        i64Temp = DRM_I64Mul( i64Temp, DRM_I64(rgArgs[1].val.lValue) );
        pOperandResult->val.u64DateTime = DRM_UI64Add( *(DRM_UINT64*)&i64Temp, rgArgs[2].val.u64DateTime );
        break;
    case FN_DATEDIFF:
        {
            DRM_UINT64  u64AbsDiff;
            DRM_LONG lSign;

            if ( rgArgs[0].TokenType != TOKEN_STRING 
              || rgArgs[1].TokenType != TOKEN_DATETIME 
              || rgArgs[2].TokenType != TOKEN_DATETIME )
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            if ( DRM_UI64Les( rgArgs[1].val.u64DateTime, rgArgs[2].val.u64DateTime ) )
            {
                u64AbsDiff = DRM_UI64Sub( rgArgs[2].val.u64DateTime, rgArgs[1].val.u64DateTime );
                lSign      = 1;
            }
            else
            {
                u64AbsDiff = DRM_UI64Sub( rgArgs[1].val.u64DateTime, rgArgs[2].val.u64DateTime );
                lSign      = -1;
            }            
            pOperandResult->TokenType = TOKEN_LONG;
            if( rgArgs[0].val.stringValue.cchString > 1 )
            {
                dr = CPRMEXP_INVALID_ARGUMENT;
                goto ErrorExit;
            }
            if( rgArgs[0].val.stringValue.pwszString[0] == g_wchd )
            {
                i64Temp = DRM_I64( 10000000 );
                i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 24uL * 60uL * 60uL ) );
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchh )
            {
                i64Temp = DRM_I64( 10000000 );
                i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 60 * 60 ) );
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchn )
            {
                i64Temp = DRM_I64( 10000000 );
                i64Temp = DRM_I64Mul( i64Temp, DRM_I64( 60 ) );
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchs )
            {
                i64Temp = DRM_I64( 10000000 );
            }
            else
            {
                dr = CPRMEXP_INVALID_ARGUMENT;
                goto ErrorExit;
            }
            pOperandResult->val.lValue = lSign * (DRM_LONG) DRM_I64ToUI32( DRM_I64Div( DRM_UI2I64( u64AbsDiff) , i64Temp) );
            break;
        }
    case FN_MIN:
        if (rgArgs[0].TokenType != TOKEN_LONG || rgArgs[1].TokenType != TOKEN_LONG)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        pOperandResult->TokenType = TOKEN_LONG;
        pOperandResult->val.lValue = min(rgArgs[0].val.lValue, rgArgs[1].val.lValue);
        break;
    case FN_MAX:
        if (rgArgs[0].TokenType != TOKEN_LONG || rgArgs[1].TokenType != TOKEN_LONG)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        pOperandResult->TokenType = TOKEN_LONG;
        pOperandResult->val.lValue = max(rgArgs[0].val.lValue, rgArgs[1].val.lValue);
        break;
    case FN_DATEPART:
        if (rgArgs[0].TokenType != TOKEN_STRING || rgArgs[1].TokenType != TOKEN_DATETIME)
        {
            dr = CPRMEXP_WRONG_TYPE_OPERAND;
            goto ErrorExit;
        }
        pOperandResult->TokenType = TOKEN_LONG;
        UI64_TO_FILETIME( rgArgs[1].val.u64DateTime, filetime );
        if (OEM_FileTimeToSystemTime(&filetime, &date))
        {
            if( rgArgs[0].val.stringValue.cchString > 1 )
            {
                dr = CPRMEXP_INVALID_ARGUMENT;
                goto ErrorExit;
            }
            if( rgArgs[0].val.stringValue.pwszString[0] == g_wchy )
            {
                pOperandResult->val.lValue = date.wYear;
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchm )
            {
                pOperandResult->val.lValue = date.wMonth;
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchd )
            {
                pOperandResult->val.lValue = date.wDay;
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchh )
            {
                pOperandResult->val.lValue = date.wHour;
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchn )
            {
                pOperandResult->val.lValue = date.wMinute;
            }
            else if( rgArgs[0].val.stringValue.pwszString[0] == g_wchs )
            {
                pOperandResult->val.lValue = date.wSecond;
            }
            else
            {
                dr = CPRMEXP_INVALID_ARGUMENT;
                goto ErrorExit;
            }
        }
        else
        {
            dr = CPRMEXP_INVALID_CONSTANT;
            goto ErrorExit;
        }
        break;
    case FN_VERSIONCOMPARE:
        {
            DRM_UINT64 ver1, ver2;
            DRM_INT64  i64;
            DRM_WORD rgwVersion[VERSION_LEN];

            if (rgArgs[0].TokenType != TOKEN_STRING || rgArgs[1].TokenType != TOKEN_STRING)
            {
                dr = CPRMEXP_WRONG_TYPE_OPERAND;
                goto ErrorExit;
            }
            pOperandResult->TokenType = TOKEN_LONG;
            
            ChkDR( DRM_UTL_GetVersionFromString(rgArgs[0].val.stringValue.pwszString, rgArgs[0].val.stringValue.cchString, rgwVersion) );
            i64 = DRM_I64Asgn( (((DRM_DWORD)rgwVersion[0]) << 16) | rgwVersion[1],
                           (((DRM_DWORD)rgwVersion[2]) << 16) | rgwVersion[3] );

            MEMCPY( &ver1, &i64, SIZEOF( DRM_INT64 ) );

            ChkDR( DRM_UTL_GetVersionFromString(rgArgs[1].val.stringValue.pwszString, rgArgs[1].val.stringValue.cchString, rgwVersion) );
            i64 = DRM_I64Asgn( (((DRM_DWORD)rgwVersion[0]) << 16) | rgwVersion[1],
                           (((DRM_DWORD)rgwVersion[2]) << 16) | rgwVersion[3] );

            MEMCPY( &ver2, &i64, SIZEOF( DRM_INT64 ) );

            if ( DRM_UI64Les( ver1, ver2 ) )
            {
                pOperandResult->val.lValue = -1;
            }
            else if ( DRM_UI64Eql( ver1, ver2 ) )
            {
                pOperandResult->val.lValue = 0;
            }
            else
            {
                pOperandResult->val.lValue = 1;
            }
        }
        break;
    case FN_DELETELICENSE:

        if (pEEContext->pLicStoreEnumContext == NULL )
        {
            dr = CPRMEXP_INVALID_CONTEXT;
            goto ErrorExit;
        }

        pOperandResult->TokenType = TOKEN_LONG;

        if (DRM_SUCCEEDED (DRM_LST_EnumDelete (pEEContext->pLicStoreEnumContext)))
        {
#if DRM_SUPPORT_LICENSE_SYNC
            DRM_SYNC_CONTEXT contextSync; 

            /* set this license to NO RIGHTS */

            dr = DRM_SNC_OpenStore  (pcontextLicEval->pcontextHDS, 
                                    &contextSync);
            if(DRM_SUCCEEDED(dr))
            {
                dr = DRM_SNC_UpdateKID  (&contextSync, 
                                        NULL,
                                        &pcontextLicEval->KID);
                dr = DRM_SNC_CloseStore (&contextSync);
            }
#endif
            pOperandResult->val.lValue = 1;
        }
        else
        {
            /* Eat the error and say that deletelicense failed by setting its value to 0. */
            pOperandResult->val.lValue = 0;
        }
        break;
    default:
        dr = CPRMEXP_UNSUPPORTED_FUNCTION; /* This case will happen if we recognize a function name but not support it. */
    }

ErrorExit:
    return(dr);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmhdrparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmheaderparser.h>
#include <drmxmlparser.h>


static DRM_RESULT _BasicHeaderChecks( 
    const DRM_CONST_STRING *pdstrContentHeader,
    OUT   DRM_CONST_STRING *pdstrData )
{
    DRM_RESULT       dr = DRM_E_LOGICERR;    
    DRM_CONST_STRING dstrValue = EMPTY_DRM_STRING;

    DRMASSERT( pdstrContentHeader != NULL );

    /* Ensure the outter tag is WMRMHEADER */
    if( DRM_FAILED( DRM_XML_GetNode( pdstrContentHeader, &g_dstrTagWrmHeader, NULL, NULL, 0, NULL, pdstrData ) ) )
    {
        dr = CH_INVALID_HEADER;
        goto ErrorExit;
    }

    /* Make sure there is a version number */
    if( DRM_FAILED( DRM_XML_GetNodeAttribute( pdstrContentHeader, &g_dstrAttributeVersion, pdstrData ) ) ||
        pdstrData->cchString == 0 )
    {
        dr = CH_VERSION_MISSING;
        goto ErrorExit;
    }

    /* Make sure we understand the version of the header */
    if( !DRM_UTL_DSTRStringsEqual( &g_dstrAttributeVersionValue, pdstrData ) )
    {
        dr = CH_UNSUPPORTED_VERSION;
        goto ErrorExit;
    }

    /* Get the data section. */
    if( DRM_FAILED( DRM_XML_GetSubNode( pdstrContentHeader, &g_dstrTagData, NULL, NULL, 0, pdstrData, NULL, 1 ) ) )
    {
        dr = CH_INVALID_HEADER;
        goto ErrorExit;
    }

    /* Get the KID */
    if( DRM_FAILED( DRM_XML_GetSubNodeByPath( pdstrData, &g_dstrTagKID, NULL, NULL, NULL, &dstrValue, g_wchForwardSlash ) ) )
    {
        dr = CH_KID_MISSING;
        goto ErrorExit;
    }


    /* Get the LAINFO */
    if( DRM_FAILED( DRM_XML_GetSubNodeByPath( pdstrData, &g_dstrTagLAINFO, NULL, NULL, NULL, &dstrValue, g_wchForwardSlash ) ) )
    {
        dr = CH_LAINFO_MISSING;
        goto ErrorExit;
    }

    /* Get the Checksum */
    if( DRM_FAILED( DRM_XML_GetSubNodeByPath( pdstrData, &g_dstrTagChecksum, NULL, NULL, NULL, &dstrValue, g_wchForwardSlash ) ) )
    {
        dr = CH_CHECKSUM_MISSING;
        goto ErrorExit;
    }

    /* Enough fields were present.  Basic checks pass */
    dr = DRM_SUCCESS;
ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_HDR_GetAttribute(
    IN const DRM_CONST_STRING       *pdstrContentHeader,
    IN const DRM_CONST_STRING       *pdstrAttrName,
    IN       eDRM_HEADER_ATTRIBUTES  eAttribute,
    OUT      DRM_CONST_STRING       *pdstrValue,
    IN       DRM_WCHAR               chXPathSeparator)
{
    DRM_RESULT              dr = DRM_SUCCESS;    
    const DRM_CONST_STRING *pdstrString = NULL;
    DRM_CONST_STRING        dstrData = EMPTY_DRM_STRING;
    
    ChkDRMString( pdstrContentHeader );
    ChkArg( pdstrValue != NULL );

    if( chXPathSeparator == 0 )
    {
        chXPathSeparator = g_wchForwardSlash;
    }

    if( (eAttribute != DRM_HEADER_ATTRIB_OTHER) && ( NULL != pdstrAttrName ) )
    {
        /* If caller wants a known attribute -- we don't allow an attribute string */
        dr = DRM_E_INVALIDARG;
        goto ErrorExit;
    }
    
    ChkDR( _BasicHeaderChecks( pdstrContentHeader, &dstrData ) );    
    switch( eAttribute )
    {
    case DRM_HEADER_ATTRIB_VERSION:
        pdstrString = &g_dstrAttributeVersion;
        dr = DRM_XML_GetNodeAttribute( pdstrContentHeader, pdstrString, pdstrValue );        
        goto ErrorExit;
    case DRM_HEADER_ATTRIB_KID:
        pdstrString = &g_dstrTagKID;
        break;
    case DRM_HEADER_ATTRIB_LAINFO:
        pdstrString = &g_dstrTagLAINFO;
        break;
    case DRM_HEADER_ATTRIB_CHECKSUM:
        pdstrString = &g_dstrTagChecksum;
        break;
    case DRM_HEADER_ATTRIB_SECURITYVERSION:
        pdstrString = &g_dstrTagSecurityVersion;
        break;
    case DRM_HEADER_ATTRIB_OTHER:
        ChkArg( pdstrAttrName );
        pdstrString = pdstrAttrName;        
        break;
    default:
        return DRM_E_INVALIDARG;
    }

    ChkDR( DRM_XML_GetSubNodeByPath( &dstrData, pdstrString, NULL, NULL, NULL, pdstrValue, chXPathSeparator ) );
    dr = DRM_SUCCESS;

ErrorExit:
    return( dr );
}

DRM_RESULT DRM_API DRM_HDR_GetUplink(
    IN const DRM_CONST_STRING *pdstrContentHeader,
    IN       DRM_DWORD         dwUplinkNumber,
    OUT      DRM_CONST_STRING *pdstrKid )
{
    DRM_RESULT dr = DRM_SUCCESS;    
    DRM_CONST_STRING dstrString = EMPTY_DRM_STRING;

    ChkDRMString( pdstrContentHeader );
    ChkArg( pdstrKid != NULL );

    ChkDR( DRM_XML_GetSubNodeByPath( pdstrContentHeader, &g_dstrXPathHeaderUplinks, NULL, NULL, &dstrString, NULL, g_wchForwardSlash ) );
    ChkDR( DRM_XML_GetSubNode( &dstrString, &g_dstrTagUplink, NULL, NULL, dwUplinkNumber, NULL, pdstrKid, 1) );
ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_HDR_Verify(
    IN const DRM_CONST_STRING   *pdstrContentHeader,
    IN const DRM_CONST_STRING   *pdstrPubKey,
    IN       DRM_CRYPTO_CONTEXT *pContext,
    OUT      DRM_LONG           *plResult)
{
    DRM_RESULT       dr = DRM_E_LOGICERR;    
    DRM_CONST_STRING dstrSig  = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrData = EMPTY_DRM_STRING;    
    DRM_DWORD        dwSize = SIZEOF( PUBKEY );    
    
    ChkDRMString( pdstrPubKey );
    ChkDRMString( pdstrContentHeader );
    ChkArg( plResult != NULL
         && pContext != NULL );

    ChkDR(DRM_B64_DecodeW(pdstrPubKey, &dwSize, (DRM_BYTE *)&(pContext->pubKey), 0 ) );    
    ChkDR( _BasicHeaderChecks( pdstrContentHeader, &dstrData ) );
    
    if( DRM_FAILED( DRM_XML_GetSubNodeByPath( pdstrContentHeader, &g_dstrXPathSigValue, NULL, NULL, NULL, &dstrSig, g_wchForwardSlash ) ) )
    {
        dr = CH_INVALID_HEADER;
        goto ErrorExit;
    }

    dwSize = PK_ENC_SIGNATURE_LEN;
    if( DRM_FAILED(DRM_B64_DecodeW(&dstrSig, &dwSize, pContext->signature, 0 ) ) )
    {
        dr = CH_UNABLE_TO_VERIFY;
        goto ErrorExit;
    }

    if ( DRM_PK_Verify( pContext->rgbCryptoContext, 
                      &(pContext->pubKey), 
                      PB_DSTR(&dstrData), 
                      CB_DSTR(&dstrData),
                      pContext->signature) )
    {
        *plResult = 1;
    }
    else
    {
        *plResult = 0;
    }
    dr = DRM_SUCCESS;

ErrorExit:
    return( dr );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmhds.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#include "drmhds_impl.c"


/* Lock Order: 
** - Slot: to lock a slot SHARED/EXCLUSIVE among other processes
** - CS:  to guard exclusive access to file handle and local stack allocator
**        among other threads
** - SRN: to lock the SRN SHARED/EXCLUSIVE among other processes
*/


#if _MULTI_THREADING_SUPPORT==1

    #define DEFINE_LOCK_VARS \
        DRM_BOOL fStoreLocked=FALSE;\
        DRM_BOOL fSRNLocked=FALSE;\
        DRM_BOOL fCSEntered=FALSE;

    #define ENTER_HDS_CS(p)  {\
        OEM_EnterCriticalSection(&((p)->oCS));\
        fCSEntered = TRUE;\
    }

    #define LEAVE_HDS_CS(p)  {\
        if ( fCSEntered )\
        {\
            OEM_LeaveCriticalSection(&((p)->oCS));\
            fCSEntered = FALSE;\
        }\
    }

    #define LOCK_SRN( hds, mode )\
        ChkDR(_HdsLockSRN((hds), (mode)))\
        fSRNLocked = TRUE;

    #define UNLOCK_SRN(hds)  {\
        if (fSRNLocked)\
        {\
            _HdsUnlockSRN((hds));\
            fSRNLocked = FALSE;\
        }\
    }
    
    #define ENTER_CS_AND_LOCK_SRN(hds, mode)\
        ENTER_HDS_CS((hds));\
        LOCK_SRN( (hds), (mode) );

    #define UNLOCK_SRN_AND_LEAVE_CS(hds)\
        UNLOCK_SRN((hds));\
        LEAVE_HDS_CS((hds));

    #define LOCK_STORE(hds, mode)\
        ChkDR( _HdsLockStore( (hds), (mode) ) );\
        fStoreLocked = TRUE;
    
    #define UNLOCK_STORE(hds) {\
        if ( fStoreLocked )\
        {\
            _HdsUnlockStore((hds));\
            fStoreLocked = FALSE;\
        }\
    }
    
#else

    #define DEFINE_LOCK_VARS
    #define ENTER_HDS_CS(p)
    #define LEAVE_HDS_CS(p)
    #define LOCK_SRN( hds, mode )
    #define UNLOCK_SRN(hds)
    #define ENTER_CS_AND_LOCK_SRN(hds, mode)
    #define UNLOCK_SRN_AND_LEAVE_CS(hds)
    #define LOCK_STORE(hds, mode)
    #define UNLOCK_STORE(hds)

#endif




/******************************************************************************
** File Flushing scheme:
*******************************************************************************
** For performance, the following file flushing scheme is applied:
** If _DATASTORE_WRITE_THRU is #define'd, all write operation will be flushed to 
** disk immediately. If not, only when expanding file or creating new namespace 
** will cause flush. Caller is responsible to call DRM_HDS_CommitStore or
** DRM_HDS_CommitNamespace to flush the store at higher level.
*******************************************************************************
*/



/******************************************************************************
** Store locking scheme:
*******************************************************************************
** Function             Access       CS   Lock (temp)      Lock (Persistent)
*******************************************************************************
** Init                 n/a          n/a  n/a              n/a
** Uninit               n/a          n/a  n/a              n/a
** Commit store         n/a           Y   n/a              n/a
** Cleanup store        file          Y   SRN Exclusive    n/a
** Checkpoint           SRN           N   SRN Exclusive    n/a
** Create store         file          Y   file Exclusive   n/a
** Open store           SRN           Y   SRN Shared       n/a
** Close store          n/a           Y   n/a              n/a
** Commit Namespace     n/a          n/a  n/a              n/a
** Create Namespace     SRN,BLOCKS    Y   SRN Exclusive    n/a
** Open Namespace       SRN,BLOCKS    Y   SRN Shared       n/a
** Close Namespace      n/a          n/a  n/a              n/a
** Delete Namespace     SRN,BLOCKS    Y   Store Exclusive  n/a
** Create Slot          SRN,BLOCKS    Y   SRN Exclusive    Slot Shared/Exclusive
** Open Slot            SRN,BLOCKS    Y   SRN Shared       Slot Shared/Exclusive
** Close Slot           n/a          n/a  n/a              n/a 
** Seek Slot            n/a          n/a  n/a              Slot Shared/Exclusive
** Read Slot            n/a          n/a  n/a              Slot Shared/Exclusive
** Write Slot           n/a          n/a  n/a              Slot Shared/Exclusive
** Resize Slot          SRN,BLOCKS    Y   SRN Exclusive    Slot Shared/Exclusive
** Delete Slot          SRN,BLOCKS    Y   SRN Exclusive
** Init enum Slot       SRN,BLOCKS    Y   SRN Shared       Slot Shared/Exclusive
** Enum next Slot       SRN,BLOCKS    Y   SRN Shared       Slot Shared/Exclusive
**
** Note:
** -  Store level locks (SHARED and EXCLUSIVE) are issued at this file
**    only.
** -  Block level locks (SHARED and EXCLUSIVE) are issued at hds_impl.c
**    as needed
*******************************************************************************
*/



/**********************************************************************
** API functions
***********************************************************************
*/


DRM_RESULT DRM_API DRM_HDS_Init( 
    IN OUT DRM_HDS_CONTEXT *pcontextHDS)
{
    DRM_RESULT   dr=DRM_SUCCESS;
    _HdsContext *pHDS=(_HdsContext*)pcontextHDS;

    ChkArg(pcontextHDS);

    ZEROMEM(pHDS, SIZEOF(_HdsContext));
    pHDS->fp = OEM_INVALID_HANDLE_VALUE;

#if _MULTI_THREADING_SUPPORT==1
    OEM_InitializeCriticalSection(&pHDS->oCS);
#endif

ErrorExit:
    return dr;
}



DRM_RESULT DRM_API DRM_HDS_Uninit( 
    IN OUT DRM_HDS_CONTEXT *pcontextHDS)
{
    DRM_RESULT   dr=DRM_SUCCESS;
    _HdsContext *pHDS=(_HdsContext*)pcontextHDS;

    ChkArg(pcontextHDS);

#if _MULTI_THREADING_SUPPORT==1
    /* delete ciritical section */
    OEM_DeleteCriticalSection(&pHDS->oCS);
#endif

ErrorExit:
    return dr;
}




DRM_RESULT DRM_API DRM_HDS_CommitStore(
    IN DRM_HDS_CONTEXT *pcontextHDS )
{
    DRM_RESULT dr = DRM_SUCCESS;

    /*
    ** Note: 
    ** if _DATASTORE_WRITE_THRU is defined, file buffers are already flushed.
    ** There is no need to flush again.
    */

#if !_DATASTORE_WRITE_THRU
    _HdsContext *pHDS=(_HdsContext*)pcontextHDS;
    DEFINE_LOCK_VARS

    ChkArg(ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(pcontextHDS != NULL
          &&  pHDS->fInited 
          &&  pHDS->fp != OEM_INVALID_HANDLE_VALUE);

    /* enter CS to get exclusive access to file handle */
    ENTER_HDS_CS(pHDS);
    
    if (!OEM_FlushFileBuffers(pHDS->fp))
    {
        dr = DRM_E_FILEWRITEERROR;
    }

ErrorExit:

    LEAVE_HDS_CS(pHDS);
#endif

    return dr;
}


DRM_RESULT DRM_API DRM_HDS_CleanupStore(
    IN DRM_HDS_CONTEXT *pcontextHDS,
    IN DRM_BOOL         fWait)
{
    DRM_RESULT   dr=DRM_SUCCESS;
    _HdsContext *pHDS = (_HdsContext*)pcontextHDS;
    DEFINE_LOCK_VARS

    ChkArg(ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(pcontextHDS 
           && pHDS->fInited 
           && pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* 
    ** First, lock the store for EXCLUSIVE. So if there are any slots locked, 
    ** this call will fail, or wait until all locks are released
    */
    LOCK_STORE( pHDS, eDRM_HDS_LOCKEXCLUSIVE | (fWait ? eDRM_HDS_LOCKWAIT : 0) );
    ENTER_CS_AND_LOCK_SRN(pHDS, eDRM_HDS_LOCKEXCLUSIVE | (fWait ? eDRM_HDS_LOCKWAIT : 0) );

    dr = _HdsCleanupStore(pHDS);
    if ( DRM_SUCCEEDED(dr) )
    {
        if (!OEM_FlushFileBuffers(pHDS->fp))
        {
            dr = DRM_E_FILEWRITEERROR;
        }
    }
    
ErrorExit:
    UNLOCK_SRN_AND_LEAVE_CS(pHDS);
    UNLOCK_STORE(pHDS);
    return dr;
}


DRM_RESULT DRM_API DRM_HDS_CreateStore( 
    IN const DRM_WCHAR       *f_wszHdsName, 
    IN const DRM_DWORD        f_dwBlockSize,       /* block size is limited up to 64K */
    IN const DRM_HDSBLKNUM    f_eBlkNumType,
    IN OUT   DRM_HDS_CONTEXT *f_pcontextHDS,
    IN       DRM_BOOL         f_fTruncateExist)
{
   return DRM_HDS_CreateStore2( 
                f_wszHdsName, 
                f_dwBlockSize,
                f_eBlkNumType,
                f_pcontextHDS,
                f_fTruncateExist,
                0) ;
}


DRM_RESULT DRM_API DRM_HDS_CreateStore2( 
    IN const DRM_WCHAR       *wszHdsName, 
    IN const DRM_DWORD        dwBlockSize,       /* block size is limited up to 64K */
    IN const DRM_HDSBLKNUM    eBlkNumType,
    IN OUT   DRM_HDS_CONTEXT *pcontextHDS,
    IN       DRM_BOOL         fTruncateExist,
    IN const DRM_DWORD        nInitSizeinKB)
{
    DRM_RESULT      dr            = DRM_SUCCESS;    
    DRM_DWORD       nMinBlockSize = 0;
    _CommBlockHDR  *tmpBlock      = NULL;
    _ChildBlockHDR *tmpChild      = NULL;
    _HdsContext    *pHDS          = NULL;
    DRM_DWORD       i             = 0;
    DEFINE_LOCK_VARS

    /* Lock order:
    **   - CS
    **   - Whole Store
    */

    DRMASSERT(wszHdsName  != NULL
           && dwBlockSize != 0
           && pcontextHDS != NULL);
           
    DRMASSERT(eBlkNumType == eDRM_HDSBLKNUM_WORD 
           || eBlkNumType == eDRM_HDSBLKNUM_DWORD);

    /* check store name 
    ** Note: we expect the filename is NULL terminated.
    */
    for (i=0; ; i++)
    {
        if (wszHdsName[i] == g_wchNull)   /* empty filename is not allowed */
        {
            DRMASSERT(FALSE);
        }   
        if (wszHdsName[i] != g_wchSpace)
        {
            break;
        }
    }

    /* verify required min block size:
    ** SIZEOF generic header + SIZEOF child header + 1 Alloc table elem + 1 slotheader + SIZEOF datablock#
    */
    nMinBlockSize = SIZEOF(tmpBlock->File.bFileImage)        /* minimum _CommBlockHDR size */
                  + SIZEOF(tmpChild->File.bFileImage)        /* minimum _ChildBlockHDR size */
                  + (DRM_WORD)eBlkNumType                    /* 1 element in alloctable */
                  + SIZEOF(_SlotHeader)                      /* 1 _SlotHeader */
                  + SIZEOF(DRM_DWORD);                       /* Block num of _DataBlockHDR */
    if (dwBlockSize < nMinBlockSize)
    {
        TRACE(("Block size too small. Minimum size is %d.\n", nMinBlockSize));
        ChkDR(DRM_E_BUFFERTOOSMALL);    /* DRM_E_HDSBLOCKTOOSMALL */
    }

    {
        /* The few fields of RootNode is const, we cannot assign values 
        ** to them. Instead, we init values to a tmp and use memcpy to 
        ** the structure. 
        ** Note: the reason for const of the first 4 fields is to prevent 
        ** accidental alteration of the values in the program. If so, the 
        ** compiler will catch it.
        */
        _SRN tmpSRN;
        
        ZEROMEM(&tmpSRN, SIZEOF (tmpSRN));
        
        tmpSRN.dwSRNSize     = SIZEOF(_SRN); 
        tmpSRN.dwBlockSize   = dwBlockSize;
        tmpSRN.eBlockNumType = eBlkNumType; 
        
        pHDS=(_HdsContext*)pcontextHDS;
                
        MEMCPY(&pHDS->oSRN, &tmpSRN, SIZEOF(_SRN));
        ZEROMEM(pHDS->oSRN.bSRNHash, SIZEOF( pHDS->oSRN.bSRNHash ) );

        /* The following logic ensures:
        ** - if the store file exists, it is opened, locked exclusive and 
        **   truncated (if requested)
        ** - if the store file does not exist, it is created and locked exclusive.
        ** - All of the above are thread safe.
        */

        /* try Open the exist store */
        pHDS->fp = OEM_OpenFile(wszHdsName, OEM_GENERIC_READ|OEM_GENERIC_WRITE,
            OEM_FILE_SHARE_READ|OEM_FILE_SHARE_WRITE, OEM_OPEN_EXISTING, OEM_ATTRIBUTE_NORMAL);

        if (pHDS->fp == OEM_INVALID_HANDLE_VALUE)
        {
            /* store does not exist */
            pHDS->fp = OEM_OpenFile(wszHdsName, OEM_GENERIC_READ|OEM_GENERIC_WRITE,
                OEM_FILE_SHARE_READ|OEM_FILE_SHARE_WRITE, OEM_CREATE_NEW, OEM_ATTRIBUTE_NORMAL);
            if (pHDS->fp == OEM_INVALID_HANDLE_VALUE)
            {
                ChkDR(DRM_E_FILEWRITEERROR);
            }

            /* get EXCLUSIVE lock, do not wait */
            LOCK_STORE( pHDS, eDRM_HDS_LOCKEXCLUSIVE );
            ENTER_CS_AND_LOCK_SRN( pHDS, eDRM_HDS_LOCKEXCLUSIVE );
        }

        else if ( !fTruncateExist )
        {
            ChkDR(DRM_E_HDSFILEEXISTS);     /* found exists, do not truncate */
        }

        else
        {
            /* get EXCLUSIVE lock, do not wait */
            LOCK_STORE( pHDS, eDRM_HDS_LOCKEXCLUSIVE );
            ENTER_CS_AND_LOCK_SRN( pHDS, eDRM_HDS_LOCKEXCLUSIVE );
            
            /* truncate exist file */
            if (!OEM_SetFilePointer(pHDS->fp, 0, OEM_FILE_BEGIN, NULL))
            {
                ChkDR(DRM_E_FILESEEKERROR);
            }
            OEM_SetEndOfFile(pHDS->fp);
        }

        pHDS->fInited = TRUE;
        pHDS->eContextSignature = eHdsContextSignature;

        /* init internal stack info */
        pHDS->oHeap.pbStack = (DRM_BYTE*)&pHDS->oSRN + SIZEOF(_SRN);
        pHDS->oHeap.cbStack = pHDS->dwContextSize - SIZEOF(_HdsContext);
        pHDS->oHeap.nStackTop = 0;
        
        ChkDR(_HdsUpdateSRN(pHDS));
        if ( !OEM_FlushFileBuffers(pHDS->fp) )
        {
            dr = DRM_E_FILEWRITEERROR;
        }

        // prealloc file size
        if ( nInitSizeinKB > 0 )
        {
            /* ignore the error. */
            (void)_HdsPreAlloc( pHDS, nInitSizeinKB, TRUE, NULL);
        }
    }

ErrorExit:

    UNLOCK_SRN_AND_LEAVE_CS( pHDS );
    UNLOCK_STORE( pHDS );

    if ( pHDS != NULL )
    {
        if (pHDS->fp != OEM_INVALID_HANDLE_VALUE)
        {
            OEM_CloseFile(pHDS->fp);
        }
        
        /* we don't need it now, clear it */
        _ZeroHDSContextIgnoringCritSec(pHDS);
    }

    return dr;
}


DRM_RESULT DRM_API DRM_HDS_OpenStore( 
    IN const DRM_WCHAR       *f_wszHdsName, 
    OUT      DRM_HDS_CONTEXT *f_pcontextHDS )
{
    return DRM_HDS_OpenStore2(f_wszHdsName, f_pcontextHDS, 0);
}


DRM_RESULT DRM_API DRM_HDS_OpenStore2( 
    IN const DRM_WCHAR       *wszHdsName, 
       OUT   DRM_HDS_CONTEXT *pcontextHDS,
    IN const DRM_DWORD        nGrowbySizeinKB)
{
    DRM_RESULT     dr = DRM_SUCCESS;    
    _HdsContext   *pHDS=(_HdsContext *)pcontextHDS;
    _CommBlockHDR *tmpBlock=NULL;
    _DataBlockHDR *dataBlock=NULL;
    OEM_FILEHDL    fp=OEM_INVALID_HANDLE_VALUE;
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(L"DRM_HDS_OpenStore2", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    DRMASSERT(wszHdsName && pcontextHDS);

    /* initialize context */
#ifdef _CHKHDS_    
    /* chkhds utility opens the store in read only mode */
    fp = OEM_OpenFile(wszHdsName, OEM_GENERIC_READ,OEM_FILE_SHARE_READ, 
        OEM_OPEN_EXISTING, OEM_ATTRIBUTE_NORMAL);
#else
    fp = OEM_OpenFile(wszHdsName, OEM_GENERIC_READ|OEM_GENERIC_WRITE,
        OEM_FILE_SHARE_READ|OEM_FILE_SHARE_WRITE, OEM_OPEN_EXISTING, OEM_ATTRIBUTE_NORMAL);
#endif
    if ( OEM_INVALID_HANDLE_VALUE==fp )
    {
        pHDS->fp = OEM_INVALID_HANDLE_VALUE;
        ChkDR(DRM_E_FILENOTFOUND);
    }

    _ZeroHDSContextIgnoringCritSec(pHDS);

    pHDS->fp                = fp;
    pHDS->dwContextSize     = HDS_CONTEXT_LENGTH(SIZEOF(_SRN));
    pHDS->fInited           = TRUE;
    pHDS->nGrowbySizeinKB   = nGrowbySizeinKB;
    pHDS->eContextSignature = eHdsContextSignature;

    /* Lock SRN SHARED among other processes */
    ENTER_CS_AND_LOCK_SRN(pHDS, (eDRM_HDS_LOCKSHARED | eDRM_HDS_LOCKWAIT));

    /* init internal stack info */
    pHDS->oHeap.pbStack = (DRM_BYTE*)&pHDS->oSRN + SIZEOF(_SRN);
    pHDS->oHeap.cbStack = pHDS->dwContextSize - SIZEOF(_HdsContext);
    pHDS->oHeap.nStackTop = 0;

    ChkDR(_HdsLoadSRN(pHDS));

    /* compute handy info */
    pHDS->nImagesize_FileBlockHDR = SIZEOF(tmpBlock->File._image.ui64TimeStamp)
                                  + SIZEOF(tmpBlock->File._image.bBlockHash)
                                  + SIZEOF(tmpBlock->File._image.nParentBlockNum)
                                  + 1; /* SIZEOF(tmpBlock->File._image.bBlockType) */;
    pHDS->nImagesize_DataBlockHDR = SIZEOF(dataBlock->File._image.nCascadingBlockNum);
    pHDS->nDataBlockPayloadPos    = pHDS->nImagesize_FileBlockHDR 
                                  + pHDS->nImagesize_DataBlockHDR;
    if( pHDS->oSRN.dwBlockSize <= pHDS->nDataBlockPayloadPos )
    {
        /* Not enough room in each block for any data */
        ChkDR(DRM_E_HDSINVALIDSTORE);
    }

    pHDS->nImagesize_DataBlockPayload = pHDS->oSRN.dwBlockSize - pHDS->nDataBlockPayloadPos;

ErrorExit:

    UNLOCK_SRN_AND_LEAVE_CS(pHDS);
    
    if (DRM_FAILED(dr))
    {
        if ( pHDS != NULL )
        {
            _ZeroHDSContextIgnoringCritSec(pHDS);
        }
        if ( fp != OEM_INVALID_HANDLE_VALUE)
        {
            OEM_CloseFile( fp );
        }
    }
    
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_HDS_OpenStore2", g_pwszLeavingFunction);

    return dr;
}


/*
**
*/
DRM_RESULT DRM_API DRM_HDS_CloseStore( 
    IN DRM_HDS_CONTEXT *pcontextHDS )
{
    DRM_RESULT   dr = DRM_SUCCESS;
    _HdsContext *pHDS=(_HdsContext*)pcontextHDS;
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(L"DRM_HDS_CloseStore", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
    ChkArg(pHDS && ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(pcontextHDS && pHDS->fInited);


    /* Lock Order: 
    ** - CS:  to guard exclusive access to file handle
    */
    ENTER_HDS_CS(pHDS);

    if ( pHDS->fp != OEM_INVALID_HANDLE_VALUE )
    {
        OEM_CloseFile( pHDS->fp );
        pHDS->fp = OEM_INVALID_HANDLE_VALUE;
    }
    
    _ZeroHDSContextIgnoringCritSec(pHDS);

ErrorExit:    
    LEAVE_HDS_CS(pHDS);
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_HDS_CloseStore", g_pwszLeavingFunction);

    return dr;
}



/*
**
*/
DRM_RESULT DRM_API DRM_HDS_CommitNamespace(
    IN DRM_HDS_NAMESPACE_CONTEXT *pcontextNS)
{
    DRM_RESULT  dr = DRM_SUCCESS;
    _NsContext *pUserNsCFG = (_NsContext *)pcontextNS;

    ChkArg( pcontextNS != NULL  
        &&  ISVALIDCONTEXT(pUserNsCFG, eCfgContextSignature));

    /* we do not need to do any locking, DRM_HDS_CommitStore will do it 
    */
    ChkDR(DRM_HDS_CommitStore( (DRM_HDS_CONTEXT *)(pUserNsCFG->pHDS) ));

ErrorExit:

    return dr;
}




/******************************************************************************
** 
** Function :   DRM_HDS_OpenNamespace
** 
** Synopsis :   Opens/creates a namespace
** 
** Arguments :  pcontextHDS - HDS context
**              pNamespace  - Namespace identifier to be opened/created
**              eOpenMode   - eDRM_HDS_CREATE_IF_NEW / eDRM_HDS_OPEN_EXISTING
**              wMaxNumChildren - Number of children if a new namespace is to
**                                be created
**              pcontextNS  - Namespace context
** 
** Returns :    DRM_E_HDSNAMESPACENOTFOUND - if namespace is not found and 
**                  request is only to open existing existing namespace
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_HDS_OpenNamespace(
    IN       DRM_HDS_CONTEXT           *pcontextHDS,    
    IN const DRM_HDS_NAMESPACE         *pNamespace,
    IN       DRM_HDS_OPENMODE           eOpenMode,
    IN       DRM_WORD                   wMaxNumChildren,
    OUT      DRM_HDS_NAMESPACE_CONTEXT *pcontextNS )
{
    DRM_RESULT   dr     = DRM_E_HDSNAMESPACENOTFOUND;
    _HdsContext *pHDS   = (_HdsContext*)pcontextHDS;
    DEFINE_LOCK_VARS
    DRM_PROFILING_ENTER_SCOPE(L"DRM_HDS_OpenNamespace", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    DRMASSERT( ( eOpenMode & eDRM_HDS_CREATE_IF_NEW ) != 0
            || ( eOpenMode & eDRM_HDS_OPEN_EXISTING ) != 0);
    DRMASSERT( pcontextHDS != NULL );    

    /* Lock SRN EXCLUSIVE */
    ENTER_CS_AND_LOCK_SRN(pHDS, (eOpenMode | eDRM_HDS_LOCKEXCLUSIVE));

	dr = DRM_E_HDSNAMESPACENOTFOUND;
    if ( (pHDS->oSRN.nNsStoreRootBlockNum > 0) )
    {
        /* open existing */
        dr = _HdsOpenExistingNamespace(pcontextHDS, pNamespace, pcontextNS);
        if ( DRM_SUCCEEDED(dr) )
        {
            goto ErrorExit;
        }
    }

    /* namespace not found and caller ask to create new */
    if ( dr == DRM_E_HDSNAMESPACENOTFOUND  &&  (eOpenMode & eDRM_HDS_CREATE_IF_NEW) != 0 )
    {        
        ChkDR( _HdsCreateNamespace( 
                    pcontextHDS, 
                    pNamespace,
                    wMaxNumChildren,
                    (eOpenMode & eDRM_HDS_LOCKWAIT)!=0 ) );

        dr = _HdsOpenExistingNamespace(pcontextHDS, pNamespace, pcontextNS);
    }

ErrorExit:
    UNLOCK_SRN_AND_LEAVE_CS(pHDS);
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_HDS_OpenNamespace", g_pwszLeavingFunction);
    return dr;
}


/*
**
*/
DRM_RESULT DRM_API DRM_HDS_CloseNamespace(
    IN DRM_HDS_NAMESPACE_CONTEXT *pcontextNS)
{
    DRM_RESULT    dr=DRM_SUCCESS;
    _HdsContext  *pHDS=NULL;
    _NsContext   *pUserNsCFG=(_NsContext *)pcontextNS;
    _SlotContext *pNsStoreSlotCtx=NULL;
    DEFINE_LOCK_VARS

        
    ChkArg(pcontextNS != NULL 
        && ISVALIDCONTEXT(pUserNsCFG, eCfgContextSignature));
    DRMASSERT(pcontextNS != NULL
           && pUserNsCFG->fInited 
           && pUserNsCFG->pHDS 
           && pUserNsCFG->pHDS->fp != OEM_INVALID_HANDLE_VALUE );

#if DBG
{
    /* let's check if the namespace is valid
    ** this may be redandunt so just do it in DBG build 
    */

    DRM_HDS_HASHKEY   oNsHashKey;
    DRM_HDS_UNIQUEKEY oNsUniqueKey;
    DRM_BOOL          fResult=FALSE;
    DRM_DWORD         cbNsStoreSlotCtx=0;
    _NsContext        oNsStoreCFG;

    pHDS = pUserNsCFG->pHDS;

    /* lock SRN SHARED among other processes */
    ENTER_CS_AND_LOCK_SRN(pHDS, (eDRM_HDS_LOCKSHARED | eDRM_HDS_LOCKWAIT));

    /* First, set up a NS context for accessing the NamespaceStore */
    ChkDR(_HdsInitNsContext(pUserNsCFG->pHDS, &oNsStoreCFG, NULL, 
        pUserNsCFG->pHDS->oSRN.nNsStoreRootBlockNum, NsStoreNumofChildren));

    /* Second, alloc buffer and setup _SlotContext (pNsStoreSlotCtx) to store  
    ** the given namespace in NamespaceStore
    */
    cbNsStoreSlotCtx = CALC_SLOTCONTEXTLEN(&oNsStoreCFG);  /* size of slot context */
    ChkDR(_Hds_malloc(pUserNsCFG->pHDS, cbNsStoreSlotCtx, (DRM_VOID**)&pNsStoreSlotCtx));
    ChkDR(_HdsInitSlotContext(&oNsStoreCFG, (DRM_BYTE *)pNsStoreSlotCtx, 
        cbNsStoreSlotCtx));

    /* Last, search if the namespace is still exist in file */
    _GenNamespaceKeys(&pUserNsCFG->pHDS->contextMD5, (DRM_CHAR *)pUserNsCFG->oNamespace, 
        DRM_HDS_NSNAME_SIZE, oNsHashKey.rgb, oNsUniqueKey.rgb);
    ChkDR(_HdsSearchSlotInFile(&oNsStoreCFG, &oNsHashKey, &oNsUniqueKey, eSearchNamespace, 
        NULL, pNsStoreSlotCtx, &fResult));
    if ( !fResult )
    {
        TRACE(("DRM_HDS_CloseNamespace(): namespace '%s' does not exist.\n", pUserNsCFG->oNamespace));
        ChkDR(DRM_E_HDSNAMESPACENOTFOUND);
    }
}
#endif /* DBG */

    /* wipe the context */
    ZEROMEM(pcontextNS, SIZEOF(_NsContext));

ErrorExit:
#if DBG
    if ( pNsStoreSlotCtx )
    {
        _Hds_free(pHDS, pNsStoreSlotCtx);
    }

    UNLOCK_SRN_AND_LEAVE_CS(pHDS);
#endif

    return dr;      
}

/*
**  This function is not being used anywhere. It was included for completeness
**  of the HDS API. It will be updated if needed.
*/
DRM_RESULT DRM_API DRM_HDS_DeleteNamespace( 
    IN       DRM_HDS_CONTEXT   *pcontextHDS,
    IN const DRM_HDS_NAMESPACE *pNamespace,
    IN       DRM_BOOL           fWait)
{
    DRM_RESULT        dr=DRM_SUCCESS;
    DRM_HDS_HASHKEY   oNsHashKey;
    DRM_HDS_UNIQUEKEY oNsUniqueKey;
    DRM_BOOL          fResult=FALSE;
    _HdsContext      *pHDS=(_HdsContext*)pcontextHDS;
    _NsContext        oNsStoreCFG;
    _SlotContext     *pNsStoreSlotCtx=NULL;
    DRM_DWORD         cbNsStoreSlotCtx=0;
    DRM_DWORD         cbNsSlotSize=0;
    _NsContext       *pcontextNS=NULL;
    _NSEntry         *pNsEntry=NULL;
    DEFINE_LOCK_VARS

    ChkArg(pcontextHDS != NULL
        && pNamespace  != NULL
        && ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(pcontextHDS != NULL
          &&  pHDS->fInited 
          &&  pNamespace  != NULL
          &&  pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* 
    ** Lock STORE EXCLUSIVE among other processes. So if there are any 
    ** locked slots, this call will fail, or wait until all locks are released
    */
    LOCK_STORE( pHDS,  eDRM_HDS_LOCKEXCLUSIVE | (fWait ? eDRM_HDS_LOCKWAIT : 0) );
    ENTER_CS_AND_LOCK_SRN(pHDS, eDRM_HDS_LOCKEXCLUSIVE | (fWait ? eDRM_HDS_LOCKWAIT : 0) );

    /*  First, set up a HDS Config (oNsStoreCFG) for accessing the NamespaceStore 
    */
    ChkDR(_HdsInitNsContext(pHDS, &oNsStoreCFG, NULL, pHDS->oSRN.nNsStoreRootBlockNum, 
        NsStoreNumofChildren));

    /* Second, alloc buffer and setup _SlotContext (pNsStoreSlotCtx) to store the given 
    ** namespace in NamespaceStore
    */
    cbNsStoreSlotCtx = CALC_SLOTCONTEXTLEN(&oNsStoreCFG);  /* size of slot context */
    ChkDR(_Hds_malloc(pHDS, cbNsStoreSlotCtx, (DRM_VOID**)&pNsStoreSlotCtx));
    ChkDR(_HdsInitSlotContext(&oNsStoreCFG, (DRM_BYTE *)pNsStoreSlotCtx, cbNsStoreSlotCtx));

    /* Third, prepare the namespace key and search it in NamespaceStore
    */
    _GenNamespaceKeys (&pHDS->contextMD5, 
           (DRM_CHAR *) pNamespace->rgb, 
                        DRM_HDS_NSNAME_SIZE, 
                        oNsHashKey.rgb, 
                        oNsUniqueKey.rgb);
    ChkDR(_HdsSearchSlotInFile(&oNsStoreCFG, &oNsHashKey, &oNsUniqueKey, eSearchNamespace,
        &cbNsSlotSize, pNsStoreSlotCtx, &fResult));
    if ( !fResult )
    {
        TRACE(("DRM_HDS_DeleteNamespace(): namespace '%s' does not exist.\n", pNamespace->rgb));
        ChkDR(DRM_E_HDSNAMESPACENOTFOUND);
    }
    else
    {
        DRM_HDS_HASHKEY   oHashKey; 
        DRM_HDS_UNIQUEKEY oUniqueKey;
    
        /* allocate buffer and load the User's namespace entry from NsStore */
        ChkDR(_Hds_malloc(pHDS, cbNsSlotSize, (DRM_VOID**)&pNsEntry));

        ChkDR(_HdsSlotRead(pNsStoreSlotCtx, cbNsSlotSize, (DRM_BYTE *)pNsEntry, NULL));

        FIX_ENDIAN_WORD( pNsEntry->wMaxNumChildren );
        FIX_ENDIAN_DWORD( pNsEntry->nNSRBlockNum );
            ChkDR(_HdsValidateNSEntryFromDisk( pHDS, pNsEntry ) );

        /* setup cfg context for the namespace */
        ChkDR(_Hds_malloc(pHDS, SIZEOF(_NsContext), (DRM_VOID**)&pcontextNS));
        ChkDR(_HdsInitNsContext(pHDS, pcontextNS, pNamespace, pNsEntry->nNSRBlockNum,
            pNsEntry->wMaxNumChildren));

        /* delete the namespace's subtree */
        ChkDR(_HdsDeleteSubTree(pcontextNS, pNsEntry->nNSRBlockNum));

        /* delete the Config's slot in NamespaceStore */
        /*ChkDR(_HdsCloseSlot(pNsStoreSlotCtx)); */

        MEMCPY(oHashKey.rgb,   oNsHashKey.rgb,   DRM_HDS_HASHKEY_SIZE);
        MEMCPY(oUniqueKey.rgb, oNsUniqueKey.rgb, DRM_HDS_UNIQUEKEY_SIZE);

        ChkDR( _HdsRemoveSlot(pNsStoreSlotCtx, eRemoveSlotPermanent ) );
    }

ErrorExit:
    if ( pcontextNS )
    {
        _Hds_free(pHDS, pcontextNS);
    }
    if ( pNsEntry )
    {
        _Hds_free(pHDS, pNsEntry);
    }
    if ( pNsStoreSlotCtx )
    {
        _Hds_free(pHDS, pNsStoreSlotCtx);
    }

    UNLOCK_SRN_AND_LEAVE_CS(pHDS);
    UNLOCK_STORE(pHDS);
    return dr;      
}

/*
**
*/
DRM_RESULT DRM_API DRM_HDS_DeleteSlot( 
    IN       DRM_HDS_NAMESPACE_CONTEXT *pcontextNS,    /* Namespace context returned from DRM_HDS_OpenNamespace */
    IN const DRM_HDS_HASHKEY           *pHashKey, 
    IN const DRM_HDS_UNIQUEKEY         *pUniqueKey,
    IN       DRM_HDS_SLOT_HINT         *pSlotHint,
    IN       DRM_BOOL                   fWait)
{
    DRM_RESULT       dr             = DRM_SUCCESS;
    _NsContext      *pNS            = (_NsContext*)pcontextNS;
    _SlotContext    *pSlotCtx       = NULL;
    DRM_BOOL         fValid         = FALSE;
    DRM_BOOL         fBlockLocked   = FALSE;
    DRM_DWORD        cbSlotSize     = 0;
    DRM_BYTE         rgbBuff [__CB_DECL(CALC_MAXSLOTCONTEXTLEN)];
    DEFINE_LOCK_VARS
    
    ChkArg(pcontextNS != NULL
       && ISVALIDCONTEXT(pNS, eCfgContextSignature));
    DRMASSERT(pcontextNS 
          &&  pNS->fInited
          &&  pHashKey   != NULL
          &&  pUniqueKey != NULL
          &&  pNS->pHDS  != NULL
          &&  pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* initialize slot context structure */
    
    pSlotCtx = (_SlotContext *) rgbBuff;

    ChkDR(_HdsInitSlotContext(pNS, (DRM_BYTE*)pSlotCtx, CALC_SLOTCONTEXTLEN(pNS)));
                        
    /* Lock SRN SHARED among other processes. */
    ENTER_CS_AND_LOCK_SRN( pNS->pHDS, ~eDRM_HDS_LOCKEXCLUSIVE & eDRM_HDS_LOCKWAIT );
    
    while ( TRUE )
    { 
        if ( pSlotHint != NULL )
        {
            dr = _HdsOpenSlotFromHint(pNS, pHashKey, pUniqueKey, (_SlotHint*)pSlotHint, TRUE, &cbSlotSize, pSlotCtx);
        }
        
        if ( pSlotHint == NULL
            || DRM_FAILED ( dr ) )
        {
            ChkDR( _HdsOpenExistingSlot(pNS, pHashKey, pUniqueKey, TRUE, &cbSlotSize, pSlotCtx) );
        }

        ChkDR( _HdsLockBlock2DeleteSlot( 
                    pSlotCtx, 
                    eDRM_HDS_LOCKEXCLUSIVE | (fWait ? eDRM_HDS_LOCKWAIT : 0) ) );                            
        fBlockLocked = TRUE;

        ChkDR(_HdsVerifySlotContext(pSlotCtx, &fValid));

        if ( fValid )
        {
            break;
        }

        /* slot context verified failed, try again */
        (void)_HdsUnlockBlock2DeleteSlot(pSlotCtx);
        fBlockLocked = FALSE;        
    } 

    /*
    **  We currently have the lock on the block as well as CS and SRN lock
    */
    ChkDR( _HdsRemoveSlot(pSlotCtx, eRemoveSlotPermanent) );
    
    if ( pSlotHint != NULL )
    {
        ZEROMEM ( pSlotHint, DRM_HDS_SLOT_HINT_LEN );
    }

ErrorExit:  

    if ( fBlockLocked )
    {
        /* error occured during verifying slot context, return error */
        (void)_HdsUnlockBlock2DeleteSlot(pSlotCtx);
    }
        
    if (pNS != NULL)
    {
        UNLOCK_SRN_AND_LEAVE_CS(pNS->pHDS);
    }
    return dr;
}



DRM_RESULT DRM_API DRM_HDS_Checkpoint( 
    IN OUT   DRM_HDS_CONTEXT *pcontextHDS,
    IN       DRM_VOID        *pvOpaqueData,
    IN       DRM_BOOL         fCreate)                /* TRUE to create, FALSE to verify */
{
    DRM_RESULT   dr=DRM_SUCCESS;
    _HdsContext *pHDS=(_HdsContext*)pcontextHDS;
    DRM_DWORD    dwByte=0;
    DRM_BYTE     hash[__CB_DECL(MD5DIGESTLEN)];
    DRM_DWORD    dwNumberOfBytesIO;
    DEFINE_LOCK_VARS

    ChkArg(pHDS!=NULL  
       &&  ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(pcontextHDS 
           && pHDS->fInited
           && pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    if ( fCreate )
    {
        DRM_UINT64 timeStamp = _GetTimeStamp();
        
        /* Wait and lock SRN EXCLUSIVE among other processes. */
        ENTER_CS_AND_LOCK_SRN(pHDS, (eDRM_HDS_LOCKEXCLUSIVE | eDRM_HDS_LOCKWAIT));

        /* create checkpoint using timestamp */
        DRM_MD5_Init( &pHDS->contextMD5 );
        DRM_MD5_Update( &pHDS->contextMD5, (DRM_BYTE*)&timeStamp, SIZEOF(DRM_UINT64));
        DRM_MD5_Final( &pHDS->contextMD5 );
        MEMCPY( hash, pHDS->contextMD5.digest, SIZEOF( pHDS->contextMD5.digest ) );

        /* write the hash to file right after SRN */
        if (!OEM_SetFilePointer(pHDS->fp, SIZEOF(DRM_DWORD)+SIZEOF(_SRN), OEM_FILE_BEGIN, NULL))
        {
            ChkDR(DRM_E_FILESEEKERROR);
        }
        if (!OEM_WriteFile(pHDS->fp, hash, __CB_DECL(MD5DIGESTLEN), &dwNumberOfBytesIO) 
            || dwNumberOfBytesIO != __CB_DECL(MD5DIGESTLEN))
        {
            ChkDR(DRM_E_FILEWRITEERROR);
        }

        /* Set datastore redundancy entry */
        ChkDR( OEM_GetSetDataStoreRedundancy(pvOpaqueData,(DRM_BYTE*)&timeStamp,SIZEOF(DRM_UINT64),FALSE));
    }
    else
    {
        DRM_BYTE   _hash[__CB_DECL(MD5DIGESTLEN)];
        DRM_UINT64 timeStamp;

        /* Wait and lock SRN SHARED among other processes. */
        ENTER_CS_AND_LOCK_SRN(pHDS, (eDRM_HDS_LOCKSHARED | eDRM_HDS_LOCKWAIT));

        /* Get datastore redundancy entry */
        dr = OEM_GetSetDataStoreRedundancy(pvOpaqueData,(DRM_BYTE*)&timeStamp,SIZEOF(DRM_UINT64),TRUE);
        if (DRM_FAILED(dr))
        {
            /* datastore redundancy entry not found. just return ok, for now ... */
            dr = DRM_SUCCESS;
            goto ErrorExit;
        }

        /* create hash using restored timestamp from datastore redundancy entry */
        DRM_MD5_Init( &pHDS->contextMD5 );
        DRM_MD5_Update( &pHDS->contextMD5, (DRM_BYTE*)&timeStamp,SIZEOF(DRM_UINT64));
        DRM_MD5_Final( &pHDS->contextMD5 );
        MEMCPY( hash, pHDS->contextMD5.digest, SIZEOF( pHDS->contextMD5.digest ) );

        /* load hash from file */
        if (!OEM_SetFilePointer(pHDS->fp, SIZEOF(DRM_DWORD)+SIZEOF(_SRN), OEM_FILE_BEGIN, NULL))
        {
            ChkDR(DRM_E_FILESEEKERROR);
        }
        if (!OEM_ReadFile(pHDS->fp, _hash, __CB_DECL(MD5DIGESTLEN), &dwNumberOfBytesIO) 
            || dwNumberOfBytesIO != __CB_DECL(MD5DIGESTLEN))
        {
            ChkDR(DRM_E_FILEREADERROR);
        }

        if ( MEMCMP(hash, _hash, __CB_DECL(MD5DIGESTLEN)) != 0 )
        {
            ChkDR(DRM_E_HASHMISMATCH);
        }
    }

ErrorExit:

    UNLOCK_SRN_AND_LEAVE_CS(pHDS);
    return dr;
}

/* Initialize a slot hint based on the slot context passed */
DRM_RESULT DRM_API DRM_HDS_MakeSlotHint(
    IN     DRM_HDS_SLOT_CONTEXT      *pcontextSlot,
    IN OUT DRM_HDS_SLOT_HINT         *pslotHint)
{
    DRM_RESULT    dr        = DRM_SUCCESS;
    _SlotContext *pSlotCtx  = (_SlotContext*)pcontextSlot;
    _SlotHint *pHint        = (_SlotHint*)pslotHint;

    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(pcontextSlot != NULL
          &&  pslotHint != NULL
          &&  pSlotCtx->pNS != NULL
          &&  pSlotCtx->pNS->pHDS != NULL
          &&  pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);
    DRMSIZEASSERT( SIZEOF( DRM_HDS_SLOT_CONTEXT ), CALC_MAXSLOTCONTEXTLEN );

    pHint->nBlockNum = pSlotCtx->oFileBlock.nBlockNum;
    pHint->nSlotPosInBlock = pSlotCtx->dwSlotPosInBlock;

ErrorExit:
    if( DRM_FAILED( dr )
        && pslotHint != NULL )
    {
        ZEROMEM( pslotHint, SIZEOF( _SlotHint ) );
    }
    
    return dr;
}

/* 
** Create or open dataslot using given key1 and key2 
*/
DRM_RESULT DRM_API DRM_HDS_OpenSlot( 
    IN     DRM_HDS_NAMESPACE_CONTEXT *pcontextNS,   /* Namespace context returned from DRM_HDS_OpenNamespace */
    IN     DRM_DWORD                  dwMode,       /* combo of DRM_HDS_OPENMODE and DRM_HDS_LOCKMODE */
    IN     const DRM_HDS_HASHKEY     *pHashKey, 
    IN     const DRM_HDS_UNIQUEKEY   *pUniqueKey, 
    IN     DRM_HDS_SLOT_HINT         *pSlotHint,
    IN OUT DRM_DWORD                 *pcbSlotSize,  /* current dataslot size */
    OUT    DRM_HDS_SLOT_CONTEXT      *pcontextSlot) /* user given Dataslot context buffer */
{
    DRM_RESULT    dr=DRM_SUCCESS;
    _NsContext   *pNS=(_NsContext*)pcontextNS;
    _SlotContext *pSlotCtx=NULL;
    DRM_BOOL      fSlotLocked = FALSE;
    DRM_BOOL      fValid        = FALSE;
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(L"DRM_HDS_OpenSlot", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature)
        && pHashKey != NULL
        && pUniqueKey != NULL
        && !_IsNULL(pHashKey->rgb, DRM_HDS_HASHKEY_SIZE));
    DRMASSERT(pcontextNS != NULL
          && pcontextSlot != NULL
          && pNS->fInited 
          && pNS->nCfgRootBlockNum > 0
          && pNS->pHDS != NULL
          && pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE
          && ((dwMode & eDRM_HDS_CREATE_IF_NEW) || (dwMode & eDRM_HDS_OPEN_EXISTING)) );
    DRMSIZEASSERT( SIZEOF( DRM_HDS_SLOT_CONTEXT ), CALC_MAXSLOTCONTEXTLEN );

    /* check slot size */
    if ( (SIZEOF(_SlotHeader) + (*pcbSlotSize)) < (*pcbSlotSize) )
    {
        /* (*pcbSlotSize) is a negative number */
        ChkDR(DRM_E_INVALID_HDSSLOTSIZE);
    }

    /* initialize slot context structure */
    ChkDR(_HdsInitSlotContext(pNS, (DRM_BYTE*)pcontextSlot,SIZEOF(DRM_HDS_SLOT_CONTEXT)));
    pSlotCtx = (_SlotContext*)pcontextSlot;
            
    while ( TRUE )
    {
        /* Lock SRN SHARED among other processes. */
        ENTER_CS_AND_LOCK_SRN(pNS->pHDS, (dwMode & (~eDRM_HDS_LOCKEXCLUSIVE)));


        /* try if we can open the slot first */
        if ( pSlotHint != NULL )
        {
            dr = _HdsOpenSlotFromHint(pNS, pHashKey, pUniqueKey, (_SlotHint*)pSlotHint, TRUE, pcbSlotSize, pSlotCtx);

            if ( DRM_FAILED(dr) )
            {
                dr = _HdsOpenExistingSlot(pNS, pHashKey, pUniqueKey, TRUE, pcbSlotSize, pSlotCtx);

                if ( DRM_SUCCEEDED(dr) )
                {
                    DRM_HDS_MakeSlotHint(pcontextSlot, pSlotHint);
                }
            }
        }
        else
        {
            dr = _HdsOpenExistingSlot(pNS, pHashKey, pUniqueKey, TRUE, pcbSlotSize, pSlotCtx);
        }

        /* slot exists but caller ask to create new only */
        if ( DRM_SUCCEEDED(dr)  &&  (dwMode & eDRM_HDS_OPEN_EXISTING) == 0 )
        {
            ChkDR(DRM_E_HDSSLOTEXIST);
        }

        /* slot does not exist and caller asked to create new */
        if ( dr == DRM_E_HDSSLOTNOTFOUND && (dwMode & eDRM_HDS_CREATE_IF_NEW) != 0)
        {
            if ( (dwMode & eDRM_HDS_LOCKEXCLUSIVE) == 0 )
            {
                ChkDR(DRM_E_HDSEXCLUSIVELOCKONLY);
            }
        
            UNLOCK_SRN( pNS->pHDS );  
            
            /* Lock SRN EXCLUSIVE among other processes. */
            LOCK_SRN( pNS->pHDS, dwMode | eDRM_HDS_LOCKEXCLUSIVE );
            
            /* 
            **  note: _HdsCreateAndOpenSlot() will issue lock for the slot             
            */
            ChkDR( _HdsCreateAndOpenSlot( pNS, 
                                   pHashKey, 
                                   pUniqueKey, 
                                   TRUE, 
                                   *pcbSlotSize, 
                                   pSlotCtx, 
                                   dwMode ) );
            fSlotLocked = TRUE;

            break;                            
        }

        /* return if other error */
        ChkDR(dr);

        /* here, a slot exists and caller is asking to open existing ...
        ** drop all the locks and CS to allow concurrency to occur 
        ** while waiting for the slot lock 
        */
        UNLOCK_SRN_AND_LEAVE_CS(pNS->pHDS);

        /* issue specific slot lock */
        ChkDR(_HdsLockSlot(pSlotCtx, dwMode));
        fSlotLocked = TRUE;

        /* we got the lock to the slot, let's verify the sanity of the slot 
        ** we need to enter CS and lock SRN again */
        ENTER_CS_AND_LOCK_SRN(pNS->pHDS, (dwMode & (~eDRM_HDS_LOCKEXCLUSIVE)));

        ChkDR(_HdsVerifySlotContext(pSlotCtx, &fValid));

        /* drop all the locks and CS again */
        UNLOCK_SRN_AND_LEAVE_CS(pNS->pHDS);

        if ( fValid )
        {
            break;
        }

        /* slot context verified failed, try again */
        (void)_HdsUnlockSlot(pSlotCtx);
        fSlotLocked = FALSE;        
    }    

ErrorExit:
    if ( pNS != NULL  &&  pNS->pHDS != NULL )
    {
        if ( DRM_FAILED(dr)  &&  fSlotLocked )
        {
            /* error occured during verifying slot context, return error */
            _HdsUnlockSlot(pSlotCtx);
        }

        UNLOCK_SRN_AND_LEAVE_CS(pNS->pHDS);
    }
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_HDS_OpenSlot", g_pwszLeavingFunction);
    
    return dr;
}

/*
**
*/
DRM_RESULT DRM_API DRM_HDS_CloseSlot( 
    IN DRM_HDS_SLOT_CONTEXT *pcontextSlot)
{
    DRM_RESULT    dr=DRM_SUCCESS;
    _SlotContext *pSlotCtx=(_SlotContext*)pcontextSlot;
    _HdsContext  *pHDS=NULL;
    DEFINE_LOCK_VARS

    ChkArg(pcontextSlot != NULL
        && ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(pcontextSlot != NULL
          && pSlotCtx->pNS 
          && pSlotCtx->pNS->pHDS 
          && pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);
    if (pSlotCtx->eStatus==eSlotCtxUninit)
    {
        ChkDR(DRM_E_HDSSLOTNOTFOUND);
    }    

    ChkDR(_HdsUnlockSlot(pSlotCtx));
    ChkDR(_HdsCloseSlot(pSlotCtx));

ErrorExit:
    return dr;
}


/*
**
*/
DRM_RESULT DRM_API DRM_HDS_SlotSeek( 
    IN       DRM_HDS_SLOT_CONTEXT *pcontextSlot,
    IN const DRM_LONG              lOffset,
    IN const DRM_HDS_SEEKMODE      eOrigin,         /* as defined above */
    OUT      DRM_DWORD            *pdwSeekPointer)   /* optional parameter, can be NULL */
{
    DRM_RESULT    dr=DRM_SUCCESS;
    _SlotContext *pSlotCtx=(_SlotContext*)pcontextSlot;

    ChkArg(pcontextSlot != NULL
        && ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(pcontextSlot != NULL
          && pSlotCtx->pNS != NULL 
          && pSlotCtx->pNS->pHDS != NULL
          && pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* Note:
    ** - We do not need to enter CS because we do not need access to file handle
    **   and Local stack
    ** - this slot is either locked for SHARED or EXCLUSIVE. We do not need to 
    **   worry if it is changed after it is opened 
    */
    if (pSlotCtx->eStatus!=eSlotCtxReady)
    {
        ChkDR(DRM_E_HDSSLOTNOTFOUND);
    }
    switch ( eOrigin )
    {
        case eDRM_HDS_SEEKCUR:
            if ( lOffset > 0 )
            {
                if ( (pSlotCtx->dwSeekPointer+lOffset) > pSlotCtx->oSlotHeader.dwSlotSize )
                {
                    ChkDR(DRM_E_HDSSEEKERROR);
                }
                pSlotCtx->dwSeekPointer += lOffset;
            }
            else
            {
                if ( pSlotCtx->dwSeekPointer < (DRM_UINT)abs(lOffset) )
                {
                    ChkDR(DRM_E_HDSSEEKERROR);
                }
                pSlotCtx->dwSeekPointer -= abs(lOffset);
            }
            break;
        case eDRM_HDS_SEEKEND:
            if ( lOffset > 0 || (DRM_UINT)abs(lOffset) > pSlotCtx->oSlotHeader.dwSlotSize )
            {
                ChkDR(DRM_E_HDSSEEKERROR);
            }
            pSlotCtx->dwSeekPointer = pSlotCtx->oSlotHeader.dwSlotSize - abs(lOffset);
            break;
        case eDRM_HDS_SEEKSET:
            if ( lOffset < 0 || lOffset > (DRM_LONG) pSlotCtx->oSlotHeader.dwSlotSize )
            {
                ChkDR(DRM_E_HDSSEEKERROR);
            }
            pSlotCtx->dwSeekPointer = lOffset;
            break;
        default:
            ChkDR(DRM_E_INVALIDARG);
    }

ErrorExit:
    if ( DRM_SUCCEEDED(dr) && pdwSeekPointer)
    {
        *pdwSeekPointer = pSlotCtx->dwSeekPointer;
    }
    return dr;
}



/*
**
*/
DRM_RESULT DRM_API DRM_HDS_SlotRead( 
    IN  DRM_HDS_SLOT_CONTEXT *pcontextSlot,
    IN  DRM_DWORD             cbData,
    OUT DRM_BYTE             *pbData,
    OUT DRM_DWORD            *pcbRead)
{
    DRM_RESULT    dr=DRM_SUCCESS;
    _SlotContext *pSlotCtx=(_SlotContext*)pcontextSlot;
    DEFINE_LOCK_VARS

    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(pcontextSlot != NULL
          &&  pSlotCtx->pNS != NULL
          &&  pSlotCtx->pNS->pHDS != NULL
          &&  pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* Note:
    ** - this slot is either locked for SHARED or EXCLUSIVE. We do not need to 
    **   worry if it is changed after it is opened 
    */

    /* Lock Order: 
    ** - CS:  to guard exclusive access to file handle
    */
    ENTER_HDS_CS(pSlotCtx->pNS->pHDS);  

    ChkDR(_HdsReadWriteSlot(pSlotCtx, cbData, pbData, pcbRead, TRUE));

ErrorExit:

    LEAVE_HDS_CS(pSlotCtx->pNS->pHDS);
    return dr;
}



/*
**
*/
DRM_RESULT DRM_API DRM_HDS_SlotWrite( 
    IN       DRM_HDS_SLOT_CONTEXT *pcontextSlot,
    IN       DRM_DWORD             cbData,
    IN const DRM_BYTE             *pbData,
    OUT      DRM_DWORD            *pcbWritten)
{
    DRM_RESULT    dr=DRM_SUCCESS;
    _SlotContext *pSlotCtx=(_SlotContext*)pcontextSlot;
    DEFINE_LOCK_VARS

    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(pcontextSlot != NULL
          &&  pSlotCtx->pNS != NULL
          &&  pSlotCtx->pNS->pHDS != NULL
          &&  pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* Note:
    ** - this slot is locked for EXCLUSIVE. We do not need to 
    **   worry if it is changed after it is opened 
    */
    
    /* slot must be locked EXCLUSIVE */
    if ( (pSlotCtx->eLockMode & eDRM_HDS_LOCKEXCLUSIVE) == 0 )
    {
        ChkDR(DRM_E_HDSNOTLOCKEDEXCLUSIVE);
    }

    /* Lock Order: 
    ** - CS:  to guard exclusive access to file handle
    */
    ENTER_HDS_CS(pSlotCtx->pNS->pHDS);  

    /* NOTE: We cast away the const-ness here because we know _HdsReadWriteSlot 
    ** is safe when the operation is Write 
    */
    ChkDR(_HdsReadWriteSlot(pSlotCtx, cbData, (DRM_BYTE*)pbData, pcbWritten, FALSE));

    /* 
    ** Note:
    ** we do not need to flush if _DATASTORE_WRITE_THRU is defined. file buffers
    ** are already flushed.
    ** if _DATASTORE_WRITE_THRU is not defined, caller should call DRM_HDS_Commit* 
    ** to flush file buffer at higher level
    */
    
ErrorExit:

    LEAVE_HDS_CS(pSlotCtx->pNS->pHDS);
    return dr;
}


DRM_RESULT DRM_API DRM_HDS_SlotResize( 
    IN DRM_HDS_SLOT_CONTEXT *pcontextSlot, 
    IN DRM_DWORD             cbSize)
{
    DRM_RESULT     dr=DRM_SUCCESS;
    _SlotContext  *pSlotCtx=(_SlotContext*)pcontextSlot;
    DEFINE_LOCK_VARS

    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(pcontextSlot != NULL
          &&  pSlotCtx->pNS != NULL 
          &&  pSlotCtx->pNS->pHDS != NULL
          &&  pSlotCtx->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE 
          &&  cbSize > 0);

    /* we do not need to verify slot content since we must have either shared
    ** or exclusive lock on the slot 
    */
    if (pSlotCtx->eStatus!=eSlotCtxReady)
    {
        ChkDR(DRM_E_HDSSLOTNOTFOUND);
    }

    /* Lock SRN EXCLUSIVE to prevent other process from change the file*/
    ENTER_CS_AND_LOCK_SRN(pSlotCtx->pNS->pHDS, (pSlotCtx->eLockMode | eDRM_HDS_LOCKEXCLUSIVE));

    ChkDR(_HdsSlotResize(pSlotCtx, cbSize));

ErrorExit:
    if ( pSlotCtx!=NULL  &&  pSlotCtx->pNS!=NULL )
    {
        UNLOCK_SRN_AND_LEAVE_CS(pSlotCtx->pNS->pHDS);
    }
    return dr;
}



DRM_RESULT DRM_API DRM_HDS_InitSlotEnum(
    IN  DRM_HDS_NAMESPACE_CONTEXT *pcontextNS,     /* Namespace context returned from DRM_HDS_OpenNamespace */
    IN  const DRM_HDS_HASHKEY     *pHashKey,       /* if NULL, all slots will be enum'ed */
    IN  DRM_HDS_LOCKMODE           eLockMode,
    OUT DRM_HDS_ENUM_CONTEXT      *pcontextEnum)
{
    DRM_RESULT    dr    = DRM_SUCCESS;
    _NsContext   *pNS   = (_NsContext   *) pcontextNS;
    _EnumContext *pEnum = (_EnumContext *) pcontextEnum;
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(L"DRM_HDS_InitSlotEnum", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
    DRMASSERT(pcontextNS && pcontextEnum);
    DRMSIZEASSERT( SIZEOF(DRM_HDS_ENUM_CONTEXT), CALC_MAXENUMCONTEXTLEN );

    ChkArg(pNS->pHDS != NULL
       &&  pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE 
       &&  ISVALIDCONTEXT(pNS, eCfgContextSignature) 
       &&  ISVALIDCONTEXT(pNS->pHDS, eHdsContextSignature));

    /* Lock SRN SHARED among other processes. */
    ENTER_CS_AND_LOCK_SRN(pNS->pHDS, (eLockMode & (~eDRM_HDS_LOCKEXCLUSIVE)));

    /* _HdsInitSlotEnum prepares the enum context. It will not block so we are okay */
    ChkDR(_HdsInitSlotEnum(pNS, pHashKey, eLockMode, pEnum));

ErrorExit:
    if ( pNS != NULL )
    {
        UNLOCK_SRN_AND_LEAVE_CS(pNS->pHDS);  /* unlock SRN */
    }
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_HDS_InitSlotEnum", g_pwszLeavingFunction);
    return dr;
}

DRM_RESULT DRM_API DRM_HDS_SlotEnumReloadCurrent( 
    IN  DRM_HDS_ENUM_CONTEXT *pcontextEnum,       /* setup by DRM_HDS_InitSlotEnum() */
    OUT DRM_HDS_SLOT_CONTEXT *pcontextSlot,       /* user given Dataslot context buffer */
    OUT DRM_HDS_HASHKEY      *pHashKey,           /* optional parameter */
    OUT DRM_HDS_UNIQUEKEY    *pUniqueKey,         /* optional parameter */
    OUT DRM_DWORD            *pcbSize)            /* current dataslot size, optional parameter */
{
    DRM_RESULT     dr         = DRM_SUCCESS;    
    _EnumContext  *pEnum      = (_EnumContext *)pcontextEnum;
    _CommBlockHDR *pCurrBlock = NULL;

    ChkArg(pEnum != NULL
       &&  pEnum->pNS != NULL
       &&  ISVALIDCONTEXT(pEnum,      eEnumContextSignature)
       &&  ISVALIDCONTEXT(pEnum->pNS, eCfgContextSignature));
    DRMASSERT(pEnum->pNS->fInited 
          &&  pEnum->pNS->pHDS  != NULL
          &&  pEnum->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE 
          &&  pcontextSlot != NULL);

    if ( !pEnum->fCurrBlockIsValid )
    {
        dr = DRM_E_NOMORE;
        goto ErrorExit;
    }
    pCurrBlock = &pEnum->oCurrBlock;

    /* use next positon as current position */
    ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos = ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos;

    dr = DRM_HDS_SlotEnumNext(pcontextEnum, pcontextSlot, pHashKey, pUniqueKey, pcbSize);

ErrorExit:
    return dr;
}



/******************************************************************************
** Function:   DRM_HDS_SlotEnumDeleteCurrent
** Synopsis:   delete the current enumerated slot
** Arguments:  pcontextEnum - HDS enum context
**             pcontextSlot - HDS slot context of the current enumerated slot
** Returns:    
** Notes:      
******************************************************************************/
DRM_RESULT DRM_API DRM_HDS_SlotEnumDeleteCurrent( 
    IN  DRM_HDS_ENUM_CONTEXT *pcontextEnum,       /* setup by DRM_HDS_InitSlotEnum() */
    IN  DRM_HDS_SLOT_CONTEXT *pcontextSlot)       /* user given Dataslot context buffer containing the current open slot*/
{
    DRM_RESULT    dr = DRM_SUCCESS;    
    _EnumContext *pEnum    = (_EnumContext *) pcontextEnum;
    _SlotContext *pSlotCtx = (_SlotContext *) pcontextSlot;
    DEFINE_LOCK_VARS

    ChkArg(pEnum != NULL
       &&  pEnum->pNS != NULL
       &&  ISVALIDCONTEXT(pEnum,      eEnumContextSignature)
       &&  ISVALIDCONTEXT(pEnum->pNS, eCfgContextSignature)
       &&  pcontextSlot != NULL
       &&  ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    
    DRMASSERT(pEnum->pNS->fInited 
          &&  pEnum->pNS->pHDS  != NULL
          &&  pEnum->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE 
          &&  pcontextSlot != NULL
          &&  pSlotCtx->pNS 
          &&  pSlotCtx->pNS->pHDS 
          &&  pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    if (pSlotCtx->eStatus != eSlotCtxReady
     || !pEnum->fCurrBlockIsValid)
    {
        ChkDR(DRM_E_HDSSLOTNOTFOUND);
    }    

    /* Lock SRN SHARED among other processes. */
    ENTER_CS_AND_LOCK_SRN(pEnum->pNS->pHDS, (pEnum->eLockMode & (~eDRM_HDS_LOCKEXCLUSIVE)));
    
    dr = _HdsSlotEnumDeleteCurrent(pEnum, pSlotCtx);

ErrorExit:

    UNLOCK_SRN_AND_LEAVE_CS(pEnum->pNS->pHDS);
    return dr;
}



DRM_RESULT DRM_API DRM_HDS_SlotEnumNext( 
    IN  DRM_HDS_ENUM_CONTEXT *pcontextEnum,       /* setup by DRM_HDS_InitSlotEnum() */
    OUT DRM_HDS_SLOT_CONTEXT *pcontextSlot,       /* user given Dataslot context buffer */
    OUT DRM_HDS_HASHKEY      *pHashKey,           /* optional parameter */
    OUT DRM_HDS_UNIQUEKEY    *pUniqueKey,         /* optional parameter */
    OUT DRM_DWORD            *pcbSize)            /* current dataslot size, optional parameter */
{
    DRM_RESULT    dr = DRM_SUCCESS;    
    _EnumContext *pEnum    = (_EnumContext *) pcontextEnum;
    _SlotContext *pSlotCtx = (_SlotContext *) pcontextSlot;
    DRM_BOOL      fValid   = FALSE;
    DRM_BOOL      fSlotLocked = FALSE;    
    DEFINE_LOCK_VARS

    DRM_PROFILING_ENTER_SCOPE(L"DRM_HDS_SlotEnumNext", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
    ChkArg(pEnum != NULL
       &&  pEnum->pNS != NULL
       &&  ISVALIDCONTEXT(pEnum,      eEnumContextSignature)
       &&  ISVALIDCONTEXT(pEnum->pNS, eCfgContextSignature));
    DRMASSERT(pEnum->pNS->fInited 
          &&  pEnum->pNS->pHDS  != NULL
          &&  pEnum->pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE 
          &&  pcontextSlot != NULL);

    if ( !pEnum->fCurrBlockIsValid )
    {
        dr = DRM_E_NOMORE;
        goto ErrorExit;
    }

    while (TRUE)
    {
        /* Lock SRN SHARED among other processes. */
        ENTER_CS_AND_LOCK_SRN(pEnum->pNS->pHDS, (pEnum->eLockMode & (~eDRM_HDS_LOCKEXCLUSIVE)));
        
        /* locate and open the slot */
        ChkDR(_HdsSlotEnumNext(pEnum, pSlotCtx, pHashKey, pUniqueKey, pcbSize));

        /* drop all the locks and CS to allow concurrency to occur 
        ** while waiting for the slot lock */
        UNLOCK_SRN_AND_LEAVE_CS(pEnum->pNS->pHDS);
        
        /* issue specific slot lock */
        ChkDR(_HdsLockSlot(pSlotCtx, pEnum->eLockMode));
        fSlotLocked = TRUE;
            
        /* we got the lock to the slot, let's verify the sanity of the slot 
        ** we need to enter CS and lock SRN again */
        ENTER_CS_AND_LOCK_SRN(pEnum->pNS->pHDS, (pEnum->eLockMode & (~eDRM_HDS_LOCKEXCLUSIVE)));
        
        ChkDR(_HdsVerifySlotContext(pSlotCtx, &fValid));
        
        /* drop all the locks and CS again */
        UNLOCK_SRN_AND_LEAVE_CS(pEnum->pNS->pHDS);
       
        if ( fValid )
        {
            break;
        }
        
        /* slot context verified failed, try again */
        (void)_HdsUnlockSlot(pSlotCtx);
        fSlotLocked = FALSE;
    }

ErrorExit:

    if ( pEnum != NULL  && pEnum->pNS )
    {
        if ( DRM_FAILED(dr)  &&  fSlotLocked )
        {
            /* error occured during verifying slot context, return error */
            _HdsUnlockSlot(pSlotCtx);
        }
        UNLOCK_SRN_AND_LEAVE_CS(pEnum->pNS->pHDS);
    }

    if (DRM_FAILED(dr))            
    {
        /* trash the slot context and return */
        ZEROMEM(pSlotCtx, pSlotCtx->dwContextSize);
    }
    DRM_PROFILING_LEAVE_SCOPE(L"DRM_HDS_SlotEnumNext", g_pwszLeavingFunction);
        
    return dr;
}

DRM_RESULT DRM_API DRM_HDS_BlockScanDelete(
    IN       DRM_HDS_NAMESPACE_CONTEXT *f_pcontextNS,
    IN const DRM_HDS_HASHKEY           *f_pkeyHash, 
    IN const DRM_HDS_UNIQUEKEY          f_rgkeyUnique [],
    IN const DRM_DWORD                  f_cKeysUnique,
    IN const DRM_BOOL                   f_fWait,
       OUT   DRM_HDS_BLOCKSCAN_CONTEXT *f_pcontextBlockScan)
{
    DRM_RESULT dr = DRM_SUCCESS;
    _NsContext        *pcontextNS = (_NsContext   *)      f_pcontextNS;
    _BlockScanContext *pcontextBS = (_BlockScanContext *) f_pcontextBlockScan;
    DRM_HDS_LOCKMODE   lockmode   = eDRM_HDS_LOCKEXCLUSIVE;
    DRM_BOOL           fOK               = FALSE;
    DRM_BOOL           fLocked           = FALSE;
    DRM_HDS_HASHKEY   *pkeyHash          = NULL;
    DRM_HDS_UNIQUEKEY *pkeyUnique        = NULL;
    _CommBlockHDR     *pblockheaderNext  = NULL;
    _CommBlockHDR     *pblockheaderTemp  = NULL;
    _CommBlockHDR     *pBlock            = NULL;
    _CommBlockHDR     *pCurrBlock        = NULL;
    _ChildBlockHDR    *pblockheaderChild = NULL;
    _SlotContext      *pcontextSlot      = NULL;
    _SlotContext      *pcontextSlotLock  = NULL;
    DEFINE_LOCK_VARS;

    ChkArg(f_pcontextNS        != NULL
        && f_pcontextBlockScan != NULL);

    ChkArg(pcontextNS->pHDS     != NULL
       &&  pcontextNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE);

    ChkArg(f_pkeyHash    != NULL
        && f_rgkeyUnique != NULL
        && f_cKeysUnique  > 0);

    ChkArg(ISVALIDCONTEXT(pcontextNS,       eCfgContextSignature) 
       &&  ISVALIDCONTEXT(pcontextNS->pHDS, eHdsContextSignature));

    if (f_fWait)
    {
        lockmode |= eDRM_HDS_LOCKWAIT;
    }

    /* Lock SRN SHARED among other processes. */

    ENTER_CS_AND_LOCK_SRN(pcontextNS->pHDS, eDRM_HDS_LOCKSHARED);

    ChkDR(_HdsBlockScanInit  (pcontextNS, f_pkeyHash, f_rgkeyUnique, f_cKeysUnique, lockmode, pcontextBS));

    /* 
    ** Verify validity of the current block of the slot context
    */

    pBlock            = &pcontextBS->blockheader;
    pCurrBlock        = &pcontextBS->blockheaderCurrent;
    pblockheaderChild = (_ChildBlockHDR *) pCurrBlock;

    /* load generic block header */
    ChkDR(_HdsGetPutBlockHDR(pcontextBS->pcontextNS, 
                             pcontextBS->blockheader.nBlockNum, 
                            &pBlock, 
                             GPBH_GENERIC_ONLY, 
                             GPBH_OPERATION_READ));

    pkeyHash = &pcontextBS->keyHash;

    ChkDR(_Hds_malloc(pcontextBS->pcontextNS->pHDS, 
  CALC_SLOTCONTEXTLEN(pcontextBS->pcontextNS), 
       (DRM_VOID **) &pcontextSlot));

    ChkDR(_Hds_malloc(pcontextBS->pcontextNS->pHDS, 
  CALC_SLOTCONTEXTLEN(pcontextBS->pcontextNS), 
       (DRM_VOID **) &pcontextSlotLock));

    ChkDR(_HdsAllocBlockBuffer(pcontextBS->pcontextNS, eCHILDBLOCK, &pblockheaderNext));

    while (dr != DRM_E_NOMORE)
    {
        DRM_BOOL fAnyDeletedFromBlock = FALSE;
        DRM_BOOL fFound               = TRUE;
        
        fLocked = FALSE;

        /* unlock the SHARED from above or the EXCLUSIVE (below) upon loop */

        UNLOCK_SRN_AND_LEAVE_CS(pcontextNS->pHDS);

        /* Lock SRN exclusively among other processes. */

        ENTER_CS_AND_LOCK_SRN(pcontextNS->pHDS, eDRM_HDS_LOCKEXCLUSIVE | eDRM_HDS_LOCKWAIT);

        while (fFound)
        {
            ChkDR(_HdsInitSlotContext(pcontextBS->pcontextNS, 
                         (DRM_BYTE *) pcontextSlot, 
                                      CALC_MAXSLOTCONTEXTLEN));

            /* search current block for any matching UNIQUEs under the HASH */

            ChkDR(_HdsSearchSlotInBlock(&pcontextBS->blockheaderCurrent,
                                         pkeyHash,
                                         NULL,
                                         eSearchSlotDontCare,
                                         pcontextSlot,
                                        &fFound));
            if (fFound)
            {
                if (_IsMatchingKey(&pcontextSlot->oSlotHeader.oUniquekey,
                                    pcontextBS->pkeyUnique,
                                    pcontextBS->cKeysUnique,
                                    pcontextBS->iKeyCurrent))
                {
                    /* mark the slot as hidden and record that we dirtied this block */

                    ChkDR(_HdsRemoveSlot(pcontextSlot, 
                                         eRemoveSlotSetHidden));

                    fAnyDeletedFromBlock = TRUE;
                    pcontextBS->iKeyCurrent++;
                    pcontextBS->cKeysFound++;

                    /* if we've already found all the keys we can complete this loop and exit both loops */

                    if (pcontextBS->cKeysFound == pcontextBS->cKeysUnique)
                    {
                        fFound = FALSE;
                        dr     = DRM_E_NOMORE;
                    }
                }
            }
        }

        /* if any hidden slots were found for this HASKEY then remove those slots */

        if (fAnyDeletedFromBlock)
        {
            DRM_RESULT drCoalesce = _CoalesceBlock(&pcontextBS->blockheaderCurrent, 
                                                    pcontextSlotLock,
                                                    pkeyHash,
                                                    pcontextBS->lockmode,
                                                   &fLocked);

            if (DRM_FAILED(drCoalesce))
            {
                ChkDR(drCoalesce);
            }
        }

        if (dr != DRM_E_NOMORE)
        {
            /* open the next block and continue */

            ChkDR(_HdsHashToChildBlock(pcontextBS->pcontextNS,
                                      &pcontextBS->blockheaderCurrent,
                                       pcontextBS->keyHash.rgb,
                                      &pblockheaderNext,
                                      &fOK,
                                       NULL));

            /* reload the next block and make sure it has the same parent as before */

            pBlock = &pcontextBS->blockheader;

            ChkDR(_HdsGetPutBlockHDR(pcontextBS->pcontextNS, 
                                     pblockheaderNext->nBlockNum, 
                                    &pBlock, 
                                    GPBH_GENERIC_ONLY, 
                                    GPBH_OPERATION_READ));

            if (fLocked)
            {
                ChkDR(_HdsUnlockBlock2DeleteSlot(pcontextSlotLock));
                fLocked = FALSE;
            }

            if (fOK)
            {
                /* the child block becomes the current block */

                ChkDR(_HdsCopyBlockBuffer(&pcontextBS->blockheaderCurrent, pblockheaderNext));

                MEMCPY(&pcontextBS->blockheader, &pcontextBS->blockheaderCurrent, SIZEOF(_CommBlockHDR));
                MEMCPY(&pcontextBS->slotheader,  &pcontextSlot->oSlotHeader,      SIZEOF(_SlotHeader));
            }
            else
            {
                UNLOCK_SRN_AND_LEAVE_CS(pcontextBS->pcontextNS->pHDS)

            /* no more block found */
                dr = DRM_E_NOMORE;
            }
        } /* end if dr != E_NOMORE */
    } /* end block loop */

    if (dr == DRM_E_NOMORE)
    {
        dr = DRM_SUCCESS;
    }
ErrorExit:

    if (pblockheaderNext != NULL)
    {
        _Hds_free(pcontextBS->pcontextNS->pHDS, pblockheaderNext);
    }

    if (pcontextSlotLock != NULL)
    {
        if (fLocked)
        {
            _HdsUnlockBlock2DeleteSlot(pcontextSlotLock);
        }

        _Hds_free(pcontextBS->pcontextNS->pHDS, pcontextSlotLock);
    }

    if (pcontextSlot != NULL)
    {
        _Hds_free(pcontextBS->pcontextNS->pHDS, pcontextSlot);
    }

    if (pblockheaderTemp != NULL)
    {
        _Hds_free(pcontextBS->pcontextNS->pHDS, pblockheaderTemp);
    }

    if (pcontextNS != NULL)
    {
        UNLOCK_SRN_AND_LEAVE_CS(pcontextNS->pHDS);  /* unlock SRN */
    }

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmheaderparser.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMHEADERPARSER_H__
#define __DRMHEADERPARSER_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Possible drmresults. */
#define CH_BASECODE                         (DRM_RESULT_CODE(DRM_E_CH_BASECODE))
#define CH_VERSION_MISSING                  (DRM_E_CH_VERSION_MISSING)
#define CH_KID_MISSING                      (DRM_E_CH_KID_MISSING)
#define CH_LAINFO_MISSING                   (DRM_E_CH_LAINFO_MISSING)
#define CH_CHECKSUM_MISSING                 (DRM_E_CH_CHECKSUM_MISSING)
#define CH_ATTR_MISSING                     (DRM_E_CH_ATTR_MISSING)
#define CH_INVALID_HEADER                   (DRM_E_CH_INVALID_HEADER)
#define CH_UNABLE_TO_VERIFY                 (DRM_E_CH_UNABLE_TO_VERIFY)
#define CH_UNSUPPORTED_VERSION              (DRM_E_CH_UNSUPPORTED_VERSION)
#define CH_UNSUPPORTED_HASH_ALGORITHM       (DRM_E_CH_UNSUPPORTED_HASH_ALGORITHM)
#define CH_UNSUPPORTED_SIGN_ALGORITHM       (DRM_E_CH_UNSUPPORTED_SIGN_ALGORITHM)
#define CH_BAD_KEY                          (DRM_E_CH_BAD_KEY)
#define CH_NOT_SIGNED                       (DRM_E_CH_NOT_SIGNED)
#define CH_UNKNOWN_ERROR                    (DRM_E_CH_UNKNOWN_ERROR)


typedef enum
{
    DRM_HEADER_ATTRIB_VERSION = 1,
    DRM_HEADER_ATTRIB_KID = 2,
    DRM_HEADER_ATTRIB_LAINFO = 3,
    DRM_HEADER_ATTRIB_CHECKSUM = 4,
    DRM_HEADER_ATTRIB_SECURITYVERSION = 5,
    DRM_HEADER_ATTRIB_OTHER = 6
} eDRM_HEADER_ATTRIBUTES;

DRM_RESULT DRM_API DRM_HDR_GetAttribute(
    IN const DRM_CONST_STRING       *pdstrContentHeader,
    IN const DRM_CONST_STRING       *pdstrAttrName,
    IN       eDRM_HEADER_ATTRIBUTES  eAttribute,
    OUT      DRM_CONST_STRING       *pdstrValue,
    IN       DRM_WCHAR               chXPathSeparator);

DRM_RESULT DRM_API DRM_HDR_GetUplink(
    IN const DRM_CONST_STRING *pdstrContentHeader,
    IN       DRM_DWORD         dwUplinkNumber,
    OUT      DRM_CONST_STRING *pdstrKid );

DRM_RESULT DRM_API DRM_HDR_Verify(
    IN const DRM_CONST_STRING   *pdstrContentHeader,
    IN const DRM_CONST_STRING   *pdstrPubKey,
    IN       DRM_CRYPTO_CONTEXT *pContext,
    OUT      DRM_LONG           *plResult);


#ifdef __cplusplus
}
#endif

#endif /* __DRMHEADERPARSER_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmhmac.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>
#include <drmhmac.h>

DRM_RESULT DRM_API DRM_HMAC_Init(
    IN OUT   HMAC_CONTEXT *pcontextHMAC,
    IN const DRM_BYTE     *pbKey,
    IN       DRM_UINT      cbKey)
{
    DRM_RESULT dr = DRM_E_LOGICERR;
    DRM_UINT   iCount;

    ChkArg( pcontextHMAC != NULL
         && cbKey        != 0 
         && pbKey        != NULL);

    if( cbKey > SHA_BLOCK_SIZE)
    {
        /* Only use the first SHA_BLOCK_SIZE bytes */
        cbKey = SHA_BLOCK_SIZE;
    }

    ZEROMEM( pcontextHMAC, SIZEOF( *pcontextHMAC ) );

    for(iCount = 0; iCount < cbKey; iCount++)
    {
        PUT_BYTE( pcontextHMAC->rgbBuffer, iCount, GET_BYTE( pbKey, iCount ) ^ 0x36 );
    }

    for(; iCount < SHA_BLOCK_SIZE ; iCount++)
    {
        PUT_BYTE( pcontextHMAC->rgbBuffer, iCount, 0 ^ 0x36 );
    }

    DRM_SHA_Init( &( pcontextHMAC->shaContext ) );
    DRM_SHA_Update(pcontextHMAC->rgbBuffer, SHA_BLOCK_SIZE, &( pcontextHMAC->shaContext ) );


    /* Update the internal context buffer so we don't have to hold onto the key. */
    for(iCount = 0; iCount < cbKey; iCount++)
    {
        PUT_BYTE( pcontextHMAC->rgbBuffer, iCount, GET_BYTE( pbKey, iCount ) ^ 0x5C );
    }

    for(; iCount < SHA_BLOCK_SIZE ; iCount++)
    {
        PUT_BYTE( pcontextHMAC->rgbBuffer, iCount, 0 ^ 0x5C );
    }

    dr = DRM_SUCCESS;

ErrorExit:
    return dr;
}

/******************************************************************************/

DRM_RESULT DRM_API DRM_HMAC_Update(
    IN OUT   HMAC_CONTEXT *pcontextHMAC,
    IN const DRM_BYTE     *pbData,
    IN       DRM_UINT      cbData)
{
    DRM_RESULT dr = DRM_E_LOGICERR;

    ChkArg( pcontextHMAC != NULL );
    if( cbData == 0 )
    {
        dr = DRM_SUCCESS;
        goto ErrorExit;
    }

    ChkArg( pbData );

    DRM_SHA_Update(pbData, cbData, &( pcontextHMAC->shaContext ) );
    dr = DRM_SUCCESS;

ErrorExit:
    return dr;

}

/******************************************************************************/

DRM_RESULT DRM_API DRM_HMAC_Finalize(
    IN OUT HMAC_CONTEXT *pcontextHMAC,
       OUT DRM_BYTE     *pbKeyedHash,
    IN     DRM_UINT      cbKeyedHash )
{
    DRM_RESULT dr = DRM_E_LOGICERR;

    ChkArg( pcontextHMAC != NULL
         && pbKeyedHash  != NULL
         && cbKeyedHash  != 0
         && cbKeyedHash  <= SHA_DIGEST_LEN );

    /* Finish the first SHA operation. */
    DRM_SHA_Finalize( &( pcontextHMAC->shaContext ), pcontextHMAC->shaDigest);

    /* Start second SHA operation */
    DRM_SHA_Init( &( pcontextHMAC->shaContext ) );
    DRM_SHA_Update(pcontextHMAC->rgbBuffer, SHA_BLOCK_SIZE, &( pcontextHMAC->shaContext ) );
    DRM_SHA_Update( pcontextHMAC->shaDigest, SHA_DIGEST_LEN, &( pcontextHMAC->shaContext ) );
    DRM_SHA_Finalize( &( pcontextHMAC->shaContext ) , pcontextHMAC->shaDigest);
    MEMCPY(pbKeyedHash, pcontextHMAC->shaDigest, cbKeyedHash);
    ZEROMEM( pcontextHMAC, SIZEOF( HMAC_CONTEXT ) );
    dr = DRM_SUCCESS;

ErrorExit:
    return dr;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmhds.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_HDS_H__
#define __DRM_HDS_H__

#include <drmhds_impl.h>

#ifdef __cplusplus
extern "C" {
#endif


typedef struct __tagDRM_HDS_NAMESPACE_BLOB
{
    DRM_BYTE rgb[__CB_DECL(DRM_HDS_NSNAME_SIZE)];
} DRM_HDS_NAMESPACE;

typedef struct __tagDRM_HDS_CONTEXT
{
    DRM_BYTE rgbOpaqueData[__CB_DECL( DRM_HDS_CONTEXT_LEN )];
} DRM_HDS_CONTEXT;

typedef struct __tagDRM_HDS_NAMESPACE_CONTEXT
{
    DRM_BYTE rgbOpaqueData[ __CB_DECL(DRM_HDS_NAMESPACE_CONTEXT_LEN) ];
} DRM_HDS_NAMESPACE_CONTEXT;

typedef struct __tagDRM_HDS_SLOT_CONTEXT
{
    DRM_BYTE rgbOpaqueData[ __CB_DECL(DRM_HDS_SLOT_CONTEXT_LEN) ];
} DRM_HDS_SLOT_CONTEXT;

typedef struct __tagDRM_HDS_ENUM_CONTEXT
{
    DRM_BYTE rgbOpaqueData[ __CB_DECL(DRM_HDS_ENUM_CONTEXT_LEN) ];
} DRM_HDS_ENUM_CONTEXT;

typedef struct __tagDRM_HDS_BLOCKSCAN_CONTEXT
{
    DRM_BYTE rgbOpaqueData[__CB_DECL(DRM_HDS_BLOCKSCAN_CONTEXT_LEN)];
} DRM_HDS_BLOCKSCAN_CONTEXT;

typedef struct __tagDRM_HDS_SLOT_HINT
{
    DRM_BYTE rgbOpaqueData[__CB_DECL(DRM_HDS_SLOT_HINT_LEN)];
} DRM_HDS_SLOT_HINT;

/* 
** API Functions 
*/


/*
** ----------------------------------------------------------------------------
** Methods applied to whole hashed file store 
** ----------------------------------------------------------------------------
*/

/**********************************************************************
** Function:    DRM_HDS_Init
** Synopsis:    Init HDS Context
** Arguments:   [pcontextHDS] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       The function MUST be called in the main thread BEFORE
**              any of the child thread(s) starting sharing the same 
**              context. If this function is called after the child
**              thread(s) started, the result is undefined.
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_Init( 
    IN OUT DRM_HDS_CONTEXT *pcontextHDS);


/**********************************************************************
** Function:    DRM_HDS_Uninit
** Synopsis:    Uninit HDS Context
** Arguments:   [pcontextHDS] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       This function MUST be called in the main thread AFTER
**              any of the child thread(s) sharing the same context 
**              stopped. If this function is called before the child
**              thread(s) stopped, the result is undefined.
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_Uninit( 
    IN OUT DRM_HDS_CONTEXT *pcontextHDS);


/**********************************************************************
** Function:    DRM_HDS_CreateStore
** Synopsis:    Create DRM data store file
** Arguments:   [] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_CreateStore( 
    IN const DRM_WCHAR       *wszHdsName, 
    IN const DRM_DWORD        dwBlockSize,       /* block size is limited up to 64K */
    IN const DRM_HDSBLKNUM    eBlkNumType,
    IN OUT   DRM_HDS_CONTEXT *pcontextHDS,
    IN       DRM_BOOL         fTruncateExist);

/**********************************************************************
** Function:    DRM_HDS_CreateStore
** Synopsis:    Create DRM data store file
** Arguments:   [] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_CreateStore2( 
    IN const DRM_WCHAR       *wszHdsName, 
    IN const DRM_DWORD        dwBlockSize,       /* block size is limited up to 64K */
    IN const DRM_HDSBLKNUM    eBlkNumType,
    IN OUT   DRM_HDS_CONTEXT *pcontextHDS,
    IN       DRM_BOOL         fTruncateExist,
    IN const DRM_DWORD        nInitSizeinKB);


/**********************************************************************
** Function:    DRM_HDS_OpenStore
** Synopsis:    Initialize the data store at szDataStoreName
** Arguments:   [wszHdsName] -- 
**              [pcontextHDS] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_OpenStore( 
    IN const DRM_WCHAR       *wszHdsName, 
    OUT      DRM_HDS_CONTEXT *pcontextHDS );      /* user given context buffer, NULL to get size */    

/**********************************************************************
** Function:    DRM_HDS_OpenStore
** Synopsis:    Initialize the data store at szDataStoreName
** Arguments:   [wszHdsName] -- 
**              [pcontextHDS] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_OpenStore2( 
    IN const DRM_WCHAR       *wszHdsName, 
       OUT   DRM_HDS_CONTEXT *pcontextHDS,       /* user given context buffer, NULL to get size */    
    IN const DRM_DWORD        nGrowbySizeinKB);

/**********************************************************************
** Function:    DRM_HDS_CloseStore
** Synopsis:    Close the license store.  This will also Commit before close
** Arguments:   [pcontextHDS] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_CloseStore( 
    IN DRM_HDS_CONTEXT *pcontextHDS );

/**********************************************************************
** Function:    DRM_HDS_CommitStore
** Synopsis:    flush unwritten data to disk
** Arguments:   [pcontextHDS] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_CommitStore(
    IN DRM_HDS_CONTEXT *pcontextHDS );


/**********************************************************************
** Function:    DRM_HDS_CleanupStore
** Synopsis:    clean up empty blocks and hidden slot in store 
** Arguments:   [pcontextHDS] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_CleanupStore(
    IN DRM_HDS_CONTEXT *pcontextHDS,
    IN DRM_BOOL         fWait);

DRM_RESULT DRM_API DRM_HDS_OpenNamespace(
    IN       DRM_HDS_CONTEXT           *pcontextHDS,    
    IN const DRM_HDS_NAMESPACE         *pNamespace,
    IN       DRM_HDS_OPENMODE           eOpenMode,
    IN       DRM_WORD                   wMaxNumChildren,
    OUT      DRM_HDS_NAMESPACE_CONTEXT *pcontextNS);

/* remove the entire namespace tree and its nodes in the data store */
DRM_RESULT DRM_API DRM_HDS_DeleteNamespace( 
    IN       DRM_HDS_CONTEXT   *pcontextHDS,
    IN const DRM_HDS_NAMESPACE *pNamespace,
    IN       DRM_BOOL           fWait);

/* start using the specified namespace, any subsequent calls will be based on this namespace */
DRM_RESULT DRM_API DRM_HDS_CloseNamespace(
    IN DRM_HDS_NAMESPACE_CONTEXT *pcontextNS);  /* Namespace context returned from DRM_HDS_OpenNamespace */


DRM_RESULT DRM_API DRM_HDS_CommitNamespace(
    IN DRM_HDS_NAMESPACE_CONTEXT *pcontextNS);

/*
** ----------------------------------------------------------------------------
** Methods to navigate, create, delete, open and close HDS dataslots  
** ----------------------------------------------------------------------------
*/

/* Initialize a slot hint based on the slot context passed */
DRM_RESULT DRM_API DRM_HDS_MakeSlotHint(
    IN     DRM_HDS_SLOT_CONTEXT      *pcontextSlot,
    IN OUT DRM_HDS_SLOT_HINT         *pslotHint);

/* Create or open dataslot using given key1 and key2 */
DRM_RESULT DRM_API DRM_HDS_OpenSlot( 
    IN       DRM_HDS_NAMESPACE_CONTEXT *pcontextNS,   /* Namespace context returned from DRM_HDS_OpenNamespace */
    IN       DRM_DWORD                  dwMode,       /* combo of DRM_HDS_OPENMODE and DRM_HDSSLOT_LOCKMODE */
    IN const DRM_HDS_HASHKEY           *pHashKey, 
    IN const DRM_HDS_UNIQUEKEY         *pUniqueKey,
    IN       DRM_HDS_SLOT_HINT         *pSlotHint,
    IN OUT   DRM_DWORD                 *pcbSlotSize,  /* current dataslot size */
       OUT   DRM_HDS_SLOT_CONTEXT      *pcontextSlot);/* user given Dataslot context buffer */

/* Close an opened dataslot */
DRM_RESULT DRM_API DRM_HDS_CloseSlot( 
    IN DRM_HDS_SLOT_CONTEXT *pcontextSlot);

/* delete the slot immediately */
DRM_RESULT DRM_API DRM_HDS_DeleteSlot( 
    IN       DRM_HDS_NAMESPACE_CONTEXT *pcontextNS,    /* Namespace context returned from DRM_HDS_OpenNamespace */
    IN const DRM_HDS_HASHKEY           *pHashKey, 
    IN const DRM_HDS_UNIQUEKEY         *pUniqueKey,
    IN       DRM_HDS_SLOT_HINT         *pSlotHint,
    IN       DRM_BOOL                   fWait);


DRM_RESULT DRM_API DRM_HDS_Checkpoint( 
    IN OUT   DRM_HDS_CONTEXT *pcontextHDS,
    IN       DRM_VOID        *pvOpaqueData,
    IN       DRM_BOOL         fCreate);                /* TRUE to create, FALSE to verify */


/**********************************************************************
** Function:    DRM_HDS_InitSlotEnum
** Synopsis:    
** Arguments:   [pcontextNS]   -- Namespace context init'd by DRM_HDS_OpenNamespace()
**              [pHashKey]     -- Hashkey, if given to query, if not, enum all will be performed
**              [eLockMode]    -- Flag specifing how to lock the slot
**              [pcontextEnum] -- returned Enum context
** Returns:     DRM_SUCCESS on success
** Notes:       This is 2 functions in one. If pHashKey is given, only the slots
**              with the same hashkey will be enum'ed. if pHashKey is NULL, all
**              slots within the namespace will be enum'ed.
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_InitSlotEnum(
    IN       DRM_HDS_NAMESPACE_CONTEXT *pcontextNS,     /* Namespace context returned from DRM_HDS_OpenNamespace */
    IN const DRM_HDS_HASHKEY           *pHashKey,       /* if NULL, all slots will be enum'ed */
    IN       DRM_HDS_LOCKMODE           eLockMode,
       OUT   DRM_HDS_ENUM_CONTEXT      *pcontextEnum);


/**********************************************************************
** Function:    DRM_HDS_SlotEnumNext
** Synopsis:    Get the next slot in the enumeration
** Arguments:   [pcontextEnum] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
**              [pcontextSlot] -- Slot Context of the current slot
**              [pHashKey] -- Hashkey of the current slot
**              [pUniqueKey] -- Uniquekey of the current slot
**              [pcbSlot] -- size of the current slot
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_SlotEnumNext( 
    IN     DRM_HDS_ENUM_CONTEXT *pcontextEnum,       /* setup by DRM_HDS_InitSlotEnum() */
       OUT DRM_HDS_SLOT_CONTEXT *pcontextSlot,       /* user given Dataslot context buffer */
       OUT DRM_HDS_HASHKEY      *pHashKey,           /* optional parameter */
       OUT DRM_HDS_UNIQUEKEY    *pUniqueKey,         /* optional parameter */
       OUT DRM_DWORD            *pcbSize);           /* current dataslot size, optional parameter */

/**********************************************************************
** Function:    DRM_HDS_SlotEnumReloadCurrent
** Synopsis:    Load the current slot in the enumeration
** Arguments:   [pcontextEnum] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
**              [pcontextSlot] -- Slot Context of the current slot
**              [pHashKey] -- Hashkey of the current slot
**              [pUniqueKey] -- Uniquekey of the current slot
**              [pcbSlot] -- size of the current slot
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_SlotEnumReloadCurrent( 
    IN     DRM_HDS_ENUM_CONTEXT *pcontextEnum,       /* setup by DRM_HDS_InitSlotEnum() */
       OUT DRM_HDS_SLOT_CONTEXT *pcontextSlot,       /* user given Dataslot context buffer */
       OUT DRM_HDS_HASHKEY      *pHashKey,           /* optional parameter */
       OUT DRM_HDS_UNIQUEKEY    *pUniqueKey,         /* optional parameter */
       OUT DRM_DWORD            *pcbSize);           /* current dataslot size, optional parameter */

/**********************************************************************
** Function:    DRM_HDS_SlotEnumDeleteCurrent
** Synopsis:    Delete the current enumerated slot
** Arguments:   [pcontextEnum] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
**              [pcontextSlot] -- Slot Context of the current slot
** Returns:     DRM_SUCCESS on success
** Notes:       The enumeration must be init'ed with EXCLUSIVE right.
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_SlotEnumDeleteCurrent( 
    IN  DRM_HDS_ENUM_CONTEXT *pcontextEnum,
    IN  DRM_HDS_SLOT_CONTEXT *pcontextSlot);

/* Block Scan API: rapid deletion of multiple slots */

DRM_RESULT DRM_API DRM_HDS_BlockScanDelete( 
    IN       DRM_HDS_NAMESPACE_CONTEXT *f_pcontextNS,
    IN const DRM_HDS_HASHKEY           *f_pkeyHash, 
    IN const DRM_HDS_UNIQUEKEY          f_rgkeyUnique [],
    IN const DRM_DWORD                  f_cKeysUnique,
    IN const DRM_BOOL                   f_fWait,
       OUT   DRM_HDS_BLOCKSCAN_CONTEXT *f_pcontextBlockScan);

/*
** ----------------------------------------------------------------------------
** Methods to read, write and seek within a dataslot
** ----------------------------------------------------------------------------
*/

/**********************************************************************
** Function:    DRM_HDS_SlotResize
** Synopsis:    resize an opened dataslot
** Arguments:   [pcontextSlot] -- An open slot context
**              [cbSize]       -- New size of the slot
** Returns:     DRM_SUCCESS on success
** Notes:       
** Possible cases:
** 
***********************************************************************/
DRM_RESULT DRM_API DRM_HDS_SlotResize( 
    IN DRM_HDS_SLOT_CONTEXT *pcontextSlot, 
    IN DRM_DWORD             cbSize);

DRM_RESULT DRM_API DRM_HDS_SlotSeek( 
    IN       DRM_HDS_SLOT_CONTEXT *pcontextSlot,
    IN const DRM_LONG              lOffset,
    IN const DRM_HDS_SEEKMODE      eOrigin,         /* as defined above */
       OUT   DRM_DWORD            *pwSeekPointer);  /* optional parameter, can be NULL */

DRM_RESULT DRM_API DRM_HDS_SlotRead( 
    IN     DRM_HDS_SLOT_CONTEXT *pcontextSlot,
    IN     DRM_DWORD             cbData,
       OUT DRM_BYTE             *pbData,
       OUT DRM_DWORD            *pcbRead);

DRM_RESULT DRM_API DRM_HDS_SlotWrite( 
    IN       DRM_HDS_SLOT_CONTEXT *pcontextSlot,
    IN       DRM_DWORD             cbData,
    IN const DRM_BYTE             *pbData,
       OUT   DRM_DWORD            *pcbWritten);


#ifdef __cplusplus
}
#endif

#endif  /* __DRM_HDS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmhds_impl.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


/*
** BUGBUG:
** - init muti-access in _SlotContext and _ChildBlockHDR using ui64TimeStamp.
** - Delete a Namespace may conflict with an opened Namespace.
*/

/* 
** Rules:
** - parent of any FreeBlock is SRN (ROOTPARENTNUM, 0x00)
** - parent of any Namespace Root block is SRN (ROOTPARENTNUM, ie: 0x00)
** - The NamespaceStore's Root block will not be free'd even when it is empty.
** - The Namespace Root block of any Namespaces will not be free'd even when it is empty.
** - When deleting a namespace and its blocks, ALL of the blocks including the Root will be free'd.
** ? Each block header contains the namespace's HashKey that it belongs for error checking.
**
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <oemimpl.h>
#include <drmsha1.h>
#include <drmhds.h>
#include "drmhds_impl.h"


/* undefine to print trace messages for lock/unlock functions */
/*#define _TRACELOCK */


#define ISOVERSIZESLOT(slotsize, cfg) \
    ((SIZEOF(_SlotHeader)+(slotsize))>(cfg)->nImagesize_ChildBlockPayload?TRUE:FALSE)

static const DRM_WORD  NsStoreNumofChildren=16;
static const DRM_BYTE  BLOCK_SIGNATURE [] = 
{
    TWO_BYTES(0xFF, 0xFE), TWO_BYTES(0xFD, 0xFC)
};
static const DRM_WORD  COPYBUFF_SIZE      = 1024;

static const DRM_CHAR  DEFAULTNS_HASHKEY1 [] = { TWO_BYTES( 'D', 'R'), TWO_BYTES( 'M', '_'),  TWO_BYTES( 'H', 'D'), TWO_BYTES( 'S', '_'), TWO_BYTES( 'H', 'A'), TWO_BYTES( 'S', 'H'), TWO_BYTES( 'K', 'E'), TWO_BYTES( 'Y', '1') };
static const DRM_CHAR  DEFAULTNS_HASHKEY2 [] = { TWO_BYTES( 'D', 'R'), TWO_BYTES( 'M', '_'),  TWO_BYTES( 'H', 'D'), TWO_BYTES( 'S', '_'), TWO_BYTES( 'H', 'A'), TWO_BYTES( 'S', 'H'), TWO_BYTES( 'K', 'E'), TWO_BYTES( 'Y', '2') };


#define DRM_HDS_FILE_CURR_VERSION   0x000A0000
#define HDS_FILEHEADERSIZE          4096



/* forward declaration */
static DRM_RESULT _HdsRemoveSlot( 
    _SlotContext    *pSlotCtx,
    _ERemoveSlotMode eMode);

static DRM_RESULT _HdsBlockNum2FilePos(
    IN  _HdsContext *pHDS,
    IN  DRM_DWORD    nBlkNum, 
    OUT DRM_DWORD   *pnFilePos);

static DRM_RESULT _HdsPreAlloc( 
    IN  _HdsContext *f_pHDS,
    IN  DRM_DWORD    f_PreAllocFileSizeInKB,
    IN  DRM_BOOL     f_fUpToSpecifiedSize,
    OUT DRM_DWORD   *f_pnNextBlockNum);



/*
** Validate an _NSEntry from disk
*/
static DRM_RESULT _HdsValidateNSEntryFromDisk( 
    _HdsContext *f_pHDS,
    _NSEntry    *f_pNsEntry )
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwFilePos  = 0;
    DRM_DWORD dwFileSize = 0;
    
    DRMASSERT( f_pHDS     != NULL
        &&     f_pNsEntry != NULL );

    /* verify # of child blocks in Alloc table */
    if(  f_pNsEntry->wMaxNumChildren == 0 
      || f_pNsEntry->wMaxNumChildren > DRM_HDS_MAXIMUM_CHILDREN 
      || f_pNsEntry->nNSRBlockNum    == 0 )
    {
        ChkDR( DRM_E_HDSFILECORRUPTED );
    }

    /* validate root block# */
    ChkDR(_HdsBlockNum2FilePos(f_pHDS, f_pNsEntry->nNSRBlockNum, &dwFilePos));
    ChkBOOL(OEM_GetFileSize(f_pHDS->fp, &dwFileSize), DRM_E_HDSFILECORRUPTED);
    ChkBOOL((dwFilePos < dwFileSize), DRM_E_HDSFILECORRUPTED);
    
ErrorExit:   

    return dr;
}

/*
** Compute the block# from a block's given file pos.
*/
static DRM_RESULT _HdsFilePos2BlockNum(
    IN  _HdsContext *pHDS,
    IN  DRM_DWORD    dwFilePos,
    OUT DRM_DWORD   *pnBlockNum)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  nBlockNum=0;

    ChkArg(ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(pHDS && pHDS->fInited &&  pnBlockNum);
    if ( dwFilePos < HDS_FILEHEADERSIZE )
    {
        DRMASSERT(FALSE);
    }

    nBlockNum = (dwFilePos - HDS_FILEHEADERSIZE) 
        / pHDS->oSRN.dwBlockSize;
        
    ++nBlockNum;    /* any block other than SRN starts from 1 */

    /* mask the block# according the BlockNumType */
    switch(pHDS->oSRN.eBlockNumType)
    {
        case eDRM_HDSBLKNUM_WORD:
            nBlockNum &= 0x0000FFFF;
            break;
        default:
            break;
    }
    
    *pnBlockNum = nBlockNum;

ErrorExit:
    
    return dr;
}

/*
** Compute the file pos of a given block
*/
static DRM_RESULT _HdsBlockNum2FilePos(
    IN  _HdsContext *pHDS,
    IN  DRM_DWORD    nBlkNum, 
    OUT DRM_DWORD   *pnFilePos)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD dwFilePos = 0;

    ChkArg(ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(pHDS && pHDS->fInited && pnFilePos);

    dwFilePos = HDS_FILEHEADERSIZE; 
    dwFilePos += (nBlkNum-1) * pHDS->oSRN.dwBlockSize;
    *pnFilePos = dwFilePos;

ErrorExit:    
    return dr;
}


/**********************************************************************
** Function:    _HdsLockSRN
** Synopsis:    Accquire lock to the Super Root Node 
** Arguments:   [pHDS] -- 
**              [eMode] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsLockSRN(
    _HdsContext *pHDS,
    DRM_DWORD    eMode)
{
#if _MULTI_THREADING_SUPPORT==1

    DRM_RESULT dr=DRM_SUCCESS;

#ifdef _TRACELOCK
    TRACE(("LockSRN issued: %c%c\n", 
           (eMode & eDRM_HDS_LOCKEXCLUSIVE)? 'X' : 'S',
           (eMode & eDRM_HDS_LOCKWAIT)? 'W' : ' '));
#endif
    /*
    **  All calls to lock the SRN should wait regardless of the wait mode passed
    **  into the various API.  It makes sense that the caller wants control over
    **  whether to wait for a slot lock since those locks are long lasting (and
    **  under control of the calling application).  But the user doesnt want 
    **  control over a frequently grabbed, internal, short-term lock like the 
    **  SRN.  Doing so will result is random failures that the caller wont be 
    **  able to understand.
    */
    if ( !OEM_LockFile( pHDS->fp, 
                        ((eMode & eDRM_HDS_LOCKEXCLUSIVE) != 0), 
                        0, 
                        HDS_FILEHEADERSIZE,
                        TRUE ) )
    {
        ChkDR(DRM_E_HDSLOCKFAILED);
    }
#ifdef _TRACELOCK
    TRACE(("LockSRN obtained\n"));
#endif    
ErrorExit:
    return dr;
    
#else
    return DRM_SUCCESS;
#endif
}


/**********************************************************************
** Function:    _HdsUnlockSRN
** Synopsis:    Release lock to a specific store block 
** Arguments:   [pHDS] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsUnlockSRN(
    _HdsContext *pHDS)
{
#if _MULTI_THREADING_SUPPORT==1

    DRM_RESULT dr=DRM_SUCCESS;

    if ( pHDS->fp == OEM_INVALID_HANDLE_VALUE )
    {
        ChkDR(DRM_E_HDSLOCKFAILED);
    }

#ifdef _TRACELOCK
    TRACE(("\tUnlockSRN issued \n"));
#endif
    if (!OEM_UnlockFile(pHDS->fp, 0, HDS_FILEHEADERSIZE))
    {
        ChkDR(DRM_E_HDSLOCKFAILED);
    }

ErrorExit:
    return dr;
    
#else
    return DRM_SUCCESS;
#endif
}

/**********************************************************************
** Function:    _HdsLockStore
** Synopsis:    Accquire lock for the store 
** Arguments:   [pHDS] -- 
**              [fExclusive] --
** Returns:     DRM_SUCCESS on success
** Notes:       It is essentially the same as _HdsLockSlot where we are
**              grabbing a lock on a bigger slot (all the blocks)
***********************************************************************
*/
static DRM_RESULT _HdsLockStore(
    _HdsContext *pHDS,
    DRM_DWORD    eMode)
{
#if _MULTI_THREADING_SUPPORT==1

    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwSRN = HDS_FILEHEADERSIZE;

#ifdef _TRACELOCK
    TRACE(("LockStore issued: %c\n", (eMode & eDRM_HDS_LOCKEXCLUSIVE) != 0 ? 'X' : 'S'));
#endif
    
    /* lock the whole file from SRN */
    if (!OEM_LockFile(
            pHDS->fp, 
            ((eMode & eDRM_HDS_LOCKEXCLUSIVE) != 0),
            dwSRN, 
            0xFFFFFFFF-dwSRN,
            ((eMode & eDRM_HDS_LOCKWAIT) != 0) ) )
    {
        ChkDR(DRM_E_HDSLOCKFAILED);
    }
#ifdef _TRACELOCK
    TRACE(("LockStore obtained\n"));
#endif    
    
ErrorExit:
    return dr;
#else
    return DRM_SUCCESS;
#endif
}


/**********************************************************************
** Function:    _HdsUnlockStore
** Synopsis:    Release lock for the store 
** Arguments:   [pHDS] -- 
**              
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsUnlockStore(
    _HdsContext *pHDS )
{
#if _MULTI_THREADING_SUPPORT==1
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwSRN = HDS_FILEHEADERSIZE;

    /* unlock the whole file from SRN */
#ifdef _TRACELOCK
    TRACE(("\tUnlockStore issued\n"));
#endif
    if (!OEM_UnlockFile(pHDS->fp, dwSRN, 0xFFFFFFFF-dwSRN))
    {
        ChkDR(DRM_E_HDSLOCKFAILED);
    }

ErrorExit:
    return dr;
#else
    return DRM_SUCCESS;
#endif
}

/**********************************************************************
** Function:    _HdsLockSlot
** Synopsis:    Accquire lock to a specific slot 
** Arguments:   [pSlotCtx] -- 
**              [eMode] --
** Returns:     DRM_SUCCESS on success
** Notes:       The slot header will only be locked for SHARED. THis is
**              necessary for making Search to work.
***********************************************************************
*/
static DRM_RESULT _HdsLockSlot(
    _SlotContext *pSlotCtx,
    DRM_DWORD     eMode)
{
#if _MULTI_THREADING_SUPPORT==1

    DRM_RESULT dr           = DRM_SUCCESS;
    DRM_DWORD  dwFilePos    = 0;
    DRM_LONG   dwLockSize   = 0;

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS, 
        pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* adjust filepos relative to the block */
    dwFilePos += pSlotCtx->pNS->nChildBlockPayloadPos;
    dwFilePos += pSlotCtx->dwSlotPosInBlock;
    dwFilePos += SIZEOF(_SlotHeader);
    
    if ( ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        dwLockSize = SIZEOF(DRM_DWORD);
    }
    else
    {
        dwLockSize = pSlotCtx->oSlotHeader.dwSlotSize;
    }

#ifdef _TRACELOCK
    TRACE(("LockSlot issued:  %c%c - pos %d,  size %d\n", 
           (eMode & eDRM_HDS_LOCKEXCLUSIVE)? 'X' : 'S', 
           (eMode & eDRM_HDS_LOCKWAIT)? 'W' : ' ', 
           dwFilePos, 
           dwLockSize));
#endif

    /* lock slot content */
    if ( !OEM_LockFile( pSlotCtx->pNS->pHDS->fp, 
                        ((eMode & eDRM_HDS_LOCKEXCLUSIVE) != 0), 
                        dwFilePos, 
                        dwLockSize,
                        ( (eMode & eDRM_HDS_LOCKWAIT) != 0 ) ) )
    {
        ChkDR(DRM_E_HDSLOCKFAILED);
    }
    pSlotCtx->eLockMode = eMode;
    
#ifdef _TRACELOCK
    TRACE(("LockSlot obtained\n"));
#endif    

ErrorExit:
    return dr;
    
#else

    pSlotCtx->eLockMode = eMode;
    return DRM_SUCCESS;
    
#endif
}


/**********************************************************************
** Function:    _HdsUnlockSlot
** Synopsis:    release lock to a specific slot 
** Arguments:   [pSlotCtx] -- 
**              [fExclusive] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsUnlockSlot(
    _SlotContext *pSlotCtx)
{
#if _MULTI_THREADING_SUPPORT==1

    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwFilePos=0;
    DRM_LONG   dwLockSize=0;
    DRM_BOOL   fResult = FALSE;
    
    DRMASSERT(pSlotCtx!=NULL);

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS, 
        pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* adjust filepos relative to the block */
    dwFilePos += pSlotCtx->pNS->nChildBlockPayloadPos;
    dwFilePos += pSlotCtx->dwSlotPosInBlock;
    dwFilePos += SIZEOF(_SlotHeader);
    
    if ( ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        dwLockSize = SIZEOF(DRM_DWORD);
    }
    else
    {
        dwLockSize = pSlotCtx->oSlotHeader.dwSlotSize;
    }

#ifdef _TRACELOCK
    TRACE(("\tUnlockSlot issued:  pos %d,  size %d\n", dwFilePos, dwLockSize));
#endif
   
    if ( !OEM_UnlockFile( pSlotCtx->pNS->pHDS->fp,
                          dwFilePos, 
                          dwLockSize ) )
    {
        ChkDR(DRM_E_HDSLOCKFAILED);
    }
    
ErrorExit:
    
    return dr;
    
#else
    return DRM_SUCCESS;
#endif
}


/**********************************************************************
** Function:    _HdsLockBlock2DeleteSlot
** Synopsis:    lock block payload from the given slot to end of block.
**              It is essentially the same as _HdsLockSlot where we are
**              grabbing a lock on a bigger slot.
** Arguments:   [pSlotCtx] -- 
**              [fExclusive] --
** Returns:     DRM_SUCCESS on success
** Notes:       To remove a slot from a block, it is necessary to lock
**              the slot to end of block (to do adjustments).
***********************************************************************
*/
static DRM_RESULT _HdsLockBlock2DeleteSlot(
    _SlotContext *pSlotCtx,
    DRM_DWORD     eMode)
{
#if _MULTI_THREADING_SUPPORT==1

    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwFilePos=0;
    DRM_LONG   dwLockSize=0;

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS, 
        pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* adjust filepos relative to the block */
    dwLockSize = dwFilePos + pSlotCtx->pNS->pHDS->oSRN.dwBlockSize;
    dwFilePos += (pSlotCtx->pNS->nChildBlockPayloadPos + pSlotCtx->dwSlotPosInBlock);
    dwLockSize -= dwFilePos;

#ifdef _TRACELOCK
    TRACE(("LockSlot2RestOfBlock issued:  %c%c - pos %d,  size %d\n", 
          (eMode & eDRM_HDS_LOCKEXCLUSIVE)? 'X' : 'S', 
          (eMode & eDRM_HDS_LOCKWAIT)? 'W' : ' ', 
          dwFilePos, 
          dwLockSize));
#endif

    /* lock it */
    if ( !OEM_LockFile(
            pSlotCtx->pNS->pHDS->fp, 
            ((eMode & eDRM_HDS_LOCKEXCLUSIVE) != 0), 
            dwFilePos, 
            dwLockSize,
            ((eMode & eDRM_HDS_LOCKWAIT) != 0) ) )
    {
        ChkDR(DRM_E_HDSLOCKFAILED);
    }
#ifdef _TRACELOCK
    TRACE(("LockSlot2RestOfBlock obtained\n"));
#endif    

ErrorExit:
    return dr;
    
#else

    return DRM_SUCCESS;
    
#endif
}


static DRM_RESULT _HdsUnlockBlock2DeleteSlot(
    _SlotContext *pSlotCtx)
{
#if _MULTI_THREADING_SUPPORT==1

    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwFilePos=0;
    DRM_LONG   dwLockSize=0;
    DRM_BOOL   fResult = FALSE;

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS, 
        pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* adjust filepos relative to the block */
    dwLockSize = dwFilePos + pSlotCtx->pNS->pHDS->oSRN.dwBlockSize;
    dwFilePos += (pSlotCtx->pNS->nChildBlockPayloadPos+pSlotCtx->dwSlotPosInBlock);
    dwLockSize -= dwFilePos;

#ifdef _TRACELOCK
    TRACE(("_HdsUnlockBlock2DeleteSlot issued:  - pos %d,  size %d\n", dwFilePos, 
        dwLockSize));
#endif

    /* unlock it, do not return even if this fail */
    fResult = OEM_UnlockFile(pSlotCtx->pNS->pHDS->fp, dwFilePos, dwLockSize);

    if ( !fResult )
    {
        dr = DRM_E_HDSLOCKFAILED;
    }

ErrorExit:
    return dr;
    
#else

    return DRM_SUCCESS;
    
#endif
}


/**********************************************************************
** Function:    _Hds_malloc
** Synopsis:    HDS Component memory allocation redirector
** Arguments:   [pHDS] -- 
**              [cbBuffer] --
**              [ppbBuffer] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _Hds_malloc(
    _HdsContext *pHDS,
    DRM_DWORD    cbBuffer,
    DRM_VOID   **ppbBuffer)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRMASSERT(pHDS && ppbBuffer && cbBuffer);
    
    ChkDR(DRM_STK_Alloc(&pHDS->oHeap, cbBuffer, ppbBuffer));

ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    _Hds_free
** Synopsis:    HDS Component memory allocation redirector
** Arguments:   [pHDS] -- 
**              [pBuffer] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _Hds_free(
    _HdsContext *pHDS,
    DRM_VOID    *pBuffer)
{
    DRMASSERT(pHDS!=NULL);

    if (pBuffer==NULL)
    {
        return DRM_SUCCESS;
    }
        
    return DRM_STK_Free(&pHDS->oHeap, pBuffer);
}



/**********************************************************************
** Function:    _GetTimeStamp
** Synopsis:    Generate 8-byte timestamp
** Arguments:   [pdwStamp] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_UINT64 _GetTimeStamp()
{
    DRM_UINT64  u64      = { 0 };
    DRMFILETIME filetime = { 0, 0 };

    OEM_GetDeviceTime( &filetime );

    FILETIME_TO_UI64( filetime, u64 );

    return u64;
}


/**********************************************************************
** Function:    _IsNULL
** Synopsis:    check if the given byte array contains all NULL bytes.
** Arguments:   [pbBuff] -- byte array to be checked
**              [cbBuff[ -- size of pbBuff
** Returns:     TRUE if all NULL
** Notes:       
***********************************************************************
*/
static DRM_BOOL _IsNULL(
    const DRM_BYTE *pbBuff,
          DRM_DWORD cbBuff)
{
    DRM_DWORD i=0;

    for (i=0; i<cbBuff; i++)
    {
        if (GET_BYTE(pbBuff,i) != 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}

/*
** generate hash keys for namespace name
*/
static DRM_VOID _GenNamespaceKeys(
    IN DRM_MD5_CTX *pcontextMD5,
    IN const DRM_CHAR* pbNamespace,
    IN DRM_WORD cbNamespace,
    OUT DRM_BYTE bNsHashKey   [__CB_DECL(DRM_HDS_HASHKEY_SIZE)], 
    OUT DRM_BYTE bNsUniqueKey [__CB_DECL(DRM_HDS_UNIQUEKEY_SIZE)])
{
    DRM_MD5_Init(pcontextMD5 );
    DRM_MD5_Update(pcontextMD5, (DRM_VOID*)pbNamespace, cbNamespace);
    DRM_MD5_Update(pcontextMD5, (DRM_VOID*)DEFAULTNS_HASHKEY1, SIZEOF(DEFAULTNS_HASHKEY1) );
    DRM_MD5_Final( pcontextMD5 );

	MEMCPY(bNsHashKey, pcontextMD5->digest, DRM_HDS_HASHKEY_SIZE);

    DRM_MD5_Init(pcontextMD5 );
    DRM_MD5_Update(pcontextMD5, (DRM_VOID*)pbNamespace, cbNamespace);
    DRM_MD5_Update(pcontextMD5, (DRM_VOID*)DEFAULTNS_HASHKEY2, SIZEOF(DEFAULTNS_HASHKEY2) );
    DRM_MD5_Final( pcontextMD5 );
	
    MEMCPY(bNsUniqueKey, pcontextMD5->digest, DRM_HDS_HASHKEY_SIZE);
}



/**********************************************************************
** Function:    _GenSRNHash
** Synopsis:    Generate hash of the Super Root Node 
** Arguments:   [pLSContext] -- 
**              [hash] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsGenSRNHash(
    IN  _HdsContext *pHDS,
    OUT DRM_BYTE     hash [__CB_DECL(MD5DIGESTLEN)])
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD dwByte;

    ChkArg(ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT(pHDS && pHDS->fInited);
    DRM_MD5_Init( &pHDS->contextMD5 );

    BYTES_TO_DWORD( dwByte, ((DRM_BYTE*)&(pHDS->oSRN.dwSRNSize)) );
    DRM_MD5_Update(&pHDS->contextMD5, (DRM_VOID*)&dwByte, SIZEOF(DRM_DWORD));

    BYTES_TO_DWORD( dwByte, ((DRM_BYTE*)&(pHDS->oSRN.dwBlockSize)) );
    DRM_MD5_Update(&pHDS->contextMD5, (DRM_VOID*)&dwByte, SIZEOF(DRM_DWORD));

    BYTES_TO_DWORD( dwByte, ((DRM_BYTE*)&(pHDS->oSRN.eBlockNumType)) );
    DRM_MD5_Update(&pHDS->contextMD5, (DRM_VOID*)&dwByte, SIZEOF(DRM_DWORD));

    BYTES_TO_DWORD( dwByte, ((DRM_BYTE*)&(pHDS->oSRN.nFreeListHead)) );
    DRM_MD5_Update(&pHDS->contextMD5, (DRM_VOID*)&dwByte, SIZEOF(DRM_DWORD));

    BYTES_TO_DWORD( dwByte, ((DRM_BYTE*)&(pHDS->oSRN.nNsStoreRootBlockNum)) );
    DRM_MD5_Update(&pHDS->contextMD5, (DRM_VOID*)&dwByte, SIZEOF(DRM_DWORD));

    DRM_MD5_Final( &pHDS->contextMD5 );
    MEMCPY( hash, pHDS->contextMD5.digest, SIZEOF( pHDS->contextMD5.digest ) );

ErrorExit:
    return dr;
}

/*
**
*/
static DRM_RESULT _HdsInitBlockBuffer(
    IN  _NsContext    *pNS,
    OUT _CommBlockHDR *pBlock,
    IN  DRM_DWORD      nParentBlockNum,
    IN  _EBlockType    eBlockType)
{
    DRM_RESULT dr=DRM_SUCCESS;
    
    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    DRMASSERT(pNS && pNS->fInited && pBlock);

    /* set up the block */
    pBlock->File._image.nParentBlockNum = nParentBlockNum;
    pBlock->File._image.ui64TimeStamp   = _GetTimeStamp();

    PUT_BYTE( &pBlock->File._image.bBlockType, 0, eBlockType );

    if (eBlockType==eCHILDBLOCK)
    {
        _ChildBlockHDR *pChild = (_ChildBlockHDR*)pBlock;
        pChild->nCurrSlotPos = MAXSLOTPOS;
        pChild->nNextSlotPos = MAXSLOTPOS;
        pChild->nPayloadSize = pNS->nImagesize_ChildBlockPayload;
        pChild->File._image.nFreeMem = pNS->nImagesize_ChildBlockPayload;
        ZEROMEM(pChild->File._image.bChildAllocTable, pNS->nImagesize_ChildAllocTable);
    }
    else   /* eDATABLOCK or eFREEBLOCK */
    {
        _DataBlockHDR *pData = (_DataBlockHDR*)pBlock;
        pData->nPayloadSize = pNS->pHDS->nImagesize_DataBlockPayload;
        pData->File._image.nCascadingBlockNum = 0;
    }

ErrorExit:
    return dr;
}

/*
** create a buffer big enough for a store block
*/
static DRM_RESULT _HdsAllocBlockBuffer(
    IN  _NsContext     *pNS,
    IN  _EBlockType     eBlockType,
    OUT _CommBlockHDR **ppBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD cbBlocksize=0;

    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    DRMASSERT( pNS 
            && pNS->fInited 
            && ppBlock 
            && ( eBlockType==eCHILDBLOCK || eBlockType==eDATABLOCK ) );

    /* allocate buffer for the block */
    if ( eBlockType==eCHILDBLOCK )
    {
        cbBlocksize = GetMemsize_ChildBlock(pNS);
    }
    else /* eDATABLOCK */
    {
        cbBlocksize = GetMemsize_DataBlock();
    }

    ChkDR(_Hds_malloc(pNS->pHDS, cbBlocksize, (DRM_VOID**)ppBlock));
    ChkDR(_HdsInitBlockBuffer(pNS, *ppBlock, 0, eBlockType));

ErrorExit:
    return dr;
}


#define _MEMBER_ENCODE(pb, ib, x) \
    DRM_BYT_CopyBytes(pb, ib, (DRM_BYTE*)&x, 0, SIZEOF(x)); \
    ib += SIZEOF(x)

#define _MEMBER_DECODE(pb, ib, x) \
    DRM_BYT_CopyBytes((DRM_BYTE*)&x, 0, pb, ib, SIZEOF(x)); \
    ib += SIZEOF(x)

static DRM_BOOL _WriteSRN( 
    _HdsContext *pHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbWritten = 0;
    DRM_BOOL   fOK       = TRUE;
    DRM_BYTE  *pbBuffer  = NULL;
    DRM_DWORD  cbBuffer  = 0;
    DRM_DWORD  ibBuffer  = 0;
    
    FIX_ENDIAN_QWORD( pHDS->oSRN.ui64Timestamp );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwSRNSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwBlockSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nFreeListHead );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nNsStoreRootBlockNum );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwReserved );
    FIX_ENDIAN_DWORD( pHDS->oSRN.eBlockNumType );

    /* this must be updated when the structure of SRN is modified */
    cbBuffer = SIZEOF(DRM_UINT64) + 6 * SIZEOF(DRM_DWORD) + MD5DIGESTLEN;
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* encode structure to byte array */
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.bSRNHash);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.dwSRNSize);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.dwBlockSize);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.eBlockNumType);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.ui64Timestamp);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.nFreeListHead);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.nNsStoreRootBlockNum);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pHDS->oSRN.dwReserved);

    /* write to file */
    if ( !OEM_WriteFile( pHDS->fp, pbBuffer, cbBuffer, &cbWritten ) 
      || cbWritten != cbBuffer)
    {
        fOK = FALSE;
    }
    
ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    
    FIX_ENDIAN_QWORD( pHDS->oSRN.ui64Timestamp );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwSRNSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwBlockSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nFreeListHead );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nNsStoreRootBlockNum );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwReserved );
    FIX_ENDIAN_DWORD( pHDS->oSRN.eBlockNumType );
    
    return fOK;
}


static DRM_BOOL _ReadSRN( 
    _HdsContext *pHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbRead = 0;
    DRM_BOOL   fOK = TRUE;
    DRM_BYTE  *pbBuffer  = NULL;
    DRM_DWORD  cbBuffer  = 0;
    DRM_DWORD  ibBuffer  = 0;

    /* this must be updated when the structure of SRN is modified */
    cbBuffer = SIZEOF(DRM_UINT64) + 6 * SIZEOF(DRM_DWORD) + MD5DIGESTLEN;
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* read byte array from file */
    if ( !OEM_ReadFile( pHDS->fp, pbBuffer, cbBuffer, &cbRead ) 
      || cbRead != cbBuffer)
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* decode structure members from byte array */
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.bSRNHash);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.dwSRNSize);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.dwBlockSize);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.eBlockNumType);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.ui64Timestamp);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.nFreeListHead);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.nNsStoreRootBlockNum);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pHDS->oSRN.dwReserved);

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_QWORD( pHDS->oSRN.ui64Timestamp );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwSRNSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwBlockSize );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nFreeListHead );
    FIX_ENDIAN_DWORD( pHDS->oSRN.nNsStoreRootBlockNum );
    FIX_ENDIAN_DWORD( pHDS->oSRN.dwReserved );
    FIX_ENDIAN_DWORD( pHDS->oSRN.eBlockNumType );
    
    return fOK;
}

static DRM_BOOL _WriteCommonBlockHeader( 
    _HdsContext   *pHDS,
    _CommBlockHDR *pBlock, 
    DRM_DWORD      cbToWrite,
    DRM_DWORD     *pcbWritten)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  cbWritten = 0;
    DRM_BOOL   fOK = TRUE;
    DRM_DWORD  ibBuffer = 0;
    DRM_DWORD  cbBuffer = 0;
    DRM_BYTE  *pbBuffer = NULL;
    
    DRMASSERT( pBlock != NULL );

    FIX_ENDIAN_QWORD( pBlock->File._image.ui64TimeStamp );
    FIX_ENDIAN_DWORD( pBlock->File._image.nParentBlockNum );

    /* this must be updated when the structure of _CommBlockHDR is modified */
    cbBuffer = SIZEOF(DRM_UINT64) + MD5DIGESTLEN + SIZEOF(DRM_DWORD) + 1;
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* encode structure to byte array */
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pBlock->File._image.ui64TimeStamp);
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pBlock->File._image.bBlockHash );
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pBlock->File._image.nParentBlockNum );
    DRM_BYT_CopyBytes(pbBuffer, ibBuffer, &(pBlock->File._image.bBlockType), 0, 1);
    ibBuffer += 1;

    /* write byte array to file */
    if ( !OEM_WriteFile( pHDS->fp, pbBuffer, cbBuffer, &cbWritten ) 
      || cbWritten != cbBuffer)
    {
        fOK = FALSE;
    }

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_QWORD( pBlock->File._image.ui64TimeStamp );
    FIX_ENDIAN_DWORD( pBlock->File._image.nParentBlockNum );

    if ( pcbWritten!= NULL )
    {
        *pcbWritten = cbWritten;
    }
    return fOK;
}

static DRM_BOOL _ReadCommonBlockHeader( 
    _HdsContext   *pHDS,
    _CommBlockHDR *pBlock, 
    DRM_DWORD      cbToRead, 
    DRM_DWORD     *pcbRead )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_BOOL   fOK = TRUE;
    DRM_DWORD  cbRead   = 0;
    DRM_DWORD  ibBuffer = 0;
    DRM_DWORD  cbBuffer = 0;
    DRM_BYTE  *pbBuffer = NULL;

    DRMASSERT( pBlock != NULL );

    /* this must be updated when the structure of _CommBlockHDR is modified */
    cbBuffer = SIZEOF(DRM_UINT64) + MD5DIGESTLEN + SIZEOF(DRM_DWORD) + 1;
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* read byte array from file */
    if ( !OEM_ReadFile( pHDS->fp, pbBuffer, cbBuffer, &cbRead ) 
      || cbRead != cbBuffer)
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* decode structur member from file */
    _MEMBER_DECODE(pbBuffer, ibBuffer, pBlock->File._image.ui64TimeStamp);
    _MEMBER_DECODE(pbBuffer, ibBuffer, pBlock->File._image.bBlockHash );
    _MEMBER_DECODE(pbBuffer, ibBuffer, pBlock->File._image.nParentBlockNum );
    DRM_BYT_CopyBytes(&(pBlock->File._image.bBlockType), 0, pbBuffer, ibBuffer, 1);

    ibBuffer += 1;

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_QWORD( pBlock->File._image.ui64TimeStamp );
    FIX_ENDIAN_DWORD( pBlock->File._image.nParentBlockNum );

    if ( pcbRead!= NULL )
    {
        *pcbRead = cbRead;
    }
    return fOK;
}

static DRM_BOOL _ReadChildBlockHeader( 
    _HdsContext    *pHDS,
    _ChildBlockHDR *pChild, 
    DRM_DWORD       dwSize )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_BOOL   fOK = TRUE;
    DRM_DWORD  cbRead   = 0;
    DRM_DWORD  ibBuffer = 0;
    DRM_DWORD  cbBuffer = 0;
    DRM_BYTE  *pbBuffer = NULL;

    /* this must be updated when the structure of _ChildBlockHDR is modified */
    cbBuffer = dwSize;
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* read byte array from file */
    if ( !OEM_ReadFile( pHDS->fp, pbBuffer, cbBuffer, &cbRead ) 
      || cbRead != cbBuffer)
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* decode structure member from byte array */
    _MEMBER_DECODE(pbBuffer, ibBuffer, pChild->File._image.nFreeMem);
    DRM_BYT_CopyBytes(&(pChild->File._image.bChildAllocTable), 
                      0, 
                      pbBuffer, 
                      ibBuffer, 
                      dwSize - SIZEOF(pChild->File._image.nFreeMem));
    ibBuffer += dwSize - SIZEOF( pChild->File._image.nFreeMem );
    
ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_DWORD( pChild->File._image.nFreeMem );
    return fOK;
}

static DRM_BOOL _WriteChildBlockHeader( 
    _HdsContext    *pHDS,
    _ChildBlockHDR *pChild, 
    DRM_DWORD       dwSize )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_BOOL   fOK = TRUE;
    DRM_DWORD  cbWritten = 0;
    DRM_DWORD  ibBuffer  = 0;
    DRM_DWORD  cbBuffer  = 0;
    DRM_BYTE  *pbBuffer  = NULL;
    
    FIX_ENDIAN_DWORD( pChild->File._image.nFreeMem );

    /* this must be updated when the structure of _ChildBlockHDR is modified */
    cbBuffer = dwSize;
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* encode structure member to byte array */
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pChild->File._image.nFreeMem);
    DRM_BYT_CopyBytes(pbBuffer, 
                      ibBuffer, 
                      &(pChild->File._image.bChildAllocTable), 
                      0, 
                      dwSize - SIZEOF(pChild->File._image.nFreeMem));
    
    ibBuffer += dwSize - SIZEOF( pChild->File._image.nFreeMem );

    /* write byte array to file */    
    if ( !OEM_WriteFile( pHDS->fp, pbBuffer, cbBuffer, &cbWritten ) 
      || cbWritten != cbBuffer)
    {
        fOK = FALSE;
    }

ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_DWORD( pChild->File._image.nFreeMem );
    return fOK;
}

static DRM_BOOL _ReadDataBlockHeader( 
    _HdsContext   *pHDS,
    _DataBlockHDR *pBlock )
{
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_BOOL   fOK = TRUE;
    DRM_DWORD  cbRead    = 0;
    DRM_DWORD  ibBuffer  = 0;
    DRM_DWORD  cbBuffer  = 0;
    DRM_BYTE  *pbBuffer  = NULL;
   
    DRMASSERT( pBlock != NULL );

    /* this must be updated when the structure of _DataBlockHDR is modified */
    cbBuffer = SIZEOF(pBlock->File._image.nCascadingBlockNum);
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* read byte array from file */
    if ( !OEM_ReadFile( pHDS->fp, pbBuffer, cbBuffer, &cbRead ) 
      || cbRead != cbBuffer)
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    /* decode structure member from byte array */
    _MEMBER_DECODE(pbBuffer, ibBuffer, pBlock->File._image.nCascadingBlockNum);
    
ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_DWORD( pBlock->File._image.nCascadingBlockNum );
    return fOK;
}

static DRM_BOOL _WriteDataBlockHeader( 
    _HdsContext   *pHDS,
    _DataBlockHDR *pBlock )
{
    DRM_BOOL   fOK = TRUE;
    DRM_RESULT dr  = DRM_SUCCESS;
    DRM_DWORD  cbWritten = 0;
    DRM_DWORD  ibBuffer  = 0;
    DRM_DWORD  cbBuffer  = 0;
    DRM_BYTE  *pbBuffer  = NULL;
    
    DRMASSERT( pBlock != NULL );

    /* this must be updated when the structure of _DataBlockHDR is modified */
    cbBuffer = SIZEOF(pBlock->File._image.nCascadingBlockNum);
    dr = _Hds_malloc(pHDS, cbBuffer, (DRM_VOID **) &pbBuffer);
    if ( DRM_FAILED(dr) )
    {
        fOK = FALSE;
        goto ErrorExit;
    }

    FIX_ENDIAN_DWORD( pBlock->File._image.nCascadingBlockNum );
    _MEMBER_ENCODE(pbBuffer, ibBuffer, pBlock->File._image.nCascadingBlockNum);
    if ( !OEM_WriteFile( pHDS->fp, pbBuffer, cbBuffer, &cbWritten ) 
      || cbWritten != cbBuffer)
    {
        fOK = FALSE;
    }
    
ErrorExit:
    (void)_Hds_free(pHDS, pbBuffer);
    FIX_ENDIAN_DWORD( pBlock->File._image.nCascadingBlockNum );
    return fOK;
}

/**********************************************************************
** Function:    GetPutBlock
** Synopsis:    
** Arguments:   [pHDS] -- pointer to LicenseStore Context structure
**              [nBlkNum] --block number 
**              [ppBlock] --buffer to receive the new block, if *ppBlock is NULL, 
**                         a new buffer will be allocated from the context. 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/

#define GPBH_GENERIC_ONLY   TRUE
#define GPBH_ANY_HEADER     FALSE

#define GPBH_OPERATION_READ  TRUE
#define GPBH_OPERATION_WRITE  FALSE

static DRM_RESULT
_HdsGetPutBlockHDR(
    IN _NsContext *pNS,
    IN DRM_DWORD nBlkNum,
    IN OUT _CommBlockHDR **ppBlock,
    IN DRM_BOOL fGenericHeaderOnly,
    IN DRM_BOOL fGet)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD dwFilePos = 0;
    _HdsContext *pHDS=NULL;

#if DRM_PROFILE_HDSGETPUT
    DRM_PROFILING_ENTER_SCOPE(L"_HdsGetPutBlockHDR", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
#endif

    /* Seek to the begining of the block and read the data. */
    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    DRMASSERT(pNS&& pNS->fInited && ppBlock && nBlkNum);
    pHDS = pNS->pHDS;

    ChkDR(_HdsBlockNum2FilePos(pHDS, nBlkNum, &dwFilePos));

    /* read/write the file block header */
    if ( fGet )
    {
        _CommBlockHDR tmpBlock;
        DRM_DWORD     dwFileSize = 0;

        /* verify the file position: 
        ** file header must be less than or equal to file size - block size 
        */
        ChkBOOL(OEM_GetFileSize(pHDS->fp, &dwFileSize), DRM_E_HDSFILECORRUPTED);
        ChkBOOL((dwFilePos <= (dwFileSize - pHDS->oSRN.dwBlockSize)), DRM_E_HDSFILECORRUPTED);

        if (!OEM_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
        {
            ChkDR(DRM_E_FILEREADERROR);
        }

        if( !_ReadCommonBlockHeader( pHDS, &tmpBlock, pHDS->nImagesize_FileBlockHDR, NULL ) )
        {
            ChkDR(DRM_E_FILEREADERROR);
        }
      
        /* allocate new buffer if not given */
        if ( *ppBlock == NULL )
        {
            ChkDR(_HdsAllocBlockBuffer(pNS, tmpBlock.File._image.bBlockType, ppBlock));
        }
        /* verify if the given buffer is the correct type */
        else if ( GET_BYTE( &(*ppBlock)->File._image.bBlockType, 0 ) != GET_BYTE( &tmpBlock.File._image.bBlockType, 0 )
               &&  ! ( (*ppBlock)->File._image.bBlockType == eDATABLOCK 
                    && tmpBlock.File._image.bBlockType    == eFREEBLOCK 
                    || (*ppBlock)->File._image.bBlockType == eFREEBLOCK 
                    && tmpBlock.File._image.bBlockType    == eDATABLOCK ) )
        {
            ChkDR(DRM_E_HDSBLOCKMISMATCH);
        }

        /* copy block header to new buffer */
        MEMCPY((*ppBlock)->File.bFileImage, tmpBlock.File.bFileImage, pHDS->nImagesize_FileBlockHDR);
    }
    else
    {
        _CommBlockHDR tmpBlock;

        if (!OEM_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
        {
            ChkDR(DRM_E_FILEREADERROR);
        }
        
        MEMCPY(tmpBlock.File.bFileImage, (*ppBlock)->File.bFileImage, SIZEOF(tmpBlock.File.bFileImage));
        
        if(!_WriteCommonBlockHeader(pHDS, &tmpBlock, pHDS->nImagesize_FileBlockHDR, NULL ) )
        {
            ChkDR(DRM_E_FILEWRITEERROR);
        }
    }

    if ( fGenericHeaderOnly )
    {
        goto ErrorExit;
    }
    
    switch ( GET_BYTE( &(*ppBlock)->File._image.bBlockType, 0 ) )
    {
        case eCHILDBLOCK:
            {
                /* read/write _ChildBlockHDR */
                _ChildBlockHDR *pChild = (_ChildBlockHDR*)(*ppBlock);
                if ( fGet )
                {
                    if (!_ReadChildBlockHeader(pHDS, pChild, pNS->nImagesize_ChildBlockHDR))
                    {
                        ChkDR(DRM_E_FILEREADERROR);
                    }
                    pChild->nCurrSlotPos = MAXSLOTPOS;
                    pChild->nNextSlotPos = MAXSLOTPOS;
                    pChild->nPayloadSize = pNS->nImagesize_ChildBlockPayload;
                }                        
                else
                {
                    if (!_WriteChildBlockHeader(pHDS, pChild, pNS->nImagesize_ChildBlockHDR) )
                    {
                        ChkDR(DRM_E_FILEWRITEERROR);
                    }
                }
            }
            break;

        case eDATABLOCK:
        case eFREEBLOCK:
            {
                /* read the HDSData */
                _DataBlockHDR *pData = (_DataBlockHDR*)(*ppBlock);
                if ( fGet )
                {
                    if (!_ReadDataBlockHeader(pHDS, pData ) )
                    {
                        ChkDR(DRM_E_FILEREADERROR);
                    }
                    pData->nPayloadSize = pHDS->nImagesize_DataBlockPayload;
                }                        
                else
                {
                    if (!_WriteDataBlockHeader(pHDS, pData ) )
                    {
                        ChkDR(DRM_E_FILEWRITEERROR);
                    }
                }
            }
            break;

        case eINVALIDBLOCK:
        default:
            ChkDR(DRM_E_HDSFILECORRUPTED);
    }
    
    /* everything is alright */
    if ( fGet )
    {
        (*ppBlock)->nBlockNum = nBlkNum;
        (*ppBlock)->pNS = pNS;
    }

ErrorExit:

#if _DATASTORE_WRITE_THRU
    if ( DRM_SUCCEEDED(dr) && !fGet )
    {
        if ( !OEM_FlushFileBuffers(pHDS->fp) )
        {
            dr = DRM_E_FILEWRITEERROR;
        }
    }
#endif

#if DRM_PROFILE_HDSGETPUT
    DRM_PROFILING_LEAVE_SCOPE(L"_HdsGetPutBlockHDR", g_pwszLeavingFunction);
#endif
    return dr;
}


/**********************************************************************
** Function:    _GenBlockHash
** Synopsis:    Generate hash of the given block
** Arguments:   [pLSContext] -- 
**              [pBlock] --
**              [blockHash] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT 
_HdsGenBlockHash( 
    IN _HdsContext   *pHDS,
    IN _NsContext    *pNS,
    IN _CommBlockHDR *pBlock,
    OUT DRM_BYTE      Hash [__CB_DECL(MD5DIGESTLEN)])
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE rgbBlockType[__CB_DECL(SIZEOF(DRM_DWORD))] = {0};

    if ( GET_BYTE(&pBlock->File._image.bBlockType, 0 ) == eCHILDBLOCK )
    {
        ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
        DRMASSERT(pNS && pNS->fInited);
    }

    DRMASSERT(pBlock!=NULL);
    DRM_MD5_Init(&pHDS->contextMD5 );

    /* _CommBlockHDR header */
    FIX_ENDIAN_DWORD( pBlock->File._image.nParentBlockNum );    
    FIX_ENDIAN_QWORD( pBlock->File._image.ui64TimeStamp );
    PUT_BYTE( rgbBlockType, 0, GET_BYTE( &pBlock->File._image.bBlockType, 0 ) );
    DRM_MD5_Update( &pHDS->contextMD5, (DRM_VOID*)&pBlock->File._image.nParentBlockNum, SIZEOF(DRM_DWORD));
    DRM_MD5_Update( &pHDS->contextMD5, (DRM_VOID*)&pBlock->File._image.ui64TimeStamp,   SIZEOF(DRM_UINT64));
    DRM_MD5_Update( &pHDS->contextMD5, (DRM_VOID*)rgbBlockType,                         SIZEOF(DRM_DWORD));
    FIX_ENDIAN_DWORD( pBlock->File._image.nParentBlockNum );
    FIX_ENDIAN_QWORD( pBlock->File._image.ui64TimeStamp );

    switch (GET_BYTE(&pBlock->File._image.bBlockType, 0 ))
    {
        case eCHILDBLOCK:
            {
                /* _ChildBlockHDR header */
                _ChildBlockHDR *pChild = (_ChildBlockHDR*)pBlock;
                FIX_ENDIAN_DWORD( pChild->File._image.nFreeMem );
                DRM_MD5_Update(&pHDS->contextMD5, (DRM_VOID*)&pChild->File._image.nFreeMem, SIZEOF(DRM_DWORD));
                DRM_MD5_Update(&pHDS->contextMD5, (DRM_VOID*)pChild->File._image.bChildAllocTable, pNS->nImagesize_ChildAllocTable);
                FIX_ENDIAN_DWORD( pChild->File._image.nFreeMem );
            }
            break;
        case eDATABLOCK:
        case eFREEBLOCK:
            {
                /* _DataBlockHDR header */
                _DataBlockHDR *pData = (_DataBlockHDR*)pBlock;
                FIX_ENDIAN_DWORD( pData->File._image.nCascadingBlockNum );
                DRM_MD5_Update(&pHDS->contextMD5, (DRM_VOID*)&pData->File._image.nCascadingBlockNum, SIZEOF(DRM_DWORD));
                FIX_ENDIAN_DWORD( pData->File._image.nCascadingBlockNum );
            }
            break;
        default:
            ChkDR(DRM_E_HDSFILECORRUPTED);
    }
    DRM_MD5_Final( &pHDS->contextMD5 );
    
    MEMCPY( Hash, pHDS->contextMD5.digest, MD5DIGESTLEN );

ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    _LoadFileBlock
** Synopsis:    Load/read a specific block from file
** Arguments:   [pHDS] -- pointer to LicenseStore Context structure
**              [nBlkNum] --block number 
**              [ppBlock] --buffer to receive the new block
** Returns:     DRM_SUCCESS on success
** Notes:       Caller is responsible to call OEM_free(*ppBlock);
***********************************************************************
*/
static DRM_RESULT _HdsLoadBlockHDR(
    IN _NsContext *pNS,
    IN DRM_DWORD nBlkNum,
    OUT _CommBlockHDR **ppBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_BYTE  rgbHash [__CB_DECL(MD5DIGESTLEN)];
    DRM_BOOL fAllocBuff=TRUE;

    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    DRMASSERT(pNS && pNS->fInited && ppBlock);
    if ( *ppBlock!= NULL)
    {
        fAllocBuff = FALSE;
    }

    ChkDR(_HdsGetPutBlockHDR(pNS, nBlkNum, ppBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));
    ChkDR(_HdsGenBlockHash(pNS->pHDS, pNS, *ppBlock, rgbHash));
    if (MEMCMP((*ppBlock)->File._image.bBlockHash, rgbHash, MD5DIGESTLEN ) != 0)
    {
        ChkDR(DRM_E_HASHMISMATCH);
    }

ErrorExit:
    if ( DRM_FAILED(dr) && fAllocBuff && *ppBlock != NULL )
    {
        _Hds_free(pNS->pHDS, *ppBlock);
        *ppBlock = NULL;
    }
    return dr;
}


/**********************************************************************
** Function:    _WriteFileBlock
** Synopsis:    write the given block to file
** Arguments:   [pLSContext] -- pointer to LicenseStore Context structure
**              [pBlock] --buffer containing the file block content.
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsWriteBlockHDR(
    IN OUT _CommBlockHDR *pBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;

    DRMASSERT(pBlock!=NULL);
    pBlock->File._image.ui64TimeStamp = _GetTimeStamp();    /* update timestamp */
    ChkDR(_HdsGenBlockHash(pBlock->pNS->pHDS, pBlock->pNS, pBlock, pBlock->File._image.bBlockHash));
    ChkDR(_HdsGetPutBlockHDR(pBlock->pNS, pBlock->nBlockNum, &pBlock, GPBH_ANY_HEADER, GPBH_OPERATION_WRITE));
    
ErrorExit:    
    return dr;
}

/*
** Copy block
*/
static DRM_RESULT _HdsCopyBlockBuffer(
    OUT _CommBlockHDR *pDestBlock,
    IN _CommBlockHDR *pSrcBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    
    if (pDestBlock == pSrcBlock)
    {
       goto ErrorExit;
    }
    
    DRMASSERT( pDestBlock != NULL
            && pSrcBlock  != NULL
            && GET_BYTE( &pDestBlock->File._image.bBlockType, 0 ) == GET_BYTE( &pSrcBlock->File._image.bBlockType, 0 ) );

    MEMCPY(pDestBlock, pSrcBlock, SIZEOF(_CommBlockHDR));
    if ( GET_BYTE( &pSrcBlock->File._image.bBlockType, 0 ) == eCHILDBLOCK )
    {
        _ChildBlockHDR *pChildSrc = (_ChildBlockHDR*)pSrcBlock;
        _ChildBlockHDR *pChildDest = (_ChildBlockHDR*)pDestBlock;

        pChildDest->nCurrSlotPos = pChildSrc->nCurrSlotPos;
        pChildDest->nNextSlotPos = pChildSrc->nNextSlotPos;
        pChildDest->nPayloadSize = pChildSrc->nPayloadSize;
        MEMCPY(pChildDest->File.bFileImage, 
               pChildSrc->File.bFileImage, 
               pSrcBlock->pNS->nImagesize_ChildBlockHDR);
    }
    else if ( GET_BYTE( &pSrcBlock->File._image.bBlockType, 0 ) == eDATABLOCK )
    {
        _DataBlockHDR *pDataSrc = (_DataBlockHDR*)pSrcBlock;
        _DataBlockHDR *pDataDest = (_DataBlockHDR*)pDestBlock;

        pDataDest->nPayloadSize = pDataSrc->nPayloadSize;
        MEMCPY(pDataDest->File.bFileImage, 
               pDataSrc->File.bFileImage, 
               pSrcBlock->pNS->pHDS->nImagesize_DataBlockHDR);
    }

ErrorExit:
    return dr;
}

/*
**
*/
static DRM_RESULT _HdsGetPutChildBlockNum(
    IN     _NsContext *pNS,
    IN     DRM_BYTE   *pbChildAllocTable,
    IN     DRM_DWORD   nIndex,
    IN OUT DRM_DWORD  *pnChildBlkNum,
    IN     DRM_BOOL    fGet)
{
    DRM_RESULT dr = DRM_SUCCESS;

    DRMASSERT(pNS && pNS->fInited && pbChildAllocTable && pnChildBlkNum 
        && nIndex < pNS->wMaxNumChildren);	
	
    switch (pNS->pHDS->oSRN.eBlockNumType)
    {
        case eDRM_HDSBLKNUM_DWORD:
            if ( fGet )
            {
                *pnChildBlkNum = ((DRM_DWORD*)pbChildAllocTable)[nIndex];
                FIX_ENDIAN_DWORD( *pnChildBlkNum );
            }
            else
            {
                DRM_DWORD *rgdwTab = (DRM_DWORD*)pbChildAllocTable;
                DRM_DWORD dwIndex  = *pnChildBlkNum;
                FIX_ENDIAN_DWORD( dwIndex );
                rgdwTab[nIndex] = dwIndex;
            }
            break;
        case eDRM_HDSBLKNUM_WORD:
            if ( fGet )
            {
                DRM_WORD wNum=((DRM_WORD*)pbChildAllocTable)[nIndex];
                FIX_ENDIAN_WORD( wNum );
                *pnChildBlkNum = (DRM_DWORD)wNum;
            }
            else
            {
                DRM_WORD *rgwTab = (DRM_WORD*)pbChildAllocTable;
                DRM_WORD wNum    = (DRM_WORD)*pnChildBlkNum;
                
                DRMASSERT( ((*pnChildBlkNum) & 0xFFFF0000) == 0 );
                
                FIX_ENDIAN_WORD( wNum );
                rgwTab[nIndex] = wNum;
            }
            break;
        default:
            dr = DRM_E_HDSBLOCKMISMATCH;
            break;
    }
    
    return dr;
}

/**********************************************************************
** Function:    HashKeyToIndex
** Synopsis:    
** Arguments:   [pbDRMData] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
_HdsHashKeyToIndex(
    IN _NsContext *pNS,
    IN const DRM_BYTE HashKey [__CB_DECL(DRM_HDS_HASHKEY_SIZE)], 
    IN DRM_DWORD nBlkNum,
    OUT DRM_DWORD *pnIndex)
{
    DRM_DWORD nFilePos;

    DRMASSERT(pNS && pNS->fInited && pnIndex);
    _HdsBlockNum2FilePos(pNS->pHDS, nBlkNum, &nFilePos);

    DRM_MD5_Init( &pNS->pHDS->contextMD5 );
    DRM_MD5_Update( &pNS->pHDS->contextMD5, HashKey, DRM_HDS_HASHKEY_SIZE);
    FIX_ENDIAN_DWORD( nFilePos );
    DRM_MD5_Update( &pNS->pHDS->contextMD5, (DRM_VOID*)&nFilePos, SIZEOF(DRM_DWORD) );
    DRM_MD5_Final( &pNS->pHDS->contextMD5 );

    /* mod the first 4 bytes of the hash value with number of children per parent block */    
    BYTES_TO_DWORD( *pnIndex, pNS->pHDS->contextMD5.digest );
    *pnIndex %= (DRM_DWORD)pNS->wMaxNumChildren;

/*  TRACE(("HashKeyToIndex %d, blocknum %d\n", *pnIndex, nBlkNum)); */

    return DRM_SUCCESS;
}


/**********************************************************************
** Function:    GoDownOneLevel
** Synopsis:    Traverse to a child block according to the given CID and SKUID.
** Arguments:   [pHDS] -- 
**              [pCurrBlock] -- NULL indicates no parent "child" node. the RootNode will 
**                 used as the parent.
**              [rgbCID]
**              [rgbSKUID]
**              [pBlock] -- retrieved child block
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
_HdsHashToChildBlock(
    IN  _NsContext     *pNS,
    IN  _CommBlockHDR  *pParentBlock,  /* NULL if start from NSRoot of current Namespace */
    IN  const DRM_BYTE  bHashKey [__CB_DECL(DRM_HDS_HASHKEY_SIZE)], 
    OUT _CommBlockHDR **ppChildBlock, 
    OUT DRM_BOOL       *pfResult,
    OUT DRM_DWORD      *pdwChildIndex)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  nBlockNum=0;
    DRM_DWORD  nIndex=0;

    DRMASSERT(pNS && bHashKey && pNS->fInited && ppChildBlock && pfResult);
    *pfResult=FALSE;

    if ( pParentBlock == NULL )   /* start from Root of current Namespace */
    {
        nBlockNum = pNS->nCfgRootBlockNum;
    }
    else
    {
        /* compute the child's hash index */
        ChkDR(_HdsHashKeyToIndex(pNS, bHashKey, pParentBlock->nBlockNum, &nIndex));
        ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pParentBlock)->File._image.bChildAllocTable,
            nIndex, &nBlockNum, TRUE));
        if ( nBlockNum == 0 )
        {
            goto ErrorExit;  /* not found */
        }
    }

    ChkDR(_HdsLoadBlockHDR(pNS, nBlockNum, ppChildBlock));
    if ( GET_BYTE( &(*ppChildBlock)->File._image.bBlockType, 0) == eCHILDBLOCK )
    {
        *pfResult = TRUE;
        if ( pdwChildIndex )
        {
            *pdwChildIndex = nIndex;
        }
    }
    else
    {
        dr = DRM_E_HDSFILECORRUPTED;
    }
    
ErrorExit:
    
    return dr;
}

/*
**
*/
static DRM_RESULT
_HdsExpandStore(
    IN  _HdsContext *pHDS,
    IN  DRM_DWORD    nGrowNumofBlocks,
    OUT DRM_DWORD   *pnNextBlockNum)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD  dwFilePos=0, dwTmpPos=0, nBlockNum=0;
    DRM_DWORD  dwNumberOfBytesIO=0;

    ChkArg(pnNextBlockNum != NULL);

    if (!OEM_GetFileSize(pHDS->fp, &dwFilePos))
    {
        ChkDR(DRM_E_FILESEEKERROR);
    }
        
    ChkDR(_HdsFilePos2BlockNum(pHDS, dwFilePos, &nBlockNum));

    /* verify block num */
    ChkDR(_HdsBlockNum2FilePos(pHDS, nBlockNum, &dwTmpPos));
    if ( dwTmpPos != dwFilePos )
    {
        /* max block number reached */
        TRACE( ("_HdsExpandStore(): Data store is full.\n" ));
        ChkDR(DRM_E_HDSSTOREFULL);
    }

    /* expand the file:
    ** - seek to block-size -SIZEOF(BLOCK_SIGNATURE) bytes after current EOF,
    ** - write the BLOCK_SIGNATURE at the position,
    ** - flush the file
    */ 
    if (!OEM_SetFilePointer(
                pHDS->fp, 
                (nGrowNumofBlocks * pHDS->oSRN.dwBlockSize) - SIZEOF(BLOCK_SIGNATURE), 
                OEM_FILE_END, 
                NULL))
    {
        ChkDR(DRM_E_HDSSTOREFULL);
    }
    if (!OEM_WriteFile(pHDS->fp, (DRM_VOID*)BLOCK_SIGNATURE, SIZEOF(BLOCK_SIGNATURE), 
        &dwNumberOfBytesIO) || dwNumberOfBytesIO!=SIZEOF(BLOCK_SIGNATURE))
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }
    
    *pnNextBlockNum = nBlockNum;

ErrorExit:
    return dr;
}

#define GPBP_OPERATION_READ  TRUE
#define GPBP_OPERATION_WRITE FALSE

/*
** Get the specified size of payload at the specified pos of the block's child payload
*/
static DRM_RESULT _HdsGetPutBlockPayload(
    IN _CommBlockHDR *pBlock,
    IN DRM_DWORD nPos,   /* position relative to given block's payload, starts from 0 */
    IN DRM_DWORD nSize,
    IN OUT DRM_VOID *pBuff,
    IN DRM_BOOL fGet)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD dwFilePos=0;
    DRM_DWORD ioCount=0;    

#if DRM_PROFILE_HDSGETPUT
    DRM_PROFILING_ENTER_SCOPE(L"_HdsGetPutBlockPayload", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
#endif

    DRMASSERT( pBlock && pBuff );
    if( nSize == 0 )
    {
        /* No data read or written */
        goto ErrorExit;
    }

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pBlock->pNS->pHDS, pBlock->nBlockNum, &dwFilePos));

    /* adjust filepos relative to the block */
    switch (GET_BYTE( &pBlock->File._image.bBlockType, 0 ))
    {
        case eCHILDBLOCK:
            {
                _ChildBlockHDR *pChild=(_ChildBlockHDR*)pBlock;
                DRMASSERT( (nPos+nSize)<=pChild->nPayloadSize );
                dwFilePos += pBlock->pNS->nChildBlockPayloadPos + nPos;
            }
            break;
        case eDATABLOCK:
            {
                _DataBlockHDR *pData=(_DataBlockHDR*)pBlock;
                DRMASSERT( (nPos+nSize)<=pData->nPayloadSize );
                dwFilePos += pBlock->pNS->pHDS->nDataBlockPayloadPos + nPos;
            }
            break;
        case eFREEBLOCK:
            break;
        default:
            DRMASSERT(FALSE);                
    }

    /* seek to the appropriate file position */
    if (OEM_SetFilePointer(pBlock->pNS->pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
    {
        DRM_BOOL fIO;
        
        if ( fGet )
        {
            /* Note: we do not verify file position here because we already
            **       verified the block header position is at least 
            **       filesize - block size.
            */
            fIO = OEM_ReadFile(pBlock->pNS->pHDS->fp, pBuff, nSize, &ioCount);
        }
        else
        {
            fIO = OEM_WriteFile(pBlock->pNS->pHDS->fp, pBuff, nSize, &ioCount);
        }

        if (fIO)
        {

#if _DATASTORE_WRITE_THRU
            if ( !fGet )
            {
                ChkBOOL( OEM_FlushFileBuffers(pBlock->pNS->pHDS->fp), DRM_E_FILEWRITEERROR );
            }
#endif
            goto ErrorExit;
        }
    }

    if ( fGet )
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    else
    {
        ChkDR(DRM_E_FILEWRITEERROR);
    }

ErrorExit:
#if DRM_PROFILE_HDSGETPUT
    DRM_PROFILING_LEAVE_SCOPE(L"_HdsGetPutBlockPayload", g_pwszLeavingFunction);
#endif
    return dr;
}


/**********************************************************************
** Function:    _HdsUpdateSRN
** Synopsis:    
** Arguments:   [pbHdsContext] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsUpdateSRN( 
    IN _HdsContext *pHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_BYTE   bSRNHash [__CB_DECL(MD5DIGESTLEN)];
    DRM_DWORD  dwFileSize=0;
    DRM_DWORD  dwNumberOfBytesIO=0;

    /* update hash of the root node */
    ChkArg(ISVALIDCONTEXT(pHDS, eHdsContextSignature));
    DRMASSERT( pHDS != NULL
            && pHDS->fInited 
            && pHDS->fp != OEM_INVALID_HANDLE_VALUE );

    /* read the SRN Hash in file and make sure it is the same as we have now
    ** if not, someone has been updated the SRN and we should not update ours to the file.
    */
    if (OEM_GetFileSize(pHDS->fp, &dwFileSize))
    {
        if ( dwFileSize < HDS_FILEHEADERSIZE )
        {
            /* expand the file to accomodate file header */
            if (!OEM_SetFilePointer(pHDS->fp, HDS_FILEHEADERSIZE-SIZEOF(BLOCK_SIGNATURE), OEM_FILE_BEGIN, NULL))
            {
                ChkDR(DRM_E_FILESEEKERROR);
            }
            if (!OEM_WriteFile(pHDS->fp, (DRM_VOID*)BLOCK_SIGNATURE, SIZEOF(BLOCK_SIGNATURE), &dwNumberOfBytesIO) 
                || dwNumberOfBytesIO!=SIZEOF(BLOCK_SIGNATURE))
            {
                ChkDR(DRM_E_FILEWRITEERROR);
            }
           
            goto CommitStore;  /* this is a new file */
        }

        if (OEM_SetFilePointer(pHDS->fp, SIZEOF(DRM_DWORD), OEM_FILE_BEGIN, NULL))
        {
            /* verify hash value of SRN */
            if (OEM_ReadFile(pHDS->fp, bSRNHash, MD5DIGESTLEN, &dwNumberOfBytesIO) &&
                dwNumberOfBytesIO == MD5DIGESTLEN)
            {
                if (MEMCMP(bSRNHash, pHDS->oSRN.bSRNHash, MD5DIGESTLEN) == 0 )
                {
                    goto CommitStore;
                }
                else
                {
                    TRACE(("DRM_HDS_UpdateSRN(): Super root node's hash value mismatched\n"));
                    ChkDR(DRM_E_HDSSRNCORRUPTED);
                }
            }
        }
    }
    ChkDR(DRM_E_FILESEEKERROR);

CommitStore:
    
    /* update the SRN in the file */
    pHDS->oSRN.ui64Timestamp = _GetTimeStamp();
    ChkDR(_HdsGenSRNHash(pHDS, pHDS->oSRN.bSRNHash));

    /* Seek to the begining of the file and write out updated SRN data. */
    if (OEM_SetFilePointer(pHDS->fp, 0, OEM_FILE_BEGIN, NULL))
    {
        DRM_DWORD dwStoreVersion = DRM_HDS_FILE_CURR_VERSION;
        FIX_ENDIAN_DWORD( dwStoreVersion );
        if (OEM_WriteFile(pHDS->fp, (DRM_VOID*)&dwStoreVersion, SIZEOF(DRM_DWORD), 
            &dwNumberOfBytesIO) && dwNumberOfBytesIO == SIZEOF(DRM_DWORD))
        {
            if (_WriteSRN(pHDS))
            {
#if _DATASTORE_WRITE_THRU
                ChkBOOL( OEM_FlushFileBuffers(pHDS->fp), DRM_E_FILEWRITEERROR );
#endif
                goto ErrorExit;
            }
        }        
    }
    ChkDR(DRM_E_FILEWRITEERROR);

ErrorExit:
    return dr;
}


/*
**
*/
static DRM_RESULT _HdsLoadSRN(
    IN _HdsContext *pHDS)
{
    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwStoreVersion = 0;
    DRM_DWORD  nFileSize=0;
    DRM_BYTE   rgbHash [__CB_DECL(MD5DIGESTLEN)];
    DRM_DWORD  dwNumberOfBytesIO;
    DRMASSERT(pHDS!=NULL);

    /* read store version # */
    if (!OEM_SetFilePointer(pHDS->fp, 0, OEM_FILE_BEGIN, NULL) ||
        !OEM_ReadFile(pHDS->fp, &dwStoreVersion, SIZEOF(DRM_DWORD), &dwNumberOfBytesIO) ||
        dwNumberOfBytesIO!=SIZEOF(DRM_DWORD))
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    FIX_ENDIAN_DWORD( dwStoreVersion );

    /* verify the version # and set file header size appropriately */
    switch (dwStoreVersion)
    {
        case DRM_HDS_FILE_CURR_VERSION:
            break;
            
        default:
            TRACE( ("HDS file version incorrect. Can't handle this file.\n" ));
            ChkDR(DRM_E_HDSINVALIDSTORE);
    }

    /* Read the SRN */
    ZEROMEM(&pHDS->oSRN, SIZEOF(_SRN));
    if (!OEM_SetFilePointer(pHDS->fp, SIZEOF(DRM_DWORD), OEM_FILE_BEGIN, NULL) || /* skip size of version DWORD */
        !_ReadSRN(pHDS) ) /* read the SRN data from file */
    {
        ChkDR(DRM_E_FILEREADERROR);
    }

    /* check SRN and block size */
    if( pHDS->oSRN.dwSRNSize   != SIZEOF(_SRN) 
     || pHDS->oSRN.dwBlockSize == 0 )
    {
        /* Incorrect Super root node size */
        ChkDR(DRM_E_HDSINVALIDSTORE);
    }            

    if (!OEM_GetFileSize(pHDS->fp, &nFileSize))
    {
        ChkDR(DRM_E_FILESEEKERROR);
    }

    if ( nFileSize < HDS_FILEHEADERSIZE 
        || ((nFileSize - HDS_FILEHEADERSIZE) % pHDS->oSRN.dwBlockSize) != 0 )
    {
        ChkDR(DRM_E_HDSFILECORRUPTED);
    }

    if ( pHDS->oSRN.eBlockNumType != eDRM_HDSBLKNUM_DWORD 
      && pHDS->oSRN.eBlockNumType != eDRM_HDSBLKNUM_WORD )
    {
        ChkDR(DRM_E_HDSFILECORRUPTED);
    }

    /* verify the hash value */
    ChkDR(_HdsGenSRNHash(pHDS, rgbHash));
    if (MEMCMP(rgbHash, pHDS->oSRN.bSRNHash, SIZEOF( pHDS->oSRN.bSRNHash ) ) != 0)
    {
        ChkDR(DRM_E_HASHMISMATCH);      /* SRN Hash failed! */
    }

ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    _HdsAllocBlock
** Synopsis:    Allocate a File Block. 
** Arguments:   [pHDS] -- 
**              [nParentBlockNum] --parent block num of of the new block
**              [pBlock] --buffer to receive the new block
**              [eBlockType] --type of the block
** Returns:     DRM_SUCCESS on success
** Notes:       A recycle free block list is kept in the root node. _AllocFileBlock will first
**              check if any free block is available.
***********************************************************************
*/
static DRM_RESULT
_HdsAllocBlock(
    IN     _NsContext     *pNS,
    IN     DRM_DWORD       nParentBlockNum,
       OUT _CommBlockHDR **ppBlock,
    IN     _EBlockType     eBlockType)
{
    DRM_RESULT    dr          = DRM_SUCCESS;
    DRM_BOOL      fAllocBuff  = FALSE;
    _HdsContext  *pHDS        = NULL;
    DRM_BYTE     *pCopyBuffer = NULL;
    DRM_DWORD     dwFilePos   = 0;
    DRM_BYTE      rgbHash [__CB_DECL(MD5DIGESTLEN)];
    _CommBlockHDR tmpBlock;

    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    DRMASSERT(pNS && pNS->fInited && ppBlock && 
        (eBlockType==eCHILDBLOCK || eBlockType==eDATABLOCK));

    pHDS = pNS->pHDS;
    if ( *ppBlock == NULL )
    {
        fAllocBuff = TRUE;
        ChkDR(_HdsAllocBlockBuffer(pNS, eBlockType, ppBlock));
    }

    /* flush SRN in context */
    ChkDR(_HdsLoadSRN(pHDS));

    /* check if there is any recycle blocks kept in RootNode */
    if ( pHDS->oSRN.nFreeListHead == 0 )     
    {
        ChkDR(_HdsPreAlloc(pHDS, pHDS->nGrowbySizeinKB, FALSE, NULL));
    }


    /* Free list in SRN must have some free block(s) now 
    */
    
    /* Seek to the begining of the free block and read the generic header. */
    ChkDR(_HdsBlockNum2FilePos(pHDS, pHDS->oSRN.nFreeListHead, &dwFilePos));
    
    if (!OEM_SetFilePointer(pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    if( !_ReadCommonBlockHeader( pHDS, &tmpBlock, pHDS->nImagesize_FileBlockHDR, NULL ) )
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    
    if ( GET_BYTE( &(tmpBlock.File._image.bBlockType), 0 ) != eFREEBLOCK )  /* verify if the given buffer is the correct type */
    {
        ChkDR(DRM_E_HDSBLOCKMISMATCH);
    }
    
    /* copy block header to new buffer */
    MEMCPY((*ppBlock)->File.bFileImage, tmpBlock.File.bFileImage, pHDS->nImagesize_FileBlockHDR);

    /* read the rest of the free block */
    if (!_ReadDataBlockHeader(pHDS, ((_DataBlockHDR*)(*ppBlock)) ) )
    {
        ChkDR(DRM_E_FILEREADERROR);
    }
    
    /* everything is alright */
    ((_DataBlockHDR*)(*ppBlock))->nPayloadSize = pHDS->nImagesize_DataBlockPayload;
    (*ppBlock)->nBlockNum = pHDS->oSRN.nFreeListHead;
    (*ppBlock)->pNS = pNS;

    /* validate the block's hash value */
    ChkDR(_HdsGenBlockHash(pNS->pHDS, pNS, *ppBlock, rgbHash));
    if (MEMCMP((*ppBlock)->File._image.bBlockHash, rgbHash, SIZEOF( rgbHash ) ) != 0)
    {
        ChkDR(DRM_E_HASHMISMATCH);
    }
    
    /* update free list and commit changes of root node to file */
    pHDS->oSRN.nFreeListHead = ((_DataBlockHDR*)(*ppBlock))->File._image.nCascadingBlockNum;
    ChkDR(_HdsUpdateSRN(pHDS));

    /* wipe the whole block with NULL char */
    {
        DRM_DWORD nIndex = 0;
        DRM_DWORD dwAmount = 0;

        if ( eBlockType == eCHILDBLOCK ) 
        {
            dwAmount = (*ppBlock)->pNS->nImagesize_ChildBlockPayload - SIZEOF(BLOCK_SIGNATURE);
        }
        else  /* eBlockType == eDATABLOCK */
        {
            dwAmount = (*ppBlock)->pNS->pHDS->nImagesize_DataBlockPayload - SIZEOF(BLOCK_SIGNATURE);
        }
        
        ChkDR(_Hds_malloc((*ppBlock)->pNS->pHDS, COPYBUFF_SIZE, (DRM_VOID**)&pCopyBuffer));
        
        for (nIndex=0; nIndex<dwAmount;)
        {
            ChkDR(_HdsGetPutBlockPayload((*ppBlock), nIndex, min(COPYBUFF_SIZE, dwAmount-nIndex),
                pCopyBuffer, GPBP_OPERATION_WRITE));
            nIndex += min(COPYBUFF_SIZE, dwAmount-nIndex);
        }

        /* write the block signature at end of block */
        ChkDR(_HdsGetPutBlockPayload((*ppBlock), dwAmount, SIZEOF(BLOCK_SIGNATURE), 
            (DRM_VOID*)BLOCK_SIGNATURE, GPBP_OPERATION_WRITE));
    }
    

    /* set up the block */
    ChkDR(_HdsInitBlockBuffer(pNS, *ppBlock, nParentBlockNum, eBlockType));

    /* update the new block */
    ChkDR(_HdsWriteBlockHDR(*ppBlock));

    /* make sure the new block is written to disk before the parent block */
    ChkBOOL( OEM_FlushFileBuffers(pHDS->fp), DRM_E_FILEWRITEERROR );

ErrorExit:    
    if ( pCopyBuffer != NULL )
    {
        _Hds_free((*ppBlock)->pNS->pHDS, pCopyBuffer);
    }
    
    if ( DRM_FAILED(dr) && fAllocBuff && *ppBlock!=NULL )
    {
        _Hds_free(pHDS, *ppBlock);
    }

    return dr;
}


/**********************************************************************
** Function:    _HdsFreeBlock
** Synopsis:    Free an allocated File Block. 
** Arguments:   [pHDS] -- 
**              [pBlock] --block to be free'd
** Returns:     DRM_SUCCESS on success
** Notes:       A recycle free block list is kept in the root node. All free'd blocks
**              are put in a linked list.
***********************************************************************
*/
static DRM_RESULT _HdsFreeBlock(
    IN OUT _CommBlockHDR *pBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _DataBlockHDR *pDataBlock=NULL;
    DRM_BYTE *pCopyBuffer=NULL;
    DRM_DWORD nIndex=0;

    DRMASSERT(pBlock && pBlock->pNS && pBlock->pNS->fInited);

    /* flush SRN in context */
    ChkDR(_HdsLoadSRN(pBlock->pNS->pHDS));

    /* wipe the block buffer */
    ZEROMEM(pBlock->File.bFileImage, pBlock->pNS->pHDS->nImagesize_FileBlockHDR);
    _HdsInitBlockBuffer(pBlock->pNS, pBlock, 0, eDATABLOCK);

    /* optional: wipe the whole block with NULL char */
    {
        DRM_DWORD dwAmount = pBlock->pNS->pHDS->nImagesize_DataBlockPayload - SIZEOF(BLOCK_SIGNATURE);
        
        ChkDR(_Hds_malloc(pBlock->pNS->pHDS, COPYBUFF_SIZE, (DRM_VOID**)&pCopyBuffer));
        ZEROMEM((DRM_BYTE *) pCopyBuffer, COPYBUFF_SIZE); 
        
        for (nIndex=0; nIndex<dwAmount;)
        {
            ChkDR(_HdsGetPutBlockPayload(pBlock, nIndex, min(COPYBUFF_SIZE, dwAmount-nIndex),
                pCopyBuffer, GPBP_OPERATION_WRITE));
            nIndex += min(COPYBUFF_SIZE, dwAmount-nIndex);
        }

        /* write the block signature at end of block */
        ChkDR(_HdsGetPutBlockPayload(pBlock, dwAmount, SIZEOF(BLOCK_SIGNATURE), 
            (DRM_VOID*)BLOCK_SIGNATURE, GPBP_OPERATION_WRITE));
    }
    
    PUT_BYTE( &pBlock->File._image.bBlockType, 0, eFREEBLOCK );

    /* chain to SRN's freelist */
    pDataBlock = (_DataBlockHDR*)pBlock;
    pDataBlock->File._image.nCascadingBlockNum = pBlock->pNS->pHDS->oSRN.nFreeListHead;
    pBlock->pNS->pHDS->oSRN.nFreeListHead = pBlock->nBlockNum;

    /* update block to file */
    ChkDR(_HdsWriteBlockHDR(pBlock));
    
    /* commit changes of root node to file */
    ChkDR(_HdsUpdateSRN(pBlock->pNS->pHDS));


ErrorExit:
    if ( pCopyBuffer )
    {
        _Hds_free(pBlock->pNS->pHDS, pCopyBuffer);
    }
    return dr;
}


/**********************************************************************
** Function:    _HdsLocateFreeBlockForSlot
** Synopsis:    Locate a block with timestamp >= given timestamp and have 
**              enough space to store the license.
** Arguments:   [pHDS] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
_HdsLocateFreeBlockForSlot(
    IN  _NsContext    *pNS,
    IN  const DRM_BYTE bHashKey [__CB_DECL(DRM_HDS_HASHKEY_SIZE)], 
    IN  DRM_DWORD      cbSlot,
    OUT _SlotContext  *pSlotCtx,
    IN  DRM_UINT64     ui64TimeStamp)
{
    DRM_RESULT     dr=DRM_SUCCESS;
    DRM_BOOL       fResult=FALSE;
    _CommBlockHDR *pParentBlock=NULL;

#ifdef _DEBUG
    DRM_DWORD nNumLevels=0;
#endif

    DRMASSERT(pNS && bHashKey && pNS->fInited && pSlotCtx && 
        pSlotCtx->eStatus!=eSlotCtxUninit && cbSlot);

    /* pSlotCtx might have something we can start with */
    if ( pSlotCtx->eStatus==eSlotCtxReady &&   /* pSlotCtx has info we can use */
        MEMCMP(bHashKey, pSlotCtx->oSlotHeader.oHashkey.rgb, DRM_HDS_HASHKEY_SIZE)==0 )   /* make sure key1 is the same */
    {
        ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pParentBlock));
        if ( pSlotCtx->nBlockWithLargestFreeSpace!=0 )
        {
            if ( pSlotCtx->dwLargestSpace >= cbSlot )
            {
                ChkDR(_HdsLoadBlockHDR(pNS, pSlotCtx->nBlockWithLargestFreeSpace, 
                    &pSlotCtx->pCurrChildBlock));
                goto ErrorExit;
            }
            else
            {
                /* let's start with this block */
                ChkDR(_HdsLoadBlockHDR(pNS, pSlotCtx->nBlockWithLargestFreeSpace, &pParentBlock));
            }
        }
        else
        {
            /* start with current child block in pSlotCtx */
            ChkDR(_HdsCopyBlockBuffer(pParentBlock, pSlotCtx->pCurrChildBlock));
        }
    }

    while (TRUE)
    {
        /* find a child block according to bHashKey and parentBlockNum */
        ChkDR(_HdsHashToChildBlock(pNS, pParentBlock, bHashKey, &pSlotCtx->pCurrChildBlock, 
            &fResult, NULL));
#ifdef _DEBUG
        ++nNumLevels;
#endif
        if ( !fResult )
        {
            /* no children block found, let's create one */
            DRM_DWORD nIndex=0;

            ChkDR(_HdsHashKeyToIndex(pNS, bHashKey, pParentBlock->nBlockNum, &nIndex));
            ChkDR(_HdsAllocBlock(pNS, pParentBlock->nBlockNum, &pSlotCtx->pCurrChildBlock, eCHILDBLOCK));
            pSlotCtx->eStatus = eSlotCtxReady;

            /* assign new block num to parent block and update the parent block to file */
            ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pParentBlock)->File._image.bChildAllocTable,
                nIndex, &(pSlotCtx->pCurrChildBlock->nBlockNum), FALSE));
            
            ChkDR(_HdsWriteBlockHDR(pParentBlock));                         /* write Block HDR */
            break;
        }

        /* found one, check if we can use it */
        else if ( ((_ChildBlockHDR*)(pSlotCtx->pCurrChildBlock))->File._image.nFreeMem >= cbSlot &&   /* check avail space */
                  DRM_UI64Les( ui64TimeStamp, pSlotCtx->pCurrChildBlock->File._image.ui64TimeStamp ) )    /* time stamp later than what we need */
        {
            pSlotCtx->eStatus = eSlotCtxReady;
            break;
        }

        /* keep digging along the path */
        if ( pParentBlock == NULL )
        {
            ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pParentBlock));
        }
        
        ChkDR(_HdsCopyBlockBuffer(pParentBlock, (pSlotCtx->pCurrChildBlock)));
    }

#ifdef _DEBUG
    /*TRACE(("[Levels traversed down=%d]\n", nNumLevels)); */
#endif
    
ErrorExit:
    if (pParentBlock)
    {
        _Hds_free(pNS->pHDS, pParentBlock);
    }
    
    return dr;
}


/**********************************************************************
** Function:    CreateOversizedSlot
** Synopsis:    store an oversized license over 1+ cascading _DATANODE's
** Arguments:   [pHDS] -- 
**              [pBlock] --
**              [pbLicense] --
**              [cbLicense] --
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
_HdsCreateOversizedSlot(
    IN _NsContext *pNS,
    IN DRM_DWORD nParentBlockNum,
    IN DRM_DWORD cbSlot,
    OUT _CommBlockHDR *pFirstDataBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nBytesLeft=0;
    _CommBlockHDR *pDataBlock=NULL;
    _CommBlockHDR *pTmpBlock=NULL;
    DRM_BOOL fCopied=FALSE;

    DRMASSERT(pNS && pNS->fInited && cbSlot>0 && pFirstDataBlock);

    /* allocate working buffer */
    ChkDR(_HdsAllocBlockBuffer(pNS, eDATABLOCK, &pDataBlock));
    ChkDR(_HdsAllocBlockBuffer(pNS, eDATABLOCK, &pTmpBlock));

    /* allocate the first _DataBlockHDR */
    ChkDR(_HdsAllocBlock(pNS, nParentBlockNum, &pDataBlock, eDATABLOCK));

    /* divide the slot content into packets and store the packets in _DataBlockHDR's */
    nBytesLeft = cbSlot;
    while (nBytesLeft > 0)
    {
        if ( nBytesLeft <= pNS->pHDS->nImagesize_DataBlockPayload )
        {
            /* we are done */
            ((_DataBlockHDR*)pDataBlock)->File._image.nCascadingBlockNum = 0; 
            ChkDR(_HdsWriteBlockHDR(pDataBlock));
            if ( !fCopied )
            {
                ChkDR(_HdsCopyBlockBuffer(pFirstDataBlock, pDataBlock));
            }
            break;
        }
        else
        {
            /* switch buffer and allocate a new block, update the block to file and keep on */
            ChkDR(_HdsAllocBlock(pNS, pDataBlock->nBlockNum, &pTmpBlock, eDATABLOCK));
            ((_DataBlockHDR*)pDataBlock)->File._image.nCascadingBlockNum = pTmpBlock->nBlockNum;
            ChkDR(_HdsWriteBlockHDR(pDataBlock));
            if ( !fCopied )
            {
                fCopied = TRUE;
                ChkDR(_HdsCopyBlockBuffer(pFirstDataBlock, pDataBlock));
            }

            nBytesLeft -= pNS->pHDS->nImagesize_DataBlockPayload;
            _HdsCopyBlockBuffer(pDataBlock, pTmpBlock);
        }
    }

    ChkBOOL( OEM_FlushFileBuffers(pNS->pHDS->fp), DRM_E_FILEWRITEERROR );

ErrorExit:
    /* free these have to be in reverse order of alloc */
    if (pTmpBlock)
    {
        _Hds_free(pNS->pHDS, pTmpBlock);
    }
    if (pDataBlock)
    {
        _Hds_free(pNS->pHDS, pDataBlock);
    }
    return dr;
}

/**********************************************************************
** Function:    OpenSlotFromHint
** Synopsis:    
** Arguments:   [pCurrBlock] -- block to search in
**              [bHashkey] --hashkey to be searched
**              [pUniquekey] --uniquekey to be searched
**              [pSlotHint] --hint to be used for finding slot
**              [pcbSlotSize] -- slot size
**              [pSlotCtx] -- slot context to be returned
** Returns:     DRM_SUCCESS on success
** Notes:       Slot content is preceded with a _SlotHeader structure in the payload
**              of _ChildBlockHDR. _SlotHeader.dwSlotSize indicates the actual size of the
**              slot.
***********************************************************************
*/
static DRM_RESULT _HdsOpenSlotFromHint(
    IN       _NsContext        *pNS,
    IN const DRM_HDS_HASHKEY   *pHashkey,
    IN const DRM_HDS_UNIQUEKEY *pUniquekey,
    IN       _SlotHint         *pSlotHint,
    IN       DRM_BOOL           fIsDataSlot,
    IN OUT   DRM_DWORD         *pcbSlotSize,
       OUT   _SlotContext      *pSlotCtx)
{
    DRM_RESULT          dr              = DRM_SUCCESS;
    DRM_BOOL            fResult         = FALSE;
    _CommBlockHDR      *pBlock          = NULL;
    DRM_DWORD           dwChildIndex    = 0;
    _SlotHeader         oHeader;
    _ESlotSearchMode    eSearchMode     = fIsDataSlot? eSearchDataSlot : eSearchNamespace;
    DRM_BOOL            fAcceptSlot     = FALSE;

    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    ChkArg(!_IsNULL(pHashkey->rgb, DRM_HDS_HASHKEY_SIZE));
    ChkArg( pSlotHint != NULL );
    DRMASSERT(pNS && pNS->fInited && pNS->pHDS && pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE
        && pSlotCtx && pHashkey && pUniquekey);
    DRMASSERT(pNS->nCfgRootBlockNum>0);

    ChkArg( !(pSlotHint->nBlockNum == 0 && pSlotHint->nSlotPosInBlock == 0) );

    pSlotCtx->nBlockWithLargestFreeSpace = 0;
    pSlotCtx->dwLargestSpace = 0;
    *pcbSlotSize = 0;

    ChkDR(_HdsLoadBlockHDR(pNS, pSlotHint->nBlockNum, &pBlock));

    ChkDR(_HdsGetPutBlockPayload(pBlock, pSlotHint->nSlotPosInBlock, 
        SIZEOF(_SlotHeader), (DRM_BYTE*)&oHeader, GPBP_OPERATION_READ));
    FIX_ENDIAN_DWORD( oHeader.dwSlotSize );
    FIX_ENDIAN_DWORD( oHeader.dwAttributes );

    if ((oHeader.dwAttributes & eSlotIsHidden) != 0)
    {
        fAcceptSlot = (eSearchMode == eSearchHiddenOnly);
    }
    else
    {
        fAcceptSlot = (eSearchMode == eSearchSlotDontCare 
                || (eSearchMode == eSearchNamespace &&  (oHeader.dwAttributes & eSlotIsNamespace))
                || (eSearchMode == eSearchDataSlot  && !(oHeader.dwAttributes & eSlotIsNamespace)));

    }

    if ( !fAcceptSlot )
    {
        ChkDR(DRM_E_HDSSLOTNOTFOUND);
    }

    /* check the keys */
    if (!((pHashkey   == NULL || MEMCMP(oHeader.oHashkey.rgb,   pHashkey->rgb,   DRM_HDS_HASHKEY_SIZE)   == 0)
    &&  (pUniquekey == NULL || MEMCMP(oHeader.oUniquekey.rgb, pUniquekey->rgb, DRM_HDS_UNIQUEKEY_SIZE) == 0)))
    {
        ChkDR(DRM_E_HDSSLOTNOTFOUND);
    }


    /* prepare for return */

    /* fill in the fields in _SlotContext */
    MEMCPY(&pSlotCtx->oFileBlock, pBlock, SIZEOF(_CommBlockHDR));
    ChkDR(_HdsCopyBlockBuffer(pSlotCtx->pCurrChildBlock, pBlock));  /* copy curr block to slot context */

    MEMCPY(&pSlotCtx->oSlotHeader, &oHeader, SIZEOF(_SlotHeader));
    pSlotCtx->dwSlotPosInBlock = pSlotHint->nSlotPosInBlock;
    pSlotCtx->dwSeekPointer = 0;

    /* check if we need to load _DataBlockHDR */
    if ( !ISOVERSIZESLOT(oHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        pSlotCtx->pCurrDataBlock = NULL;
    }
    else
    {
        /* get _DataBlockHDR block # */
        ChkDR(_HdsGetPutBlockPayload(pBlock, pSlotHint->nSlotPosInBlock+SIZEOF(_SlotHeader), 
            SIZEOF(DRM_DWORD), (DRM_BYTE*)&(pSlotCtx->dwFirstDataBlockNum), GPBP_OPERATION_READ));
        FIX_ENDIAN_DWORD( pSlotCtx->dwFirstDataBlockNum );
        /* load the first _DataBlockHDR */
        ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, pSlotCtx->dwFirstDataBlockNum, &pSlotCtx->pCurrDataBlock));
        pSlotCtx->dwNumofDataBlockVisited = 0;
    }
 
    *pcbSlotSize = oHeader.dwSlotSize;
    pSlotCtx->eStatus = eSlotCtxReady;

ErrorExit:

    if ( pBlock != NULL )
    {
        _Hds_free(pNS->pHDS, pBlock);
    }

    return dr;
}


/**********************************************************************
** Function:    SearchSlotInBlock
** Synopsis:    search a license in the block at next searchable position.
** Arguments:   [pCurrBlock] -- block to search in
**              [bHashKey] --hashkey to be searched
**              [pbUniqueKey] --uniquekey to be searched
**              [pcbSlotSize] -- slot size
**              [pSlotCtx] -- slot context to be returned
**              [pfResult] --TRUE if a matching slot is found
** Returns:     DRM_SUCCESS on success
** Notes:       Slot content is preceded with a _SlotHeader structure in the payload
**              of _ChildBlockHDR. _SlotHeader.dwSlotSize indicates the actual size of the
**              slot.
***********************************************************************
*/
static DRM_RESULT _HdsSearchSlotInBlock(
    IN  _CommBlockHDR           *pCurrBlock,
    IN  const DRM_HDS_HASHKEY   *pHashkey,  /* if Hashkey is NULL, Uniquekey MUST be NULL */
    IN  const DRM_HDS_UNIQUEKEY *pUniquekey,
    IN  _ESlotSearchMode         eSearchMode,
    OUT _SlotContext            *pSlotCtx,  /* user given Dataslot context buffer */
    OUT DRM_BOOL                *pfResult)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nBytesToSearch=0;
    DRM_DWORD nBytesToSkip=0;
    _ChildBlockHDR *pChild=(_ChildBlockHDR*)pCurrBlock;
    _SlotHeader oHeader;

    /* Note: It is safe not to issue any lock when search each slot header in
    ** the block. It is because the caller function should already lock the SRN
    ** either shared or exclusive before calling this function. Functions which
    ** writing to the slot header(s) must issued exclusive lock to the SRN. So
    ** if we reach this point, there are no thread(s) or process(es) writing to
    ** the slot header(s).
    */

    DRMASSERT( pCurrBlock && pSlotCtx && pfResult 
        && pSlotCtx->eStatus>=eSlotCtxInited && pSlotCtx->pCurrChildBlock
        && GET_BYTE( &pSlotCtx->pCurrChildBlock->File._image.bBlockType, 0 ) == eCHILDBLOCK);
    if ( pHashkey==NULL )
    {
        DRMASSERT(pUniquekey==NULL);   /* if Hashkey is NULL, Uniquekey MUST be NULL */
    }

    *pfResult = FALSE;
    ZEROMEM(&oHeader, SIZEOF(_SlotHeader));
    nBytesToSearch = pSlotCtx->pNS->nImagesize_ChildBlockPayload - pChild->File._image.nFreeMem;
    if ( nBytesToSearch == 0 )
    {
        goto ErrorExit;
    }
    
    /* walk the payload of child node to find matching HashKey and UniqueKey. Each license are stored 
    ** one by one in the payload ... 
    */
    if ( pChild->nNextSlotPos == MAXSLOTPOS )
    {
        pChild->nNextSlotPos = 0;
    }

    for (; pChild->nNextSlotPos<nBytesToSearch; pChild->nNextSlotPos+=nBytesToSkip)
    {
        DRM_BOOL fAcceptSlot = FALSE;

        /* read the _SlotHeader structure */

        ChkDR(_HdsGetPutBlockPayload((_CommBlockHDR*)pChild, pChild->nNextSlotPos, 
            SIZEOF(_SlotHeader), (DRM_BYTE*)&oHeader, GPBP_OPERATION_READ));
        FIX_ENDIAN_DWORD( oHeader.dwSlotSize );
        FIX_ENDIAN_DWORD( oHeader.dwAttributes );

        if ((oHeader.dwAttributes & eSlotIsHidden) != 0)
        {
            fAcceptSlot = (eSearchMode == eSearchHiddenOnly);
        }
        else
        {
            fAcceptSlot = (eSearchMode == eSearchSlotDontCare 
                       || (eSearchMode == eSearchNamespace &&  (oHeader.dwAttributes & eSlotIsNamespace))
                       || (eSearchMode == eSearchDataSlot  && !(oHeader.dwAttributes & eSlotIsNamespace)));

        }

        if (fAcceptSlot)
        {
            /* check the keys */
            if ((pHashkey   == NULL || MEMCMP(oHeader.oHashkey.rgb,   pHashkey->rgb,   DRM_HDS_HASHKEY_SIZE)   == 0)
            &&  (pUniquekey == NULL || MEMCMP(oHeader.oUniquekey.rgb, pUniquekey->rgb, DRM_HDS_UNIQUEKEY_SIZE) == 0))
            {
                goto PrepareSlot;  /* we get a match */
            }
        }
        
        /* skip this slot */
        if ( ISOVERSIZESLOT(oHeader.dwSlotSize, pSlotCtx->pNS) )
        {
            nBytesToSkip = SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);
        }
        else
        {
            nBytesToSkip = SIZEOF(_SlotHeader) + oHeader.dwSlotSize;
        }
    }

    /* slot not found !! */
    goto ErrorExit; 

PrepareSlot:
    /* prepare for return */

    /* fill in the fields in _SlotContext */
    MEMCPY(&pSlotCtx->oFileBlock, &pChild->oBlockHeader, SIZEOF(_CommBlockHDR));
    ChkDR(_HdsCopyBlockBuffer(pSlotCtx->pCurrChildBlock, pCurrBlock));  /* copy curr block to slot context */

    MEMCPY(&pSlotCtx->oSlotHeader, &oHeader, SIZEOF(_SlotHeader));
    pSlotCtx->dwSlotPosInBlock = pChild->nNextSlotPos;
    pSlotCtx->dwSeekPointer = 0;

    /* check if we need to load _DataBlockHDR */
    if ( !ISOVERSIZESLOT(oHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        pSlotCtx->pCurrDataBlock = NULL;
    }
    else
    {
        /* get _DataBlockHDR block # */
        ChkDR(_HdsGetPutBlockPayload((_CommBlockHDR*)pChild, pChild->nNextSlotPos+SIZEOF(_SlotHeader), 
            SIZEOF(DRM_DWORD), (DRM_BYTE*)&(pSlotCtx->dwFirstDataBlockNum), GPBP_OPERATION_READ));
        FIX_ENDIAN_DWORD( pSlotCtx->dwFirstDataBlockNum );
        /* load the first _DataBlockHDR */
        ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, pSlotCtx->dwFirstDataBlockNum, &pSlotCtx->pCurrDataBlock));
        pSlotCtx->dwNumofDataBlockVisited = 0;
    }

    /* update slot pointer in child block */       
    pChild->nCurrSlotPos = pChild->nNextSlotPos; /* set pointer to current Slot */

    /* move next pointer to next slot */
    if ( ISOVERSIZESLOT(oHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        pChild->nNextSlotPos += SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);
    }
    else
    {
        pChild->nNextSlotPos += SIZEOF(_SlotHeader) + oHeader.dwSlotSize;
    }

    pSlotCtx->eStatus = eSlotCtxReady;
    *pfResult = TRUE;
ErrorExit:
    return dr;
}

/**********************************************************************
** Function:    SearchSlotInFile
** Synopsis:    
** Arguments:   [pHDS] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
_HdsSearchSlotInFile(
    IN  _NsContext              *pNS,
    IN  const DRM_HDS_HASHKEY   *pHashkey, 
    IN  const DRM_HDS_UNIQUEKEY *pUniquekey, 
    IN  _ESlotSearchMode         eSearchMode,
    OUT DRM_DWORD                *pcbSlotSize, /* current dataslot size, can be NULL */
    OUT _SlotContext            *pSlotCtx,    /* user given Dataslot context buffer */
    OUT DRM_BOOL                *pfResult)
{
    DRM_RESULT     dr=DRM_SUCCESS;
    _CommBlockHDR *pParentBlock=NULL;
    DRM_DWORD      dwChildIndex=0;    

    DRM_PROFILING_ENTER_SCOPE(L"_HdsSearchSlotInFile", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
    DRMASSERT( pNS && pHashkey && pSlotCtx && pfResult );

    pSlotCtx->nBlockWithLargestFreeSpace = 0;
    pSlotCtx->dwLargestSpace = 0;
    while (TRUE)
    {
        /* locate a child block which might contain the slot */
        *pfResult = FALSE;
        ChkDR(_HdsHashToChildBlock(pNS, pParentBlock, pHashkey->rgb, 
            &pSlotCtx->pCurrChildBlock, pfResult, &dwChildIndex));
        pSlotCtx->eStatus = eSlotCtxInited;
        if ( !*pfResult )
        {
            break;
        }

#ifdef _CHKHDS_    
        if ( pParentBlock!=NULL )
        {
            printf("\t[Hashing]\tBlock%5d - Alloctable[%d]\n", 
                pParentBlock->nBlockNum, dwChildIndex);
        }
#endif
        /* cache the result of this search path for later use */
        if ( ((_ChildBlockHDR*)pSlotCtx->pCurrChildBlock)->File._image.nFreeMem > pSlotCtx->dwLargestSpace )
        {
            pSlotCtx->nBlockWithLargestFreeSpace = pSlotCtx->pCurrChildBlock->nBlockNum;
            pSlotCtx->dwLargestSpace = ((_ChildBlockHDR*)pSlotCtx->pCurrChildBlock)->File._image.nFreeMem;
        }

        /* search the possible slot in the block */
        ChkDR(_HdsSearchSlotInBlock(pSlotCtx->pCurrChildBlock, pHashkey, pUniquekey, 
            eSearchMode, pSlotCtx, pfResult));
        
        if ( *pfResult )
        {
            if ( pcbSlotSize )
            {
                *pcbSlotSize = pSlotCtx->oSlotHeader.dwSlotSize;
            }
#ifdef _CHKHDS_    
            printf("\t[Found in]\tBlock%5d\n", pSlotCtx->pCurrChildBlock->nBlockNum);
#endif            
            break;
        }
        
        /* keep digging along the hash path */
        if ( pParentBlock == NULL )
        {
            /* allocate buffer for the process */
            ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pParentBlock));
        }
        _HdsCopyBlockBuffer(pParentBlock, pSlotCtx->pCurrChildBlock);
    }

ErrorExit:
    if ( pParentBlock )
    {
        _Hds_free(pNS->pHDS, pParentBlock);
    }
    DRM_PROFILING_LEAVE_SCOPE(L"_HdsSearchSlotInFile", g_pwszLeavingFunction);
        
    return dr;
}

/**********************************************************************
** Function:    _HdsAllocSlotInFile
** Synopsis:    Allocate a slot of specified size in the file.
** Arguments:   [pHDS] -- 
**              [pbLicense] --
**              [cbLicense] --size must be at least the size of DRM_LICENSE_V1
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsAllocSlotInFile( 
    IN  _NsContext     *pNS,
    IN  const DRM_BYTE  bHashKey   [__CB_DECL(DRM_HDS_HASHKEY_SIZE)], 
    IN  const DRM_BYTE  bUniqueKey [__CB_DECL(DRM_HDS_UNIQUEKEY_SIZE)], 
    IN  DRM_BOOL        fIsDataSlot,
    OUT DRM_DWORD       cbSlot,   /* current dataslot size */
    OUT _SlotContext   *pSlotCtx)  /* user given Dataslot context buffer */
{
    DRM_RESULT      dr=DRM_SUCCESS;
    DRM_DWORD       dwPhysicalSize=0, dwSlotPos=0;
    _ChildBlockHDR *pChild=NULL;
    _SlotHeader     oHeader = { 0 };
    
    DRMASSERT(pNS && bHashKey && bUniqueKey && pNS->fInited && cbSlot && pSlotCtx);
    
    /* compute the space needed in _ChildBlockHDR */
    if ( ISOVERSIZESLOT(cbSlot, pNS) )
    {
        dwPhysicalSize = SIZEOF(_SlotHeader)+SIZEOF(DRM_DWORD);
    }
    else
    {
        dwPhysicalSize = SIZEOF(_SlotHeader)+cbSlot;
    }

    /***************************************************************************
    **** Note: exclusive access to SRN guard the concurrency of this action. ***
    **** Caller of this function is expect to lock SRN for exclusive access. ***
    ****************************************************************************
    */

    /* locate a _ChildBlock for this slot */
    ChkDR(_HdsLocateFreeBlockForSlot(pNS, bHashKey, dwPhysicalSize, pSlotCtx, DRM_UI64( 0 ) ));
    pChild = (_ChildBlockHDR*)(pSlotCtx->pCurrChildBlock);

    /* init slot content */
    dwSlotPos = pNS->nImagesize_ChildBlockPayload -pChild->File._image.nFreeMem;
    oHeader.dwSlotSize = cbSlot;
    MEMCPY(oHeader.oHashkey.rgb, bHashKey, DRM_HDS_HASHKEY_SIZE);
    MEMCPY(oHeader.oUniquekey.rgb, bUniqueKey, DRM_HDS_UNIQUEKEY_SIZE);
    if( !fIsDataSlot )
    {
        oHeader.dwAttributes |= eSlotIsNamespace;
    }

    /* store _SlotHeader of the slot */
    FIX_ENDIAN_DWORD( oHeader.dwSlotSize );
    FIX_ENDIAN_DWORD( oHeader.dwAttributes );
    dr = _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, dwSlotPos, SIZEOF(_SlotHeader), 
        (DRM_BYTE *)&oHeader, GPBP_OPERATION_WRITE);
    FIX_ENDIAN_DWORD( oHeader.dwSlotSize );
    FIX_ENDIAN_DWORD( oHeader.dwAttributes );
    ChkDR( dr );

    /* allocate _DataBlock if necessary */
    if ( !ISOVERSIZESLOT(cbSlot, pNS) )
    {
        pSlotCtx->pCurrDataBlock = NULL;
    }
    else
    {
        ChkDR(_HdsCreateOversizedSlot(pNS, pSlotCtx->pCurrChildBlock->nBlockNum, cbSlot, 
            pSlotCtx->pCurrDataBlock));
        pSlotCtx->dwNumofDataBlockVisited = 0;
        pSlotCtx->dwFirstDataBlockNum = pSlotCtx->pCurrDataBlock->nBlockNum;

        /* store the datablock# to this slot */
        FIX_ENDIAN_DWORD( pSlotCtx->pCurrDataBlock->nBlockNum );
        dr = _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, dwSlotPos+SIZEOF(_SlotHeader), 
            SIZEOF(DRM_DWORD), (DRM_BYTE *)&(pSlotCtx->pCurrDataBlock->nBlockNum), GPBP_OPERATION_WRITE);
        FIX_ENDIAN_DWORD( pSlotCtx->pCurrDataBlock->nBlockNum );
        ChkDR( dr );
    }

    /* init pSlotCtx */
    MEMCPY(&pSlotCtx->oFileBlock, &pChild->oBlockHeader, SIZEOF(_CommBlockHDR));
    MEMCPY(&pSlotCtx->oSlotHeader, &oHeader, SIZEOF(_SlotHeader));
    pSlotCtx->dwSlotPosInBlock = dwSlotPos;
    pSlotCtx->dwSeekPointer = 0;
    pSlotCtx->eLockMode = eDRM_HDS_LOCKEXCLUSIVE;

    /* set the slot content to NULL. We are overloading the function here.  */
    /* oversize slot payload is always NULL by default */
    if ( !ISOVERSIZESLOT(cbSlot, pNS) )
    {
        _HdsRemoveSlot(pSlotCtx, eRemoveSlotSetNull);
        pSlotCtx->oSlotHeader.dwAttributes = 0;     /* _HdsRemoveSlot() sets dwAttributes to hidden, we have to revert it here. */
        pSlotCtx->dwSeekPointer = 0;                /* reset seek pointer */
    }

    /* update freemem in block and write the block to file */
    pChild->File._image.nFreeMem -= dwPhysicalSize;
    ChkDR(_HdsWriteBlockHDR(pSlotCtx->pCurrChildBlock));

ErrorExit:

    return dr;
}


/*
** Note: when pNamespace is NULL, it is the CFG of the namespace stoe.
*/
static DRM_RESULT _HdsInitNsContext(
    IN  _HdsContext             *pHDS,
    OUT _NsContext              *pCfg,
    IN  const DRM_HDS_NAMESPACE *pNamespace,
    IN  DRM_DWORD                nCfgRootBlockNum,
    IN  DRM_WORD                 wMaxNumChildren)
{
    DRM_RESULT dr = DRM_SUCCESS;
    
    _ChildBlockHDR *pChild = NULL; /* declared solely for SIZEOF below */

    DRMASSERT(pHDS && pHDS->fInited && pCfg && wMaxNumChildren > 0);

    
    /* initialize the computed info for this namespace in the context */
    ZEROMEM(pCfg, SIZEOF(_NsContext));
    pCfg->wContextSize = SIZEOF(_NsContext);
    pCfg->eContextSignature = eCfgContextSignature;
    pCfg->pHDS = pHDS;
    if ( pNamespace )
    {
        DRMSIZEASSERT( SIZEOF( pCfg->oNamespace ), SIZEOF( *pNamespace ) );
        MEMCPY( &pCfg->oNamespace, pNamespace, SIZEOF( *pNamespace ) );
    }
    
    pCfg->fInited                      = TRUE;
    pCfg->nCfgRootBlockNum             = nCfgRootBlockNum;
    pCfg->wMaxNumChildren              = wMaxNumChildren;
    pCfg->nImagesize_ChildAllocTable   = wMaxNumChildren * pHDS->oSRN.eBlockNumType;
    pCfg->nImagesize_ChildBlockHDR     = SIZEOF(pChild->File._image.nFreeMem) 
                                       + 1 /*SIZEOF(pChild->File._image.bChildAllocTable)  */
                                       + pCfg->nImagesize_ChildAllocTable;
    pCfg->nChildBlockPayloadPos        = pHDS->nImagesize_FileBlockHDR + pCfg->nImagesize_ChildBlockHDR;
    pCfg->nImagesize_ChildBlockPayload = pHDS->oSRN.dwBlockSize - pCfg->nChildBlockPayloadPos;

    /* Not enough room in each block for any data */
    ChkBOOL((pHDS->oSRN.dwBlockSize > pCfg->nChildBlockPayloadPos), DRM_E_HDSINVALIDSTORE);

ErrorExit:
    
    return dr;
}

/*
**
*/
static DRM_RESULT
_HdsInitSlotContext(
    _NsContext *pNS,
    OUT DRM_BYTE *pbSlotContext,      /* user given Dataslot context buffer */
    IN DRM_DWORD cbSlotContext)    /* Dataslot context size */
{
    DRM_RESULT dr=DRM_SUCCESS;
    _SlotContext *pSlotCtx=NULL;

    DRMASSERT(pNS && pbSlotContext && cbSlotContext);
           
    ZEROMEM(pbSlotContext, cbSlotContext);
    
    pSlotCtx = (_SlotContext*)pbSlotContext;
    
    pSlotCtx->eContextSignature = eSlotContextSignature;
    pSlotCtx->pNS = pNS;
    pSlotCtx->eStatus = eSlotCtxInited;
    pSlotCtx->dwContextSize = cbSlotContext;
    pSlotCtx->pCurrChildBlock = (_CommBlockHDR *)pSlotCtx->bBuff;
    pSlotCtx->pCurrDataBlock  = (_CommBlockHDR *) (pSlotCtx->bBuff + __CB_DECL(GetMemsize_ChildBlock(pNS)));
    ChkDR(_HdsInitBlockBuffer(pNS, pSlotCtx->pCurrChildBlock, 0, eCHILDBLOCK));
    ChkDR(_HdsInitBlockBuffer(pNS, pSlotCtx->pCurrDataBlock, 0, eDATABLOCK));

ErrorExit:
    return dr;
}


/* 
** Create or open dataslot using given key1 and key2 
*/
static DRM_RESULT _HdsCreateAndOpenSlot( 
    IN     _NsContext              *pNS, 
    IN     const DRM_HDS_HASHKEY   *pHashKey, 
    IN     const DRM_HDS_UNIQUEKEY *pUniqueKey, 
    IN     DRM_BOOL                 fIsDataSlot,
    IN OUT DRM_DWORD                cbSlot,
    OUT    _SlotContext            *pSlotCtx,
    IN     DRM_DWORD                eLockMode)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_BOOL   fResult=FALSE;
    
    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    ChkArg(!_IsNULL(pHashKey->rgb, DRM_HDS_HASHKEY_SIZE));
    DRMASSERT(pNS        != NULL
           && pNS->pHDS  != NULL
           && pSlotCtx   != NULL
           && pHashKey   != NULL
           && pUniqueKey != NULL);

    DRMASSERT(pNS->fInited);
    DRMASSERT(pNS->pHDS->fp != OEM_INVALID_HANDLE_VALUE);
    DRMASSERT(pNS->nCfgRootBlockNum > 0);
    DRMASSERT(cbSlot                > 0);  /* new slot size must be > 0 */

    ChkDR(_HdsSearchSlotInFile(pNS, 
                               pHashKey, 
                               pUniqueKey, 
                              (fIsDataSlot ? eSearchDataSlot : eSearchNamespace), 
                               NULL, 
                               pSlotCtx, 
                              &fResult));
    if ( fResult )
    {
        ChkDR(DRM_E_HDSSLOTEXIST);
    }

    ChkDR(_HdsAllocSlotInFile(pNS, pHashKey->rgb, pUniqueKey->rgb, fIsDataSlot, cbSlot, pSlotCtx));
    pSlotCtx->eLockMode = eLockMode;

    /* this will not be blocked because this is a new slot and we have SRN exclusive lock */
    ChkDR(_HdsLockSlot(pSlotCtx, eLockMode));
    
ErrorExit:

    return dr;
}


/* 
** Crreate or open dataslot using given key1 and key2 
*/
static DRM_RESULT _HdsOpenExistingSlot( 
    IN       _NsContext        *pNS,
    IN const DRM_HDS_HASHKEY   *pHashKey,
    IN const DRM_HDS_UNIQUEKEY *pUniqueKey,
    IN       DRM_BOOL           fIsDataSlot,
    IN OUT   DRM_DWORD         *pcbSlotSize,
       OUT   _SlotContext      *pSlotCtx)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_BOOL   fResult=FALSE;

    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    ChkArg(!_IsNULL(pHashKey->rgb, DRM_HDS_HASHKEY_SIZE));
    DRMASSERT(pNS && pNS->fInited && pNS->pHDS && pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE
        &&  pSlotCtx && pHashKey && pUniqueKey);
    DRMASSERT(pNS->nCfgRootBlockNum>0);

    ChkDR(_HdsSearchSlotInFile(pNS, pHashKey, pUniqueKey, 
        fIsDataSlot? eSearchDataSlot : eSearchNamespace, pcbSlotSize, pSlotCtx, &fResult));
    if ( !fResult )
    {
        ChkDR(DRM_E_HDSSLOTNOTFOUND);
    }
    
ErrorExit:

    return dr;
}


/*
** Verify the given slot context to make sure the Child and Data block are consistent.
*/
static DRM_RESULT
_HdsVerifySlotContext(
    IN OUT _SlotContext *pSlotCtx,
    OUT DRM_BOOL *pfValid)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _CommBlockHDR *pBlock=NULL;
    _CommBlockHDR *pCurrBlock = NULL;
    _SlotHeader slotHeader;
    _CommBlockHDR *pTmpBlock=NULL;
    
    DRMASSERT(pSlotCtx && pSlotCtx->eStatus==eSlotCtxReady && pfValid);
    *pfValid = FALSE;

    /* load generic block header */
    pBlock = &pSlotCtx->oFileBlock;
    pCurrBlock = pSlotCtx->pCurrChildBlock;

    /* load generic block header */
    ChkDR(_HdsGetPutBlockHDR(pSlotCtx->pNS, pSlotCtx->oFileBlock.nBlockNum, &pBlock, GPBH_GENERIC_ONLY, GPBH_OPERATION_READ));

    /* verify the generic header */
    if ( DRM_UI64Eql( pSlotCtx->oFileBlock.File._image.ui64TimeStamp, pCurrBlock->File._image.ui64TimeStamp )
      && MEMCMP(pSlotCtx->oFileBlock.File._image.bBlockHash, pCurrBlock->File._image.bBlockHash, SIZEOF( pCurrBlock->File._image.bBlockHash ))==0 )
    {
       *pfValid = TRUE;
        goto ErrorExit;
    }

    /* the current block has been updated/written since last read */

    /* check if it is still a CHILD block or belong to the same parent */
    if ( GET_BYTE( &pSlotCtx->oFileBlock.File._image.bBlockType, 0 ) != GET_BYTE( &pCurrBlock->File._image.bBlockType, 0 )
      || pSlotCtx->oFileBlock.File._image.nParentBlockNum            != pCurrBlock->File._image.nParentBlockNum )
    {
        goto ReloadChildBlock;
    }

    /* load the child block in a tmp buffer */
    ChkDR(_HdsAllocBlockBuffer(pSlotCtx->pNS, eCHILDBLOCK, &pTmpBlock));
    ChkDR(_HdsGetPutBlockHDR(pSlotCtx->pNS, pSlotCtx->oFileBlock.nBlockNum, &pTmpBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));

    /* try to load the current slot header from file */
    dr = _HdsGetPutBlockPayload(pTmpBlock, pSlotCtx->dwSlotPosInBlock,
        SIZEOF(_SlotHeader), &slotHeader, GPBP_OPERATION_READ);
    FIX_ENDIAN_DWORD( slotHeader.dwSlotSize );
    FIX_ENDIAN_DWORD( slotHeader.dwAttributes );
    if ( DRM_SUCCEEDED(dr) )
    {
        if (MEMCMP(&slotHeader, &pSlotCtx->oSlotHeader, SIZEOF(_SlotHeader))==0 )
        {
            /* the current slot is intact, update the block buffer and continue */
            ChkDR(_HdsGetPutBlockHDR(pSlotCtx->pNS, pSlotCtx->oFileBlock.nBlockNum, &pCurrBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));
            *pfValid = TRUE;
            goto ErrorExit;
        }
    }

ReloadChildBlock:       
{

#if _MULTI_THREADING_SUPPORT==1
    /* BUGBUG: is this possible to happen? 
    ** The current slot is supposed be locked during DRM_HDS_OpenSlot(). The slot
    ** should not be able to be updated 
    */
    ChkDR(DRM_E_HDSSLOTNOTFOUND);

#else

    /* reload and initialize the slot context using the hashkey and uniquekey in 
       current slot context */

    /*
    _NsContext *pNS = pSlotCtx->pNS;
    _SlotHeader oSlotHeader = pSlotCtx->oSlotHeader;
    DRM_DWORD dwSeekPointer = pSlotCtx->dwSeekPointer;
    DRM_HDS_SLOT_CONTEXT *pSlotContext=NULL;
    
    ChkDR(_HdsOpenExistingSlot(pNS,&oSlotHeader.oHashkey, TRUE, &oSlotHeader.oUniquekey, NULL, pSlotCtx));

    pSlotCtx->dwSeekPointer = dwSeekPointer;
    *pfValid = TRUE;
    */
#endif
}

ErrorExit:
    if ( pTmpBlock )
    {
        _Hds_free(pSlotCtx->pNS->pHDS, pTmpBlock);
    }
    
    return dr;
}


/*
**
*/
DRM_RESULT DRM_API 
_HdsReadWriteSlot( 
    IN _SlotContext *pSlotCtx,
    IN const DRM_DWORD cbData,  /* count in bytes to read/write */
    OUT DRM_BYTE  *pbData,      /* buffer for read/write */
    OUT DRM_DWORD *pcbIO,       /* actual amount of count in bytes read/written */
    IN DRM_BOOL fGet)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD cbIO=0;
    DRMASSERT(pSlotCtx && pSlotCtx->eStatus==eSlotCtxReady && pbData); 

    if ( !ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        /* calc the position relative to the _ChildBlockHDR */
        DRM_DWORD wPos = pSlotCtx->dwSlotPosInBlock + SIZEOF(_SlotHeader) + pSlotCtx->dwSeekPointer;
        if ( (pSlotCtx->dwSeekPointer + cbData) > pSlotCtx->oSlotHeader.dwSlotSize )
        {
            cbIO = pSlotCtx->oSlotHeader.dwSlotSize - pSlotCtx->dwSeekPointer;
        }
        else
        {
            cbIO = cbData;
        }

        ChkDR(_HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, wPos, cbIO, pbData, fGet));
    }
    else    /* Slot data is contained in a chain of _DataBlockHDR's */
    {
        DRM_DWORD nRelativeSeekPtr=0;
        DRM_DWORD nBytesLeft=0;
        DRM_DWORD nNextBlockNum=0;
        DRM_BYTE *pBuff=NULL;
        
        /* calc which _DataBlockHDR we need to load that contains the position of seekpointer */
        DRM_DWORD nthBlock = pSlotCtx->dwSeekPointer / pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload;

        /* load the appropriate data block */
        if ( nthBlock > pSlotCtx->dwNumofDataBlockVisited )
        {
            while ( nthBlock > pSlotCtx->dwNumofDataBlockVisited )
            {
                nNextBlockNum = ((_DataBlockHDR*)pSlotCtx->pCurrDataBlock)->File._image.nCascadingBlockNum;
                ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nNextBlockNum, &pSlotCtx->pCurrDataBlock));
                ++pSlotCtx->dwNumofDataBlockVisited;
            }
        }
        else if ( nthBlock < pSlotCtx->dwNumofDataBlockVisited )
        {
            /* start from the first data block in the chain */
            nNextBlockNum = pSlotCtx->dwFirstDataBlockNum;            
            ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nNextBlockNum, &pSlotCtx->pCurrDataBlock));
            pSlotCtx->dwNumofDataBlockVisited = 0;

            while (pSlotCtx->dwNumofDataBlockVisited < nthBlock )
            {
                nNextBlockNum = ((_DataBlockHDR*)(pSlotCtx->pCurrDataBlock))->File._image.nCascadingBlockNum;
                ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nNextBlockNum, &pSlotCtx->pCurrDataBlock));
                ++pSlotCtx->dwNumofDataBlockVisited;
            }
        }

        /* calc # of bytes to read/write */
        if ( (pSlotCtx->dwSeekPointer + cbData) > pSlotCtx->oSlotHeader.dwSlotSize )
        {
            cbIO = pSlotCtx->oSlotHeader.dwSlotSize - pSlotCtx->dwSeekPointer;
        }
        else
        {
            cbIO = cbData;
        }

        /* calc relative pos of dwSeekPointer in this _DataBlockHDR */
        nRelativeSeekPtr = pSlotCtx->dwSeekPointer - (nthBlock * pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload);
        pBuff = pbData;
        nBytesLeft=cbIO;

        /* read/write slot content to buffer */
        ChkDR(_HdsGetPutBlockPayload(pSlotCtx->pCurrDataBlock, nRelativeSeekPtr, 
            min(nBytesLeft, pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload - nRelativeSeekPtr), pBuff, fGet));
        pBuff      += __CB_DECL(min(nBytesLeft, pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload - nRelativeSeekPtr));
        nBytesLeft -=           min(nBytesLeft, pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload - nRelativeSeekPtr);

        /* more data is contained along the _DataBlockHDR's chain */
        while (nBytesLeft > 0)
        {
            nNextBlockNum = ((_DataBlockHDR*)pSlotCtx->pCurrDataBlock)->File._image.nCascadingBlockNum;
            ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nNextBlockNum, &pSlotCtx->pCurrDataBlock));
            ++pSlotCtx->dwNumofDataBlockVisited;
            ChkDR(_HdsGetPutBlockPayload(pSlotCtx->pCurrDataBlock, 0, 
                min(nBytesLeft, pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload), pBuff, fGet));

            /* check if we are done */
            if ( nBytesLeft <= pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload )
            {
                break;
            }

            pBuff      += __CB_DECL(pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload);
            nBytesLeft -=           pSlotCtx->pNS->pHDS->nImagesize_DataBlockPayload;
        }
    }

    pSlotCtx->dwSeekPointer += cbIO;
	if ( pcbIO )
    {
		*pcbIO = cbIO;
    }

ErrorExit:
    return dr;
}

#define ADJUST_PAYLOAD_TO_END   0xFFFFFFFF

/*
** Adjust content of Child payload from SrcPos to DestPos,
** _ChildBlockHDR's nFreeMem is adjusted appropriately.
*/
static DRM_RESULT _HdsAdjustChildPayload(
    _CommBlockHDR *f_pblockheader, 
    DRM_DWORD      f_oFileDest, 
    DRM_DWORD      f_oFileSrc,
    DRM_DWORD      f_cbMove)
{
    DRM_RESULT      dr        = DRM_SUCCESS;
    DRM_DWORD       oFileCurr = 0;
    DRM_DWORD       cbMove    = 0;
    DRM_DWORD       cb        = 0;
    DRM_BYTE       *pbBuffer  = NULL;
    _ChildBlockHDR *pblockheaderChild = (_ChildBlockHDR *) f_pblockheader;

    DRMASSERT(f_pblockheader!=NULL);

    /* nothing to do */

    if (f_oFileDest == f_oFileSrc)
    {
        goto ErrorExit;
    }

    ChkDR(_Hds_malloc(f_pblockheader->pNS->pHDS, COPYBUFF_SIZE, (DRM_VOID **) &pbBuffer));

    if (f_cbMove == ADJUST_PAYLOAD_TO_END)
    {
        cbMove = pblockheaderChild->nPayloadSize 
               - pblockheaderChild->File._image.nFreeMem 
               - f_oFileSrc;
    }
    else
    {
        cbMove = f_cbMove;
    }

    if (f_oFileSrc > f_oFileDest)   /* Shrinking the payload */
    {
        /* copy it */
        for (oFileCurr  = 0; 
             oFileCurr  < cbMove;
             oFileCurr += min(cbMove - oFileCurr, COPYBUFF_SIZE))
        {
            cb = min(cbMove - oFileCurr, COPYBUFF_SIZE);

            ChkDR(_HdsGetPutBlockPayload(f_pblockheader, 
                                         oFileCurr + f_oFileSrc,  
                                         cb, 
                                         pbBuffer, 
                                         GPBP_OPERATION_READ));

            ChkDR(_HdsGetPutBlockPayload(f_pblockheader, 
                                         oFileCurr + f_oFileDest, 
                                         cb, 
                                         pbBuffer, 
                                         GPBP_OPERATION_WRITE));
        }

        /* wipe the space left behind */

        if (f_cbMove == ADJUST_PAYLOAD_TO_END)
        {
            DRM_DWORD oFileWipeEnd = pblockheaderChild->nPayloadSize
                                   - pblockheaderChild->File._image.nFreeMem;

            ZEROMEM(pbBuffer, COPYBUFF_SIZE);

            for (oFileCurr = f_oFileDest + cbMove; 
                 oFileCurr < oFileWipeEnd;
                 oFileCurr += min(oFileWipeEnd - oFileCurr, COPYBUFF_SIZE))
            {
                ChkDR(_HdsGetPutBlockPayload(f_pblockheader, oFileCurr, min(oFileWipeEnd-oFileCurr, COPYBUFF_SIZE), pbBuffer, FALSE));
            }

            /* update nFreeMem in block .. only valid if we are moving the tail*/

            pblockheaderChild->File._image.nFreeMem += f_oFileSrc - f_oFileDest;
        }
    }
    else    /* enlarging the payload (wSrcPos < wDestPos) */
    {
        cb = 0;

        ChkArg(f_cbMove != ADJUST_PAYLOAD_TO_END);

        if (cbMove > (pblockheaderChild->nPayloadSize - f_oFileDest))
        {
            TRACE(("_ChildBlockHDR does not have enough room for the move.\n"));
            DRMASSERT(FALSE);
        }

        /* copy from the end */
        for (oFileCurr  = cbMove; 
             oFileCurr  > 0;
             oFileCurr -= cb)
        {

            cb = min(oFileCurr, COPYBUFF_SIZE);

            ChkDR(_HdsGetPutBlockPayload(f_pblockheader, 
                                         oFileCurr + f_oFileSrc - cb,  
                                         cb, 
                                         pbBuffer, 
                                         GPBP_OPERATION_READ));

            ChkDR(_HdsGetPutBlockPayload(f_pblockheader,
                                         oFileCurr + f_oFileDest - cb,
                                         cb,
                                         pbBuffer,
                                         GPBP_OPERATION_WRITE));
        }

        /* wipe the enlarged area of the payload */
        cb = f_oFileDest - f_oFileSrc;

        ZEROMEM(pbBuffer, COPYBUFF_SIZE);

        for (oFileCurr = 0; 
             oFileCurr < cb;
             oFileCurr += min(cb - oFileCurr, COPYBUFF_SIZE))
        {
            ChkDR(_HdsGetPutBlockPayload(f_pblockheader, 
                                         oFileCurr + f_oFileSrc, 
                                         min(cb - oFileCurr, COPYBUFF_SIZE), 
                                         pbBuffer, 
                                         GPBP_OPERATION_WRITE));
        }

        /* update nFreeMem in block */
        if (pblockheaderChild->File._image.nFreeMem > (f_oFileDest - f_oFileSrc))
        {
            pblockheaderChild->File._image.nFreeMem -= f_oFileDest - f_oFileSrc;
        }
        else
        {
            pblockheaderChild->File._image.nFreeMem = 0;
        }
    }

ErrorExit:
    if (pbBuffer != NULL)
    {
        _Hds_free(f_pblockheader->pNS->pHDS, pbBuffer);
    }    
    return dr;
}

/**********************************************************************
** Function:    FindLeftmostLeafBlock
** Synopsis:    find the leftmost block which does any children blocks
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT
_HdsFindLeftmostLeafBlock(
    IN _CommBlockHDR *pRefBlock,
    OUT DRM_DWORD *pnLeafBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nChildBlkNum=0;
    DRM_DWORD nIndex=0;
    _CommBlockHDR *pTmpBlock=NULL;
    _CommBlockHDR *pCurrBlock=NULL;
    _NsContext *pNS=NULL;

    DRMASSERT(pRefBlock && pnLeafBlock);
    
    pNS = pRefBlock->pNS;
    *pnLeafBlock = pRefBlock->nBlockNum;  /* init to itself first */
    ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pTmpBlock));
    pCurrBlock = pRefBlock;

    /* for loop for each level of the tree */
    while (TRUE)
    {
        /* find the first occupied slot at this level */
        for (nIndex=0; nIndex < pCurrBlock->pNS->wMaxNumChildren; nIndex++)
        {
            ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pCurrBlock)->File._image.bChildAllocTable,
                nIndex, &nChildBlkNum, TRUE));
            if ( nChildBlkNum != 0 )  /* child node exists */
            {
                if ( pCurrBlock == pRefBlock )
                {
                    pCurrBlock = pTmpBlock;
                }

                /* load the child block */
                ChkDR(_HdsLoadBlockHDR(pNS, nChildBlkNum, &pCurrBlock));
                *pnLeafBlock = pCurrBlock->nBlockNum;
                break;
            }
        }

        /* no occupied slot found in this level, that means this block is a leaf block */
        if ( nIndex >= pCurrBlock->pNS->wMaxNumChildren )
        {
            break;
        }
    }
    
ErrorExit:
    if ( pTmpBlock )
    {
        _Hds_free(pNS->pHDS, pTmpBlock);
    }

    return dr;
}

/*
**
*/
static DRM_RESULT _HdsCopySlot_Child2Child(
    IN _CommBlockHDR *pDestBlock, 
    IN DRM_DWORD dwPosInDestBlock,
    IN _CommBlockHDR *pSourceBlock, 
    IN DRM_DWORD dwPosInSrcBlock, 
    IN DRM_DWORD dwSize)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _NsContext *pNS=NULL;
    DRM_DWORD nIndex;
    DRM_BYTE *pCopyBuffer=NULL;

    DRMASSERT(pDestBlock && pSourceBlock
        && GET_BYTE( &pDestBlock->File._image.bBlockType, 0 )   == (DRM_BYTE)eCHILDBLOCK
        && GET_BYTE( &pSourceBlock->File._image.bBlockType, 0 ) == (DRM_BYTE)eCHILDBLOCK);

    pNS = pSourceBlock->pNS;

    ChkDR(_Hds_malloc(pNS->pHDS, COPYBUFF_SIZE, (DRM_VOID**)&pCopyBuffer));
    for (nIndex=0; nIndex < dwSize; ) 
    {
        ChkDR(_HdsGetPutBlockPayload(pSourceBlock, nIndex+dwPosInSrcBlock,  min(COPYBUFF_SIZE, dwSize-nIndex), pCopyBuffer, GPBP_OPERATION_READ));
        ChkDR(_HdsGetPutBlockPayload(pDestBlock,   nIndex+dwPosInDestBlock, min(COPYBUFF_SIZE, dwSize-nIndex), pCopyBuffer, GPBP_OPERATION_WRITE));

        nIndex += min(COPYBUFF_SIZE, dwSize-nIndex);
    }

ErrorExit:
    if ( pCopyBuffer )
    {
        _Hds_free(pNS->pHDS, pCopyBuffer);
    }
    return dr;
}

/*
** Copy the payload of the source child block to the destination child block 
*/
static DRM_RESULT _HdsCopyChildPayload(
    OUT _CommBlockHDR *pDestBlock,
    IN _CommBlockHDR *pSourceBlock)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nBytesToSkip=0;
    DRM_DWORD nNextSlotPos=0, nBytesToSearch=0;
    _SlotHeader oHeader;
    _CommBlockHDR *pDataBlock=NULL;
    
    DRMASSERT(pDestBlock && pSourceBlock);

    /* copy payload */
    ChkDR(_HdsCopySlot_Child2Child(pDestBlock, 0, pSourceBlock, 0, 
        pDestBlock->pNS->nImagesize_ChildBlockPayload));

    /* update freemem */    
    ((_ChildBlockHDR*)pDestBlock)->File._image.nFreeMem = ((_ChildBlockHDR*)pSourceBlock)->File._image.nFreeMem;

    /* walk each slot in the pDestBlock, adopt, if any, all data blocks to pDestBlock */
    nBytesToSearch = pDestBlock->pNS->nImagesize_ChildBlockPayload - ((_ChildBlockHDR*)pDestBlock)->File._image.nFreeMem;
    if ( nBytesToSearch == 0 )
    {
        goto ErrorExit;
    }
    
    /* walk the payload of child node to find matching HashKey and UniqueKey. Each license are stored 
    ** one by one in the payload ... 
    */
    ChkDR(_HdsAllocBlockBuffer(pSourceBlock->pNS, eDATABLOCK, &pDataBlock));
    for (; nNextSlotPos<nBytesToSearch; nNextSlotPos+=nBytesToSkip)
    {
        /* read the _SlotHeader structure */
        ChkDR(_HdsGetPutBlockPayload(pDestBlock, nNextSlotPos, 
            SIZEOF(_SlotHeader), (DRM_BYTE*)&oHeader, GPBP_OPERATION_READ));
        FIX_ENDIAN_DWORD( oHeader.dwSlotSize );
        FIX_ENDIAN_DWORD( oHeader.dwAttributes );

        /* skip this license if not oversized */
        if ( !ISOVERSIZESLOT(oHeader.dwSlotSize, pDestBlock->pNS) )
        {
            nBytesToSkip = SIZEOF(_SlotHeader) + oHeader.dwSlotSize;
        }
        else
        {
            /* load the data block, update its parent block # to pDestBlock's block # */
            DRM_DWORD dwDataBlockNum=0;
            ChkDR(_HdsGetPutBlockPayload(pDestBlock, nNextSlotPos+SIZEOF(_SlotHeader), 
                SIZEOF(DRM_DWORD), (DRM_BYTE*)&dwDataBlockNum, GPBP_OPERATION_READ));
            FIX_ENDIAN_DWORD( dwDataBlockNum );
            ChkDR(_HdsLoadBlockHDR(pSourceBlock->pNS, dwDataBlockNum, &pDataBlock));

            /* update parent block # */
            pDataBlock->File._image.nParentBlockNum = pDestBlock->nBlockNum;
            ChkDR(_HdsWriteBlockHDR(pDataBlock));

            nBytesToSkip = SIZEOF(_SlotHeader)+SIZEOF(DRM_DWORD);
        }
    }

ErrorExit:
    if (pDataBlock)
    {
        _Hds_free(pSourceBlock->pNS->pHDS, pDataBlock);
    }

    return dr;
}


/**********************************************************************
** Function:    _HdsDefragmentFile
** Synopsis:    Defragment the file from the given block
** Arguments:   [pRefBlock] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       We cannot simply free a block even if it's empty. If we do so, the
**              structure of its subtree will be modified and all of the licenses stored
**              in this subtree will no longer be able to be retrieved. Instead, we 
**              traverse to the leftmost leaf block of this subtree and move its 
**              content to the given block. Then we can free that emptied leaf
**              block. This way, since the leaf block does not have any children,
**              its subtree can be freed.
***********************************************************************
*/
static DRM_RESULT
_HdsDefragmentFile(
    IN _CommBlockHDR *pRefBlock,
    OUT DRM_BOOL *pfRefBlockFreed)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nParentBlock=0;
    DRM_DWORD nLeafBlock=0;
    DRM_DWORD nIndex=0;
    _CommBlockHDR *pLeafBlock=NULL;

    DRMASSERT(pRefBlock && pRefBlock->pNS && pRefBlock->pNS->fInited);

    if ( ((_ChildBlockHDR*)pRefBlock)->File._image.nFreeMem < (pRefBlock->pNS->nImagesize_ChildBlockPayload) )
    {
        goto ErrorExit;     /* this block is not empty! */
    }

    /* find the leftmost leaf node in the 'hash path' */
    ChkDR(_HdsAllocBlockBuffer(pRefBlock->pNS, eCHILDBLOCK, &pLeafBlock));
    ChkDR(_HdsFindLeftmostLeafBlock(pRefBlock, &nLeafBlock));

    if ( pfRefBlockFreed )
    {
        *pfRefBlockFreed = FALSE;
    }

    /* ref block is a leaf */
    if ( nLeafBlock == pRefBlock->nBlockNum )  
    {
        if ( pRefBlock->File._image.nParentBlockNum == ROOTPARENTNUM )
        {
            goto ErrorExit;     /* This is the root node of namespace, leave it */
        }

        nParentBlock = pRefBlock->File._image.nParentBlockNum;
        _HdsFreeBlock(pRefBlock);
        if ( pfRefBlockFreed )
        {
            *pfRefBlockFreed = TRUE;
        }
        goto UpdateParentBlock;
    }

    ChkDR(_HdsLoadBlockHDR(pRefBlock->pNS, nLeafBlock, &pLeafBlock)); /* load the leaf block */
    ChkDR(_HdsCopyChildPayload(pRefBlock, pLeafBlock));    /* copy its content to the ref block */
    ChkDR(_HdsWriteBlockHDR(pRefBlock));  /* update ref block */

    /* get the parent block num of the leaf block and free the leaf block */
    nParentBlock = pLeafBlock->File._image.nParentBlockNum;
    _HdsFreeBlock(pLeafBlock);  /* delete the ref block in file */

UpdateParentBlock:

    /* update the leaf block's parent's alloctable so that it won't point to the leaf node */
    _HdsInitBlockBuffer(pRefBlock->pNS, pLeafBlock, 0, eCHILDBLOCK);
    ChkDR(_HdsLoadBlockHDR(pRefBlock->pNS, nParentBlock, &pLeafBlock));

    /* walk the allocTable to find the slot contains the leaf block # */
    for (nIndex=0; nIndex<pLeafBlock->pNS->wMaxNumChildren; nIndex++)
    {
        DRM_DWORD nChildBlkNum;
        ChkDR(_HdsGetPutChildBlockNum(pRefBlock->pNS, ((_ChildBlockHDR*)pLeafBlock)->File._image.bChildAllocTable,
            nIndex, &nChildBlkNum, TRUE));
        if ( nChildBlkNum == nLeafBlock )
        {
            nChildBlkNum = 0;
            ChkDR(_HdsGetPutChildBlockNum(pRefBlock->pNS, ((_ChildBlockHDR*)pLeafBlock)->File._image.bChildAllocTable,
                nIndex, &nChildBlkNum, FALSE));

            ChkDR(_HdsWriteBlockHDR(pLeafBlock));
            goto ErrorExit;
        }
    }

    ChkDR(DRM_E_HDSFILECORRUPTED);     /* something must be wrong */

ErrorExit:        
    _Hds_free(pRefBlock->pNS->pHDS, pLeafBlock);
    return dr;
}

/*
**
*/
static DRM_RESULT _HdsSlotRead( 
    IN  _SlotContext *pSlotCtx,
    IN  DRM_DWORD      cbData,
    OUT DRM_BYTE     *pbData,
    OUT DRM_DWORD    *pcbRead)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_BOOL fSlotCtxIsValid=FALSE;

    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(pSlotCtx && pSlotCtx->pNS && pSlotCtx->pNS->pHDS 
        && pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    ChkDR(_HdsVerifySlotContext(pSlotCtx, &fSlotCtxIsValid));
    if (pSlotCtx->eStatus!=eSlotCtxReady || !fSlotCtxIsValid)
    {
        ChkDR(DRM_E_HDSSLOTNOTFOUND);
    }
    ChkDR(_HdsReadWriteSlot(pSlotCtx, cbData, pbData, pcbRead, TRUE));

ErrorExit:

    return dr;
}


/*
**
*/
static DRM_RESULT _HdsSlotWrite( 
    IN _SlotContext   *pSlotCtx,
    IN DRM_DWORD        cbData,
    IN const DRM_BYTE *pbData,
    OUT DRM_DWORD      *pcbWritten)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_BOOL fSlotCtxIsValid=FALSE;

    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(pSlotCtx && pSlotCtx->pNS && pSlotCtx->pNS->pHDS 
        && pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE );
    
    ChkDR(_HdsVerifySlotContext(pSlotCtx, &fSlotCtxIsValid));
    if (pSlotCtx->eStatus!=eSlotCtxReady || !fSlotCtxIsValid)
    {
        ChkDR(DRM_E_HDSSLOTNOTFOUND);
    }

    /* slot must be locked EXCLUSIVE */
    if ( (pSlotCtx->eLockMode & eDRM_HDS_LOCKEXCLUSIVE) == 0 )
    {
        ChkDR(DRM_E_HDSNOTLOCKEDEXCLUSIVE);
    }

    /* NOTE: We cast away the const-ness here because we know _HdsReadWriteSlot 
    ** is safe when the operation is Write */
    ChkDR(_HdsReadWriteSlot(pSlotCtx, cbData, (DRM_BYTE*)pbData, pcbWritten, FALSE));

ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    _HdsRemoveSlot
** Synopsis:    Remove the slot from the block. If it is oversized, the
**              associated _DataBlocks are also removed.
** Arguments:   [pSlotCtx] -- 
**              [fPermanent] -- TRUE if to remove the slot permanently,
**                              FALSE if just to set it as 'hidden'
** Returns:     DRM_SUCCESS on success
** Notes:       It is the callers responsibility to lock the block for
**              EXCLUSIVE.
***********************************************************************
*/
static DRM_RESULT _HdsRemoveSlot( 
    _SlotContext    *pSlotCtx,
    _ERemoveSlotMode eMode)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD   wDestPos=pSlotCtx->dwSlotPosInBlock; 
    DRM_DWORD   wSrcPos=0;

    if ( eMode == eRemoveSlotPermanent )
    {
        /* remove _DataBlockHDR's, if necessary */
        if ( !ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
        {
            /* lock the associated block */
            wSrcPos = pSlotCtx->dwSlotPosInBlock + SIZEOF(_SlotHeader) + 
                pSlotCtx->oSlotHeader.dwSlotSize;
        }
        else
        {
            DRM_DWORD nDataBlockNum = pSlotCtx->dwFirstDataBlockNum;

            wSrcPos = pSlotCtx->dwSlotPosInBlock + SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);
            while (nDataBlockNum > 0)
            {
                ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nDataBlockNum, &pSlotCtx->pCurrDataBlock));
                nDataBlockNum = ((_DataBlockHDR*)(pSlotCtx->pCurrDataBlock))->File._image.nCascadingBlockNum;
                ChkDR(_HdsFreeBlock(pSlotCtx->pCurrDataBlock));
            }
        }

        /* remove slot in _ChildBlockHDR */
        ChkDR(_HdsAdjustChildPayload(pSlotCtx->pCurrChildBlock, wDestPos, wSrcPos, ADJUST_PAYLOAD_TO_END));
        ChkDR(_HdsWriteBlockHDR(pSlotCtx->pCurrChildBlock));
    }
    else if ( eMode == eRemoveSlotSetNull )
    {
        if ( !ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
        {
            /* trash content of slot to NULL */
            DRM_BYTE *pbCopyBuffer=NULL;
            DRM_DWORD  cbWrite=0, cbWritten=0;
            
            dr = _Hds_malloc(pSlotCtx->pNS->pHDS, COPYBUFF_SIZE, (DRM_VOID**)&pbCopyBuffer);
            if ( DRM_SUCCEEDED(dr) )
            {
                pSlotCtx->dwSeekPointer=0;
                while (pSlotCtx->dwSeekPointer < pSlotCtx->oSlotHeader.dwSlotSize )
                {
                    cbWrite = min(COPYBUFF_SIZE, pSlotCtx->oSlotHeader.dwSlotSize-pSlotCtx->dwSeekPointer);
                    dr = _HdsSlotWrite(pSlotCtx, cbWrite, pbCopyBuffer, &cbWritten);
                    if ( DRM_FAILED(dr) )
                    {
                        break;
                    }
                    else if ( cbWrite != cbWritten )
                    {
                        dr = DRM_E_FILEWRITEERROR;
                        break;
                    }
                }

                _Hds_free(pSlotCtx->pNS->pHDS, pbCopyBuffer);
            }
        }
        else
        {
            /* delete all _DataBlock and set Datablock number to 0 in slot */
            DRM_DWORD nDataBlockNum = pSlotCtx->dwFirstDataBlockNum;

            /*wSrcPos = pSlotCtx->dwSlotPosInBlock + SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);*/
            while (nDataBlockNum > 0)
            {
                ChkDR(_HdsLoadBlockHDR(pSlotCtx->pNS, nDataBlockNum, &pSlotCtx->pCurrDataBlock));
                nDataBlockNum = ((_DataBlockHDR*)(pSlotCtx->pCurrDataBlock))->File._image.nCascadingBlockNum;
                ChkDR(_HdsFreeBlock(pSlotCtx->pCurrDataBlock));
            }

            /* make sure the flag is hidden */
            pSlotCtx->oSlotHeader.dwAttributes |= eSlotIsHidden;
            FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
            FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
            dr = _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock,
                SIZEOF(_SlotHeader), &pSlotCtx->oSlotHeader, GPBP_OPERATION_WRITE);
            FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
            FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );

            /* update _DataBlock number in Slot */
            pSlotCtx->dwFirstDataBlockNum = 0;
            dr = _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock+SIZEOF(_SlotHeader),
                SIZEOF(DRM_DWORD), &pSlotCtx->dwFirstDataBlockNum, GPBP_OPERATION_WRITE);
        }
    }
    else if ( eMode == eRemoveSlotSetHidden )
    {
        /* set the flag to hidden */
        pSlotCtx->oSlotHeader.dwAttributes |= eSlotIsHidden;
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
        dr = _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock,
            SIZEOF(_SlotHeader), &pSlotCtx->oSlotHeader, GPBP_OPERATION_WRITE);
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
    }
    
ErrorExit:

    return dr;
}

/*
** Duplicate the given Slot Context structure. 
** Caller is responsible to _PrivateStackFree the resulting duplicate if buffer 
** is not pre-allocated.
*/
static DRM_RESULT
_HdsDupSlotContext(
    IN const _SlotContext *pSrcContext,
    OUT _SlotContext **ppDstContext)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _SlotContext *pDupCtx=NULL;

    DRMASSERT(pSrcContext && ppDstContext);
    if ( *ppDstContext==NULL )
    {
        ChkDR(_Hds_malloc(pSrcContext->pNS->pHDS, pSrcContext->dwContextSize, (DRM_VOID**)&pDupCtx));
    }
    else
    {
        pDupCtx = *ppDstContext;
        ZEROMEM(pDupCtx, pSrcContext->dwContextSize);
    }

    MEMCPY(pDupCtx, pSrcContext, pSrcContext->dwContextSize);
    pDupCtx->pCurrChildBlock = (_CommBlockHDR *)pDupCtx->bBuff;
    if ( pSrcContext->pCurrDataBlock )
    {
        pDupCtx->pCurrDataBlock = (_CommBlockHDR *)(pDupCtx->bBuff + __CB_DECL(GetMemsize_ChildBlock(pSrcContext->pNS)));
    }
    
ErrorExit:
    if ( DRM_FAILED(dr) )
    {
        _Hds_free(pSrcContext->pNS->pHDS, pDupCtx);
    }
    else
    {
        *ppDstContext = pDupCtx;
    }
    
    return dr;
}


/*
** upon success, ppNewSlotCtx contains a new slot. Caller is responsible
** for freeing the buffer. Upon success, the new slot will have the same lock
** as the source slot.
*/
static DRM_RESULT _HdsCopyAndLockNewSlot(
    IN  _SlotContext  *pSlotCtx, 
    IN  DRM_DWORD      cbNewSize,
    OUT _SlotContext **ppNewSlotCtx)
{
    DRM_RESULT    dr=DRM_SUCCESS;
    DRM_DWORD     cbSlotContext=0;
    DRM_BYTE     *pbCopyBuffer=NULL;
    _HdsContext  *pHDS=NULL;
    _NsContext   *pNS=NULL;
    _SlotContext *pNewSlotCtx=NULL;
    _SlotHeader   oTmpHeader;
    DRM_DWORD     cbRead=0, cbWritten=0;

    DRMASSERT(pSlotCtx && ppNewSlotCtx);
    pHDS = pSlotCtx->pNS->pHDS;
    pNS  = pSlotCtx->pNS;

    /* alloc copy buffer & context for new slot */
    cbSlotContext = CALC_SLOTCONTEXTLEN(pNS);
    ChkDR(_Hds_malloc(pHDS, cbSlotContext, (DRM_VOID **)&pNewSlotCtx));
    ChkDR(_HdsInitSlotContext(pNS, (DRM_BYTE*)pNewSlotCtx, cbSlotContext));
    ChkDR(_Hds_malloc(pHDS, COPYBUFF_SIZE, (DRM_VOID**)&pbCopyBuffer));

    /* Copy key from original slot and create new slot with temp keys. 
    ** if this succeed, an EXCLUSIVE lock is issued for the new slot */
    MEMCPY(&oTmpHeader, &pSlotCtx->oSlotHeader, SIZEOF(_SlotHeader));
    ChkDR(_HdsCreateAndOpenSlot(
        pNewSlotCtx->pNS, 
        &oTmpHeader.oHashkey, 
        &oTmpHeader.oUniquekey, 
        TRUE, 
        cbNewSize, 
        pNewSlotCtx,
        pSlotCtx->eLockMode));

    /* copy content from original slot to new slot 
    ** BUGBUG: This copy process can be enhanced for oversized slot:
    ** it may be more efficient to simple detach the head of DataBlock list
    ** to the new slot. 
    */
    pSlotCtx->dwSeekPointer=0;
    pNewSlotCtx->dwSeekPointer=0;
    while (pNewSlotCtx->dwSeekPointer < min(cbNewSize, pSlotCtx->oSlotHeader.dwSlotSize))
    {
        dr = _HdsSlotRead(pSlotCtx, min(cbNewSize-pSlotCtx->dwSeekPointer, COPYBUFF_SIZE), pbCopyBuffer, &cbRead);
        if ( DRM_SUCCEEDED(dr) )    
        {
            dr = _HdsSlotWrite(pNewSlotCtx, cbRead, pbCopyBuffer, &cbWritten);
            if ( DRM_SUCCEEDED(dr) )    
            {
                if ( cbRead == cbWritten)
                {
                    continue;
                }
                else if (cbRead != COPYBUFF_SIZE)
                {
                    break;
                }
                else /* (cbRead != cbWritten) */
                {
                    dr = DRM_E_FILEWRITEERROR;
                } 
            }
        }
        break;
    }

    if (DRM_FAILED(dr))
    {
        _HdsUnlockSlot(pNewSlotCtx);  /* some error occured, unlock the slot */
    }
    
ErrorExit:
    _Hds_free(pHDS, pbCopyBuffer);
    if ( DRM_FAILED(dr) )
    {
        _Hds_free(pHDS, pNewSlotCtx);
    }
    else
    {
        *ppNewSlotCtx = pNewSlotCtx;
    }
    return dr;
}


/**********************************************************************
** Function:    _HdsRelocateSlotAndKeepCurrLock
** Synopsis:    Relocate a slot
** Arguments:   [pSlotCtx] -- Slot context of interest
**              [cbSize] -- new size
** Returns:     DRM_SUCCESS on success
** Notes:       The slot must be locked exclusive before calling
***********************************************************************
*/
static DRM_RESULT _HdsRelocateSlotAndKeepCurrLock( 
    IN _SlotContext *pSlotCtx, 
    IN DRM_DWORD     cbSize)
{
    DRM_RESULT    dr=DRM_SUCCESS;
    _SlotContext *pNewSlotCtx=NULL;
    _HdsContext  *pHDS=NULL;
    _NsContext   *pNS=NULL;

    DRMASSERT(pSlotCtx != NULL
          &&  pSlotCtx->pNS != NULL
          &&  pSlotCtx->pNS->pHDS != NULL
          &&  pSlotCtx->eStatus == eSlotCtxReady 
          &&  cbSize > 0
          &&  (pSlotCtx->eLockMode & eDRM_HDS_LOCKEXCLUSIVE) != 0 );

    pHDS = pSlotCtx->pNS->pHDS;
    pNS  = pSlotCtx->pNS;

    ChkDR(_HdsRemoveSlot(pSlotCtx, eRemoveSlotSetHidden));  /* set slot as 'hidden' */
    dr = _HdsCopyAndLockNewSlot(pSlotCtx, cbSize, &pNewSlotCtx);
    if ( DRM_SUCCEEDED(dr) )
    {
        /* BUGBUG: if we failed any where here, the new slot is left in file !! */
        DRM_BOOL fResult=FALSE;

        /* set old slot to null first */
        _HdsRemoveSlot(pSlotCtx, eRemoveSlotSetNull);

        /* remove old slot permanently if we can lock the block. It's okay to 
        ** leave it as 'hidden'. we can pick it up when doing store cleanup. */
        _HdsUnlockSlot(pSlotCtx);       /* igmore return values */
        _HdsUnlockSlot(pNewSlotCtx);
        if ( DRM_SUCCEEDED(_HdsLockBlock2DeleteSlot(
                pSlotCtx, 
                eDRM_HDS_LOCKEXCLUSIVE ) ) )
        {
            _HdsRemoveSlot(pSlotCtx, eRemoveSlotPermanent);
            _HdsUnlockBlock2DeleteSlot(pSlotCtx);
        }

        /* re-initialize the new slot. This is necessary because _HdsRemoveSlot()
        ** may move the location of the new slot 
        */
        ChkDR(_HdsSearchSlotInFile(pNS, &pNewSlotCtx->oSlotHeader.oHashkey, 
            &pNewSlotCtx->oSlotHeader.oUniquekey, eSearchDataSlot, NULL, pSlotCtx, &fResult));
        DRMASSERT(fResult); /* this should not happen, something must be wrong */

        /* issue lock to the relocated slot */
        dr = _HdsLockSlot(pSlotCtx, eDRM_HDS_LOCKEXCLUSIVE | eDRM_HDS_LOCKWAIT);
    }
    else
    {
        /* try recovering ... try unhide the slot */
        pSlotCtx->oSlotHeader.dwAttributes &= ~eSlotIsHidden;

        /* we do not care if this success or not. that's all we can do ... */
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
        _HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock,
            SIZEOF(_SlotHeader), &pSlotCtx->oSlotHeader, GPBP_OPERATION_WRITE);
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
    }

ErrorExit:

    _Hds_free(pHDS, pNewSlotCtx);
    return dr;
}


/*
**
*/
static DRM_RESULT
_HdsDeleteSubTree(
    _NsContext *pNS,
    DRM_DWORD nSubtreeRootBlockNum)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nIndex=0;
    _CommBlockHDR *pCurrBlock=NULL;
    DRM_DWORD nBlkNum=0;
    DRM_DWORD nParentBlkNum=0;

    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    DRMASSERT(pNS && pNS->fInited);

    ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pCurrBlock));
    nBlkNum = nSubtreeRootBlockNum;

UPLEVEL:

    _HdsInitBlockBuffer(pNS, pCurrBlock, 0, eCHILDBLOCK);
    ChkDR(_HdsLoadBlockHDR(pNS, nBlkNum, &pCurrBlock));
    if (nParentBlkNum == 0 )    /* this should be run the first time */
    {
        nParentBlkNum = pCurrBlock->nBlockNum;
        DRMASSERT(nParentBlkNum!=0);  /* the root block of any Config sub-tree should NOT have parent block num == 0 */
    }

DOWNLEVEL:
    
    for (nIndex=0; nIndex < pCurrBlock->pNS->wMaxNumChildren; nIndex++)
    {
        ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pCurrBlock)->File._image.bChildAllocTable,
            nIndex, &nBlkNum, TRUE));
        if ( nBlkNum != 0 )  /* child node exists */
        {
            /* update child alloc table */
            DRM_DWORD n=0;
            ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pCurrBlock)->File._image.bChildAllocTable,
                nIndex, &n, FALSE));
            ChkDR(_HdsWriteBlockHDR(pCurrBlock));
            
            /* load the child block */
            ChkDR(_HdsLoadBlockHDR(pNS, nBlkNum, &pCurrBlock));
            goto DOWNLEVEL;
        }
    }

    if ( pCurrBlock->nBlockNum == nParentBlkNum )   /* terminating condition */
    {
        ChkDR(_HdsFreeBlock(pCurrBlock));
        goto ErrorExit; /* this is the root */
    }

    nBlkNum = pCurrBlock->File._image.nParentBlockNum;
    ChkDR(_HdsFreeBlock(pCurrBlock));
    goto UPLEVEL;
    
ErrorExit:
    if ( pNS )
    {
        _Hds_free(pNS->pHDS, pCurrBlock);
    }

    return dr;
}

/*
** 
*/
static DRM_RESULT
_HdsTraverseNextRightSiblingBlock(    
    IN _NsContext *pNS,
    IN _CommBlockHDR * pCurrBlock, 
    OUT DRM_DWORD *pnNextSiblingBlkNum)    /* 0 if no more child can be found */
{
    DRM_RESULT dr=DRM_SUCCESS;
    _CommBlockHDR *pParentBlock=NULL;
    DRM_DWORD nIndex=0;

    DRMASSERT(pNS && pCurrBlock && pnNextSiblingBlkNum);
    *pnNextSiblingBlkNum = 0;  

    /* get ChildAllocTable of the parent node */
    if ( pCurrBlock->File._image.nParentBlockNum == ROOTPARENTNUM )
    {
        goto ErrorExit;     /* Currblock is the root, that's it */
    }

    ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pParentBlock));
    ChkDR(_HdsLoadBlockHDR(pNS, pCurrBlock->File._image.nParentBlockNum, &pParentBlock));

    /* search index of the current child in parent's ChildAlloc table */
    for (nIndex=0; nIndex<(DRM_DWORD)pNS->wMaxNumChildren; nIndex++)
    {
        DRM_DWORD nChildNum;
        ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pParentBlock)->File._image.bChildAllocTable,
            nIndex, &nChildNum, TRUE));
        
        if ( nChildNum == pCurrBlock->nBlockNum ) /* found current child */
        {
            /* search for next child */
            ++nIndex;
            for (; nIndex<(DRM_DWORD)pNS->wMaxNumChildren; nIndex++)
            {
                ChkDR(_HdsGetPutChildBlockNum(pNS, ((_ChildBlockHDR*)pParentBlock)->File._image.bChildAllocTable,
                    nIndex, &nChildNum, TRUE));
                if ( nChildNum!= 0 )    /* found one */
                {
                    *pnNextSiblingBlkNum = nChildNum;
                    break;
                }
            }
            goto ErrorExit;
        }
    }

    /* cannot find current child from parent, this should never happen */
    ChkDR(DRM_E_HDSFILECORRUPTED);  /* internal error */

ErrorExit:        
    if (pParentBlock)
    {
        _Hds_free(pNS->pHDS, pParentBlock);
    }
    
    return dr;
}

/**********************************************************************
** Function:    _HdsTraverseBlocksInPostOrder
** Synopsis:    
** Arguments:   [pNS] -- 
**              [pCurrBlock] -- 
**              [pNextBlock] -- 
**              [pResult] 
** Returns:     DRM_SUCCESS on success
** Notes:       From the given current block, traverse the tree in POST ORDER fashion.
** Algorithm:
**    PostOrder(CFG, Current, Next)
**    {
**        if ( Current == NULL )
**            Next = CFG->Root;
**        else
**        {
**            Next = NextRightSibling(Current);
**            if ( Next == NULL )
**            {
**                Next = Current->Parent;
**                if ( Next == NULL )
**                    return FALSE;  // that's it
**                else
**                    return TRUE;
**            }
**        }
**        Next = LeftmostLeaf(Next);
**        return TRUE;
**    }
**
***********************************************************************
*/
static DRM_RESULT
_HdsTraverseBlocksInPostOrder(
    IN _NsContext *pNS,
    IN _CommBlockHDR *pCurrBlock,
    OUT _CommBlockHDR *pNextBlock,
    OUT DRM_BOOL *pResult)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD nBlockNum=0;
    
    DRMASSERT( pNS && pNextBlock && pResult);
    *pResult = FALSE;

    if ( pCurrBlock == NULL )   /* start from Root of current Namespace */
    {
        nBlockNum = pNS->nCfgRootBlockNum;
    }
    else
    {
        ChkDR(_HdsTraverseNextRightSiblingBlock(pNS, pCurrBlock, &nBlockNum));
        if ( nBlockNum == 0 )   /* no more sibling found */
        {
            /* no more sibling found, load the parent, if any, and return 
            ** if no more sibling found and the parent is root, that's it 
            */
            if ( pCurrBlock->File._image.nParentBlockNum == ROOTPARENTNUM )
            {
                *pResult = FALSE;   /* current block is the root */
            }
            else
            {   /* load parent block and return */
                ChkDR(_HdsLoadBlockHDR(pNS, pCurrBlock->File._image.nParentBlockNum, 
                    &pNextBlock));
                *pResult = TRUE;
            }

            goto ErrorExit;
        }
    }

    ChkDR(_HdsLoadBlockHDR(pNS, nBlockNum, &pNextBlock));
    ChkDR(_HdsFindLeftmostLeafBlock(pNextBlock, &nBlockNum));
    if ( nBlockNum != pNextBlock->nBlockNum )
        ChkDR(_HdsLoadBlockHDR(pNS, nBlockNum, &pNextBlock));

    *pResult = TRUE;
    
ErrorExit:
    return dr;
}

/*
** Get/Put the "attributes" field in the header of the specific slot
*/
static DRM_RESULT _HdsGetPutSlotAttributes( 
    IN _NsContext              *pNS,
    IN const DRM_HDS_HASHKEY   *pHashKey, 
    IN const DRM_HDS_UNIQUEKEY *pUniqueKey,
    IN DRM_BOOL                 fIsDataSlot,  
    IN OUT DRM_UINT            *pfAttributes,
    IN DRM_BOOL                 fGet)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _SlotContext *pSlotCtx=NULL;
    DRM_BOOL fResult=FALSE;
    DRM_DWORD cbSlotContext=0;

    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    DRMASSERT(pNS->fInited && pNS->pHDS && pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE
        && pHashKey && pUniqueKey && pfAttributes);

    DRMASSERT(pNS->nCfgRootBlockNum>0);

    /* locate and open the slot */
    cbSlotContext = CALC_SLOTCONTEXTLEN(pNS);
    ChkDR( _Hds_malloc(pNS->pHDS, cbSlotContext, (DRM_VOID **)&pSlotCtx) );
    ChkDR( _HdsInitSlotContext(pNS, (DRM_BYTE*)pSlotCtx, cbSlotContext) );
    ChkDR( _HdsSearchSlotInFile(pNS, pHashKey, pUniqueKey, 
        fIsDataSlot? eSearchDataSlot : eSearchNamespace, NULL, 
        pSlotCtx, &fResult) );
    if ( !fResult )
    {
        ChkDR(DRM_E_HDSSLOTNOTFOUND);
    }

    if ( fGet )
    {
        ChkDR(_HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock, 
            SIZEOF(_SlotHeader), &pSlotCtx->oSlotHeader, GPBP_OPERATION_READ));
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
        *pfAttributes = pSlotCtx->oSlotHeader.dwAttributes;

        /* Strip off private attributes */
        *pfAttributes &= ~(eSlotIsHidden|eSlotIsNamespace);
    }
    else
    {
        /* update the flag and flush to disk */
        DRM_DWORD dwAttributes = (pSlotCtx->oSlotHeader.dwAttributes) & (eSlotIsNamespace|eSlotIsHidden);

        /* Set to new public attributes.  Turn off private attributes */
        pSlotCtx->oSlotHeader.dwAttributes = *pfAttributes & ~(eSlotIsNamespace|eSlotIsHidden);
        
        /* OR back in private attributes */
        pSlotCtx->oSlotHeader.dwAttributes |= dwAttributes;
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
        ChkDR(_HdsGetPutBlockPayload(pSlotCtx->pCurrChildBlock, pSlotCtx->dwSlotPosInBlock, 
            SIZEOF(_SlotHeader), &pSlotCtx->oSlotHeader, GPBP_OPERATION_WRITE));
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwAttributes );
        FIX_ENDIAN_DWORD( pSlotCtx->oSlotHeader.dwSlotSize );
    }

ErrorExit:        
    if ( pSlotCtx )
    {
        _Hds_free(pNS->pHDS, pSlotCtx);
    }

    return dr;
}


/*
**
*/
static DRM_RESULT _HdsInitSlotEnum(
    IN  _NsContext            *pNS,
    IN  const DRM_HDS_HASHKEY *pHashKey,
    IN  DRM_HDS_LOCKMODE       eLockMode,
    OUT _EnumContext          *pEnum)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_BOOL   fResult=FALSE;

    /* init Enum context */
    ZEROMEM(pEnum, SIZEOF(DRM_HDS_ENUM_CONTEXT));
    pEnum->wContextSize = SIZEOF(DRM_HDS_ENUM_CONTEXT);
    pEnum->pNS = pNS;
    pEnum->fInited = TRUE;
    pEnum->eContextSignature = eEnumContextSignature;
    pEnum->fCurrBlockIsValid = FALSE;
    pEnum->eLockMode = eLockMode;

    /* locate and prepare pEnum->oCurrBlock, if possible, for EnumNext() */
    ChkDR(_HdsInitBlockBuffer(pEnum->pNS, &pEnum->oCurrBlock, 0, eCHILDBLOCK));
    if ( pHashKey != NULL )     /* Hashkey is given, do query on the Hashkey */
    {
        DRM_DWORD      cbSlotCtx; 
        _SlotContext *pSlotCtx=NULL;

        /* find the first block containing the Hashkey */
        pEnum->fIsQuery = TRUE;
        MEMCPY(pEnum->oHashKey.rgb, pHashKey->rgb, DRM_HDS_HASHKEY_SIZE);
    
        /* allocate temp slotcontext */
        cbSlotCtx = CALC_SLOTCONTEXTLEN(pNS);
        ChkDR(_Hds_malloc(pNS->pHDS, cbSlotCtx, (DRM_VOID**)&pSlotCtx));
        dr = _HdsInitSlotContext(pNS, (DRM_BYTE *)pSlotCtx, cbSlotCtx);
        if ( DRM_SUCCEEDED(dr) )
        {
            /* search the first slot matching given hashkey */
            dr = _HdsSearchSlotInFile(pNS, pHashKey, NULL, eSearchSlotDontCare, NULL, 
                pSlotCtx, &fResult);
            if ( DRM_SUCCEEDED(dr) )
            {
                if ( !fResult )
                {
                    dr = DRM_E_HDSSLOTNOTFOUND;
                }
                else
                {
                    dr = _HdsCopyBlockBuffer(&pEnum->oCurrBlock, pSlotCtx->pCurrChildBlock);
                    if ( DRM_SUCCEEDED(dr) )
                    {
                        ((_ChildBlockHDR*)(&pEnum->oCurrBlock))->nCurrSlotPos = MAXSLOTPOS;
                        ((_ChildBlockHDR*)(&pEnum->oCurrBlock))->nNextSlotPos = MAXSLOTPOS;
                    }
                }
            }
        }

        _Hds_free(pNS->pHDS, pSlotCtx);
        ChkDR(dr);
    }
    else
    {
        /* find the first block in postorder */
        pEnum->fIsQuery = FALSE;
        ChkDR(_HdsTraverseBlocksInPostOrder(pNS, NULL, &pEnum->oCurrBlock, &fResult));
        if ( !fResult )
        {
            ChkDR(DRM_E_HDSSLOTNOTFOUND);
        }
    }

    pEnum->fCurrBlockIsValid = TRUE;
    MEMCPY(&pEnum->oFileBlock, &pEnum->oCurrBlock, SIZEOF(_CommBlockHDR));

ErrorExit:        
    return dr;
}


/*
**
*/
static DRM_RESULT
_HdsCleanupNamespace(
    IN _NsContext *pNS)
{
    DRM_RESULT dr = DRM_SUCCESS;    
    DRM_BOOL fResult;
    _CommBlockHDR *pCurrBlock=NULL;
    _CommBlockHDR *pNextBlock=NULL;

    ChkArg(ISVALIDCONTEXT(pNS, eCfgContextSignature));
    DRMASSERT(pNS && pNS->fInited && pNS->pHDS && pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);
    ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pCurrBlock));
    ChkDR(_HdsAllocBlockBuffer(pNS, eCHILDBLOCK, &pNextBlock));

    /* traverse the namespace in POST ORDER and process each block */    
    ChkDR(_HdsTraverseBlocksInPostOrder(pNS, NULL,  pCurrBlock, &fResult));
    while (fResult)
    {
        DRM_BOOL fEmpty=FALSE;

#if 0
        ChkDR(_HdsCleanupBlock((_ChildBlockHDR*)pCurrBlock));   /* cleanup hidden slots */
#endif
        if ( ((_ChildBlockHDR*)pCurrBlock)->File._image.nFreeMem == pNS->nImagesize_ChildBlockPayload )
        {
            fEmpty = TRUE;
        }
        
        ChkDR(_HdsTraverseBlocksInPostOrder(pNS, pCurrBlock, pNextBlock, &fResult)); /* traverse next */
        if ( fEmpty )
        {
            /* perform defragment now.  note: pCurrBlock might get free'd */
            ChkDR(_HdsDefragmentFile(pCurrBlock, NULL));
        }
        if ( !fResult )
        {
            goto ErrorExit;  /* that's it */
        }
        /* the block becomes the current block */
        ChkDR(_HdsCopyBlockBuffer(pCurrBlock, pNextBlock));
    }

ErrorExit:
    if ( pNextBlock )
    {
        _Hds_free(pNS->pHDS, pNextBlock);
    }
    if ( pCurrBlock )
    {
        _Hds_free(pNS->pHDS, pCurrBlock);
    }
    
    return dr;
}



/*
**
*/
static DRM_RESULT _HdsCloseSlot(
    IN _SlotContext *pSlotCtx)
{
    DRM_RESULT dr=DRM_SUCCESS;
    
    ChkArg(ISVALIDCONTEXT(pSlotCtx, eSlotContextSignature));
    DRMASSERT(pSlotCtx && pSlotCtx->pNS && pSlotCtx->pNS->pHDS && 
        pSlotCtx->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

#if DBG
    /* trash the slot context and return */    
    MEMSET(pSlotCtx, 0xdb, pSlotCtx->dwContextSize);
#endif

    /* to indicate the slot is closed */
    pSlotCtx->eStatus = eSlotCtxUninit;
ErrorExit:
    return dr;
}


/**********************************************************************
** Function:    _HdsSlotEnumNext
** Synopsis:    
** Arguments:   [pEnumContext] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
**              [pSlotContext] -- Slot Context of the current slot
**              [pHashKey] -- Hashkey of the current slot
**              [pUniqueKey] -- Uniquekey of the current slot
**              [pcbSlotSize] -- size of the current slot
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsSlotEnumNext( 
    IN  _EnumContext      *pEnum,
    OUT _SlotContext      *pSlotCtx,
    OUT DRM_HDS_HASHKEY   *pHashKey, 
    OUT DRM_HDS_UNIQUEKEY *pUniqueKey,
    OUT DRM_DWORD         *pcbSlotSize)
{
    DRM_RESULT       dr = DRM_SUCCESS;    
    DRM_BOOL         fResult=FALSE;
    DRM_HDS_HASHKEY *pQueriedHashkey=NULL;
    _CommBlockHDR   *pNextBlock=NULL;
    _CommBlockHDR   *pTmpBlock=NULL;

    DRMASSERT(pEnum && pEnum->pNS);
    ChkArg(ISVALIDCONTEXT(pEnum, eEnumContextSignature));
    ChkArg(ISVALIDCONTEXT(pEnum->pNS, eCfgContextSignature));
    DRMASSERT(pEnum->pNS->fInited && pEnum->pNS->pHDS && pSlotCtx
        && pEnum->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* 
    ** Verify validity of the current block of the slot context
    ** BUGBUG: a more detail analysis is needed for this scenario 
    */
    {
        _CommBlockHDR *pBlock = &pEnum->oFileBlock;
        _CommBlockHDR *pCurrBlock = &pEnum->oCurrBlock;
        
        /* load generic block header */
        ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, &pBlock, 
            GPBH_GENERIC_ONLY, GPBH_OPERATION_READ));

        /* verify the generic header */
        if ( !DRM_UI64Eql(pEnum->oFileBlock.File._image.ui64TimeStamp, pCurrBlock->File._image.ui64TimeStamp) ||
           MEMCMP(pEnum->oFileBlock.File._image.bBlockHash, pCurrBlock->File._image.bBlockHash, SIZEOF(pCurrBlock->File._image.bBlockHash))!=0 )
        {
            /* the current block has been updated/written since last read */
            _SlotHeader slotHeader;
            DRM_DWORD   dwCurrPos = 0;

            /* check if it is still a CHILD block or belong to the same parent */
            if ( GET_BYTE( &pEnum->oFileBlock.File._image.bBlockType, 0 ) != GET_BYTE( &pCurrBlock->File._image.bBlockType, 0 ) 
              || pEnum->oFileBlock.File._image.nParentBlockNum            != pCurrBlock->File._image.nParentBlockNum )
            {
                /* there is nothing we can do when the current block is 
                ** totally invalid 
                */
                ChkDR(DRM_E_NOMORE);    
            }

            /* check if query started yet */
            if ( ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos == MAXSLOTPOS )
            {
                /* query has not been started, reload the current block from file and keep on */
                ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, 
                    &pCurrBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));
                goto Verified_Okay;
            }

            /* load the child block in a tmp buffer */
            ChkDR(_HdsAllocBlockBuffer(pEnum->pNS, eCHILDBLOCK, &pTmpBlock));
            ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, 
                &pTmpBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));

            /* load the current slot header from file */
            ChkDR(_HdsGetPutBlockPayload(pTmpBlock, ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos,
                SIZEOF(_SlotHeader), &slotHeader, GPBP_OPERATION_READ));
            FIX_ENDIAN_DWORD( slotHeader.dwAttributes );
            FIX_ENDIAN_DWORD( slotHeader.dwSlotSize );
            if (MEMCMP(&slotHeader, &pEnum->oSlotHeader, SIZEOF(_SlotHeader))==0 )
            {
                /* the current slot is intact, update the block buffer and continue */
                DRM_DWORD _dwCurrPos = ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos;
                DRM_DWORD _dwNextPos = ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos;
                
                ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, &pCurrBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));
                ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos = _dwCurrPos;
                ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos = _dwNextPos;
                goto Verified_Okay;
            }

            /* walk the new block, try seek to >=  the current slot position. */
            dwCurrPos = ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos;
            if ( pEnum->fIsQuery )
            {
                pQueriedHashkey = &pEnum->oHashKey;
            }
            
            ChkDR(_HdsInitSlotContext(pEnum->pNS, (DRM_BYTE*)pSlotCtx, CALC_MAXSLOTCONTEXTLEN));
            while (TRUE)
            {
                /* search current block at next postion */
                ChkDR(_HdsSearchSlotInBlock(pTmpBlock, pQueriedHashkey, NULL, 
                    eSearchSlotDontCare, pSlotCtx, &fResult));
                if ( !fResult )
                {
                    /* the current block has less slots than before, restart query at next block, if any */
                    goto Verified_Okay;
                }
                if ( ((_ChildBlockHDR*)pTmpBlock)->nCurrSlotPos >= dwCurrPos )
                {
                    /* walk to position >= current slot position in old block. restart query from here in new block*/
                    ((_ChildBlockHDR*)pTmpBlock)->nNextSlotPos = ((_ChildBlockHDR*)pTmpBlock)->nCurrSlotPos;
                    ChkDR(_HdsCopyBlockBuffer(&pEnum->oCurrBlock, pTmpBlock));

                    goto Verified_Okay;
                }
            }
        }
    }

Verified_Okay:

    if ( pEnum->fIsQuery )
    {
        pQueriedHashkey = &pEnum->oHashKey;
    }
    
    ChkDR(_HdsInitSlotContext(pEnum->pNS, (DRM_BYTE*)pSlotCtx, CALC_MAXSLOTCONTEXTLEN));
    ChkDR(_HdsAllocBlockBuffer(pEnum->pNS, eCHILDBLOCK, &pNextBlock));
    while (TRUE)
    {
        /* search current block at next postion */
        ChkDR(_HdsSearchSlotInBlock(&pEnum->oCurrBlock, pQueriedHashkey, NULL, 
            eSearchSlotDontCare, pSlotCtx, &fResult));
        if ( fResult )
        {
            if ( pHashKey )
            {
                MEMCPY(pHashKey->rgb, pSlotCtx->oSlotHeader.oHashkey.rgb, DRM_HDS_HASHKEY_SIZE);
            }
            if ( pUniqueKey )
            {
                MEMCPY(pUniqueKey->rgb, pSlotCtx->oSlotHeader.oUniquekey.rgb, DRM_HDS_UNIQUEKEY_SIZE);
            }
            if ( pcbSlotSize )
            {
               *pcbSlotSize = pSlotCtx->oSlotHeader.dwSlotSize;
            }
    
            pSlotCtx->eStatus = eSlotCtxReady;
            break;
        }

        /* keep digging */
        if ( pEnum->fIsQuery )
        {
            ChkDR(_HdsHashToChildBlock(pEnum->pNS, &pEnum->oCurrBlock, pEnum->oHashKey.rgb, 
                &pNextBlock, &fResult, NULL));
        }
        else
        {
            ChkDR(_HdsTraverseBlocksInPostOrder(pEnum->pNS, &pEnum->oCurrBlock, 
                pNextBlock, &fResult));
        }
        
        if ( !fResult )
        {
            /* no more block found */
            dr = DRM_E_NOMORE;
            goto ErrorExit;
        }
        
        /* the block becomes the current block */
        ChkDR(_HdsCopyBlockBuffer(&pEnum->oCurrBlock, pNextBlock));
    }

    MEMCPY(&pEnum->oFileBlock, &pEnum->oCurrBlock, SIZEOF(_CommBlockHDR));
    MEMCPY(&pEnum->oSlotHeader, &pSlotCtx->oSlotHeader, SIZEOF(_SlotHeader));

ErrorExit:

    if ( pNextBlock )
    {
        _Hds_free(pEnum->pNS->pHDS, pNextBlock);
    }
    if ( pTmpBlock )
    {
        _Hds_free(pEnum->pNS->pHDS, pTmpBlock);
    }
    return dr;
}



/**********************************************************************
** Function:    _HdsCleanupStore
** Synopsis:    
** Arguments:   [pHDS] -- 
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsCleanupStore(
    _HdsContext *pHDS)
{
    DRM_RESULT            dr=DRM_SUCCESS;
    DRM_DWORD              cbEntry=0, cbRead=0;
    _EnumContext         *pEnumContext=NULL;
    _NsContext           *pNsStoreCTX=NULL; 
    _NsContext           *pNsCtx=NULL;
    DRM_HDS_SLOT_CONTEXT *pSlotContext=NULL;
    DRM_HDS_NAMESPACE    *pNamespace=NULL;
    _NSEntry             *pNsStoreEntry=NULL;

    /* no namespace store exist ==> no namespace found */
    DRMASSERT(pHDS && pHDS->oSRN.nNsStoreRootBlockNum>0);

    /* allocate memory */
    ChkDR(_Hds_malloc(pHDS, DRM_HDS_ENUM_CONTEXT_LEN,      (DRM_VOID**)&pEnumContext));
    ChkDR(_Hds_malloc(pHDS, DRM_HDS_NAMESPACE_CONTEXT_LEN, (DRM_VOID**)&pNsStoreCTX));
    ChkDR(_Hds_malloc(pHDS, DRM_HDS_NAMESPACE_CONTEXT_LEN, (DRM_VOID**)&pNsCtx));
    ChkDR(_Hds_malloc(pHDS, SIZEOF(DRM_HDS_SLOT_CONTEXT),  (DRM_VOID**)&pSlotContext));
    ChkDR(_Hds_malloc(pHDS, SIZEOF(DRM_HDS_NAMESPACE),     (DRM_VOID**)&pNamespace));

    /* Enum each namespace, call cleanupNamespace */
    ChkDR(_HdsInitNsContext(pHDS, pNsStoreCTX, NULL, pHDS->oSRN.nNsStoreRootBlockNum, 
        NsStoreNumofChildren));
    ChkDR(_HdsInitSlotEnum(pNsStoreCTX, NULL, eDRM_HDS_LOCKSHARED, pEnumContext));
    while (TRUE)
    {
        dr = _HdsSlotEnumNext(pEnumContext, (_SlotContext*)pSlotContext, NULL, NULL, &cbEntry);
        if (dr == DRM_E_NOMORE)
        {
            dr = DRM_SUCCESS;
            break;
        }
        ChkDR(dr);

        /* alloc memory and read the entry */
        ChkDR(_Hds_malloc(pHDS, cbEntry, (DRM_VOID**)&pNsStoreEntry));
        ChkDR(_HdsSlotRead((_SlotContext*)pSlotContext, cbEntry, (DRM_BYTE *)pNsStoreEntry, &cbRead));
        if ( cbRead != cbEntry )
        {
            ChkDR(DRM_E_FILEREADERROR);
        }
        FIX_ENDIAN_WORD( pNsStoreEntry->wMaxNumChildren );
        FIX_ENDIAN_DWORD( pNsStoreEntry->nNSRBlockNum );

        ChkDR(_HdsCloseSlot((_SlotContext*)pSlotContext));
        ChkDR(_HdsValidateNSEntryFromDisk( pHDS, pNsStoreEntry ) );

        /* cleanup this namespace */
        MEMCPY(pNamespace->rgb, pNsStoreEntry->bNSName, DRM_HDS_NSNAME_SIZE);
        ChkDR(_HdsInitNsContext(pHDS, pNsCtx, pNamespace, pNsStoreEntry->nNSRBlockNum,
            pNsStoreEntry->wMaxNumChildren));
        ChkDR(_HdsCleanupNamespace(pNsCtx));
        ChkDR(_Hds_free(pHDS, pNsStoreEntry));
        pNsStoreEntry = NULL;
    }
    
ErrorExit:
    /* free the local memory in reverse order */
    _Hds_free(pHDS, pNsStoreEntry);
    _Hds_free(pHDS, pNamespace);
    _Hds_free(pHDS, pSlotContext);
    _Hds_free(pHDS, pNsCtx);
    _Hds_free(pHDS, pNsStoreCTX);
    _Hds_free(pHDS, pEnumContext);
    return dr;
}


/**********************************************************************
** Function:    _HdsSlotResize
** Synopsis:    
** Arguments:   [pSlotCtx]  -- slot context
**              [cbNewSize] -- new size to be used
** Returns:     DRM_SUCCESS on success
** Notes:       The resized slot will have the same type of lock as before.
***********************************************************************
*/
static DRM_RESULT _HdsSlotResize( 
    IN _SlotContext *pSlotCtx, 
    IN DRM_DWORD     cbNewSize)
{
    DRM_RESULT     dr=DRM_SUCCESS;
    DRM_DWORD      dwOldSize=0;

    DRMASSERT(pSlotCtx && cbNewSize && pSlotCtx->pNS && pSlotCtx->pNS->pHDS);
    dwOldSize=pSlotCtx->oSlotHeader.dwSlotSize;
    if ( cbNewSize == dwOldSize )    /* same size, do nothing */
    {
        goto ErrorExit;
    }

    /* slot must be locked EXCLUSIVE */
    if ( (pSlotCtx->eLockMode & eDRM_HDS_LOCKEXCLUSIVE) == 0 )
    {
        ChkDR(DRM_E_HDSNOTLOCKEDEXCLUSIVE);
    }
    
    /*************************************************************************
    ** all other cases will involve copying or moving slot content
    */
    ChkDR(_HdsRelocateSlotAndKeepCurrLock(pSlotCtx, cbNewSize));
    pSlotCtx->dwSeekPointer = 0;
    
ErrorExit:
    if( DRM_SUCCEEDED( dr ) )
    {
        /* On success the size of the slot should be the user given size */
        pSlotCtx->oSlotHeader.dwSlotSize = cbNewSize;
    }
    return dr;
}

static DRM_VOID _ZeroHDSContextIgnoringCritSec(
    _HdsContext *f_pcontextHDS)
{
    f_pcontextHDS->dwContextSize               = 0;
    f_pcontextHDS->fInited                     = FALSE;
    f_pcontextHDS->eContextSignature           = 0;
    f_pcontextHDS->fp                          = OEM_INVALID_HANDLE_VALUE;
    f_pcontextHDS->nImagesize_FileBlockHDR     = 0;
    f_pcontextHDS->nImagesize_DataBlockHDR     = 0;
    f_pcontextHDS->nImagesize_DataBlockPayload = 0;
    f_pcontextHDS->nDataBlockPayloadPos        = 0;

    ZEROMEM(&f_pcontextHDS->oHeap,    SIZEOF(f_pcontextHDS->oHeap));
    ZEROMEM(&f_pcontextHDS->oSRN,     SIZEOF(f_pcontextHDS->oSRN));
    ZEROMEM(&f_pcontextHDS->contextMD5, SIZEOF(f_pcontextHDS->contextMD5));
}


static DRM_RESULT _HdsCreateNameSpaceStore(
    IN _HdsContext *pHDS)
{
    DRM_RESULT     dr   = DRM_SUCCESS;
    _NsContext     oNsStoreCFG;
    _CommBlockHDR *pNsStoreBlock = NULL;

    /* if namespace store does not exist */
    if ( pHDS->oSRN.nNsStoreRootBlockNum == 0 )
    {
        /* NamespaceStore root block does not exist, create one and update SRN */
        ChkDR(_HdsInitNsContext(pHDS, &oNsStoreCFG, NULL, 0, NsStoreNumofChildren));
        ChkDR(_HdsLoadSRN(pHDS));   /* update SRN in memory */
        
        ChkDR(_HdsAllocBlock(&oNsStoreCFG, ROOTPARENTNUM, &pNsStoreBlock, eCHILDBLOCK));
        pHDS->oSRN.nNsStoreRootBlockNum = pNsStoreBlock->nBlockNum;

        ChkDR(_HdsUpdateSRN(pHDS));

        /* we do not create namespace too often, let's flush it now */
        if ( !OEM_FlushFileBuffers(pHDS->fp) )
        {
            ChkDR(DRM_E_FILEWRITEERROR);
        }
    }

ErrorExit:

    _Hds_free(pHDS, pNsStoreBlock);
    return dr;
}


static DRM_RESULT _HdsCreateNamespace( 
    IN       DRM_HDS_CONTEXT   *pcontextHDS,
    IN const DRM_HDS_NAMESPACE *pNamespace,
    IN const DRM_WORD           wMaxNumChildren, /* wMaxNumChildren must be <= DRM_HDS_MAXIMUM_CHILDREN */
    IN       DRM_BOOL           fWait)
{
    DRM_RESULT        dr=DRM_SUCCESS;
    DRM_DWORD         cbNsStoreSlotCtx=0, cbNsStoreSlot=0;
    _HdsContext      *pHDS=(_HdsContext*)pcontextHDS;
    _NsContext        oNsStoreCFG;
    _SlotContext     *pNsStoreSlotCtx=NULL;
    _NSEntry         *pNsStoreEntry=NULL;
    _CommBlockHDR    *pNsRootBlock=NULL;
    DRM_BOOL          fCreated=FALSE;
    _NsContext        oNsCtx;

    DRMASSERT(pcontextHDS && pNamespace && pHDS->fp!=OEM_INVALID_HANDLE_VALUE &&
        wMaxNumChildren > 0 && wMaxNumChildren <= DRM_HDS_MAXIMUM_CHILDREN);

    /* flush SRN in context */
    ChkDR(_HdsLoadSRN(pHDS));

    /* First, set up a HDS Config for accessing the NamespaceStore 
    ** ===========================================================
    */
    ChkDR(_HdsCreateNameSpaceStore(pHDS));


    /* Second, set up tmp Config for the new namespace, allocate and set up 
    ** the Root block for the new namespace 
    ** Note, parent of NamespaceRoot block is always 'ROOTPARENTNUM'
    ** ============================================================
    */
    ChkDR(_HdsInitNsContext(pHDS, &oNsCtx, pNamespace, 0, wMaxNumChildren));
    ChkDR(_HdsAllocBlock(&oNsCtx, ROOTPARENTNUM, &pNsRootBlock, eCHILDBLOCK));

    /* Third, alloc buffer and setup _SlotContext to store the given 
    ** namespace in NamespaceStore
    ** ==============================================================
    */
    {
        DRM_HDS_HASHKEY   oNsHashKey;
        DRM_HDS_UNIQUEKEY oNsUniqueKey;
        DRM_DWORD         cbNsStoreSlotCtx = 0;
    
        ChkDR(_HdsInitNsContext(pHDS, &oNsStoreCFG, NULL, pHDS->oSRN.nNsStoreRootBlockNum, 
            NsStoreNumofChildren));     /* set up the Config for NamespaceStore */

        cbNsStoreSlotCtx = CALC_SLOTCONTEXTLEN(&oNsStoreCFG);  /* size of slot context */
        ChkDR(_Hds_malloc(pHDS, cbNsStoreSlotCtx, (DRM_VOID**)&pNsStoreSlotCtx));
        ChkDR(_HdsInitSlotContext(&oNsStoreCFG, (DRM_BYTE *)pNsStoreSlotCtx, cbNsStoreSlotCtx));

        /* prepare the namespace content and store it in NamespaceStore
        ** ===================================================================
        */
        _GenNamespaceKeys (&pHDS->contextMD5, 
               (DRM_CHAR *) pNamespace->rgb, 
                            DRM_HDS_NSNAME_SIZE, 
                            oNsHashKey.rgb, 
                            oNsUniqueKey.rgb);  /* gen key for given namespace */
        cbNsStoreSlot = SIZEOF(_NSEntry) + DRM_HDS_NSNAME_SIZE;    /* size of the namespace slot in NamespaceStore */
        dr = _HdsCreateAndOpenSlot(
                &oNsStoreCFG, 
                &oNsHashKey, 
                &oNsUniqueKey, 
                FALSE, 
                cbNsStoreSlot, 
                pNsStoreSlotCtx,
                eDRM_HDS_LOCKEXCLUSIVE | (fWait? eDRM_HDS_LOCKWAIT : 0) );
        if ( DRM_SUCCEEDED(dr) )
        {
            /* store the namespace into NamespaceStore */
            _NsContext oNsCtx;
            DRM_DWORD cbWritten=0;

            fCreated = TRUE;

            /* set up tmp Config for the new namespace and allocate and set up 
            ** the Root block for the new namespace 
            ** Note, parent of NamespaceRoot block is always 'ROOTPARENTNUM'*/
            ChkDR(_HdsInitNsContext(pHDS, &oNsCtx, pNamespace, 0, wMaxNumChildren));

            /* allocate buffer and prepare the namespace slot */
            ChkDR(_Hds_malloc(pHDS, cbNsStoreSlot, (DRM_VOID**)&pNsStoreEntry));
            pNsStoreEntry->nNSRBlockNum = pNsRootBlock->nBlockNum;
            pNsStoreEntry->wMaxNumChildren = wMaxNumChildren;
            MEMCPY(pNsStoreEntry->bNSName, pNamespace->rgb, DRM_HDS_NSNAME_SIZE);

            /* write the namespace slot in NsStore */
            FIX_ENDIAN_WORD( pNsStoreEntry->wMaxNumChildren );
            FIX_ENDIAN_DWORD( pNsStoreEntry->nNSRBlockNum );
            dr = _HdsSlotWrite(pNsStoreSlotCtx, cbNsStoreSlot, (DRM_BYTE *)pNsStoreEntry, &cbWritten);
            FIX_ENDIAN_WORD( pNsStoreEntry->wMaxNumChildren );
            FIX_ENDIAN_DWORD( pNsStoreEntry->nNSRBlockNum );

            /* we do not create namespace too often, let's flush it now */
            if ( !OEM_FlushFileBuffers(pHDS->fp) )
            {
                dr = DRM_E_FILEWRITEERROR;
            }
            
            goto ErrorExit;        
        }
        else if ( dr == DRM_E_HDSSLOTEXIST )
        {
            TRACE(("DRM_HDS_CreateNamespace(): namespace '%s' already exist.\n", pNamespace->rgb));
            dr = DRM_E_HDSNAMESPACEEXIST;
        }
    }

ErrorExit:

    if ( DRM_FAILED(dr)  &&  pNsRootBlock != NULL )
    {
        /* we have error, remove the allocated slot */
        _HdsFreeBlock((_CommBlockHDR *)pNsRootBlock);
    }        
    
    if ( fCreated )
    {
        _HdsUnlockSlot(pNsStoreSlotCtx);
        _HdsCloseSlot(pNsStoreSlotCtx);
    }
    
    _Hds_free(pHDS, pNsStoreEntry);
    _Hds_free(pHDS, pNsStoreSlotCtx);
    _Hds_free(pHDS, pNsRootBlock);
    return dr;
}




static DRM_RESULT _HdsOpenExistingNamespace(
    IN       DRM_HDS_CONTEXT           *pcontextHDS,
    IN const DRM_HDS_NAMESPACE         *pNamespace,
    OUT      DRM_HDS_NAMESPACE_CONTEXT *pcontextNS) /* user given NS context buffer, NULL to get size */
{
    DRM_RESULT        dr=DRM_SUCCESS;
    DRM_HDS_HASHKEY   oNsHashKey;
    DRM_HDS_UNIQUEKEY oNsUniqueKey;
    DRM_DWORD         cbNsStoreSlotCtx=0;
    DRM_DWORD         cbNsSlotSize=0;
    _NsContext        oNsStoreCFG;
    _HdsContext      *pHDS=(_HdsContext*)pcontextHDS;
    _SlotContext     *pNsStoreSlotCtx=NULL;
    _NSEntry         *pNsEntry=NULL;

    DRMASSERT(pcontextHDS && pNamespace && pcontextNS && pHDS->fp!=OEM_INVALID_HANDLE_VALUE);
    DRMSIZEASSERT( SIZEOF( _NsContext ), SIZEOF( DRM_HDS_NAMESPACE_CONTEXT ) );

    /* First, set up a HDS Config (oNsStoreCFG) for accessing the NamespaceStore 
    */
    ChkDR(_HdsInitNsContext(pHDS, &oNsStoreCFG, NULL, pHDS->oSRN.nNsStoreRootBlockNum, 
        NsStoreNumofChildren));

    /* Second, alloc buffer and setup _SlotContext (pNsStoreSlotCtx) to store the given 
    ** namespace in NamespaceStore
    */
    cbNsStoreSlotCtx = CALC_MAXSLOTCONTEXTLEN;
    ChkDR(_Hds_malloc(pHDS, cbNsStoreSlotCtx, (DRM_VOID**)&pNsStoreSlotCtx));
    ChkDR(_HdsInitSlotContext(&oNsStoreCFG, (DRM_BYTE *)pNsStoreSlotCtx, cbNsStoreSlotCtx));

    /* Third, prepare the namespace key and search it in NamespaceStore
    */
    _GenNamespaceKeys (&pHDS->contextMD5, 
           (DRM_CHAR *) pNamespace->rgb, 
                        DRM_HDS_NSNAME_SIZE, 
                        oNsHashKey.rgb, 
                        oNsUniqueKey.rgb);
    dr = _HdsOpenExistingSlot(&oNsStoreCFG, &oNsHashKey, &oNsUniqueKey, FALSE,
        &cbNsSlotSize, pNsStoreSlotCtx);
    if ( !DRM_FAILED(dr) )
    {
        _NsContext *pNsCFG=NULL;

        /* allocate buffer and load the User's namespace entry from NsStore */
        ChkDR(_Hds_malloc(pHDS, cbNsSlotSize, (DRM_VOID**)&pNsEntry));
        
        ChkDR(_HdsSlotRead(pNsStoreSlotCtx, cbNsSlotSize, (DRM_BYTE *)pNsEntry, NULL));
        FIX_ENDIAN_WORD( pNsEntry->wMaxNumChildren );
        FIX_ENDIAN_DWORD( pNsEntry->nNSRBlockNum );
        ChkDR(_HdsValidateNSEntryFromDisk( pHDS, pNsEntry ) );

        pNsCFG = (_NsContext *)pcontextNS;
        ChkDR(_HdsInitNsContext(pHDS, pNsCFG, pNamespace, pNsEntry->nNSRBlockNum,
            pNsEntry->wMaxNumChildren));

#ifdef _CHKHDS_
        printf("\n\t[Namespace Info]\n");
        printf("\t[# of Children blocks]\t\t%d\n", pNsEntry->wMaxNumChildren);
        printf("\t[Namespace Root block#]\t\t%d\n", pNsEntry->nNSRBlockNum);
        printf("\t[Generic block header size]\t%d\n", pHDS->nImagesize_FileBlockHDR);
        printf("\t[CHILD block header size]\t%d\n", pNsCFG->nImagesize_ChildBlockHDR);
        printf("\t[CHILD alloctable size]\t\t%d\n", pNsCFG->nImagesize_ChildAllocTable);
        printf("\t[CHILD block payload size]\t%d\n", pNsCFG->nImagesize_ChildBlockPayload);
        printf("\t[CHILD block payload pos]\t%d\n", pNsCFG->nChildBlockPayloadPos);
#endif
        
        ChkDR(_HdsCloseSlot(pNsStoreSlotCtx));
    }
    else if ( dr == DRM_E_HDSSLOTNOTFOUND )
    {
        TRACE(("_HdsOpenExistingNamespace(): namespace '%s' does not exist.\n", pNamespace->rgb));
        ChkDR(DRM_E_HDSNAMESPACENOTFOUND);
    }
    ChkDR(dr);

ErrorExit:
    if ( pNsEntry )
    {
        _Hds_free(pHDS, pNsEntry);
    }
    if ( pNsStoreSlotCtx )
    {
        _Hds_free(pHDS, pNsStoreSlotCtx);
    }
    return dr;      
}


static DRM_RESULT _HdsPreAlloc( 
    IN  _HdsContext *f_pHDS,
    IN  DRM_DWORD    f_PreAllocFileSizeInKB,
    IN  DRM_BOOL     f_fUpToSpecifiedSize,
    OUT DRM_DWORD   *f_pnNextBlockNum)
{
    DRM_RESULT     dr   = DRM_SUCCESS;
    DRM_DWORD      i    = 0;
    DRM_DWORD      dwFilePos = 0;
    DRM_DWORD      nBlocks   = 0;
    _CommBlockHDR *pBlock    = NULL;
    DRM_DWORD      nNextBlockNum = 0;
    DRM_BYTE      *pCopyBuffer = NULL;

    /* calc # of blocks to be appended at end of file, then append them */
    if (!OEM_GetFileSize(f_pHDS->fp, &dwFilePos))
    {
        ChkDR(DRM_E_FILEREADERROR);
    }

    /* make sure the prealloc size is bigger than the current file size */
    if ( f_fUpToSpecifiedSize )
    {
        ChkArg( dwFilePos < (f_PreAllocFileSizeInKB * 1024) );
    }

    nBlocks = (f_PreAllocFileSizeInKB * 1024) / f_pHDS->oSRN.dwBlockSize;
    
    /* make sure # of blocks to prealloc is not zero */
    if (nBlocks == 0)
    {
        nBlocks = 1;
    }

    /* expand the file by n blocks */
    ChkDR(_HdsExpandStore(f_pHDS, nBlocks, &nNextBlockNum));

    /* flush SRN in context */
    ChkDR( _HdsLoadSRN(f_pHDS) );


    ChkDR(_Hds_malloc(f_pHDS, GetMemsize_DataBlock(), (DRM_VOID**)&pBlock));
    ChkDR(_Hds_malloc(f_pHDS, COPYBUFF_SIZE, (DRM_VOID**)&pCopyBuffer));
    ZEROMEM((DRM_BYTE *) pCopyBuffer, COPYBUFF_SIZE); 

    /* format the expanded file in blocks, start from end of file */
    for (i = (nNextBlockNum + nBlocks - 1); i >= nNextBlockNum; i--)
    {
        _DataBlockHDR *pDataBlock = (_DataBlockHDR*)pBlock;

        /* initialize the tmp block */
        pBlock->nBlockNum = i;
        pBlock->File._image.nParentBlockNum = 0;
        pBlock->File._image.ui64TimeStamp   = _GetTimeStamp();

        PUT_BYTE( &pBlock->File._image.bBlockType, 0, eFREEBLOCK );

        pDataBlock->nPayloadSize = f_pHDS->nImagesize_DataBlockPayload;
        pDataBlock->File._image.nCascadingBlockNum = f_pHDS->oSRN.nFreeListHead;

        /* chain the block to SRN's freelist */
        f_pHDS->oSRN.nFreeListHead = pBlock->nBlockNum;

        /* update block to file */
        ChkDR(_HdsGenBlockHash(f_pHDS, NULL, pBlock, pBlock->File._image.bBlockHash));

        ChkDR(_HdsBlockNum2FilePos(f_pHDS, i, &dwFilePos));
        if (!OEM_SetFilePointer(f_pHDS->fp, dwFilePos, OEM_FILE_BEGIN, NULL))
        {
            ChkDR(DRM_E_FILESEEKERROR);
        }
        if (!_WriteCommonBlockHeader(f_pHDS, pBlock, f_pHDS->nImagesize_FileBlockHDR, NULL ) )
        {
            ChkDR(DRM_E_FILEWRITEERROR);
        }
        if (!_WriteDataBlockHeader(f_pHDS, pDataBlock) )
        {
            ChkDR(DRM_E_FILEWRITEERROR);
        }

        /* commit changes of root node to file */
        ChkDR(_HdsUpdateSRN(f_pHDS));
    }

    if ( f_pnNextBlockNum != NULL )
    {
        *f_pnNextBlockNum = nNextBlockNum;
    }
ErrorExit:

    _Hds_free(f_pHDS, pCopyBuffer);
    _Hds_free(f_pHDS, pBlock);
    return dr;
}


/**********************************************************************
** Function:    _HdsLockRestOfBlock2DeleteSlot
** Synopsis:    lock block payload from the given slot to end of block.
**              It is essentially the same as _HdsLockSlot where we are
**              grabbing a lock on a bigger slot.
** Arguments:   [pSlotCtx] -- 
**              [fExclusive] --
** Returns:     DRM_SUCCESS on success
** Notes:       To remove a slot from a block, it is necessary to lock
**              the slot to end of block (to do adjustments).
***********************************************************************
*/
static DRM_RESULT _HdsLockRestOfBlock2DeleteSlot(
    _SlotContext *pSlotCtx,
    DRM_DWORD     eMode)
{
#if _MULTI_THREADING_SUPPORT==1

    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwFilePos    = 0;
    DRM_LONG   dwLockSize   = 0;
    DRM_DWORD  nBytesToSkip = 0;

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS, pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* skip current slot */
    if ( ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        nBytesToSkip = SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);
    }
    else
    {
        nBytesToSkip = SIZEOF(_SlotHeader) + pSlotCtx->oSlotHeader.dwSlotSize;
    }

    /* adjust filepos relative to the block */
    dwLockSize = dwFilePos + pSlotCtx->pNS->pHDS->oSRN.dwBlockSize;
    dwFilePos += (pSlotCtx->pNS->nChildBlockPayloadPos + pSlotCtx->dwSlotPosInBlock + nBytesToSkip);
    dwLockSize -= dwFilePos;

#ifdef _TRACELOCK
    TRACE(("_HdsLockRestOfBlock2DeleteSlot issued:  %c%c - pos %d,  size %d\n",  
          (eMode & eDRM_HDS_LOCKEXCLUSIVE)? 'X' : 'S', 
          (eMode & eDRM_HDS_LOCKWAIT)? 'W' : ' ', 
          dwFilePos, 
          dwLockSize));
#endif

    /* lock it */
    if ( !OEM_LockFile(pSlotCtx->pNS->pHDS->fp, 
                       ((eMode & eDRM_HDS_LOCKEXCLUSIVE) != 0), 
                       dwFilePos, 
                       dwLockSize,
                       ((eMode & eDRM_HDS_LOCKWAIT) != 0) ) )
    {
        ChkDR(DRM_E_HDSLOCKFAILED);
    }
#ifdef _TRACELOCK
    TRACE(("_HdsLockRestOfBlock2DeleteSlot obtained\n"));
#endif    

ErrorExit:
    return dr;
    
#else   /* !_MULTI_THREADING_SUPPORT==1 */

    return DRM_SUCCESS;
    
#endif
}


static DRM_RESULT _HdsUnlockRestOfBlock2DeleteSlot(
    _SlotContext *pSlotCtx)
{
#if _MULTI_THREADING_SUPPORT==1

    DRM_RESULT dr = DRM_SUCCESS;
    DRM_DWORD  dwFilePos    = 0;
    DRM_LONG   dwLockSize   = 0;
    DRM_DWORD  nBytesToSkip = 0;
    DRM_BOOL   fResult = FALSE;

    /* compute filepos of the block */
    ChkDR(_HdsBlockNum2FilePos(pSlotCtx->pNS->pHDS, pSlotCtx->pCurrChildBlock->nBlockNum, &dwFilePos));

    /* skip current slot */
    if ( ISOVERSIZESLOT(pSlotCtx->oSlotHeader.dwSlotSize, pSlotCtx->pNS) )
    {
        nBytesToSkip = SIZEOF(_SlotHeader) + SIZEOF(DRM_DWORD);
    }
    else
    {
        nBytesToSkip = SIZEOF(_SlotHeader) + pSlotCtx->oSlotHeader.dwSlotSize;
    }

    /* adjust filepos relative to the block */
    dwLockSize = dwFilePos + pSlotCtx->pNS->pHDS->oSRN.dwBlockSize;
    dwFilePos += (pSlotCtx->pNS->nChildBlockPayloadPos+pSlotCtx->dwSlotPosInBlock + nBytesToSkip);
    dwLockSize -= dwFilePos;

#ifdef _TRACELOCK
    TRACE(("_HdsUnlockRestOfBlock2DeleteSlot issued:  - pos %d,  size %d\n", dwFilePos, 
        dwLockSize));
#endif

    /* unlock it, do not return even if this fail */
    fResult = OEM_UnlockFile(pSlotCtx->pNS->pHDS->fp, dwFilePos, dwLockSize);

    if ( !fResult )
    {
        dr = DRM_E_HDSLOCKFAILED;
    }

ErrorExit:
    return dr;
    
#else   /* !_MULTI_THREADING_SUPPORT==1 */

    return DRM_SUCCESS;
    
#endif
}




/**********************************************************************
** Function:    _HdsSlotEnumDeleteCurrent
** Synopsis:    
** Arguments:   [pEnumContext] -- Enum Context init'd by DRM_HDS_InitSlotEnum()
**              [pSlotContext] -- Slot Context of the current slot
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
static DRM_RESULT _HdsSlotEnumDeleteCurrent( 
    IN  _EnumContext *pEnum,
    OUT _SlotContext *pSlotCtx)
{
    DRM_RESULT       dr = DRM_SUCCESS;    
    DRM_BOOL         fRestOfBlockLocked = FALSE;
    _CommBlockHDR   *pTmpBlock = NULL;

    DRMASSERT(pEnum && pEnum->pNS);
    ChkArg(ISVALIDCONTEXT(pEnum, eEnumContextSignature));
    ChkArg(ISVALIDCONTEXT(pEnum->pNS, eCfgContextSignature));
    DRMASSERT(pEnum->pNS->fInited && pEnum->pNS->pHDS && pSlotCtx
        && pEnum->pNS->pHDS->fp!=OEM_INVALID_HANDLE_VALUE);

    /* 
    ** Verify validity of the current block of the slot context
    ** BUGBUG: a more detail analysis is needed for this scenario 
    */
    {
        _CommBlockHDR *pBlock = &pEnum->oFileBlock;
        _CommBlockHDR *pCurrBlock = &pEnum->oCurrBlock;

        /* check if query started yet */
        if ( ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos == MAXSLOTPOS )
        {
            /* query has not been started, cannot proceed */
            ChkDR(DRM_E_HDSSLOTNOTFOUND);
        }

        /* load generic block header */
        ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, &pBlock, GPBH_GENERIC_ONLY, GPBH_OPERATION_READ));

        /* verify the generic header */
        if ( !DRM_UI64Eql(pEnum->oFileBlock.File._image.ui64TimeStamp, pCurrBlock->File._image.ui64TimeStamp) 
          || MEMCMP(pEnum->oFileBlock.File._image.bBlockHash, pCurrBlock->File._image.bBlockHash, SIZEOF(pCurrBlock->File._image.bBlockHash))!=0 )
        {
            /* the current block has been updated/written since last read */
            _SlotHeader slotHeader;
            DRM_DWORD   dwCurrPos = 0;

            /* check if it is still a CHILD block or belong to the same parent */
            if ( GET_BYTE( &pEnum->oFileBlock.File._image.bBlockType, 0 ) != GET_BYTE( &pCurrBlock->File._image.bBlockType, 0 ) 
              || pEnum->oFileBlock.File._image.nParentBlockNum            != pCurrBlock->File._image.nParentBlockNum )
            {
                /* there is nothing we can do when the current block is totally invalid 
                */
                ChkDR(DRM_E_HDSSLOTNOTFOUND);    
            }

            /* load the child block in a tmp buffer */
            ChkDR(_HdsAllocBlockBuffer(pEnum->pNS, eCHILDBLOCK, &pTmpBlock));
            ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, 
                &pTmpBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));

            /* load the current slot header from file */
            ChkDR(_HdsGetPutBlockPayload(pTmpBlock, ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos,
                SIZEOF(_SlotHeader), &slotHeader, GPBP_OPERATION_READ));
            FIX_ENDIAN_DWORD( slotHeader.dwAttributes );
            FIX_ENDIAN_DWORD( slotHeader.dwSlotSize );
            if (MEMCMP(&slotHeader, &pEnum->oSlotHeader, SIZEOF(_SlotHeader))==0 )
            {
                /* the current slot is intact, update the block buffer and continue */
                DRM_DWORD _dwCurrPos = ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos;
                DRM_DWORD _dwNextPos = ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos;
                
                ChkDR(_HdsGetPutBlockHDR(pEnum->pNS, pEnum->oFileBlock.nBlockNum, &pCurrBlock, GPBH_ANY_HEADER, GPBH_OPERATION_READ));
                ((_ChildBlockHDR*)pCurrBlock)->nCurrSlotPos = _dwCurrPos;
                ((_ChildBlockHDR*)pCurrBlock)->nNextSlotPos = _dwNextPos;
                goto Verified_Okay;
            }

            ChkDR(DRM_E_HDSSLOTNOTFOUND);    
        }
    }

Verified_Okay:

    /* we have exclusive lock of the slot already. Let's lock the rest of the block */
    if ( DRM_SUCCEEDED(_HdsLockRestOfBlock2DeleteSlot(pSlotCtx, eDRM_HDS_LOCKEXCLUSIVE)) )
    {
        fRestOfBlockLocked = TRUE;
        ChkDR( _HdsRemoveSlot(pSlotCtx, eRemoveSlotPermanent) );
    }

ErrorExit:

    if ( fRestOfBlockLocked )
    {
        _HdsUnlockRestOfBlock2DeleteSlot(pSlotCtx);
    }

    if ( pTmpBlock )
    {
        _Hds_free(pEnum->pNS->pHDS, pTmpBlock);
    }

    if ( DRM_SUCCEEDED(dr) )
    {
        _HdsUnlockSlot(pSlotCtx);
        _HdsCloseSlot(pSlotCtx);
    }
    return dr;
}


static DRM_RESULT _HdsBlockScanInit(
    IN        _NsContext      *f_pcontextNS,
    IN const DRM_HDS_HASHKEY  *f_pkeyHash,
    IN const DRM_HDS_UNIQUEKEY f_rgkeyUnique [],
    IN const DRM_DWORD         f_cKeysUnique,
    IN const DRM_HDS_LOCKMODE  f_lockmode,
    OUT _BlockScanContext     *f_pcontextBlockScan)
{
    DRM_RESULT    dr            = DRM_SUCCESS;
    DRM_BOOL      fOK       = FALSE;
    DRM_DWORD     cbSlotContext = 0; 
    _SlotContext *pcontextSlot  = NULL;

    /* init Enum context */

    ZEROMEM(f_pcontextBlockScan, SIZEOF(DRM_HDS_BLOCKSCAN_CONTEXT));
    f_pcontextBlockScan->cbContext         = SIZEOF(DRM_HDS_BLOCKSCAN_CONTEXT);
    f_pcontextBlockScan->pcontextNS        = f_pcontextNS;
    f_pcontextBlockScan->fInited           = TRUE;
    f_pcontextBlockScan->eContextSignature = eEnumContextSignature;
    f_pcontextBlockScan->fCurrBlockIsValid = FALSE;
    f_pcontextBlockScan->lockmode          = f_lockmode;
    f_pcontextBlockScan->pkeyUnique        = f_rgkeyUnique;
    f_pcontextBlockScan->cKeysUnique       = f_cKeysUnique;
    f_pcontextBlockScan->iKeyCurrent       = 0;

    /* locate and prepare pEnum->oCurrBlock, if possible, for EnumNext() */

    ChkDR(_HdsInitBlockBuffer(f_pcontextBlockScan->pcontextNS, 
                             &f_pcontextBlockScan->blockheaderCurrent, 
                              0, 
                              eCHILDBLOCK));

    /* save the hash key in the blockscan context */

    MEMCPY(f_pcontextBlockScan->keyHash.rgb, f_pkeyHash->rgb, DRM_HDS_HASHKEY_SIZE);

    /* allocate temp slotcontext */

    cbSlotContext = CALC_SLOTCONTEXTLEN(f_pcontextNS);

    ChkDR(_Hds_malloc(f_pcontextNS->pHDS, 
                        cbSlotContext, 
        (DRM_VOID **) &pcontextSlot));
    
    dr = _HdsInitSlotContext(f_pcontextNS, (DRM_BYTE *)pcontextSlot, cbSlotContext);

    /* find the first block containing the Hashkey */

    if (DRM_SUCCEEDED(dr))
    {
        /* search the first slot matching given hashkey */

        dr = _HdsSearchSlotInFile(f_pcontextNS, 
                                  f_pkeyHash, 
                                  NULL, 
                                  eSearchSlotDontCare, 
                                  NULL, 
                                  pcontextSlot, 
                                 &fOK);

        if (DRM_SUCCEEDED(dr))
        {
            if (! fOK)
            {
                dr = DRM_E_HDSSLOTNOTFOUND;
            }
            else
            {
                dr = _HdsCopyBlockBuffer(&f_pcontextBlockScan->blockheaderCurrent, pcontextSlot->pCurrChildBlock);

                if (DRM_SUCCEEDED(dr))
                {
                    _ChildBlockHDR *pheaderChild = (_ChildBlockHDR *) &f_pcontextBlockScan->blockheaderCurrent;

                    pheaderChild->nCurrSlotPos = MAXSLOTPOS;
                    pheaderChild->nNextSlotPos = MAXSLOTPOS;
                }
            }
        }
    }

    _Hds_free(f_pcontextNS->pHDS, pcontextSlot);
    ChkDR(dr);

    f_pcontextBlockScan->fCurrBlockIsValid = TRUE;

    MEMCPY(&f_pcontextBlockScan->blockheader, 
           &f_pcontextBlockScan->blockheaderCurrent, 
     SIZEOF(f_pcontextBlockScan->blockheaderCurrent));

ErrorExit:        
    return dr;
}

static DRM_BOOL _IsMatchingKey(
    IN       DRM_HDS_UNIQUEKEY *f_pkey,
    IN const DRM_HDS_UNIQUEKEY  f_rgkeys [],
    IN       DRM_DWORD          f_cKeys,
    IN       DRM_DWORD          f_iHint)
{
    DRM_BOOL  fMatch = FALSE;
    DRM_DWORD iKey   = 0;

    if (f_iHint >= f_cKeys)
    {
        f_iHint = 0;
    }

    for (iKey = f_iHint; iKey < f_cKeys; iKey++)
    {
        if (MEMCMP(f_pkey, f_rgkeys + iKey, SIZEOF(DRM_HDS_UNIQUEKEY)) == 0)
        {
            fMatch = TRUE;
            goto MatchFound;
        }
    }

    if (f_iHint > 0)
    {
        for (iKey = 0; iKey < f_iHint; iKey++)
        {
            if (MEMCMP(f_pkey, f_rgkeys + iKey, SIZEOF(DRM_HDS_UNIQUEKEY)) == 0)
            {
                fMatch = TRUE;
                break;
            }
        }
    }

MatchFound:
    return fMatch;
}

#define COA_BLOCK_NOT_SET 0xFFFFFFFF

static DRM_RESULT _CoalesceBlock(_CommBlockHDR   *f_pblockheader,
                                 _SlotContext    *f_pcontextSlotLock,
                                 DRM_HDS_HASHKEY *f_pkeyHash,
                                 DRM_HDS_LOCKMODE f_lockmode,
                                 DRM_BOOL        *f_fLocked)
{
    DRM_RESULT      dr                   = DRM_SUCCESS;
    DRM_BOOL        fFound               = TRUE;
    DRM_BOOL        fMove                = FALSE;
    DRM_DWORD       ibSource             = COA_BLOCK_NOT_SET;
    DRM_DWORD       ibNext               = COA_BLOCK_NOT_SET;
    DRM_DWORD       ibDest               = COA_BLOCK_NOT_SET;
    _SlotContext   *pcontextSlot         = NULL;
    const DRM_DWORD cbBlock              = f_pblockheader->pNS->pHDS->oSRN.dwBlockSize;
    const DRM_DWORD cbSlotContext        = CALC_SLOTCONTEXTLEN(f_pblockheader->pNS);

    /* allocate temporary slotcontext */

    ChkDR(_Hds_malloc(f_pblockheader->pNS->pHDS, 
                      cbSlotContext, 
       (DRM_VOID **) &pcontextSlot));

    ((_ChildBlockHDR *) f_pblockheader)->nNextSlotPos = 0;

   *f_fLocked = FALSE;

    while (fFound)
    {
        ChkDR(_HdsInitSlotContext(f_pblockheader->pNS, 
                     (DRM_BYTE *) pcontextSlot, 
                                  cbSlotContext));

        /* get the next hidden block for this HASHKEY */

        ChkDR(_HdsSearchSlotInBlock(f_pblockheader,
                                    f_pkeyHash,
                                    NULL,
                                    eSearchHiddenOnly,
                                    pcontextSlot,
                                   &fFound));

        if (fFound)
        {
            fMove = TRUE;

            /* if this is the first of >= 1 adjacent blocks, cache the offset of the beginning  */

            if (ibDest == COA_BLOCK_NOT_SET)
            {
                ibDest = pcontextSlot->dwSlotPosInBlock;

                /* save the first slot to be affected by the move */

                MEMCPY(f_pcontextSlotLock, pcontextSlot, cbSlotContext);
                /* Set the pointers within the copied context that refer back to the source context,
                   since we will be freeing the source context at the end of this function */
                f_pcontextSlotLock->pCurrChildBlock = (_CommBlockHDR *)f_pcontextSlotLock->bBuff;
                f_pcontextSlotLock->pCurrDataBlock  = (_CommBlockHDR *) (f_pcontextSlotLock->bBuff + __CB_DECL(GetMemsize_ChildBlock(f_pblockheader->pNS)));


                ChkDR(_HdsLockBlock2DeleteSlot(f_pcontextSlotLock, f_lockmode));

               *f_fLocked = TRUE;
            }

            /* if this isn't contiguous with the last hidden block then close that previous hole 
            ** and continue from where we are
            */

            else if (pcontextSlot->dwSlotPosInBlock != ibNext)
            {
                DRM_DWORD cbMove = pcontextSlot->dwSlotPosInBlock - ibNext;

                ChkDR(_HdsAdjustChildPayload(pcontextSlot->pCurrChildBlock, 
                                             ibDest, 
                                             ibSource,
                                             cbMove));

                /* the new destination is the end of the blocks just moved */

                ibDest += cbMove;
            }

            /* remove _DataBlockHDR's, if necessary */

            if (ISOVERSIZESLOT(pcontextSlot->oSlotHeader.dwSlotSize, 
                               pcontextSlot->pNS))
            {
                DRM_DWORD nBlockData = pcontextSlot->dwFirstDataBlockNum;

                ibSource = pcontextSlot->dwSlotPosInBlock 
                         + SIZEOF(_SlotHeader) 
                         + SIZEOF(DRM_DWORD);

                while (nBlockData > 0)
                {
                    ChkDR(_HdsLoadBlockHDR(pcontextSlot->pNS, 
                                           nBlockData, 
                                          &pcontextSlot->pCurrDataBlock));

                    nBlockData = ((_DataBlockHDR *)(pcontextSlot->pCurrDataBlock))->File._image.nCascadingBlockNum;

                    ChkDR(_HdsFreeBlock(pcontextSlot->pCurrDataBlock));
                }
            }
            else
            {
                ibSource = pcontextSlot->dwSlotPosInBlock 
                         + pcontextSlot->oSlotHeader.dwSlotSize
                         + SIZEOF(_SlotHeader);
            }

            ibNext = ibSource;
        } /* endif found a hidden slot */
    }                                                           

    /* if we have an unprocessed move do it now */

    if (fMove)
    {
        /* move up the remaining space and update the free space */

        ChkDR(_HdsAdjustChildPayload(f_pblockheader, 
                                     ibDest, 
                                     ibSource, 
                                     ADJUST_PAYLOAD_TO_END));

        /* remove slot in _ChildBlockHDR */

        ChkDR(_HdsWriteBlockHDR     (f_pblockheader));
    }

ErrorExit:

    if (pcontextSlot != NULL)
    {
        _Hds_free(f_pblockheader->pNS->pHDS, pcontextSlot);
    }

    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmhds_impl.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef _HDS_IMPL_H
#define _HDS_IMPL_H

#include <oemimpl.h>
#include <drmmd5.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** These first few enums are public information.
** They are followed by internal implementation details of the HDS
*/

typedef enum 
{
    eDRM_HDSBLKNUM_WORD  = 2,      /* max of 65536 blocks */
    eDRM_HDSBLKNUM_DWORD = 4       /* max of 4 G blocks */
} DRM_HDSBLKNUM;

typedef enum
{
    eDRM_HDS_CREATE_IF_NEW = 0x1000,      /* create if not exist, if exists, open instead */
    eDRM_HDS_OPEN_EXISTING = 0x2000       /* opened if exist, failed if not */
} DRM_HDS_OPENMODE;


typedef enum
{
    eDRM_HDS_LOCKSHARED    = 0x0,
    eDRM_HDS_LOCKEXCLUSIVE = 0x1,
    eDRM_HDS_LOCKWAIT      = 0x2
} DRM_HDS_LOCKMODE;

typedef enum
{
    eDRM_HDS_SEEKCUR = 1,
    eDRM_HDS_SEEKEND,
    eDRM_HDS_SEEKSET
} DRM_HDS_SEEKMODE;

typedef DRM_KID DRM_HDS_HASHKEY;
typedef DRM_LID DRM_HDS_UNIQUEKEY;

/*
** uncomment the following if do not need DRM_HDS_InitSlotEnum() and DRM_HDS_SlotEnumNext() 
*/
/* #define _NOENUMALL */


/*
** Note: this is implementation specific. 
*/
#define CONTEXT_LENGTH    3072
#define MAXSLOTPOS        0xFFFF
#define ROOTPARENTNUM     0x00


#define DRM_E_HDSINVALIDSTORE     DRM_E_INVALIDLICENSESTORE
#define DRM_E_HDSSRNCORRUPTED     DRM_E_HDSFILECORRUPTED
#define DRM_E_HDSNAMESPACEEXIST     DRM_E_FAIL

#define DRM_HDS_HASHKEY_SIZE        DRM_ID_SIZE
#define DRM_HDS_UNIQUEKEY_SIZE      DRM_ID_SIZE
#define DRM_HDS_NSNAME_SIZE 16

/* create a namespace tree in the data store */
#define DRM_HDS_MAXIMUM_CHILDREN 16



/*
** Useful macros used in this source file only
*/
#define HDS_CONTEXT_LENGTH(srnsize)    \
    (SIZEOF(_HdsContext) - SIZEOF(_SRN) + (srnsize) + CONTEXT_LENGTH)

#define ISVALIDCONTEXT(ctx, eSignature) \
    (((ctx)->eContextSignature==(eSignature))?TRUE : FALSE)

#define CALC_SLOTCONTEXTLEN(cfg) \
    (SIZEOF(_SlotContext)+GetMemsize_ChildBlock((cfg))+GetMemsize_DataBlock())

#define CALC_MAXSLOTCONTEXTLEN \
    (SIZEOF(_SlotContext)+GetMaxMemsize_ChildBlock()+GetMemsize_DataBlock())

#define CALC_MAXENUMCONTEXTLEN \
    (SIZEOF(_EnumContext)+GetMaxMemsize_ChildBlock()-SIZEOF(_CommBlockHDR))

#define CALC_MAXBLOCKSCANCONTEXTLEN \
    (SIZEOF(_BlockScanContext)+GetMaxMemsize_ChildBlock()-SIZEOF(_CommBlockHDR))

/*
**  NOTE:
**  -Child Node number = (Fileposition / NodeSize) + 1
**  -Node number of the RootNode is always 0
**  -Uses DRM_USHORT for Nodenum gives roughly 64K nodes in a file. On average, if a node
**   can store 5 licenses, a license file can store up to 320K licenses.
**  -If a larger number of licneses need to be stored, DRM_DWORD can be used. This will gives
**   4096M nodes or 20480M licenses.
**  -to search a node containing a particular license, we only have to traverse Log(N) times where
**   N is the number of licenses in the file.
*/




/******************************************************************************
** Major implementation data structure
*******************************************************************************
*/


/* 
** Block Type 
*/
typedef enum 
{
    eINVALIDBLOCK = 0x00,
    eCHILDBLOCK,
    eDATABLOCK,
    eFREEBLOCK
} _EBlockType;

typedef enum
{
    eHdsContextSignature  = 0x01,
    eCfgContextSignature  = 0x02,
    eSlotContextSignature = 0x03,
    eEnumContextSignature = 0x04
} _EContextSignature;


/*
**
*/
typedef enum
{
    eSlotCtxUninit = 0,
    eSlotCtxInited,
    eSlotCtxReady
} _ESlotContextStatus;


typedef enum
{
    eSearchSlotDontCare,
    eSearchDataSlot,
    eSearchNamespace,
    eSearchHiddenOnly
} _ESlotSearchMode;


typedef enum
{
    eRemoveSlotSetHidden = 1,
    eRemoveSlotSetNull   = 2,
    eRemoveSlotPermanent = 3
} _ERemoveSlotMode;

/*
** Namespace entry in SRN's namespace alloc table
*/
typedef struct _tag_NSEntry
{
    DRM_WORD  wMaxNumChildren;
    DRM_WORD  wPadding;
    DRM_DWORD nNSRBlockNum;                  /* block # of the Namespace Root node */
    DRM_BYTE  bNSName [__CB_DECL(DRM_HDS_NSNAME_SIZE)]; /* Namespace name */
} _NSEntry;


/*
** Super Root Node
*/
typedef struct _tag_SRN
{
    DRM_UINT64    ui64Timestamp;    /* updates every time SRN is updated */
    DRM_DWORD     dwSRNSize;        /* super root node size */
    DRM_DWORD     dwBlockSize;      /* File block size */
    DRM_DWORD     eBlockNumType;    /* DRM_HDSBLKNUM */
    DRM_DWORD     nFreeListHead;
    DRM_DWORD     nNsStoreRootBlockNum;
    DRM_DWORD     dwReserved;
    DRM_BYTE      bSRNHash [__CB_DECL(MD5DIGESTLEN)];    /* MD5 hash value of SRN */
} _SRN;

/*
** HDS context
*/
typedef struct _tag_Context
{
    OEM_CRITICAL_SECTION oCS;
    DRM_DWORD   dwContextSize;
    DRM_BOOL    fInited;
    DRM_DWORD   eContextSignature;
    OEM_FILEHDL fp;
    DRM_MD5_CTX contextMD5;
    DRM_DWORD   nGrowbySizeinKB;

    /* computed when HDS is 'opened' */
    DRM_DWORD   nImagesize_FileBlockHDR;     /* file image size of _CommBlockHDR, not including payload */
    DRM_DWORD   nImagesize_DataBlockHDR;     /* file image size of _DataBlockHDR, not including payload */
    DRM_DWORD   nImagesize_DataBlockPayload; /* payload size of a _DataBlockHDR */
    DRM_DWORD   nDataBlockPayloadPos;        /* payload pos from begining of a _DataBlockHDR */

    /* work buffer initialized when HDS is opened */
    DRM_STACK_ALLOCATOR_CONTEXT oHeap;

    _SRN oSRN;    /* super root node, pbStack points to the area after oSRN */
} _HdsContext;

/*
** HDS Config context
*/
typedef struct _tag_CfgContext
{
    DRM_DWORD wContextSize;
    DRM_DWORD eContextSignature;
    DRM_BOOL fInited;
    _HdsContext *pHDS;
    DRM_BYTE oNamespace[__CB_DECL(DRM_HDS_NSNAME_SIZE)];

    /* computed when a Namespace is 'used' */
    DRM_DWORD nCfgRootBlockNum;    
    DRM_DWORD wMaxNumChildren;                /* # of children of the current selected Namespace */
    DRM_DWORD nImagesize_ChildBlockHDR;       /* file image size of _ChildBlockHDR, not including payload */
    DRM_DWORD nImagesize_ChildAllocTable;     /* file image size of ChildAlloc table of _ChildBlockHDR and _NSRootBlock */
    DRM_DWORD nImagesize_ChildBlockPayload;   /* payload size of _ChildBlockHDR  */
    DRM_DWORD nChildBlockPayloadPos;          /* payload pos from begining of _ChildBlockHDR */
} _NsContext;


#define Memsize_FileBlock  SIZEOF(_CommBlockHDR)
typedef struct _tag_GenericBlockHeader {
    DRM_UINT64  ui64TimeStamp;
    DRM_BYTE    bBlockHash [__CB_DECL(MD5DIGESTLEN)];   /* MD5 hash of the above */
    DRM_DWORD   nParentBlockNum;
    DRM_BYTE    bBlockType;    
} _CommBlockFileHDR;    /*_FileImage; */

typedef struct _tag_FileBlock
{
    /* computed at run time */
    DRM_DWORD nBlockNum;   
    _NsContext *pNS;

    /* read from file */
    union 
    {        
        _CommBlockFileHDR _image;
        DRM_BYTE bFileImage[__CB_DECL(SIZEOF( _CommBlockFileHDR ))];
    } File;
} _CommBlockHDR;


typedef struct _tag_ChildBlockHeader 
{
    DRM_DWORD nFreeMem;
    DRM_BYTE bChildAllocTable [1];
} _ChildBlockFileHDR;


#define GetMemsize_ChildBlock(cfg)    (SIZEOF(_ChildBlockHDR)+(cfg)->nImagesize_ChildAllocTable)
#define GetMaxMemsize_ChildBlock()    (SIZEOF(_ChildBlockHDR)+(DRM_HDS_MAXIMUM_CHILDREN*eDRM_HDSBLKNUM_DWORD))
typedef struct _tag_ChildBlock
{
    _CommBlockHDR oBlockHeader;    /* derive from _CommBlockHDR */

    /* calculated during init'd */
    DRM_DWORD nCurrSlotPos;
    DRM_DWORD nNextSlotPos;
    DRM_DWORD nPayloadSize;
    union 
    {
        DRM_BYTE bFileImage[__CB_DECL(SIZEOF(_ChildBlockFileHDR))];
        _ChildBlockFileHDR _image;
    } File;
} _ChildBlockHDR;


typedef struct _tag_DataBlockHeader {
    DRM_DWORD nCascadingBlockNum;
} _DataBlockFileHDR;


#define GetMemsize_DataBlock()   SIZEOF(_DataBlockHDR)
typedef struct _tag_DataBlock
{
    _CommBlockHDR oBlockHeader;    /* derive from _CommBlockHDR */

    DRM_DWORD nPayloadSize;
    union 
    {
        DRM_BYTE bFileImage[__CB_DECL(SIZEOF(DRM_DWORD))];
        _DataBlockFileHDR _image;
    } File;
} _DataBlockHDR;



typedef enum
{
    eSlotIsNamespace = 0x00000001,
    eSlotIsHidden    = 0x00000002
} _ESlotAtributes;

/*
** record header structure precedes the actual storage of data record
*/
typedef struct _tag_SlotHeader
{
    DRM_DWORD dwSlotSize;           /* actual Data Record Size */
    DRM_DWORD dwAttributes;         /* Attributes for this slot (see _ESlotAtributes) */
    DRM_HDS_HASHKEY oHashkey; 
    DRM_HDS_UNIQUEKEY oUniquekey; 
} _SlotHeader;


/*
** License FindFirst /  FindNext context
*/
typedef struct _tag_SlotContext
{
    DRM_DWORD dwContextSize;
    DRM_DWORD eContextSignature;
    DRM_DWORD eStatus;
    _NsContext *pNS;
    DRM_HDS_LOCKMODE eLockMode;

    /* cache of search result for slot allocation */
    DRM_DWORD nBlockWithLargestFreeSpace;
    DRM_DWORD dwLargestSpace;

    _CommBlockHDR oFileBlock;      /* a copy of the file block in _ChildBlockHDR for verification purpose */
    _CommBlockHDR *pCurrChildBlock; /* pointer of the _ChildBlockHDR containing the Slot, pointing somewhere in bBuff */
    DRM_DWORD dwSlotPosInBlock;   /* the position in ChildBlock's payload where the slot is located (at begining _SlotHeader ) */
    _SlotHeader oSlotHeader;    /* Slot header record in _ChildBlockHDR */
    DRM_DWORD dwSeekPointer;      /* the current position in Slot where next slot read/write occurs */

    /* the following is valid if slot data is stored in _DataBlockHDR chain */
    DRM_DWORD dwNumofDataBlockVisited;  /* num of _DataBlockHDR visited not including current one */
    DRM_DWORD dwFirstDataBlockNum;    /* first _DataBlockHDR number in the chain */
    _CommBlockHDR *pCurrDataBlock;

    /* buffer to contain _ChildBlockHDR and _DataBlockHDR */
    DRM_BYTE bBuff [1];  /* size = dynamic size of _ChildBlockHDR + _DataBlockHDR */
} _SlotContext;


/*
** Slot Enum context
** this structure's size must be greater than or equal to CALC_MAXENUMCONTEXTLEN 
*/
typedef struct _tag_EnumContext
{
    DRM_DWORD wContextSize;
    DRM_DWORD eContextSignature;
    _NsContext *pNS;
    DRM_BOOL fInited;

    _CommBlockHDR oFileBlock;      /* a copy of the file block in _ChildBlockHDR for verification purpose */
    _SlotHeader oSlotHeader;    /* current slot header */

    DRM_HDS_LOCKMODE eLockMode;
    DRM_BOOL fIsQuery;             /* TRUE if oHashKey is not NULL, FALSE if enum all */
    DRM_HDS_HASHKEY oHashKey;  

    DRM_BOOL fCurrBlockIsValid;
    _CommBlockHDR oCurrBlock;  /* this field must be located at end of structure */
} _EnumContext;

typedef struct _tag_BlockScanContext
{
    DRM_DWORD                cbContext;
    DRM_DWORD                eContextSignature;
    _NsContext              *pcontextNS;
    DRM_BOOL                 fInited;
    _CommBlockHDR            blockheader;  /* a copy of the file block in _ChildBlockHDR for verification purpose */
    _SlotHeader              slotheader;   /* current slot header */
    DRM_HDS_LOCKMODE         lockmode;
    DRM_HDS_HASHKEY          keyHash;  
    const DRM_HDS_UNIQUEKEY *pkeyUnique;  /* array of KIDs to delete */
    DRM_DWORD                cKeysUnique; /* size of array */
    DRM_DWORD                cKeysFound;  /* number of KIDs marked for deletion thus far */
    DRM_DWORD                iKeyCurrent; /* index of next unmarked KID in the array */
    DRM_BOOL                 fCurrBlockIsValid;
    _CommBlockHDR            blockheaderCurrent;  /* this field must be located at end of structure */
} _BlockScanContext;

typedef struct _tag_SlotHint
{
    DRM_DWORD nSlotPosInBlock;
    DRM_DWORD nBlockNum;
} _SlotHint;

/* HDS context sizes */
#define DRM_HDS_CONTEXT_LEN HDS_CONTEXT_LENGTH(SIZEOF(_SRN))
#define DRM_HDS_NAMESPACE_CONTEXT_LEN (SIZEOF( _NsContext ))
#define DRM_HDS_SLOT_CONTEXT_LEN       CALC_MAXSLOTCONTEXTLEN
#define DRM_HDS_ENUM_CONTEXT_LEN       CALC_MAXENUMCONTEXTLEN
#define DRM_HDS_BLOCKSCAN_CONTEXT_LEN  CALC_MAXBLOCKSCANCONTEXTLEN
#define DRM_HDS_SLOT_HINT_LEN          (SIZEOF(_SlotHint))

#ifdef __cplusplus
}
#endif


#endif  /* _HDS_IMPL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmhmac.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMHMAC_H__
#define __DRMHMAC_H__

#include <drmsha1.h>

#ifdef __cplusplus
extern "C" {
#endif


typedef struct __tagHMAC_CONTEXT
{
	SHA_CONTEXT	shaContext;
	DRM_BYTE    shaDigest[__CB_DECL(SHA_DIGEST_LEN)];
	DRM_BYTE    rgbBuffer[__CB_DECL(SHA_BLOCK_SIZE)]; /* This is 64 bytes.  */
} HMAC_CONTEXT;


/*********************************************************************
**
**  Function:  HMACInit
**
**  Synopsis:  HMAC is a keyed-hash message authentication code.  It creates a
**             unique hash of data based on the data and an arbitrary key.
**
**  Arguments:  
**     [pcontextHMAC] -- Context structure to contain a running HMAC calculation.
**     [pbKey] -- Pointer a array of bytes to as the HMAC key.
**     [cbKey] -- Length of pbKey in bytes.
**
**  Notes:  This HMAC code uses SHA-1 as the Secure Hash
**
*********************************************************************/
DRM_RESULT DRM_API DRM_HMAC_Init(
    IN OUT   HMAC_CONTEXT *pcontextHMAC,
    IN const DRM_BYTE     *pbKey,
    IN       DRM_UINT      cbKey);


/*********************************************************************
**
**  Function:  DRM_HMAC_Update
**
**  Synopsis:  
**
**  Arguments:  
**     [pcontextHMAC] -- Valid HMAC_CONTEXT create with DRM_HMAC_Init
**     [pbData] -- Data to add the the secure hash
**     [cbData] -- Length of pbData in bytes
**
*********************************************************************/
DRM_RESULT DRM_API DRM_HMAC_Update(
    IN OUT   HMAC_CONTEXT *pcontextHMAC,
    IN const DRM_BYTE     *pbData,
    IN       DRM_UINT      cbData);

/*********************************************************************
**
**  Function:  DRM_HMAC_Finalize
**
**  Synopsis:  Closes the MHAC context and returns the computed secure hash.
**
**  Arguments:  
**     [pcontextHMAC] -- Valid HMAC_CONTEXT created with DRM_HMAC_Init
**     [pbKeyedHash] -- Pointer to byte array that will recieve the secure hash
**     [cbKeyedHash] -- Length of pbKeyedHash in bytes
**
**  Notes:  cbKeyedHash must be less than or equal to SHA_DIGEST_LEN and greater than 0.
*********************************************************************/
DRM_RESULT DRM_API DRM_HMAC_Finalize(
    IN OUT HMAC_CONTEXT *pcontextHMAC,
       OUT DRM_BYTE     *pbKeyedHash,
    IN     DRM_UINT      cbKeyedHash );


#ifdef __cplusplus
}
#endif

#endif /* __DRMHMAC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmint64.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/
#include <drmcommon.h>

#if DRM_NO_NATIVE_64_TYPES

#ifdef __TMS320C55X__
#include "tipatch.h"
static const  DRM_INT64  g_one  = {1, 0};
static const DRM_UINT64  g_uone = {1, 0};
#else
static const  DRM_INT64  g_one  = {1, 0, 0, 0, 0, 0, 0, 0};
static const DRM_UINT64  g_uone = {1, 0, 0, 0, 0, 0, 0, 0};
#endif          


static DRM_UINT64 _RemoveSign(const DRM_INT64 a, long * sa)
{   
    DRM_UINT64 aa;
    unsigned long int *pa, *pb;

    pa  = (unsigned long int *)&(a.val);
    pb  = (unsigned long int *)&(aa.val);
    *pb = *pa; 
    *(pb+1) = *(pa+1);
    *sa  = ((*(pa+1)) & 0x80000000);
    if (*sa) {
        *pb     = ~(*pb);
        *(pb+1) = ~(*(pb+1));
        aa = DRM_UI64Add(aa, g_uone);
    }                  
    return aa;
}

static void _SetBit(unsigned long int * pData, int loc)
{   
    long bit = 1;
    bit = bit << loc;
    *pData |= bit;
}

DRM_INT64 DRM_I64Add(const DRM_INT64 a, const DRM_INT64 b)
{ 
    /* Same as DRM_UI64Add */
    DRM_INT64 c;
    unsigned short int *upa, *upb, *upc;
    unsigned long int temp, carry, i;
    upa = (unsigned short int *)&(a.val);
    upb = (unsigned short int *)&(b.val);
    upc = (unsigned short int *)&(c.val);
    carry = 0;
#ifdef __TMS320C55X__    
    carry = 0;
    temp  = carry + *(upa+1) + *(upb+1);
    carry = temp >> 16;
    *(upc+1)  = temp;
    
    temp  = carry + *upa + *upb;
    carry = temp >> 16;
    *upc  = temp;
    
    temp  = carry + *(upa+3) + *(upb+3);
    carry = temp >> 16;
    *(upc+3)  = temp;
    
    temp  = carry + *(upa+2) + *(upb+2);
    carry = temp >> 16;
    *(upc+2)  = temp;
#else         
    carry = 0;
    for (i=0;i<4;i++) {
        temp  = (carry + *upa) + *upb;
        carry = temp >> 16;
        *upc  = (unsigned short)temp;
        upa++; upb++; upc++;
    } 
#endif    
    return c;
}


DRM_INT64 DRM_I64Sub(const DRM_INT64 a, const DRM_INT64 b)
{   
    DRM_INT64 nb;
    unsigned long int *pa, *pb;
    pa  = (unsigned long int *)&(nb.val);
    pb  = (unsigned long int *)&(b.val);
    *pa = ~(*pb); 
    pa++; pb++; 
    *pa = ~(*pb);
    return DRM_I64Add(a, DRM_I64Add(nb, g_one)) ;

}

DRM_INT64 DRM_I64Mul(const DRM_INT64 a, const DRM_INT64 b)
{   
    DRM_INT64  c;
    DRM_UINT64 aa, bb, cc;
    unsigned long int *pa, *pb;
    long sa, sb;

    aa = _RemoveSign(a,&sa) ;
    bb = _RemoveSign(b,&sb) ;

    cc = DRM_UI64Mul(aa, bb);
    if (sa ^ sb) {
        pa  = (unsigned long int *)&(cc.val);
        *pa     = ~(*pa);
        *(pa+1) = ~(*(pa+1));
        cc = DRM_UI64Add(cc, g_uone);
    }

    pa  = (unsigned long int *)&(cc.val);
    pb  = (unsigned long int *)&(c.val);
    *pb = *pa; 
    *(pb+1) = *(pa+1);

    return c;
}


DRM_INT64 DRM_I64Div(const DRM_INT64 a, const DRM_INT64 b)
{   
    DRM_INT64 c;
    DRM_UINT64 aa, bb, cc;
    unsigned long int *pa, *pb;
    long sa, sb;

    aa = _RemoveSign(a,&sa) ;
    bb = _RemoveSign(b,&sb) ;

    cc = DRM_UI64Div(aa, bb);
    if (sa ^ sb) {
        pa  = (unsigned long int *)&(cc.val);
        *pa     = ~(*pa);
        *(pa+1) = ~(*(pa+1));
        cc = DRM_UI64Add(cc, g_uone);
    }

    pa  = (unsigned long int *)&(cc.val);
    pb  = (unsigned long int *)&(c.val);
    *pb = *pa; 
    *(pb+1) = *(pa+1);

    return c;
}


DRM_INT64 DRM_I64Mod(const DRM_INT64 a, const DRM_INT64 b)
{   
    DRM_INT64 c;
    DRM_UINT64 aa, bb, cc;
    unsigned long int *pa, *pb;
    long sa, sb;

    aa = _RemoveSign(a,&sa) ;
    bb = _RemoveSign(b,&sb) ;

    cc = DRM_UI64Mod(aa, bb);

    if (sa) {
        pa  = (unsigned long int *)&(cc.val);
        *pa     = ~(*pa);
        *(pa+1) = ~(*(pa+1));
        cc = DRM_UI64Add(cc, g_uone);
    }

    pa  = (unsigned long int *)&(cc.val);
    pb  = (unsigned long int *)&(c.val);
    *pb = *pa; 
    *(pb+1) = *(pa+1);

    return c;
}


DRM_INT64 DRM_I64And(const DRM_INT64 a, const DRM_INT64 b)
{   
    DRM_INT64 c;
    long int *pa, *pb, *pc;
    pa = (long int *)&(a.val);
    pb = (long int *)&(b.val);
    pc = (long int *)&(c.val);

    *pc = *pa & *pb;
    pc++; pa++; pb++;
    *pc = *pa & *pb;
    return c;
}


DRM_INT64 DRM_I64ShR(const DRM_INT64 a, const unsigned int b)
{
    DRM_INT64 c;
    unsigned long int *upa, *upc, td;
    long int *pa, *pc;
    upa = (unsigned long int *)&(a.val);
    upc = (unsigned long int *)&(c.val);
    pa  = (long int *)&(a.val);
    pc  = (long int *)&(c.val);

    if (b > 63) {
        if ( *(pa+1) < 0 ) {
            *upc++ = 0xFFFFFFFF;
            *upc   = 0xFFFFFFFF;
        } else {
            *upc++ = 0;
            *upc = 0;
        }
    }
    else if (b > 31){
        *pc = *(pa+1) >> (b - 32);
        pc++; 
        *pc = *(pa+1)<0 ? 0xFFFFFFFF : 0;
    }
    else if (b > 0) {
        *upc = *upa >> b;
        td  = *(upa+1) << (32 - b);
        *upc |= td;
        pc++; pa++;
        *pc = *pa >> b;
    }
    else {
        *upc = *upa ;
        upc++; upa++;
        *upc = *upa ;
    }
    return c;



}


DRM_INT64 DRM_I64ShL(const DRM_INT64 a, const unsigned int b)
{ 
    DRM_INT64 c;
    unsigned long int *pa, *pc, td;
    pa = (unsigned long int *)&(a.val);
    pc = (unsigned long int *)&(c.val);

    if (b > 63) {
        *pc = 0;
        pc++; 
        *pc = 0;
    }
    else if (b > 31){
        *pc = 0;
        pc++; 
        *pc = *pa << (b - 32);
    }
    else if (b >0) {
        *pc = *pa << b;
        td  = *pa >> (32 - b);
        pc++; pa++;
        *pc = *pa << b;
        *pc |= td;
    }
    else {
        *pc = *pa ;
        pc++; pa++;
        *pc = *pa ;
    }
    return c;
}


int DRM_I64Eql(const DRM_INT64 a, const DRM_INT64 b)
{ 
    long int *pa, *pb;
    pa = (long int *)&(a.val);
    pb = (long int *)&(b.val);

    return ((*pa == *pb)&&(*(pa+1) == *(pb+1)));

}


int DRM_I64Les(const DRM_INT64 a, const DRM_INT64 b)
{
    long int *pa = (long int *) &(a.val);
    long int *pb = (long int *) &(b.val);

    if (*(pa+1) == *(pb+1))
    {
        /* high 32-bits are equal,
        ** so just compare low 32-bits
        */
        return (*(unsigned long int *)pa < *(unsigned long int *)pb);
    }
    else 
    {
        if ((*(pa+1)) & 0x80000000)
        {
            if((*(pb+1)) & 0x80000000)
            {
                /* a and b are both negative,
                ** so compare high bytes using 'greater than'
                */
                return (*(unsigned long int *)(pa+1) > *(unsigned long int *)(pb+1));
            }
            else
            {
                /* a is negative, b is positive,
                ** so a is less than b
                */
                return 1;
            }
        }
        else
        {
            if((*(pb+1)) & 0x80000000)
            {
                /* a is positive, b is negative, 
                ** so a is not less than b
                */
                return 0;
            }
            else
            {
                /* a and b are both positive and not equal,
                ** so just compare the high bytes
                */
                return (*(pa+1) < *(pb+1));
            }
        }
    }
}


DRM_INT64 DRM_I64(const long int b)
{   
    DRM_INT64 c;
    long int *pa;
    pa = (long int *)&(c.val);
    *pa = b;
    pa++;
    if( b & 0x80000000 )
    {
        /* Make sure we sign extend correctly */
        *pa = 0xFFFFFFFF;
    }
    else
    {
        *pa = 0;
    }
    
    return c;
}         


DRM_INT64 DRM_I64Asgn(const long int a, const long int b)
{
    DRM_INT64 c;
    long int *pa;
    pa = (long int *)&(c.val);
    *pa = b;
    pa++;
    *pa = a;
    
    return c;
}


DRM_INT64 DRM_UI2I64(const DRM_UINT64 b)
{   
    DRM_INT64 c;
    long int *pa, *pb;
    pa = (long int *)&(c.val);
    pb = (long int *)&(b.val);
    *pa = *pb;
    pa++; pb++;
    *pa = *pb;
    
    return c;
}


unsigned long int DRM_I64ToUI32(const DRM_INT64 b)
{   
    unsigned long int *pa;
    pa = (unsigned long int *)&(b.val);
    
    return *pa;
}


DRM_UINT64 DRM_UI64Add(const DRM_UINT64 a, const DRM_UINT64 b)
{
    DRM_UINT64 c;
    unsigned short int *upa, *upb, *upc;
    unsigned long int temp, carry, i;
    upa = (unsigned short int *)&(a.val);
    upb = (unsigned short int *)&(b.val);
    upc = (unsigned short int *)&(c.val);
#ifdef __TMS320C55X__    
    carry = 0;
    temp  = carry + *(upa+1) + *(upb+1);
    carry = temp >> 16;
    *(upc+1)  = temp;
    
    temp  = carry + *upa + *upb;
    carry = temp >> 16;
    *upc  = temp;
    
    temp  = carry + *(upa+3) + *(upb+3);
    carry = temp >> 16;
    *(upc+3)  = temp;
    
    temp  = carry + *(upa+2) + *(upb+2);
    carry = temp >> 16;
    *(upc+2)  = temp;
#else         
    carry = 0;
    for (i=0;i<4;i++) {
        temp  = carry + *upa + *upb;
        carry = temp >> 16;
        *upc  = (unsigned short)temp;
        upa++; upb++; upc++;
    } 
#endif    
    return c;
}


DRM_UINT64 DRM_UI64Sub(const DRM_UINT64 a, const DRM_UINT64 b)
{   
    DRM_UINT64 nb;
    unsigned long int *pa, *pb;
    pa  = (unsigned long int *)&(nb.val);
    pb  = (unsigned long int *)&(b.val);
    *pa = ~(*pb);
    pa++; pb++; 
    *pa = ~(*pb);
    return DRM_UI64Add(a, DRM_UI64Add(nb, g_uone)) ;
}


DRM_UINT64 DRM_UI64Mul(const DRM_UINT64 a, const DRM_UINT64 b)
{   
    DRM_UINT64 c;
    DRM_BOOL fZero = TRUE;
    DRM_LONG i; 
    DRM_LONG j; 
    DRM_LONG carry; 
    DRM_LONG temp;
               
#ifdef __TMS320C55X__    
    DRM_BYTE aa[8], bb[8], cc[8];
    
    DRM_LONG2CHARS(a.val[0], aa  );
    DRM_LONG2CHARS(a.val[1], aa+4);
    DRM_LONG2CHARS(b.val[0], bb  );
    DRM_LONG2CHARS(b.val[1], bb+4);
#endif

    for (i = 0; i < NO_OF(a.val); i++)
    {
        if (a.val [i] != 0
        ||  b.val [i] != 0)
        {
            fZero = FALSE;
            break;
        }
    }
    
    if (fZero)
    {
        for (i = 0; i < NO_OF(c.val); i++)
        {
            c.val [i] = 0;
        }
        
        return c;
    }
	 
    carry = 0;

    for (i = 0; i < 8; i++) {
        temp = carry;
        for (j=0;j<=i;j++) {
#ifdef __TMS320C55X__
            temp += aa[j] * bb[(i-j)];
#else
            temp += a.val[j] * b.val[(i-j)];
#endif            
        }
        carry = temp >> 8;
#ifdef __TMS320C55X__        
        cc[i] = temp & 0xFF;
#else
        c.val[i] = (unsigned char)temp;
#endif        
    }

#ifdef __TMS320C55X__        
    c.val[0] =  DRM_CHARS2LONG(cc);
    c.val[1] =  DRM_CHARS2LONG(cc+4);
#endif    
    return c;
}

#ifdef __TMS320C55X__
#   define TEST_TOP_BIT(x) (x.val[1]&0x80000000)
#   define TEST_BIT(x,b) ( x.val[(b)>>5]&(1<<((b)&0x1f)) )
#else
#   define TEST_TOP_BIT(x) (x.val[7]&0x80)
#   define TEST_BIT(x,b) ( x.val[(b)>>3]&(1<<((b)&7)) )
#endif


DRM_UINT64 DRM_UI64Div(const DRM_UINT64 a, const DRM_UINT64 b)
{
    DRM_UINT64 c, aa, bb;
    unsigned long int *pc, *pb, td;

    pb = (unsigned long int *)&(b.val);
    pc = (unsigned long int *)&(c.val);

    aa = a;
    bb = b;
    *pc = 0; *(pc+1) = 0;
    if (DRM_UI64Les(a, b) || ((*pb==0) && (*(pb+1)==0)) ) 
        return c;

    while(!DRM_UI64Les(aa,bb)) { 
        td = 1;
        if ( !TEST_TOP_BIT(b) ) {
            while(1) {
                if ( TEST_BIT(b,64-td) )
                    break;  /* b > aa if a has top bit on and b will shift a bit off msb */
                if ( DRM_UI64Les(aa,DRM_UI64ShL(b,td)) )
                    break;
                td++;
            }
        }
        td--;

        if (td > 31)
            _SetBit(pc+1, td-32);
        else
            _SetBit(pc, td);

        aa = DRM_UI64Sub(aa,DRM_UI64ShL(b,td));
    }
    return c;
}


DRM_UINT64 DRM_UI64Mod(const DRM_UINT64 a, const DRM_UINT64 b)
{
    DRM_UINT64 aa, bb;
    unsigned long int td, *pb;

    pb = (unsigned long int *)&(b.val);

    aa = a;
    bb = b;
    if (DRM_UI64Les(aa, bb)) {
        return aa;
    }
    if ( (*pb==0) && (*(pb+1)==0) )
        return b;

    while(!DRM_UI64Les(aa,bb)) { 
        td = 1;
        if ( !TEST_TOP_BIT(b) ) {
            while(1) {
                if ( TEST_BIT(b,64-td) )
                    break;  /* b > aa if a has top bit on and b will shift a bit off msb */
                if ( DRM_UI64Les(aa,DRM_UI64ShL(b,td)) )
                    break;
                td++;
            }
        }
        td--;

        aa = DRM_UI64Sub(aa,DRM_UI64ShL(b,td));
    }
    return aa;
}


DRM_UINT64 DRM_UI64And(const DRM_UINT64 a, const DRM_UINT64 b)
{   
    DRM_UINT64 c;
    long int *pa, *pb, *pc;
    pa = (long int *)&(a.val);
    pb = (long int *)&(b.val);
    pc = (long int *)&(c.val);

    *pc = *pa & *pb;
    pc++; pa++; pb++;
    *pc = *pa & *pb;
    return c;
}


DRM_UINT64 DRM_UI64ShR(const DRM_UINT64 a,const unsigned int b)
{
    DRM_UINT64 c;
    unsigned long int *pa, *pc, td;
    pa = (unsigned long int *)&(a.val);
    pc = (unsigned long int *)&(c.val);

    if (b > 63) {
        *pc = 0;
        pc++; 
        *pc = 0;
    }
    else if (b > 31){
        *pc = *(pa+1) >> (b - 32);
        pc++; 
        *pc = 0;
    }
    else if (b > 0) {
        *pc = *pa >> b;
        td  = *(pa+1) << (32 - b);
        *pc |= td;
        pc++; pa++;
        *pc = *pa >> b;
    }
    else {
        *pc = *pa ;
        pc++; pa++;
        *pc = *pa ;
    }
    return c;

}


DRM_UINT64 DRM_UI64ShL(const DRM_UINT64 a,const unsigned int b)
{   
    DRM_UINT64 c;
    unsigned long int *pa, *pc, td;
    pa = (unsigned long int *)&(a.val);
    pc = (unsigned long int *)&(c.val);

    if (b > 63) {
        *pc = 0;
        pc++; 
        *pc = 0;
    }
    else if (b > 31){
        *pc = 0;
        pc++; 
        *pc = *pa << (b - 32);
    }
    else if (b >0) {
        *pc = *pa << b;
        td  = *pa >> (32 - b);
        pc++; pa++;
        *pc = *pa << b;
        *pc |= td;
    }
    else {
        *pc = *pa ;
        pc++; pa++;
        *pc = *pa ;
    }
    return c;
}


int DRM_UI64Eql(const DRM_UINT64 a, const DRM_UINT64 b)
{   
    long int *pa, *pb;
    pa = (long int *)&(a.val);
    pb = (long int *)&(b.val);

    return ((*pa == *pb)&&(*(pa+1) == *(pb+1)));
}


int DRM_UI64Les(const DRM_UINT64 a, const DRM_UINT64 b)
{   
    unsigned long int *pa, *pb;
    pa = (unsigned long int *)&(a.val);
    pb = (unsigned long int *)&(b.val);

    if (*(pa+1) != *(pb+1))
        return (*(pa+1) < *(pb+1));
    else
        return (*pa < *pb);
}


DRM_UINT64 DRM_UI64(const unsigned long int b)
{   
    DRM_UINT64 c;
    unsigned long int *pa;
    pa = (unsigned long int *)&(c.val);
    *pa = b;
    pa++;
    *pa = 0;
    
    return c;
}

DRM_UINT64 DRM_UI64HL(const unsigned long int a, const unsigned long int b)
{   
    DRM_UINT64 c;
    unsigned long int *pa;
    pa = (unsigned long int *)&(c.val);
    *pa = b;
    pa++;
    *pa = a;    
    return c;
}

unsigned long int DRM_UI64High32( DRM_UINT64 a )
{   
    unsigned long int *pa;
    pa = (unsigned long int *)&(a.val);    
    pa++;
    return *pa;
}

unsigned long int DRM_UI64Low32( DRM_UINT64 a )
{   
    unsigned long int *pa;
    pa = (unsigned long int *)&(a.val);    
    return *pa;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmkeygenerator.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMKEYGEN_H__
#define __DRMKEYGEN_H__


#ifdef __cplusplus
extern "C" {
#endif


#define DRM_CONTENT_KEY_LENGTH  7
#define DRM_KEYSEED_LEN        40

/**************
  NOTE:  All Keygen functions include a NULL termination character
  in the character count and the string on function return
**************/

/**********************************************************************
** Function:    DRM_KG_GenerateKeyseed
** Synopsis:    Generate pseudo random keyseed
** Arguments:   [pwszKeyseed] -- Pointer of Unicode string to receive the keyseed
**              [pchKeyseed] -- size in chars of pwszKeyseed
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
DRM_RESULT DRM_API DRM_KG_GenerateKeyseed(
       OUT DRM_WCHAR *pwszKeyseed,
    IN OUT DRM_DWORD *pcchKeyseed);

/**********************************************************************
** Function:    DRM_KG_GenerateKeyID
** Synopsis:    Generate pseudo random Key ID 
** Arguments:   [pwszKeyseed] -- Pointer of Unicode string to receive the keyseed
**              [pchKeyseed] -- size in chars of pwszKeyseed
** Returns:     DRM_SUCCESS on success
** Notes:       
***********************************************************************
*/
DRM_RESULT DRM_API DRM_KG_GenerateKeyID(
       OUT DRM_WCHAR *pwszKeyID,           /* base64 encoded string */
    IN OUT DRM_DWORD *pcchKeyID);


/*******************************************************************************
** Function:   DRMGenerateKey
** Parameters: 
**      [in] pbKeySeed:    A byte array representing seed.
**      [in] cbKeySeed:    The length of the pbKeySeed field
**      [in] pbKId:        The key id (KID). Normally, this is base-64 encoded guid.
**      [in] cbKId:        The length of the pbKId field.
**      [out] pwszContentKey: base64  
**      [in] pcchContentKey: 
** Purpose:
**      To generate the key for a given kid based on a license key seed of length up to 20 bytes.
********************************************************************************/
DRM_RESULT DRM_API DRM_KG_GenerateContentKey(
    IN     DRM_WCHAR *pwszKeySeed,          /* base64 encoded string */
    IN     DRM_DWORD  cchKeySeed, 
    IN     DRM_WCHAR *pwszKeyID,            /* base64 encoded string */
    IN     DRM_DWORD  cchKeyID, 
       OUT DRM_WCHAR *pwszContentKey,      /* base64 encoded string */
    IN OUT DRM_DWORD *pcchContentKey);


/*******************************************************************************
** Function:    DRM_KG_GenerateSigningKeys
** Synopsis:    Generate signing key pair. Generated key pair will be base64 encoded
** Arguments:   [pCrypto] -- pointer to PKCrypto context
**              [pwszPrivKey] -- pointer to unicode string to receive the generated priv key
**              [pcchPrivKey] -- length in char of pwszPrivKey
**              [pwszPubKey] -- pointer to unicode string to receive the generated pub key
**              [pcchPubKey] -- length in char of pwszPubkey
** Returns:     DRM_SUCCESS on success
** Notes:       
********************************************************************************/
DRM_RESULT DRM_API DRM_KG_GenerateSigningKeys(
    IN     DRM_CRYPTO_CONTEXT *pCrypto,
       OUT DRM_WCHAR          *pwszPrivKey,         /* base64 encoded string */
    IN OUT DRM_DWORD          *pcchPrivKey,
       OUT DRM_WCHAR          *pwszPubKey,          /* base64 encoded string */
    IN OUT DRM_DWORD          *pcchPubKey);


#ifdef __cplusplus
}
#endif

#endif /*__DRMKEYGEN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmint64.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMINT64_H__
#define __DRMINT64_H__


#ifdef __cplusplus 
extern "C"
{
#endif

#if DRM_NO_NATIVE_64_TYPES

#ifdef __TMS320C55X__

typedef struct _DRM_INT64 { 
    unsigned long val[2];
} DRM_INT64;

typedef struct _DRM_UINT64 {   
    unsigned long val[2];
} DRM_UINT64;

#else /* __TMS320C55X__ */

typedef struct _DRM_INT64 { 
    unsigned char val[8];
} DRM_INT64;

typedef struct _DRM_UINT64 {   
    unsigned char val[8];
} DRM_UINT64;

#endif /* ! __TMS320C55X__ */

extern DRM_INT64 DRM_I64Add(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_INT64 DRM_I64Sub(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_INT64 DRM_I64Mul(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_INT64 DRM_I64Div(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_INT64 DRM_I64Mod(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_INT64 DRM_I64And(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_INT64 DRM_I64ShR(const DRM_INT64 a, const int unsigned b);
extern DRM_INT64 DRM_I64ShL(const DRM_INT64 a, const int unsigned b);
extern int       DRM_I64Eql(const DRM_INT64 a, const DRM_INT64 b);
extern int       DRM_I64Les(const DRM_INT64 a, const DRM_INT64 b);
extern DRM_INT64 DRM_I64(const long int b);
extern DRM_INT64 DRM_I64Asgn(const long int a, const long int b);
extern DRM_INT64 DRM_UI2I64(const DRM_UINT64 b);
extern unsigned long int DRM_I64ToUI32(const DRM_INT64 b);

extern DRM_UINT64 DRM_UI64Add(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_UINT64 DRM_UI64Sub(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_UINT64 DRM_UI64Mul(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_UINT64 DRM_UI64Div(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_UINT64 DRM_UI64Mod(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_UINT64 DRM_UI64And(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_UINT64 DRM_UI64ShR(const DRM_UINT64 a, const unsigned int b);
extern DRM_UINT64 DRM_UI64ShL(const DRM_UINT64 a, const unsigned int b);
extern int        DRM_UI64Eql(const DRM_UINT64 a, const DRM_UINT64 b);
extern int        DRM_UI64Les(const DRM_UINT64 a, const DRM_UINT64 b);
extern DRM_UINT64 DRM_UI64(const unsigned long int b);

extern DRM_UINT64 DRM_UI64HL(const unsigned long int a, const unsigned long int b);
extern unsigned long int DRM_UI64High32( DRM_UINT64 a );
extern unsigned long int DRM_UI64Low32( DRM_UINT64 a );

#define DRM_UI64LITERAL(a,b) { a, b }

#define FILETIME_TO_UI64( ft, ui64 ) {ui64=DRM_UI64HL((ft).dwHighDateTime,(ft).dwLowDateTime);}
#define UI64_TO_FILETIME( ui64, ft ) {(ft).dwLowDateTime=DRM_UI64Low32(ui64);(ft).dwHighDateTime=DRM_UI64High32((ui64));}
#define NATIVE64_TO_NONNATIVE64( ui64 ) {ui64=DRM_UI64HL(DRM_UI64Low32(ui64),DRM_UI64High32(ui64));} /* Reverse the high and low */

#else

#if defined (_MSC_VER)

typedef          __int64 DRM_INT64;
typedef unsigned __int64 DRM_UINT64;

#elif defined (__GNUC__)

typedef          long long int DRM_INT64;
typedef unsigned long long int DRM_UINT64;

#endif

#define DRM_I64LITERAL(a,b) (DRM_INT64)(((DRM_INT64)a)<<32|b)
#define DRM_UI64LITERAL(a,b)(DRM_UINT64)(((DRM_UINT64)a)<<32|b)

#define FILETIME_TO_UI64( ft, ui64 ) { (ui64) = *((DRM_UINT64*)&(ft)); } 
#define UI64_TO_FILETIME( ui64, ft ) { (ft)   = *((DRMFILETIME*)&(ui64)); }
#define NATIVE64_TO_NONNATIVE64( ui64 )  

#define DRM_I64Add(a, b) ( (a) + (b) )
#define DRM_I64Sub(a, b) ( (a) - (b) )
#define DRM_I64Mul(a, b) ( (a) * (b) )
#define DRM_I64Div(a, b) ( (a) / (b) )
#define DRM_I64Mod(a, b) ( (a) % (b) )
#define DRM_I64And(a, b) ( (a) & (b) )
#define DRM_I64ShR(a, b) ( (a) >> (b) )
#define DRM_I64ShL(a, b) ( (a) << (b) )
#define DRM_I64Eql(a, b) ( (a) == (b) )
#define DRM_I64Les(a, b) ( (a) < (b) )
#define DRM_I64(b) ( (DRM_INT64) (b) )
#define DRM_I64Asgn(a, b) (((DRM_INT64)(a)<<32) | (b))
#define DRM_UI2I64(b) ((DRM_INT64)(b))

#define DRM_I64ToUI32(b) ((DRM_ULONG)(b))


#define DRM_UI64Add(a, b) ( (a) + (b) )
#define DRM_UI64Sub(a, b) ( (a) - (b) )
#define DRM_UI64Mul(a, b) ( (a) * (b) )
#define DRM_UI64Div(a, b) ( (a) / (b) )
#define DRM_UI64Mod(a, b) ( (a) % (b) )
#define DRM_UI64And(a, b) ( (a) & (b) )
#define DRM_UI64ShR(a, b) ( (a) >> (b) )
#define DRM_UI64ShL(a, b) ( (a) << (b) )
#define DRM_UI64Eql(a, b) ( (a) == (b) )
#define DRM_UI64Les(a, b) ( (a) < (b) )
#define DRM_UI64(b) ( (DRM_UINT64) (b) )

#define DRM_UI64HL(a,b) (((DRM_UINT64)(a)<<32) | (b))
#define DRM_UI64High32(a) ((unsigned long int)(a>>32))
#define DRM_UI64Low32(a) ((unsigned long int)(a&DRM_UI64LITERAL(0,0xFFFFFFFF)))

#endif

#ifdef __cplusplus 
}
#endif

#endif /* __DRMINT64_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmlicacqreq.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#if DRM_SUPPORT_DLA
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmlicacq.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <drmlicense.h>
#include <drmsha1.h>
#include <oemimpl.h>


/*************************************************************************
** static functions
**************************************************************************/

static DRM_DWORD _NumberWidth(DRM_DWORD dwNumber)
{
    DRM_DWORD cchNumber = 1;
    
    while (dwNumber > 10)
    {
        dwNumber /= 10;
        cchNumber++;
    }
    
    return cchNumber;
}

static DRM_DWORD _RequiredCharsForCLIENTINFOBlock (DRM_DWORD  levelAppSecurity,
                                                   DRM_DWORD  idSubject,
                                                   DRM_DWORD  cchSecurityVersion,
                                                   DRM_DWORD  cchClientVersion,
                                                   DRM_DWORD  cchDevcert,
                                                   DRM_DWORD  idSubject2,
                                                   DRM_DWORD  cchDrmkversion)
{
    DRM_DWORD cchRequired = 0;
    
    /* <CLIENTINFO> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagClientInfo.cchString, 0, 0, 0);
    
    /* <CLIENTID> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagClientID.cchString,    
                                                 CCH_BASE64_EQUIV (SIZEOF (CLIENTID)), 0, 0);
    
    /* <CLIENTVERSION> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagClientVersion    .cchString, 
                                                 cchClientVersion, 0, 0);
    
    /* <SECURITYVERSION> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrTagSecurityVersion.cchString,      
                                                 cchSecurityVersion, 0, 0);
    
    /* <APPSECURITY> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagAppSecurity.cchString,      
                                   _NumberWidth (levelAppSecurity), 0, 0);
    
    /* <SUBJECTID1> */
    
    cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagSubjectID1.cchString,       
                                   _NumberWidth (idSubject), 0, 0);
    
    /* <SUBJECTID2> */

    if ( idSubject2 > 0 )
    {
        cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagSubjectID2.cchString,    
                                       _NumberWidth (idSubject2), 0, 0);
    }
    else
    {
        cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagSubjectID2.cchString,    
                                                     0, 0, 0);
    }
    
   
    /* <DRMKVERSION> */

    if ( cchDrmkversion > 0 )
    {
        cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagDrmkVersion.cchString,    
                                                     cchDrmkversion, 0, 0);
    }
    else
    {
        cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrReqTagDrmkVersion.cchString,    
                                                     0, 0, 0);
    }


    /* <DEVCERT> if it is there */


    if (cchDevcert != 0)
    {
        cchRequired += DRM_XMB_RequiredCharsForTag (g_dstrTagDevCert.cchString, 
                                                    CCH_BASE64_ENC_LARGE_WCH(cchDevcert), 0, 0);
    }

    
    return cchRequired;
}

/******************************************************************************
 *                PRIVATE FUNCTION _RequiredCharsForRequest 
 *
 * calculate buffer requirement to build the license request
 *****************************************************************************/

static DRM_DWORD _RequiredCharsForRequest (IN DRM_LICENSE_CHALLENGE *f_plicensechallenge)
{
    DRM_DWORD cchRequired = 0;
    
    cchRequired  = DRM_XMB_RequiredCharsForTag (g_dstrTagLicenseRequest    .cchString, 
                                                0,
                                                g_dstrAttributeVersion     .cchString,
                                                g_dstrAttributeVersionValue.cchString);
    
    cchRequired += DRM_XMB_RequiredCharsForTag (g_dstrTagV1Challenge.cchString,
                                                CCH_CDATA_REQUIRED (&f_plicensechallenge->dstrV1Challenge),
                                                0,
                                                0);
 
    if (f_plicensechallenge->cUplinks > 0)
    {        
        DRM_DWORD cchUplink  = 0;
        
        cchRequired  += DRM_XMB_RequiredCharsForTag (g_dstrTagUplinks.cchString, 0, 0, 0);

        cchUplink    = DRM_XMB_RequiredCharsForTag (g_dstrTagUplink.cchString, 
                                                    CCH_BASE64_EQUIV (SIZEOF (DRM_LICENSE_STATE_DATA)),
                                                    g_dstrTagKID.cchString, 
                                                    CCH_BASE64_EQUIV (SIZEOF (DRM_KID)));
        
        cchRequired += CCH_BASE64_ENC_LARGE_WCH(f_plicensechallenge->cUplinks * cchUplink);
    } /* end if cUplinks > 0 */

    if (f_plicensechallenge->cRights > 0)
    {
        DRM_DWORD iRight = 0;
        
        cchRequired += DRM_XMB_RequiredCharsForTag (g_dstrTagActionList.cchString, 0, 0, 0);

        for (iRight = 0; 
             iRight < f_plicensechallenge->cRights; 
             iRight++)
        {
            cchRequired += DRM_XMB_RequiredCharsForTag (g_dstrTagAction.cchString,
                                                        f_plicensechallenge->ppdstrRights [iRight]->cchString,
                                                        0,
                                                        0);
        }                                                     
    } /* end if cRights > 0 */

    if (f_plicensechallenge->dstrClientIdentity.cchString != 0)
    {
        cchRequired += f_plicensechallenge->dstrClientIdentity.cchString;
    }
    else
    {
        cchRequired += _RequiredCharsForCLIENTINFOBlock (f_plicensechallenge->levelAppSecurity,
                                                         f_plicensechallenge->idSubject,
                                                         wcslen(f_plicensechallenge->pwszBBVer),
                                                         g_dstrReqTagClientVersionData.cchString,
                                                         f_plicensechallenge->dstrDeviceCert.cchString,
                                                         0,
                                                         0);
    }
    
    /* the header is added as a formed XML node */
    
    cchRequired += f_plicensechallenge->dstrHeader.cchString;

    return cchRequired;
}

/******************************************************************************
 *                PRIVATE FUNCTION _WriteUplinkNode
 *
 * write the <UPLINKS> section and its subnodes
 *****************************************************************************/

static DRM_RESULT _WriteUplinkNode (IN DRM_LICENSE_CHALLENGE *f_plicensechallenge)
{
    DRM_DWORD iUplink = 0;
    DRM_RESULT dr     = DRM_SUCCESS;
    
    ChkDR(DRM_XMB_WriteTag (f_plicensechallenge->pbXML,     /* <UPLINKS> */
                            &g_dstrTagUplinks,
                             NULL,
                             NULL,
                             NULL,
                             wttOpen));
    
    for (iUplink = 0; 
         iUplink < f_plicensechallenge->cUplinks;  
         iUplink++)
    {
        DRM_DWORD        cchEncoded    = CCH_BASE64_EQUIV(SIZEOF (DRM_LICENSE_STATE_DATA));
        DRM_CONST_STRING dstrStateData = EMPTY_DRM_STRING;

        dstrStateData.pwszString = (DRM_WCHAR *) f_plicensechallenge->rgbStack;
        dstrStateData.cchString  =  cchEncoded;

        ChkDR(DRM_B64_EncodeW((DRM_BYTE *) (f_plicensechallenge->rglicensestatedata + iUplink), 
                               SIZEOF (DRM_LICENSE_STATE_DATA), 
                              (DRM_WCHAR *) f_plicensechallenge->rgbStack, 
                              &cchEncoded, 
                               DRM_BASE64_ENCODE_WMDRM));
                                
        ChkDR(DRM_XMB_WriteTag(f_plicensechallenge->pbXML,             /* <UPLINK KID = "B64">B64B64B64</UPLINK> */  
                              &g_dstrTagUplink,
                              &dstrStateData, 
                              &g_dstrTagKID, 
                               f_plicensechallenge->rgdstrUplinkKID + iUplink,
                               wttClosed));
    }

    ChkDR(DRM_XMB_EncryptAndCloseCurrNode(f_plicensechallenge->pbXML, 
                                         &(f_plicensechallenge->pcontextBBX->CryptoContext),
                                         &g_pubkeyLicenseServer, 
                                          NULL)); /* </UPLINKS> */ 
    
ErrorExit:

    return dr;    
}

/******************************************************************************
 *                PRIVATE FUNCTION _WriteActionsNode
 *
 * write the <ACTIONS> section and its subnodes
 *****************************************************************************/

static DRM_RESULT _WriteActionsNode (IN DRM_LICENSE_CHALLENGE *f_plicensechallenge)
{
    DRM_DWORD  iRight = 0;
    DRM_RESULT dr     = DRM_SUCCESS;
    
    ChkDR(DRM_XMB_WriteTag (f_plicensechallenge->pbXML,      /* <ACTIONLIST> */
                            &g_dstrTagActionList,
                             NULL,
                             NULL,
                             NULL,
                             wttOpen));

    for (iRight = 0; 
         iRight < f_plicensechallenge->cRights;
         iRight++)
    {
        ChkDR(DRM_XMB_WriteTag (f_plicensechallenge->pbXML, /* <ACTION> */
                                &g_dstrTagAction,
                                 f_plicensechallenge->ppdstrRights [iRight],
                                 NULL,
                                 NULL,
                                 wttClosed));
    }

    ChkDR(DRM_XMB_CloseCurrNode (f_plicensechallenge->pbXML, NULL)); /* </ACTIONLIST> */
                                      
ErrorExit:

    return dr;                                      
}

/*
** Add the following node/subnode to the request:
**
** <CLIENTINFO>
**    <CLIENTID>...</CLIENTID>
**    <CLIENTVERSION>...</CLIENTVERSION>
**    <SECURITYVERSION>...</SECURITYVERSION>
**    <APPSECURITY>...</APPSECURITY>
**    <SUBJECTID1>...</SUBJECTID1>
**    <SUBJECTID2>...</SUBJECTID2>
**    <DRMKVERSION>...</DRMKVERSION>
**    <DEVCERT>...</DEVCERT> optional
** </CLIENTINFO>
*/

static DRM_RESULT _AddClientInfo (IN DRM_LICENSE_CHALLENGE *f_plicensechallenge)
{
    DRM_RESULT       dr           = DRM_SUCCESS;
    DRM_DWORD        cchEncoded   = CCH_BASE64_EQUIV (SIZEOF (CLIENTID));
    DRM_DWORD        cbXml        = 0;
    DRM_CONST_STRING dstrScratch  = EMPTY_DRM_STRING;
    

    ChkArg (f_plicensechallenge != NULL);

    DRMCASSERT (SIZEOF (f_plicensechallenge->rgbStack) >= CCH_BASE64_EQUIV (SIZEOF (CLIENTID)));
    cbXml = f_plicensechallenge->cbXML;

    dstrScratch.pwszString =         f_plicensechallenge->pwszBBVer;
    dstrScratch.cchString  = wcslen (f_plicensechallenge->pwszBBVer);

    ChkDR( DRM_LA_GetClientInfo(&f_plicensechallenge->clientid,
                                 f_plicensechallenge->rgbStack,
                                &cchEncoded,
          (DRM_CONST_STRING *)  &g_dstrReqTagClientVersionData,
                                &dstrScratch,
                                 f_plicensechallenge->levelAppSecurity,
                                 f_plicensechallenge->idSubject,
                                 0,
                                 NULL,
                                (f_plicensechallenge->dstrDeviceCert.cchString != 0)? &f_plicensechallenge->dstrDeviceCert : NULL,
                                 f_plicensechallenge->pbXML,
                                &cbXml,
                                &(f_plicensechallenge->pcontextBBX->CryptoContext),
                                 FALSE));

ErrorExit:
    return dr;
}

/**************************************************************************
**                  PUBLIC FUNCTION DRM_LA_CreateChallenge
***************************************************************************/
DRM_RESULT DRM_API DRM_LA_CreateChallenge (
    IN DRM_LICENSE_CHALLENGE *f_plicensechallenge,
    OUT      DRM_CHAR        *f_pszChallenge,
    IN OUT   DRM_DWORD       *f_pcchChallenge)
{
    DRM_RESULT dr    = DRM_SUCCESS;
    DRM_DWORD  cbXML = 0;
    DRM_BYTE  *pbXML = NULL;
    DRM_STRING dstr  = EMPTY_DRM_STRING;    

    DRM_PROFILING_ENTER_SCOPE(L"DRM_LA_CreateChallenge", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);
    
    ChkArg (f_plicensechallenge != NULL
        &&  f_pcchChallenge     != NULL);

    if (f_plicensechallenge->dstrHeader.cchString != 0)
    {
        ChkDRMString (&f_plicensechallenge->dstrHeader);
    }

    if (f_plicensechallenge->dstrV1Challenge.cchString != 0)
    {
        ChkDRMString (&f_plicensechallenge->dstrV1Challenge);
    }
    else
    {
        ASSIGN_DRM_STRING (f_plicensechallenge->dstrV1Challenge, g_dstrDefaultV1Data);
    }

    if (f_plicensechallenge->dstrDeviceCert.cchString != 0)
    {
        ChkDRMString (&f_plicensechallenge->dstrDeviceCert);
    }

    /* calculate the required size for the challenge XML and express as bytes */

	cbXML = _RequiredCharsForRequest (f_plicensechallenge) * SIZEOF (DRM_WCHAR)
	      + g_cbXMLBuilderMinimum;

    /* verify that the XML context is WCHAR-aligned and adjust the requirement if it isn't */

    /* check buffer sizes; adjust for possible buffer realignment */

    if   (f_pszChallenge ==  NULL 
      || *f_pcchChallenge <  CCH_BASE64_EQUIV (cbXML))
    {        
        *f_pcchChallenge = CCH_BASE64_EQUIV (cbXML);
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    ChkDR(DRM_UTL_EnsureDataAlignment ((DRM_BYTE*)f_pszChallenge, 
                                       cbXML, 
                                      &pbXML, 
                                      &cbXML, 
                                       SIZEOF (DRM_DWORD), 
                                       NULL));

    /* Initialize Context */

    ZEROMEM(pbXML, cbXML);
    
    f_plicensechallenge->pbXML = pbXML;
    f_plicensechallenge->cbXML = cbXML;

    /* Init XML Builder 
    ** Add document root tag: <LicenseRequest version=2.0.0.0"> */
    
    ChkDR(DRM_XMB_CreateDocument(f_plicensechallenge->cbXML,  f_plicensechallenge->pbXML, &g_dstrTagLicenseRequest));
    ChkDR(DRM_XMB_AddAttribute  (f_plicensechallenge->pbXML, &g_dstrAttributeVersion,   &g_dstrAttributeVersionValue));
    ChkDR(DRM_XMB_WriteCDATATag (f_plicensechallenge->pbXML, &g_dstrTagV1Challenge,     &f_plicensechallenge->dstrV1Challenge, NULL, NULL, wttClosed));
    
    if (f_plicensechallenge->cUplinks > 0)
    {
        ChkDR(_WriteUplinkNode(f_plicensechallenge));
    } 

    if (f_plicensechallenge->cRights > 0)
    {
        ChkDR(_WriteActionsNode(f_plicensechallenge));
    }                                  

    if (f_plicensechallenge->dstrClientIdentity.cchString != 0)
    {
        ChkDR(DRM_XMB_AppendNode(f_plicensechallenge->pbXML, &f_plicensechallenge->dstrClientIdentity));
    }
    else
    {
        ChkDR(_AddClientInfo(f_plicensechallenge));
    }

    if (f_plicensechallenge->dstrHeader.cchString != 0)
    {
        ChkDR(DRM_XMB_AppendNode(f_plicensechallenge->pbXML, &f_plicensechallenge->dstrHeader));
    }


    ChkDR(DRM_XMB_CloseDocument (f_plicensechallenge->pbXML, &dstr));

    TRACE(("\nRequest: %S\n\n", dstr.pwszString));

    /* construct challenge buffer */
    MEMMOVE( f_pszChallenge, PB_DSTR(&dstr), CB_DSTR(&dstr) );    
    ChkDR(DRM_B64_EncodeA((DRM_BYTE*)f_pszChallenge,  
                          CB_DSTR(&dstr), 
                          f_pszChallenge, 
                          f_pcchChallenge, 
                          DRM_BASE64_ENCODE_WMDRM));

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_LA_CreateChallenge", g_pwszLeavingFunction);
    return dr;
}

/**************************************************************************
**                  PUBLIC FUNCTION DRM_LA_GetClientInfo
***************************************************************************/

DRM_RESULT DRM_API DRM_LA_GetClientInfo (
    IN       CLIENTID               *f_pclientid,
    IN       DRM_BYTE               *f_pbStack,
    IN OUT   DRM_DWORD              *f_pcbStack,
    IN       DRM_CONST_STRING       *f_pdstrClientVersionData,
    IN       DRM_CONST_STRING       *f_pdstrSecurityVersionData,
    IN       DRM_DWORD               f_AppSecurityData,
    IN       DRM_DWORD               f_SubjectId1,
    IN       DRM_DWORD               f_SubjectId2,
    IN       DRM_CONST_STRING       *f_pdstrDRMKVersion,
    IN       DRM_CONST_STRING       *f_pdstrDevcert,
    IN OUT   DRM_BYTE               *f_pbXML,
    IN OUT   DRM_DWORD              *f_pcbXML,
    IN       DRM_CRYPTO_CONTEXT     *f_contextCRYP,
    IN       DRM_BOOL                f_fCreateNewDoc)
{
    DRM_RESULT  dr                   =  DRM_SUCCESS;
    DRM_DWORD   cbXML                =  0;
    DRM_DWORD   cchDevcert           =  0;
    DRM_DWORD   cbDRMKVersion        =  0;
    DRM_BYTE   *pbXML                = f_pbXML;
    DRM_WCHAR  *pszScratch           = (DRM_WCHAR *) f_pbStack;
    DRM_DWORD   cchEncoded           = CCH_BASE64_EQUIV (SIZEOF(CLIENTID));
    DRM_CONST_STRING dstrScratch     = EMPTY_DRM_STRING;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_LA_GetClientInfo", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    ChkArg (f_pclientid         != NULL
        &&  f_pcbStack          != NULL
        &&  f_pcbXML            != NULL
        &&  f_AppSecurityData   > 0
        &&  f_SubjectId1        > 0)

    ChkDRMString(f_pdstrClientVersionData);
    ChkDRMString(f_pdstrSecurityVersionData);
    
    if ( f_pdstrDRMKVersion != NULL )
    {
        ChkDRMString(f_pdstrDRMKVersion);
        cbDRMKVersion = f_pdstrDRMKVersion->cchString;
    }
    
    if ( f_pdstrDevcert != NULL )
    {
        ChkDRMString(f_pdstrDevcert);
        cchDevcert = f_pdstrDevcert->cchString;
    }

    /* calculate the required size for the challenge XML and express as bytes */

    cbXML += _RequiredCharsForCLIENTINFOBlock (f_AppSecurityData,
                                               f_SubjectId1,
                                               f_pdstrSecurityVersionData->cchString,
                                               f_pdstrClientVersionData->cchString,
                                               cchDevcert, 
                                               f_SubjectId2,
                                               cbDRMKVersion) * SIZEOF(DRM_WCHAR);

    if ( f_fCreateNewDoc )
    {
        cbXML += g_cbXMLBuilderMinimum;   
    }


    if ( f_pbStack == NULL 
    ||   *f_pcbStack <   CCH_BASE64_EQUIV (SIZEOF (CLIENTID))
    ||   f_pbXML == NULL
    ||   *f_pcbXML < cbXML)
    {

        *f_pcbStack = CCH_BASE64_EQUIV (SIZEOF (CLIENTID));
        *f_pcbXML = cbXML;
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    cbXML = *f_pcbXML;

    if ( f_fCreateNewDoc )
    {
        ChkDR(DRM_UTL_EnsureDataAlignment ( pbXML, 
                                            cbXML, 
                                           &pbXML, 
                                           &cbXML, 
                                            SIZEOF (DRM_DWORD), 
                                            NULL));
        
        ZEROMEM(pbXML, cbXML);
        /* Init XML Builder 
        ** Add document root tag: <CLIENTINFO> */
        
        ChkDR(DRM_XMB_CreateDocument(cbXML,  pbXML, &g_dstrReqTagClientInfo));
    }
    else
    {
        ChkDR(DRM_XMB_WriteTag (pbXML,             
                                &g_dstrReqTagClientInfo,
                                 NULL,
                                 NULL,
                                 NULL,
                                 wttOpen));
    }


    /*      <CLIENTID> */
    
    ChkDR(DRM_B64_EncodeW((DRM_BYTE*) f_pclientid, 
                           SIZEOF(CLIENTID), 
                           pszScratch, 
                          &cchEncoded,
                           DRM_BASE64_ENCODE_WMDRM));
                           
    dstrScratch.pwszString = pszScratch;
    dstrScratch.cchString  = cchEncoded;
    
    ChkDR(DRM_XMB_WriteTag (pbXML, 
                            &g_dstrReqTagClientID,
                            &dstrScratch,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <CLIENTVERSION> */

    ChkDR(DRM_XMB_WriteTag (pbXML, 
                            &g_dstrReqTagClientVersion,
                             f_pdstrClientVersionData,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <SECURITYVERSION> */
    
    
    ChkDR(DRM_XMB_WriteTag (pbXML, 
                            &g_dstrTagSecurityVersion,
                             f_pdstrSecurityVersionData,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <APPSECURITY> */
   
    dstrScratch.cchString  = DRM_UTL_NumberToString (f_AppSecurityData, pszScratch, 20);
    dstrScratch.pwszString = pszScratch;
   
    ChkDR(DRM_XMB_WriteTag (pbXML, 
                            &g_dstrReqTagAppSecurity,
                            &dstrScratch,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <SUBJECTID1> */

    dstrScratch.cchString  = DRM_UTL_NumberToString (f_SubjectId1, pszScratch, 20);
    dstrScratch.pwszString = pszScratch;    

    ChkDR(DRM_XMB_WriteTag (pbXML, 
                            &g_dstrReqTagSubjectID1,
                            &dstrScratch,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <SUBJECTID2> */

    if (f_SubjectId2 != 0)
    {
        dstrScratch.cchString  = DRM_UTL_NumberToString (f_SubjectId2, pszScratch, 20);
        dstrScratch.pwszString = pszScratch;    

        ChkDR(DRM_XMB_WriteTag (pbXML, 
                                &g_dstrReqTagSubjectID2,
                                &dstrScratch,
                                 NULL,
                                 NULL,
                                 wttClosed));            


    }
    else
    {
        ChkDR(DRM_XMB_WriteTag (pbXML, 
                                &g_dstrReqTagSubjectID2,
                                 NULL,
                                 NULL,
                                 NULL,
                                 wttClosed));            
    }

    /*      <DRMKVERSION> */

    ChkDR(DRM_XMB_WriteTag (pbXML, 
                            &g_dstrReqTagDrmkVersion,
                             f_pdstrDRMKVersion,
                             NULL,
                             NULL,
                             wttClosed));            

    /*      <DEVCERT> */

    if ( f_pdstrDevcert != NULL )
    {        
        ChkDR(DRM_XMB_OpenNode               (pbXML,&g_dstrTagDevCert));
        ChkDR(DRM_XMB_AddData                (pbXML, f_pdstrDevcert));
        ChkDR(DRM_XMB_EncryptAndCloseCurrNode(pbXML, f_contextCRYP, &g_pubkeyLicenseServer, NULL));
    }

    /* </CLIENTINFO> */

    if ( f_fCreateNewDoc )
    {
        ChkDR(DRM_XMB_CloseDocument (pbXML, (DRM_STRING *)&dstrScratch));
        *f_pcbXML = CB_DSTR( &dstrScratch );
        
        /*arrange the bytes to original position*/
        if (f_pbXML != PB_DSTR( &dstrScratch ) )
        {
            MEMCPY((DRM_BYTE*)f_pbXML, dstrScratch.pwszString, CB_DSTR(&dstrScratch));
        }        
    }
    else
    {
        ChkDR(DRM_XMB_CloseCurrNode (pbXML, NULL));    
    }
    

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_LA_GetClientInfo", g_pwszLeavingFunction);
    return dr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmkeygen.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmsha1.h>
#include <drmkeygenerator.h>
#include <oemimpl.h>


DRM_RESULT DRM_API DRM_KG_GenerateKeyseed(
       OUT DRM_WCHAR *pwszKeyseed,
    IN OUT DRM_DWORD *pcchKeyseed)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_BYTE rgbKeyseed [__CB_DECL(DRM_KEYSEED_LEN)];
    DRM_INT i=0;

    ChkArg(pcchKeyseed);
    if ( *pcchKeyseed<(DRM_KEYSEED_LEN+1) || pwszKeyseed==NULL )
    {
        dr = DRM_E_BUFFERTOOSMALL;
        *pcchKeyseed = DRM_KEYSEED_LEN+1;
        goto ErrorExit;
    }
    *pcchKeyseed = DRM_KEYSEED_LEN+1;
    ChkDR(OEM_GenRandomBytes(rgbKeyseed, DRM_KEYSEED_LEN));

    ZEROMEM((DRM_BYTE*)pwszKeyseed, *pcchKeyseed * SIZEOF(DRM_WCHAR));
    for (i = 0; i < DRM_KEYSEED_LEN; i++)
    {
        /* convert each byte into an alpha numberic character (62 available) */
        DRM_BYTE val = (GET_BYTE(rgbKeyseed, i)) % 62;

        if (val < 10)
        {
            val += NATIVE_WCHAR(g_wch0);
        }
        else if (val < 36)
        {
            val += NATIVE_WCHAR(g_wcha) - 10;
        }
        else
        {
            val += NATIVE_WCHAR(g_wchA) - 36;
        }
        pwszKeyseed[i] = WCHAR_CAST(val);
    }

ErrorExit:

    return dr;
}

DRM_RESULT DRM_API DRM_KG_GenerateKeyID(
       OUT DRM_WCHAR *pwszKeyID,           /* base64 encoded string */
    IN OUT DRM_DWORD *pcchKeyID)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_GUID keyGuid;
    DRM_DWORD cchEncoded = CCH_BASE64_EQUIV(SIZEOF(DRM_GUID));

    ChkArg(pcchKeyID);

    if ( *pcchKeyID<( cchEncoded+1) 
      || pwszKeyID==NULL )
    {
        *pcchKeyID=cchEncoded+1;
        dr =DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }
    
    /*
    ** generate random bytes for KeyID (used to generate a GUID)
    */
    ChkDR(OEM_GenRandomBytes((DRM_BYTE*)&keyGuid, SIZEOF(DRM_GUID)));

    /* base64 encode */    
    ZEROMEM((DRM_BYTE*)pwszKeyID, *pcchKeyID * SIZEOF(DRM_WCHAR));
    ChkDR(DRM_B64_EncodeW((DRM_BYTE *)&keyGuid, SIZEOF(DRM_GUID), pwszKeyID, &cchEncoded, 0));
    *pcchKeyID=cchEncoded+1;

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_KG_GenerateContentKey(
    IN     DRM_WCHAR *pwszKeySeed,          /* base64 encoded string */
    IN     DRM_DWORD  cchKeySeed, 
    IN     DRM_WCHAR *pwszKeyID,            /* base64 encoded string */
    IN     DRM_DWORD  cchKeyID, 
       OUT DRM_WCHAR *pwszContentKey,      /* base64 encoded string */
    IN OUT DRM_DWORD *pcchContentKey)
{
    DRM_RESULT dr=DRM_SUCCESS;
    SHA_CONTEXT  shaVal;    
    DRM_BYTE rgbKeyseed[__CB_DECL(DRM_KEYSEED_LEN)];
    DRM_BYTE res       [__CB_DECL(SHA_DIGEST_LEN + 1)];
    DRM_BYTE res1      [__CB_DECL(SHA_DIGEST_LEN + 1)];
    DRM_BYTE res2      [__CB_DECL(SHA_DIGEST_LEN + 1)];
    DRM_DWORD cchb64 = CCH_BASE64_EQUIV(DRM_CONTENT_KEY_LENGTH);
    DRM_UINT  i      = 0;    

    ChkArg( pwszKeySeed    != NULL
         && cchKeySeed     == DRM_KEYSEED_LEN 
         && pwszKeyID      != NULL
         && cchKeyID       != 0
         && pcchContentKey != NULL );

    /*
    **  We should actually limit this to just 24 bytes; but for historical
    **  reasons, we have some providers using slightly longer KIDs. Resuing the
    **  keyseed buffer allows for slightly longer KIDs while still checking for 
    **  KIDs that are too large
    */
    ChkArg( cchKeyID       < SIZEOF(rgbKeyseed) );
         
    /* check buffer length */
    if ( *pcchContentKey < cchb64+1 
      || pwszContentKey == NULL )
    {
        *pcchContentKey=cchb64+1;
        dr=DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }
    
    for( i=0; i<cchKeySeed; i++ )
    {
        PUT_BYTE(rgbKeyseed, i,  (DRM_BYTE) NATIVE_WCHAR (pwszKeySeed [i]));
    }

    /* init buffer */
    ZEROMEM((DRM_BYTE*)pwszContentKey, *pcchContentKey*SIZEOF(DRM_WCHAR));

    /* generate key */
    DRM_SHA_Init(&shaVal);
    DRM_SHA_Update(rgbKeyseed, DRM_KEYSEED_LEN, &shaVal);
    DRM_SHA_Finalize(&shaVal, res);

    for( i=0; i<cchKeyID; i++ )
    {
        PUT_BYTE(rgbKeyseed, i, (DRM_BYTE) NATIVE_WCHAR (pwszKeyID [i]));
    }

    DRM_SHA_Init(&shaVal);
    DRM_SHA_Update(res, 6, &shaVal);  /* Copy first 48 bits of res */
    DRM_SHA_Update(rgbKeyseed, cchKeyID, &shaVal);
    DRM_SHA_Finalize(&shaVal, res1);

    DRM_SHA_Init(&shaVal);
    DRM_SHA_UpdateOffset(res, 6, 6, &shaVal);  /* Copy 2nd set of 48 bits of res */
    DRM_SHA_Update(rgbKeyseed, cchKeyID, &shaVal);
    DRM_SHA_Finalize(&shaVal, res2);

    DRM_SHA_Init(&shaVal);
    DRM_SHA_UpdateOffset(res, 12, 6, &shaVal);  /* Copy third set of 48 bits of res */
    DRM_SHA_Update(rgbKeyseed, cchKeyID, &shaVal);
    DRM_SHA_Finalize(&shaVal, res);

    /* Reuse res to hold the final result. */
    for (i = 0; i < SHA_DIGEST_LEN; i++)
    {
        DRM_BYTE b = GET_BYTE(res, i);
        b ^= GET_BYTE(res1, i) ^ GET_BYTE(res2, i);
        PUT_BYTE(res, i, b);
    }
    
    ChkDR(DRM_B64_EncodeW(res, DRM_CONTENT_KEY_LENGTH, pwszContentKey, &cchb64, 0));    
    pwszContentKey[cchb64] = g_wchNull;
    *pcchContentKey=cchb64+1;

ErrorExit:
    return dr;
}


DRM_RESULT DRM_API DRM_KG_GenerateSigningKeys(
    IN     DRM_CRYPTO_CONTEXT *pCrypto,
       OUT DRM_WCHAR          *pwszPrivKey,         /* base64 encoded string */
    IN OUT DRM_DWORD          *pcchPrivKey,
       OUT DRM_WCHAR          *pwszPubKey,          /* base64 encoded string */
    IN OUT DRM_DWORD          *pcchPubKey)
{
    DRM_RESULT dr=DRM_SUCCESS;
    PUBKEY pub;
    PRIVKEY priv;
    DRM_DWORD cchPubEncoded  = CCH_BASE64_EQUIV(PK_ENC_PUBLIC_KEY_LEN);
    DRM_DWORD cchPrivEncoded = CCH_BASE64_EQUIV(PK_ENC_PRIVATE_KEY_LEN);

    if ( *pcchPrivKey <  cchPrivEncoded + 1 
      || *pcchPubKey  <  cchPubEncoded  + 1 
      ||  pwszPrivKey == NULL 
      ||  pwszPubKey  == NULL )
    {
        *pcchPrivKey = cchPrivEncoded + 1;
        *pcchPubKey  = cchPubEncoded  + 1;
        dr = DRM_E_BUFFERTOOSMALL;
        goto ErrorExit;
    }

    ZEROMEM((DRM_BYTE*) pwszPrivKey, *pcchPrivKey * SIZEOF(DRM_WCHAR));
    ZEROMEM((DRM_BYTE*) pwszPubKey,  *pcchPubKey  * SIZEOF(DRM_WCHAR));

    /* generate the key pair */
    ChkDR(DRM_PK_GenKeyPair( pCrypto->rgbCryptoContext, &pub, &priv ) );

    /* base64 encode */
    ChkDR(DRM_B64_EncodeW((DRM_BYTE *)&pub,  PK_ENC_PUBLIC_KEY_LEN,  pwszPubKey,  pcchPubKey,  0));    
    ChkDR(DRM_B64_EncodeW((DRM_BYTE *)&priv, PK_ENC_PRIVATE_KEY_LEN, pwszPrivKey, pcchPrivKey, 0));
    *pcchPubKey  += 1;
    *pcchPrivKey += 1;

ErrorExit:
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmlicacqresp.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcontextsizes.h>
#include <drmlicenseparser.h>
#include <drmxmlbuilder.h>
#include <drmxmlparser.h>
#include <drmblackbox.h>
#include <drmlicacq.h>
#include <drmexpreval.h>
#include <drmsha1.h>
#include <drmcrt.h>
#if DRM_SUPPORT_APP_REVOCATION || DRM_SUPPORT_DEVICE_REVOCATION || DRM_SUPPORT_REVOCATION
#include <drmmanager.h>
#include <drmrevocation.h>
#endif
#include <drmsyncstore.h>
#include <oemimpl.h>
#include <drmlicreason.h>

/*
**
*/
static DRM_RESULT DRM_API _EvaluateLicense(   
    IN     DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN     DRM_HDS_CONTEXT     *f_pcontextHDS,
    OUT    DRM_CONST_STRING    *f_pdstrLIData )
{
    DRM_BYTE         rgbLicensePassword [__CB_DECL(SHA_DIGEST_LEN)] = { 0x00 };
    DRM_CONST_STRING dstrLID   = EMPTY_DRM_STRING;
    DRM_BOOL         fOK       = FALSE;
    DRM_RESULT       dr        = DRM_SUCCESS;
    DRM_LONG         lReasonForFailure  = 0;
    DRM_BOOL         fUpdatedRevocationList = FALSE;
    
    ChkArg (f_pcontextLEVL != NULL
        &&  f_pcontextHDS  != NULL);

    ChkDRMString( &f_pcontextLEVL->dstrContentLicense );

    /*
    **  Cache the reason for failure in case we fail before any of the
    **  DRM_LEVL_PerformOperations
    */
    lReasonForFailure = f_pcontextLEVL->lReasonForFail;
    
    /*
    **  Clear the output
    */
    f_pdstrLIData->cchString = 0;
    f_pdstrLIData->pwszString = NULL;

#if DRM_SUPPORT_APP_REVOCATION
    fUpdatedRevocationList = f_pcontextLEVL->fUpdatedRevocationList;

    ChkDR(DRM_RVK_PerformAppRevocationCheck(f_pcontextLEVL,
                                            f_pcontextHDS));

    f_pcontextLEVL->fUpdatedRevocationList = (fUpdatedRevocationList || f_pcontextLEVL->fUpdatedRevocationList);                                           
#endif /* DRM_SUPPORT_APP_REVOCATION */

    /* construct lic password */
    ChkDR(DRM_SST_CreateLicenseStatePassword(&f_pcontextLEVL->LID, rgbLicensePassword, (DRM_BYTE *) f_pcontextLEVL->pcontextBBX));
    ChkDR(DRM_SST_OpenKeyTokens( f_pcontextLEVL->pcontextSSTLicense, 
                                &f_pcontextLEVL->LID, 
                                 NULL,
                                 rgbLicensePassword, 
                                 DRM_SECURE_STORE_CREATE_IF_NOT_EXISTS, 
                                 SECURE_STORE_LICENSE_DATA,
                                 f_pcontextHDS));

    /* call License Eval */
    f_pcontextLEVL->cPlaylistBurnIncrement = 0;
    f_pcontextLEVL->fReserved              = FALSE;
    f_pcontextLEVL->dwFlags                = LICEVAL_STORE_CHECK_SETTINGS;
    
    dr = DRM_LEVL_PerformOperations( f_pcontextLEVL, 
                                     DRM_LICENSE_EVAL_STORE, 
                                     DRM_LICENSE_EVAL_CAN_DO_OPERATION, 
                                     NULL,
                                    &fOK, 
                                     NULL, 
                                     f_pcontextHDS );
    /*
    **  Cache the reason for failure. We want to return this, and not the reason
    **  for failure we get from ONSELECT
    */
    lReasonForFailure = f_pcontextLEVL->lReasonForFail;
    ChkDR( dr );
    
    /* check to see if the license is selectable */
    if ( fOK )
    {
        /* save the content header */
        DRM_CONST_STRING dstrTemp = f_pcontextLEVL->dstrContentHeader;

        /* set content header NULL to avoid KID matching */
        f_pcontextLEVL->dstrContentHeader.pwszString = NULL;
        f_pcontextLEVL->dstrContentHeader.cchString = 0;
        dr = DRM_LEVL_PerformOperations( f_pcontextLEVL, 
                                         DRM_LICENSE_EVAL_SELECT, 
                                         DRM_LICENSE_EVAL_CAN_DO_OPERATION, 
                                         NULL, 
                                         &fOK, 
                                         NULL, 
                                         f_pcontextHDS);

        /* restore the content header */
        f_pcontextLEVL->dstrContentHeader = dstrTemp;
        ChkDR(dr);
    }

    if ( !fOK )
    {
        /* Note, WMRM does not set drmreason to LR_LICENSE_EXPIRED currently. So 
        ** even if a license expires, the reason code will still be zero
        */
        
        /* for the following cases, do not save the license to store. */
        if (   f_pcontextLEVL->lReasonForFail == LR_LICENSE_EXPIRED 
            || f_pcontextLEVL->lReasonForFail == LR_LICENSE_STORE_NOT_ALLOWED 
            || f_pcontextLEVL->lReasonForFail == LR_LICENSE_CERT_EXPIRED)
        {
            dr = DRM_E_FAILED_TO_STORE_LICENSE; /* License store not allowed  */
        }
    }

    /* ignore the error code here */
    (void)DRM_SST_CloseKey(f_pcontextLEVL->pcontextSSTLicense, f_pcontextHDS);

ErrorExit:
    if ( f_pcontextLEVL != NULL )
    {
        f_pcontextLEVL->lReasonForFail = lReasonForFailure;
    }
    
    return dr;
}

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS

#define CCH_SYMSIG_TAG  ( 2  + g_dstrTagSymSig.cchString               /* <SYMSIGNATURE> */                   \
                             + CCH_BASE64_EQUIV( SHA_DIGEST_LEN )      /* B64-encoded symmetric signature */  \
                         + 3 + g_dstrTagSymSig.cchString)              /* </SYMSIGNATURE> */                  \

#define CCH_SYMVAL_TAG  ( 2  + g_dstrTagSymValue.cchString             /* <SYMVALUE> */                                               \
                             + CCH_BASE64_EQUIV( 20 )                  /* B64-encoded symmetrically encrypted content key.        */  \
                                                                       /* This value will be updated during processing            */  \
                                                                       /* as it could be different sizes depending on the license */  \
                         + 3 + g_dstrTagSymValue.cchString)            /* </SYMVALUE> */                                              \


static DRM_RESULT DRM_API _UpdateLicenseWithSymmetricSignature(
    IN OUT   DRM_STRING          *f_pdstrLicense,
    IN const DRM_CONST_STRING    *f_pdstrData,
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN const DRM_SLK             *f_pslk )
{    
    DRM_BYTE          rgbSymmSignature[__CB_DECL(SHA_DIGEST_LEN)];
    DRM_CONST_STRING *pdstrLicense       = (DRM_CONST_STRING*) f_pdstrLicense;
    DRM_CONST_STRING  dstrString         = EMPTY_DRM_STRING;
    DRM_RESULT        dr                 = DRM_SUCCESS; 
    DRM_WCHAR        *pwszInsertionPoint = NULL;
    DRM_DWORD         cch                = 0;


    /*   1.  If a sym sig already exists try to verify it with the current slk
    **   2.  If sym sig doesn't exist, Verify the signature assymetrically
    **   3.  Then create new symsig
    */

    if( f_pslk != NULL
     && DRM_SUCCEEDED( DRM_XML_GetSubNodeByPath( pdstrLicense, 
                                                &g_dstrXPathSymSig, 
                                                 NULL, 
                                                 NULL, 
                                                 NULL,
                                                &dstrString, 
                                                 g_wchForwardSlash ) ) )
    {
        cch = SIZEOF( rgbSymmSignature );
        ChkDR( DRM_B64_DecodeW( &dstrString, &cch, rgbSymmSignature, 0 ) );

        if( cch != SHA_DIGEST_LEN
         || DRM_FAILED( DRM_BBX_SymmetricVerify( f_pcontextLEVL->pcontextBBX,
                                                 PB_DSTR( f_pdstrData ),
                                                 CB_DSTR( f_pdstrData ),
                                                 f_pslk,
                                                 rgbSymmSignature ) ) )
        {
            ChkDR( DRM_E_INVALIDLICENSE );
        }

        /* Set the insertion point to just at the begining of the <SYMSIG tag */
        pwszInsertionPoint = (DRM_WCHAR*) (dstrString.pwszString - ( 2 + g_dstrTagSymSig.cchString ));
    }
    else
    {
        DRM_LONG lResult = 0;

        ChkDR( DRM_LIC_VerifySignature( pdstrLicense, f_pcontextLEVL->pcontextBBX, &lResult ) );
        if( lResult != 1 )
        {
            ChkDR( DRM_E_INVALIDLICENSE );
        }
        ChkDR( DRM_LIC_VerifyCertChain( pdstrLicense, TRUE, f_pcontextLEVL, &lResult ) );
        if( lResult != 1 )
        {
            ChkDR( DRM_E_INVALIDLICENSE );
        }

        /* We are inserting immediatly after the closing tag of the DATA node */
        pwszInsertionPoint  = (DRM_WCHAR*) (f_pdstrData->pwszString + f_pdstrData->cchString);
        ChkDR( DRM_UTL_StringInsertBlankSubString( f_pdstrLicense, 
                                       (DRM_DWORD)(f_pdstrData->pwszString - f_pdstrLicense->pwszString ) + f_pdstrData->cchString, 
                                                   CCH_SYMSIG_TAG ) );

        
    }

    *pwszInsertionPoint  = g_wchLessThan;
     pwszInsertionPoint += 1;
    wcsncpy( pwszInsertionPoint, g_dstrTagSymSig.pwszString, g_dstrTagSymSig.cchString );
     pwszInsertionPoint += g_dstrTagSymSig.cchString;
    *pwszInsertionPoint  = g_wchGreaterThan;
     pwszInsertionPoint += 1;

    ChkDR( DRM_BBX_SymmetricSign( f_pcontextLEVL->pcontextBBX, 
                                  PB_DSTR( f_pdstrData ),
                                  CB_DSTR( f_pdstrData ),
                      (DRM_BYTE*) pwszInsertionPoint) );
    
    cch = CCH_BASE64_EQUIV( SHA_DIGEST_LEN );
    ChkDR( DRM_B64_EncodeW( (DRM_BYTE*)pwszInsertionPoint,
                            SHA_DIGEST_LEN,
                            pwszInsertionPoint,
                           &cch,
                            0 ) );

     pwszInsertionPoint += cch;
    *pwszInsertionPoint  = g_wchLessThan;
     pwszInsertionPoint += 1;
    *pwszInsertionPoint  = g_wchForwardSlash;
     pwszInsertionPoint += 1;
    wcsncpy( pwszInsertionPoint, g_dstrTagSymSig.pwszString, g_dstrTagSymSig.cchString );
     pwszInsertionPoint += g_dstrTagSymSig.cchString;
    *pwszInsertionPoint  = g_wchGreaterThan;
     pwszInsertionPoint += 1;

ErrorExit:
     return dr;
}

static DRM_RESULT DRM_API _UpdateLicenseWithSymmetricKey(
    IN OUT   DRM_STRING          *f_pdstrLicense,
    IN const DRM_CONST_STRING    *f_pdstrData,
    IN const DRM_CONST_STRING    *f_pdstrEnablingBits,
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN const DRM_SLK             *f_pslk )
{
    DRM_RESULT       dr                 = DRM_SUCCESS;
    DRM_CONST_STRING dstrString         = EMPTY_DRM_STRING;
    DRM_CONST_STRING *pdstrLicense      = (DRM_CONST_STRING*) f_pdstrLicense;
    DRM_DWORD        cch                = 0;
    DRM_DWORD        cbSymmKey          = 0;
    DRM_WCHAR       *pwszInsertionPoint = NULL;    
    DRM_BINDING_INFO bindinfo;    

    /*
    **   Using the blackbox create a symmerticly decryptable content key for the license
    **   1.  if a symvalue exists extract it with the current slk and rebind
    **   2.  else asymmetrically extract and rebind.
    */
        
    if( f_pslk != NULL
     && DRM_SUCCEEDED( DRM_XML_GetSubNodeByPath( pdstrLicense, 
                                                &g_dstrXPathSymValue, 
                                                 NULL, 
                                                 NULL, 
                                                 NULL,
                                                &dstrString, 
                                                 g_wchForwardSlash ) ) )
    {
        cbSymmKey = SIZEOF( bindinfo.m_rgbContentKey );
        ChkDR( DRM_B64_DecodeW( &dstrString, &cbSymmKey, bindinfo.m_rgbContentKey, 0 ) );

        ChkDR( DRM_BBX_RebindSymmetricKey( f_pcontextLEVL->pcontextBBX, f_pslk, bindinfo.m_rgbContentKey, cbSymmKey ) );
        
        /* Set the insertion point to just at the begining of the <SYMVALUE tag */
        pwszInsertionPoint = (DRM_WCHAR*) (dstrString.pwszString - ( 2 + g_dstrTagSymValue.cchString ));
    }
    else
    {
        DRM_DWORD cbKey = SIZEOF( bindinfo.m_rgbContentKey );

        /* Get the PUBKEY this license is bound to */
        ChkDR( DRM_LIC_GetEnablingBits( (DRM_CONST_STRING*) f_pdstrLicense,
                                        0,
                                       &bindinfo.m_dwAlgorithm,
                                       &bindinfo.m_oPublKey,
                                        bindinfo.m_rgbContentKey,
                                       &cbKey,
                                       &bindinfo.m_oLsPublKey,
                                        bindinfo.m_rgbSignature,
                                        NULL,
                                       &f_pcontextLEVL->pcontextBBX->CryptoContext ) );


        /* Convert the asymmertic key to a symmetric key.  This happens in place. */
        ChkDR( DRM_BBX_AsymmetricToSymmetricKey( f_pcontextLEVL->pcontextBBX, 
                                                &bindinfo,
                                                &cbSymmKey ) );

        cch = (CCH_SYMVAL_TAG - CCH_BASE64_EQUIV( 20 )) + CCH_BASE64_EQUIV(cbSymmKey);

        /* We are inserting immediatly before the closing tag of the LICENSORINFO tag */
        pwszInsertionPoint  = (DRM_WCHAR*) (f_pdstrData->pwszString + f_pdstrData->cchString);
        ChkDR( DRM_UTL_StringInsertBlankSubString( f_pdstrLicense, 
                                       (DRM_DWORD)(f_pdstrData->pwszString - f_pdstrLicense->pwszString ) + f_pdstrData->cchString, 
                                                   cch ) );
    }    
    
    /* Create the symmetric encrypted content key node and data */
    *pwszInsertionPoint = g_wchLessThan;
     pwszInsertionPoint++;
    wcsncpy( pwszInsertionPoint, g_dstrTagSymValue.pwszString, g_dstrTagSymValue.cchString );
     pwszInsertionPoint += g_dstrTagSymValue.cchString;
    *pwszInsertionPoint = g_wchGreaterThan;
     pwszInsertionPoint++;

    cch = CCH_BASE64_EQUIV( cbSymmKey );
    ChkDR( DRM_B64_EncodeW( bindinfo.m_rgbContentKey,
                            cbSymmKey,
                            pwszInsertionPoint,
                           &cch,
                            0 ) );
    
     pwszInsertionPoint += cch;
    *pwszInsertionPoint  = g_wchLessThan;
     pwszInsertionPoint += 1;
    *pwszInsertionPoint  = g_wchForwardSlash;
     pwszInsertionPoint += 1;
    
    wcsncpy( pwszInsertionPoint, g_dstrTagSymValue.pwszString, g_dstrTagSymValue.cchString );
     pwszInsertionPoint += g_dstrTagSymValue.cchString;    
    *pwszInsertionPoint  = g_wchGreaterThan;
     pwszInsertionPoint += 1;

ErrorExit:
     return dr;
}

/*********************************************************************
**
**  Function:  _UpdateLicenseWithSymmetricData
**
**  Synopsis:  Given a license update it with a symmetrical signature and symmetrically encrypted content key.
**             This drastically improves binding and playback performance by offloading those assymetricall
**             operations to a one time hit here.
**
**  Arguments:  
**     [f_pdstrLicense]  -- License to add symmetrical data to
**     [f_cchLicenseMax] -- Maximum license size that can fix in the f_pdstrLicense buffer
**     [f_pcontextLEVL]  -- Pointer to a license evaluator context.
*********************************************************************/

static DRM_RESULT DRM_API _UpdateLicenseWithSymmetricData( 
    IN OUT   DRM_STRING          *f_pdstrLicense,
    IN       DRM_DWORD            f_cchLicenseMax,
    IN       DRM_LICEVAL_CONTEXT *f_pcontextLEVL,
    IN const DRM_SLK             *f_pslk )
{
    DRM_RESULT       dr               = DRM_SUCCESS;
    DRM_CONST_STRING dstrEnablingBits = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrData         = EMPTY_DRM_STRING;
    DRM_BOOL         fChainedLicense  = FALSE;

    if( f_pdstrLicense->cchString + CCH_SYMSIG_TAG + CCH_SYMVAL_TAG > f_cchLicenseMax )
    {
        ChkDR( DRM_E_BUFFERTOOSMALL );
    }

    /*
    ** Steps:
    **   1.  Find the enabling bits node for this license.
    **   2.  Update with symmetric signature    
    **   3.  Update the license with this information
    */

    /*
    ** The following XML will be added(or updated) to the license enabling bits section
    ** <SYMVALUE>B64-encoded symmetrically encrypted content key</SYMVALUE>
    ** <SYMSIGNATURE>B64-encoded symmetric signature</SYMSIGNATURE>
    */
    
    /* If there is an uplink kid node we don't rebind the content key */
    dr = DRM_LIC_GetAttribute( (DRM_CONST_STRING*)f_pdstrLicense, 
                                NULL,
                                DRM_LICENSE_ATTRIB_CHAINEDKID,                                
                               &dstrData, 
                               &dstrEnablingBits,
                                0);
    if( DRM_SUCCEEDED( dr ) )
    {
        fChainedLicense = TRUE;
    }

    /* dstrData points at the LICENSEORINFO node in the license -- populated by the previous call to GetAttribute */

    if( fChainedLicense )
    {
        ChkDR( DRM_XML_GetSubNode( &dstrData, 
                                   &g_dstrChainedEnablingBits, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                   &dstrEnablingBits, 
                                    NULL, 
                                    1) );
    }
    else
    {
        ChkDR( DRM_XML_GetSubNode( &dstrData, 
                                   &g_dstrTagEnablingbits, 
                                    NULL, 
                                    NULL, 
                                    0, 
                                   &dstrEnablingBits, 
                                    NULL, 
                                    1) );
    }

    if( !fChainedLicense
     || f_pslk != NULL )
    {
        ChkDR( _UpdateLicenseWithSymmetricKey( f_pdstrLicense,
                                              &dstrData,
                                              &dstrEnablingBits,
                                               f_pcontextLEVL,
                                               f_pslk ) );
    }

    ChkDR( _UpdateLicenseWithSymmetricSignature( f_pdstrLicense,
                                                &dstrData,
                                                 f_pcontextLEVL,
                                                 f_pslk ) );

ErrorExit:
    return dr;
}

#endif

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
DRM_ID g_idSLKSST = { TWO_BYTES( 'I', '\0'), TWO_BYTES( 'D', '\0'), TWO_BYTES( 'F', '\0'), TWO_BYTES( 'O', '\0'), 
                      TWO_BYTES( 'R', '\0'), TWO_BYTES( 'S', '\0'), TWO_BYTES( 'L', '\0'), TWO_BYTES( 'K', '\0') };

typedef struct _tagSLKDATA
{
    DRM_SLK slk;
    DRM_ID  idSLK;
} SLKDATA;

#endif

DRM_RESULT DRM_API DRM_LA_ProcessResponse(
    IN     DRM_BYTE                *f_pbResponse,
    IN     DRM_DWORD                f_cbResponse,
    IN     DRM_LICEVAL_CONTEXT     *f_pcontextLEVL,
    IN     DRM_LICSTORE_CONTEXT    *f_pcontextLST,
    IN     pfnStoreLicenseCallback  f_pfnCallback,
    IN     DRM_VOID                *f_pvCallbackContext,
    IN     DRM_HDS_CONTEXT         *f_pcontextHDS,
    IN     DRM_VIEW_RIGHTS_CONTEXT *f_pcontextASD,
    IN     DRM_BYTE                 f_rgbLicenseBuffer[__CB_DECL(DRM_MAX_LICENSESIZE)],
    IN     DRM_SYNC_CONTEXT        *f_pcontextSync,
       OUT DRM_LONG                *f_plReason)
{
    DRM_RESULT dr       = DRM_SUCCESS;
    DRM_RESULT drReason = DRM_SUCCESS;
    DRM_DWORD  iNode    = 0;
    DRM_DWORD  cStored  = 0;
    DRM_SUBSTRING         dasstrLicenseList = { 0 };
    DRM_SUBSTRING         dasstrLicenseData = { 0 };
    DRM_SUBSTRING         dasstrNodeData    = { 0 };
    DRM_SUBSTRING         dasstrTagData     = { 0 };
    DRM_ANSI_CONST_STRING dastrLicenseData  = EMPTY_DRM_STRING;
    DRM_CONST_STRING      dstrLIData        = EMPTY_DRM_STRING;

#if DRM_SUPPORT_APP_REVOCATION
    DRM_BYTE              bZero             = 0x00;
#endif
#if DRM_SUPPORT_APP_REVOCATION || DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
    DRM_BYTE              rgbPasswordSST [SHA_DIGEST_LEN] = { 0 };
#endif
#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
    SLKDATA               slkdata           = { 0 };
    DRM_BOOL              fSLKValid         = FALSE;
#endif

    DRM_PROFILING_ENTER_SCOPE(L"DRM_LA_ProcessResponse", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    dastrLicenseData.cchString =              f_cbResponse;
    dastrLicenseData.pszString = (DRM_CHAR *) f_pbResponse;
                
    ChkArg (f_pcontextLEVL     != NULL
         && f_pcontextLST      != NULL
         && f_pbResponse       != NULL
         && f_pcontextHDS      != NULL
         && f_rgbLicenseBuffer != NULL
         && f_cbResponse       != 0);

#if DRM_SUPPORT_LICENSE_SYNC
    ChkArg( f_pcontextASD  != NULL
         && f_pcontextSync != NULL );
#endif

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
    /* Extract the current SLK from the secure store */

    if( DRM_SUCCEEDED( DRM_SST_CreateLicenseStatePassword( &g_idSLKSST, 
                                                            rgbPasswordSST, 
                                               (DRM_BYTE *) f_pcontextLEVL->pcontextBBX ) ) )
    {
        DRM_DWORD cbSLK = SIZEOF( slkdata );

        if( DRM_SUCCEEDED( DRM_SST_GetData( f_pcontextLEVL->pcontextSSTLicense, 
                                           &g_idSLKSST, 
                                            NULL,
                                            rgbPasswordSST,
                                            SECURE_STORE_GLOBAL_DATA,
                                            f_pcontextHDS,
                                (DRM_BYTE*)&slkdata,
                                           &cbSLK ) ) )
        {
            if( cbSLK == SIZEOF( slkdata ) )
            {
                fSLKValid = TRUE;
            }
        }
    }
#endif

    /* extract the license list */
    dasstrLicenseData.m_ich = 0;
    dasstrLicenseData.m_cch = f_cbResponse;

    ChkDR(DRM_XML_GetNodeA((DRM_CHAR*) f_pbResponse,
                            &dasstrLicenseData, 
                            &g_adstrLicenseRespTag, 
                             NULL, 
                             NULL, 
                             0, 
                             NULL, 
                            &dasstrLicenseList));

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
    dasstrLicenseData.m_ich = 0;
    dasstrLicenseData.m_cch = f_cbResponse;

    dr = DRM_XML_GetNodeA((DRM_CHAR*) f_pbResponse,
                          &dasstrLicenseList, 
                          &g_dastrTagSLK, 
                           NULL, 
                           NULL, 
                           0, 
                           NULL,
                          &dasstrTagData );
    if( DRM_SUCCEEDED( dr ) )
    {
        DRM_BOOL fNewSLKValid = FALSE;
        DRM_BOOL fPersist     = TRUE;

        /* BUGBUG:  Look for a persist flag */

        /* Extract the SLK ID from the response */
        dr = DRM_XML_GetNodeA( (DRM_CHAR*) f_pbResponse,
                              &dasstrTagData,
                              &g_dastrTagSLKID,
                               NULL,
                               NULL,
                               0,
                               NULL,
                              &dasstrNodeData );
        if( DRM_SUCCEEDED( dr ) )
        {
            DRM_ID    idSLKNew = { 0 };
            DRM_DWORD cbidSLK  = SIZEOF( idSLKNew );

            dr = DRM_B64_DecodeA((DRM_CHAR *) f_pbResponse, 
                                 &dasstrNodeData, 
                                 &cbidSLK, 
                                 (DRM_BYTE*)&idSLKNew, 
                                  0);
            if( DRM_SUCCEEDED( dr ) )
            {
                if( fSLKValid
                 && MEMCMP( &slkdata.idSLK, &idSLKNew, SIZEOF( idSLKNew ) ) == 0 )
                {
                    /* If same as current slk id skip */
                    fNewSLKValid = TRUE;
                }
                else
                {
                    DRM_BYTE rgbSLKKey[__CB_DECL(PK_ENC_CIPHERTEXT_LEN)];

                    /* New SLK.  Extract the SLK and decrypt */
                    dr = DRM_XML_GetNodeA( (DRM_CHAR*) f_pbResponse,
                                           &dasstrTagData,
                                           &g_dastrTagSLKDATA,
                                            NULL,
                                            NULL,
                                            0,
                                            NULL,
                                           &dasstrNodeData );

                    cbidSLK = SIZEOF( rgbSLKKey );
                    dr = DRM_B64_DecodeA((DRM_CHAR *) f_pbResponse, 
                                         &dasstrNodeData, 
                                         &cbidSLK, 
                                          rgbSLKKey,
                                          0);

                    if( cbidSLK == SIZEOF( rgbSLKKey )
                     && DRM_SUCCEEDED( dr ) )
                    {
                        dr = DRM_BBX_RebindSLK( f_pcontextLEVL->pcontextBBX, 
                                                rgbSLKKey,
                                               &slkdata.slk );
                        if( DRM_SUCCEEDED( dr ) )
                        {
                            fNewSLKValid = TRUE;
                            MEMCPY( &slkdata.idSLK, &idSLKNew, SIZEOF( slkdata.idSLK ) );
                            
                            if( fPersist )
                            {
                                if( DRM_SUCCEEDED( DRM_SST_CreateLicenseStatePassword( &g_idSLKSST, 
                                                                                        rgbPasswordSST, 
                                                                           (DRM_BYTE *) f_pcontextLEVL->pcontextBBX) ) )
                                {
                                    (void)DRM_SST_SetData( f_pcontextLEVL->pcontextSSTLicense, 
                                                          &g_idSLKSST, 
                                                           NULL,
                                                           rgbPasswordSST,
                                                           SECURE_STORE_GLOBAL_DATA,
                                                           f_pcontextHDS,
                                               (DRM_BYTE*)&slkdata,
                                                   SIZEOF( slkdata ) );
                                }
                            }
                        }
                    }
                }
            }
        }

        fSLKValid = fNewSLKValid;
    }
    else
    {
        fSLKValid = FALSE;
    }
#endif

                                           
    /* for each license in dastrLicenseList, Add license to license store */
    for (iNode = 0; ; iNode++)
    {
        DRM_CONST_STRING dstrKID         = EMPTY_DRM_STRING;
        DRM_BYTE        *pbLicense       = NULL;
        DRM_DWORD        dwPriority      = 0;
#if SIXTEEN_BIT_ADDRESSING
        DRM_BYTE         bHead           = 0;
        DRM_BOOL         fDecryptOK      = FALSE;
#endif
        dr = DRM_XML_GetNodeA((DRM_CHAR*) f_pbResponse,
                             &dasstrLicenseList, 
                             &g_dastrTagLicense, 
                              NULL, 
                              NULL, 
                              iNode, 
                             &dasstrTagData, 
                             &dasstrNodeData);

        /* A <LICENSE> node was found. */
        
        if (DRM_SUCCEEDED(dr))
        {
            DRM_DWORD     cbVersionLicense     = 0;
            DRM_SUBSTRING dasstrVersionLicense = { 0 };

            /* Check the version information */
            dr = DRM_XML_GetNodeAttributeA((DRM_CHAR*) f_pbResponse,
                                           &dasstrTagData, 
                                           &g_adstrAttributeVersion, 
                                           &dasstrVersionLicense);

            if (DRM_FAILED(dr))
            {
                continue;
            }
            else if (DRM_UTL_DASSTRStringsEqual((DRM_CHAR *) f_pbResponse, 
                                               &dasstrVersionLicense, 
                                               &g_dastrPMLicenseVersionString))
            {
#if DRM_SUPPORT_V1_LICENSES
                /* It is a V1 license.  Callback to store it */
                if (f_pfnCallback)
                {
                    DRM_ANSI_CONST_STRING dastrV1License = EMPTY_DRM_STRING;
                    
                    /* NOTE:  This code will not work on 16 bit addressable systems
                    **        which is OK because the refcode doesn't natively support
                    **        V1 licenses anyway
                    */
                    dastrV1License.pszString = (DRM_CHAR*)f_pbResponse + dasstrNodeData.m_ich;
                    dastrV1License.cchString = dasstrNodeData.m_cch;

                    drReason = f_pfnCallback((DRM_VOID*)&dastrV1License, DRM_STORE_LICENSE_STORE_V1_LICENSE, f_pvCallbackContext);

                    if (DRM_SUCCEEDED(drReason))
                    {
                        cStored++;
                    }
                }
#endif
                continue;
            }
            else            
            {
#if DRM_SUPPORT_APP_REVOCATION
                DRM_DWORD cbCRLAppCurrent = SIZEOF (f_pcontextLEVL->contextEXPR);
#endif            
                /*
                **  Check to see if there is an "encrypted" attribute.
                **  If this value is 'false' then the license is directly inline.
                **  If 'true' or non-existent then the license is B64 encoded and
                **  privacy encrypted.
                */

                dr = DRM_XML_GetNodeAttributeA((DRM_CHAR*) f_pbResponse,
                                               &dasstrTagData, 
                                               &g_adstrAttributeEncrypted, 
                                               &dasstrVersionLicense);

                drReason = DRM_B64_DecodeA((DRM_CHAR *) f_pbResponse, 
                                            &dasstrNodeData, 
                                            &cbVersionLicense, 
                                             NULL, 
                                             DRM_BASE64_DECODE_IN_PLACE);

                if (DRM_FAILED(drReason))
                {
                    drReason = DRM_E_INVALIDLICENSE;
                    continue;
                }            

                if(  DRM_FAILED( dr )
                 || !DRM_UTL_DASSTRStringsEqual((DRM_CHAR *) f_pbResponse, 
                                                &dasstrVersionLicense, 
                                                &g_dastrAttributeFALSE))
                {
                    /* Attribute doesn't exist or it isn't set to FALSE */

                    /* License is base64 decoded.  Now it should be decrypted. */

#if SIXTEEN_BIT_ADDRESSING
                    /* DecryptLicense expects an aligned CHAR* pointer, not a packed one; rather than
                    change its interface this code temporarily moves a packed buffer into alignment */

                    if ((dasstrNodeData.m_ich % CB_NATIVE_BYTE) != 0)
                    {
                        pbLicense = f_pbResponse + (dasstrNodeData.m_ich & ~CB_NATIVE_BYTE);
                        
                        DRM_16B_IncrementPackedPointer(pbLicense, dasstrNodeData.m_cch, &bHead);
                    }
                    else
                    {
                        pbLicense = f_pbResponse + __CB_DECL(dasstrNodeData.m_ich);
                    }
                    
                    if( cbVersionLicense                         > PK_ENC_CIPHERTEXT_LEN
                     && cbVersionLicense - PK_ENC_CIPHERTEXT_LEN > DRM_MAX_LICENSESIZE )
                    {
                        drReason = DRM_E_BUFFERTOOSMALL;
                        continue;
                    }
                    
                    fDecryptOK = DRM_BBX_DecryptLicense(pbLicense, cbVersionLicense, f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD) ), f_pcontextLEVL->pcontextBBX);

                    if ((dasstrNodeData.m_ich % CB_NATIVE_BYTE) != 0)
                    {
                        DRM_16B_DecrementPackedPointer(pbLicense, dasstrNodeData.m_cch, bHead);
                    }

                    if (! fDecryptOK)
                    {
                        drReason = DRM_E_INVALIDLICENSE;
                        continue;
                    }
#else                
                    /* must always add this offset when ANSI B64 decoding in place */
                    /* TODO: add in other call points, even if index is zero */
                    
                    pbLicense = f_pbResponse + dasstrNodeData.m_ich;
                    if( cbVersionLicense                         > PK_ENC_CIPHERTEXT_LEN
                     && cbVersionLicense - PK_ENC_CIPHERTEXT_LEN > DRM_MAX_LICENSESIZE )
                    {
                        drReason = DRM_E_BUFFERTOOSMALL;
                        continue;
                    }

                    if(! DRM_BBX_DecryptLicense(pbLicense, cbVersionLicense, f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD ) ), f_pcontextLEVL->pcontextBBX))
                    {
                        drReason = DRM_E_INVALIDLICENSE;
                        continue;
                    }
#endif
                    cbVersionLicense -= PK_ENC_CIPHERTEXT_LEN;
                }
                else
                {
                    if( cbVersionLicense > DRM_MAX_LICENSESIZE )
                    {
                        drReason = DRM_E_BUFFERTOOSMALL;
                        continue;
                    }

                    /* License is inline.  Copy it to the license buffer */
                    DRM_BYT_CopyBytes( f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD ) ), 0, f_pbResponse, dasstrNodeData.m_ich, cbVersionLicense );
                }

#if DEBUG__SAVE_PROTOCOL_INFORMATION
                {
	                /* save the lic to a file */
	                OEM_FILEHDL fp=OEM_INVALID_HANDLE_VALUE;
	                DRM_DWORD dwNumberOfBytesWritten=0;

	                fp = OEM_OpenFile(
	                        L"c:\\licresp.xml", 
	                        OEM_GENERIC_READ|OEM_GENERIC_WRITE,
	                        OEM_FILE_SHARE_READ|OEM_FILE_SHARE_WRITE, 
	                        OEM_CREATE_NEW, 
	                        OEM_ATTRIBUTE_NORMAL);
	                if ( fp != OEM_INVALID_HANDLE_VALUE )
	                {
	                    OEM_WriteFile(fp, f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD ) ), cbVersionLicense, &dwNumberOfBytesWritten);
	                    OEM_CloseFile(fp);
	                }
                }
#endif

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
                DSTR_FROM_PB( &dstrKID, f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD ) ), cbVersionLicense );

                ChkDR( _UpdateLicenseWithSymmetricData( (DRM_STRING*)&dstrKID, 
                                                         DRM_MAX_LICENSESIZE, 
                                                         f_pcontextLEVL, 
                                                         fSLKValid ? &slkdata.slk : NULL ) );
                cbVersionLicense = CB_DSTR( &dstrKID );
#endif
                DSTR_FROM_PB( &f_pcontextLEVL->dstrContentLicense,
                              f_rgbLicenseBuffer + __CB_DECL( SIZEOF( DRM_DWORD ) ),
                              cbVersionLicense );
                f_pcontextLEVL->fUseCachedAttribs = FALSE;
                
                {
                    DRM_CONST_STRING dstrLIData = EMPTY_DRM_STRING;
                    
                    ChkDRContinue( DRM_LIC_GetAttribute( &f_pcontextLEVL->dstrContentLicense, 
                                                          NULL, 
                                                          DRM_LICENSE_ATTRIB_PRIORITY, 
                                                         &dstrLIData, 
                                                         &dstrKID, 
                                                          0 ) );    

                    ChkDRContinue( wcsntol( dstrKID.pwszString, dstrKID.cchString, (DRM_LONG *) &dwPriority ) );

                    ChkDRContinue( DRM_LIC_GetAttribute( &f_pcontextLEVL->dstrContentLicense, 
                                                          NULL, 
                                                          DRM_LICENSE_ATTRIB_LID, 
                                                         &dstrLIData, 
                                                         &dstrKID, 
                                                          0 ) );                    
                    ChkDRContinue( DRM_UTL_StringToGuid( &dstrKID, (DRM_GUID*)f_pcontextLEVL->LID.rgb ) );

                    ChkDRContinue( DRM_LIC_GetAttribute( &f_pcontextLEVL->dstrContentLicense, 
                                                          NULL, 
                                                          DRM_LICENSE_ATTRIB_KID, 
                                                         &dstrLIData, 
                                                         &dstrKID, 
                                                          0 ) );
                    ChkDRContinue( DRM_UTL_DecodeKID( &dstrKID, &f_pcontextLEVL->KID ) );
                    /* Do not change dstrKID after this call.  Later code depends on it really pointing to the KID */
                    
                    f_pcontextLEVL->fUseCachedAttribs = TRUE;
                }
                

                drReason = _EvaluateLicense( f_pcontextLEVL, 
                                             f_pcontextHDS,
                                             &dstrLIData );

                if ( f_plReason != NULL )
                {
                    *f_plReason = f_pcontextLEVL->lReasonForFail;
                }

                /* store the license if the license evaluated ok */
                if (DRM_SUCCEEDED(drReason) )
                {
#if DRM_SUPPORT_PLAYLIST_BURN
                    /* 
                    **  Save this data off early.  If SYNC is supported the lic eval context could get changed before
                    **  we notify for playlist burn 
                    */
                    DRM_DWORD cPlaylistBurnIncrement = f_pcontextLEVL->cPlaylistBurnIncrement;
#endif

                    drReason = DRM_LST_AddLicense(f_pcontextLST, 
                                                  CB_DSTR( &f_pcontextLEVL->dstrContentLicense ),
                                                  f_rgbLicenseBuffer,
                                                 &f_pcontextLEVL->KID,
                                                 &f_pcontextLEVL->LID,
                                                  dwPriority);
                    
                    if (DRM_SUCCEEDED(drReason))
                    {
                        cStored++;

                        if (f_pfnCallback != NULL)
                        {
#if DRM_SUPPORT_PLAYLIST_BURN
                            if (cPlaylistBurnIncrement > 0)
                            {
                                DRM_PLAYLIST_NOTIFICATION_STRUCT burnUpdate;

                                burnUpdate.pdstrKID = &dstrKID;
                                burnUpdate.cPlaylistBurnIncrement = cPlaylistBurnIncrement;
                                f_pfnCallback( (DRM_VOID*) &burnUpdate, DRM_STORE_LICENSE_NOTIFY_PLAYLIST_BURN_UPDATE, f_pvCallbackContext);
                            }
#endif
                            f_pfnCallback( (DRM_VOID*) &dstrKID, DRM_STORE_LICENSE_NOTIFY_KID, f_pvCallbackContext);
                        }
                    }
                } /* end if EvaluateLicense () succeeded */

#if DRM_SUPPORT_LICENSE_SYNC
                /* don't stop the license processing loop on a synclist failure */
                ChkDRContinue( DRM_SNC_UpdateKID(f_pcontextSync, f_pcontextASD, &f_pcontextLEVL->KID) );
#endif

                /* Fill the data back in with what could be valid base64.  If not the decoded license may
                    cause further calls into the xml parser to fail */
                
                DRM_BYT_SetBytes(f_pbResponse, 
                                 dasstrNodeData.m_ich, 
                                 dasstrNodeData.m_cch, 
                                 'a');
            }
        } /* end if got license tag */
        else
        {
            if (dr == DRM_E_XMLNOTFOUND)
            {
                /* no more license found */
                dr = DRM_SUCCESS;
                break;
            }

            ChkDR(dr);  /* other errors */
        }
    } /* end for license */

#if DRM_SUPPORT_ANTIROLLBACK_CLOCK
    /* Explicitly make the global secure store writeabele */
    f_pcontextLEVL->fGlobalSecStoreWritable = TRUE;
    ChkDR(DRM_LIC_CheckClockRollback( f_pcontextLEVL,
                                      f_pcontextLST,
                                      f_pcontextLEVL->pLicStoreEnumContext,
                                      f_pbResponse,
                                      f_cbResponse,
                                      f_pcontextHDS));
#endif

ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_LA_ProcessResponse", g_pwszLeavingFunction);

    if (DRM_SUCCEEDED(dr))
    {   
        if (iNode == 1 && cStored == 0)
        {
            if (DRM_FAILED(drReason))
            {
                /* Only one license in response. No license was stored. */
                dr = drReason;
            }
            else
            {
                dr = DRM_E_FAILED_TO_STORE_LICENSE;
            }
        }
        else if (iNode > 1 && cStored == 0)
        {
            /* None were stored. Return usual error as done in past. */
            dr = DRM_E_FAILED_TO_STORE_LICENSE;
        }
        else if (iNode > 1 && cStored < iNode)
        {
            /* Multiple licenses in response. One or more licenses were not stored. */
            dr = DRM_E_NOT_ALL_STORED;
        }
    }
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmlicacq.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_LA_H__
#define __DRM_LA_H__

#include <drmlicstore.h>
#include <drmliceval.h>
#include <drmviewprops.h>
#include <drmsyncstore.h>

#ifdef __cplusplus
extern "C" {
#endif

#if DRM_SUPPORT_DLA
#define CB_STACK_LICENSE_CHALLENGE ((((SIZEOF(CLIENTID)*4)/3)+8)*SIZEOF(DRM_WCHAR))

typedef struct __tagDRM_LICENSE_CHALLENGE
{
    /* XML context buffer */

    DRM_BYTE                *pbXML;    
    DRM_DWORD                cbXML;
    
    /* uplink entries */
    
    DRM_LICENSE_STATE_DATA   rglicensestatedata  [DRM_MAX_LICENSE_CHAIN_DEPTH+1];
    DRM_CONST_STRING         rgdstrUplinkKID     [DRM_MAX_LICENSE_CHAIN_DEPTH+1];
    DRM_DWORD                cUplinks;
    
    /* actions/rights */
    
    const DRM_CONST_STRING **ppdstrRights;
    DRM_DWORD                cRights;
    
    /* miscellaneous client data */
    
    DRM_CONST_STRING         dstrDeviceCert,
                             dstrClientIdentity,
                             dstrHeader,
                             dstrV1Challenge;
    DRM_DWORD                levelAppSecurity, 
                             idSubject;
    DRM_WCHAR               *pwszBBVer;
    CLIENTID                 clientid;

    DRM_BB_CONTEXT          *pcontextBBX;
    
    /* stack buffer */
    
    DRM_BYTE   rgbStack [__CB_DECL(CB_STACK_LICENSE_CHALLENGE)];     
} DRM_LICENSE_CHALLENGE;

/**********************************************************************
** Function:    DRM_LA_CreateChallenge
** Synopsis:    Creates and initializes a request context.
** Arguments:   [f_plicensechallenge] -- pointer to a DRM_LICENSE_CHALLENGE, whose members are initialized by the 
**                                     caller as follows:
**                  cbXML              -- for internal use
**                  pbXML              -- for internal use
**                  dstrHeader         -- WMRM Header extracted from media file
**                  pwszBbVer          -- NULL terminated string containing the blackbox version
**                  pdstrV1Challenge   -- pointer to a pregenerated V1 challenge string.  Can be NULL.
**                  clientid           -- CLIENTID structure created by the blackbox
**                  rgdstrUplinkKID    -- array of DRM_CONST_STRINGs, the KID's that were found in the 
**                                        content header (UPLINK kids)
**                  rglicensestatedata -- The current license state data for each KID in rgdstrKID
**                  cUplinks           -- The number of UPLINKS found in the header.  This is the length 
**                                        of the rgdstrUplinkKID and rglicensestatedata arrays
**                  ppdstrRights       -- array of DRM_CONST_STRING pointerss naming rights/actions
**                  cRights            -- array size of ppdstrRights
**                  dstrEncryptedCert  -- device certificate filled in by the caller.  This should be 
**                                        encrypted and base64 encoded (for privacy).
**                  pdstrClientIdentity-- string representation of the client id (encrypted/encoded old 
**                                        style certificate of the client
**                  levelAppSecurity   -- app security number preparsed from the device certificate
**                  idSubject          -- subject ID preparsed from the device certificate
**
**              [f_pszChallenge]       -- user-allocated buffer for challenge output, B64 encoded; NULL to query size
**              [f_cchChallenge]      -- size of pbChallenge
**
** Returns:     DRM_SUCCESS on success. On Failure, it returns:
**              DRM_E_INVALIDARG
**              DRM_E_BUFFERTOOSMALL
**
** Notes:       To get the minimum size required, first call with pbData and/or pbChallenge set to NULL. 
**              This will return DRM_E_BUFFERTOOSMALL and pcbData and pcbChallenge will point to values 
**              of minimum context size.
***********************************************************************/

DRM_RESULT DRM_API DRM_LA_CreateChallenge (
    IN DRM_LICENSE_CHALLENGE *f_plicensechallenge,
    OUT      DRM_CHAR        *f_pszChallenge,
    IN OUT   DRM_DWORD       *f_pcchChallenge);
   
/**********************************************************************
** Function:    DRM_LA_GetClientInfo
** Synopsis:    Creates CLIENTINFO 
** Arguments:   [f_pclientid] -- pointer to CLIENTID
**              [f_pbStack] -- pointer to stack for internal use.
**              [f_pcbStack] --pointer to size of f_pbStack in bytes
**              [f_pdstrClientVersionData] --pointer to drm string containing Client version info
**              [f_pdstrSecurityVersionData] -- pointer to drm string containing security version info
**              [f_AppSecurityData] -- Application security data.
**              [f_SubjectId1] --Subject ID1
**              [f_SubjectId2] --Subject ID2 (0 for no subject id2)
**              [f_pdstrDRMKVersion] --DRMK version(0 for no drmk version).
**              [f_pdstrEncryptedDevcert] --pointer to drm string containing encrypted devcert. Optional
**              [f_pbXML] --pointer to a buffer to get this client info.
**              [f_pcbXML] --pointer to size of f_pbXML in bytes
**              [f_fCreateNewDoc] --Flag. If TRUE, creates a new document otherwise add nodes to an existing document
** Returns:     DRM_SUCCESS on success, or failed with 
**              DRM_E_INVALIDARG,
**              DRM_E_BUFFERTOOSMALL.
** Sample CLIENTINFO:
**
**
** Add the following node/subnode to the request:
**
** <CLIENTINFO>
**    <CLIENTID>...</CLIENTID>
**    <CLIENTVERSION>...</CLIENTVERSION>
**    <SECURITYVERSION>...</SECURITYVERSION>
**    <APPSECURITY>...</APPSECURITY>
**    <SUBJECTID1>...</SUBJECTID1>
**    <SUBJECTID2>...</SUBJECTID2>
**    <DRMKVERSION>...</DRMKVERSION>
**    <DEVCERT>...</DEVCERT> optional
** </CLIENTINFO>
**
************************************************************************/

DRM_RESULT DRM_API DRM_LA_GetClientInfo (
    IN       CLIENTID               *f_pclientid,
    IN       DRM_BYTE               *f_pbStack,
    IN OUT   DRM_DWORD              *f_pcbStack,
    IN       DRM_CONST_STRING       *f_pdstrClientVersionData,
    IN       DRM_CONST_STRING       *f_pdstrSecurityVersionData,
    IN       DRM_DWORD               f_AppSecurityData,
    IN       DRM_DWORD               f_SubjectId1,
    IN       DRM_DWORD               f_SubjectId2,
    IN       DRM_CONST_STRING       *f_pdstrDRMKVersion,
    IN       DRM_CONST_STRING       *f_pdstrEncryptedDevcert,
    IN       DRM_BYTE               *f_pbXML,
    IN OUT   DRM_DWORD              *f_pcbXML,
    IN       DRM_CRYPTO_CONTEXT     *f_pcontextCRYP,
    IN       DRM_BOOL                f_fCreateNewDoc );

#endif

typedef enum
{
    DRM_STORE_LICENSE_NOTIFY_KID       = 1,  /* Callbacks with this reason will have pvData as a DRM_CONST_STRING */
    DRM_STORE_LICENSE_STORE_V1_LICENSE = 2   /* Callbacks with this reason will have pvData as a DRM_ANSI_CONST_STRING */

#if DRM_SUPPORT_PLAYLIST_BURN
    , DRM_STORE_LICENSE_NOTIFY_PLAYLIST_BURN_UPDATE = 3 /* Callbacks with this reason will have pvData as a DRM_PLAYLIST_NOTIFICATION_STRUCT */
#endif

} DRM_STORE_LICENSE_CALLBACK_ENUM;

#if DRM_SUPPORT_PLAYLIST_BURN
typedef struct 
{
    const DRM_CONST_STRING *pdstrKID;
    DRM_DWORD               cPlaylistBurnIncrement;
} DRM_PLAYLIST_NOTIFICATION_STRUCT;
#endif

typedef DRM_RESULT (DRM_API *pfnStoreLicenseCallback)( 
    IN DRM_VOID                        *pvData, 
    IN DRM_STORE_LICENSE_CALLBACK_ENUM  eReason, 
    IN DRM_VOID                        *pvContext );

/**********************************************************************
** Function:    DRM_LA_ProcessResponse
** Synopsis:    Process license request response received from license server
** Arguments:   [f_pbResponse] -- Response string received from license server
**              [f_cbResponse] -- size of pbResponse in bytes.
**              [f_pLicEvalContext] --pointer to the context of license eval object
**              [f_pbLicenseStoreContext] --pointer to the context of license store object
**              [f_pfnCallback] -- pointer to a callback function if the caller wants notification of successfull license stores
**              [f_pvCallbackContext] -- pointer to a context that will be passed to the callback function.
**              [f_poHdsContext] --pointer to the current HDS context that should be used
**              [f_pcontextViewRights] --pointer to a view rights context.  This is only used if Sync Support is enabled.
**              [f_rgbLicenseBuffer] -- Pointer to a buffer of size DRM_MAX_LICENSESIZE bytes.  This will be used as a temporary working buffer.
**              [f_plReason] -- to receive the reason code
** Returns:     DRM_SUCCESS on success, or failed with 
**              DRM_E_INVALIDARG,
**              DRM_E_INVALIDLICENSE, and
**              error codes from Licesne store.
** Notes:       This function process each license(s) contained in the response 
**              received from the license server. It tries to evaluate each license to see
**              if it can store in the license store.
** Sample Response:
**
** <LICENSERESPONSE>
**     <LICENSE version="2.0.0.0">
**         {base64-encoded DRMv7 License}
**     </LICENSE>
**     ...
**     <LICENSE version="2.0.0.0">
**         {base64-encoded DRMv7 License}
**     </LICENSE>
** </LICENSERESPONSE>
***********************************************************************
*/

DRM_RESULT DRM_API DRM_LA_ProcessResponse(
    IN     DRM_BYTE                *f_pbResponse,
    IN     DRM_DWORD                f_cbResponse,
    IN     DRM_LICEVAL_CONTEXT     *f_pLicEvalContext,
    IN     DRM_LICSTORE_CONTEXT    *f_pbLicenseStoreContext,
    IN     pfnStoreLicenseCallback  f_pfnCallback,
    IN     DRM_VOID                *f_pvCallbackContext,
    IN     DRM_HDS_CONTEXT         *f_poHdsContext,
    IN     DRM_VIEW_RIGHTS_CONTEXT *f_pcontextViewRights,
    IN     DRM_BYTE                 f_rgbLicenseBuffer[__CB_DECL(DRM_MAX_LICENSESIZE)],
    IN     DRM_SYNC_CONTEXT        *f_pcontextSync,
       OUT DRM_LONG                *f_plReason);

#ifdef __cplusplus
}
#endif

#endif  /* __DRM_LA_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmlicense.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRMLICENSE_H__
#define __DRMLICENSE_H__

#include "drmpkcrypto.h"


#ifdef __cplusplus 
extern "C" {
#endif

#define ISSUER_LEN           4
#define SUBJ_LEN             4
#define DATE_LEN             4
#define SER_NUM_LEN          4
#define INT_LEN				 4

#define VER_STRING_MAX_LEN 20

/* Constant indicating the number of times SHA has to be used to get the hash of key. */
/* This hash is used to check whether the key is good or bad. */
/* CHECKSUM_LENGTH indicates the number of bytes in final hash value to use as CHECKSUM. */
#define SHA_ITERATIONS      5
#define CHECKSUM_LENGTH     7
#define APPSEC_LEN   4
#define RIGHTS_LEN   4

/* V1 rights bits */
extern const DRM_BYTE RIGHT_PLAY_ON_PC            [__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_COPY_TO_NONSDMI_DEVICE[__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_NO_RESTORE            [__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_BURN_TO_CD            [__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_COPY_TO_SDMI_DEVICE   [__CB_DECL(RIGHTS_LEN)];
extern const DRM_BYTE RIGHT_ONE_TIME              [__CB_DECL(RIGHTS_LEN)];

extern const DRM_LID g_rgbSecStoreGlobalName;


/* Version Format: a.b.c.d */
/*            a = not used. */
/*            b = major version */
/*            c = minor version */
/*            d = revision version */

extern const DRM_CONST_STRING g_dstrDRM_VERSION_STRING;
extern const DRM_BYTE DRM_VERSION    [__CB_DECL(VERSION_LEN)];
extern const DRM_BYTE PK_VER         [__CB_DECL(VERSION_LEN)]; /* Indicates the version of the pubkey to be used for verification of PK CERT. */
extern const DRM_BYTE KEYFILE_VER    [__CB_DECL(VERSION_LEN)]; /* Version of the key file. */
extern const DRM_BYTE LICREQUEST_VER [__CB_DECL(VERSION_LEN)];
extern const DRM_BYTE CERT_VER       [__CB_DECL(VERSION_LEN)]; /* Indicates the public root key needed to verify the license server certificates. */
extern const DRM_BYTE LICENSE_VER    [__CB_DECL(VERSION_LEN)]; /* Indicates the license version delivered. */
extern const DRM_BYTE CLIENT_ID_VER  [__CB_DECL(VERSION_LEN)]; /* The version for client id. */
extern const DRM_BYTE CONTENT_VERSION[__CB_DECL(VERSION_LEN)]; /* Content Version. Keep this in sync with CONTENT_VERSION_STRING above. */
extern const DRM_BYTE PM_LICENSE_VER [__CB_DECL(VERSION_LEN)]; /* Indicates the license version delivered to PMs */


extern const PUBKEY g_pubkeyLicenseServer;

typedef struct CERTDATAtag{
    PUBKEY pk;
    DRM_BYTE expiryDate  [__CB_DECL(DATE_LEN)];
    DRM_BYTE serialNumber[__CB_DECL(SER_NUM_LEN)];
    DRM_BYTE issuer      [__CB_DECL(ISSUER_LEN)];
    DRM_BYTE subject     [__CB_DECL(SUBJ_LEN)];
} CERTDATA, *PCERTDATA;


typedef struct CERTtag{
    DRM_BYTE certVersion[__CB_DECL(VERSION_LEN)];
    DRM_BYTE datalen    [__CB_DECL(INT_LEN)];
    DRM_BYTE sign       [__CB_DECL(PK_ENC_SIGNATURE_LEN)];
    CERTDATA cd;
} CERT, *PCERT;



typedef struct {
	PK pk;
	DRM_BYTE appSec [__CB_DECL(APPSEC_LEN)];
	DRM_BYTE subject[__CB_DECL(SUBJ_LEN)];
} APPCERTDATA;

typedef struct {
	DRM_BYTE appcertVersion[__CB_DECL(VERSION_LEN)];
	DRM_BYTE datalen       [__CB_DECL(INT_LEN)];
	DRM_BYTE sign          [__CB_DECL(PK_ENC_SIGNATURE_LEN)];
	APPCERTDATA appcd;
} APPCERT;

typedef struct __tagDRM_CRYPTO_CONTEXT
{
    DRM_BYTE rgbCryptoContext[__CB_DECL(DRM_PKCRYPTO_CONTEXT_BUFFER_SIZE)];   /* size of the buffer pkcrypto code needs. Note this may have alignment problems. */
    PUBKEY   pubKey;  /* 40 BYTES */
    PUBKEY   pubKey2; /* 40 BYTES */
    union 
    {
        CERT     cert;    /* 108 bytes */
        PKCERT   pkcert;  /* 84 bytes  */
    } union_cert;
    DRM_BYTE signature[__CB_DECL(PK_ENC_SIGNATURE_LEN)];   /* 40 BYTES     */
} DRM_CRYPTO_CONTEXT;

typedef struct __tagCLIENTID
{
	DRM_BYTE version[__CB_DECL(VERSION_LEN)];
    DRM_BYTE randNum[__CB_DECL(PK_ENC_CIPHERTEXT_LEN)];
    PKCERT pk;
} CLIENTID;


typedef struct __tagDRM_V1Header 
{
    DRM_BYTE  *pbKeyID;
    DRM_DWORD  cbKeyID;
    DRM_BYTE  *pbSecretData;
    DRM_DWORD  cbSecretData;
    DRM_BYTE  *pbURL;
    DRM_DWORD  cbURL;
    DRM_BYTE   bBuffer[1];
} DRM_V1Header;

#ifdef __cplusplus 
}
#endif

#endif /* __DRMLICENSE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmlicreason.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


/* Description: The error codes to indicate the reason why a license is not usable.
              The error codes are used to give a better feedback to the user.
              These codes are used in the license to indicate the reason.
              drm.reason variable is set to this reason.
*/

#ifndef __LICREASON_H__
#define __LICREASON_H__

#ifdef __cplusplus
extern "C" {
#endif

/* Server can help with these values. These are reasons why a license that was just obtained is not usable. */
/* Clearly, playcount cannot be a reason unless the count started with 0. Similarly, clockrollback is not a reason. */
enum 
{
    LR_LICENSE_EXPIRED = 1,
    LR_LICENSE_NOTENABLED = 2,
    LR_LICENSE_APPSECLOW = 3,
    LR_LICENSE_NEEDINDI = 4,
    LR_LICENSE_STORE_NOT_ALLOWED = 5,
    LR_LICENSE_APP_NOT_ALLOWED = 6,
    LR_LICENSE_PLEDGE_LICENSE = 7,
    LR_LICENSE_CERT_EXPIRED = 8,
    LR_LICENSE_SECLOW = 9,
    LR_LICENSE_CONTENT_REVOKED = 10,
    LR_LICENSE_DEVICE_NOT_REGISTERED = 11,
    LR_LICENSE_TRACK_BURN_LIMIT_EXCEEDED = 12
};

/* Client side detectable reasons */
enum
{
    LR_LICENSE_NOSAP = 50,
    LR_LICENSE_NOSVP,
    LR_LICENSE_NOWDM,
    LR_LICENSE_NOTRUSTEDCODEC,
    LR_LICENSE_DUMMY_TO_SIGNAL_END2,
	LR_LICENSE_NEED_UPGRADE_MSSAP,		/* special cases as the corresponding error codes in nserror.h are not consecutive to the others */
	LR_LICENSE_INVALID_APPLICATION,
    LR_LICENSE_CLOCK_NOT_SET
};

#ifdef __cplusplus
}
#endif

#endif /* __LICREASON_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmliceval.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#ifndef __DRMLICEVAL_H__
#define __DRMLICEVAL_H__

#include <drmsecurestore.h>
#include <drmexpreval.h>
#include <drmblackbox.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Flags for use with SetLicense method */
enum
{    
    LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK    = 1,
    LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK = 2,
    LICEVAL_VERIFY_SIGNATURE                = 4,
    LICEVAL_VERIFY_IGNORE_VERIFICATION      = 8
};


#define LICEVAL_STORE_CHECK_SETTINGS             (LICEVAL_VERIFY_CERT_WITH_EXPIRYCHECK|LICEVAL_VERIFY_SIGNATURE) 
#define LICEVAL_OPEN_CHECK_SETTINGS              (LICEVAL_VERIFY_CERT_WITHOUT_EXPIRYCHECK|LICEVAL_VERIFY_SIGNATURE)

/* Possible drmresults. This can be mapped to the error messages specified in the array at the end. */
#define LICEVAL_BASECODE                        0x1300
#define LICEVAL_PARAM_NOT_OPTIONAL              MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+1)
#define LICEVAL_MEMORY_ALLOCATION_ERROR         MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+2)
#define LICEVAL_INIT_FAILURE                    MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+3)

#define LICEVAL_LICENSE_NOT_SUPPLIED            MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+4)
#define LICEVAL_UNSUPPORTED_LIC_VERSION         MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+5)
#define LICEVAL_INVALID_LICENSE                 MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+6)
#define LICEVAL_LICENSE_NOT_VALIDATED           MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+7)
#define LICEVAL_EVENT_MISSING                   MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+8)
#define LICEVAL_FIELD_MISSING                   MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+9)

#define LICEVAL_CONTENT_HEADER_NOT_SUPPLIED     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+10)
#define LICEVAL_UNSUPPORTED_CONTENT_VERSION     MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+11)
#define LICEVAL_INVALID_CONTENT_HEADER          MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+12)
#define LICEVAL_CONTENT_HEADER_NOT_VALIDATED    MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+13)
#define LICEVAL_KID_MISMATCH                    MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+14)
#define LICEVAL_CONTENT_SIGNATURE_FAILURE       MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+15)
#define LICEVAL_UNKNOWN_ERROR                   MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+16)
#define LICEVAL_LICENSE_REVOKED                 MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+17)
#define LICEVAL_RETRIEVAL_FAILURE               MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+18)
#define LICEVAL_UPDATE_FAILURE                  MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+19)
#define LICEVAL_BAD_CONTENT_REVOCATION          MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+20)
#define LICEVAL_EXPIRED_CERT                    MAKE_DRM_RESULT(DRM_SEVERITY_ERROR,  DRM_FACILITY_ITF, LICEVAL_BASECODE+21)


typedef struct __tagDRM_APPCERT_INFO
{
    DRM_DWORD appSec;
    DRM_DWORD appcd_subject;
} DRM_APPCERT_INFO;

typedef enum
{
    LICEVAL_NOREFERENECE                    = 0,
    LICEVAL_MACHINEDATETIMEREFERENCED       = 1,
    LICEVAL_GRACEPERIODREFERENCED           = 2
}eDRM_LICEVAL_TIMEBASED_STATE;

typedef enum
{    
    eDRM_LIC_CACHED_ATTRIB_KID = 0,
    eDRM_LIC_CACHED_ATTRIB_LID,
    eDRM_LIC_CACHED_ATTRIB_CONTENTPUBKEY,
    eDRM_LIC_CACHED_ATTRIB_METERING_ID,
    eDRM_LIC_CACHED_ATTRIB_CHAINEDKID,
    eDRM_LIC_CACHED_ATTRIB_LAST
} eDRM_LIC_CACHED_ATTRIBS;

typedef struct tagDRM_CACHED_EVENT
{
    DRM_CONST_STRING    dstrType;
    DRM_CONST_STRING    dstrAction;
    DRM_CONST_STRING    dstrCondition;
    DRM_CONST_STRING    dstrRestriction;
} DRM_CACHED_EVENT;

#if DRM_SUPPORT_REVOCATION
/*
**  Current revocation list values should be placed in this struct and passed to CompleteChain so licenses can be compared against these
**  values.
*/
typedef struct __tagDRM_REVLIST_ID_VALUES
{
    DRM_DWORD app;
    DRM_DWORD device;
    DRM_DWORD wmdrmnet;
    DRM_DWORD riv;
}DRM_REVLIST_ID_VALUES;
#endif

typedef struct __tagDRM_LICEVAL_CONTEXT
{
    DRM_BB_CONTEXT              *pcontextBBX;
    APPCERT                      appcert;
    EXPR_EVAL_CONTEXT            contextEXPR;
    DRM_CONST_STRING             dstrContentHeader;
    DRM_CONST_STRING             dstrContentLicense;
    DRM_CONST_STRING             dstrBBVer;
    DRM_CONST_STRING             dstrDRMVer;
    DRM_CONST_STRING             dstrDRMKVer;    
    DRM_SECSTORE_CONTEXT        *pcontextSSTLicense;
    DRM_SECSTORE_CONTEXT        *pcontextSSTGlobal;
    DRM_SECSTORE_CONTEXT        *pcontextSSTRevocation;
    DRM_LICSTOREENUM_CONTEXT    *pLicStoreEnumContext;
    DRM_APPCERT_INFO             certinfoSDK;
    DRM_APPCERT_INFO             certinfoApp;
    DRM_BOOL                     fAppInfoValid;
    DRM_DWORD                    dwChainDepth;
    DRM_BOOL                     fDeviceRegistered;      /* TRUE if the device is registered */
    DRM_LID                      LID;
    DRM_KID                      KID;
    DRM_BOOL                     fGlobalSecStoreWritable;
    DRM_LONG                     lReasonForFail;
    const DRM_CONST_STRING      *pwszPMLicVersion;       /* IN:  Set to a string that represents the PM license version */
    DRM_LONG                     lPMAppSec;              /* IN:  Set to the app sec of the PM */
    DRM_LONG                     lPMRights;              /* This is an OUT param.  If CREATE_PM_LICENSE was queries this will contain the rights bits of the license to create */
    DRMSYSTEMTIME                PMExpiryDate;           /* This is an OUT param.  If CREATE_PM_LICENSE was queries this will contain the expiry date */
    DRM_CONST_STRING             wszDRMKParam;           /* This is an OUT string.  After a license is evaluated this will point to a version string if SAP is required */
    DRM_DWORD                    dwFlags;                /* Default as this LICEVAL_OPEN_CHECK_SETTINGS */
    DRM_BYTE                    *pbRevocationBuffer;     /* User gives a point to work in.  This is actually going to be used for revocation from the secure store */
    DRM_DWORD                    cbRevocationBuffer;     /* Size of the user supplied pointer */    
    DRM_BOOL                     fReserved;              /* Must be initialized to 0 */
    DRM_BOOL                     fSecureTimeDataValid;   /* Is secure time data valid.Must be initialized to 0 */
    DRM_BOOL                     fInGracePeriod;         /* Is in Grace period */
    DRM_UINT64                   u64GPStartTime;         /*Grace period duration*/
    DRM_DWORD                    cPlaylistBurnIncrement; /* OUT:  If playlist burn is supported this will set (if the license also sets it) */
    DRM_HDS_CONTEXT             *pcontextHDS;
    DRM_BOOL                     fIgnoreTimeBoundLicense;
    eDRM_LICEVAL_TIMEBASED_STATE eTimeBasedState;
#if DRM_SUPPORT_REVOCATION
    DRM_REVLIST_ID_VALUES        idCRLsCurrent;
    DRM_BOOL                     fUpdatedRevocationList;
#endif
    DRM_BOOL                     fDeleteLicense;
    
    DRM_BOOL                     fUseCachedAttribs;
    DRM_CONST_STRING rgdstrCachedAttribs[ eDRM_LIC_CACHED_ATTRIB_LAST ]; 
    DRM_CACHED_EVENT rgCachedEvents[ DRM_MAX_ACTIONS ];
    DRM_DWORD        cCachedEvents;
} DRM_LICEVAL_CONTEXT;

typedef enum
{
    DRM_LICENSE_EVAL_SELECT = 1,
    DRM_LICENSE_EVAL_DELETE = 2,
    DRM_LICENSE_EVAL_STORE = 3,
    DRM_LICENSE_EVAL_REPORTCLOCK_ROLLBACK = 4,  /* Only use DRM_LICENSE_EVAL_DONE_WITH_OPERATION for clock rollback. */
    DRM_LICENSE_EVAL_ACTION = 5                 /* With ACTION you must provide an action string */
} eDRM_LICEVAL_OPERATIONS;

typedef enum
{
    DRM_LICENSE_EVAL_CAN_DO_OPERATION = 1,
    DRM_LICENSE_EVAL_DONE_WITH_OPERATION = 2
} eDRM_LICEVAL_OPERATION_STATE;


DRM_RESULT DRM_API DRM_LEVL_PerformOperations(
    IN  DRM_LICEVAL_CONTEXT          *pcontextLicenseEval,
    IN  eDRM_LICEVAL_OPERATIONS       eOperation,
    IN  eDRM_LICEVAL_OPERATION_STATE  eOperationState,
    IN  const DRM_CONST_STRING       *pdstrAction,     /* Only required if DRM_LICENSE_EVAL_ACTION is passed as eOperation */
    OUT DRM_BOOL                     *pfPerform,
    OUT DRM_BOOL                     *pfActionExisted,
    IN  DRM_HDS_CONTEXT              *pcontextHDS);

DRM_RESULT DRM_API DRM_LEVL_EvaluateExpression(
    IN       DRM_LICEVAL_CONTEXT *pcontextLicenseEval,
    IN const DRM_CONST_STRING    *pdstrExpression,
    IN       DRM_BOOL            *pfValue);

DRM_RESULT DRM_API DRM_LEVL_IsLicenseReadyForDeletion( 
    IN  DRM_LICEVAL_CONTEXT *pContext,
    OUT DRM_BOOL            *pfDelete);

#ifdef __cplusplus
}
#endif

#endif /* __DRMLICEVAL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmlicstore.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmlicenseparser.h>
#include <drmlicstore.h>
#include <drmhds.h>


/*************************************************************************
** local constants
**************************************************************************/
static const DRM_WORD _wLicenseNumChildren=16;
static const DRM_HDS_NAMESPACE _oLicenseStoreNamespace = { TWO_BYTES('L', 'i'), TWO_BYTES('c', 'S'), TWO_BYTES('t', 'o'), TWO_BYTES('r', 'e') };

/*************************************************************************
** static functions
**************************************************************************/

/*
** Load the prioritiszed list
*/
static DRM_RESULT _LoadPrioritizedList(
    _LicEnumContext *pEnum)
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_DWORD i=0;
    DRM_HDS_SLOT_CONTEXT slotContextTemp;

    ChkArg(pEnum != NULL);
    pEnum->List.oPrioritized.nNumLicenses  = 0;
    pEnum->List.oPrioritized.nNextLicIndex = 0;
    while (TRUE)
    {
        DRM_BOOL fInserted=FALSE;
        DRM_DWORD iList = MAX_PRILIC_LIST;
        DRM_HDS_SLOT_CONTEXT *pslotContext = &pEnum->oSlotContext;


        if( pEnum->List.oPrioritized.nNumLicenses == 0 )
        {
            pslotContext = &slotContextTemp;
            iList = 0;
        }

        dr = DRM_HDS_SlotEnumNext(&pEnum->oHdsEnumContext,
                                pslotContext,
                                &pEnum->List.oPrioritized.oKID,
                                &pEnum->List.oPrioritized.pPrioritizedList[iList].oLID,
                                NULL);

        if ( dr == DRM_E_NOMORE )
        {
            if( pEnum->List.oPrioritized.nNumLicenses == 1 )
            {
                ChkDR(DRM_HDS_CloseSlot(&slotContextTemp));
            }
            
            dr = DRM_SUCCESS;
            break;
        }
        ChkDR(dr);

        ChkDR( DRM_HDS_MakeSlotHint( pslotContext, &(pEnum->List.oPrioritized.pPrioritizedList[iList].slotHint) ) );

        if( pEnum->List.oPrioritized.nNumLicenses == 0 )
        {
            /* In an attempt to optimize the case where we only have 1 license and save reading the
               priority from the slot we will defer the slot read until we have 2 licenses */
            pEnum->List.oPrioritized.nNumLicenses++;
            continue;
        }
        else if( pEnum->List.oPrioritized.nNumLicenses == 1 )
        {
            /* There are more than 1 license.  Read the first license's priority and add it to the list
               and continue with regular processing */
            ChkDR(DRM_HDS_SlotRead(&slotContextTemp,
                                   SIZEOF(DRM_DWORD),
                                   (DRM_BYTE*)&(pEnum->List.oPrioritized.pPrioritizedList[0].dwPriority),
                                   NULL));
            FIX_ENDIAN_DWORD( pEnum->List.oPrioritized.pPrioritizedList[0].dwPriority );
            ChkDR(DRM_HDS_CloseSlot(&slotContextTemp));
        }

        /* load the license's priority */
        ChkDR(DRM_HDS_SlotRead(&pEnum->oSlotContext,
                               SIZEOF(DRM_DWORD),
                               (DRM_BYTE*)&(pEnum->List.oPrioritized.pPrioritizedList[iList].dwPriority),
                               NULL));
        FIX_ENDIAN_DWORD( pEnum->List.oPrioritized.pPrioritizedList[iList].dwPriority );
        ChkDR(DRM_HDS_CloseSlot(&pEnum->oSlotContext));

        /* Merge this license to the list */ 
        for (i=0; i<pEnum->List.oPrioritized.nNumLicenses; i++)
        {
            DRM_DWORD j=0;
            if ( pEnum->List.oPrioritized.pPrioritizedList[MAX_PRILIC_LIST].dwPriority > pEnum->List.oPrioritized.pPrioritizedList[i].dwPriority )
            {
                /* bump the licenses from i to rest and insert the new license to pos i */
                j = (pEnum->List.oPrioritized.nNumLicenses==MAX_PRILIC_LIST)? 
                    pEnum->List.oPrioritized.nNumLicenses-1 : pEnum->List.oPrioritized.nNumLicenses;
                
                for (; j>i; j--)
                {
                    MEMCPY(&pEnum->List.oPrioritized.pPrioritizedList[j], 
                           &pEnum->List.oPrioritized.pPrioritizedList[j-1], 
                           SIZEOF(_PrioritizedLicense));
                }

                MEMCPY(&pEnum->List.oPrioritized.pPrioritizedList[i], 
                       &pEnum->List.oPrioritized.pPrioritizedList[MAX_PRILIC_LIST], 
                       SIZEOF(_PrioritizedLicense));
                
                if ( pEnum->List.oPrioritized.nNumLicenses < MAX_PRILIC_LIST )
                {
                    ++pEnum->List.oPrioritized.nNumLicenses;
                }

                fInserted = TRUE;
                break;
            }
        }

        if ( !fInserted && pEnum->List.oPrioritized.nNumLicenses < MAX_PRILIC_LIST )
        {
            MEMCPY(&pEnum->List.oPrioritized.pPrioritizedList[pEnum->List.oPrioritized.nNumLicenses],
                   &pEnum->List.oPrioritized.pPrioritizedList[MAX_PRILIC_LIST], 
                   SIZEOF(_PrioritizedLicense));

            ++pEnum->List.oPrioritized.nNumLicenses;
        }
    }
    
ErrorExit:
    return dr;
}

/**************************************************************************
** API functions
* *************************************************************************/


DRM_RESULT DRM_API DRM_LST_Open( 
    OUT DRM_LICSTORE_CONTEXT *pbLicContext,
    IN  DRM_HDS_CONTEXT      *poHdsContext )
{
    DRM_RESULT dr=DRM_SUCCESS;
    _LicContext *pLS=(_LicContext*)pbLicContext;
    
    ChkArg(pbLicContext != NULL);
    DRMSIZEASSERT( SIZEOF( _LicContext ), SIZEOF( DRM_LICSTORE_CONTEXT ) );

    /* open the namespace for the LicenseStore */
    ChkDR( DRM_HDS_OpenNamespace( poHdsContext, 
                                  &_oLicenseStoreNamespace, 
                                  eDRM_HDS_CREATE_IF_NEW | eDRM_HDS_LOCKWAIT,
                                  _wLicenseNumChildren,
                                  &pLS->oNamespaceContext ) );                                   
    pLS->fInited = TRUE;
    pLS->pDeviceStoreContext = poHdsContext;

ErrorExit:
   /* if ( DRM_FAILED(dr) && poHdsContext )
        DRM_UninitDeviceStore(); */

    return dr;
}


DRM_RESULT DRM_API DRM_LST_Close( 
    IN DRM_LICSTORE_CONTEXT *pbLicContext)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _LicContext * pLS=(_LicContext *)pbLicContext;
    
    ChkArg(pbLicContext != NULL);

    if( pLS->fInited )
    {
        ChkDR(DRM_HDS_CloseNamespace(&pLS->oNamespaceContext));
    }

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_LST_AddLicense(
    IN DRM_LICSTORE_CONTEXT *pbLicContext,
    IN DRM_DWORD             cbLicense,
    IN DRM_BYTE             *pbLicense,
    IN DRM_KID              *pkid,
    IN DRM_LID              *plid,
    IN DRM_DWORD             dwPriority )
{
    DRM_RESULT dr=DRM_SUCCESS;
    DRM_CONST_STRING dstrLicense = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrValue   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrLIData  = EMPTY_DRM_STRING;
    _LicContext * pLS=(_LicContext *)pbLicContext;
    DRM_HDS_HASHKEY oKID; 
    DRM_HDS_UNIQUEKEY oLID;
    DRM_DWORD nPriority=0;
    DRM_DWORD dwSize = 0;
    DRM_BOOL fCompatWrite = FALSE;

    ChkArg( pbLicContext != NULL
         && pbLicense    != NULL
         && cbLicense    !=0 
         && (cbLicense    < cbLicense+sizeof(DRM_DWORD)) /* Test for wrap around */
         && pLS->fInited );

    nPriority = dwPriority;
    if( pkid == NULL
     || plid == NULL )
    {
        /* To support older clients that just pass in a license buffer with no 
           preparsed data we can extract it.  The preferred method is for the caller
           to pass in this data */
        fCompatWrite = TRUE;
        DSTR_FROM_PB( &dstrLicense, pbLicense, cbLicense );
        ChkDR( DRM_LIC_GetAttribute( &dstrLicense, NULL, DRM_LICENSE_ATTRIB_KID, &dstrLIData, &dstrValue, 0 ) );
        ChkDR( DRM_UTL_DecodeKID( &dstrValue, &oKID ) );
        ChkDR( DRM_LIC_GetAttribute( &dstrLicense, NULL, DRM_LICENSE_ATTRIB_LID, &dstrLIData, &dstrValue, 0 ) );
        ChkDR( DRM_UTL_StringToGuid(&dstrValue, (DRM_GUID*)(oLID.rgb)) );
        ChkDR( DRM_LIC_GetAttribute( &dstrLicense, NULL, DRM_LICENSE_ATTRIB_PRIORITY, &dstrLIData, &dstrValue, 0 ) );    
        ChkDR( wcsntol( dstrValue.pwszString, dstrValue.cchString, (DRM_LONG *) &nPriority ) );
        pkid = &oKID;
        plid = &oLID;
    }
    
    /* allocate a slot in the license store */ 
    dwSize = cbLicense + SIZEOF(DRM_DWORD);
    ChkDR( DRM_HDS_OpenSlot(&pLS->oNamespaceContext, 
                            eDRM_HDS_CREATE_IF_NEW | eDRM_HDS_LOCKEXCLUSIVE | eDRM_HDS_LOCKWAIT, 
                            pkid, 
                            plid, 
                            NULL, 
                            &dwSize, 
                            &pLS->oSlotContext) );

    FIX_ENDIAN_DWORD( nPriority );
    if( fCompatWrite )
    {
        ChkDR(DRM_HDS_SlotWrite(&pLS->oSlotContext, SIZEOF(DRM_DWORD), (DRM_BYTE *)&nPriority, NULL));
        ChkDR(DRM_HDS_SlotWrite(&pLS->oSlotContext, cbLicense,         pbLicense,              NULL));
    }
    else
    {
        MEMCPY( pbLicense, &nPriority, SIZEOF(DRM_DWORD) );
        ChkDR(DRM_HDS_SlotWrite(&pLS->oSlotContext, dwSize, pbLicense, NULL));
    }

    ChkDR(DRM_HDS_CloseSlot(&pLS->oSlotContext));

#if !_DATASTORE_WRITE_THRU
    ChkDR(DRM_HDS_CommitStore(pLS->pDeviceStoreContext));
#endif

ErrorExit:    
    return dr;
}


DRM_RESULT DRM_API DRM_LST_GetLicense( 
    IN     DRM_LICSTORE_CONTEXT *pbLicContext,
    IN     DRM_KID              *pKID,      /* key to use for the query */
    IN     DRM_LID              *pLID, 
    IN     DRM_HDS_SLOT_HINT    *pSlotHint,
       OUT DRM_BYTE             *pbLicense, 
    IN OUT DRM_DWORD            *pcbLicense)
{
    DRM_RESULT dr=DRM_SUCCESS;
    _LicContext * pLS=(_LicContext *)pbLicContext;
    DRM_DWORD cbSlotSize=0;
   
    ChkArg( pbLicContext != NULL
         && pcbLicense   != NULL
         && pKID         != NULL
         && pLID         != NULL );

    /* get size of SlotContext */
    ChkDR( DRM_HDS_OpenSlot(&pLS->oNamespaceContext, 
                            eDRM_HDS_OPEN_EXISTING | eDRM_HDS_LOCKWAIT, 
                            pKID, 
                            pLID, 
                            pSlotHint,
                            &cbSlotSize, 
                            &pLS->oSlotContext) );

    /* check size of license buffer */
    if ( *pcbLicense < (cbSlotSize-SIZEOF(DRM_DWORD) ) )
    {
        *pcbLicense = (cbSlotSize-SIZEOF(DRM_DWORD));
        ChkDR(DRM_HDS_CloseSlot(&pLS->oSlotContext));
        ChkDR(DRM_E_BUFFERTOOSMALL);
    }

    /* read the license */
    ChkDR(DRM_HDS_SlotSeek(&pLS->oSlotContext, SIZEOF(DRM_DWORD), eDRM_HDS_SEEKSET, NULL));
    ChkArg(pbLicense);
    ChkDR(DRM_HDS_SlotRead(&pLS->oSlotContext, cbSlotSize, pbLicense, pcbLicense));
    ChkDR(DRM_HDS_CloseSlot(&pLS->oSlotContext));

ErrorExit:    
    return dr;
}


DRM_RESULT DRM_API DRM_LST_InitEnum(
    IN  DRM_LICSTORE_CONTEXT     *pbLicContext, 
    IN  DRM_KID                  *pKID,           /* if NULL, all licenses will be enum'ed */
    IN  DRM_BOOL                  fPrioritized,   /* ignored if pKID is NULL */
    OUT DRM_LICSTOREENUM_CONTEXT *pLicEnumContext)
{
    DRM_RESULT dr=DRM_SUCCESS;  
    _LicContext     *pLS   = (_LicContext *)   pbLicContext;
    _LicEnumContext *pEnum = (_LicEnumContext*)pLicEnumContext;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_LST_InitEnum", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    ChkArg( pbLicContext    != NULL
         && pLicEnumContext != NULL
         && pLS->fInited );

    DRMSIZEASSERT(SIZEOF(DRM_LICSTOREENUM_CONTEXT), SIZEOF(_LicEnumContext));

    ZEROMEM(pLicEnumContext, SIZEOF(_LicEnumContext));
    dr = DRM_HDS_InitSlotEnum(
                &pLS->oNamespaceContext, 
                pKID, 
                eDRM_HDS_LOCKSHARED | eDRM_HDS_LOCKWAIT, 
                &pEnum->oHdsEnumContext);
    if( dr == DRM_E_HDSSLOTNOTFOUND )
    {
        /* No licenses found. */
        pEnum->eMode = eLicEnumNone;
        pEnum->List.oPrioritized.nNumLicenses = pEnum->List.oPrioritized.nNextLicIndex = 0;
        dr = DRM_SUCCESS;
    }
    else if( DRM_FAILED( dr ) )
    {
        goto ErrorExit;
    }
    else if ( pKID != NULL )
    {
        MEMCPY(pEnum->List.oNonPrioritized.oCurrKID.rgb, pKID->rgb, DRM_ID_SIZE);
        if ( fPrioritized )
        {
            MEMCPY(pEnum->List.oPrioritized.oKID.rgb, pKID->rgb, DRM_ID_SIZE);
            ChkDR(_LoadPrioritizedList(pEnum));
            pEnum->eMode = eLicEnumPrioritized;
        }
        else
        {
            pEnum->eMode = eLicEnumFiltered;
            pEnum->List.oNonPrioritized.fCurrIsValid = FALSE;
        }
    }
    else
    {
        pEnum->eMode = eLicEnumNatural;
        pEnum->List.oNonPrioritized.fCurrIsValid = FALSE;
    }
    pEnum->fInited = TRUE;
    pEnum->pLS = pLS;

ErrorExit:    

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_LST_InitEnum", g_pwszLeavingFunction);
    return dr;
}


/*
**
*/
DRM_RESULT DRM_API DRM_LST_EnumNext( 
    IN DRM_LICSTOREENUM_CONTEXT *pLicEnumContext,    /* setup by DRM_LST_InitEnum() */
    OUT DRM_KID                 *pKID,               /* if priortized or pKID is given, this is optional */
    OUT DRM_LID                 *pLID,
    OUT DRM_HDS_SLOT_HINT       *pSlotHint,
    OUT DRM_DWORD               *pcbLicense)         /* License size */
{
    DRM_RESULT dr=DRM_SUCCESS;
    _LicEnumContext *pEnum = (_LicEnumContext*)pLicEnumContext;

    DRM_PROFILING_ENTER_SCOPE(L"DRM_LST_EnumNext", g_pwszEnteringFunction, DRM_PROFILING_DONT_START);

    ChkArg( pLicEnumContext != NULL
         && pLID            != NULL
         && pEnum->fInited           );

    DRMSIZEASSERT(SIZEOF(DRM_LICSTOREENUM_CONTEXT), SIZEOF(_LicEnumContext));

    if ( pEnum->eMode == eLicEnumNone )
    {
        ChkDR( DRM_E_NOMORE );
    }

    if ( pcbLicense != NULL )
    {
        *pcbLicense = 0;
    }

    if ( pEnum->eMode == eLicEnumPrioritized )
    {
        if ( pEnum->List.oPrioritized.nNextLicIndex == pEnum->List.oPrioritized.nNumLicenses ) /* end of list reached */
        {
            /* end of prioritized list. start to enum in non-prioritized way if we had filled our priority list */
            if ( pEnum->List.oPrioritized.nNumLicenses == MAX_PRILIC_LIST )
            {
                pEnum->eMode = eLicEnumPostPrioritized;
                dr = DRM_HDS_InitSlotEnum(
                            &pEnum->pLS->oNamespaceContext, 
                            &pEnum->List.oNonPrioritized.oCurrKID, 
                            eDRM_HDS_LOCKSHARED | eDRM_HDS_LOCKWAIT, 
                            &pEnum->oHdsEnumContext);
            }
            else
            {
                ChkDR( DRM_E_NOMORE );
            }
        }
        else
        {
	        /* get license size */
            if ( pcbLicense != NULL )
            {
	            dr = DRM_LST_GetLicense( (DRM_LICSTORE_CONTEXT *)pEnum->pLS, 
	                                    &pEnum->List.oPrioritized.oKID,
	                                    &pEnum->List.oPrioritized.pPrioritizedList[pEnum->List.oPrioritized.nNextLicIndex].oLID, 
	                                    &pEnum->List.oPrioritized.pPrioritizedList[pEnum->List.oPrioritized.nNextLicIndex].slotHint,
                                        NULL, 
	                                    pcbLicense);

                if( DRM_FAILED( dr ) && dr != DRM_E_BUFFERTOOSMALL )
	            {
	                goto ErrorExit;
	            }
                dr = DRM_SUCCESS;
            }

	        if ( pKID != NULL )
	        {
	            MEMCPY(pKID->rgb, pEnum->List.oPrioritized.oKID.rgb, DRM_ID_SIZE);
	        }

            if ( pSlotHint != NULL )
            {
	            MEMCPY(pSlotHint, &(pEnum->List.oPrioritized.pPrioritizedList[pEnum->List.oPrioritized.nNextLicIndex].slotHint), DRM_HDS_SLOT_HINT_LEN);
            }
            
	        MEMCPY(pLID->rgb, 
	               pEnum->List.oPrioritized.pPrioritizedList[pEnum->List.oPrioritized.nNextLicIndex].oLID.rgb, 
	               DRM_ID_SIZE);
	        pEnum->List.oPrioritized.nNextLicIndex++;
	    }
    }

    /* not in prioritize list or the prioritize is exhausted */
    if ( pEnum->eMode != eLicEnumPrioritized )  /* eLicEnumFiltered or eLicEnumNatural */
    {
        DRM_DWORD dwSlot=0;

        pEnum->List.oNonPrioritized.fCurrIsValid = FALSE;
        if ( pEnum->eMode == eLicEnumNatural )
        {
            ChkArg(pKID != NULL);
        }
        
        while (TRUE)
        {
            DRM_BOOL  fSkip = FALSE;
            DRM_DWORD i     = 0;
            
	        dr = DRM_HDS_SlotEnumNext(&pEnum->oHdsEnumContext, 
	                                  &pEnum->oSlotContext, 
	                                  &pEnum->List.oNonPrioritized.oCurrKID, 
	                                  &pEnum->List.oNonPrioritized.oCurrLID, 
	                                  &dwSlot);
	        if ( dr == DRM_E_NOMORE )
	        {
	            goto ErrorExit;
	        }
	        else if ( dr == DRM_E_HDSBLOCKMISMATCH || dr == DRM_E_HDSSLOTNOTFOUND )
	        {
	            ChkDR(DRM_E_LICENSENOTFOUND);   /* license has been changed or removed */
	        }
	        ChkDR(dr);

	        MEMCPY(pLID->rgb, pEnum->List.oNonPrioritized.oCurrLID.rgb, DRM_ID_SIZE);
	        if ( pKID != NULL )     /* optional if in filtered mode */
	        {
	            MEMCPY(pKID->rgb, pEnum->List.oNonPrioritized.oCurrKID.rgb, DRM_ID_SIZE);
	        }

	        pEnum->List.oNonPrioritized.fCurrIsValid = TRUE;

            if ( pcbLicense != NULL )
            {
	            *pcbLicense = dwSlot;
            }

            if ( pSlotHint != NULL )
            {
                DRM_HDS_MakeSlotHint(&pEnum->oSlotContext, pSlotHint);
            }

	        ChkDR(DRM_HDS_CloseSlot(&pEnum->oSlotContext));

            if ( pEnum->eMode != eLicEnumPostPrioritized )
            {
                break;
            }

            fSkip = FALSE;
            /* check if the LID is in the priority list, if so, skip it */
            for (i=0; i<pEnum->List.oPrioritized.nNumLicenses; i++)
            {
                if ( MEMCMP(&pEnum->List.oPrioritized.pPrioritizedList[i].oLID, pLID, DRM_ID_SIZE) == 0 )
                {
                    fSkip = TRUE;
                    break;
                }
            }

            if ( !fSkip )
            {
                break;
            }
        }
    }
    
ErrorExit:

    DRM_PROFILING_LEAVE_SCOPE(L"DRM_LST_EnumNext", g_pwszLeavingFunction);
    
    return dr;
}


/* delete current enumerated license */
DRM_RESULT DRM_API DRM_LST_EnumDelete( 
    IN DRM_LICSTOREENUM_CONTEXT *pLicEnumContext)
{
    DRM_RESULT dr = DRM_SUCCESS;
    _LicEnumContext *pEnum = (_LicEnumContext*)pLicEnumContext;

    ChkArg( pLicEnumContext != NULL
         && pEnum->fInited);

    DRMSIZEASSERT(SIZEOF(DRM_LICSTOREENUM_CONTEXT), SIZEOF(_LicEnumContext));

    if ( pEnum->eMode==eLicEnumNone )
    {
        dr = DRM_E_LICENSENOTFOUND;
        goto ErrorExit;            
    }

    else if ( pEnum->eMode==eLicEnumPrioritized )
    {
        /* no current exist */
        if ( pEnum->List.oPrioritized.nNextLicIndex==0    /* EnumNext not called yet */
         || pEnum->List.oPrioritized.pPrioritizedList[pEnum->List.oPrioritized.nNextLicIndex-1].fDelete == TRUE ) /* already deleted */
        {
            dr = DRM_E_LICENSENOTFOUND;
            goto ErrorExit;            
        }

        /* delete it */
        ChkDR(DRM_HDS_DeleteSlot(&pEnum->pLS->oNamespaceContext, 
                                 &pEnum->List.oPrioritized.oKID, 
                                 &pEnum->List.oPrioritized.pPrioritizedList[pEnum->List.oPrioritized.nNextLicIndex-1].oLID,
                                 &(pEnum->List.oPrioritized.pPrioritizedList[pEnum->List.oPrioritized.nNextLicIndex-1].slotHint),
                                 TRUE));

        pEnum->List.oPrioritized.pPrioritizedList[pEnum->List.oPrioritized.nNextLicIndex-1].fDelete = TRUE;
    }
    else /* eLicEnumFiltered or eLicEnumNatural */
    {
        if ( !pEnum->List.oNonPrioritized.fCurrIsValid )  /* EnumNext not called yet or current license already deleted */
        {
            dr = DRM_E_LICENSENOTFOUND;
            goto ErrorExit;            
        }
        else
        {
            ChkDR(DRM_HDS_DeleteSlot(&pEnum->pLS->oNamespaceContext,
                                     &pEnum->List.oNonPrioritized.oCurrKID, 
                                     &pEnum->List.oNonPrioritized.oCurrLID,
                                     NULL,
                                     TRUE));
            pEnum->List.oNonPrioritized.fCurrIsValid = FALSE;
        }
    }

#if !_DATASTORE_WRITE_THRU
    ChkDR(DRM_HDS_CommitStore(pEnum->pLS->pDeviceStoreContext));
#endif

ErrorExit:
    
    return dr;
}


DRM_RESULT DRM_API DRM_LST_DeleteLicense(
    DRM_LICSTORE_CONTEXT *pcontextLS,
    DRM_KID              *pkid,
    DRM_LID              *plid, 
    DRM_HDS_SLOT_HINT    *pslotHint )
{
    DRM_RESULT   dr   = DRM_SUCCESS;
    _LicContext *pLS  = (_LicContext *) pcontextLS;

    ChkArg( pLS  != NULL
         && pLS->fInited
         && pkid != NULL
         && plid != NULL );

    ChkDR( DRM_HDS_DeleteSlot(&pLS->oNamespaceContext,
                             pkid, 
                             plid,
                             pslotHint,
                             FALSE ));

ErrorExit:
    return dr;
}

DRM_RESULT DRM_API DRM_LST_LicCount( 
    IN  DRM_LICSTOREENUM_CONTEXT *pLicEnumCtxt, 
    OUT DRM_DWORD                *pcLicenses )
{
    DRM_RESULT          dr = DRM_SUCCESS;
    DRM_DWORD           cLicenses = 0;
    _LicEnumContext*    pEnum = (_LicEnumContext*)pLicEnumCtxt;

    /*  Check input */
    ChkArg( pLicEnumCtxt != NULL
         && pcLicenses   != NULL
         && pEnum->fInited       );

    /*  Clear output    */
    *pcLicenses = 0;
    
    DRMSIZEASSERT( SIZEOF(DRM_LICSTOREENUM_CONTEXT),  SIZEOF(_LicEnumContext) );
    
    if ( pEnum->eMode == eLicEnumNone )
    {
        /*  No licenses in store    */
        goto ErrorExit;            
    }
            
    while( TRUE )
    {
        /*  Look for next available license */
        ChkDR(DRM_HDS_SlotEnumNext( &pEnum->oHdsEnumContext, 
                                    &pEnum->oSlotContext, 
                                    &pEnum->List.oNonPrioritized.oCurrKID, 
                                    &pEnum->List.oNonPrioritized.oCurrLID, 
                                    NULL ));

        /*  Increment the license count */
        cLicenses++;

        /*  Close the slot  */
        ChkDR(DRM_HDS_CloseSlot(&pEnum->oSlotContext));
        
    }        
    
ErrorExit:
    if (DRM_E_NOMORE == dr)
    {
        dr = DRM_SUCCESS;
        *pcLicenses = cLicenses;
    }
    return dr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmlicparser.c ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/

#include <drmcommon.h>
#include <drmutilities.h>
#include <drmcrt.h>
#include <drmcontextsizes.h>
#include <drmblackbox.h>
#include <drmlicenseparser.h>
#include <drmlicense.h>
#include <drmxmlparser.h>

#define RESTRICTED_COUNT    3
const DRM_BYTE CERT_SUBJECT_RESTRICTED[RESTRICTED_COUNT][__CB_DECL(SUBJ_LEN)] = 
{
    {   TWO_BYTES(0, 0), TWO_BYTES(0, 2)    }, 
    {   TWO_BYTES(0, 0), TWO_BYTES(0, 3)    }, 
    {   TWO_BYTES(0, 0), TWO_BYTES(0, 4)    }
};

static PUBKEY s_BrLicSrvPubl =
{
    {
        TWO_BYTES(0x34, 0x8b), TWO_BYTES(0x02, 0xae), TWO_BYTES(0xb6, 0x3a), TWO_BYTES(0x58, 0x8d),
        TWO_BYTES(0xb6, 0xf5), TWO_BYTES(0x38, 0x3b), TWO_BYTES(0x46, 0x47), TWO_BYTES(0xb2, 0xcd),
        TWO_BYTES(0xf5, 0x77), TWO_BYTES(0x67, 0x31), TWO_BYTES(0xaa, 0xe8), TWO_BYTES(0x33, 0x44),
        TWO_BYTES(0x44, 0xdb), TWO_BYTES(0x90, 0x95), TWO_BYTES(0xbb, 0x7f), TWO_BYTES(0xcc, 0x51),
        TWO_BYTES(0x80, 0x9d), TWO_BYTES(0x2d, 0x3a), TWO_BYTES(0x7f, 0xbd), TWO_BYTES(0x4c, 0x08)
    }
};

/******************************************************************************
** 
** Function :   DRM_LIC_GetAttribute
** 
** Synopsis :   Get an attribute from a license
** 
** Arguments :  pdstrLicense    - License string
**              pdstrAttrName   - Name of attribute
**              eAttribute      - Type of ettribute
**              pdstrLIData     - (Optional) LICENSORINFO\DATA section. If a 
**                                valid string, attribute will be searched 
**                                directly in this. On exit, the pointer will be 
**                                updated 
**              pdstrValue      - Value of attribute
**              chXPathSeparator- path separator to use
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_LIC_GetAttribute(
    IN const DRM_CONST_STRING        *pdstrLicense, 
    IN const DRM_CONST_STRING        *pdstrAttrName,
    IN       eDRM_LICENSE_ATTRIBUTES  eAttribute,
    IN  OUT  DRM_CONST_STRING        *pdstrLIData,
        OUT  DRM_CONST_STRING        *pdstrValue,
    IN       DRM_WCHAR                chXPathSeparator)
{
    DRM_RESULT               dr = DRM_SUCCESS;    
    DRM_CONST_STRING        *pdstrSectionData   = NULL;    
    DRM_CONST_STRING         dstrSectionData    = EMPTY_DRM_STRING;
    DRM_CONST_STRING         dstrLicenseBody    = EMPTY_DRM_STRING;  
    const DRM_CONST_STRING  *pdstr              = NULL;

    ChkArg( pdstrLicense != NULL
         && pdstrValue   != NULL );
    
    if( chXPathSeparator == 0 )
    {
        chXPathSeparator = g_wchForwardSlash;
    }
    if ((eAttribute != DRM_LICENSE_ATTRIB_OTHER && 
         eAttribute != DRM_LICENSE_ATTRIB_REVOCATION &&
         eAttribute != DRM_LICENSE_ATTRIB_META_ATTRIBUTE ) && 
         NULL       != pdstrAttrName )
    {
        /* We allow user specified strings for META attributes, OTHER attribues and REVOCATION attributes */
        dr = DRM_E_INVALIDARG;
        goto ErrorExit;
    }

    if ( pdstrLIData == NULL )
    {
        pdstrSectionData = &dstrSectionData;
        ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, pdstrSectionData, NULL, g_wchForwardSlash ) );        
    }
    else
    {
        pdstrSectionData = pdstrLIData;
        if ( pdstrLIData->cchString == 0 )
        {
            ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, pdstrSectionData, NULL, g_wchForwardSlash ) );
        }
    }

    switch( eAttribute )
    {

        case DRM_LICENSE_ATTRIB_VERSION:        
            /* skip <?xml version="1.0"?>, if any */
            ChkDR(DRM_XML_GetNode(pdstrLicense, &g_dstrLicense, NULL, NULL, 0, &dstrLicenseBody, NULL));

            /* get the attr value */
            dr = DRM_XML_GetNodeAttribute( &dstrLicenseBody, &g_dstrAttributeVersion, pdstrValue);
            goto ErrorExit;

        case DRM_LICENSE_ATTRIB_KID:
            pdstr = &g_dstrTagKID;
            break;

        case DRM_LICENSE_ATTRIB_LID:
            pdstr = &g_dstrTagLID;
            break;
            
        case DRM_LICENSE_ATTRIB_METERING_ID:
            pdstr = &g_dstrTagMID; 
            break;
            
        case DRM_LICENSE_ATTRIB_REVOCATION:
            /* What type of revocation are they asking for? */
            /* We special case app revocation... */
            ChkArg( pdstrAttrName ); /* An attribute name is required if revocation lists are needed */
            if( DRM_UTL_DSTRStringsEqual( &g_dstrAppRevocation, pdstrAttrName ) )
            {
                pdstr = &g_dstrAppRevocation;
                pdstrAttrName = NULL;
            }
            else
            {
                pdstr = &g_dstrTagRevocation;
            }
            break;

        case DRM_LICENSE_ATTRIB_ISSUEDATE:
            pdstr = &g_dstrIssueDate;
            break;

        case DRM_LICENSE_ATTRIB_CONTENTPUBKEY:
            pdstr = &g_dstrContentPubKey;
            break;

        case DRM_LICENSE_ATTRIB_PRIORITY:
            pdstr = &g_dstrPriority;
            break;

        case DRM_LICENSE_ATTRIB_CHAINEDKID:
            pdstr = &g_dstrUplinkKid;
            break;

        case DRM_LICENSE_ATTRIB_META_ATTRIBUTE:        
            /* We are at the Data section.  We need to move to the META section */        
            ChkDR( DRM_XML_GetSubNodeByPath( pdstrSectionData, &g_dstrMeta, NULL, NULL, pdstrValue, NULL, g_wchForwardSlash ) );
            pdstrSectionData = pdstrValue;
            /* Fall through as META and regular attribute are the same.  Only difference is that we needed to be at a different
            node for META, which we are now. */

        case DRM_LICENSE_ATTRIB_OTHER:
            ChkArg( pdstrAttrName != NULL );
            pdstr = pdstrAttrName;
            pdstrAttrName = NULL;
            break;
            
        case DRM_LICENSE_ATTRIB_REVINFO:
            pdstr = &g_dstrTagRevInfoVersion;
            break;

        case DRM_LICENSE_ATTRIB_SOURCEID:
            pdstr = &g_dstrTagSourceID;
            break;
            
        default:
            ChkDR (DRM_E_INVALIDARG);
    }
    if( pdstrAttrName == NULL )
    {
        ChkDR( DRM_XML_GetSubNodeByPath( pdstrSectionData, pdstr, NULL, NULL, NULL, pdstrValue, chXPathSeparator ) );
    }
    else
    {
        ChkDR( DRM_XML_GetSubNodeByPath( pdstrSectionData, pdstr, &g_dstrAttributeType, pdstrAttrName, NULL, pdstrValue, chXPathSeparator ) );
    }

ErrorExit:
    return dr;
}

/******************************************************************************
** 
** Function :   DRM_LIC_GetEvent
** 
** Synopsis :   Parse and get details about an event from a license
** 
** Arguments :  pdstrLicense    - License string
**              pdstrEvent      - Name of event
**              pdstrTypeValue  - Type of event
**              pdstrLIData     - (Optional) LICENSORINFO\DATA section. If a 
**                                valid string, attribute will be searched 
**                                directly in this. On exit, the pointer will be 
**                                updated 
**              pdstrCondition  - Condition node from event
**              pdstrAction     - Action node from event
**              pdstrRestriction- Restriction node from event
** 
** Returns :    
** 
** Notes :      
** 
******************************************************************************/
DRM_RESULT DRM_API DRM_LIC_GetEvent(
    IN const DRM_CONST_STRING *pdstrLicense, 
    IN const DRM_CONST_STRING *pdstrEvent, 
    IN const DRM_CONST_STRING *pdstrTypeValue, 
    IN  OUT  DRM_CONST_STRING *pdstrLIData,
    OUT      DRM_CONST_STRING *pdstrCondition,     
    OUT      DRM_CONST_STRING *pdstrAction,
    OUT      DRM_CONST_STRING *pdstrRestriction)
{
    DRM_RESULT           dr                 = DRM_SUCCESS;
    DRM_CONST_STRING    *pdstrSectionData   = NULL;    
    DRM_CONST_STRING     dstrSectionData    = EMPTY_DRM_STRING;
    DRM_CONST_STRING     dstrListEvent      = EMPTY_DRM_STRING;

    if ( pdstrLIData == NULL)
    {
        pdstrSectionData = &dstrSectionData;
        ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, pdstrSectionData, NULL, g_wchForwardSlash ) );    
    }
    else
    {
        pdstrSectionData = pdstrLIData;
        if ( pdstrSectionData->cchString == 0)
        {
            pdstrSectionData = pdstrLIData;
            ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, pdstrSectionData, NULL, g_wchForwardSlash ) );    
        }
    }
    ChkDR( DRM_XML_GetSubNode( pdstrSectionData, 
                               pdstrEvent, 
                               pdstrTypeValue?&g_dstrAttributeType:NULL, 
                               pdstrTypeValue, 
                               0, 
                               &dstrListEvent, 
                               NULL, 
                               1 ) );
    if (NULL != pdstrCondition)
    {
        /* ONSTORE must use ACTION.CDATA not CONDITION.CDATA... */
        if( DRM_FAILED( DRM_XML_GetSubNodeByPath( &dstrListEvent, &g_dstrCondition, NULL, NULL, NULL, pdstrCondition, g_wchForwardSlash) ) )
        {
            INIT_DRM_STRING( *pdstrCondition );
        }
    }

    if (NULL != pdstrAction)
    {        
        if( DRM_FAILED( DRM_XML_GetSubNodeByPath( &dstrListEvent, &g_dstrAction, NULL, NULL, NULL, pdstrAction, g_wchForwardSlash) ) )
        {          
            INIT_DRM_STRING( *pdstrAction );
        }
    }

    if (NULL != pdstrRestriction)
    {  
        if( DRM_FAILED( DRM_XML_GetSubNode( &dstrListEvent, 
                                            &g_dstrRestrictions, 
                                            NULL, 
                                            NULL, 
                                            0,
                                            NULL, 
                                            pdstrRestriction, 
                                            1 ) ) )
        {
            INIT_DRM_STRING( *pdstrRestriction );            
        }        
    }

    dr = DRM_SUCCESS;
ErrorExit:
    return(dr);
}


/*--------------------------------------------------------------------
** 
** Function :   DRM_LIC_GetNextActionEvent
** 
** Synopsis :   
** 
** Arguments :  [pdstrActionsBuffer] - XML Buffer holding the ONACTION events
**              [pdstrCondition] - Condition inside ONACTION\CONDITION\CDATA
**
** Returns :    On returning, pdstrCondition contains the condition to be 
**              evaluated, and pdstrActionsBuffer is advanced beyond the current
**              ONACTION node, if there was one.
**              returns DRM_E_XMLNOTFOUND when no more ONACTION events are 
**              present
** 
** Notes :      
** 
--------------------------------------------------------------------*/
DRM_RESULT DRM_API DRM_LIC_GetNextActionEvent(
    IN OUT      DRM_CONST_STRING *pdstrActionsBuffer, 
    OUT         DRM_CONST_STRING *pdstrCondition )
{
    DRM_RESULT          dr = DRM_SUCCESS;
    DRM_CONST_STRING    dstrAction = EMPTY_DRM_STRING;
    
    /*  Check input */
    ChkDRMString(pdstrActionsBuffer);
    ChkArg( pdstrCondition != NULL );    

    /*  Initialize output   */
    pdstrCondition->cchString  = 0;
    pdstrCondition->pwszString = NULL;

    /*  Get the next action  */
    ChkDR(DRM_XML_GetSubNode( 
                pdstrActionsBuffer, 
                &g_dstrLicEvalOnAction, 
                NULL, 
                NULL, 
                0, 
                &dstrAction, 
                NULL,
                0));

    /*  Advance Action buffer to the next action    */
    pdstrActionsBuffer->pwszString += dstrAction.cchString;
    pdstrActionsBuffer->cchString  -= dstrAction.cchString;
    
    /*  Get the condition  */
    dr = DRM_XML_GetSubNodeByPath( 
            &dstrAction, 
            &g_dstrCondition, 
            NULL, 
            NULL, 
            NULL, 
            pdstrCondition, 
            g_wchForwardSlash);
    if( DRM_FAILED( dr ) )
    { 
        pdstrCondition->cchString  = 0;
        pdstrCondition->pwszString = NULL;
        ChkDR(dr);
    }      
    
ErrorExit:
    return(dr);
}

static DRM_RESULT GetLSPubKey(
    const DRM_CONST_STRING   *pdstrLicense, 
          PUBKEY             *pbPubKey, 
          DRM_CRYPTO_CONTEXT *pcontextCrypto)
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrCert          = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrListCertChain = EMPTY_DRM_STRING;
    DRM_DWORD        iNode = 0;
    
    if (pbPubKey == NULL)
    {
        dr = LIC_PARAM_NOT_OPTIONAL;
        goto ErrorExit;
    }
        
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrCertChain, NULL, NULL, &dstrListCertChain, NULL, g_wchForwardSlash ) );
    while( DRM_SUCCEEDED( DRM_XML_GetSubNode( &dstrListCertChain, &g_dstrTagCertificate, NULL, NULL, iNode, &dstrCert, NULL, 1 ) ) )
    {
        iNode++;
    }
    if( iNode == 0 )
    {
        dr = LIC_INVALID_LICENSE;
        goto ErrorExit;
    }

    ChkDR( DRM_XML_GetSubNode( &dstrListCertChain, &g_dstrTagCertificate, NULL, NULL, iNode - 1, NULL, &dstrCert, 1 ) );
    iNode = SIZEOF( CERT );
    ChkDR(DRM_B64_DecodeW(&dstrCert, &iNode, (DRM_BYTE *)&(pcontextCrypto->union_cert.cert), 0 ) );
    MEMCPY( pbPubKey, &(pcontextCrypto->union_cert.cert.cd.pk), SIZEOF(PUBKEY) );    

ErrorExit:
    if( DRM_FAILED( dr ) )
    {
        dr = LIC_INVALID_LICENSE;
    }

    return(dr);
}

DRM_RESULT DRM_API DRM_LIC_GetEnablingBits(
    IN const DRM_CONST_STRING   *pdstrLicense,
    IN       DRM_DWORD           dwIndex,
    OUT      DRM_DWORD          *pdwAlgorithm,
    OUT      PUBKEY             *pPubKey, 
    OUT      DRM_BYTE           *pbValue, 
    OUT      DRM_DWORD          *pdValueLen, 
    OUT      PUBKEY             *pVerPubKey, 
    OUT      DRM_BYTE           *pbSignature,
    OUT      DRM_BYTE            rgbChainedChecksum[CHECKSUM_LENGTH],
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto)
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrString              = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrEnablingBitsSection = EMPTY_DRM_STRING;
    DRM_DWORD        dwSize                  = SIZEOF( PUBKEY );
    DRM_BOOL         fSymmetricallyBound     = FALSE;

    if ( pPubKey     == NULL 
      || pdValueLen  == NULL 
      || pbSignature == NULL )
    {
        dr = LIC_PARAM_NOT_OPTIONAL;
        goto ErrorExit;
    }

    dr = DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrDrmRestoreInfoEnablingBits, NULL, NULL, &dstrEnablingBitsSection, NULL, g_wchForwardSlash );
    if( DRM_FAILED( dr ) 
     && dwIndex == 0 )
    {
        /* There is no restore enabling bits.  So 0 index is the first regular enabling bits */
        dwIndex++;
    }

    if( dwIndex > 0 )
    {
        ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, &dstrString, NULL, g_wchForwardSlash ) );
        dr = DRM_XML_GetSubNode( &dstrString, &g_dstrTagEnablingbits, NULL, NULL, dwIndex - 1, &dstrEnablingBitsSection, NULL, 1);
        if( DRM_FAILED( dr ) )
        {
            /* These was no ENABLINGBITS section.  This could be a chained license.  Look for CHAINEDENABLINGBITS */
            ChkDR( DRM_XML_GetSubNode( &dstrString, &g_dstrChainedEnablingBits, NULL, NULL, dwIndex - 1, &dstrEnablingBitsSection, NULL, 1) );
            if( NULL != rgbChainedChecksum )
            {
                /* Get PubKey     */
                ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrChainedCheckSum, NULL, NULL, NULL, &dstrString, g_wchForwardSlash ) );
                /* Decode PubKey */
                dwSize = CHECKSUM_LENGTH;
                ChkDR(DRM_B64_DecodeW(&dstrString, &dwSize, rgbChainedChecksum, 0) );
            }

        }
        else
        {
            ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrTagPubkey, NULL, NULL, NULL, &dstrString, g_wchForwardSlash ) );
            /* Decode PubKey */
            dwSize = SIZEOF( PUBKEY );
            ChkDR( DRM_B64_DecodeW(&dstrString, &dwSize, (DRM_BYTE *)pPubKey, 0) );
        }

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
        /* Get PubKey     */
        if( DRM_SUCCEEDED( DRM_XML_GetSubNode(  pdstrLicense,
                                               &g_dstrTagSymValue,
                                                NULL,
                                                NULL,
                                                0,
                                               &dstrString,
                                                NULL,
                                                2 ) ) )
        {
            /* This license has been rebound to a symmetric key.  Ensure that we return the correct values in this case */
            fSymmetricallyBound = TRUE;
        }
#endif

        if ( NULL != pVerPubKey )
        {
            ChkDR( GetLSPubKey( pdstrLicense, pVerPubKey, pcontextCrypto ) );
        }
    }
    else if( NULL != pVerPubKey )
    {
        /* Get PubKey     */
        ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrTagPubkey, NULL, NULL, NULL, &dstrString, g_wchForwardSlash ) );
        /* Decode PubKey */
        dwSize = SIZEOF( PUBKEY );
        ChkDR(DRM_B64_DecodeW(&dstrString, &dwSize, (DRM_BYTE *)pPubKey, 0) );
        MEMCPY(pVerPubKey, &s_BrLicSrvPubl, SIZEOF(PUBKEY) );
    }

    if (NULL != pdwAlgorithm )
    {
        if( fSymmetricallyBound )
        {
            *pdwAlgorithm = eMSDRM_SYM;
        }
        else
        {
            DRM_CONST_STRING dstrAlgo = EMPTY_DRM_STRING;

            *pdwAlgorithm = 0;

            ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrTagHashAlgorithm, NULL, NULL, &dstrString, NULL, g_wchForwardSlash ) );
            ChkDR( DRM_XML_GetNodeAttribute( &dstrString, &g_dstrAttributeType, &dstrAlgo ) );
            if( DRM_UTL_DSTRStringsEqual( &dstrAlgo, &g_dstrMSDRM ) )
            {
                *pdwAlgorithm = eMSDRM_PK;
                /* Is is a eMSDRM_PK algorithm */
            }
            else if( DRM_UTL_DSTRStringsEqual( &dstrAlgo, &g_dstrMSDRM_CK ) )
            {
                *pdwAlgorithm = eMSDRM_CK;
                /* It is a eMSDRM_CK algorithm */
            }
            else
            {
                ChkDR( DRM_E_UNSUPPORTEDALGORITHM );
            }
        }
    }

    /* Get Value     */
    if( fSymmetricallyBound )
    {
        ChkDR( DRM_XML_GetSubNode( pdstrLicense, &g_dstrTagSymValue, NULL, NULL, 0, NULL, &dstrString, 2) );
    }
    else
    {
        ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrTagValue, NULL, NULL, NULL, &dstrString, g_wchForwardSlash ) );
    }
    
    /* Base64 Decode Value */
    ChkDR(DRM_B64_DecodeW(&dstrString, pdValueLen, pbValue, 0 ) );

    /* Get Signature     */
    ChkDR( DRM_XML_GetSubNodeByPath( &dstrEnablingBitsSection, &g_dstrTagSignature, NULL, NULL, NULL, &dstrString, g_wchForwardSlash ) );

    /* Decode Signature */
    dwSize = PK_ENC_SIGNATURE_LEN;
    ChkDR(DRM_B64_DecodeW(&dstrString, &dwSize, pbSignature, 0) );

    dr = DRM_SUCCESS;
ErrorExit:
    return(dr);
}

DRM_RESULT DRM_API DRM_LIC_VerifySignature(
    IN const DRM_CONST_STRING *pdstrLicense,
    IN       DRM_BB_CONTEXT   *pcontextBBX,
       OUT   DRM_LONG         *plResult)
{
    DRM_RESULT       dr  = DRM_SUCCESS;    
    DRM_CONST_STRING dstrData      = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrLicInfo   = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrSignature = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrLID       = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrBRInfo    = EMPTY_DRM_STRING;
    DRM_DWORD        dwSize = PK_ENC_SIGNATURE_LEN;
    
    ChkArg ( plResult     != NULL 
          && pdstrLicense != NULL
          && pcontextBBX  != NULL );

    *plResult = 0; /* Init. */

    ChkDR( GetLSPubKey(pdstrLicense, &pcontextBBX->CryptoContext.pubKey, &pcontextBBX->CryptoContext ) );
    
    /* Get DATA section     */
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, &dstrData, NULL, g_wchForwardSlash ) );

#if DRM_SUPPORT_SYMMETRIC_OPTIMIZATIONS
    /* Look for a SYMMETRIC signature first.  If not found then proceed to regular signature verification */
    if( DRM_SUCCEEDED( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLicensorInfoNode, NULL, NULL, &dstrLicInfo, NULL, g_wchForwardSlash ) ) )
    {
        if( DRM_SUCCEEDED( DRM_XML_GetSubNode( &dstrLicInfo,
                                               &g_dstrTagSymSig,
                                                NULL,
                                                NULL,
                                                0,
                                                NULL,
                                                &dstrSignature,
                                                1 ) ) )
        {
            /* There is a symmetric signature, verify it. */
            DRM_BYTE rgbSymSig[__CB_DECL( SHA_DIGEST_LEN )];
            
            dwSize = SIZEOF( rgbSymSig );
            ChkDR( DRM_B64_DecodeW( &dstrSignature, &dwSize, rgbSymSig, 0 ) );
            ChkDR( DRM_BBX_SymmetricVerify( pcontextBBX, 
                                            PB_DSTR( &dstrData ), 
                                            CB_DSTR( &dstrData ), 
                                            NULL,
                                            rgbSymSig ) );

            /* Signture verification passed.  Skip the rest of the function */
            *plResult = 1;
            goto ErrorExit;
        }
    }
#endif


    /* Get the LID */
    ChkDR( DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrTagLID, NULL, NULL, &dstrLID, NULL, g_wchForwardSlash ) );

    if( DRM_FAILED( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLISigHashAlgo, &g_dstrAttributeType, &g_dstrSHA, &dstrSignature, NULL, g_wchForwardSlash ) ) )
    {
        dr = LIC_UNSUPPORTED_VALUE;
        goto ErrorExit;
    }


    if( DRM_FAILED( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLISigAlgo, &g_dstrAttributeType, &g_dstrMSDRM, &dstrSignature, NULL, g_wchForwardSlash ) ) )
    {
        dr = LIC_UNSUPPORTED_VALUE;
        goto ErrorExit;
    }
    
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLISigValue, NULL, NULL, NULL, &dstrSignature, g_wchForwardSlash ) );
    ChkDR(DRM_B64_DecodeW(&dstrSignature, &dwSize, pcontextBBX->CryptoContext.signature, 0 ) );

    if ( DRM_PK_Verify( pcontextBBX->CryptoContext.rgbCryptoContext, &pcontextBBX->CryptoContext.pubKey, PB_DSTR(&dstrData), CB_DSTR(&dstrData), pcontextBBX->CryptoContext.signature) )
    {
        if( DRM_SUCCEEDED( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrDrmRestoreInfo, NULL, NULL, &dstrBRInfo, NULL, g_wchForwardSlash ) ) )
        {
            /* The DRMRESTOREINFO section exists so we need to validate that             */
            
            
            ChkDR( DRM_XML_GetSubNodeByPath( &dstrBRInfo, &g_dstrTagSignature, NULL, NULL, &dstrData, NULL, g_wchForwardSlash ) );
            
            /* 
            ** Get the SHA hashalgorithm and MSDRM signalgorithm.  
            ** Don't do anything with it just make sure it is there
            */
            ChkDR( DRM_XML_GetSubNode( &dstrData, &g_dstrTagHashAlg, &g_dstrAttributeType, &g_dstrSHA,   0, &dstrSignature, NULL, 1 ) );
            ChkDR( DRM_XML_GetSubNode( &dstrData, &g_dstrTagSignAlg, &g_dstrAttributeType, &g_dstrMSDRM, 0, &dstrSignature, NULL, 1 ) );

            ChkDR( DRM_XML_GetSubNodeByPath( &dstrBRInfo, &g_dstrXPathSigValue, NULL, NULL, NULL,       &dstrSignature, g_wchForwardSlash ) );            
            ChkDR( DRM_XML_GetSubNodeByPath( &dstrBRInfo, &g_dstrTagData,       NULL, NULL, &dstrData,   NULL,          g_wchForwardSlash ) );

            /* Get the LID that is in the DRMRESTOREINFO/DATA section */
            ChkDR( DRM_XML_GetSubNodeByPath( &dstrData,   &g_dstrTagLID,        NULL, NULL, &dstrBRInfo, NULL,          g_wchForwardSlash ) );

            /* Compare with the original LID to prevent a spoofing attack */
            if( !DRM_UTL_DSTRStringsEqual( &dstrBRInfo, &dstrLID ) )
            {
                /* The LID from the original license and the LID in the B/R info don't match */
                /* Someone isn't playing nice.  We fail the signature check because something is fishy. */
                dr = LIC_INVALID_LICENSE;
                goto ErrorExit;
            }
            ChkDR(DRM_B64_DecodeW(&dstrSignature, &dwSize, pcontextBBX->CryptoContext.signature, 0) );

            if( dstrData.cchString > ((DRM_DWORD)(-1)) ||
                dstrData.cchString * SIZEOF( DRM_WCHAR ) > ((DRM_DWORD)(-1)) )
            {
                dr = DRM_E_ARITHMETIC_OVERFLOW;
                goto ErrorExit;
            }

            if ( DRM_PK_Verify( pcontextBBX->CryptoContext.rgbCryptoContext, &s_BrLicSrvPubl, PB_DSTR(&dstrData), CB_DSTR(&dstrData), pcontextBBX->CryptoContext.signature) )                
            {
                *plResult = 1;
            }

        }
        else
        {
            *plResult = 1;
        }
    }
    dr = DRM_SUCCESS;
ErrorExit:
    return( dr );
}

DRM_RESULT DRM_API DRM_LIC_VerifyCertChain(
    IN const DRM_CONST_STRING    *pdstrLicense, 
    IN       DRM_BOOL             fCheckExpiry,
    IN       DRM_LICEVAL_CONTEXT *pcontextLEVL,
    OUT      DRM_LONG            *plResult)
{
    DRM_RESULT       dr = DRM_SUCCESS;    
    DRM_CONST_STRING dstrCert          = EMPTY_DRM_STRING; 
    DRM_CONST_STRING dstrListCertChain = EMPTY_DRM_STRING;
    DRM_DWORD        dwIndex = 0;
    DRM_BOOL         fFirstCertCheck = TRUE;

    ChkArg( plResult     != NULL
         && pdstrLicense != NULL
         && pcontextLEVL != NULL );

    *plResult = 0;
    
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrCertChain, NULL, NULL, &dstrListCertChain, NULL, g_wchForwardSlash ) );

    for(dwIndex = 0; DRM_SUCCEEDED(dr); dwIndex++ )
    {
        DRM_DWORD dwSize = SIZEOF( CERT );
        dr = DRM_XML_GetSubNode( &dstrListCertChain, 
                                 &g_dstrTagCertificate, 
                                 NULL, 
                                 NULL, 
                                 dwIndex, 
                                 NULL, 
                                 &dstrCert, 
                                 1 );
        if ( (dr == DRM_E_XMLNOTFOUND) && (dwIndex == 0) )
        {
            ChkDR( LIC_INVALID_LICENSE );
        }
        else if ( DRM_SUCCEEDED(dr) )
        {                    
            ChkDR(DRM_B64_DecodeW(&dstrCert, 
                                  &dwSize, 
                                  (DRM_BYTE*) &(pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert), 
                                  0));
            ChkDR( DRM_UTL_CheckCert( &(pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert), 
                                      fFirstCertCheck?NULL:&(pcontextLEVL->pcontextBBX->CryptoContext.pubKey),
                                      fCheckExpiry, 
                                      pcontextLEVL ) );
            MEMCPY( &(pcontextLEVL->pcontextBBX->CryptoContext.pubKey), 
                    &(pcontextLEVL->pcontextBBX->CryptoContext.union_cert.cert.cd.pk), 
                    SIZEOF( PUBKEY ) );
            fFirstCertCheck = FALSE;   
        }
    }

    *plResult = 1;
    dr = DRM_SUCCESS;

ErrorExit:
    return(dr);
}

#if DRM_SUPPORT_CONTENT_REVOCATION

DRM_RESULT DRM_API DRM_LIC_VerifyContentRevocation(
    IN const DRM_CONST_STRING   *pdstrContentRevocation, 
    OUT      DRM_CONST_STRING   *pdstrLSPubKey,
    OUT      DRM_DWORD          *pdwSequenceNumber,
    OUT      DRM_CONST_STRING   *pdstrContentOwnerPubKey,
    OUT      DRM_CONST_STRING   *pdstrCondition,
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto)
{
    DRM_RESULT       dr = DRM_E_LOGICERR;
    DRM_CONST_STRING dstrData          = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrContentPubKey = EMPTY_DRM_STRING;
    DRM_DWORD        dwSize = 0;

    ChkArg( pcontextCrypto         != NULL
         && pdstrContentRevocation != NULL );
        
    /* Initialize output parameters. */
    if (NULL != pdwSequenceNumber)
    {
        *pdwSequenceNumber = 0;
    }
    if (NULL != pdstrContentOwnerPubKey)
    {
        INIT_DRM_STRING( *pdstrContentOwnerPubKey );
    }
    if (NULL != pdstrCondition)
    {
        INIT_DRM_STRING( *pdstrCondition );
    }
        
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrContentRevocation, &g_dstrTagData, NULL, NULL, &dstrData, NULL, g_wchForwardSlash ) );

    /* Get Sequence Number */
    if (NULL != pdwSequenceNumber)
    {
        DRM_CONST_STRING dstrSequenceNumber = EMPTY_DRM_STRING;        
        dr = DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrSequenceNumber, NULL, NULL, NULL, &dstrSequenceNumber, g_wchForwardSlash );
        if( DRM_SUCCEEDED( dr ) )
        {
            ChkDR (wcsntol (dstrSequenceNumber.pwszString, 
                            dstrSequenceNumber.cchString, 
               (DRM_LONG *) pdwSequenceNumber));
        }
    }

    /* Get Content Owner PubKey     */
    ChkDR( DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrContentPubKey, NULL, NULL, NULL, &dstrContentPubKey, g_wchForwardSlash ) );
    if (NULL != pdstrContentOwnerPubKey)
    {
        ASSIGN_DRM_STRING( *pdstrContentOwnerPubKey, dstrContentPubKey );
    }
    dwSize = SIZEOF( PUBKEY );
    ChkDR(DRM_B64_DecodeW(&dstrContentPubKey, &dwSize, (DRM_BYTE *)&(pcontextCrypto->pubKey), 0 ) );

    /* Get License Server PubKey. It is optional. */
    if (NULL != pdstrLSPubKey)
    {        
        dr = DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrLSPubKey, NULL, NULL, NULL, pdstrLSPubKey, g_wchForwardSlash );
        if( DRM_FAILED( dr ) )
        {
            INIT_DRM_STRING( *pdstrLSPubKey );
        }
    }

    /* Get the Condition */
    if (NULL != pdstrCondition)
    {
        if( DRM_FAILED( DRM_XML_GetSubNodeByPath( &dstrData, &g_dstrCondition, NULL, NULL, NULL, pdstrCondition, g_wchForwardSlash) ) )
        {
            INIT_DRM_STRING( *pdstrCondition );
        }
    }
    
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrContentRevocation, &g_dstrTagSignature, NULL, NULL, &dstrContentPubKey, NULL, g_wchForwardSlash ) );

    /* Get the SHA hashalgorithm.  Don't do anything with it just make sure it is there */
    ChkDR( DRM_XML_GetSubNode( &dstrContentPubKey, &g_dstrTagHashAlg, &g_dstrAttributeType, &g_dstrSHA, NULL, &dstrData, NULL, 1 ) );

    /* Get the MSDRM signalgorithm.  Don't do anything with it just make sure it is there */
    ChkDR( DRM_XML_GetSubNode( &dstrContentPubKey, &g_dstrTagSignAlg, &g_dstrAttributeType, &g_dstrMSDRM, NULL, &dstrData, NULL, 1 ) );

    ChkDR( DRM_XML_GetSubNodeByPath( pdstrContentRevocation, &g_dstrXPathSigValue, NULL, NULL, NULL, &dstrData, g_wchForwardSlash ) );
    dwSize = PK_ENC_SIGNATURE_LEN;
    ChkDR(DRM_B64_DecodeW(&dstrData, &dwSize, pcontextCrypto->signature, 0) );
    
    ChkDR( DRM_XML_GetSubNodeByPath( pdstrContentRevocation, &g_dstrTagData, NULL, NULL, &dstrData, NULL, g_wchForwardSlash ) );

    if( dstrData.cchString > ((DRM_DWORD)(-1)) ||
        dstrData.cchString * SIZEOF( DRM_WCHAR ) > ((DRM_DWORD)(-1)) )
    {
        ChkDR( DRM_E_ARITHMETIC_OVERFLOW );
    }

    /* Use PkCrypto to verify the signature of the DATA section        */
    if (!DRM_PK_Verify( pcontextCrypto->rgbCryptoContext, 
                       &pcontextCrypto->pubKey,
                        PB_DSTR( &dstrData ), 
                        CB_DSTR( &dstrData ),
                        pcontextCrypto->signature) )
    {
        /* This is internally used to indicate that the content revocation blob is bad. */
        ChkDR( DRM_E_INVALID_SIGNATURE );
    }
    
    /* Everything looks good.  */
    dr = DRM_SUCCESS;
ErrorExit:
    return ( dr );    
}


DRM_RESULT DRM_API DRM_LIC_GetContentRevocation(
    IN const DRM_CONST_STRING   *pdstrLicense,
    IN       DRM_DWORD           dwSequenceNumber,
    OUT      DRM_DWORD          *pdwSequenceNumber,
    OUT      DRM_CONST_STRING   *pdstrContentRevocation,
    OUT      DRM_CONST_STRING   *pdstrContentOwnerPubKey,
    OUT      DRM_CONST_STRING   *pdstrCondition,
    IN       DRM_CRYPTO_CONTEXT *pcontextCrypto)
{
    DRM_RESULT       dr = DRM_SUCCESS;
    DRM_CONST_STRING dstrSectionData = EMPTY_DRM_STRING;    
    DRM_CONST_STRING dstrLSPubKey    = EMPTY_DRM_STRING;
    DRM_CONST_STRING dstrTemp        = EMPTY_DRM_STRING;

    ChkArg( pdstrLicense            != NULL
         && pdstrContentRevocation  != NULL
         && pdstrContentOwnerPubKey != NULL );
        
    if( DRM_FAILED ( DRM_XML_GetSubNodeByPath( pdstrLicense, &g_dstrLIData, NULL, NULL, &dstrSectionData, NULL, g_wchForwardSlash ) ) )
    {
        dr = DRM_S_FALSE;
        goto ErrorExit;
    }
    
    if( DRM_FAILED ( DRM_XML_GetSubNode( &dstrSectionData, &g_dstrContentRevocation, NULL, NULL, dwSequenceNumber, pdstrContentRevocation, &dstrTemp, 1 ) ) )
    {
        dr = DRM_S_FALSE;
        goto ErrorExit;
    }

    /* Verify and set output parameters. */
    ChkDR( DRM_LIC_VerifyContentRevocation( pdstrContentRevocation, &dstrLSPubKey, pdwSequenceNumber, pdstrContentOwnerPubKey, pdstrCondition, pcontextCrypto) );
    
    /* If license server pubkey is in the content revocation list, make sure that it corresponds to that of this license. */
    /* If the license server pubkey exists and is non-empty string, make sure it matched the one in license. */
    if ( NULL != dstrLSPubKey.pwszString )
    {
        DRM_DWORD dwSize = SIZEOF( PUBKEY );

        /* Retrieve pubkey of license server for this license. */
        ChkDR( GetLSPubKey( pdstrLicense, &(pcontextCrypto->pubKey), pcontextCrypto ) );
        ChkDR(DRM_B64_DecodeW(&dstrLSPubKey, &dwSize, (DRM_BYTE*) &(pcontextCrypto->pubKey2), 0));
        if (MEMCMP((DRM_BYTE*) &(pcontextCrypto->pubKey), (DRM_BYTE*) &(pcontextCrypto->pubKey2), SIZEOF( PUBKEY ) ) != 0 )
        {
            ChkDR( DRM_E_KEY_MISMATCH );
        }
    }
    dr = DRM_SUCCESS;
ErrorExit:
    return(dr);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\common\security\wmdrm\dll\drmlicstore.h ===
/**@@@+++@@@@******************************************************************
**
** Microsoft Windows Media
** Copyright (C) Microsoft Corporation. All rights reserved.
**
***@@@---@@@@******************************************************************
*/


#ifndef __DRM_LICSTORE_H__
#define __DRM_LICSTORE_H__

#include "drmhds.h"

#ifdef __cplusplus
extern "C" {
#endif


/* License store context size */
#define MAX_PRILIC_LIST     10


/*
** License store context stucture. This contains the HDS namespace context it is using and
** the local stack info for internal use
*/
typedef struct _tag_LicContext
{    
    DRM_HDS_SLOT_CONTEXT oSlotContext;
    DRM_HDS_NAMESPACE_CONTEXT oNamespaceContext;
    DRM_HDS_CONTEXT *pDeviceStoreContext;
    DRM_BOOL fInited;
    /* Extra 2 bytes of alignment here */
} _LicContext;

/*
**
*/
typedef enum _tag_EnumMode
{
    eLicEnumNone=0,       /* no license found */
    eLicEnumPrioritized=1, /* a local list of license's KID and LID is loaded for query */
    eLicEnumFiltered,     /* enum for licenses matching given KID */
    eLicEnumNatural,          /* enum all licenses */
    eLicEnumPostPrioritized   /* enum for licenses matching given KID after eLicEnumPrioritized exhausted */
} _EnumMode;

/*
**
*/
typedef struct _tag_PrioritizedLicense
{
    DRM_DWORD dwPriority;   /* the higher the value, the higher the priority */
    DRM_LID oLID;
    DRM_BOOL fDelete;
    DRM_HDS_SLOT_HINT slotHint;
} _PrioritizedLicense;

typedef struct _tag_PrioritizedList 
{
    DRM_KID oKID;
    DRM_DWORD nNextLicIndex;
    DRM_DWORD nNumLicenses; /* # of license slot used in the array */
    _PrioritizedLicense pPrioritizedList[MAX_PRILIC_LIST+1]; /* one extra for working buffer */
} _PrioritizedList;

typedef struct _tag_NonPriorityList
{
    DRM_BOOL fCurrIsValid;
    DRM_KID oCurrKID;
    DRM_LID oCurrLID;
} _NonPriorityList;

/*
**
*/
typedef struct _tag_LicEnumContext
{
    _LicContext *pLS;
    DRM_HDS_ENUM_CONTEXT oHdsEnumContext;
    DRM_HDS_SLOT_CONTEXT oSlotContext;
    DRM_BOOL fInited;
    
    _EnumMode eMode;
    struct
    {
        _PrioritizedList oPrioritized;
        _NonPriorityList oNonPrioritized;
    } List;
} _LicEnumContext;

typedef _LicContext     DRM_LICSTORE_CONTEXT;
typedef _LicEnumContext DRM_LICSTOREENUM_CONTEXT;


/* 
** API Function