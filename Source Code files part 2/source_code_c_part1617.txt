((AfpServerState == AFP_STATE_STOP_PENDING) ||
        (AfpServerState == AFP_STATE_SHUTTINGDOWN) ||
        (AfpServerState == AFP_STATE_STOPPED))
    {
	    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("AfpTdiIpAddressCameIn: server shutting down, returning\n"));
        return;
    }

    //
    // do we already have the DSI-tdi interface initialized (i.e. DsiTcpAdapter
    // is non-null)?  If we already saw an ipaddr come in earlier, this would be
    // initialized.  if not, we must initialize now
    //
    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
    if (DsiTcpAdapter == NULL)
    {
        fCreateAdapter = TRUE;
    }
    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);


    // add this ipaddress to our list
    DsiAddIpaddressToList(IpAddress);

    if (fCreateAdapter)
    {
        DsiCreateAdapter();
    }

    // ipaddress came in: update the status buffer
    DsiScheduleWorkerEvent(DsiUpdateAfpStatus, NULL);
}




/***	DsiIpAddressWentAway
 *
 *	This routine gets called when ipaddress goes away on an adapter
 *
 *  Parm IN:  Address - TA_ADDRESS
 *            Context1 -
 *            Context2 -
 *
 *  Returns:  none
 *
 */
VOID
DsiIpAddressWentAway(
    IN  PTA_ADDRESS         Address,
    IN  PUNICODE_STRING     DeviceName,
    IN  PTDI_PNP_CONTEXT    Context2
)
{
    PUNICODE_STRING     pBindDeviceName;
    IPADDRESS           IpAddress;
    KIRQL               OldIrql;
    BOOLEAN             fDestroyIt=FALSE;
    BOOLEAN             fIpAddrRemoved=TRUE;
    BOOLEAN             fMustDeref=FALSE;


    pBindDeviceName = DeviceName;

    if (Address->AddressType != TDI_ADDRESS_TYPE_IP)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("AfpTdiIpAddressWentAway: unknown AddrType %d on %ws, ignoring!\n",
            Address->AddressType,(pBindDeviceName)->Buffer));
        return;
    }

    IpAddress = ntohl(((PTDI_ADDRESS_IP)&Address->Address[0])->in_addr);

    if (IpAddress == 0)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
            ("AfpTdiIpAddressWentAway: ipaddress is 0 on %ws!\n",
            (pBindDeviceName)->Buffer));
        return;
    }

    DsiRemoveIpaddressFromList(IpAddress);

    //
    // if the global adapter exists, see if we need to destroy it because the
    // last ipaddress went away
    //
    ACQUIRE_SPIN_LOCK(&DsiAddressLock, &OldIrql);
    if (DsiTcpAdapter != NULL)
    {
        fDestroyIt = IsListEmpty(&DsiIpAddrList)? TRUE : FALSE;
    }

    RELEASE_SPIN_LOCK(&DsiAddressLock, OldIrql);

    // ipaddress went away: update the status buffer
    DsiScheduleWorkerEvent(DsiUpdateAfpStatus, NULL);

    if (fDestroyIt)
    {
        DsiDestroyAdapter();
    }
}



/***	DsiTdiConnectHandler
 *
 *	This routine
 *
 *  Parm IN:  EventContext - pTcpAdptr that we passed when we set tdi handlers
 *            MacIpAddrLen - length of the address of the Mac (4 bytes!)
 *            pMacIpAddr - ipaddr of the Mac that's attempting to connect
 *            DsiDataLength - length of DSI data, if any, in this connect request
 *            pDsiData - pointer to DSI data, if any
 *            OptionsLength - unused
 *            pOptions - unused
 *
 *  Parm OUT: pOurConnContext - connection context, pTcpConn for this connection
 *            ppOurAcceptIrp - irp, if accpeting this connection
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiConnectHandler(
    IN  PVOID                EventContext,
    IN  int                  MacIpAddrLen,
    IN  PVOID                pSrcAddress,
    IN  int                  DsiDataLength,
    IN  PVOID                pDsiData,
    IN  int                  OptionsLength,
    IN  PVOID                pOptions,
    OUT CONNECTION_CONTEXT  *pOurConnContext,
    OUT PIRP                *ppOurAcceptIrp
)
{
    NTSTATUS            status=STATUS_SUCCESS;
    PTCPADPTR           pTcpAdptr;
    PTCPCONN            pTcpConn;
    PDEVICE_OBJECT      pDeviceObject;
    IPADDRESS           MacIpAddr;
    PTRANSPORT_ADDRESS  pXportAddr;
    PIRP                pIrp;


    pTcpAdptr = (PTCPADPTR)EventContext;

    *pOurConnContext = NULL;
    *ppOurAcceptIrp = NULL;

    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    pDeviceObject = IoGetRelatedDeviceObject(pTcpAdptr->adp_pFileObject);

    if ((pIrp = AfpAllocIrp(pDeviceObject->StackSize)) == NULL)
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiConnectHandler: AllocIrp failed\n"));

        return(STATUS_DATA_NOT_ACCEPTED);
    }

    pXportAddr = (PTRANSPORT_ADDRESS)pSrcAddress;
    MacIpAddr = ((PTDI_ADDRESS_IP)&pXportAddr->Address[0].Address[0])->in_addr;

    //
    // see if DSI wants to accept this connection
    //
    status = DsiAcceptConnection(pTcpAdptr, ntohl(MacIpAddr), &pTcpConn);

    if (!NT_SUCCESS(status))
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiConnectHandler: DsiAccep.. failed %lx\n",status));

        AfpFreeIrp(pIrp);
        return(status);
    }

    TdiBuildAccept(pIrp,
                   IoGetRelatedDeviceObject(pTcpConn->con_pFileObject),
                   pTcpConn->con_pFileObject,
                   DsiAcceptConnectionCompletion,
                   pTcpConn,
                   NULL,
                   NULL);

    pIrp->MdlAddress = NULL;

    *pOurConnContext = (CONNECTION_CONTEXT)pTcpConn;
    *ppOurAcceptIrp = pIrp;

    // do what IoSubSystem would have done, if we had called IoCallDriver
    IoSetNextIrpStackLocation(pIrp);

    return(STATUS_MORE_PROCESSING_REQUIRED);

}

/***	DsiTdiReceiveHandler
 *
 *	This routine
 *
 *  Parm IN:  EventContext - pTcpAdptr that we passed when we set tdi handlers
 *            ConnectionContext - our context, pTcpConn for this connection
 *            RcvFlags - more info about how the data was received
 *            BytesIndicated - number of bytes tcp is indicating
 *            BytesAvailable - number of bytes that came in (tcp has with it)
 *            pDsiData - the data that came in
 *
 *  Parm OUT: pBytesAccepted - how many bytes did we accept
 *            ppIrp - irp, if for tcp to copy data in (if needed)
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiReceiveHandler(
    IN  PVOID       EventContext,
    IN  PVOID       ConnectionContext,
    IN  USHORT      RcvFlags,
    IN  ULONG       BytesIndicated,
    IN  ULONG       BytesAvailable,
    OUT PULONG      pBytesAccepted,
    IN  PVOID       pDsiData,
    OUT PIRP       *ppIrp
)
{

    NTSTATUS        status;
    PTCPCONN        pTcpConn;
    PBYTE           pBuffer;
    PIRP            pIrp;


    pTcpConn = (PTCPCONN)ConnectionContext;

    *ppIrp = NULL;
    *pBytesAccepted = 0;

    ASSERT(VALID_TCPCONN(pTcpConn));

    status = DsiProcessData(pTcpConn,
                            BytesIndicated,
                            BytesAvailable,
                            (PBYTE)pDsiData,
                            pBytesAccepted,
                            ppIrp);

    return(status);
}

/***	DsiTdiDisconnectHandler
 *
 *	This routine
 *
 *  Parm IN:  EventContext - pTcpAdptr that we passed when we set tdi handlers
 *            ConnectionContext - our context, pTcpConn for this connection
 *            DisconnectDataLength -
 *            pDisconnectData -
 *
 *
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiDisconnectHandler(
    IN PVOID        EventContext,
    IN PVOID        ConnectionContext,
    IN ULONG        DisconnectDataLength,
    IN PVOID        pDisconnectData,
    IN ULONG        DisconnectInformationLength,
    IN PVOID        pDisconnectInformation,
    IN ULONG        DisconnectIndicators
)
{

    PTCPCONN        pTcpConn;
    KIRQL           OldIrql;
    BOOLEAN         fMustAbort=FALSE;
    BOOLEAN         fWeInitiatedAbort=FALSE;


    pTcpConn = (PTCPCONN)ConnectionContext;

    ASSERT(VALID_TCPCONN(pTcpConn));

    //
    // if the connection went away non-gracefully (i.e. TCP got a reset), and
    // if we have not already given an irp down to tcp to disconnect, then
    // complete the disconnect here
    //
    if ((UCHAR)DisconnectIndicators == TDI_DISCONNECT_ABORT)
    {
        ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

        fWeInitiatedAbort =
            (pTcpConn->con_State & TCPCONN_STATE_ABORTIVE_DISCONNECT)? TRUE : FALSE;

        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("ABORT from %s on %lx\n",fWeInitiatedAbort?"Local":"Remote",pTcpConn));

        if (pTcpConn->con_State & TCPCONN_STATE_NOTIFY_TCP)
        {
            fMustAbort = TRUE;
            pTcpConn->con_State &= ~TCPCONN_STATE_NOTIFY_TCP;
            pTcpConn->con_State |= TCPCONN_STATE_CLOSING;
        }
        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

        if (fMustAbort)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                ("DsiTdiDisconnectHandler: abortive disconnect on %lx\n",pTcpConn));

            DsiAbortConnection(pTcpConn);

            DsiTcpDisconnectCompletion(NULL, NULL, pTcpConn);

            // TCP is telling us it got cient's RST: remove the TCP CLIENT-FIN refcount
            DsiDereferenceConnection(pTcpConn);

            DBGREFCOUNT(("DsiTdiDisconnectHandler: CLIENT-FIN dec %lx (%d  %d,%d)\n",
                pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
        }

        //
        // if we had initiated a graceful close, remove that TCP CLIENT-FIN refcount:
        // (if we had initiated an abortive close, we already took care of it)
        //
        else if (!fWeInitiatedAbort)
        {
            DsiDereferenceConnection(pTcpConn);
        }
        else
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
                ("DsiTdiDisconnectHandler: abortive disc,race condition on %lx\n",
                pTcpConn));
        }
    }
    else if ((UCHAR)DisconnectIndicators == TDI_DISCONNECT_RELEASE)
    {
        //
        // since we got a graceful disconnect from the remote client, we had
        // better received the DSI Close already.  If not, the client is on
        // drugs, so just reset the connection!
        //
        ACQUIRE_SPIN_LOCK(&pTcpConn->con_SpinLock, &OldIrql);

        if ((pTcpConn->con_State & TCPCONN_STATE_AFP_ATTACHED) &&
            (!(pTcpConn->con_State & TCPCONN_STATE_RCVD_REMOTE_CLOSE)))
        {
            fMustAbort = TRUE;
        }
        RELEASE_SPIN_LOCK(&pTcpConn->con_SpinLock, OldIrql);

        if (fMustAbort)
        {
            DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_WARN,
                ("DsiTdiDisconnectHandler: ungraceful FIN, killing %lx\n",pTcpConn));

            DsiAbortConnection(pTcpConn);
        }
        else
        {
            //
            // by this time, we shouldn't have to do this, but just in case we
            // have an ill-behaved client (calling this routine many times is ok)
            //
            DsiTerminateConnection(pTcpConn);

            // TCP is telling us it got cient's FIN: remove the TCP CLIENT-FIN refcount
            DsiDereferenceConnection(pTcpConn);

            DBGREFCOUNT(("DsiTdiDisconnectHandler: CLIENT-FIN dec %lx (%d  %d,%d)\n",
                pTcpConn,pTcpConn->con_RefCount,pTcpConn->con_State,pTcpConn->con_RcvState));
        }
    }
    else
    {
        DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
            ("DsiTdiDisconnectHandler: flag=%d, ignored on %lx\n",
            DisconnectIndicators,pTcpConn));
        ASSERT(0);
    }

    return(STATUS_SUCCESS);
}


/***	DsiTdiErrorHandler
 *
 *	This routine
 *
 *  Parm IN:  EventContext - pTcpAdptr that we passed when we set tdi handlers
 *            status - what went wrong?
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiTdiErrorHandler(
    IN PVOID    EventContext,
    IN NTSTATUS Status
)
{

    DBGPRINT(DBG_COMP_STACKIF, DBG_LEVEL_ERR,
        ("DsiTdiErrorHandler: entered, with Status=%lx\n",Status));

    ASSERT(0);

    return(STATUS_DATA_NOT_ACCEPTED);
}


/***	DsiCloseTdiAddress
 *
 *	This routine closes the address object with TCP
 *
 *  Parm IN:  pTcpAdptr - our adapter object
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiCloseTdiAddress(
    IN PTCPADPTR    pTcpAdptr
)
{

    PEPROCESS   CurrentProcess;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    CurrentProcess = IoGetCurrentProcess();
    AFPAttachProcess(CurrentProcess);;

    if (pTcpAdptr->adp_pFileObject)
    {
        ObDereferenceObject((PVOID *)pTcpAdptr->adp_pFileObject);
        pTcpAdptr->adp_pFileObject = NULL;
    }

    if (pTcpAdptr->adp_FileHandle != INVALID_HANDLE_VALUE)
    {
        ZwClose(pTcpAdptr->adp_FileHandle);
        pTcpAdptr->adp_FileHandle = INVALID_HANDLE_VALUE;
    }

    AFPDetachProcess(CurrentProcess);

    return(STATUS_SUCCESS);
}




/***	DsiCloseTdiConnection
 *
 *	This routine closes the connection object with TCP
 *
 *  Parm IN:  pTcpConn - our connection context
 *
 *  Returns:  status of operation
 *
 */
NTSTATUS
DsiCloseTdiConnection(
    IN PTCPCONN     pTcpConn
)
{

    PEPROCESS   CurrentProcess;


    ASSERT(KeGetCurrentIrql() != DISPATCH_LEVEL);

    ASSERT(pTcpConn->con_Signature == DSI_CONN_SIGNATURE);

    ASSERT(pTcpConn->con_pTcpAdptr->adp_Signature == DSI_ADAPTER_SIGNATURE);

    CurrentProcess = IoGetCurrentProcess();
    AFPAttachProcess(CurrentProcess);;

    if (pTcpConn->con_pFileObject)
    {
        ObDereferenceObject((PVOID *)pTcpConn->con_pFileObject);
        pTcpConn->con_pFileObject = NULL;
    }

    if (pTcpConn->con_FileHandle != INVALID_HANDLE_VALUE)
    {
        ZwClose(pTcpConn->con_FileHandle);
        pTcpConn->con_FileHandle = INVALID_HANDLE_VALUE;
    }

    AFPDetachProcess(CurrentProcess);

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\time.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	time.h

Abstract:

	This file defines macros and prototypes for time related operations.
	header files.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/


#ifndef	_TIME_
#define	_TIME_

#define	AfpGetPerfCounter(pTime)	*(pTime) = KeQueryPerformanceCounter(NULL)

extern
VOID
AfpGetCurrentTimeInMacFormat(
	OUT	PAFPTIME 	MacTime
);


extern
AFPTIME
AfpConvertTimeToMacFormat(
	IN	PTIME		pSomeTime
);

extern
VOID
AfpConvertTimeFromMacFormat(
	IN	AFPTIME		MacTime,
	OUT PTIME		pNtTime
);

#endif	// _TIME_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\volume.h ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	volume.h

Abstract:

	This module contains volume related data structures.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef _VOLUME_
#define _VOLUME_

#define IDINDEX_BUCKETS_DIR_MIN     16
#define IDINDEX_BUCKETS_FILE_MIN    32
#define IDINDEX_BUCKETS_DIR_INIT    64          // no index info? assume ~1000 dirs
#define IDINDEX_BUCKETS_FILE_INIT   1024        // no index info? assume ~20000 files
#define IDINDEX_BUCKETS_32K         32768
#define IDINDEX_BUCKETS_MAX		    65536
#define IDINDEX_CACHE_ENTRIES		512
#define APPL_BUCKETS				16
#define ICON_BUCKETS				16

#define AFP_VOLUME_FIXED_DIR		2		// Volume Signature

// These flags should be consistent with AFP
// The UI (registry) visible definitions are in macfile.h

// #define AFP_VOLUME_READONLY			0x00000001
// #define VOLUME_GUESTACCESS			0x00008000
// #define VOLUME_EXCLUSIVE				0x00010000
// #define AFP_VOLUME_HAS_CUSTOM_ICON	0x00020000
// #define AFP_VOLUME_4GB				0x00040000
// #define AFP_VOLUME_AGE_DFES			0x00080000

#define AFP_VOLUME_HASPASSWORD			0x00000002
#define AFP_VOLUME_SUPPORTS_FILEID		0x00000004
#define AFP_VOLUME_SUPPORTS_CATSRCH		0x00000008
#define AFP_VOLUME_SUPPORTS_BLANKPRV	0x00000010
#define	AFP_VOLUME_MASK_AFP				0x0000001F	// This is all AFP can see

#define	VOLUME_PROCESSING_NOTIFY		0x00000020	// Notify processing under way
#define	VOLUME_NOTIFY_POSTED			0x00000040	// Notify has been posted

#define	VOLUME_STOPPED					0x00000080	// The volume is about to stop
													// Set when server is stopping
#define	VOLUME_DELETED					0x00000100	// This volume is about to be
													// deleted, set when volume is
													// deleted by admin
#define	VOLUME_IDDBHDR_DIRTY			0x00000200	// The header needs to be written ASAP

#define	VOLUME_NTFS						0x00000400	// Volume is an NTFS volume
#define	VOLUME_INTRANSITION				0x00000800	// VolumeAdd is in progress
													// Is not usable still.
#define	VOLUME_SCAVENGER_RUNNING		0x00001000	// Volume is referenced for scavenger
#define	VOLUME_CDFS_INVALID				0x00002000	// If this is set, then no go
#define	VOLUME_INITIAL_CACHE			0x00004000	// Set initially when caching
#define VOLUME_CD_HFS					0x00200000	// volume is a CD with HFS support
#define VOLUME_DISKQUOTA_ENABLED        0x00400000  // diskquota is enabled on this volume
#define VOLUME_NEW_FIRST_PASS           0x00800000  // first pass of id db building
#define VOLUME_SRVR_NOTIF_PENDING       0x01000000  // server notification is pending


// Values for scavenger routines
#define	VOLUME_NTFS_SCAVENGER_INTERVAL	60		// # of seconds
#define	VOLUME_CDFS_SCAVENGER_INTERVAL	60		// # of seconds
//#define	VOLUME_IDDB_UPDATE_INTERVAL	600		// # of seconds
//#define	MAX_INVOCATIONS_TO_SKIP		60		// # of passes
//#define	MAX_CHANGES_BEFORE_WRITE	1000	// # of changes
#define VOLUME_OURCHANGE_AGE			30		// # of seconds
#define OURCHANGE_AGE					10		// # of seconds
//
// The ChangeNotify delay is introduced to prevent the problem where
// the PC side is doing a copyfile or forkize of a macfile, and as
// soon as we receive the notification of the initial create we will
// slap on our AFPInfo stream.  Then when the CopyFile or forkize operation
// gets around to writing its AFPInfo, we do not get notified and will not
// reread the information.  In this case, a mac file copied from one volume
// to another (e.g.) will not show up with the correct finder info.
//
#define	VOLUME_NTFY_DELAY				3		// # of seconds
#define	VOLUME_IDDB_AGE_DELAY			60*60	// # of seconds
#define	VOLUME_IDDB_AGE_GRANULARITY		30		// # of invocations

#define VOLUME_STARTUP_WAIT             5       // # of seconds to wait

// make sure there is enough room to hold a change notification for a
// rename operation on a maximum length win32 path (which is 260 chars)
#define	AFP_VOLUME_NOTIFY_STARTING_BUFSIZE		(2048 - POOL_OVERHEAD)
#define	AFP_VOLUME_NOTIFY_MAX_BUFSIZE		    8*16384

// List of these structures hangs off the volume descriptor to list the
// changes initiated by us that should be filtered from the ChangeNotify
// list of changes.
typedef struct _OurChange
{
	LIST_ENTRY			oc_Link;
	UNICODE_STRING		oc_Path;
	AFPTIME				oc_Time;	// Time when this was queued.
} OUR_CHANGE, *POUR_CHANGE;

// defines for indices into vds_OurChangeList
#define AFP_CHANGE_ACTION_ADDED				0
#define AFP_CHANGE_ACTION_REMOVED			1
#define AFP_CHANGE_ACTION_MODIFIED			2
#define AFP_CHANGE_ACTION_RENAMED			3
#define AFP_CHANGE_ACTION_MODIFIED_STREAM	4
#define	AFP_CHANGE_ACTION_MAX				AFP_CHANGE_ACTION_MODIFIED_STREAM
#define NUM_AFP_CHANGE_ACTION_LISTS			(AFP_CHANGE_ACTION_MAX + 1)

// Convert an NT FILE_ACTION_xxx (ntioapi.h) to an array index into
// vds_OurChangeList array.  Note the close tie between the first 4
// AFP_CHANGE_ACTION_xxx and the values of FILE_ACTION_xxx in ntioapi.h
#define AFP_CHANGE_ACTION(NTAction)	\
	(NTAction == FILE_ACTION_MODIFIED_STREAM ? AFP_CHANGE_ACTION_MODIFIED_STREAM : (NTAction - 1))

/*
 * All changes to the volume descriptor should be protected by vds_VolLock
 * Changes to the Id Db and the desktop Db should be protected by their
 * respective locks.
 *
 * NOTE:  The volume path and name (unicode) must be uppercased, since when
 *		 looking up or adding a volume, we will be holding a spinlock, and
 *		 case insensitive string compares cannot be done at DPC level since
 *		 the codepages are kept in paged memory, and we can't take a page
 *		 fault at DPC level.
 */
#if DBG
#define	VOLDESC_SIGNATURE		*(DWORD *)"VDS"
#define	VALID_VOLDESC(pVolDesc)	(((pVolDesc) != NULL) && \
								 ((pVolDesc)->Signature == VOLDESC_SIGNATURE))
#else
#define	VALID_VOLDESC(pVolDesc)	((pVolDesc) != NULL)
#endif

typedef struct _VolDesc
{
#if	DBG
	DWORD				Signature;
	DWORD				QuadAlign1;
#endif
	struct _VolDesc *	vds_Next;			// Pointer to next volume
	DWORD				vds_UseCount;		// Number of active connections
	DWORD				vds_RefCount;		// Number of references.
											// Cannot be freed till both of the
											// above go to ZERO. Of course there
											// is a RefCount for every UseCount
	// Configuration information.
	DWORD				vds_Flags;			// Volume flags
	LONG				vds_VolId;			// Volume Id for FPOpenVol
	DWORD				vds_MaxUses;		// Maximum opens on a volume
	UNICODE_STRING		vds_Name;			// Volume name in unicode
	UNICODE_STRING		vds_UpCaseName;		// Volume name in UPPER CASE unicode
	ANSI_STRING			vds_MacName;		// Volume name in Mac Ansi
	ANSI_STRING			vds_MacPassword;	// Volume password in Mac Ansi
	UNICODE_STRING		vds_Path;			// File system path to the volume root;
											//  Path is always upper cased


	LARGE_INTEGER		vds_VolumeSize;		// Size of volume
	LARGE_INTEGER		vds_FreeBytes;		// Free space on the volume
#define	vds_pFileObject	vds_hRootDir.fsh_FileObject
	FILESYSHANDLE		vds_hRootDir;		// Handle to open root directory
											// in the servers context. All
											// subsequent opens are relative
											// to this handle
	FILESYSHANDLE		vds_hNWT;			// Handle to Network Trash so it can't
											// be deleted from under us (NTFS)

    DWORD               vds_AllocationBlockSize;
                                            // Bytes per sector

	// The following fields are used by the Id database code and are copied
	// to/from the on-disk idDb header. Protected by vds_VolLock.
	DWORD				vds_LastId;			// Highest id that is assigned
	AFPTIME				vds_CreateTime;		// Creation time for this volume
	AFPTIME				vds_ModifiedTime;	// Modified time for this volume
	AFPTIME				vds_BackupTime;		// Backup time for this volume

#ifdef	AGE_DFES
	DWORD				vds_ScavengerInvocationCnt;
											// Used by the volume scavenger to fire off
											// AfpAgeDfEntries
#endif
	DWORD				vds_RequiredNotifyBufLen;
											// How deep is the tree. This is used by
											// the afpVolumePostnotify to allocate an
											// appropriate buffer.
#ifdef	BLOCK_MACS_DURING_NOTIFYPROC
	DWORD				vds_QueuedNotifyCount;
											// How many change notify buffers
											// have moved into the global queue
											// for this volume -- This value is
											// ONLY touched by the Change
											// Notify thread.
#endif
	SWMR				vds_IdDbAccessLock;	// Access cookie for the id db
											// Protects the vds_pDfexxxBuckets.
	LONG				vds_cScvgrIdDb;		// # of times the update to the Id
											// database was passed up
	DWORD				vds_NumDirDfEntries;// Number of directory DfEntries in this volume
	DWORD				vds_NumFileDfEntries;// Number of file DfEntries in this volume
	struct _DirFileEntry * vds_pDfeRoot;	// Pointer to DFE of root

    DWORD               vds_DirHashTableSize;
    DWORD               vds_FileHashTableSize;
	struct _DirFileEntry ** vds_pDfeDirBucketStart;
	struct _DirFileEntry ** vds_pDfeFileBucketStart;
											// IdDb DfEntry hash buckets
	struct _DirFileEntry * vds_pDfeCache[IDINDEX_CACHE_ENTRIES];
											// IdDb DfEntry cache

	// The following fields are used by the desktop database code
	LONG				vds_cScvgrDt;		// # of times the update to the desktop
											// database was passed up
	SWMR				vds_DtAccessLock;	// Access cookie for the desktop db
											// Protects the following FIVE fields

	// The following fields are copied to/from the on-disk Desktop header.
	// Protected by vds_VolLock.
	LONG				vds_cApplEnts;		// Number of APPL entries
	LONG				vds_cIconEnts;		// Number of ICON entries

	struct _ApplInfo2 *	vds_pApplBuckets[APPL_BUCKETS];
											// APPL hash buckets
	struct _IconInfo *	vds_pIconBuckets[ICON_BUCKETS];
											// ICON hash buckets
	SWMR				vds_ExchangeFilesLock; // Access to the FileId stored
											// in an OpenForkDesc, used by
											// FpExchangeFiles and fork APIs

	LIST_ENTRY			vds_OurChangeList[NUM_AFP_CHANGE_ACTION_LISTS];
											// ^^^
											// Lists of create/delete/move/rename
											// operations initiated by this server

	LIST_ENTRY			vds_ChangeNotifyLookAhead;
											// ^^^
											// List of all completed (but not yet
											// processed) DELETE or RENAME changes
											// on this Volume.

	LIST_ENTRY			vds_DelayedNotifyList;

	struct _OpenForkDesc * vds_pOpenForkDesc;
											// List of open forks for this volume

	LONG				vds_cPrivateNotifies;
											// Count of private notifies
	LONG				vds_maxPrivateNotifies;
											// Keep track of max private notifies
	PBYTE				vds_EnumBuffer;		// Used during notify processing to cache in the tree
	LONG				vds_cOutstandingNotifies;
											// Used in conjunction with above
	PIRP				vds_pIrp;			// Irp used by Notify, we never
											// free this until its time to
											// delete or stop
	DWORD				vds_TimeMustSendNotify;  // time at which we *must* send the notif
	DWORD  				vds_TimeToSendNotify;  // when to send the next notification
	AFP_SPIN_LOCK		vds_VolLock;		// Lock for this volume
    BOOLEAN             MacLimitExceeded;   // True if # folders or volume size exceeds Apple limits
	LARGE_INTEGER			vds_IndxStTime;
} VOLDESC, *PVOLDESC;

// AppleShare limit for files+folders in a volume: 65535
#define APLIMIT_MAX_FOLDERS     0xffff

#define	IS_VOLUME_NTFS(pVolDesc)		(((pVolDesc)->vds_Flags & VOLUME_NTFS) ? True : False)
#define	IS_VOLUME_RO(pVolDesc)			(((pVolDesc)->vds_Flags & AFP_VOLUME_READONLY) ? True : False)
#define	IS_VOLUME_CD_HFS(pVolDesc)		(((pVolDesc)->vds_Flags & VOLUME_CD_HFS) ? True : False)
#define	EXCLUSIVE_VOLUME(pVolDesc)		(((pVolDesc)->vds_Flags & AFP_VOLUME_EXCLUSIVE) ? True : False)
#define IS_VOLUME_AGING_DFES(pVolDesc)	(((pVolDesc)->vds_Flags & AFP_VOLUME_AGE_DFES) ? True : False)

#define	CONN_DESKTOP_CLOSED			0x0000
#define	CONN_DESKTOP_OPENED			0x0001
#define	CONN_CLOSING				0x8000

#if DBG
#define	CONNDESC_SIGNATURE			*(DWORD *)"CDS"
#define	VALID_CONNDESC(pConnDesc)	\
								(((pConnDesc) != NULL) && \
								 ((pConnDesc)->Signature == CONNDESC_SIGNATURE))
#else
#define	VALID_CONNDESC(pConnDesc)	((pConnDesc) != NULL)
#endif

typedef struct _ConnDesc
{
#if	DBG
	DWORD				Signature;
#endif
	LONG				cds_RefCount;	// Number of references to the open volume
	DWORD				cds_Flags;		// One or more of the bits defined above
	struct _ConnDesc *	cds_Next;		// Link to next open volume for this
										// session. Starts from the SDA
	struct _ConnDesc *	cds_NextGlobal;	// Link to next for global list.
										// Starts from AfpConnList
	struct _VolDesc *	cds_pVolDesc;	// Pointer to volume structure
	PSDA				cds_pSda;		// Session that opened this volume
    LARGE_INTEGER       cds_QuotaLimit; // how much is the DiskQuota limit
    LARGE_INTEGER       cds_QuotaAvl;   // how much DiskQuota is available
	DWORD				cds_ConnId;		// Connection Id assigned by the server
	AFPTIME				cds_TimeOpened;	// Time stamp when volume opened
										// in macintosh time
	LONG				cds_cOpenForks;	// Number of open forks from this conn
	PENUMDIR			cds_pEnumDir;	// Current enumerated directory
	AFP_SPIN_LOCK			cds_ConnLock;	// Lock for this connection
} CONNDESC, *PCONNDESC;

#define	IS_CONN_NTFS(pConnDesc)	IS_VOLUME_NTFS((pConnDesc)->cds_pVolDesc)
#define	IS_CONN_CD_HFS(pConnDesc)	IS_VOLUME_CD_HFS((pConnDesc)->cds_pVolDesc)

// Volume parameters bitmap definitions
#define	VOL_BITMAP_ATTR				0x0001
#define	VOL_BITMAP_SIGNATURE		0x0002
#define	VOL_BITMAP_CREATETIME		0x0004
#define	VOL_BITMAP_MODIFIEDTIME		0x0008
#define	VOL_BITMAP_BACKUPTIME		0x0010
#define	VOL_BITMAP_VOLUMEID			0x0020
#define	VOL_BITMAP_BYTESFREE		0x0040
#define	VOL_BITMAP_VOLUMESIZE		0x0080
#define	VOL_BITMAP_VOLUMENAME		0x0100
#define VOL_BITMAP_EXTBYTESFREE     0x0200
#define VOL_BITMAP_EXTBYTESTOTAL    0x0400
#define VOL_BITMAP_ALLOCBLKSIZE     0x0800
#define	VOL_BITMAP_MASK				0x0FFF

typedef	VOID	(FASTCALL *NOTIFYPROCESSOR)(IN PVOID);

// Structure of a notify buffer. The Mdl describes only the Buffer following the struct.
typedef	struct _VolumeNotify
{
#define Notify_NextFree        Notify_NextOverflow
	struct _VolumeNotify *  Notify_NextOverflow;   // Overflow links

	LIST_ENTRY			vn_List;		// Chained from AfpVolumeNotifyQueue[i]
	union
	{
		LIST_ENTRY		vn_DelRenLink;	// Chained from vds_ChangeNotifyLookAhead
										// - VALID ONLY IFF THE ACTION HAS THE PRIVATE BIT CLEAR
		struct
		{
			DWORD		vn_ParentId;	// Afp Id of the parent
										// - VALID ONLY IFF THE ACTION HAS THE PRIVATE BIT SET
			DWORD		vn_TailLength;	// Length in bytes of the last component of the path
										// - VALID ONLY IFF THE ACTION HAS THE PRIVATE BIT SET
		};
	};
	NOTIFYPROCESSOR		vn_Processor;	// Routine that processes the notification
	AFPTIME				vn_TimeStamp;	// When the notify came in
	PVOLDESC			vn_pVolDesc;	// Volume being watched
	DWORD 				vn_StreamId;	// Stream Id
	LONG				vn_VariableLength;	
	// followed by FILE_NOTIFY_INFORMATION
} VOL_NOTIFY, *PVOL_NOTIFY;

// Notify's come in four sizes. This helps in efficiently managing them in a block
// package (see later). THESE SIZES NEED TO BE 4*N, else we run into alignment
// faults on architectures that require it.
#define	NOTIFY_INDEX_TINY			0
#define	NOTIFY_INDEX_SMALL			1
#define	NOTIFY_INDEX_MEDIUM			2
#define	NOTIFY_INDEX_LARGE			3

//
// Make sure each of the sizes below (XXX_U) are multiple of 8
//
#define	NOTIFY_SIZE_TINY			128		// These are lengths for ANSI names
#define	NOTIFY_SIZE_SMALL			256		//		- ditto -
#define	NOTIFY_SIZE_MEDIUM			512		//		- ditto -
#define	NOTIFY_SIZE_LARGE			1024		//		- ditto -	corres. to AFP_FILENAME_LEN

#define	NOTIFY_SIZE_TINY_U			NOTIFY_SIZE_TINY*sizeof(WCHAR)		// These are lengths for UNICODE names
#define	NOTIFY_SIZE_SMALL_U			NOTIFY_SIZE_SMALL*sizeof(WCHAR)	//		- ditto -
#define	NOTIFY_SIZE_MEDIUM_U		NOTIFY_SIZE_MEDIUM*sizeof(WCHAR)	//		- ditto -
#define	NOTIFY_SIZE_LARGE_U			NOTIFY_SIZE_LARGE*sizeof(WCHAR)	//		- ditto -	corres. to AFP_FILENAME_LEN

#define	NOTIFY_USIZE_TO_INDEX(_Size)												\
		(((_Size) <= NOTIFY_SIZE_TINY_U) ? NOTIFY_INDEX_TINY :					\
						(((_Size) <= NOTIFY_SIZE_SMALL_U) ? NOTIFY_INDEX_SMALL :	\
						 (((_Size) <= NOTIFY_SIZE_MEDIUM_U) ? NOTIFY_INDEX_MEDIUM : NOTIFY_INDEX_LARGE)))



// Notify Blocks are aged after NOTIFY_MAX_BLOCK_AGE*NOTIFY_DIR_BLOCK_AGE_TIME seconds (currently 1 min/s)
#define	NOTIFY_MAX_BLOCK_AGE			1
#define	NOTIFY_DIR_BLOCK_AGE_TIME		60		// # of seconds
#define	NOTIFY_MAX_BLOCK_TYPE			4			// For TINY, SMALL, MEDIUM & LARGE

#define VALID_NOTIFY_BLOCK(pDfeBlock)	((pDfeBlock) != NULL)

typedef	struct _Notify_Block
{
	struct _Notify_Block *	dfb_Next;			// Link to next
	struct _Notify_Block **	dfb_Prev;			// Link to previous
	USHORT				dfb_NumFree;		// # of free DFEs in this block
	BYTE				dfb_Age;			// Age of the Block if all are free
	BOOLEAN				dfb_fDir;			// TRUE if it is a Dir DFB - else a file DFB
	PVOL_NOTIFY			dfb_FreeHead;		// Head of the list of free DFEs
} VOL_NOTIFY_BLOCK, *PVOL_NOTIFY_BLOCK, **PPVOL_NOTIFY_BLOCK;

GLOBAL	PVOL_NOTIFY_BLOCK	afpDirNotifyFreeBlockHead[NOTIFY_MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };
GLOBAL	PVOL_NOTIFY_BLOCK	afpDirNotifyPartialBlockHead[NOTIFY_MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };
GLOBAL	PVOL_NOTIFY_BLOCK	afpDirNotifyUsedBlockHead[NOTIFY_MAX_BLOCK_TYPE] EQU  { NULL, NULL, NULL };

GLOBAL	SHORT	afpNotifyUnicodeBufSize[NOTIFY_MAX_BLOCK_TYPE] EQU		\
	{																	\
		NOTIFY_SIZE_TINY_U, NOTIFY_SIZE_SMALL_U,						\
		NOTIFY_SIZE_MEDIUM_U, NOTIFY_SIZE_LARGE_U						\
	};

GLOBAL	USHORT		afpNotifyDirBlockSize[NOTIFY_MAX_BLOCK_TYPE] EQU		    \
	{																    \
		(USHORT)(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_TINY_U),	\
		(USHORT)(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_SMALL_U),	\
		(USHORT)(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_MEDIUM_U),	\
		(USHORT)(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_LARGE_U)	\
	};

GLOBAL	USHORT      afpNotifyNumDirBlocks[NOTIFY_MAX_BLOCK_TYPE] EQU		\
	{																\
		(PAGE_SIZE - sizeof(VOL_NOTIFY_BLOCK))/						        \
			(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_TINY_U),	\
		(PAGE_SIZE - sizeof(VOL_NOTIFY_BLOCK))/						        \
			(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_SMALL_U),\
		(PAGE_SIZE - sizeof(VOL_NOTIFY_BLOCK))/						        \
			(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_MEDIUM_U),\
		(PAGE_SIZE - sizeof(VOL_NOTIFY_BLOCK))/						        \
			(sizeof(VOL_NOTIFY) + sizeof(FILE_NOTIFY_INFORMATION) + (AFP_LONGNAME_LEN+1)*sizeof(WCHAR) + NOTIFY_SIZE_LARGE_U)	\
	};

GLOBAL  SWMR    afpNotifyBlockLock EQU { 0 };

GLOBAL	LONG		afpNotifyAllocCount	EQU 0;
GLOBAL	LONG		afpNotifyBlockAllocCount	EQU 0;
GLOBAL	LONG		afpMaxNotifyBlockAllocCount	EQU 0;
GLOBAL	LONG		afpNotify64kBlockCount	EQU 0;


// For maintaining track of delayed transactions
typedef struct _DELAYED_NOTIFY {
	    LIST_ENTRY dn_List;
		UNICODE_STRING filename;
} DELAYED_NOTIFY, *PDELAYED_NOTIFY;

// largest volume id that's currently in use.
GLOBAL	LONG	                afpLargestVolIdInUse    EQU  0;

GLOBAL	LONG			AfpVolCount			EQU 0;		// Total number of volumes
GLOBAL	PVOLDESC		AfpVolumeList		EQU NULL;	// List of volumes
GLOBAL	AFP_SPIN_LOCK		AfpVolumeListLock	EQU {0};	// Lock for AfpVolumeList,
GLOBAL 	SWMR				AfpVolumeListSwmr;	// Access cookie VolumeNotifyList 
														// AfpVolCount,
														// AfpVolumeNotifyList,
														// AfpVolumeNotifyCount

GLOBAL	PCONNDESC		AfpConnList			EQU NULL;	// Global connection list
GLOBAL	AFP_SPIN_LOCK		AfpConnLock			EQU { 0 };	// Lock for AfpConnList

GLOBAL	UNICODE_STRING	AfpNetworkTrashNameU EQU { 0 };

GLOBAL	KQUEUE			AfpVolumeNotifyQueue[NUM_NOTIFY_QUEUES] EQU { 0 };
GLOBAL	LIST_ENTRY		AfpVolumeNotifyList[NUM_NOTIFY_QUEUES] EQU { 0 };
GLOBAL	LIST_ENTRY		AfpVirtualMemVolumeNotifyList[NUM_NOTIFY_QUEUES] EQU { 0 };

// Count of change notification buffers that are in the list
GLOBAL	LONG			AfpNotifyListCount[NUM_NOTIFY_QUEUES] EQU { 0 };
// Count of change notification buffers that have transitioned into the queue.
GLOBAL	LONG			AfpNotifyQueueCount[NUM_NOTIFY_QUEUES] EQU { 0 };
GLOBAL	VOL_NOTIFY		AfpTerminateNotifyThread EQU { 0 };

GLOBAL  LONG            ChangeNotifyQueueLimit EQU 200000;

#define	AfpVolumeQueueChangeNotify(pVolNotify, pNotifyQueue)			\
	{																	\
		KeInsertQueue(pNotifyQueue,										\
					  &(pVolNotify)->vn_List);							\
	}

// Used for PRIVATE notifies of directory ADDED
#define AFP_QUEUE_NOTIFY_IMMEDIATELY	BEGINNING_OF_TIME

#define	AfpVolumeInsertChangeNotifyList(pVolNotify, pVolDesc)			\
	{																	\
		PLIST_ENTRY	pListHead;											\
																		\
		pListHead = &AfpVolumeNotifyList[(pVolDesc)->vds_VolId % NUM_NOTIFY_QUEUES]; \
		if (pVolNotify->vn_TimeStamp != AFP_QUEUE_NOTIFY_IMMEDIATELY)	\
		{																\
			ExInterlockedInsertTailList(pListHead,						\
										&(pVolNotify)->vn_List,			\
										&(AfpVolumeListLock.SpinLock));			\
		}																\
		else															\
		{																\
			ExInterlockedInsertHeadList(pListHead,						\
										&(pVolNotify)->vn_List,			\
										&(AfpVolumeListLock.SpinLock));			\
		}																\
		INTERLOCKED_ADD_ULONG(&AfpNotifyListCount[(pVolDesc)->vds_VolId % NUM_NOTIFY_QUEUES], \
							  1,										\
										&AfpVolumeListLock);			\
	}

#define	AfpIdDbHdrToVolDesc(_pIdDbHdr, _pVolDesc)						\
	{																	\
		(_pVolDesc)->vds_LastId = (_pIdDbHdr)->idh_LastId;				\
		(_pVolDesc)->vds_CreateTime   = (_pIdDbHdr)->idh_CreateTime;	\
		(_pVolDesc)->vds_ModifiedTime = (_pIdDbHdr)->idh_ModifiedTime;	\
		(_pVolDesc)->vds_BackupTime   = (_pIdDbHdr)->idh_BackupTime;	\
	}

#define	AfpVolDescToIdDbHdr(_pVolDesc, _pIdDbHdr)						\
	{																	\
		(_pIdDbHdr)->idh_Signature = AFP_SERVER_SIGNATURE;				\
		(_pIdDbHdr)->idh_Version = AFP_IDDBHDR_VERSION;					\
		(_pIdDbHdr)->idh_LastId = (_pVolDesc)->vds_LastId;				\
		(_pIdDbHdr)->idh_CreateTime   = (_pVolDesc)->vds_CreateTime;	\
		(_pIdDbHdr)->idh_ModifiedTime = (_pVolDesc)->vds_ModifiedTime;	\
		(_pIdDbHdr)->idh_BackupTime   = (_pVolDesc)->vds_BackupTime;	\
	}

#define	AfpDtHdrToVolDesc(_pDtHdr, _pVolDesc)							\
	{																	\
		(_pVolDesc)->vds_cApplEnts = (_pDtHdr)->dtp_cApplEnts;			\
		(_pVolDesc)->vds_cIconEnts = (_pDtHdr)->dtp_cIconEnts;			\
	}

#define	AfpVolDescToDtHdr(_pVolDesc, _pDtHdr)							\
	{																	\
		(_pDtHdr)->dtp_Signature = AFP_SERVER_SIGNATURE;				\
		(_pDtHdr)->dtp_Version = AFP_DESKTOP_VERSION;					\
		(_pDtHdr)->dtp_cApplEnts = (_pVolDesc)->vds_cApplEnts;			\
		(_pDtHdr)->dtp_cIconEnts = (_pVolDesc)->vds_cIconEnts;			\
	}

extern
NTSTATUS
AfpVolumeInit(
	VOID
);

extern
PCONNDESC FASTCALL
AfpConnectionReference(
	IN	PSDA			pSda,
	IN	LONG			VolId
);


extern
PCONNDESC FASTCALL
AfpConnectionReferenceAtDpc(
	IN  PSDA		pSda,
	IN  LONG		VolId
);

extern
PCONNDESC FASTCALL
AfpConnectionReferenceByPointer(
	IN	PCONNDESC		pConnDesc
);


extern
PCONNDESC FASTCALL
AfpReferenceConnectionById(
	IN	 DWORD			ConnId
);


extern
VOID FASTCALL
AfpConnectionDereference(
	IN	PCONNDESC		pConnDesc
);


extern
BOOLEAN FASTCALL
AfpVolumeReference(
	IN	PVOLDESC		pVolDesc
);

extern
PVOLDESC FASTCALL
AfpVolumeReferenceByUpCaseName(
	IN	PUNICODE_STRING	pTargetName
);

extern
AFPSTATUS FASTCALL
AfpVolumeReferenceByPath(
	IN	PUNICODE_STRING	pFDPath,
	OUT	PVOLDESC	*	ppVolDesc
);

extern
VOID FASTCALL
AfpVolumeDereference(
	IN	PVOLDESC		pVolDesc
);

extern
BOOLEAN
AfpVolumeMarkDt(
	IN	PSDA			pSda,
	IN	PCONNDESC		pConnDesc,
	IN	DWORD			OpenState
);


extern
VOID FASTCALL
AfpVolumeSetModifiedTime(
	IN	PVOLDESC		pVolDesc
);


extern
AFPSTATUS FASTCALL
AfpSendServerNotification(
	IN	PVOLDESC		pVolDesc
);

extern
AFPSTATUS
AfpConnectionOpen(
	IN	PSDA			pSda,
	IN	PANSI_STRING	pVolName,
	IN	PANSI_STRING	pVolPass,
	IN	DWORD			Bitmap,
	OUT	PBYTE			pVolParms
);


extern
VOID FASTCALL
AfpConnectionClose(
	IN	PCONNDESC		pConnDesc
);

extern
USHORT FASTCALL
AfpVolumeGetParmsReplyLength(
	IN	DWORD			Bitmap,
	IN	USHORT			NameLen
);


extern
VOID
AfpVolumePackParms(
	IN	PSDA			pSda,
	IN	PVOLDESC		pVolDesc,
	IN	DWORD			Bitmap,
	IN	PBYTE			pVolParms
);

extern
AFPSTATUS
AfpAdmWVolumeAdd(
	IN	OUT	PVOID		Inbuf		OPTIONAL,
	IN	LONG			OutBufLen	OPTIONAL,
	OUT	PVOID			Outbuf		OPTIONAL
);

extern
AFPSTATUS
AfpAdmWVolumeDelete(
	IN	OUT	PVOID		InBuf		OPTIONAL,
	IN	LONG			OutBufLen	OPTIONAL,
	OUT	PVOID			OutBuf		OPTIONAL
);


extern
AFPSTATUS
AfpAdmWConnectionClose(
	IN	OUT	PVOID		InBuf		OPTIONAL,
	IN	LONG			OutBufLen	OPTIONAL,
	OUT	PVOID			OutBuf		OPTIONAL
);

extern
VOID
AfpVolumeStopAllVolumes(
	VOID
);

extern
AFPSTATUS FASTCALL
AfpVolumeBeginIndexing(
    IN  PVOLDESC            pVolDesc
);

extern
NTSTATUS FASTCALL
AfpVolumePostChangeNotify(
	IN	PVOLDESC		pVolDesc
);

extern
VOID FASTCALL
AfpUpdateVolFreeSpaceAndModTime(
	IN	PVOLDESC	pVolDesc,
    IN  BOOLEAN     fUpdateModTime
);

extern
AFPSTATUS FASTCALL
AfpVolumeScavenger(
	IN	PVOLDESC		pVolDesc
);

extern
BOOLEAN FASTCALL
AfpVolumeAbortIndexing(
    IN  PVOLDESC    pVolDesc
);

extern
BOOLEAN FASTCALL
AfpVolumeStopIndexing(
    IN  PVOLDESC    pVolDesc,
	IN  PVOL_NOTIFY pVolNotify
);

extern
PVOL_NOTIFY 
afpAllocNotify(
	IN	LONG						Index,
	IN	BOOLEAN						fDir
);

extern
VOID 
afpFreeNotify(					
	IN	PVOID					pDfEntry
);

extern
AFPSTATUS FASTCALL
afpNotifyBlockAge(
    IN  PPVOL_NOTIFY_BLOCK		pBlockHead
);

extern
VOID
afpFreeNotifyBlockMemory(
);

VOID
AfpVolumeUpdateIdDbAndDesktop(
	IN	PVOLDESC		pVolDesc,
	IN	BOOLEAN			WriteDt,
	IN	BOOLEAN			WriteIdDb,
	IN	PIDDBHDR		pIdDbHdr	OPTIONAL
);

extern
VOID FASTCALL
afpActivateVolume(
    IN  struct _VolDesc *           pVolDesc
);


#ifdef	VOLUME_LOCALS
//
// private routines
//

LOCAL AFPSTATUS FASTCALL
afpVolumeCloseHandleAndFreeDesc(
	IN	PVOLDESC		pVolDesc
);

LOCAL AFPSTATUS FASTCALL
afpVolumeAdd(
	IN	PVOLDESC		pVolDesc
);

LOCAL AFPSTATUS FASTCALL
afpVolumeCheckForDuplicate(
	IN	PVOLDESC		pNewVol
);

LOCAL VOID FASTCALL
afpVolumeGetNewIdAndLinkToList(
	IN	PVOLDESC		pVolDesc
);

LOCAL VOID FASTCALL
afpNudgeCdfsVolume(
	IN	PVOLDESC		pVolDesc
);

LOCAL PCONNDESC FASTCALL
afpConnectionReferenceById(
	IN	DWORD			ConnId
);

LOCAL VOID FASTCALL
afpConnectionGetNewIdAndLinkToList(
	IN	PCONNDESC		pConnDesc
);

LOCAL NTSTATUS
afpVolumeChangeNotifyComplete(
	IN	PDEVICE_OBJECT	pDeviceObject,
	IN	PIRP			pIrp,
	IN	PVOLDESC		pVolDesc
);

LOCAL	DWORD	afpNextConnId = 1;	// Next conn id to assign to an open volume

LOCAL	LONG	afpNumPostedNotifies = 0;

// This is the smallest free volume id that is guaranteed to be free. Access
// to this is via the AfpVolumeListLock.

LOCAL	LONG	afpSmallestFreeVolId = 1;

#endif	// VOLUME_LOCALS

#endif	// _VOLUME_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\server\time.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	volume.c

Abstract:

	This module contains the routines which manipulates time values and
	conversions.

Author:

	Jameel Hyder (microsoft!jameelh)


Revision History:
	25 Apr 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM	FILE_TIME

#include <afp.h>


/***	AfpGetCurrentTimeInMacFormat
 *
 *	This gets the current system time in macintosh format which is number of
 *	seconds since ZERO hours on Jan 1, 2000. Time before this date is
 * negative time. (the time returned is the system local time)
 */
VOID
AfpGetCurrentTimeInMacFormat(
	OUT AFPTIME *	pMacTime
)
{
	TIME	SystemTime;

	KeQuerySystemTime(&SystemTime);

	*pMacTime = AfpConvertTimeToMacFormat(&SystemTime);
}



/***	AfpConvertTimeToMacFormat
 *
 *	Convert time in the host format i.e. # of 100ns since 1601 A.D. to
 *	the macintosh time i.e. # of seconds since 2000 A.D. The system time
 *	is in UTC. We need to first convert it to local time.
 */
AFPTIME
AfpConvertTimeToMacFormat(
	IN	PTIME	pSystemTime
)
{
	AFPTIME	MacTime;
	TIME	LocalTime;

	// Convert this to number of seconds since 1980
	RtlTimeToSecondsSince1980(pSystemTime, (PULONG)&MacTime);

	MacTime -= SECONDS_FROM_1980_2000;

	return MacTime;
}


/***	AfpConvertTimeFromMacFormat
 *
 *	Convert time in the  macintosh time i.e. # of seconds since 2000 A.D. to
 *	the host format i.e. # of 100ns since 1601 A.D. Convert from local time
 *	to system time i.e UTC.
 */
VOID
AfpConvertTimeFromMacFormat(
	IN	AFPTIME	MacTime,
	OUT PTIME	pSystemTime
)
{
	TIME	LocalTime;

	MacTime += SECONDS_FROM_1980_2000;
	RtlSecondsSince1980ToTime(MacTime, pSystemTime);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\client\apistub.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	apistub.c
//
// Description: This module contains the AFP server service API RPC
//		client stubs.
//
// History:
//	June 11,1992.	NarenG		Created original version.
//
#include "client.h"

//**
//
// Call:	AfpAdminConnect
//
// Returns:	NO_ERROR - success
//		non-zero returns from the AfpRPCBind routine.
//		
//
// Description: This is the DLL entrypoint for AfpAdminConnect
//
DWORD
AfpAdminConnect(
	IN  LPWSTR 		lpwsServerName,
	OUT PAFP_SERVER_HANDLE  phAfpServer
)
{
    // Bind with the server
    //
    return( AfpRPCBind( lpwsServerName, phAfpServer ) );

}

//**
//
// Call:	AfpAdminDisconnect
//
// Returns:	none.
//
// Description: This is the DLL entrypoint for AfpAdminDisconnect
//
VOID
AfpAdminDisconnect(
	IN AFP_SERVER_HANDLE hAfpServer
)
{
    RpcBindingFree( (handle_t *)&hAfpServer );
}

//**
//
// Call:	AfpAdminBufferFree
//
// Returns:	none
//
// Description: This is the DLL entrypoint for AfpAdminBufferFree
//
VOID
AfpAdminBufferFree(
	IN PVOID		pBuffer
)
{
    MIDL_user_free( pBuffer );
}

//**
//
// Call:	AfpAdminVolumeEnum
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero returns from AdpAdminrVolumeEnum
//
// Description: This is the DLL entry point for AfpAdminVolumeEnum.
//
DWORD
AfpAdminVolumeEnum(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	  	*ppbBuffer,
	IN  DWORD		dwPrefMaxLen,
	OUT LPDWORD		lpdwEntriesRead,
	OUT LPDWORD 	  	lpdwTotalEntries,
	IN  LPDWORD 	  	lpdwResumeHandle
)
{
DWORD			dwRetCode;
VOLUME_INFO_CONTAINER   InfoStruct;

    // Touch all pointers
    //
    try {
	
	*ppbBuffer 	  = NULL;
	*lpdwEntriesRead  = 0;
	*lpdwTotalEntries = 0;

	if ( lpdwResumeHandle )
	    *lpdwResumeHandle;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    InfoStruct.dwEntriesRead = 0;
    InfoStruct.pBuffer       = NULL;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrVolumeEnum( hAfpServer,
    					 &InfoStruct,
					 dwPrefMaxLen,
					 lpdwTotalEntries,
					 lpdwResumeHandle );

	if ( InfoStruct.pBuffer != NULL ) {
    	    *ppbBuffer 	     = (LPBYTE)(InfoStruct.pBuffer);
	    *lpdwEntriesRead = InfoStruct.dwEntriesRead;
	}
	else
	    *lpdwEntriesRead = 0;

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminVolumeSetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrVolumeSetInfo
//
// Description: This is the DLL entrypoint for AfpAdminSetInfo
//
DWORD
AfpAdminVolumeSetInfo(
	IN  AFP_SERVER_HANDLE hAfpServer,
	IN  LPBYTE  	      pbBuffer,
    	IN  DWORD	      dwParmNum
)
{
DWORD	dwRetCode;

    if ( dwParmNum == 0 )
	return( ERROR_INVALID_PARAMETER );
	
    if ( !IsAfpVolumeInfoValid( dwParmNum, (PAFP_VOLUME_INFO)pbBuffer ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrVolumeSetInfo( hAfpServer,
		       			    (PAFP_VOLUME_INFO)pbBuffer,
					    dwParmNum );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );

}

//**
//
// Call:	AfpAdminVolumeGetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrVolumeGetInfo
//
// Description: This is the DLL entrypoint for AfpAdminVolumeGetInfo
//
DWORD
AfpAdminVolumeGetInfo(
	IN  AFP_SERVER_HANDLE hAfpServer,
	IN  LPWSTR	      lpwsVolumeName ,
	OUT LPBYTE  	      *ppbBuffer
)
{
DWORD	dwRetCode;

    if ( !IsAfpVolumeNameValid( lpwsVolumeName ) )
	return( ERROR_INVALID_PARAMETER );

    // Make sure that all pointers passed in are valid
    //
    try {
    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode = AfpAdminrVolumeGetInfo( hAfpServer,
					    lpwsVolumeName,
					    (PAFP_VOLUME_INFO*)ppbBuffer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminVolumeDelete
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrVolumeDelete
//
// Description: This is the DLL entrypoint for AfpAdminVolumeDelete
//
DWORD
AfpAdminVolumeDelete(
	IN  AFP_SERVER_HANDLE hAfpServer,
	IN  LPWSTR	      lpwsVolumeName
)
{
DWORD	dwRetCode;

    if ( !IsAfpVolumeNameValid( lpwsVolumeName ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrVolumeDelete( hAfpServer, lpwsVolumeName );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminVolumeAdd
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrVolumeAdd
//
// Description: This is the DLL entrypoint for AfpAdminVolumeAdd
//
DWORD
AfpAdminVolumeAdd(
	IN  AFP_SERVER_HANDLE    hAfpServer,
	IN  LPBYTE  	         pbBuffer
)
{
DWORD	dwRetCode;

    if ( !IsAfpVolumeInfoValid( AFP_VALIDATE_ALL_FIELDS,
				(PAFP_VOLUME_INFO)pbBuffer ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrVolumeAdd(hAfpServer, (PAFP_VOLUME_INFO)pbBuffer);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminInvalidVolumeEnum
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero returns from AdpAdminrInvalidVolumeEnum
//
// Description: This is the DLL entry point for AfpAdminInvalidVolumeEnum.
//
DWORD
AfpAdminInvalidVolumeEnum(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	  	*ppbBuffer,
	OUT LPDWORD		lpdwEntriesRead
)
{
DWORD			dwRetCode;
VOLUME_INFO_CONTAINER   InfoStruct;

    // Touch all pointers
    //
    try {
	
	*ppbBuffer 	  = NULL;
	*lpdwEntriesRead  = 0;

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    InfoStruct.dwEntriesRead = 0;
    InfoStruct.pBuffer       = NULL;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrInvalidVolumeEnum( hAfpServer, &InfoStruct );

	if ( InfoStruct.pBuffer != NULL ) {
    	    *ppbBuffer 	     = (LPBYTE)(InfoStruct.pBuffer);
	    *lpdwEntriesRead = InfoStruct.dwEntriesRead;
	}
	else
	    *lpdwEntriesRead = 0;

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminInvalidVolumeDelete
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrInvalidVolumeDelete
//
// Description: This is the DLL entrypoint for AfpAdminInvalidVolumeDelete
//
DWORD
AfpAdminInvalidVolumeDelete(
	IN  AFP_SERVER_HANDLE hAfpServer,
	IN  LPWSTR	      lpwsVolumeName
)
{
DWORD	dwRetCode;

    if ( !IsAfpVolumeNameValid( lpwsVolumeName ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrInvalidVolumeDelete( hAfpServer, lpwsVolumeName );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminDirectoryGetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrDirectoryGetInfo
//
// Description: This is the DLL entrypoint for AfpAdminDirectoryGetInfo
//
DWORD
AfpAdminDirectoryGetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  LPWSTR		lpwsPath,
	OUT LPBYTE  	        *ppbBuffer
)
{
DWORD	dwRetCode;

    // Make sure that all pointers passed in are valid
    //
    try {
	STRLEN( lpwsPath );
    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode = AfpAdminrDirectoryGetInfo(hAfpServer,
			  	              lpwsPath,
					      (PAFP_DIRECTORY_INFO*)ppbBuffer);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminDirectorySetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrDirectorySetInfo
//
// Description: This is the DLL entrypoint for AfpAdminDirectorySetInfo
//
DWORD
AfpAdminDirectorySetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  LPBYTE  	        pbBuffer,
	IN  DWORD		dwParmNum
)
{
DWORD	dwRetCode;

    if ( dwParmNum == 0 )
	return( ERROR_INVALID_PARAMETER );

    if ( !IsAfpDirInfoValid( dwParmNum, (PAFP_DIRECTORY_INFO)pbBuffer ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrDirectorySetInfo(hAfpServer,
					      (PAFP_DIRECTORY_INFO)pbBuffer,
					      dwParmNum );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminServerGetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrServerGetInfo
//
// Description: This is the DLL entrypoint for AfpAdminServerGetInfo
//
DWORD
AfpAdminServerGetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	        *ppbBuffer
)
{
DWORD	dwRetCode;

    // Make sure that all pointers passed in are valid
    //
    try {
    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode = AfpAdminrServerGetInfo( hAfpServer,
					    (PAFP_SERVER_INFO*)ppbBuffer);

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminServerSetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrServerSetInfo
//
// Description: This is the DLL entrypoint for AfpAdminServerSetInfo
//
DWORD
AfpAdminServerSetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  LPBYTE  	        pbBuffer,
	IN  DWORD		dwParmNum
)
{
DWORD	dwRetCode;

    if ( dwParmNum == 0 )
	return( ERROR_INVALID_PARAMETER );

    if ( !IsAfpServerInfoValid( dwParmNum, (PAFP_SERVER_INFO)pbBuffer ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode = AfpAdminrServerSetInfo( hAfpServer,
					    (PAFP_SERVER_INFO)pbBuffer,
					    dwParmNum );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminSessionEnum
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrSessionEnum
//
// Description: This is the DLL entry point for AfpAdminSessionEnum.
//
DWORD
AfpAdminSessionEnum(
	IN  AFP_SERVER_HANDLE 	hAfpServer,
	OUT LPBYTE  	      	*ppbBuffer,
	IN  DWORD		dwPrefMaxLen,
	OUT LPDWORD	   	lpdwEntriesRead,
	OUT LPDWORD 	   	lpdwTotalEntries,
	IN  LPDWORD 	   	lpdwResumeHandle
)
{
DWORD			 dwRetCode;
SESSION_INFO_CONTAINER   InfoStruct;

    // Touch all pointers
    //
    try {
	
	*ppbBuffer 	  = NULL;
	*lpdwEntriesRead  = 0;
	*lpdwTotalEntries = 0;

	if ( lpdwResumeHandle )
	    *lpdwResumeHandle;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    InfoStruct.dwEntriesRead = 0;
    InfoStruct.pBuffer       = NULL;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrSessionEnum( hAfpServer,
					  &InfoStruct,
					  dwPrefMaxLen,
					  lpdwTotalEntries,
					  lpdwResumeHandle );

	if ( InfoStruct.pBuffer != NULL ) {
    	    *ppbBuffer 	     = (LPBYTE)(InfoStruct.pBuffer);
	    *lpdwEntriesRead = InfoStruct.dwEntriesRead;
	}
	else
	    *lpdwEntriesRead = 0;

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminSessionClose
//
// Returns:	NO_ERROR	- success
//		non-zero return codes from AfpAdminrSessionClose
//
// Description: This is the DLL entrypoint for AfpAdminSessionClose
//
DWORD
AfpAdminSessionClose(
	IN  AFP_SERVER_HANDLE 	hAfpServer,
	IN  DWORD		dwSessionId
)
{
DWORD	dwRetCode;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrSessionClose( hAfpServer, dwSessionId );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminConnectionEnum
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrConnectionEnum
//
// Description: This is the DLL entry point for AfpAdminConnectionEnum.
//
DWORD
AfpAdminConnectionEnum(
	IN  AFP_SERVER_HANDLE 	hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer,
	IN  DWORD		dwFilter,
	IN  DWORD		dwId,
	IN  DWORD		dwPrefMaxLen,
	OUT LPDWORD	   	lpdwEntriesRead,
	OUT LPDWORD 	   	lpdwTotalEntries,
	IN  LPDWORD 	   	lpdwResumeHandle
)
{
DWORD		      dwRetCode;
CONN_INFO_CONTAINER   InfoStruct;

    switch( dwFilter ){

    case AFP_FILTER_ON_VOLUME_ID:
    case AFP_FILTER_ON_SESSION_ID:
	
	if ( dwId == 0 )
	    return( ERROR_INVALID_PARAMETER );
	
	break;

    case AFP_NO_FILTER:
	break;

    default:
	return( ERROR_INVALID_PARAMETER );
	
    }

    // Touch all pointers
    //
    try {
	
	*ppbBuffer 	  = NULL;
	*lpdwEntriesRead  = 0;
	*lpdwTotalEntries = 0;


	if ( lpdwResumeHandle )
	    *lpdwResumeHandle;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    InfoStruct.dwEntriesRead = 0;
    InfoStruct.pBuffer       = NULL;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrConnectionEnum( hAfpServer,
					     &InfoStruct,
					     dwFilter,		
					     dwId,
					     dwPrefMaxLen,
					     lpdwTotalEntries,
					     lpdwResumeHandle );

	if ( InfoStruct.pBuffer != NULL ) {
    	    *ppbBuffer       = (LPBYTE)(InfoStruct.pBuffer);
	    *lpdwEntriesRead = InfoStruct.dwEntriesRead;
	}
	else
	    *lpdwEntriesRead = 0;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminConnectionClose
//
// Returns:	NO_ERROR	- success
//		non-zero return codes from AfpAdminrConnectionClose
//
// Description: This is the DLL entrypoint for AfpAdminConnectionClose
//
DWORD
AfpAdminConnectionClose(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  DWORD		dwConnectionId
)
{
DWORD	dwRetCode;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrConnectionClose( hAfpServer, dwConnectionId );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminFileEnum
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrFileEnum
//
// Description: This is the DLL entry point for AfpAdminFileEnum.
//
DWORD
AfpAdminFileEnum(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer,
	IN  DWORD		dwPrefMaxLen,
	OUT LPDWORD	   	lpdwEntriesRead,
	OUT LPDWORD 	   	lpdwTotalEntries,
	IN  LPDWORD 	   	lpdwResumeHandle
)
{
DWORD		      dwRetCode;
FILE_INFO_CONTAINER   InfoStruct;

    // Touch all pointers
    //
    try {
	
	*ppbBuffer 	  = NULL;
	*lpdwEntriesRead  = 0;
	*lpdwTotalEntries = 0;

	if ( lpdwResumeHandle )
	    *lpdwResumeHandle;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    InfoStruct.dwEntriesRead = 0;
    InfoStruct.pBuffer       = NULL;


    RpcTryExcept{
	
	dwRetCode = AfpAdminrFileEnum(   hAfpServer,
					 &InfoStruct,
					 dwPrefMaxLen,
					 lpdwTotalEntries,
					 lpdwResumeHandle );

	if ( InfoStruct.pBuffer != NULL ) {
    	    *ppbBuffer       = (LPBYTE)(InfoStruct.pBuffer);
	    *lpdwEntriesRead = InfoStruct.dwEntriesRead;
	}
	else
	    *lpdwEntriesRead = 0;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminFileClose
//
// Returns:	NO_ERROR	- success
//		non-zero return codes from AfpAdminrFileClose
//
// Description: This is the DLL entrypoint for AfpAdminFileClose
//
DWORD
AfpAdminFileClose(
	IN  AFP_SERVER_HANDLE    hAfpServer,
	IN  DWORD		 dwFileId
)
{
DWORD	dwRetCode;

    RpcTryExcept{
	
	dwRetCode = AfpAdminrFileClose( hAfpServer, dwFileId );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminETCMapGetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrETCMapGetInfo
//
// Description: This is the DLL entry point for AfpAdminETCMapGetInfo.
//
DWORD
AfpAdminETCMapGetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer
)
{
DWORD	dwRetCode;

    try {

    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode = AfpAdminrETCMapGetInfo( hAfpServer,
					    (PAFP_ETCMAP_INFO*)ppbBuffer
					  );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminETCMapAdd
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrETCMapAdd
//
// Description: This is the DLL entrypoint for AfpAdminETCMapAdd
//
DWORD
AfpAdminETCMapAdd(
	IN  AFP_SERVER_HANDLE   hAfpServer,
      	IN  PAFP_TYPE_CREATOR   pAfpTypeCreator
)
{
DWORD	dwRetCode;

    if ( !IsAfpTypeCreatorValid( pAfpTypeCreator ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrETCMapAdd( hAfpServer, pAfpTypeCreator );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminETCMapDelete
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrETCMapDelete
//
// Description: This is the DLL entrypoint for AfpAdminETCMapDelete
//
DWORD
AfpAdminETCMapDelete(
	IN  AFP_SERVER_HANDLE   hAfpServer,
      	IN  PAFP_TYPE_CREATOR   pAfpTypeCreator
)
{
DWORD	dwRetCode;

    if ( !IsAfpTypeCreatorValid( pAfpTypeCreator ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrETCMapDelete( hAfpServer, pAfpTypeCreator );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );

}

//**
//
// Call:	AfpAdminrETCMapSetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrETCMapSetInfo
//
// Description: This is the DLL entrypoint for AfpAdminETCMapSetInfo
//
DWORD
AfpAdminETCMapSetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
      	IN  PAFP_TYPE_CREATOR   pAfpTypeCreator
)
{
DWORD	dwRetCode;

    if ( !IsAfpTypeCreatorValid( pAfpTypeCreator ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrETCMapSetInfo( hAfpServer, pAfpTypeCreator );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminETCMapAssociate
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrETCMapAssociate
//
// Description: This is the DLL entrypoint for AfpAdminETCMapAssociate
//
DWORD
AfpAdminETCMapAssociate(
	IN  AFP_SERVER_HANDLE   hAfpServer,
      	IN  PAFP_TYPE_CREATOR   pAfpTypeCreator,
      	IN  PAFP_EXTENSION      pAfpExtension
)
{
DWORD	dwRetCode;

    if ( !IsAfpTypeCreatorValid( pAfpTypeCreator ) )
	return( ERROR_INVALID_PARAMETER );

    if ( !IsAfpExtensionValid( pAfpExtension ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrETCMapAssociate(  hAfpServer,
						pAfpTypeCreator,
						pAfpExtension
				 	     );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminStatisticsGet
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrStatisticsGet
//
// Description: This is the DLL entrypoint for AfpAdminStatisticsGet
//
DWORD
AfpAdminStatisticsGet(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer
)
{
DWORD	dwRetCode;

    try {

    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrStatisticsGet( hAfpServer,
					     (PAFP_STATISTICS_INFO*)ppbBuffer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminStatisticsGetEx
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrStatisticsGetEx
//
// Description: This is the DLL entrypoint for AfpAdminStatisticsGetEx
//
DWORD
AfpAdminStatisticsGetEx(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer
)
{
DWORD	dwRetCode;

    try {

    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrStatisticsGetEx( hAfpServer,
					     (PAFP_STATISTICS_INFO_EX *)ppbBuffer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminStatisticsClear
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrStatisticsClear
//
// Description: This is the DLL entrypoint for AfpAdminStatisticsClear
//
DWORD
AfpAdminStatisticsClear(
	IN  AFP_SERVER_HANDLE   hAfpServer
)
{
DWORD	dwRetCode;

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrStatisticsClear( hAfpServer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminProfileGet
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrProfileGet
//
// Description: This is the DLL entrypoint for AfpAdminProfileGet
//
DWORD
AfpAdminProfileGet(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	OUT LPBYTE  	   	*ppbBuffer
)
{
DWORD	dwRetCode;

    try {

    	*ppbBuffer = NULL;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrProfileGet( hAfpServer,
					     (PAFP_PROFILE_INFO*)ppbBuffer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminProfileClear
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrProfileClear
//
// Description: This is the DLL entrypoint for AfpAdminProfileClear
//
DWORD
AfpAdminProfileClear(
	IN  AFP_SERVER_HANDLE   hAfpServer
)
{
DWORD	dwRetCode;

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrProfileClear( hAfpServer );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminMessageSend
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrMessageSend
//
// Description: This is the DLL entrypoint for AfpAdminMessageSend
//
DWORD
AfpAdminMessageSend(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  PAFP_MESSAGE_INFO 	pAfpMessageInfo
)
{
DWORD	dwRetCode;


    try {

    	*pAfpMessageInfo;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	return( ERROR_INVALID_PARAMETER );
    }

    if ( !IsAfpMsgValid( pAfpMessageInfo->afpmsg_text ) )
	return( ERROR_INVALID_PARAMETER );

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrMessageSend( hAfpServer, 	
					   pAfpMessageInfo );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminFinderSetInfo
//
// Returns:	NO_ERROR	- success
//		ERROR_INVALID_PARAMETER
//		non-zero return codes from AfpAdminrFinderSetInfo
//
// Description: This is the DLL entrypoint for AfpAdminFinderSetInfo
//
DWORD
AfpAdminFinderSetInfo(
	IN  AFP_SERVER_HANDLE   hAfpServer,
	IN  LPWSTR	 	pType,
	IN  LPWSTR	 	pCreator,
	IN  LPWSTR	 	pData,
	IN  LPWSTR	 	pResource,
	IN  LPWSTR	 	pTarget,
 	IN  DWORD		dwParmNum
)
{
DWORD	dwRetCode;

    if ( !IsAfpFinderInfoValid( pType, 
				pCreator, 
				pData, 
				pResource, 
				pTarget, 
				dwParmNum ) )
	return( ERROR_INVALID_PARAMETER );

    if ( pType == NULL )
	pType = (LPWSTR)TEXT("");

    if ( pCreator == NULL )
	pCreator = (LPWSTR)TEXT("");

    if ( pData == NULL )
	pData = (LPWSTR)TEXT("");

    if ( pResource == NULL )
	pResource = (LPWSTR)TEXT("");

    RpcTryExcept{
	
	dwRetCode =  AfpAdminrFinderSetInfo( hAfpServer, 
					     pType, 
					     pCreator, 
					     pData,
					     pResource,
					     pTarget,
					     dwParmNum );

    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {
	dwRetCode = RpcExceptionCode();
    }
    RpcEndExcept

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\client\client.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:
//
// Description: 
//
// History:
//	May 11,1992.	NarenG		Created original version.
//
#ifndef _CLIENT_
#define _CLIENT_

#include <nt.h>
#include <ntrtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <nturtl.h>     // needed for winbase.h

#include <windows.h>
#include <rpc.h>
#include <string.h>
#include <afpsvc.h>
#include <afpcomn.h>
#include <admin.h>
#include <macfile.h>
#include <rpcasync.h>



DWORD
AfpRPCBind( 
	IN  LPWSTR 	       lpwsServerName, 
	OUT PAFP_SERVER_HANDLE phAfpServer 
);

#endif  // _CLIENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\client\rpcbind.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	rpcbind.c
//
// Description: Contains the RPC bind and un-bind routines for the AFP
//    		Admin. client-side APIs.
//
// History:
//	June 11,1992.	NarenG		Created original version.
//
#include "client.h"

//**
//
// Call:	AFPSVC_HANDLE_bind
//
// Returns: 	The binding handle is returned to the stub routine.  If the
//	    	binding is unsuccessful, a NULL will be returned.
//
// Description: This routine will simply return what was passed to it. The
//		RPC runtime will pass it a handle of the binding that was
//		obtained by calling AfpRpcBind.
//
handle_t
AFPSVC_HANDLE_bind( 
	IN AFPSVC_HANDLE hServer 
) 
{
    return( (handle_t)hServer );
}

//**
//
// Call:	AFPSVC_HANDLE_unbind
//
// Returns:	none
//
// Description: Unbinds from the RPC interface.
//
void
AFPSVC_HANDLE_unbind( 
	IN AFPSVC_HANDLE   hServer,
    	IN handle_t        hBinding
)
{

    AFP_UNREFERENCED( hServer );
    AFP_UNREFERENCED( hBinding );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\idl\import.h ===
/********************************************************************/
/**               Copyright(c) 1991 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename: 	import.h
//
// Description: This file allows us to include standard system header files 
//		in the .idl file.  The main .idl file imports a file called 
//		import.idl. This allows the .idl file to use the types defined 
//		in these header files. It also causes the following line to 
//		be added in the MIDL generated header file:
//
//    		#include "import.h"
//
//   		Thus these types are available to the RPC stub routines as well.
//
// History:
//	June 11,1992.	NarenG		Created original version.
//


#include <windef.h>

#ifdef MIDL_PASS
#define LPWSTR      [string] wchar_t*
#define BOOL        DWORD
#endif

#include <macfile.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\client\rpcutil.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	rpcutil.c
//
// Description: Contains RPC utiliry routines.
//
// History:
//	May 11,1992.	NarenG		Created original version.
//
#include "client.h"


//**
//
// Call:	AfpRPCBind
//
// Returns:	NO_ERROR			- success
//		ERROR_NOT_ENOUGH_MEMORY
//	        AFPERR_InvalidComputername 
//		non-sero returns from RPC calls.
//
// Description: This routine is called when it is necessary to bind to a server.
//    		The binding is done to allow impersonation by the server since 
//		that is necessary for the API calls.
//
DWORD
AfpRPCBind( 
	IN  LPWSTR 		lpwsServerName, 
	OUT PAFP_SERVER_HANDLE  phAfpServer 
)
{
RPC_STATUS  RpcStatus;
LPWSTR      lpwsStringBinding;
LPWSTR      lpwsEndpoint;

    // We need to concatenate \pipe\ to the front of the service
    // name.
    //
    lpwsEndpoint = (LPWSTR)LocalAlloc( 0, sizeof(NT_PIPE_PREFIX) +  
				((STRLEN(AFP_SERVICE_NAME)+1)*sizeof(WCHAR)));
    if ( lpwsEndpoint == NULL) 
       return( ERROR_NOT_ENOUGH_MEMORY );

    STRCPY( lpwsEndpoint, NT_PIPE_PREFIX );
    STRCAT( lpwsEndpoint, AFP_SERVICE_NAME );

    RpcStatus = RpcStringBindingCompose( 
				NULL, 
				TEXT("ncacn_np"), 
				lpwsServerName,
                    		lpwsEndpoint, 
			 	TEXT("Security=Impersonation Static True"),
				&lpwsStringBinding);
    LocalFree( lpwsEndpoint );

    if ( RpcStatus != RPC_S_OK ) 
       return( I_RpcMapWin32Status( RpcStatus ) );

    RpcStatus = RpcBindingFromStringBinding( lpwsStringBinding, 
					     (handle_t *)phAfpServer );

    RpcStringFree( &lpwsStringBinding );

    if ( RpcStatus != RPC_S_OK ) {
	
	if ( ( RpcStatus == RPC_S_INVALID_ENDPOINT_FORMAT ) 
	     ||
	     ( RpcStatus == RPC_S_INVALID_NET_ADDR ) ) 

	    return( (DWORD)AFPERR_InvalidComputername );
	else
       	    return( I_RpcMapWin32Status( RpcStatus ) );
	
    }
	
    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\afpsvc_s_stub.c ===
#include "afpsvc_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\afpsvcp.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename: 	afpsvcp.h
//
// Description: This is the main header file for the AFP Server Service.
//
// History:
//		May 11,1992.	NarenG		Created original version.
//
#ifndef _AFPSVCP_
#define _AFPSVCP_

#include <nt.h>
#include <ntrtl.h>
#include <ntseapi.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <nturtl.h>     // needed for winbase.h
#include <ntmsv1_0.h>
#include <samrpc.h>
#include <align.h>

#include <windows.h>	// Win32 base API's
#include <winuser.h>	// Needed for LoadString
#include <winsvc.h>	// Win32 service control stuff
#include <winreg.h>	// Win32 registry API's
#include <lm.h>
#include <srvann.h>
#include <rpc.h>	// RPC api's
#include <devioctl.h>	// FILE_DEVICE_NETWORK, METHOD_BUFFERD constants
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <wchar.h>
#include <search.h>

#if DBG
#define DEBUG	TRUE
#endif

#include <afpsvc.h>	// Generated by MIDL
#include <admin.h>
#include <macfile.h>
#include <afpcomn.h>
#include "events.h"
#include "ioctl.h"
#include "rasfmsub.h"
#include "debug.h"


#define LOGON_PROCESS_NAME  "SFM_SERVICE"

#define AFPSTATE_RPC_STARTED		0x1
#define AFPSTATE_FSD_LOADED		    0x2
#define AFPSTATE_BLOCKED_ON_DOMINFO 0x4

// Id's of the various data structures
//
typedef enum _AFP_STRUCTURE_TYPE {

    AFP_EXTENSION_STRUCT,
    AFP_TYPECREATOR_STRUCT,
    AFP_ICON_STRUCT,
    AFP_VOLUME_STRUCT,
    AFP_SERVER_STRUCT,
    AFP_DIRECTORY_STRUCT,
    AFP_SESSION_STRUCT,
    AFP_CONNECTION_STRUCT,
    AFP_MESSAGE_STRUCT,
    AFP_FILE_STRUCT,
    AFP_FINDER_STRUCT

} AFP_STRUCTURE_TYPE;

// The approximate times (in milliseconds) taken to respond to various
// service control requests.
//
#define AFP_SERVICE_INSTALL_TIME	15*60000	// 15 minutes
#define AFP_SERVICE_STOP_TIME		5*60000		// 5 minutes
#define AFP_SERVICE_CONTINUE_TIME	5000
#define AFP_SERVICE_PAUSE_TIME		1000

// Macro to calculate the byte offset of a field in a structure of type type.
//
#define AFP_FIELD_OFFSET(type, field)    ((LONG)((LONG_PTR)&(((type *)0)->field)))

// Macro to calculate the size of a given field within a structure.
//
#define AFP_FIELD_SIZE(type, field)    sizeof(((type *)0)->field)


// Access mask values
//
#define 	AFPSVC_ALL_ACCESS	0x0001

// All global variables are packaged within this structure.
//
typedef struct _AFP_GLOBALS {

    // Handle to the key that contains the server parameters
    //
    HKEY 		hkeyServerParams;

    // Handle to the key that contains the volumes list.
    //
    HKEY 		hkeyVolumesList;

    // Handle to the key that contains the list of Type/Creator/Comment tupples
    //
    HKEY 		hkeyTypeCreators;

    // Handle to the key that contains the list mapped extensions.
    //
    HKEY 		hkeyExtensions;

    // Handle to the key that contains the icon list.
    //
    HKEY 		hkeyIcons;

    // Service parameters
    //
    WCHAR		wchServerName[AFP_SERVERNAME_LEN+1];
    DWORD		dwServerOptions;
    DWORD		dwMaxSessions;
    WCHAR		wchLoginMsg[AFP_MESSAGE_LEN+1];
    DWORD		dwMaxPagedMem;
    DWORD		dwMaxNonPagedMem;
    WCHAR		wchCodePagePath[MAX_PATH];

    // Localizable strings
    //
    WCHAR		wchInvalid[100];
    WCHAR		wchDeleted[100];
    WCHAR		wchUnknown[100];
    WCHAR		wchDefTCComment[AFP_ETC_COMMENT_LEN+1];

    // Contains information about what components were initialized
    // successfully
    //
    DWORD		dwServerState;

    // Handle to the AFP Server FSD
    //
    HANDLE 		hFSD;

    // Handle used to announce the service status
    //
    SERVICE_STATUS_HANDLE hServiceStatus;

    SERVICE_STATUS	ServiceStatus;

    // This is a cache of ext/type/creator mappings
    //
    AFP_ETCMAP_INFO	AfpETCMapInfo;

    // Will contain the Id of the next type/creator that will be added to the
    // registry via the AfpAdminAddETCMap API.
    //
    DWORD		dwCurrentTCId;

    // Mutex handle for mutual exclusion around volume SetInfo/ Add/ Delete
    // ETC mappings registry and cache operations.
    //
    HANDLE		hmutexETCMap;

    // Mutex handle for mutual exclusion around volume SetInfo/ Add/ Delete
    // volume registry operations.
    //
    HANDLE		hmutexVolume;

    // This will be used by the server helper thread to inicate its
    // success or failure while initializing itself. The parent thread
    // can then take appropriate action.
    //
    HANDLE		heventSrvrHlprThread;

	// This is used by the server helper thread(s) to indicate that they have terminated
    //
	HANDLE		heventSrvrHlprThreadTerminate;

    // This is used in special case: if we have to terminate the helper thread when
    // it's blocked trying to get domain info
	HANDLE		heventSrvrHlprSpecial;

	DWORD		nThreadCount;

    DWORD		dwSrvrHlprCode;

	DWORD		dwSrvrHlprCount;

	NT_PRODUCT_TYPE	NtProductType;
	PSID		pSidNone;

} AFP_GLOBALS, *PAFP_GLOBALS;

#ifdef DEFINE_AFP_GLOBALS
AFP_GLOBALS		AfpGlobals;
HANDLE          SfmLsaHandle;
DWORD           SfmAuthPkgId;
#else
extern AFP_GLOBALS	AfpGlobals;
extern HANDLE       SfmLsaHandle;
extern DWORD        SfmAuthPkgId;
#endif

// prototypes of functions used across modules
//
VOID
AfpAnnounceServiceStatus(
	VOID
);

DWORD
AfpInitialize(
	VOID
);

VOID
AfpTerminate(
	VOID
);

DWORD
AfpRegGetKeyInfo(
	IN  HKEY    hKey,
	OUT LPDWORD lpdwMaxValNameLen,   // Longest valuename in this key
	OUT LPDWORD lpdwNumValues,	 // Number of values in this key
	OUT LPDWORD lpdwMaxValueDataSize // Max. size of value data.
);

DWORD
AfpRegOpen(
	VOID
);

VOID
AfpRegClose(
	VOID
);

DWORD
AfpRegVolumeAdd(
	IN PAFP_VOLUME_INFO  	pVolumeInfo
);

DWORD
AfpRegVolumeDelete(
	IN LPWSTR 		lpwsVolumeName
);

DWORD
AfpRegVolumeSetInfo(
	IN PAFP_VOLUME_INFO    	pVolumeInfo
);

DWORD
AfpRegExtensionEnum(
	VOID
);

DWORD
AfpRegTypeCreatorEnum(
	VOID
);

DWORD
AfpRegExtensionAdd(
	IN PAFP_EXTENSION	pAfpExtension
);

DWORD
AfpRegExtensionSetInfo(
	IN PAFP_EXTENSION	pAfpExtension
);

DWORD
AfpRegExtensionDelete(
	IN PAFP_EXTENSION	pAfpExtension
);

DWORD
AfpRegTypeCreatorSetInfo(
	IN PAFP_TYPE_CREATOR    pAfpTypeCreator
);

DWORD
AfpRegTypeCreatorAdd(
	IN PAFP_TYPE_CREATOR   	pAfpTypeCreator
);

DWORD
AfpRegTypeCreatorDelete(
	IN PAFP_TYPE_CREATOR 	pAfpTypeCreator
);

DWORD
AfpRegServerGetInfo(
	VOID
);

DWORD
AfpRegServerSetInfo(
	IN PAFP_SERVER_INFO 	pServerInfo,
	IN DWORD 		dwParmnum
);

DWORD
AfpRegServerGetCodePagePath(
	VOID
);

DWORD
AfpSecObjCreate(
	VOID
);

DWORD
AfpSecObjDelete(
	VOID
);

DWORD
AfpSecObjAccessCheck(
	IN  DWORD 		DesiredAccess,
	OUT LPDWORD 		pfAccessStatus 		
);

DWORD
AfpBufMakeFSDRequest(
	IN  LPBYTE  		pBuffer,
	IN  DWORD	        cbReqPktSize,	
	IN  AFP_STRUCTURE_TYPE	dwStructureId,	
	OUT LPBYTE 		*ppSelfRelativeBuf,	
	OUT LPDWORD		lpdwSelfRelativeBufSize
);

DWORD
AfpBufMakeFSDETCMappings(
	OUT PSRVETCPKT		*ppSrvSetEtc,
	OUT LPDWORD		lpdwSrvSetEtcBufSize
);

VOID
AfpBufOffsetToPointer(
	IN OUT LPBYTE		  pBuffer,
	IN     DWORD		  dwNumEntries,
	IN     AFP_STRUCTURE_TYPE dwStructureType
);

VOID
AfpBufCopyFSDETCMapInfo(
	IN  PAFP_TYPE_CREATOR 	pAfpTypeCreator,
	IN  PAFP_EXTENSION	pAfpExtension,
	OUT PETCMAPINFO2        pFSDETCMapInfo
);

VOID
AfpBufMakeFSDIcon(
	IN  PAFP_ICON_INFO 	pIconInfo,
	OUT LPBYTE	  	lpbFSDIcon,
	OUT LPDWORD	  	lpcbFSDIconSize
);

DWORD
AfpBufMakeMultiSz(
	IN  AFP_STRUCTURE_TYPE	dwStructureId,	
	IN  LPBYTE		pbStructure,
	OUT LPBYTE*		ppbMultiSz,
	OUT LPDWORD		lpdwMultiSzSize
);

DWORD
AfpBufParseMultiSz(
	IN  AFP_STRUCTURE_TYPE	dwStructureId,	
	IN  LPBYTE		pbMultiSz,
	OUT LPBYTE		pbStructure
);

DWORD
AfpBufStructureSize(
	IN  AFP_STRUCTURE_TYPE	dwStructureId,	
	IN LPBYTE		lpbStructure
);

DWORD
AfpBufUnicodeToNibble(
	IN OUT LPWSTR		lpwsData
);

void *
AfpBinarySearch(
	IN const void * pKey,
	IN const void * pBase,
	IN size_t num,
	IN size_t width,
	IN int (_cdecl *compare)(const void * pElem1, const void * pElem2 )
);

int
_cdecl
AfpBCompareTypeCreator(
	IN const void * pAfpTypeCreator1,
	IN const void * pAfpTypeCreatro2
);

int
_cdecl
AfpLCompareTypeCreator(
	IN const void * pAfpTypeCreator1,
	IN const void * pAfpTypeCreatro2
);

int
_cdecl
AfpBCompareExtension(
	IN const void * pAfpExtension1,
	IN const void * pAfpExtension2
);

int
_cdecl
AfpLCompareExtension(
	IN const void * pAfpExtension1,
	IN const void * pAfpExtension2
);


DWORD
AfpFSDOpen(
	OUT PHANDLE pFSD
);

DWORD
AfpFSDClose(
	IN HANDLE hFSD
);

DWORD
AfpFSDUnload(
	VOID
);

DWORD
AfpFSDLoad(
	VOID
);

DWORD
AfpFSDIOControl(
	IN  HANDLE	hFSD,
	IN  DWORD 	dwOpCode,
	IN  PVOID	pInbuf 		OPTIONAL,
	IN  DWORD	cbInbufLen,
	OUT PVOID	pOutbuf 	OPTIONAL,
	IN  DWORD	cbOutbuflen,
	OUT LPDWORD	cbBytesTransferred
);

DWORD
AfpCreateServerHelperThread(
	BOOL fIsFirstThread
);

VOID
AfpTerminateCurrentThread(
	VOID
);

DWORD
AfpInitServerHelper(
	VOID
);

DWORD
AfpServerHelper(
	IN LPVOID Parameter
);

VOID
AfpLogEvent(
    	IN DWORD    dwMessageId,
    	IN WORD     cNumberOfSubStrings,
        IN LPWSTR*  plpwsSubStrings,
     	IN DWORD    dwErrorCode,
     	IN WORD     wSeverity
);

VOID
AfpLogServerEvent(
	IN	PAFP_FSD_CMD_PKT	pAfpFsdCmd
);

VOID
AfpAddInvalidVolume(
	IN LPWSTR	lpwsName,
	IN LPWSTR	lpwsPath
);

VOID
AfpDeleteInvalidVolume(
	IN LPWSTR	lpwsVolumeName
);

DWORD
I_DirectorySetInfo(
	IN PAFP_DIRECTORY_INFO 	pAfpDirectoryInfo,
	IN DWORD	 	dwParmNum
);

DWORD
I_DirectoryGetInfo(
	IN LPWSTR 		  lpwsPath,
	OUT PAFP_DIRECTORY_INFO * ppAfpDirectoryInfo
);

#endif // _AFPSVCP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\idl\afpcomn.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	afpcomn.h
//
// Description: This file contains definitions common to the client
//		and server compoents.
// History:
//	June 11,1992.	NarenG		Created original version.
//
#ifndef _AFPCOMN_
#define _AFPCOMN_

#define AFP_UNREFERENCED( x )		( x )		

#define NT_PIPE_PREFIX      		TEXT("\\PIPE\\")

// All string functions are multibyte
//
#define STRCPY				wcscpy
#define STRLEN				wcslen	
#define STRCAT				wcscat	
#define STRCMP				wcscmp	
#define STRICMP				_wcsicmp	
#define STRNICMP			_wcsnicmp	
#define STRUPR				_wcsupr	
#define STRNCPY				wcsncpy	

#define AFP_VALIDATE_ALL_FIELDS		0

//
//	Prototypes of validation functions.
//
BOOL
IsAfpServerInfoValid(
        IN DWORD		dwParmNum,
	IN PAFP_SERVER_INFO	pAfpServerInfo
);

BOOL
IsAfpServerNameValid(
	IN LPVOID
);

BOOL
IsAfpServerOptionsValid(
	IN LPVOID
);

BOOL
IsAfpMaxSessionsValid(
	IN LPVOID
);

BOOL
IsAfpMsgValid(
	IN LPVOID
);

BOOL
IsAfpCodePageValid(
	IN LPVOID pCodePagePath
);

BOOL
IsAfpTypeCreatorValid(
	IN PAFP_TYPE_CREATOR	pAfpTypeCreator
);

BOOL
IsAfpExtensionValid(
	IN PAFP_EXTENSION pAfpExtension
);

BOOL
IsAfpMaxPagedMemValid(
	IN LPVOID pMaxPagedMem
);

BOOL
IsAfpMaxNonPagedMemValid(
	IN LPVOID pMaxNonPagedMem
);

BOOL
IsAfpNumThreadsValid(
	IN LPVOID pNumThreads
);

BOOL
IsAfpVolumeInfoValid(
	IN DWORD		dwParmNum,
        IN PAFP_VOLUME_INFO     pAfpVolume
);

BOOL
IsAfpVolumeNameValid(
	IN LPWSTR 	lpwsVolumeName
);

BOOL
IsAfpDirInfoValid(
	IN DWORD		dwParmNum,
	IN PAFP_DIRECTORY_INFO  pAfpDirInfo
);

BOOL
IsAfpIconValid(
	IN PAFP_ICON_INFO	pAfpIconInfo
);

BOOL
IsAfpFinderInfoValid(
	IN LPWSTR		pType,
	IN LPWSTR		pCreator,
	IN LPWSTR		pData,
	IN LPWSTR		pResource,
	IN LPWSTR		pPath,
	IN DWORD		dwParmNum
);

#endif // _AFPCOMN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\buffer.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	buffer.c
//
// Description: This module contains routines to manipulate cached
//		information. ie volume info, server properties and
//		ETC mappings info.
//
// History:
//		May 11,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

// This should be more than the size (in bytes) all the value names
// each AfpMultSzInfo structure. It will be used to calculate the amount
// of memory needed to create a multi-sz.
//
#define AFP_CUMULATIVE_VALNAME_SIZE	150

// This data structure will be used by AfpBufParseMultiSz and
// AfpBufMakeMultiSz.
//
typedef struct _AfpMultiSzInfo {

    DWORD	dwType;			// Type of data, string or DWORD
    DWORD	dwOffset;		// Offset of this field from the start
    LPWSTR	lpwsValueName;		// Value name for this field.
					// If this is NULL then it does not
					// have a value name. It is the
					// value name for this MULT_SZ.
    DWORD	fIsInPlace;		// If string, is it a pointer or a
					// buffer.
    DWORD	cch;			// If fIsInPlace is TRUE, then how
					// big (in UNICODE chars.) is the
					// buffer.

} AFP_MULTISZ_INFO, *PAFP_MULTISZ_INFO;

static AFP_MULTISZ_INFO AfpVolumeMultiSz[] = {

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_name ),
	NULL,
	FALSE,
	0,

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_password ),
	AFPREG_VALNAME_PASSWORD,
	FALSE,
	0,

	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_max_uses ),
	AFPREG_VALNAME_MAXUSES,
	FALSE,
	0,
	
	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_props_mask ),
	AFPREG_VALNAME_PROPS,
	FALSE,
	0,

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_path ),
	AFPREG_VALNAME_PATH,
	FALSE,
	0,

	REG_NONE, 0, 0, 0, 0
	};

static AFP_MULTISZ_INFO AfpExtensionMultiSz[] = {

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_EXTENSION, afpe_extension[0] ),
	NULL,
	TRUE,
	AFP_FIELD_SIZE( AFP_EXTENSION, afpe_extension ),

	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_EXTENSION, afpe_tcid ),
	AFPREG_VALNAME_ID,
	FALSE,
	0,

	REG_NONE, 0, 0, 0, 0
	};


static AFP_MULTISZ_INFO AfpTypeCreatorMultiSz[] = {

	REG_SZ,
	AFP_FIELD_OFFSET(AFP_TYPE_CREATOR, afptc_creator[0] ),
	AFPREG_VALNAME_CREATOR,
	TRUE,
	AFP_FIELD_SIZE(AFP_TYPE_CREATOR, afptc_creator ),

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_TYPE_CREATOR, afptc_type[0] ),
	AFPREG_VALNAME_TYPE,
	TRUE,
	AFP_FIELD_SIZE( AFP_TYPE_CREATOR, afptc_type ),

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_TYPE_CREATOR, afptc_comment[0] ),
	AFPREG_VALNAME_COMMENT,
	TRUE,
	AFP_FIELD_SIZE( AFP_TYPE_CREATOR, afptc_comment ),

	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_TYPE_CREATOR, afptc_id ),
	NULL,
	FALSE,
	0,

	REG_NONE, 0, 0, 0, 0
	};

static AFP_MULTISZ_INFO AfpIconMultiSz[] = {

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_ICON_INFO, afpicon_type[0] ),
	AFPREG_VALNAME_TYPE,
	TRUE,
	AFP_FIELD_SIZE( AFP_ICON_INFO, afpicon_type ),

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_ICON_INFO, afpicon_creator[0] ),
	AFPREG_VALNAME_CREATOR,
	TRUE,
	AFP_FIELD_SIZE( AFP_ICON_INFO, afpicon_creator ),

	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_ICON_INFO, afpicon_icontype ),
	AFPREG_VALNAME_ICONTYPE,
	FALSE,
	0,

	REG_DWORD,
	AFP_FIELD_OFFSET( AFP_ICON_INFO, afpicon_length ),
	AFPREG_VALNAME_LENGTH,
	FALSE,
	0,

	REG_SZ,
	AFP_FIELD_OFFSET( AFP_ICON_INFO, afpicon_data ),
	AFPREG_VALNAME_DATA,
	FALSE,
	0,

	REG_NONE, 0, 0, 0, 0
	};

// These arrays represents the byte offsets, from the beginning of the
// structure, of the LPWSTR fields.
//
static BYTE ServerOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_SERVER_INFO, afpsrv_name ),
	AFP_FIELD_OFFSET( AFP_SERVER_INFO, afpsrv_login_msg ),
	AFP_FIELD_OFFSET( AFP_SERVER_INFO, afpsrv_codepage ),
	0xFF
	};

static BYTE VolumeOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_name ),
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_password ),
	AFP_FIELD_OFFSET( AFP_VOLUME_INFO, afpvol_path ),
	0xFF
	};

static BYTE DirOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_DIRECTORY_INFO, afpdir_path ),
	AFP_FIELD_OFFSET( AFP_DIRECTORY_INFO, afpdir_owner ),
	AFP_FIELD_OFFSET( AFP_DIRECTORY_INFO, afpdir_group ),
	0xFF
	};

static BYTE SessionOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_SESSION_INFO, afpsess_ws_name ),
	AFP_FIELD_OFFSET( AFP_SESSION_INFO, afpsess_username ),
	0xFF
	};

static BYTE FileOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_FILE_INFO, afpfile_path ),
	AFP_FIELD_OFFSET( AFP_FILE_INFO, afpfile_username ),
	0xFF
	};

static BYTE ConnectionOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_CONNECTION_INFO, afpconn_username ),
	AFP_FIELD_OFFSET( AFP_CONNECTION_INFO, afpconn_volumename ),
	0xFF
	};

static BYTE MessageOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_MESSAGE_INFO, afpmsg_text ),
	0xFF
	};

static BYTE FinderOffsetTable[] = {
	AFP_FIELD_OFFSET( AFP_FINDER_INFO, afpfd_path ),
	0xFF
	};


//**
//
// Call:	AfpBufStructureSize
//
// Returns:	The size (in bytes) of the data withing the structure.
//
// Description:	It will calculate the size of all the variable data and
//		add that to the fixed size of the structure.
//
DWORD
AfpBufStructureSize(
	IN AFP_STRUCTURE_TYPE	dwStructureType,
	IN LPBYTE		lpbStructure
)
{
DWORD	cbStructureSize;
DWORD	dwIndex;
DWORD	cbBufSize;
LPWSTR* plpwsStringField;
PBYTE	OffsetTable;

    switch( dwStructureType ) {

    case AFP_VOLUME_STRUCT:
	OffsetTable 	= VolumeOffsetTable;
	cbStructureSize = sizeof( AFP_VOLUME_INFO );
	break;

    case AFP_SERVER_STRUCT:
	OffsetTable 	= ServerOffsetTable;
	cbStructureSize = sizeof( AFP_SERVER_INFO );
	break;

    case AFP_DIRECTORY_STRUCT:
	OffsetTable 	= DirOffsetTable;
	cbStructureSize = sizeof( AFP_DIRECTORY_INFO );
	break;

    case AFP_EXTENSION_STRUCT:
	return( sizeof(AFP_EXTENSION) );
	break;

    case AFP_TYPECREATOR_STRUCT:
	return( sizeof(AFP_TYPE_CREATOR) );
	break;

    case AFP_MESSAGE_STRUCT:
	OffsetTable 	= MessageOffsetTable;
	cbStructureSize = sizeof( AFP_MESSAGE_INFO );
	break;

    case AFP_ICON_STRUCT:
	return( sizeof(AFP_ICON_INFO) +
		((PAFP_ICON_INFO)lpbStructure)->afpicon_length );
	break;

    case AFP_FINDER_STRUCT:
	OffsetTable 	= FinderOffsetTable;
	cbStructureSize = sizeof( AFP_FINDER_INFO );
	break;

    default:
	return( 0 );
    }

    // First calculate the amount of memory that will be needed to
    // store all the string information.
    //
    for( dwIndex = 0, cbBufSize = 0;

	 OffsetTable[dwIndex] != 0xFF;

	 dwIndex++

	) {
	
   	plpwsStringField=(LPWSTR*)((ULONG_PTR)lpbStructure + OffsetTable[dwIndex]);

        cbBufSize += ( ( *plpwsStringField == NULL ) ? 0 :
		         STRLEN( *plpwsStringField ) + 1 );
    }

    // Convert to UNICODE size
    //
    cbBufSize *= sizeof( WCHAR );

    // Add size of fixed part of the structure
    //
    cbBufSize += cbStructureSize;

    return( cbBufSize );

}

//**
//
// Call:	AfpBufMakeFSDRequest
//
// Returns:	NO_ERROR	
//		ERROR_NOT_ENOUGH_MEMORY	
//
// Description: This routine is called by the worker routines for the client
//		API calls. The purpose of this routine is to convert a
//		AFP_XXX_INFO structure passed by the client API into a
//		contiguous self-relative buffer. This has to be done because
//		the FSD cannot reference pointers to user space.
//
//		This routine will allocate the required amount of memory to
//		store all the information in self relative form. It is
//		the reponsibility of the caller to free this memory.
//
//		All pointer fields will be converted to offsets from the
//		beginning of the structure.
//		
//		The cbReqPktSize parameter specifies how many bytes of space
//		should be allocated before the self relative data structure.
//		i.e.
//				|------------|
//				|cbReqPktSize|
//				|   bytes    |
//				|------------|
//				|   Self     |
//				|  relative  |
//				| structure  |
//				|------------|
//
DWORD
AfpBufMakeFSDRequest(

	// Buffer as received by the client API	
	//
	IN  LPBYTE  		pBuffer,

	// Size of FSD request packet.
	//
	IN  DWORD		cbReqPktSize,

	IN  AFP_STRUCTURE_TYPE dwStructureType,

	// Self-relative form of I/P buf
	//
	OUT LPBYTE 		*ppSelfRelativeBuf,

	// Size of self relative buf
	//
	OUT LPDWORD		lpdwSelfRelativeBufSize
)
{
LPBYTE		 lpbSelfRelBuf;
DWORD		 cbSRBufSize;
DWORD		 dwIndex;
LPWSTR		 lpwsVariableData;
LPWSTR *	 plpwsStringField;
LPWSTR *	 plpwsStringFieldSR;
PBYTE		 OffsetTable;
DWORD		 cbStructureSize;


    // Initialize the offset table and the structure size values
    //
    switch( dwStructureType ) {

    case AFP_VOLUME_STRUCT:
	OffsetTable     = VolumeOffsetTable;
	cbStructureSize = sizeof( AFP_VOLUME_INFO );
	break;

    case AFP_SERVER_STRUCT:
	OffsetTable     = ServerOffsetTable;
	cbStructureSize = sizeof( AFP_SERVER_INFO );
	break;

    case AFP_DIRECTORY_STRUCT:
	OffsetTable = DirOffsetTable;
	cbStructureSize = sizeof( AFP_DIRECTORY_INFO );
	break;

    case AFP_MESSAGE_STRUCT:
	OffsetTable = MessageOffsetTable;
	cbStructureSize = sizeof( AFP_MESSAGE_INFO );
	break;

    case AFP_FINDER_STRUCT:
	OffsetTable = FinderOffsetTable;
	cbStructureSize = sizeof( AFP_FINDER_INFO );
	break;

    default:
	return( ERROR_INVALID_PARAMETER );
    }

    cbSRBufSize = cbReqPktSize + AfpBufStructureSize(dwStructureType, pBuffer);

    // Allocate space for self relative buffer
    //
    if ( ( lpbSelfRelBuf = (LPBYTE)LocalAlloc( LPTR, cbSRBufSize ) ) == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    *ppSelfRelativeBuf       = lpbSelfRelBuf;
    *lpdwSelfRelativeBufSize = cbSRBufSize;

    // Advance this pointer beyond the request packet
    //
    lpbSelfRelBuf += cbReqPktSize;

    // memcpy to fill in the non-string data
    //
    CopyMemory( lpbSelfRelBuf, pBuffer, cbStructureSize );

    // Now copy all the strings
    //
    for( dwIndex = 0,
	 lpwsVariableData = (LPWSTR)((ULONG_PTR)lpbSelfRelBuf + cbStructureSize);

	 OffsetTable[dwIndex] != 0xFF;

	 dwIndex++ ) {

	
	// This will point to a string pointer field in the non self-relative
	// structure.
	//
   	plpwsStringField = (LPWSTR*)((ULONG_PTR)pBuffer + OffsetTable[dwIndex]);

	// This will point to the corresponding string pointer field in the
	// self-relative structure
	//
   	plpwsStringFieldSR=(LPWSTR*)((ULONG_PTR)lpbSelfRelBuf+OffsetTable[dwIndex]);

	// If there is no string to be copied, then just set to NULL
  	//
    	if ( *plpwsStringField == NULL )
       	    *plpwsStringFieldSR = NULL;
	else {

	    // There is a string so copy it
	    //
            STRCPY( lpwsVariableData, *plpwsStringField );

	    // Store the pointer value
	    //
            *plpwsStringFieldSR = lpwsVariableData;

	    // Convert the pointer to this data to an offset
	    //
            POINTER_TO_OFFSET( *plpwsStringFieldSR, lpbSelfRelBuf );
	
	    // Update the pointer to where the next variable length data
	    // will be stored.
	    //
    	    lpwsVariableData += ( STRLEN( *plpwsStringField ) + 1 );

	}

    }

    return( NO_ERROR );

}

//**
//
// Call:	AfpBufOffsetToPointer
//
// Returns:	none.
//
// Description:	Will walk a list of structures, converting all offsets
//		within each structure to pointers.
//
VOID
AfpBufOffsetToPointer(
	IN OUT LPBYTE	          pBuffer,
	IN     DWORD		  dwNumEntries,
	IN     AFP_STRUCTURE_TYPE dwStructureType
)
{
PBYTE		OffsetTable;
DWORD		cbStructureSize;
LPWSTR 	       *plpwsStringField;
DWORD		dwIndex;


    // Initialize the offset table and the structure size values
    //
    switch( dwStructureType ) {

    case AFP_VOLUME_STRUCT:
	OffsetTable 	= VolumeOffsetTable;
	cbStructureSize = sizeof( AFP_VOLUME_INFO );
 	break;

    case AFP_SESSION_STRUCT:
	OffsetTable 	= SessionOffsetTable;
	cbStructureSize = sizeof( AFP_SESSION_INFO );
 	break;

    case AFP_CONNECTION_STRUCT:
	OffsetTable 	= ConnectionOffsetTable;
	cbStructureSize = sizeof( AFP_CONNECTION_INFO );
 	break;

    case AFP_FILE_STRUCT:
	OffsetTable 	= FileOffsetTable;
	cbStructureSize = sizeof( AFP_FILE_INFO );
 	break;

    case AFP_DIRECTORY_STRUCT:
	OffsetTable 	= DirOffsetTable;
	cbStructureSize = sizeof( AFP_DIRECTORY_INFO );
 	break;

    case AFP_MESSAGE_STRUCT:
	OffsetTable 	= MessageOffsetTable;
	cbStructureSize = sizeof( AFP_MESSAGE_INFO );
 	break;

    case AFP_SERVER_STRUCT:
	OffsetTable 	= ServerOffsetTable;
	cbStructureSize = sizeof( AFP_SERVER_INFO );
 	break;

    default:
	return;
    }

    // Walk the list and convert each structure.
    //
    while( dwNumEntries-- ) {

	// Convert every LPWSTR from an offset to a pointer
	//
        for( dwIndex = 0;  OffsetTable[dwIndex] != 0xFF;  dwIndex++ ) {
	
	    plpwsStringField = (LPWSTR*)( (ULONG_PTR)pBuffer
					  + (DWORD)OffsetTable[dwIndex] );

	    OFFSET_TO_POINTER( *plpwsStringField, pBuffer );
	
	}

	pBuffer += cbStructureSize;
	
    }

    return;
}

//**
//
// Call:	AfpBufMakeMultiSz
//
// Returns:	NO_ERROR	- success
//		ERROR_NOT_ENOUGH_MEMORY
//
// Description: This routine will take a give structure and create a
//		REG_MULTI_SZ from it. This can then be set directly into the
//		registry. It is the caller's responsibility to free
//		the memory allocated for *ppbMultiSz.
//
DWORD
AfpBufMakeMultiSz(
	IN  AFP_STRUCTURE_TYPE  dwStructureType,
	IN  LPBYTE		lpbStructure,
	OUT LPBYTE *		ppbMultiSz,
	OUT LPDWORD		lpdwMultiSzSize
)
{
PAFP_MULTISZ_INFO	pAfpMultiSz;
PWCHAR			lpwchWalker;			
PVOID			pData;
DWORD			dwIndex;
DWORD			cbStructureSize;

    switch( dwStructureType ) {

    case AFP_VOLUME_STRUCT:
	pAfpMultiSz = AfpVolumeMultiSz;
	break;

    case AFP_EXTENSION_STRUCT:
	pAfpMultiSz = AfpExtensionMultiSz;
	break;

    case AFP_TYPECREATOR_STRUCT:
	pAfpMultiSz = AfpTypeCreatorMultiSz;
	break;

    case AFP_ICON_STRUCT:
	pAfpMultiSz = AfpIconMultiSz;
	break;

    default:
	return( ERROR_INVALID_PARAMETER );
    }

    // Allocate enough memory to create the multi-sz.
    // AFP_CUMULATIVE_VALNAME_SIZE should be greater than the sum of all the
    // value names of all the structures.
    //
    cbStructureSize = AfpBufStructureSize( dwStructureType, lpbStructure )
		      + AFP_CUMULATIVE_VALNAME_SIZE;

    if ( ( *ppbMultiSz = (LPBYTE)LocalAlloc( LPTR, cbStructureSize ) ) == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    ZeroMemory( *ppbMultiSz, cbStructureSize );

    // For every field, we create a string
    //
    for ( dwIndex = 0,
	  lpwchWalker = (PWCHAR)*ppbMultiSz;

	  pAfpMultiSz[dwIndex].dwType != REG_NONE;

	  dwIndex++

	){
	
	// This is the value name so do not put it in the buffer.
	//
	if ( pAfpMultiSz[dwIndex].lpwsValueName == NULL )
	    continue;

	STRCPY( lpwchWalker, pAfpMultiSz[dwIndex].lpwsValueName );
	STRCAT( lpwchWalker, TEXT("="));

	lpwchWalker += STRLEN( lpwchWalker );

	pData = lpbStructure + pAfpMultiSz[dwIndex].dwOffset;

	// Convert to string and concatenate
	//
	if ( pAfpMultiSz[dwIndex].dwType == REG_DWORD ) {

	    UCHAR chAnsiBuf[12];
	
	    _itoa( *((LPDWORD)pData), chAnsiBuf, 10 );
	
	    mbstowcs( lpwchWalker, chAnsiBuf, sizeof(chAnsiBuf) );
	}

	if ( pAfpMultiSz[dwIndex].dwType == REG_SZ ) {

	    // Check if this is a pointer or an in-place buffer
	    //
	    if ( pAfpMultiSz[dwIndex].fIsInPlace )
	     	STRCPY( lpwchWalker, (LPWSTR)pData );
	    else {

		if ( *(LPWSTR*)pData != NULL )
	    	    STRCPY( lpwchWalker, *((LPWSTR*)pData) );
	    }
	}

	lpwchWalker += ( STRLEN( lpwchWalker ) + 1 );
	
    }

    *lpdwMultiSzSize = (DWORD)((ULONG_PTR)lpwchWalker - (ULONG_PTR)(*ppbMultiSz) ) + sizeof(WCHAR);

    return( NO_ERROR );
}

//**
//
// Call:	AfpBufParseMultiSz
//
// Returns:	NO_ERROR		- success
//		ERROR_INVALID_PARAMETER
//
// Description: This routine will parse a REG_MULTI_SZ and fill in the
//		appropriate data structure. All pointers will point to
//		the pbMultiSz input parameter.
//
DWORD
AfpBufParseMultiSz(
	IN  AFP_STRUCTURE_TYPE  dwStructureType,
	IN  LPBYTE		pbMultiSz,
	OUT LPBYTE		pbStructure
)
{
PAFP_MULTISZ_INFO	pAfpMultiSz;
DWORD			dwIndex;
DWORD			cbStructSize;
LPWSTR			lpwchWalker;
PVOID			pData;
UCHAR           chAnsiBuf[12];
DWORD           dwDisableCatsearch=0;

    switch( dwStructureType ) {

    case AFP_VOLUME_STRUCT:
	pAfpMultiSz  = AfpVolumeMultiSz;
	cbStructSize = sizeof( AFP_VOLUME_INFO );

    //
    // The following "quick fix" is for Disabling CatSearch support.  Read in the
    // DisableCatsearch parameter if it's put in.  In most cases, this parm won't
    // be there.  If it is, the server disables CatSearch
    //
    for ( (lpwchWalker = (LPWSTR)pbMultiSz);
          (*lpwchWalker != TEXT('\0') );
          (lpwchWalker += ( STRLEN( lpwchWalker ) + 1 ) ))
    {
	    if ( STRNICMP( AFPREG_VALNAME_CATSEARCH,
			           lpwchWalker,
			           STRLEN( AFPREG_VALNAME_CATSEARCH ) ) == 0 )
        {
	        lpwchWalker += ( STRLEN( AFPREG_VALNAME_CATSEARCH ) + 1 );
           	wcstombs( chAnsiBuf, lpwchWalker, sizeof(chAnsiBuf) );
	    	dwDisableCatsearch = atoi( chAnsiBuf );
            break;
        }
    }

	break;

    case AFP_EXTENSION_STRUCT:
	pAfpMultiSz = AfpExtensionMultiSz;
	cbStructSize = sizeof( AFP_EXTENSION );
	break;

    case AFP_TYPECREATOR_STRUCT:
	pAfpMultiSz = AfpTypeCreatorMultiSz;
	cbStructSize = sizeof( AFP_TYPE_CREATOR );
	break;

    case AFP_ICON_STRUCT:
	pAfpMultiSz = AfpIconMultiSz;
	cbStructSize = sizeof( AFP_ICON_INFO );
	break;

    default:
	return( ERROR_INVALID_PARAMETER );
    }

    ZeroMemory( pbStructure, cbStructSize );

    // For every field in the structure
    //
    for ( dwIndex = 0; pAfpMultiSz[dwIndex].dwType != REG_NONE; dwIndex++ ){
	
	// This is the value name so do not try to retrieve it from the
	// buffer.
	//
	if ( pAfpMultiSz[dwIndex].lpwsValueName == NULL )
	    continue;

	// Search for valuename for this field
	//
        for (  lpwchWalker = (LPWSTR)pbMultiSz;

	       ( *lpwchWalker != TEXT('\0') )
	       &&
	       ( STRNICMP( pAfpMultiSz[dwIndex].lpwsValueName,
			   lpwchWalker,
			   STRLEN(pAfpMultiSz[dwIndex].lpwsValueName) ) != 0 );

	       lpwchWalker += ( STRLEN( lpwchWalker ) + 1 ) );

	// Could not find parameter
	//
	if ( *lpwchWalker == TEXT('\0') )
	    return( ERROR_INVALID_PARAMETER );

	// Otherwise we found it so get the value
	//
	lpwchWalker += ( STRLEN( pAfpMultiSz[dwIndex].lpwsValueName ) + 1 );

	pData = pbStructure + pAfpMultiSz[dwIndex].dwOffset;

	// If there is no value after the value name then ignore this field
	// It defaults to zero.
	//
        if ( *lpwchWalker != TEXT( '\0' ) ) {

	    // Convert to integer
	    //
	    if ( pAfpMultiSz[dwIndex].dwType == REG_DWORD ) {
	
            	wcstombs( chAnsiBuf, lpwchWalker, sizeof(chAnsiBuf) );

	    	*((LPDWORD)pData) = atoi( chAnsiBuf );
	
	    }

        //
        // CatSearch hack continued: if we are looking at the volume mask
        // parameter, see if we must turn the bit off.
        //
        if( dwStructureType == AFP_VOLUME_STRUCT && dwDisableCatsearch )
        {
	        if ( STRNICMP( pAfpMultiSz[dwIndex].lpwsValueName,
			              AFPREG_VALNAME_PROPS,
			              STRLEN(pAfpMultiSz[dwIndex].lpwsValueName) ) == 0 )
            {
                *((LPDWORD)pData) |= AFP_VOLUME_DISALLOW_CATSRCH;
            }
        }

	    if ( pAfpMultiSz[dwIndex].dwType == REG_SZ ) {

	    	// Check if this is a pointer or an in-place buffer
	    	//
	    	if ( pAfpMultiSz[dwIndex].fIsInPlace ) {

		    if ( STRLEN( lpwchWalker ) > pAfpMultiSz[dwIndex].cch )
    			return( ERROR_INVALID_PARAMETER );

		    STRCPY( (LPWSTR)pData, lpwchWalker );
		}
	    	else
		    *((LPWSTR*)pData) = lpwchWalker;
	    }

	}

    }

    return( NO_ERROR );

}

//**
//
// Call:	AfpBufMakeFSDETCMappings
//
// Returns:	NO_ERROR	
//		ERROR_NOT_ENOUGH_MEMORY	
//
// Description: This routine will convert all the mappings in the
//		form stored in AfpGlobals.AfpETCMapInfo to the form
//		required by the FSD, ie. the ETCMAPINFO structure.
//		It is the responsibility for the caller to free
//		allocated memory.
//
DWORD
AfpBufMakeFSDETCMappings(
	OUT PSRVETCPKT		*ppSrvSetEtc,
	OUT LPDWORD		lpdwSrvSetEtcBufSize
)
{
DWORD			dwIndex;
PETCMAPINFO2		pETCMapInfo;
PAFP_EXTENSION		pExtensionWalker;
PAFP_TYPE_CREATOR	pTypeCreator;
AFP_TYPE_CREATOR	AfpTypeCreatorKey;
DWORD			dwNumTypeCreators;


    // Allocate space to hold the ETCMaps in the form required by the FSD.
    //
    *ppSrvSetEtc = (PSRVETCPKT)LocalAlloc( LPTR,
	  AFP_FIELD_SIZE( SRVETCPKT, retc_NumEtcMaps ) +
          (AfpGlobals.AfpETCMapInfo.afpetc_num_extensions*sizeof(ETCMAPINFO2)));

    if ( *ppSrvSetEtc == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    // Walk through the extension list
    //
    for( dwIndex 	   = 0,
	 pETCMapInfo       = (*ppSrvSetEtc)->retc_EtcMaps,
	 pExtensionWalker  = AfpGlobals.AfpETCMapInfo.afpetc_extension,
	 pTypeCreator      = AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
	 dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
    	 (*ppSrvSetEtc)->retc_NumEtcMaps = 0;

	 dwIndex < AfpGlobals.AfpETCMapInfo.afpetc_num_extensions;

	 dwIndex++,
	 dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
	 pExtensionWalker++

	) {

	
	// Ignore any extensions that are associated with the default
	// type/creator. They shouldnt be in the registry to begin with.
	//
	if ( pExtensionWalker->afpe_tcid == AFP_DEF_TCID )
	    continue;
	
	// Find the type/creator associated with this extension.
	//
  	AfpTypeCreatorKey.afptc_id = pExtensionWalker->afpe_tcid;

    	pTypeCreator = _lfind(  &AfpTypeCreatorKey,
			       AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
			       (unsigned int *)&dwNumTypeCreators,
			       sizeof(AFP_TYPE_CREATOR),
			       AfpLCompareTypeCreator );
	

	// If there is a type/creator associated with this extension
	//
	if ( pTypeCreator != NULL ) {

	    AfpBufCopyFSDETCMapInfo( pTypeCreator,
				     pExtensionWalker,
				     pETCMapInfo );

	    pETCMapInfo++;
    	    (*ppSrvSetEtc)->retc_NumEtcMaps++;
	}

    }

    *lpdwSrvSetEtcBufSize = AFP_FIELD_SIZE( SRVETCPKT, retc_NumEtcMaps ) +
    	    ((*ppSrvSetEtc)->retc_NumEtcMaps * sizeof(ETCMAPINFO2));

    return( NO_ERROR );
}

//**
//
// Call:	AfpBufMakeFSDIcon
//
// Returns:	none.
//
// Description: This routine will copy the icon information from the
//		AFP_ICON_INFO data structure to an SRVICONINFO data
//		structure viz. the form that the FSD needs.
//
VOID
AfpBufMakeFSDIcon(
	IN  PAFP_ICON_INFO pIconInfo,
	OUT LPBYTE	   lpbFSDIcon,
	OUT LPDWORD	   lpcbFSDIconSize
)
{
UCHAR	chBuffer[sizeof(AFP_ICON_INFO)]; // Need enough space to translate

    // Blank out the whole structure so that type and creator will
    // be padded with blanks
    //
    memset( lpbFSDIcon, ' ', sizeof(SRVICONINFO) );

    // Convert to ANSI and copy type
    //
    wcstombs(chBuffer,pIconInfo->afpicon_type,sizeof(chBuffer));

    CopyMemory( ((PSRVICONINFO)lpbFSDIcon)->icon_type,
	    	chBuffer,
	    	STRLEN(pIconInfo->afpicon_type));

    // Convert to ANSI copy creator
    //
    wcstombs(chBuffer,pIconInfo->afpicon_creator,sizeof(chBuffer));

    CopyMemory( ((PSRVICONINFO)lpbFSDIcon)->icon_creator,
	      	chBuffer,
	    	STRLEN(pIconInfo->afpicon_creator));

    // Set icon type
    //
    ((PSRVICONINFO)lpbFSDIcon)->icon_icontype = pIconInfo->afpicon_icontype;

    // Set icon data length
    //
    ((PSRVICONINFO)lpbFSDIcon)->icon_length = pIconInfo->afpicon_length;

    CopyMemory( lpbFSDIcon + sizeof(SRVICONINFO),
	        pIconInfo->afpicon_data,
	    	((PSRVICONINFO)lpbFSDIcon)->icon_length );

    *lpcbFSDIconSize = sizeof(SRVICONINFO) + pIconInfo->afpicon_length;

    return;
}

//**
//
// Call:	AfpBufCopyFSDETCMapInfo
//
// Returns:	none
//
// Description: This routine will copu information from the AFP_TYPE_CREATOR
//		and AFP_EXTENSION data structures into a ETCMAPINFO data
//		structure viz. in the form as required by the FSD.
//
VOID
AfpBufCopyFSDETCMapInfo( 	
	IN  PAFP_TYPE_CREATOR 	pAfpTypeCreator,
	IN  PAFP_EXTENSION	pAfpExtension,
	OUT PETCMAPINFO2         pFSDETCMapInfo
)
{
    CHAR	Buffer[sizeof(AFP_TYPE_CREATOR)];


    // Insert blanks which will be used to pad type/creators less
    // than their max. lengths.
    //
    memset( (LPBYTE)pFSDETCMapInfo, ' ', sizeof(ETCMAPINFO2) );
    ZeroMemory( (LPBYTE)(pFSDETCMapInfo->etc_extension),
            	AFP_FIELD_SIZE( ETCMAPINFO2, etc_extension ) );

    CopyMemory( pFSDETCMapInfo->etc_extension,
                pAfpExtension->afpe_extension,
	    	    wcslen(pAfpExtension->afpe_extension) * sizeof(WCHAR));

    wcstombs( Buffer, pAfpTypeCreator->afptc_type, sizeof(Buffer) );
    CopyMemory( pFSDETCMapInfo->etc_type,
	      	Buffer,
	    	STRLEN(pAfpTypeCreator->afptc_type));

    wcstombs( Buffer, pAfpTypeCreator->afptc_creator, sizeof(Buffer) );
    CopyMemory( pFSDETCMapInfo->etc_creator,
	    	Buffer,
	    	STRLEN(pAfpTypeCreator->afptc_creator));

    return;

}

//**
//
// Call:	AfpBufUnicodeToNibble
//
// Returns:	NO_ERROR
//		ERROR_INVALID_PARAMETER
//
// Description: This routine will take a pointer to a UNCODE string and
//		convert each UNICODE char to a the corresponding nibble.
//		it char. 'A' will be converted to a nibble having value 0xA
//		This conversion is done in-place.
//
DWORD
AfpBufUnicodeToNibble(
	IN OUT LPWSTR	lpwsData
)
{
DWORD 	dwIndex;
BYTE	bData;
LPBYTE  lpbData = (LPBYTE)lpwsData;

    // Convert each UNICODE character to nibble. (in place)
    //
    for ( dwIndex = 0; *lpwsData != TEXT('\0'); dwIndex++, lpwsData++ ) {

	if ( iswalpha( *lpwsData ) ) {
	
	    if ( iswupper( *lpwsData ) )
            	bData = *lpwsData - TEXT('A');
	    else
            	bData = *lpwsData - TEXT('a');

	    bData += 10;
	
	    if ( bData > 0x0F )
		return( ERROR_INVALID_PARAMETER );
	}
	else if ( iswdigit( *lpwsData ) )
	    bData = *lpwsData - TEXT('0');
	else
	    return( ERROR_INVALID_PARAMETER );

	// Multipy so that data is in the most significant nibble.
	// Do this every other time.
	//
	if ( ( dwIndex % 2 ) == 0 )
	    *lpbData = bData * 16;
	else {
	    *lpbData += bData;
	    lpbData++;
	}
				
				
    }

    return( NO_ERROR );
}

//**
//
// Call:	AfpBCompareTypeCreator
//
// Returns:	< 0  if pAfpTypeCreator1 comes before pAfpTypeCreator2
// 		> 0  if pAfpTypeCreator1 comes before pAfpTypeCreator2
//		== 0 if pAfpTypeCreator1 is equal to  pAfpTypeCreator2
//
// Description: This routine is called by qsort to sort the list of
//		type creators in the cache. The list is sorted in
//		ascending alphabetical order of the concatenation of the
//		creator and type. This list is sorted to facilitate quick
//		lookup (binary search). This routine is also called by
//		bsearch to do a binary search on the list.
//
int
_cdecl
AfpBCompareTypeCreator(
	IN const void * pAfpTypeCreator1,
	IN const void * pAfpTypeCreator2
)
{
WCHAR	wchTypeCreator1[ sizeof( AFP_TYPE_CREATOR )];
WCHAR	wchTypeCreator2[ sizeof( AFP_TYPE_CREATOR )];
		

    STRCPY(wchTypeCreator1,
	   ((PAFP_TYPE_CREATOR)pAfpTypeCreator1)->afptc_creator);

    if (STRLEN(((PAFP_TYPE_CREATOR)pAfpTypeCreator1)->afptc_creator) == 0)
        wchTypeCreator1[0]=L'\0';

    STRCAT(wchTypeCreator1,((PAFP_TYPE_CREATOR)pAfpTypeCreator1)->afptc_type );

    STRCPY(wchTypeCreator2,
	   ((PAFP_TYPE_CREATOR)pAfpTypeCreator2)->afptc_creator);

    STRCAT(wchTypeCreator2,((PAFP_TYPE_CREATOR)pAfpTypeCreator2)->afptc_type );

    return( STRCMP( wchTypeCreator1, wchTypeCreator2 ) );
}

//**
//
// Call:	AfpLCompareTypeCreator
//
// Returns:	< 0  if pAfpTypeCreator1 comes before pAfpTypeCreator2
// 		> 0  if pAfpTypeCreator1 comes before pAfpTypeCreator2
//		== 0 if pAfpTypeCreator1 is equal to  pAfpTypeCreator2
//
// Description: This routine is called by lfind to do a linear search of
//		the type/creator list.
//
int
_cdecl
AfpLCompareTypeCreator(
	IN const void * pAfpTypeCreator1,
	IN const void * pAfpTypeCreator2
)
{

    return( ( ((PAFP_TYPE_CREATOR)pAfpTypeCreator1)->afptc_id ==
    	      ((PAFP_TYPE_CREATOR)pAfpTypeCreator2)->afptc_id ) ? 0 : 1 );
}

//**
//
// Call:	AfpBCompareExtension
//
// Returns:	< 0  if pAfpExtension1 comes before pAfpExtension2
// 		> 0  if pAfpExtension1 comes before pAfpExtension2
//		== 0 if pAfpExtension1 is equal to  pAfpExtension2
//
// Description: This is called by qsort to sort the list of extensions in the
//		cache. The list is sorted by ID. This routine is also called
//		by bserach to do a binary lookup of this list.
//
int
_cdecl
AfpBCompareExtension(
	IN const void * pAfpExtension1,
	IN const void * pAfpExtension2
)
{
    return((((PAFP_EXTENSION)pAfpExtension1)->afpe_tcid ==
    	    ((PAFP_EXTENSION)pAfpExtension2)->afpe_tcid ) ? 0 :
          ((((PAFP_EXTENSION)pAfpExtension1)->afpe_tcid <
    	    ((PAFP_EXTENSION)pAfpExtension2)->afpe_tcid ) ? -1 : 1 ));

}

//**
//
// Call:	AfpLCompareExtension
//
// Returns:	< 0  if pAfpExtension1 comes before pAfpExtension2
// 		> 0  if pAfpExtension1 comes before pAfpExtension2
//		== 0 if pAfpExtension1 is equal to  pAfpExtension2
//
// Description: This routine is called by lfind to do a linear lookup of the
//		list of extensions in the cache.
//
int
_cdecl
AfpLCompareExtension(
	IN const void * pAfpExtension1,
	IN const void * pAfpExtension2
)
{
    return( STRICMP( ((PAFP_EXTENSION)pAfpExtension1)->afpe_extension,
    		     ((PAFP_EXTENSION)pAfpExtension2)->afpe_extension ) );
}

//**
//
// Call:	AfpBinarySearch
//
// Returns:	Pointer to first occurance of element that matches pKey.
//
// Description: This is a wrapper around bsearch. Since bsearch does not
//		return the first occurance of an element within the array,
//		this routine will back up to point to the first occurance
//		of a record with a particular key is reached.
//
void *
AfpBinarySearch(
	IN const void * pKey,
	IN const void * pBase,
	IN size_t num,
	IN size_t width,
	IN int (_cdecl *compare)(const void * pElem1, const void * pElem2 )
)
{
void * pCurrElem = bsearch( pKey, pBase, num, width, compare);


    if ( pCurrElem == NULL )
	return( NULL );

    // Backup until first occurance is reached
    //
    while ( ( (ULONG_PTR)pCurrElem > (ULONG_PTR)pBase )
	    &&
	    ( (*compare)( pKey, (void*)((ULONG_PTR)pCurrElem - width) ) == 0 ) )

	pCurrElem = (void *)((ULONG_PTR)pCurrElem - width);

    return( pCurrElem );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\debug.h ===
/*******************************************************************/
/*	      Copyright(c)  1992 Microsoft Corporation		   */
/*******************************************************************/


//***
//
// Filename:	debug.h
//
// Description: This module debug definitions for
//		the supervisor module.
//
// Author:	Narendra Gidwani (nareng)    May 22, 1992.
//
// Revision History:
//
//***



#ifndef _DEBUG_
#define _DEBUG_


#ifdef DBG

VOID
DbgUserBreakPoint(VOID);

#define DEBUG_INITIALIZATION            0x00000001
#define DEBUG_TERMINATION		0x00000002
#define DEBUG_FSM			0x00000004
#define DEBUG_TIMER			0x00000008

extern DWORD	AfpDebug;

//#define DEBUG if ( TRUE )
// #define IF_DEBUG(flag) if (SDebug & (DEBUG_ ## flag))

VOID
AfpPrintf (
    char *Format,
    ...
    );
#define AFP_PRINT(args) DbgPrint args

VOID
AfpAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    );
#define AFP_ASSERT(exp) if (!(exp)) AfpAssert( #exp, __FILE__, __LINE__ )

#else

#define AFP_PRINT(args)

#define AFP_ASSERT(exp)


#endif

#endif // ndef _DEBUG_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\etcmap.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.       **/
/********************************************************************/

//***
//
// Filename:    etcmap.c
//
// Description: This module contains support routines for the extension/
//        	type/creator mappings category API's for the AFP server
//        	service. These routines are called directly by the RPC
//		runtime.
//
// History:
//    		June 11,1992.    NarenG        Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:    	AfpAdminrETCMapGetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		ERROR_NOT_ENOUGH_MEMORY
//
// Description: Will alllocate enough memory to contain all mappings, copy
//        	the information and return.
//
DWORD
AfpAdminrETCMapGetInfo(
        IN  AFP_SERVER_HANDLE    hServer,
        OUT PAFP_ETCMAP_INFO     *ppAfpETCMapInfo
)
{
DWORD            dwRetCode=0;
DWORD            dwAccessStatus=0;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapGetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
        AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL, 	
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapGetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexETCMap, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

    	// Allocate memory and copy ETC mappings information
    	//
    	*ppAfpETCMapInfo = MIDL_user_allocate( sizeof(AFP_ETCMAP_INFO) );

    	if ( *ppAfpETCMapInfo == NULL ) {
	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
	}

    	(*ppAfpETCMapInfo)->afpetc_num_type_creators =
	     		     AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators;

    	(*ppAfpETCMapInfo)->afpetc_type_creator = MIDL_user_allocate(
			     sizeof(AFP_TYPE_CREATOR)
    			    *AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators);

    	if ( (*ppAfpETCMapInfo)->afpetc_type_creator == NULL ) {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
        }

    	(*ppAfpETCMapInfo)->afpetc_num_extensions =
	     		     AfpGlobals.AfpETCMapInfo.afpetc_num_extensions;

    	(*ppAfpETCMapInfo)->afpetc_extension = MIDL_user_allocate(
			      sizeof(AFP_EXTENSION)
    			     *AfpGlobals.AfpETCMapInfo.afpetc_num_extensions);

        if ( (*ppAfpETCMapInfo)->afpetc_extension == NULL ) {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
	}

        CopyMemory( (LPBYTE)(*ppAfpETCMapInfo)->afpetc_type_creator,
            	    (LPBYTE)(AfpGlobals.AfpETCMapInfo.afpetc_type_creator),
	    	    sizeof(AFP_TYPE_CREATOR)
	    	    * AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators);

    	CopyMemory( (LPBYTE)(*ppAfpETCMapInfo)->afpetc_extension,
            	    (LPBYTE)(AfpGlobals.AfpETCMapInfo.afpetc_extension),
	    	    sizeof(AFP_EXTENSION)
	    	    * AfpGlobals.AfpETCMapInfo.afpetc_num_extensions);

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexETCMap );

    if ( dwRetCode ) {

	if ( *ppAfpETCMapInfo != NULL ) {

	    if ( (*ppAfpETCMapInfo)->afpetc_type_creator != NULL )
	    	MIDL_user_free( (*ppAfpETCMapInfo)->afpetc_type_creator );

	    MIDL_user_free( *ppAfpETCMapInfo );
        }
    }

    return( dwRetCode );
}

//**
//
// Call:    	AfpAdminrETCMapAdd
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//	        AFPERR_DuplicateTypeCreator;
//		non-zero returns from the registry API's
//
// Description: This routine will add a type/creator/comment tupple to the
//        	registry and the cache.
//
DWORD
AfpAdminrETCMapAdd(
    IN  AFP_SERVER_HANDLE    hServer,
    IN  PAFP_TYPE_CREATOR    pAfpTypeCreator
)
{
DWORD               dwRetCode=0;
DWORD               dwAccessStatus=0;
PAFP_TYPE_CREATOR   pTypeCreator;
DWORD		    dwNumTypeCreators;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapAdd, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
        AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		    dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapAdd, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexETCMap, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

        // First check to see if the type already exists.
    	//
    	pTypeCreator = AfpBinarySearch(
			      pAfpTypeCreator,
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpBCompareTypeCreator );

        // It exists so return error
        //
        if ( pTypeCreator != NULL ) {
	    dwRetCode = (DWORD)AFPERR_DuplicateTypeCreator;
	    break;
	}

	// Set the ID for this type/creator	
	//
        pAfpTypeCreator->afptc_id = ++AfpGlobals.dwCurrentTCId;

        // It does not exist so add it to the registry and the cache.
        //
        if ( dwRetCode = AfpRegTypeCreatorAdd( pAfpTypeCreator ) )
	    break;

        // Grow the cache size by one entry.
        //
        pTypeCreator      = AfpGlobals.AfpETCMapInfo.afpetc_type_creator;
        dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators;

        pTypeCreator = (PAFP_TYPE_CREATOR)LocalReAlloc(
				 pTypeCreator,
    			         (dwNumTypeCreators+1)*sizeof(AFP_TYPE_CREATOR),
			         LMEM_MOVEABLE );

        if ( pTypeCreator == NULL ) {
	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
	}

    	pTypeCreator[dwNumTypeCreators++] = *pAfpTypeCreator;

    	AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators = dwNumTypeCreators;
    	AfpGlobals.AfpETCMapInfo.afpetc_type_creator      = pTypeCreator;

        // Sort the table
        //
        qsort(  pTypeCreator,
	   	dwNumTypeCreators,
	   	sizeof(AFP_TYPE_CREATOR),
	   	AfpBCompareTypeCreator );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexETCMap );

    return( dwRetCode );
}

//**
//
// Call:    	AfpAdminrETCMapDelete
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		AFPERR_TypeCreatorNotExistant
//		non-zero returns from registry api's.
//		non-zero returns from the FSD.
//		
//
// Description: This routine will delete a type/creator tupple from the
//		registry and the cache. If there are any extensions that map
//		to this tupple, they are deleted.
//		Shrinking by reallocating is not done. This will be done the
//		next time an extension is added or if the server is restarted.
//		
DWORD
AfpAdminrETCMapDelete(
    IN  AFP_SERVER_HANDLE    hServer,
    IN  PAFP_TYPE_CREATOR    pAfpTypeCreator
)
{
AFP_REQUEST_PACKET  AfpSrp;
DWORD               dwRetCode=0;
DWORD               dwAccessStatus=0;
PAFP_TYPE_CREATOR   pTypeCreator;
AFP_EXTENSION	    AfpExtensionKey;
PAFP_EXTENSION	    pExtension;
PAFP_EXTENSION	    pExtensionWalker;
DWORD		    cbSize;
DWORD		    dwIndex;
ETCMAPINFO2	    ETCMapFSDBuf;
DWORD		    dwCount;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapDelete, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
        AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapDelete, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexETCMap, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

    	// First check to see if the type/creator exists.
    	//
    	pTypeCreator = AfpBinarySearch(
			      pAfpTypeCreator,
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpBCompareTypeCreator );

    	// It does not exist so return error
    	//
    	if ( pTypeCreator == NULL ) {
	    dwRetCode = (DWORD)AFPERR_TypeCreatorNotExistant;
	    break;
	}

  	// If this is the default type/creator
	//
    	if ( pTypeCreator->afptc_id == AFP_DEF_TCID ) {
	    dwRetCode = (DWORD)AFPERR_CannotDeleteDefaultTC;
	    break;
  	}

	// Store the id of this type/creator. All extensions with this
	// id will have to be deleted.
	//
    	AfpExtensionKey.afpe_tcid = pTypeCreator->afptc_id;

        // Walk the list of extensions and delete all entries with
    	// the corresponding type/creator ID
    	//
    	pExtension = AfpBinarySearch(
				&AfpExtensionKey,
			        AfpGlobals.AfpETCMapInfo.afpetc_extension,
    			        AfpGlobals.AfpETCMapInfo.afpetc_num_extensions,
			        sizeof(AFP_EXTENSION),
			    	AfpBCompareExtension );

    	if ( pExtension != NULL ) {
	
            for ( dwIndex = (DWORD)(((ULONG_PTR)pExtension -
			     (ULONG_PTR)(AfpGlobals.AfpETCMapInfo.afpetc_extension)) / sizeof(AFP_EXTENSION)),
		         pExtensionWalker = pExtension,
		         dwCount = 0;
	
		         ( dwIndex < AfpGlobals.AfpETCMapInfo.afpetc_num_extensions )
		         &&
		         ( pExtensionWalker->afpe_tcid == AfpExtensionKey.afpe_tcid );

	      	     dwIndex++,
		         dwCount++,
		         pExtensionWalker++ )
            {
		
	   	        // IOCTL the FSD to delete this tupple
  	    	    //
	    	    AfpBufCopyFSDETCMapInfo( pAfpTypeCreator,
				             pExtensionWalker,
				             &ETCMapFSDBuf );

    	        AfpSrp.dwRequestCode 	           = OP_SERVER_DELETE_ETC;
            	AfpSrp.dwApiType 	       	   = AFP_API_TYPE_DELETE;
                AfpSrp.Type.Delete.pInputBuf       = &ETCMapFSDBuf;
                AfpSrp.Type.Delete.cbInputBufSize  = sizeof(ETCMAPINFO2);

                if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
                {
		            break;
                }

	            // Delete this extension from the registry
	            //
    	        if ( dwRetCode = AfpRegExtensionDelete( pExtensionWalker ))
                {
		            break;
                }
	        }

	    if ( dwRetCode )
	    	break;

	    // Remove the extensions from the cache
	    //
            AfpGlobals.AfpETCMapInfo.afpetc_num_extensions -= dwCount;

	    // Remove these extensions from the cache too
	    //
            cbSize = AfpGlobals.AfpETCMapInfo.afpetc_num_extensions
		     * sizeof(AFP_EXTENSION);

            cbSize -= (DWORD)((ULONG_PTR)pExtension -
		       (ULONG_PTR)(AfpGlobals.AfpETCMapInfo.afpetc_extension));

	    CopyMemory( (LPBYTE)pExtension, (LPBYTE)pExtensionWalker, cbSize );

	}

        // Delete the type/creator from the registry
        //
        if ( dwRetCode = AfpRegTypeCreatorDelete( pTypeCreator ) )
	    break;

        // Delete the type/creator from the cache
        //
        AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators--;

        cbSize = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators
	         * sizeof(AFP_TYPE_CREATOR);

        cbSize -= (DWORD)((ULONG_PTR)pTypeCreator -
		   (ULONG_PTR)AfpGlobals.AfpETCMapInfo.afpetc_type_creator);

        CopyMemory( (LPBYTE)pTypeCreator,
	            (LPBYTE)((ULONG_PTR)pTypeCreator+sizeof(AFP_TYPE_CREATOR)),
    	        cbSize );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexETCMap );

    return( dwRetCode );
}

//**
//
// Call:    	AfpAdminrETCMapSetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		AFPERR_TypeCreatorNotExistant
//	        AFPERR_CannotEditDefaultTC;
//		non-zero returns from registry api's.
//
// Description: This routine will simply change the comment for a type/creator
//		tupple.
//
DWORD
AfpAdminrETCMapSetInfo(
    IN  AFP_SERVER_HANDLE    hServer,
    IN  PAFP_TYPE_CREATOR    pAfpTypeCreator
)
{
DWORD            	dwRetCode=0;
DWORD            	dwAccessStatus=0;
PAFP_TYPE_CREATOR    	pTypeCreator;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapSetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
        AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapSetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexETCMap, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {
	dwRetCode = NO_ERROR;


    	// First check to see if the type/creator exists.
    	//
    	pTypeCreator = AfpBinarySearch(
			      pAfpTypeCreator,
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpBCompareTypeCreator );

    	// It does not exist so return error
    	//
    	if ( pTypeCreator == NULL ) {
	    dwRetCode = (DWORD)AFPERR_TypeCreatorNotExistant;
	    break;
	}

	// If this is the default type/creator
	//
    	if ( pTypeCreator->afptc_id == AFP_DEF_TCID ) {
	    dwRetCode = (DWORD)AFPERR_CannotEditDefaultTC;
	    break;
  	}

	// Copy the id.
	//
    	pAfpTypeCreator->afptc_id = pTypeCreator->afptc_id;
	
        // Set the comment in the registry
        //
    	if ( dwRetCode = AfpRegTypeCreatorSetInfo( pAfpTypeCreator ) ) {
	    break;
	}

    	// Set the comment in the cache.
    	//
    	STRCPY( pTypeCreator->afptc_comment, pAfpTypeCreator->afptc_comment );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexETCMap );

    return( dwRetCode );
}

//**
//
// Call:    	AfpAdminrETCMapAssociate
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		AFPERR_TypeCreatorNotExistant
//		non-zero returns from registry api's.
//		non-zero returns from the FSD
//
//
// Description: This routine will associate the given extension with the
//		specified type/creator if it exists. If the extension is
//		being mapped to the default type/creator, it will be
//		deleted.
//
DWORD
AfpAdminrETCMapAssociate(
    IN  AFP_SERVER_HANDLE   hServer,
    IN  PAFP_TYPE_CREATOR   pAfpTypeCreator,
    IN  PAFP_EXTENSION	    pAfpExtension
)
{
AFP_REQUEST_PACKET  AfpSrp;
DWORD               dwRetCode=0;
DWORD               dwAccessStatus=0;
PAFP_TYPE_CREATOR   pTypeCreator;
PAFP_EXTENSION	    pExtension;
SRVETCPKT	    SrvETCPkt;
DWORD		    dwNumExtensions;
DWORD		    cbSize;
BYTE		    bETCMapFSDBuf[sizeof(ETCMAPINFO2)+sizeof(SETINFOREQPKT)];


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapAssociate, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
        AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrETCMapAssociate, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexETCMap, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {
	dwRetCode = NO_ERROR;

    	// First check to see if the type/creator pair that the
	// new extension is to be associated with, exists.
      	//
    	pTypeCreator = AfpBinarySearch(
			      pAfpTypeCreator,
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpBCompareTypeCreator );

    	// It does not exist so return error
    	//
    	if ( pTypeCreator == NULL ) {
	    dwRetCode =  (DWORD)AFPERR_TypeCreatorNotExistant;
	    break;
	}

    	// Now check to see if the extension is already associated with
    	// a type/creator pair.
    	//
        dwNumExtensions = AfpGlobals.AfpETCMapInfo.afpetc_num_extensions;
    	pExtension = _lfind( pAfpExtension,
			    AfpGlobals.AfpETCMapInfo.afpetc_extension,
    			    (unsigned int *)&dwNumExtensions,
			    sizeof(AFP_EXTENSION),
			    AfpLCompareExtension );

    	// Not currently associated so we need to add an entry
    	//
    	if ( pExtension == NULL ) {
	
	    // If this extension is being associated with the default
  	    // then simply return.
 	    //
    	    if ( pTypeCreator->afptc_id == AFP_DEF_TCID ) {
		dwRetCode = NO_ERROR;
		break;
	    }

	    // Add mapping to FSD
	    //
	    AfpBufCopyFSDETCMapInfo(  pAfpTypeCreator,
				      pAfpExtension,
				      &(SrvETCPkt.retc_EtcMaps[0]) );

            SrvETCPkt.retc_NumEtcMaps = 1;
	
    	    AfpSrp.dwRequestCode 	    = OP_SERVER_ADD_ETC;
            AfpSrp.dwApiType 		    = AFP_API_TYPE_ADD;
            AfpSrp.Type.Add.pInputBuf       = &SrvETCPkt;
            AfpSrp.Type.Add.cbInputBufSize  = sizeof(SRVETCPKT);

            if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
		break;

	    // Add extension to registry.
	    //
            pAfpExtension->afpe_tcid = pTypeCreator->afptc_id;

    	    if ( dwRetCode = AfpRegExtensionSetInfo( pAfpExtension ) ) {
		break;
	    }
	
	    // Add extension to cache.
	    //
            pExtension      = AfpGlobals.AfpETCMapInfo.afpetc_extension;
            dwNumExtensions = AfpGlobals.AfpETCMapInfo.afpetc_num_extensions;

            pExtension = (PAFP_EXTENSION)LocalReAlloc(
				  pExtension,
    			          (dwNumExtensions+1)*sizeof(AFP_EXTENSION),
			          LMEM_MOVEABLE );

            if ( pExtension == NULL ) {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
		break;
	    }

            pExtension[dwNumExtensions++] = *pAfpExtension;

            AfpGlobals.AfpETCMapInfo.afpetc_num_extensions = dwNumExtensions;
            AfpGlobals.AfpETCMapInfo.afpetc_extension      = pExtension;

    	}

    	// Extension is already mapped.
    	//
    	else {

	    // If this extension is being associated with the default
  	    // then delete this extension from the registry and cache and
	    // delete the mapping from the FSD
 	    //
  	    if ( pTypeCreator->afptc_id == AFP_DEF_TCID ) {
	
	   	// IOCTL the FSD to delete this tupple
  	    	//
	    	AfpBufCopyFSDETCMapInfo( pAfpTypeCreator,
				     	 pAfpExtension,
				     	 (PETCMAPINFO2)bETCMapFSDBuf );

    	    	AfpSrp.dwRequestCode 	           = OP_SERVER_DELETE_ETC;
            	AfpSrp.dwApiType 		   = AFP_API_TYPE_DELETE;
            	AfpSrp.Type.Delete.pInputBuf       = bETCMapFSDBuf;
            	AfpSrp.Type.Delete.cbInputBufSize  = sizeof(ETCMAPINFO2);

            	if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
		    break;

	        // Delete this extension from the registry
	    	//
    	    	if ( dwRetCode = AfpRegExtensionDelete( pAfpExtension ) ) {
		    break;
		}

	       	// Remove this extensions from the cache too
	        //
                AfpGlobals.AfpETCMapInfo.afpetc_num_extensions--;

                cbSize = AfpGlobals.AfpETCMapInfo.afpetc_num_extensions
		         * sizeof(AFP_EXTENSION);

                cbSize -= (DWORD)((ULONG_PTR)pExtension -
			   (ULONG_PTR)(AfpGlobals.AfpETCMapInfo.afpetc_extension));

	        CopyMemory( (LPBYTE)pExtension,
		            (LPBYTE)((ULONG_PTR)pExtension+sizeof(AFP_EXTENSION)),
		            cbSize );

	    }
	    else {

		// Otherwise simply change the mapping in the FSD
		//
        	pExtension->afpe_tcid = pTypeCreator->afptc_id;

		AfpBufCopyFSDETCMapInfo(pTypeCreator,
				  	pExtension,
 			    (PETCMAPINFO2)(bETCMapFSDBuf+sizeof(SETINFOREQPKT)));

    		AfpSrp.dwRequestCode 	            = OP_SERVER_SET_ETC;
        	AfpSrp.dwApiType 		    = AFP_API_TYPE_SETINFO;
        	AfpSrp.Type.SetInfo.pInputBuf       = bETCMapFSDBuf;
        	AfpSrp.Type.SetInfo.cbInputBufSize  = sizeof(bETCMapFSDBuf);

        	if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
		    break;

		// Change the registry
		//
    		if ( dwRetCode = AfpRegExtensionSetInfo( pExtension ) ) {
		    break;
		}
	    }

        }

    	// Sort the table
    	//
    	qsort(  AfpGlobals.AfpETCMapInfo.afpetc_extension,
            	AfpGlobals.AfpETCMapInfo.afpetc_num_extensions,
	    	sizeof(AFP_EXTENSION),
	    	AfpBCompareExtension );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexETCMap );

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\dir.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.         **/
/********************************************************************/

//***
//
// Filename:    dir.c
//
// Description: This module contains support routines for the diretory
//              category API's for the AFP server service. These routines
//              are called by the RPC runtime.
//
// History:
//              June 11,1992.   NarenG          Created original version.
//
#include <nt.h>
#include <ntrtl.h>
#include <ntlsa.h>
#include <nturtl.h>     // needed for winbase.h
#include "afpsvcp.h"

//**
//
// Call:        AfpDirConvertSidsToNames
//
// Returns:     NO_ERROR
//              error return codes from LsaOpenPolicy and LsaLookupSids
//
// Description: Will convert the directory structure returned by the FSD
//              which contains pointers to owner and groups SIDS to their
//              respective names. The caller is responsible for freeing up
//              the memory allocated to hold the converted dir structure.
//
DWORD
AfpDirConvertSidsToNames(
        IN  PAFP_DIRECTORY_INFO  pAfpDirInfo,
        OUT PAFP_DIRECTORY_INFO* ppAfpConvertedDirInfo
)
{
LSA_HANDLE                      hLsa            = NULL;
NTSTATUS                        ntStatus;
PLSA_REFERENCED_DOMAIN_LIST     pDomainList     = NULL;
PLSA_TRANSLATED_NAME            pNames          = NULL;
PSID                            pSidArray[2];
SECURITY_QUALITY_OF_SERVICE     QOS;
OBJECT_ATTRIBUTES               ObjectAttributes;
DWORD                           dwRetCode       = NO_ERROR;
PAFP_DIRECTORY_INFO             pOutputBuf      = NULL;
DWORD                           cbOutputBuf;
LPBYTE                          pbVariableData;
DWORD                           dwIndex;
WCHAR *                         pWchar;
BOOL                            fUseUnknownAccount = FALSE;
DWORD                           dwUse, dwCount = 0;
SID                             AfpBuiltInSid = { 1, 1, SECURITY_NT_AUTHORITY,
                                                  SECURITY_BUILTIN_DOMAIN_RID };

    // First open the LSA and obtain a handle to it.
    //
    QOS.Length              = sizeof( QOS );
    QOS.ImpersonationLevel  = SecurityImpersonation;
    QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QOS.EffectiveOnly       = FALSE;

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                0L,
                                NULL,
                                NULL );

    ObjectAttributes.SecurityQualityOfService = &QOS;

    ntStatus = LsaOpenPolicy(   NULL,
                                &ObjectAttributes,
                                POLICY_LOOKUP_NAMES,
                                &hLsa );

    if ( !NT_SUCCESS( ntStatus ))
        return( RtlNtStatusToDosError( ntStatus ) );

    // This is not a loop
    //
    do {


        // Set up the owner and group sid into the array.
        //
                if ((PSID)(pAfpDirInfo->afpdir_owner) != NULL)
                {
                        pSidArray[dwCount++] = (PSID)(pAfpDirInfo->afpdir_owner);
                }
                if ((PSID)(pAfpDirInfo->afpdir_group) != NULL)
                {
                        pSidArray[dwCount++] = (PSID)(pAfpDirInfo->afpdir_group);
                }
                    
        // Try to get the names of the owner and primary group.
        //
                if (dwCount > 0)
                {
                        ntStatus = LsaLookupSids( hLsa, dwCount, pSidArray, &pDomainList, &pNames );
        
                        if ( !NT_SUCCESS( ntStatus ) ) {
        
                                if ( ntStatus == STATUS_NONE_MAPPED ) {
        
                                        fUseUnknownAccount = TRUE;
        
                                        dwRetCode = NO_ERROR;
        
                                }
                                else {
        
                                        dwRetCode = RtlNtStatusToDosError( ntStatus );
        
                    AFP_PRINT(( "SFMSVC: AfpDirConvertSidsToNames, LsaLookupSids failed with error (%ld)\n", dwRetCode));

                                        break;
                                }
                        }
                }

        // We need to calculate the length of the buffer we need to allocate.
        //
        for( dwIndex = 0,
                 dwRetCode = NO_ERROR,
             cbOutputBuf = sizeof( AFP_DIRECTORY_INFO );

             dwIndex < dwCount;

             dwIndex++ ) {

             if ( fUseUnknownAccount )
                         dwUse = SidTypeUnknown;
             else
                         dwUse = pNames[dwIndex].Use;

             switch( dwUse ) {

             case SidTypeInvalid:
                cbOutputBuf += ((wcslen((LPWSTR)(AfpGlobals.wchInvalid))+1)
                                * sizeof(WCHAR));
                break;

             case SidTypeDeletedAccount:
                cbOutputBuf += ((wcslen((LPWSTR)(AfpGlobals.wchDeleted))+1)
                                * sizeof(WCHAR));
                break;

             case SidTypeUnknown:
                cbOutputBuf += ((wcslen((LPWSTR)(AfpGlobals.wchUnknown))+1)
                                * sizeof(WCHAR));
                break;

             case SidTypeWellKnownGroup:
                cbOutputBuf += (pNames[dwIndex].Name.Length+sizeof(WCHAR));
                break;

             case SidTypeDomain:
                cbOutputBuf +=
                ((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name.Length                + sizeof(WCHAR) );
                break;

             default:
                if ( ( pNames[dwIndex].DomainIndex != -1 ) &&   
                     ( pNames[dwIndex].Name.Buffer != NULL ) ) {

                    PSID                pDomainSid;
                    PUNICODE_STRING     pDomain;

                    pDomain =
                    &((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name);

                    pDomainSid =
                        (pDomainList->Domains[pNames[dwIndex].DomainIndex]).Sid;

                    if ( !RtlEqualSid( &AfpBuiltInSid, pDomainSid ))
                        cbOutputBuf += ( pDomain->Length + sizeof( TEXT('\\')));

                    cbOutputBuf += (pNames[dwIndex].Name.Length+sizeof(WCHAR));
                }
                else
                    dwRetCode = ERROR_NONE_MAPPED;
                break;
            }
        }

        pOutputBuf = (PAFP_DIRECTORY_INFO)MIDL_user_allocate( cbOutputBuf );

        if ( pOutputBuf == NULL ) {
                dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            AFP_PRINT(( "SFMSVC: AfpDirConvertSidsToNames, MIDL_user_allocate 1 failed with error (%ld)\n", dwRetCode));
                break;
        }

        ZeroMemory( (LPBYTE)pOutputBuf, cbOutputBuf );

        // Copy the fixed part of the structure.
        //
        CopyMemory( (LPBYTE)pOutputBuf,
                    (LPBYTE)pAfpDirInfo,
                    sizeof(AFP_DIRECTORY_INFO) );

        // Now we need to copy the names
        //
        for( dwIndex = 0,
             pbVariableData = (LPBYTE)((ULONG_PTR)pOutputBuf + cbOutputBuf);

             dwIndex < dwCount;

             dwIndex++ ) {

             if ( fUseUnknownAccount )
                         dwUse = SidTypeUnknown;
             else
                         dwUse = pNames[dwIndex].Use;

             switch( dwUse ) {

             case SidTypeInvalid:
                pbVariableData -= ((wcslen(AfpGlobals.wchInvalid)+1)
                                  * sizeof(WCHAR));
                wcscpy( (LPWSTR)pbVariableData, AfpGlobals.wchInvalid );
                break;

             case SidTypeDeletedAccount:
                pbVariableData -= ((wcslen(AfpGlobals.wchDeleted)+1)
                                  * sizeof(WCHAR));
                wcscpy( (LPWSTR)pbVariableData, AfpGlobals.wchDeleted );
                break;

             case SidTypeUnknown:
                pbVariableData -= ((wcslen(AfpGlobals.wchUnknown)+1)
                                  * sizeof(WCHAR));
                wcscpy( (LPWSTR)pbVariableData, AfpGlobals.wchUnknown );
                break;

             case SidTypeWellKnownGroup:
                pbVariableData -= (pNames[dwIndex].Name.Length+sizeof(WCHAR));
                CopyMemory( pbVariableData,
                            pNames[dwIndex].Name.Buffer,
                            pNames[dwIndex].Name.Length );
                break;

             case SidTypeDomain:
                cbOutputBuf +=
                ((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name.Length);
                CopyMemory( pbVariableData,
                ((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name.Buffer),
                ((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name.Length));
                break;

             default:

                {
                
                PSID pDomainSid;

                PUNICODE_STRING pDomain;

                pDomain =
                    &((pDomainList->Domains[pNames[dwIndex].DomainIndex]).Name);

                pDomainSid =
                       (pDomainList->Domains[pNames[dwIndex].DomainIndex]).Sid;

                pbVariableData -= ((pNames[dwIndex].Name.Length+sizeof(WCHAR)));

                pWchar = (WCHAR*)pbVariableData;

                // Copy the domain name if it is not BUILTIN
                //
                if ( !RtlEqualSid( &AfpBuiltInSid, pDomainSid ) ) {

                    pbVariableData -= ( pDomain->Length + sizeof( TEXT('\\')));

                    CopyMemory(pbVariableData,pDomain->Buffer,pDomain->Length);

                    wcscat((LPWSTR)pbVariableData, (LPWSTR)TEXT("\\"));

                    pWchar = (WCHAR*)pbVariableData;

                    pWchar += wcslen( (LPWSTR)pbVariableData );

                }

                CopyMemory( pWchar,
                            pNames[dwIndex].Name.Buffer,
                            pNames[dwIndex].Name.Length );
                }

            }

            // If this is the first time this loop executes then set the
            // owner.
            //
            if ( (dwIndex == 0) && (pAfpDirInfo->afpdir_owner != NULL) )
                pOutputBuf->afpdir_owner = (LPWSTR)pbVariableData;
            else
                pOutputBuf->afpdir_group = (LPWSTR)pbVariableData;
        }

    } while( FALSE );

    if ( pNames != NULL )
        LsaFreeMemory( pNames );

    if ( pDomainList != NULL )
        LsaFreeMemory( pDomainList );

    if ( hLsa != NULL )
        LsaClose( hLsa );

    if ( dwRetCode != NO_ERROR ) {

        AFP_PRINT(( "SFMSVC: AfpDirConvertSidsToNames, failed, error = (%ld)\n"
                    , dwRetCode));

        if ( pOutputBuf != NULL )
            MIDL_user_free( pOutputBuf );
    }
    else
    {
        *ppAfpConvertedDirInfo = pOutputBuf;
    }

    return( dwRetCode );
}

//**
//
// Call:        AfpGetDirInfo
//
// Returns:     NO_ERROR        - success
//              ERROR_NOT_ENOUGH_MEMORY
//              Non-zero returns from NtOpenFile, NtQuerySecurityObject,
//              NtQueryInformationFile.
//
// Description: Read the security descriptor for this directory and obtain the
//              SIDs for Owner and Primary group. Finally obtain Owner, Group
//              and World permissions.
DWORD
AfpGetDirInfo(
        LPWSTR                lpwsDirPath,
        PAFP_DIRECTORY_INFO * lppDirInfo
)
{
NTSTATUS                ntStatus;
DWORD                   dwSizeNeeded;
PBYTE                   pBuffer = NULL;
PBYTE                   pAbsBuffer = NULL;
PISECURITY_DESCRIPTOR   pSecDesc;
PBYTE                   pAbsSecDesc = NULL; // Used in conversion of
                                                                                                // sec descriptor to 
                                                                                                // absolute format
BOOL                    fSawOwnerAce = FALSE;
BOOL                    fSawGroupAce = FALSE;
BYTE                    bOwnerRights = 0;
BYTE                    bGroupRights = 0;
BYTE                    bWorldRights = 0;
FILE_BASIC_INFORMATION  FileBasicInfo;
IO_STATUS_BLOCK         IOStatusBlock;
OBJECT_ATTRIBUTES       ObjectAttributes;
UNICODE_STRING          DirectoryName;
HANDLE                  hDirectory;
PAFP_DIRECTORY_INFO     pAfpDir;
DWORD           dwAlignedSizeAfpDirInfo = sizeof (AFP_DIRECTORY_INFO);
LPWSTR                  pDirPath;
SID                     AfpSidNull = { 1, 1, SECURITY_NULL_SID_AUTHORITY,
                                             SECURITY_NULL_RID };
SID                     AfpSidWorld = { 1, 1, SECURITY_WORLD_SID_AUTHORITY,
                                              SECURITY_WORLD_RID };

    pDirPath = (LPWSTR)LocalAlloc( LPTR,
                                   ( STRLEN(lpwsDirPath) +
                                     STRLEN(TEXT("\\DOSDEVICES\\"))+1)
                                     * sizeof( WCHAR ) );
    if ( pDirPath == NULL )
        return( ERROR_NOT_ENOUGH_MEMORY );

    STRCPY( pDirPath, TEXT("\\DOSDEVICES\\") );
    STRCAT( pDirPath, lpwsDirPath );

    RtlInitUnicodeString( &DirectoryName, pDirPath );

    InitializeObjectAttributes( &ObjectAttributes,
                                &DirectoryName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntStatus = NtOpenFile( &hDirectory,
                           GENERIC_READ | READ_CONTROL | SYNCHRONIZE,
                           &ObjectAttributes,
                           &IOStatusBlock,
                           FILE_SHARE_READ |
                           FILE_SHARE_WRITE |
                           FILE_SHARE_DELETE,
                           FILE_DIRECTORY_FILE |
                           FILE_SYNCHRONOUS_IO_NONALERT );

    LocalFree( pDirPath );

    if ( !NT_SUCCESS( ntStatus ) )
        return( RtlNtStatusToDosError( ntStatus ) );
        
    // Read the security descriptor for this directory. First get the owner
    // and group security descriptors. We want to optimize on how much memory
    // we need to read this in. Its a pain to make a call just to get that.
    // So just make a guess. If that turns out to be short then do the exact
    // allocation.
    //
    dwSizeNeeded = 2048;

    do {

        if ( pBuffer != NULL )
            MIDL_user_free( pBuffer );

        if ((pBuffer = MIDL_user_allocate( dwSizeNeeded +
                                           dwAlignedSizeAfpDirInfo ))==NULL)
            return( ERROR_NOT_ENOUGH_MEMORY );

        ZeroMemory( pBuffer, dwSizeNeeded + dwAlignedSizeAfpDirInfo );

        pSecDesc = (PSECURITY_DESCRIPTOR)(pBuffer + dwAlignedSizeAfpDirInfo);

        ntStatus = NtQuerySecurityObject( hDirectory,
                                          OWNER_SECURITY_INFORMATION |
                                          GROUP_SECURITY_INFORMATION |
                                          DACL_SECURITY_INFORMATION,
                                          pSecDesc,
                                          dwSizeNeeded,
                                          &dwSizeNeeded);

    } while ((ntStatus != STATUS_SUCCESS) &&
             ((ntStatus == STATUS_BUFFER_OVERFLOW) ||
              (ntStatus == STATUS_BUFFER_TOO_SMALL) ||
              (ntStatus == STATUS_MORE_ENTRIES)));

    if (!NT_SUCCESS(ntStatus)) {
        NtClose( hDirectory );
        MIDL_user_free( pBuffer );
        return( RtlNtStatusToDosError( ntStatus ) );
    }

    pSecDesc = (PISECURITY_DESCRIPTOR)((PBYTE)pSecDesc);

    // If the security descriptor is in self-relative form, convert to absolute
    //
    if (pSecDesc->Control & SE_SELF_RELATIVE)
    {
                    NTSTATUS Status;

            DWORD dwAbsoluteSizeNeeded;

            AFP_PRINT (("AfpGetDirInfo: SE_SELF_RELATIVE security desc\n"));

                        // An absolute SD is not necessarily the same size as a relative
                        // SD, so an in-place conversion may not be possible.
                                                
                        dwAbsoluteSizeNeeded = dwSizeNeeded;            
            Status = RtlSelfRelativeToAbsoluteSD2(pSecDesc, &dwAbsoluteSizeNeeded);
            // Buffer will be small only for 64-bit

                        if (Status == STATUS_BUFFER_TOO_SMALL)
                        {
                                        // Allocate a new buffer in which to store the absolute
                                        // security descriptor, copy the contents of the relative
                                        // descriptor in and try again

                        if ((pAbsBuffer = MIDL_user_allocate( dwAbsoluteSizeNeeded +
                                            dwAlignedSizeAfpDirInfo ))==NULL)
                    {
                        Status = STATUS_NO_MEMORY;
                        AFP_PRINT (("AfpGetDirInfo: MIDL_user_allocate failed for pAbsBuffer\n"));
                    }
                    else
                    {

                            ZeroMemory( pAbsBuffer, dwAbsoluteSizeNeeded + dwAlignedSizeAfpDirInfo );

                            memcpy (pAbsBuffer, pBuffer, sizeof(AFP_DIRECTORY_INFO));

                                pAbsSecDesc = (PSECURITY_DESCRIPTOR)(pAbsBuffer + dwAlignedSizeAfpDirInfo);

                                                        RtlCopyMemory((VOID *)pAbsSecDesc, (VOID *)pSecDesc, dwSizeNeeded);
                                    
                            // All operations hereon will be performed on 
                            // pAbsBuffer. Free earlier memory

                            MIDL_user_free(pBuffer);
                            pBuffer = NULL;
                            pBuffer = pAbsBuffer;

                                                        Status = RtlSelfRelativeToAbsoluteSD2 (pAbsSecDesc,
                                                                                        &dwAbsoluteSizeNeeded);
                                                        if (NT_SUCCESS(Status))
                                                        {
                                                                        // We don't need relative form anymore, 
                                                                        // we will work with the Absolute form
                                                                        pSecDesc = (PISECURITY_DESCRIPTOR)pAbsSecDesc;
                                                        }
                                                        else
                                                        {
                                    AFP_PRINT (("AfpGetDirInfo: RtlSelfRelativeToAbsoluteSD2 2 failed with error %ld\n", Status));
                                                        }
                    }
                        }
            else
            {
                    AFP_PRINT (("AfpGetDirInfo: RtlSelfRelativeToAbsoluteSD2 failed with error %ld\n", Status));
            }

            if (!NT_SUCCESS(Status))
            {
                                AFP_PRINT (("AfpGetDirInfo: RtlSelfRelativeToAbsoluteSD2: returned error %lx\n", Status));
                                if (pBuffer != NULL)
                                {
                                    MIDL_user_free( pBuffer );
                                        pBuffer = NULL;
                                }
                                NtClose( hDirectory );
                        return( RtlNtStatusToDosError( ntStatus ));
            }
    }

    pAfpDir = (PAFP_DIRECTORY_INFO)pBuffer;


    // Walk through the ACL list and determine Owner/Group and World
    // permissions. For Owner and Group, if the specific ace's are not
    // present then they inherit the world permissions.
    //
    // A NULL Acl => All rights to everyone. An empty Acl on the other
    // hand => no access for anyone.
    //
    // Should we be checking for creater owner/creater group well-defined
    // sids or the Owner and Group fields in the security descriptor ?
    //
    bWorldRights = DIR_ACCESS_ALL;
    if (pSecDesc->Control & SE_DACL_PRESENT)
        bWorldRights = 0;

        
    if (pSecDesc->Dacl != NULL ) {

        DWORD               dwCount;
        PSID                pSid;
        PACL                pAcl;
        PACCESS_ALLOWED_ACE pAce;
        
        bWorldRights = 0;
        pAcl = pSecDesc->Dacl;
        pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAcl + sizeof(ACL));

        for ( dwCount = 0; dwCount < pSecDesc->Dacl->AceCount; dwCount++) {

            pSid = (PSID)(&pAce->SidStart);

            if ( (pSecDesc->Owner != NULL) &&
                 RtlEqualSid(pSid, pSecDesc->Owner ) ){

                AfpAccessMaskToAfpPermissions( bOwnerRights,
                                               pAce->Mask,
                                               pAce->Header.AceType);

                fSawOwnerAce = TRUE;
            }

            if ( ( pSecDesc->Group != NULL ) && 
                   RtlEqualSid(pSid, pSecDesc->Group)){

                AfpAccessMaskToAfpPermissions( bGroupRights,
                                               pAce->Mask,
                                               pAce->Header.AceType);
                fSawGroupAce = TRUE;
            }

            if (RtlEqualSid(pSid, (PSID)&AfpSidWorld)) {

                AfpAccessMaskToAfpPermissions( bWorldRights,
                                               pAce->Mask,
                                               pAce->Header.AceType);
            }

            pAce = (PACCESS_ALLOWED_ACE)((PBYTE)pAce + pAce->Header.AceSize);
        }

    }
        
    if (!fSawOwnerAce)
                bOwnerRights = bWorldRights;

        if (!fSawGroupAce)
                bGroupRights = bWorldRights;

        if (RtlEqualSid(pSecDesc->Group, &AfpSidNull) ||
                ((AfpGlobals.NtProductType != NtProductLanManNt) &&
                  RtlEqualSid(pSecDesc->Group, AfpGlobals.pSidNone)))
        {
                bGroupRights = 0;
                pSecDesc->Group = NULL;
        }

    ntStatus = NtQueryInformationFile( hDirectory,
                                       &IOStatusBlock,
                                       &FileBasicInfo,
                                       sizeof( FileBasicInfo ),
                                       FileBasicInformation );


    NtClose( hDirectory );

    if ( !NT_SUCCESS( ntStatus ) ) {
        MIDL_user_free( pBuffer );
        return( RtlNtStatusToDosError( ntStatus ) );
    }

    pAfpDir->afpdir_perms = (bOwnerRights << OWNER_RIGHTS_SHIFT) +
                            (bGroupRights << GROUP_RIGHTS_SHIFT) +
                            (bWorldRights << WORLD_RIGHTS_SHIFT);

    if ( FileBasicInfo.FileAttributes & FILE_ATTRIBUTE_READONLY )
        pAfpDir->afpdir_perms |= AFP_PERM_INHIBIT_MOVE_DELETE;


    pAfpDir->afpdir_owner = pSecDesc->Owner;
    pAfpDir->afpdir_group = pSecDesc->Group;
                    

    *lppDirInfo = pAfpDir;

        return( NO_ERROR );
}

//**
//
// Call:        AfpValidatePartition
//
// Returns:     NO_ERROR
//              non-zero returns from GetVolumeInformation.
//              AFPERR_UnsupportedFS
//              
//
// Description: Will check to see if the directory is in an NTFS/CDFS
//              partition not.
//
DWORD
AfpValidatePartition(
        IN     LPWSTR lpwsPath
)
{
WCHAR   wchDrive[5];
DWORD   dwMaxCompSize;
DWORD   dwFlags;
WCHAR   wchFileSystem[10];

    // Get the drive letter, : and backslash
    //
    ZeroMemory( wchDrive, sizeof( wchDrive ) );

    STRNCPY( wchDrive, lpwsPath, 3 );

    if ( !( GetVolumeInformation( (LPWSTR)wchDrive,
                                  NULL,
                                  0,
                                  NULL,
                                  &dwMaxCompSize,
                                  &dwFlags,
                                  (LPWSTR)wchFileSystem,
                                  sizeof( wchFileSystem ) ) ) ){
        return GetLastError();
    }

    if ( STRICMP( wchFileSystem, TEXT("CDFS") ) == 0 )
        return( (DWORD)AFPERR_SecurityNotSupported );

    if ( STRICMP( wchFileSystem, TEXT("NTFS") ) == 0 )
        return( NO_ERROR );
    else
        return( (DWORD)AFPERR_UnsupportedFS );
        
}

//**
//
// Call:        AfpAdminrDirectoryGetInfo
//
// Returns:     NO_ERROR
//              ERROR_ACCESS_DENIED
//              non-zero retunrs from I_DirectoryGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//              the AfpAdminDirectoryGetInfo function. The real work is done
//              by I_DirectoryGetInfo
//
DWORD
AfpAdminrDirectoryGetInfo(
        IN  AFP_SERVER_HANDLE    hServer,
        IN  LPWSTR               lpwsPath,
        OUT PAFP_DIRECTORY_INFO* ppAfpDirectoryInfo
)
{
DWORD   dwRetCode=0;
DWORD   dwAccessStatus=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrDirectoryGetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
            AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
                     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrDirectoryGetInfo, AfpSecObjAccessCheck returned error (%ld)\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    dwRetCode = I_DirectoryGetInfo( lpwsPath, ppAfpDirectoryInfo );

    return( dwRetCode );
}

//**
//
// Call:        I_DirectoryGetInfo
//
// Returns:     NO_ERROR
//
// Description: This does the real work to get the directory information.
//              The reason for this worker routine is so that it may be
//              called without the RPC handle and access checking by
//              AfpAdminVolumeAdd API.
//
DWORD
I_DirectoryGetInfo(
        IN LPWSTR                 lpwsPath,
        OUT PAFP_DIRECTORY_INFO * ppAfpDirectoryInfo
)
{
DWORD                           dwRetCode;
AFP_REQUEST_PACKET              AfpSrp;
AFP_DIRECTORY_INFO              AfpDirInfo;
PAFP_DIRECTORY_INFO             pAfpDirInfoSR;
PAFP_DIRECTORY_INFO             pAfpDirInfo;
DWORD                           cbAfpDirInfoSRSize;

    // The FSD expects AFP_VOLUME_INFO structure with only the dir path field
    // filled in.
    //
    AfpDirInfo.afpdir_path  = lpwsPath;
    AfpDirInfo.afpdir_owner = NULL;
    AfpDirInfo.afpdir_group = NULL;

    // Make buffer self relative.
    //
    if ( dwRetCode = AfpBufMakeFSDRequest(  (LPBYTE)&AfpDirInfo,
                                            0,
                                            AFP_DIRECTORY_STRUCT,
                                            (LPBYTE*)&pAfpDirInfoSR,
                                            &cbAfpDirInfoSRSize ) )
        return( dwRetCode );

    // Make IOCTL to get info
    //
    AfpSrp.dwRequestCode                = OP_DIRECTORY_GET_INFO;
    AfpSrp.dwApiType                    = AFP_API_TYPE_GETINFO;
    AfpSrp.Type.GetInfo.pInputBuf       = pAfpDirInfoSR;
    AfpSrp.Type.GetInfo.cbInputBufSize  = cbAfpDirInfoSRSize;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    LocalFree( pAfpDirInfoSR );

    if ( ( dwRetCode != ERROR_MORE_DATA ) &&
         ( dwRetCode != NO_ERROR ) &&
         ( dwRetCode != AFPERR_DirectoryNotInVolume ) )
        return( dwRetCode );

    // If the directory is not part of a volume, then there server does not
    // return any information back. So we have to do the work here.
    //
    if ( dwRetCode == AFPERR_DirectoryNotInVolume ) {

        // First check to see if the directory is in an NTFS/CDFS partition
        //
        if ( ( dwRetCode = AfpValidatePartition( AfpDirInfo.afpdir_path ))
                                                                != NO_ERROR )
            return( dwRetCode );

        if ( ( dwRetCode = AfpGetDirInfo( AfpDirInfo.afpdir_path,
                                          &pAfpDirInfo ) ) != NO_ERROR )
            return( dwRetCode );

        pAfpDirInfo->afpdir_in_volume = FALSE;
    }
    else {

        pAfpDirInfo = AfpSrp.Type.GetInfo.pOutputBuf;

        // Convert all offsets to pointers
        //
        AfpBufOffsetToPointer( (LPBYTE)pAfpDirInfo, 1, AFP_DIRECTORY_STRUCT );

        pAfpDirInfo->afpdir_in_volume = TRUE;
    }

    // Now convert the owner and group SIDs to names
    //
    dwRetCode = AfpDirConvertSidsToNames( pAfpDirInfo, ppAfpDirectoryInfo );
                                        
    MIDL_user_free( pAfpDirInfo );

    return( dwRetCode );
}

//**
//
// Call:        AfpDirMakeFSDRequest
//
// Returns:     NO_ERROR
//              non-zero returnd from LsaLookupNames
//              ERROR_NOT_ENOUGH_MEMORY
//
// Description: Given a AFP_DIRECTORY_INFO structure, will create a
//              self-relative buffer that is used to IOCTL the directory
//              information down to the FSD. If there are any SIDs names
//              (owner or group) they will be converted to their
//              SIDs.
//
DWORD
AfpDirMakeFSDRequest(
        IN     PAFP_DIRECTORY_INFO      pAfpDirectoryInfo,
        IN     DWORD                    dwParmNum,
        IN OUT PAFP_DIRECTORY_INFO *    ppAfpDirInfoSR,
        OUT    LPDWORD                  pcbAfpDirInfoSRSize )
{
UNICODE_STRING                  Names[2];
DWORD                           dwIndex     = 0;
DWORD                           dwCount     = 0;
PLSA_REFERENCED_DOMAIN_LIST     pDomainList = NULL;
PLSA_TRANSLATED_SID             pSids       = NULL;
LPBYTE                          pbVariableData;
NTSTATUS                        ntStatus;
LSA_HANDLE                      hLsa        = NULL;
SECURITY_QUALITY_OF_SERVICE     QOS;
OBJECT_ATTRIBUTES               ObjectAttributes;
PSID                            pDomainSid;
DWORD                           AuthCount;
PAFP_DIRECTORY_INFO             pAfpDirInfo;

    *pcbAfpDirInfoSRSize = (DWORD)(sizeof( SETINFOREQPKT ) +
                                       sizeof( AFP_DIRECTORY_INFO ) +
                                       (( wcslen( pAfpDirectoryInfo->afpdir_path ) + 1 )
                                        * sizeof(WCHAR)));

    // If the client wants to set the owner or the group
    // then we need to translate the names to sids
    //
    if ( ( dwParmNum & AFP_DIR_PARMNUM_OWNER ) ||
         ( dwParmNum & AFP_DIR_PARMNUM_GROUP ) )
    {

        // First open the LSA and obtain a handle to it.
        //
        QOS.Length              = sizeof( QOS );
        QOS.ImpersonationLevel  = SecurityImpersonation;
        QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        QOS.EffectiveOnly       = FALSE;

        InitializeObjectAttributes(     &ObjectAttributes,
                                        NULL,
                                        0L,
                                        NULL,
                                        NULL );

        ObjectAttributes.SecurityQualityOfService = &QOS;

        ntStatus = LsaOpenPolicy(       NULL,
                                        &ObjectAttributes,
                                        POLICY_LOOKUP_NAMES,
                                        &hLsa );

        if ( !NT_SUCCESS( ntStatus ))
        {
            return( RtlNtStatusToDosError( ntStatus ) );
        }

        //
            // Translate the owner
            //
        if ( dwParmNum & AFP_DIR_PARMNUM_OWNER )
        {
                RtlInitUnicodeString( &(Names[dwCount++]),
                                                  pAfpDirectoryInfo->afpdir_owner );
            }

        //
            // Translate the group
            //
        if ( dwParmNum & AFP_DIR_PARMNUM_GROUP )
        {
                RtlInitUnicodeString( &(Names[dwCount++]),
                                  pAfpDirectoryInfo->afpdir_group );
            }

        ntStatus = LsaLookupNames(hLsa, dwCount, Names, &pDomainList, &pSids);

        if ( !NT_SUCCESS( ntStatus ) )
        {
            LsaClose( hLsa );

                if ( ntStatus == STATUS_NONE_MAPPED )
            {
                        return( (DWORD)AFPERR_NoSuchUserGroup );
            }
                else
            {
                return( RtlNtStatusToDosError( ntStatus ) );
            }
            }

            for ( dwIndex = 0; dwIndex < dwCount; dwIndex++ )
        {

                if ( ( pSids[dwIndex].Use == SidTypeInvalid ) ||
                     ( pSids[dwIndex].Use == SidTypeUnknown ) ||
                     ( pSids[dwIndex].Use == SidTypeDomain )  ||
                     ( pSids[dwIndex].DomainIndex == -1 ) )
            {

                    LsaFreeMemory( pDomainList );
                    LsaClose( hLsa );

                        if ( ( pSids[dwIndex].Use == SidTypeUnknown ) ||
                             ( pSids[dwIndex].Use == SidTypeInvalid ) )
                {

                        LsaFreeMemory( pSids );

                    if ((dwParmNum & AFP_DIR_PARMNUM_OWNER)&&(dwIndex == 0 ))
                    {
                            return( (DWORD)AFPERR_NoSuchUser );
                    }
                            else
                    {
                            return( (DWORD)AFPERR_NoSuchGroup );
                    }
                        }
                        else
                {

                        LsaFreeMemory( pSids );
                
                        return( (DWORD)AFPERR_NoSuchUserGroup );
                        }
                }

                pDomainSid = pDomainList->Domains[pSids[dwIndex].DomainIndex].Sid;

            AuthCount = *RtlSubAuthorityCountSid( pDomainSid ) + 1;

                *pcbAfpDirInfoSRSize += RtlLengthRequiredSid(AuthCount);
            }
    }

    *ppAfpDirInfoSR=(PAFP_DIRECTORY_INFO)LocalAlloc(LPTR,*pcbAfpDirInfoSRSize);

    if ( *ppAfpDirInfoSR == NULL )
    {
            LsaFreeMemory( pDomainList );
            LsaFreeMemory( pSids );
            LsaClose( hLsa );
            return( ERROR_NOT_ENOUGH_MEMORY );
    }

    pbVariableData = (LPBYTE)((ULONG_PTR)(*ppAfpDirInfoSR) + *pcbAfpDirInfoSRSize);

    pAfpDirInfo = (PAFP_DIRECTORY_INFO)((ULONG_PTR)( *ppAfpDirInfoSR) +
                                                 sizeof( SETINFOREQPKT ));
    // First copy the fixed part
    //
    CopyMemory( pAfpDirInfo, pAfpDirectoryInfo, sizeof(AFP_DIRECTORY_INFO) );

    // Now copy the path
    //
    pbVariableData-=((wcslen(pAfpDirectoryInfo->afpdir_path)+1)*sizeof(WCHAR));

    wcscpy( (LPWSTR)pbVariableData, pAfpDirectoryInfo->afpdir_path );

    pAfpDirInfo->afpdir_path = (LPWSTR)pbVariableData;

    POINTER_TO_OFFSET( pAfpDirInfo->afpdir_path, pAfpDirInfo );

    // Now copy the SIDs if there are any to be copied
    //
    dwCount = 0;

    if ( dwParmNum & AFP_DIR_PARMNUM_OWNER )
    {

            pDomainSid = pDomainList->Domains[pSids[dwCount].DomainIndex].Sid;

        AuthCount = *RtlSubAuthorityCountSid( pDomainSid ) + 1;

            pbVariableData -= RtlLengthRequiredSid(AuthCount);
                        
        // Copy the Domain Sid.
        //
            RtlCopySid( RtlLengthRequiredSid(AuthCount),
                            (PSID)pbVariableData,
                            pDomainSid );


        // Append the Relative Id.
        //
        *RtlSubAuthorityCountSid( (PSID)pbVariableData ) += 1;
        *RtlSubAuthoritySid( (PSID)(pbVariableData), AuthCount - 1) =
                                        pSids[dwCount].RelativeId;

            pAfpDirInfo->afpdir_owner = (LPWSTR)pbVariableData;

        POINTER_TO_OFFSET( pAfpDirInfo->afpdir_owner, pAfpDirInfo );

            dwCount++;
    }

    if ( dwParmNum & AFP_DIR_PARMNUM_GROUP )
    {
            pDomainSid = pDomainList->Domains[pSids[dwCount].DomainIndex].Sid;

        AuthCount = *RtlSubAuthorityCountSid( pDomainSid ) + 1;

            pbVariableData -= RtlLengthRequiredSid(AuthCount);

        // Copy the Domain Sid.
        //
            RtlCopySid( RtlLengthRequiredSid(AuthCount),
                            (PSID)pbVariableData,
                            pDomainSid );

        // Append the Relative Id.
        //
        *RtlSubAuthorityCountSid( (PSID)pbVariableData ) += 1;
        *RtlSubAuthoritySid( (PSID)(pbVariableData), AuthCount - 1) =
                                                pSids[dwCount].RelativeId;

            pAfpDirInfo->afpdir_group = (LPWSTR)pbVariableData;

        POINTER_TO_OFFSET( pAfpDirInfo->afpdir_group, pAfpDirInfo );
    }

    LsaFreeMemory( pDomainList );
    LsaFreeMemory( pSids );
    LsaClose( hLsa );

    return( NO_ERROR );
}

//**
//
// Call:        AfpSetDirPermission
//
// Returns:     NO_ERROR
//              non-zero returns from AfpserverIOCtrl.
//
// Description: Given a directory path, will try to set permissions on it
//
DWORD
AfpSetDirPermission(
        IN LPWSTR               lpwsDirPath,
        IN PAFP_DIRECTORY_INFO  pAfpDirInfo,
        IN DWORD                dwParmNum
)
{
AFP_REQUEST_PACKET  AfpSrp;
PAFP_DIRECTORY_INFO pAfpDirInfoSR;
DWORD               cbAfpDirInfoSRSize;
DWORD               dwRetCode;


    pAfpDirInfo->afpdir_path = lpwsDirPath;

    // Make a self relative buffer and translate any names to SIDs
    //
    if ( dwRetCode = AfpDirMakeFSDRequest( pAfpDirInfo,
                                           dwParmNum,
                                           &pAfpDirInfoSR,
                                           &cbAfpDirInfoSRSize ) )
        return( dwRetCode );

    // Make IOCTL to set info
    //
    AfpSrp.dwRequestCode                = OP_DIRECTORY_SET_INFO;
    AfpSrp.dwApiType                    = AFP_API_TYPE_SETINFO;
    AfpSrp.Type.SetInfo.pInputBuf       = pAfpDirInfoSR;
    AfpSrp.Type.SetInfo.cbInputBufSize  = cbAfpDirInfoSRSize;
    AfpSrp.Type.SetInfo.dwParmNum       = dwParmNum;

    dwRetCode = AfpServerIOCtrl( &AfpSrp );

    LocalFree( pAfpDirInfoSR );

    return( dwRetCode );

}

//**
//
// Call:        AfpRecursePermissions
//
// Returns:     NO_ERROR
//              non-zero returns from FindFirstFile and FindNextFile.
//              non-zero returns from AfpSetDirPermissions
//              ERROR_NOT_ENOUGH_MEMORY.
//
// Description: Will recursively set permissions on a given directory.
//
DWORD
AfpRecursePermissions(
        IN HANDLE               hFile,
        IN LPWSTR               lpwsDirPath,
        IN PAFP_DIRECTORY_INFO  pAfpDirInfo,
        IN DWORD                dwParmNum
)
{
WIN32_FIND_DATA FileInfo;
DWORD           dwRetCode = NO_ERROR;
LPWSTR          lpwsPath;
WCHAR *         pwchPath;
DWORD           dwRetryCount;


    do  {

        lpwsPath = LocalAlloc(LPTR,
                              (STRLEN(lpwsDirPath)+MAX_PATH)*sizeof(WCHAR));

        if ( lpwsPath == NULL ) {
            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        STRCPY( lpwsPath, lpwsDirPath );

        if ( hFile != INVALID_HANDLE_VALUE ) {

            // Search for the next sub-directory
            //
            do {

                if ( !FindNextFile( hFile, &FileInfo ) ) {
                    dwRetCode = GetLastError();
                    AFP_PRINT( ( "AFPSVC_dir: Closing handle %x\n", hFile ) );
                    FindClose( hFile );
                    break;
                }

                if ( ( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                     (!( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM )) &&
                     (!( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )) &&
                     ( STRCMP( FileInfo.cFileName, TEXT(".") ) != 0 )     &&
                     ( STRCMP( FileInfo.cFileName, TEXT("..") ) != 0 ) )
                    break;
        
            } while( TRUE );

            if ( dwRetCode != NO_ERROR )
                break;

            pwchPath = wcsrchr( lpwsPath, TEXT('\\') );

            STRCPY( pwchPath+1, FileInfo.cFileName );

        }else{

            STRCAT( lpwsPath, TEXT("\\*") );

            hFile = FindFirstFile( lpwsPath, &FileInfo );

            // If there are no more files, we return to the previous
            // level in the recursion.
            //
            if ( hFile == INVALID_HANDLE_VALUE ){

                dwRetCode = GetLastError();
                break;
            }


            // Search for the first sub-directory
            //
            do {

                if ( ( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                     (!( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM )) &&
                     (!( FileInfo.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN )) &&
                     ( STRCMP( FileInfo.cFileName, TEXT(".") ) != 0 )     &&
                     ( STRCMP( FileInfo.cFileName, TEXT("..") ) != 0 ) )
                    break;

                if ( !FindNextFile( hFile, &FileInfo ) ) {
                    dwRetCode = GetLastError();

                    AFP_PRINT( ( "AFPSVC_dir: Closing handle %x\n", hFile ) );
                    FindClose( hFile );

                    break;
                }

            } while( TRUE );

            if ( dwRetCode != NO_ERROR )
                break;

            pwchPath = lpwsPath + STRLEN(lpwsDirPath) + 1;

            STRCPY( pwchPath, FileInfo.cFileName );
        }


        // Don't send the \\?\ down to the server
        pwchPath = lpwsPath + 4;

        // Set the information
        //
        dwRetryCount = 0;

        do
        {
            dwRetCode = AfpSetDirPermission( pwchPath, pAfpDirInfo, dwParmNum );

            if ( dwRetCode != ERROR_PATH_NOT_FOUND )
                break;

            Sleep( 1000 );

        } while( ++dwRetryCount < 4 );

        if ( dwRetCode != NO_ERROR )
            break;

        // Recurse on the directory
        //
        dwRetCode = AfpRecursePermissions(  hFile,
                                            lpwsPath,
                                            pAfpDirInfo,
                                            dwParmNum );


        if ( dwRetCode != NO_ERROR )
            break;

        // Recurse on the sub-directory
        //
        dwRetCode = AfpRecursePermissions(  INVALID_HANDLE_VALUE,
                                            lpwsPath,
                                            pAfpDirInfo,
                                            dwParmNum );
            break;

        if ( dwRetCode != NO_ERROR )
            break;


    } while( FALSE );

    if ( lpwsPath != (LPWSTR)NULL )
    {
        LocalFree( lpwsPath );
    }

    if ( dwRetCode == ERROR_NO_MORE_FILES )
    {
        dwRetCode = NO_ERROR;
    }

    return( dwRetCode );
}

//**
//
// Call:        AfpAdminrDirectorySetInfo
//
// Returns:     NO_ERROR
//              ERROR_ACCESS_DENIED
//              non-zero retunrs from I_DirectorySetInfo.
//
// Description: This routine communicates with the AFP FSD to implement
//              the AfpAdminDirectorySetInfo function. The real work is done
//              by I_DirectorySetInfo
//
DWORD
AfpAdminrDirectorySetInfo(
        IN  AFP_SERVER_HANDLE    hServer,
        IN  PAFP_DIRECTORY_INFO  pAfpDirectoryInfo,
        IN  DWORD                dwParmNum
)
{
DWORD               dwRetCode=0;
DWORD               dwAccessStatus=0;
                                        

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrDirectorySetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
            AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
                     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrDirectorySetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    dwRetCode = I_DirectorySetInfo( pAfpDirectoryInfo, dwParmNum );

    return( dwRetCode );
}

//**
//
// Call:        I_DirectorySetInfo
//
// Returns:     NO_ERROR
//              
//
// Description: This routine does the real work. The existance of this
//              worker is so that it may be called from the AfpAfdminVolmeAdd
//              API without the RPC handle and access checking.
//
DWORD
I_DirectorySetInfo(
        IN PAFP_DIRECTORY_INFO  pAfpDirectoryInfo,
        IN DWORD                dwParmNum
)
{
DWORD   dwRetCode;

    if (pAfpDirectoryInfo->afpdir_path == NULL)
    {
        AFP_PRINT(( "SFMSVC: I_DirectorySetInfo, pAfpDirectoryInfo->afpdir_path == NULL\n"));
        return ERROR_INVALID_DATA;
    }

    // Set the permissions on the directory
    //
    if ( ( dwRetCode = AfpSetDirPermission( pAfpDirectoryInfo->afpdir_path,
                                            pAfpDirectoryInfo,
                                            dwParmNum ) ) != NO_ERROR )
        return( dwRetCode );

    // If the user wants to set these permissions recursively
    //
    if ( pAfpDirectoryInfo->afpdir_perms & AFP_PERM_SET_SUBDIRS )
    {
        LPWSTR NTDirName;

        // We must use the \\?\ notation for the path in order to bypass
        // the Win32 path length limitation of 260 chars
        NTDirName = LocalAlloc( LPTR,
                                (STRLEN(pAfpDirectoryInfo->afpdir_path) + 4 + 1)
                                * sizeof(WCHAR));

        if (NTDirName == NULL)
            return( ERROR_NOT_ENOUGH_MEMORY );

        STRCPY( NTDirName, TEXT("\\\\?\\"));
        STRCAT( NTDirName, pAfpDirectoryInfo->afpdir_path);

        dwRetCode = AfpRecursePermissions( INVALID_HANDLE_VALUE,
                                           NTDirName,
                                           pAfpDirectoryInfo,
                                           dwParmNum );
        LocalFree( NTDirName );

    }

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\debug.c ===
/*****************************************************************************/
/**			 Microsoft LAN Manager				    **/
/**		   Copyright (C) Microsoft Corp., 1992			    **/
/*****************************************************************************/

//***
//	File Name:  debug.c
//
//	Function:   debug functions
//
//	History:
//
//	    05/21/92	Narendra Gidwani	- Original Version 1.0
//***


#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include "afpsvcp.h"

#include "debug.h"


#ifdef DBG
VOID
AfpAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber
    )
{
    BOOL ok;
    CHAR choice[16];
    DWORD bytes;
    DWORD error;

    AfpPrintf( "\nAssertion failed: %s\n  at line %ld of %s\n",
                FailedAssertion, LineNumber, FileName );
    do {
        AfpPrintf( "Break or Ignore [bi]? " );
        bytes = sizeof(choice);
        ok = ReadFile(
                GetStdHandle(STD_INPUT_HANDLE),
                &choice,
                bytes,
                &bytes,
                NULL
                );
        if ( ok ) {
            if ( toupper(choice[0]) == 'I' ) {
                break;
            }
            if ( toupper(choice[0]) == 'B' ) {
                DbgUserBreakPoint( );
            }
        } else {
            error = GetLastError( );
        }
    } while ( TRUE );

    return;

} // AfpAssert


VOID
AfpPrintf (
    char *Format,
    ...
    )

{
    va_list arglist;
    char OutputBuffer[1024];
    ULONG length;

    va_start( arglist, Format );

    vsprintf( OutputBuffer, Format, arglist );

    va_end( arglist );

    length = strlen( OutputBuffer );

    WriteFile( GetStdHandle(STD_OUTPUT_HANDLE), (LPVOID )OutputBuffer, length, &length, NULL );

} // AfpPrintf

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\conn.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	conn.c
//
// Description: This module contains support routines for the connection
//		category API's for the AFP server service. These routines
//		are called directly by the RPC runtime.
//
// History:
//		June 21,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:	AfpAdminrConnectionEnum
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlaGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminConnectionEnum function.
//
DWORD
AfpAdminrConnectionEnum(
	IN     AFP_SERVER_HANDLE      	hServer,
	IN OUT PCONN_INFO_CONTAINER     pInfoStruct,
	IN     DWORD			dwFilter,
	IN     DWORD			dwId,
	IN     DWORD 		  	dwPreferedMaximumLength,
	OUT    LPDWORD 		  	lpdwTotalEntries,
	OUT    LPDWORD 		  	lpdwResumeHandle
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrConnectionEnum, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrConnectionEnum, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_CONNECTION_ENUM;
    AfpSrp.dwApiType     		= AFP_API_TYPE_ENUM;
    AfpSrp.Type.Enum.cbOutputBufSize    = dwPreferedMaximumLength;

    if ( lpdwResumeHandle )
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = *lpdwResumeHandle;
    else
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = 0;

    AfpSrp.Type.Enum.EnumRequestPkt.erqp_Filter = dwFilter;
    AfpSrp.Type.Enum.EnumRequestPkt.erqp_ID = dwId;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *lpdwTotalEntries 	       = AfpSrp.Type.Enum.dwTotalAvail;
    pInfoStruct->pBuffer = (PAFP_CONNECTION_INFO)(AfpSrp.Type.Enum.pOutputBuf);
    pInfoStruct->dwEntriesRead = AfpSrp.Type.Enum.dwEntriesRead;

    if ( lpdwResumeHandle )
    	*lpdwResumeHandle = AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index;

    // Convert all offsets to pointers
    //
    AfpBufOffsetToPointer( (LPBYTE)(pInfoStruct->pBuffer),
			   pInfoStruct->dwEntriesRead,
			   AFP_CONNECTION_STRUCT );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrConnectionClose
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminConnectionClose function.
//
DWORD
AfpAdminrConnectionClose(
	IN AFP_SERVER_HANDLE 	hServer,
	IN DWORD 		dwConnectionId
)
{
AFP_REQUEST_PACKET  AfpSrp;
AFP_CONNECTION_INFO AfpConnInfo;
DWORD		    dwAccessStatus=0;
DWORD		    dwRetCode=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrConnectionClose, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrConnectionClose, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // The FSD expects an AFP_CONNECTION_INFO structure with only the id field
    // filled in.
    //
    AfpConnInfo.afpconn_id = dwConnectionId;

    // IOCTL the FSD to close the session
    //
    AfpSrp.dwRequestCode 		= OP_CONNECTION_CLOSE;
    AfpSrp.dwApiType     		= AFP_API_TYPE_DELETE;
    AfpSrp.Type.Delete.pInputBuf     	= &AfpConnInfo;
    AfpSrp.Type.Delete.cbInputBufSize   = sizeof(AFP_CONNECTION_INFO);

    return ( AfpServerIOCtrl( &AfpSrp ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\errorlog.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	errorlog.c
//
// Description:
//
// History:
//		May 11,1992.	NarenG		Created original version.
//		Feb  2,1993		SueA		Added routine to handle server's event
//									logging (from FSCTL by service)
//
#include "afpsvcp.h"

//**
//
// Call: 	AfpLogEvent
//
// Returns:	none
//
// Description:
//
VOID
AfpLogEvent(
    	IN DWORD    dwMessageId,
    	IN WORD     cNumberOfSubStrings,
        IN LPWSTR * plpwsSubStrings,
     	IN DWORD    dwErrorCode,
	IN WORD     wSeverity
)
{
HANDLE 	hLog;
PSID 	pSidUser = NULL;

    hLog = RegisterEventSource( NULL, AFP_SERVICE_NAME );

    AFP_ASSERT( hLog != NULL );

    // Log the error code specified
    //
    ReportEvent( hLog,
                 wSeverity,
                 0,            		// event category
                 dwMessageId,
                 pSidUser,
                 cNumberOfSubStrings,
                 sizeof(DWORD),
                 plpwsSubStrings,
                 (PVOID)&dwErrorCode
                 );

    DeregisterEventSource( hLog );

    AFP_PRINT( ("AFPSVC_Errorlog: dwMessageId = %d\n", dwMessageId ));

    return;
}

//**
//
// Call: 	AfpLogServerEvent
//
// Returns:	none
//
// Description: Gets an error or audit log packet from the Afp Server FSD
// and does the event logging on its behalf.  (See AfpServerHelper thread
// routine in srvrhlpr.c)
//
VOID
AfpLogServerEvent(
	IN	PAFP_FSD_CMD_PKT	pAfpFsdCmd
)
{
	PAFP_EVENTLOG_DESC	pEventData;
	HANDLE			 	hLog;
	PSID 				pSidUser = NULL;
	int					i;

    hLog = RegisterEventSource( NULL, AFP_SERVICE_NAME );

    AFP_ASSERT( hLog != NULL );

	pEventData = &pAfpFsdCmd->Data.Eventlog;

	OFFSET_TO_POINTER(pEventData->ppStrings, pAfpFsdCmd);

	for (i = 0; i < pEventData->StringCount; i++)
	{
		OFFSET_TO_POINTER(pEventData->ppStrings[i], pAfpFsdCmd);
	}

	OFFSET_TO_POINTER(pEventData->pDumpData, pAfpFsdCmd);

	ReportEvent( hLog,
				 pEventData->EventType,
				 0,						// event category
				 pEventData->MsgID,
				 pSidUser,
				 pEventData->StringCount,
				 pEventData->DumpDataLen,
				 pEventData->ppStrings,
				 pEventData->pDumpData
			   );

    DeregisterEventSource( hLog );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\init.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	init.c
//
// Description: This module contains code to intialize and de-initialize
//		the AFP Server, RPC server, the security object and
//		other global vriables.
//
// History:
//		May 11,1992.	NarenG		Created original version.
//
//
#include "afpsvcp.h"

// Prototypes of functions used only within this module.
//
DWORD
AfpInitServerVolumes(
	VOID
);

DWORD
AfpInitServerParameters(
	VOID
);

DWORD
AfpInitServerIcons(
	VOID
);

DWORD
AfpInitETCMaps(
	VOID
);

DWORD
AfpInitRPC(
	VOID
);

DWORD
AfpInitServerDomainOffsets(
	VOID
);

VOID
AfpTerminateRPC(
	VOID
);


VOID
AfpIniLsa(
	VOID
);


BOOL
IsAfpGuestAccountEnabled(
    VOID
);

//**
//
// Call:	AfpInitialize
//
// Returns:	NO_ERROR
//
// Description:	Will do all server intialization.
//		1) Create the security object.
//		2) Set up the server for RPC.
//		3) Open all the registry keys that store AFP data.
//		4) Get the handle to the FSD.
//		5) Get default server parameters
//		6) It will initialize the AFP Server with volume, ETC, icon
//		   and server parameter information.
//		7) IOCTL the FSD to start the server.
//
DWORD
AfpInitialize(
	VOID
)
{
AFP_REQUEST_PACKET	AfpRequestPkt;
DWORD			dwRetCode;
BOOL			fFirstThread;
DWORD			nThreads;




    // Load strings from resource file
    //
    if (( !LoadString( GetModuleHandle( NULL ), 1, AfpGlobals.wchUnknown, 100 ))
	||
        ( !LoadString( GetModuleHandle( NULL ), 2, AfpGlobals.wchInvalid, 100 ))
	||
        ( !LoadString( GetModuleHandle( NULL ), 3, AfpGlobals.wchDeleted, 100 ))
	||
        ( !LoadString( GetModuleHandle( NULL ), 4, AfpGlobals.wchDefTCComment,
    		       AFP_ETC_COMMENT_LEN+1 )))
	AfpLogEvent( AFPLOG_CANT_LOAD_RESOURCE, 0, NULL,
		     GetLastError(), EVENTLOG_WARNING_TYPE );

    //
    // Create the security object
    //
    if ( dwRetCode = AfpSecObjCreate() ) {
	AfpLogEvent( AFPLOG_CANT_CREATE_SECOBJ, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
	return( dwRetCode );
    }

    // Initialize the server to accept RPC calls
    //
    if ( dwRetCode = AfpInitRPC() ) {
	AfpLogEvent( AFPLOG_CANT_INIT_RPC, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
	return( dwRetCode );
    }

    AfpGlobals.dwServerState |= AFPSTATE_RPC_STARTED;

    // Open the registry keys where AFP Server information is stored
    //
    if ( dwRetCode = AfpRegOpen() ) {
	AfpLogEvent( AFPLOG_CANT_OPEN_REGKEY, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
	return( dwRetCode );
    }

    AfpGlobals.ServiceStatus.dwCheckPoint++;
    AfpAnnounceServiceStatus();

    // Open and load the AFP Server FSD and obtain a handle to it
    //
    if ( dwRetCode = AfpFSDLoad() ) {
	AfpLogEvent( AFPLOG_CANT_LOAD_FSD, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
	return( dwRetCode );
    }

    AfpGlobals.dwServerState |= AFPSTATE_FSD_LOADED;

    if ( dwRetCode = AfpFSDOpen( &(AfpGlobals.hFSD) ) ) {
	AfpLogEvent( AFPLOG_CANT_OPEN_FSD, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
	return( dwRetCode );
    }

	// Query the product type of server.
	//
	AfpGlobals.pSidNone = NULL;
	RtlGetNtProductType ( &(AfpGlobals.NtProductType) );

    // Create the event object for the server helper thread.
    //
    if ( (AfpGlobals.heventSrvrHlprThread =
					CreateEvent( NULL, FALSE, FALSE, NULL ) ) == NULL){
	AfpLogEvent( AFPLOG_CANT_START, 0, NULL, GetLastError(),
		     EVENTLOG_ERROR_TYPE );
	return( GetLastError() );
    }

    // Create the event object for the server helper thread termination.
    //
    if ( (AfpGlobals.heventSrvrHlprThreadTerminate =
                                CreateEvent( NULL, FALSE, FALSE, NULL ) ) == NULL){
	AfpLogEvent( AFPLOG_CANT_START, 0, NULL, GetLastError(),
		     EVENTLOG_ERROR_TYPE );
	return( GetLastError() );
    }

    // Create the event object for the "special case" unblocking of server helper thread
    //
    if ( (AfpGlobals.heventSrvrHlprSpecial =
                                CreateEvent( NULL, FALSE, FALSE, NULL ) ) == NULL){
	AfpLogEvent( AFPLOG_CANT_START, 0, NULL, GetLastError(),
		     EVENTLOG_ERROR_TYPE );
	return( GetLastError() );
    }

    // Create server helper threads. The parameter indicates if this is the
    // first thread that is being created.
    //
    fFirstThread = TRUE;
    nThreads     = 0;

    do {

    	if ( ( dwRetCode = AfpCreateServerHelperThread( fFirstThread ) )
								!= NO_ERROR ) {
	    AfpLogEvent( AFPLOG_CANT_CREATE_SRVRHLPR, 0, NULL,
			 dwRetCode, EVENTLOG_ERROR_TYPE );

	    if ( fFirstThread ) {
	        AfpLogEvent( AFPLOG_CANT_START, 0, NULL,
			     dwRetCode, EVENTLOG_ERROR_TYPE );
	    	return( dwRetCode );
	    }
        }

        // Wait for the server helper thread to indicate if it successfully
        // initialized itself.
        //
        WaitForSingleObject( AfpGlobals.heventSrvrHlprThread, INFINITE );

        if ( AfpGlobals.dwSrvrHlprCode != NO_ERROR ) {
	        AfpLogEvent(AFPLOG_CANT_INIT_SRVRHLPR,
			            0,	
			            NULL,
			            AfpGlobals.dwSrvrHlprCode,
			            EVENTLOG_ERROR_TYPE );

	        if ( fFirstThread )
            {
    	        AFP_PRINT( ( "SFMSVC: can't start macfile, first thread failed %ld\n",
                        AfpGlobals.dwSrvrHlprCode));	
	            AfpLogEvent( AFPLOG_CANT_START, 0, NULL, dwRetCode,
			                 EVENTLOG_ERROR_TYPE );
            	return( AfpGlobals.dwSrvrHlprCode );
	        }
    	}

	    fFirstThread = FALSE;

    }while( ++nThreads < NUM_SECURITY_UTILITY_THREADS );

    // Read in server parameters from the registry and intialize the
    // server with them.
    //
    if ( dwRetCode = AfpInitServerParameters())
    {
        AFP_PRINT( ( "SFMSVC: AfpInitServerParameters failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_INIT_SRVR_PARAMS, 0, NULL, dwRetCode,EVENTLOG_ERROR_TYPE );
	    return( dwRetCode );
    }


    AfpGlobals.ServiceStatus.dwCheckPoint++;
    AfpAnnounceServiceStatus();


    // Read in the ETC Mappings and initialize the AFP Server with them
    // Also create a private cache of this information.
    //
    if ( dwRetCode = AfpInitETCMaps() )
    {
        AFP_PRINT( ( "SFMSVC: AfpInitETCMaps failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_INIT_ETCINFO, 0, NULL, dwRetCode,EVENTLOG_ERROR_TYPE );
	    return( dwRetCode );
    }


    if ( dwRetCode = AfpInitServerIcons() )
    {
        AFP_PRINT( ( "SFMSVC: AfpInitServerIcons failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_INIT_ICONS, 0, NULL, dwRetCode ,EVENTLOG_ERROR_TYPE );
	    return( dwRetCode );
    }


    AfpGlobals.ServiceStatus.dwCheckPoint++;
    AfpAnnounceServiceStatus();

    // Read in any volumes and initialize the server with them
    //
    if ( dwRetCode = AfpInitServerVolumes() )
    {
        AFP_PRINT( ( "SFMSVC: AfpInitServerVolumes failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_INIT_VOLUMES, 0, NULL, dwRetCode,EVENTLOG_ERROR_TYPE );
	    return( dwRetCode );
    }


    // Create mutex objects around volume operations to avoid simultaneous
    // writing in the registry.
    //
    if ( (AfpGlobals.hmutexVolume = CreateMutex( NULL, FALSE, NULL ) ) == NULL)
    {
        AFP_PRINT( ( "SFMSVC: CreateMutex failed in AfpInitialize\n"));
	    AfpLogEvent( AFPLOG_CANT_START, 0, NULL, dwRetCode,EVENTLOG_ERROR_TYPE );
	    return( GetLastError() );
    }

    // Create mutex objects around ETCMap operations.
    //
    if ( (AfpGlobals.hmutexETCMap = CreateMutex( NULL, FALSE, NULL ) ) == NULL)
    {
        AFP_PRINT( ( "SFMSVC: CreateMutex 2 failed in AfpInitialize\n"));
	    AfpLogEvent( AFPLOG_CANT_START, 0, NULL, GetLastError(),EVENTLOG_ERROR_TYPE );
	    return( GetLastError() );
    }

    // OK we are all set to go so lets tell the AFP Server to start
    //
    AfpRequestPkt.dwRequestCode = OP_SERVICE_START;
    AfpRequestPkt.dwApiType     = AFP_API_TYPE_COMMAND;

     AFP_PRINT( ( "SFMSVC: ioctling sfmsrv to start\n"));

    if ( dwRetCode = AfpServerIOCtrl( &AfpRequestPkt ) )
    {
        AFP_PRINT( ( "SFMSVC: AfpServerIOCtrl to start sfmsrv failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_START,0,NULL,dwRetCode,EVENTLOG_ERROR_TYPE);
	    return( dwRetCode );
    }


    AfpIniLsa();

    return( NO_ERROR );

}

//**
//
// Call:	AfpTerminate
//
// Returns:	none.
//
// Description: This procedure will shut down the server, and do any
//		clean up if required.
//
VOID
AfpTerminate(
	VOID
)
{
AFP_REQUEST_PACKET	AfpRequestPkt;
DWORD			dwRetCode;


    // If the FSD was loaded
    //
    if ( AfpGlobals.dwServerState & AFPSTATE_FSD_LOADED ) {

    	// Tell the server to shut down
    	//
    	AfpRequestPkt.dwRequestCode = OP_SERVICE_STOP;
    	AfpRequestPkt.dwApiType     = AFP_API_TYPE_COMMAND;

    	if ( dwRetCode = AfpServerIOCtrl( &AfpRequestPkt ) )
	    AfpLogEvent( AFPLOG_CANT_STOP, 0, NULL,
			 dwRetCode, EVENTLOG_ERROR_TYPE );
    }

    AfpGlobals.ServiceStatus.dwCheckPoint++;
    AfpAnnounceServiceStatus();

    // Try to close the FSD
    //
    if ( AfpGlobals.hFSD != NULL )
    {
    	if ( dwRetCode = AfpFSDClose( AfpGlobals.hFSD ) )
        {
	        AfpLogEvent( AFPLOG_CANT_STOP, 0, NULL,
			                dwRetCode, EVENTLOG_ERROR_TYPE );
        }

        // Try to unload the FSD
        //
        if ( dwRetCode = AfpFSDUnload() )
        {
	        AfpLogEvent( AFPLOG_CANT_STOP, 0, NULL,
                            dwRetCode, EVENTLOG_ERROR_TYPE);
        }
    }
	
    AfpGlobals.ServiceStatus.dwCheckPoint++;
    AfpAnnounceServiceStatus();

    // Delete the security object.
    //
    AfpSecObjDelete();

    // De-initialize the RPC server
    //
    AfpTerminateRPC();

    // Close the registry keys.
    //
    AfpRegClose();

	// Free the pSidNone if we allocated it for standalone
	//
	if (AfpGlobals.pSidNone != NULL)
	{
		LocalFree(AfpGlobals.pSidNone);
		AfpGlobals.pSidNone = NULL;
	}

    if (SfmLsaHandle != NULL)
    {
        LsaDeregisterLogonProcess( SfmLsaHandle );
        SfmLsaHandle = NULL;
    }

    return;

}

//**
//
// Call:	AfpInitServerParameters
//
// Returns:	NO_ERROR
//		non-zero return codes from the IOCTL or other system calls.
//
// Description: This procedure will set default values for parameters. It
//		will then call AfpRegServerGetInfo to override these defaults
//		with any parameters that may be stored in the registry. It
//		will then initialize the FSD with these parameters.
//
DWORD
AfpInitServerParameters(
	VOID
)
{
AFP_SERVER_INFO	 	AfpServerInfo;
DWORD			cbServerNameSize;
DWORD			dwRetCode;
AFP_REQUEST_PACKET	AfpRequestPkt;


    // Initialize all the server parameters with defaults
    //
    cbServerNameSize = sizeof( AfpGlobals.wchServerName );
    if ( !GetComputerName( AfpGlobals.wchServerName, &cbServerNameSize ) )
	return( GetLastError() );

    AfpGlobals.dwMaxSessions     	= AFP_DEF_MAXSESSIONS;
    AfpGlobals.dwServerOptions   	= AFP_DEF_SRVOPTIONS;
    AfpGlobals.wchLoginMsg[0]    	= TEXT('\0');
    AfpGlobals.dwMaxPagedMem		= AFP_DEF_MAXPAGEDMEM;
    AfpGlobals.dwMaxNonPagedMem		= AFP_DEF_MAXNONPAGEDMEM;

    // Read in any server parameters in the registry. Registry parameters
    // will override the defaults set above.
    //
    if ( dwRetCode = AfpRegServerGetInfo() )
	return( dwRetCode );

    if (IsAfpGuestAccountEnabled())
    {
        AfpGlobals.dwServerOptions |= AFP_SRVROPT_GUESTLOGONALLOWED;
    }
    else
    {
        AfpGlobals.dwServerOptions &= ~AFP_SRVROPT_GUESTLOGONALLOWED;
    }

    // Get the path to the codepage
    //
    if ( dwRetCode = AfpRegServerGetCodePagePath() )
	return( dwRetCode );

    // Set up server info structure
    //
    AfpServerInfo.afpsrv_name 		  = AfpGlobals.wchServerName;
    AfpServerInfo.afpsrv_max_sessions     = AfpGlobals.dwMaxSessions;
    AfpServerInfo.afpsrv_options          = AfpGlobals.dwServerOptions;
	if (AfpGlobals.NtProductType != NtProductLanManNt)
	{
		AfpServerInfo.afpsrv_options |= AFP_SRVROPT_STANDALONE;
	}
	AfpServerInfo.afpsrv_login_msg        = AfpGlobals.wchLoginMsg;
    AfpServerInfo.afpsrv_max_paged_mem    = AfpGlobals.dwMaxPagedMem;
    AfpServerInfo.afpsrv_max_nonpaged_mem = AfpGlobals.dwMaxNonPagedMem;
    AfpServerInfo.afpsrv_codepage	  = AfpGlobals.wchCodePagePath;

    // Make this buffer self-relative.
    //
    if ( dwRetCode = AfpBufMakeFSDRequest(
			(LPBYTE)&AfpServerInfo,
			sizeof(SETINFOREQPKT),
			AFP_SERVER_STRUCT,
			(LPBYTE*)&(AfpRequestPkt.Type.SetInfo.pInputBuf),
		        &(AfpRequestPkt.Type.SetInfo.cbInputBufSize)))
    {
	return( dwRetCode );
    }

    // IOCTL the FSD to set the server parameters
    //
    AfpRequestPkt.dwRequestCode 	 = OP_SERVER_SET_INFO;
    AfpRequestPkt.dwApiType 		 = AFP_API_TYPE_SETINFO;
    AfpRequestPkt.Type.SetInfo.dwParmNum = AFP_SERVER_PARMNUM_ALL;

    dwRetCode = AfpServerIOCtrl( &AfpRequestPkt );

    LocalFree( AfpRequestPkt.Type.SetInfo.pInputBuf );

    return( dwRetCode );

}

//**
//
// Call:	AfpInitServerVolumes
//
// Returns:	NO_ERROR - success
//		ERROR_NOT_ENOUGH_MEMORY
//		non-zero return codes from registry apis.
//
// Description: This procedure will read in a volume at a time from the
//		registry, and then register this volume with the server.
//		This procedure will only return fatal errors that will
//		require that the service to fail initialization. All other
//		error will be logged by this routine. All returns from the
//		the FSD are treated as non-fatal.
//
DWORD
AfpInitServerVolumes(
	VOID
)
{
DWORD		 	dwRetCode;
LPWSTR  	 	lpwsValName, lpwsSrcIconPath, lpwsDstIconPath;
DWORD		 	dwMaxValNameLen;
DWORD			dwValNameBufSize;
DWORD		 	dwNumValues;
DWORD		 	dwMaxValueDataSize;
DWORD		 	dwIndex;
DWORD		 	dwType;
DWORD			dwBufSize;
AFP_REQUEST_PACKET	AfpRequestPkt;
AFP_VOLUME_INFO 	VolumeInfo;
LPBYTE			lpbMultiSz;
LPBYTE			lpbFSDBuf;
DWORD			dwLength;
DWORD			dwCount;
WCHAR wchServerIconFile[AFPSERVER_VOLUME_ICON_FILE_SIZE] = AFPSERVER_VOLUME_ICON_FILE;
BOOLEAN			fCopiedIcon;
DWORD			dwLastDstCharIndex;

    // Find out the size of the largest data value and the largest
    // value name.
    //
    if ( dwRetCode = AfpRegGetKeyInfo( AfpGlobals.hkeyVolumesList,
				       &dwMaxValNameLen,
				       &dwNumValues,
				       &dwMaxValueDataSize
				      ))
   	return( dwRetCode );

    // If there are no volumes to add then simply return
    //
    if ( dwNumValues == 0 )
	return( NO_ERROR );
	
    if (( lpwsValName = (LPWSTR)LocalAlloc( LPTR, dwMaxValNameLen ) ) == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    if ((lpbMultiSz = (LPBYTE)LocalAlloc( LPTR, dwMaxValueDataSize )) == NULL ){
	LocalFree( lpwsValName );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    if (( lpwsSrcIconPath = (LPWSTR)LocalAlloc( LPTR, MAX_PATH * sizeof(WCHAR) ) ) == NULL )
	{
		LocalFree( lpwsValName );
		LocalFree( lpbMultiSz );
		return( ERROR_NOT_ENOUGH_MEMORY );
	}

    if (( lpwsDstIconPath = (LPWSTR)LocalAlloc( LPTR, (MAX_PATH +
						   AFPSERVER_VOLUME_ICON_FILE_SIZE + 1 +
						   (sizeof(AFPSERVER_RESOURCE_STREAM)/sizeof(WCHAR))) *
						   sizeof(WCHAR)) ) == NULL )
	{
		LocalFree( lpwsValName );
		LocalFree( lpbMultiSz );
		LocalFree( lpwsSrcIconPath );
		return( ERROR_NOT_ENOUGH_MEMORY );
	}

	// Construct a path to the NTSFM volume custom icon
	//
	*lpwsSrcIconPath = 0;
	if ( GetSystemDirectory( lpwsSrcIconPath, MAX_PATH * sizeof(WCHAR) ))
	{
		wcscat( lpwsSrcIconPath, AFP_DEF_VOLICON_SRCNAME );
	}


    for ( dwIndex 		= 0,
	  dwBufSize 		= dwMaxValueDataSize,
	  dwValNameBufSize 	= dwMaxValNameLen;

	  dwIndex < dwNumValues;

	  dwIndex++,
	  dwBufSize 		= dwMaxValueDataSize,
	  dwValNameBufSize 	= dwMaxValNameLen ) {
				
	ZeroMemory( lpbMultiSz, dwBufSize );

	// Get the volume info from the registry in multi-sz form.
  	//
	if ( dwRetCode = RegEnumValue( AfpGlobals.hkeyVolumesList,
				       dwIndex,
				       lpwsValName,
				       &dwValNameBufSize,
				       NULL,
				       &dwType,
				       lpbMultiSz,
				       &dwBufSize
				      ))
	    break;

	// Parse the mult sz and extract info into volume info structure
 	//
	if ( dwRetCode = AfpBufParseMultiSz(
					AFP_VOLUME_STRUCT,
					lpbMultiSz,
					(LPBYTE)&VolumeInfo ) ) {

	    // If this volume contained invalid registry information then log
	    // it and store the volume name in the list of invalid volumes.
	    //
	    AfpAddInvalidVolume( lpwsValName, NULL );

	    AfpLogEvent( AFPLOG_INVALID_VOL_REG,1,&lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Insert the volume name viz. the valuename
	//
	VolumeInfo.afpvol_name = lpwsValName;

	// Validate the volume info structure
	//
	if ( !IsAfpVolumeInfoValid( AFP_VALIDATE_ALL_FIELDS, &VolumeInfo ) ) {

	    // If this volume contained invalid registry information then log
	    // it and store the volume name in the list of invalid volumes.
	    //
	    AfpAddInvalidVolume( lpwsValName, NULL );

	    AfpLogEvent( AFPLOG_INVALID_VOL_REG,1,&lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// If there is a password then decrypt it
	//
	if ( VolumeInfo.afpvol_password != (LPWSTR)NULL ){
	
	    dwLength = STRLEN( VolumeInfo.afpvol_password );

	    for ( dwCount = 0; dwCount < dwLength; dwCount++ )
	    	VolumeInfo.afpvol_password[dwCount] ^= 0xF000;
	}

	//
	// Construct a path to the destination volume "Icon<0D>" file
	//

	fCopiedIcon = FALSE;

	wcscpy( lpwsDstIconPath, VolumeInfo.afpvol_path );
	if (lpwsDstIconPath[wcslen(lpwsDstIconPath) - 1] != TEXT('\\'))
	{
		wcscat( lpwsDstIconPath, TEXT("\\") );
	}
	wcscat( lpwsDstIconPath, wchServerIconFile );
	// Keep track of end of name without the resource fork tacked on
	//
	dwLastDstCharIndex = wcslen(lpwsDstIconPath);
	wcscat( lpwsDstIconPath, AFPSERVER_RESOURCE_STREAM );

	// Copy the icon file to the root of the volume (do not overwrite)
	//
	if ((fCopiedIcon = (BOOLEAN)CopyFile( lpwsSrcIconPath, lpwsDstIconPath, TRUE )) ||
	   (GetLastError() == ERROR_FILE_EXISTS))
	{
		VolumeInfo.afpvol_props_mask |= AFP_VOLUME_HAS_CUSTOM_ICON;

	    // Make sure the file is hidden
		SetFileAttributes( lpwsDstIconPath,
						   FILE_ATTRIBUTE_HIDDEN |
						    FILE_ATTRIBUTE_ARCHIVE );
	}


	// Make this a self relative buffer
	//
	if ( dwRetCode = AfpBufMakeFSDRequest(
					(LPBYTE)&VolumeInfo,
					0,
					AFP_VOLUME_STRUCT,
					&lpbFSDBuf,
					&dwBufSize
				        ))
	    break;

	// Initialize the FSD with this volume
	//
    	AfpRequestPkt.dwRequestCode 	      = OP_VOLUME_ADD;
        AfpRequestPkt.dwApiType 	      = AFP_API_TYPE_ADD;	
    	AfpRequestPkt.Type.Add.pInputBuf      = lpbFSDBuf;
    	AfpRequestPkt.Type.Add.cbInputBufSize = dwBufSize;

    	dwRetCode = AfpServerIOCtrl( &AfpRequestPkt );

		if ( dwRetCode ) {
	
			// If this volume could not be added by the FSD then we errorlog
			// this and insert this volume into the list of invalid volumes.
			//
			AfpAddInvalidVolume( lpwsValName, VolumeInfo.afpvol_path );
	
			AfpLogEvent( AFPLOG_CANT_ADD_VOL, 1, &lpwsValName,
				 dwRetCode, EVENTLOG_WARNING_TYPE );
			dwRetCode = NO_ERROR;

			// Delete the icon file we just copied if the volume add failed
			//
			if ( fCopiedIcon )
			{
				// Truncate the resource fork name so we delete the whole file
				lpwsDstIconPath[dwLastDstCharIndex] = 0;
				DeleteFile( lpwsDstIconPath );
			}

		}
	
    	LocalFree( lpbFSDBuf );
    }

    LocalFree( lpwsValName );
    LocalFree( lpbMultiSz );
	LocalFree( lpwsSrcIconPath );
	LocalFree( lpwsDstIconPath );

    return( dwRetCode );
}

//**
//
// Call:	AfpInitETCMaps
//
// Returns:	NO_ERROR	success
//		non-zero returns from the IOCTL
//		non-zero returns from the AfpRegXXX apis.
//		
//
// Description: This routine will read in all the type/creators and extensions
//		from the registry and store them in a cache. It will then
//		create a list of mappings from the cache and then IOCTL the
//		the FSD to add them. If the default is not in the registry,
//		a hardcoded one is used. All non-zero returns from this
//		routine are fatal. All non-fatal errors will be logged.
//		
//
DWORD
AfpInitETCMaps(
	VOID
)
{
DWORD 			dwRetCode;
AFP_REQUEST_PACKET	AfpSrp;
AFP_EXTENSION		DefExtension;
AFP_TYPE_CREATOR	DefTypeCreator;
BYTE			bDefaultETC[sizeof(ETCMAPINFO2)+sizeof(SETINFOREQPKT)];
PAFP_TYPE_CREATOR	pTypeCreator;
DWORD	    		dwNumTypeCreators;
AFP_TYPE_CREATOR	AfpTypeCreatorKey;

    // Get all type-creators from the registry and store them in a global cache.
    //
    if ( dwRetCode = AfpRegTypeCreatorEnum() )
	return( dwRetCode );

    // Get all extensions from the registry and store them in a global cache.
    //
    if ( dwRetCode = AfpRegExtensionEnum() )
	return( dwRetCode );

    // If there are no mappings do not IOCTL.
    //
    if ( AfpGlobals.AfpETCMapInfo.afpetc_num_extensions > 0 ) {

    	// IOCTL the FSD to Add these mappings
    	//
    	AfpSrp.dwRequestCode   = OP_SERVER_ADD_ETC;
    	AfpSrp.dwApiType       = AFP_API_TYPE_ADD;

    	// Make a buffer with the type/creator mappings in the form as required
    	// by the FSD
    	//
    	if ( dwRetCode = AfpBufMakeFSDETCMappings(
				(PSRVETCPKT*)&(AfpSrp.Type.Add.pInputBuf),
    				&(AfpSrp.Type.Add.cbInputBufSize) ) )
	    return( dwRetCode );

	if ( AfpSrp.Type.Add.cbInputBufSize > 0 ) {

    	    dwRetCode = AfpServerIOCtrl( &AfpSrp );

    	    LocalFree( AfpSrp.Type.Add.pInputBuf );

	    if ( dwRetCode )
	    	return( dwRetCode );
	}
	else
    	    LocalFree( AfpSrp.Type.Add.pInputBuf );
    }

    // Check to see if the default type/creator is in the registry
    //
    AfpTypeCreatorKey.afptc_id = AFP_DEF_TCID;

    dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators;

    pTypeCreator = _lfind(  &AfpTypeCreatorKey,
			   AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
			   (unsigned int *)&dwNumTypeCreators,
			   sizeof(AFP_TYPE_CREATOR),
			   AfpLCompareTypeCreator );
	
    // If the default is not in the registry use the hard-coded defaults.
    //
    if ( pTypeCreator == NULL ) {

        STRCPY( DefTypeCreator.afptc_type,    AFP_DEF_TYPE );
        STRCPY( DefTypeCreator.afptc_creator, AFP_DEF_CREATOR );
        STRCPY( DefTypeCreator.afptc_comment, AfpGlobals.wchDefTCComment );
        DefTypeCreator.afptc_id = AFP_DEF_TCID;
    }
    else
	DefTypeCreator = *pTypeCreator;

    ZeroMemory( (LPBYTE)(DefExtension.afpe_extension),
		AFP_FIELD_SIZE( AFP_EXTENSION, afpe_extension) );

    STRCPY( DefExtension.afpe_extension,  AFP_DEF_EXTENSION_W );

    AfpBufCopyFSDETCMapInfo( &DefTypeCreator,
			     &DefExtension,
 			     (PETCMAPINFO2)(bDefaultETC+sizeof(SETINFOREQPKT)));

    // IOCTL the FSD to set the default
    //
    AfpSrp.dwRequestCode  		= OP_SERVER_SET_ETC;
    AfpSrp.dwApiType 	  		= AFP_API_TYPE_SETINFO;
    AfpSrp.Type.SetInfo.pInputBuf	= bDefaultETC;
    AfpSrp.Type.SetInfo.cbInputBufSize  = sizeof( bDefaultETC );

    if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
	return( dwRetCode );

    // If the default was not in the cache, add it now.
    //
    if ( pTypeCreator == NULL ) {

        // Grow the cache size by one entry.
        //
        pTypeCreator      = AfpGlobals.AfpETCMapInfo.afpetc_type_creator;
        dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators;

        pTypeCreator = (PAFP_TYPE_CREATOR)LocalReAlloc(
				 pTypeCreator,
    			         (dwNumTypeCreators+1)*sizeof(AFP_TYPE_CREATOR),
			         LMEM_MOVEABLE );

        if ( pTypeCreator == NULL )
	    return( ERROR_NOT_ENOUGH_MEMORY );

    	pTypeCreator[dwNumTypeCreators++] = DefTypeCreator;

    	AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators = dwNumTypeCreators;
    	AfpGlobals.AfpETCMapInfo.afpetc_type_creator      = pTypeCreator;

        // Sort the table
        //
        qsort(  pTypeCreator,
	   	dwNumTypeCreators,
	   	sizeof(AFP_TYPE_CREATOR),
	   	AfpBCompareTypeCreator );
    }

    return( NO_ERROR );

}

//**
//
// Call:	AfpInitServerIcons
//
// Returns:	NO_ERROR - success
//		ERROR_NOT_ENOUGH_MEMORY
//		non-zero return codes from registry apis.
//
// Description: This procedure will read in an icon at a time from the
//		registry, and then register this icon with the server.
//		This procedure will only return fatal errors that will
//		require that the service fail initialization. All other
//		error will be logged by this routine. All returns from the
//		the FSD are treated as non-fatal.
//
//
DWORD
AfpInitServerIcons(
	VOID
)
{
DWORD		 	dwRetCode;
LPWSTR  	 	lpwsValName;
DWORD		 	dwMaxValNameLen;
DWORD		 	dwNumValues;
DWORD		 	dwMaxValueDataSize;
DWORD		 	dwIndex;
DWORD		 	dwType;
DWORD			dwBufSize;
DWORD			dwValNameBufSize;
AFP_REQUEST_PACKET	AfpRequestPkt;
LPBYTE			lpbMultiSz;
AFP_ICON_INFO 	        IconInfo;

    // Find out the size of the largest data value and the largest
    // value name.
    //
    if ( dwRetCode = AfpRegGetKeyInfo( AfpGlobals.hkeyIcons,
				       &dwMaxValNameLen,
				       &dwNumValues,
				       &dwMaxValueDataSize
					))
   	return( dwRetCode );
	
    // If there are no icons in the registry then simply return
    //
    if ( dwNumValues == 0 )
	return( NO_ERROR );

    if (( lpwsValName = (LPWSTR)LocalAlloc( LPTR, dwMaxValNameLen )) == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    if (( lpbMultiSz = (LPBYTE)LocalAlloc( LPTR, dwMaxValueDataSize))== NULL){
	LocalFree( lpwsValName );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    for ( dwIndex 		= 0,
	  dwBufSize 		= dwMaxValueDataSize,
	  dwValNameBufSize 	= dwMaxValNameLen;

	  dwIndex < dwNumValues;

	  dwIndex++,
	  dwBufSize 		= dwMaxValueDataSize,
	  dwValNameBufSize 	= dwMaxValNameLen ) {
				
	ZeroMemory( lpbMultiSz, dwBufSize );

	// Get the icon from the registry.
  	//
	if ( dwRetCode = RegEnumValue(  AfpGlobals.hkeyIcons,
				  	dwIndex,
				  	lpwsValName,
				  	&dwValNameBufSize,
				  	NULL,
				  	&dwType,
				  	lpbMultiSz,
				        &dwBufSize
				     ))
	    break;
				
	// Parse the mult sz and extract info into icon info structure
 	//
	if ( dwRetCode = AfpBufParseMultiSz(
					AFP_ICON_STRUCT,
					lpbMultiSz,
					(LPBYTE)&IconInfo
				      )) {
	    AfpLogEvent( AFPLOG_CANT_ADD_ICON, 1, &lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	if ( dwRetCode = AfpBufUnicodeToNibble((LPWSTR)IconInfo.afpicon_data)){
	    AfpLogEvent( AFPLOG_CANT_ADD_ICON, 1, &lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Validate the icon info structure
	//
	if ( !IsAfpIconValid( &IconInfo ) ) {
	    AfpLogEvent( AFPLOG_CANT_ADD_ICON, 1, &lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Copy the icon info into an FSD icon structure.
	// NOTE: Re-use lpbMultiSz to store the FSD Icon structure. We know
	// it is big enough, because the FSD icon structure HAS to be
	// smaller than the MultiSz that contains the same information.
	//
	AfpBufMakeFSDIcon( &IconInfo, lpbMultiSz, &dwBufSize );

	// Initialize the FSD with this icon
	//
    	AfpRequestPkt.dwRequestCode             = OP_SERVER_ADD_ICON;
        AfpRequestPkt.dwApiType     	        = AFP_API_TYPE_ADD;	
    	AfpRequestPkt.Type.Add.pInputBuf 	= lpbMultiSz;
    	AfpRequestPkt.Type.Add.cbInputBufSize   = dwBufSize;

    	if ( dwRetCode = AfpServerIOCtrl( &AfpRequestPkt ) ) {
	    AfpLogEvent( AFPLOG_CANT_ADD_ICON, 1, &lpwsValName,
			 dwRetCode, EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}
    }

    LocalFree( lpwsValName );
    LocalFree( lpbMultiSz );

    return( dwRetCode );
}

//**
//
// Call:	AfpInitRPC
//
// Returns:	NO_ERROR	- success
//		ERROR_NOT_ENOUGH_MEMORY
//		nonzero returns from RPC APIs
//                 	RpcServerRegisterIf()
//                 	RpcServerUseProtseqEp()
//
// Description: Starts an RPC Server, adds the address (or port/pipe),
//		and adds the interface (dispatch table).
//
DWORD
AfpInitRPC( VOID )
{
RPC_STATUS           RpcStatus;
LPWSTR               lpwsEndpoint = NULL;
BOOL                 Bool;


    // We need to concatenate \pipe\ to the front of the interface name.
    //
    lpwsEndpoint = (LPWSTR)LocalAlloc( LPTR, sizeof(NT_PIPE_PREFIX) +
				((STRLEN(AFP_SERVICE_NAME)+1)*sizeof(WCHAR)));
    if ( lpwsEndpoint == NULL)
       return( ERROR_NOT_ENOUGH_MEMORY );

    STRCPY( lpwsEndpoint, NT_PIPE_PREFIX );
    STRCAT( lpwsEndpoint, AFP_SERVICE_NAME );


    // Ignore the second argument for now.
    //
    RpcStatus = RpcServerUseProtseqEpW( TEXT("ncacn_np"), 	
					                    10, 	
				                        lpwsEndpoint,
				                        NULL );

    if ( RpcStatus != RPC_S_OK )
    {
	    LocalFree( lpwsEndpoint );
     	return( I_RpcMapWin32Status( RpcStatus ) );
    }

    RpcStatus = RpcServerRegisterIf( afpsvc_v0_0_s_ifspec, 0, 0);

    LocalFree( lpwsEndpoint );

    if ( RpcStatus == RPC_S_OK )
	return( NO_ERROR );
    else
     	return( I_RpcMapWin32Status( RpcStatus ) );

}

//**
//
// Call: 	AfpTerminateRPC
//
// Returns:	none
//
// Description: Deletes the interface.
//
VOID
AfpTerminateRPC(
	VOID
)
{
    RPC_STATUS           RpcStatus;

    if ( AfpGlobals.dwServerState & AFPSTATE_RPC_STARTED )
    {
    	RpcStatus = RpcServerUnregisterIf( afpsvc_v0_0_s_ifspec, 0, 0 );

        if (RpcStatus != RPC_S_OK)
        {
            AFP_PRINT(("RpcServerUnregisterIf failed %ld\n", I_RpcMapWin32Status( RpcStatus )));
        }
    }

    return;
}

//**
//
// Call:	AfpIniLsa
//
// Returns:	none.
//
// Description: This procedure will register our process with LSA, needed for
//              change-password
//
VOID
AfpIniLsa(
	VOID
)
{
    NTSTATUS                ntstatus;
    STRING                  LsaName;
    LSA_OPERATIONAL_MODE    SecurityMode;


    //
    // register with Lsa as a logon process
    //

    RtlInitString(&LsaName, LOGON_PROCESS_NAME);

    ntstatus = LsaRegisterLogonProcess(&LsaName, &SfmLsaHandle, &SecurityMode);
    if (ntstatus != STATUS_SUCCESS)
    {
        SfmLsaHandle = NULL;
        return;
    }

    //
    // call Lsa to get the MSV1_0's pkg id, which we need during logon
    //

    RtlInitString(&LsaName, MSV1_0_PACKAGE_NAME);

    ntstatus = LsaLookupAuthenticationPackage(SfmLsaHandle, &LsaName, &SfmAuthPkgId);
    if (ntstatus != STATUS_SUCCESS)
    {
        LsaDeregisterLogonProcess( SfmLsaHandle );
        SfmLsaHandle = NULL;
        return;
    }

    return;

}


BOOL
IsAfpGuestAccountEnabled(
    VOID
)
{

    NTSTATUS                    rc;
    LSA_HANDLE                  hLsa;
    PPOLICY_ACCOUNT_DOMAIN_INFO pAcctDomainInfo;
    SECURITY_QUALITY_OF_SERVICE QOS;
    OBJECT_ATTRIBUTES           ObjAttribs;
    NTSTATUS                    status;
    SAM_HANDLE                  SamHandle;
    SAM_HANDLE                  DomainHandle;
    PUSER_ACCOUNT_INFORMATION   UserAccount = NULL;
    BOOLEAN                     fGuestEnabled;
    SAMPR_HANDLE                GuestAcctHandle;



    // for now
    fGuestEnabled = FALSE;

    //
    // Open the LSA and obtain a handle to it.
    //
    QOS.Length = sizeof(QOS);
    QOS.ImpersonationLevel = SecurityImpersonation;
    QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QOS.EffectiveOnly = FALSE;

    InitializeObjectAttributes(&ObjAttribs, NULL, 0L, NULL, NULL);

    ObjAttribs.SecurityQualityOfService = &QOS;

    status = LsaOpenPolicy(NULL,
                           &ObjAttribs,
                           POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES,
                           &hLsa);

    if (!NT_SUCCESS(status))
    {
        AFP_PRINT(("LsaOpenPolicy failed %lx\n",status));
        return(fGuestEnabled);
    }

    //
    // get the Domain Sid for the local domain: we'll need it very shortly
    //
    rc = LsaQueryInformationPolicy(hLsa,
                                   PolicyAccountDomainInformation,
                                   (PVOID) &pAcctDomainInfo);
    if (!NT_SUCCESS(rc))
    {
        AFP_PRINT(("InitLSA: LsaQueryInfo... failed (%lx)\n",rc));
        LsaClose(hLsa);
        return(fGuestEnabled);
    }

    InitializeObjectAttributes(&ObjAttribs, NULL, 0L, NULL, NULL);

    status = SamConnect(NULL, &SamHandle, MAXIMUM_ALLOWED, &ObjAttribs);

    if (!NT_SUCCESS(status))
    {
        AFP_PRINT(("SamConnect failed %lx\n",status));
        LsaFreeMemory(pAcctDomainInfo);
        LsaClose(hLsa);
        return(fGuestEnabled);
    }

    status = SamOpenDomain(
                SamHandle,
                MAXIMUM_ALLOWED,
                pAcctDomainInfo->DomainSid,
                &DomainHandle);

    LsaFreeMemory(pAcctDomainInfo);

    LsaClose(hLsa);

    if (!NT_SUCCESS(status))
    {
        AFP_PRINT(("SamOpenDomain failed %lx\n",status));
        SamCloseHandle(SamHandle);
        return(fGuestEnabled);
    }

    status = SamOpenUser(
                DomainHandle,
                MAXIMUM_ALLOWED,
                DOMAIN_USER_RID_GUEST,
                &GuestAcctHandle);

    if (!NT_SUCCESS(status))
    {
        AFP_PRINT(("SamOpenUser failed %lx\n",status));
        SamCloseHandle(SamHandle);
        return(fGuestEnabled);
    }

    status = SamQueryInformationUser(
                GuestAcctHandle,
                UserAccountInformation,
                (PVOID *) &UserAccount );

    if (!NT_SUCCESS(status))
    {
        AFP_PRINT(("SamQueryInformationUser failed %lx\n",status));
        SamCloseHandle(SamHandle);
        return(fGuestEnabled);
    }

    //
    // now, see if the guest account is enabled.
    //
    if (!(UserAccount->UserAccountControl & USER_ACCOUNT_DISABLED))
    {
        fGuestEnabled = TRUE;
    }

    SamFreeMemory(UserAccount);

    SamCloseHandle(GuestAcctHandle);

    SamCloseHandle(SamHandle);

    return(fGuestEnabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\file.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	file.c
//
// Description: This module contains support routines for the file
//		category API's for the AFP server service. These routines
//		are called by the RPC runtime.
//
// History:
//		June 21,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:	AfpAdminrFileEnum
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminFileEnum function.
//
DWORD
AfpAdminrFileEnum(
	IN     AFP_SERVER_HANDLE    hServer,
	IN OUT PFILE_INFO_CONTAINER pInfoStruct,
	IN     DWORD 		    dwPreferedMaximumLength,
	OUT    LPDWORD 		    lpdwTotalEntries,
	OUT    LPDWORD 		    lpdwResumeHandle
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFileEnum, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFileEnum, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_FORK_ENUM;
    AfpSrp.dwApiType     		= AFP_API_TYPE_ENUM;
    AfpSrp.Type.Enum.cbOutputBufSize    = dwPreferedMaximumLength;

    if ( lpdwResumeHandle )
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = *lpdwResumeHandle;
    else
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = 0;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *lpdwTotalEntries 		= AfpSrp.Type.Enum.dwTotalAvail;
    pInfoStruct->pBuffer        = (PAFP_FILE_INFO)(AfpSrp.Type.Enum.pOutputBuf);
    pInfoStruct->dwEntriesRead  = AfpSrp.Type.Enum.dwEntriesRead;

    if ( lpdwResumeHandle )
    	*lpdwResumeHandle = AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index;

    // Convert all offsets to pointers
    //
    AfpBufOffsetToPointer( (LPBYTE)(pInfoStruct->pBuffer),
			   pInfoStruct->dwEntriesRead,
			   AFP_FILE_STRUCT );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrFileClose
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminFileClose function.
//
DWORD
AfpAdminrFileClose(
	IN AFP_SERVER_HANDLE 	hServer,
	IN DWORD 		dwFileId
)
{
AFP_REQUEST_PACKET AfpSrp;
AFP_FILE_INFO	   AfpFileInfo;
DWORD		   dwAccessStatus=0;
DWORD		   dwRetCode=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFileClose, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFileClose, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // The FSD expects an AFP_FILE_INFO structure with only the id field
    // filled in.
    //
    AfpFileInfo.afpfile_id = dwFileId;

    // IOCTL the FSD to close the file
    //
    AfpSrp.dwRequestCode 		= OP_FORK_CLOSE;
    AfpSrp.dwApiType     		= AFP_API_TYPE_DELETE;
    AfpSrp.Type.Delete.pInputBuf     	= &AfpFileInfo;
    AfpSrp.Type.Delete.cbInputBufSize   = sizeof(AFP_FILE_INFO);

    return ( AfpServerIOCtrl( &AfpSrp ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\finder.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	finder.c
//
// Description: This module contains support routines for the finder
//		category API's for the AFP server service
//
// History:
//		Sept 30,1993.	NarenG		Created original version.
//
#include "afpsvcp.h"

BOOL
IsTargetNTFS(
	IN     LPWSTR lpwsPath
);

DWORD
CopyStream(
    	IN	HANDLE hSrc,
	IN	HANDLE hDst
);

#define	AFP_RESC_STREAM			TEXT(":AFP_Resource")

//**
//
// Call:	AfpAdminrFinderSetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminFinderSetInfo function.
//
DWORD
AfpAdminrFinderSetInfo(
	IN AFP_SERVER_HANDLE 	hServer,
	IN LPWSTR     		pType,
	IN LPWSTR     		pCreator,
	IN LPWSTR     		pData,
	IN LPWSTR     		pResource,
	IN LPWSTR     		pTarget,
	IN DWORD		dwParmNum
)
{
AFP_REQUEST_PACKET 	AfpSrp;
DWORD			dwRetCode = NO_ERROR, dwRetryCount = 0;
AFP_FINDER_INFO	AfpFinderInfo;
LPBYTE 			pAfpFinderInfoSR = NULL;
DWORD			cbAfpFinderInfoSRSize;
DWORD		    dwAccessStatus=0;
HANDLE			hTarget = INVALID_HANDLE_VALUE;
HANDLE		    hDataSrc = INVALID_HANDLE_VALUE;
HANDLE		    hResourceSrc = INVALID_HANDLE_VALUE;
LPWSTR			lpwsResourceFork;
BOOLEAN			fCreatedFile = FALSE;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFinderSetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
		AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
					 dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrFinderSetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    if ( wcsstr( pTarget, (LPWSTR)TEXT(":\\") ) == NULL )
		return( ERROR_INVALID_NAME );

    if ( !IsTargetNTFS( pTarget ) )
		return( (DWORD)AFPERR_UnsupportedFS );


	//
	// Impersonate the client while we read/write the fork data
	//
	dwRetCode = RpcImpersonateClient( NULL );
	if ( dwRetCode != RPC_S_OK )
	{
		return(I_RpcMapWin32Status( dwRetCode ));
	}

    // open the data source file if one was specified
    //
	if ( STRLEN( pData ) > 0 ){
		hDataSrc = CreateFile(pData, GENERIC_READ, FILE_SHARE_READ, NULL,
					  OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	
		if (hDataSrc == INVALID_HANDLE_VALUE) {
			RpcRevertToSelf();
			return( GetLastError() );
		}
	
	
		// open the target file's data stream if the file exists,
		// otherwise create the file
		//
		hTarget = CreateFile(pTarget, GENERIC_WRITE, FILE_SHARE_READ, NULL,
					 OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	
		if (hTarget == INVALID_HANDLE_VALUE) {
			dwRetCode = GetLastError();
			CloseHandle(hDataSrc);
			RpcRevertToSelf();
			return( dwRetCode );
			}

        // Figure out if we just created a new file
	    if (GetLastError() == 0)
		{
			fCreatedFile = TRUE;
		}

		SetFilePointer(hTarget,0,NULL,FILE_BEGIN);
		SetEndOfFile(hTarget);
	
		// Read the source data and write it to target data stream
		//
		SetLastError(NO_ERROR);
		dwRetCode = CopyStream(hDataSrc, hTarget);
	
		CloseHandle(hDataSrc);
		CloseHandle(hTarget);
	
		if (dwRetCode != NO_ERROR) {
			RpcRevertToSelf();
			return( dwRetCode );
		}
	}

    // open the resource source file if one was specified
    //
    if ( STRLEN( pResource ) > 0 ) {

		hResourceSrc = CreateFile( pResource, GENERIC_READ, FILE_SHARE_READ,
					   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
					   NULL);
	
		if (hResourceSrc == INVALID_HANDLE_VALUE) {
			RpcRevertToSelf();
			return( GetLastError() );
		}
	
		lpwsResourceFork = LocalAlloc( LPTR,
						   (STRLEN(pTarget)+
							STRLEN(AFP_RESC_STREAM)+1)
						* sizeof( WCHAR ) );
	
		if ( lpwsResourceFork == NULL ) {
			CloseHandle(hResourceSrc);
			RpcRevertToSelf();
			return( ERROR_NOT_ENOUGH_MEMORY );
		}
	
		// Open the target resource fork
		//
		STRCPY(lpwsResourceFork, pTarget );
		STRCAT(lpwsResourceFork, AFP_RESC_STREAM);
	
		hTarget = CreateFile(lpwsResourceFork, GENERIC_WRITE, FILE_SHARE_READ,
					 NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	
		if (hTarget == INVALID_HANDLE_VALUE) {
			dwRetCode = GetLastError();
			LocalFree( lpwsResourceFork );
			CloseHandle(hResourceSrc);
			RpcRevertToSelf();
			return( dwRetCode );
		}
	
		LocalFree( lpwsResourceFork );
	
		// Assume we created a new file (datafork) in the process, there is
		// no way to tell for sure since creating a new resource fork will
		// not tell us whether or not the datafork already existed or not
		fCreatedFile = TRUE;

		// Read the source resource and write it to target resource stream
		//
		SetLastError(NO_ERROR);
		dwRetCode = CopyStream(hResourceSrc, hTarget);
	
		CloseHandle(hResourceSrc);
		CloseHandle(hTarget);
	
		if (dwRetCode != NO_ERROR) {
			RpcRevertToSelf();
			return( dwRetCode );
		}
	
	}

	//
	// Revert back to LocalSystem context
	//
	RpcRevertToSelf();

    if ( dwParmNum & ( AFP_FD_PARMNUM_TYPE | AFP_FD_PARMNUM_CREATOR ) ){

		dwRetCode = NO_ERROR;
	
		AfpFinderInfo.afpfd_path = pTarget;
	
		if ( dwParmNum & AFP_FD_PARMNUM_TYPE )
			STRCPY( AfpFinderInfo.afpfd_type, pType );
			else
			AfpFinderInfo.afpfd_type[0] = TEXT( '\0' );
		
		if ( dwParmNum & AFP_FD_PARMNUM_CREATOR )
			STRCPY( AfpFinderInfo.afpfd_creator, pCreator );
		else
			AfpFinderInfo.afpfd_creator[0] = TEXT( '\0' );
	
		// Make this buffer self-relative.
		//
		if ( dwRetCode = AfpBufMakeFSDRequest((LPBYTE)&AfpFinderInfo,
						   sizeof(SETINFOREQPKT),
						   AFP_FINDER_STRUCT,
						   &pAfpFinderInfoSR,
						   &cbAfpFinderInfoSRSize ))
	        return( dwRetCode );

		// Make IOCTL to set info
		//
		AfpSrp.dwRequestCode 		    = OP_FINDER_SET;
		AfpSrp.dwApiType     		    = AFP_API_TYPE_SETINFO;
		AfpSrp.Type.SetInfo.pInputBuf       = pAfpFinderInfoSR;
		AfpSrp.Type.SetInfo.cbInputBufSize  = cbAfpFinderInfoSRSize;
		AfpSrp.Type.SetInfo.dwParmNum       = dwParmNum;


		// Since there will be a delay between the time the change
		// notify comes into the server for the new file, and the
		// time it is actually processed by the server, we need to
		// put in a delay and retry to give the server a chance to
		// cache the new file
		if (fCreatedFile)
		{
			Sleep( 2000 );
		}

		do
		{

			dwRetCode = AfpServerIOCtrl( &AfpSrp );

			if (dwRetCode != ERROR_PATH_NOT_FOUND)
			{
				break;
			}

			Sleep( 2000);

		} while ( ++dwRetryCount < 4 );

		LocalFree( pAfpFinderInfoSR );
	
    }

    return( dwRetCode );
}



DWORD
CopyStream(
    	IN	HANDLE hSrc,
	IN	HANDLE hDst
)
{
    DWORD bytesread, byteswritten, Status = NO_ERROR;
    BYTE		Buffer[1024 * 16];

    do
    {
	bytesread = byteswritten = 0;

	// read from src, write to dst
	//
	if (ReadFile(hSrc, Buffer, sizeof(Buffer), &bytesread, NULL))
	{
	    if (bytesread == 0)
	    {
		break;
	    }
	}
	else
	{
	    Status = GetLastError();
	    break;
	}

	if (!WriteFile(hDst, Buffer, bytesread, &byteswritten, NULL))
	{
	    Status = GetLastError();
	    break;
	}

    } while (TRUE);

    return(Status);
}

BOOL
IsTargetNTFS(
	IN     LPWSTR lpwsPath
)
{
WCHAR	wchDrive[5];
DWORD   dwMaxCompSize;
DWORD   dwFlags;
WCHAR   wchFileSystem[10];

    // Get the drive letter, : and backslash
    //
    ZeroMemory( wchDrive, sizeof( wchDrive ) );

    STRNCPY( wchDrive, lpwsPath, 3 );

    if ( !( GetVolumeInformation( (LPWSTR)wchDrive,
			          NULL,
			          0,
 			          NULL,
			          &dwMaxCompSize,
			          &dwFlags,
				  (LPWSTR)wchFileSystem,
				  sizeof( wchFileSystem ) ) ) ){
	return( FALSE );
    }

    if ( STRICMP( wchFileSystem, TEXT("NTFS") ) == 0 )
   	return( TRUE );
    else
	return( FALSE );
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\ioctl.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	ioctl.h
//
// Description: Contains the security function prototypes and
//		defintion of AFP_REQUEST_PACKET data structure.
//
// History:
//	May 11,1992.	NarenG		Created original version.
//

#ifndef _IOCTL_
#define _IOCTL_

// This is the size of the buffer sent to the FSD to enumerate entities.
//
#define AFP_INITIAL_BUFFER_SIZE 	4096


// This value in a heuristic to calculate the amount of memory required to
// hold all enumerated entities. This value represents the avg size of all
// entities.
//
#define AFP_AVG_STRUCT_SIZE			512

// Id's of the various API types
//
typedef enum _AFP_API_TYPE {

    AFP_API_TYPE_COMMAND,
    AFP_API_TYPE_SETINFO,
    AFP_API_TYPE_DELETE,
    AFP_API_TYPE_GETINFO,
    AFP_API_TYPE_ENUM,
    AFP_API_TYPE_ADD

} AFP_API_TYPE;



typedef struct _AFP_REQUEST_PACKET {

    // Command code
    //
    DWORD		dwRequestCode;

    AFP_API_TYPE	dwApiType;

    union {

    	struct {

    	    PVOID	pInputBuf;
    	    DWORD	cbInputBufSize;

	    DWORD	dwParmNum;

	} SetInfo;

    	struct {

    	    PVOID	pInputBuf;
    	    DWORD	cbInputBufSize;

	} Add;

    	struct {

    	    PVOID	pInputBuf;

	    // This parameter will be set to indicate the maximum amount of
	    // data that may be returned to the client.
	    // -1 indicates all available data.
	    //
    	    DWORD	cbInputBufSize;

    	    PVOID	pOutputBuf;
    	    DWORD	cbOutputBufSize;

	    DWORD	cbTotalBytesAvail;

	} GetInfo;

    	struct {

    	    // Will be pointer to an output buffer for Enum calls
	    //
    	    PVOID	pOutputBuf;

	    // This parameter will be set to indicate the maximum amount of
	    // data that may be returned to the client.
	    // -1 indicates all available data.
	    //
    	    DWORD	cbOutputBufSize;

    	    DWORD	dwEntriesRead;

    	    // Will contain the total number of entries available from the
	    // current position (pointed to by dwResumeHandle)
    	    //
    	    DWORD	dwTotalAvail;

	    // This information will get sent to the FSD as the Enum
	    // request packet.
	    //
 	    ENUMREQPKT  EnumRequestPkt;
	
	} Enum;

    	struct  {

	    // Will point to structure representing the entity to be
	    // closed, deleted or removed.
            //
    	    PVOID	pInputBuf;
    	    DWORD	cbInputBufSize;

	} Delete;

    } Type;

} AFP_REQUEST_PACKET, *PAFP_REQUEST_PACKET;

// Function prototypes
//
DWORD
AfpServerIOCtrl(
	PAFP_REQUEST_PACKET pAfpSrp
);

DWORD
AfpServerIOCtrlGetInfo(
	PAFP_REQUEST_PACKET pAfpSrp
);

#endif // ifndef _IOCTL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\message.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	message.c
//
// Description: This module contains support routines for the message
//		category API's for the AFP server service. These routines
//		will be called by the RPC runtime.
//
// History:
//		July 21,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:	AfpAdminrMessageSend
//
// Returns:	NO_ERROR	- success
//		ERROR_ACCESS_DENIED
//		non-zero returns from the IOCTL
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminMessageSend function.
//
DWORD
AfpAdminrMessageSend(
	IN  AFP_SERVER_HANDLE     hServer,
	IN  PAFP_MESSAGE_INFO     pAfpMessageInfo
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwAccessStatus=0;
DWORD		   dwRetCode=0;
PAFP_MESSAGE_INFO  pAfpMessageInfoSR;	
DWORD		   cbAfpMessageInfoSRSize;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrMessageSend, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrMessageSend, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Make this buffer self-relative.
    //
    if ( dwRetCode = AfpBufMakeFSDRequest((LPBYTE)pAfpMessageInfo,
					  0,
					  AFP_MESSAGE_STRUCT,
					  (LPBYTE*)&pAfpMessageInfoSR,
					  &cbAfpMessageInfoSRSize ))
	return( dwRetCode );

        // Make IOCTL to set info

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_MESSAGE_SEND;
    AfpSrp.dwApiType     		= AFP_API_TYPE_ADD;
    AfpSrp.Type.Add.pInputBuf		= pAfpMessageInfoSR;
    AfpSrp.Type.Add.cbInputBufSize	= cbAfpMessageInfoSRSize;

    dwRetCode = AfpServerIOCtrl( &AfpSrp );

    LocalFree( pAfpMessageInfoSR );

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\ioctl.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	ioctl.c
//
// Description: This module contains wrappers around the actual ioctl
//		call to the kernel mode FSD.
//
// History:
//	May 11,1992.	NarenG		Created original version.
//	
//	For Enums the FSD should use zero-based indexing.
//

#include "afpsvcp.h"

//**
//
// Call:	AfpServerIOCtrl
//
// Returns:	NO_ERROR	- success
//		non-zero returns from AfpFSDIOControl
//		ERROR_INVALID_PARAMETER 	
//
// Description: This procedure is a wrapper around the I/O control to the
//	 	AFP kernel mode FSD. It unmarshals the information in the
//		AFP_REQUEST_PACKET calls the driver and then marshalls the
//		returned information back into the AFP_REQUEST_PACKET and
//		returns.
//		
//		NOTE: This should never be called directly for Enum and
//		      GetInfo type requests. AfpServerIOCtrlGetInfo should
//		      be called. It will take care of buffer manipulation.
//
DWORD
AfpServerIOCtrl(
	IN PAFP_REQUEST_PACKET pAfpSrp
)
{
DWORD		cbBytesReturned;
PVOID		pInputBuffer       = NULL;
PVOID		pOutputBuffer      = NULL;
DWORD		cbInputBufferSize  = 0;
DWORD		cbOutputBufferSize = 0;
DWORD		dwRetCode;

    // Set up the input and output buffers depending on the type of operation
    //
    switch( pAfpSrp->dwApiType ) {
	
    // No input or output buffers requred for this type of API
    //
    case AFP_API_TYPE_COMMAND:
	break;

    // Input buffer contains information to be set.
    // No output buffer required.
    //
    case AFP_API_TYPE_SETINFO:

	pInputBuffer      = pAfpSrp->Type.SetInfo.pInputBuf;
	cbInputBufferSize = pAfpSrp->Type.SetInfo.cbInputBufSize;

        ((PSETINFOREQPKT)pInputBuffer)->sirqp_parmnum =
					pAfpSrp->Type.SetInfo.dwParmNum;
	break;

    case AFP_API_TYPE_ADD:

	pInputBuffer      = pAfpSrp->Type.Add.pInputBuf;
	cbInputBufferSize = pAfpSrp->Type.Add.cbInputBufSize;

	break;

    case AFP_API_TYPE_DELETE:

	pInputBuffer      = pAfpSrp->Type.Delete.pInputBuf;
	cbInputBufferSize = pAfpSrp->Type.Delete.cbInputBufSize;

	break;

    // Input buffer contains resume handle
    // Output buffer needed to hold returned data
    //
    case AFP_API_TYPE_ENUM:

        pInputBuffer       = (PVOID)&( pAfpSrp->Type.Enum.EnumRequestPkt );
	cbInputBufferSize  = sizeof( pAfpSrp->Type.Enum.EnumRequestPkt );

	pOutputBuffer      = pAfpSrp->Type.Enum.pOutputBuf;
	cbOutputBufferSize = pAfpSrp->Type.Enum.cbOutputBufSize;

	break;

    // Input buffer contains information regarding the entity for
    // which information is requested.
    // Output buffer will contain information regarding that entity.
    //
    case AFP_API_TYPE_GETINFO:

        pInputBuffer       = pAfpSrp->Type.GetInfo.pInputBuf;
	cbInputBufferSize  = pAfpSrp->Type.GetInfo.cbInputBufSize;

	pOutputBuffer      = pAfpSrp->Type.GetInfo.pOutputBuf;
	cbOutputBufferSize = pAfpSrp->Type.GetInfo.cbOutputBufSize;

	break;

    default:
	return( ERROR_INVALID_PARAMETER );

    }
	
    dwRetCode = AfpFSDIOControl( AfpGlobals.hFSD,
				 pAfpSrp->dwRequestCode,
			   	 pInputBuffer,
			         cbInputBufferSize,
			         pOutputBuffer,
			         cbOutputBufferSize,
				 &cbBytesReturned
				);

    if ( (dwRetCode != ERROR_MORE_DATA) && (dwRetCode != NO_ERROR) )
	return( dwRetCode );

    // If API was of Enum type store the Total number of entries read,
    // total number of available entries and resumable handle into the
    // Srp
    //
    if ( pAfpSrp->dwApiType == AFP_API_TYPE_ENUM ) {

	pAfpSrp->Type.Enum.dwEntriesRead =
				((PENUMRESPPKT)pOutputBuffer)->ersp_cInBuf;
	pAfpSrp->Type.Enum.dwTotalAvail =
				((PENUMRESPPKT)pOutputBuffer)->ersp_cTotEnts;
	pAfpSrp->Type.Enum.EnumRequestPkt.erqp_Index =
				((PENUMRESPPKT)pOutputBuffer)->ersp_hResume;

	// Shift the data to the start of the buffer, over-writing the
	// enum reponse information.
	//
	CopyMemory( pOutputBuffer,
		    (PVOID)((ULONG_PTR)pOutputBuffer+sizeof(ENUMRESPPKT)),
		    cbBytesReturned - sizeof(ENUMRESPPKT) );
    }

    // If API type was GetInfo, store the Total number of bytes available
    // and the total number of bytes read.
    //
    if ( pAfpSrp->dwApiType == AFP_API_TYPE_GETINFO )
	pAfpSrp->Type.GetInfo.cbTotalBytesAvail = cbBytesReturned;

    return( dwRetCode );
}

//**
//
// Call:	AfpServerIOCtrlGetInfo
//
// Returns:	NO_ERROR		- success
//		non-zero returns from DeviceIOCtrl
//		Non-zero returns from CreateEvent
//		ERROR_NOT_ENOUGH_MEMORY
//		ERROR_INVALID_PARAMETER 	
//
// Description: This is a wrapper around the AfpServerIOCtrl call for GetInfo
//		and Enum type calls that can return variable amounts of data.
//
//		For Enum calls, if AfpSrp.Enum.dwOutputBufSize == -1 it will
//		allocate and return ALL information that is available.
//		Otherwise it will allocate and return as much data that can
//		be contained in the AfpSrp.Enum.dwOutputBufSize parameter. The
//		caller of this procedure will set the value in
//		AfpSrp.Enum.dwOutputBufSize to be equal to the value of
//		MaxPreferredLength which was set by the caller of the Enum or
//		GetInfo API.
//
//		For GetInfo type calls AfpSrp.Enum.dwOutputBufSize == -1 always,
//		so this routine will always try to get ALL the available
//		information.
//
DWORD
AfpServerIOCtrlGetInfo(
	IN OUT PAFP_REQUEST_PACKET pAfpSrp
)
{
DWORD		dwRetCode;
BOOL		fGetEverything = FALSE;
PVOID		pOutputBuf;

    // Set up the output buffers
    //
    switch( pAfpSrp->dwApiType ) {
	
    case AFP_API_TYPE_ENUM:

	// Find out how much data the client wants.
  	//
 	if ( pAfpSrp->Type.Enum.cbOutputBufSize == -1 ) {

	    // Client wants everything, so allocate a default size buffer
	    //
	    pAfpSrp->Type.Enum.cbOutputBufSize = AFP_INITIAL_BUFFER_SIZE +
					         sizeof(ENUMRESPPKT);
	    fGetEverything = TRUE;

	}
	else {
	
	    // Otherwise just allocate enough for what the client wants
	    //
	    pAfpSrp->Type.Enum.cbOutputBufSize += sizeof(ENUMRESPPKT);
	}

	pOutputBuf = MIDL_user_allocate( pAfpSrp->Type.Enum.cbOutputBufSize );

	if ( pOutputBuf == NULL )
	    return( ERROR_NOT_ENOUGH_MEMORY );
	
	pAfpSrp->Type.Enum.pOutputBuf = pOutputBuf;

	break;

    case AFP_API_TYPE_GETINFO:

	// Client will ALWAYS want everything
	//
	pAfpSrp->Type.GetInfo.cbOutputBufSize = AFP_INITIAL_BUFFER_SIZE;

	pOutputBuf = MIDL_user_allocate(pAfpSrp->Type.GetInfo.cbOutputBufSize);

	if ( pOutputBuf == NULL )
	    return( ERROR_NOT_ENOUGH_MEMORY );

	pAfpSrp->Type.GetInfo.pOutputBuf = pOutputBuf;

	fGetEverything = TRUE;

    	break;

    default:
	return( ERROR_INVALID_PARAMETER );

    }

    // Make the IOCTL to the FSD
    //
    dwRetCode = AfpServerIOCtrl( pAfpSrp );

    if ( (dwRetCode != NO_ERROR) && (dwRetCode != ERROR_MORE_DATA) ) {
     	MIDL_user_free( pOutputBuf );
        return( dwRetCode );
    }
	
    // If we have obtained all requested data then we are done
    //
    if ( !(( dwRetCode == ERROR_MORE_DATA ) && fGetEverything ))
        return( dwRetCode );

    // Otherwise the client wants more data and there is more to be obtained
    //
    if ( pAfpSrp->dwApiType == AFP_API_TYPE_ENUM ) {

	// Increase the buffer size using a heuristic.
	//
	MIDL_user_free( pOutputBuf );
	pAfpSrp->Type.Enum.cbOutputBufSize = pAfpSrp->Type.Enum.dwTotalAvail
					   * AFP_AVG_STRUCT_SIZE
			  		   + AFP_INITIAL_BUFFER_SIZE
					   + sizeof(ENUMRESPPKT);

	pOutputBuf = MIDL_user_allocate( pAfpSrp->Type.Enum.cbOutputBufSize );

	if ( pOutputBuf == NULL )
	    return( ERROR_NOT_ENOUGH_MEMORY );
		
	pAfpSrp->Type.Enum.pOutputBuf = pOutputBuf;

	// If we are trying to get all the information then we reset the
	// resume handle to 0
	//
	if ( fGetEverything )
	    pAfpSrp->Type.Enum.EnumRequestPkt.erqp_Index = 0;
    }


    if ( pAfpSrp->dwApiType == AFP_API_TYPE_GETINFO ) {

    	// Increase the buffer size using the total available number
	// of bytes + Fudge Factor.
	//
	MIDL_user_free( pOutputBuf );

	pAfpSrp->Type.GetInfo.cbOutputBufSize =
			     pAfpSrp->Type.GetInfo.cbTotalBytesAvail +
			     AFP_INITIAL_BUFFER_SIZE;

	pOutputBuf=MIDL_user_allocate( pAfpSrp->Type.GetInfo.cbOutputBufSize );

	if ( pOutputBuf == NULL )
	    return( ERROR_NOT_ENOUGH_MEMORY );
		
	pAfpSrp->Type.GetInfo.pOutputBuf = pOutputBuf;
    }

	
    // Make the IOCTL to the FSD, if we dont get all the data this time
    // we give up and return to the caller.
    //
    dwRetCode = AfpServerIOCtrl( pAfpSrp );
	
    if ( (dwRetCode != NO_ERROR) && (dwRetCode != ERROR_MORE_DATA) )
        MIDL_user_free( pOutputBuf );

    return( dwRetCode );
		
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\registry.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	registry.c
//
// Description: This module contains routines to manupilate information
//		in the registry.
//
// History:
//		May 11,1992.	NarenG		Created original version.
//

#include "afpsvcp.h"

// AFP Server Service registry parameter structure
//
typedef struct _AFP_SERVER_REG_PARAMS {

    LPWSTR	lpwValueName;
    PVOID	pValue;
    DWORD	dwDataType;
    DWORD	dwErrorLogId;
    BOOL 	(*pfuncIsValid)( LPVOID );

} AFP_SERVER_REG_PARAMS, *PAFP_SERVER_REG_PARAMS;

AFP_SERVER_REG_PARAMS AfpServerRegParams[] = {

    AFPREG_VALNAME_SVRNAME, 
    AfpGlobals.wchServerName,
    REG_SZ,
    AFPLOG_INVALID_SERVERNAME,
    IsAfpServerNameValid, 

    AFPREG_VALNAME_SRVOPTIONS, 
    &(AfpGlobals.dwServerOptions),
    REG_DWORD,
    AFPLOG_INVALID_SRVOPTION,
    IsAfpServerOptionsValid, 

    AFPREG_VALNAME_MAXSESSIONS, 
    &(AfpGlobals.dwMaxSessions),
    REG_DWORD,
    AFPLOG_INVALID_MAXSESSIONS,
    IsAfpMaxSessionsValid, 

    AFPREG_VALNAME_LOGINMSG, 
    AfpGlobals.wchLoginMsg,
    REG_SZ,
    AFPLOG_INVALID_LOGINMSG,
    IsAfpMsgValid, 

    AFPREG_VALNAME_MAXPAGEDMEM,
    &(AfpGlobals.dwMaxPagedMem),
    REG_DWORD,
    AFPLOG_INVALID_MAXPAGEDMEM,
    IsAfpMaxPagedMemValid, 

    AFPREG_VALNAME_MAXNONPAGEDMEM,
    &(AfpGlobals.dwMaxNonPagedMem),
    REG_DWORD,
    AFPLOG_INVALID_MAXNONPAGEDMEM,
    IsAfpMaxNonPagedMemValid, 

    NULL, NULL, 0, 0, FALSE
};

//**
//
// Call:	AfpRegOpen
//
// Returns:	NO_ERROR	- success	
//		non-zero returns from registry API's
//
// Description:	Will simply open and handles to keys in the registry
//		where the server parameters, volumes list and ETC list
//		are stored. These open handles will be stored in global
//		variables.
//
DWORD
AfpRegOpen( 
	VOID 
)
{
DWORD	dwRetCode;

    AfpGlobals.hkeyServerParams = NULL;
    AfpGlobals.hkeyVolumesList  = NULL;
    AfpGlobals.hkeyIcons	= NULL;
    AfpGlobals.hkeyTypeCreators = NULL;
    AfpGlobals.hkeyExtensions   = NULL;

    // The do - while( FALSE ) loop is used here to avoid using a goto to
    // do a cleanup and exit.
    //
    do {

    	// Obtain handle to the ..\PARAMETERS key.
    	//
    	if ( dwRetCode = RegOpenKeyEx(
				  HKEY_LOCAL_MACHINE,
				  AFP_KEYPATH_SERVER_PARAMS,
				  0,
				  KEY_ALL_ACCESS,
				  &AfpGlobals.hkeyServerParams
				))
	    break;

    	// Obtain handle to the ..\PARAMETERS\VOLUMES volume list key
        //
    	if ( dwRetCode = RegOpenKeyEx(
				  HKEY_LOCAL_MACHINE,
				  AFP_KEYPATH_VOLUMES,
				  0,
				  KEY_ALL_ACCESS,
				  &AfpGlobals.hkeyVolumesList
				)) 
	    break;

    	// Obtain handle to the ..\PARAMETERS\TYPE_CREATORS key
    	//
    	if ( dwRetCode = RegOpenKeyEx(
				  HKEY_LOCAL_MACHINE,
			          AFP_KEYPATH_TYPE_CREATORS,
				  0,
				  KEY_ALL_ACCESS,
			          &AfpGlobals.hkeyTypeCreators
			   	 )) 
	    break;

    	// Obtain handle to the ..\PARAMETERS\EXTENSIONS key
    	//
    	if ( dwRetCode = RegOpenKeyEx(
				  HKEY_LOCAL_MACHINE,
			          AFP_KEYPATH_EXTENSIONS,
				  0,
				  KEY_ALL_ACCESS,
			          &AfpGlobals.hkeyExtensions
			   	 )) 
	    break;

    	// Obtain handle to the ..\PARAMETERS\ICONS key
    	//
    	if ( dwRetCode = RegOpenKeyEx(
				  HKEY_LOCAL_MACHINE,
			          AFP_KEYPATH_ICONS,
				  0,
				  KEY_ALL_ACCESS,
			          &AfpGlobals.hkeyIcons
			   	 )) 
	    break;

    } while( FALSE );

    return( dwRetCode );
}

//**
//
// Call:	AfpRegClose
//
// Returns:	none
//
// Description: Simply closes all handles opened by AfpRegOpen
//
VOID
AfpRegClose( 
	VOID 
)
{
    if ( AfpGlobals.hkeyServerParams )
   	RegCloseKey( AfpGlobals.hkeyServerParams );

    if ( AfpGlobals.hkeyVolumesList )
   	RegCloseKey( AfpGlobals.hkeyVolumesList );

    if ( AfpGlobals.hkeyTypeCreators )
    	RegCloseKey( AfpGlobals.hkeyTypeCreators );

    if ( AfpGlobals.hkeyExtensions )
    	RegCloseKey( AfpGlobals.hkeyExtensions );

    if ( AfpGlobals.hkeyIcons )
    	RegCloseKey( AfpGlobals.hkeyIcons );

    return;
}

//**
//
// Call:	AfpRegServerGetInfo
//
// Returns:	NO_ERROR	- success
//		non-zero returns from registry calls.
//		ERROR_NOT_ENOUGH_MEMORY
//
// Description: This procedure is called to obtain server parameters.
//		It is assumed that before this procedure is called the 
//		default values for these parameters are already set.
//		If the parameter is not in the registry the default will 
//		be used ie. this procedure will not change it.
//		If a parameter exists in the registry, it will be retrieved.
//		If the retrieved parameter is invalid, an error event will
//		be logged and the default value will be used.
//
//		
DWORD
AfpRegServerGetInfo( 
	VOID 
)
{
DWORD 	dwRetCode;
DWORD 	dwTitle	= 0;
DWORD  	dwType;
LPBYTE  lpbValueBuf;
DWORD 	dwMaxValNameLen;
DWORD 	dwNumValues;
DWORD 	dwMaxValueDataSize;
DWORD	dwBufSize;
DWORD	dwIndex;

    // First find out the number of values and the max. size of them.
    //
    if ( dwRetCode = AfpRegGetKeyInfo(  AfpGlobals.hkeyServerParams,
		  		        &dwMaxValNameLen,    
		  		  	&dwNumValues,
		  			&dwMaxValueDataSize  
					))
	return( dwRetCode );

    // Allocate enough memory to hold the max. variable length data.
    //
    if ( ( lpbValueBuf = (LPBYTE)LocalAlloc(LPTR, dwMaxValueDataSize)) == NULL )
	return( ERROR_NOT_ENOUGH_MEMORY );

    // Run through ad get all the server parameters.
    // 
    for ( dwIndex   = 0, 
	  dwBufSize = dwMaxValueDataSize; 

	  AfpServerRegParams[dwIndex].lpwValueName != NULL;

	  dwIndex++, 
	  dwBufSize = dwMaxValueDataSize ) {

	ZeroMemory( lpbValueBuf, dwMaxValueDataSize );

    	// Get the server parameter.
    	//    
    	dwRetCode = RegQueryValueEx( AfpGlobals.hkeyServerParams,
	  			     AfpServerRegParams[dwIndex].lpwValueName, 
				     NULL,
				     &dwType,
				     lpbValueBuf,
				     &dwBufSize );

 	// If the parameter was present then read it in otherwise just
  	// skip it and let the default value stand. 
        //
    	if ( dwRetCode == NO_ERROR ) {

	     // If the parameter was valid we use it
	     //
	     if ( (*(AfpServerRegParams[dwIndex].pfuncIsValid))(lpbValueBuf) ){

		switch( AfpServerRegParams[dwIndex].dwDataType ) {
		
		case REG_SZ:

		    if ( STRLEN( (LPWSTR)lpbValueBuf ) > 0 ) 
		    	STRCPY( (LPWSTR)(AfpServerRegParams[dwIndex].pValue),
			        (LPWSTR)lpbValueBuf );
		    else
		    	((LPWSTR)(AfpServerRegParams[dwIndex].pValue))[0] = 
								     TEXT('\0');

		    break;

		case REG_DWORD:
    		    *(LPDWORD)(AfpServerRegParams[dwIndex].pValue) = 
						*(LPDWORD)lpbValueBuf;
		    break;

		default:
		    AFP_ASSERT( FALSE );
		    break;
		}
	     }
	     else {
		
		// Otherwise we log this error
		//
	        AfpLogEvent( AfpServerRegParams[dwIndex].dwErrorLogId, 
			     0, NULL, dwRetCode, EVENTLOG_WARNING_TYPE );
	    }
	}
	else if ( dwRetCode == ERROR_FILE_NOT_FOUND ) 
	    dwRetCode = NO_ERROR;
	else
	    break;
    }

    LocalFree( lpbValueBuf );
    return( dwRetCode );
}

//**
//
// Call:	AfpRegVolumeAdd
//
// Returns:	NO_ERROR		- success
//		non-zero returns from registry API's
//
// Description: This routine takes a AFP_VOLUME_INFO, creates a REG_MULTI_SZ
//		from it and stores it in the registry.
//
DWORD
AfpRegVolumeAdd( 
	IN PAFP_VOLUME_INFO    pVolumeInfo  
)
{
DWORD	dwRetCode;
DWORD	cbMultiSzSize;
LPBYTE  lpbMultiSz;
DWORD	dwLength;
DWORD   dwIndex;
WCHAR   wchEncryptedPass[AFP_VOLPASS_LEN+1];
			    
    // Before we add the volume we encrypt the password if there is one
    //
    if ( ( pVolumeInfo->afpvol_password != (LPWSTR)NULL ) &&
         ( STRLEN( pVolumeInfo->afpvol_password ) > 0 ) ) {

	ZeroMemory( wchEncryptedPass, sizeof( wchEncryptedPass ) );

    	dwLength = STRLEN( pVolumeInfo->afpvol_password );

    	for ( dwIndex = 0; dwIndex < AFP_VOLPASS_LEN; dwIndex++ ) {

	    wchEncryptedPass[dwIndex] =  ( dwIndex < dwLength )   
			? pVolumeInfo->afpvol_password[dwIndex] ^ 0xF000
	    		: (wchEncryptedPass[dwIndex] ^= 0xF000); 
	}

    	pVolumeInfo->afpvol_password = wchEncryptedPass;

    }
 
    if ( dwRetCode = AfpBufMakeMultiSz( AFP_VOLUME_STRUCT,
				        (LPBYTE)pVolumeInfo,
				        &lpbMultiSz,
					&cbMultiSzSize ))
	return( dwRetCode );

    // Set the data.
    //
    dwRetCode = RegSetValueEx(  AfpGlobals.hkeyVolumesList,
				pVolumeInfo->afpvol_name,
				0,
				REG_MULTI_SZ,
				lpbMultiSz,
				cbMultiSzSize
				);

    LocalFree( lpbMultiSz );

    return( dwRetCode );
}

//**
//
// Call:	AfpRegVolumeDelete
//
// Returns:	NO_ERROR	- success
//		non-zero returns from registry calls.
//
// Description: Will delete a volume from the Volume list in the registry.
//
DWORD
AfpRegVolumeDelete( 
	IN LPWSTR lpwsVolumeName 
)
{
    return( RegDeleteValue( AfpGlobals.hkeyVolumesList, lpwsVolumeName ) );
}

//**
//
// Call:	AfpRegVolumeSetInfo
//
// Returns:	NO_ERROR		- success
//		non-zero returns from registry API's
//
// Description: 
//		
//
DWORD
AfpRegVolumeSetInfo( 	
	IN PAFP_VOLUME_INFO    pVolumeInfo  
)
{
    return( AfpRegVolumeAdd( pVolumeInfo ) );
}

//**
//
// Call:	AfpRegTypeCreatorEnum
//
// Returns:	NO_ERROR	- success
//	   	ERROR_NOT_ENOUGH_MEMORY 
//		non-zero returns from registry APIs.
//
// Description: This procedure will read in type/creator/comment information
//		from the registry and store it in memory in the
//		AfpGlobals.AfpETCMapInfo structure. Only fatal errors will
//		be returned. Non-fatal errors will be errorlogged.
//
DWORD
AfpRegTypeCreatorEnum( 
	VOID 
)
{
DWORD 	     	   dwRetCode;
DWORD 	     	   cbMaxValNameLen;   
DWORD		   cbValNameBufSize;
DWORD 	     	   dwNumValues;	
DWORD 	     	   cbMaxValueDataSize;
DWORD	     	   dwValueIndex;
DWORD	     	   cbBufSize;
DWORD	     	   dwType;
PAFP_TYPE_CREATOR  pTypeCreatorWalker;
PAFP_TYPE_CREATOR  pTypeCreator;
LPWSTR	           lpwsValName;
LPBYTE		   lpbMultiSz;
CHAR		   chAnsiBuf[10];
   

    // Read in the type/creators
    //
    if ( dwRetCode = AfpRegGetKeyInfo( 	AfpGlobals.hkeyTypeCreators,
		  			&cbMaxValNameLen,    
		  			&dwNumValues,	
		  			&cbMaxValueDataSize 
				  	))
	return( dwRetCode );


    // Allocate space for the number of values in this key.
    //
    AfpGlobals.AfpETCMapInfo.afpetc_type_creator=(PAFP_TYPE_CREATOR)LocalAlloc(
 					LPTR, 
					sizeof(AFP_TYPE_CREATOR) * dwNumValues);

    if ( AfpGlobals.AfpETCMapInfo.afpetc_type_creator == NULL ) 
	return( ERROR_NOT_ENOUGH_MEMORY );

    AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators = 0;

    if ( dwNumValues == 0 ) 
	return( NO_ERROR );

    if (( lpwsValName = (LPWSTR)LocalAlloc( LPTR, cbMaxValNameLen )) == NULL){
	LocalFree(AfpGlobals.AfpETCMapInfo.afpetc_type_creator );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    if (( lpbMultiSz = (LPBYTE)LocalAlloc( LPTR, cbMaxValueDataSize )) == NULL){
	LocalFree(AfpGlobals.AfpETCMapInfo.afpetc_type_creator );
	LocalFree( lpwsValName );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    // Read in the type/creator/comment tuples
    //
    for ( dwValueIndex 		   = 0, 
	  AfpGlobals.dwCurrentTCId = AFP_DEF_TCID + 1,
	  cbBufSize        	   = cbMaxValueDataSize, 
          cbValNameBufSize         = cbMaxValNameLen,
	  pTypeCreatorWalker    = AfpGlobals.AfpETCMapInfo.afpetc_type_creator;

	  dwValueIndex < dwNumValues;

	  dwValueIndex++, 
	  cbBufSize        	   = cbMaxValueDataSize, 
          cbValNameBufSize         = cbMaxValNameLen
	) {
	
	if ( dwRetCode = RegEnumValue(	AfpGlobals.hkeyTypeCreators,
				  	dwValueIndex,
				  	lpwsValName,
				  	&cbValNameBufSize,
				  	NULL,
				  	&dwType,
					lpbMultiSz,
					&cbBufSize
				 	))
	    break;


	// Parse the mult sz and extract info into volume info structure
 	//
	if ( dwRetCode = AfpBufParseMultiSz( 
    				        AFP_TYPECREATOR_STRUCT,
					lpbMultiSz,
					(LPBYTE)pTypeCreatorWalker
				      )) {
	    LPWSTR lpwsNames[2]; 

	    lpwsNames[0] = pTypeCreatorWalker->afptc_type;
	    lpwsNames[1] = pTypeCreatorWalker->afptc_creator;

	    AfpLogEvent( AFPLOG_INVALID_TYPE_CREATOR,
			 2,
			 lpwsNames,
			 (DWORD)AFPERR_InvalidTypeCreator,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Id is value name, so copy it in
        //
	wcstombs( chAnsiBuf, lpwsValName, sizeof( chAnsiBuf ) );
        pTypeCreatorWalker->afptc_id = atoi( chAnsiBuf ); 

        if ( !IsAfpTypeCreatorValid( pTypeCreatorWalker ) ) { 

	    LPWSTR lpwsNames[2]; 

	    lpwsNames[0] = pTypeCreatorWalker->afptc_type;
	    lpwsNames[1] = pTypeCreatorWalker->afptc_creator;

	    AfpLogEvent( AFPLOG_INVALID_TYPE_CREATOR,
			 2,
			 lpwsNames,
			 (DWORD)AFPERR_InvalidTypeCreator,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Check to see if this is a duplicate.
  	//
    	pTypeCreator = AfpBinarySearch( 
			      pTypeCreatorWalker,  
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpBCompareTypeCreator );

	if ( pTypeCreator != NULL ) {

	    LPWSTR lpwsNames[2]; 

	    lpwsNames[0] = pTypeCreatorWalker->afptc_type;
	    lpwsNames[1] = pTypeCreatorWalker->afptc_creator;

	    AfpLogEvent( AFPLOG_INVALID_TYPE_CREATOR,
			 2,
			 lpwsNames,
			 (DWORD)AFPERR_InvalidTypeCreator,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

 	// Keep the Current id the max of all ids
	//
	AfpGlobals.dwCurrentTCId = 
	( AfpGlobals.dwCurrentTCId < pTypeCreatorWalker->afptc_id ) ? 
	pTypeCreatorWalker->afptc_id  :  AfpGlobals.dwCurrentTCId;

        AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators++;
	pTypeCreatorWalker++;

    }

    LocalFree( lpwsValName );
    LocalFree( lpbMultiSz );

    if ( dwRetCode ) {
	LocalFree( AfpGlobals.AfpETCMapInfo.afpetc_type_creator );
	return( dwRetCode );
    }

    // Sort the type/creator table
    //
    qsort(  AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
            AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators,
	    sizeof(AFP_TYPE_CREATOR), 
	    AfpBCompareTypeCreator );

    return( NO_ERROR );

}

//**
//
// Call:	AfpRegExtensionEnum
//
// Returns:	NO_ERROR	- success
//	   	ERROR_NOT_ENOUGH_MEMORY 
//		non-zero returns from registry APIs.
//
// Description: This procedure will read in extension information
//		from the registry and store it in memory in the
//		AfpGlobals.AfpETCMapInfo structure. Only fatal errors will
//		be returned. Non-fatal errors will be errorlogged.
//
DWORD
AfpRegExtensionEnum(
	VOID
)
{
DWORD 	     	   dwRetCode;
DWORD 	     	   cbMaxValNameLen;   
DWORD		   cbValNameBufSize;
DWORD 	     	   dwNumValues;	
DWORD 	     	   cbMaxValueDataSize;
DWORD	     	   dwValueIndex;
DWORD	     	   cbBufSize;
DWORD	     	   dwType;
PAFP_EXTENSION	   pExtensionWalker;
PAFP_EXTENSION     pExtension;
LPWSTR	           lpwsValName;
LPBYTE		   lpbMultiSz;
DWORD		   dwNumExtensions;
PAFP_TYPE_CREATOR  pTypeCreator;
AFP_TYPE_CREATOR   AfpTypeCreator;
DWORD		   dwNumTypeCreators;
   

    // Read in the extensions
    //
    if ( dwRetCode = AfpRegGetKeyInfo( 	AfpGlobals.hkeyExtensions,
		  			&cbMaxValNameLen,    
		  			&dwNumValues,	
		  			&cbMaxValueDataSize 
				  	))
	return( dwRetCode );

    AfpGlobals.AfpETCMapInfo.afpetc_extension = (PAFP_EXTENSION)LocalAlloc(  
					LPTR, 
					sizeof(AFP_EXTENSION) *dwNumValues );

    if ( AfpGlobals.AfpETCMapInfo.afpetc_extension == NULL ) 
	return( ERROR_NOT_ENOUGH_MEMORY );

    AfpGlobals.AfpETCMapInfo.afpetc_num_extensions = 0;
        
    if ( dwNumValues == 0 )
	return( NO_ERROR );

    // Read in the extensions
    //
    if (( lpwsValName = (LPWSTR)LocalAlloc( LPTR, cbMaxValNameLen )) == NULL) {
        LocalFree( AfpGlobals.AfpETCMapInfo.afpetc_extension ); 
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    if (( lpbMultiSz = (LPBYTE)LocalAlloc( LPTR, cbMaxValueDataSize )) == NULL){
        LocalFree( AfpGlobals.AfpETCMapInfo.afpetc_extension ); 
	LocalFree( lpwsValName );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    for ( dwValueIndex 	   = 0, 
	  pExtensionWalker = AfpGlobals.AfpETCMapInfo.afpetc_extension,
	  cbBufSize        = cbMaxValueDataSize, 
          cbValNameBufSize = cbMaxValNameLen;

	  dwValueIndex < dwNumValues;

	  dwValueIndex++, 
	  cbBufSize        = cbMaxValueDataSize, 
          cbValNameBufSize = cbMaxValNameLen
	) {
	
	if ( dwRetCode = RegEnumValue(  AfpGlobals.hkeyExtensions,
				  	dwValueIndex,
				  	lpwsValName,
					&cbValNameBufSize,
				  	NULL,
				  	&dwType,
					lpbMultiSz,
					&cbBufSize
				 	)) 
	    break;

	// Parse the mult sz and extract info into volume info structure
 	//
	if ( dwRetCode = AfpBufParseMultiSz( 
					AFP_EXTENSION_STRUCT,
					lpbMultiSz,
				  	(LPBYTE)pExtensionWalker
				      )) {
	    LPWSTR lpwsName = pExtensionWalker->afpe_extension;
	    AfpLogEvent( AFPLOG_INVALID_EXTENSION,
			 1,
			 &lpwsName,
			 (DWORD)AFPERR_InvalidExtension,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

	// Value name is extension, so copy it in
	//
	STRCPY( pExtensionWalker->afpe_extension, lpwsValName );
	
        if ( !IsAfpExtensionValid( pExtensionWalker ) ) {
	    LPWSTR lpwsName = pExtensionWalker->afpe_extension;
	    AfpLogEvent( AFPLOG_INVALID_EXTENSION,
			 1,
			 &lpwsName,
			 (DWORD)AFPERR_InvalidExtension,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
        }

 	// Check to see if this extension is associated with a vaid type/creator
	// pair
 	//
	dwNumTypeCreators = AfpGlobals.AfpETCMapInfo.afpetc_num_type_creators;
	AfpTypeCreator.afptc_id = pExtensionWalker->afpe_tcid;

    	pTypeCreator = _lfind( &AfpTypeCreator,  
			      AfpGlobals.AfpETCMapInfo.afpetc_type_creator,
    			      (unsigned int *)&dwNumTypeCreators,
			      sizeof(AFP_TYPE_CREATOR),
			      AfpLCompareTypeCreator );

	if ( pTypeCreator == NULL ) {
	    LPWSTR lpwsName = pExtensionWalker->afpe_extension;
	    AfpLogEvent( AFPLOG_INVALID_EXTENSION,
			 1,
			 &lpwsName,
			 (DWORD)AFPERR_InvalidExtension,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

 	// Check to see if this extension is a duplicate
 	//
	dwNumExtensions = AfpGlobals.AfpETCMapInfo.afpetc_num_extensions; 

    	pExtension = _lfind( pExtensionWalker,  
			    AfpGlobals.AfpETCMapInfo.afpetc_extension,
    			    (unsigned int *)&dwNumExtensions,
			    sizeof(AFP_EXTENSION),
			    AfpLCompareExtension );

	if ( pExtension != NULL ) {
	    LPWSTR lpwsName = pExtensionWalker->afpe_extension;
	    AfpLogEvent( AFPLOG_INVALID_EXTENSION,
			 1,
			 &lpwsName,
			 (DWORD)AFPERR_DuplicateExtension,
			 EVENTLOG_WARNING_TYPE );
	    dwRetCode = NO_ERROR;
	    continue;
	}

        AfpGlobals.AfpETCMapInfo.afpetc_num_extensions++;
	pExtensionWalker++;

    }

    LocalFree( lpwsValName );
    LocalFree( lpbMultiSz );

    if ( dwRetCode ) {
        LocalFree( AfpGlobals.AfpETCMapInfo.afpetc_extension );
	return( dwRetCode );
    }

    // Sort the extension table
    //
    qsort(  AfpGlobals.AfpETCMapInfo.afpetc_extension,
            AfpGlobals.AfpETCMapInfo.afpetc_num_extensions,
	    sizeof(AFP_EXTENSION), 
	    AfpBCompareExtension );

    return( NO_ERROR );
}

//**
//
// Call:	AfpRegTypeCreatorAdd 
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry
//
// Description: This routine will add a tupple to the registry. The value
//		name for the tupple will be id of the type creator.
//
DWORD
AfpRegTypeCreatorAdd( 
	IN PAFP_TYPE_CREATOR     pAfpTypeCreator
) 
{
DWORD			cbMultiSzSize;
LPBYTE  		lpbMultiSz;
DWORD   		dwRetCode;
WCHAR			wchValueName[10];
CHAR			chValueName[10];

    _itoa( pAfpTypeCreator->afptc_id, chValueName, 10 );
    mbstowcs( wchValueName, chValueName, sizeof(wchValueName) );
			    
    if ( dwRetCode = AfpBufMakeMultiSz( AFP_TYPECREATOR_STRUCT,
				   	(LPBYTE)pAfpTypeCreator,
				   	&lpbMultiSz,
				   	&cbMultiSzSize ))
	return( dwRetCode );

    dwRetCode =  RegSetValueEx( AfpGlobals.hkeyTypeCreators,
				wchValueName,
				0,
				REG_MULTI_SZ,
				lpbMultiSz,
				cbMultiSzSize
				);

    LocalFree( lpbMultiSz );

    return( dwRetCode );
	
}

//**
//
// Call:	AfpRegTypeCreatorSetInfo
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry
//
// Description: Will change the value of a particular tupple.
//
DWORD
AfpRegTypeCreatorSetInfo( 
	IN PAFP_TYPE_CREATOR     pAfpTypeCreator
) 
{
    return( AfpRegTypeCreatorAdd( pAfpTypeCreator ) );
}

//**
//
// Call:	AfpRegTypeCreatorDelete 
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry apis
//
// Description:	Will delete a type creator entry from the registry key.
//
DWORD
AfpRegTypeCreatorDelete( 
	IN PAFP_TYPE_CREATOR     pAfpTypeCreator
) 
{
WCHAR	wchValueName[10];
CHAR	chValueName[10];

    _itoa( pAfpTypeCreator->afptc_id, chValueName, 10 );
    mbstowcs( wchValueName, chValueName, sizeof(wchValueName) );

    return( RegDeleteValue( AfpGlobals.hkeyTypeCreators, wchValueName ));
}

//**
//
// Call:	AfpRegExtensionAdd 
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry
//
// Description: This routine will add a tupple to the registry. The value
//		name for the tupple will be the concatenation of the
//		type, creator and the extension. This is done to keep the
//		value name unique so that it may be accessed directly.
//
DWORD
AfpRegExtensionAdd( 
	IN PAFP_EXTENSION     pAfpExtension
) 
{
DWORD			cbMultiSzSize;
LPBYTE  		lpbMultiSz;
DWORD   		dwRetCode;
			    
    if ( dwRetCode = AfpBufMakeMultiSz( AFP_EXTENSION_STRUCT,
				   	(LPBYTE)pAfpExtension,
				   	&lpbMultiSz,
				   	&cbMultiSzSize ))
	return( dwRetCode );

    dwRetCode =  RegSetValueEx( AfpGlobals.hkeyExtensions,
				pAfpExtension->afpe_extension,
				0,
				REG_MULTI_SZ,
				lpbMultiSz,
				cbMultiSzSize );
    LocalFree( lpbMultiSz );

    return( dwRetCode );
}

//**
//
// Call:	AfpRegExtensionSetInfo
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry
//
// Description: Will change the value of a particular tupple.
//
DWORD
AfpRegExtensionSetInfo( 
	IN PAFP_EXTENSION     pAfpExtension
) 
{
    // Make a Mult-sz of this and add it to the registry
    //
    return( AfpRegExtensionAdd( pAfpExtension ) );
}

//**
//
// Call:	AfpRegExtensionDelete 
//
// Returns:	NO_ERROR	- success
//		non-zero returns from the registry
//
// Description: Deletes an extension from the registry.
//
DWORD
AfpRegExtensionDelete( 
	IN PAFP_EXTENSION     pAfpExtension
) 
{
    return( RegDeleteValue( AfpGlobals.hkeyExtensions, 
			    pAfpExtension->afpe_extension ));
}

//**
//
// Call:	AfpRegGetKeyInfo
//
// Returns:	NO_ERROR		- success
//		non-zero returns from registry API's
//
// Description: Will retrieve the number of values in this key and the
//		maximum size of the value data. It will also return the
//		length IN BYTES of the largest value name (including the
//		NULL character ).
//
DWORD
AfpRegGetKeyInfo( 
	IN  HKEY    hKey,
	OUT LPDWORD lpdwMaxValNameLen,    // Longest valuename in this key
	OUT LPDWORD lpdwNumValues,	  // Number of values in this key
	OUT LPDWORD lpdwMaxValueDataSize  // Max. size of value data.
)
{
WCHAR		wchClassName[256];// This should be large enough to hold the
				  // class name for this key.
DWORD		dwClassSize = sizeof( wchClassName );
DWORD 		dwNumSubKeys;
DWORD   	dwMaxSubKeySize;
DWORD		dwMaxClassSize;
DWORD		dwSecDescLen;
FILETIME   	LastWrite;
DWORD		dwRetCode;

    dwRetCode = RegQueryInfoKey(hKey,
				wchClassName,
				&dwClassSize,
				NULL,
				&dwNumSubKeys,
				&dwMaxSubKeySize,
				&dwMaxClassSize,
				lpdwNumValues,
				lpdwMaxValNameLen,
				lpdwMaxValueDataSize,
				&dwSecDescLen,
				&LastWrite
				);

    if ( dwRetCode == NO_ERROR ) {

	if ( *lpdwMaxValNameLen > 0 )
	    *lpdwMaxValNameLen = (*lpdwMaxValNameLen + 1) * sizeof(WCHAR);
	
    }

    return( dwRetCode );
}

//**
//
// Call:	AfpRegServerGetCodePagePath
//
// Returns:	NO_ERROR
//	    	ERROR_PATH_NOT_FOUND
//		other errors returned from registry APIs
//
// Description: Will get the path to the Mac codepage and store it in
//		AfpGlobals.wchCodePagePath. 
//		It will first get the system directory. It will then get
//		the codepage filename and concatenate it to the system 
//		directory.
//
DWORD
AfpRegServerGetCodePagePath( 
	VOID
)
{
DWORD 	dwRetCode;
HKEY	hkeyCodepagePath;
DWORD   dwType;
DWORD   dwBufSize;
WCHAR   wchCodepageNum[20];
WCHAR   wchCodePageFile[MAX_PATH];

    // Open the key
    //
    if ( dwRetCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
			           AFP_KEYPATH_CODEPAGE,
				   0,
				   KEY_QUERY_VALUE,
			           &hkeyCodepagePath
			   	  )) 
	return( dwRetCode );


    // This is not a loop
    //
    do { 

	// First get the system directory path
	//
	if ( !GetSystemDirectory( AfpGlobals.wchCodePagePath,
				  sizeof( AfpGlobals.wchCodePagePath ))) {
	    dwRetCode = ERROR_PATH_NOT_FOUND;
	    break;
	}

	// Get the Code page number value for the Mac
 	//
	dwBufSize = sizeof( wchCodepageNum );
	if ( dwRetCode = RegQueryValueEx( hkeyCodepagePath,
	  			          AFPREG_VALNAME_CODEPAGE,
				          NULL,
				          &dwType,
				          (LPBYTE)wchCodepageNum,
				          &dwBufSize ))
	    break;

	// Finally get the codepage filename
	//
	dwBufSize = sizeof( wchCodePageFile );
	if ( dwRetCode = RegQueryValueEx( hkeyCodepagePath,
	  			          wchCodepageNum, 
				          NULL,
				          &dwType,
					  (LPBYTE)wchCodePageFile,
				          &dwBufSize ))
	    break;

	// Concatenate the filename to the system directory path
	//
	wcscat( AfpGlobals.wchCodePagePath, (LPWSTR)TEXT("\\") );
	wcscat( AfpGlobals.wchCodePagePath, wchCodePageFile );

    } while( FALSE );

    // Close the key
    //
    RegCloseKey( hkeyCodepagePath );

    return( dwRetCode );
    
}
//**
//
// Call:	AfpRegServerSetInfo
//
// Returns:	NO_ERROR	- success
//		non-zero returns from registry APIs.
//
// Description:	This procedure will set specific server parameters in the 
//		registy depending on what bit is set the the dwParmnum
//		parameter. The input will be a AFP_SERVER_INFO self relative
//		structure that contains the parameter to set.
//
DWORD
AfpRegServerSetInfo( 
	IN PAFP_SERVER_INFO pServerInfo, 
	IN DWORD 	    dwParmnum 
)
{
DWORD	dwRetCode;
LPWSTR  lpwsPtr;


    // Set the server name
    //
    if ( dwParmnum & AFP_SERVER_PARMNUM_NAME ) {

	DWORD Length = 0;

	lpwsPtr = pServerInfo->afpsrv_name;

	if ( lpwsPtr != NULL ) {

	    OFFSET_TO_POINTER( lpwsPtr, pServerInfo );
	    Length = STRLEN(lpwsPtr)+1;
	}

	if ( dwRetCode=RegSetValueEx(
				AfpGlobals.hkeyServerParams,
    				AFPREG_VALNAME_SVRNAME, 
				0,
				REG_SZ,
				(LPBYTE)lpwsPtr,
				Length * sizeof(WCHAR)))
	    return( dwRetCode );
    }

    // Set Max sessions
    //
    if ( dwParmnum & AFP_SERVER_PARMNUM_MAX_SESSIONS ) {

	if ( dwRetCode=RegSetValueEx(
				AfpGlobals.hkeyServerParams,
				AFPREG_VALNAME_MAXSESSIONS,
				0,
				REG_DWORD,
				(LPBYTE)&(pServerInfo->afpsrv_max_sessions),
				sizeof( DWORD )))
	    return( dwRetCode );
    }

    // Set server options
    //
    if ( dwParmnum & AFP_SERVER_PARMNUM_OPTIONS	) {

	if ( dwRetCode = RegSetValueEx(
				AfpGlobals.hkeyServerParams,
				AFPREG_VALNAME_SRVOPTIONS,
				0,
				REG_DWORD,
				(LPBYTE)&(pServerInfo->afpsrv_options),
				sizeof( DWORD )
				))
	    return( dwRetCode );
    }

    // Set Login message
    //
    if ( dwParmnum & AFP_SERVER_PARMNUM_LOGINMSG ) {

	DWORD Length = 0;

	lpwsPtr = pServerInfo->afpsrv_login_msg;

	if ( lpwsPtr != NULL ) {

	    OFFSET_TO_POINTER( lpwsPtr, pServerInfo );
	    Length = STRLEN(lpwsPtr)+1;
	}

	if ( dwRetCode = RegSetValueEx( 
				AfpGlobals.hkeyServerParams,
				AFPREG_VALNAME_LOGINMSG,
				0,
				REG_SZ,
				(LPBYTE)lpwsPtr,
				 Length * sizeof(WCHAR)))
	    return( dwRetCode );
    }
   
    return( NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\main.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename: 	main.c
//
// Description: This module contains the main procedure of the AFP server
//		service. It will contain code to initialize and install
//		itself and the kernel-mode AFP Server. It also contains
//		code to respond to the server controller. It will also
//		handle service shutdown.
//
//		??? Does the service controller log start/stop events etc ??
//		    if not log it.
//		
// History:
//		May 11,1990.	NarenG		Created original version.
//
#define DEFINE_AFP_GLOBALS	// This will cause AfpGlobals to be defined.
#include "afpsvcp.h"

// Prototypes of functions used only within this module.
//
VOID
AfpMain(
	IN DWORD 	argc,
	IN LPWSTR * 	lpwsServiceArgs
);

VOID
AfpCleanupAndExit(
	IN DWORD 	dwError
);

VOID
AfpControlResponse(
	IN DWORD 	dwControlCode
);


//**
//
// Call:	main.c
//
// Returns:	none.
//
// Description: Will simply register the entry point of the AFP server
//		service with the service controller. The service controller
//		will capture this thread. It will be freed only when
//		the service is shutdown. At that point we will simply exit
//		the process.
//
void
_cdecl
main( int argc, unsigned char * argv[] )
{
SERVICE_TABLE_ENTRY	AfpServiceDispatchTable[2];

#ifdef DBG

    CONSOLE_SCREEN_BUFFER_INFO csbi;
    COORD coord;
    (VOID)AllocConsole( );
    (VOID)GetConsoleScreenBufferInfo( GetStdHandle(STD_OUTPUT_HANDLE),
                		      &csbi
                 		    );
    coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
    coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
    (VOID)SetConsoleScreenBufferSize( GetStdHandle(STD_OUTPUT_HANDLE),
                		      coord
                		    );
#endif

    AFP_UNREFERENCED( argc );
    AFP_UNREFERENCED( argv );


    AfpServiceDispatchTable[0].lpServiceName = AFP_SERVICE_NAME;
    AfpServiceDispatchTable[0].lpServiceProc = AfpMain;
    AfpServiceDispatchTable[1].lpServiceName = NULL;
    AfpServiceDispatchTable[1].lpServiceProc = NULL;

    if ( !StartServiceCtrlDispatcher( AfpServiceDispatchTable ) )
	AfpLogEvent( AFPLOG_CANT_START, 0, NULL,
		     GetLastError(), EVENTLOG_ERROR_TYPE );

    ExitProcess(0);

}

//**
//
// Call:	AfpMain
//
// Returns:	none.
//
// Description: This is the main procedure for the Afp Server Service. It
//		will be called when the service is supposed to start itself.
//		It will do all service wide initialization.
//
VOID
AfpMain( DWORD	  argc,		// Command line arguments. Will be ignored.
	 LPWSTR * lpwsServiceArgs
)
{
DWORD	dwRetCode;


    AFP_UNREFERENCED( argc );
    AFP_UNREFERENCED( lpwsServiceArgs );

    // NULL out all the globals
    //
    ZeroMemory( (LPBYTE)&AfpGlobals, sizeof(AfpGlobals) );

    // Register the service control handler with the service controller
    //
    AfpGlobals.hServiceStatus = RegisterServiceCtrlHandler(AFP_SERVICE_NAME,
							   AfpControlResponse );

    if ( AfpGlobals.hServiceStatus == (SERVICE_STATUS_HANDLE)0 ) {
	    AfpLogEvent( AFPLOG_CANT_START, 0, NULL,
                    GetLastError(), EVENTLOG_ERROR_TYPE );
	    AfpCleanupAndExit( GetLastError() );
        return;
    }

    AfpGlobals.ServiceStatus.dwServiceType  	      = SERVICE_WIN32;
    AfpGlobals.ServiceStatus.dwCurrentState 	      = SERVICE_START_PENDING;
    AfpGlobals.ServiceStatus.dwControlsAccepted       = 0;
    AfpGlobals.ServiceStatus.dwWin32ExitCode 	      = NO_ERROR;
    AfpGlobals.ServiceStatus.dwServiceSpecificExitCode= 0;
    AfpGlobals.ServiceStatus.dwCheckPoint 	      = 1;
    AfpGlobals.ServiceStatus.dwWaitHint 	      =AFP_SERVICE_INSTALL_TIME;

    AfpAnnounceServiceStatus();

    // Read in registry information and initialize the kernel-mode
    // server. Initialize the server to accept RPC calls. Initialize
    // all global vriables etc.
    //
    if ( dwRetCode = AfpInitialize() )
    {
        if (AfpGlobals.dwServerState & AFPSTATE_BLOCKED_ON_DOMINFO)
        {
	        AfpCleanupAndExit( NO_ERROR );
        }
        else
        {
	        AfpCleanupAndExit( dwRetCode );
        }
        return;
    }


    // Set the MAC bit for NetServerEnum
    //
    if ( !I_ScSetServiceBits( AfpGlobals.hServiceStatus,
			      SV_TYPE_AFP,
			      TRUE,
	                      TRUE,
			      NULL ))
    {

	    dwRetCode = GetLastError();
	    AfpLogEvent( AFPLOG_CANT_START, 0, NULL,
		                    GetLastError(), EVENTLOG_ERROR_TYPE );
        AfpCleanupAndExit( dwRetCode );
        return;
    }

    // now tell the service controller that we are up
    //
    if (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
    {
        AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
        AfpGlobals.ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
		    			          SERVICE_ACCEPT_PAUSE_CONTINUE;
        AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
        AfpGlobals.ServiceStatus.dwWaitHint         = 0;

        AfpAnnounceServiceStatus();
    }


    // Start listening for RPC admin client calls. This will block
    // until RpcMgmtStopServerListening is called while processing a
    // STOP_SERVICE control request.
    //
    if ( dwRetCode = RpcServerListen( 1,
				      RPC_C_LISTEN_MAX_CALLS_DEFAULT,
				      0 ) )	// Blocking mode
    {

	    AfpLogEvent( AFPLOG_CANT_INIT_RPC, 0, NULL,
		                        dwRetCode, EVENTLOG_ERROR_TYPE );
    }

    AfpCleanupAndExit( dwRetCode );

}

//**
//
// Call:	AfpCleanupAndExit
//
// Returns:	none
//
// Description: Will free any allocated memory, deinitialize RPC, deinitialize
//		the kernel-mode server and unload it if it was loaded.
//		This could have been called due to an error on SERVICE_START
//		or normal termination.
//
VOID
AfpCleanupAndExit(
	IN DWORD dwError
)
{

    AFP_PRINT( ("AFPSVC_main: Cleaning up and exiting Code = %d\n", dwError));

    // Tear down and free everything
    //
    AfpTerminate();

    if ( dwError == NO_ERROR )
    	AfpGlobals.ServiceStatus.dwWin32ExitCode = NO_ERROR;
    else {
    	AfpGlobals.ServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
	//AFP_ASSERT(0);
    }

    AfpGlobals.ServiceStatus.dwCurrentState 		= SERVICE_STOPPED;
    AfpGlobals.ServiceStatus.dwCheckPoint   		= 0;
    AfpGlobals.ServiceStatus.dwWaitHint     		= 0;
    AfpGlobals.ServiceStatus.dwServiceSpecificExitCode 	= dwError;

    AfpAnnounceServiceStatus();

    return;
}

//**
//
// Call:	AfpControlResponse
//
// Returns:	none
//
// Description: Will respond to control requests from the service controller.
//
VOID
AfpControlResponse( IN DWORD dwControlCode )
{
AFP_REQUEST_PACKET	AfpRequestPkt;
DWORD			dwRetCode;

    switch( dwControlCode ) {

    case SERVICE_CONTROL_STOP:

	if ( (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
	     ||
	     (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_STOPPED ))
	    break;

	// Announce that we are stopping
	//
    	AfpGlobals.ServiceStatus.dwCurrentState        = SERVICE_STOP_PENDING;
    	AfpGlobals.ServiceStatus.dwControlsAccepted    = 0;
    	AfpGlobals.ServiceStatus.dwCheckPoint          = 1;
    	AfpGlobals.ServiceStatus.dwWaitHint            = AFP_SERVICE_STOP_TIME;

    	AfpAnnounceServiceStatus();

        // if srvrhlpr thread is blocked retrying to get domain info, unblock it
        SetEvent(AfpGlobals.heventSrvrHlprSpecial);

        // if srvrhlpr thread was blocked, no more init was done, so we're done
        if (AfpGlobals.dwServerState & AFPSTATE_BLOCKED_ON_DOMINFO)
        {
            return;
        }

	// This call will unblock the main thread that had called
	// RpcServerListen. We let that thread do the announcing
	// while cleaning up.
	//
    if ( (dwRetCode = 
            RpcMgmtStopServerListening( (RPC_BINDING_HANDLE)NULL ))
            != RPC_S_OK )
    {
        ASSERT (0);
    }


	return;

    case SERVICE_CONTROL_PAUSE:

	if ( (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING)
	     ||
	     (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_PAUSED ))
	    break;

    	AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_PAUSE_PENDING;
    	AfpGlobals.ServiceStatus.dwControlsAccepted = 0;
    	AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
    	AfpGlobals.ServiceStatus.dwWaitHint 	    = AFP_SERVICE_PAUSE_TIME;

    	AfpAnnounceServiceStatus();


	// Tell the kernel-mode that we want to pause.
  	//
	AfpRequestPkt.dwRequestCode = OP_SERVICE_PAUSE;
        AfpRequestPkt.dwApiType     = AFP_API_TYPE_COMMAND;

	dwRetCode = AfpServerIOCtrl( &AfpRequestPkt );

	AFP_ASSERT( dwRetCode == NO_ERROR );

    	AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
    	AfpGlobals.ServiceStatus.dwWaitHint         = 0;
    	AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_PAUSED;
    	AfpGlobals.ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
					          SERVICE_ACCEPT_PAUSE_CONTINUE;
	break;

    case SERVICE_CONTROL_CONTINUE:

	if ( (AfpGlobals.ServiceStatus.dwCurrentState==SERVICE_CONTINUE_PENDING)
	     ||
	     (AfpGlobals.ServiceStatus.dwCurrentState == SERVICE_RUNNING ))
	    break;

    	AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_CONTINUE_PENDING;
    	AfpGlobals.ServiceStatus.dwControlsAccepted = 0;
    	AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
    	AfpGlobals.ServiceStatus.dwWaitHint         = AFP_SERVICE_CONTINUE_TIME;

    	AfpAnnounceServiceStatus();

	// Tell the kernel-mode that we want to continue.
  	//
	AfpRequestPkt.dwRequestCode = OP_SERVICE_CONTINUE;
        AfpRequestPkt.dwApiType     = AFP_API_TYPE_COMMAND;

	dwRetCode = AfpServerIOCtrl( &AfpRequestPkt );

	AFP_ASSERT( dwRetCode == NO_ERROR );

    	AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
    	AfpGlobals.ServiceStatus.dwWaitHint 	    = 0;
    	AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
    	AfpGlobals.ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
					          SERVICE_ACCEPT_PAUSE_CONTINUE;

	break;

    case SERVICE_CONTROL_INTERROGATE:
	break;

    default:
	break;

    }

    AfpAnnounceServiceStatus();
}

//**
//
// Call:	AfpAnnounceServiceStatus
//
// Returns:	none
//
// Description: Will simly call SetServiceStatus to inform the service
//		control manager of this service's current status.
//
VOID
AfpAnnounceServiceStatus( VOID )
{
BOOL dwRetCode;


    dwRetCode = SetServiceStatus( AfpGlobals.hServiceStatus,
				  &(AfpGlobals.ServiceStatus) );

    AFP_ASSERT( dwRetCode == TRUE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\stats.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	stats.c
//
// Description: This module contains support routines for the statistics
//		category API's for the AFP server service. These routines
//		are called by the RPC runtime.
//
// History:
//		July 21,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:	AfpAdminrStatisticsGet
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminStatisticsGet function.
//
DWORD
AfpAdminrStatisticsGet(
	IN  AFP_SERVER_HANDLE     hServer,
	OUT PAFP_STATISTICS_INFO* ppAfpStatisticsInfo
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		    dwRetCode=0;
DWORD		    dwAccessStatus=0;
AFP_STATISTICS_INFO afpStats;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsGet, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsGet, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_GET_STATISTICS;
    AfpSrp.dwApiType     		= AFP_API_TYPE_GETINFO;
    AfpSrp.Type.GetInfo.pInputBuf     	= &afpStats;
    AfpSrp.Type.GetInfo.cbInputBufSize  = sizeof( afpStats );

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *ppAfpStatisticsInfo = (PAFP_STATISTICS_INFO)AfpSrp.Type.GetInfo.pOutputBuf;

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrStatisticsGetEx
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminStatisticsGet function.
//
DWORD
AfpAdminrStatisticsGetEx(
	IN  AFP_SERVER_HANDLE     hServer,
	OUT PAFP_STATISTICS_INFO_EX* ppAfpStatisticsInfo
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		    dwRetCode=0;
DWORD		    dwAccessStatus=0;
AFP_STATISTICS_INFO_EX afpStats;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsGetEx, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsGetEx, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_GET_STATISTICS_EX;
    AfpSrp.dwApiType     		= AFP_API_TYPE_GETINFO;
    AfpSrp.Type.GetInfo.pInputBuf     	= &afpStats;
    AfpSrp.Type.GetInfo.cbInputBufSize  = sizeof( afpStats );

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *ppAfpStatisticsInfo = (PAFP_STATISTICS_INFO_EX)AfpSrp.Type.GetInfo.pOutputBuf;

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrStatisticsClear
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminFileClose function.
//
DWORD
AfpAdminrStatisticsClear(
	IN AFP_SERVER_HANDLE 	hServer
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwAccessStatus=0;
DWORD		   dwRetCode=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsClear, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrStatisticsClear, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // IOCTL the FSD to clear the statistics
    //
    AfpSrp.dwRequestCode = OP_CLEAR_STATISTICS;
    AfpSrp.dwApiType     = AFP_API_TYPE_COMMAND;

    return ( AfpServerIOCtrl( &AfpSrp ) );
}



//**
//
// Call:	AfpAdminrProfileGet
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminProfileGet function.
//
DWORD
AfpAdminrProfileGet(
	IN  AFP_SERVER_HANDLE     hServer,
	OUT PAFP_PROFILE_INFO *   ppAfpProfileInfo
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		    dwRetCode=0;
DWORD		    dwAccessStatus=0;
AFP_PROFILE_INFO afpProfs;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrProfileGet, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrProfileGet, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_GET_PROF_COUNTERS;
    AfpSrp.dwApiType     		= AFP_API_TYPE_GETINFO;
    AfpSrp.Type.GetInfo.pInputBuf     	= &afpProfs;
    AfpSrp.Type.GetInfo.cbInputBufSize  = sizeof( afpProfs );

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *ppAfpProfileInfo = (PAFP_PROFILE_INFO)AfpSrp.Type.GetInfo.pOutputBuf;

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrProfileClear
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminProfileClear function.
//
DWORD
AfpAdminrProfileClear(
	IN AFP_SERVER_HANDLE 	hServer
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwAccessStatus=0;
DWORD		   dwRetCode=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrProfileClear, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrProfileClear, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // IOCTL the FSD to clear the statistics
    //
    AfpSrp.dwRequestCode = OP_CLEAR_PROF_COUNTERS;
    AfpSrp.dwApiType     = AFP_API_TYPE_COMMAND;

    return ( AfpServerIOCtrl( &AfpSrp ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\session.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	session.c
//
// Description: This module contains support routines for the session
//		category API's for the AFP server service. These routines
//		will be called by the RPC runtime.
//
// History:
//		June 21,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"


//**
//
// Call:	AfpAdminrSessionEnum
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminSessionEnum function.
//
DWORD
AfpAdminrSessionEnum(
	IN     AFP_SERVER_HANDLE 	hServer,
	IN OUT PSESSION_INFO_CONTAINER  pInfoStruct,
	IN     DWORD 		  	dwPreferedMaximumLength,
	OUT    LPDWORD 		  	lpdwTotalEntries,
	IN OUT LPDWORD 		  	lpdwResumeHandle
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;

    AFP_PRINT( ( "AFPSVC_session: Received enum request\n"));	

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrSessionEnum, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrSessionEnum, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_SESSION_ENUM;
    AfpSrp.dwApiType     		= AFP_API_TYPE_ENUM;
    AfpSrp.Type.Enum.cbOutputBufSize    = dwPreferedMaximumLength;

    if ( lpdwResumeHandle )
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = *lpdwResumeHandle;
    else
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = 0;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *lpdwTotalEntries          = AfpSrp.Type.Enum.dwTotalAvail;
    pInfoStruct->pBuffer     = (PAFP_SESSION_INFO)(AfpSrp.Type.Enum.pOutputBuf);
    pInfoStruct->dwEntriesRead = AfpSrp.Type.Enum.dwEntriesRead;

    if ( lpdwResumeHandle )
    	*lpdwResumeHandle = AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index;

    // Convert all offsets to pointers
    //
    AfpBufOffsetToPointer( (LPBYTE)(pInfoStruct->pBuffer),
			   pInfoStruct->dwEntriesRead,
			   AFP_SESSION_STRUCT );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrSessionClose
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminSessionClose function.
//
DWORD
AfpAdminrSessionClose( IN AFP_SERVER_HANDLE 	hServer,
		       IN DWORD 		dwSessionId
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwAccessStatus=0;
AFP_SESSION_INFO   AfpSessionInfo;
DWORD	           dwRetCode=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrSessionClose, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrSessionClose, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // The FSD expects an AFP_SESSION_INFO structure with only the id field
    // filled in.
    //
    AfpSessionInfo.afpsess_id = dwSessionId;

    // IOCTL the FSD to close the session
    //
    AfpSrp.dwRequestCode 		= OP_SESSION_CLOSE;
    AfpSrp.dwApiType     		= AFP_API_TYPE_DELETE;
    AfpSrp.Type.Delete.pInputBuf     	= &AfpSessionInfo;
    AfpSrp.Type.Delete.cbInputBufSize   = sizeof(AFP_SESSION_INFO);

    return ( AfpServerIOCtrl( &AfpSrp ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\util.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	util.c
//
// Description: This module contains misc. utility routines.
//		
// History: 	May 11,1992.	NarenG		Created original version.
//
#include <nt.h>
#include <ntioapi.h>
#include <ntrtl.h>
#include <ntobapi.h>
#include <nturtl.h>     // needed for winbase.h
#include <afpsvcp.h>

#define PRIVILEGE_BUF_SIZE  512

//**
//
// Call:	AfpFSDOpen
//
// Returns:	0		- success
//		non-zero returns mapped to WIN32 errors.
//
// Description: Opens the AFP file system driver. It is opened in exclusive
//		mode.
//		NTOpenFile is used instead of it's WIN32 counterpart, since
//		WIN32 always prpends \Dos\devices to the file name. The AFP FSD
//		driver is not a dos device.
//
DWORD
AfpFSDOpen(
	OUT PHANDLE	phFSD
)
{
NTSTATUS		ntRetCode;
OBJECT_ATTRIBUTES	ObjectAttributes;
UNICODE_STRING	 	FSDName;
IO_STATUS_BLOCK		IoStatus;

    RtlInitUnicodeString( &FSDName, AFPSERVER_DEVICE_NAME );

    InitializeObjectAttributes( &ObjectAttributes,
				&FSDName,
				OBJ_CASE_INSENSITIVE,
				NULL,
				NULL );
			
			
    ntRetCode = NtOpenFile(phFSD,
			   SYNCHRONIZE,
			   &ObjectAttributes,
			   &IoStatus,
#ifdef DBG
			   FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
#else
			   0,
#endif
			   FILE_SYNCHRONOUS_IO_NONALERT );

    if ( NT_SUCCESS( ntRetCode ) )
	return( NO_ERROR );
    else
        return( RtlNtStatusToDosError( ntRetCode ) );
	
}

//**
//
// Call:	AfpFSDClose
//
// Returns:	0		- success
//		non-zero returns mapped to WIN32 errors.
//
// Description: Closes and the AFP file system driver.
//
DWORD
AfpFSDClose(
	IN HANDLE	hFSD
)
{
NTSTATUS	ntStatus;

    ntStatus = NtClose( hFSD );

    if ( !NT_SUCCESS( ntStatus ) )
        return( RtlNtStatusToDosError( ntStatus ) );

    return( NO_ERROR );
}

//**
//
// Call:	AfpFSDUnload
//
// Returns:	0		- success
//		non-zero returns mapped to WIN32 errors.
//
// Description: Unloads the AFP file system driver.
//
DWORD
AfpFSDUnload(
	VOID
)
{
NTSTATUS status;
LPWSTR registryPathBuffer;
UNICODE_STRING registryPath;

    registryPathBuffer = (LPWSTR)MIDL_user_allocate(
                                    sizeof(AFPSERVER_REGISTRY_KEY) );

    if ( registryPathBuffer == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    wcscpy( registryPathBuffer, AFPSERVER_REGISTRY_KEY );

    RtlInitUnicodeString( &registryPath, registryPathBuffer );

	// Wait here for all the server helper threads to terminate
	if (AfpGlobals.nThreadCount > 0)
        WaitForSingleObject( AfpGlobals.heventSrvrHlprThreadTerminate, INFINITE );

    status = NtUnloadDriver( &registryPath );

    MIDL_user_free( registryPathBuffer );

    return( RtlNtStatusToDosError( status ));
}

//**
//
// Call:	AfpFSDLoad
//
// Returns:	0		- success
//		non-zero returns mapped to WIN32 errors.
//
// Description: Loads the AFP file system driver.
//
DWORD
AfpFSDLoad(
	VOID
)
{
NTSTATUS status;
LPWSTR registryPathBuffer;
UNICODE_STRING registryPath;
BOOLEAN fEnabled;

    registryPathBuffer = (LPWSTR)MIDL_user_allocate(
                                    sizeof(AFPSERVER_REGISTRY_KEY) );

    if ( registryPathBuffer == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    status = RtlAdjustPrivilege( SE_LOAD_DRIVER_PRIVILEGE,
				 TRUE,
				 FALSE,
				 &fEnabled );

    if ( !NT_SUCCESS( status ) ) {
        MIDL_user_free( registryPathBuffer );
    	return( RtlNtStatusToDosError( status ));
    }

    wcscpy( registryPathBuffer, AFPSERVER_REGISTRY_KEY );

    RtlInitUnicodeString( &registryPath, registryPathBuffer );

    status = NtLoadDriver( &registryPath );

    MIDL_user_free( registryPathBuffer );

    if ( status == STATUS_IMAGE_ALREADY_LOADED )
	status = STATUS_SUCCESS;

    return( RtlNtStatusToDosError( status ));
}

//**
//
// Call:	AfpFSDIOControl
//
// Returns:	0		- success
//		AFPERR		- Macintosh specific errors.
//		non-zero returns mapped to WIN32 errors.
//		
//
// Description: Will ioctl the AFP FSD.
//		NtDeviceIoControlFile api is used to communicate with the FSD
//		instead of it's WIN32 counterpart because the WIN32 version
//		maps all return codes to WIN32 error codes. This runs into
//		problems when AFPERR_XXX error codes are returned.
//
DWORD
AfpFSDIOControl(
	IN  HANDLE	hFSD,
	IN  DWORD 	dwOpCode,
	IN  PVOID	pInbuf 		OPTIONAL,
	IN  DWORD	cbInbufLen,
	OUT PVOID	pOutbuf 	OPTIONAL,
	IN  DWORD	cbOutbufLen,
	OUT LPDWORD	lpcbBytesTransferred
)
{
NTSTATUS	 ntRetCode;
IO_STATUS_BLOCK	 IOStatus;


    ntRetCode = NtDeviceIoControlFile( 	   hFSD,
					   NULL,
					   NULL,
					   NULL,
					   &IOStatus,
					   dwOpCode,
					   pInbuf,
					   cbInbufLen,
					   pOutbuf,
					   cbOutbufLen );

    *lpcbBytesTransferred = (DWORD)(IOStatus.Information);

    if ( ntRetCode ) {

    	// If it is not an AFPERR_* then map it
    	//
    	if ( ( ntRetCode < AFPERR_BASE ) && ( ntRetCode >= AFPERR_MIN ) )
	    return( ntRetCode );
    	else
	    return( RtlNtStatusToDosError( ntRetCode ) );
    }
    else
	return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
DWORD
AfpCreateServerHelperThread(
	BOOL fIsFirstThread
)
{
DWORD	dwId;

    if ( CreateThread(  NULL,
			0,
			AfpServerHelper,
			(LPVOID)((ULONG_PTR)fIsFirstThread),
			0,
			&dwId ) == NULL )
	return( GetLastError() );
    else
	return( NO_ERROR );
}

//**
//
// Call:
//
// Returns:
//
// Description:
//
VOID
AfpTerminateCurrentThread(
	VOID
)
{
    TerminateThread( GetCurrentThread(), NO_ERROR );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\security.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	security.c
//
// Description: This module contains code that will create and delete the
//		security object. It will also contain access checking calls.
//
// History:
//	June 21,1992.	NarenG		Created original version.
//
// NOTE: ??? The lpdwAccessStatus parameter for AccessCheckAndAuditAlarm
//	     returns junk. ???
//
#include "afpsvcp.h"

typedef struct _AFP_SECURITY_OBJECT {

    LPWSTR		  lpwsObjectName;
    LPWSTR		  lpwsObjectType;
    GENERIC_MAPPING	  GenericMapping;
    PSECURITY_DESCRIPTOR  pSecurityDescriptor;

} AFP_SECURITY_OBJECT, PAFP_SECURITY_OBJECT;

static AFP_SECURITY_OBJECT	AfpSecurityObject;

#define AFPSVC_SECURITY_OBJECT		TEXT("AfpSvcAdminApi");
#define AFPSVC_SECURITY_OBJECT_TYPE	TEXT("Security");



//**
//
// Call:	AfpSecObjCreate
//
// Returns:	NO_ERROR	- success
//		ERROR_NOT_ENOUGH_MEMORY
//		non-zero returns from security functions
//
// Description: This procedure will set up the security object that will
//		be used to check to see if an RPC client is an administrator
//		for the local machine.
//
DWORD
AfpSecObjCreate(
	VOID
)
{
PSID			 pAdminSid 	  = NULL;
PSID			 pLocalSystemSid  = NULL;
PSID 			 pServerOpSid     = NULL;
PSID             pPwrUserSid = NULL;
PACL			 pDacl		  = NULL;
HANDLE			 hProcessToken    = NULL;
PULONG			 pSubAuthority;
SID_IDENTIFIER_AUTHORITY SidIdentifierNtAuth = SECURITY_NT_AUTHORITY;
SECURITY_DESCRIPTOR	 SecurityDescriptor;
DWORD			 dwRetCode;
DWORD			 cbDaclSize;


    // Set up security object
    //
    AfpSecurityObject.lpwsObjectName = AFPSVC_SECURITY_OBJECT;
    AfpSecurityObject.lpwsObjectType = AFPSVC_SECURITY_OBJECT_TYPE;

    // Generic mapping structure for the security object
    // All generic access types are allowed API access.
    //
    AfpSecurityObject.GenericMapping.GenericRead =  STANDARD_RIGHTS_READ |
	    					    AFPSVC_ALL_ACCESS;

    AfpSecurityObject.GenericMapping.GenericWrite = STANDARD_RIGHTS_WRITE |
	    					    AFPSVC_ALL_ACCESS;

    AfpSecurityObject.GenericMapping.GenericExecute =
						    STANDARD_RIGHTS_EXECUTE |
						    AFPSVC_ALL_ACCESS;

    AfpSecurityObject.GenericMapping.GenericAll =   AFPSVC_ALL_ACCESS;

    // The do - while(FALSE) statement is used so that the break statement
    // maybe used insted of the goto statement, to execute a clean up and
    // and exit action.
    //
    do {

	    dwRetCode = NO_ERROR;

    	// Set up the SID for the admins that will be allowed to have
    	// access. This SID will have 2 sub-authorities
    	// SECURITY_BUILTIN_DOMAIN_RID and DOMAIN_ALIAS_ADMIN_RID.
    	//
    	pAdminSid = (PSID)LocalAlloc( LPTR, GetSidLengthRequired( 2 ) );

    	if ( pAdminSid == NULL ) {
	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
	}

    	if ( !InitializeSid( pAdminSid, &SidIdentifierNtAuth, 2 ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	// Set the sub-authorities
    	//
    	pSubAuthority  = GetSidSubAuthority( pAdminSid, 0 );
    	*pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

    	pSubAuthority  = GetSidSubAuthority( pAdminSid, 1 );
    	*pSubAuthority = DOMAIN_ALIAS_RID_ADMINS;

	    // Create the server operators SID
	    //
    	pServerOpSid = (PSID)LocalAlloc( LPTR, GetSidLengthRequired( 2 ) );

    	if ( pServerOpSid == NULL )
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

    	if ( !InitializeSid( pServerOpSid, &SidIdentifierNtAuth, 2 ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	// Set the sub-authorities
    	//
    	pSubAuthority  = GetSidSubAuthority( pServerOpSid, 0 );
    	*pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

    	pSubAuthority  = GetSidSubAuthority( pServerOpSid, 1 );
    	*pSubAuthority = DOMAIN_ALIAS_RID_SYSTEM_OPS;

        //
	    // Create the Power user operators SID
	    //
    	pPwrUserSid = (PSID)LocalAlloc( LPTR, GetSidLengthRequired( 2 ) );

    	if ( pPwrUserSid == NULL )
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

    	if ( !InitializeSid( pPwrUserSid, &SidIdentifierNtAuth, 2 ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	// Set the sub-authorities
    	//
    	pSubAuthority  = GetSidSubAuthority( pPwrUserSid, 0 );
    	*pSubAuthority = SECURITY_BUILTIN_DOMAIN_RID;

    	pSubAuthority  = GetSidSubAuthority( pPwrUserSid, 1 );
    	*pSubAuthority = DOMAIN_ALIAS_RID_POWER_USERS;

    	// Create the LocalSystemSid which will be the owner and the primary
    	// group of the security object.
    	//
    	pLocalSystemSid = (PSID)LocalAlloc( LPTR, GetSidLengthRequired( 1 ) );

    	if ( pLocalSystemSid == NULL )
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }

    	if ( !InitializeSid( pLocalSystemSid, &SidIdentifierNtAuth, 1 ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	// Set the sub-authorities
    	//
    	pSubAuthority = GetSidSubAuthority( pLocalSystemSid, 0 );
    	*pSubAuthority = SECURITY_LOCAL_SYSTEM_RID;

    	// Set up the DACL that will allow admins with the above SID all access
    	// It should be large enough to hold all ACEs.
    	//
    	cbDaclSize = sizeof(ACL) + ( sizeof(ACCESS_ALLOWED_ACE) * 2 ) +
		     GetLengthSid(pAdminSid) + GetLengthSid(pServerOpSid) + GetLengthSid(pPwrUserSid);
		
    	if ( (pDacl = (PACL)LocalAlloc( LPTR, cbDaclSize ) ) == NULL )
        {
	        dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	        break;
	    }
	
        if ( !InitializeAcl( pDacl,  cbDaclSize, ACL_REVISION2 ) )
        {
	        dwRetCode = GetLastError();
	        break;
 	    }

        // Add the ACE to the DACL
    	//
    	if ( !AddAccessAllowedAce( pDacl,
			           ACL_REVISION2,
			           AFPSVC_ALL_ACCESS, // What the admin can do
			           pAdminSid ))
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	if ( !AddAccessAllowedAce( pDacl,
			           ACL_REVISION2,
			           AFPSVC_ALL_ACCESS, // What the admin can do
			           pServerOpSid ))
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	if ( !AddAccessAllowedAce( pDacl,
			           ACL_REVISION2,
			           AFPSVC_ALL_ACCESS, // What the power user can do
			           pPwrUserSid ))
        {
	        dwRetCode = GetLastError();
	        break;
	    }

        // Create the security descriptor an put the DACL in it.
    	//
    	if ( !InitializeSecurityDescriptor( &SecurityDescriptor, 1 ))
        {
	        dwRetCode = GetLastError();
	        break;
    	}

    	if ( !SetSecurityDescriptorDacl( &SecurityDescriptor,
					 TRUE,
					 pDacl,
					 FALSE ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }
	

	    // Set owner for the descriptor
   	    //
    	if ( !SetSecurityDescriptorOwner( &SecurityDescriptor,
					  pLocalSystemSid,
					  FALSE ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }


	    // Set group for the descriptor
   	    //
    	if ( !SetSecurityDescriptorGroup( &SecurityDescriptor,
					  pLocalSystemSid,
					  FALSE ) )
        {
	        dwRetCode = GetLastError();
	        break;
	    }

    	// Get token for the current process
    	//
    	if ( !OpenProcessToken( GetCurrentProcess(),
				TOKEN_QUERY,
				&hProcessToken ))
        {
	        dwRetCode = GetLastError();
	        break;
    	}

    	// Create a security object. This is really just a security descriptor
    	// is self-relative form. This procedure will allocate memory for this
    	// security descriptor and copy all in the information passed in. This
    	// allows us to free all dynamic memory allocated.
    	//
    	if ( !CreatePrivateObjectSecurity(
				      NULL,
				      &SecurityDescriptor,
				      &(AfpSecurityObject.pSecurityDescriptor),
				      FALSE,
				      hProcessToken,
    				      &(AfpSecurityObject.GenericMapping)
				     ))
	     dwRetCode = GetLastError();

    } while( FALSE );

	
    // Free up the dynamic memory
    //
    if ( pLocalSystemSid != NULL )
    	LocalFree( pLocalSystemSid );

    if ( pAdminSid != NULL )
    	LocalFree( pAdminSid );

    if ( pServerOpSid != NULL )
    	LocalFree( pServerOpSid );

    if ( pPwrUserSid != NULL )
    	LocalFree( pPwrUserSid );

    if ( pDacl != NULL )
    	LocalFree( pDacl );

    if ( hProcessToken != NULL )
    	CloseHandle( hProcessToken );

    return( dwRetCode );

}

//**
//
// Call:	AfpSecObjDelete
//
// Returns:	NO_ERROR	- success
//		non-zero returns from security functions
//
// Description: Will destroy a valid security descriptor.
//
DWORD
AfpSecObjDelete( VOID )
{
    if ( !IsValidSecurityDescriptor( AfpSecurityObject.pSecurityDescriptor))
    	return( NO_ERROR );

    if (!DestroyPrivateObjectSecurity( &AfpSecurityObject.pSecurityDescriptor))
	return( GetLastError() );

    return( NO_ERROR );
}

//**
//
// Call:	AfpSecObjAccessCheck
//
// Returns:	NO_ERROR	- success
//		non-zero returns from security functions
//
// Description: This procedure will first impersonate the client, then
//		check to see if the client has the desired access to the
//		security object. If he/she does then the AccessStatus
//		variable will be set to NO_ERROE otherwise it will be
//		set to ERROR_ACCESS_DENIED. It will the revert to self and
//		return.
//
DWORD
AfpSecObjAccessCheck( IN  DWORD 		DesiredAccess,
		      OUT LPDWORD 		lpdwAccessStatus 		
)
{
DWORD		dwRetCode;
ACCESS_MASK	GrantedAccess;
BOOL		fGenerateOnClose;

    // Impersonate the client
    //
    dwRetCode = RpcImpersonateClient( NULL );

    if ( dwRetCode != RPC_S_OK )
	return( I_RpcMapWin32Status( dwRetCode ));

    dwRetCode = AccessCheckAndAuditAlarm(
				    AFP_SERVICE_NAME,
				    NULL,
    				    AfpSecurityObject.lpwsObjectType,
				    AfpSecurityObject.lpwsObjectName,
				    AfpSecurityObject.pSecurityDescriptor,
				    DesiredAccess,
				    &(AfpSecurityObject.GenericMapping),
				    FALSE,
 			 	    &GrantedAccess,	
				    (LPBOOL)lpdwAccessStatus,
				    &fGenerateOnClose
				  );

    RpcRevertToSelf();

    if ( !dwRetCode )
	return( GetLastError() );

    // Check if desired access == granted Access
    //
    if ( DesiredAccess != GrantedAccess )
    {
        AFP_PRINT(( "SFMSVC: AfpSecObjAccessCheck: granted = 0x%x, desired = 0x%x\n",
            GrantedAccess,DesiredAccess));
	    *lpdwAccessStatus = ERROR_ACCESS_DENIED;
    }
    else
    {
	    *lpdwAccessStatus = NO_ERROR;
    }

    return( NO_ERROR );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\server.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	server.c
//
// Description: This module contains support routines for the server
//		category API's for the AFP server service. These routines
//		are called by the RPC runtime.
//
// History:
//		December 15,1992.	NarenG	   Created original version.
//
#include "afpsvcp.h"

//**
//
// Call:	AfpAdminrServerGetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero retunrs from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminServerGetInfo function.
//
DWORD
AfpAdminrServerGetInfo(
	IN  AFP_SERVER_HANDLE    hServer,
    	OUT PAFP_SERVER_INFO*    ppAfpServerInfo
)
{
AFP_REQUEST_PACKET  AfpSrp;
DWORD		    dwRetCode=0;
DWORD		    dwAccessStatus=0;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrServerGetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrServerGetInfo, AfpSecObjAccessCheck returned %ld\n",dwRetCode));
        return( ERROR_ACCESS_DENIED );
    }

    // Make IOCTL to get info
    //
    AfpSrp.dwRequestCode 		= OP_SERVER_GET_INFO;
    AfpSrp.dwApiType     		= AFP_API_TYPE_GETINFO;
    AfpSrp.Type.GetInfo.pInputBuf	= NULL;
    AfpSrp.Type.GetInfo.cbInputBufSize  = 0;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *ppAfpServerInfo = (PAFP_SERVER_INFO)(AfpSrp.Type.GetInfo.pOutputBuf);

    // Convert all offsets to pointers
    //
    AfpBufOffsetToPointer((LPBYTE)*ppAfpServerInfo,1,AFP_SERVER_STRUCT);

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrServerSetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero retunrs from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminServerSetInfo function.
//
DWORD
AfpAdminrServerSetInfo(
	IN  AFP_SERVER_HANDLE    hServer,
    	IN  PAFP_SERVER_INFO     pAfpServerInfo,
	IN  DWORD		 dwParmNum
)
{
AFP_REQUEST_PACKET  AfpSrp;
PAFP_SERVER_INFO    pAfpServerInfoSR;
DWORD 		    cbAfpServerInfoSRSize;
DWORD		    dwRetCode=0;
DWORD		    dwAccessStatus=0;
LPWSTR		    lpwsServerName = NULL;



    //
    // if this is a "notification" that Guest account changed (disable to enable
    // or vice versa), don't bother checking access for caller: see if guest
    // account was indeed flipped, and let afp server know.
    // NOTICE we don't do (dwParmNum & AFP_SERVER_GUEST_ACCT_NOTIFY) here, as an
    // extra precaution.
    //
    if (dwParmNum == AFP_SERVER_GUEST_ACCT_NOTIFY)
    {
        if (pAfpServerInfo->afpsrv_options ^
                (AfpGlobals.dwServerOptions & AFP_SRVROPT_GUESTLOGONALLOWED))
        {
            AfpGlobals.dwServerOptions ^= AFP_SRVROPT_GUESTLOGONALLOWED;
        }
        else
        {
            AFP_PRINT(( "AFPSVC_server: no change in GuestAcct, nothing done\n"));	
            return(NO_ERROR);
        }
    }

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "AFPSVC_server: Sorry, accessCheck failed! %ld\n",dwRetCode));	
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
                     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(("AFPSVC_server: Sorry, accessCheck failed at 2! %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Check to see if the client wants to set the server name as well
    //
    if ( dwParmNum & AFP_SERVER_PARMNUM_NAME )
    {
	    lpwsServerName = pAfpServerInfo->afpsrv_name;
	    pAfpServerInfo->afpsrv_name = NULL;
	    dwParmNum &= (~AFP_SERVER_PARMNUM_NAME);
    }

    // Make buffer self relative.
    //
    if ( dwRetCode = AfpBufMakeFSDRequest(  (LPBYTE)pAfpServerInfo,
					    sizeof(SETINFOREQPKT),
					    AFP_SERVER_STRUCT,
					    (LPBYTE*)&pAfpServerInfoSR,
					    &cbAfpServerInfoSRSize ) )
    {
	    return( dwRetCode );
    }

    // Make IOCTL to set info
    //
    AfpSrp.dwRequestCode 		= OP_SERVER_SET_INFO;
    AfpSrp.dwApiType     		= AFP_API_TYPE_SETINFO;
    AfpSrp.Type.SetInfo.pInputBuf     	= pAfpServerInfoSR;
    AfpSrp.Type.SetInfo.cbInputBufSize  = cbAfpServerInfoSRSize;
    AfpSrp.Type.SetInfo.dwParmNum       = dwParmNum;

    dwRetCode = AfpServerIOCtrl( &AfpSrp );

    if ( dwRetCode == NO_ERROR )
    {

   	    LPBYTE pServerInfo;

        // guest-account notification? nothing to write to registry, done here
        if (dwParmNum == AFP_SERVER_GUEST_ACCT_NOTIFY)
        {
            LocalFree( pAfpServerInfoSR );
            return( dwRetCode );
        }

	    // If the client wants to set the servername as well
	    //
	    if ( lpwsServerName != NULL ) {

	        LocalFree( pAfpServerInfoSR );

    	    // Make another self relative buffer with the server name.
    	    //
	        pAfpServerInfo->afpsrv_name = lpwsServerName;

	        dwParmNum |= AFP_SERVER_PARMNUM_NAME;
	
    	    if ( dwRetCode = AfpBufMakeFSDRequest(
			    	    (LPBYTE)pAfpServerInfo,
				        sizeof(SETINFOREQPKT),
				        AFP_SERVER_STRUCT,
    				    (LPBYTE*)&pAfpServerInfoSR,
	    			    &cbAfpServerInfoSRSize ) )
            {
		        return( dwRetCode );
            }
            AfpSrp.dwRequestCode 		= OP_SERVER_SET_INFO;
            AfpSrp.dwApiType     		= AFP_API_TYPE_SETINFO;
            AfpSrp.Type.SetInfo.pInputBuf     	= pAfpServerInfoSR;
            AfpSrp.Type.SetInfo.cbInputBufSize  = cbAfpServerInfoSRSize;
            AfpSrp.Type.SetInfo.dwParmNum       = dwParmNum;

            dwRetCode = AfpServerIOCtrl( &AfpSrp );
	    }

   	    pServerInfo = ((LPBYTE)pAfpServerInfoSR)+sizeof(SETINFOREQPKT);

        if (dwRetCode == NO_ERROR)
        {
 	        dwRetCode = AfpRegServerSetInfo( (PAFP_SERVER_INFO)pServerInfo,
		    		         dwParmNum );
        }
        else
        {
            AFP_PRINT(("AFPSVC_server: AfpServerIOCtrl failed %lx\n",dwRetCode));
        }
    }


    LocalFree( pAfpServerInfoSR );

    return( dwRetCode );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\validate.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	validate.c
//
// Description: Contains routines to validate AFP_***_INFO structure
//		fields. These routines are called to validate information
//		passed by the user and information read from the registry.
//
// History:
//		July 11,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"
#include <lmcons.h>		// UNLEN and GNLEN

//**
//
// Call:	IsAfpServerNameValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validated server name field.
//
BOOL
IsAfpServerNameValid(
	IN LPVOID pAfpServerName
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

	dwLength = STRLEN( (LPWSTR)pAfpServerName );

	if ( ( dwLength > AFP_SERVERNAME_LEN ) || ( dwLength == 0 ) )
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpServerOptionsValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates Server options field.
//
BOOL
IsAfpServerOptionsValid(
	IN LPVOID pServerOptions
)
{
DWORD ServerOptions = *((LPDWORD)pServerOptions);
BOOL  fValid = TRUE;

    try {

    	// Make sure only valid bits are set
    	//
    	if ( ServerOptions & ~( AFP_SRVROPT_GUESTLOGONALLOWED       |
			                    AFP_SRVROPT_CLEARTEXTLOGONALLOWED   |
			                    AFP_SRVROPT_4GB_VOLUMES             |
                                AFP_SRVROPT_MICROSOFT_UAM           |
                                AFP_SRVROPT_NATIVEAPPLEUAM          |
			                    AFP_SRVROPT_ALLOWSAVEDPASSWORD ))
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
	
}

//**
//
// Call:	IsAfpMaxSessionsValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates Max sessions field.
//
BOOL
IsAfpMaxSessionsValid(
	IN LPVOID pMaxSessions
)
{
BOOL fValid = TRUE;

    try {

    	if ( *((LPDWORD)pMaxSessions) > AFP_MAX_ALLOWED_SRV_SESSIONS )
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpMsgValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates message field.
//
BOOL
IsAfpMsgValid(
	IN LPVOID pMsg
)
{
BOOL fValid = TRUE;

    try {
    	if ( STRLEN( (LPWSTR)pMsg ) > AFP_MESSAGE_LEN )
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpCodePageValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates code page path.
//
BOOL
IsAfpCodePageValid(
	IN LPVOID pCodePagePath
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

  	dwLength = STRLEN( (LPWSTR)pCodePagePath );

	if ( ( dwLength == 0 ) || ( dwLength > MAX_PATH ) )
	    fValid = FALSE;

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpExtensionValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validated the extension field in the AFP_EXTENSION structure.
//
BOOL
IsAfpExtensionValid(
	IN PAFP_EXTENSION pAfpExtension
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

	// NULL extensions are not allowed
	//
	dwLength = STRLEN( pAfpExtension->afpe_extension );

	if ( ( dwLength == 0  ) || ( dwLength > AFP_EXTENSION_LEN ) )
	    fValid = FALSE;

        STRUPR( pAfpExtension->afpe_extension );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpMaxPagedMemValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates Max. pages memory field.
//
BOOL
IsAfpMaxPagedMemValid(
	IN LPVOID pMaxPagedMem
)
{
BOOL fValid = TRUE;

    try {

    	if ((*((LPDWORD)pMaxPagedMem) < AFP_MIN_ALLOWED_PAGED_MEM ) ||
	    (*((LPDWORD)pMaxPagedMem) > AFP_MAX_ALLOWED_PAGED_MEM ))
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpServerInfoValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates the AFP_SERER_INFO structure.
//
BOOL
IsAfpServerInfoValid(
        IN DWORD		dwParmNum,
	IN PAFP_SERVER_INFO	pAfpServerInfo
)
{

    // Can only set 5 fields
    //
    if ( dwParmNum & ~( AFP_SERVER_PARMNUM_MAX_SESSIONS |
			AFP_SERVER_PARMNUM_OPTIONS      |
			AFP_SERVER_PARMNUM_NAME         |
			AFP_SERVER_PARMNUM_LOGINMSG     |
            AFP_SERVER_GUEST_ACCT_NOTIFY ))
	return( FALSE );

    // Null out the fields the are not allowed to be set so that RPC does
    // not think that they are valid pointers.
    //
    pAfpServerInfo->afpsrv_codepage = NULL;

    if ( dwParmNum & AFP_SERVER_PARMNUM_NAME ){

	if ( pAfpServerInfo->afpsrv_name != NULL ) {

	    if ( !IsAfpServerNameValid( pAfpServerInfo->afpsrv_name ) )
	    	return( FALSE );
	}
    }
    else
	pAfpServerInfo->afpsrv_name = NULL;

    if ( dwParmNum & AFP_SERVER_PARMNUM_MAX_SESSIONS ) {

	if ( !IsAfpMaxSessionsValid( &(pAfpServerInfo->afpsrv_max_sessions) ))
	    return( FALSE );
    }

    if ( dwParmNum & AFP_SERVER_PARMNUM_OPTIONS ){

	if ( !IsAfpServerOptionsValid( &(pAfpServerInfo->afpsrv_options) ))
	    return( FALSE );
    }

    if ( dwParmNum & AFP_SERVER_PARMNUM_LOGINMSG ){

	if ( pAfpServerInfo->afpsrv_login_msg != NULL ) {

	    if( !IsAfpMsgValid( pAfpServerInfo->afpsrv_login_msg ) )
	    	return( FALSE );
	}
    }
    else
	pAfpServerInfo->afpsrv_login_msg = NULL;

    return( TRUE );
}

//**
//
// Call:	IsAfpTypeCreatorValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates the AFP_TYPE_CREATOR structure.
//
BOOL
IsAfpTypeCreatorValid(
	IN PAFP_TYPE_CREATOR	pAfpTypeCreator
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

	dwLength = STRLEN( pAfpTypeCreator->afptc_type );

	if ( ( dwLength == 0 ) || ( dwLength > AFP_TYPE_LEN ) )
	    fValid = FALSE;

	dwLength =  STRLEN( pAfpTypeCreator->afptc_creator );

	if ( ( dwLength == 0 ) || ( dwLength > AFP_CREATOR_LEN ) )
	    fValid = FALSE;

	dwLength = STRLEN(pAfpTypeCreator->afptc_comment);

	if ( dwLength > AFP_ETC_COMMENT_LEN )
	    fValid = FALSE;

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );

}

//**
//
// Call:	IsAfpMaxNonPagedMemValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates the max non-paged memory field.
//
BOOL
IsAfpMaxNonPagedMemValid(
	IN LPVOID pMaxNonPagedMem
)
{
BOOL fValid = TRUE;

    try {

    	if ((*((LPDWORD)pMaxNonPagedMem) < AFP_MIN_ALLOWED_NONPAGED_MEM )  ||
	    (*((LPDWORD)pMaxNonPagedMem) > AFP_MAX_ALLOWED_NONPAGED_MEM ))
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpVolumeInfoValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Wil validate a volume info structure and the associated
//		parm number. If the parm number is zero it is assume that
//		the user is trying to add a volume vs. trying to set
//		information for that volume. If the parm number is not
//		zero, then all string pointer values that are not being
//		set by the user, are set to NULL, otherwise RPC might mistake
//		these fields for valid string poiters.
//		
//
BOOL
IsAfpVolumeInfoValid(
	IN DWORD		dwParmNum,
        IN PAFP_VOLUME_INFO     pAfpVolume
)
{
BOOL fValid = TRUE;

    if ( !IsAfpVolumeNameValid( pAfpVolume->afpvol_name ) )
	return( FALSE );
	
    try {

	// User is wants to set info
	//
  	if ( dwParmNum != AFP_VALIDATE_ALL_FIELDS ) {

    	    if ( ~AFP_VOL_PARMNUM_ALL & dwParmNum )
		fValid = FALSE;

            if ( dwParmNum & AFP_VOL_PARMNUM_PASSWORD  ){
		
		// Validate password
		//
	        if ( pAfpVolume->afpvol_password != NULL
		     &&
		     ( STRLEN(pAfpVolume->afpvol_password) > AFP_VOLPASS_LEN ))
		    fValid = FALSE;
	    }
	    else
    	    	pAfpVolume->afpvol_password = NULL;
	
            if ( dwParmNum & AFP_VOL_PARMNUM_PROPSMASK ) {
		
	        if ( ~AFP_VOLUME_ALL & pAfpVolume->afpvol_props_mask )
		    fValid = FALSE;
	    }

	    // Set path to NULL since user cannot change this
	    //
            pAfpVolume->afpvol_path = NULL;

	}
	else {

	    if ( pAfpVolume->afpvol_password != NULL
		 &&
		 ( STRLEN(pAfpVolume->afpvol_password) > AFP_VOLPASS_LEN ))
		fValid = FALSE;

	    if ( ~AFP_VOLUME_ALL & pAfpVolume->afpvol_props_mask )
		fValid = FALSE;

	    // Just make sure this is a valid string pointer
	    //
	    STRLEN( pAfpVolume->afpvol_path );

	}
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );

}

//**
//
// Call:	IsAfpVolumeNameValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Will validate the volume name
//
BOOL
IsAfpVolumeNameValid(
	IN LPWSTR 	lpwsVolumeName
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

	dwLength = STRLEN( lpwsVolumeName );

	if ( ( dwLength > AFP_VOLNAME_LEN ) || ( dwLength == 0 ) )
	    fValid = FALSE;
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpDirInfoValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Will validate various field in the AFP_VOLUME_INFO
//		structure depending on the parm number.
//
BOOL
IsAfpDirInfoValid(
	IN DWORD		dwParmNum,
	IN PAFP_DIRECTORY_INFO  pAfpDirInfo
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    if ( ~AFP_DIR_PARMNUM_ALL & dwParmNum )
	return( FALSE );

    try {

	// Make sure path is a valid string
	//
	dwLength = STRLEN( pAfpDirInfo->afpdir_path );

	if ( ( dwLength == 0 ) || ( dwLength > MAX_PATH ) )
	    fValid = FALSE;

	if ( dwParmNum & AFP_DIR_PARMNUM_OWNER ) {

	    dwLength = STRLEN( pAfpDirInfo->afpdir_owner );

	    if ( ( dwLength == 0 ) || ( dwLength > UNLEN ) )
		fValid = FALSE;
	}
	else
	    pAfpDirInfo->afpdir_owner = NULL;

	if ( dwParmNum & AFP_DIR_PARMNUM_GROUP ){

	    dwLength = STRLEN( pAfpDirInfo->afpdir_group );

	    if ( ( dwLength == 0 ) || ( dwLength > GNLEN ) )
		fValid = FALSE;
	}
	else
	    pAfpDirInfo->afpdir_group = NULL;

	if ( dwParmNum & AFP_DIR_PARMNUM_PERMS ) {

	    if ( ~( AFP_PERM_OWNER_MASK  	 |
		    AFP_PERM_GROUP_MASK  	 |
		    AFP_PERM_WORLD_MASK 	 |
		    AFP_PERM_INHIBIT_MOVE_DELETE |
		    AFP_PERM_SET_SUBDIRS ) &
		pAfpDirInfo->afpdir_perms )

	    fValid = FALSE;
	
	}

    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpIconValid
//
// Returns:	TRUE  - valid
//		FALSE - invalid
//
// Description:	Will validate a AFP_ICON_INFO data structure.
//
BOOL
IsAfpIconValid(
	IN PAFP_ICON_INFO	pAfpIconInfo
)
{
BOOL  fValid = TRUE;
DWORD dwLength;

    try {

	dwLength = STRLEN( pAfpIconInfo->afpicon_type );

	if ( ( dwLength == 0 ) || ( dwLength > AFP_TYPE_LEN ) )
	    fValid = FALSE;

	dwLength = STRLEN( pAfpIconInfo->afpicon_creator );

	if ( ( dwLength == 0 ) || ( dwLength > AFP_CREATOR_LEN ) )
	    fValid = FALSE;

	switch( pAfpIconInfo->afpicon_icontype ) {
	
	case ICONTYPE_SRVR:
	case ICONTYPE_ICN:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICN )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	case ICONTYPE_ICS:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICS )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	case ICONTYPE_ICN4:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICN4 )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	case ICONTYPE_ICN8:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICN8 )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	case ICONTYPE_ICS4:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICS4 )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	case ICONTYPE_ICS8:
	    if ( pAfpIconInfo->afpicon_length == ICONSIZE_ICS8 )
	 	pAfpIconInfo->afpicon_data[pAfpIconInfo->afpicon_length-1];
	    else
	    	fValid = FALSE;
	    break;

	default:
	    fValid = FALSE;

	}
	
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

//**
//
// Call:	IsAfpFinderInfoValid
//
// Returns:	TRUE	- valid
//		FALSE	- invalid
//
// Description: Validates the Type, Creator, Path and ParmNum values
//
BOOL
IsAfpFinderInfoValid(
	IN LPWSTR		pType,
	IN LPWSTR		pCreator,
	IN LPWSTR		pData,
	IN LPWSTR		pResource,
	IN LPWSTR		pPath,
	IN DWORD		dwParmNum
)
{
BOOL  fValid = TRUE;

    try {

	if ( dwParmNum & ~AFP_FD_PARMNUM_ALL )
	    return( FALSE );

    	if ( STRLEN( pPath ) == 0 )
	    return( FALSE );

	if ( pData != NULL ) {
    	    if ( STRLEN( pData ) == 0 )
	    	return( FALSE );
	}

	if ( pResource != NULL ) {
    	    if ( STRLEN( pResource ) == 0 )
	    	return( FALSE );
	}

	if ( pType != NULL ) {
	    if ( ( STRLEN( pType ) == 0 ) ||
		 ( STRLEN( pType ) > AFP_TYPE_LEN ) )
	    	return( FALSE );
    	}

	if ( pCreator != NULL ) {

	    if ( ( STRLEN( pCreator ) == 0 ) ||
	         ( STRLEN( pCreator ) > AFP_CREATOR_LEN ) )
	    	return( FALSE );
    	}

        return( TRUE );
    }
    except( EXCEPTION_EXECUTE_HANDLER ) {
	fValid = FALSE;
    }

    return( fValid );
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\srvrhlpr.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	srvrhlpr.c
//
// Description: This module will contain code to process specific security
//		information requests by the server. This is done because
//		the api's required to obtain this information cannot be
//		called from kernel mode. The following functionality is
//		supported:
//
//		1) Name to Sid Lookup.
//		2) Sid to Name lookup.
//		3) Enumerate Posix offsets of all domains.
//		4) Change password.
//		5) Log an event.
//
// History: 	August 18,1992.	   NarenG     Created original version.
//
#include <afpsvcp.h>
#include <lm.h>
#include <logonmsv.h>	// prototype of I_NetGetDCList
#include <seposix.h>
#include <dsgetdc.h>

static PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo = NULL;
static PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo = NULL;

static HANDLE hmutexThreadCount = NULL;


NTSTATUS
AfpNameToSid(
	IN  LSA_HANDLE 	        	hLsa,
	IN  PAFP_FSD_CMD_PKT    	pAfpFsdCmd,
	OUT PAFP_FSD_CMD_PKT   		*ppAfpFsdCmdResponse,
	OUT LPDWORD			pcbResponse
);

NTSTATUS
AfpSidToName(
	IN  LSA_HANDLE 	        	hLsa,
	IN  PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo,
	IN  PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo,
	IN  PAFP_FSD_CMD_PKT    	pAfpFsdCmd,
	OUT PAFP_FSD_CMD_PKT   		*ppAfpFsdCmdResponse,
	OUT LPDWORD			pcbResponse
);

NTSTATUS
AfpChangePassword(
    IN  LSA_HANDLE                  hLsa,
	IN  PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo,
	IN  PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo,
	IN  PAFP_FSD_CMD_PKT    	pAfpFsdCmd,
	OUT PAFP_FSD_CMD_PKT   		*ppAfpFsdCmdResponse,
	OUT LPDWORD			pcbResponse
);

NTSTATUS
AfpChangePasswordOnDomain(
    	IN PAFP_PASSWORD_DESC 	   	pPassword,
    	IN PUNICODE_STRING	   	pDomainName,
    	IN PSID		  	   	pDomainSid
);

NTSTATUS
AfpCreateWellknownSids(
	OUT AFP_SID_OFFSET 		pWellKnownSids[]
);

NTSTATUS
AfpInsertSidOffset(
	IN PAFP_SID_OFFSET 		pSidOffset,
	IN LPBYTE 	   		pbVariableData,
	IN PSID		   		pSid,
	IN DWORD	   		Offset,
	IN AFP_SID_TYPE	   		SidType
);

DWORD
AfpGetDomainInfo(
	IN     LSA_HANDLE 		    hLsa,
	IN OUT PLSA_HANDLE 		    phLsaController,
	IN OUT PPOLICY_ACCOUNT_DOMAIN_INFO* ppAccountDomainInfo,
	IN OUT PPOLICY_PRIMARY_DOMAIN_INFO* ppPrimaryDomainInfo
);

DWORD
AfpIOCTLDomainOffsets(	
	IN LSA_HANDLE 			hLsa,
	IN PPOLICY_ACCOUNT_DOMAIN_INFO  pAccountDomainInfo,
	IN PPOLICY_PRIMARY_DOMAIN_INFO  pPrimaryDomainInfo
);

DWORD
AfpOpenLsa(
	IN PUNICODE_STRING		pSystem OPTIONAL,
	IN OUT PLSA_HANDLE 		phLsa
);


NTSTATUS
AfpChangePwdArapStyle(
    	IN PAFP_PASSWORD_DESC 	pPassword,
    	IN PUNICODE_STRING	pDomainName,
    	IN PSID		  	pDomainSid
);


//**
//
// Call:	AfpServerHelper
//
// Returns:	NO_ERROR
//
// Description: This is the main function for each helper thread. If sits
//		in a loop processing commands from the server. It is terminated
//		by command from the server.
//
DWORD
AfpServerHelper(
	IN LPVOID fFirstThread
)
{
NTSTATUS	    	    ntStatus;
DWORD	    	    	    dwRetCode;
PAFP_FSD_CMD_PKT    	    pAfpFsdCmdResponse;
AFP_FSD_CMD_HEADER  	    AfpCmdHeader;
PAFP_FSD_CMD_PKT    	    pAfpFsdCmd;
PBYTE		    	    pOutputBuffer;
DWORD		    	    cbOutputBuffer;
PBYTE		    	    pInputBuffer;
DWORD		    	    cbInputBuffer;
IO_STATUS_BLOCK	    	    IoStatus;
BYTE		    	    OutputBuffer[MAX_FSD_CMD_SIZE];
HANDLE 		    	    hFSD 	       = NULL;
LSA_HANDLE 	    	    hLsa 	       = NULL;
BOOLEAN                 fFirstLoop=TRUE;


    // Open the AFP Server FSD and obtain a handle to it
    //
    if ( ( dwRetCode = AfpFSDOpen( &hFSD ) ) != NO_ERROR ) {
	AfpGlobals.dwSrvrHlprCode = dwRetCode;
	AfpLogEvent( AFPLOG_OPEN_FSD, 0, NULL, dwRetCode, EVENTLOG_ERROR_TYPE );
	SetEvent( AfpGlobals.heventSrvrHlprThread );
	return( dwRetCode );
    }

    // Open the Local LSA
    //
    if ( ( dwRetCode = AfpOpenLsa( NULL, &hLsa ) ) != NO_ERROR ) {
	
    	AfpFSDClose( hFSD );
	AfpGlobals.dwSrvrHlprCode = dwRetCode;
	AfpLogEvent( AFPLOG_OPEN_LSA, 0, NULL, dwRetCode, EVENTLOG_ERROR_TYPE );
	SetEvent( AfpGlobals.heventSrvrHlprThread );
	return( dwRetCode );
    }

    // If this is the first server helper thread then enumerate and
    // IOCTL down the list of domains and their offsets.
    //
    if ( (BOOL)(ULONG_PTR)fFirstThread )
    {

	    LSA_HANDLE hLsaController = NULL;

        //
    	// Create the event object for mutual exclusion around the thread
	    // count
    	//
    	if ( (hmutexThreadCount = CreateMutex( NULL, FALSE, NULL ) ) == NULL)
        {
    	    AFP_PRINT( ( "SFMSVC: CreateMutex failed\n"));	
	        return( GetLastError() );
        }

        while (1)
        {
    	    // Get the account, primary and all trusted domain info
    	    //
    	    dwRetCode = AfpGetDomainInfo( hLsa,
			    		    &hLsaController,
				    	    &pAccountDomainInfo,
					        &pPrimaryDomainInfo);

            AfpGlobals.dwSrvrHlprCode = dwRetCode;

            if (dwRetCode == NO_ERROR)
            {
                break;
            }
            else if (dwRetCode != ERROR_CANT_ACCESS_DOMAIN_INFO)
            {
    	        AFP_PRINT( ( "SFMSVC: Get Domain Info failed %ld\n",dwRetCode));	
	            AfpLogEvent( AFPLOG_CANT_GET_DOMAIN_INFO, 0, NULL,
			                dwRetCode, EVENTLOG_ERROR_TYPE );
    	        AfpFSDClose( hFSD );
	            LsaClose( hLsa );
	            SetEvent( AfpGlobals.heventSrvrHlprThread );
	            return( dwRetCode );
            }

            // ok, we couldn't access domain info.  keep retrying until we
            // are successful (or until the service is stopped!)
            AfpGlobals.dwServerState |= AFPSTATE_BLOCKED_ON_DOMINFO;

            if (fFirstLoop)
            {
                fFirstLoop = FALSE;

                AFP_PRINT( ( "SFMSVC: first loop, telling service controller to go ahead\n"));

                // tell the service controller we're running, so the user
                // doesn't have to wait as long as we're blocked here!
                //
                AfpGlobals.ServiceStatus.dwCurrentState     = SERVICE_RUNNING;
                AfpGlobals.ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
		    	        	          SERVICE_ACCEPT_PAUSE_CONTINUE;
                AfpGlobals.ServiceStatus.dwCheckPoint       = 0;
                AfpGlobals.ServiceStatus.dwWaitHint         = 0;

                AfpAnnounceServiceStatus();

                // log an event to give the bad news..
	            AfpLogEvent( AFPLOG_DOMAIN_INFO_RETRY, 0, NULL,
			                    dwRetCode, EVENTLOG_WARNING_TYPE );
            }

            AFP_PRINT( ( "SFMSVC: sleeping 20 sec before retrying domain info\n"));

            // wait for 20 seconds before retrying for the domain info
            // Meanwhile, watch to see if the service is stopping.  If so, we
            // must do the necessary setevent and get out
            if (WaitForSingleObject( AfpGlobals.heventSrvrHlprSpecial, 20000 ) == 0)
            {
    	        AfpFSDClose( hFSD );
	            LsaClose( hLsa );
	            SetEvent( AfpGlobals.heventSrvrHlprThread );
	            return( dwRetCode );
            }

            AFP_PRINT( ( "SFMSVC: retrying getdomain info\n"));
        }

        // if we were blocked retrying the domain-info, log an event that we
        // are ok now
        if (AfpGlobals.dwServerState & AFPSTATE_BLOCKED_ON_DOMINFO)
        {
            AFP_PRINT( ( "SFMSVC: domain info stuff finally worked\n"));

            AfpGlobals.dwServerState &= ~AFPSTATE_BLOCKED_ON_DOMINFO;

	        AfpLogEvent( AFPLOG_SFM_STARTED_OK, 0, NULL, 0, EVENTLOG_SUCCESS );
        }

        //
    	// IOCTL all the domain offsets
        // if hLsaController is NULL, the server is in a WorkGroup, not domain
    	//
    	if ( ( dwRetCode = AfpIOCTLDomainOffsets(
					            hLsaController,
				                pAccountDomainInfo,
					            pPrimaryDomainInfo) ) != NO_ERROR )
        {

    	    AFP_PRINT( ( "SFMSVC: Ioctl Domain Offsets failed.\n"));	

	        AfpLogEvent( AFPLOG_CANT_INIT_DOMAIN_INFO, 0, NULL,
                         dwRetCode, EVENTLOG_ERROR_TYPE );

	        // First clean up
	        //
    	    AfpFSDClose( hFSD );
	
	        // If the local machine is not a controller
	        //
	        if ( (hLsaController != NULL) && (hLsa != hLsaController) )
            {
    	    	LsaClose( hLsaController );
            }

    	    LsaClose( hLsa );

	        if ( pAccountDomainInfo != NULL )
            {
    	    	LsaFreeMemory( pAccountDomainInfo );
            }

	        if ( pPrimaryDomainInfo != NULL )
            {
	    	    LsaFreeMemory( pPrimaryDomainInfo );
            }

	        AfpGlobals.dwSrvrHlprCode = dwRetCode;
	        SetEvent( AfpGlobals.heventSrvrHlprThread );

	        return( dwRetCode );
	    }

	    // If the local machine is not a controller, then close the handle
	    // since we have all the information we need.
	    //
	    if ( (hLsaController != NULL) && (hLsa != hLsaController) )
        {
    	    LsaClose( hLsaController );
        }

    }

    // OK everything initialize OK. Tell parent (init) thread that it may
    // continue.
    //
    AfpGlobals.dwSrvrHlprCode = dwRetCode;
    SetEvent( AfpGlobals.heventSrvrHlprThread );

    WaitForSingleObject( hmutexThreadCount, INFINITE );
    AfpGlobals.nThreadCount++;
    ReleaseMutex( hmutexThreadCount );

    pOutputBuffer  	= OutputBuffer;
    cbOutputBuffer 	= sizeof( OutputBuffer );
    pAfpFsdCmd		= (PAFP_FSD_CMD_PKT)pOutputBuffer;

    pInputBuffer     	= NULL;
    cbInputBuffer      	= 0;
    pAfpFsdCmdResponse 	= (PAFP_FSD_CMD_PKT)NULL;

    while( TRUE ) {


	// IOCTL the FSD
	//
	ntStatus = NtFsControlFile(	hFSD,
					NULL,
					NULL,
					NULL,
					&IoStatus,
					OP_GET_FSD_COMMAND,
					pInputBuffer,
					cbInputBuffer,
					pOutputBuffer,
					cbOutputBuffer
					);

	if (!NT_SUCCESS(ntStatus))
	    AFP_PRINT(("SFMSVC: NtFsControlFile Returned %lx\n",
			ntStatus));

    	ASSERT( NT_SUCCESS( ntStatus ));

	// Free previous call's input buffer
	//
	if ( pAfpFsdCmdResponse != NULL )
	    LocalFree( pAfpFsdCmdResponse );

	// Process the command
	//
	switch( pAfpFsdCmd->Header.FsdCommand ) {
	
	case AFP_FSD_CMD_NAME_TO_SID:

    	    ntStatus = AfpNameToSid( 	hLsa,
					pAfpFsdCmd,
					&pAfpFsdCmdResponse,
					&cbInputBuffer );

    	    if ( NT_SUCCESS( ntStatus ))
	    	pInputBuffer  	= (PBYTE)pAfpFsdCmdResponse;
	    else {
	    	pInputBuffer 	= (PBYTE)&AfpCmdHeader;
	    	cbInputBuffer	= sizeof( AFP_FSD_CMD_HEADER );
	    	pAfpFsdCmdResponse  = NULL;
	    }

	    break;

	case AFP_FSD_CMD_SID_TO_NAME:

    	    ntStatus = AfpSidToName( 	hLsa,
					pAccountDomainInfo,
					pPrimaryDomainInfo,
					pAfpFsdCmd,
					&pAfpFsdCmdResponse,
					&cbInputBuffer );

    	    if ( NT_SUCCESS( ntStatus ))
	    	pInputBuffer  	= (PBYTE)pAfpFsdCmdResponse;
	    else {
	    	pInputBuffer 	= (PBYTE)&AfpCmdHeader;
	    	cbInputBuffer	= sizeof( AFP_FSD_CMD_HEADER );
	    	pAfpFsdCmdResponse  = NULL;
	    }

	    break;

	case AFP_FSD_CMD_CHANGE_PASSWORD:

    	    ntStatus = AfpChangePassword(
                    hLsa,
					pAccountDomainInfo,
					pPrimaryDomainInfo,
					pAfpFsdCmd,
					&pAfpFsdCmdResponse,
					&cbInputBuffer );

	    pInputBuffer 	= (PBYTE)&AfpCmdHeader;
	    cbInputBuffer	= sizeof( AFP_FSD_CMD_HEADER );
	    pAfpFsdCmdResponse  = NULL;

	    break;

	case AFP_FSD_CMD_LOG_EVENT:

	    AfpLogServerEvent(pAfpFsdCmd);

	    pInputBuffer 	= (PBYTE)&AfpCmdHeader;
	    cbInputBuffer	= sizeof( AFP_FSD_CMD_HEADER );
	    pAfpFsdCmdResponse  = NULL;
	    ntStatus		= STATUS_SUCCESS;

	    break;

	case AFP_FSD_CMD_TERMINATE_THREAD:

	    // Do clean up
	    //
    	    LsaClose( hLsa );
    	    AfpFSDClose( hFSD );

    	    WaitForSingleObject( hmutexThreadCount, INFINITE );

		AfpGlobals.nThreadCount --;
	    // This is the last thread so clean up all the global stuff.
	    //
	    if ( AfpGlobals.nThreadCount == 0 ) {

	    	if ( pAccountDomainInfo != NULL )
            {
	    	    LsaFreeMemory( pAccountDomainInfo );
                pAccountDomainInfo = NULL;
            }

	        if ( pPrimaryDomainInfo != NULL )
	    	    LsaFreeMemory( pPrimaryDomainInfo );

			SetEvent(AfpGlobals.heventSrvrHlprThreadTerminate);
	    }

    	    ReleaseMutex( hmutexThreadCount );

	    return( NO_ERROR );

	    break;

	default:
	    ntStatus 		= STATUS_NOT_SUPPORTED;
	    pInputBuffer 	= (PBYTE)&AfpCmdHeader;
	    cbInputBuffer	= sizeof( AFP_FSD_CMD_HEADER );
	    pAfpFsdCmdResponse  = NULL;
	    break;

	}


	CopyMemory( pInputBuffer, pAfpFsdCmd, sizeof( AFP_FSD_CMD_HEADER ) );

	((PAFP_FSD_CMD_HEADER)pInputBuffer)->ntStatus = ntStatus;
    }

    return( NO_ERROR );
}

//**
//
// Call:	AfpGetDomainInfo
//
// Returns:	LsaQueryInformationPolicy, I_NetGetDCList and AfpOpenLsa
//
// Description: Will retrieve information regarding the account, primary and
//		trusted domains.
//
DWORD
AfpGetDomainInfo(
	IN     LSA_HANDLE 		    hLsa,
	IN OUT PLSA_HANDLE 		    phLsaController,
	IN OUT PPOLICY_ACCOUNT_DOMAIN_INFO* ppAccountDomainInfo,
	IN OUT PPOLICY_PRIMARY_DOMAIN_INFO* ppPrimaryDomainInfo
)
{
    DWORD			            dwRetCode = 0;
    NTSTATUS		            ntStatus  = STATUS_SUCCESS;
    LSA_ENUMERATION_HANDLE	    hLsaEnum  = 0;
	LPWSTR	    	            DomainName = NULL;
    PDOMAIN_CONTROLLER_INFO     pDCInfo = NULL;
    UNICODE_STRING              DCName;

    // This is not a loop.
    //
    do {

	    *phLsaController     = NULL;
	    *ppAccountDomainInfo = NULL;
	    *ppPrimaryDomainInfo = NULL;


	    // Get the account domain
	    //
    	ntStatus = LsaQueryInformationPolicy(
			  		hLsa,
					PolicyAccountDomainInformation,	
					(PVOID*)ppAccountDomainInfo
					);

    	if ( !NT_SUCCESS( ntStatus ) )
        {
            AFP_PRINT( ( "SFMSVC: Lsa..Policy for Acct dom failed %lx\n",ntStatus));
	        break;
        }

	// Get the primary domain
	//
    	ntStatus = LsaQueryInformationPolicy(
			  		hLsa,
					PolicyPrimaryDomainInformation,	
					(PVOID*)ppPrimaryDomainInfo
					);
    	if ( !NT_SUCCESS( ntStatus ) )
        {
            AFP_PRINT( ( "SFMSVC: Lsa..Policy for Primary dom failed %lx\n",ntStatus));
	        break;
        }

	    // If this machine is part of a domain (not standalone), then we need
	    // to get a list of trusted domains. Note that a workstation and a
	    // member server can both join a domain, but they don't have to.
	    //
	    if ( (*ppPrimaryDomainInfo)->Sid != NULL )
        {

	        // To obtain a list of trusted domains, we need to first open
	        // the LSA on a domain controller. If we are an PDC/BDC
	        // (NtProductLanManNt) then the local LSA will do, otherwise we need
	        // to search for domain controllers (NtProductServer, NtProductWinNt).
	        //
	        if ( AfpGlobals.NtProductType != NtProductLanManNt )
            {

	    	    ULONG	    	ulCount;
	    	    ULONG	    	ControllerCount  = 0;
		        PUNICODE_STRING ControllerNames  = NULL;
	    	    PUNICODE_STRING DomainController = NULL;

    	    	DomainName = (LPWSTR)LocalAlloc(
			                            LPTR,
			                            (*ppPrimaryDomainInfo)->Name.Length+sizeof(WCHAR));

	    	    if ( DomainName == NULL )
                {
	  	            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
		            break;
	    	    }

	    	    CopyMemory( DomainName,
    			            (*ppPrimaryDomainInfo)->Name.Buffer,
			                (*ppPrimaryDomainInfo)->Name.Length );

                DomainName[(*ppPrimaryDomainInfo)->Name.Length/sizeof(WCHAR)] = 0;

                dwRetCode = DsGetDcName(
                                 NULL,
                                 (LPWSTR)DomainName,
                                 NULL,               // domain
                                 NULL,               // site name
                                 DS_DIRECTORY_SERVICE_PREFERRED,
                                 &pDCInfo);

	    	    if ( dwRetCode != NO_ERROR )
                {
                    AFP_PRINT( ( "SFMSVC: DsGetDcName failed 0x%lx\n",dwRetCode));
	                dwRetCode = ERROR_CANT_ACCESS_DOMAIN_INFO;
		            break;
                }

                AFP_PRINT(("SFMSVC: AfpOpenLsa on DC %ws for domain %ws\n",
                    pDCInfo->DomainControllerName,DomainName));

                RtlInitUnicodeString(&DCName, pDCInfo->DomainControllerName);

                dwRetCode = AfpOpenLsa(&DCName, phLsaController );

                //
                // it's possible that this DC is down: force discovery
                //
                if (dwRetCode != NO_ERROR)
                {

                    AFP_PRINT(("SFMSVC: DC %ws unreachable, forcing discovery\n",
                                pDCInfo->DomainControllerName));

                    NetApiBufferFree(pDCInfo);

                    pDCInfo = NULL;

                    dwRetCode = DsGetDcName(
                                     NULL,
                                     (LPWSTR)DomainName,
                                     NULL,
                                     NULL,
                                     (DS_DIRECTORY_SERVICE_PREFERRED | DS_FORCE_REDISCOVERY),
                                     &pDCInfo);

	    	        if ( dwRetCode != NO_ERROR )
                    {
                        AFP_PRINT(("SFMSVC: second DsGetDcName failed %lx\n",dwRetCode));
    	                dwRetCode = ERROR_CANT_ACCESS_DOMAIN_INFO;
	    	            break;
                    }

                    RtlInitUnicodeString(&DCName, pDCInfo->DomainControllerName);

                    dwRetCode = AfpOpenLsa(&DCName, phLsaController );
                }

	        }
	        else
            {

		        *phLsaController = hLsa;

		        // Since the local server is an PDC/BDC, it's account
		        // domain is the same as it's primary domain so set the
		        // account domain info to NULL
	 	        //
    	    	LsaFreeMemory( *ppAccountDomainInfo );
	    	    *ppAccountDomainInfo = NULL;
	        }


	    }
	    else
        {
	        LsaFreeMemory( *ppPrimaryDomainInfo );
	        *ppPrimaryDomainInfo = NULL;
	    }

    } while( FALSE );


    if (DomainName)
    {
	    LocalFree( DomainName );
    }

    if (pDCInfo)
    {
        NetApiBufferFree(pDCInfo);
    }


    if ( !NT_SUCCESS( ntStatus ) || ( dwRetCode != NO_ERROR ) )
    {
    	if ( *ppAccountDomainInfo != NULL )
        {
 	        LsaFreeMemory( *ppAccountDomainInfo );
        }

    	if ( *ppPrimaryDomainInfo != NULL )
        {
	        LsaFreeMemory( *ppPrimaryDomainInfo );
        }

    	if ( *phLsaController != NULL )
        {
	        LsaClose( *phLsaController );
        }
	
    	if ( dwRetCode == NO_ERROR )
        {
	        dwRetCode = RtlNtStatusToDosError( ntStatus );
        }
    }


    return( dwRetCode );

}

//**
//
// Call:	AfpOpenLsa
//
// Returns:	Returns from LsaOpenPolicy.
//
// Description: The LSA will be opened.
//
DWORD
AfpOpenLsa(
	IN PUNICODE_STRING	pSystem OPTIONAL,
	IN OUT PLSA_HANDLE 	phLsa
)
{
SECURITY_QUALITY_OF_SERVICE	QOS;
OBJECT_ATTRIBUTES		ObjectAttributes;
NTSTATUS			ntStatus;

    // Open the LSA and obtain a handle to it.
    //
    QOS.Length 		    = sizeof( QOS );
    QOS.ImpersonationLevel  = SecurityImpersonation;
    QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QOS.EffectiveOnly 	    = FALSE;

    InitializeObjectAttributes( &ObjectAttributes,
				NULL,
				0L,
				NULL,
				NULL );

    ObjectAttributes.SecurityQualityOfService = &QOS;

    ntStatus = LsaOpenPolicy( 	pSystem,
			      	&ObjectAttributes,
			      	POLICY_VIEW_LOCAL_INFORMATION |
				POLICY_LOOKUP_NAMES,
			      	phLsa );

    if ( !NT_SUCCESS( ntStatus ))
    {
        AFP_PRINT(("SFMSVC: AfpOpenLsa: LsaOpenPolicy failed %lx\n",ntStatus));
    	return( RtlNtStatusToDosError( ntStatus ) );
    }

    return( NO_ERROR );
}

//
// Call:	AfpNameToSid
//
// Returns:	NT_SUCCESS
//		error return codes from LSA apis.
//
// Description: Will use LSA API's to translate a name to a SID. On a
//		successful return, the pSid should be freed using LocalFree.
//
NTSTATUS
AfpNameToSid(
	IN  LSA_HANDLE 	      		hLsa,
	IN  PAFP_FSD_CMD_PKT  		pAfpFsdCmd,
	OUT PAFP_FSD_CMD_PKT 		*ppAfpFsdCmdResponse,
	OUT LPDWORD	      		pcbResponse
)
{
NTSTATUS 			ntStatus;
UNICODE_STRING	 		Name;
PLSA_REFERENCED_DOMAIN_LIST	pDomainList;
PLSA_TRANSLATED_SID		pSids;
UCHAR 				AuthCount;
PSID				pDomainSid;
PSID				pSid;

    // This do - while(FALSE) loop facilitates a single exit and clean-up point.
    //
    do {

	*ppAfpFsdCmdResponse = NULL;
	pDomainList 	     = NULL;
	pSids 	    	     = NULL;

    	RtlInitUnicodeString( &Name, (LPWSTR)(pAfpFsdCmd->Data.Name) );

    	ntStatus = LsaLookupNames( hLsa, 1, &Name, &pDomainList, &pSids );

    	if ( !NT_SUCCESS( ntStatus ) )
	    return( ntStatus );

	if ( pSids->Use == SidTypeDeletedAccount ){
	    ntStatus = STATUS_NO_SUCH_USER;
	    break;
	}

	if ( ( pDomainList->Entries == 0 ) 	     ||
	     ( pSids->Use == SidTypeDomain )         ||
	     ( pSids->Use == SidTypeInvalid )        ||
	     ( pSids->Use == SidTypeUnknown )	     ||
	     ( pSids->DomainIndex == -1 )) {

	    ntStatus = STATUS_NONE_MAPPED;
	    break;
	}

	pDomainSid = pDomainList->Domains[pSids->DomainIndex].Sid;

    	AuthCount = *RtlSubAuthorityCountSid( pDomainSid ) + 1;

    	*pcbResponse = sizeof(AFP_FSD_CMD_PKT)+RtlLengthRequiredSid(AuthCount);

    	*ppAfpFsdCmdResponse = (PAFP_FSD_CMD_PKT)LocalAlloc(LPTR,*pcbResponse);
    	if ( *ppAfpFsdCmdResponse == NULL ) {
	    ntStatus = STATUS_NO_MEMORY ;
	    break;
	}

	pSid = (*ppAfpFsdCmdResponse)->Data.Sid;

    	// Copy the Domain Sid.
    	//
    	RtlCopySid( RtlLengthRequiredSid(AuthCount), pSid, pDomainSid );

    	// Append the Relative Id.
    	//
    	*RtlSubAuthorityCountSid( pSid ) += 1;
    	*RtlSubAuthoritySid( pSid, AuthCount - 1) = pSids->RelativeId;

    } while( FALSE );

    if ( (!NT_SUCCESS( ntStatus )) && ( *ppAfpFsdCmdResponse != NULL ) )
    	LocalFree( *ppAfpFsdCmdResponse );

    if ( pSids != NULL )
    	LsaFreeMemory( pSids );

    if ( pDomainList != NULL )
    	LsaFreeMemory( pDomainList );

    return( ntStatus );
			
}

//**
//
// Call:	AfpSidToName
//
// Returns:	NT_SUCCESS
//		error return codes from LSA apis.
//
// Description: Given a SID, this routine will find the corresponding
//		UNICODE name.
//
NTSTATUS
AfpSidToName(
	IN  LSA_HANDLE        		hLsa,
	IN  PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo,
	IN  PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo,
	IN  PAFP_FSD_CMD_PKT  		pAfpFsdCmd,
	OUT PAFP_FSD_CMD_PKT 		*ppAfpFsdCmdResponse,
	OUT LPDWORD	      		pcbResponse
)
{
NTSTATUS 			ntStatus;
PLSA_REFERENCED_DOMAIN_LIST	pDomainList	= NULL;
PLSA_TRANSLATED_NAME		pNames		= NULL;
PSID				pSid 		= (PSID)&(pAfpFsdCmd->Data.Sid);
WCHAR *   			pWchar;
BOOL	    			fDoNotCopyDomainName = TRUE;
DWORD				cbResponse;
DWORD				dwUse;
SID			        AfpBuiltInSid = { 1, 1, SECURITY_NT_AUTHORITY,
					          SECURITY_BUILTIN_DOMAIN_RID };

    do {

	*ppAfpFsdCmdResponse = NULL;

    	ntStatus = LsaLookupSids( hLsa, 1, &pSid, &pDomainList, &pNames );

    	if ( !NT_SUCCESS( ntStatus ) ) {
	
	    if ( ntStatus == STATUS_NONE_MAPPED ) {

		dwUse = SidTypeUnknown;
		ntStatus = STATUS_SUCCESS;
	    }
	    else
	    	break;
	}
	else
	    dwUse = pNames->Use;

	cbResponse = sizeof( AFP_FSD_CMD_PKT );

 	switch( dwUse ){

	case SidTypeInvalid:
	    cbResponse += ((wcslen(AfpGlobals.wchInvalid)+1) * sizeof(WCHAR));
	    break;

	case SidTypeDeletedAccount:
	    cbResponse += ((wcslen(AfpGlobals.wchDeleted)+1) * sizeof(WCHAR));
	    break;

	case SidTypeUnknown:
	    cbResponse += ((wcslen(AfpGlobals.wchUnknown)+1) * sizeof(WCHAR));
	    break;

	case SidTypeWellKnownGroup:
	    cbResponse += ( pNames->Name.Length + sizeof(WCHAR) );
	    break;

	case SidTypeDomain:
	    cbResponse += ( pDomainList->Domains->Name.Length + sizeof(WCHAR) );
	    break;

	default:

	    if ((pNames->DomainIndex == -1) || (pNames->Name.Buffer == NULL)){
	    	ntStatus = STATUS_NONE_MAPPED;
	    	break;
	    }

	    // Do not copy the domain name if the name is either a well known
	    // group or if the SID belongs to the ACCOUNT or BUILTIN domains.
	    // Note, the pAccountDomainInfo is NULL is this is an advanced
	    // server, in that case we check to see if the domain name is
	    // the primary domain name.
	    //
	    if (( RtlEqualSid( &AfpBuiltInSid, pDomainList->Domains->Sid )) ||
	       (( pAccountDomainInfo != NULL ) &&
	       (RtlEqualUnicodeString( &(pAccountDomainInfo->DomainName),
				        &(pDomainList->Domains->Name),
				        TRUE ))) ||
	       ((pAccountDomainInfo == NULL) && (pPrimaryDomainInfo != NULL) &&
	       (RtlEqualUnicodeString( &(pPrimaryDomainInfo->Name),
				       &(pDomainList->Domains->Name),
				       TRUE )))){
		
		cbResponse += ( pNames->Name.Length + sizeof(WCHAR) );

	    	fDoNotCopyDomainName = TRUE;
	    }
	    else {

	    	fDoNotCopyDomainName = FALSE;

	        cbResponse += ( pDomainList->Domains->Name.Length +
		                sizeof(TEXT('\\')) +
		                pNames->Name.Length +
		                sizeof(WCHAR) );
	    }
	}

    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	*pcbResponse = cbResponse;

    	*ppAfpFsdCmdResponse = (PAFP_FSD_CMD_PKT)LocalAlloc(LPTR,cbResponse);

  	if ( *ppAfpFsdCmdResponse == NULL ){
	    ntStatus = STATUS_NO_MEMORY ;
	    break;
	}

	pWchar = (WCHAR*)((*ppAfpFsdCmdResponse)->Data.Name);

 	switch( dwUse ){

	case SidTypeInvalid:
	    wcscpy( pWchar, AfpGlobals.wchInvalid );
	    break;

	case SidTypeDeletedAccount:
	    wcscpy( pWchar, AfpGlobals.wchDeleted );
	    break;

	case SidTypeUnknown:
	    wcscpy( pWchar, AfpGlobals.wchUnknown );
	    break;

	case SidTypeWellKnownGroup:
	    CopyMemory( pWchar, pNames->Name.Buffer, pNames->Name.Length );
	    break;

	case SidTypeDomain:
	    CopyMemory( pWchar,
		    	pDomainList->Domains->Name.Buffer,
		    	pDomainList->Domains->Name.Length );
	    break;

	default:

	    if ( !fDoNotCopyDomainName ) {

	    	CopyMemory( pWchar,
		    	    pDomainList->Domains->Name.Buffer,
		    	    pDomainList->Domains->Name.Length );

	        pWchar += wcslen( pWchar );

	        CopyMemory( pWchar, TEXT("\\"), sizeof(TEXT("\\")) );

	        pWchar += wcslen( pWchar );
	    }

	    CopyMemory( pWchar, pNames->Name.Buffer, pNames->Name.Length );
	}
		
    } while( FALSE );

    if ( (!NT_SUCCESS( ntStatus )) && ( *ppAfpFsdCmdResponse != NULL ) )
    	LocalFree( *ppAfpFsdCmdResponse );

    if ( pNames != NULL )
    	LsaFreeMemory( pNames );

    if ( pDomainList != NULL )
    	LsaFreeMemory( pDomainList );

    return( ntStatus );
			
}

//**
//
// Call:	AfpChangePassword
//
// Returns:	NT_SUCCESS
//		error return codes from LSA apis.
//
// Description: Given the AFP_PASSWORD_DESC data structure, this procedure
//		will change the password of a given user.
//		If the passwords are supplied in clear text, then it calculate
//		the OWF's (encrypt OWF = One Way Function) them.
//		If the domain name that the user
//		belongs to is not supplied then a list of domains are tried
//		in sequence. The sequence is 1) ACCOUNT domain
//					     2) PRIMARY domain
//					     3) All trusted domains.
//
NTSTATUS
AfpChangePassword(
    IN  LSA_HANDLE                  hLsa,
	IN  PPOLICY_ACCOUNT_DOMAIN_INFO pAccountDomainInfo,
	IN  PPOLICY_PRIMARY_DOMAIN_INFO pPrimaryDomainInfo,
	IN  PAFP_FSD_CMD_PKT    	pAfpFsdCmd,
	OUT PAFP_FSD_CMD_PKT   		*ppAfpFsdCmdResponse,
	OUT LPDWORD			pcbResponse
)
{



    PAFP_PASSWORD_DESC 		        pPassword = &(pAfpFsdCmd->Data.Password);
    NTSTATUS			            ntStatus=STATUS_SUCCESS;
    PSID				            pDomainSid;
    UNICODE_STRING			        TargetDomainName;
    WCHAR                           RefDomainName[DNLEN+1];
    DWORD                           cbRefDomainNameLen;
    DWORD                           cbSidLen;
    PSID                            pUserSid=NULL;
    PLSA_TRANSLATED_SID             pTransSids;
    SID_NAME_USE                    peUse;
    PLSA_REFERENCED_DOMAIN_LIST     pDomainList=NULL;
    DWORD                           dwRetCode;


    AFP_PRINT(("SFMSVC: entered AfpChangePassword for user %ws\n",(LPWSTR)pPassword->UserName));

    do
    {

        //
        // Was the domain on which the account name exists specified ??
        //
        if ( pPassword->DomainName[0] != TEXT('\0') )
        {
	        RtlInitUnicodeString(&TargetDomainName, (LPWSTR)pPassword->DomainName);
        }

        //
        // hmmm, no domain name.  We must first find which domain this user belongs to
        //
        else
        {
            cbRefDomainNameLen = DNLEN+1;

            cbSidLen = 100;

            do
            {
                dwRetCode = ERROR_SUCCESS;
                if (pUserSid)
                {
                    LocalFree(pUserSid);
                }

                pUserSid = (PSID)LocalAlloc(LPTR, cbSidLen);

                if (pUserSid == NULL)
                {
                    dwRetCode = ERROR_NO_SYSTEM_RESOURCES;
                    break;
                }

                if (!LookupAccountName(
                        NULL,
                        (LPWSTR)pPassword->UserName,
                        pUserSid,
                        &cbSidLen,
                        RefDomainName,
                        &cbRefDomainNameLen,
                        &peUse))
                {
                    ntStatus = (NTSTATUS)GetLastError();
                }

                AFP_PRINT(("SFMSVC: LookupAccountName in loop: %d\n",GetLastError()));

            } while ( dwRetCode == ERROR_INSUFFICIENT_BUFFER );

            if (dwRetCode != ERROR_SUCCESS)
            {
                AFP_PRINT(("SFMSVC: LookupAccountName on %ws failed with %ld\n",(LPWSTR)pPassword->UserName,dwRetCode));
                ntStatus = (NTSTATUS)dwRetCode;
                break;
            }

            LocalFree(pUserSid);

	        RtlInitUnicodeString(&TargetDomainName, RefDomainName);
        }


AFP_PRINT(("SFMSVC: changing pwd for user %ws, domain %ws\n",
    (LPWSTR)pPassword->UserName,TargetDomainName.Buffer));

        //
        // now, we must find the sid for this domain
        //
        ntStatus = LsaLookupNames(hLsa, 1, &TargetDomainName, &pDomainList, &pTransSids);

        if (!NT_SUCCESS(ntStatus))
        {
            AFP_PRINT(("SFMSVC: LsaLookupNames failed %lx\n",ntStatus));
            break;
        }

        if ((pDomainList->Entries == 0) ||
            (pTransSids->DomainIndex == -1) ||
            (pTransSids->Use != SidTypeDomain) ||
            (pTransSids->Use == SidTypeInvalid) ||
            (pTransSids->Use == SidTypeUnknown))
        {
            AFP_PRINT(("SFMSVC: invalide type? Entries = %d, DomIndex = %d, Use = %d\n",
                    pDomainList->Entries,pTransSids->DomainIndex,pTransSids->Use));
            ntStatus = STATUS_NONE_MAPPED;
            break;
        }

        pDomainSid = pDomainList->Domains[pTransSids->DomainIndex].Sid;


        //
        // call our function to change the password
        //
    	ntStatus = AfpChangePasswordOnDomain(
				        pPassword,
			            &TargetDomainName,
				        pDomainSid );

AFP_PRINT(("SFMSVC: AfpChangePasswordOnDomain returned %lx\n",ntStatus));

    } while ( FALSE );


    if (pDomainList)
    {
        LsaFreeMemory( pDomainList );
    }

    return( ntStatus );
}

//**
//
// Call:	AfpChangePasswordOnDomain
//
// Returns:	NT_SUCCESS
//		STATUS_NONE_MAPPED 	- If the user account does not
//					  exist in the specified domain.
//		error return codes from LSA apis.
//
// Description: This procedure will try to change the user's password on a
//		specified domain. It is assumed that this procedure will be
//		called with either the pDomainName pointing to the domain, or
//		the pPassword->DomainName field containing the domain.
//
NTSTATUS
AfpChangePasswordOnDomain(
    	IN PAFP_PASSWORD_DESC 	pPassword,
    	IN PUNICODE_STRING	pDomainName,
    	IN PSID		  	pDomainSid
)
{

    LPWSTR				            DCName  = (LPWSTR)NULL;
    SAM_HANDLE			            hServer = (SAM_HANDLE)NULL;
    SAM_HANDLE			            hDomain = (SAM_HANDLE)NULL;
    SAM_HANDLE			            hUser   = (SAM_HANDLE)NULL;
    PULONG				            pUserId = (PULONG)NULL;
    PSID_NAME_USE			        pUse   	= (PSID_NAME_USE)NULL;
    OBJECT_ATTRIBUTES		        ObjectAttributes;
    UNICODE_STRING			        UserName;
    ANSI_STRING			            AOldPassword;
    UNICODE_STRING			        UOldPassword;
    ANSI_STRING			            ANewPassword;
    UNICODE_STRING			        UNewPassword;
    POEM_STRING                     pOemSrvName;
    OEM_STRING                      OemServerName;
    OEM_STRING                      OemUserName;
    SECURITY_QUALITY_OF_SERVICE	    QOS;
    PPOLICY_ACCOUNT_DOMAIN_INFO     pDomainInfo    = NULL;
    NTSTATUS			            ntStatus;
    UNICODE_STRING			        PDCServerName;
    PUNICODE_STRING			        pPDCServerName = &PDCServerName;
    PDOMAIN_PASSWORD_INFORMATION	pPasswordInfo = NULL;
    BYTE				            EncryptedPassword[LM_OWF_PASSWORD_LENGTH];
    WCHAR				            wchDomain[DNLEN+1];
    PDOMAIN_CONTROLLER_INFO         pDCInfo = NULL;
    PUSER_INFO_1			        pUserInfo = NULL;
    DWORD                           dwRetCode;



    if ((pPassword->AuthentMode == RANDNUM_EXCHANGE) ||
        (pPassword->AuthentMode == TWOWAY_EXCHANGE))
    {
            
        AFP_PRINT(("SFMSVC: Entering AfpChangePwdArapStyle for RANDNUM_EXCHANGE || TWOWAY_EXCHANGE\n"));
        ntStatus = AfpChangePwdArapStyle(pPassword, pDomainName, pDomainSid);
        AFP_PRINT(("SFMSVC: Returned from AfpChangePwdArapStyle with error %lx\n", ntStatus));
        return(ntStatus);
    }

    OemServerName.Buffer = NULL;
    OemUserName.Buffer = NULL;

    InitializeObjectAttributes( &ObjectAttributes,
				NULL,
				0L,
				NULL,
				NULL );

    QOS.Length 		    = sizeof( QOS );
    QOS.ImpersonationLevel  = SecurityImpersonation;
    QOS.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    QOS.EffectiveOnly 	    = FALSE;

    ObjectAttributes.SecurityQualityOfService = &QOS;

    // If the domain was not the account domain then we try to get the
    // primary domain controller for the domain.
    //
    if ((pDomainName != NULL) &&
        (pAccountDomainInfo != NULL) &&
        !(RtlEqualUnicodeString( &(pAccountDomainInfo->DomainName),pDomainName, TRUE)))
    {
	    ZeroMemory( wchDomain, sizeof( wchDomain ) );

    	CopyMemory( wchDomain, pDomainName->Buffer, pDomainName->Length );

    	// Get the PDC for the domain if this is not the account domain
    	//
        dwRetCode = DsGetDcName(
                         NULL,
                         wchDomain,
                         NULL,
                         NULL,
                         (DS_DIRECTORY_SERVICE_PREFERRED | DS_WRITABLE_REQUIRED),
                         &pDCInfo);

	    if ( dwRetCode != NO_ERROR )
        {
            AFP_PRINT (("SFMSVC: AfpChange... DsGetDcName failed %lx\n",dwRetCode));
	        return( STATUS_CANT_ACCESS_DOMAIN_INFO );
        }

        RtlInitUnicodeString(pPDCServerName, pDCInfo->DomainControllerName);

        DCName = pDCInfo->DomainControllerName;
    }
    else
    {
    	pPDCServerName = NULL;

        DCName = NULL;
    }

	
    do
    {
        //
        // first and foremost: make sure this user can actually change pwd
        //
	    if ((ntStatus= NetUserGetInfo( (LPWSTR)DCName,
				             pPassword->UserName, 	
				             1, 	
				             (LPBYTE*)&pUserInfo )) == NO_ERROR )
        {

	        if ( ( pUserInfo->usri1_flags & UF_PASSWD_CANT_CHANGE )     ||
	             ( pUserInfo->usri1_flags & UF_LOCKOUT ) )
            {
                AFP_PRINT(("SFMSVC: can't change pwd: %s\n",
                    (pUserInfo->usri1_flags & UF_LOCKOUT) ?
                    "account is locked out" : "user not allowed to change pwd"));

	    	    ntStatus = STATUS_ACCESS_DENIED;
	    	    break;
	        }
		    else if ( pUserInfo->usri1_flags & UF_ACCOUNTDISABLE )
		    {
                AFP_PRINT(("SFMSVC: can't change pwd: user account is disabled\n"));
			    ntStatus = STATUS_ACCOUNT_DISABLED;
			    break;
		    }
	    }
	    else
        {
            AFP_PRINT(("SFMSVC: can't change pwd: NetUserGetInfo failed\n"));

            if (ntStatus == ERROR_ACCESS_DENIED)
            {
                ntStatus = STATUS_SUCCESS;
            }
            else
            {
                ntStatus = STATUS_PASSWORD_RESTRICTION;
                break;
            }
        }

        //
        // if this is a password change request coming from MSUAM Version 2,
        // then we are getting passwords (and not OWFs) encrypted.  Use a
        // different scheme of changing password
        //
        if (pPassword->AuthentMode == CUSTOM_UAM_V2)
        {
            OemServerName.MaximumLength = OemServerName.Length = 0;
            OemUserName.MaximumLength = OemUserName.Length = 0;

    	    RtlInitUnicodeString( &UserName, pPassword->UserName );

            if (pPDCServerName)
            {
                ntStatus = RtlUnicodeStringToOemString(
                                    &OemServerName,
                                    pPDCServerName,
                                    TRUE             // allocate buffer
                                    );
                if (!NT_SUCCESS(ntStatus))
                {
                    AFP_PRINT(("SFMSVC: 1st Rtl..OemString failed %lx\n",ntStatus));
                    break;
                }

                pOemSrvName = &OemServerName;
            }
            else
            {
                pOemSrvName = NULL;
            }

            ntStatus = RtlUnicodeStringToOemString(
                                &OemUserName,
                                &UserName,
                                TRUE             // allocate buffer
                                );
            if (!NT_SUCCESS(ntStatus))
            {
                AFP_PRINT(("SFMSVC: 2nd Rtl..OemString failed %lx\n",ntStatus));
                break;
            }

            ntStatus = SamiOemChangePasswordUser2(
                            pOemSrvName,
                            &OemUserName,
                            (PSAMPR_ENCRYPTED_USER_PASSWORD)pPassword->NewPassword,
                            (PENCRYPTED_LM_OWF_PASSWORD)pPassword->OldPassword);

            AFP_PRINT(("SFMSVC: change pwd for MSUAM V2.0 user done, status = %lx\n",ntStatus));

            // done here
            break;
        }

        AFP_PRINT(("SFMSVC: AuthMode != MSUAM\n"));

    	// Connect to the PDC of that domain
    	//

    	ntStatus = SamConnect(
                        pPDCServerName,
			  	        &hServer,
				        SAM_SERVER_EXECUTE,
				        &ObjectAttributes);

	    if ( !NT_SUCCESS( ntStatus ))
        {
            AFP_PRINT(("SFMSVC: SamConnect to %ws failed %lx\n",
                (pPDCServerName)?pPDCServerName->Buffer:L"LOCAL",ntStatus));
	        break;
        }

    	// Get Sid of Domain and open the domain
    	//
    	ntStatus = SamOpenDomain( 	
				hServer,
				DOMAIN_EXECUTE,
				pDomainSid,
				&hDomain
			    	);

	    if ( !NT_SUCCESS( ntStatus ))
        {
            AFP_PRINT(("SFMSVC: SamOpenDomain failed %lx\n",ntStatus));
	        break;
        }

    	// Get this user's ID
    	//
    	RtlInitUnicodeString( &UserName, pPassword->UserName );

    	ntStatus = SamLookupNamesInDomain(
				hDomain,
				1,
				&UserName,
				&pUserId,
				&pUse
				);

	    if ( !NT_SUCCESS( ntStatus ))
        {
            AFP_PRINT(("SFMSVC: SamLookupNamesInDomain failed %lx\n",ntStatus));
	        break;
        }

    	// Open the user account for this user
    	//
    	ntStatus = SamOpenUser( hDomain,
				USER_CHANGE_PASSWORD,
				*pUserId,
				&hUser
			    	);


	    if ( !NT_SUCCESS( ntStatus ))
        {
            AFP_PRINT(("SFMSVC: SamOpenUser failed %lx\n",ntStatus));
	        break;
        }
	
 	    // First get the minimum password length requred
	    //
	    ntStatus = SamQueryInformationDomain(
		    		hDomain,
			    	DomainPasswordInformation,
    				&pPasswordInfo
	    			);

	    if ( !NT_SUCCESS( ntStatus ) )
        {
            AFP_PRINT(("SFMSVC: SamQueryInformationDomain failed %lx\n",ntStatus));
	        break;
        }

	
    	// First we check to see if the passwords passed are in cleartext.
    	// If they are, we need to calculate the OWF's for them.
		// (OWF = "One Way Function")
    	//
        if ( pPassword->AuthentMode == CLEAR_TEXT_AUTHENT )
        {
            AFP_PRINT(("SFMSVC: AuthentMode == CLEAR_TEXT_AUTHENT\n"));

	        // First check to see if the new password is long enough
	        //

	        if ( strlen( pPassword->NewPassword )
                < pPasswordInfo->MinPasswordLength ) {
		        ntStatus = STATUS_PWD_TOO_SHORT;
		        break;
	        }

            RtlInitAnsiString( &AOldPassword, pPassword->OldPassword );

            RtlInitAnsiString( &ANewPassword, pPassword->NewPassword );


            RtlInitUnicodeString( &UserName, pPassword->UserName );
            if ((ntStatus = RtlAnsiStringToUnicodeString( &UOldPassword, &AOldPassword, TRUE )) != STATUS_SUCCESS)
            {
                AFP_PRINT(("SFMSVC: RtlAnsiStringToUnicodeString: UOldPassword failed with error %lx]n", ntStatus));
                break;
            }
            if ((ntStatus = RtlAnsiStringToUnicodeString( &UNewPassword, &ANewPassword, TRUE )) != STATUS_SUCCESS)
            {
                AFP_PRINT(("SFMSVC: RtlAnsiStringToUnicodeString: UNewPassword failed with error %lx]n", ntStatus));
                RtlFreeUnicodeString (&UOldPassword);
                break;
            }
    
            AFP_PRINT(("SFMSVC: Calling SamChangePasswordUser2 \n"));
    
    	    // Change the password for this user
    	    //
    	    ntStatus = SamChangePasswordUser2 (
                    pPDCServerName,
                    &UserName,
                    &UOldPassword,
                    &UNewPassword
				    );
    
            AFP_PRINT(("SFMSVC: SamChangePasswordUser2 returned %lx\n", ntStatus));
    
            RtlFreeUnicodeString (&UOldPassword);
            RtlFreeUnicodeString (&UNewPassword);
    
            break;
        }
        else
        {

	        if (pPassword->bPasswordLength < pPasswordInfo->MinPasswordLength)
            {
                AFP_PRINT(("SFMSVC: AfpChangePasswordOnDomain: pwd is too short\n"));
		        ntStatus = STATUS_PWD_TOO_SHORT;
    		    break;
	        }
	    }

                
        AFP_PRINT(("SFMSVC: Invalid UAM type\n"));
        ntStatus = STATUS_INVALID_PARAMETER;
        break;


				
    } while( FALSE );

    if ( pUserInfo != NULL )
    {
	    NetApiBufferFree( pUserInfo );
    }

    if ( hServer != (SAM_HANDLE)NULL )
    {
	    SamCloseHandle( hServer );
    }

    if ( hDomain != (SAM_HANDLE)NULL )
    {
	    SamCloseHandle( hDomain );
    }

    if ( hUser != (SAM_HANDLE)NULL )
    {
	    SamCloseHandle( hUser );
    }
	
    if ( pDomainInfo != NULL )
    {
    	LsaFreeMemory( pDomainInfo );
    }

    if ( pUserId != (PULONG)NULL )
    {
	    SamFreeMemory( pUserId );
    }

    if ( pUse != (PSID_NAME_USE)NULL )
    {
	    SamFreeMemory( pUse );
    }

    if ( pPasswordInfo != (PDOMAIN_PASSWORD_INFORMATION)NULL )
    {
	    SamFreeMemory( pPasswordInfo );
    }

    if (pDCInfo)
    {
        NetApiBufferFree(pDCInfo);
    }

    if (OemServerName.Buffer)
    {
        RtlFreeAnsiString(&OemServerName);
    }

    if (OemUserName.Buffer)
    {
        RtlFreeAnsiString(&OemUserName);
    }

    return( ntStatus );
}

//**
//
// Call:	AfpIOCTLDomainOffsets
//
// Returns:	NT_SUCCESS
//		error return codes from LSA apis.
//
// Description: Will IOCTL a list of SIDs and corresponding POSIX offsets
//		of all trusted domains and other well known domains.
//		
//
DWORD
AfpIOCTLDomainOffsets(	
	IN LSA_HANDLE 			hLsa,
	IN PPOLICY_ACCOUNT_DOMAIN_INFO  pAccountDomainInfo,
	IN PPOLICY_PRIMARY_DOMAIN_INFO  pPrimaryDomainInfo
)
{
    NTSTATUS		    ntStatus;
    LSA_HANDLE		    hLsaDomain;
    PTRUSTED_POSIX_OFFSET_INFO  pPosixOffset;
    PAFP_SID_OFFSET		    pSidOffset;
    ULONG			    cbSids;
    PBYTE			    pbVariableData;
    AFP_SID_OFFSET		    pWellKnownSids[20]; 	
    DWORD			    dwIndex;
    DWORD			    dwCount;
    AFP_REQUEST_PACKET	    AfpRequestPkt;
    PAFP_SID_OFFSET_DESC	    pAfpSidOffsets	= NULL;
    DWORD			    cbSidOffsets;
    DWORD			    dwRetCode;


    // Null this array out.
    //
    ZeroMemory( pWellKnownSids, sizeof(AFP_SID_OFFSET)*20 );

    // This is a dummy loop used only so that the break statement may
    // be used to localize all the clean up in one place.
    //
    do {

	    // Create all the well known SIDs
	    //
	    ntStatus = AfpCreateWellknownSids( pWellKnownSids );

    	if ( !NT_SUCCESS( ntStatus ) )
        {
	        break;
        }

	    // Add the size of the all the well known SIDS
  	    //
	    for( dwCount = 0, cbSids = 0;
	         pWellKnownSids[dwCount].pSid != (PBYTE)NULL;
	         dwCount++ )
        {
	        cbSids += RtlLengthSid( (PSID)(pWellKnownSids[dwCount].pSid) );
        }

    	// Insert the SID of the Account domain if is is not an advanced server
    	//
	    if ( pAccountDomainInfo != NULL )
        {
	        cbSids += RtlLengthSid( pAccountDomainInfo->DomainSid );
	        dwCount++;
	    }

	    // Add the primary domain Sids only if this machine
	    // is a member of a domain.
	    //
	    if ( pPrimaryDomainInfo != NULL )
        {
	        cbSids += RtlLengthSid( pPrimaryDomainInfo->Sid );
	        dwCount++;
	    }

	    // OK, now allocate space for all these SIDS plus their offsets
	    //
	    cbSidOffsets = (dwCount * sizeof(AFP_SID_OFFSET)) + cbSids +
				   (sizeof(AFP_SID_OFFSET_DESC) - sizeof(AFP_SID_OFFSET));
			

    	pAfpSidOffsets = (PAFP_SID_OFFSET_DESC)LocalAlloc( LPTR, cbSidOffsets );

    	if ( pAfpSidOffsets == NULL )
        {
	        ntStatus = STATUS_NO_MEMORY ;
	        break;
	    }

	    // First insert all the well known SIDS
	    //
	    for( dwIndex = 0,
	         pAfpSidOffsets->CountOfSidOffsets = dwCount,
	         pSidOffset = pAfpSidOffsets->SidOffsetPairs,
	         pbVariableData = (LPBYTE)pAfpSidOffsets + cbSidOffsets;

	         pWellKnownSids[dwIndex].pSid != (PBYTE)NULL;

	         dwIndex++ )
        {

    	    pbVariableData-=RtlLengthSid((PSID)(pWellKnownSids[dwIndex].pSid));

	        ntStatus = AfpInsertSidOffset(
			    		pSidOffset++,
			          		pbVariableData,
    					(PSID)(pWellKnownSids[dwIndex].pSid),
	    				pWellKnownSids[dwIndex].Offset,
		    			pWellKnownSids[dwIndex].SidType );

    	    if ( !NT_SUCCESS( ntStatus ) )
            {
	    	    break;
            }
	    }

    	if ( !NT_SUCCESS( ntStatus ) )
        {
	        break;
        }

	    // Now insert the Account domain's SID/OFFSET pair if there is one
	    //
	    if ( pAccountDomainInfo != NULL )
        {
		    pbVariableData -= RtlLengthSid( pAccountDomainInfo->DomainSid );

	        ntStatus = AfpInsertSidOffset(
			    		pSidOffset++,
			      		pbVariableData,
			      		pAccountDomainInfo->DomainSid,
			      		SE_ACCOUNT_DOMAIN_POSIX_OFFSET,
					    AFP_SID_TYPE_DOMAIN );

    	    if ( !NT_SUCCESS( ntStatus ) )
            {
	    	    break;
            }

		    // Construct the "None" sid if we are a standalone server (i.e. not
		    // a PDC or BDC).  This will be used when querying the group ID of
		    // a directory so the the UI will never show this group to the user.
		    //
		    if ( AfpGlobals.NtProductType != NtProductLanManNt )
		    {
			    ULONG SubAuthCount, SizeNoneSid = 0;

			    SubAuthCount = *RtlSubAuthorityCountSid(pAccountDomainInfo->DomainSid);

			    SizeNoneSid = RtlLengthRequiredSid(SubAuthCount + 1);

			    if ((AfpGlobals.pSidNone = (PSID)LocalAlloc(LPTR,SizeNoneSid)) == NULL)
			    {
    				ntStatus = STATUS_INSUFFICIENT_RESOURCES;
				    break;
			    }

			    RtlCopySid(SizeNoneSid, AfpGlobals.pSidNone, pAccountDomainInfo->DomainSid);

			    // Add the relative ID
			    *RtlSubAuthorityCountSid(AfpGlobals.pSidNone) = (UCHAR)(SubAuthCount+1);

			    // Note that the "None" sid on standalone is the same as the
			    // "Domain Users" Sid on PDC/BDC. (On PDC/BDC the primary
			    // domain is the same as the account domain).
			    *RtlSubAuthoritySid(AfpGlobals.pSidNone, SubAuthCount) = DOMAIN_GROUP_RID_USERS;

		    }

	    }

	    // Now insert the primary domain if this machine is a member of a domain
	    //
	    if ( pPrimaryDomainInfo != NULL )
        {

	        // Insert the primary domain's SID/OFFSET pair
	        //
        	pbVariableData -= RtlLengthSid( pPrimaryDomainInfo->Sid );

	        ntStatus = AfpInsertSidOffset(	
					    pSidOffset++,
    			      	pbVariableData,
			      		pPrimaryDomainInfo->Sid,
			      		SE_PRIMARY_DOMAIN_POSIX_OFFSET,
					    AFP_SID_TYPE_PRIMARY_DOMAIN );

    	    if ( !NT_SUCCESS( ntStatus ) )
            {
	    	    break;
            }
	    }

    } while( FALSE );


    // IOCTL down the information if all was OK
    //
    if ( NT_SUCCESS( ntStatus ) )
    {
    	AfpRequestPkt.dwRequestCode 	      = OP_SERVER_ADD_SID_OFFSETS;
    	AfpRequestPkt.dwApiType 	      = AFP_API_TYPE_ADD;
    	AfpRequestPkt.Type.SetInfo.pInputBuf  = pAfpSidOffsets;
    	AfpRequestPkt.Type.Add.cbInputBufSize = cbSidOffsets;

    	dwRetCode = AfpServerIOCtrl( &AfpRequestPkt );
    }
    else
    {
	    dwRetCode = RtlNtStatusToDosError( ntStatus );
    }

    if ( pAfpSidOffsets != NULL )
    {
   	    LocalFree( pAfpSidOffsets );
    }

    // Free all the well known SIDS
    //
    for( dwIndex = 0;
	     pWellKnownSids[dwIndex].pSid != (PBYTE)NULL;
	     dwIndex++ )
    {
	    RtlFreeSid( (PSID)(pWellKnownSids[dwIndex].pSid) );
    }

    return( dwRetCode );

}

//**
//
// Call:	AfpInsertSidOffset
//
// Returns:	NT_SUCCESS
//		error return codes from RtlCopySid
//
// Description: Will insert a SID/OFFSET pair in the slot pointed to by
//		pSidOffset. The pbVariableData will point to where the
//		SID will be stored.
//
NTSTATUS
AfpInsertSidOffset(
	IN PAFP_SID_OFFSET pSidOffset,
	IN LPBYTE 	   pbVariableData,
	IN PSID		   pSid,
	IN DWORD	   Offset,
	IN AFP_SID_TYPE	   afpSidType
)
{
NTSTATUS ntStatus;

    // Copy the offset
    //
    pSidOffset->Offset = Offset;

    // Set the SID type
    //
    pSidOffset->SidType = afpSidType;

    // Copy Sid at the end of the buffer and set the offset to it
    //
    ntStatus = RtlCopySid( RtlLengthSid( pSid ), pbVariableData, pSid );

    if ( !NT_SUCCESS( ntStatus ) )
   	 return( ntStatus );

    pSidOffset->pSid = pbVariableData;

    POINTER_TO_OFFSET( (pSidOffset->pSid), pSidOffset );

    return( STATUS_SUCCESS );

}

//**
//
// Call:	AfpCreateWellknownSids
//
// Returns:	NT_SUCCESS
//	 	STATUS_NO_MEMORY
//		non-zero returns from RtlAllocateAndInitializeSid
//
// Description: Will allocate and initialize all well known SIDs.
//		The array is terminated by a NULL pointer.
//
NTSTATUS
AfpCreateWellknownSids(
	OUT AFP_SID_OFFSET pWellKnownSids[]
)
{
PSID			    pSid;
DWORD			    dwIndex = 0;
NTSTATUS		    ntStatus;
SID_IDENTIFIER_AUTHORITY    NullSidAuthority   = SECURITY_NULL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    WorldSidAuthority  = SECURITY_WORLD_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    LocalSidAuthority  = SECURITY_LOCAL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    CreatorSidAuthority= SECURITY_CREATOR_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    NtAuthority	       = SECURITY_NT_AUTHORITY;

    do {

	//
    	// OK, create all the well known SIDS
    	//

	// Create NULL SID
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&NullSidAuthority,
				      	1,
					SECURITY_NULL_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_NULL_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create WORLD SID
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&WorldSidAuthority,
				      	1,
					SECURITY_WORLD_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_WORLD_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create LOCAL SID
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&LocalSidAuthority,
				      	1,
					SECURITY_LOCAL_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_LOCAL_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create CREATOR OWNER SID
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&CreatorSidAuthority,
				      	1,
					SECURITY_CREATOR_OWNER_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_CREATOR_OWNER_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create CREATOR GROUP SID
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&CreatorSidAuthority,
				      	1,
					SECURITY_CREATOR_GROUP_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_CREATOR_GROUP_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create SECURITY_NT_AUTHORITY Sid
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&NtAuthority,
					0,0,0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_AUTHORITY_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create SECURITY_DIALUP Sid
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&NtAuthority,
					1,
					SECURITY_DIALUP_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_DIALUP_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create SECURITY_NETWORK Sid
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&NtAuthority,
					1,
					SECURITY_NETWORK_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_NETWORK_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create SECURITY_BATCH Sid
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&NtAuthority,
					1,
					SECURITY_BATCH_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_NETWORK_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create SECURITY_INTERACTIVE Sid
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&NtAuthority,
					1,
					SECURITY_INTERACTIVE_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_INTERACTIVE_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create SECURITY_SERVICE Sid
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&NtAuthority,
					1,
					SECURITY_SERVICE_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_SERVICE_POSIX_ID;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_WELL_KNOWN;
	dwIndex++;

	// Create the built in domain SID
	//
	ntStatus = RtlAllocateAndInitializeSid(
					&NtAuthority,
					1,
				      	SECURITY_BUILTIN_DOMAIN_RID,
					0,0,0,0,0,0,0,
				      	&pSid );
 	
    	if ( !NT_SUCCESS( ntStatus ) )
	    break;

	pWellKnownSids[dwIndex].pSid    = (PBYTE)pSid;
	pWellKnownSids[dwIndex].Offset  = SE_BUILT_IN_DOMAIN_POSIX_OFFSET;
	pWellKnownSids[dwIndex].SidType = AFP_SID_TYPE_DOMAIN;
	dwIndex++;

	pWellKnownSids[dwIndex].pSid   = (PBYTE)NULL;


    } while( FALSE );

    if ( !NT_SUCCESS( ntStatus ) ) {

	while( dwIndex > 0 )
	    RtlFreeSid( pWellKnownSids[--dwIndex].pSid );
    }

    return( ntStatus );
}



//**
//
// Call:	AfpChangePwdArapStyle
//
// Returns:	return code
//
// Description: This procedure will try to change the user's password on a
//		specified domain. This does it only for native Apple UAM clients
//		i.e., the user's password is stored in the DS in a reversibly-encrypted
//      form, and the client sends the old and the new password (not owf as in
//      MS-UAM case).  This is what ARAP does, that's why the name.
//      This function is big time cut-n-paste from the ARAP code
//
NTSTATUS
AfpChangePwdArapStyle(
    	IN PAFP_PASSWORD_DESC 	pPassword,
    	IN PUNICODE_STRING	    pDomainName,
    	IN PSID		  	        pDomainSid
)
{

    NTSTATUS                        status;
    NTSTATUS                        PStatus;
    PMSV1_0_PASSTHROUGH_REQUEST     pPassThruReq;
    PMSV1_0_SUBAUTH_REQUEST         pSubAuthReq;
    PMSV1_0_PASSTHROUGH_RESPONSE    pPassThruResp;
    PMSV1_0_SUBAUTH_RESPONSE        pSubAuthResp;
    DWORD                           dwSubmitBufLen;
    DWORD                           dwSubmitBufOffset;
    PRAS_SUBAUTH_INFO               pRasSubAuthInfo;
    PARAP_SUBAUTH_REQ               pArapSubAuthInfo;
    ARAP_SUBAUTH_RESP               ArapResp;
    PARAP_SUBAUTH_RESP              pArapRespBuffer;
    PVOID                           RetBuf;
    DWORD                           dwRetBufLen;



    // if our registeration with lsa process failed at init time, or if
    // there is no domain name for this user, just fail the succer
    // (if the user logged on successfully using native Apple UAM, then
    // there had better be a domain!)
    if ((SfmLsaHandle == NULL) ||(pDomainName == NULL))
    {
        return(STATUS_LOGON_FAILURE);
    }

    if (pDomainName != NULL)
    {
        if (pDomainName->Length == 0)
        {
            return(STATUS_LOGON_FAILURE);
        }
    }

    dwSubmitBufLen = sizeof(MSV1_0_PASSTHROUGH_REQUEST)         +
                        sizeof(WCHAR)*(MAX_ARAP_USER_NAMELEN+1) +  // domain name
                        sizeof(TEXT(MSV1_0_PACKAGE_NAME))       +  // package name
                        sizeof(MSV1_0_SUBAUTH_REQUEST)          +
                        sizeof(RAS_SUBAUTH_INFO)                +
                        sizeof(ARAP_SUBAUTH_REQ)                +
                        ALIGN_WORST;                               // for alignment

    pPassThruReq = (PMSV1_0_PASSTHROUGH_REQUEST)
                    GlobalAlloc(GMEM_FIXED, dwSubmitBufLen);

    if (!pPassThruReq)
    {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory((PBYTE)pPassThruReq, dwSubmitBufLen);

    //
    // Set up the MSV1_0_PASSTHROUGH_REQUEST structure
    //

    // tell MSV that it needs to visit our subauth pkg (for change pwd)
    pPassThruReq->MessageType = MsV1_0GenericPassthrough;


    pPassThruReq->DomainName.Length = pDomainName->Length;

    pPassThruReq->DomainName.MaximumLength =
            (sizeof(WCHAR) * (MAX_ARAP_USER_NAMELEN+1));

    pPassThruReq->DomainName.Buffer = (PWSTR) (pPassThruReq + 1);

    RtlMoveMemory(pPassThruReq->DomainName.Buffer,
                  pDomainName->Buffer,
                  pPassThruReq->DomainName.Length);

    pPassThruReq->PackageName.Length =
                        (sizeof(WCHAR) * wcslen(TEXT(MSV1_0_PACKAGE_NAME)));

    pPassThruReq->PackageName.MaximumLength = sizeof(TEXT(MSV1_0_PACKAGE_NAME));

    pPassThruReq->PackageName.Buffer =
        (PWSTR)((PBYTE)(pPassThruReq->DomainName.Buffer) +
                 pPassThruReq->DomainName.MaximumLength);

    RtlMoveMemory(pPassThruReq->PackageName.Buffer,
                  TEXT(MSV1_0_PACKAGE_NAME),
                  sizeof(TEXT(MSV1_0_PACKAGE_NAME)));

    pPassThruReq->DataLength = sizeof(MSV1_0_SUBAUTH_REQUEST) +
                    sizeof(RAS_SUBAUTH_INFO) + sizeof(ARAP_SUBAUTH_REQ);

    pPassThruReq->LogonData =
            ROUND_UP_POINTER( ((PBYTE)pPassThruReq->PackageName.Buffer +
                                pPassThruReq->PackageName.MaximumLength),
                                ALIGN_WORST );

	if (pPassThruReq->LogonData >= ((PCHAR)pPassThruReq + dwSubmitBufLen))
	{
			AFP_PRINT (("srvrhlpr.c: Error in ROUND_UP_POINTER\n"));
        	GlobalFree((HGLOBAL)pPassThruReq);
			return STATUS_INVALID_BUFFER_SIZE;
	}

    pSubAuthReq = (PMSV1_0_SUBAUTH_REQUEST)pPassThruReq->LogonData;

    pSubAuthReq->MessageType = MsV1_0SubAuth;
    pSubAuthReq->SubAuthPackageId = MSV1_0_SUBAUTHENTICATION_DLL_RAS;

    pSubAuthReq->SubAuthInfoLength =
                        sizeof(RAS_SUBAUTH_INFO) + sizeof(ARAP_SUBAUTH_REQ);

    //
    // this pointer is self-relative
    //
    pSubAuthReq->SubAuthSubmitBuffer = (PUCHAR)sizeof(MSV1_0_SUBAUTH_REQUEST);


    //
    // copy the structure our subauth pkg will use at the other end
    //
    pRasSubAuthInfo = (PRAS_SUBAUTH_INFO)(pSubAuthReq + 1);


    pRasSubAuthInfo->ProtocolType = RAS_SUBAUTH_PROTO_ARAP;
    pRasSubAuthInfo->DataSize = sizeof(ARAP_SUBAUTH_REQ);

    pArapSubAuthInfo = (PARAP_SUBAUTH_REQ)&pRasSubAuthInfo->Data[0];

    pArapSubAuthInfo->PacketType = SFM_SUBAUTH_CHGPWD_PKT;

    wcscpy(pArapSubAuthInfo->ChgPwd.UserName, pPassword->UserName);

    RtlCopyMemory(pArapSubAuthInfo->ChgPwd.OldMunge,
                  pPassword->OldPassword,
                  MAX_MAC_PWD_LEN);

    pArapSubAuthInfo->ChgPwd.OldMunge[MAX_MAC_PWD_LEN] = 0;

    RtlCopyMemory(pArapSubAuthInfo->ChgPwd.NewMunge,
                  pPassword->NewPassword,
                  MAX_MAC_PWD_LEN);

    pArapSubAuthInfo->ChgPwd.NewMunge[MAX_MAC_PWD_LEN] = 0;

    //
    // whew! finally done setting up all the parms: now call that api
    //

    status = LsaCallAuthenticationPackage (
                        SfmLsaHandle,
                        SfmAuthPkgId,
                        pPassThruReq,
                        dwSubmitBufLen,
                        &RetBuf,
                        &dwRetBufLen,
                        &PStatus);

    if (status != STATUS_SUCCESS || PStatus != STATUS_SUCCESS)
    {
        GlobalFree((HGLOBAL)pPassThruReq);

        if (status == STATUS_SUCCESS)
        {
            status = PStatus;
        }
        return(status);
    }


    pPassThruResp = (PMSV1_0_PASSTHROUGH_RESPONSE)RetBuf;

    pSubAuthResp = (PMSV1_0_SUBAUTH_RESPONSE)(pPassThruResp->ValidationData);


    // our return buffer is in self-relative format
    pArapRespBuffer = (PARAP_SUBAUTH_RESP)((PBYTE)pSubAuthResp +
                           (ULONG_PTR)(pSubAuthResp->SubAuthReturnBuffer));


    RtlCopyMemory(&ArapResp,
                  (PUCHAR)pArapRespBuffer,
                  pSubAuthResp->SubAuthInfoLength);


    GlobalFree((HGLOBAL)pPassThruReq);

    LsaFreeReturnBuffer(RetBuf);

    if(ArapResp.Result != 0)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\sfmctrs\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h  

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a 
// performance data instance (PERF_INSTANCE_DEFINITION) as described in 
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\service\server\volume.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	volume.c
//
// Description: This module contains support routines for the volume
//		category API's for the AFP server service
//
// History:
//		June 11,1992.	NarenG		Created original version.
//
#include "afpsvcp.h"

static HANDLE hmutexInvalidVolume;

// Invalid volume structure
//
typedef struct _AFP_BADVOLUME {

    LPWSTR	    lpwsName;

    LPWSTR	    lpwsPath;

    DWORD 	    cbVariableData; // Number of bytes of name+path.

    struct _AFP_BADVOLUME * Next;

} AFP_BADVOLUME, * PAFP_BADVOLUME;

// Singly linked list of invalid volumes
//
typedef struct _AFP_INVALID_VOLUMES {

    DWORD 	    cbTotalData;

    PAFP_BADVOLUME  Head;

} AFP_INVALID_VOLUMES;

static AFP_INVALID_VOLUMES InvalidVolumeList;


//**
//
// Call:	AfpAdminrVolumeEnum
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminrVolumeEnum function.
//
DWORD
AfpAdminrVolumeEnum(
	IN     AFP_SERVER_HANDLE 	hServer,
	IN OUT PVOLUME_INFO_CONTAINER   pInfoStruct,
  	IN     DWORD 		    	dwPreferedMaximumLength,
	OUT    LPDWORD 		        lpdwTotalEntries,
	IN OUT LPDWORD 		        lpdwResumeHandle  OPTIONAL
)
{
AFP_REQUEST_PACKET AfpSrp;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeEnum, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS,
		     0, NULL, dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeEnum, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Set up request packet and make IOCTL to the FSD
    //
    AfpSrp.dwRequestCode 		= OP_VOLUME_ENUM;
    AfpSrp.dwApiType     		= AFP_API_TYPE_ENUM;
    AfpSrp.Type.Enum.cbOutputBufSize    = dwPreferedMaximumLength;

    // If resume handle was not passed then we set it to zero, cause caller
    // wants all information starting from the beginning.
    //
    if ( lpdwResumeHandle )
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = *lpdwResumeHandle;
    else
     	AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index = 0;

    dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	return( dwRetCode );

    *lpdwTotalEntries 	       = AfpSrp.Type.Enum.dwTotalAvail;
    pInfoStruct->pBuffer       =(PAFP_VOLUME_INFO)(AfpSrp.Type.Enum.pOutputBuf);
    pInfoStruct->dwEntriesRead = AfpSrp.Type.Enum.dwEntriesRead;

    if ( lpdwResumeHandle )
    	*lpdwResumeHandle = AfpSrp.Type.Enum.EnumRequestPkt.erqp_Index;

    // Convert all offsets to pointers
    //
    AfpBufOffsetToPointer( (LPBYTE)(pInfoStruct->pBuffer),
			   pInfoStruct->dwEntriesRead,
			   AFP_VOLUME_STRUCT );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrVolumeSetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminVolumeSetInfo function.
//
DWORD
AfpAdminrVolumeSetInfo(
	IN AFP_SERVER_HANDLE 	hServer,
	IN PAFP_VOLUME_INFO     pAfpVolumeInfo,
	IN DWORD		dwParmNum
)
{
AFP_REQUEST_PACKET 	AfpSrp;
DWORD			dwRetCode=0;
LPBYTE 			pAfpVolumeInfoSR = NULL;
DWORD			cbAfpVolumeInfoSRSize;
DWORD		        dwAccessStatus=0;
					

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeSetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeSetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexVolume, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

        // Make this buffer self-relative.
    	//
    	if ( dwRetCode = AfpBufMakeFSDRequest((LPBYTE)pAfpVolumeInfo,
					       sizeof(SETINFOREQPKT),
					       AFP_VOLUME_STRUCT,
					       &pAfpVolumeInfoSR,
					       &cbAfpVolumeInfoSRSize ))
	    break;

        // Make IOCTL to set info
    	//
    	AfpSrp.dwRequestCode 		    = OP_VOLUME_SET_INFO;
    	AfpSrp.dwApiType     		    = AFP_API_TYPE_SETINFO;
    	AfpSrp.Type.SetInfo.pInputBuf       = pAfpVolumeInfoSR;
    	AfpSrp.Type.SetInfo.cbInputBufSize  = cbAfpVolumeInfoSRSize;
    	AfpSrp.Type.SetInfo.dwParmNum       = dwParmNum;

        if ( dwRetCode = AfpServerIOCtrl( &AfpSrp ) )
	    break;

	// Now IOCTL the FSD to get information to set in the registry
	// The input buffer for a GetInfo type call should point to a volume
	// structure with the volume name filled in. Since we already have
	// this from the previos SetInfo call, we use the same buffer with
	// the pointer advances by sizeof(SETINFOREQPKT) bytes.
	//
    	AfpSrp.dwRequestCode 		    = OP_VOLUME_GET_INFO;
    	AfpSrp.dwApiType     		    = AFP_API_TYPE_GETINFO;
    	AfpSrp.Type.GetInfo.pInputBuf       = pAfpVolumeInfoSR +
					      sizeof(SETINFOREQPKT);
    	AfpSrp.Type.GetInfo.cbInputBufSize  = cbAfpVolumeInfoSRSize -
					      sizeof(SETINFOREQPKT);

	if ( dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp ) )
	    break;
	
        // Update the registry if the IOCTL was successful
        //
	AfpBufOffsetToPointer( AfpSrp.Type.GetInfo.pOutputBuf,
			       1,
		               AFP_VOLUME_STRUCT
			     );

	dwRetCode = AfpRegVolumeSetInfo( AfpSrp.Type.GetInfo.pOutputBuf );

	LocalFree( AfpSrp.Type.GetInfo.pOutputBuf );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexVolume );

    if ( pAfpVolumeInfoSR )
    	LocalFree( pAfpVolumeInfoSR );

    return( dwRetCode );

}

//**
//
// Call:	AfpAdminrVolumeDelete
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminVolumeDelete function.
//
DWORD
AfpAdminrVolumeDelete(
	IN AFP_SERVER_HANDLE 	hServer,
	IN LPWSTR 		lpwsVolumeName
)
{
AFP_REQUEST_PACKET AfpSrp;
PAFP_VOLUME_INFO   pAfpVolumeInfoSR;
AFP_VOLUME_INFO    AfpVolumeInfo;
DWORD		   cbAfpVolumeInfoSRSize;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeDelete, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeDelete, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // Delete FSD request expects a AFP_VOLUME_INFO structure with only
    // the volume name field filled in.
    //
    AfpVolumeInfo.afpvol_name     = lpwsVolumeName;
    AfpVolumeInfo.afpvol_password = NULL;
    AfpVolumeInfo.afpvol_path     = NULL;

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexVolume, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

    	// Make this buffer self-relative.
    	//
    	if ( dwRetCode = AfpBufMakeFSDRequest((LPBYTE)&AfpVolumeInfo,
					      0,
					      AFP_VOLUME_STRUCT,
					      (LPBYTE*)&pAfpVolumeInfoSR,
					      &cbAfpVolumeInfoSRSize ) )
	    break;

        // IOCTL the FSD to delete the volume
        //
        AfpSrp.dwRequestCode 		    = OP_VOLUME_DELETE;
        AfpSrp.dwApiType     		    = AFP_API_TYPE_DELETE;
        AfpSrp.Type.Delete.pInputBuf        = pAfpVolumeInfoSR;
        AfpSrp.Type.Delete.cbInputBufSize   = cbAfpVolumeInfoSRSize;

        dwRetCode = AfpServerIOCtrl( &AfpSrp );

    	LocalFree( pAfpVolumeInfoSR );

	if ( dwRetCode )
	    break;

    	// Update the registry if the IOCTL was successful
    	//
	dwRetCode = AfpRegVolumeDelete( lpwsVolumeName );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexVolume );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrVolumeAdd
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrl
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminVolumeAdd function.
//
DWORD
AfpAdminrVolumeAdd(
	IN AFP_SERVER_HANDLE 	hServer,
	IN PAFP_VOLUME_INFO     pAfpVolumeInfo
)
{
AFP_REQUEST_PACKET 	AfpSrp;
DWORD				dwRetCode=0, dwLastDstCharIndex = 0;
PAFP_VOLUME_INFO 	pAfpVolumeInfoSR = NULL;
DWORD			cbAfpVolumeInfoSRSize;
DWORD			dwAccessStatus=0;
BOOL			fCopiedIcon = FALSE;
WCHAR			wchSrcIconPath[MAX_PATH];
WCHAR wchDstIconPath[MAX_PATH + AFPSERVER_VOLUME_ICON_FILE_SIZE + 1 + (sizeof(AFPSERVER_RESOURCE_STREAM)/sizeof(WCHAR))];
WCHAR wchServerIconFile[AFPSERVER_VOLUME_ICON_FILE_SIZE] = AFPSERVER_VOLUME_ICON_FILE;

	// Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeAdd, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0,
		     NULL, dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeAdd, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

	if ( pAfpVolumeInfo == NULL)
	{
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeAdd, pAfpVolumeInfo == NULL\n"));
        return( ERROR_INVALID_DATA );
	}

    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexVolume, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

		// Copy the server icon to the volume root
		//

		// Construct a path to the NTSFM volume custom icon
		//
		if ( GetSystemDirectory( wchSrcIconPath, MAX_PATH ) )
		{
			wcscat( wchSrcIconPath, AFP_DEF_VOLICON_SRCNAME );

			if ( pAfpVolumeInfo->afpvol_path == NULL )
			{
        			AFP_PRINT(( "SFMSVC: AfpAdminrVolumeAdd, pAfpVolumeInfo->afpvol_path == NULL\n"));
        			dwRetCode = ERROR_INVALID_DATA;
				    break;
			}

			// Construct a path to the destination volume "Icon<0D>" file
			//
			wcscpy( wchDstIconPath, pAfpVolumeInfo->afpvol_path );

			if ( wcslen(wchDstIconPath) == 0 )
			{
        			AFP_PRINT(( "SFMSVC: AfpAdminrVolumeAdd, wcslen(wchDstIconPath) == 0\n"));
        			dwRetCode = ERROR_INVALID_DATA;
				break;
			}

			if (wchDstIconPath[wcslen(wchDstIconPath) - 1] != TEXT('\\'))
			{
				wcscat( wchDstIconPath, TEXT("\\") );
			}
			wcscat( wchDstIconPath, wchServerIconFile );
			// Keep track of end of name without the resource fork tacked on
			//
			dwLastDstCharIndex = wcslen(wchDstIconPath);
			wcscat( wchDstIconPath, AFPSERVER_RESOURCE_STREAM );

			// Copy the icon file to the root of the volume (do not overwrite)
			//
			if ((fCopiedIcon = CopyFile( wchSrcIconPath, wchDstIconPath, TRUE )) ||
			   (GetLastError() == ERROR_FILE_EXISTS))
			{
				pAfpVolumeInfo->afpvol_props_mask |= AFP_VOLUME_HAS_CUSTOM_ICON;

			    // Make sure the file is hidden
				SetFileAttributes( wchDstIconPath,
								   FILE_ATTRIBUTE_HIDDEN |
								    FILE_ATTRIBUTE_ARCHIVE );
			}
		}
        else
        {
            dwRetCode = GetLastError ();
            break;
        }

    	// Make this buffer self-relative.
    	//
    	if ( dwRetCode = AfpBufMakeFSDRequest( (LPBYTE)pAfpVolumeInfo,
					       0,
					       AFP_VOLUME_STRUCT,
					       (LPBYTE*)&pAfpVolumeInfoSR,
					       &cbAfpVolumeInfoSRSize ) )
	    break;

    	// IOCTL the FSD to add the volume
    	//
    	AfpSrp.dwRequestCode 		= OP_VOLUME_ADD;
    	AfpSrp.dwApiType     		= AFP_API_TYPE_ADD;
    	AfpSrp.Type.Add.pInputBuf     	= pAfpVolumeInfoSR;
    	AfpSrp.Type.Add.cbInputBufSize  = cbAfpVolumeInfoSRSize;

        dwRetCode = AfpServerIOCtrl( &AfpSrp );

		// Don't allow icon bit to be written to the registry if it was set
		pAfpVolumeInfo->afpvol_props_mask &= ~AFP_VOLUME_HAS_CUSTOM_ICON;

		if ( dwRetCode )
		{
			// Delete the icon file we just copied if the volume add failed
			//
			if ( fCopiedIcon )
			{
				// Truncate the resource fork name so we delete the whole file
				wchDstIconPath[dwLastDstCharIndex] = 0;
				DeleteFile( wchDstIconPath );
			}

			break;
        }

        // Update the registry if the IOCTL was successful
        //
		dwRetCode = AfpRegVolumeAdd( pAfpVolumeInfo );

		if ( dwRetCode )
			break;

		// Delete this volume if it exists in the invalid volume list
		//
    	AfpDeleteInvalidVolume( pAfpVolumeInfo->afpvol_name );

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexVolume );

    if ( pAfpVolumeInfoSR != NULL )
		LocalFree( pAfpVolumeInfoSR );

    return( dwRetCode );

}

//**
//
// Call:	AfpAdminrVolumeGetInfo
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//		non-zero returns from AfpServerIOCtrlGetInfo
//
// Description: This routine communicates with the AFP FSD to implement
//		the AfpAdminVolumeGetInfo function.
//
DWORD
AfpAdminrVolumeGetInfo(
	IN  AFP_SERVER_HANDLE 	hServer,
	IN  LPWSTR 		lpwsVolumeName,
    	OUT PAFP_VOLUME_INFO*   ppAfpVolumeInfo
)
{
AFP_REQUEST_PACKET AfpSrp;
PAFP_VOLUME_INFO   pAfpVolumeInfoSR;
AFP_VOLUME_INFO    AfpVolumeInfo;
DWORD		   cbAfpVolumeInfoSRSize;
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeGetInfo, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrVolumeGetInfo, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }


    // MUTEX start
    //
    WaitForSingleObject( AfpGlobals.hmutexVolume, INFINITE );

    // This loop is used to allow break's instead of goto's to be used
    // on an error condition.
    //
    do {

	dwRetCode = NO_ERROR;

    	// Get info FSD request expects a AFP_VOLUME_INFO structure with only
    	// the volume name field filled in.
    	//
    	AfpVolumeInfo.afpvol_name     = lpwsVolumeName;
    	AfpVolumeInfo.afpvol_password = NULL;
    	AfpVolumeInfo.afpvol_path     = NULL;

    	// Make this buffer self-relative.
    	//
    	if ( dwRetCode = AfpBufMakeFSDRequest((LPBYTE)&AfpVolumeInfo,
					      0,
					      AFP_VOLUME_STRUCT,
					      (LPBYTE*)&pAfpVolumeInfoSR,
					      &cbAfpVolumeInfoSRSize ) )
	    break;

    	AfpSrp.dwRequestCode 	           = OP_VOLUME_GET_INFO;
    	AfpSrp.dwApiType     	           = AFP_API_TYPE_GETINFO;
    	AfpSrp.Type.GetInfo.pInputBuf      = pAfpVolumeInfoSR;
    	AfpSrp.Type.GetInfo.cbInputBufSize = cbAfpVolumeInfoSRSize;

	dwRetCode = AfpServerIOCtrlGetInfo( &AfpSrp );

    	if ( dwRetCode != ERROR_MORE_DATA && dwRetCode != NO_ERROR )
	    break;

    	LocalFree( pAfpVolumeInfoSR );

    	*ppAfpVolumeInfo = AfpSrp.Type.GetInfo.pOutputBuf;

    	// Convert all offsets to pointers
    	//
    	AfpBufOffsetToPointer( (LPBYTE)*ppAfpVolumeInfo, 1, AFP_VOLUME_STRUCT);

    } while( FALSE );

    // MUTEX end
    //
    ReleaseMutex( AfpGlobals.hmutexVolume );

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrInvalidVolumeEnum
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//
// Description: This routine will return a list of all invalid volumes. This
//		List is stored in a cache that is local to this module.
//
DWORD
AfpAdminrInvalidVolumeEnum(
	IN     AFP_SERVER_HANDLE 	hServer,
	IN OUT PVOLUME_INFO_CONTAINER   pInfoStruct
)
{
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;
PAFP_VOLUME_INFO   pOutputBuf;
PAFP_VOLUME_INFO   pOutputWalker;
WCHAR *   	   pwchVariableData;
PAFP_BADVOLUME     pAfpBadVolWalker;


    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrInvalidVolumeEnum, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrInvalidVolumeEnum, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }

    // MUTEX start
    //
    WaitForSingleObject( hmutexInvalidVolume, INFINITE );

    // Allocate enough space to hold all the information.
    //
    pOutputBuf = MIDL_user_allocate( InvalidVolumeList.cbTotalData );

    if ( pOutputBuf == NULL ){
    	ReleaseMutex( hmutexInvalidVolume );
	return( ERROR_NOT_ENOUGH_MEMORY );
    }

    ZeroMemory( pOutputBuf, InvalidVolumeList.cbTotalData );

    // Variable data begins from the end of the buffer.
    //
    pwchVariableData=(WCHAR*)((ULONG_PTR)pOutputBuf+InvalidVolumeList.cbTotalData);

    // Walk the list and create the array of volume structures
    //
    for( pAfpBadVolWalker = InvalidVolumeList.Head,
         pInfoStruct->dwEntriesRead = 0,
	 pOutputWalker = pOutputBuf;

         pAfpBadVolWalker != NULL;

	 pOutputWalker++,
         (pInfoStruct->dwEntriesRead)++,
         pAfpBadVolWalker = pAfpBadVolWalker->Next ) {

	pwchVariableData -= (STRLEN(pAfpBadVolWalker->lpwsName) + 1);

        STRCPY( (LPWSTR)pwchVariableData, pAfpBadVolWalker->lpwsName );

	pOutputWalker->afpvol_name = (LPWSTR)pwchVariableData;

	if ( pAfpBadVolWalker->lpwsPath != NULL ) {

	    pwchVariableData -=( STRLEN(pAfpBadVolWalker->lpwsPath)+1 );

            STRCPY( (LPWSTR)pwchVariableData, pAfpBadVolWalker->lpwsPath );

	    pOutputWalker->afpvol_path = (LPWSTR)pwchVariableData;

	}

    }

    // MUTEX end
    //
    ReleaseMutex( hmutexInvalidVolume );

    pInfoStruct->pBuffer = pOutputBuf;

    return( dwRetCode );
}

//**
//
// Call:	AfpAdminrInvalidVolumeDelete
//
// Returns:	NO_ERROR
//		ERROR_ACCESS_DENIED
//
// Description: This routine will remove an invalid volume from the registry
//		and the list of invalid volumes.
//
DWORD
AfpAdminrInvalidVolumeDelete(
	IN AFP_SERVER_HANDLE 	hServer,
	IN LPWSTR 		lpwsVolumeName
)
{
DWORD		   dwRetCode=0;
DWORD		   dwAccessStatus=0;

    // Check if caller has access
    //
    if ( dwRetCode = AfpSecObjAccessCheck( AFPSVC_ALL_ACCESS, &dwAccessStatus))
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrInvalidVolumeDelete, AfpSecObjAccessCheck failed %ld\n",dwRetCode));
	    AfpLogEvent( AFPLOG_CANT_CHECK_ACCESS, 0, NULL,
		     dwRetCode, EVENTLOG_ERROR_TYPE );
        return( ERROR_ACCESS_DENIED );
    }

    if ( dwAccessStatus )
    {
        AFP_PRINT(( "SFMSVC: AfpAdminrInvalidVolumeDelete, AfpSecObjAccessCheck returned %ld\n",dwAccessStatus));
        return( ERROR_ACCESS_DENIED );
    }


    // Remove this volume from the registry
    //
    if ( dwRetCode = AfpRegVolumeDelete( lpwsVolumeName  ) ) {

	if ( dwRetCode == ERROR_FILE_NOT_FOUND )
	    dwRetCode = (DWORD)AFPERR_VolumeNonExist;
    }

    // MUTEX start
    //
    WaitForSingleObject( hmutexInvalidVolume, INFINITE );

    AfpDeleteInvalidVolume( lpwsVolumeName );

    // MUTEX end
    //
    ReleaseMutex( hmutexInvalidVolume );

    return( dwRetCode );
}

//**
//
// Call:	AfpAddInvalidVolume
//
// Returns:	none
//
// Description: Will add a volume structure to a sigly linked list of volumes.
//
VOID
AfpAddInvalidVolume(
	IN LPWSTR	lpwsName,
	IN LPWSTR	lpwsPath
)
{
DWORD		 dwRetCode = NO_ERROR;
WCHAR* 	 	 pwchVariableData = NULL;
PAFP_BADVOLUME   pAfpVolumeInfo = NULL;
DWORD		 cbVariableData;

    // MUTEX start
    //
    WaitForSingleObject( hmutexInvalidVolume, INFINITE );

    do {

    	cbVariableData = (STRLEN(lpwsName)+1) * sizeof(WCHAR);

    	if ( lpwsPath != NULL )
    	    cbVariableData += ( (STRLEN(lpwsPath)+1)*sizeof(WCHAR) );

    	pwchVariableData = (WCHAR*)LocalAlloc( LPTR, cbVariableData );

    	if ( pwchVariableData == NULL ) {
	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
    	}

    	pAfpVolumeInfo = (PAFP_BADVOLUME)LocalAlloc( LPTR,
						     sizeof(AFP_BADVOLUME));
    	if ( pAfpVolumeInfo == NULL ) {
	    dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
	    break;
    	}

	// Add the volume strucutre
        //
	pAfpVolumeInfo->Next = InvalidVolumeList.Head;

        InvalidVolumeList.Head = pAfpVolumeInfo;

	// Add the name and the path
	//
	STRCPY( (LPWSTR)pwchVariableData, lpwsName );
	pAfpVolumeInfo->lpwsName = (LPWSTR)pwchVariableData;

	if ( lpwsPath != NULL ) {

	    pwchVariableData += ( STRLEN( lpwsName ) + 1);
	    STRCPY( (LPWSTR)pwchVariableData, lpwsPath );
	    pAfpVolumeInfo->lpwsPath = (LPWSTR)pwchVariableData;
	}

	pAfpVolumeInfo->cbVariableData = cbVariableData;

	InvalidVolumeList.cbTotalData +=  ( sizeof( AFP_VOLUME_INFO ) +
					    cbVariableData );
	
    } while( FALSE );

    if ( dwRetCode != NO_ERROR ) {

    	if ( pAfpVolumeInfo != NULL )
	    LocalFree( pAfpVolumeInfo );

    	if ( pwchVariableData != NULL ) {
	    LocalFree( pwchVariableData );
	}
    }

    // MUTEX end
    //
    ReleaseMutex( hmutexInvalidVolume );
}

//**
//
// Call:	AfpDeleteInvalidVolume
//
// Returns:	none
//
// Description: Will delete a volume structure from the list of invalid
//		volumes, if it is found.
//
VOID
AfpDeleteInvalidVolume(
	IN LPWSTR	lpwsVolumeName
)
{
PAFP_BADVOLUME	   pTmp;
PAFP_BADVOLUME     pBadVolWalker;

    // Walk the list and delete the volume structure
    //
    if ( InvalidVolumeList.Head != NULL ) {
	
	if ( STRICMP( InvalidVolumeList.Head->lpwsName, lpwsVolumeName ) == 0 ){
	
	    pTmp = InvalidVolumeList.Head;

	    InvalidVolumeList.cbTotalData -= ( sizeof( AFP_VOLUME_INFO )
					       + pTmp->cbVariableData );
	
	    InvalidVolumeList.Head = pTmp->Next;

	    LocalFree( pTmp->lpwsName );
	    LocalFree( pTmp );
	}
	else {

	    for( pBadVolWalker = InvalidVolumeList.Head;
		 pBadVolWalker->Next != NULL;
		 pBadVolWalker = pBadVolWalker->Next ) {

		if ( STRICMP( pBadVolWalker->Next->lpwsName, lpwsVolumeName )
			      == 0 ) {

		    pTmp = pBadVolWalker->Next;

    	    	    InvalidVolumeList.cbTotalData -= ( sizeof( AFP_VOLUME_INFO )
						       + pTmp->cbVariableData );

		    pBadVolWalker->Next = pTmp->Next;

		    LocalFree( pTmp->lpwsName );
		    LocalFree( pTmp);

		    break;
		}

	    }
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\sfmctrs\datasfm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

      datasfm.h

Abstract:

    Header file for the SFM Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

   Russ Blake  02/24/93
   Sue Adams 	6/03/93

Revision History:


--*/

#ifndef _DATASFM_H_
#define _DATASFM_H_

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define SFM_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------

//
//  SFM Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define NUM_MAXPAGD_OFFSET	    sizeof(PERF_COUNTER_BLOCK)
#define NUM_CURPAGD_OFFSET	    NUM_MAXPAGD_OFFSET + sizeof(DWORD) // sizeof previous counter
#define NUM_MAXNONPAGD_OFFSET	NUM_CURPAGD_OFFSET + sizeof(DWORD)
#define NUM_CURNONPAGD_OFFSET	NUM_MAXNONPAGD_OFFSET + sizeof(DWORD)
#define NUM_CURSESSIONS_OFFSET 	NUM_CURNONPAGD_OFFSET + sizeof(DWORD)
#define NUM_MAXSESSIONS_OFFSET  NUM_CURSESSIONS_OFFSET + sizeof(DWORD)
#define NUM_CURFILESOPEN_OFFSET NUM_MAXSESSIONS_OFFSET + sizeof(DWORD)
#define NUM_MAXFILESOPEN_OFFSET NUM_CURFILESOPEN_OFFSET + sizeof(DWORD)
#define NUM_NUMFAILEDLOGINS_OFFSET	NUM_MAXFILESOPEN_OFFSET + sizeof(DWORD)
#define NUM_DATAREAD_OFFSET 	NUM_NUMFAILEDLOGINS_OFFSET + sizeof(DWORD)
#define NUM_DATAWRITTEN_OFFSET 	NUM_DATAREAD_OFFSET + sizeof(LARGE_INTEGER)
#define NUM_DATAIN_OFFSET 		NUM_DATAWRITTEN_OFFSET + sizeof(LARGE_INTEGER)
#define NUM_DATAOUT_OFFSET 		NUM_DATAIN_OFFSET + sizeof(LARGE_INTEGER)
#define NUM_CURQUEUELEN_OFFSET 	NUM_DATAOUT_OFFSET + sizeof(LARGE_INTEGER)
#define NUM_MAXQUEUELEN_OFFSET 	NUM_CURQUEUELEN_OFFSET + sizeof(DWORD)

#define NUM_CURTHREADS_OFFSET 	NUM_MAXQUEUELEN_OFFSET + sizeof(DWORD)
#define NUM_MAXTHREADS_OFFSET 	NUM_CURTHREADS_OFFSET + sizeof(DWORD)

#define SIZE_OF_SFM_PERFORMANCE_DATA \
				    NUM_MAXTHREADS_OFFSET + sizeof(DWORD)


//
//  This is the counter structure presently returned by Sfm for
//  each Resource.  Each Resource is an Instance, named by its number.
//  (Sfm has no instances)
//

typedef struct _SFM_DATA_DEFINITION {
    PERF_OBJECT_TYPE		SfmObjectType;
    PERF_COUNTER_DEFINITION	MaxPagdMem;
	PERF_COUNTER_DEFINITION CurPagdMem;
    PERF_COUNTER_DEFINITION	MaxNonPagdMem;
	PERF_COUNTER_DEFINITION	CurNonPagdMem;
	PERF_COUNTER_DEFINITION CurSessions;
	PERF_COUNTER_DEFINITION MaxSessions;
	PERF_COUNTER_DEFINITION CurFilesOpen;
	PERF_COUNTER_DEFINITION MaxFilesOpen;
	PERF_COUNTER_DEFINITION FailedLogins;
	PERF_COUNTER_DEFINITION DataRead;
	PERF_COUNTER_DEFINITION DataWritten;
	PERF_COUNTER_DEFINITION DataIn;
	PERF_COUNTER_DEFINITION DataOut;
	PERF_COUNTER_DEFINITION CurQueueLen;
	PERF_COUNTER_DEFINITION MaxQueueLen;
	PERF_COUNTER_DEFINITION CurThreads;
	PERF_COUNTER_DEFINITION MaxThreads;

} SFM_DATA_DEFINITION;

#pragma pack ()

#endif //_DATASFM_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\sfmctrs\sfmctrnm.h ===
//
//  sfmctrnm.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define SFMOBJ 0

#define MAXPAGD 2
#define CURPAGD 4

#define MAXNONPAGD 6
#define CURNONPAGD 8

#define CURSESSIONS	10
#define MAXSESSIONS	12

#define CURFILESOPEN	14
#define MAXFILESOPEN	16

#define NUMFAILEDLOGINS		18

#define	DATAREAD	20
#define DATAWRITTEN	22

#define	DATAIN	24
#define DATAOUT	26

#define CURQUEUELEN	28
#define MAXQUEUELEN	30

#define CURTHREADS	32
#define MAXTHREADS	34




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\sfmctrs\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "sfmctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging
//             LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\sfmctrs\datasfm.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    datasfm.c

Abstract:

    a file containing the constant data structures used by the Performance
    Monitor data for the MacFile extensible counters.

    This file contains a set of constant data structures which are
    currently defined for the MacFile extensible counters.

Created:

    Russ Blake  26 Feb 93
	Sue Adams	03 Jun 93 - Adapt for use by MacFile counters

Revision History:

    Sue Adams	23 Feb 94 - Hard code counter and help indexes since these
							values are now part of the NT base system counter
	                        index values.

--*/
//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include "datasfm.h"

//
//  Constant structure initializations
//      defined in datasfm.h
//

SFM_DATA_DEFINITION SfmDataDefinition = {

    {
		// TotalByteLength
		sizeof(SFM_DATA_DEFINITION) + SIZE_OF_SFM_PERFORMANCE_DATA,

		// DefinitionLength
		sizeof(SFM_DATA_DEFINITION),

		// HeaderLength
		sizeof(PERF_OBJECT_TYPE),

		// ObjectNameTitleIndex
		1000,

		// ObjectNameTitle
		0,

	   // ObjectHelpTitleIndex
	   1001,

	   // ObjectHelpTitle
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // NumCounters
	   (sizeof(SFM_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE)) / sizeof(PERF_COUNTER_DEFINITION),

	   // DefaultCounter
	   0,

	   // NumInstances
	   PERF_NO_INSTANCES,

	   // CodePage
	   0,

	   // PerfTime
	   {0,0},

	   // PerfFreq
	   {0,0}
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1002,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1003,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXPAGD_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1004,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1005,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURPAGD_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1006,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1007,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXNONPAGD_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1008,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1009,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURNONPAGD_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1010,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1011,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURSESSIONS_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1012,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1013,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXSESSIONS_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1014,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1015,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_WIZARD,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURFILESOPEN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1016,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1017,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_WIZARD,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXFILESOPEN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1018,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1019,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_NUMFAILEDLOGINS_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1020,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1021,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_BULK_COUNT,

	   // CounterSize
	   sizeof(LARGE_INTEGER),

	   // CounterOffset
	   NUM_DATAREAD_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1022,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1023,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_BULK_COUNT,

	   // CounterSize
	   sizeof(LARGE_INTEGER),

	   // CounterOffset
	   NUM_DATAWRITTEN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1024,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1025,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_BULK_COUNT,

	   // CounterSize
	   sizeof(LARGE_INTEGER),

	   // CounterOffset
	   NUM_DATAIN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1026,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1027,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   -4,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_BULK_COUNT,

	   // CounterSize
	   sizeof(LARGE_INTEGER),

	   // CounterOffset
	   NUM_DATAOUT_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1028,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1029,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURQUEUELEN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1030,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1031,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXQUEUELEN_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1032,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1033,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_CURTHREADS_OFFSET
   },
   {
	   // ByteLength
	   sizeof(PERF_COUNTER_DEFINITION),

	   // CounterNameTitleIndex
	   1034,

	   // CounterNameTitle
	   0,

	   // CounterHelpTitleIndex
	   1035,

	   // CounterHelpTitle
	   0,

	   // DefaultScale
	   0,

	   // DetailLevel
	   PERF_DETAIL_NOVICE,

	   // CounterType
	   PERF_COUNTER_RAWCOUNT,

	   // CounterSize
	   sizeof(DWORD),

	   // CounterOffset
	   NUM_MAXTHREADS_OFFSET
   }
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\sfmctrs\perfsfm.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfsfm.c

Abstract:

    This file implements the Extensible Objects for  the Sfm object type

Created:

    Russ Blake			24 Feb 93
	Sue Adams			07 Jun 93

Revision History
	Sue Adams			23 Feb 94 - no longer need to open \MacSrv\... registry
						key to query for FirstCounter and FirstHelp.  These
	                    are now hardcoded values in the base NT system.
						SFMOBJ = 1000, SFMOBJ_HELP = 1001
	Jameel Hyder		Use SFM Apis instead of Nt apis to get the counters.

--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <string.h>
#include <wcstr.h>
#include <winperf.h>
#include "sfmctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "datasfm.h"
#include <macfile.h>
#include <admin.h>

//
//  References to constants which initialize the Object type definitions
//  (see datasfm.h & .c)
//

extern SFM_DATA_DEFINITION SfmDataDefinition;

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK

//
// Sfm data structures
//

PPERF_COUNTER_BLOCK pCounterBlock;

AFP_SERVER_HANDLE	SfmRpcHandle;

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC		OpenAfpPerformanceData;
PM_COLLECT_PROC		CollectAfpPerformanceData;
PM_CLOSE_PROC		CloseAfpPerformanceData;


DWORD
OpenAfpPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open the Sfmsrv FSD/FSP driver to
    pass performance data back. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened.  (Will be null for
	MacFile).


Return Value:

    None.

--*/

{
    LONG status;

    OBJECT_ATTRIBUTES SfmObjectAttributes;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //
#if DBG
	OutputDebugString("sfmctr.dll: Open routine entered...\n");
#endif

	if (!dwOpenCount) {
        // open Eventlog interface

        hEventLog = MonOpenEventLog();

        pCounterBlock = NULL;   // initialize pointer to memory

		status = AfpAdminConnect(L"", &SfmRpcHandle);
		
        if (!NT_SUCCESS(status)) {
            REPORT_ERROR (SFMPERF_OPEN_FILE_DRIVER_ERROR, LOG_USER);
            // this is fatal, if we can't open the driver then there's no
            // point in continuing.
            goto OpenExitPoint;
        }

        bInitOK = TRUE; // ok to use this function
    }

    dwOpenCount++;  // increment OPEN counter

    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return status;
}


DWORD
CollectAfpPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the SFM counters.

Arguments:

	IN		LPWSTR   lpValueName
			pointer to a wide character string passed by registry.

	IN OUT	LPVOID   *lppData
	IN:		pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
    OUT:	points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

	IN OUT	LPDWORD  lpcbTotalBytes
	IN:		the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
	OUT:	the number of bytes added by this routine is written to the
            DWORD pointed to by this argument

	IN OUT	LPDWORD  NumObjectTypes
	IN:		the address of the DWORD to receive the number of objects added
            by this routine
	OUT:	the number of objects added by this routine is written to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

	PAFP_STATISTICS_INFO_EX	pAfpStats;
    NTSTATUS			Status;
    ULONG 				SpaceNeeded;
    PDWORD 				pdwCounter;
	LARGE_INTEGER UNALIGNED * pliCounter;
	PERF_COUNTER_BLOCK 		* pPerfCounterBlock;
    SFM_DATA_DEFINITION 	* pSfmDataDefinition;

    // variables used for error logging

    DWORD                               dwQueryType;

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK) {
        // unable to continue because open failed.
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN) {
        // this routine does not service requests for data from
        // Non-NT computers
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
	if ( !(IsNumberInUnicodeList (SfmDataDefinition.SfmObjectType.ObjectNameTitleIndex, lpValueName))) {

            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
    	    *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pSfmDataDefinition = (SFM_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(SFM_DATA_DEFINITION) +
		  SIZE_OF_SFM_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded ) {
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

	//
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove(pSfmDataDefinition,
	   &SfmDataDefinition,
	   sizeof(SFM_DATA_DEFINITION));

    //
    //	Format and collect SFM data from IOCTL
    //
	Status =  AfpAdminStatisticsGetEx( SfmRpcHandle, (LPBYTE *)&pAfpStats);

	if (Status != NO_ERROR)
	{
		AfpAdminDisconnect(SfmRpcHandle);
		SfmRpcHandle = 0;
		bInitOK = FALSE;
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
	}

    //
	// Go to end of SfmDataDefinitionStructure to get to PerfCounterBlock
	//
	pPerfCounterBlock = (PERF_COUNTER_BLOCK *) &pSfmDataDefinition[1];

    pPerfCounterBlock->ByteLength = SIZE_OF_SFM_PERFORMANCE_DATA;

    // Go to end of PerfCounterBlock to get to array of counters
	pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    *pdwCounter++ = pAfpStats->stat_MaxPagedUsage;
    *pdwCounter++ = pAfpStats->stat_CurrPagedUsage;

    *pdwCounter++ = pAfpStats->stat_MaxNonPagedUsage;
    *pdwCounter++ = pAfpStats->stat_CurrNonPagedUsage;

	*pdwCounter++ = pAfpStats->stat_CurrentSessions;
	*pdwCounter++ = pAfpStats->stat_MaxSessions;

	*pdwCounter++ = pAfpStats->stat_CurrentInternalOpens;
	*pdwCounter++ = pAfpStats->stat_MaxInternalOpens;

	*pdwCounter++ = pAfpStats->stat_NumFailedLogins;

	pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
	pliCounter->QuadPart = pAfpStats->stat_DataRead.QuadPart +
						   pAfpStats->stat_DataReadInternal.QuadPart;
	pliCounter++;
	pliCounter->QuadPart = pAfpStats->stat_DataWritten.QuadPart +
						   pAfpStats->stat_DataWrittenInternal.QuadPart;

	pliCounter++;
    *pliCounter++ = pAfpStats->stat_DataIn;
	*pliCounter++ = pAfpStats->stat_DataOut;

	pdwCounter = (PDWORD) pliCounter;
	*pdwCounter++ = pAfpStats->stat_CurrQueueLength;
	*pdwCounter++ = pAfpStats->stat_MaxQueueLength;

	*pdwCounter++ = pAfpStats->stat_CurrThreadCount;
	*pdwCounter++ = pAfpStats->stat_MaxThreadCount;

	*lppData = (PVOID) pdwCounter;

    // update arguments for return

    *lpNumObjectTypes = 1;

    *lpcbTotalBytes = (DWORD)((PBYTE) pdwCounter - (PBYTE) pSfmDataDefinition);

    AfpAdminBufferFree(pAfpStats);

    return ERROR_SUCCESS;
}


DWORD
CloseAfpPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to MacFile device performance counters

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    if (!(--dwOpenCount))
	{
		// when this is the last thread...

		if (SfmRpcHandle != 0)
			AfpAdminDisconnect(SfmRpcHandle);

        pCounterBlock = NULL;

        MonCloseEventLog();
    }

    return ERROR_SUCCESS;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\sfmctrs\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  07/30/92
	Sue Adams	06/07/93
Revision History:

--*/
//
//  include files
//
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "sfmctrs.h"	 // error message definition
#include "perfmsg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = "EventLogLevel";

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\afphelp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    afphelp.h
    SFMMGR include file for help numbers

    FILE HISTORY:
        NarenG    27-Feb-1993   Created

*/


#ifndef _AFPHELP_H_
#define _AFPHELP_H_


#include <uihelp.h>			// For HC_UI_RASMAC_BASE = 25000

#define HC_UI_AFPMGR_BASE 		HC_UI_RASMAC_BASE
#define HC_UI_AFPMGR_LAST 		(HC_UI_RASMAC_BASE+200)



#define HC_FILE_MANAGER_CONTENTS	(HC_UI_RASMAC_BASE + 50)

//
//  Help contexts for the various dialogs.
//

#define HC_NEW_VOLUME_SRVMGR_DIALOG	(HC_UI_RASMAC_BASE + 1)
#define HC_NEW_VOLUME_FILEMGR_DIALOG	(HC_UI_RASMAC_BASE + 2)
#define HC_VOLUME_EDIT_DIALOG		(HC_UI_RASMAC_BASE + 3)
#define HC_VOLUME_PROPERTIES_DIALOG	(HC_UI_RASMAC_BASE + 4)
#define HC_VOLUME_DELETE_DIALOG		(HC_UI_RASMAC_BASE + 5)
#define HC_DIRECTORY_PERMISSIONS_DLG	(HC_UI_RASMAC_BASE + 6)
#define HC_SERVER_PROPERTIES		(HC_UI_RASMAC_BASE + 7)
#define HC_SESSIONS_DIALOG		(HC_UI_RASMAC_BASE + 8)
#define HC_VOLUMES_DIALOG		(HC_UI_RASMAC_BASE + 9)
#define HC_OPENS_DIALOG			(HC_UI_RASMAC_BASE + 10)
#define HC_SERVER_PARAMETERS_DIALOG	(HC_UI_RASMAC_BASE + 11)
#define HC_CHANGE_SERVER_NAME_DLG	(HC_UI_RASMAC_BASE + 12)
#define HC_SELECT_OWNER_GROUP		(HC_UI_RASMAC_BASE + 13)
#define HC_LOCAL_GROUP_DLG		(HC_UI_RASMAC_BASE + 14)
#define HC_GLOBAL_GROUP_DLG		(HC_UI_RASMAC_BASE + 15)
#define HC_FIND_DLG			(HC_UI_RASMAC_BASE + 16)
#define HC_TYPE_CREATOR_ADD		(HC_UI_RASMAC_BASE + 17)
#define HC_TYPE_CREATOR_EDIT		(HC_UI_RASMAC_BASE + 18)
#define HC_SEND_MSG_USER_DIALOG		(HC_UI_RASMAC_BASE + 19)
#define HC_SEND_MSG_SERVER_DIALOG	(HC_UI_RASMAC_BASE + 20)
#define HC_VOLUME_MANAGEMENT_DIALOG	(HC_UI_RASMAC_BASE + 21)
#define HC_FILE_ASSOCIATION_DIALOG	(HC_UI_RASMAC_BASE + 22)
#define HC_CURRENT_USERS_WARNING_DIALOG	(HC_UI_RASMAC_BASE + 23)

//
//  Help context for the various menu items.
//

#define HC_SFMSERVER_CREATE_VOLUME      (HC_UI_RASMAC_BASE + 52)
#define HC_SFMSERVER_EDIT_VOLUMES    	(HC_UI_RASMAC_BASE + 53)
#define HC_SFMSERVER_REMOVE_VOLUME      (HC_UI_RASMAC_BASE + 54)
#define HC_SFMSERVER_PERMISSIONS     	(HC_UI_RASMAC_BASE + 55)
#define HC_SFMSERVER_ASSOCIATE    	(HC_UI_RASMAC_BASE + 56)


#define HC_SFMSERVER_PROPERTIES      	IDM_PROPERTIES	   // The help contexts	
#define HC_SFMSERVER_VOLUMES         	IDM_VOLUME_MGT	   // for the server
#define HC_SFMSERVER_SEND_MESSAGE       IDM_SEND_MESSAGE   // manager menu items
							   // are the same as 
							   // their menu ids.
							   // This is how
							   // server manager 
							   // works.



//
//  Help contexts for the message popups.
//

#define HC_SERVERNAME_CHANGE    	(HC_UI_RASMAC_BASE + 101)
#define HC_DELETE_VOLUME_CONFIRM 	(HC_UI_RASMAC_BASE + 102)
#define HC_MUST_BE_VALID_DIR        	(HC_UI_RASMAC_BASE + 103)
#define HC_DELETE_TC_CONFIRM            (HC_UI_RASMAC_BASE + 104)
#define HC_TYPE_LOCAL_PATH     		(HC_UI_RASMAC_BASE + 105)
#define HC_INVALID_DIR_ACCOUNT     	(HC_UI_RASMAC_BASE + 106)
#define HC_MACFILE_NOT_INSTALLED        (HC_UI_RASMAC_BASE + 107)
#define HC_AFPERR_UnsupportedFS         (HC_UI_RASMAC_BASE + 108)


#endif  // _AFPHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\afpmgr.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    afpmgr.h
    Server Manager include file.

    This file contains the ID constants used by the Server Manager.


    FILE HISTORY:
	NarenG		13-10-92	Stole from Server Manager.
*/


#ifndef _AFPMGR_H_
#define _AFPMGR_H_

#include <uimsg.h>			// For IDS_UI_RASMAC_BASE
#include <uirsrc.h>			// For IDRSRC_RASMAC_BASE

#define IDS_AFPMGR_BASE			IDS_UI_RASMAC_BASE
#define IDS_AFPMGR_LAST 		(IDS_UI_RASMAC_BASE+200)
#define CID_AFPMGR_BASE			IDRSRC_RASMAC_BASE
#define CID_AFPMGR_LAST			(IDRSRC_RASMAC_BASE+800)


#define ERROR_ALREADY_REPORTED		0xFFFFFFFF

//
// string ID's
//

#define IDS_AFPMGR_HELPFILENAME         (IDS_AFPMGR_BASE+1)
#define IDS_AFPMGR_MENU_NAME     	(IDS_AFPMGR_BASE+2)

//
//  Message Pop-up string IDs.
//

#define IDS_CANNOT_FIND_SERVER      	(IDS_AFPMGR_BASE+10)

#define IDS_NOT_NT 			(IDS_AFPMGR_BASE+11)

#define IDS_YES                     	(IDS_AFPMGR_BASE+13)
#define IDS_NO                      	(IDS_AFPMGR_BASE+14)

#define IDS_BUTTON_USERS            	(IDS_AFPMGR_BASE+15)
#define IDS_BUTTON_VOLUMES          	(IDS_AFPMGR_BASE+16)
#define IDS_BUTTON_OPENFILES        	(IDS_AFPMGR_BASE+17)
#define IDS_BUTTON_SERVERPARMS        	(IDS_AFPMGR_BASE+18)

#define IDS_MACFILE_NOT_INSTALLED       (IDS_AFPMGR_BASE+19)

#define IDS_NEED_TEXT_TO_SEND       	(IDS_AFPMGR_BASE+25)

#define IDS_CAPTION_PROPERTIES      	(IDS_AFPMGR_BASE+27)
#define IDS_CAPTION_USERS           	(IDS_AFPMGR_BASE+28)
#define IDS_CAPTION_OPENFILES       	(IDS_AFPMGR_BASE+29)
#define IDS_CAPTION_VOLUMES         	(IDS_AFPMGR_BASE+30)
#define IDS_CAPTION_OWNER         	(IDS_AFPMGR_BASE+31)
#define IDS_CAPTION_GROUP         	(IDS_AFPMGR_BASE+32)
#define IDS_CAPTION_ATTRIBUTES         	(IDS_AFPMGR_BASE+33)
#define IDS_CAPTION_CREATE_VOLUME       (IDS_AFPMGR_BASE+34)
#define IDS_CAPTION_VOLUME_PROPERTIES   (IDS_AFPMGR_BASE+35)
#define IDS_CAPTION_DIRECTORY_PERMS     (IDS_AFPMGR_BASE+36)

#define IDS_FILE_PATH			(IDS_AFPMGR_BASE+37)
#define IDS_VOLUME_PATH			(IDS_AFPMGR_BASE+38)

#define IDS_MULTISEL_NOT_ALLOWED	(IDS_AFPMGR_BASE+39)

#define IDS_AFPMCPA_NAME_STRING     	(IDS_AFPMGR_BASE+40)
#define IDS_AFPMCPA_INFO_STRING     	(IDS_AFPMGR_BASE+41)

#define IDS_SVCCPA_NAME_STRING      	(IDS_AFPMGR_BASE+42)
#define IDS_SVCCPA_INFO_STRING      	(IDS_AFPMGR_BASE+43)

#define IDS_MESSAGE_TOO_LONG      	(IDS_AFPMGR_BASE+44)

#define IDS_FILE_CLOSED			(IDS_AFPMGR_BASE+45)
#define IDS_SESSION_DELETED		(IDS_AFPMGR_BASE+46)
#define IDS_CONNECTION_DELETED		(IDS_AFPMGR_BASE+47)

#define IDS_REDIRECTED_PATH_NOT_ALLOWED (IDS_AFPMGR_BASE+48)
#define IDS_VOLUME_TOO_BIG		(IDS_AFPMGR_BASE+49)

#define IDS_CLOSE_FILE_WRITE	    	(IDS_AFPMGR_BASE+54)
#define IDS_CLOSE_FILE     	    	(IDS_AFPMGR_BASE+55)
#define IDS_CLOSE_FILE_ALL 	    	(IDS_AFPMGR_BASE+56)
#define IDS_CLOSE_FILE_ALL_WRITE    	(IDS_AFPMGR_BASE+57)

#define IDS_OPEN_MODE_READ_WRITE    	(IDS_AFPMGR_BASE+58)
#define IDS_OPEN_MODE_READ          	(IDS_AFPMGR_BASE+59)
#define IDS_OPEN_MODE_WRITE         	(IDS_AFPMGR_BASE+60)
#define IDS_OPEN_MODE_NONE  	   	(IDS_AFPMGR_BASE+61)

#define IDS_LOCAL_SERVER                (IDS_AFPMGR_BASE+62)
#define IDS_START_AFPSERVER_NOW         (IDS_AFPMGR_BASE+63)
#define IDS_STARTING_AFPSERVER_NOW      (IDS_AFPMGR_BASE+64)
#define IDS_GUEST      			(IDS_AFPMGR_BASE+65)
#define IDS_UNKNOWN      		(IDS_AFPMGR_BASE+66)

#define IDS_INVALID_DIR_ACCOUNT		(IDS_AFPMGR_BASE+67)

#define IDS_DISCONNECT_SESS     	(IDS_AFPMGR_BASE+68)
#define IDS_DISCONNECT_SESS_OPEN     	(IDS_AFPMGR_BASE+69)
#define IDS_DISCONNECT_SESS_ALL     	(IDS_AFPMGR_BASE+70)
#define IDS_DISCONNECT_SESS_ALL_OPEN    (IDS_AFPMGR_BASE+71)
#define IDS_DISCONNECT_VOL     		(IDS_AFPMGR_BASE+72)
#define IDS_DISCONNECT_VOL_OPEN     	(IDS_AFPMGR_BASE+73)
#define IDS_DISCONNECT_VOL_ALL     	(IDS_AFPMGR_BASE+74)
#define IDS_DISCONNECT_VOL_ALL_OPEN     (IDS_AFPMGR_BASE+75)


#define IDS_MESSAGE_SENT     		(IDS_AFPMGR_BASE+76)

#define IDS_COULD_NOT_GET_CURRENT_SEL   (IDS_AFPMGR_BASE+77)

#define IDS_VOLUMES_LB_TITLE_TEXT       (IDS_AFPMGR_BASE+78)

#define IDS_VOLUME_CURRENT_USERS_TEXT   (IDS_AFPMGR_BASE+79)

#define IDS_PASSWORD_MISMATCH   	(IDS_AFPMGR_BASE+80)

#define IDS_NOT_RECEIVED   		(IDS_AFPMGR_BASE+81)

#define IDS_NEED_VOLUME_NAME  		(IDS_AFPMGR_BASE+82)

#define IDS_NO_VOLUMES  		(IDS_AFPMGR_BASE+83)

#define IDS_DELETE_VOLUME_CONFIRM	(IDS_AFPMGR_BASE+84)

#define IDS_TYPE_LOCAL_PATH		(IDS_AFPMGR_BASE+85)

#define IDS_NEED_TYPE_CREATOR 		(IDS_AFPMGR_BASE+86)

#define IDS_MUST_BE_VALID_DIR 		(IDS_AFPMGR_BASE+87)

#define IDS_DELETE_TC_CONFIRM 		(IDS_AFPMGR_BASE+88)

#define IDS_FM_HELP_ASSOCIATE		(IDS_AFPMGR_BASE+89)
#define IDS_FM_HELP_CREATE_VOLUME	(IDS_AFPMGR_BASE+90)
#define IDS_FM_HELP_EDIT_VOLUMES	(IDS_AFPMGR_BASE+91)
#define IDS_FM_HELP_DELETE_VOLUMES	(IDS_AFPMGR_BASE+92)
#define IDS_FM_HELP_PERMISSIONS		(IDS_AFPMGR_BASE+93)
#define IDS_FM_HELP_HELP		(IDS_AFPMGR_BASE+94)
#define IDS_NEED_OWNER  		(IDS_AFPMGR_BASE+95)
#define IDS_NEED_PRIMARY_GROUP  	(IDS_AFPMGR_BASE+96)

#define IDS_SERVERNAME_CHANGE		(IDS_AFPMGR_BASE+97)

#define IDS_NEED_SERVER_NAME		(IDS_AFPMGR_BASE+98)
#define IDS_FM_SFM			(IDS_AFPMGR_BASE+99)

//
// Do not change the ID numbers of these strings. AFPERR_*
// map to these string ids via the formula:
// -(AFPERR_*) + IDS_AFPMGR_BASE + AFPERR_BASE + 100 = IDS_*
// 

#define AFPERR_TO_STRINGID( AfpErr )				\
								\
    ((( AfpErr <= AFPERR_BASE ) && ( AfpErr >= AFPERR_MIN )) ?	\
    (IDS_AFPMGR_BASE+100+AFPERR_BASE-AfpErr) : AfpErr )


#define	IDS_AFPERR_InvalidVolumeName		(IDS_AFPMGR_BASE+101)
#define	IDS_AFPERR_InvalidId			(IDS_AFPMGR_BASE+102)
#define	IDS_AFPERR_InvalidParms			(IDS_AFPMGR_BASE+103)
#define IDS_AFPERR_CodePage			(IDS_AFPMGR_BASE+104)
#define	IDS_AFPERR_InvalidServerName		(IDS_AFPMGR_BASE+105)
#define	IDS_AFPERR_DuplicateVolume		(IDS_AFPMGR_BASE+106)
#define	IDS_AFPERR_VolumeBusy			(IDS_AFPMGR_BASE+107)
#define	IDS_AFPERR_VolumeReadOnly		(IDS_AFPMGR_BASE+108)
#define IDS_AFPERR_DirectoryNotInVolume		(IDS_AFPMGR_BASE+109)
#define IDS_AFPERR_SecurityNotSupported		(IDS_AFPMGR_BASE+110)
#define	IDS_AFPERR_BufferSize			(IDS_AFPMGR_BASE+111)
#define IDS_AFPERR_DuplicateExtension		(IDS_AFPMGR_BASE+112)
#define IDS_AFPERR_UnsupportedFS		(IDS_AFPMGR_BASE+113)
#define	IDS_AFPERR_InvalidSessionType		(IDS_AFPMGR_BASE+114)
#define IDS_AFPERR_InvalidServerState		(IDS_AFPMGR_BASE+115)
#define IDS_AFPERR_NestedVolume			(IDS_AFPMGR_BASE+116)
#define IDS_AFPERR_InvalidComputername		(IDS_AFPMGR_BASE+117)
#define IDS_AFPERR_DuplicateTypeCreator		(IDS_AFPMGR_BASE+118)
#define	IDS_AFPERR_TypeCreatorNotExistant 	(IDS_AFPMGR_BASE+119)
#define IDS_AFPERR_CannotDeleteDefaultTC 	(IDS_AFPMGR_BASE+120)
#define	IDS_AFPERR_CannotEditDefaultTC  	(IDS_AFPMGR_BASE+121)
#define	IDS_AFPERR_InvalidTypeCreator		(IDS_AFPMGR_BASE+122)
#define	IDS_AFPERR_InvalidExtension		(IDS_AFPMGR_BASE+123)
#define IDS_AFPERR_TooManyEtcMaps		(IDS_AFPMGR_BASE+124)
#define IDS_AFPERR_InvalidPassword		(IDS_AFPMGR_BASE+125)
#define IDS_AFPERR_VolumeNonExist		(IDS_AFPMGR_BASE+126)
#define IDS_AFPERR_NoSuchUserGroup		(IDS_AFPMGR_BASE+127)
#define IDS_AFPERR_NoSuchUser			(IDS_AFPMGR_BASE+128)
#define IDS_AFPERR_NoSuchGroup			(IDS_AFPMGR_BASE+129)

//
//  For DLGEDIT.EXE's benefit.
//

#ifndef IDHELPBLT
#error "Get IDHELPBLT definition from bltrc.h"

    //
    // The value of IDHELPBLT here is only a placeholder to keep dlgedit.exe 
    // happy. It is redefined to the value in bltrc.h before creating the 
    // resources.
    //

#define IDHELPBLT                       80
#endif  // IDHELPBLT


// 
// Icon that shows up on the control panel
//

#define IDI_AFPMCPA_ICON            	11001

//
//  Button-Bar Bitmap IDs
//

#define IDBM_USERS                  	11002
#define IDBM_FILES                  	11003
#define IDBM_OPENRES                	11004
#define IDBM_SERVERPARMS                11005


//
//  ListBox Bitmap IDs
//

#define IDBM_LB_USER                	11006
#define IDBM_LB_GOOD_VOLUME             11007
#define IDBM_LB_DATA_FORK               11008
#define IDBM_LB_RESOURCE_FORK           11009
#define IDBM_LB_BAD_VOLUME		11010

//
//  Server Properties.
//


#define IDD_SERVER_PROPERTIES       	11020
#define IDSP_ICON                   	11021
#define IDSP_GB_SUMMARY		        11022
#define IDSP_ST_CURRENT_SESSIONS    	11023
#define IDSP_DT_CURRENT_SESSIONS	11024
#define IDSP_ST_CURRENT_OPENFILES	11025
#define IDSP_DT_CURRENT_OPENFILES	11026
#define IDSP_ST_CURRENT_FILELOCKS	11027
#define IDSP_DT_CURRENT_FILELOCKS	11028
#define IDSP_GB_USERS			11029
#define IDSP_GB_VOLUMES			11030
#define IDSP_GB_OPENFILES		11031
#define IDSP_GB_SERVERPARMS		11032

//
//  Specific Sub-Property IDs.
//

// 
//  Share volumes sub-property dialog
//

#define IDD_SHARED_VOLUMES 		11050
#define IDSV_LB_VOLUMELIST		11051	// NOTE: These 4 items
#define IDSV_ST_VOLUMENAME		11052	// must have 
#define IDSV_ST_USES			11053	// consecutive 
#define IDSV_ST_PATH			11054	// ID's
#define IDSV_LB_USERLIST		11055	// NOTE: Thes 4 items 
#define IDSV_ST_CONNUSER		11056	// must have
#define IDSV_ST_TIME			11057	// consecutive 
#define IDSV_ST_INUSE			11058	// ID's
#define IDSV_ST_USERCOUNT		11059
#define IDSV_DT_USERCOUNT		11060
#define IDSV_PB_DISCONNECT		11062
#define IDSV_PB_DISCONNECTALL		11063

//
// Change servername dialog
//

#define IDD_CHANGE_SERVERNAME_DIALOG	11075
#define IDCS_SLE_SERVER_NAME		11076

// 
// Open files sub-property dialog
//

#define IDD_OPENFILES			11100
#define IDOF_ST_OPENCOUNT		11101
#define IDOF_DT_OPENCOUNT 		11102
#define IDOF_ST_LOCKCOUNT		11103
#define IDOF_DT_LOCKCOUNT		11104
#define IDOF_LB_OPENLIST		11105	// NOTE: These 4 items
#define IDOF_ST_OPENEDBY		11106	// must have
#define IDOF_ST_OPENMODE		11107	// consecutive
#define IDOF_ST_LOCKS			11108	// consecutive
#define IDOF_ST_PATH			11109	// ID's
#define IDOF_PB_REFRESH			11110
#define IDOF_PB_CLOSEFILE		11111
#define IDOF_PB_CLOSEALLFILES		11112

//
// User connection sub-property
//

#define IDD_USER_CONNECTIONS		11150
#define IDUC_LB_USER_CONNLIST		11151	// NOTE: These 5 items
#define IDUC_ST_CONNUSERS		11152	// must 
#define IDUC_ST_COMPUTER		11153	// have 
#define IDUC_ST_OPENS			11154	// consecutive
#define IDUC_ST_ELAPSED_TIME		11155	// ID's
#define IDUC_ST_USERS_CONNECTED		11156
#define IDUC_DT_USERS_CONNECTED		11157
#define IDUC_LB_VOLUMES			11158	// NOTE: These 4 items
#define IDUC_ST_VOLUME			11159	// must have 
#define IDUC_ST_FILEOPENS		11160	// consecutive
#define IDUC_ST_TIME			11161	// ID's
#define IDUC_PB_DISCONNECT		11162
#define IDUC_PB_DISCONNECT_ALL		11163
#define IDUC_PB_SEND_MESSAGE		11164

//
// AFP Service start progress icons
//

#define IDI_PROGRESS_ICON_0     	11200
#define IDI_PROGRESS_ICON_1     	11201
#define IDI_PROGRESS_ICON_2     	11202
#define IDI_PROGRESS_ICON_3     	11203
#define IDI_PROGRESS_ICON_4     	11204
#define IDI_PROGRESS_ICON_5     	11205
#define IDI_PROGRESS_ICON_6     	11206
#define IDI_PROGRESS_ICON_7     	11207
#define IDI_PROGRESS_ICON_8     	11208
#define IDI_PROGRESS_ICON_9     	11209
#define IDI_PROGRESS_ICON_10    	11210
#define IDI_PROGRESS_ICON_11    	11211
#define IDI_PROGRESS_NUM_ICONS 		12

//
//	Start AFP service dialog
//

#define IDD_SERVICE_CTRL_DIALOG 	11250
#define IDSC_PROGRESS			11251
#define IDSC_ST_MESSAGE			11252

//
//  Send Message dialog (from connected users dialog).
//

#define IDD_SEND_MSG_USER_DIALOG 	11300
#define IDSM_GB_RECEPIENTS		11301
#define IDSM_RB_SINGLE_USER		11302
#define IDSM_RB_ALL_USERS		11303
#define IDSM_DT_SERVER_NAME		11304
#define IDSM_DT_USER_NAME		11305
#define IDSM_ST_MESSAGE			11306
#define IDSM_ET_MESSAGE			11307

//
//  Current users warning dialog
//

#define IDD_CURRENT_USERS_WARNING_DLG   11350
#define IDCU_SLT_VOL_TEXT 		11351
#define IDCU_LB_CURRENT_USERS		11352	// NOTE: These 3 items must
#define IDCU_ST_USERNAME		11353	// have
#define IDCU_ST_FILEOPENS		11354	// consecutive 
#define IDCU_ST_TIME			11355	// IDs

//
//  Volume management dialog
//

#define IDD_VOLUME_MANAGEMENT_DLG 	11400
#define IDVM_PB_DELETE_VOL 		11401
#define IDVM_PB_VOL_INFO 		11402
#define IDVM_PB_ADD_VOLUME		11403
#define IDVM_SLT_VOLUME_TITLE		11404
#define IDVM_LB_VOLUMES			11405	// NOTE: These 3 items must
#define IDVM_ST_NAME			11406	// have
#define IDVM_ST_PATH			11407	// consecutive IDs.

//
// New volume dialog
//

#define IDD_NEW_VOLUME_DIALOG		11450
#define IDNV_SLE_NAME 			11451
#define IDNV_SLE_PATH 			11452
#define IDNV_SLE_PASSWORD 		11453
#define IDNV_SLE_CONFIRM_PASSWORD 	11454
#define IDNV_CHK_READONLY 		11455
#define IDNV_CHK_GUEST_ACCESS 		11456
#define IDNV_RB_UNLIMITED		11457
#define IDNV_RB_USERS			11458
#define IDNV_SLE_USERS			11459
#define IDNV_SB_USERS_GROUP 		11460
#define IDNV_SB_USERS_UP 		11461
#define IDNV_SB_USERS_DOWN		11462
#define IDNV_PB_PERMISSIONS 		11463
#define IDNV_SLE_USERS_GROUP            11464

//
// Server Parameters dialog
//

#define IDD_SERVER_PARAMETERS_DIALOG 	11475
#define IDSP_SLT_SERVERNAME		11476
#define IDSP_PB_CHANGE			11477
#define IDSP_MLE_LOGINMSG		11478
#define IDSP_CHK_CLEARTEXT		11479
#define IDSP_CHK_PASSWORD_SAVES		11480
#define IDSP_CHK_GUESTLOGONS		11481
#define IDSP_RB_UNLIMITED		11482
#define IDSP_RB_SESSIONS		11483
#define IDSP_SLE_SESSIONS		11484
#define IDSP_SB_SESSIONS_GROUP		11485
#define IDSP_SB_SESSIONS_UP		11486
#define IDSP_SB_SESSIONS_DOWN		11487
#define IDSP_SLE_SESSIONS_GROUP         11488

//
// Volume properties dialog
//

#define IDD_VOLUME_PROPERTIES_DIALOG	11500
#define IDVP_SLT_NAME 			11501
#define IDVP_SLT_PATH 			11502
#define IDVP_SLE_PASSWORD 		11503
#define IDVP_SLE_CONFIRM_PASSWORD 	11504
#define IDVP_CHK_READONLY 		11505
#define IDVP_CHK_GUEST_ACCESS 		11506
#define IDVP_RB_UNLIMITED		11507
#define IDVP_RB_USERS			11508
#define IDVP_SLE_USERS			11509
#define IDVP_SB_USERS_GROUP 		11510
#define IDVP_SB_USERS_UP 		11511
#define IDVP_SB_USERS_DOWN		11512
#define IDVP_PB_PERMISSIONS 		11513
#define IDVP_SLE_USERS_GROUP		11514

//
// Directory permissions dialog
//

#define	IDD_DIRECTORY_PERMISSIONS_DLG	11525
#define IDDP_CHK_OWNER_FILE		11526
#define IDDP_CHK_OWNER_FOLDER		11527
#define IDDP_CHK_OWNER_CHANGES		11528
#define IDDP_CHK_GROUP_FILE		11529
#define IDDP_CHK_GROUP_FOLDER		11530
#define IDDP_CHK_GROUP_CHANGES		11531
#define IDDP_CHK_WORLD_FILE		11532
#define IDDP_CHK_WORLD_FOLDER		11533
#define IDDP_CHK_WORLD_CHANGES		11534
#define IDDP_SLE_OWNER			11535
#define IDDP_SLE_PRIMARYGROUP		11536
#define IDDP_CHK_READONLY		11537
#define IDDP_CHK_RECURSE		11538
#define IDDP_SLT_PATH			11539
#define IDDP_PB_OWNER			11540
#define IDDP_PB_GROUP			11541

//
// Volume delete dialog
//

#define IDD_VOLUME_DELETE_DLG		11550
#define IDDV_SLT_VOLUME_TITLE		11551
#define	IDDV_LB_VOLUMES			11552	// NOTE: These 3 items must
#define IDDV_ST_NAME			11553	// have
#define IDDV_ST_PATH			11554	// consecutive IDs.

//
// Volume edit dialog
//

#define	IDD_VOLUME_EDIT_DLG		11600
#define	IDEV_SLT_VOLUME_TITLE		11601
#define IDEV_PB_VOL_INFO 		11602
#define IDEV_LB_VOLUMES			11603	// NOTE: These 3 items must
#define IDEV_ST_NAME			11604	// have
#define IDEV_ST_PATH			11605	// consecutive IDs.


//
//  Send Message dialog (from top level of server manager).
//

#define IDD_SEND_MSG_SERVER_DIALOG 	11625
#define IDSD_DT_SERVER_NAME		11626
#define IDSD_ET_MESSAGE			11627

//
// File type/creator add dialog
//

#define IDD_TYPE_CREATOR_ADD_DIALOG  	11650
#define IDTA_SLE_DESCRIPTION 		11651
#define IDTA_CB_CREATOR 		11652
#define IDTA_CB_TYPE 			11653

//
// File type/creator edit dialog
//

#define IDD_TYPE_CREATOR_EDIT_DIALOG  	11675
#define IDTE_SLE_DESCRIPTION		11676
#define IDTE_SLE_CREATOR		11677
#define IDTE_SLE_TYPE			11678

//
// File association dialog
//

#define IDD_FILE_ASSOCIATION_DIALOG 	11700
#define IDFA_CB_EXTENSIONS		11701
#define IDFA_PB_ADD			11702
#define IDFA_PB_EDIT			11703
#define IDFA_PB_DELETE			11704
#define IDFA_PB_ASSOCIATE		11705
#define IDFA_LB_TYPE_CREATORS		11706	// NOTE: These 4 items must 
#define IDFA_ST_CREATOR			11707 	// have
#define IDFA_ST_TYPE			11708	// consecutive 
#define IDFA_ST_COMMENT			11709	// IDs.

//
//  Server Manager extension menu
//  The IDM_* should be between 1-99
//

#define ID_SRVMGR_MENU 			11725
#define IDM_SEND_MESSAGE		10
#define IDM_PROPERTIES			11
#define IDM_VOLUME_MGT			12

//
//  File Manager extension menu
//  The IDM_* should be between 1-99
//

#define ID_FILEMGR_MENU			11730
#define IDM_FILE_ASSOCIATE		10
#define IDM_VOLUME_CREATE		11
#define IDM_VOLUME_EDIT			12
#define IDM_VOLUME_DELETE		13
#define IDM_DIRECTORY_PERMISSIONS	14
#define IDM_AFPMGR_HELP			15

//
// File manager button bar bitmap
//

#define IDBM_AFP_TOOLBAR		11735

//
// help context
//

#include "afphelp.h"


#endif  // _AFPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\assoc.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		Copyright(c) Microsoft Corp., 1991  		     **/
/**********************************************************************/

/*
   assoc.cxx
     This file contains the definitions of

	FILE_ASSOCIATION_DIALOG,

     		TYPE_CREATOR_LISTBOX,
			TYPE_CREATOR_LBI,

		EXTENSIONS_COMBOBOX,
			EXTENSIONS_LBI

   History:
     NarenG		12/4/92		Created
*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>

extern "C"
{
#include <afpmgr.h>
#include <search.h>
#include <macfile.h>

//
// Compare routine needed for qsort
//

int __cdecl CompareExtensions(
	IN const void * pAfpExtension1,
	IN const void * pAfpExtension2
	);
}

#include <ellipsis.hxx>
#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <netname.hxx>

#include "assoc.hxx"

/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: FILE_ASSOCIATION_DIALOG

    SYNOPSIS:   FILE_ASSOCIATION_DIALOG class constructor.

    ENTRY:      hWndOwner               - The owning window.

    		hServer                 - Handle used to make admin
					  API calls.

    		pszExtension            - File extension of current selection.

    EXIT:       The object is constructed.

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/
FILE_ASSOCIATION_DIALOG :: FILE_ASSOCIATION_DIALOG(
				  HWND             	hWndOwner,
                                  AFP_SERVER_HANDLE 	hServer,
			          const TCHAR *		pszPath,
				  BOOL			fIsFile )
  : DIALOG_WINDOW ( MAKEINTRESOURCE( IDD_FILE_ASSOCIATION_DIALOG ), hWndOwner ),
    _hServer( hServer ),
    _cbExtensions( this, IDFA_CB_EXTENSIONS, AFP_EXTENSION_LEN ),
    _lbTypeCreators( this, IDFA_LB_TYPE_CREATORS, hServer ),
    _pbAssociate( this, IDFA_PB_ASSOCIATE ),
    _pbAdd( this, IDFA_PB_ADD ),
    _pbEdit( this, IDFA_PB_EDIT	),
    _pbDelete( this, IDFA_PB_DELETE )

{
    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;
    if ( (( err = _cbExtensions.QueryError() )	  != NERR_Success ) ||
    	 (( err = _lbTypeCreators.QueryError() )  != NERR_Success ) ||
    	 (( err = _pbAssociate.QueryError() )	  != NERR_Success ) ||
    	 (( err = _pbAdd.QueryError() )	          != NERR_Success ) ||
    	 (( err = _pbEdit.QueryError() )	  != NERR_Success ) ||
    	 (( err = _pbDelete.QueryError() )	  != NERR_Success ))
    {
	ReportError( err );
	return;
    }

    //
    // This may take a while
    //

    AUTO_CURSOR Cursor;

    //
    // If a path is supplied and the selection is a file, then extract
    // the extension and set the SLE.
    //

    if ( pszPath != NULL && fIsFile )
    {
	//
	// Extract the extension from the file
	//

	NLS_STR nlsExtension( pszPath );

	if ( (err = nlsExtension.QueryError() ) != NERR_Success )
	{
	    ReportError( err );
	    return;
	}

  	ISTR istrExtension( nlsExtension );

	if ( nlsExtension.strrchr( &istrExtension, TEXT('.') ))
	{
	    const TCHAR * pszExtension =
		     (nlsExtension.QuerySubStr(++istrExtension))->QueryPch();

	    _cbExtensions.SetText( pszExtension );

	}
    }

    err = BASE_ELLIPSIS::Init();

    if( err != NO_ERROR )
    {
        ReportError( err );
	return;
    }

    //
    //  Refresh the dialog and select the type/creator that the current
    //  extension, if there is one, is associated with.
    //

    err = RefreshAndSelectTC();

    if( err != NO_ERROR )
    {
        ReportError( AFPERR_TO_STRINGID( err ));
	return;
    }

    _cbExtensions.SelectString();

} // FILE_ASSOCIATION_DIALOG :: FILE_ASSOCIATION_DIALOG


/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: ~FILE_ASSOCIATION_DIALOG

    SYNOPSIS:   FILE_ASSOCIATION_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/

FILE_ASSOCIATION_DIALOG :: ~FILE_ASSOCIATION_DIALOG()
{
    BASE_ELLIPSIS::Term();
}


/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/
ULONG FILE_ASSOCIATION_DIALOG :: QueryHelpContext( void )
{
    return HC_FILE_ASSOCIATION_DIALOG;

}   // FILE_ASSOCIATION_DIALOG:: QueryHelpContext

/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: EnableControls

    SYNOPSIS:   This function handles the enabling/disabling of
		the edit and delete buttons.

    RETURNS:    none

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/
VOID FILE_ASSOCIATION_DIALOG :: EnableControls( BOOL fEnable )
{

    if ( fEnable )
    {
    	_pbDelete.Enable( TRUE );
    	_pbEdit.Enable( TRUE );
    	_pbEdit.MakeDefault();
    }
    else
    {
	if ( _pbEdit.HasFocus() || _pbDelete.HasFocus() )
	{
	    _lbTypeCreators.ClaimFocus();
	}

    	_pbDelete.Enable( FALSE );
    	_pbEdit.Enable( FALSE );
	
    }

} // FILE_ASSOCIATION_DIALOG :: EnableControls

/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: SelectTypeCreator

    SYNOPSIS:   This function will call the SelectTypeCreator member
		function of the TYPE_CREATOR_LISTBIX class and
		enable/disable the delete and edit buttons appropriately.

    RETURNS:    none

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/
VOID FILE_ASSOCIATION_DIALOG :: SelectTypeCreator( NLS_STR * pnlsType,
						   NLS_STR * pnlsCreator )
{
    DWORD dwIdSelected = _lbTypeCreators.SelectTypeCreator( pnlsType,
							    pnlsCreator );


    if ( ( dwIdSelected != AFP_DEF_TCID ) && ( dwIdSelected != (DWORD)-1 ) )
    {
	EnableControls( TRUE );
    }
    else
    {
	EnableControls( FALSE );
	
    }
		

}   // FILE_ASSOCIATION_DIALOG :: SelectTypeCreator

/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: SelectTypeCreator

    SYNOPSIS:   This function will call the SelectTypeCreator member
		function of the TYPE_CREATOR_LISTBIX class and
		enable/disable the delete and edit buttons appropriately.

    RETURNS:    none

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/
VOID FILE_ASSOCIATION_DIALOG :: SelectTypeCreator( DWORD dwId )
{
    DWORD dwIdSelected = _lbTypeCreators.SelectTypeCreator( dwId );

    if ( ( dwIdSelected != AFP_DEF_TCID ) && ( dwIdSelected != (DWORD)-1 ) )
    {
	EnableControls( TRUE );
    }
    else
    {
	EnableControls( FALSE );

    }
		

}   // FILE_ASSOCIATION_DIALOG :: SelectTypeCreator

/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: OnCommand

    SYNOPSIS:   This method is called whenever a WM_COMMAND message
                is sent to the dialog procedure.

    ENTRY:      cid                     - The control ID from the
                                          generating control.

    EXIT:       The command has been handled.

    RETURNS:    BOOL                    - TRUE  if we handled the command.
                                          FALSE if we did not handle
                                          the command.

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/
BOOL FILE_ASSOCIATION_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{

    if( event.QueryCid() == _cbExtensions.QueryCid() )
    {
        //
        //  The COMBOBOX is trying to tell us something...
        //

        if( event.QueryCode() == CBN_SELCHANGE )
        {
            //
            //  The user changed the selection in the COMBOBOX.
	    //  So set focus on type/creator associated with this extension
	    //

	    SelectTypeCreator( _cbExtensions.QueryCurrentItemId() );

    	    _pbAssociate.Enable( TRUE );
        }

        if( event.QueryCode() == CBN_EDITCHANGE )
        {
	
	    APIERR  err;
	    NLS_STR nlsItemText;

	    if ( (( err = nlsItemText.QueryError() ) != NERR_Success ) ||
	         (( err = _cbExtensions.QueryText( &nlsItemText ))
							     != NERR_Success))
	    {
	    	::MsgPopup( this, err );

	    	return FALSE;
	    }

	    if ((nlsItemText.QueryPch() == NULL) || (nlsItemText.strlen() == 0))
	    {
    	    	_pbAssociate.Enable( FALSE );
	    }
	    else
	    {
    	    	_pbAssociate.Enable( TRUE );
	    }

	    //
	    // The user typed in something in the SLE. Find out if we have
	    // a match in the combobox.
	    //

	    INT Index  = _cbExtensions.FindItemExact( nlsItemText );

	    DWORD dwId;

	    if ( Index < 0 )
	    {
		dwId = AFP_DEF_TCID;
	    }
	    else
	    {
	    	_cbExtensions.SetTopIndex( Index );

		dwId = _cbExtensions.QueryItemId( Index );
	    }

	    SelectTypeCreator( dwId );

	}

        return TRUE;
    }

    if( event.QueryCid() == _lbTypeCreators.QueryCid() )
    {
        if( event.QueryCode() == LBN_SELCHANGE )
	{
	    if ( _lbTypeCreators.QueryItem()->QueryId() == AFP_DEF_TCID )
	    {
		EnableControls( FALSE );
	    }
	    else
            {
		EnableControls( TRUE );
	    }
	}
    }

    if( event.QueryCid() == _pbAssociate.QueryCid() )
    {
        //
        // This may take a while
        //

        AUTO_CURSOR Cursor;

        //
        //  The user pressed the Associate button. So associate the currently
	//  selected Extension with the currently selected type/creator.
        //

	AFP_TYPE_CREATOR AfpTypeCreator;
	AFP_EXTENSION 	 AfpExtension;
	DWORD 		 err;
	NLS_STR 	 nlsItemText;

	if ( (( err = nlsItemText.QueryError() ) != NERR_Success ) ||
	     (( err = _cbExtensions.QueryText(&nlsItemText) ) != NERR_Success))
	{
	    ::MsgPopup( this, err );
	    return FALSE;

	}

	::wcscpy( AfpExtension.afpe_extension, nlsItemText.QueryPch() );

	TYPE_CREATOR_LBI * ptclbi = _lbTypeCreators.QueryItem();

	::wcscpy( AfpTypeCreator.afptc_creator, ptclbi->QueryCreator() );
	::wcscpy( AfpTypeCreator.afptc_type, ptclbi->QueryType() );

	err = ::AfpAdminETCMapAssociate( _hServer,
					 &AfpTypeCreator,	
					 &AfpExtension );

	if ( err != NO_ERROR )
	{
	    ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
	}

        //
        // Refresh the dialog
        //

	err = RefreshAndSelectTC();

	if ( err != NO_ERROR )
	{
	    ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	    return FALSE;
	}

	return TRUE;

    }

    if( event.QueryCid() == _pbAdd.QueryCid() )
    {
        //
        //  The user pressed the Add button.  Bring up dialog to allow user
	//  to add a type/creator pair
        //

	return TypeCreatorAddDialog();
    }


    if( event.QueryCid() == _pbEdit.QueryCid() )
    {
        //
        //  The user pressed the Edit button.  Bring up dialog to allow user
	//  to edit a type/creator pair.
        //

	return TypeCreatorEditDialog();
    }

    if ( event.QueryCid() == _lbTypeCreators.QueryCid() )
    {
    	if ((event.QueryCode() == LBN_DBLCLK) &&
	    (_lbTypeCreators.QuerySelCount()>0))
        {
            //
            //  The user double-clicked on a type/creator.  Bring up dialog to
	    //  allow user  to edit a type/creator pair.
            //

	    return TypeCreatorEditDialog();
   	}
    }


    if( event.QueryCid() == _pbDelete.QueryCid() )
    {
        //
        // This may take a while
        //

        AUTO_CURSOR Cursor;

        //
        //  The user pressed the Delete button.  Delete the currently
	//  selected type/creator pair
        //

    	//
    	// First warn the user.
    	//

    	if ( ::MsgPopup( this,
                       	 IDS_DELETE_TC_CONFIRM,
                       	 MPSEV_WARNING,
                       	 MP_YESNO,
                       	 MP_YES ) == IDNO )
    	{
            return FALSE;
        }

	AFP_TYPE_CREATOR AfpTypeCreator;

	TYPE_CREATOR_LBI * ptclbi = _lbTypeCreators.QueryItem();

	ZeroMemory( &AfpTypeCreator, sizeof( AfpTypeCreator ) );
	::wcscpy( AfpTypeCreator.afptc_creator, ptclbi->QueryCreator() );
	::wcscpy( AfpTypeCreator.afptc_type, ptclbi->QueryType() );

	DWORD err = ::AfpAdminETCMapDelete( _hServer, &AfpTypeCreator );

	if ( err != NO_ERROR )
	{
	    ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
	}

        //
        // Refresh the dialog.
        //

        err = Refresh();

	if ( err != NO_ERROR )
	{
	    ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	    return FALSE;
	}

	return TRUE;

    }

    return DIALOG_WINDOW::OnCommand( event );
}

/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: TypeCreatorAddDialog

    SYNOPSIS:   Bring up the dialog to add a type/creator

    EXIT:

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

*******************************************************************/

BOOL FILE_ASSOCIATION_DIALOG :: TypeCreatorAddDialog( VOID )
{

    NLS_STR nlsType;
    NLS_STR nlsCreator;
    DWORD   err;
    BOOL    fOK = FALSE;

    if (  ( ( err = nlsType.QueryError() ) != NERR_Success ) ||
          ( ( err = nlsCreator.QueryError() ) != NERR_Success ) )
    { 	
	::MsgPopup( this, err );
	return FALSE;
    }

	
    TYPE_CREATOR_ADD * ptcadlg = new TYPE_CREATOR_ADD( QueryHwnd(),
						       _hServer,
						       &_lbTypeCreators,
						       &nlsType,
						       &nlsCreator );

    err = ( ptcadlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                              : ptcadlg->Process( &fOK );

    if ( ptcadlg != NULL )
    {
        delete ptcadlg;
    }


    if( err != NERR_Success )
    {
    	MsgPopup( this, AFPERR_TO_STRINGID( err ));
	return FALSE;
    }

    //
    // Refresh the dialog
    //

    err = Refresh();

    if ( err != NO_ERROR )
    {
	::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	return FALSE;
    }

    if ( fOK )
    {
    	SelectTypeCreator( &nlsType, &nlsCreator );
    }

    return TRUE;
}

/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: TypeCreatorEditDialog

    SYNOPSIS:   Bring up the dialog to add a type/creator

    EXIT:

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

*******************************************************************/

BOOL FILE_ASSOCIATION_DIALOG :: TypeCreatorEditDialog( VOID )
{

    TYPE_CREATOR_LBI * ptclbi = _lbTypeCreators.QueryItem();

    //
    // Do not allow editing of the default type/creator
    //

    if ( ptclbi->QueryId() == AFP_DEF_TCID )
    {
	return FALSE;
    }

    TYPE_CREATOR_EDIT * ptcedlg = new TYPE_CREATOR_EDIT( QueryHwnd(),
							 _hServer,
							  ptclbi );

    DWORD err = ( ptcedlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                    : ptcedlg->Process();


    if( err != NERR_Success )
    {
    	MsgPopup( this, AFPERR_TO_STRINGID( err ));
    }

    if ( ptcedlg != NULL )
    {
        delete ptcedlg;
    }

    //
    // Refresh the dialog.
    //

    err = Refresh();

    if ( err != NO_ERROR )
    {
	::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	return FALSE;
    }

    return TRUE;
}

/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: Refresh

    SYNOPSIS:   Refresh the dialog.

    EXIT:

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

DWORD FILE_ASSOCIATION_DIALOG :: Refresh( VOID )
{

    //
    // Find out the type creator that has the current focus.
    //

    TYPE_CREATOR_LBI * ptclbi = _lbTypeCreators.QueryItem();

    DWORD dwId = ( ptclbi == NULL ) ? AFP_DEF_TCID : ptclbi->QueryId();

    //
    // Find out the extension that has the current focus
    //

    APIERR err;
    NLS_STR nlsCurrentExtension;

    if ( (( err = nlsCurrentExtension.QueryError() ) != NERR_Success ) ||
         (( err = _cbExtensions.QueryText( &nlsCurrentExtension ))
							   != NERR_Success))
    {
	return err;
    }

    if ( ( err = Update() ) != NO_ERROR )
    {
	return err;
    }

    SelectTypeCreator( dwId );

    //
    // Set the extension to what it was before
    //

    if ((nlsCurrentExtension.QueryPch() == NULL) ||
	(nlsCurrentExtension.strlen() == 0))
    {
    	_pbAssociate.Enable( FALSE );
    }
    else
    {
    	_cbExtensions.SetText( nlsCurrentExtension );
    	_pbAssociate.Enable( TRUE );
    }

    return NO_ERROR;
}

/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: RefreshAndSelectTC

    SYNOPSIS:   Refresh the dialog and then select the Type/Creator
		item that the current extension is associated with..

    EXIT:

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

DWORD FILE_ASSOCIATION_DIALOG :: RefreshAndSelectTC( VOID )
{

    APIERR err;

    if ( ( err = Refresh() ) != NO_ERROR )
    {
	return err;
    }

    //
    // Get the Type/creator id that the current extension is associated
    // with
    //

    NLS_STR nlsCurrentExtension;

    if ( (( err = nlsCurrentExtension.QueryError() ) != NERR_Success ) ||
         (( err = _cbExtensions.QueryText( &nlsCurrentExtension ))
							    != NERR_Success))
    {
	return err;
    }

    INT Index = _cbExtensions.FindItemExact( nlsCurrentExtension );

    DWORD dwId = ( Index < 0 ) ? AFP_DEF_TCID
			       : _cbExtensions.QueryItemId( Index );

    SelectTypeCreator( dwId );

    return NO_ERROR;
}

/*******************************************************************

    NAME:       FILE_ASSOCIATION_DIALOG :: Update

    SYNOPSIS:   Updates the dialog with new date.

    EXIT:

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

DWORD FILE_ASSOCIATION_DIALOG :: Update( VOID )
{

    APIERR  	     err;
    PAFP_ETCMAP_INFO pAfpEtcMapInfo = NULL;

    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    // This is not a loop
    //

    do {

    	//
    	// Get the new data
    	//

    	err = ::AfpAdminETCMapGetInfo( _hServer, (LPBYTE *)&pAfpEtcMapInfo );

    	if ( err != NO_ERROR )
    	{
	    break;
	}

    	//
    	// Update the extensions COMBOBOX.
    	//

    	err = _cbExtensions.Update( pAfpEtcMapInfo->afpetc_num_extensions,
			            pAfpEtcMapInfo->afpetc_extension );

    	if ( err != NO_ERROR )
    	{
	    break;
    	}

    	//
    	//  Update the type/creator listbox
    	//

    	err = _lbTypeCreators.Update( pAfpEtcMapInfo->afpetc_num_type_creators,
    			              pAfpEtcMapInfo->afpetc_type_creator );

	if ( err != NO_ERROR )
	{
	    break;
        }

	EnableControls( _lbTypeCreators.QueryCount() > 0 );

    } while( FALSE );

    if ( pAfpEtcMapInfo != NULL )
    {
    	::AfpAdminBufferFree( pAfpEtcMapInfo );
    }

    if ( err != NO_ERROR )
    {
        //
        //  There was an error refreshing the dialog
        //  so nuke everything in the TypeCreator & extension listboxes
        //  then disable the associate, edit and delete buttons.
        //

        _lbTypeCreators.DeleteAllItems();
        _cbExtensions.DeleteAllItems();

	EnableControls( FALSE );

    }

    return err;

}   // FILE_ASSOCIATION_DIALOG :: Update

//
//  EXTENSION_COMBOBOX methods.
//

/*******************************************************************

    NAME:       EXTENSION_COMBOBOX :: EXTENSION_COMBOBOX

    SYNOPSIS:   EXTENSION_COMBOBOX class constructor.

    ENTRY:      powOwner                - The owning window.

                cid                     - The listbox CID.

		sleSize			- Max. number of sle chars.

    EXIT:       The object is constructed.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

EXTENSION_COMBOBOX :: EXTENSION_COMBOBOX( OWNER_WINDOW   *  powOwner,
                                    	  CID               cid,
                                    	  INT		    sleSize )
  : COMBOBOX( powOwner, cid, sleSize ),
    _pExtensions( NULL )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }
}

/*******************************************************************

    NAME:       EXTENSION_COMBOBOX :: ~EXTENSION_COMBOBOX

    SYNOPSIS:   EXTENSION_COMBOBOX class destructor.

    ENTRY:

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

EXTENSION_COMBOBOX :: ~EXTENSION_COMBOBOX()
{
    //
    // Delete cache of sorted extensions
    //

    if ( _pExtensions != NULL )
    {
	delete [] _pExtensions;
    }
    _pExtensions = NULL;

}   // FEXTENSION_COMBOBOX :: ~EXTENSION_COMBOBOX

/*******************************************************************

    NAME:       EXTENSION_COMBOBOX :: Update

    SYNOPSIS:   Updates the combobox.

    EXIT:       The combobox is updated.

    RETURNS:    DWORD                  - Any errors we encounter.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

DWORD EXTENSION_COMBOBOX :: Update( DWORD 	    nExtensions,
				    PAFP_EXTENSION pAfpExtensions )
{

    if ( _pExtensions != NULL )
    {
	delete [] _pExtensions;
    }

    //
    //  Store and sort the extensions list.
    //

    _pExtensions = new AFP_EXTENSION[nExtensions];

    if ( _pExtensions == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY;
    }


    ::CopyMemory( _pExtensions,
		  pAfpExtensions,
		  (UINT)(nExtensions * sizeof(AFP_EXTENSION)));

    ::qsort( _pExtensions,
	     (UINT)nExtensions,
	     sizeof(AFP_EXTENSION),
	     ::CompareExtensions );

    //
    // OK, now update the combobox
    //

    SetRedraw( FALSE );
    DeleteAllItems();

    //
    //  For iterating the associated extensions.
    //

    PAFP_EXTENSION pExtensionIter = _pExtensions;

    //
    //  Iterate the extensions, adding them to the combobox.
    //

    DWORD err = NO_ERROR;

    while( ( err == NO_ERROR ) && ( nExtensions-- ) )
    {

	if ( AddItem( pExtensionIter->afpe_extension ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
	    break;
        }

	pExtensionIter++;
    }

    SetRedraw( TRUE );

    Invalidate( TRUE );

    return err;

}

/*******************************************************************

    NAME:       EXTENSION_COMBOBOX :: QueryCurrentItemId

    SYNOPSIS:   Will return the Type/Creator id the currently
	  	selected extension item is associated with.

    ENTRY:      none

    EXIT:

    RETURNS:	Type/Creator id

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

DWORD EXTENSION_COMBOBOX :: QueryCurrentItemId( VOID ) const
{

    return QueryItemId( QueryCurrentItem() );
}


/*******************************************************************

    NAME:       EXTENSION_COMBOBOX :: QueryItemId

    SYNOPSIS:   Given and index into the extensions list, this will return
		the Type/Creator id associated with the indexed extension.

    ENTRY:      Index 	- Index of the extension in the combobox

    EXIT:

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

DWORD EXTENSION_COMBOBOX :: QueryItemId( INT Index ) const
{
    if( ( Index < 0 ) || ( Index > QueryCount() ) )
    {
	return AFP_DEF_TCID;
    }
    else
    {
	return _pExtensions[Index].afpe_tcid;
    }
}

//
//  TYPE_CREATOR_LISTBOX methods.
//

/*******************************************************************

    NAME:       TYPE_CREATOR_LISTBOX :: TYPE_CREATOR_LISTBOX

    SYNOPSIS:   TYPE_CREATOR_LISTBOX class constructor.

    ENTRY:      powOwner                - The owning window.

                cid                     - The listbox CID.

                hServer                 - The target server.

    EXIT:       The object is constructed.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

TYPE_CREATOR_LISTBOX :: TYPE_CREATOR_LISTBOX( OWNER_WINDOW   *  powOwner,
                                    	      CID               cid,
                                    	      AFP_SERVER_HANDLE hServer )
  : BLT_LISTBOX( powOwner, cid ),
    _hServer( hServer )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
				     COLS_FA_LB_TYPE_CREATORS,
				     powOwner,
				     cid,
				     FALSE );

} // TYPE_CREATOR_LISTBOX :: TYPE_CREATOR_LISTBOX


/*******************************************************************

    NAME:       TYPE_CREATOR_LISTBOX :: ~TYPE_CREATOR_LISTBOX

    SYNOPSIS:   TYPE_CREATOR_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/
TYPE_CREATOR_LISTBOX :: ~TYPE_CREATOR_LISTBOX()
{
    //
    //  This space intentionally left blank.
    //

}   // TYPE_CREATOR_LISTBOX :: ~TYPE_CREATOR_LISTBOX

/*******************************************************************

    NAME:       TYPE_CREATOR_LISTBOX :: Update

    SYNOPSIS:   Fills the listbox.

    EXIT:

    RETURNS:    DWORD                  - Any errors we encounter.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

DWORD TYPE_CREATOR_LISTBOX :: Update( DWORD 	        nTypeCreators,
				      PAFP_TYPE_CREATOR pAfpTypeCreators )
{

    //
    // Will be set to point to the default type/creator
    //

    PAFP_TYPE_CREATOR pDefAfpTypeCreator;

    //
    //  let's nuke everything in the listbox.
    //

    SetRedraw( FALSE );
    DeleteAllItems();

    //
    //  Iterate the volumes adding them to the listbox.
    //

    DWORD err = NO_ERROR;

    while( ( err == NO_ERROR ) && ( nTypeCreators-- ) )
    {

	//
	// If this is the default type/creator, do not add it now. It will
	// be added as the first item in the end.
	//

	if ( pAfpTypeCreators->afptc_id == AFP_DEF_TCID )
  	{
            pDefAfpTypeCreator = pAfpTypeCreators;
	}
	else
	{
	    TYPE_CREATOR_LBI * ptclbi = new TYPE_CREATOR_LBI(pAfpTypeCreators);

            if( AddItem( ptclbi ) < 0 )
            {
            	err = ERROR_NOT_ENOUGH_MEMORY;
            }
	}

	pAfpTypeCreators++;
    }

    //
    // Now add the default if there were no errors.
    //

    if ( err == NO_ERROR )
    {
    	TYPE_CREATOR_LBI * ptclbi = new TYPE_CREATOR_LBI(pDefAfpTypeCreator);

        if ( InsertItemData( 0, ptclbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}   // TYPE_CREATOR_LISBOX :: Refresh

/*******************************************************************

    NAME:       TYPE_CREATOR_LISTBOX :: SelectTypeCreator

    SYNOPSIS:   Given a Type/Creator this procedure will set focus on
		that item.

    EXIT:

    RETURNS:    DWORD                  - Any errors we encounter.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

DWORD TYPE_CREATOR_LISTBOX :: SelectTypeCreator( NLS_STR * pnlsType,
						 NLS_STR * pnlsCreator )
{

    INT 		ItemCount = QueryCount();
    INT 		Index;
    TYPE_CREATOR_LBI * 	ptclbi;

    if ( ItemCount == 0 )
    {
	return (DWORD)-1;
    }

    for( Index = 0; Index < ItemCount; Index++ )
    {
        ptclbi = QueryItem( Index );

	if ( pnlsType->strcmp( ptclbi->QueryType() ) == 0 )
	{
	    if ( pnlsCreator->strcmp( ptclbi->QueryCreator() ) == 0 )
	    {
      	    	SelectItem( Index );
	    	return ptclbi->QueryId();
	    }
	}
    }

    SelectItem( 0 );

    return AFP_DEF_TCID;
}
/*******************************************************************

    NAME:       TYPE_CREATOR_LISTBOX :: SelectTypeCreator

    SYNOPSIS:   Given an extension id, this procedure will set focus on
		that item in the type/creator listbox.

    EXIT:

    RETURNS:    DWORD                  - Any errors we encounter.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/

DWORD TYPE_CREATOR_LISTBOX :: SelectTypeCreator( DWORD dwId )
{

    INT 		ItemCount = QueryCount();
    INT 		Index;
    TYPE_CREATOR_LBI * 	ptclbi;

    if ( ItemCount == 0 )
    {
	return (DWORD)-1;
    }

    for( Index = 0; Index < ItemCount; Index++ )
    {
        ptclbi = QueryItem( Index );

	if ( ptclbi->QueryId() == dwId )
	{
      	    SelectItem( Index );
	    return dwId;
	}
    }

    SelectItem( 0 );

    return AFP_DEF_TCID;
}

//
// TYPE_CREATOR_LBI methods.
//

/*******************************************************************

    NAME:       TYPE_CREATOR_LBI :: TYPE_CREATOR_LBI

    SYNOPSIS:   TYPE_CREATOR_LBI class constructor.

    ENTRY:      pszVolumeName           - The sharepoint name.

                pszPath                 - The path for this sharepoint.

                cUses                   - Number of uses for this share.

    EXIT:       The object is constructed.

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/

TYPE_CREATOR_LBI :: TYPE_CREATOR_LBI( PAFP_TYPE_CREATOR pAfpTypeCreator	)
  : _nlsType( pAfpTypeCreator->afptc_type),
    _nlsCreator(pAfpTypeCreator->afptc_creator),
    _nlsComment(pAfpTypeCreator->afptc_comment),
    _dwId( pAfpTypeCreator->afptc_id )
{

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if ((( err = _nlsType.QueryError() )     != NERR_Success ) ||
        (( err = _nlsCreator.QueryError() )  != NERR_Success ) ||
        (( err = _nlsComment.QueryError() )  != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

}   // TYPE_CREATOR_LBI :: TYPE_CREATOR_LBI


/*******************************************************************

    NAME:       TYPE_CREATOR_LBI :: ~TYPE_CREATOR_LBI

    SYNOPSIS:   TYPE_CREATOR_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/
TYPE_CREATOR_LBI :: ~TYPE_CREATOR_LBI()
{

    //
    // Intentionally left blank
    //

}   // TYPE_CREATOR_LBI :: ~TYPE_CREATOR_LBI


/*******************************************************************

    NAME:       TYPE_CREATOR_LBI :: Paint

    SYNOPSIS:   Draw an entry in VOLUMES_LISTBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/
VOID TYPE_CREATOR_LBI :: Paint( LISTBOX *        plb,
                           	HDC              hdc,
                           	const RECT     * prect,
                           	GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE 		dteCreator( _nlsCreator.QueryPch() );
    STR_DTE 		dteType( _nlsType.QueryPch() );
    STR_DTE_ELLIPSIS 	dteComment(_nlsComment.QueryPch(),plb,ELLIPSIS_RIGHT);

    DISPLAY_TABLE dtab( COLS_FA_LB_TYPE_CREATORS,
                        ((TYPE_CREATOR_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = &dteCreator;
    dtab[1] = &dteType;
    dtab[2] = &dteComment;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // TYPE_CREATOR_LBI :: Paint


/*******************************************************************

    NAME:       TYPE_CREATOR_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/
WCHAR TYPE_CREATOR_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsCreator );

    return _nlsCreator.QueryChar( istr );

}   // TYPE_CREATOR_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       TYPE_CREATOR_LBI :: Compare

    SYNOPSIS:   Compare two BASE_RES_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/
INT TYPE_CREATOR_LBI :: Compare( const LBI * plbi ) const
{
    INT Result = _nlsCreator._stricmp(
			((const TYPE_CREATOR_LBI *)plbi)->_nlsCreator );
    if ( Result == 0 )
    {
    	return _nlsType._stricmp(
			((const TYPE_CREATOR_LBI *)plbi)->_nlsType );
    }
    else
	return Result;

}   // TYPE_CREATOR_LBI :: Compare


/*******************************************************************

   NAME:	CompareExtensions

   SYNOPSIS:    Compare routine for qsort call.

   ENTRY:

   RETURNS:	< 0  if pAfpExtension1 comes before pAfpExtension2
 		> 0  if pAfpExtension1 comes before pAfpExtension2
		== 0 if pAfpExtension1 is equal to  pAfpExtension2

   HISTORY:
	NarenG	    7-Dec-1992 		Created

********************************************************************/
int __cdecl
CompareExtensions(
	IN const void * pAfpExtension1,
	IN const void * pAfpExtension2
)
{

    return( ::stricmpf(((PAFP_EXTENSION)pAfpExtension1)->afpe_extension,
    		       ((PAFP_EXTENSION)pAfpExtension2)->afpe_extension ));
}

/*******************************************************************

    NAME:       TYPE_CREATOR_ADD :: TYPE_CREATOR_ADD

    SYNOPSIS:   TYPE_CREATOR_ADD class constructor.

    ENTRY:      hWndOwner               - The owning window.

    		hServer                 - Handle used to make admin
					  API calls.

    		ptclb * 		- Pointer to the list of type/creators

    EXIT:       The object is constructed.

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/

TYPE_CREATOR_ADD :: TYPE_CREATOR_ADD( HWND 		     hWndOwner,
			      	      AFP_SERVER_HANDLE      hServer,
				      TYPE_CREATOR_LISTBOX * ptclb,
				      NLS_STR *		     pnlsType,
				      NLS_STR * 	     pnlsCreator )
  : DIALOG_WINDOW( MAKEINTRESOURCE(IDD_TYPE_CREATOR_ADD_DIALOG), hWndOwner ),
    _hServer( hServer ),
    _sleComment( this, IDTA_SLE_DESCRIPTION, AFP_ETC_COMMENT_LEN ),
    _cbTypes( this, IDTA_CB_TYPE , AFP_TYPE_LEN ),
    _cbCreators( this, IDTA_CB_CREATOR, AFP_CREATOR_LEN ),
    _pnlsType( pnlsType ),
    _pnlsCreator( pnlsCreator )

{

    //
    //  Let's make sure everything constructed OK.
    //

    if ( QueryError() != NERR_Success )
    {
        return;
    }

    DWORD err;

    if ( (( err = _sleComment.QueryError() ) != NERR_Success ) ||
         (( err = _cbTypes.QueryError() )    != NERR_Success ) ||
         (( err = _cbCreators.QueryError() ) != NERR_Success ))
    {
	ReportError( err );
	return;
    }

    //
    // This may take a while
    //

    AUTO_CURSOR Cursor;

    //
    //  Fill up the COMBOBOXes
    //

    DWORD nItems = ptclb->QueryCount();
    DWORD Count;

    for ( Count = 0; Count < nItems; Count++ )
    {

	TYPE_CREATOR_LBI * ptclbi = ptclb->QueryItem( (INT)Count );

	if ( _cbTypes.AddItemIdemp( ptclbi->QueryType() ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
	    break;
        }

	if ( _cbCreators.AddItemIdemp( ptclbi->QueryCreator() ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
	    break;
        }

    }

    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    _cbCreators.ClaimFocus();

}

/*******************************************************************

    NAME:       TYPE_CREATOR_ADD :: OnOK

    SYNOPSIS:   Gather all information and Add the type creator pair

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          12/14/92        Created

********************************************************************/

BOOL TYPE_CREATOR_ADD :: OnOK( VOID )
{
    APIERR  err;
    NLS_STR nlsType;
    NLS_STR nlsCreator;
    NLS_STR nlsComment;

    //
    // This may take a while
    //

    AUTO_CURSOR Cursor;

    if ( (( err = nlsType.QueryError() )    != NERR_Success ) ||
     	 (( err = nlsCreator.QueryError() ) != NERR_Success ) ||
    	 (( err = nlsComment.QueryError() ) != NERR_Success ) ||
         (( err = _cbTypes.QueryText( &nlsType ) )       != NERR_Success ) ||
         (( err = _cbCreators.QueryText( &nlsCreator ) ) != NERR_Success ) ||
         (( err = _sleComment.QueryText( &nlsComment ) ) != NERR_Success ))
    {
	::MsgPopup( this, err );

	Dismiss( FALSE );

	return FALSE;
    }

    //
    // Validate all the information
    //

    AFP_TYPE_CREATOR AfpTypeCreator;

    if ( nlsCreator.strlen() == 0 )
    {
	::MsgPopup( this, IDS_NEED_TYPE_CREATOR );
	_cbCreators.ClaimFocus();
	return FALSE;
    }

    if ( nlsType.strlen() == 0 )
    {
	::MsgPopup( this, IDS_NEED_TYPE_CREATOR );
	_cbTypes.ClaimFocus();
	return FALSE;
    }

    ::wcscpy( AfpTypeCreator.afptc_creator, nlsCreator.QueryPch() );
    ::wcscpy( AfpTypeCreator.afptc_type, nlsType.QueryPch() );
    ::wcscpy( AfpTypeCreator.afptc_comment, nlsComment.QueryPch() );

    err = ::AfpAdminETCMapAdd( _hServer, &AfpTypeCreator );

    if ( err != NO_ERROR )
    {
	::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	return FALSE;
    }

    _pnlsType->CopyFrom( nlsType );
    _pnlsCreator->CopyFrom( nlsCreator );

    Dismiss( TRUE );

    return TRUE;

}

/*******************************************************************

    NAME:       TYPE_CREATOR_ADD :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/
ULONG TYPE_CREATOR_ADD :: QueryHelpContext( void )
{
    return HC_TYPE_CREATOR_ADD;

}   // TYPE_CREATOR_ADD:: QueryHelpContext

/*******************************************************************

    NAME:       TYPE_CREATOR_EDIT :: TYPE_CREATOR_EDIT

    SYNOPSIS:   TYPE_CREATOR_EDIT class constructor.

    ENTRY:      hWndOwner               - The owning window.

    		hServer                 - Handle used to make admin
					  API calls.

    		ptclbi * 		- Pointer to the selected type/creator

    EXIT:       The object is constructed.

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/

TYPE_CREATOR_EDIT :: TYPE_CREATOR_EDIT( HWND 		     hWndOwner,
			      	        AFP_SERVER_HANDLE    hServer,
				        TYPE_CREATOR_LBI *   ptclbi )
  : DIALOG_WINDOW( MAKEINTRESOURCE(IDD_TYPE_CREATOR_EDIT_DIALOG), hWndOwner ),
    _hServer( hServer ),
    _sleComment( this, IDTE_SLE_DESCRIPTION, AFP_ETC_COMMENT_LEN ),
    _sltType( this, IDTE_SLE_TYPE ),
    _sltCreator( this, IDTE_SLE_CREATOR )
{

    //
    //  Let's make sure everything constructed OK.
    //

    if ( QueryError() != NERR_Success )
    {
        return;
    }

    DWORD err;

    NLS_STR nlsAmp( TEXT("&") );
    NLS_STR nlsType( ptclbi->QueryType() );
    NLS_STR nlsCreator( ptclbi->QueryCreator() );

    if ( (( err = _sleComment.QueryError() ) != NERR_Success )   ||
         (( err = _sltType.QueryError() )    != NERR_Success )   ||
         (( err = nlsType.QueryError() )    != NERR_Success ) 	 ||
         (( err = nlsCreator.QueryError() )    != NERR_Success ) ||
         (( err = nlsAmp.QueryError() )    != NERR_Success )     ||
         (( err = _sltCreator.QueryError() ) != NERR_Success ))
    {
	ReportError( err );
	return;
    }

    //
    // Add an extra & for every & found in the type and creator,
    // otherwise the character following the & will become a hotkey.
    //

    ISTR istrPosType( nlsType );
    ISTR istrStartType( nlsType );

    while ( nlsType.strstr( &istrPosType, nlsAmp, istrStartType ) )
    {
	nlsType.InsertStr( nlsAmp, ++istrPosType );

	istrStartType = ++istrPosType;
    }

    _sltType.SetText( nlsType );

    ISTR istrPosCreator( nlsCreator );
    ISTR istrStartCreator( nlsCreator );

    while ( nlsCreator.strstr( &istrPosCreator, nlsAmp, istrStartCreator ) )
    {
	nlsCreator.InsertStr( nlsAmp, ++istrPosCreator );

	istrStartCreator = ++istrPosCreator;
    }

    _sltCreator.SetText( nlsCreator );

    _sleComment.SetText( ptclbi->QueryComment() );
    _sleComment.SelectString();

}

/*******************************************************************

    NAME:       TYPE_CREATOR_EDIT :: OnOK

    SYNOPSIS:   Gather all information and set the type/creator information.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          12/14/92        Created

********************************************************************/

BOOL TYPE_CREATOR_EDIT :: OnOK( VOID )
{
    APIERR  err;
    NLS_STR nlsType;
    NLS_STR nlsCreator;
    NLS_STR nlsComment;

    //
    // This may take a while
    //

    AUTO_CURSOR Cursor;

    if ( (( err = nlsType.QueryError() )    != NERR_Success ) ||
     	 (( err = nlsCreator.QueryError() ) != NERR_Success ) ||
    	 (( err = nlsComment.QueryError() ) != NERR_Success ) ||
         (( err = _sltType.QueryText( &nlsType ) )       != NERR_Success ) ||
         (( err = _sltCreator.QueryText( &nlsCreator ) ) != NERR_Success ) ||
         (( err = _sleComment.QueryText( &nlsComment ) ) != NERR_Success ))
    {
	::MsgPopup( this, err );

	Dismiss( FALSE );
	return FALSE;
    }

    //
    // Validate all the information
    //

    AFP_TYPE_CREATOR AfpTypeCreator;

    ::wcscpy( AfpTypeCreator.afptc_creator, nlsCreator.QueryPch() );
    ::wcscpy( AfpTypeCreator.afptc_type, nlsType.QueryPch() );
    ::wcscpy( AfpTypeCreator.afptc_comment, nlsComment.QueryPch() );

    err = ::AfpAdminETCMapSetInfo( _hServer, &AfpTypeCreator );

    if ( err != NO_ERROR )
    {
	::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	Dismiss( FALSE );
	return FALSE;
    }

    Dismiss( TRUE );

    return TRUE;

}

/*******************************************************************

    NAME:       TYPE_CREATOR_EDIT :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
     NarenG		12/4/92		Created

********************************************************************/
ULONG TYPE_CREATOR_EDIT :: QueryHelpContext( void )
{
    return HC_TYPE_CREATOR_EDIT;

}   // TYPE_CREATOR_EDIT:: QueryHelpContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\afpmgr.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    afpmgr.cxx
    This module contains the "LibMain" function.


    FILE HISTORY:
        NarenG      1-Oct-1991  Converted srvmgr.cpl to afpmgr.cpl

*/


#define INCL_NET
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <uitrace.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#include <dbgstr.hxx>

extern "C"
{
#include <afpmgr.h>

    //
    //  DLL load/unload entry point.
    //

    BOOL FAR PASCAL AfpMgrDllInitialize( HINSTANCE 	hInstance,
                                         DWORD  	nReason,
                                         LPVOID 	pReserved );

    //
    //  Globals.
    //

    HINSTANCE _hInstance = NULL;

}   // extern "C"


/*******************************************************************

    NAME:       InitializeAfpMgr

    SYNOPSIS:   Called during processing of DLL_PROCESS_ATTACH notification to
                initialize the DLL.

    ENTRY:     

    RETURNS:    BOOL                    - TRUE  = AfpMgr should be installed.
                                          FALSE = AfpMgr cannot be installed.

    HISTORY:
        NarenG      1-Oct-1992  Stole from original.

********************************************************************/
BOOL InitializeAfpMgr( VOID )
{
    //
    //  Initialize all of the NetUI goodies.
    //


    APIERR err = BLT::Init( _hInstance,
			    CID_AFPMGR_BASE, CID_AFPMGR_LAST,	
			    IDS_AFPMGR_BASE, IDS_AFPMGR_LAST );

    if( err == NERR_Success )
    {
        err = BLT_MASTER_TIMER::Init();

        if( err != NERR_Success )
        {
            //
            //  BLT initialized OK, but BLT_MASTER_TIMER
            //  failed.  So, before we bag-out, we must
            //  deinitialize BLT.
            //

            BLT::Term( _hInstance );
        }
    }


    if( err == NERR_Success )
    {
 	err = BLT::RegisterHelpFile( _hInstance,
                                     IDS_AFPMGR_HELPFILENAME,
                                     HC_UI_AFPMGR_BASE,
                                     HC_UI_AFPMGR_LAST );

   	if( err != NERR_Success )
        {
       	    //
            //  This is the only place where we can safely
            //  invoke MsgPopup, since we *know* that all of
            //  the BLT goodies were initialized properly.
            //

//            ::MsgPopup( hWnd, err );
      	}
    }

    return err == NERR_Success;

}   // InitializeAfpMgr


/*******************************************************************

    NAME:       TerminateAfpMgr

    SYNOPSIS:   Called during processing of DLL_PROCESS_DETACH notification to
                terminate the AfpMgr.

    ENTRY:      hWnd                    - Window handle of parent window.

    HISTORY:
        NarenG      1-Oct-1992  Stole from original.

********************************************************************/
VOID TerminateAfpMgr( VOID )
{
    //
    //  Kill the NetUI goodies.
    //

    BLT_MASTER_TIMER::Term();

    BLT::Term( _hInstance );

}   // TerminateAfpMgr



/*******************************************************************

    NAME:       AfpMgrDllInitialize

    SYNOPSIS:   This DLL entry point is called when processes & threads
                are initialized and terminated, or upon calls to
                LoadLibrary() and FreeLibrary().

    ENTRY:      hInstance               - A handle to the DLL.

                nReason                 - Indicates why the DLL entry
                                          point is being called.

                pReserved               - Reserved.

    RETURNS:    BOOL                    - TRUE  = DLL init was successful.
                                          FALSE = DLL init failed.

    NOTES:      The return value is only relevant during processing of
                DLL_PROCESS_ATTACH notifications.

    HISTORY:
        NarenG      1-Oct-1992  Stole from original.

********************************************************************/

BOOL FAR PASCAL AfpMgrDllInitialize( HINSTANCE 	hInstance,
                                     DWORD  	nReason,
                                     LPVOID 	pReserved )
{
    BOOL fResult = TRUE;

    UNREFERENCED( pReserved );

    switch( nReason  )
    {
    case DLL_PROCESS_ATTACH:
        //
        //  This notification indicates that the DLL is attaching to
        //  the address space of the current process.  This is either
        //  the result of the process starting up, or after a call to
        //  LoadLibrary().  The DLL should us this as a hook to
        //  initialize any instance data or to allocate a TLS index.
        //
        //  This call is made in the context of the thread that
        //  caused the process address space to change.
        //

    	_hInstance = hInstance;

        fResult = InitializeAfpMgr();

        break;

    case DLL_PROCESS_DETACH:
        //
        //  This notification indicates that the calling process is
        //  detaching the DLL from its address space.  This is either
        //  due to a clean process exit or from a FreeLibrary() call.
        //  The DLL should use this opportunity to return any TLS
        //  indexes allocated and to free any thread local data.
        //
        //  Note that this notification is posted only once per
        //  process.  Individual threads do not invoke the
        //  DLL_THREAD_DETACH notification.
        //

	TerminateAfpMgr();

        _hInstance = NULL;

        break;

    case DLL_THREAD_ATTACH:
        //
        //  This notfication indicates that a new thread is being
        //  created in the current process.  All DLLs attached to
        //  the process at the time the thread starts will be
        //  notified.  The DLL should use this opportunity to
        //  initialize a TLS slot for the thread.
        //
        //  Note that the thread that posts the DLL_PROCESS_ATTACH
        //  notification will not post a DLL_THREAD_ATTACH.
        //
        //  Note also that after a DLL is loaded with LoadLibrary,
        //  only threads created after the DLL is loaded will
        //  post this notification.
        //

        break;

    case DLL_THREAD_DETACH:
        //
        //  This notification indicates that a thread is exiting
        //  cleanly.  The DLL should use this opportunity to
        //  free any data stored in TLS indices.
        //

        break;

    default:
        //
        //  Who knows?  Just ignore it.
        //

        break;
    }

    return fResult;


}   // AfpMgrDllInitialize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\cpl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    cpl.cxx
    This module contains entry points for the Afp Manager Control Panel Applet.
    It contains "CplApplet" function.


    FILE HISTORY:
        NarenG      1-Oct-1991  Stole from srvmgr.cpl. 

*/


#define INCL_NET
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <uitrace.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#include <dbgstr.hxx>
#include <lmoloc.hxx>

extern "C"
{
#include <cpl.h>     	// Multimedia CPL defs
#include <afpmgr.h>
#include <macfile.h>

}

#include <srvprop.hxx>
#include <startafp.hxx>


extern "C"
{
    //
    //  Control Panel Applet entry point.
    //

    LONG FAR PASCAL CPlApplet( HWND hwndCPl,
                               WORD nMsg,
                               LPARAM lParam1,
                               LPARAM lparam2 );

    //
    //  Globals.
    //

    extern HINSTANCE _hInstance;	// Exported by the afpmgr.cxx module.

}   // extern "C"


/*******************************************************************

    NAME:       GetLocalServerName

    SYNOPSIS:   Returns the name of the current server (\\server).

    ENTRY:      nlsServerName           - Will receive the server name.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        NarenG      1-Oct-1992  Stole from original.

********************************************************************/
APIERR GetLocalServerName( NLS_STR * nlsServerName )
{
    LOCATION loc( LOC_TYPE_LOCAL );

    APIERR err = loc.QueryError();

    if( err == NERR_Success )
    {
        err = loc.QueryDisplayName( nlsServerName );
    }

    return err;

}   // GetLocalServerName


/*******************************************************************

    NAME:       RunAfpMgr

    SYNOPSIS:   Invoke the main dialog of the AFP Server Manager Control
                Panel Applet.

    ENTRY:      hWnd                    - Window handle of parent window.

    RETURNS:    APIERR

    HISTORY:
        NarenG      1-Oct-1992  Stole from original.

********************************************************************/
APIERR RunAfpMgr( HWND hWnd )
{

    NLS_STR 	      nlsServerName;
    BOOL	      fAFPRunning;
    APIERR 	      err; 
    AFP_SERVER_HANDLE hServer = NULL;

    //
    // This is not a loop
    //
    do {

    	if ( ( err = nlsServerName.QueryError() ) != NERR_Success )
	    break;

    	//
    	//  Try to get the Local Server Name
    	//
    	err = GetLocalServerName( &nlsServerName );

    	if ( err != NERR_Success )
	    break;

	err = IsAfpServiceRunning( nlsServerName.QueryPch(), &fAFPRunning );

    	if ( err != NERR_Success )
	    break;

    	//
    	//  The server is not started. 
    	//
    	if( !fAFPRunning ) 
    	{

	    //
	    // Ask the user if he/she wants to start it.
	    //
	    if ( ::MsgPopup( 	hWnd,
                       	  	IDS_START_AFPSERVER_NOW,
                       		MPSEV_WARNING,
                       		MP_YESNO,
                       		MP_YES ) == IDYES ) 
	    {

            	//
            	//  Start the AFP Service
            	//

            	err = StartAfpService( hWnd, nlsServerName.QueryPch());

    		if ( err != NERR_Success ) 
    	    	    break;
	    }
	    else
	    {
	    	break;
	    }

	}

	//
	// Set up an RPC conenction with the server
	//

        if ( ( err = ::AfpAdminConnect( (LPWSTR)(nlsServerName.QueryPch()), 
				   	&hServer ) ) != NO_ERROR )
	{
	    break;
	}

	//
        //  Invoke the Main Property Dialog.
        //

	SERVER_PROPERTIES * pDlg = new SERVER_PROPERTIES( 
						   hWnd,
						   hServer,
                                                   nlsServerName.QueryPch() );

        err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY : pDlg->Process();

        delete pDlg;

	if ( hServer != NULL )
	{
	    ::AfpAdminDisconnect( hServer );
	}

    } while( FALSE );

    if( err != NERR_Success )
    {
        if ( err == IDS_MACFILE_NOT_INSTALLED )
        {
            ::MsgPopup( hWnd, 
                        err, 
                        MPSEV_ERROR, 
                        MP_OKCANCEL,
                        nlsServerName.QueryPch(),
                        MP_OK );
        }
        else
        {
            ::MsgPopup( hWnd, AFPERR_TO_STRINGID(err) );
        }
    }

    return err;

}   // RunAfpMgr


/*******************************************************************

    NAME:       CPlApplet

    SYNOPSIS:   Exported function to start the Server Manager Control
                Panel Applet.

    ENTRY:      hwndCPl                 - Window handle of parent.

                nMsg                    - CPL user message (see CPL.H
                                          in WINDOWS\SHELL\CONTROL\H).

                lParam1                 - Message-specific pointer.

                lParam2                 - Message-specific pointer.

    RETURNS:    LONG

    HISTORY:
        NarenG      1-Oct-1992  Stole from original.

********************************************************************/
LONG FAR PASCAL CPlApplet( HWND hwndCPl,
                           WORD nMsg,
                           LPARAM lParam1,
                           LPARAM lParam2 )
{
    LPCPLINFO pCplInfo;
    LONG      nResult = 0;

    UNREFERENCED( lParam1 );

    switch( nMsg )
    {
    case CPL_INIT:
        //
        //  This message is sent to indicate that CPlApplet() was found.
        //
        //  lParam1 and lParam2 are not used.
        //
        //  Return TRUE if applet should be installed, FALSE otherwise.
        //

        return (LONG)TRUE;

    case CPL_GETCOUNT:
        //
        //  This message is set to determine the number of applets contained
        //  in this DLL.
        //
        //  lParam1 and lParam2 are not used.
        //
        //  Return the number of applets contained in this DLL.
        //

        return 1;

    case CPL_INQUIRE:
        //
        //  This message is sent once per applet to retrieve information
        //  about each applet.
        //
        //  lParam1 is the applet number to register.
        //
        //  lParam2 is a pointer to a CPLINFO structure.  The CPLINFO
        //  structure's idIcon, idName, idInfo, and lData fields should
        //  be initialized as appropriate for the applet.
        //
        //  There is no return value.
        //

        pCplInfo = (LPCPLINFO)lParam2;

        pCplInfo->idIcon = IDI_AFPMCPA_ICON;
        pCplInfo->idName = IDS_AFPMCPA_NAME_STRING;
        pCplInfo->idInfo = IDS_AFPMCPA_INFO_STRING;
        pCplInfo->lData  = 0L;

        break;

    case CPL_SELECT:
        //
        //  This message is sent when the applet's icon has been
        //  selected.
        //
        //  lParam1 is the applet number that was selected.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        break;

    case CPL_DBLCLK:
        //
        //  This message is sent when the applet's icon has been
        //  double-clicked.  This message should initiate the
        //  applet's dialog box.
        //
        //  lParam1 is the applet number that was selected.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        RunAfpMgr( hwndCPl );

        break;

    case CPL_STOP:
        //
        //  This message is sent once for each applet when the
        //  control panel is shutting down.  This message should
        //  initiate applet specific cleanup.
        //
        //  lParam1 is the applet number being stopped.
        //
        //  lParam2 is the applet's lData value.
        //
        //  There is no return value.
        //

        break;

    case CPL_EXIT:
        //
        //  This message is sent just before the control panel calls
        //  FreeLibrary.  
        //
        //  lParam1 and lParam2 are not used.
        //
        //  There is no return value.
        //

        break;

    case CPL_NEWINQUIRE:
        //
        //  This message is basically the same as CPL_INQUIRE, except
        //  lParam2 points to a NEWCPLINFO structure.  This message will
        //  be sent *before* CPL_INQUIRE.  If the applet returns a non
        //  zero value, then CPL_INQUIRE will not be sent.
        //
        //  lParam1 is the applet number to register.
        //
        //  lParam2 is a pointer to a NEWCPLINFO structure.
        //
        //  There is no return value.
        //

        return FALSE;

    default:
        //
        //  Who knows.  Ignore it.
        //

        break;
    }

    return nResult;

}   // CPlApplet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\fmx.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    fmx.cxx
    This file contains the FMExtensionProc. All code that interfaces with
    the file manager lives in this module

    FILE HISTORY:
	NarenG		11/23/92    Created.

*/

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSERVICE
#define INCL_NETLIB
#define INCL_NETACCESS
#define INCL_NETUSE
#include <lmui.hxx>


#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#include <uiassert.hxx>
#include <dbgstr.hxx>
#include <lmoloc.hxx>
#include <netname.hxx>

extern "C"
{
#include <wfext.h>
#include <macfile.h>
#include <afpmgr.h>
}


#include <lmsvc.hxx>
#include <fmx.hxx>
#include <startafp.hxx>
#include <newvol.hxx>
#include <voledit.hxx>
#include <voldel.hxx>
#include <assoc.hxx>
#include <perms.hxx>


extern "C"
{
    //
    //  Globals.
    //

    extern HINSTANCE _hInstance;// Exported by the afpmgr.cxx module.

    static HWND   _hWnd;	// Handle to the owner window.

    static DWORD  _dwDelta;	// Used to manipulate menu items.

    static HMENU  _hMenu;	// Created at load time.

    EXT_BUTTON aExtButton[] = { IDM_VOLUME_CREATE, 		0, 0,
    				IDM_VOLUME_DELETE, 		0, 0,
				IDM_DIRECTORY_PERMISSIONS, 	0, 0
			 	};


}   // extern "C"

/*******************************************************************

    NAME:       GetCurrentFocus

    SYNOPSIS:   Will retrieve the current selection.

    ENTRY:

    EXIT: 	pnlsServerName    - Will point to a server name if it is not
				    local.
		pnlsPath     	  - Will point to the path as returned by
				    filemgr.
		pnlsLocalPath     - Will point to the local path if pnlsPath
				    was a remote drive, otherwise it will
				    be the same as pnlsPath.
		pfIsFile	  - Indicates if the current selection is
				    a file or not.

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/23/92    Created.

********************************************************************/

APIERR GetCurrentFocus( NLS_STR * pnlsServerName,
			NLS_STR * pnlsPath,
			NLS_STR * pnlsLocalPath,
			BOOL *    pfIsFile )
{

    APIERR  err;
    //
    // Get the current selection
    //

    if ( err = ::GetSelItem( _hWnd, pnlsPath, FALSE, pfIsFile ))
    {
	return err;
    }

    NET_NAME NetName( pnlsPath->QueryPch() );

    if ( ( err = NetName.QueryError() ) != NERR_Success )
    {
	return err;
    }

    BOOL fIsLocal = NetName.IsLocal( &err );

    if ( err != NERR_Success )
    {
	return err;
    }

    if ( fIsLocal )
    {
	pnlsLocalPath->CopyFrom( *pnlsPath );
    }
    else
    {
	if ( ( err = NetName.QueryLocalPath( pnlsLocalPath ) ) != NERR_Success )
	{
	    return err;
	}
    }

    //
    // Get the server name to connect to.
    //

    if (( err = NetName.QueryComputerName(pnlsServerName)) != NERR_Success)
    {
	return err;
    }

    return NERR_Success;
}

/*******************************************************************

    NAME:       FMExtensionProcW

    SYNOPSIS:   File Manager Extension Procedure

    ENTRY:      hwnd        See FMX spec for details
                wEvent
                lParam

    EXIT:       See FMX spec for details

    RETURNS:    See FMX spec for details

    NOTES:

    HISTORY:
	NarenG		11/23/92    Created.

********************************************************************/

LONG /* FAR PASCAL */ FMExtensionProcW( HWND hWnd, WORD wEvent, LONG lParam )
{
NLS_STR  		nlsServerName;
NLS_STR  		nlsPath;
NLS_STR  		nlsLocalPath;
DWORD   		err = NO_ERROR;
BOOL			fIsFile;
AFP_SERVER_HANDLE	hServer = NULL;


    UNREFERENCED( _dwDelta );
    FMX         Fmx( hWnd );

    //
    // If this is a user event then we need to connect to the server
    //

    if ( ( wEvent == IDM_FILE_ASSOCIATE ) ||
         ( wEvent == IDM_VOLUME_CREATE  ) ||
         ( wEvent == IDM_VOLUME_EDIT    ) ||
         ( wEvent == IDM_VOLUME_DELETE  ) ||
         ( wEvent == IDM_DIRECTORY_PERMISSIONS ) )
    {

        AUTO_CURSOR Cursor;

	//
	// Get the current focus
	//

        if ((( err = nlsServerName.QueryError() )    != NERR_Success ) ||
            (( err = nlsLocalPath.QueryError() )     != NERR_Success ) ||
            (( err = nlsPath.QueryError() )          != NERR_Success ))
	{
    	    ::MsgPopup( _hWnd, err );
	    return err;
	}


    	if ( Fmx.QuerySelCount() > 1 )
   	{
    	    ::MsgPopup( _hWnd, IDS_MULTISEL_NOT_ALLOWED );
	    return( ERROR_TOO_MANY_OPEN_FILES );
	}

	if ( (err = GetCurrentFocus( &nlsServerName,
				     &nlsPath,
				     &nlsLocalPath,
				     &fIsFile ) ) != NERR_Success )
	{
    	    ::MsgPopup( _hWnd, err );
	    return err;
	}

        //
	// Check if the server focus of the current selection is running AFP
	//

	BOOL fIsAfpRunning;

        if ( ( err = IsAfpServiceRunning( nlsServerName.QueryPch(),
				          &fIsAfpRunning ) ) != NERR_Success )
	{
            if ( err == IDS_MACFILE_NOT_INSTALLED )
            {
                ::MsgPopup( _hWnd,
                            err,
                            MPSEV_ERROR,
                            MP_OKCANCEL,
                            nlsServerName.QueryPch(),
                            MP_OK );
            }
            else
            {
    	        ::MsgPopup( _hWnd, err );
            }

	    return err;
	}

	if ( !fIsAfpRunning )
        {
	    //
	    // Ask the user if he/she wants to start it.
	    //

	    if ( ::MsgPopup( hWnd,
                       	     IDS_START_AFPSERVER_NOW,
                       	     MPSEV_WARNING,
                       	     MP_YESNO,
                       	     MP_YES ) == IDYES )
	    {

            	//
            	//  Start the AFP Service
            	//

            	err = StartAfpService( hWnd, nlsServerName.QueryPch());

    		if ( err != NERR_Success )
		{
    	    	    ::MsgPopup( _hWnd, err );
	    	    return err;
		}

	    }
	    else
	    {
		//
		// User does not want to start the AFP Service now so
		// simply return
		//

	    	return NERR_Success;
	    }
  	}

	//
	// Set up an RPC conenction with the server
	//

        if ( ( err = ::AfpAdminConnect( (LPWSTR)(nlsServerName.QueryPch()),
				        &hServer ) ) != NO_ERROR )
	{
    	    ::MsgPopup( _hWnd, AFPERR_TO_STRINGID( err ) );
	    return err;
	}
    }

    //
    // What does the user want to do with the server ?
    //

    switch( wEvent )
    {

    case IDM_FILE_ASSOCIATE:
	{

	FILE_ASSOCIATION_DIALOG * pfadlg = new FILE_ASSOCIATION_DIALOG(
				  		_hWnd,
						hServer,
				      	   	nlsPath.QueryPch(),
						fIsFile );

        err = ( pfadlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
				 : pfadlg->Process();

        delete pfadlg;

	break;
	}

    case IDM_VOLUME_CREATE:
	{

	NEW_VOLUME_FILEMGR_DIALOG * pnvdlg = new NEW_VOLUME_FILEMGR_DIALOG(
						_hWnd,
				      	   	nlsPath.QueryPch(),
						fIsFile );

        err = ( pnvdlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
				 : pnvdlg->Process();

        delete pnvdlg;

        break;
	}

    case IDM_VOLUME_EDIT:
	{

	VOLUME_EDIT_DIALOG * pvedlg = new VOLUME_EDIT_DIALOG(
						_hWnd,
						hServer,
						nlsServerName.QueryPch(),
				      	   	nlsLocalPath.QueryPch(),
						fIsFile );

        err = ( pvedlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
				 : pvedlg->Process();

        delete pvedlg;

        break;
	}

    case IDM_VOLUME_DELETE:
	{

	VOLUME_DELETE_DIALOG * pvddlg = new VOLUME_DELETE_DIALOG(
						_hWnd,
						hServer,
						nlsServerName.QueryPch(),
				      	   	nlsLocalPath.QueryPch(),
						fIsFile );

        err = ( pvddlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
				 : pvddlg->Process();

        delete pvddlg;

        break;
	}

    case IDM_DIRECTORY_PERMISSIONS:
	{

	if ( fIsFile )
  	{
    	    ::MsgPopup( _hWnd, IDS_MUST_BE_VALID_DIR );
	    return NO_ERROR;
	}

	DIRECTORY_PERMISSIONS_DLG * pdpdlg = new DIRECTORY_PERMISSIONS_DLG(
						_hWnd,
						hServer,
						nlsServerName.QueryPch(),
						FALSE,
						nlsLocalPath.QueryPch(),
				      	   	nlsPath.QueryPch() );

        err = ( pdpdlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
				 : pdpdlg->Process();

        delete pdpdlg;

        break;
	}

    case IDM_AFPMGR_HELP:
	{

        RESOURCE_STR nlsHelpFile( IDS_AFPMGR_HELPFILENAME );

        if ( err = nlsHelpFile.QueryError() )
        {
            break;
        }

        ::WinHelp( _hWnd, nlsHelpFile, HELP_FINDER, HC_FILE_MANAGER_CONTENTS );

	break;
	}

    case FMEVENT_LOAD:
	{

	//
        // The file manager is ANSI only, so we need to MAP appropriately
        //

        FMS_LOAD * pfmsload = (FMS_LOAD *)lParam;

    	//
    	// Save the handle to the owner window
    	//

    	_hWnd    = hWnd;
        _dwDelta = pfmsload->wMenuDelta;

        pfmsload->dwSize = sizeof( FMS_LOAD );

        RESOURCE_STR nlsMenuName( IDS_AFPMGR_MENU_NAME );

        if ( nlsMenuName.QueryError() != NERR_Success )
        {
            return FALSE;       // failed to install FMX
        }

	//
        // MENU_TEXT_LEN is defined in wfext.h, in BYTES
	//

        if ( nlsMenuName.QueryTextSize() > sizeof(pfmsload->szMenuName) )
        {
            return FALSE;       // failed to install FMX
        }

        if ( nlsMenuName.MapCopyTo(pfmsload->szMenuName,
                                   sizeof(pfmsload->szMenuName))!=NERR_Success)
        {
 	    return FALSE ;
        }

	//
        //  Compute hMenu
	//

        _hMenu = ::LoadMenu(::_hInstance,MAKEINTRESOURCE(ID_FILEMGR_MENU));

        if ( _hMenu == NULL )
        {
  	    return FALSE;       // failed to install FMX
        }

        pfmsload->hMenu = _hMenu;

	return TRUE;

	}

    case FMEVENT_INITMENU:
	{

        return 0;

	}

    case FMEVENT_UNLOAD:
	{

        _hWnd = NULL;
        _dwDelta = 0;

        return 0;
	}

    case FMEVENT_TOOLBARLOAD:
	{
	
        FMS_TOOLBARLOAD  * pfmstoolbarload = (FMS_TOOLBARLOAD *)lParam;
        pfmstoolbarload->dwSize    	   = sizeof(FMS_TOOLBARLOAD) ;
        pfmstoolbarload->lpButtons 	   = aExtButton ;
        pfmstoolbarload->cButtons  	   = 3;
        pfmstoolbarload->cBitmaps  	   = 3;
	pfmstoolbarload->idBitmap  	   = IDBM_AFP_TOOLBAR;
	pfmstoolbarload->hBitmap   	   = NULL ;

        return TRUE;
	}

    case FMEVENT_HELPSTRING:
	{

	FMS_HELPSTRING * pfmshelp = (FMS_HELPSTRING *) lParam ;
	MSGID msgHelp ;

	switch ( pfmshelp->idCommand )
	{
    	case IDM_FILE_ASSOCIATE:
	    {
	    msgHelp = IDS_FM_HELP_ASSOCIATE;
	    break;
	    }

    	case IDM_VOLUME_CREATE:
	    {
	    msgHelp = IDS_FM_HELP_CREATE_VOLUME;
	    break;
	    }

    	case IDM_VOLUME_EDIT:
	    {
	    msgHelp = IDS_FM_HELP_EDIT_VOLUMES;
	    break;
	    }

    	case IDM_VOLUME_DELETE:
	    {
	    msgHelp = IDS_FM_HELP_DELETE_VOLUMES;
	    break;
	    }

    	case IDM_DIRECTORY_PERMISSIONS:
	    {
	    msgHelp = IDS_FM_HELP_PERMISSIONS;
	    break;
	    }

    	case IDM_AFPMGR_HELP:
	    {
	    msgHelp = IDS_FM_HELP_HELP;
	    break;
	    }

	default:
	    {
	    msgHelp = IDS_FM_SFM;
	    break;
	    }
	}

	RESOURCE_STR nlsHelp( msgHelp );

	if ( !nlsHelp.QueryError() )
	{
	    (void) nlsHelp.MapCopyTo( pfmshelp->szHelp,
					  sizeof( pfmshelp->szHelp )) ;
	}

	break;

	}
    //
    //  Somebody's pressed F1 on the security menu item selection
    //

    case FMEVENT_HELPMENUITEM:

        {

        err = NERR_Success;

        RESOURCE_STR nlsHelpFile( IDS_AFPMGR_HELPFILENAME );

        if ( err = nlsHelpFile.QueryError() )
        {
            break;
        }

        ULONG hc;

        switch ( lParam )
        {

    	case IDM_FILE_ASSOCIATE:
	    {
	    hc = HC_SFMSERVER_ASSOCIATE;
	    break;
	    }

    	case IDM_VOLUME_CREATE:
	    {
	    hc = HC_SFMSERVER_CREATE_VOLUME;
	    break;
	    }

    	case IDM_VOLUME_EDIT:
	    {
	    hc = HC_SFMSERVER_EDIT_VOLUMES;
	    break;
	    }

    	case IDM_VOLUME_DELETE:
	    {
	    hc = HC_SFMSERVER_REMOVE_VOLUME;
	    break;
	    }

    	case IDM_DIRECTORY_PERMISSIONS:
	    {
	    hc = HC_SFMSERVER_PERMISSIONS;
            break;
	    }

	default:
	    {
	    hc = HC_FILE_MANAGER_CONTENTS;
            break;
	    }
        }

        ::WinHelp( _hWnd, nlsHelpFile, HELP_CONTEXT, hc );

        break;
        }

    default:
	{
    	return 0;
	}
    }

    if ( ( err != NO_ERROR ) && ( err != ERROR_ALREADY_REPORTED ) )
    {
    	::MsgPopup( _hWnd, AFPERR_TO_STRINGID( err ) );
    }

    if ( hServer != NULL )
    {
	::AfpAdminDisconnect( hServer );
    }

    return err;

}  // FMExtensionProcW

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\newvol.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		Copyright(c) Microsoft Corp., 1991  		     **/
/**********************************************************************/

/*
   newvol.cxx
     This file contains the definition of NEW_VOLUME_DIALOG.

   History:
     NarenG		11/18/92	Modified SHARE_DIALOG_BASE for
					AFPMGR
*/

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <ntseapi.h>
#include <nturtl.h>
}

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NET
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#define INCL_NETUSE
#define INCL_NETSHARE
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#include <lmodev.hxx>
#include <lmoshare.hxx>
#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <netname.hxx>

extern "C"
{
#include <mnet.h>
#include <afpmgr.h>
#include <macfile.h>

extern APIERR ConvertRedirectedDriveToLocal( NLS_STR   nlsServer,
					     NLS_STR * pnlsDrive,
					     NLS_STR * pnlsPath  );

extern BOOL IsDriveGreaterThan2Gig( LPWSTR lpwsVolPath,
                                    APIERR *  perr );

}

#include "util.hxx"
#include "perms.hxx"
#include "newvol.hxx"

/*******************************************************************

    NAME:	NEW_VOLUME_SRVMGR_DIALOG::NEW_VOLUME_SRVMGR_DIALOG

    SYNOPSIS:   Constructor for NEW_VOLUME_SRVMGR_DIALOG class

    ENTRY:      hwndParent     - handle of parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

NEW_VOLUME_SRVMGR_DIALOG::NEW_VOLUME_SRVMGR_DIALOG(
					HWND 			hwndParent,
			              	AFP_SERVER_HANDLE 	hServer,
					const TCHAR * 		pszServerName )
    : DIALOG_WINDOW ( MAKEINTRESOURCE(IDD_NEW_VOLUME_DIALOG), hwndParent ),
      _sleVolumeName( this, IDNV_SLE_NAME, AFP_VOLNAME_LEN ),
      _sleVolumePath( this, IDNV_SLE_PATH ),
      _slePassword( this, IDNV_SLE_PASSWORD, AFP_VOLPASS_LEN ),
      _slePasswordConfirm( this, IDNV_SLE_CONFIRM_PASSWORD, AFP_VOLPASS_LEN ),
      _chkReadOnly( this, IDNV_CHK_READONLY ),
      _chkGuestAccess( this, IDNV_CHK_GUEST_ACCESS ),
      _mgrpUserLimit( this, IDNV_RB_UNLIMITED, 2, IDNV_RB_UNLIMITED),
      _spsleUsers( this, IDNV_SLE_USERS,1,1,AFP_VOLUME_UNLIMITED_USES-1,
                   TRUE,IDNV_SLE_USERS_GROUP),
      _spgrpUsers(this,IDNV_SB_USERS_GROUP,IDNV_SB_USERS_UP,IDNV_SB_USERS_DOWN),
      _pbPermissions( this, IDNV_PB_PERMISSIONS ),
      _pbOK( this, IDOK ),
      _pbCancel( this, IDCANCEL ),
      _nlsOwner(),
      _nlsGroup(),
      _hServer( hServer ),
      _nlsServerName( pszServerName ),
      _fCommitDirInfo( FALSE )
{

    AUTO_CURSOR Cursor;

    //
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _mgrpUserLimit.QueryError()) != NERR_Success )
       || ((err = _spgrpUsers.AddAssociation( &_spsleUsers )) != NERR_Success )
       || ((err = _mgrpUserLimit.AddAssociation( IDNV_RB_USERS, &_spgrpUsers ))
	          != NERR_Success )
       || ((err = _chkReadOnly.QueryError()) != NERR_Success )
       || ((err = _chkGuestAccess.QueryError()) != NERR_Success )
       || ((err = _nlsServerName.QueryError()) != NERR_Success )
       || ((err = _nlsOwner.QueryError()) != NERR_Success )
       || ((err = _nlsGroup.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    //
    // Set the caption
    //

    err = ::SetCaption( this, IDS_CAPTION_CREATE_VOLUME, pszServerName );

    if ( err != NO_ERROR )
    {
        ReportError( err );
        return;
    }

    //
    // Set the defaults
    //

    _chkReadOnly.SetCheck( FALSE );
    _chkGuestAccess.SetCheck( TRUE );
    _mgrpUserLimit.SetSelection( IDNV_RB_UNLIMITED );
    _pbPermissions.Enable( FALSE );

}


/*******************************************************************

    NAME:       NEW_VOLUME_SRVMGR_DIALOG::OnCommand

    SYNOPSIS:   Handle the case where the user clicked the permission button

    ENTRY:      event - the CONTROL_EVENT that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

BOOL NEW_VOLUME_SRVMGR_DIALOG::OnCommand( const CONTROL_EVENT &event )
{

    APIERR 	      err;

    if ( event.QueryCid() == IDNV_PB_PERMISSIONS )
    {

	AUTO_CURSOR Cursor;

    	//
    	//  Get the volume path and validate it.
    	//

    	NLS_STR nlsDisplayPath;
    	NLS_STR nlsVolumePath;
    	BOOL	fOk;

    	if ((( err = nlsVolumePath.QueryError() ) != NERR_Success )  ||
    	    (( err = nlsDisplayPath.QueryError() ) != NERR_Success ) ||
    	    (( err = _sleVolumePath.QueryText(&nlsDisplayPath))
						  != NERR_Success ))
	{
            ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

            return FALSE;
	}

	//
	// Validate the path.
	//

    	NET_NAME netname( nlsDisplayPath.QueryPch() );

    	if ( ( err = netname.QueryError() ) != NERR_Success )
    	{
            ::MsgPopup( this, err );

	    SetFocusOnPath();

	    return FALSE;
	}

    	if ( netname.QueryType() == TYPE_PATH_UNC )
    	{
            ::MsgPopup( this, IDS_TYPE_LOCAL_PATH );

	    SetFocusOnPath();

	    return TRUE;
        }

	nlsVolumePath.CopyFrom( nlsDisplayPath );

	_fCommitDirInfo = TRUE;

    	DIRECTORY_PERMISSIONS_DLG *pdlg = new DIRECTORY_PERMISSIONS_DLG(
						QueryHwnd(),
						_hServer,
						_nlsServerName.QueryPch(),
						TRUE,
						nlsVolumePath.QueryPch(),
						nlsDisplayPath.QueryPch(),
						FALSE,
						&_nlsOwner,
						&_nlsGroup,
						&_dwPerms );

        if ( ( pdlg == NULL )
               || (( err = pdlg->QueryError()) != NERR_Success )
               || (( err = pdlg->Process( &fOk )) != NERR_Success )
               )
        {
            err = (pdlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY : err;

            ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
        }

        delete pdlg;

    	if ( ( err != NERR_Success ) || ( !fOk ) )
	{
	    _fCommitDirInfo = FALSE;
	}

        return TRUE;
    }

    //
    // Enable the permissions button if the path string is filled in.
    //

    if ( event.QueryCid() == IDNV_SLE_PATH )
    {
        if ( event.QueryCode() == EN_CHANGE )
        {

            if ( _sleVolumePath.QueryTextLength() > 0 )
            {
            	_pbOK.MakeDefault();

            	_pbPermissions.Enable( TRUE );

            }
            else
            {
            	_pbPermissions.Enable( FALSE );

            	_pbCancel.MakeDefault();

            }
        }

        return TRUE;

    }

    return DIALOG_WINDOW::OnCommand( event );
}

/*******************************************************************

    NAME:	NEW_VOLUME_SRVMGR_DIALOG::OnOK	

    SYNOPSIS:   Validate all the information and create the volume.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

BOOL NEW_VOLUME_SRVMGR_DIALOG::OnOK( VOID )
{
    APIERR err;

    NLS_STR nlsVolumePath;
    NLS_STR nlsVolumeName;
    NLS_STR nlsPassword;
    NLS_STR nlsPasswordConfirm;
    WCHAR   szVolPath[CNLEN+6];
    WCHAR   *wchTemp;

    AUTO_CURSOR Cursor;

    //
    // This is not a loop.
    //

    do {

    	//
    	// Get the volume name.
    	//

    	if ( ( err = nlsVolumeName.QueryError() ) != NERR_Success )
	    break;

    	if ((err = _sleVolumeName.QueryText( &nlsVolumeName )) != NERR_Success)
	    break;

    	//
    	//  Get the volume path.
    	//

    	if ( ( err = nlsVolumePath.QueryError() ) != NERR_Success )
	    break;

    	if (( err = _sleVolumePath.QueryText(&nlsVolumePath)) != NERR_Success)
	    break;

    	//
    	//  Get the password if there is one.
    	//

    	if ( ( err = nlsPassword.QueryError() ) != NERR_Success )
	    break;

    	if ( ( err = _slePassword.QueryText( &nlsPassword )) != NERR_Success )
	    break;

    	//
    	//  Get the password confirmation.
    	//

    	if ( ( err = nlsPasswordConfirm.QueryError() ) != NERR_Success )
	    break;

    	if ( ( err = _slePasswordConfirm.QueryText( &nlsPasswordConfirm ))
							     != NERR_Success )
	    break;

    }while( FALSE );


    if ( err != NERR_Success )
    {
        ::MsgPopup( this,  err );

    	return TRUE;
    }

    //
    // Set up the volume structure
    //

    AFP_VOLUME_INFO AfpVolume;

    if ( nlsVolumeName.strlen() > 0 )
    {
    	//
    	// Validate the volume name
    	//

        ISTR istr( nlsVolumeName );

        if ( nlsVolumeName.strchr( &istr, TEXT(':') ) )
        {
	    ::MsgPopup( this, IDS_AFPERR_InvalidVolumeName );

	    SetFocusOnName();

	    return FALSE;
	}

    	AfpVolume.afpvol_name = (LPWSTR)(nlsVolumeName.QueryPch());
    }
    else
    {
        ::MsgPopup( this, IDS_NEED_VOLUME_NAME  );

	SetFocusOnName();

    	return TRUE;
    }

    //
    // Validate the path.
    //

    NET_NAME netname( nlsVolumePath.QueryPch() );

    if ( ( err = netname.QueryError() ) != NERR_Success )
    {
        ::MsgPopup( this, err );

	SetFocusOnPath();

	return TRUE;
    }

    if ( netname.QueryType() == TYPE_PATH_UNC )
    {
        ::MsgPopup( this, IDS_TYPE_LOCAL_PATH );

	    SetFocusOnPath();

	    return TRUE;
    }


    ::wcscpy(szVolPath, _nlsServerName.QueryPch());

    wchTemp = szVolPath + wcslen(szVolPath);
    *wchTemp++ = TEXT('\\');
    *wchTemp++ = (nlsVolumePath.QueryPch())[0];
    *wchTemp++ = TEXT('$');
    *wchTemp++ = TEXT('\\');
    *wchTemp++ = 0;

    BOOL fDriveGreaterThan2Gig = ::IsDriveGreaterThan2Gig( (LPWSTR)(szVolPath), &err );

    if ( err != NERR_Success )
    {
        ::MsgPopup( this, err );

	    SetFocusOnPath();

    	return TRUE;
    }

    if ( fDriveGreaterThan2Gig )
    {
        if ( ::MsgPopup( this,
                         IDS_VOLUME_TOO_BIG,
                         MPSEV_WARNING,
                         MP_YESNO,
                         MP_NO ) == IDNO )
        {
	        SetFocusOnPath();

	        return TRUE;
        }
    }

    AfpVolume.afpvol_path = (LPWSTR)(nlsVolumePath.QueryPch());

    //
    // Make sure the passwords match.
    //

    if ( nlsPassword.strcmp( nlsPasswordConfirm ) )
    {
    	::MsgPopup( this, IDS_PASSWORD_MISMATCH  );

	SetFocusOnPasswordConfirm();

    	return TRUE;
    }

    if ( nlsPassword.strlen() > 0 )
    {
    	AfpVolume.afpvol_password = (LPWSTR)(nlsPassword.QueryPch());
    }
    else
    {
    	AfpVolume.afpvol_password = (LPWSTR)NULL;
    }


    AfpVolume.afpvol_props_mask = _chkReadOnly.QueryCheck()
				  ? AFP_VOLUME_READONLY
				  : 0;

    AfpVolume.afpvol_props_mask = _chkGuestAccess.QueryCheck()
			? (AFP_VOLUME_GUESTACCESS | AfpVolume.afpvol_props_mask)
			: AfpVolume.afpvol_props_mask;


    AfpVolume.afpvol_max_uses = QueryUserLimit();

    //
    //  Try to create the volume.
    //

    err = ::AfpAdminVolumeAdd( _hServer, (LPBYTE)&AfpVolume );

    if ( err != NO_ERROR )
    {
        ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	SetFocusOnPath();

	return FALSE;
    }

    //
    // If the user mucked around with the root directory's permissions
    // the we have to set it.
    //

    if ( _fCommitDirInfo )
    {
	AFP_DIRECTORY_INFO AfpDirInfo;

    	AfpDirInfo.afpdir_path  = (LPWSTR)nlsVolumePath.QueryPch();

    	AfpDirInfo.afpdir_owner = (LPWSTR)_nlsOwner.QueryPch();

    	AfpDirInfo.afpdir_group = (LPWSTR)_nlsGroup.QueryPch();

    	AfpDirInfo.afpdir_perms = _dwPerms;

    	err = ::AfpAdminDirectorySetInfo( _hServer,
				          (LPBYTE)&AfpDirInfo,
					  AFP_DIR_PARMNUM_ALL );
    }
    else
    {
	
	//
	// User did not muck arount with the permissions, so we have
	// to get and reset the current permissions. This is requred
	// to remove everyone as the owner.
	//

    	PAFP_DIRECTORY_INFO pAfpDirInfo;

    	err = ::AfpAdminDirectoryGetInfo( _hServer,
				      	  (LPWSTR)nlsVolumePath.QueryPch(),
				      	  (LPBYTE*)&pAfpDirInfo );

	if ( err == NO_ERROR )
	{
            DWORD dwParmNum = AFP_DIR_PARMNUM_PERMS;

    	    pAfpDirInfo->afpdir_path = (LPWSTR)(nlsVolumePath.QueryPch());

    	    if ( pAfpDirInfo->afpdir_owner != (LPWSTR)NULL )
            {
                dwParmNum |= AFP_DIR_PARMNUM_OWNER;
            }

    	    if ( pAfpDirInfo->afpdir_group != (LPWSTR)NULL )
            {
                dwParmNum |= AFP_DIR_PARMNUM_GROUP;
            }

    	    err = ::AfpAdminDirectorySetInfo( _hServer,
				              (LPBYTE)pAfpDirInfo,
                                              dwParmNum );

	    ::AfpAdminBufferFree( pAfpDirInfo );
	}

    }


    switch( err )
    {
    case NO_ERROR:
    case AFPERR_SecurityNotSupported:
        Dismiss( TRUE );
	break;

    case AFPERR_NoSuchUser:
    case AFPERR_NoSuchGroup:
    case AFPERR_NoSuchUserGroup:
    case ERROR_NONE_MAPPED:

   	::MsgPopup( this, IDS_INVALID_DIR_ACCOUNT, MPSEV_INFO );

	Dismiss( TRUE );
	break;

    case AFPERR_UnsupportedFS:

        //
        // Ignore this error
        //
        Dismiss( TRUE );
        break;

    default:

	::AfpAdminVolumeDelete( _hServer, (LPWSTR)(nlsVolumeName.QueryPch()));

        ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	break;
    }

    return TRUE;
}


/*******************************************************************

    NAME:	NEW_VOLUME_SRVMGR_DIALOG::QueryUserLimit

    SYNOPSIS:   Get the user limit from the magic group

    ENTRY:

    EXIT:

    RETURNS:    The user limit stored in the user limit magic group

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

DWORD NEW_VOLUME_SRVMGR_DIALOG::QueryUserLimit( VOID ) const
{

    switch ( _mgrpUserLimit.QuerySelection() )
    {

    case IDNV_RB_UNLIMITED:

    	return( AFP_VOLUME_UNLIMITED_USES );

    case IDNV_RB_USERS:

        return( _spsleUsers.QueryValue() );

    default:

	//	
	// Should never get here but in case we do, return unlimited
	//

        return( AFP_VOLUME_UNLIMITED_USES );
    }

}

/*******************************************************************

    NAME:	NEW_VOLUME_SRVMGR_DIALOG::QueryHelpContext	

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

ULONG NEW_VOLUME_SRVMGR_DIALOG::QueryHelpContext( VOID )
{
    return HC_NEW_VOLUME_SRVMGR_DIALOG;
}

/*******************************************************************

    NAME:	NEW_VOLUME_FILEMGR_DIALOG::NEW_VOLUME_FILEMGR_DIALOG

    SYNOPSIS:   Constructor for NEW_VOLUME_FILEMGR_DIALOG class

    ENTRY:      hwndParent     - handle of parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

NEW_VOLUME_FILEMGR_DIALOG::NEW_VOLUME_FILEMGR_DIALOG(
					HWND 		hwndParent,
				      	const TCHAR *  	pszPath,
				      	BOOL		fIsFile )
    : DIALOG_WINDOW ( MAKEINTRESOURCE(IDD_NEW_VOLUME_DIALOG), hwndParent ),
      _sleVolumeName( this, IDNV_SLE_NAME, AFP_VOLNAME_LEN ),
      _sleVolumePath( this, IDNV_SLE_PATH ),
      _slePassword( this, IDNV_SLE_PASSWORD, AFP_VOLPASS_LEN ),
      _slePasswordConfirm( this, IDNV_SLE_CONFIRM_PASSWORD, AFP_VOLPASS_LEN ),
      _chkReadOnly( this, IDNV_CHK_READONLY ),
      _chkGuestAccess( this, IDNV_CHK_GUEST_ACCESS ),
      _mgrpUserLimit( this, IDNV_RB_UNLIMITED, 2, IDNV_RB_UNLIMITED),
      _spsleUsers( this, IDNV_SLE_USERS,1,1,AFP_VOLUME_UNLIMITED_USES-1,
                   TRUE,IDNV_SLE_USERS_GROUP),
      _spgrpUsers(this,IDNV_SB_USERS_GROUP,IDNV_SB_USERS_UP,IDNV_SB_USERS_DOWN),
      _pbPermissions( this, IDNV_PB_PERMISSIONS ),
      _pbOK( this, IDOK ),
      _pbCancel( this, IDCANCEL ),
      _nlsOwner(),
      _nlsGroup(),
      _fCommitDirInfo( FALSE )
{

    AUTO_CURSOR Cursor;

    //
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _mgrpUserLimit.QueryError()) != NERR_Success )
       || ((err = _spgrpUsers.AddAssociation( &_spsleUsers )) != NERR_Success )
       || ((err = _mgrpUserLimit.AddAssociation( IDNV_RB_USERS, &_spgrpUsers ))
	          != NERR_Success )
       || ((err = _chkReadOnly.QueryError()) != NERR_Success )
       || ((err = _chkGuestAccess.QueryError()) != NERR_Success )
       || ((err = _nlsOwner.QueryError()) != NERR_Success )
       || ((err = _nlsGroup.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    //
    // Set the defaults
    //

    _chkReadOnly.SetCheck( FALSE );
    _chkGuestAccess.SetCheck( TRUE );
    _mgrpUserLimit.SetSelection( IDNV_RB_UNLIMITED );
    _pbPermissions.Enable( FALSE );

    //
    //  Set the volumename and path if the path drive is NTFS
    //

    NLS_STR nlsVolumePath( pszPath );
    NLS_STR nlsVolumeName;
    NLS_STR nlsUNCPath;

    if ( (( err = nlsVolumePath.QueryError() ) != NERR_Success ) ||
         (( err = nlsVolumeName.QueryError() ) != NERR_Success ) ||
         (( err = nlsUNCPath.QueryError() ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    err = ValidateVolumePath( nlsVolumePath.QueryPch() );

    if ( ( err != NO_ERROR ) && ( err != AFPERR_UnsupportedFS ) )
    {
        ReportError( err );
        return;
    }

    //
    // If the drive is an NTFS/CDFS drive, then set the volume name and path
    //

    if ( err == NO_ERROR )
    {

    	//
    	// If this is a file then we need to remove the file name from the
    	// path.
    	//

    	if ( fIsFile )
    	{
            ISTR istrVolumePath( nlsVolumePath );

	    if ( nlsVolumePath.strrchr( &istrVolumePath, TEXT('\\') ))
	    {
	    	nlsVolumePath.DelSubStr( istrVolumePath );
	    }
        }

	//
	// Extract the last component of the path and use it to set the
	// volume name
	//

	nlsVolumeName = nlsVolumePath;

        ISTR istrStart( nlsVolumeName );
        ISTR istrEnd( nlsVolumeName );

	if ( nlsVolumeName.strrchr( &istrEnd, TEXT('\\') ))
	{
	    nlsVolumeName.DelSubStr( istrStart, ++istrEnd );
	}

	if ( nlsVolumeName.QueryTextLength() <= AFP_VOLNAME_LEN )
    	    _sleVolumeName.SetText( nlsVolumeName );

	//
	// Ok, if the drive is remote then we need to display the UNC path
	//

   	NET_NAME netname( nlsVolumePath );

	if ( ( err = netname.QueryError() ) != NERR_Success )
	{
	    ReportError( err );
	    return;
	}

	BOOL fIsLocal = netname.IsLocal( &err );

	if ( err != NERR_Success )
	{
	    ReportError( err );
	    return;
	}

	if ( fIsLocal )
	{
    	    _sleVolumePath.SetText( nlsVolumePath );
	}
   	else
	{
	    if ( ( err = netname.QueryUNCPath( &nlsUNCPath ) ) != NERR_Success )
	    {
	    	ReportError( err );
	    	return;
	    }

    	    _sleVolumePath.SetText( nlsUNCPath );

	}

    	_pbPermissions.Enable( TRUE );

	_sleVolumeName.SelectString();

    	SetFocusOnName();
    }
}


/*******************************************************************

    NAME:       NEW_VOLUME_FILEMGR_DIALOG::OnCommand

    SYNOPSIS:   Handle the case where the user clicked the permission button

    ENTRY:      event - the CONTROL_EVENT that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

BOOL NEW_VOLUME_FILEMGR_DIALOG::OnCommand( const CONTROL_EVENT &event )
{

    APIERR 	      err;
    AFP_SERVER_HANDLE hServer = NULL;

    if ( event.QueryCid() == IDNV_PB_PERMISSIONS )
    {

        AUTO_CURSOR Cursor;

    	//
    	//  Get the volume path and validate it.
    	//

    	NLS_STR nlsDisplayPath;
    	NLS_STR nlsVolumePath;
	NLS_STR nlsComputerName;
	NLS_STR nlsDrive;
    	BOOL	fOk;

    	if ((( err = nlsVolumePath.QueryError() )   != NERR_Success )  ||
    	    (( err = nlsComputerName.QueryError() ) != NERR_Success )  ||
    	    (( err = nlsDrive.QueryError() ) 	    != NERR_Success )  ||
    	    (( err = nlsDisplayPath.QueryError() )  != NERR_Success )  ||
    	    (( err = _sleVolumePath.QueryText(&nlsDisplayPath))
						  != NERR_Success ))
	{
            ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

            return FALSE;
	}

	//
	// If the path is not local then we need to get the local
	// path.
   	//

    	NET_NAME netname( nlsDisplayPath.QueryPch() );

    	if ( ( err = netname.QueryError() ) != NERR_Success )
    	{
            ::MsgPopup( this, err );
	    return FALSE;
        }

	BOOL fIsLocal = netname.IsLocal( &err );

	if ( err != NERR_Success )
    	{
            ::MsgPopup( this, err );
	    return FALSE;
	}

	//
	// Get the computer name for this volume
	//

	if ((err = netname.QueryComputerName(&nlsComputerName)) != NERR_Success)
    	{
	    if ( err == NERR_InvalidDevice )
	    {
	    	err = ERROR_INVALID_DRIVE;
	    }

            ::MsgPopup( this, err );

	    return FALSE;
	}

	if ((!fIsLocal) || (fIsLocal && (netname.QueryType() == TYPE_PATH_UNC)))
	{
	    //
	    // If the path is remote get the absolute path with
	    // the drive letter.
	    //

	    err = netname.QueryLocalPath( &nlsVolumePath );
	
	    if ( err != NERR_Success )
	    {
            	::MsgPopup( this, err );

	    	SetFocusOnPath();

	    	return FALSE;
	    }
   	}
	else
	{
    	    //
    	    // If the path happens to be a loopback redirected drive then we
	    // replace
    	    // the redirected drive with the action drive.
    	    //

    	    if ( (err = netname.QueryDrive( &nlsDrive )) != NERR_Success )
    	    {
        	::MsgPopup( this, err );

		SetFocusOnPath();

		return TRUE;
    	    }

	    nlsVolumePath.CopyFrom( nlsDisplayPath );

    	    if ( (err=::ConvertRedirectedDriveToLocal(
					nlsComputerName,
					&nlsDrive,
					&nlsVolumePath ))!= NERR_Success )
    	    {
    		::MsgPopup( this, err );

		SetFocusOnPath();

		return FALSE;
	    }

	}

	if ( ( err = ::AfpAdminConnect((LPWSTR)(nlsComputerName.QueryPch()),
					&hServer ) ) != NO_ERROR )
	{
            ::MsgPopup( this, err );
	    SetFocusOnPath();
	    return FALSE;
	}

	_fCommitDirInfo = TRUE;

    	DIRECTORY_PERMISSIONS_DLG *pdlg = new DIRECTORY_PERMISSIONS_DLG(
						QueryHwnd(),
						hServer,
						NULL,
						FALSE,
						nlsVolumePath.QueryPch(),
						nlsDisplayPath.QueryPch(),
						FALSE,
						&_nlsOwner,
						&_nlsGroup,
						&_dwPerms );

        if ( ( pdlg == NULL )
               || (( err = pdlg->QueryError()) != NERR_Success )
               || (( err = pdlg->Process( &fOk )) != NERR_Success )
               )
        {
            err = (pdlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY : err;

            ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
        }

        delete pdlg;

    	if ( ( err != NERR_Success ) || ( !fOk ) )
	{
	    _fCommitDirInfo = FALSE;
	}

	if ( hServer != NULL )
	{
	    ::AfpAdminDisconnect( hServer );
	}

        return TRUE;
    }

    //
    // Enable the permissions button if the path string is filled in.
    //

    if ( event.QueryCid() == IDNV_SLE_PATH )
    {
        if ( event.QueryCode() == EN_CHANGE )
        {

            if ( _sleVolumePath.QueryTextLength() > 0 )
            {
            	_pbOK.MakeDefault();

            	_pbPermissions.Enable( TRUE );

            }
            else
            {
            	_pbPermissions.Enable( FALSE );

            	_pbCancel.MakeDefault();

            }
        }

        return TRUE;

    }

    return DIALOG_WINDOW::OnCommand( event );
}

/*******************************************************************

    NAME:	NEW_VOLUME_FILEMGR_DIALOG::OnOK	

    SYNOPSIS:   Validate all the information and create the volume.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

BOOL NEW_VOLUME_FILEMGR_DIALOG::OnOK( VOID )
{
    APIERR err;

    NLS_STR nlsVolumePath;
    NLS_STR nlsVolumeName;
    NLS_STR nlsPassword;
    NLS_STR nlsPasswordConfirm;
    NLS_STR nlsComputerName;
    NLS_STR nlsDrive;
    AFP_SERVER_HANDLE hServer = NULL;

    AUTO_CURSOR Cursor;

    //
    // This is not a loop.
    //

    do {

    	if ( ( err = nlsComputerName.QueryError() ) != NERR_Success )
	    break;

    	if ( ( err = nlsDrive.QueryError() ) != NERR_Success )
	    break;

    	//
    	// Get the volume name.
    	//

    	if ( ( err = nlsVolumeName.QueryError() ) != NERR_Success )
	    break;

    	if ((err = _sleVolumeName.QueryText( &nlsVolumeName )) != NERR_Success)
	    break;

    	//
    	//  Get the volume path.
    	//

    	if ( ( err = nlsVolumePath.QueryError() ) != NERR_Success )
	    break;

    	if (( err = _sleVolumePath.QueryText(&nlsVolumePath)) != NERR_Success)
	    break;

    	//
    	//  Get the password if there is one.
    	//

    	if ( ( err = nlsPassword.QueryError() ) != NERR_Success )
	    break;

    	if ( ( err = _slePassword.QueryText( &nlsPassword )) != NERR_Success )
	    break;

    	//
    	//  Get the password confirmation.
    	//

    	if ( ( err = nlsPasswordConfirm.QueryError() ) != NERR_Success )
	    break;

    	if ( ( err = _slePasswordConfirm.QueryText( &nlsPasswordConfirm ))
							     != NERR_Success )
	    break;


    }while( FALSE );


    if ( err != NERR_Success )
    {
        ::MsgPopup( this,  err );

    	return TRUE;
    }

    //
    // Set up the volume structure
    //

    AFP_VOLUME_INFO AfpVolume;

    if ( nlsVolumeName.strlen() > 0 )
    {
    	//
    	// Validate the volume name
    	//

        ISTR istr( nlsVolumeName );

        if ( nlsVolumeName.strchr( &istr, TEXT(':') ) )
        {
	    ::MsgPopup( this, IDS_AFPERR_InvalidVolumeName );

	    SetFocusOnName();

	    return FALSE;
	}

    	AfpVolume.afpvol_name = (LPWSTR)(nlsVolumeName.QueryPch());
    }
    else
    {
        ::MsgPopup( this, IDS_NEED_VOLUME_NAME  );

	SetFocusOnName();

    	return TRUE;
    }

    //
    // If the path is not local then we need to get the local
    // path.
    //

    NET_NAME netname( nlsVolumePath.QueryPch() );

    if ( ( err = netname.QueryError() ) != NERR_Success )
    {
     	::MsgPopup( this, err );

	SetFocusOnPath();

	return TRUE;
    }

    BOOL fIsLocal = netname.IsLocal( &err );

    if ( err != NERR_Success )
    {
     	::MsgPopup( this, err );

	SetFocusOnPath();

	return TRUE;
    }

    if ( (err = netname.QueryComputerName( &nlsComputerName )) != NERR_Success)
    {
	if ( err == NERR_InvalidDevice )
	{
	    err = ERROR_INVALID_DRIVE;
	}

    	::MsgPopup( this, err );

	SetFocusOnPath();

	return FALSE;
    }

    BOOL fDriveGreaterThan2Gig = ::IsDriveGreaterThan2Gig( (LPWSTR)(nlsVolumePath.QueryPch()),
                                                            &err );

    if ( err != NERR_Success )
    {
        ::MsgPopup( this, err );

	    SetFocusOnPath();

    	return TRUE;
    }

    if ( (!fIsLocal) || (fIsLocal && (netname.QueryType() == TYPE_PATH_UNC)))
    {
    	//
    	// If the path is remote then get the absolute path and drive letter.
    	//

    	err = netname.QueryLocalPath( &nlsVolumePath );
	
    	if ( err != NERR_Success )
    	{
    	    ::MsgPopup( this, err );

	    SetFocusOnPath();

	    return FALSE;
	}
    }
    else
    {

        //
    	// If the path happens to be a loopback redirected drive then we
	// replace
    	// the redirected drive with the action drive.
    	//

    	if ( (err = netname.QueryDrive( &nlsDrive )) != NERR_Success )
    	{
            ::MsgPopup( this, err );

	        SetFocusOnPath();

	        return TRUE;
    	}

    	if ( (err=::ConvertRedirectedDriveToLocal(
					nlsComputerName,
					&nlsDrive,
					&nlsVolumePath )) != NERR_Success )
    	{
    	    ::MsgPopup( this, err );

	        SetFocusOnPath();

	        return FALSE;
	    }
    }

    if ( fDriveGreaterThan2Gig )
    {
        if ( ::MsgPopup( this,
                         IDS_VOLUME_TOO_BIG,
                         MPSEV_WARNING,
                         MP_YESNO,
                         MP_NO ) == IDNO )
        {
	        SetFocusOnPath();

	        return TRUE;
        }
    }

    AfpVolume.afpvol_path = (LPWSTR)(nlsVolumePath.QueryPch());


    if ( nlsPassword.strcmp( nlsPasswordConfirm ) )
    {
    	::MsgPopup( this, IDS_PASSWORD_MISMATCH  );

	SetFocusOnPasswordConfirm();

    	return TRUE;
    }

    if ( nlsPassword.strlen() > 0 )
    {
    	AfpVolume.afpvol_password = (LPWSTR)(nlsPassword.QueryPch());
    }
    else
    {
    	AfpVolume.afpvol_password = (LPWSTR)NULL;
    }


    AfpVolume.afpvol_props_mask = _chkReadOnly.QueryCheck()
				  ? AFP_VOLUME_READONLY
				  : 0;

    AfpVolume.afpvol_props_mask = _chkGuestAccess.QueryCheck()
			? (AFP_VOLUME_GUESTACCESS | AfpVolume.afpvol_props_mask)
			: AfpVolume.afpvol_props_mask;


    AfpVolume.afpvol_max_uses = QueryUserLimit();

    //
    //  Try to create the volume.
    //

    err = ::AfpAdminConnect((LPWSTR)(nlsComputerName.QueryPch()), &hServer );

    if ( err == NO_ERROR )
    {
    	err = ::AfpAdminVolumeAdd( hServer, (LPBYTE)&AfpVolume );
    }

    if ( err == NO_ERROR )
    {
	//
	// If the user mucked around with the root directory's permissions
	// the we have to set it.
	//

 	if ( _fCommitDirInfo )
	{
	    AFP_DIRECTORY_INFO AfpDirInfo;

    	    AfpDirInfo.afpdir_path  = (LPWSTR)(nlsVolumePath.QueryPch());

    	    AfpDirInfo.afpdir_owner = (LPWSTR)(_nlsOwner.QueryPch());

    	    AfpDirInfo.afpdir_group = (LPWSTR)(_nlsGroup.QueryPch());

    	    AfpDirInfo.afpdir_perms = _dwPerms;

    	    err = ::AfpAdminDirectorySetInfo( hServer,
				              (LPBYTE)&AfpDirInfo,
					      AFP_DIR_PARMNUM_ALL );
	}
     	else
    	{
	
	    //
	    // User did not muck arount with the permissions, so we have
	    // to get and reset the current permissions. This is requred
	    // to remove everyone as the owner.
	    //

    	    PAFP_DIRECTORY_INFO pAfpDirInfo;

    	    err = ::AfpAdminDirectoryGetInfo(hServer,
				      	     (LPWSTR)(nlsVolumePath.QueryPch()),
				      	     (LPBYTE*)&pAfpDirInfo );

	    if ( err == NO_ERROR )
	    {
                DWORD dwParmNum = AFP_DIR_PARMNUM_PERMS;

		pAfpDirInfo->afpdir_path = (LPWSTR)(nlsVolumePath.QueryPch());

    	        if ( pAfpDirInfo->afpdir_owner != (LPWSTR)NULL )
                {
                    dwParmNum |= AFP_DIR_PARMNUM_OWNER;
                }

    	        if ( pAfpDirInfo->afpdir_group != (LPWSTR)NULL )
                {
                    dwParmNum |= AFP_DIR_PARMNUM_GROUP;
                }

    	    	err = ::AfpAdminDirectorySetInfo( hServer,
				              	  (LPBYTE)pAfpDirInfo,
                                                  dwParmNum );

	    	::AfpAdminBufferFree( pAfpDirInfo );
	    }
	}

    	switch( err )
        {
    	case NO_ERROR:
	    break;

    	case AFPERR_SecurityNotSupported:
	    err = NO_ERROR;
	    break;

    	case AFPERR_NoSuchUser:
    	case AFPERR_NoSuchGroup:
    	case AFPERR_NoSuchUserGroup:
    	case ERROR_NONE_MAPPED:

	    err = NO_ERROR;

   	    ::MsgPopup( this, IDS_INVALID_DIR_ACCOUNT, MPSEV_INFO );

	    break;

        case AFPERR_UnsupportedFS:

            //
            // Ignore this error
            //

            err = NO_ERROR;

            break;

    	default:

	    ::AfpAdminVolumeDelete( hServer,
				    (LPWSTR)(nlsVolumeName.QueryPch()));
	    break;
        }


    }

    if ( hServer != NULL )
    {
	::AfpAdminDisconnect( hServer );
    }

    if ( err == NO_ERROR )
    {
        Dismiss( TRUE );
    }
    else
    {
        ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	SetFocusOnPath();
    }

    return TRUE;
}


/*******************************************************************

    NAME:	NEW_VOLUME_FILEGMR_DIALOG::QueryUserLimit

    SYNOPSIS:   Get the user limit from the magic group

    ENTRY:

    EXIT:

    RETURNS:    The user limit stored in the user limit magic group

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

DWORD NEW_VOLUME_FILEMGR_DIALOG::QueryUserLimit( VOID ) const
{

    switch ( _mgrpUserLimit.QuerySelection() )
    {

    case IDNV_RB_UNLIMITED:

    	return( AFP_VOLUME_UNLIMITED_USES );

    case IDNV_RB_USERS:

        return( _spsleUsers.QueryValue() );

    default:

	//	
	// Should never get here but in case we do, return unlimited
	//

        return( AFP_VOLUME_UNLIMITED_USES );
    }

}

/*******************************************************************

    NAME:	NEW_VOLUME_FILEMGR_DIALOG::ValidateVolumePath	

    SYNOPSIS:   Validates the volume path. It makes sure that the
		the path syntax is valid and the volume of the drive
		is either NTFS or CDFS.

    ENTRY:	pszPath 	- Pointer to the volume path

    EXIT:

    RETURNS:    Any error encountered. (Path syntax is invalid etc)

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

DWORD NEW_VOLUME_FILEMGR_DIALOG::ValidateVolumePath( const WCHAR * pszPath )
{
    WCHAR   wchDrive[5];
    DWORD   dwMaxCompSize;
    DWORD   dwFlags;
    WCHAR   wchFileSystem[10];
    DWORD   err = NO_ERROR;

    NET_NAME Path( pszPath );

    if ( ( err = Path.QueryError() ) != NERR_Success )
    {
	return err;
    }


    // Get the drive letter, : and backslash
    //
    ::ZeroMemory( wchDrive, sizeof( wchDrive ) );

    ::wcsncpy( wchDrive, pszPath, 3 );

    if ( !( ::GetVolumeInformation( (LPWSTR)wchDrive,
			          NULL,
			          0,
 			          NULL,
			          &dwMaxCompSize,
			          &dwFlags,
				  (LPWSTR)wchFileSystem,
				  sizeof( wchFileSystem ) ) ) ){
	return GetLastError();
    }

    if ( ( ::_wcsicmp( wchFileSystem, SZ("NTFS") ) == 0 ) ||
	 ( ::_wcsicmp( wchFileSystem, SZ("CDFS") ) == 0 ) ||
	 ( ::_wcsicmp( wchFileSystem, SZ("AHFS") ) == 0 ) )
   	return( NO_ERROR );
    else
	return( (DWORD)AFPERR_UnsupportedFS );
	
}

/*******************************************************************

    NAME:	NEW_VOLUME_FILEMGR_DIALOG::QueryHelpContext	

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

ULONG NEW_VOLUME_FILEMGR_DIALOG::QueryHelpContext( VOID )
{
    return HC_NEW_VOLUME_FILEMGR_DIALOG;
}

/*******************************************************************

    NAME:	::ConvertRedirectedDriveToLocal

    SYNOPSIS:   Determines if a drive is a loopback redirected drive or
		not. If it is, then the redirected drive is changed to
		the local drive.

    ENTRY:

    EXIT:

    RETURNS:    NERR_Success - Success
		Non zero return codes - failure

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

APIERR ConvertRedirectedDriveToLocal( 	NLS_STR   nlsServer,
				 	NLS_STR * pnlsDrive,
					NLS_STR * pnlsPath  )
{
    PBYTE pBuf;
    APIERR err;
    NLS_STR nlsDrive;

    if ( ( err = nlsDrive.QueryError() ) != NERR_Success )
    {
	return err;
    }

    err = ::MNetUseGetInfo(nlsServer.QueryPch(),pnlsDrive->QueryPch(),1,&pBuf);

    if ( err != NERR_Success )
    {
	if ( err == NERR_UseNotFound )
	    return NERR_Success;
	else
	    return err;
    }

    NET_NAME netname( ((PUSE_INFO_0)pBuf)->ui0_remote );

    ::MNetApiBufferFree( &pBuf );

    if ( ( err = netname.QueryError() ) != NERR_Success )
    {
	return err;
    }

    if ( ( err = netname.QueryLocalPath( pnlsPath ) ) != NERR_Success )
    {
	return err;
    }

    return( NERR_Success );

}


/*******************************************************************

    NAME:	::IsDriveGreaterThan2Gig

    SYNOPSIS:	Determines if the disk is bigger than 2Gig.  If it, return
		TRUE so that a warning can be displayed to the user

    RETURNS:	TRUE if disk is larger than 2Gig
		FALSE otherwise

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

BOOL IsDriveGreaterThan2Gig( LPWSTR lpwsVolPath,
                             APIERR * perr    )
{
    DWORD         SectorsPerCluster;
    DWORD         BytesPerSector;
    DWORD         NumberOfFreeClusters;
    DWORD         TotalNumberOfClusters;
    LARGE_INTEGER DriveSize;
    LARGE_INTEGER TwoGig = { MAXLONG, 0 };
    LPWSTR        lpwsPath;
    LPWSTR        lpwsTmp;


    //
    // If this drive volume is greater than 2G then we print warning
    //

    *perr = NERR_Success;

    lpwsPath = (LPWSTR)::LocalAlloc( LPTR, (::wcslen(lpwsVolPath) + 2)*sizeof(WCHAR));
    if (lpwsPath == NULL)
    {
        *perr = ERROR_NOT_ENOUGH_MEMORY;
        return( TRUE );
    }
    ::wcscpy(lpwsPath, lpwsVolPath);

    // if this is a unc path of the type \\foo\bar\path\name then we must
    // generate a string that is "\\foo\bar\"
    if ( lpwsPath[0] == TEXT('\\') && lpwsPath[1] == TEXT('\\'))
    {
        lpwsTmp = lpwsPath;
        lpwsTmp++;
        lpwsTmp++;            // point to f in \\foo\bar\path\name
        lpwsTmp = ::wcschr(lpwsTmp, TEXT('\\'));
        lpwsTmp++;            // point to b in \\foo\bar\path\name
        lpwsTmp = ::wcschr(lpwsTmp, TEXT('\\'));

        // if the path is \\foo\bar\path\name then
        if (lpwsTmp != NULL)
        {
            lpwsTmp++;
        }
        // else if the path is just \\foo\bar then
        else
        {
            lpwsTmp = lpwsPath + ::wcslen(lpwsPath);
            if ( *(lpwsTmp-1) != TEXT('\\'))
            {
                *lpwsTmp = TEXT('\\');
                lpwsTmp++;
            }
        }

        *(lpwsTmp) = 0;
    }

    // else if this is a local path of the type c:\foo\bar\path\name then
    // we must generate a string that is "c:\"
    else if (lpwsPath[1] == TEXT(':'))
    {
        lpwsPath[2] = TEXT('\\');
        lpwsPath[3] = 0;
    }

    // huh??  how did this happen?
    else
    {
        *perr = ERROR_INVALID_DRIVE;
        ::LocalFree(lpwsPath);
        return( TRUE );
    }

    if ( !::GetDiskFreeSpace( lpwsPath,
                              &SectorsPerCluster,
                              &BytesPerSector,
                              &NumberOfFreeClusters,
                              &TotalNumberOfClusters
                            ))
    {
        ::LocalFree(lpwsPath);

        // call failed: it's not fatal, treat it like disk size is ok
	    return FALSE;
    }

    ::LocalFree(lpwsPath);

    DriveSize = RtlEnlargedIntegerMultiply( SectorsPerCluster * BytesPerSector,
                                            TotalNumberOfClusters ) ;


    if ( DriveSize.QuadPart > TwoGig.QuadPart )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\curusers.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    curusers.cxx
      Contain the dialog for enumerating current users to a volume

    FILE HISTORY:
      NarenG         11/13/92        Modified for AFPMGR
*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}

#include <string.hxx>
#include <uitrace.hxx>
#include <ellipsis.hxx>

#include <strnumer.hxx>

#include <ctime.hxx>
#include <intlprof.hxx>

#include "curusers.hxx"

/*******************************************************************

    NAME:       CURRENT_USERS_WARNING_DIALOG::CURRENT_USERS_WARNING_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of Parent Window
		pAfpConnections   - pointer to a list of current users.
		nConnections 	  - number of current users
                pszServerName     - Server Name
                pszvolumeName     - volume Name
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
      NarenG         11/13/92        Modified for AFPMGR

********************************************************************/

CURRENT_USERS_WARNING_DIALOG::CURRENT_USERS_WARNING_DIALOG(
				HWND 			hwndParent,
				AFP_SERVER_HANDLE	hServer,
				PAFP_CONNECTION_INFO  	pAfpConnections,
				DWORD			nConnections,
                                const TCHAR 		*pszVolumeName )
    : DIALOG_WINDOW( IDD_CURRENT_USERS_WARNING_DLG, hwndParent ),
      _sltVolumeText( this, IDCU_SLT_VOL_TEXT ),
      _lbUsers( this, IDCU_LB_CURRENT_USERS ),
      _hServer( hServer )
{

    //
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;

    ALIAS_STR nlsVolume( pszVolumeName );

    RESOURCE_STR nlsVolumeText( IDS_VOLUME_CURRENT_USERS_TEXT );

    if (( err = nlsVolumeText.InsertParams( nlsVolume )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _sltVolumeText.SetText( nlsVolumeText );

    err = BASE_ELLIPSIS::Init();

    if( err != NO_ERROR )
    {
        ReportError( err );
	return;
    }

    if ( ( err = _lbUsers.Fill( pAfpConnections,
				nConnections) ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       CURRENT_USERS_WARNING_DIALOG :: ~CURRENT_USERS_WARNING_DIALOG

    SYNOPSIS:   CURRENT_USERS_WARNING_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
CURRENT_USERS_WARNING_DIALOG :: ~CURRENT_USERS_WARNING_DIALOG()
{
    BASE_ELLIPSIS::Term();

}   // CURRENT_USERS_WARNING_DIALOG :: ~CURRENT_USERS_WARNING_DIALOG

/*******************************************************************

    NAME:       CURRENT_USERS_WARNING_DIALOG::QueryHelpContext

    SYNOPSIS:   Get the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Returns the help context

    NOTES:

    HISTORY:
      NarenG         11/13/92        Modified for AFPMGR

********************************************************************/

ULONG CURRENT_USERS_WARNING_DIALOG::QueryHelpContext( VOID )
{
    return HC_CURRENT_USERS_WARNING_DIALOG;
}

/*******************************************************************

    NAME:       CURRENT_USERS_WARNING_DIALOG :: OnCommand

    SYNOPSIS:   This method is called whenever a WM_COMMAND message
                is sent to the dialog procedure.

    ENTRY:      cid                     - The control ID from the
                                          generating control.

    EXIT:       The command has been handled.

    RETURNS:    BOOL                    - TRUE  if we handled the command.
                                          FALSE if we did not handle
                                          the command.

    HISTORY:
	NarenG		12/15/92		Created

********************************************************************/
BOOL CURRENT_USERS_WARNING_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{

    DWORD err;

    if( event.QueryCid() == IDYES )
    {
	AUTO_CURSOR;

    	INT nCount = _lbUsers.QueryCount();

    	for ( INT Index = 0; Index < nCount; Index++ )
    	{
	    CURRENT_USERS_LBI * pculbi = _lbUsers.QueryItem( Index );

	    //
	    // Blow away this connection
    	    //

	    err = :: AfpAdminConnectionClose( _hServer, pculbi->QueryId() );

	    if ( ( err != NO_ERROR ) && ( err != AFPERR_InvalidId ) )
	    {
	    	break;
	    }
      	}

     	if ( ( err != NO_ERROR ) && ( err != AFPERR_InvalidId ) )
    	{
            ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	    Dismiss( FALSE );

	    return FALSE;
    	}

	Dismiss( TRUE );
    	return TRUE;
    }


    if( event.QueryCid() == IDNO )
    {
    	Dismiss( FALSE );
    	return FALSE;
    }

    return DIALOG_WINDOW::OnCommand( event );

}


/*******************************************************************

    NAME:       CURRENT_USERS_LISTBOX::CURRENT_USERS_LISTBOX

    SYNOPSIS:   Constructor - list box used in CURRENT_USERS_WARNING_DIALOG

    ENTRY:      powin - owner window
                cid   - resource id of the listbox

    EXIT:

    RETURNS:

    NOTES:      This is a read-only listbox.

    HISTORY:
      NarenG         11/13/92        Modified for AFPMGR

********************************************************************/

CURRENT_USERS_LISTBOX::CURRENT_USERS_LISTBOX( OWNER_WINDOW *powin,
					      CID 	   cid )
    : BLT_LISTBOX( powin, cid, TRUE )
{

    //
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    APIERR err = DISPLAY_TABLE::CalcColumnWidths( _adx,
						  COLS_CU_LB_USERS,
						  powin,
						  cid,
						  FALSE);

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       CURRENT_USERS_LISTBOX::Fill

    SYNOPSIS:   Fills the listbox with the current users.

    ENTRY:      pAfpConnections - Pointer to connections info
                nConnections    - Number of connections.

    EXIT:

    RETURNS:

    NOTES:      This is a read-only listbox.

    HISTORY:
      NarenG         11/13/92        Modified for AFPMGR

********************************************************************/

APIERR CURRENT_USERS_LISTBOX::Fill( PAFP_CONNECTION_INFO pAfpConnections,
			    	    DWORD 		 nConnections )
{
    APIERR err = NERR_Success;

    //
    // Gather all connections to the volume that the user wants to delete.
    //

    SetRedraw( FALSE );

    while ( ( err == NERR_Success ) && ( nConnections-- ) )
    {
        CURRENT_USERS_LBI *pCurUserslbi =  new CURRENT_USERS_LBI(
					pAfpConnections->afpconn_username,
					pAfpConnections->afpconn_num_opens,
					pAfpConnections->afpconn_time,
					pAfpConnections->afpconn_id );

        if ( AddItem( pCurUserslbi ) < 0 )
	{
	    err = ERROR_NOT_ENOUGH_MEMORY;
	}

        pAfpConnections++;
    }

    Invalidate( TRUE );

    SetRedraw( TRUE );

    return err;
}

/*******************************************************************

    NAME:       CURRENT_USERS_LBI::CURRENT_USERS_LBI

    SYNOPSIS:   List box items used in CURRENT_USERS_WARNING_DIALOG

    ENTRY:      pszUserName - Pointer to the current username
		dwNumOpens  - Number of files opened by this users.
		dwTime	    - Time since connected.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
      NarenG         11/13/92        Modified for AFPMGR

********************************************************************/

CURRENT_USERS_LBI::CURRENT_USERS_LBI( const TCHAR * pszUserName,
		      		      DWORD	    dwNumOpens,
		      		      DWORD	    dwTime,
		      		      DWORD	    dwId )
    : _nlsUserName(),
      _dwNumOpens( dwNumOpens ),
      _ulTime( dwTime ),
      _dwId( dwId )
{

    //
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _nlsUserName.QueryError();
	
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //	Fill in Guest for username if it is null
    //

    if ( pszUserName == NULL )
    {
    	err = _nlsUserName.Load( IDS_GUEST );
    }
    else
    {
    	err = _nlsUserName.CopyFrom( pszUserName );
    }
}

/*******************************************************************

    NAME:       CURRENT_USERS_LBI::Paint

    SYNOPSIS:   Redefine Paint() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
      NarenG         11/13/92        Modified for AFPMGR

********************************************************************/

VOID CURRENT_USERS_LBI::Paint(  LISTBOX 	*plb,
                       	    	HDC 		hdc,
                       		const RECT 	*prect,
                       		GUILTT_INFO 	*pGUILTT ) const
{

    APIERR err;
    DEC_STR nlsNumOpens( _dwNumOpens );
    NLS_STR nlsTime;

    if (  ((err = nlsNumOpens.QueryError()) 	    != NERR_Success )
       || ((err = nlsTime.QueryError()) 	    != NERR_Success )
       || ((err = ConvertTime( _ulTime, &nlsTime )) != NERR_Success )
       )
    {
        ::MsgPopup( plb->QueryOwnerHwnd(), err);
        return;
    }


    STR_DTE_ELLIPSIS 	strdteUserName( _nlsUserName.QueryPch(),
					plb, ELLIPSIS_RIGHT );
    STR_DTE 		strdteNumOpens( nlsNumOpens.QueryPch() );
    STR_DTE 		strdteTime( nlsTime.QueryPch() );

    DISPLAY_TABLE dt( COLS_CU_LB_USERS,
		      ((CURRENT_USERS_LISTBOX *) plb)->QueryColumnWidths() );

    dt[0] = &strdteUserName;
    dt[1] = &strdteNumOpens;
    dt[2] = &strdteTime;

    dt.Paint( plb, hdc, prect, pGUILTT );

}

/*******************************************************************

    NAME:       CURRENT_USERS_LBI::ConvertTime

    SYNOPSIS:   Convert the time given from ULONG (seconds) to a string
                to be shown. It complies with the internationalization
                of time using INTL_PROFILE.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
      NarenG         11/13/92        Modified for AFPMGR

********************************************************************/

#define SECONDS_PER_DAY    86400
#define SECONDS_PER_HOUR    3600
#define SECONDS_PER_MINUTE    60

APIERR CURRENT_USERS_LBI::ConvertTime( ULONG ulTime, NLS_STR *pnlsTime)  const
{
    INTL_PROFILE intlProf;

    INT nDay = (INT) ulTime / SECONDS_PER_DAY;
    ulTime %= SECONDS_PER_DAY;
    INT nHour = (INT) ulTime / SECONDS_PER_HOUR;
    ulTime %= SECONDS_PER_HOUR;
    INT nMinute = (INT) ulTime / SECONDS_PER_MINUTE;
    INT nSecond = (INT) ulTime % SECONDS_PER_MINUTE;


    return intlProf.QueryDurationStr( nDay, nHour, nMinute,
                                      nSecond, pnlsTime);
}

/*******************************************************************

    NAME:       CURRENT_USERS_LBI::Compare

    SYNOPSIS:   Redefine Compare() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
      NarenG         11/13/92        Modified for AFPMGR

********************************************************************/

INT CURRENT_USERS_LBI::Compare( const LBI *plbi ) const
{
    return( _nlsUserName._stricmp(
			((const CURRENT_USERS_LBI *) plbi)->_nlsUserName ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\openfile.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    openfile.cxx
    Class definitions for the OPENS_DIALOG, OPENS_LISTBOX, and
    OPENS_LBI classes.

    The OPENS_DIALOG is used to show the remotely open files on a
    particular server.  This listbox contains a [Close] button to
    allow the admin to close selected files.


    FILE HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <ellipsis.hxx>
#include <uiassert.hxx>
#include <ctime.hxx>
#include <intlprof.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}

#include <util.hxx>
#include <prefix.hxx>
#include <openfile.hxx>

//
//  min/max macros
//

#define min(x,y) (((x) < (y)) ? (x) : (y))
#define max(x,y) (((x) > (y)) ? (x) : (y))


//
//  OPENS_DIALOG methods.
//

/*******************************************************************

    NAME:       OPENS_DIALOG :: OPENS_DIALOG

    SYNOPSIS:   OPENS_DIALOG class constructor.

    ENTRY:      hwndOwner               - The "owning" dialog.

                pszServer               - Name of the target server.

    EXIT:       The object is constructed.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
OPENS_DIALOG :: OPENS_DIALOG( HWND       	hwndOwner,
                              AFP_SERVER_HANDLE hServer,
			      const TCHAR *	pszServerName )
  : DIALOG_WINDOW( IDD_OPENFILES, hwndOwner ),
    _hServer( hServer ),
    _sltOpenCount( this, IDOF_DT_OPENCOUNT ),
    _sltLockCount( this, IDOF_DT_LOCKCOUNT ),
    _pbClose( this, IDOF_PB_CLOSEFILE ),
    _pbCloseAll( this, IDOF_PB_CLOSEALLFILES ),
    _pbOk( this, IDOK ),
    _nlsServer( pszServerName ),
    _lbFiles( this, IDOF_LB_OPENLIST, hServer ),
    _pbRefresh( this, IDOF_PB_REFRESH )
{

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
        return;

    //
    // make sure the strings constructed fine.
    //

    APIERR err = _nlsServer.QueryError();

    if ( err != NERR_Success )
    {
        ReportError(err) ;
        return;
    }

    //
    //  Set the caption.
    //

    err = ::SetCaption( this, IDS_CAPTION_OPENFILES, pszServerName ) ;

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    err = BASE_ELLIPSIS::Init();

    if( err != NO_ERROR )
    {
        ReportError( err );
	return;
    }

    //
    //  Refresh the dialog.
    //

    DWORD error = Refresh();

    if( error != NO_ERROR )
    {
        ReportError( AFPERR_TO_STRINGID( error ) );
    }

}   // OPENS_DIALOG :: OPENS_DIALOG



/*******************************************************************

    NAME:       OPENS_DIALOG :: ~OPENS_DIALOG

    SYNOPSIS:   OPENS_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
OPENS_DIALOG :: ~OPENS_DIALOG()
{
    BASE_ELLIPSIS::Term();

}   // OPENS_DIALOG :: ~OPENS_DIALOG


/*******************************************************************

    NAME:       OPENS_DIALOG :: OnCommand

    SYNOPSIS:   Handle user commands.

    ENTRY:      cid                     - Control ID.

                lParam                  - lParam from the message.

    RETURNS:    BOOL                    - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
BOOL OPENS_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    //
    //  Determine the control which is sending the command.
    //

    switch( event.QueryCid() )
    {
    case IDOF_PB_REFRESH:
	{

        Refresh();

        return TRUE;
	}

    case IDOF_PB_CLOSEFILE:

	{
        OPENS_LBI * polbi = _lbFiles.QueryItem();
        UIASSERT( polbi != NULL );

	//
        // See if the user really wants to close this file.
	//

        if ( ::MsgPopup( this,
                         (polbi->IsOpenForWrite()) ? IDS_CLOSE_FILE_WRITE
					           : IDS_CLOSE_FILE,
                         MPSEV_WARNING,
                         MP_YESNO,
                         polbi->QueryUserName(),
                         polbi->QueryPath(),
                         MP_NO ) == IDYES )
        {
	    //
            //  Close the file And refresh dialog
	    //
            DWORD err = ::AfpAdminFileClose( _hServer, polbi->QueryFileID() );

            if( err != NO_ERROR )
            {
                //
                //  The file close failed.  Tell the user the bad news.
                //

		if ( err == AFPERR_InvalidId )
		{
                    ::MsgPopup( this, IDS_FILE_CLOSED );
		}
 	   	else
		{
                    ::MsgPopup( this, AFPERR_TO_STRINGID(err) );
		}
            }

            Refresh();
        }
        return TRUE;
	}

    case IDOF_PB_CLOSEALLFILES:
	
	{
	//
        // See if the user really wants to close *all* files.
	//

        if( WarnCloseMulti() )
        {
            //
            //  Close ALL of the open files.
            //

            DWORD err = ::AfpAdminFileClose( _hServer, 0 );

            if( err != NO_ERROR )
            {
                //
                //  The close fileste failed.  Tell the user the bad news.
                //
                ::MsgPopup( this, AFPERR_TO_STRINGID(err) );
	    }

	    //
            //  Refresh the dialog.
	    //
            Refresh();

        }
        return TRUE;
	}

    case IDOF_LB_OPENLIST:

	{
    	if ((event.QueryCode() == LBN_DBLCLK) && (_lbFiles.QuerySelCount()>0))
        {
            OPENS_LBI * plbi = _lbFiles.QueryItem();

	    ::MsgPopup( this,
			IDS_FILE_PATH,
			MPSEV_INFO,
			1,
			plbi->QueryPath(),
			MP_OK );
        }

        return TRUE;
	}

    default:

	{
	//
        // we are not interested, let parent handle
	//

        return( FALSE );
	}
    }

}   // OPENS_DIALOG :: OnCommand


/*******************************************************************

    NAME:       OPENS_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
ULONG OPENS_DIALOG :: QueryHelpContext( void )
{
    return HC_OPENS_DIALOG;

}   // OPENS_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:       OPEN_DIALOG :: Refresh

    SYNOPSIS:   Refreshes the Open Resources dialog.

    EXIT:       The dialog is feeling relaxed and refreshed.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
DWORD OPENS_DIALOG :: Refresh( VOID )
{
    //
    // Refresh the Open files listbox
    //

    DWORD err = _lbFiles.Refresh();

    if ( err != NO_ERROR )
    {
	//
        //  Since we couldn't retreive the file information,
        //  we'll just display ??.
	//

        const TCHAR * pszNotAvailable = SZ("??");

        _sltOpenCount.Enable( FALSE );
        _sltLockCount.Enable( FALSE );

        _sltOpenCount.SetText( pszNotAvailable );
        _sltLockCount.SetText( pszNotAvailable );

        _lbFiles.DeleteAllItems();
        _pbClose.Enable( FALSE );
        _pbCloseAll.Enable( FALSE );

    }
    else
    {

    	//
    	// Set open files and lock counts
    	//

    	_sltOpenCount.Enable( TRUE );
    	_sltLockCount.Enable( TRUE );

    	_sltOpenCount.SetValue( _lbFiles.QueryCount() );
    	_sltLockCount.SetValue( _lbFiles.QueryLockCount() );

    	//
    	//  Enable buttons as appropriate
    	//

	if ( _lbFiles.QuerySelCount() > 0 )
	{
    	    _pbClose.Enable( TRUE );
	}
	else
	{
	    if ( _pbClose.HasFocus() )
	    {
		_pbOk.ClaimFocus();
	    }

    	    _pbClose.Enable( FALSE );
	}

	if ( _lbFiles.QueryCount() > 0 )
	{
    	    _pbCloseAll.Enable( TRUE );
	}
	else
	{
	    if ( _pbCloseAll.HasFocus() )
	    {
		_pbOk.ClaimFocus();
	    }

    	    _pbCloseAll.Enable( FALSE );
	}
    }

    return err;
}


/*******************************************************************

    NAME:       OPEN_DIALOG :: WarnCloseMulti

    SYNOPSIS:   Warn the user before closing all open resources.

    RETURNS:    BOOL                    - TRUE  if the wants to close the
                                          resources,
                                          FALSE otherwise.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
BOOL OPENS_DIALOG :: WarnCloseMulti( VOID )
{
    //
    //  Get the number of items in the listbox.
    //

    INT cItems = _lbFiles.QueryCount();
    UIASSERT( cItems > 0 );

    MSGID idMsg = IDS_CLOSE_FILE_ALL;

    //
    //  Scan for any file that is opened for write
    //

    for( INT i = 0 ; i < cItems ; i++ )
    {
        OPENS_LBI * plbi = _lbFiles.QueryItem( i );

        UIASSERT( plbi != NULL );

        if( plbi->IsOpenForWrite() )
        {
    	    idMsg = IDS_CLOSE_FILE_ALL_WRITE;
	    break;
	
        }
    }

    return( ::MsgPopup( this,
                        idMsg,
                        MPSEV_WARNING,
                        MP_YESNO,
			_nlsServer.QueryPch(),
                        MP_NO ) == IDYES );

}   // OPEN_DIALOG :: WarnCloseMulti

//
//  OPENS_LISTBOX methods.
//

/*******************************************************************

    NAME:       OPENS_LISTBOX :: OPENS_LISTBOX

    SYNOPSIS:   OPENS_LISTBOX class constructor.

    ENTRY:      powOwner                - The "owning" window.

                cid                     - The listbox CID.

                nlsServer               - Name of target server

                nlsBasePath             - Base Path of File Enum

    EXIT:       The object is constructed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
OPENS_LISTBOX :: OPENS_LISTBOX( OWNER_WINDOW   *  powOwner,
                                CID               cid,
				AFP_SERVER_HANDLE hServer )
  : BLT_LISTBOX( powOwner, cid ),
    _hServer( hServer ),
    _dmdteDataFork( IDBM_LB_DATA_FORK ),
    _dmdteResourceFork( IDBM_LB_RESOURCE_FORK ),
    _dwNumLocks( 0 )
{
    //
    //  Ensure we constructed properly.
    //
    if( QueryError() != NERR_Success )
        return;

    //
    //  Build the column width table to be used by
    //  OPENS_LBI :: Paint().
    //
    DISPLAY_TABLE::CalcColumnWidths(_adx,
                                    COLS_OF_LB_FILES,
                                    powOwner,
                                    cid,
                                    TRUE) ;

}   // OPENS_LISTBOX :: OPENS_LISTBOX


/*******************************************************************

    NAME:       OPENS_LISTBOX :: ~OPENS_LISTBOX

    SYNOPSIS:   OPENS_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
OPENS_LISTBOX :: ~OPENS_LISTBOX()
{
    //
    //  This space intentionally left blank.
    //

}   // OPENS_LISTBOX :: ~OPENS_LISTBOX


/*******************************************************************

    NAME:       OPENS_LISTBOX :: Fill

    SYNOPSIS:   Fill the list of open files.

    EXIT:       The listbox is filled.

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
DWORD OPENS_LISTBOX :: Fill( VOID )
{
    AUTO_CURSOR Cursor;

    //
    //  Enumerate all the open files.
    //

    PAFP_FILE_INFO pAfpFiles;
    DWORD	   cEntriesRead;
    DWORD	   cTotalAvail;

    DWORD err = ::AfpAdminFileEnum( _hServer,
				    (LPBYTE *)&pAfpFiles,
				    (DWORD)-1,		// Get all files
				    &cEntriesRead,
				    &cTotalAvail,
				    NULL );

    if( err != NO_ERROR )
    {
	return err;

    }

    //
    //  Now that we know the file info is available,
    //  let's nuke everything in the listbox.
    //

    SetRedraw( FALSE );
    DeleteAllItems();

    //
    //  For iterating the available files.
    //
    PAFP_FILE_INFO pFileIter = pAfpFiles;

    //
    //  Iterate the files adding them to the listbox.
    //

    _dwNumLocks = 0;

    while( ( err == NO_ERROR ) && ( cEntriesRead-- ) )
    {
        OPENS_LBI * polbi = new OPENS_LBI( pFileIter->afpfile_id,
					   pFileIter->afpfile_username,
					   pFileIter->afpfile_open_mode,
				           pFileIter->afpfile_fork_type,
				           pFileIter->afpfile_num_locks,
					   pFileIter->afpfile_path );
        if( AddItem( polbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
  	
	_dwNumLocks += pFileIter->afpfile_num_locks;

	pFileIter++;

    }

    ::AfpAdminBufferFree( pAfpFiles );

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

} //OPENS_LISTBOX :: Fill( VOID )


/*******************************************************************

    NAME:       OPENS_LISTBOX :: Refresh

    SYNOPSIS:   Refreshes the list of open resources.

    EXIT:       The listbox is refreshed & redrawn.

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
DWORD OPENS_LISTBOX :: Refresh( VOID )
{
    INT iCurrent = QueryCurrentItem();
    INT iTop     = QueryTopIndex();

    DWORD err = Fill();

    if( err != NO_ERROR )
    {
        return err;
    }

    INT cItems = QueryCount();

    if( cItems > 0 )
    {
        iCurrent = min( max( iCurrent, 0 ), cItems - 1 );
        iTop     = min( max( iTop, 0 ), cItems - 1 );

        SelectItem( iCurrent );
        SetTopIndex( iTop );
    }


    return NO_ERROR;

}


//
//  OPENS_LBI methods.
//

/*******************************************************************

    NAME:       OPENS_LBI :: OPENS_LBI

    SYNOPSIS:   OPENS_LBI class constructor.

    ENTRY:      pszUserName             - The user for this entry.

                usPermissions           - Open permissions.

                cLocks                  - Number of locks.

                pszPath                 - The open pathname.

    EXIT:       The object is constructed.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
OPENS_LBI :: OPENS_LBI( DWORD         dwFileID,
			const TCHAR * pszUserName,
                        DWORD	      dwOpenMode,
                        DWORD	      dwForkType,
			DWORD	      dwNumLocks,
                        const TCHAR * pszPath )
  : _dwFileID( dwFileID ),
    _nlsUserName(),
    _dwOpenMode( dwOpenMode ),
    _dwForkType( dwForkType ),
    _nlsOpenMode(),
    _nlsNumLocks( dwNumLocks ),
    _nlsPath( pszPath )
{

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;
    if( ( ( err = _nlsUserName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsOpenMode.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsNumLocks.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsPath.QueryError() )     != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    //
    //  Initialize the more complex strings.
    //

    UINT idString =
	((dwOpenMode & AFP_OPEN_MODE_READ)&&(dwOpenMode&AFP_OPEN_MODE_WRITE))
	?  IDS_OPEN_MODE_READ_WRITE
	   : (( dwOpenMode & AFP_OPEN_MODE_READ )
	     ? IDS_OPEN_MODE_READ
		: (( dwOpenMode & AFP_OPEN_MODE_WRITE)
	 	  ? IDS_OPEN_MODE_WRITE
		     : IDS_OPEN_MODE_NONE));

    err = _nlsOpenMode.Load( idString );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    // If user name is NULL then a guest has loged on
    //

    if ( pszUserName == NULL )
    {
       	err = _nlsUserName.Load( IDS_GUEST );
    }
    else
    {
    	err = _nlsUserName.CopyFrom( pszUserName );
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

} //OPENS_LBI :: OPENS_LBI

/********************************************************************

    NAME:       OPENS_LBI :: ~OPENS_LBI

    SYNOPSIS:   OPENS_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
OPENS_LBI :: ~OPENS_LBI()
{
	
    //
    // This space intentionally left blank
    //
}


/*******************************************************************

    NAME:       OPENS_LBI :: Paint

    SYNOPSIS:   Draw an entry in OPENS_LISTBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
VOID OPENS_LBI :: Paint( LISTBOX *     plb,
                         HDC           hdc,
                         const RECT  * prect,
                         GUILTT_INFO * pGUILTT ) const
{
    STR_DTE_ELLIPSIS 	dteUserName( _nlsUserName.QueryPch(),
				     plb, ELLIPSIS_RIGHT);
    STR_DTE 	  	dteOpenMode( _nlsOpenMode.QueryPch() );
    STR_DTE 		dteNumForks( _nlsNumLocks.QueryPch() );
    STR_DTE_ELLIPSIS 	dtePath( _nlsPath.QueryPch(), plb, ELLIPSIS_PATH );

    DISPLAY_TABLE dtab( COLS_OF_LB_FILES,
			((OPENS_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = ( _dwForkType ==  AFP_FORK_DATA )
	      ? ((OPENS_LISTBOX *) plb)->QueryDataForkBitmap()
	      : ((OPENS_LISTBOX *) plb)->QueryResourceForkBitmap();

    dtab[1] = &dteUserName;
    dtab[2] = &dteOpenMode;
    dtab[3] = &dteNumForks;
    dtab[4] = &dtePath;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // OPENS_LBI :: Paint


/*******************************************************************

    NAME:       OPENS_LBI :: Compare

    SYNOPSIS:   Compare two OPENS_LBI items.

    ENTRY:      plbi                    - The "other" item.

    RETURNS:    INT                     -  0 if the items match.
                                          -1 if we're < the other item.
                                          +1 if we're > the other item.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
INT OPENS_LBI :: Compare( const LBI * plbi ) const
{
    NLS_STR * pnls    = &(((OPENS_LBI *)plbi)->_nlsUserName);
    INT       nResult = _nlsUserName._stricmp( *pnls );

    if( nResult == 0 )
    {
        pnls    = &(((OPENS_LBI *)plbi)->_nlsPath);
        nResult = _nlsPath._stricmp( *pnls );
    }

    return nResult;

}   // OPENS_LBI :: Compare


/*******************************************************************

    NAME:       OPENS_LBI :: QueryLeadingChar

    SYNOPSIS:   Return the leading character of this item.

    RETURNS:    WCHAR - The leading character.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
WCHAR OPENS_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsUserName );

    return _nlsUserName.QueryChar( istr );
}


/*******************************************************************

    NAME:       OPENS_LBI :: IsOpenForWrite

    SYNOPSIS:   Checks to see if the file is opened for write

    RETURNS:    TRUE if this file is opened for write, FALSE otherwise.

    HISTORY:
        NarenG      2-Oct-1992  Stole from server manager.
				Merged OPEN_DIALOG_BASE with OPENS_DIALIG

********************************************************************/
BOOL OPENS_LBI :: IsOpenForWrite( VOID ) const
{
    return ( _dwOpenMode & AFP_OPEN_MODE_WRITE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\perms.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    perms.cxx
      Contains the dialog for setting permissions on directories
      DIRECTORY_PERMISSIONS_DLG

    FILE HISTORY:
      NarenG        	11/30/92        Created

*/

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <ntseapi.h>
#include <nturtl.h>
}

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSERVER
#define INCL_NETSHARE
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>


extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
#define _NTSEAPI_	// This prevents getuser.h from including
			// ntseapi.h again.
#include <getuser.h>	// the user-browser dialog
}


#include <netname.hxx>
#include <string.hxx>
#include <uitrace.hxx>

#include "util.hxx"
#include "perms.hxx"

/*******************************************************************

    NAME:       DIRECTORY_PERMISSIONS_DLG::DIRECTORY_PERMISSIONS_DLG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
		hServer		  - handle to the AFP server
                pszDirPath        - Absolute path relative to the server that
				    is being administered.
                pszDisplayPath    - Path as the user typed it in or as was
				    selected from the filemgr,
		fDirInVolume	  - If TRUE then the directory path must be
				    part of a volume. If FALSE then it may
				    not and the directory information is not
				    set. Instead, the information is returned
				    in the follwing fields.
		pnlsOwner	  - Owner of the directory.
		pnlsGroup	  - Primary Group of the directory.
		lpdwPerms 	  - Various directory permissions.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/30/92        Created

********************************************************************/

DIRECTORY_PERMISSIONS_DLG::DIRECTORY_PERMISSIONS_DLG(
					HWND 		  hwndOwner,
					AFP_SERVER_HANDLE hServer,
					const TCHAR 	  *pszServerName,
				   	BOOL		  fCalledBySrvMgr,
                                        const TCHAR 	  *pszDirPath,
                                        const TCHAR 	  *pszDisplayPath,
					BOOL		  fDirInVolume,
					NLS_STR		  *pnlsOwner,
					NLS_STR		  *pnlsGroup,
					DWORD		  *lpdwPerms )
	: DIALOG_WINDOW( MAKEINTRESOURCE( IDD_DIRECTORY_PERMISSIONS_DLG ),
  				          hwndOwner ),
    	_chkOwnerSeeFiles( this, IDDP_CHK_OWNER_FILE ),
    	_chkOwnerSeeFolders( this,IDDP_CHK_OWNER_FOLDER ),
    	_chkOwnerMakeChanges( this,IDDP_CHK_OWNER_CHANGES ),
    	_chkGroupSeeFiles( this,IDDP_CHK_GROUP_FILE ),
    	_chkGroupSeeFolders( this,IDDP_CHK_GROUP_FOLDER ),
    	_chkGroupMakeChanges( this,IDDP_CHK_GROUP_CHANGES ),
    	_chkWorldSeeFiles( this,IDDP_CHK_WORLD_FILE ),
    	_chkWorldSeeFolders( this,IDDP_CHK_WORLD_FOLDER ),
    	_chkWorldMakeChanges( this,IDDP_CHK_WORLD_CHANGES ),
    	_chkReadOnly( this,IDDP_CHK_READONLY ),
    	_chkRecursePerms( this, IDDP_CHK_RECURSE ),
    	_sltpPath( this, IDDP_SLT_PATH, ELLIPSIS_PATH ),
    	_sleOwner( this, IDDP_SLE_OWNER, UNLEN ),
    	_slePrimaryGroup( this, IDDP_SLE_PRIMARYGROUP, GNLEN ),
    	_pszDirPath( pszDirPath ),
	_pbOwner( this, IDDP_PB_OWNER ),
	_pbGroup( this, IDDP_PB_GROUP ),
   	_fDirInVolume( fDirInVolume ),
	_pnlsOwner( pnlsOwner ),
	_pnlsGroup( pnlsGroup ),
	_lpdwPerms( lpdwPerms ),
	_nlsServerName( pszServerName ),
	_hServer( hServer )

{


    //
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;

    if ( (( err = _chkOwnerSeeFiles.QueryError() ) != NERR_Success )    ||
    	 (( err = _chkOwnerSeeFolders.QueryError() ) != NERR_Success )  ||
    	 (( err = _chkOwnerMakeChanges.QueryError() ) != NERR_Success ) ||
    	 (( err = _chkGroupSeeFiles.QueryError() ) != NERR_Success )    ||
    	 (( err = _chkGroupSeeFolders.QueryError() ) != NERR_Success )  ||
    	 (( err = _chkGroupMakeChanges.QueryError() ) != NERR_Success ) ||
    	 (( err = _chkWorldSeeFiles.QueryError() ) != NERR_Success )    ||
    	 (( err = _chkWorldSeeFolders.QueryError() ) != NERR_Success )  ||
    	 (( err = _chkWorldMakeChanges.QueryError() ) != NERR_Success ) ||
    	 (( err = _chkReadOnly.QueryError() ) != NERR_Success )         ||
    	 (( err = _chkRecursePerms.QueryError() ) != NERR_Success )     ||
    	 (( err = _sltpPath.QueryError() ) != NERR_Success )            ||
    	 (( err = _sleOwner.QueryError() ) != NERR_Success )            ||
	 (( err = _nlsServerName.QueryError() ) != NERR_Success )	||
    	 (( err = _slePrimaryGroup.QueryError() ) != NERR_Success ) ) 
    {
	ReportError( err );
	return;
    }

    //
    // This may take a while..
    //

    AUTO_CURSOR Cursor;

    if ( fCalledBySrvMgr )
    {
    	//
    	//  Set the caption.
    	//

    	err = ::SetCaption( this, 	
			    IDS_CAPTION_DIRECTORY_PERMS,
			    pszServerName);

    	if( err != NERR_Success )
    	{
            ReportError( err );
            return;
	}
    }

    //
    // Get the directory information
    //

    PAFP_DIRECTORY_INFO pAfpDirInfo;

    err = ::AfpAdminDirectoryGetInfo( _hServer,
				      (LPWSTR)pszDirPath,
				      (LPBYTE*)&pAfpDirInfo );

    if ( err != NO_ERROR )
    {
        ReportError( err );
        return;
    }

    //
    // Set the path, search for & and add another & to it
    //

    NLS_STR nlsDisplayPath( pszDisplayPath );

    if ( ( err = nlsDisplayPath.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    // Add an extra & for every & found in the path, otherwise the character
    // following the & will become a hotkey.
    //

    NLS_STR nlsAmp( TEXT("&") );

    if ( ( err = nlsAmp.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    ISTR istrPos( nlsDisplayPath );
    ISTR istrStart( nlsDisplayPath );

    while ( nlsDisplayPath.strstr( &istrPos, nlsAmp, istrStart ) )
    {
	nlsDisplayPath.InsertStr( nlsAmp, ++istrPos );

	istrStart = ++istrPos;
    }

    _sltpPath.SetText( nlsDisplayPath );

    //
    // If the directory must be within the volume and it is not then
    // we return the error
    //

    if ( fDirInVolume && (!pAfpDirInfo->afpdir_in_volume) )
    {
    	::AfpAdminBufferFree( pAfpDirInfo );
        ReportError( AFPERR_DirectoryNotInVolume );
        return;
	
    }

    //
    // Ok, we have all the information we need so set all the controls
    //

    _sleOwner.SetText( pAfpDirInfo->afpdir_owner );

    _slePrimaryGroup.SetText( pAfpDirInfo->afpdir_group );

    _chkOwnerSeeFiles.SetCheck((INT)( pAfpDirInfo->afpdir_perms
				      & AFP_PERM_OWNER_SFI ));

    _chkOwnerSeeFolders.SetCheck( (INT)( pAfpDirInfo->afpdir_perms
					 & AFP_PERM_OWNER_SFO ));

    _chkOwnerMakeChanges.SetCheck( (INT)( pAfpDirInfo->afpdir_perms
					  & AFP_PERM_OWNER_MC ));

    _chkGroupSeeFiles.SetCheck( (INT)( pAfpDirInfo->afpdir_perms
				       & AFP_PERM_GROUP_SFI ));

    _chkGroupSeeFolders.SetCheck( (INT)( pAfpDirInfo->afpdir_perms
					 & AFP_PERM_GROUP_SFO ));

    _chkGroupMakeChanges.SetCheck( (INT)( pAfpDirInfo->afpdir_perms
					  & AFP_PERM_GROUP_MC ));

    _chkWorldSeeFiles.SetCheck( (INT)( pAfpDirInfo->afpdir_perms
				       & AFP_PERM_WORLD_SFI ));

    _chkWorldSeeFolders.SetCheck( (INT)( pAfpDirInfo->afpdir_perms
					 & AFP_PERM_WORLD_SFO ));

    _chkWorldMakeChanges.SetCheck( (INT)( pAfpDirInfo->afpdir_perms
					  & AFP_PERM_WORLD_MC ));

    _chkReadOnly.SetCheck( (INT)( pAfpDirInfo->afpdir_perms
				  & AFP_PERM_INHIBIT_MOVE_DELETE ));

    _sleOwner.ClaimFocus();

    ::AfpAdminBufferFree( pAfpDirInfo );

}

/*******************************************************************

    NAME:       DIRECTORY_PERMISSIONS_DLG :: OnCommand

    SYNOPSIS:   This method is called whenever a WM_COMMAND message
                is sent to the dialog procedure.

    ENTRY:      cid                     - The control ID from the
                                          generating control.

    EXIT:       The command has been handled.

    RETURNS:    BOOL                    - TRUE  if we handled the command.
                                          FALSE if we did not handle
                                          the command.

    HISTORY:
        NarenG          11/30/92        Created

********************************************************************/
BOOL DIRECTORY_PERMISSIONS_DLG :: OnCommand( const CONTROL_EVENT & event )
{


    if( ( event.QueryCid() == _pbOwner.QueryCid() ) ||
        ( event.QueryCid() == _pbGroup.QueryCid() ) )
    {
	USERBROWSER 	UserBrowser;
	HUSERBROW	hUserBrowser;
	BYTE		Buffer[3000];
	LPUSERDETAILS   lpUserDetails = (LPUSERDETAILS)&Buffer;
	DWORD		dwBufferSize  = sizeof( Buffer );
	NLS_STR		nlsHelpFileName;
	NLS_STR 	nlsCaption;
	APIERR 		err; 
	NTSTATUS	ntStatus;
	SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
	PSID		pSid;

    	//
    	// This may take a while..
    	//

    	AUTO_CURSOR Cursor;

	if ( ( ( err = nlsCaption.QueryError() ) != NERR_Success ) ||
	     ( ( err = nlsHelpFileName.QueryError() ) != NERR_Success ) )
	{
    	    ::MsgPopup( this, err );

	    return FALSE;
	}

    	if ( (err = nlsHelpFileName.Load(IDS_AFPMGR_HELPFILENAME ) ) 
							  != NERR_Success ) {
	    ::MsgPopup( this, err );

	    return FALSE;
	}

        INT ids = (( event.QueryCid() == _pbOwner.QueryCid() )
		   	? IDS_CAPTION_OWNER 
			: IDS_CAPTION_GROUP );

    	if ( (err = nlsCaption.Load( ids ) ) != NERR_Success )
	{
    	    ::MsgPopup( this, err );
	    return FALSE;
	}

        UserBrowser.fExpandNames     = TRUE;

        UserBrowser.ulStructSize     = sizeof( UserBrowser );

        UserBrowser.pszInitialDomain = (LPWSTR)(_nlsServerName.QueryPch());

        UserBrowser.pszHelpFileName  = (LPWSTR)(nlsHelpFileName.QueryPch());

        UserBrowser.ulHelpContext    = HC_SELECT_OWNER_GROUP;

        UserBrowser.hwndOwner = QueryHwnd();
       
	UserBrowser.Flags = ( USRBROWS_SINGLE_SELECT 	 	| 
	    		      USRBROWS_INCL_ALL 		| 
	    		      USRBROWS_SHOW_GROUPS		|
	    		      USRBROWS_SHOW_USERS 		| 
	    		      USRBROWS_SHOW_ALIASES 		| 
			      USRBROWS_EXPAND_USERS 		);

        UserBrowser.pszTitle = (WCHAR *)(nlsCaption.QueryPch());

	hUserBrowser = ::OpenUserBrowser( &UserBrowser );

        if ( UserBrowser.fUserCancelled )
	{
	    return FALSE;
	}

	if ( hUserBrowser == NULL )
	{
    	    ::MsgPopup( this, ::GetLastError() );

	    return FALSE;
	}

	if ( ::EnumUserBrowserSelection( hUserBrowser,
					 lpUserDetails,
					 &dwBufferSize ) == FALSE )
	{
    	    err = ::GetLastError();

            if ( err != ERROR_NO_MORE_ITEMS )
	    {

    	    	::MsgPopup( this, ::GetLastError() );
	    }

	    return FALSE;
	}

	if ( ::CloseUserBrowser( hUserBrowser ) == FALSE )
	{
    	    ::MsgPopup( this, ::GetLastError() );

	    return FALSE;
	}

	NLS_STR nlsDomainName;
	NLS_STR nlsAccountName;

	if ( (( err = nlsDomainName.QueryError() ) != NERR_Success ) ||
	     (( err = nlsAccountName.QueryError() ) != NERR_Success ) )
	{
	    ::MsgPopup( this, err );
	    return FALSE;
	}

	//
	// This is really a workaround for a bug in the user browser.
	// It prepends the account domain name for all built-in accounts.
	// So we have to check the SID to see if it is a built-in account,
	// and if it is we do not copy the domain name.
	//

        ntStatus = RtlAllocateAndInitializeSid( &NtAuthority, 
						1, 
						SECURITY_BUILTIN_DOMAIN_RID,
						0,0,0,0,0,0,0,
						&pSid );

	if ( !NT_SUCCESS(ntStatus) )
	{
	    ::MsgPopup( this, RtlNtStatusToDosError( ntStatus ) );
	    return FALSE;
	}

	if ( !RtlEqualSid( pSid, lpUserDetails->psidDomain ) ) 
	{
	    if ( ( (lpUserDetails->pszDomainName) != NULL ) &&
	         ( ::wcslen(lpUserDetails->pszDomainName) > 0 ) )
	    {
	        nlsDomainName.CopyFrom((TCHAR *)(lpUserDetails->pszDomainName));
	    	nlsDomainName.AppendChar( TEXT('\\') );
	    }
	}

	RtlFreeSid( pSid );

	nlsAccountName.CopyFrom( (TCHAR *)(lpUserDetails->pszAccountName) );

	nlsDomainName.Append( nlsAccountName );

        if( event.QueryCid() == _pbOwner.QueryCid() )
	{
    	    _sleOwner.SetText( nlsDomainName.QueryPch() );
        }
        else
	{
    	    _slePrimaryGroup.SetText( nlsDomainName.QueryPch() );
	}
    }

    return DIALOG_WINDOW::OnCommand( event );
}

/*******************************************************************

    NAME:       DIRECTORY_PERMISSIONS_DLG::OnOK

    SYNOPSIS:   Called when user pushes OK button.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/
BOOL DIRECTORY_PERMISSIONS_DLG::OnOK( VOID )
{

    //
    // This may take a while..
    //

    AUTO_CURSOR Cursor;

    //
    // This is not a loop
    //

    DWORD err;

    do {

	NLS_STR nlsOwner;
	NLS_STR nlsPrimaryGroup;
	DWORD	dwPerms;

    	if (( err = nlsOwner.QueryError()) != NERR_Success )
	    break;

    	if (( err = _sleOwner.QueryText( &nlsOwner )) != NERR_Success )
	    break;

    	if (( err = nlsPrimaryGroup.QueryError()) != NERR_Success )
	    break;

  	if (( err = _slePrimaryGroup.QueryText( &nlsPrimaryGroup ))
							  != NERR_Success )
	    break;

    	//
    	// Make sure user supplied an owner and a primary group
    	//

    	if ( nlsOwner.strlen() == 0 )
    	{
    	    ::MsgPopup( this,IDS_NEED_OWNER );
    	    _sleOwner.ClaimFocus();
	    return TRUE;
    	}

    	if ( nlsPrimaryGroup.strlen() == 0 )
    	{
    	    ::MsgPopup( this, IDS_NEED_PRIMARY_GROUP );
	    _slePrimaryGroup.ClaimFocus();
	    return TRUE;
    	}

	//
	// Get the directory(folder) permssions
	//

    	dwPerms = 0;
    	dwPerms |= _chkOwnerSeeFiles.QueryCheck() ? AFP_PERM_OWNER_SFI : 0;
    	dwPerms |= _chkOwnerSeeFolders.QueryCheck() ? AFP_PERM_OWNER_SFO : 0;
    	dwPerms |= _chkOwnerMakeChanges.QueryCheck() ? AFP_PERM_OWNER_MC : 0;
    	dwPerms |= _chkGroupSeeFiles.QueryCheck() ? AFP_PERM_GROUP_SFI : 0;
    	dwPerms |= _chkGroupSeeFolders.QueryCheck() ? AFP_PERM_GROUP_SFO : 0;
    	dwPerms |= _chkGroupMakeChanges.QueryCheck() ? AFP_PERM_GROUP_MC : 0;
    	dwPerms |= _chkWorldSeeFiles.QueryCheck() ? AFP_PERM_WORLD_SFI : 0;
    	dwPerms |= _chkWorldSeeFolders.QueryCheck() ? AFP_PERM_WORLD_SFO : 0;
    	dwPerms |= _chkWorldMakeChanges.QueryCheck() ? AFP_PERM_WORLD_MC : 0;
    	dwPerms |= _chkReadOnly.QueryCheck() ? AFP_PERM_INHIBIT_MOVE_DELETE : 0;
    	dwPerms |= _chkRecursePerms.QueryCheck() ? AFP_PERM_SET_SUBDIRS: 0;

	//
	// If the directory has to be a part of a volume then we set the
	// information at this point, otherwise we return the information
	// to the caller.
	//

	if ( _fDirInVolume )
	{
    	    AFP_DIRECTORY_INFO AfpDirInfo;

    	    AfpDirInfo.afpdir_path  = (LPWSTR)_pszDirPath;

    	    AfpDirInfo.afpdir_owner = (LPWSTR)nlsOwner.QueryPch();

    	    AfpDirInfo.afpdir_group = (LPWSTR)nlsPrimaryGroup.QueryPch();

    	    AfpDirInfo.afpdir_perms = dwPerms;

    	    err = ::AfpAdminDirectorySetInfo( _hServer,
				              (LPBYTE)&AfpDirInfo,
					      AFP_DIR_PARMNUM_ALL );
	}
	else
	{
	    _pnlsOwner->CopyFrom( nlsOwner );
	    _pnlsGroup->CopyFrom( nlsPrimaryGroup );
	    *_lpdwPerms = dwPerms;
	}

    } while ( FALSE );

    if ( err == NO_ERROR )
    {
        Dismiss( TRUE );
    }
    else
    {
    	::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	if ( err == AFPERR_NoSuchGroup )
	    _slePrimaryGroup.ClaimFocus();
	else
    	    _sleOwner.ClaimFocus();
    }

    return TRUE;

}


/*******************************************************************

    NAME:       DIRECTORY_PERMISSIONS_DLG::QueryHelpContext

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
        NarenG          11/30/92        Created

********************************************************************/

ULONG DIRECTORY_PERMISSIONS_DLG::QueryHelpContext( VOID )
{
    return HC_DIRECTORY_PERMISSIONS_DLG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\senddlg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    sendmsg.cxx

    This file contains the SEND_MSG_USER_DIALOG class definition viz.
    used to send a message from the users dialog and 
    SEND_MSG_SERVER_DIALOG viz used to send a message to all the users
    connected with the server.

    The 2 dialogs SEND_MSG_USER_DIALOG and SEND_MSG_SERVER_DIALOG are
    very similar and can easily be subclassed. The amount of code saved
    would be minimal if anything at all. Therefore this hs not been done.
    

    FILE HISTORY:
	NarenG		16-Oct-1992  	Folded MSG_DIALOG_BASE and
					SEND_MESSAGE_DIALOG into one.
					

*/

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>

extern "C"
{

#include <afpmgr.h>
#include <macfile.h>

}

#include <string.hxx>
#include <senddlg.hxx>


/*******************************************************************

    NAME:       SEND_MSG_USER_DIALOG::SEND_MSG_USER_DIALOG

    SYNOPSIS:   Constructor for AFP Manager Send Message Dialog

    ENTRY:      Expects valid HWND for hDlg 
    		Must have server and user selection

    EXIT:       Usual construction stuff, slt set to contain
                server of current focus.

    HISTORY:
	NarenG		16-Oct-1992  	Created

********************************************************************/

SEND_MSG_USER_DIALOG::SEND_MSG_USER_DIALOG( 
					  HWND       	       hWndOwner,
                                    	  AFP_SERVER_HANDLE    hServer,
				    	  const TCHAR *	       pszServerName, 
				    	  const TCHAR *	       pszUserName, 
					  DWORD		       dwSessionId )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_SEND_MSG_USER_DIALOG ), hWndOwner ),
     _sltServerName( this, IDSM_DT_SERVER_NAME ),
     _sltUserName( this, IDSM_DT_USER_NAME ),
     _rgRecipients( this, IDSM_RB_SINGLE_USER, 2, IDSM_RB_SINGLE_USER ),
     _mleTextMsg( this, IDSM_ET_MESSAGE, AFP_MESSAGE_LEN  ),
     _hServer( hServer ),
     _dwSessionId( dwSessionId )
{

    // 
    // Did everything construct properly ?
    // 

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;

    if ( (( err = _sltServerName.QueryError() ) != NERR_Success ) ||
    	 (( err = _sltUserName.QueryError() )   != NERR_Success ) ||
    	 (( err = _rgRecipients.QueryError() )  != NERR_Success ) ||
    	 (( err = _mleTextMsg.QueryError() )    != NERR_Success ) )
    {
	ReportError( err );
  	return;
    }
	
    //
    // Must have a users and server selection
    //

    UIASSERT(pszServerName != NULL) ;
    UIASSERT(pszUserName != NULL) ;

    //
    //	Set the server name after removing the backslashes
    //

    ALIAS_STR nlsServerName( pszServerName );
    UIASSERT( nlsServerName.QueryError() == NERR_Success );

    ISTR istr( nlsServerName );

    //
    //  Skip the backslashes.
    //

    istr += 2;

    ALIAS_STR nlsWithoutPrefix( nlsServerName.QueryPch( istr ) );
    UIASSERT( nlsWithoutPrefix.QueryError() == NERR_Success );

    _sltServerName.SetText( nlsWithoutPrefix );
    _sltServerName.Enable( TRUE );


    // 
    //  Set the selected user's name
    //

    _sltUserName.SetText( pszUserName );
    _sltUserName.Enable( TRUE );

    //
    //  Direct the message edit control not to add end-of-line
    //  character from wordwrapped text lines.
    //

    _mleTextMsg.SetFmtLines(FALSE);

}

/*******************************************************************

    NAME:       SEND_MSG_USER_DIALOG::~SEND_MSG_USER_DIALOG

    SYNOPSIS:   this destructor does nothing

    HISTORY:
	NarenG		16-Oct-1992  	Created

********************************************************************/

SEND_MSG_USER_DIALOG::~SEND_MSG_USER_DIALOG()
{

    //
    // This space intentionally left blank
    //
}

/*******************************************************************

    NAME:       SEND_MSG_USER_DIALOG::QueryHelpContext

    SYNOPSIS:   Query help text for SEND_MSG_USER_DIALOG

    HISTORY:
	NarenG		16-Oct-1992  	Created

********************************************************************/

ULONG SEND_MSG_USER_DIALOG::QueryHelpContext( void )
{
    return HC_SEND_MSG_USER_DIALOG;
}

/*******************************************************************

    NAME:       SEND_MSG_USER_DIALOG::OnOK

    SYNOPSIS:   Replaces the OnOK in DIALOG_WINDOW. It gets the 
	 	text from the MLE and sends it.

    HISTORY:
	NarenG		16-Oct-1992  	Created

********************************************************************/

BOOL SEND_MSG_USER_DIALOG::OnOK()
{

    //
    // Set cursor to hour glass.
    //

    AUTO_CURSOR 	AutoCursor;

    AFP_MESSAGE_INFO 	AfpMsg;

    // 
    // Find out whom to send the message to.
    //

    AfpMsg.afpmsg_session_id = 
			( _rgRecipients.QuerySelection() == IDSM_RB_ALL_USERS )
		        ? 0 : _dwSessionId;

    //
    // Attempt to send the message
    //

    UINT cb = _mleTextMsg.QueryTextSize();

    //
    // Was there any text ?
    //

    if ( cb <= sizeof(TCHAR) )    // always has a terminating NULL
    {
        ::MsgPopup( this, IDS_NEED_TEXT_TO_SEND );

    	_mleTextMsg.ClaimFocus();

    	return(TRUE);
    }

    NLS_STR nlsMsgText( cb );
    APIERR  err;

    if ( (( err = nlsMsgText.QueryError() ) != NERR_Success ) ||
         (( err = _mleTextMsg.QueryText( &nlsMsgText ) ) != NERR_Success ) )
    {
        ::MsgPopup( this, err );

    	return(FALSE);
    }
  
//	MSKK HitoshiT modified to handle DBCS	94/09/01
#ifdef	DBCS
    UNICODE_STRING unistr;
    unistr.Length = nlsMsgText.QueryTextLength() * sizeof(WCHAR) ;
    unistr.MaximumLength = unistr.Length ;
    unistr.Buffer = (WCHAR *)nlsMsgText.QueryPch() ;
    if ( RtlUnicodeStringToOemSize( &unistr ) > AFP_MESSAGE_LEN )
#else
    if ( nlsMsgText.QueryTextLength() > AFP_MESSAGE_LEN )
#endif
    {
	::MsgPopup( this, IDS_MESSAGE_TOO_LONG );

    	_mleTextMsg.ClaimFocus();
    	_mleTextMsg.SelectString();

    	return(FALSE);
    }

    AfpMsg.afpmsg_text = (LPWSTR)(nlsMsgText.QueryPch());

    err = AfpAdminMessageSend( _hServer, &AfpMsg );

    switch( err )
    {
    case AFPERR_InvalidId:
    	::MsgPopup( this, IDS_SESSION_DELETED );
        Dismiss( FALSE );
  	break;

    case NO_ERROR:
        ::MsgPopup( this, IDS_MESSAGE_SENT, MPSEV_INFO );
        Dismiss( TRUE );
	break;
  
    case AFPERR_InvalidSessionType:

	if ( _rgRecipients.QuerySelection() == IDSM_RB_ALL_USERS )  
    	    ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
	else
    	    ::MsgPopup( this, IDS_NOT_RECEIVED  );

        Dismiss( FALSE );
	break;

    default:
        ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
        Dismiss( FALSE );
	break;
    }

    return(TRUE);
}


/*******************************************************************

    NAME:       SEND_MSG_SERVER_DIALOG::SEND_MSG_SERVER_DIALOG

    SYNOPSIS:   Constructor for AFP Manager Send Message Dialog

    ENTRY:      Expects valid HWND for hDlg 
    		Must have server selection

    EXIT:       Usual construction stuff, slt set to contain
                server of current focus.

    HISTORY:
	NarenG		16-Oct-1992  	Created

********************************************************************/

SEND_MSG_SERVER_DIALOG::SEND_MSG_SERVER_DIALOG( 
					  HWND       	       hWndOwner,
                                    	  AFP_SERVER_HANDLE    hServer,
				    	  const TCHAR *	       pszServerName )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_SEND_MSG_SERVER_DIALOG ), hWndOwner ),
     _sltServerName( this, IDSD_DT_SERVER_NAME ),
     _mleTextMsg( this, IDSD_ET_MESSAGE, AFP_MESSAGE_LEN  ),
     _hServer( hServer )
{

    // 
    // Did everything construct properly ?
    // 

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;

    if ( (( err = _sltServerName.QueryError() ) != NERR_Success ) ||
    	 (( err = _mleTextMsg.QueryError() )    != NERR_Success ) )
    {
	ReportError( err );
  	return;
    }
	
    //
    // Must have a users and server selection
    //

    UIASSERT(pszServerName != NULL) ;

    //
    //	Set the server name after removing the backslashes
    //

    ALIAS_STR nlsServerName( pszServerName );
    UIASSERT( nlsServerName.QueryError() == NERR_Success );

    ISTR istr( nlsServerName );

    //
    //  Skip the backslashes.
    //

    istr += 2;

    ALIAS_STR nlsWithoutPrefix( nlsServerName.QueryPch( istr ) );
    UIASSERT( nlsWithoutPrefix.QueryError() == NERR_Success );

    _sltServerName.SetText( nlsWithoutPrefix );
    _sltServerName.Enable( TRUE );

    //
    //  Direct the message edit control not to add end-of-line
    //  character from wordwrapped text lines.
    //

    _mleTextMsg.SetFmtLines(FALSE);

}

/*******************************************************************

    NAME:       SEND_MSG_SERVER_DIALOG::~SEND_MSG_SERVER_DIALOG

    SYNOPSIS:   this destructor does nothing

    HISTORY:
	NarenG		16-Oct-1992  	Created

********************************************************************/

SEND_MSG_SERVER_DIALOG::~SEND_MSG_SERVER_DIALOG()
{

    //
    // This space intentionally left blank
    //
}

/*******************************************************************

    NAME:       SEND_MSG_SERVER_DIALOG::QueryHelpContext

    SYNOPSIS:   Query help text for SEND_MSG_SERVER_DIALOG

    HISTORY:
	NarenG		16-Oct-1992  	Created

********************************************************************/

ULONG SEND_MSG_SERVER_DIALOG::QueryHelpContext( void )
{
    return HC_SEND_MSG_SERVER_DIALOG;
}

/*******************************************************************

    NAME:       SEND_MSG_SERVER_DIALOG::OnOK

    SYNOPSIS:   Replaces the OnOK in DIALOG_WINDOW. It gets the 
	 	text from the MLE and sends it.

    HISTORY:
	NarenG		16-Oct-1992  	Created

********************************************************************/

BOOL SEND_MSG_SERVER_DIALOG::OnOK()
{

    //
    // Set cursor to hour glass.
    //

    AUTO_CURSOR 	AutoCursor;

    AFP_MESSAGE_INFO 	AfpMsg;

    // 
    // Send a message to all the users.
    //

    AfpMsg.afpmsg_session_id = 0;

    //
    // Attempt to send the message
    //

    UINT cb = _mleTextMsg.QueryTextSize();

    //
    // Was there any text ?
    //

    if ( cb <= sizeof(TCHAR) )    // always has a terminating NULL
    {
        ::MsgPopup( this, IDS_NEED_TEXT_TO_SEND );

    	_mleTextMsg.ClaimFocus();

    	return(FALSE);
    }

    NLS_STR nlsMsgText( cb );
    APIERR  err;

    if ( (( err = nlsMsgText.QueryError() ) != NERR_Success ) ||
         (( err = _mleTextMsg.QueryText( &nlsMsgText ) ) != NERR_Success ) ) 
    {
        ::MsgPopup( this, err );

    	return(FALSE);
    }

//	MSKK HitoshiT modified to handle DBCS	94/09/01
#ifdef	DBCS
    UNICODE_STRING unistr;
    unistr.Length = nlsMsgText.QueryTextLength() * sizeof(WCHAR) ;
    unistr.MaximumLength = unistr.Length ;
    unistr.Buffer = (WCHAR *)nlsMsgText.QueryPch() ;
    if ( RtlUnicodeStringToOemSize( &unistr ) > AFP_MESSAGE_LEN )
#else
    if ( nlsMsgText.QueryTextLength() > AFP_MESSAGE_LEN )
#endif
    {
	::MsgPopup( this, IDS_MESSAGE_TOO_LONG );

    	_mleTextMsg.ClaimFocus();
    	_mleTextMsg.SelectString();

    	return(FALSE);
    }
  
    AfpMsg.afpmsg_text = (LPWSTR)(nlsMsgText.QueryPch());

    DWORD error = AfpAdminMessageSend( _hServer, &AfpMsg );

    if ( error != NO_ERROR )
    {
        ::MsgPopup( this, AFPERR_TO_STRINGID(error) );

        Dismiss( FALSE );
    }
    else
    {
        ::MsgPopup( this, IDS_MESSAGE_SENT, MPSEV_INFO );

        Dismiss( TRUE );
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\sessions.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    sessions.cxx
    Class declarations for the SESSIONS_DIALOG, SESSIONS_LISTBOX, and
    SESSIONS_LBI classes.

    These classes implement the AFP Server Manager Users subproperty
    sheet.  The SESSIONS_LISTBOX/SESSIONS_LBI classes implement the listbox
    which shows the connected users.  SESSIONS_DIALOG implements the
    actual dialog box.


    FILE HISTORY:
	NarenG	    Stole from Server Manager

*/
#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_MSGPOPUP
#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <lmsrvres.hxx>
#include <ctime.hxx>
#include <intlprof.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}   // extern "C"

#include <ellipsis.hxx>
#include <bltnslt.hxx>
#include <sessions.hxx>
#include <util.hxx>
#include <senddlg.hxx>

//
//  min/max macros
//

#define min(x,y) (((x) < (y)) ? (x) : (y))
#define max(x,y) (((x) > (y)) ? (x) : (y))


//
//  SESSIONS_DIALOG methods
//

/*******************************************************************

    NAME:           SESSIONS_DIALOG :: SESSIONS_DIALOG

    SYNOPSIS:       SESSIONS_DIALOG class constructor.

    ENTRY:          hWndOwner       - The owning window.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
SESSIONS_DIALOG :: SESSIONS_DIALOG( HWND       		hWndOwner,
                                    AFP_SERVER_HANDLE   hServer,
				    const TCHAR *	pszServerName )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_USER_CONNECTIONS ), hWndOwner ),
    _sltUsersConnected( this, IDUC_DT_USERS_CONNECTED ),
    _pbDisc( this, IDUC_PB_DISCONNECT ),
    _pbDiscAll( this, IDUC_PB_DISCONNECT_ALL ),
    _pbSendMessage( this, IDUC_PB_SEND_MESSAGE ),
    _pbOK( this, IDOK ),
    _lbSessions( this, IDUC_LB_USER_CONNLIST, hServer ),
    _lbResources( this, IDUC_LB_VOLUMES, hServer ),
    _pszServerName( pszServerName ),
    _hServer( hServer )

{
    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Set the caption.
    //

    APIERR err = ::SetCaption( this, IDS_CAPTION_USERS, pszServerName );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    err = BASE_ELLIPSIS::Init();

    if( err != NO_ERROR )
    {
        ReportError( err );
	return;
    }

    //
    //  Fill the users Listbox.
    //

    err = Refresh();

    if( err != NO_ERROR )
    {
        ReportError( AFPERR_TO_STRINGID( err ));
	return;
    }

}   // SESSIONS_DIALOG :: SESSIONS_DIALOG

/*******************************************************************

    NAME:       SESSIONS_DIALOG :: ~SESSIONS_DIALOG

    SYNOPSIS:   SESSIONS_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
SESSIONS_DIALOG :: ~SESSIONS_DIALOG()
{
    BASE_ELLIPSIS::Term();

}   // SESSIONS_DIALOG :: ~SESSIONS_DIALOG


/*******************************************************************

    NAME:       SESSIONS_DIALOG :: Refresh

    SYNOPSIS:   Refresh the dialog.

    EXIT:       The dialog is feeling refreshed.

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
DWORD SESSIONS_DIALOG :: Refresh( VOID )
{
    //
    //  This is the currently selected item.
    //

    SESSIONS_LBI * plbiOld = _lbSessions.QueryItem();

    DWORD dwSessionIdOld = ( plbiOld == NULL ) ? 0 : plbiOld->QuerySessionId();

    //
    //  Refresh the user listbox.
    //

    DWORD err = _lbSessions.Refresh();

    if( err != NO_ERROR )
    {
        //
        //  There was an error refreshing the sessions listbox.
        //  So, nuke everything in the sessions and volumes listboxen,
        //  then disable the Disconnect[All] buttons.
        //

        _lbResources.DeleteAllItems();
        _lbResources.Invalidate( TRUE );
        _lbSessions.DeleteAllItems();
        _lbSessions.Invalidate( TRUE );

        _pbDisc.Enable( FALSE );
        _pbDiscAll.Enable( FALSE );

        _sltUsersConnected.SetText( SZ("??") );
        _sltUsersConnected.Enable( FALSE );

        return err;
    }

    //
    //  Get the "new" currently selected item (after the refresh).
    //

    SESSIONS_LBI * plbiNew = _lbSessions.QueryItem();

    DWORD dwSessionIdNew = (plbiNew == NULL) ? 0 : plbiNew->QuerySessionId();

    if( plbiNew == NULL )
    {
        //
        //  There is no current selection, so clear the resource listbox.
        //

        err = _lbResources.Refresh( 0 );
    }
    else
    if( ( plbiOld == NULL ) || ( dwSessionIdOld != dwSessionIdNew ) )
    {
        //
        //  Either there was no selection before the refresh, OR
        //  the current selection does not match the previous
        //  selection.  Therefore, fill the resource listbox with
        //  the current selection.
        //

        err = _lbResources.Refresh( plbiNew->QuerySessionId() );
    }
    else
    {
        //
        //  There was no selection change after refresh.  Therefore,
        //  refresh the resource listbox.
        //

        err = _lbResources.Refresh( plbiNew->QuerySessionId() );
    }


    if ( _lbSessions.QuerySelCount() > 0 )
    {
    	_pbDisc.Enable( TRUE );
    	_pbSendMessage.Enable( TRUE );
    }
    else
    {
	if ( _pbDisc.HasFocus() )
	{
	    _pbOK.ClaimFocus();
	}

	if ( _pbSendMessage.HasFocus() )
	{
	    _pbOK.ClaimFocus();
	}

    	_pbDisc.Enable( FALSE );
    	_pbSendMessage.Enable( FALSE );
    }

    if ( _lbSessions.QueryCount() > 0 )
    {
    	_pbDiscAll.Enable( TRUE );
    }
    else
    {
	if ( _pbDiscAll.HasFocus() )
	{
	    _pbOK.ClaimFocus();
	}

    	_pbDiscAll.Enable( FALSE );
    }

    _sltUsersConnected.Enable( TRUE );
    _sltUsersConnected.SetValue( _lbSessions.QueryCount() );

    return err;

}   // SESSIONS_DIALOG :: Refresh


/*******************************************************************

    NAME:           SESSIONS_DIALOG :: OnCommand

    SYNOPSIS:       Handle user commands.

    ENTRY:          cid                 - Control ID.
                    lParam              - lParam from the message.

    EXIT:           None.

    RETURNS:        BOOL                - TRUE  if we handled the msg.
                                          FALSE if we didn't.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
BOOL SESSIONS_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{
    if( event.QueryCid() == _lbSessions.QueryCid() )
    {
        //
        //  The SESSIONS_LISTBOX is trying to tell us something...
        //

        if( event.QueryCode() == LBN_SELCHANGE )
        {
            //
            //  The user changed the selection in the SESSIONS_LISTBOX.
            //

            SESSIONS_LBI * plbi = _lbSessions.QueryItem();
            UIASSERT( plbi != NULL );


	    DWORD err = _lbResources.Refresh( plbi->QuerySessionId() );

	    if ( err == NO_ERROR )
	    {

	    	//
	    	// Make sure that the total number of opens in the
	    	// resource listbox appears in the selected user's listbox item.
	    	//

		plbi->SetNumOpens( _lbResources.QueryNumOpens() );
		_lbSessions.InvalidateItem( _lbSessions.QueryCurrentItem(),
					    TRUE );
	    }
	    else
		Refresh();

        }

        return TRUE;
    }

    //
    // The user wants to blow away the selected user
    //

    if( event.QueryCid() == _pbDisc.QueryCid() )
    {
        //
        //  The user pressed the Disconnect button.  Blow off the
        //  selected user.
        //

        SESSIONS_LBI * plbi = _lbSessions.QueryItem();
        UIASSERT( plbi != NULL );

        if ( MsgPopup( this,
                       ( plbi->QueryNumOpens() > 0 ) ? IDS_DISCONNECT_SESS_OPEN
                                                     : IDS_DISCONNECT_SESS,
                       MPSEV_WARNING,
                       MP_YESNO,
                       plbi->QueryUserName(),
                       MP_NO ) == IDYES )
        {
    	    AUTO_CURSOR Cursor;

            //
            //  Blow off the user.
            //

            DWORD err = ::AfpAdminSessionClose( _hServer,
						plbi->QuerySessionId() );

            if( err != NO_ERROR )
            {
                //
                //  The session delete failed.  Tell the user the bad news.
                //

		if ( err == AFPERR_InvalidId )
		{
                    ::MsgPopup( this, IDS_SESSION_DELETED );
		}
		else
		{
                    ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
		}
            }

            //
            //  Refresh the dialog.
            //

            Refresh();

        }

        return TRUE;
    }

    //
    // The user wants to disconnect all the users
    //

    if( event.QueryCid() == _pbDiscAll.QueryCid() )
    {
        //
        //  The user pressed the Disconnect All button.  Blow off the
        //  users.
        //

        if ( MsgPopup( this,
                       ( _lbSessions.AreResourcesOpen() ) ?
			 		IDS_DISCONNECT_SESS_ALL_OPEN
                         	      : IDS_DISCONNECT_SESS_ALL,
                       MPSEV_WARNING,
                       MP_YESNO,
                       MP_NO ) == IDYES )
        {
    	    AUTO_CURSOR Cursor;

 	    //
            //  Blow off all users. SessionId of 0 will do the trick
            //

            DWORD err = ::AfpAdminSessionClose( _hServer, 0 );

            if( err != NERR_Success )
            {
              	//
                //  The session delete failed.  Tell the user the bad news.
                //

                MsgPopup( this,  AFPERR_TO_STRINGID( err ) );
            }

            //
            //  Kill the Resource Listbox.
            //

            _lbResources.DeleteAllItems();
            _lbResources.Invalidate( TRUE );

            //
            //  Refresh the dialog.
            //

            Refresh();

        }
        return TRUE;
    }

    //
    // Does the user want to send a message ?
    //

    if( event.QueryCid() == _pbSendMessage.QueryCid() )
    {
        SESSIONS_LBI * plbi = _lbSessions.QueryItem();
        UIASSERT( plbi != NULL );

    	_pbSendMessage.Enable( _lbSessions.QuerySelCount() > 0 );

        SEND_MSG_USER_DIALOG * pDlg = new SEND_MSG_USER_DIALOG(
					QueryHwnd(), 			
                                    	_hServer,
				    	_pszServerName,
				    	plbi->QueryUserName(),
					plbi->QuerySessionId() );

        DWORD err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : pDlg->Process();

        if( err != NERR_Success )
        {
            MsgPopup( this, AFPERR_TO_STRINGID( err ) );
        }

        delete pDlg;

        RepaintNow();

        Refresh();

        return TRUE;
    }


    return DIALOG_WINDOW :: OnCommand( event );

}   // SESSIONS_DIALOG :: OnCommand


/*******************************************************************

    NAME:       SESSIONS_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
ULONG SESSIONS_DIALOG :: QueryHelpContext( void )
{
    return HC_SESSIONS_DIALOG;

}   // SESSIONS_DIALOG :: QueryHelpContext


/*******************************************************************

    NAME:           SESSIONS_LISTBOX :: SESSIONS_LISTBOX

    SYNOPSIS:       SESSIONS_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    cid                 - The listbox CID.

                    pserver             - The target server.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
SESSIONS_LISTBOX :: SESSIONS_LISTBOX( OWNER_WINDOW * 	powner,
                                      CID             	cid,
                                      AFP_SERVER_HANDLE hServer )
  : BLT_LISTBOX( powner, cid ),
    _hServer( hServer )

{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Retrieve the time separator.
    //

    NLS_STR nlsTimeSep;
    APIERR  err;

    if( ( err = nlsTimeSep.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    INTL_PROFILE intl;

    if( ( err = intl.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    err = intl.QueryTimeSeparator( &nlsTimeSep );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    UIASSERT( nlsTimeSep.QueryTextLength() == 1 );

    _chTimeSep = *(nlsTimeSep.QueryPch());

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     COLS_UC_LB_USERS,
                                     powner,
                                     cid,
                                     TRUE) ;

}   // SESSIONS_LISTBOX :: SESSIONS_LISTBOX

/*******************************************************************

    NAME:       SESSIONS_LISTBOX :: Refresh

    SYNOPSIS:   Refresh the listbox, maintaining (as much as
                possible) the current selection state.

    EXIT:       The listbox is feeling refreshed.

    RETURNS:    DWORD                  - Any errors we encounter.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
DWORD SESSIONS_LISTBOX :: Refresh( VOID )
{
    INT iCurrent = QueryCurrentItem();
    INT iTop     = QueryTopIndex();

    DWORD dwCurrentSessionId = 0;

    //
    // Retrieve the session id of the current selection
    //

    if ( QuerySelCount() > 0 )
    {

    	dwCurrentSessionId = QueryItem( iCurrent )->QuerySessionId();
    }

    DWORD err = Fill();

    if( err != NO_ERROR )
    {
        return err;
    }

    INT cItems = QueryCount();

    if( cItems > 0 )
    {

  	INT iSel = -1;

	if ( ( iCurrent >= 0 ) && ( iCurrent < cItems ) )
  	{
	    //
	    // iCurrent is still valid, see if this item matches the
	    // pre-refresh item.
	    //
	
	    if ( dwCurrentSessionId == QueryItem( iCurrent )->QuerySessionId() )
	    {
		iSel = iCurrent;
	    }
	}

	if ( iSel < 0 )
	{
	    //
	    // Either iCurrent was out of range or the item does not
	    // match so search for it.
	    //

	    for ( INT i = 0; i < cItems; i++ )
	    {
		SESSIONS_LBI * plbi = QueryItem( i );

		if ( dwCurrentSessionId == plbi->QuerySessionId() )
		{
		    iSel = i;
		    break;
		}
	    }
	}

	if ( iSel < 0 )
	{
	    //
	    // If no selection found then default = first item
	    //

	    iSel = 0;
	}

	//
	// If the previous top index is out of range then
	// set default = first item.
	//

	if ( ( iTop < 0 ) || ( iTop >= cItems ) )
	{
	    iTop = 0;
	}

        SetTopIndex( iTop );
        SelectItem( iSel );
    }

    return NO_ERROR;

}   // SESSIONS_LISTBOX :: Refresh

/*******************************************************************

    NAME:           SESSIONS_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox with the available sharepoints.

    ENTRY:          None.

    EXIT:           The listbox is filled.

    RETURNS:        APIERR              - Any errors encountered.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
DWORD SESSIONS_LISTBOX :: Fill( VOID )
{
    //
    //  Just to be cool...
    //
    AUTO_CURSOR Cursor;


    SetRedraw( FALSE );
    DeleteAllItems();

    //
    // enumerate all sessions
    //
    PAFP_SESSION_INFO pAfpSessions;
    DWORD	      cEntriesRead;
    DWORD	      cTotalAvail;

    DWORD err = AfpAdminSessionEnum( _hServer,
				      (LPBYTE*)&pAfpSessions,
				      (DWORD)-1,	// Get all sessions
				      &cEntriesRead,
				      &cTotalAvail,
				      NULL );
					
    if( err != NO_ERROR )
    {
        return ( err ) ;
    }

    //
    //  We've got our enumeration, now find all users
    //
    PAFP_SESSION_INFO pAfpSessionIter = pAfpSessions;

    while( ( err == NO_ERROR ) && ( cEntriesRead-- ) )
    {
        SESSIONS_LBI * pulbi = new SESSIONS_LBI(
				pAfpSessionIter->afpsess_id,
				pAfpSessionIter->afpsess_username,
				pAfpSessionIter->afpsess_ws_name,
				pAfpSessionIter->afpsess_num_cons,
				pAfpSessionIter->afpsess_num_opens,
				pAfpSessionIter->afpsess_time,
                                _chTimeSep );


        if( AddItem( pulbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }

	pAfpSessionIter++;
    }

    ::AfpAdminBufferFree( pAfpSessions );

    SetRedraw( TRUE );
    Invalidate( TRUE );

    //
    //  Success!
    //

    return NO_ERROR;

}   // SESSIONS_LISTBOX :: Fill


/*******************************************************************

    NAME:       SESSIONS_LISTBOX :: AreResourcesOpen

    SYNOPSIS:   Returns TRUE if any user in the listbox has any
                resources open.

    RETURNS:    BOOL

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
BOOL SESSIONS_LISTBOX :: AreResourcesOpen( VOID ) const
{
    INT cItems = QueryCount();

    for( INT i = 0 ; i < cItems ; i++ )
    {
        SESSIONS_LBI * plbi = QueryItem( i );

        if( plbi->QueryNumOpens() > 0 )
        {
            return TRUE;
        }
    }

    return FALSE;

}   // SESSIONS_LISTBOX :: AreResourcesOpen


/*******************************************************************

    NAME:           SESSIONS_LBI :: SESSIONS_LBI

    SYNOPSIS:       SESSIONS_LBI class constructor.

    ENTRY:          pszShareName        - The sharepoint name.

                    pszPath             - The path for this sharepoint.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
SESSIONS_LBI :: SESSIONS_LBI( DWORD	    dwSessionId,
			      const TCHAR * pszUserName,
                              const TCHAR * pszComputerName,
			      DWORD	    cConnections,
                              DWORD         cOpens,
                              DWORD         dwTime,
                              TCHAR         chTimeSep ) :
    _dwSessionId( dwSessionId ),
    _dteIcon( IDBM_LB_USER ),
    _nlsConnections( cConnections ),
    _cOpens( cOpens ),
    _nlsOpens( cOpens ),
    _nlsUserName(),
    _nlsComputerName(),
    _nlsTime( dwTime, chTimeSep )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsConnections.QueryError() )  != NERR_Success ) ||
        ( ( err = _nlsOpens.QueryError() )  	  != NERR_Success ) ||
        ( ( err = _nlsComputerName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsUserName.QueryError() )     != NERR_Success ) ||
        ( ( err = _dteIcon.QueryError() ) 	  != NERR_Success ) ||
        ( ( err = _nlsTime.QueryError() ) 	  != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    //
    // If user name is NULL then a guest has loged on
    //

    if ( pszUserName == NULL )
    {
        err = _nlsUserName.Load( IDS_GUEST );
    }
    else
    {
    	err = _nlsUserName.CopyFrom( pszUserName );
    }


    if ( err == NERR_Success )
    {

	//
	// If the computer name is NULL then the computer name is
  	// UNKNOWN
	//

    	if ( pszComputerName == NULL )
    	{
            err = _nlsComputerName.Load( IDS_UNKNOWN );
      	}
    	else
    	{
    	    err = _nlsComputerName.CopyFrom( pszComputerName );
    	}
    }

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // SESSIONS_LBI :: SESSIONS_LBI


/*******************************************************************

    NAME:           SESSIONS_LBI :: ~SESSIONS_LBI

    SYNOPSIS:       SESSIONS_LBI class destructor.

    ENTRY:          None.

    EXIT:           The object is destroyed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
SESSIONS_LBI :: ~SESSIONS_LBI()
{

}   // SESSIONS_LBI :: ~SESSIONS_LBI


/*******************************************************************

    NAME:           SESSIONS_LBI :: SetNumOpens

    SYNOPSIS:       Sets the number of opens for this entry.

    ENTRY:          cOpens              - The number of open resources.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
APIERR SESSIONS_LBI :: SetNumOpens( DWORD cOpens )
{
    DEC_STR nls( cOpens );

    APIERR err = nls.QueryError();

    if( err == NERR_Success )
    {
        _nlsOpens.CopyFrom( nls );
    }

    return err;

}   // SESSIONS_LBI :: SetNumOpens

/*******************************************************************

    NAME:           SESSIONS_LBI :: Paint

    SYNOPSIS:       Draw an entry in SESSIONS_LISTBOX.

    ENTRY:          plb                 - Pointer to a BLT_LISTBOX.
                    hdc                 - The DC to draw upon.
                    prect               - Clipping rectangle.
                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
VOID SESSIONS_LBI :: Paint( LISTBOX *        plb,
                            HDC              hdc,
                            const RECT     * prect,
                            GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE_ELLIPSIS 	dteUserName(_nlsUserName.QueryPch(),plb,ELLIPSIS_RIGHT);
    STR_DTE_ELLIPSIS 	dteComputerName( _nlsComputerName.QueryPch(),
				      	plb,  ELLIPSIS_RIGHT );
    STR_DTE     	dteConnections( _nlsConnections.QueryPch() );
    STR_DTE     	dteOpens( _nlsOpens.QueryPch() );
    STR_DTE     	dteTime( _nlsTime.QueryPch() );

    DISPLAY_TABLE dtab( COLS_UC_LB_USERS,
		 	( (SESSIONS_LISTBOX *)plb )->QueryColumnWidths() );

    dtab[0] = (DTE *)&_dteIcon;
    dtab[1] = &dteUserName;
    dtab[2] = &dteComputerName;
    dtab[3] = &dteOpens;
    dtab[4] = &dteTime;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // SESSIONS_LBI :: Paint


/*******************************************************************

    NAME:       SESSIONS_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
WCHAR SESSIONS_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsUserName );

    return _nlsUserName.QueryChar( istr );

}   // SESSIONS_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       SESSIONS_LBI :: Compare

    SYNOPSIS:   Compare two SESSIONS_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
INT SESSIONS_LBI :: Compare( const LBI * plbi ) const
{
    return _nlsUserName._stricmp( ((const SESSIONS_LBI *)plbi)->_nlsUserName );

}   // SESSIONS_LBI :: Compare


/*******************************************************************

    NAME:           RESOURCES_LISTBOX :: RESOURCES_LISTBOX

    SYNOPSIS:       RESOURCES_LISTBOX class constructor.

    ENTRY:          powOwner            - The owning window.

                    cid                 - The listbox CID.

                    pserver             - The target server.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
RESOURCES_LISTBOX :: RESOURCES_LISTBOX( OWNER_WINDOW * 		powner,
                                        CID            		cid,
                                        AFP_SERVER_HANDLE       hserver )
  : BLT_LISTBOX( powner, cid, TRUE ),
    _hServer( hserver ),
    _cOpens( 0 )

{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Retrieve the time separator.
    //

    NLS_STR nlsTimeSep;

    if( !nlsTimeSep )
    {
        ReportError( nlsTimeSep.QueryError() );
        return;
    }

    INTL_PROFILE intl;

    if( !intl )
    {
        ReportError( intl.QueryError() );
        return;
    }

    APIERR err = intl.QueryTimeSeparator( &nlsTimeSep );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    UIASSERT( nlsTimeSep.QueryTextLength() == 1 );

    _chTimeSep = *(nlsTimeSep.QueryPch());

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     COLS_UC_LB_VOLUMES,
                                     powner,
                                     cid,
                                     TRUE) ;

}   // RESOURCES_LISTBOX :: RESOURCES_LISTBOX

/*******************************************************************

    NAME:       RESOURCES_LISTBOX :: Refresh

    SYNOPSIS:   Refreshes the listbox, maintaining (as much as
                possible) the relative position of the current
                selection.

    EXIT:       The listbox is feeling refreshed.

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
DWORD RESOURCES_LISTBOX :: Refresh( DWORD dwSessionId )
{
    INT iCurrent = QueryCurrentItem();
    INT iTop     = QueryTopIndex();

    DWORD err = Fill( dwSessionId );

    if( err != NO_ERROR )
    {
        return err;
    }

    INT cItems = QueryCount();

    if( cItems > 0 )
    {
        iCurrent = min( max( iCurrent, 0 ), cItems - 1 );
        iTop     = min( max( iTop, 0 ), cItems - 1 );

        SelectItem( iCurrent );
        SetTopIndex( iTop );
    }

    return NO_ERROR;
}

/*******************************************************************

    NAME:           RESOURCES_LISTBOX :: Fill

    SYNOPSIS:       Fills the listbox with the available sharepoints.

    ENTRY:          None.

    EXIT:           The listbox is filled.

    RETURNS:        DWORD              - Any errors encountered.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
DWORD RESOURCES_LISTBOX :: Fill( DWORD dwSessionId )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    //  Nuke the listbox.
    //

    DeleteAllItems();

    //
    //  If the session Id is zero (a valid scenario) then
    //  there are no resources in the listbox.
    //

    if( dwSessionId == 0 )
    {
        return NO_ERROR;
    }

    //
    //  Enumerate the connections to this volume.
    //
    //
    //  We enumerate the connections.
    //

    PAFP_CONNECTION_INFO pAfpConnections;
    DWORD	      	 cEntriesRead;
    DWORD	         cTotalAvail;

    DWORD err = ::AfpAdminConnectionEnum( _hServer,
				      	  (LPBYTE*)&pAfpConnections,
					  AFP_FILTER_ON_SESSION_ID,
					  dwSessionId,
				      	  (DWORD)-1,	// Get all conenctions
				          &cEntriesRead,
				          &cTotalAvail,
				          NULL );

    //
    //  See if the connections are available.
    //

    if( err != NO_ERROR )
    {
        return err;
    }

    //  Now that we know the connection info is available,
    //  let's nuke everything in the listbox.
    //


    SetRedraw( FALSE );
    DeleteAllItems();

    //
    //  For iterating the available connections.
    //

    PAFP_CONNECTION_INFO pAfpConnIter = pAfpConnections;

    //
    //  Iterate the connections adding them to the listbox.
    //

    _cOpens = 0;

    while( ( err == NO_ERROR ) && ( cEntriesRead-- ) )
    {

        RESOURCES_LBI * prlbi = new RESOURCES_LBI(
					pAfpConnIter->afpconn_volumename,
					pAfpConnIter->afpconn_num_opens,
					pAfpConnIter->afpconn_time,
                                        _chTimeSep );

	_cOpens += pAfpConnIter->afpconn_num_opens;

        if( AddItem( prlbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
	
	pAfpConnIter++;
    }

    ::AfpAdminBufferFree( pAfpConnections );

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}   // RESOURCES_LISTBOX :: Fill


/*******************************************************************

    NAME:           RESOURCES_LBI :: RESOURCES_LBI

    SYNOPSIS:       RESOURCES_LBI class constructor.

    ENTRY:          pszResourceName     - The sharepoint name.

                    pszPath             - The path for this sharepoint.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
RESOURCES_LBI :: RESOURCES_LBI( const TCHAR * pszResourceName,
                                DWORD         cOpens,
                                DWORD         ulTime,
                                TCHAR         chTimeSep ) :
    _pdteBitmap( NULL ),
    _nlsResourceName( pszResourceName ),
    _nlsOpens( cOpens ),
    _nlsTime( ulTime, chTimeSep )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsResourceName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsOpens.QueryError()        ) != NERR_Success ) ||
        ( ( err = _nlsTime.QueryError()         ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    _pdteBitmap = new DMID_DTE( IDBM_LB_GOOD_VOLUME );

    if( _pdteBitmap == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

}   // RESOURCES_LBI :: RESOURCES_LBI


/*******************************************************************

    NAME:           RESOURCES_LBI :: ~RESOURCES_LBI

    SYNOPSIS:       RESOURCES_LBI class destructor.

    ENTRY:          None.

    EXIT:           The object is destroyed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
RESOURCES_LBI :: ~RESOURCES_LBI()
{
    delete _pdteBitmap;
    _pdteBitmap = NULL;

}   // RESOURCES_LBI :: ~RESOURCES_LBI


/*******************************************************************

    NAME:           RESOURCES_LBI :: Paint

    SYNOPSIS:       Draw an entry in RESOURCES_LISTBOX.

    ENTRY:          plb                 - Pointer to a BLT_LISTBOX.
                    hdc                 - The DC to draw upon.
                    prect               - Clipping rectangle.
                    pGUILTT             - GUILTT info.

    EXIT:           The item is drawn.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
VOID RESOURCES_LBI :: Paint( LISTBOX *     plb,
                             HDC           hdc,
                             const RECT  * prect,
                             GUILTT_INFO * pGUILTT ) const
{
    STR_DTE_ELLIPSIS	dteResourceName( _nlsResourceName.QueryPch(),
					 plb, ELLIPSIS_RIGHT );
    STR_DTE     	dteOpens( _nlsOpens.QueryPch() );
    STR_DTE     	dteTime( _nlsTime.QueryPch() );

    DISPLAY_TABLE dtab( COLS_UC_LB_VOLUMES,
			( (RESOURCES_LISTBOX *)plb )->QueryColumnWidths() );

    dtab[0] = _pdteBitmap;
    dtab[1] = &dteResourceName;
    dtab[2] = &dteOpens;
    dtab[3] = &dteTime;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // RESOURCES_LBI :: Paint


/*******************************************************************

    NAME:       RESOURCES_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
WCHAR RESOURCES_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsResourceName );

    return _nlsResourceName.QueryChar( istr );

}   // RESOURCES_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       RESOURCES_LBI :: Compare

    SYNOPSIS:   Compare two RESOURCES_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
	NarenG	    Stole from Server Manager

********************************************************************/
INT RESOURCES_LBI :: Compare( const LBI * plbi ) const
{
    return _nlsResourceName._stricmp( ((const RESOURCES_LBI *)plbi)->_nlsResourceName );

}   // RESOURCES_LBI :: Compare
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\smx.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    smx.cxx

	This module contains all the entry points for the Server Manager
	extension.


    FILE HISTORY:
        NarenG     6-Oct-1992 	Created.

*/


#define INCL_NET
#define INCL_NETLIB
#define INCL_NETSERVICE
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#include <uiassert.hxx>
#include <uitrace.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#include <dbgstr.hxx>

extern "C"
{
#include <smx.h>
#include <afpmgr.h>
#include <macfile.h>
}

#include <startafp.hxx>
#include <senddlg.hxx>
#include <srvprop.hxx>
#include <volmgt.hxx>

extern "C"
{
    //
    //  Globals.
    //

    extern HINSTANCE _hInstance;// Exported by the afpmgr.cxx module.

    static HWND   _hWnd;	// Handle to the owner window.

    static DWORD  _dwVersion;	// Will contain the SMX version being used.

    static DWORD  _dwDelta;	// Used to manipulate menu items.

    static HMENU  _hMenu;	// Created at load time.

}   // extern "C"





/*******************************************************************

    NAME:       SMELoadMenu

    SYNOPSIS:   This entrypoint is to notify the DLL that it
                is getting loaded by the Server Manager.

    ENTRY:      hWnd                    - The "owning" window.

                psmsload                - Points to an SMS_LOADMENU
                                          structure containing load
                                          parameters.

    RETURNS:    DWORD                   - Actually an APIERR, should be
                                          0 if successful.

    HISTORY:
        NarenG     5-Nov-1992 	Created.

********************************************************************/
DWORD PASCAL SMELoadMenuW( HWND          hWnd,
                           PSMS_LOADMENU psmsload )
{

    if( psmsload == NULL )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // 
    // Save the handle to the owner window
    //

    _hWnd = hWnd;

    //
    // Set the version field to the lower of the our version and the
    // Server manager version
    //

    _dwVersion = SME_VERSION;

    if( psmsload->dwVersion > _dwVersion )
    {
        psmsload->dwVersion = _dwVersion;
    }
    else
    if( psmsload->dwVersion < _dwVersion )
    {
        _dwVersion = psmsload->dwVersion;
    }

    //
    // Delta to be added to the menu ID before trying to manipulate
    // any menu item
    //

    _dwDelta = psmsload->dwMenuDelta;

    //
    // Only enumerate AFP type servers
    //

    psmsload->dwServerType = SV_TYPE_AFP;

    RESOURCE_STR nlsMenuName( IDS_AFPMGR_MENU_NAME );

    APIERR err;
    if ( ( err = nlsMenuName.QueryError() ) != NERR_Success )
    {
    	return err;       
    }

    if ( err = nlsMenuName.MapCopyTo( psmsload->szMenuName,
                                      sizeof(psmsload->szMenuName)))
    {
 	return err;
    }

    _hMenu = ::LoadMenu(::_hInstance,MAKEINTRESOURCE(ID_SRVMGR_MENU));

    if ( _hMenu == NULL )
    {
 	return ::GetLastError();
    }

    psmsload->hMenu = _hMenu;

    RESOURCE_STR nlsHelpFileName( IDS_AFPMGR_HELPFILENAME );

    if ( ( err = nlsHelpFileName.QueryError() ) != NERR_Success )
    {
    	return err;       
    }

    if ( err = nlsHelpFileName.MapCopyTo( psmsload->szHelpFileName,
                                          sizeof(psmsload->szHelpFileName)))
    {
 	return err;
    }

    return NO_ERROR;

}   // SMELoadMenu


/*******************************************************************

    NAME:       SMEGetExtendedErrorString

    SYNOPSIS:   If SMELoad returns ERROR_EXTENDED_ERROR, then this
                entrypoint will be called to retrieve the error
                text associated with the failure condition.

    RETURNS:    LPTSTR                  - The extended error text.

    HISTORY:
        NarenG     5-Nov-1992 	Created.

********************************************************************/
LPTSTR PASCAL SMEGetExtendedErrorStringW( VOID )
{
    return (TCHAR*)TEXT("");

}   // SMEGetExtendedErrorString


/*******************************************************************

    NAME:       SMEUnloadMenu

    SYNOPSIS:   Notifies the extension DLL that it is getting unloaded.

    HISTORY:
        NarenG     5-Nov-1992 	Created.

********************************************************************/
VOID PASCAL SMEUnloadMenu( VOID )
{

    //
    //  This space intentionally left blank.
    //

}   // SMEUnload


/*******************************************************************

    NAME:       SMEInitializeMenu

    SYNOPSIS:   Notifies the DLL that the main menu is
                getting activated.  Do all menu manipulations here.

    HISTORY:
        NarenG     5-Nov-1992 	Created.

********************************************************************/
VOID PASCAL SMEInitializeMenu( VOID )
{
    //
    // If there was no server selected. Disable all the menu items
    //

    SMS_GETSELCOUNT  smsSelCount;

    if( ( !SendMessage(	_hWnd, 
			SM_GETSELCOUNT, 
			0, 
			(LPARAM)&smsSelCount ) ) 
	||
        ( smsSelCount.dwItems == 0 ) )
    {
	EnableMenuItem( _hMenu,
		        (UINT)(IDM_SEND_MESSAGE+_dwDelta),
			(UINT)MF_GRAYED);
 
	EnableMenuItem( _hMenu,
			(UINT)(IDM_PROPERTIES+_dwDelta),
			(UINT)MF_GRAYED);

	EnableMenuItem( _hMenu,
			(UINT)(IDM_VOLUME_MGT+_dwDelta),
			(UINT)MF_GRAYED);
    }
    else
    {
	EnableMenuItem( _hMenu,
			(UINT)(IDM_SEND_MESSAGE+_dwDelta),
			(UINT)MF_ENABLED);

    	EnableMenuItem( _hMenu,
			(UINT)(IDM_PROPERTIES+_dwDelta),
			(UINT)MF_ENABLED);

    	EnableMenuItem( _hMenu,	
			(UINT)(IDM_VOLUME_MGT+_dwDelta),
			(UINT)MF_ENABLED);
    }

    return;

}   // SMEInitializeMenu


/*******************************************************************

    NAME:       SMERefresh

    SYNOPSIS:   Notifies the extension DLL that the user has requested
                a refresh.  The extension should use this opportunity
                to update any cached data.

    HISTORY:
        NarenG     5-Nov-1992 	Created.

********************************************************************/
VOID PASCAL SMERefresh( HWND hWnd )
{

    //
    //  This space intentionally left blank.
    //

}   // SMERefresh

/*******************************************************************

    NAME:       SMEValidate

    SYNOPSIS:   Called to validate a server that the server manager
		does not recognize. We ignore these servers.

    HISTORY:
        NarenG     5-Nov-1992 	Created.

********************************************************************/
BOOL PASCAL SMEValidateW( PSMS_VALIDATE psmsValidate )
{
    return FALSE;

}   // SMEValidate


/*******************************************************************

    NAME:       SMEMenuAction

    SYNOPSIS:   Notifies the DLL that one of its menu
                items has been selected.

    ENTRY:      dwEventId               - The menu ID being activated
                                          (should be 1-99).

    HISTORY:
        NarenG     5-Nov-1992 	Created.

********************************************************************/
VOID PASCAL SMEMenuAction( HWND hWnd, DWORD dwEventId )
{
    DWORD 	      err; 
    AFP_SERVER_HANDLE hServer = NULL;

    AUTO_CURSOR Cursor;

    // 
    // Get the current server selection
    //

    SMS_GETSERVERSEL2 smsSel;

    if( !SendMessage( _hWnd, SM_GETSERVERSEL2, 0, (LPARAM)&smsSel ) )
    {
	// 
	// Tell the user the bad news
 	//

        ::MsgPopup( _hWnd,
                    IDS_COULD_NOT_GET_CURRENT_SEL,
                    MPSEV_WARNING,
                    MP_OK );
	return;
    }

    //
    // Check if the server focus of the current selection is running AFP
    //

    BOOL fIsAfpRunning;

    if ( ( err = IsAfpServiceRunning( smsSel.szServerName,
				      &fIsAfpRunning ) ) != NERR_Success )
    {
        if ( err == IDS_MACFILE_NOT_INSTALLED )
        {
            ::MsgPopup( _hWnd, 
                         err, 
                         MPSEV_ERROR, 
                         MP_OKCANCEL,
                         smsSel.szServerName,
                         MP_OK );
        }
        else
        {
    	    ::MsgPopup( _hWnd, err );
        }

	return;
    }

    if ( !fIsAfpRunning )
    {
	//
	// Ask the user if he/she wants to start it.
	//

	if ( MsgPopup( hWnd,
                       IDS_START_AFPSERVER_NOW,
                       MPSEV_WARNING,
                       MP_YESNO,
                       MP_YES ) == IDNO ) 
	{
	    //
	    // User does not want to start the afpserver so simply return.
	    //
	
	    return;
	}

        //
        //  Start the AFP Service
        //

        err = StartAfpService( hWnd, smsSel.szServerName );

    	if ( err != NERR_Success ) 
	{
    	    ::MsgPopup( _hWnd, err );
	    return;
	}

    }

    //
    // Set up an RPC conenction with the server
    //

    if( (err = ::AfpAdminConnect( smsSel.szServerName, &hServer )) != NO_ERROR)
    {
    	::MsgPopup( _hWnd, err );
	return;
    }

    //
    // What does the user want to do with the server ?
    //

    switch( dwEventId )
    {

    case IDM_SEND_MESSAGE:

	{
	//
      	//  Invoke the send message Dialog.
        //

        SEND_MSG_SERVER_DIALOG * pSendMsgDlg = new SEND_MSG_SERVER_DIALOG( 
						   _hWnd,
						   hServer,
                                                   smsSel.szServerName );

        err = ( pSendMsgDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY  
				      : pSendMsgDlg->Process();

        delete pSendMsgDlg;

	break;
	}

    case IDM_PROPERTIES:

	{
	//
      	//  Invoke the Main Property Dialog.
        //

        SERVER_PROPERTIES * pPropDlg = new SERVER_PROPERTIES( 
						   _hWnd,
						   hServer,
                                                   smsSel.szServerName );

        err = ( pPropDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY  
				   : pPropDlg->Process();

        delete pPropDlg;

        break;
	}

    case IDM_VOLUME_MGT:

	{
	//
      	//  Invoke the volume management dialog
        //

        VOLUME_MANAGEMENT_DIALOG * pVolMgtDlg = new VOLUME_MANAGEMENT_DIALOG( 
						   _hWnd,
						   hServer,
                                                   smsSel.szServerName );

        err = ( pVolMgtDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY  
				     : pVolMgtDlg->Process();

        delete pVolMgtDlg;

        break;
	}

    default :
	{
        return;
	}
    }

    if( err != NERR_Success )
    {
        ::MsgPopup( _hWnd, AFPERR_TO_STRINGID(err) );
    }

    if ( hServer != NULL )
    {
	::AfpAdminDisconnect( hServer );
    }

}   // SMEMenuAction
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\srvprop.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    srvprop.cxx
    Class definitions for the SERVER_PROPERTIES class.

    This file contains the class declarations for the SERVER_PROPERTIES.
    The SERVER_PROPERTIES class implements the Server Manager main property 
    sheet.  

    FILE HISTORY:
        NarenG      1-Oct-1992  Stole from NETUI server manager. 
				Removed LM specific stuff and put AFP
				specific stuff

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <dbgstr.hxx>

#include <lmsrvres.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>

}   // extern "C"

#include <srvprop.hxx>
#include <volumes.hxx>
#include <sessions.hxx>
#include <openfile.hxx>
#include <util.hxx>
#include <server.hxx>


#define PATH_SEPARATOR          TCH('\\')


//
//  This macro is used in the SERVER_PROPERTIES::OnCommand() method to
//  invoke the appropriate dialog when one of the graphical buttons is
//  pressed.  If DIALOG_WINDOW's destructor were virtual, we could do
//  all of this in a common worker function, thus reducing code size.
//
//  NOTE:  This macro assumes that the dialog constructor takes an HWND
//         and a AFP_SERVER_HANDLE.  This macro further assumes that there 
//	   is a variable named _hserver of type AFP_SERVER_HANDLE in some 
//	   visible scope.
//

#define SUBPROPERTY( DlgClass )                                         \
    if( TRUE )                                                          \
    {                                                                   \
        DlgClass * pDlg = new DlgClass( QueryHwnd(), 			\
					_hServer,			\
					_pszServerName  );        	\
                                                                        \
        DWORD err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY          \
                                      : pDlg->Process();                \
                                                                        \
        if( err != NERR_Success )                                       \
        {                                                               \
            MsgPopup( this, err );                                      \
        }                                                               \
                                                                        \
        delete pDlg;                                                    \
                                                                        \
        RepaintNow();                                                   \
        Refresh();                                                      \
                                                                        \
        return TRUE;                                                    \
    }                                                                   \
    else


//
//  SERVER_PROPERTIES methods.
//

/*******************************************************************

    NAME:       SERVER_PROPERTIES :: SERVER_PROPERTIES

    SYNOPSIS:   SERVER_PROPERTIES class constructor.

    ENTRY:      hWndOwner               - Handle to the "owning" window.

                pszServerName           - Name of the target server.

    EXIT:       The object is constructed.

    RETURNS:    No return value.

    NOTES:      All SERVER_PROPERTIES methods assume that the current
                user has sufficient privilege to adminster the target
                server.

    HISTORY:
        NarenG      1-Oct-1992 	Replaced LM stuff with AFP stuff

********************************************************************/
SERVER_PROPERTIES :: SERVER_PROPERTIES( HWND              hWndOwner,
				        AFP_SERVER_HANDLE hServer,
                                        const TCHAR *     pszServerName )
  : DIALOG_WINDOW( IDD_SERVER_PROPERTIES, hWndOwner ),
    _pszServerName( pszServerName ),
    _sltCurrentActiveSessions( this, IDSP_DT_CURRENT_SESSIONS ),
    _sltCurrentOpenFiles( this, IDSP_DT_CURRENT_OPENFILES ),
    _sltCurrentFileLocks( this, IDSP_DT_CURRENT_FILELOCKS ),
    _hServer( hServer ),
/* MSKK NaotoN Appended for Localizing into Japanese 8/24/93 */
#ifdef	JAPAN
    _fontHelv( (TCHAR *)"lr SVbN", FIXED_PITCH | FF_MODERN, 8, FONT_ATT_DEFAULT ),
#else
    _fontHelv( FONT_DEFAULT ),
#endif
/*							end  */
    _gbUsers( this,
              IDSP_GB_USERS,
              MAKEINTRESOURCE( IDBM_USERS )),
    _gbVolumes( this,
              IDSP_GB_VOLUMES,
              MAKEINTRESOURCE(IDBM_FILES) ),
    _gbOpenFiles( this,
              IDSP_GB_OPENFILES,
              MAKEINTRESOURCE(IDBM_OPENRES) ),
    _gbServerParms( this,
              IDSP_GB_SERVERPARMS,
              MAKEINTRESOURCE(IDBM_SERVERPARMS) )
{

    AUTO_CURSOR Cursor;

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_fontHelv )
    {
        ReportError( _fontHelv.QueryError() );
        return;
    }

    //
    //  Display the dynamic server data.
    //

    DWORD err = Refresh();

    if ( err != NO_ERROR )
    {
        ReportError( err );
        return;
    }

    //
    //  Initialize our magic button bar.
    //

    err = SetupButtonBar();

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Set the dialog caption.
    //

    err = ::SetCaption( this, IDS_CAPTION_PROPERTIES, _pszServerName );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // SERVER_PROPERTIES :: SERVER_PROPERTIES


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: ~SERVER_PROPERTIES

    SYNOPSIS:   SERVER_PROPERTIES class destructor.

    ENTRY:      None.

    EXIT:       The object is destroyed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        NarenG      1-Oct-1992 	Replaced LM stuff with AFP stuff

********************************************************************/
SERVER_PROPERTIES :: ~SERVER_PROPERTIES()
{

    // 
    // This space intentionally left blank
    //

}   // SERVER_PROPERTIES :: ~SERVER_PROPERTIES


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: OnCommand

    SYNOPSIS:   This method is called whenever a WM_COMMAND message
                is sent to the dialog procedure.  In this case, we're
                only interested in commands sent as a result of the
                user clicking one of the graphical buttons.

    ENTRY:      cid                     - The control ID from the
                                          generating control.

                lParam                  - Varies.

    EXIT:       The command has been handled.

    RETURNS:    BOOL                    - TRUE  if we handled the command.
                                          FALSE if we did not handle
                                          the command.

    NOTES:

    HISTORY:
        NarenG      1-Oct-1992 	Replaced LM stuff with AFP stuff

********************************************************************/
BOOL SERVER_PROPERTIES :: OnCommand( const CONTROL_EVENT & event )
{
    AUTO_CURSOR Cursor;

    switch ( event.QueryCid() )
    {
    case IDSP_GB_USERS:

        //
        //  The Users dialog.
        //

        SUBPROPERTY( SESSIONS_DIALOG );
        break;

    case IDSP_GB_VOLUMES:

        //
        //  The Files dialog.
        //

        SUBPROPERTY( VOLUMES_DIALOG );
        break;

    case IDSP_GB_OPENFILES:

        //
        //  The In Use dialog.
        //

        SUBPROPERTY( OPENS_DIALOG );
        break;

    case IDSP_GB_SERVERPARMS:

        //
        //  The Server Parameters dialog
        //

        SUBPROPERTY( SERVER_PARAMETERS_DIALOG );
        break;

    default:

        //
        //  If we made it this far, then we're not interested
        //  in the command.
        //

        return FALSE;
    }

}   // SERVER_PROPERTIES :: OnCommand


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    ENTRY:      None.

    EXIT:       None.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    NOTES:

    HISTORY:
        NarenG      1-Oct-1992 	Replaced LM stuff with AFP stuff

********************************************************************/
ULONG SERVER_PROPERTIES :: QueryHelpContext( void )
{
    return HC_SERVER_PROPERTIES;

}   // SERVER_PROPERITES :: QueryHelpContext


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: Refresh

    SYNOPSIS:   This method will display any server data which may
                need to be refreshed during the lifetime of the
                properties dialog.  This includes the number of
                active sessions, open files, etc.

    ENTRY:      None.

    EXIT:       The dynamic server data has been displayed.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        NarenG      1-Oct-1992 	Replaced LM stuff with AFP stuff

********************************************************************/
DWORD SERVER_PROPERTIES :: Refresh( VOID )
{
    //
    //  This may take a while...
    //

    AUTO_CURSOR Cursor;

    //
    //  This string will contain our "??" string.
    //

    const TCHAR * pszNotAvail = SZ("??");

    //
    //  Retrieve the statitistics server info.
    //

    PAFP_STATISTICS_INFO pAfpStats;

    DWORD err = ::AfpAdminStatisticsGet( _hServer, (LPBYTE*)&pAfpStats );


    if( err == NO_ERROR )
    {
    	_sltCurrentActiveSessions.Enable( TRUE );
    	_sltCurrentActiveSessions.SetValue( pAfpStats->stat_CurrentSessions);

    	_sltCurrentOpenFiles.Enable( TRUE );
    	_sltCurrentOpenFiles.SetValue( pAfpStats->stat_CurrentFilesOpen );

    	_sltCurrentFileLocks.Enable( TRUE );
    	_sltCurrentFileLocks.SetValue( pAfpStats->stat_CurrentFileLocks );

 	::AfpAdminBufferFree( pAfpStats );

    }
    else
    {
    	_sltCurrentActiveSessions.SetText( pszNotAvail );
    	_sltCurrentActiveSessions.Enable( FALSE );

    	_sltCurrentOpenFiles.SetText( pszNotAvail );
    	_sltCurrentOpenFiles.Enable( FALSE );

    	_sltCurrentFileLocks.SetText( pszNotAvail );
    	_sltCurrentFileLocks.Enable( FALSE );

    }

    return err;

}   // SERVER_PROPERTIES :: Refresh


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: SetupButtonBar

    SYNOPSIS:   The method initializes the magic scrolling button bar.

    ENTRY:      None.

    EXIT:       The button bar has been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:

    HISTORY:
        NarenG      1-Oct-1992 	Replaced LM stuff with AFP stuff

********************************************************************/
APIERR SERVER_PROPERTIES :: SetupButtonBar( VOID )
{
    //
    //  Setup the graphical buttons.
    //

    InitializeButton( &_gbUsers,      IDS_BUTTON_USERS,      NULL );
    InitializeButton( &_gbVolumes,    IDS_BUTTON_VOLUMES,    NULL );
    InitializeButton( &_gbOpenFiles,  IDS_BUTTON_OPENFILES,  NULL );
    InitializeButton( &_gbServerParms,IDS_BUTTON_SERVERPARMS,NULL );

    //
    //  Success!
    //

    return NO_ERROR;

}   // SERVER_PROPERTIES :: SetupButtonBar


/*******************************************************************

    NAME:       SERVER_PROPERTIES :: InitializeButton

    SYNOPSIS:   Initialize a single graphical button for use in
                the graphical button bar.

    ENTRY:      pgb                     - Pointer to a GRAPHICAL_BUTTON.

                msg                     - The resource ID of the string
                                          to be used as button text.

                bmid                    - The bitmap ID for the button
                                          status bitmap.  This is the
                                          tiny bitmap displayed in the
                                          upper left corner of the button.

    EXIT:       The button has been initialized.

    RETURNS:    No return value.

    NOTES:

    HISTORY:
        NarenG      1-Oct-1992 	Replaced LM stuff with AFP stuff

********************************************************************/
VOID SERVER_PROPERTIES :: InitializeButton( GRAPHICAL_BUTTON * pgb,
                                            MSGID              msg,
                                            BMID               bmid )
{
    //
    //  This NLS_STR is used to retrieve strings
    //  from the resource string table.
    //

    STACK_NLS_STR( nlsButtonText, MAX_RES_STR_LEN );

    nlsButtonText.Load( msg );
    UIASSERT( nlsButtonText.QueryError() == NERR_Success );

    pgb->SetFont( _fontHelv );
    pgb->SetStatus( bmid );
    pgb->SetText( nlsButtonText.QueryPch() );

}   // SERVER_PROPERTIES :: InitializeButton
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\server.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		Copyright(c) Microsoft Corp., 1991  		     **/
/**********************************************************************/

/*
   server.cxx
     This file contains the definition of SERVER_PARAMETERS_DIALOG.
 
   History:
     NarenG		12/15/92	Created.
*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}

#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <netname.hxx>

#include "util.hxx"
#include "srvname.hxx"
#include "server.hxx"

/*******************************************************************

    NAME:	SERVER_PARAMETERS_DIALOG::SERVER_PARAMETERS_DIALOG

    SYNOPSIS:   Constructor for SERVER_PARAMETERS_DIALOG class

    ENTRY:      hwndParent     - handle of parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		12/15/92		Created

********************************************************************/

SERVER_PARAMETERS_DIALOG::SERVER_PARAMETERS_DIALOG( 
				 	HWND 		  hwndParent,
				        AFP_SERVER_HANDLE hServer,
					const TCHAR * 	  pszServerName )
    : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_SERVER_PARAMETERS_DIALOG ), 
		     hwndParent ),
      _sltServerName( this, IDSP_SLT_SERVERNAME, ELLIPSIS_RIGHT ),
      _mleTextMsg( this, IDSP_MLE_LOGINMSG, AFP_MESSAGE_LEN ),
      _chkAllowPasswordSaves( this,IDSP_CHK_PASSWORD_SAVES ),
      _chkAllowGuestLogons( this, IDSP_CHK_GUESTLOGONS ),
      _chkAllowClearTextPasswords( this,IDSP_CHK_CLEARTEXT ),
      _mgrpSessionLimit( this, IDSP_RB_UNLIMITED, 2, IDSP_RB_UNLIMITED),  
      _spsleSessions( this, IDSP_SLE_SESSIONS, 1, 1, AFP_MAXSESSIONS-1, 
                      TRUE, IDSP_SLE_SESSIONS_GROUP ),
      _spgrpSessions(this,IDSP_SB_SESSIONS_GROUP, IDSP_SB_SESSIONS_UP,
		  IDSP_SB_SESSIONS_DOWN),
      _pbChange( this, IDSP_PB_CHANGE ),
      _dwParmNum( 0 ),
      _hServer( hServer )
{

    UNREFERENCED( pszServerName );

    // 
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _mgrpSessionLimit.QueryError()) != NERR_Success )
       || ((err = _spgrpSessions.AddAssociation(&_spsleSessions))!=NERR_Success)
       || ((err = _mgrpSessionLimit.AddAssociation( IDSP_RB_SESSIONS,
						    &_spgrpSessions ))
	          				   != NERR_Success ) 
       || ((err = _pbChange.QueryError()) != NERR_Success )
       || ((err = _chkAllowPasswordSaves.QueryError()) != NERR_Success )
       || ((err = _chkAllowGuestLogons.QueryError()) != NERR_Success )
       || ((err = _chkAllowClearTextPasswords.QueryError()) != NERR_Success )
       || ((err = _mleTextMsg.QueryError()) != NERR_Success )
       || ((err = _sltServerName.QueryError()) != NERR_Success )
       ) 
    {
        ReportError( err );
        return;
    }

    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    err = BASE_ELLIPSIS::Init();

    if( err != NO_ERROR )
    {
        ReportError( err );
	return;
    }

    //
    //  Set the caption to "SFM Server Attributes of Server".
    //

    err = ::SetCaption( this, IDS_CAPTION_ATTRIBUTES, pszServerName );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    // Get the server information.
    //

    PAFP_SERVER_INFO pAfpServerInfo;

    err = ::AfpAdminServerGetInfo( _hServer, (LPBYTE*)&pAfpServerInfo );

    if ( err != NO_ERROR )
    {
	ReportError( AFPERR_TO_STRINGID( err ) );
	return;
    }

    // 
    // Set the information
    // 

    _sltServerName.SetText( pAfpServerInfo->afpsrv_name );

    _chkAllowPasswordSaves.SetCheck( 
				(INT)(pAfpServerInfo->afpsrv_options &
				      AFP_SRVROPT_ALLOWSAVEDPASSWORD ));

    _chkAllowGuestLogons.SetCheck( 
				(INT)(pAfpServerInfo->afpsrv_options &
		     		      AFP_SRVROPT_GUESTLOGONALLOWED ));

    _chkAllowClearTextPasswords.SetCheck( 
				(INT)(!(pAfpServerInfo->afpsrv_options &
				       AFP_SRVROPT_CLEARTEXTLOGONALLOWED )));

    SetSessionLimit( pAfpServerInfo->afpsrv_max_sessions );
	
    _mleTextMsg.SetText( pAfpServerInfo->afpsrv_login_msg );

    //
    //  Direct the message edit control not to add end-of-line
    //  character from wordwrapped text lines.
    //

    _mleTextMsg.SetFmtLines(FALSE);

    ::AfpAdminBufferFree( pAfpServerInfo );

    _pbChange.ClaimFocus();
}

/*******************************************************************

    NAME:       SERVER_PARAMETERS_DIALOG :: ~SERVER_PARAMETERS_DIALOG

    SYNOPSIS:   SERVER_PARAMETERS_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
SERVER_PARAMETERS_DIALOG :: ~SERVER_PARAMETERS_DIALOG()
{
    BASE_ELLIPSIS::Term();

}   // SERVER_PARAMETERS_DIALOG :: ~SERVER_PARAMETERS_DIALOG

/*******************************************************************

    NAME:       SERVER_PARAMETERS_DIALOG :: OnCommand

    SYNOPSIS:   This method is called whenever a WM_COMMAND message
                is sent to the dialog procedure.

    ENTRY:      cid                     - The control ID from the
                                          generating control.

    EXIT:       The command has been handled.

    RETURNS:    BOOL                    - TRUE  if we handled the command.
                                          FALSE if we did not handle
                                          the command.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
BOOL SERVER_PARAMETERS_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{

    DWORD err;

    if( event.QueryCid() == _pbChange.QueryCid() )
    {
    	//
    	//  Just to be cool...
    	//

    	AUTO_CURSOR Cursor;

        //
        //  Bring up the change server name dialog
        //

	NLS_STR nlsServerName;
    	BOOL    fOK;

	if ( ( err = nlsServerName.QueryError() ) != NERR_Success )
	{
            ::MsgPopup( this, err );
	    return FALSE;
	}

	_sltServerName.QueryText( &nlsServerName ) ;

        CHANGE_SERVER_NAME_DLG *pDlg = new CHANGE_SERVER_NAME_DLG( 
					QueryHwnd(), 
					&nlsServerName );

    	if ( ( pDlg == NULL )
       		|| ((err = pDlg->QueryError()) != NERR_Success )
       		|| ((err = pDlg->Process( &fOK ))    != NERR_Success ) )
    	{
            err = err ? err : ERROR_NOT_ENOUGH_MEMORY;
        }

    	delete pDlg;

    	pDlg = NULL;

	if ( err != NO_ERROR )
	{
            ::MsgPopup( this, err );
	    return FALSE;
	}
        else
   	{
	    if ( fOK )
	    {
		_sltServerName.SetText( nlsServerName );

		_dwParmNum |= AFP_SERVER_PARMNUM_NAME;

        	::MsgPopup( this, IDS_SERVERNAME_CHANGE, MPSEV_WARNING, MP_OK );
	    }
	}
	
    }

    return DIALOG_WINDOW::OnCommand( event );

}

/*******************************************************************

    NAME:	SERVER_PARAMETERS_DIALOG::OnOK	

    SYNOPSIS:   Validate all the information and create the volume.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		12/15/92		Created

********************************************************************/

BOOL SERVER_PARAMETERS_DIALOG :: OnOK( VOID )
{
    APIERR err;

    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    AFP_SERVER_INFO AfpServerInfo;

    NLS_STR nlsServerName;

    if ( ( err = nlsServerName.QueryError() ) != NERR_Success )
    {
 	::MsgPopup( this, err );

        Dismiss(FALSE) ;

    	return(FALSE);
    }

    //
    // Set the server name
    //

    _sltServerName.QueryText( &nlsServerName );

    AfpServerInfo.afpsrv_name = (LPWSTR)(nlsServerName.QueryPch());

    //
    // Get the logon message 
    //
 
    UINT cb = _mleTextMsg.QueryTextSize();

    NLS_STR nlsMsgText( cb );

    //
    // Was there any text ?
    //

    if ( cb <= sizeof(TCHAR) )    // always has a terminating NULL
    {
   	AfpServerInfo.afpsrv_login_msg = NULL;

    }
    else
    {

    	if ( (( err = nlsMsgText.QueryError() ) != NERR_Success ) ||
    	     (( err = _mleTextMsg.QueryText(&nlsMsgText))!= NERR_Success ))
        {
            ::MsgPopup( this, err );

            Dismiss(FALSE) ;

    	    return(TRUE);
    	}

	if ( nlsMsgText.QueryTextLength() > AFP_MESSAGE_LEN )
	{
	    ::MsgPopup( this, IDS_MESSAGE_TOO_LONG );

    	    _mleTextMsg.ClaimFocus();
    	    _mleTextMsg.SelectString();

    	    return(FALSE);
	}

        AfpServerInfo.afpsrv_login_msg = (LPWSTR)(nlsMsgText.QueryPch());
    }

  
    //
    // Set the server options if the user changed it
    //


    AfpServerInfo.afpsrv_options =  _chkAllowPasswordSaves.QueryCheck()
				    ? AFP_SRVROPT_ALLOWSAVEDPASSWORD
				    : 0;

    AfpServerInfo.afpsrv_options |= _chkAllowGuestLogons.QueryCheck()
		     		    ? AFP_SRVROPT_GUESTLOGONALLOWED
				    : 0;

    AfpServerInfo.afpsrv_options |= _chkAllowClearTextPasswords.QueryCheck()
				    ? 0 : AFP_SRVROPT_CLEARTEXTLOGONALLOWED;


    AfpServerInfo.afpsrv_max_sessions = QuerySessionLimit();

    //
    //  Set this information
    //

    _dwParmNum |= ( AFP_SERVER_PARMNUM_LOGINMSG |
        	    AFP_SERVER_PARMNUM_OPTIONS  |
		    AFP_SERVER_PARMNUM_MAX_SESSIONS );

    err = ::AfpAdminServerSetInfo( _hServer,  
				    (LPBYTE)&AfpServerInfo, 
				   _dwParmNum );

    if ( err == NO_ERROR )
    {
        Dismiss( TRUE );
    }
    else
    {
        ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
    }

    return TRUE;
}


/*******************************************************************

    NAME:	SERVER_PARAMETERS_DIALOG::QuerySessionLimit

    SYNOPSIS:   Get the user limit from the magic group

    ENTRY:

    EXIT:

    RETURNS:    The user limit stored in the user limit magic group

    NOTES:

    HISTORY:
	NarenG		12/15/92		Created

********************************************************************/

DWORD SERVER_PARAMETERS_DIALOG::QuerySessionLimit( VOID ) const
{

    switch ( _mgrpSessionLimit.QuerySelection() )
    {

    case IDSP_RB_UNLIMITED:

    	return( AFP_MAXSESSIONS );

    case IDSP_RB_SESSIONS:

        return( _spsleSessions.QueryValue() );

    default:

	//	
	// Should never get here but in case we do, return unlimited
	//

        return( AFP_MAXSESSIONS );
    }

}

/*******************************************************************

    NAME:	SERVER_PARAMETERS_DIALOG::SetSessionLimit	

    SYNOPSIS:   Sets the user limit on the magic group

    ENTRY:      dwSessionLimit - maximum number of users allowed

    EXIT:

    RETURNS:   

    NOTES:

    HISTORY:
	NarenG		12/15/92		Created

********************************************************************/

VOID SERVER_PARAMETERS_DIALOG::SetSessionLimit( DWORD dwSessionLimit )
{

     if ( dwSessionLimit == AFP_MAXSESSIONS )
     {
         //
         // Set selection to the  Unlimited button
         //

         _mgrpSessionLimit.SetSelection( IDSP_RB_UNLIMITED );

     }
     else 
     {
	//
        // Set the sessions button to the value
	//
	
        _mgrpSessionLimit.SetSelection( IDSP_RB_SESSIONS );

        _spsleSessions.SetValue( dwSessionLimit );

        _spsleSessions.Update();

     }

}

/*******************************************************************

    NAME:	SERVER_PARAMETERS_DIALOG::QueryHelpContext	

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
	NarenG		12/15/92		Created

********************************************************************/

ULONG SERVER_PARAMETERS_DIALOG::QueryHelpContext( VOID )
{
    return HC_SERVER_PARAMETERS_DIALOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\srvname.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		Copyright(c) Microsoft Corp., 1991  		     **/
/**********************************************************************/

/*
   srvname.cxx
     This file contains the definition of CHANGE_SERVER_NAME_DLG.
 
   History:
     NarenG		12/15/92	Created.
*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}

#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <netname.hxx>

#include "srvname.hxx"

/*******************************************************************

    NAME:	CHANGE_SERVER_NAME_DLG::CHANGE_SERVER_NAME_DLG


    SYNOPSIS:   Constructor for SERVER_PARAMETERS_DIALOG class

    ENTRY:      hwndParent     - handle of parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		12/15/92		Created

********************************************************************/

CHANGE_SERVER_NAME_DLG :: CHANGE_SERVER_NAME_DLG(
				 	HWND 		  hwndParent,
					NLS_STR		  *pnlsServerName )
    : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_CHANGE_SERVERNAME_DIALOG ), 
		     hwndParent ),
      _sleServerName( this, IDCS_SLE_SERVER_NAME, AFP_SERVERNAME_LEN ),
      _pnlsServerName( pnlsServerName )
{

    // 
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;

    if ( (err = _sleServerName.QueryError()) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _sleServerName.SetText( *pnlsServerName );

    _sleServerName.ClaimFocus();

}

/*******************************************************************

    NAME:	CHANGE_SERVER_NAME_DLG::OnOK	

    SYNOPSIS:   

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		12/15/92		Created

********************************************************************/

BOOL CHANGE_SERVER_NAME_DLG :: OnOK( VOID )
{
    
    _sleServerName.QueryText( _pnlsServerName );

    if ( _pnlsServerName->QueryTextLength() == 0 )
    {
	::MsgPopup( this, IDS_NEED_SERVER_NAME );
	_sleServerName.ClaimFocus();
	return FALSE;
    }

    //
    // Validate the server name
    // 

    ISTR istr( *_pnlsServerName );

    if ( _pnlsServerName->strchr( &istr, TEXT(':') ) )
    {
	::MsgPopup( this, IDS_AFPERR_InvalidServerName );
	_sleServerName.ClaimFocus();
	return FALSE;
    }

    Dismiss( TRUE );
    return TRUE;

}


/*******************************************************************

    NAME:	CHANGE_SERVER_NAME_DLG::QueryHelpContext	

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
	NarenG		12/15/92		Created

********************************************************************/

ULONG CHANGE_SERVER_NAME_DLG::QueryHelpContext( VOID )
{
    return HC_CHANGE_SERVER_NAME_DLG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\startafp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    startafp.cxx

    This file contains the code for starting the AFP Service

    FILE HISTORY:
        NarenG      14-Oct-1992     Stole from srvsvc.cxx in server manager.
*/

#define INCL_NET
#define INCL_NETLIB
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_CLIENT
#define INCL_BLT_EVENT
#define INCL_BLT_MISC
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_TIMER
#define INCL_BLT_CC
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <uiassert.hxx>
#include <lmsvc.hxx>
#include <lmosrv.hxx>
#include <svcman.hxx>           // service controller wrappers

#include <dbgstr.hxx>

extern "C" 
{
#include <winsvc.h>         	// service controller
#include <afpmgr.h>
#include <macfile.h>
#include <mnet.h>
}

#include <startafp.hxx>


/*******************************************************************

    NAME:       SERVICE_WAIT_DIALOG::SERVICE_WAIT_DIALOG

    SYNOPSIS:   constructor for SERVICE_WAIT

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

SERVICE_WAIT_DIALOG::SERVICE_WAIT_DIALOG( HWND 	  	hWndOwner,
                            		  LM_SERVICE  *	plmsvc,
                            		  const TCHAR * pszDisplayName ) 
  : DIALOG_WINDOW(MAKEINTRESOURCE( IDD_SERVICE_CTRL_DIALOG),
                                   hWndOwner),
    _timer( this, TIMER_FREQ, FALSE ),
    _plmsvc(plmsvc),
    _progress( this, 
	       IDSC_PROGRESS, 
	       IDI_PROGRESS_ICON_0, 
	       IDI_PROGRESS_NUM_ICONS ),
    _sltMessage( this, IDSC_ST_MESSAGE ),
    _pszDisplayName( pszDisplayName ),
    _nTickCounter( TIMER_MULT )
{
    UIASSERT( pszDisplayName != NULL );

    if ( QueryError() != NERR_Success ) 
    {
        return ;
    }

    //
    // set the message.
    //

    ALIAS_STR nlsServer( pszDisplayName );
    UIASSERT( nlsServer.QueryError() == NERR_Success );

    RESOURCE_STR nlsMessage( IDS_STARTING_AFPSERVER_NOW );

    APIERR err = nlsMessage.QueryError();

    if( err == NERR_Success )
    {
        ISTR istrServer( nlsServer );
        istrServer += 2;

        err = nlsMessage.InsertParams( nlsServer[istrServer] );
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    _sltMessage.SetText( nlsMessage );

    //
    // set polling timer
    //

    _timer.Enable( TRUE );

}

/*******************************************************************

    NAME:       SERVICE_WAIT_DIALOG::~SERVICE_WAIT_DIALOG

    SYNOPSIS:   destructor for SERVICE_WAIT_DIALOG. Stops
                the timer if it has not already been stopped.

    HISTORY:
        ChuckC      07-Sep-1991     Created

********************************************************************/

SERVICE_WAIT_DIALOG::~SERVICE_WAIT_DIALOG( void )
{
    _timer.Enable( FALSE );
}

/*******************************************************************

    NAME:       SERVICE_WAIT_DIALOG::OnTimerNotification

    SYNOPSIS:   Virtual callout invoked during WM_TIMER messages.

    ENTRY:      tid                     - TIMER_ID of this timer.

    HISTORY:
        KeithMo     06-Oct-1991     Created.

********************************************************************/
VOID SERVICE_WAIT_DIALOG :: OnTimerNotification( TIMER_ID tid )
{
    //
    //  Bag-out if it's not our timer.
    //

    if( tid != _timer.QueryID() )
    {
        TIMER_CALLOUT :: OnTimerNotification( tid );
        return;
    }

    //
    //  Advance the progress indicator.
    //

    _progress.Advance();

    //
    //  No need to continue if we're just amusing the user.
    //

    if( --_nTickCounter > 0 )
    {
        return;
    }

    _nTickCounter = TIMER_MULT;

    //
    //  Poll the service to see if the operation is
    //  either complete or continuing as expected.
    //

    BOOL fDone;
    APIERR err = _plmsvc->Poll( &fDone );

    if (err != NERR_Success)
    {
        //
        //      Either an error occurred retrieving the
        //      service status OR the service is returning
        //      bogus state information.
        //

        Dismiss( err );
        return;
    }

    if( fDone )
    {
        //
        //      The operation is complete.
        //
        Dismiss( NERR_Success );
        return;
    }

    //
    //  If we made it this far, then the operation is
    //  continuing as expected.  We'll have to wait for
    //  the next WM_TIMER message to recheck the service.
    //

}   // SERVICE_WAIT_DIALOG :: OnTimerNotification

/*******************************************************************

    NAME:       StartAfpService

    SYNOPSIS:   Starts the Afp Service on the local machine.

    ENTRY:      hWnd                    - "Owning" window handle.
		pszComputerName		- name of machine to start service on

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        NarenG      1-Oct-1992  Stole from original.

********************************************************************/
APIERR StartAfpService( HWND hWnd, const TCHAR * pszComputerName )
{

    AUTO_CURSOR AutoCursor;

    LM_SERVICE * psvc = new LM_SERVICE( pszComputerName, 
					(const TCHAR *)AFP_SERVICE_NAME );

    APIERR err = ( psvc == NULL ) ? ERROR_NOT_ENOUGH_MEMORY 
			     	  : psvc->QueryError();

    if (err == NERR_Success) 
    {
     	//
    	// Initiate the Start
    	//

    	err = psvc->Start( NULL, POLL_TIMER_FREQ, POLL_DEFAULT_MAX_TRIES );

	if ( err == NERR_Success ) 
	{

    	    UINT errDlg = NERR_Success;

    	    //
    	    //  Invoke the wait dialog.
    	    //

    	    SERVICE_WAIT_DIALOG * pDlg = new SERVICE_WAIT_DIALOG( 
						    hWnd,
                                                    psvc,
                                                    pszComputerName );

    	    err = ( pDlg == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                   : pDlg->Process( &errDlg );


    	    if( err == NERR_Success )
    	    {

		delete pDlg;

		err = (APIERR)errDlg;

    	    }

            delete psvc;
	}
    }

    return err;

}   // StartAfpService

/*******************************************************************

    NAME:       IsAfpServiceRunning

    SYNOPSIS:   Checks to see if the AfpService is running on a given 
	  	machine.

    ENTRY:      hWnd                    - "Owning" window handle.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        NarenG      1-Oct-1992  Stole from original.

********************************************************************/
APIERR IsAfpServiceRunning( const TCHAR * pszComputer, BOOL * fIsAfpRunning )
{

    LPSERVICE_INFO_1  psvci1;
    DWORD err;

    SERVER_1 Server1( pszComputer );

    if ( ( err = Server1.GetInfo() ) != NERR_Success )
    {
	return err;
    }

    if ( !(Server1.QueryServerType() & SV_TYPE_NT ) )
    {
	return IDS_NOT_NT;
    }

    //
    // Find out if the AFP service is running on the given machine 
    //

    err = ::MNetServiceGetInfo(	pszComputer,
				(const TCHAR *)AFP_SERVICE_NAME, 
                                1,
                                (BYTE **)&psvci1 );

    if ( err == NERR_BadServiceName )
    {
	return IDS_MACFILE_NOT_INSTALLED;
    }

    if( err != NERR_Success )
    {
	return err;
    }

    *fIsAfpRunning = (BOOL)(psvci1->svci1_status & SERVICE_INSTALLED);

    ::MNetApiBufferFree( (BYTE **)&psvci1 );

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\voldel.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    voldel.cxx
      Contains the dialog for managing volumes in the server manager
      VOLUME_DELETE_DIALOG
 
    FILE HISTORY:
      NarenG        	11/11/92        Modified sharemgt.cxx for AFPMGR
 
*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSERVER
#define INCL_NETSHARE
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}


#include <lmoloc.hxx>
#include <string.hxx>
#include <uitrace.hxx>

#include "voldel.hxx"

/*******************************************************************

    NAME:       VOLUME_DELETE_DIALOG::VOLUME_DELETE_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
		hServer		  - handle to the target server
                pszServerName     - name of the selected computer

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

VOLUME_DELETE_DIALOG::VOLUME_DELETE_DIALOG( 
					HWND 		  hwndOwner,
					AFP_SERVER_HANDLE hServer,
                                        const TCHAR 	  *pszServerName,
                                        const TCHAR 	  *pszPath,
					BOOL		  fIsFile )  
	: VIEW_VOLUMES_DIALOG_BASE( MAKEINTRESOURCE(IDD_VOLUME_DELETE_DLG),
  				    hwndOwner,  
				    hServer,
    			            pszServerName,
				    TRUE,
				    IDDV_SLT_VOLUME_TITLE,
				    IDDV_LB_VOLUMES),
      _pbOK( this, IDOK ),
      _pbCancel( this, IDCANCEL ),
      _hServer( hServer ),
      _sltVolumeTitle( this, IDDV_SLT_VOLUME_TITLE )
{
    AUTO_CURSOR Cursor;

    // 
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    //
    // Set the text of the list box title
    //

    DWORD    err;
    NLS_STR  nlsServer;
    LOCATION Loc( pszServerName );

    RESOURCE_STR nlsTitle( IDS_VOLUMES_LB_TITLE_TEXT );
    
    if ( ((err = nlsTitle.QueryError()) 		!= NERR_Success ) || 
         ((err = _sltVolumeTitle.QueryError())		!= NERR_Success ) || 
         ((err = nlsServer.QueryError()) 		!= NERR_Success ) || 
         ((err = Loc.QueryDisplayName( &nlsServer ))	!= NERR_Success ) || 
	 ((err = nlsTitle.InsertParams( nlsServer ))    != NERR_Success ))
    {
        ReportError( err );
	return;
    }       

    _sltVolumeTitle.SetText( nlsTitle );

    err = Refresh();

    if ( err != NO_ERROR )
    {
        ReportError( err );
        return;
    }

    //
    // If there are not items then tell the user that there are no
    // items to delete
    //

    if ( QueryLBVolumes()->QueryCount() == 0 )
    {
    	::MsgPopup( this, IDS_NO_VOLUMES, MPSEV_INFO );
        ReportError( ERROR_ALREADY_REPORTED );
        return;
    }

    //
    // If a directory was selected then select the volume item that has a
    // matching path.
    //

    if ( !fIsFile )
    {
	err = SelectVolumeItem( pszPath );

    	if ( err != NO_ERROR )
    	{
            ReportError( err );
            return;
        }
    }
}

/*******************************************************************

    NAME:       VOLUME_DELETE_DIALOG::OnOK

    SYNOPSIS:   Gather information and delete the volumes selected
                in the listbox.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

BOOL VOLUME_DELETE_DIALOG::OnOK( VOID )
{

    AUTO_CURSOR AutoCursor;

    APIERR err = NERR_Success;

    VIEW_VOLUMES_LISTBOX *plbVolume = QueryLBVolumes();
    INT ciMax = plbVolume->QuerySelCount();

    //
    //  If there are no items selected in the listbox,
    //  just dismiss the dialog.
    //

    if ( ciMax == 0 )
    {
        Dismiss( FALSE );
        return TRUE;
    }

    //
    // Warn the user.
    //

    if ( ::MsgPopup(    this,
                       	IDS_DELETE_VOLUME_CONFIRM,
                       	MPSEV_WARNING,
                       	MP_YESNO,
                       	MP_YES ) == IDNO ) 
    {
        Dismiss( FALSE );
        return TRUE;
    }

    //
    //  Get all the items selected in the listbox
    //

    INT *paSelItems = (INT *) new BYTE[ sizeof(INT) * ciMax ];
 
    if ( paSelItems == NULL )
    {
        ::MsgPopup( this, ERROR_NOT_ENOUGH_MEMORY);

        return TRUE;
    }

    err = plbVolume->QuerySelItems( paSelItems,  ciMax );
    UIASSERT( err == NERR_Success );

    //
    //  Loop through each volume that the user selects in the listbox
    //  and delete the volume. We will break out of the loop
    //  if any error occurred in deleting a volume or if the user
    //  decides not to delete a volume that some user is connected to.
    // 

    BOOL fCancel;
    VIEW_VOLUMES_LBI *pvlbi = NULL;

    for ( INT i = 0; i < ciMax; i++ )
    {
         pvlbi = plbVolume->QueryItem( paSelItems[i] );

    	 err = VolumeDelete( pvlbi, &fCancel ); 

         if ( fCancel || ( err != NO_ERROR ))
             break;
    }
 
    delete paSelItems;

    paSelItems = NULL;
    
    // 
    //  Dismiss the dialog only if everything went on smoothly.
    //

    if ( err != NO_ERROR )
    {
        ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

    }
    else if ( !fCancel )
    {
        Dismiss( TRUE );
	return TRUE;
    }

    //
    //  Refresh the listbox.
    //

    err = Refresh();

    if ( err != NO_ERROR )
    {
    	::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

        Dismiss( FALSE );
    }
    else
    {

        if ( plbVolume->QueryCount() > 0 )
	{
            plbVolume->SelectItem( 0 );
            plbVolume->ClaimFocus();
	}
        else
	{
            _pbOK.Enable( FALSE ); 
            _pbCancel.ClaimFocus();
	}
    }

    return TRUE;
}


/*******************************************************************

    NAME:       VOLUME_DELETE_DIALOG::OnVolumeLbDblClk

    SYNOPSIS:   This is called when the user double clicks on a share
                in the listbox. 

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

BOOL VOLUME_DELETE_DIALOG::OnVolumeLbDblClk( VOID )
{
    return OnOK();
}

/*******************************************************************

    NAME:       VOLUME_DELETE_DIALOG::QueryHelpContext

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

ULONG VOLUME_DELETE_DIALOG::QueryHelpContext( VOID )
{
    return HC_VOLUME_DELETE_DIALOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\util.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    util.cxx
	Utility functions used by the SFMMGR UI.

    1) SetCaption method.


    FILE HISTORY:   
	NarenG	27-Dec-1992	Created.

*/

#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#include <blt.hxx>

#include "util.hxx"


/*******************************************************************

    NAME:       SetCaption

    SYNOPSIS:   Sets the dialog caption to "Foo on Server".

    ENTRY:      powin                   - The dialog window.

                idCaption               - Resource ID for the caption
                                          string (for example,
                                          "Open Resources on %1").

                pszServerName           - The server name, if this is NULL
					  it will be assumed that there is no
					  insert string.

    EXIT:       The caption is set.

    RETURNS:    APIERR                  - Any error encountered.

    NOTES:      

    HISTORY:
        NarenG     22-Sep-1992 Created.

********************************************************************/

APIERR SetCaption( OWNER_WINDOW *  powin,
                   UINT            idCaption,
                   const TCHAR   * pszServerName )

{
    //
    //  This will (eventually...) receive the caption string.
    //

    NLS_STR nlsCaption;

    APIERR err;


    if ( ( ( err = nlsCaption.QueryError() ) != NERR_Success ) ||
         ( ( err = nlsCaption.Load( idCaption ) ) != NERR_Success ) )
    {
        return err;
    }

    if ( pszServerName != NULL )
    {
    	//
    	//  Note that the server name still has the leading
    	//  backslashes (\\).  They are not to be displayed.
    	//

    	ALIAS_STR nlsServerName( pszServerName );

    	ISTR istr( nlsServerName );

    	//
    	//  Skip the backslashes.
    	//
    	istr += 2;

    	ALIAS_STR nlsWithoutPrefix( nlsServerName.QueryPch( istr ) );

    	//
    	//  The insert strings for Load().
    	//

    	nlsCaption.InsertParams( nlsWithoutPrefix );

    	if( !nlsCaption )
    	{
            return nlsCaption.QueryError();
    	}

    }

    //
    //  Set the caption.
    //

    powin->SetText( nlsCaption.QueryPch() );

    //
    //  Success!
    //

    return NERR_Success;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\volumes.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    volumes.cxx
    Class declarations for the VOLUMES_DIALOG, VOLUMES_LISTBOX, and
    VOLUMES_LBI classes.

    These classes implement the Server Manager Shared Volumes subproperty
    sheet.  The VOLUMES_LISTBOX/VOLUMES_LBI classes implement the listbox
    which shows the available sharepoints.  VOLUMES_DIALOG implements the
    actual dialog box.


    FILE HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

*/
#define INCL_NET
#define INCL_WINDOWS
#define INCL_WINDOWS_GDI
#define INCL_NETERRORS
#define INCL_DOSERRORS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif  // DEBUG

#include <ellipsis.hxx>
#include <uiassert.hxx>
#include <ctime.hxx>
#include <intlprof.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}   // extern "C"

#include <util.hxx>
#include <volumes.hxx>

//
//  min/max macros
//

#define min(x,y) (((x) < (y)) ? (x) : (y))
#define max(x,y) (((x) > (y)) ? (x) : (y))

//
//  VOLUMES_DIALOG methods.
//

/*******************************************************************

    NAME:       VOLUMES_DIALOG :: VOLUMES_DIALOG

    SYNOPSIS:   VOLUMES_DIALOG class constructor.

    ENTRY:      hWndOwner               - The owning window.

    		hServer                 - Handle used to make admin
					  API calls.

    		pszServerName           - Name of server currently
					  being administered.

    EXIT:       The object is constructed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
VOLUMES_DIALOG :: VOLUMES_DIALOG( HWND             	hWndOwner,
                                  AFP_SERVER_HANDLE 	hServer,
			          const TCHAR *		pszServerName )
  : DIALOG_WINDOW( MAKEINTRESOURCE( IDD_SHARED_VOLUMES ), hWndOwner ),
    _hServer( hServer ),
    _lbVolumes( this, IDSV_LB_VOLUMELIST, hServer ),
    _lbUsers( this, IDSV_LB_USERLIST, hServer ),
    _sltUsersCount( this, IDSV_DT_USERCOUNT ),
    _pbDisconnect( this,  IDSV_PB_DISCONNECT ),
    _pbDisconnectAll( this, IDSV_PB_DISCONNECTALL ),
    _pbOK( this, IDOK )
{

    //
    //  Let's make sure everything constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;
    if ( (( err = _lbVolumes.QueryError() ) 	  != NERR_Success ) ||
         (( err = _lbUsers.QueryError() ) 	  != NERR_Success ) ||
     	 (( err = _sltUsersCount.QueryError() )   != NERR_Success ) ||
         (( err = _pbDisconnect.QueryError() )    != NERR_Success ) ||
     	 (( err = _pbDisconnectAll.QueryError() ) != NERR_Success ))
    {
	ReportError( err );
	return;
    }

    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    //  Set the caption to "Shared Volumes on Server".
    //

    err = ::SetCaption( this, IDS_CAPTION_VOLUMES, pszServerName );

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    err = BASE_ELLIPSIS::Init();

    if( err != NO_ERROR )
    {
        ReportError( err );
	return;
    }

    //
    //  Refresh the dialog.
    //

    err = Refresh();

    if( err != NO_ERROR )
    {
        ReportError( AFPERR_TO_STRINGID( err ));
    }

}   // VOLUMES_DIALOG :: VOLUMES_DIALOG


/*******************************************************************

    NAME:       VOLUMES_DIALOG :: ~VOLUMES_DIALOG

    SYNOPSIS:   VOLUMES_DIALOG class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
VOLUMES_DIALOG :: ~VOLUMES_DIALOG()
{
    BASE_ELLIPSIS::Term();

}   // VOLUMES_DIALOG :: ~VOLUMES_DIALOG


/*******************************************************************

    NAME:       VOLUMES_DIALOG :: QueryHelpContext

    SYNOPSIS:   This function returns the appropriate help context
                value (HC_*) for this particular dialog.

    RETURNS:    ULONG                   - The help context for this
                                          dialog.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
ULONG VOLUMES_DIALOG :: QueryHelpContext( void )
{
    return HC_VOLUMES_DIALOG;

}   // VOLUMES_DIALOG :: QueryHelpContext

/*******************************************************************

    NAME:       VOLUMES_DIALOG :: OnCommand

    SYNOPSIS:   This method is called whenever a WM_COMMAND message
                is sent to the dialog procedure.

    ENTRY:      cid                     - The control ID from the
                                          generating control.

    EXIT:       The command has been handled.

    RETURNS:    BOOL                    - TRUE  if we handled the command.
                                          FALSE if we did not handle
                                          the command.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
BOOL VOLUMES_DIALOG :: OnCommand( const CONTROL_EVENT & event )
{

    DWORD err;

    if( event.QueryCid() == _lbVolumes.QueryCid() )
    {
        //
        //  The VOLUMES_LISTBOX is trying to tell us something...
        //

        if( event.QueryCode() == LBN_SELCHANGE )
        {
            //
            //  The user changed the selection in the VOLUMES_LISTBOX.
            //

            VOLUMES_LBI * plbi = _lbVolumes.QueryItem();
            UIASSERT( plbi != NULL );

            _lbUsers.Refresh( plbi->QueryVolumeId() );

            DWORD cUses = _lbUsers.QueryCount();

            (VOID)plbi->NotifyNewUseCount( cUses );
            _lbVolumes.InvalidateItem( _lbVolumes.QueryCurrentItem() );

            _sltUsersCount.SetValue( cUses );

            _pbDisconnect.Enable( cUses > 0 );
            _pbDisconnectAll.Enable( cUses > 0 );
        }

    	if ((event.QueryCode() == LBN_DBLCLK) && (_lbVolumes.QuerySelCount()>0))
	{
            VOLUMES_LBI * plbi = _lbVolumes.QueryItem();

	    ::MsgPopup( this,
			IDS_VOLUME_PATH,
			MPSEV_INFO,
			1,
			plbi->QueryPath(),
			MP_OK );
	}

        return TRUE;
    }

    if( event.QueryCid() == _pbDisconnect.QueryCid() )
    {
        //
        //  The user pressed the Disconnect button.  Blow off the
        //  selected user.
        //

        USERS_LBI * pulbi = _lbUsers.QueryItem();
        UIASSERT( pulbi != NULL );

        VOLUMES_LBI * pvlbi = _lbVolumes.QueryItem();
        UIASSERT( pvlbi != NULL );

        if ( ::MsgPopup( this,
                         (pulbi->QueryNumOpens() > 0) ? IDS_DISCONNECT_VOL_OPEN
                                                      : IDS_DISCONNECT_VOL,
                         MPSEV_WARNING,
                         MP_YESNO,
                         pulbi->QueryUserName(),
                         pvlbi->QueryVolumeName(),
                         MP_NO ) == IDYES )
        {
    	    AUTO_CURSOR Cursor;

            //
            //  Blow off the user.
            //

            err = ::AfpAdminConnectionClose( _hServer,
					     pulbi->QueryConnectionId() );

            if( err != NO_ERROR )
            {
                //
                //  The session delete failed.  Tell the user the bad news.
                //

		if ( err == AFPERR_InvalidId )
		{
                    ::MsgPopup( this, IDS_CONNECTION_DELETED );
		}
 	   	else
		{
                    ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
		}
            }

            //
            //  Refresh the dialog.
            //

            Refresh();
        }

        return TRUE;
    }

    if( event.QueryCid() == _pbDisconnectAll.QueryCid() )
    {
        //
        //  The user pressed the "Disconnect All" button.
        //  Blow off all of the connected users.
        //

        UIASSERT( _lbUsers.QueryCount() > 0 );

        VOLUMES_LBI * pvlbi = _lbVolumes.QueryItem();
        UIASSERT( pvlbi != NULL );

        if( MsgPopup( this,
                      ( _lbUsers.AreResourcesOpen() )
				? IDS_DISCONNECT_VOL_ALL_OPEN
                                : IDS_DISCONNECT_VOL_ALL,
                      MPSEV_WARNING,
                      MP_YESNO,
                      pvlbi->QueryVolumeName(),
                      MP_NO ) == IDYES )
        {

    	    AUTO_CURSOR Cursor;

    	    INT nCount = _lbUsers.QueryCount();

    	    for ( INT Index = 0; Index < nCount; Index++ )
    	    {
            	USERS_LBI * pulbi = _lbUsers.QueryItem( Index );

	    	//
	    	// Blow away this connection
    	    	//

	    	err = :: AfpAdminConnectionClose( _hServer,
					          pulbi->QueryConnectionId() );

	    	if ( ( err != NO_ERROR ) && ( err != AFPERR_InvalidId ) )
	    	{
	    	    break;
	     	}
       	    }

            if( ( err != NO_ERROR ) && ( err != AFPERR_InvalidId ) )
            {
            	//
                //  The connection delete failed.
                //  Tell the user the bad news.
                //

                MsgPopup( this, AFPERR_TO_STRINGID(err) );

            }

            //
            //  Refresh the dialog.
            //

            Refresh();
        }

        return TRUE;
    }

    //
    //  If we made it this far, then we're not
    //  interested in the command.
    //

    return FALSE;

}   // VOLUMES_DIALOG :: OnCommand


/*******************************************************************

    NAME:       VOLUMES_DIALOG :: Refresh

    SYNOPSIS:   Refresh the dialog.

    EXIT:       The dialog is feeling refreshed.

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
DWORD VOLUMES_DIALOG :: Refresh( VOID )
{
    //
    //  This is the currently selected item.
    //

    VOLUMES_LBI * plbiOld = _lbVolumes.QueryItem();

    DWORD dwVolumeIdOld = ( plbiOld == NULL ) ? 0 : plbiOld->QueryVolumeId();

    //
    //  Refresh the resource listbox.
    //

    DWORD err = _lbVolumes.Refresh();

    if( err != NO_ERROR )
    {
        //
        //  There was an error refreshing the resource listbox.
        //  So, nuke everything in the volumes & user listboxen,
        //  then disable the Disconnect[All] buttons.
        //

        _lbVolumes.DeleteAllItems();
        _lbVolumes.Invalidate( TRUE );
        _lbUsers.DeleteAllItems();
        _lbUsers.Invalidate( TRUE );

        _pbDisconnect.Enable( FALSE );
        _pbDisconnectAll.Enable( FALSE );

        return err;
    }

    //
    //  Get the "new" currently selected item (after the refresh).
    //

    VOLUMES_LBI * plbiNew = _lbVolumes.QueryItem();

    DWORD dwVolumeIdNew = (plbiNew == NULL) ? 0 : plbiNew->QueryVolumeId();

    if( plbiNew == NULL )
    {
        //
        //  There is no current selection, so clear the users listbox.
        //

        err = _lbUsers.Refresh( 0 );
    }
    else
    if( ( plbiOld == NULL ) || ( dwVolumeIdOld != dwVolumeIdNew ) )
    {
        //
        //  Either there was no selection before the refresh, OR
        //  the current selection does not match the previous
        //  selection.  Therefore, fill the users listbox with
        //  the current selection.
        //

        err = _lbUsers.Refresh( plbiNew->QueryVolumeId() );

    }
    else
    {
        //
        //  There was no selection change after refresh.  Therefore,
        //  refresh the users listbox.
        //

        err = _lbUsers.Refresh( plbiNew->QueryVolumeId() );
    }

    if ( _lbUsers.QuerySelCount() > 0 )
    {
    	_pbDisconnect.Enable( TRUE );
    }
    else
    {
	if ( _pbDisconnect.HasFocus() )
	{
	    _pbOK.ClaimFocus();
	}

    	_pbDisconnect.Enable( FALSE );
    }

    if ( _lbUsers.QueryCount() > 0 )
    {
    	_pbDisconnectAll.Enable( TRUE );
    }
    else
    {
	if ( _pbDisconnectAll.HasFocus() )
	{
	    _pbOK.ClaimFocus();
	}

    	_pbDisconnectAll.Enable( FALSE );
    }

    _sltUsersCount.SetValue( _lbUsers.QueryCount() );

    //
    //  Success!
    //

    return err;

}   // VOLUMES_DIALOG :: Refresh

//
//  VOLUMES_LISTBOX methods.
//

/*******************************************************************

    NAME:       VOLUMES_LISTBOX :: VOLUMES_LISTBOX

    SYNOPSIS:   VOLUMEs_LISTBOX class constructor.

    ENTRY:      powOwner                - The owning window.

                cid                     - The listbox CID.

                hServer                 - The target server.

    EXIT:       The object is constructed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
VOLUMES_LISTBOX :: VOLUMES_LISTBOX( OWNER_WINDOW   *  powOwner,
                                    CID               cid,
                                    AFP_SERVER_HANDLE hServer )
  : BLT_LISTBOX( powOwner, cid ),
    _hServer( hServer ),
    _dteDisk( IDBM_LB_GOOD_VOLUME )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( err = _dteDisk.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Build our column width table.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
				     COLS_SV_LB_VOLUMES,
				     powOwner,
				     cid,
				     TRUE ) ;

}   // VOLUMES_LISTBOX :: VOLUMES_LISTBOX


/*******************************************************************

    NAME:       VOLUMES_LISTBOX :: ~VOLUMES_LISTBOX

    SYNOPSIS:   VOLUMES_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
VOLUMES_LISTBOX :: ~VOLUMES_LISTBOX()
{
    //
    //  This space intentionally left blank.
    //

}   // VOLUMES_LISTBOX :: ~VOLUMES_LISTBOX


/*******************************************************************

    NAME:       VOLUMES_LISTBOX :: Refresh

    SYNOPSIS:   Refresh the listbox, maintaining (as much as
                possible) the current selection state.

    EXIT:       The listbox is feeling refreshed.

    RETURNS:    DWORD                  - Any errors we encounter.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
DWORD VOLUMES_LISTBOX :: Refresh( VOID )
{
    INT iCurrent = QueryCurrentItem();
    INT iTop     = QueryTopIndex();

    DWORD dwCurrentVolumeId = 0;

    //
    // Retrieve the volume id of the current selection
    //

    if ( QuerySelCount() > 0 )
    {
    	dwCurrentVolumeId = QueryItem( iCurrent )->QueryVolumeId();
    }

    DWORD err = Fill();

    if( err != NO_ERROR )
    {
        return err;
    }

    INT cItems = QueryCount();

    if( cItems > 0 )
    {

  	INT iSel = -1;

	if ( ( iCurrent >= 0 ) && ( iCurrent < cItems ) )
  	{
	    //
	    // iCurrent is still valid, see if this item matches the
	    // pre-refresh item.
	    //
	
	    if ( dwCurrentVolumeId == QueryItem( iCurrent )->QueryVolumeId() )
	    {
		iSel = iCurrent;
	    }
	}

	if ( iSel < 0 )
	{
	    //
	    // Either iCurrent was out of range or the item does not
	    // match so search for it.
	    //

	    for ( INT i = 0; i < cItems; i++ )
	    {
		VOLUMES_LBI * plbi = QueryItem( i );

		if ( dwCurrentVolumeId == plbi->QueryVolumeId() )
		{
		    iSel = i;
		    break;
		}
	    }
	}

	if ( iSel < 0 )
	{
	    //
	    // If no selection found then default = first item
	    //

	    iSel = 0;
	}

	//
	// If the previous top index is out of range then
	// set default = first item.
	//

	if ( ( iTop < 0 ) || ( iTop >= cItems ) )
	{
	    iTop = 0;
	}

        SetTopIndex( iTop );
        SelectItem( iSel );
    }

    return NO_ERROR;

}   // VOLUMES_LISTBOX :: Refresh

/*******************************************************************

    NAME:       VOLUMES_LISTBOX :: Fill

    SYNOPSIS:   Fills the listbox with the available sharepoints.

    EXIT:       The listbox is filled.

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
DWORD VOLUMES_LISTBOX :: Fill( VOID )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    //  Enumerate all successfully shared volumes.
    //

    PAFP_VOLUME_INFO  pAfpVolumes;
    DWORD	      cEntriesRead;
    DWORD	      cTotalAvail;

    DWORD err = ::AfpAdminVolumeEnum( _hServer,
				      (LPBYTE*)&pAfpVolumes,
				      (DWORD)-1,	// Get all volumes
				      &cEntriesRead,		
				      &cTotalAvail,		
				      NULL );

    //
    //  See if the volumes are available.
    //

    if( err != NO_ERROR )
    {
        return err;
    }

    //
    //  Now that we know the volume info is available,
    //  let's nuke everything in the listbox.
    //

    SetRedraw( FALSE );
    DeleteAllItems();

    //
    //  For iterating the available sharepoints.
    //

    PAFP_VOLUME_INFO pVolIter = pAfpVolumes;

    //
    //  Iterate the volumes adding them to the listbox.
    //

    err = NO_ERROR;

    while( ( err == NO_ERROR ) && ( cEntriesRead-- ) )
    {

        VOLUMES_LBI * pslbi = new VOLUMES_LBI(  pVolIter->afpvol_id,
                                           	pVolIter->afpvol_name,
                                           	pVolIter->afpvol_path,
                                           	pVolIter->afpvol_curr_uses,
                                           	&_dteDisk );

        if( AddItem( pslbi ) < 0 )
        {
            //
            //  CODEWORK:  What should we do in error conditions?
            //  As currently spec'd, we do nothing.  If the data
            //  cannot be retrieved, we display "n/a" in the
            //  statistics strings.  Should we hide the listbox
            //  and display a message a'la WINNET??
            //

            err = ERROR_NOT_ENOUGH_MEMORY;
        }

	pVolIter++;
    }

    ::AfpAdminBufferFree( pAfpVolumes );

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}   // VOLUMES_LISTBOX :: Fill


//
//  VOLUMES_LBI methods.
//

/*******************************************************************

    NAME:       VOLUMES_LBI :: VOLUMES_LBI

    SYNOPSIS:   VOLUMES_LBI class constructor.

    ENTRY:      pszVolumeName           - The sharepoint name.

                pszPath                 - The path for this sharepoint.

                cUses                   - Number of uses for this share.

    EXIT:       The object is constructed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
VOLUMES_LBI :: VOLUMES_LBI( DWORD 	  dwVolumeId,	
			    const TCHAR * pszVolumeName,
                            const TCHAR * pszPath,
			    DWORD	  cUses,
                            DMID_DTE    * pdte )
  : _dwVolumeId( dwVolumeId ),
    _nlsVolumeName( pszVolumeName ),
    _pdte( pdte ),
    _nlsPath( pszPath ),
    _nlsUses( cUses )
{
    UIASSERT( pszVolumeName != NULL );
    UIASSERT( pdte != NULL );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsPath.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsUses.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsVolumeName.QueryError() ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

}   // VOLUMES_LBI :: VOLUMES_LBI


/*******************************************************************

    NAME:       VOLUMES_LBI :: ~VOLUMES_LBI

    SYNOPSIS:   VOLUMES_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
VOLUMES_LBI :: ~VOLUMES_LBI()
{
    _pdte = NULL;

}   // VOLUMES_LBI :: ~VOLUMES_LBI


/*******************************************************************

    NAME:       VOLUMES_LBI :: Paint

    SYNOPSIS:   Draw an entry in VOLUMES_LISTBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
VOID VOLUMES_LBI :: Paint( LISTBOX *        plb,
                           HDC              hdc,
                           const RECT     * prect,
                           GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE_ELLIPSIS 	dteVolumeName( _nlsVolumeName.QueryPch(),
				       plb, ELLIPSIS_RIGHT );
    STR_DTE 		dteUses( _nlsUses.QueryPch() );
    STR_DTE_ELLIPSIS 	dtePath( _nlsPath.QueryPch(), plb, ELLIPSIS_PATH );

    DISPLAY_TABLE dtab( COLS_SV_LB_VOLUMES,
                        ((VOLUMES_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = _pdte;
    dtab[1] = &dteVolumeName;
    dtab[2] = &dteUses;
    dtab[3] = &dtePath;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // VOLUMES_LBI :: Paint


/*******************************************************************

    NAME:       VOLUMES_LBI :: NotifyNewUseCount

    SYNOPSIS:   Notifies the LBI that the "use" count has changed.

    ENTRY:      cUses                   - The new use count.

    RETURNS:    DWORD                   - Any errors that occur.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
APIERR VOLUMES_LBI :: NotifyNewUseCount( DWORD cUses )
{
    DEC_STR nls( cUses );

    APIERR err = nls.QueryError();

    if( err == NERR_Success )
    {
        err = _nlsUses.CopyFrom( nls );
    }

    return err;

}   // VOLUMES_LBI :: NotifyNewUseCount


/*******************************************************************

    NAME:       VOLUMES_LBI :: QueryLeadingChar

    SYNOPSIS:   Returns the first character in the resource name.
                This is used for the listbox keyboard interface.

    RETURNS:    WCHAR                   - The first character in the
                                          resource name.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
WCHAR VOLUMES_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsVolumeName );

    return _nlsVolumeName.QueryChar( istr );

}   // VOLUMES_LBI :: QueryLeadingChar


/*******************************************************************

    NAME:       VOLUMES_LBI :: Compare

    SYNOPSIS:   Compare two BASE_RES_LBI items.

    ENTRY:      plbi                    - The LBI to compare against.

    RETURNS:    INT                     - The result of the compare
                                          ( <0 , ==0 , >0 ).

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
INT VOLUMES_LBI :: Compare( const LBI * plbi ) const
{
    return _nlsVolumeName._stricmp( ((const VOLUMES_LBI *)plbi)->_nlsVolumeName);

}   // VOLUMES_LBI :: Compare


//
//  USERS_LISTBOX methods.
//

/*******************************************************************

    NAME:       USERS_LISTBOX :: USERS_LISTBOX

    SYNOPSIS:   USERS_LISTBOX class constructor.

    ENTRY:      powner                  - The owning window.

                cid                     - The listbox CID.

                hServer                 - Handlr to the remote server.

    EXIT:       The object is constructed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
USERS_LISTBOX :: USERS_LISTBOX( OWNER_WINDOW *    powner,
                                CID               cid,
                                AFP_SERVER_HANDLE hServer )
  : BLT_LISTBOX( powner, cid ),
    _hServer( hServer ),
    _dteIcon( IDBM_LB_USER )
{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( err = _dteIcon.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Retrieve the time separator.
    //

    NLS_STR nlsTimeSep;

    if( ( err = nlsTimeSep.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    INTL_PROFILE intl;

    if( ( err = intl.QueryError() ) != NERR_Success )
    {
        ReportError( intl.QueryError() );
        return;
    }

    if ( ( err = intl.QueryTimeSeparator( &nlsTimeSep ) ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    UIASSERT( nlsTimeSep.QueryTextLength() == 1 );

    _chTimeSep = *(nlsTimeSep.QueryPch());

    //
    //  Build the column width table used for
    //  displaying the listbox items.
    //

    DISPLAY_TABLE::CalcColumnWidths( _adx,
                                     COLS_SV_LB_USERS,
                                     powner,
                                     cid,
                                     TRUE) ;

}   // USERS_LISTBOX :: USERS_LISTBOX


/*******************************************************************

    NAME:       USERS_LISTBOX :: ~USERS_LISTBOX

    SYNOPSIS:   USERS_LISTBOX class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
USERS_LISTBOX :: ~USERS_LISTBOX()
{
    //
    //  This space intentionally left blank.
    //

}   // USERS_LISTBOX :: ~USERS_LISTBOX


/*******************************************************************

    NAME:       USERS_LISTBOX :: Fill

    SYNOPSIS:   Fills the listbox with the connected users.

    ENTRY:      pszShare                - The target sharename.  Note
                                          that this sharename is "sticky"
                                          in that it will be used in
                                          subsequent Refresh() calls.

    EXIT:       The listbox is filled.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
DWORD USERS_LISTBOX :: Fill( DWORD dwVolumeId )
{
    //
    //  Just to be cool...
    //

    AUTO_CURSOR Cursor;

    //
    //  Nuke the listbox.
    //

    DeleteAllItems();

    //
    //  If the Volume Id is zero (a valid scenario) then
    //  there are no connections in the listbox.
    //

    if( dwVolumeId == 0 )
    {
        return NO_ERROR;
    }

    //
    //  Enumerate the connections to this volume.
    //

    PAFP_CONNECTION_INFO pAfpConnections;
    DWORD	      	 cEntriesRead;
    DWORD	         cTotalAvail;


    DWORD err = ::AfpAdminConnectionEnum( _hServer,
				      	  (LPBYTE*)&pAfpConnections,
					  AFP_FILTER_ON_VOLUME_ID,
					  dwVolumeId,
				      	  (DWORD)-1,	// Get all conenctions
				          &cEntriesRead,
				          &cTotalAvail,
				          NULL );

    //
    //  See if the connections are available.
    //

    if( err != NO_ERROR )
    {
        return err;
    }

    SetRedraw( FALSE );

    //
    //  For iterating the available connections.
    //

    PAFP_CONNECTION_INFO pConnIter = pAfpConnections;

    //
    //  Iterate the connections adding them to the listbox.
    //

    while( ( err == NO_ERROR ) && ( cEntriesRead-- ) )
    {
        USERS_LBI * pclbi = new USERS_LBI( pConnIter->afpconn_id,
					   pConnIter->afpconn_username,
					   pConnIter->afpconn_time,
					   pConnIter->afpconn_num_opens,
                                           _chTimeSep,
					   &_dteIcon );

        if( AddItem( pclbi ) < 0 )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
  	
	pConnIter++;
    }

    ::AfpAdminBufferFree( pAfpConnections );

    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}   // USERS_LISTBOX :: Fill


/*******************************************************************

    NAME:       USERS_LISTBOX :: Refresh

    SYNOPSIS:   Refreshes the listbox, maintaining (as much as
                possible) the relative position of the current
                selection.

    EXIT:       The listbox is feeling refreshed.

    RETURNS:    DWORD                  - Any errors encountered.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
DWORD USERS_LISTBOX :: Refresh( DWORD dwVolumeId )
{
    INT iCurrent = QueryCurrentItem();
    INT iTop     = QueryTopIndex();

    DWORD err = Fill( dwVolumeId );

    if( err != NO_ERROR )
    {
        return err;
    }

    INT cItems = QueryCount();

    if( cItems > 0 )
    {
        iCurrent = min( max( iCurrent, 0 ), cItems - 1 );
        iTop     = min( max( iTop, 0 ), cItems - 1 );

        SelectItem( iCurrent );
        SetTopIndex( iTop );
    }

    return NO_ERROR;

}   // USERS_LISTBOX :: Refresh


/*******************************************************************

    NAME:       USERS_LISTBOX :: AreResourcesOpen

    SYNOPSIS:   Returns TRUE if any user in the listbox has any
                resources open.

    RETURNS:    BOOL

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
BOOL USERS_LISTBOX :: AreResourcesOpen( VOID ) const
{
    INT cItems = QueryCount();

    for( INT i = 0 ; i < cItems ; i++ )
    {
        USERS_LBI * plbi = QueryItem( i );

        if( plbi->QueryNumOpens() > 0 )
        {
            return TRUE;
        }
    }

    return FALSE;

}   // USERS_LISTBOX :: AreResourcesOpen



//
//  USERS_LBI methods.
//

/*******************************************************************

    NAME:       USERS_LBI :: USERS_LBI

    SYNOPSIS:   USERS_LBI class constructor.

    ENTRY:      pszUserName             - The user for this entry.

                pszComputerName         - The user's computer name.

                ulTime                  - Connection time.

                cOpens                  - Number of opens on this connection.

                chTimeSep               - Time format separator.

    EXIT:       The object is constructed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
USERS_LBI :: USERS_LBI( DWORD	      dwConnectionId,
			const TCHAR * pszUserName,
                        ULONG         ulTime,
                        DWORD         cOpens,
                        TCHAR         chTimeSep,
                        DMID_DTE    * pdte )
  : _dwConnectionId( dwConnectionId ),
    _nlsInUse(),
    _nlsUserName(),
    _nlsTime( ulTime, chTimeSep ),
    _pdte( pdte ),
    _cOpens( cOpens )
{
    //
    //  Make sure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsUserName.QueryError()     ) != NERR_Success ) ||
        ( ( err = _nlsInUse.QueryError()        ) != NERR_Success ) ||
        ( ( err = _nlsTime.QueryError()         ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

    //
    //  Build the more complex display strings.
    //

    err = _nlsInUse.Load( ( cOpens > 0 ) ? IDS_YES : IDS_NO );

    if ( err == NERR_Success )
    {
	if ( pszUserName == NULL )
	{
    	    err = _nlsUserName.Load( IDS_GUEST );
	}
    	else
    	{
    	    err = _nlsUserName.CopyFrom( pszUserName );
    	}
    }

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // USERS_LBI :: USERS_LBI


/*******************************************************************

    NAME:       USERS_LBI :: ~USERS_LBI

    SYNOPSIS:   USERS_LBI class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
USERS_LBI :: ~USERS_LBI()
{
    //
    //  This space intentionally left blank.
    //

}   // USERS_LBI :: ~USERS_LBI


/*******************************************************************

    NAME:       USERS_LBI :: Paint

    SYNOPSIS:   Draw an entry in USERS_LISTBOX.

    ENTRY:      plb                     - Pointer to a BLT_LISTBOX.

                hdc                     - The DC to draw upon.

                prect                   - Clipping rectangle.

                pGUILTT                 - GUILTT info.

    EXIT:       The item is drawn.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
VOID USERS_LBI :: Paint( LISTBOX *        plb,
                         HDC              hdc,
                         const RECT     * prect,
                         GUILTT_INFO    * pGUILTT ) const
{
    STR_DTE_ELLIPSIS 	dteUserName( _nlsUserName.QueryPch(),
				     plb, ELLIPSIS_RIGHT );
    STR_DTE 		dteTime( _nlsTime.QueryPch() );
    STR_DTE 		dteInUse( _nlsInUse.QueryPch() );

    DISPLAY_TABLE dtab( COLS_SV_LB_USERS, 	
			((USERS_LISTBOX *)plb)->QueryColumnWidths() );

    dtab[0] = _pdte;
    dtab[1] = &dteUserName;
    dtab[2] = &dteTime;
    dtab[3] = &dteInUse;

    dtab.Paint( plb, hdc, prect, pGUILTT );

}   // USERS_LBI :: Paint


/*******************************************************************

    NAME:       USERS_LBI :: QueryLeadingChar

    SYNOPSIS:   Return the leading character of this item.

    RETURNS:    WCHAR                   - The leading character.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
WCHAR USERS_LBI :: QueryLeadingChar( VOID ) const
{
    ISTR istr( _nlsUserName );

    return _nlsUserName.QueryChar( istr );

}   // USERS_LBI :: QueryLeadingChar

/*******************************************************************

    NAME:       USERS_LBI :: Compare

    SYNOPSIS:   Compare two USERS_LBI items.

    ENTRY:      plbi                    - The "other" item.

    RETURNS:    INT                     -  0 if the items match.
                                          -1 if we're < the other item.
                                          +1 if we're > the other item.

    HISTORY:
	NarenG	    02-Oct-1993 Stole from Server Manager and folded
				BASE_RES_DIALOG and FILES_DIALOG into one.

********************************************************************/
INT USERS_LBI :: Compare( const LBI * plbi ) const
{
    NLS_STR * pnls = &(((USERS_LBI *)plbi)->_nlsUserName);

    return _nlsUserName._stricmp( *pnls );

}   // USERS_LBI :: Compare
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\volmgt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
 *   volmgt.cxx
 *     Contains the dialog for managing volumes in the server manager
 *       VOLUME_MANAGEMENT_DIALOG
 *
 *   FILE HISTORY:
 *     NarenG        	11/11/92        Modified sharemgt.cxx for AFPMGR
 *
 */

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSERVER
#define INCL_NETSHARE
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}


#include <string.hxx>
#include <uitrace.hxx>

#include <newvol.hxx>
#include <volprop.hxx>
#include "util.hxx"
#include "volmgt.hxx"

/*******************************************************************

    NAME:       VOLUME_MANAGEMENT_DIALOG::VOLUME_MANAGEMENT_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
		hServer		  - handle to the target server
                pszServerName     - name of the selected computer

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

VOLUME_MANAGEMENT_DIALOG::VOLUME_MANAGEMENT_DIALOG( 
					HWND 		  hwndOwner,
					AFP_SERVER_HANDLE hServer,
                                        const TCHAR 	  *pszServerName )  
	: VIEW_VOLUMES_DIALOG_BASE( MAKEINTRESOURCE(IDD_VOLUME_MANAGEMENT_DLG),
  				    hwndOwner,  
				    hServer,
    			            pszServerName,
				    TRUE,
				    IDVM_SLT_VOLUME_TITLE,
				    IDVM_LB_VOLUMES),
      _pbVolumeDelete( this, IDVM_PB_DELETE_VOL ),
      _pbVolumeInfo( this, IDVM_PB_VOL_INFO ),
      _hServer( hServer ),
      _nlsServerName( pszServerName ),
      _pbClose( this, IDOK )
{

    //
    // Just to be cool
    //

    AUTO_CURSOR Cursor;

    // 
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    DWORD err;

    if ( ( err = _nlsServerName.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  Set the caption to "Volumes on Server".
    //

    err = ::SetCaption( this, IDS_CAPTION_VOLUMES, pszServerName );

    if ( err != NO_ERROR )
    {
        ReportError( err );
        return;
    }

    err = Refresh();

    if ( err != NO_ERROR )
    {
        ReportError( err );
        return;
    }

    ResetControls();

}


/*******************************************************************

    NAME:       VOLUME_MANAGEMENT_DIALOG::Refresh

    SYNOPSIS:   Refresh the volume listbox

    ENTRY:      

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

DWORD VOLUME_MANAGEMENT_DIALOG::Refresh( VOID )
{
    //
    // Just to be cool
    //

    AUTO_CURSOR Cursor;

    DWORD err = VIEW_VOLUMES_DIALOG_BASE::Refresh();

    ResetControls();

    return err;
}

/*******************************************************************

    NAME:       VOLUME_MANAGEMENT_DIALOG::ResetControls

    SYNOPSIS:   Enable/Disable/MakeDefault the push buttons according
                to whether there are items in the listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

VOID VOLUME_MANAGEMENT_DIALOG::ResetControls( VOID )
{
    INT nCount = QueryLBVolumes()->QueryCount();

    // 
    // If there are items in the listbox, select the first one
    // and set focus to the listbox.
    //

    if ( nCount > 0 )
    {
        QueryLBVolumes()->SelectItem( 0 );
        QueryLBVolumes()->ClaimFocus();
        _pbVolumeDelete.Enable( TRUE );
        _pbVolumeInfo.Enable( IsFocusOnGoodVolume() );
	
    }
    else
    {
    	//
    	// Else set focus to the Close button
    	//

        _pbClose.MakeDefault();
        _pbClose.ClaimFocus();
        _pbVolumeDelete.Enable( FALSE );
        _pbVolumeInfo.Enable( FALSE );
    }
         
}

/*******************************************************************

    NAME:       VOLUME_MANAGEMENT_DIALOG::OnCommand

    SYNOPSIS:   Handle all push buttons commands

    ENTRY:      event - the CONTROL_EVENT that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/
BOOL VOLUME_MANAGEMENT_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    switch ( event.QueryCid() )
    {
        case IDVM_PB_DELETE_VOL:
            return( OnVolumeDelete() );

        case IDVM_PB_VOL_INFO:
            return( OnVolumeInfo() );
            break;

        case IDVM_PB_ADD_VOLUME:
            return( OnVolumeAdd() );
            break;

	case IDVM_LB_VOLUMES:
    	    _pbVolumeInfo.Enable( IsFocusOnGoodVolume() );
	    break;

        default:
	    break;

    }

    return( VIEW_VOLUMES_DIALOG_BASE::OnCommand( event ) );

}

/*******************************************************************

    NAME:       VOLUME_MANAGEMENT_DIALOG::OnVolumeDelete

    SYNOPSIS:   Called when the "Stop Sharing" button is pressed.
                Delete the selected share and pop up any warning
                message if there are users connected to the share.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/
BOOL VOLUME_MANAGEMENT_DIALOG::OnVolumeDelete( VOID )
{

    //
    // First warn the user.
    //

    if ( ::MsgPopup(    this,
                       	IDS_DELETE_VOLUME_CONFIRM,
                       	MPSEV_WARNING,
                       	MP_YESNO,
                       	MP_YES ) == IDNO ) 
    {
        return NO_ERROR;
    }

    //
    // Just to be cool
    //

    AUTO_CURSOR Cursor;

    VIEW_VOLUMES_LISTBOX *plbVolume = QueryLBVolumes();
    VIEW_VOLUMES_LBI *pvlbi = plbVolume->QueryItem();

    BOOL fCancel;

    //
    // Delete the selected item in the listbox
    //

    DWORD err = VolumeDelete( pvlbi, &fCancel );

    if ( err != NO_ERROR )
    {
        ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
    }

    if ( ( err = Refresh() ) != NO_ERROR )
    {
    	::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	return FALSE;
    }

    return TRUE;

}

/*******************************************************************

    NAME:       VOLUME_MANAGEMENT_DIALOG::OnVolumeAdd

    SYNOPSIS:   Called when the "New Volume" button is pressed.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

BOOL VOLUME_MANAGEMENT_DIALOG::OnVolumeAdd( VOID )
{
    //
    // Just to be cool
    //

    AUTO_CURSOR Cursor;

    DWORD err = NO_ERROR;

    NEW_VOLUME_SRVMGR_DIALOG *pDlg = new NEW_VOLUME_SRVMGR_DIALOG( 
						QueryHwnd(), 
						_hServer,
						_nlsServerName.QueryPch() );
		
    if ( ( pDlg == NULL )
       || ((err = pDlg->QueryError()) != NERR_Success )
       || ((err = pDlg->Process())    != NERR_Success )
       )
    {
        err = err ? err : ERROR_NOT_ENOUGH_MEMORY;
    }

    delete pDlg;

    pDlg = NULL;

    if ( err != NO_ERROR )
    {
        ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
    }

    if ( ( err = Refresh() ) != NO_ERROR )
    {
    	::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	return FALSE;
    }

    return TRUE;

}

/*******************************************************************

    NAME:       VOLUME_MANAGEMENT_DIALOG::OnVolumeInfo

    SYNOPSIS:   Called when the "Properties" button is pressed.
                Will pop up a dialog showing the properties of the
                selected share.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

BOOL VOLUME_MANAGEMENT_DIALOG::OnVolumeInfo( VOID )
{
    if ( !IsFocusOnGoodVolume() )
    {
	return FALSE;
    } 

    //
    // Just to be cool
    //

    AUTO_CURSOR Cursor;

    DWORD err = NO_ERROR;

    VIEW_VOLUMES_LISTBOX *plbVolume = QueryLBVolumes();
    VIEW_VOLUMES_LBI *pvlbi = plbVolume->QueryItem();

    VOLUME_PROPERTIES_DIALOG *pDlg = new VOLUME_PROPERTIES_DIALOG( 
					QueryHwnd(), 
					_hServer,
					pvlbi->QueryVolumeName(),
					_nlsServerName.QueryPch(),
					TRUE );
		
    if ( ( pDlg == NULL )
       || ((err = pDlg->QueryError()) != NERR_Success )
       || ((err = pDlg->Process())    != NERR_Success )
       )
    {
        err = err ? err : ERROR_NOT_ENOUGH_MEMORY;
    }

    delete pDlg;

    pDlg = NULL;

    if ( err != NO_ERROR )
    {
        ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

        if ( ( err = Refresh() ) != NO_ERROR )
        {
    	    ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
	}

	return FALSE;
    }

    return TRUE;

}

/*******************************************************************

    NAME:       VOLUME_MANAGEMENT_DIALOG::OnVolumeLbDblClk

    SYNOPSIS:   This is called when the user double clicks on a volume
                in the listbox. Will pop up a dialog showing the 
                properties of the selected volume if is valid.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

BOOL VOLUME_MANAGEMENT_DIALOG::OnVolumeLbDblClk( VOID )
{
    return( OnVolumeInfo() );
}

/*******************************************************************

    NAME:       VOLUME_MANAGEMENT_DIALOG::QueryHelpContext

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

ULONG VOLUME_MANAGEMENT_DIALOG::QueryHelpContext( VOID )
{
    return HC_VOLUME_MANAGEMENT_DIALOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\voledit.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    voledit.cxx
      Contains the dialog for editing volumes in the file manager
      VOLUME_EDIT_DIALOG
 
    FILE HISTORY:
      NarenG        	11/11/92        Modified sharemgt.cxx for AFPMGR
 
*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSERVER
#define INCL_NETSHARE
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}


#include <lmoloc.hxx>
#include <string.hxx>
#include <uitrace.hxx>

#include <volprop.hxx>
#include "voledit.hxx"

/*******************************************************************

    NAME:       VOLUME_EDIT_DIALOG::VOLUME_EDIT_DIALOG

    SYNOPSIS:   Constructor

    ENTRY:      hwndParent        - hwnd of the parent window
		hServer		  - handle to the target server
                pszServerName     - name of the selected computer

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

VOLUME_EDIT_DIALOG::VOLUME_EDIT_DIALOG( HWND 		  hwndOwner,
					AFP_SERVER_HANDLE hServer,
                                        const TCHAR 	  *pszServerName,
                                        const TCHAR 	  *pszPath,
					BOOL		  fIsFile )  
	: VIEW_VOLUMES_DIALOG_BASE( MAKEINTRESOURCE(IDD_VOLUME_EDIT_DLG),
  				    hwndOwner,  
				    hServer,
    			            pszServerName,
				    FALSE,
				    IDEV_SLT_VOLUME_TITLE,
				    IDEV_LB_VOLUMES),
      _pbVolumeInfo( this, IDEV_PB_VOL_INFO ),
      _hServer( hServer ),
      _pbClose( this, IDOK ),
      _sltVolumeTitle( this, IDEV_SLT_VOLUME_TITLE )
{

    AUTO_CURSOR Cursor;
    
    // 
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;
   
    //
    // Set the text of the list box title
    //

    DWORD    err;
    NLS_STR  nlsServer;
    LOCATION Loc( pszServerName );

    RESOURCE_STR nlsTitle( IDS_VOLUMES_LB_TITLE_TEXT );
    
    if ( ((err = nlsTitle.QueryError()) 		!= NERR_Success ) || 
         ((err = _sltVolumeTitle.QueryError())		!= NERR_Success ) || 
         ((err = nlsServer.QueryError()) 		!= NERR_Success ) || 
         ((err = Loc.QueryDisplayName( &nlsServer ))	!= NERR_Success ) || 
	 ((err = nlsTitle.InsertParams( nlsServer ))    != NERR_Success ))
    {
        ReportError( err );
	return;
    }       

    _sltVolumeTitle.SetText( nlsTitle );

    err = Refresh();

    if ( err != NO_ERROR )
    {
        ReportError( err );
        return;
    }

    //
    // If there are not items then tell the user that there are no
    // items to delete
    //

    if ( QueryLBVolumes()->QueryCount() == 0 )
    {
    	::MsgPopup( this, IDS_NO_VOLUMES, MPSEV_INFO );
        ReportError( ERROR_ALREADY_REPORTED );
        return;
    }

    //
    // If the current selection is a directory set the initial 
    // selection to the item that matches this directory path.
    //

    if ( !fIsFile )
    {
	if ( (err = SelectVolumeItem( pszPath ) ) != NERR_Success )
        {
            ReportError( err );
            return;
	}
    }

    ResetControls();

}


/*******************************************************************

    NAME:       VOLUME_EDIT_DIALOG::ResetControls

    SYNOPSIS:   Enable/Disable/MakeDefault the push buttons according
                to whether there are items in the listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

VOID VOLUME_EDIT_DIALOG::ResetControls( VOID )
{
    INT nCount = QueryLBVolumes()->QuerySelCount();

    //
    // If there was no initial selection, then simply select the first item
    //

    if ( nCount == 0 )
    {
        QueryLBVolumes()->SelectItem( 0 );
    }

    QueryLBVolumes()->ClaimFocus();
         
}

/*******************************************************************

    NAME:       VOLUME_EDIT_DIALOG::OnCommand

    SYNOPSIS:   Handle all push buttons commands

    ENTRY:      event - the CONTROL_EVENT that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/
BOOL VOLUME_EDIT_DIALOG::OnCommand( const CONTROL_EVENT &event )
{
    switch ( event.QueryCid() )
    {
        case IDEV_PB_VOL_INFO:
            return( OnVolumeInfo() );

        default:
    	    return VIEW_VOLUMES_DIALOG_BASE::OnCommand( event );
    }

}

/*******************************************************************

    NAME:       VOLUME_EDIT_DIALOG::OnVolumeInfo

    SYNOPSIS:   Called when the "Properties" button is pressed.
                Will pop up a dialog showing the properties of the
                selected volume.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

BOOL VOLUME_EDIT_DIALOG::OnVolumeInfo( VOID )
{
    AUTO_CURSOR Cursor;

    INT nCount = QueryLBVolumes()->QuerySelCount();

    if ( nCount == 0 )
    {
	return FALSE;
    }

    DWORD err = NO_ERROR;

    VIEW_VOLUMES_LISTBOX *plbVolume = QueryLBVolumes();
    VIEW_VOLUMES_LBI *pvlbi = plbVolume->QueryItem();

    VOLUME_PROPERTIES_DIALOG *pDlg = new VOLUME_PROPERTIES_DIALOG( 
					QueryHwnd(), 
					_hServer,
					pvlbi->QueryVolumeName(),
					NULL,
					FALSE );
		
    if ( ( pDlg == NULL )
       || ((err = pDlg->QueryError()) != NERR_Success )
       || ((err = pDlg->Process())    != NERR_Success )
       )
    {
        err = err ? err : ERROR_NOT_ENOUGH_MEMORY;
    }

    delete pDlg;

    pDlg = NULL;

    if ( err != NO_ERROR )
    {
        ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

        if ( ( err = Refresh() ) != NO_ERROR )
        {
            ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );

	    return FALSE;
        }

        if ( QueryLBVolumes()->QueryCount() > 0 )
        {
            QueryLBVolumes()->SelectItem( 0 );
     	    QueryLBVolumes()->ClaimFocus();
        }
  	else
	{
      	    _pbVolumeInfo.Enable( FALSE );
      	    _pbClose.ClaimFocus();
	}
    }

    return TRUE;

}

/*******************************************************************

    NAME:       VOLUME_EDIT_DIALOG::OnVolumeLbDblClk

    SYNOPSIS:   This is called when the user double clicks on a volume
                in the listbox. Will pop up a dialog showing the 
                properties of the selected volume.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

BOOL VOLUME_EDIT_DIALOG::OnVolumeLbDblClk( VOID )
{
    return OnVolumeInfo();
}

/*******************************************************************

    NAME:       VOLUME_EDIT_DIALOG::QueryHelpContext

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
        NarenG          11/18/92        Modified for AFPMGR

********************************************************************/

ULONG VOLUME_EDIT_DIALOG::QueryHelpContext( VOID )
{
    return HC_VOLUME_EDIT_DIALOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\vvolbase.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    vvolbase.cxx
      Contains the base dialog for used by the delete volume dialog
      the volume management dialog and the edit volume dialog.

    FILE HISTORY:
      NarenG          11/11/92        Stole and modified sharestp.cxx
*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#include <blt.hxx>


extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}

#include <ellipsis.hxx>
#include <string.hxx>
#include <uitrace.hxx>

#include <strnumer.hxx>

#include "curusers.hxx"
#include "vvolbase.hxx"

/*******************************************************************

    NAME:       VIEW_VOLUMES_LBI::VIEW_VOLUMES_LBI

    SYNOPSIS:   Listbox items used in the VIEW_VOLUMES_LISTBOX

    ENTRY:      dwVolumeId	- Id of this volume.
		pszVolumeName   - Name of volume.
		pszVolumePath	- Path of volume.
		fGoodVolume  	- If this volume was successfully shared.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

VIEW_VOLUMES_LBI::VIEW_VOLUMES_LBI( DWORD	  dwVolumeId,
				    const TCHAR * pszVolumeName,
				    const TCHAR * pszVolumePath,
				    BOOL 	  fGoodVolume )
     : _dwVolumeId( dwVolumeId ),
       _nlsVolumeName( pszVolumeName ),
       _nlsVolumePath( pszVolumePath ),
       _fGoodVolume( fGoodVolume )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;

    if (  (( err = _nlsVolumeName.QueryError()) != NERR_Success )
       || (( err = _nlsVolumePath.QueryError()) != NERR_Success ))
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       VIEW_VOLUMES_LBI::~VIEW_VOLUMES_LBI

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

VIEW_VOLUMES_LBI::~VIEW_VOLUMES_LBI()
{

    //
    // This space intentionally left blank
    //

}


/*******************************************************************

    NAME:       VIEW_VOLUMES_LBI::QueryLeadingChar

    SYNOPSIS:   Returns the leading character of the listbox item.
                The enables shortcut keys in the listbox

    ENTRY:

    EXIT:

    RETURNS:    Returns the first char of the volume name

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

WCHAR VIEW_VOLUMES_LBI::QueryLeadingChar( VOID ) const
{

    ISTR istr( _nlsVolumeName );

    return _nlsVolumeName.QueryChar( istr );

}

/*******************************************************************

    NAME:       VIEW_VOLUMES_LBI::Paint

    SYNOPSIS:   Redefine Paint() method of LBI class

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

VOID VIEW_VOLUMES_LBI::Paint( 	LISTBOX 	*plb,
                       		HDC 		hdc,
                       		const RECT 	*prect,
                       		GUILTT_INFO 	*pGUILTT ) const
{

    STR_DTE_ELLIPSIS strdteVolumeName( _nlsVolumeName.QueryPch(),
				       plb, ELLIPSIS_RIGHT );
    STR_DTE_ELLIPSIS strdteVolumePath( _nlsVolumePath, plb, ELLIPSIS_PATH );

    DISPLAY_TABLE dt(COLS_VV_LB_VOLUMES,
		     ((VIEW_VOLUMES_LISTBOX *) plb)->QueryColumnWidths() );

    dt[0] = _fGoodVolume
	    ? ((VIEW_VOLUMES_LISTBOX *) plb)->QueryGoodVolumeBitmap()
	    : ((VIEW_VOLUMES_LISTBOX *) plb)->QueryBadVolumeBitmap();

    dt[1] = &strdteVolumeName;
    dt[2] = &strdteVolumePath;

    dt.Paint( plb, hdc, prect, pGUILTT );

}

/*******************************************************************

    NAME:       VIEW_VOLUMES_LBI::Compare

    SYNOPSIS:   Redefine Compare() method of LBI class
                We compare the share names of two LBIs.

    ENTRY:      plbi - pointer to the LBI to compare with

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/
INT VIEW_VOLUMES_LBI::Compare( const LBI *plbi ) const
{
    return( _nlsVolumeName._stricmp(
	    ((const VIEW_VOLUMES_LBI *)plbi)->_nlsVolumeName ));
}

/*******************************************************************

    NAME:       VIEW_VOLUMES_LISTBOX::VIEW_VOLUMES_LISTBOX

    SYNOPSIS:   Constructor

    ENTRY:      powin      - owner window
                cid        - resource id of the share listbox

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

VIEW_VOLUMES_LISTBOX::VIEW_VOLUMES_LISTBOX(
					OWNER_WINDOW 	  *powin,
      					BOOL 		  fDisplayBadVolumes,
					CID 	 	  cid,
					AFP_SERVER_HANDLE hServer )
    : BLT_LISTBOX( powin, cid ),
      _hServer( hServer ),
      _fDisplayBadVolumes( fDisplayBadVolumes ),
      _dmdteGoodVolume( IDBM_LB_GOOD_VOLUME ),
      _dmdteBadVolume( IDBM_LB_BAD_VOLUME )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = NERR_Success;

    if ( ((err = _dmdteGoodVolume.QueryError()) != NERR_Success ) ||
         ((err = _dmdteBadVolume.QueryError()) != NERR_Success ))
    {
        ReportError( err );
	return;
    }

    if ( ( err = DISPLAY_TABLE::CalcColumnWidths( _adx,
						  COLS_VV_LB_VOLUMES,
					 	  powin,
						  cid,
						  TRUE ) ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       VIEW_VOLUMES_LISTBOX::~VIEW_VOLUMES_LISTBOX

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

VIEW_VOLUMES_LISTBOX::~VIEW_VOLUMES_LISTBOX()
{

    //
    // This space intentionally left blank
    //
}

/*******************************************************************

    NAME:       VIEW_VOLUMES_LISTBOX::Refresh

    SYNOPSIS:   Update the volumes in the listbox

    ENTRY:      hServer - handle to the target server.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

*******************************************************************/

DWORD VIEW_VOLUMES_LISTBOX::Refresh( VOID )
{

    //
    //  Enumerate all successfully shared volumes.
    //

    PAFP_VOLUME_INFO  pAfpVolumes;
    DWORD	      cgvEntriesRead;
    DWORD	      cTotalAvail;

    DWORD err = ::AfpAdminVolumeEnum( _hServer,
				      (LPBYTE*)&pAfpVolumes,
				      (DWORD)-1,	// Get all volumes
				      &cgvEntriesRead,		
				      &cTotalAvail,		
				      NULL );

    //
    //  See if the volumes are available.
    //

    if( err != NO_ERROR )
    {
        return err;
    }

    //
    // Get all the bad volumes if so requested.
    //

    PAFP_VOLUME_INFO  pAfpBadVolumes;
    DWORD	      cbvEntriesRead;

    if ( _fDisplayBadVolumes )
    {
    	err = ::AfpAdminInvalidVolumeEnum( _hServer,
				           (LPBYTE*)&pAfpBadVolumes,
				           &cbvEntriesRead );
    	if( err != NO_ERROR )
    	{
	    return err;
    	}

    }

    //
    //  Now that we know the volume info is available,
    //  let's nuke everything in the listbox.
    //

    SetRedraw( FALSE );
    DeleteAllItems();

    //
    //  For iterating volumes
    //

    PAFP_VOLUME_INFO pVolIter = pAfpVolumes;

    //
    //  Iterate the volumes adding them to the listbox.
    //

    err = NO_ERROR;

    while( ( err == NO_ERROR ) && ( cgvEntriesRead-- ) )
    {

        VIEW_VOLUMES_LBI * plbi = new VIEW_VOLUMES_LBI(
						pVolIter->afpvol_id,
                                           	pVolIter->afpvol_name,
                                           	pVolIter->afpvol_path,
						TRUE );

        if( AddItem( plbi ) < 0 )
        {
            //
            //  CODEWORK:  What should we do in error conditions?
            //  As currently spec'd, we do nothing.  If the data
            //  cannot be retrieved, we display "n/a" in the
            //  statistics strings.  Should we hide the listbox
            //  and display a message a'la WINNET??
            //

            err = ERROR_NOT_ENOUGH_MEMORY;
        }

	pVolIter++;
    }

    ::AfpAdminBufferFree( pAfpVolumes );

    //
    // If we have to display bad volumes.
    //

    if ( _fDisplayBadVolumes && ( err == NO_ERROR ) )
    {

    	pVolIter = pAfpBadVolumes;

    	//
    	//  Iterate the volumes adding them to the listbox.
    	//

    	while( ( err == NO_ERROR ) && ( cbvEntriesRead-- ) )
    	{

            VIEW_VOLUMES_LBI * plbi = new VIEW_VOLUMES_LBI(
						pVolIter->afpvol_id,
                                           	pVolIter->afpvol_name,
                                           	pVolIter->afpvol_path,
						FALSE );

            if( AddItem( plbi ) < 0 )
            {
            	//
            	//  CODEWORK:  What should we do in error conditions?
            	//  As currently spec'd, we do nothing.  If the data
            	//  cannot be retrieved, we display "n/a" in the
            	//  statistics strings.  Should we hide the listbox
            	//  and display a message a'la WINNET??
            	//

            	err = ERROR_NOT_ENOUGH_MEMORY;
            }

	    pVolIter++;
	}

    	::AfpAdminBufferFree( pAfpBadVolumes );
    }


    SetRedraw( TRUE );
    Invalidate( TRUE );

    return err;

}

/*******************************************************************

    NAME:       VIEW_VOLUMES_DIALOG_BASE::VIEW_VOLUMES_DIALOG_BASE

    SYNOPSIS:   Constructor

    ENTRY:
		idrsrcDialog	  - dialog resources id
                hwndOwner         - handle of the parent
    		pszServerName 	  - current focus server
                ulHelpContextBase - the base help context

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

VIEW_VOLUMES_DIALOG_BASE::VIEW_VOLUMES_DIALOG_BASE(
					const IDRESOURCE   &idrsrcDialog,
                                  	const PWND2HWND    &hwndOwner,
                                    	AFP_SERVER_HANDLE  hServer,
    			      		const TCHAR	   *pszServerName,
				        BOOL		   fDisplayBadVolumes,
					DWORD		   cidVolumeTitle,
					DWORD		   cidVolumesLb )
    : DIALOG_WINDOW( idrsrcDialog, hwndOwner ),
      _sltVolumeTitle( this, cidVolumeTitle ),
      _lbVolumes( this, fDisplayBadVolumes, cidVolumesLb, hServer ),
      _pszServerName( pszServerName ),
      _hServer( hServer ),
      _cidVolumesLb( cidVolumesLb )
{

    //
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if ( ((err = _sltVolumeTitle.QueryError()) != NERR_Success ) ||
         ((err = _lbVolumes.QueryError()) != NERR_Success ))
    {
	ReportError( err );
	return;
    }

    err = BASE_ELLIPSIS::Init();

    if( err != NO_ERROR )
    {
        ReportError( err );
	return;
    }
}

/*******************************************************************

    NAME:       VIEW_VOLUMES_DIALOG_BASE::~VIEW_VOLUMES_DIALOG_BASE

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

VIEW_VOLUMES_DIALOG_BASE::~VIEW_VOLUMES_DIALOG_BASE()
{

    BASE_ELLIPSIS::Term();
}

/*******************************************************************

    NAME:       VIEW_VOLUMES_DIALOG_BASE::SelectVolumeItem

    SYNOPSIS:   Selects the item which has the same path as the
		supplied path.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

APIERR VIEW_VOLUMES_DIALOG_BASE::SelectVolumeItem( const TCHAR * pszPath )
{
    NLS_STR nlsPath( pszPath );

    APIERR err = nlsPath.QueryError();

    if ( err != NERR_Success )
    {
	return err;
    }

    INT ilbCount = _lbVolumes.QueryCount();

    for ( INT i = 0; i < ilbCount; i++ )
    {
 	VIEW_VOLUMES_LBI *pvvlbi = _lbVolumes.QueryItem(i);

        if ( nlsPath._stricmp( pvvlbi->QueryVolumePath() ) == 0 )
	{
            _lbVolumes.SelectItem(i);
	    break;
	}
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:       VIEW_VOLUMES_DIALOG_BASE::Refresh

    SYNOPSIS:   Refresh the volumes listbox

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

DWORD VIEW_VOLUMES_DIALOG_BASE::Refresh( VOID )
{
    APIERR err = _lbVolumes.Refresh();

    _lbVolumes.Enable( _lbVolumes.QueryCount() > 0 );

    _sltVolumeTitle.Enable( _lbVolumes.QueryCount() > 0 );

    return err;
}

/*******************************************************************

    NAME:       VIEW_VOLUMES_DIALOG_BASE::OnCommand

    SYNOPSIS:   Check if the user double clicks on a volume

    ENTRY:      event - the event that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

BOOL VIEW_VOLUMES_DIALOG_BASE::OnCommand( const CONTROL_EVENT &event )
{
    APIERR err = NERR_Success;

    if ( event.QueryCid() == _cidVolumesLb )
    {
    	if ((event.QueryCode() == LBN_DBLCLK) && (_lbVolumes.QuerySelCount()>0))
        {
            return OnVolumeLbDblClk();
        }
    }

    return DIALOG_WINDOW::OnCommand( event );
}

/*******************************************************************

    NAME:       VIEW_VOLUMES_DIALOG_BASE::VolumeDelete

    SYNOPSIS:   Helper method to Delete a volume and popup any
                warning if some users are connected to the volume

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

DWORD VIEW_VOLUMES_DIALOG_BASE::VolumeDelete( VIEW_VOLUMES_LBI * pvlbi,
					      BOOL	       * pfCancel )
{

    *pfCancel = FALSE;

    //
    // If this is a bad volume simply delete it
    //

    if ( !(pvlbi->IsVolumeValid()) )
    {
	DWORD err = ::AfpAdminInvalidVolumeDelete(
					_hServer,
				      	(LPWSTR)pvlbi->QueryVolumeName() );

	return err;
    }

    BOOL  fOK = TRUE;

    //
    // Check if there are any users connected to the volume
    // by enumerating the connections to this volume.
    //
    PAFP_CONNECTION_INFO pAfpConnections;
    DWORD	      	 cEntriesRead;
    DWORD	         cTotalAvail;


    DWORD err = ::AfpAdminConnectionEnum( _hServer,
				    	  (LPBYTE*)&pAfpConnections,
				    	  AFP_FILTER_ON_VOLUME_ID,
				    	  pvlbi->QueryVolumeId(),
				          (DWORD)-1,	// Get all conenctions
				          &cEntriesRead,
				          &cTotalAvail,
				          NULL );

    //
    //  See if the connections are available.
    //

    if( err != NO_ERROR )
    {
        return err;
    }

    if ( cEntriesRead > 0 )
    {

        //
        // There are users currently connected to the share to be deleted,
        // hence, popup a dialog displaying all uses to the volume.
        //

        CURRENT_USERS_WARNING_DIALOG *pdlg =
            new CURRENT_USERS_WARNING_DIALOG( QueryRobustHwnd(),
					      _hServer,
					      pAfpConnections,
					      cEntriesRead,
                                              pvlbi->QueryVolumeName());

        if (  ( pdlg == NULL )
           || ((err = pdlg->QueryError())    != NERR_Success )
           || ((err = pdlg->Process( &fOK )) != NERR_Success )
           )
        {
            err = pdlg == NULL ? ERROR_NOT_ENOUGH_MEMORY : err;
        }

	//
        // User clicked CANCEL for the pdlg
        //

        if ( ( err != NO_ERROR ) || !fOK )
        {
            *pfCancel = TRUE;
        }

        delete pdlg;
    }

    ::AfpAdminBufferFree( pAfpConnections );

    //
    // If user gave the go ahead to close the volume then go ahead and
    // try to close it.
    //

    if ( err == NO_ERROR && fOK )
    {
        err = ::AfpAdminVolumeDelete( _hServer,
				      (LPWSTR)pvlbi->QueryVolumeName() );
    }

    return err;
}

/*******************************************************************

    NAME:       VIEW_VOLUMES_DIALOG_BASE::IsFocusOnGoodVolume

    SYNOPSIS:   Will check to see if the current selection is a good or
		bad volume.

    ENTRY:

    EXIT:

    RETURNS:	Returns TRUE if current selection is a valid volume.
		FALSE otherwise.

    NOTES:

    HISTORY:
        NarenG        	11/11/92          Modified for AFPMGR

********************************************************************/

BOOL VIEW_VOLUMES_DIALOG_BASE::IsFocusOnGoodVolume( VOID ) const
{

    if( _lbVolumes.QuerySelCount() > 0 )
    {
    	return( _lbVolumes.QueryItem()->IsVolumeValid() );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\messages\dummy.c ===
void
DummyEntryPoint(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\cmdline\cmd.h ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:    cmd.h
//
// Description:
//
// History:
//	Nov 11,1993.	NarenG		Created original version.
//

#define MACFILE_IDS_BASE        1000

//
// Do not change the ID numbers of these strings. AFPERR_*
// map to these string ids via the formula:
// -(AFPERR_*) + MACFILE_IDS_BASE + AFPERR_BASE = IDS_*
//

#define AFPERR_TO_STRINGID( AfpErr )                            \
                                                                \
    ((( AfpErr <= AFPERR_BASE ) && ( AfpErr >= AFPERR_MIN )) ?  \
    (MACFILE_IDS_BASE+AFPERR_BASE-AfpErr) : AfpErr )


#define IDS_AFPERR_InvalidVolumeName            (MACFILE_IDS_BASE+1)
#define IDS_AFPERR_InvalidId                    (MACFILE_IDS_BASE+2)
#define IDS_AFPERR_InvalidParms                 (MACFILE_IDS_BASE+3)
#define IDS_AFPERR_CodePage                     (MACFILE_IDS_BASE+4)
#define IDS_AFPERR_InvalidServerName            (MACFILE_IDS_BASE+5)
#define IDS_AFPERR_DuplicateVolume              (MACFILE_IDS_BASE+6)
#define IDS_AFPERR_VolumeBusy                   (MACFILE_IDS_BASE+7)
#define IDS_AFPERR_VolumeReadOnly               (MACFILE_IDS_BASE+8)
#define IDS_AFPERR_DirectoryNotInVolume         (MACFILE_IDS_BASE+9)
#define IDS_AFPERR_SecurityNotSupported         (MACFILE_IDS_BASE+0)
#define IDS_AFPERR_BufferSize                   (MACFILE_IDS_BASE+10)
#define IDS_AFPERR_DuplicateExtension           (MACFILE_IDS_BASE+12)
#define IDS_AFPERR_UnsupportedFS                (MACFILE_IDS_BASE+13)
#define IDS_AFPERR_InvalidSessionType           (MACFILE_IDS_BASE+14)
#define IDS_AFPERR_InvalidServerState           (MACFILE_IDS_BASE+15)
#define IDS_AFPERR_NestedVolume                 (MACFILE_IDS_BASE+16)
#define IDS_AFPERR_InvalidComputername          (MACFILE_IDS_BASE+17)
#define IDS_AFPERR_DuplicateTypeCreator         (MACFILE_IDS_BASE+18)
#define IDS_AFPERR_TypeCreatorNotExistant       (MACFILE_IDS_BASE+19)
#define IDS_AFPERR_CannotDeleteDefaultTC        (MACFILE_IDS_BASE+20)
#define IDS_AFPERR_CannotEditDefaultTC          (MACFILE_IDS_BASE+21)
#define IDS_AFPERR_InvalidTypeCreator           (MACFILE_IDS_BASE+22)
#define IDS_AFPERR_InvalidExtension             (MACFILE_IDS_BASE+23)
#define IDS_AFPERR_TooManyEtcMaps               (MACFILE_IDS_BASE+24)
#define IDS_AFPERR_InvalidPassword              (MACFILE_IDS_BASE+25)
#define IDS_AFPERR_VolumeNonExist               (MACFILE_IDS_BASE+26)
#define IDS_AFPERR_NoSuchUserGroup              (MACFILE_IDS_BASE+27)
#define IDS_AFPERR_NoSuchUser                   (MACFILE_IDS_BASE+28)
#define IDS_AFPERR_NoSuchGroup                  (MACFILE_IDS_BASE+29)
#define IDS_GENERAL_SYNTAX                      (MACFILE_IDS_BASE+30)
#define IDS_VOLUME_SYNTAX                       (MACFILE_IDS_BASE+31)
#define IDS_DIRECTORY_SYNTAX                    (MACFILE_IDS_BASE+32)
#define IDS_SERVER_SYNTAX                       (MACFILE_IDS_BASE+33)
#define IDS_FORKIZE_SYNTAX                      (MACFILE_IDS_BASE+34)
#define IDS_AMBIGIOUS_SWITCH_ERROR              (MACFILE_IDS_BASE+35)
#define IDS_UNKNOWN_SWITCH_ERROR                (MACFILE_IDS_BASE+36)
#define IDS_DUPLICATE_SWITCH_ERROR              (MACFILE_IDS_BASE+37)
#define IDS_API_ERROR                           (MACFILE_IDS_BASE+38)
#define IDS_SUCCESS                             (MACFILE_IDS_BASE+39)
#define IDS_VOLUME_TOO_BIG                      (MACFILE_IDS_BASE+40)

//  This structure is required by GetSwitchValue. It will store the
//  information of the switches on the command line. This structure is
//  global within this module.

typedef struct cmdfmt {

    CHAR *   cf_parmstr;
    CHAR *   cf_ptr;
    DWORD    cf_usecount;

} CMD_FMT, * PCMD_FMT;


VOID
ParseCmdArgList(
    INT argc,
    CHAR * argv[]
);


BOOL
IsDriveGreaterThan2Gig( LPSTR lpwsDrivePath );

VOID
GetArguments(
    CMD_FMT * pArgFmt,
    CHAR *    argv[],
    DWORD     argc,
    DWORD     ArgCount
);

VOID
GetSwitchValue(
    CMD_FMT * pArgFmt,
    IN CHAR * pchSwitchPtr
);

VOID
PrintMessageAndExit(
    DWORD  ids,
    CHAR * pchInsertString
);

VOID
DoVolumeAdd(
    CHAR * gblServer,
    CHAR * gblName,
    CHAR * gblPath,
    CHAR * gblPassword,
    CHAR * gblReadOnly,
    CHAR * gblGuestsAllowed,
    CHAR * gblMaxUses
);

VOID
DoVolumeDelete(
    CHAR * gblServer,
    CHAR * gblName
);

VOID
DoVolumeSet(
    CHAR * gblServer,
    CHAR * gblName,
    CHAR * gblPassword,
    CHAR * gblReadOnly,
    CHAR * gblGuestsAllowed,
    CHAR * gblMaxUses
);

VOID
DoServerSetInfo(
    CHAR * gblServer,
    CHAR * gblMaxSessions,
    CHAR * gblLoginMessage,
    CHAR * gblGuestsAllowed,
    CHAR * gblUAMRequired,
    CHAR * pchAllowSavedPasswords,
    CHAR * pchMacServerName
);

VOID
DoForkize(
    CHAR * gblServer,
    CHAR * gblType,
    CHAR * gblCreator,
    CHAR * gblDataFork,
    CHAR * gblResourceFork,
    CHAR * gblTargetFile
);

VOID
DoDirectorySetInfo(
    CHAR * gblServer,
    CHAR * gblPath,
    CHAR * gblOwnerName,
    CHAR * gblGroupName,
    CHAR * gblPermissions
);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\cmdline\cmd.c ===
/********************************************************************/
/**               Copyright(c) 1989 Microsoft Corporation.	   **/
/********************************************************************/

//***
//
// Filename:	cmd.c
//
// Description:
//
// History:
//		Oct 1,1993.	NarenG		Created original version.
//

#include <client.h>
#include <stdio.h>
#include <stdlib.h>
#include "cmd.h"

CHAR * pszTRUE  	= "TRUE";
CHAR * pszFALSE 	= "FALSE";
CHAR * pszUnlimited = "UNLIMITED";


VOID
PrintMessageAndExit(
    DWORD  ids,
    CHAR * pchInsertString
)
{
    CHAR    Error[10];
    CHAR    MsgBuf[1000];
    DWORD   cbMessage;
    LPSTR   pszMessage;

    switch( ids )
    {
    case IDS_GENERAL_SYNTAX:
    case IDS_VOLUME_SYNTAX:
    case IDS_DIRECTORY_SYNTAX:
    case IDS_SERVER_SYNTAX:
    case IDS_FORKIZE_SYNTAX:
    case IDS_VOLUME_TOO_BIG:
    case IDS_SUCCESS:

        cbMessage = FormatMessageA(
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_HMODULE,
                                NULL,
                                (DWORD)ids,
                                LANG_NEUTRAL,
                                (LPSTR)&pszMessage,
                                128,
                                NULL );


        break;

    case IDS_AMBIGIOUS_SWITCH_ERROR:
    case IDS_UNKNOWN_SWITCH_ERROR:
    case IDS_DUPLICATE_SWITCH_ERROR:

        cbMessage = FormatMessageA(
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_HMODULE    |
                                FORMAT_MESSAGE_IGNORE_INSERTS,
                                NULL,
                                (DWORD)ids,
                                LANG_NEUTRAL,
                                (LPSTR)&pszMessage,
                                128,
                                NULL );

        if ( cbMessage > 0 )
        {
            sprintf( MsgBuf, pszMessage, pchInsertString );

            CharToOem( MsgBuf, MsgBuf );

            LocalFree( pszMessage );

            fprintf( stdout, MsgBuf );

            fprintf( stdout, "\n" );
        }

        exit( 0 );

        break;

    case IDS_API_ERROR:

        _itoa( (int)((ULONG_PTR)pchInsertString), Error, 10 );

        cbMessage = FormatMessageA(
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_HMODULE    |
                                FORMAT_MESSAGE_IGNORE_INSERTS,
                                NULL,
                                (DWORD)ids,
                                LANG_NEUTRAL,
                                (LPSTR)&pszMessage,
                                128,
                                NULL );

        if ( cbMessage > 0 )
        {
            sprintf( MsgBuf, pszMessage, Error );

            CharToOem( MsgBuf, MsgBuf );

            fprintf( stdout, MsgBuf );

            fprintf( stdout, "\n" );

            LocalFree( pszMessage );
        }

        if ( ((LONG)((LONG_PTR)pchInsertString)) > 0 )
        {
            cbMessage = FormatMessageA(
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                (LONG)((LONG_PTR)pchInsertString),
                                LANG_NEUTRAL,
                                (LPSTR)&pszMessage,
                                128,
                                NULL );
        }

        if ( ((LONG)((LONG_PTR)pchInsertString)) < 0 )
        {
            cbMessage = FormatMessageA(
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_HMODULE,
                                NULL,
                                AFPERR_TO_STRINGID( (LONG)((LONG_PTR)pchInsertString) ),
                                LANG_NEUTRAL,
                                (LPSTR)&pszMessage,
                                128,
                                NULL );

        }

        break;

    default:
        exit( 0 );
    }

    if ( cbMessage > 0 )
    {
        CharToOem( pszMessage, pszMessage );

        fprintf( stdout, pszMessage );

        fprintf( stdout, "\n" );

        LocalFree( pszMessage );
    }

    exit(0);
}

VOID
DoVolumeAdd(
    CHAR * pchServer,
    CHAR * pchName,
    CHAR * pchPath,
    CHAR * pchPassword,
    CHAR * pchReadOnly,
    CHAR * pchGuestsAllowed,
    CHAR * pchMaxUses
)
{
    PAFP_DIRECTORY_INFO pAfpDirInfo;
    AFP_VOLUME_INFO 	AfpVolInfo;
    DWORD	  	dwRetCode;
    AFP_SERVER_HANDLE   hServer;
    WCHAR		wchName[AFP_VOLNAME_LEN+1];
    WCHAR		wchPassword[AFP_VOLPASS_LEN+1];
    WCHAR		wchServer[CNLEN+3];
    LPWSTR		lpwsPath;
    LPSTR		lpDrivePath;
    DWORD       dwParmNum = AFP_DIR_PARMNUM_PERMS;

    ZeroMemory( &AfpVolInfo, sizeof( AfpVolInfo ) );

    //
    // Check to see if the mandatory values are not supplied
    //

    if ( ( pchName == NULL ) || ( pchPath == NULL ) || ( *pchName == (CHAR)NULL)
	 || ( *pchPath == (CHAR)NULL ) )
	PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );
	
    mbstowcs(wchName, pchName, sizeof(wchName));

    AfpVolInfo.afpvol_name = wchName;

    lpwsPath = LocalAlloc(LPTR, (strlen(pchPath) + 1) * sizeof(WCHAR));

    if (lpwsPath == NULL)
	    PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

    lpDrivePath = LocalAlloc(LPTR, (CNLEN + 6 + 1));
    if (lpDrivePath == NULL)
	    PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

    mbstowcs(lpwsPath, pchPath, (strlen(pchPath)+1)*sizeof(WCHAR));

    AfpVolInfo.afpvol_path = lpwsPath;

    if ( pchServer )
    {
	    if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer));
	    else
	        PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    if ( (pchPassword) && ( strlen( pchPassword ) > 0 ) )
    {
        mbstowcs(wchPassword, pchPassword, sizeof(wchPassword));

        AfpVolInfo.afpvol_password = wchPassword;
    }
    else
        AfpVolInfo.afpvol_password = NULL;

    if ( pchMaxUses )
    {
        if ( *pchMaxUses )
        {
	    if (_strnicmp(pchMaxUses, pszUnlimited, strlen(pchMaxUses)) == 0)
    	        AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
	    else if ( strspn(pchMaxUses, "1234567890") != strlen(pchMaxUses) )
	        PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
            else if ( strlen( pchMaxUses ) > strlen( "4294967295" ) )
    	        AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
            else if ( ( strlen( pchMaxUses ) == strlen( "4294967295" ) ) &&
                      ( _stricmp( pchMaxUses, "4294967295" ) > 0 ) )
    	        AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
	    else
    	        AfpVolInfo.afpvol_max_uses  = atoi(pchMaxUses);

            if ( AfpVolInfo.afpvol_max_uses == 0 )
                PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
        }
        else
            PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }
    else
    	AfpVolInfo.afpvol_max_uses = AFP_VOLUME_UNLIMITED_USES;

    AfpVolInfo.afpvol_props_mask = 0;

    if (pchReadOnly != NULL)
    {
        if ( *pchReadOnly )
        {
            if (_strnicmp(pchReadOnly, pszTRUE, strlen(pchReadOnly) ) == 0)
                AfpVolInfo.afpvol_props_mask |= AFP_VOLUME_READONLY;
	    else if (_strnicmp(pchReadOnly, pszFALSE, strlen(pchReadOnly))!=0)
	        PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
        }
        else
	    PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    if (pchGuestsAllowed != NULL)
    {
        if ( *pchGuestsAllowed )
        {
            if (_strnicmp(pchGuestsAllowed,pszTRUE,strlen(pchGuestsAllowed))==0)
                AfpVolInfo.afpvol_props_mask |= AFP_VOLUME_GUESTACCESS;
	    else if(_strnicmp(pchGuestsAllowed,
                             pszFALSE,strlen(pchGuestsAllowed))!=0)
	        PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
        }
        else
            PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }
    else
    	AfpVolInfo.afpvol_props_mask |= AFP_VOLUME_GUESTACCESS;


    //
    // Connect with the server
    //

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    //
    // First get and set directory information.
    //


    dwRetCode = AfpAdminDirectoryGetInfo(hServer,
					    lpwsPath,
					    (LPBYTE*)&pAfpDirInfo);

    if (dwRetCode == NO_ERROR)
    {
        pAfpDirInfo->afpdir_path = lpwsPath;

        if ( pAfpDirInfo->afpdir_owner != (LPWSTR)NULL )
        {
            dwParmNum |= AFP_DIR_PARMNUM_OWNER;
        }

        if ( pAfpDirInfo->afpdir_group != (LPWSTR)NULL )
        {
            dwParmNum |= AFP_DIR_PARMNUM_GROUP;
        }

        dwRetCode = AfpAdminVolumeAdd(hServer, (LPBYTE)&AfpVolInfo);
		
		// Directory permissions need not be changed here

#if 0
        if (dwRetCode == NO_ERROR)
        {
		    dwRetCode = AfpAdminDirectorySetInfo(hServer,
                                          	  (LPBYTE)pAfpDirInfo,
                                              dwParmNum);
        }
#endif

	    if (dwRetCode != NO_ERROR)
	    {
		    printf ("AfpAdminVolumeAdd failed with error %ld\n", 
			    dwRetCode);
	    }	

        AfpAdminBufferFree(pAfpDirInfo);
    }

    // we will get this if it's a CDROM.  UI ignores this error: why not macfile?
    else if (dwRetCode == AFPERR_SecurityNotSupported)
    {
        dwRetCode = AfpAdminVolumeAdd(hServer, (LPBYTE)&AfpVolInfo);
    }

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect(hServer);

    LocalFree(lpwsPath);

    if (pchServer)
    {
        DWORD   dwLen;

        // using the server name, form a path like \\foobar\d$\
        // (the +2 for the leading \\)
        for (dwLen=0; dwLen < CNLEN+2; dwLen++ )
        {
            lpDrivePath[dwLen] = pchServer[dwLen];
            if (pchServer[dwLen] == 0)
            {
                break;
            }
        }
        lpDrivePath[CNLEN] = 0;          // just to be sure
        strcat(lpDrivePath,"\\");
        dwLen = strlen(lpDrivePath);
        lpDrivePath[dwLen] = pchPath[0];
        lpDrivePath[dwLen+1] = 0;
        strcat(lpDrivePath,"$\\");
    }
    else
    {
        strncpy(lpDrivePath, pchPath, 3);
        lpDrivePath[2] = '\\';
        lpDrivePath[3] = 0;
    }

    if (IsDriveGreaterThan2Gig(lpDrivePath))
    {
        LocalFree(lpDrivePath);
        PrintMessageAndExit(IDS_VOLUME_TOO_BIG, NULL);
    }

    LocalFree(lpDrivePath);

    if (dwRetCode != NO_ERROR)
        PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));
    else
        PrintMessageAndExit(IDS_SUCCESS, NULL);
	
}

VOID
DoVolumeDelete(
    CHAR * pchServer,
    CHAR * pchName
)
{
    WCHAR 		 wchName[AFP_VOLNAME_LEN+1];
    DWORD 		 dwRetCode;
    AFP_SERVER_HANDLE    hServer;
    WCHAR		 wchServer[CNLEN+3];
    PAFP_VOLUME_INFO     pAfpVolumeInfo;
    PAFP_CONNECTION_INFO pAfpConnections;
    PAFP_CONNECTION_INFO pAfpConnInfoIter;
    DWORD                cEntriesRead;
    DWORD                cTotalAvail;
    DWORD                dwIndex;

    if ( ( pchName == NULL ) || ( *pchName == (CHAR)NULL ) )
	PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

    mbstowcs(wchName, pchName, sizeof(wchName));

    if (pchServer)
    {
        if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer));
	    else
	        PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));


    dwRetCode = AfpAdminVolumeGetInfo(  hServer,
                                        (LPWSTR)wchName,
                                        (LPBYTE*)&pAfpVolumeInfo );

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    //
    // Check if there are any users connected to the volume
    // by enumerating the connections to this volume.
    //

    dwRetCode = AfpAdminConnectionEnum( hServer,
                                        (LPBYTE*)&pAfpConnections,
                                        AFP_FILTER_ON_VOLUME_ID,
                                        pAfpVolumeInfo->afpvol_id,
                                        (DWORD)-1,    // Get all conenctions
                                        &cEntriesRead,
                                        &cTotalAvail,
                                        NULL );

    AfpAdminBufferFree( pAfpVolumeInfo );

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    for ( dwIndex = 0, pAfpConnInfoIter = pAfpConnections;
          dwIndex < cEntriesRead;
          dwIndex++, pAfpConnInfoIter++ )
    {
        dwRetCode = AfpAdminConnectionClose( hServer,
                                             pAfpConnInfoIter->afpconn_id );

        if ( dwRetCode != NO_ERROR )
	    PrintMessageAndExit( IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode) );
    }

    AfpAdminBufferFree( pAfpConnections );

    dwRetCode = AfpAdminVolumeDelete( hServer, wchName );

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect( hServer );

    PrintMessageAndExit(IDS_SUCCESS, NULL);
}

VOID
DoVolumeSet(
    CHAR * pchServer,
    CHAR * pchName,
    CHAR * pchPassword,
    CHAR * pchReadOnly,
    CHAR * pchGuestsAllowed,
    CHAR * pchMaxUses
)
{
    DWORD		dwParmNum = 0;
    AFP_VOLUME_INFO 	AfpVolInfo;
    DWORD	  	dwRetCode;
    AFP_SERVER_HANDLE   hServer;
    WCHAR		wchName[AFP_VOLNAME_LEN+1];
    WCHAR		wchPassword[AFP_VOLPASS_LEN+1];
    WCHAR		wchServer[CNLEN+3];

    //
    // Check to see if the mandatory values are not supplied
    //

    if ( ( pchName == NULL ) || ( *pchName == (CHAR)NULL ) )
	PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );
	
    mbstowcs(wchName, pchName, sizeof(wchName));

    AfpVolInfo.afpvol_name = wchName;

    if (pchServer)
    {
	if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer));
	else
	    PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    if (pchPassword)
    {
        dwParmNum |= AFP_VOL_PARMNUM_PASSWORD;

	if (*pchPassword)
	{
	    mbstowcs(wchPassword, pchPassword, sizeof(wchPassword));
            AfpVolInfo.afpvol_password = wchPassword;
	}
	else
            AfpVolInfo.afpvol_password = NULL;
    }

    if (pchMaxUses)
    {
	if (*pchMaxUses)
        {
            dwParmNum |= AFP_VOL_PARMNUM_MAXUSES;

	    if (_strnicmp(pchMaxUses, pszUnlimited, strlen(pchMaxUses))== 0)
    	    	AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
	    else if ( strspn(pchMaxUses, "1234567890") != strlen(pchMaxUses) )
	    	PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
            else if ( strlen( pchMaxUses ) > strlen( "4294967295" ) )
    	    	AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
            else if ( ( strlen( pchMaxUses ) == strlen( "4294967295" ) ) &&
                      ( _stricmp( pchMaxUses, "4294967295" ) > 0 ) )
    	    	AfpVolInfo.afpvol_max_uses  = AFP_VOLUME_UNLIMITED_USES;
	    else
    	    	AfpVolInfo.afpvol_max_uses = atoi(pchMaxUses);

            if ( AfpVolInfo.afpvol_max_uses == 0 )
                PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }
    else
    	AfpVolInfo.afpvol_max_uses  = 0;

    AfpVolInfo.afpvol_props_mask = 0;

    if (pchReadOnly)
    {
	if (*pchReadOnly)
	{
            dwParmNum |= AFP_VOL_PARMNUM_PROPSMASK;

	    if (_strnicmp(pchReadOnly, pszTRUE, strlen(pchReadOnly) ) == 0)
    		AfpVolInfo.afpvol_props_mask |= AFP_VOLUME_READONLY;
	    else if (_strnicmp(pchReadOnly, pszFALSE, strlen(pchReadOnly))!=0)
	    	PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    if (pchGuestsAllowed)
    {
	if (*pchGuestsAllowed)
	{
            dwParmNum |= AFP_VOL_PARMNUM_PROPSMASK;

	    if (_strnicmp(pchGuestsAllowed, pszTRUE,
                                                strlen(pchGuestsAllowed))==0)
    		AfpVolInfo.afpvol_props_mask |= AFP_VOLUME_GUESTACCESS;
	    else if (_strnicmp(pchGuestsAllowed,
                        pszFALSE,strlen(pchGuestsAllowed)) != 0)
	    	PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_VOLUME_SYNTAX, NULL);
    }

    if (dwParmNum == 0)
	PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

    //
    // Connect with the server
    //

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    dwRetCode = AfpAdminVolumeSetInfo( hServer,
					(LPBYTE)&AfpVolInfo,
					dwParmNum);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect(hServer);
	
    PrintMessageAndExit(IDS_SUCCESS, NULL);
}

VOID
DoServerSetInfo(
    CHAR * pchServer,
    CHAR * pchMaxSessions,
    CHAR * pchLoginMessage,
    CHAR * pchGuestsAllowed,
    CHAR * pchUAMRequired,
    CHAR * pchAllowSavedPasswords,
    CHAR * pchMacServerName
)
{
    DWORD	  	dwRetCode;
    AFP_SERVER_HANDLE   hServer;
    WCHAR		wchServer[CNLEN+3];
    DWORD		dwParmNum = 0;
    AFP_SERVER_INFO	AfpServerInfo;
    WCHAR		wchLoginMsg[AFP_MESSAGE_LEN+1];
    WCHAR		wchMacServerName[AFP_SERVERNAME_LEN+1];

    if (pchMaxSessions)
    {
	if (*pchMaxSessions)
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_MAX_SESSIONS;

	    if (_strnicmp(pchMaxSessions,
			   pszUnlimited,
			   strlen(pchMaxSessions)) == 0)
		AfpServerInfo.afpsrv_max_sessions = AFP_MAXSESSIONS;
	    else if (strspn(pchMaxSessions, "1234567890")
						!= strlen(pchMaxSessions))
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	    else
		AfpServerInfo.afpsrv_max_sessions = atoi(pchMaxSessions);
	}
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }

    if (pchLoginMessage)
    {
 	if (*pchLoginMessage)
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_LOGINMSG;

	    if (strlen(pchLoginMessage) > AFP_MESSAGE_LEN)
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	    else
	    {
		mbstowcs(wchLoginMsg, pchLoginMessage, sizeof(wchLoginMsg));
		AfpServerInfo.afpsrv_login_msg = wchLoginMsg;
	    }
	}
	else
        {
	    dwParmNum |= AFP_SERVER_PARMNUM_LOGINMSG;
	    AfpServerInfo.afpsrv_login_msg = NULL;
        }
    }

    AfpServerInfo.afpsrv_options = 0;

#if 0
    if (pchGuestsAllowed)
    {
	if (*pchGuestsAllowed)
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_OPTIONS;

	    if (_strnicmp(pchGuestsAllowed,
			   pszTRUE,
			   strlen(pchGuestsAllowed)) == 0)
    		AfpServerInfo.afpsrv_options |= AFP_SRVROPT_GUESTLOGONALLOWED;
	    else if (_strnicmp(pchGuestsAllowed,
				pszFALSE,
			        strlen(pchGuestsAllowed)) != 0)
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }
    else
    	AfpServerInfo.afpsrv_options |= AFP_SRVROPT_GUESTLOGONALLOWED;
#endif


    if (pchUAMRequired)
    {
	if (*pchUAMRequired)	
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_OPTIONS;

	    if (_strnicmp(pchUAMRequired,
			   pszFALSE,
			   strlen(pchGuestsAllowed)) == 0)
    		AfpServerInfo.afpsrv_options|=AFP_SRVROPT_CLEARTEXTLOGONALLOWED;
	    else if (_strnicmp(pchUAMRequired,
				pszTRUE,
			        strlen(pchUAMRequired)) != 0)
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }

    if (pchAllowSavedPasswords)
    {
	if (*pchAllowSavedPasswords)	
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_OPTIONS;

	    if (_strnicmp(pchAllowSavedPasswords,
			   pszTRUE,
			   strlen(pchAllowSavedPasswords)) == 0)
    		AfpServerInfo.afpsrv_options|=AFP_SRVROPT_ALLOWSAVEDPASSWORD;
	    else if (_strnicmp(pchAllowSavedPasswords,
				pszFALSE,
			        strlen(pchAllowSavedPasswords)) != 0)
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	}
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }

    if (pchMacServerName)
    {
	if (*pchMacServerName)
	{
	    dwParmNum |= AFP_SERVER_PARMNUM_NAME;

	    if (strlen(pchMacServerName) > AFP_SERVERNAME_LEN)
	    	PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
	    else
	    {
		mbstowcs(wchMacServerName,
			  pchMacServerName,
			  sizeof(wchMacServerName));
	
		AfpServerInfo.afpsrv_name = wchMacServerName;
	    }
	}
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }

    if (dwParmNum == 0)
        PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);

    if (pchServer)
    {
	if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer));
	else
	    PrintMessageAndExit(IDS_SERVER_SYNTAX, NULL);
    }

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    dwRetCode = AfpAdminServerSetInfo( hServer,
				        (LPBYTE)&AfpServerInfo,
					dwParmNum);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect(hServer);

    PrintMessageAndExit(IDS_SUCCESS, NULL);
}

VOID
DoDirectorySetInfo(
    CHAR * pchServer,
    CHAR * pchPath,
    CHAR * pchOwnerName,
    CHAR * pchGroupName,
    CHAR * pchPermissions
)
{
    DWORD	  	dwRetCode;
    AFP_SERVER_HANDLE   hServer;
    WCHAR		wchServer[CNLEN+3];
    LPWSTR		lpwsPath;
    WCHAR		wchOwner[UNLEN+1];
    WCHAR		wchGroup[GNLEN+1];
    DWORD               dwPerms;

    AFP_DIRECTORY_INFO  AfpDirInfo;
    DWORD               dwParmNum = 0;

    if ( ( pchPath == NULL ) || ( *pchPath == (CHAR)NULL ) )
	PrintMessageAndExit( IDS_DIRECTORY_SYNTAX, NULL );

    lpwsPath = LocalAlloc(LPTR, (strlen(pchPath) + 1) * sizeof(WCHAR));

    if (lpwsPath == NULL)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

    mbstowcs(lpwsPath, pchPath, (strlen(pchPath)+1)*sizeof(WCHAR));
    AfpDirInfo.afpdir_path  = lpwsPath;

    if (pchServer)
    {
	if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer));
	else
	    PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);
    }

    if (pchOwnerName)
    {
	if (*pchOwnerName)
	{
	    if (strlen(pchOwnerName) > UNLEN)
	    	PrintMessageAndExit(IDS_GENERAL_SYNTAX, NULL);

	    mbstowcs(wchOwner, pchOwnerName, sizeof(wchOwner));
            AfpDirInfo.afpdir_owner = wchOwner;
            dwParmNum |= AFP_DIR_PARMNUM_OWNER;

	}
	else
	    PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);
    }

    if (pchGroupName)
    {
	if (*pchGroupName)
	{
	    mbstowcs(wchGroup, pchGroupName, sizeof(wchGroup));
            AfpDirInfo.afpdir_group = wchGroup;
            dwParmNum |= AFP_DIR_PARMNUM_GROUP;
   	}
	else
	    PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);
    }

    if (pchPermissions)
    {
	if (*pchPermissions)
	{
	    if (strspn(pchPermissions, "10") != strlen(pchPermissions))
	    	PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);

	    if (strlen(pchPermissions) != 11)
	    	PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);

            dwPerms = 0;

	    if (pchPermissions[0] == '1')
    		dwPerms |= AFP_PERM_OWNER_SFI;
	    if (pchPermissions[1] == '1')
    		dwPerms |= AFP_PERM_OWNER_SFO;
	    if (pchPermissions[2] == '1')
    		dwPerms |= AFP_PERM_OWNER_MC;
	    if (pchPermissions[3] == '1')
    		dwPerms |= AFP_PERM_GROUP_SFI;
	    if (pchPermissions[4] == '1')
    		dwPerms |= AFP_PERM_GROUP_SFO;
	    if (pchPermissions[5] == '1')
    		dwPerms |= AFP_PERM_GROUP_MC;
	    if (pchPermissions[6] == '1')
    		dwPerms |= AFP_PERM_WORLD_SFI;
	    if (pchPermissions[7] == '1')
    		dwPerms |= AFP_PERM_WORLD_SFO;
	    if (pchPermissions[8] == '1')
    		dwPerms |= AFP_PERM_WORLD_MC;
	    if (pchPermissions[9] == '1')
    		dwPerms |= AFP_PERM_INHIBIT_MOVE_DELETE;
	    if (pchPermissions[10] == '1')
    		dwPerms |= AFP_PERM_SET_SUBDIRS;

            AfpDirInfo.afpdir_perms = dwPerms;
            dwParmNum |= AFP_DIR_PARMNUM_PERMS;
	}
	else
	    PrintMessageAndExit(IDS_DIRECTORY_SYNTAX, NULL);
    }

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    dwRetCode = AfpAdminDirectorySetInfo(hServer,
                                      	  (LPBYTE)&AfpDirInfo,
                                          dwParmNum);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect(hServer);

    LocalFree(lpwsPath);

    PrintMessageAndExit(IDS_SUCCESS, NULL);
}

VOID
DoForkize(
    CHAR * pchServer,
    CHAR * pchType,
    CHAR * pchCreator,
    CHAR * pchDataFork,
    CHAR * pchResourceFork,
    CHAR * pchTargetFile
)
{
    DWORD	  	dwRetCode;
    AFP_SERVER_HANDLE   hServer;
    WCHAR		wchServer[CNLEN+3];
    LPWSTR		lpwsTarget;
    LPWSTR		lpwsResource;
    LPWSTR		lpwsData;
    WCHAR		wchType[AFP_TYPE_LEN+1];
    WCHAR		wchCreator[AFP_CREATOR_LEN+1];
    DWORD		dwParmNum = 0;

    if ( ( pchTargetFile == NULL ) || ( *pchTargetFile == (CHAR)NULL ) )
	PrintMessageAndExit( IDS_FORKIZE_SYNTAX, NULL );

    lpwsTarget = LocalAlloc(LPTR, (strlen(pchTargetFile) + 1) * sizeof(WCHAR));

    if (lpwsTarget == NULL)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

    mbstowcs(lpwsTarget,pchTargetFile,(strlen(pchTargetFile)+1)*sizeof(WCHAR));

    if (pchServer)
    {
	if (*pchServer)
    	    mbstowcs(wchServer, pchServer, sizeof(wchServer));
	else
	    PrintMessageAndExit(IDS_FORKIZE_SYNTAX, NULL);
    }

    if (pchType != NULL)
    {
	if ( ( *pchType == (CHAR)NULL ) || ( strlen( pchType ) > AFP_TYPE_LEN ))
	    PrintMessageAndExit(IDS_API_ERROR,(LPSTR)AFPERR_InvalidTypeCreator);
	else
    	    mbstowcs(wchType, pchType, sizeof(wchType));

    	dwParmNum |= AFP_FD_PARMNUM_TYPE;
    }

    if (pchCreator != NULL)
    {
	if ((*pchCreator == (CHAR)NULL) || (strlen(pchCreator)>AFP_CREATOR_LEN))
	    PrintMessageAndExit(IDS_API_ERROR,(LPSTR)AFPERR_InvalidTypeCreator);
	else
    	    mbstowcs(wchCreator, pchCreator, sizeof(wchCreator));

    	dwParmNum |= AFP_FD_PARMNUM_CREATOR;
    }

    if (pchResourceFork != NULL)
    {
	if ( *pchResourceFork == (CHAR)NULL )
	    PrintMessageAndExit( IDS_FORKIZE_SYNTAX, NULL );

    	lpwsResource=LocalAlloc(LPTR,(strlen(pchResourceFork)+1)*sizeof(WCHAR));

    	if (lpwsResource == NULL)
	    PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

        mbstowcs(lpwsResource,pchResourceFork,
		 (strlen(pchResourceFork)+1)*sizeof(WCHAR));
    }
    else
	lpwsResource = NULL;

    if (pchDataFork != NULL)
    {
	if ( *pchDataFork == (CHAR)NULL )
	    PrintMessageAndExit( IDS_FORKIZE_SYNTAX, NULL );

    	lpwsData = LocalAlloc(LPTR,(strlen(pchDataFork)+1)*sizeof(WCHAR));

    	if (lpwsData == NULL)
	    PrintMessageAndExit(IDS_API_ERROR, (CHAR*)ERROR_NOT_ENOUGH_MEMORY);

        mbstowcs(lpwsData,pchDataFork,
		 (strlen(pchDataFork)+1)*sizeof(WCHAR));
    }
    else
    	lpwsData = NULL;

    if ((pchType == NULL) && (pchCreator == NULL) &&
	 (pchResourceFork == NULL) && (pchDataFork == NULL))
	PrintMessageAndExit(IDS_FORKIZE_SYNTAX, NULL);

    dwRetCode = AfpAdminConnect(pchServer ? wchServer : NULL, &hServer);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    dwRetCode = AfpAdminFinderSetInfo(	hServer,
    				       	wchType,
    				       	wchCreator,
    				       	lpwsData,
    				     	lpwsResource,
    					lpwsTarget,
					dwParmNum);

    if (dwRetCode != NO_ERROR)
	PrintMessageAndExit(IDS_API_ERROR, (CHAR *)((ULONG_PTR)dwRetCode));

    AfpAdminDisconnect(hServer);

    PrintMessageAndExit(IDS_SUCCESS, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\afpmgr\volprop.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		Copyright(c) Microsoft Corp., 1991  		     **/
/**********************************************************************/

/*
   volprop.cxx
     This file contains the definitions of VOLUME_PROPERTIES_DIALOG
     class.

   History:
     NarenG		11/18/92	Modified SHARE_DIALOG_BASE for
					AFPMGR
*/

#define INCL_WINDOWS_GDI
#define INCL_WINDOWS
#define INCL_DOSERRORS
#define INCL_NETERRORS
#define INCL_NETSHARE
#define INCL_NETSERVER
#define INCL_NETCONS
#define INCL_NETLIB
#include <lmui.hxx>

#define INCL_BLT_WINDOW
#define INCL_BLT_DIALOG
#define INCL_BLT_CONTROL
#define INCL_BLT_MISC
#define INCL_BLT_CLIENT
#define INCL_BLT_MSGPOPUP
#define INCL_BLT_SPIN_GROUP
#define INCL_BLT_GROUP
#include <blt.hxx>

extern "C"
{
#include <afpmgr.h>
#include <macfile.h>
}

#include <string.hxx>
#include <uitrace.hxx>
#include <dbgstr.hxx>
#include <netname.hxx>

#include "util.hxx"
#include "perms.hxx"
#include "volprop.hxx"

/*******************************************************************

    NAME:	VOLUME_PROPERTIES_DIALOG::VOLUME_PROPERTIES_DIALOG

    SYNOPSIS:   Constructor for VOLUME_PROPERTIES_DIALOG class

    ENTRY:      hwndParent     - handle of parent window

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

VOLUME_PROPERTIES_DIALOG::VOLUME_PROPERTIES_DIALOG(
					HWND 	          hwndParent,
				      	AFP_SERVER_HANDLE hServer,
				      	const TCHAR *  	  pszVolumeName,
				      	const TCHAR *  	  pszServerName,
					BOOL		  fCalledBySrvMgr )
    : DIALOG_WINDOW ( MAKEINTRESOURCE(IDD_VOLUME_PROPERTIES_DIALOG),hwndParent),
      _sltpVolumeName( this, IDVP_SLT_NAME, ELLIPSIS_RIGHT ),
      _sltpVolumePath( this, IDVP_SLT_PATH, ELLIPSIS_PATH ),
      _slePassword( this, IDVP_SLE_PASSWORD, AFP_VOLPASS_LEN ),
      _slePasswordConfirm( this, IDVP_SLE_CONFIRM_PASSWORD, AFP_VOLPASS_LEN ),
      _chkReadOnly( this, IDVP_CHK_READONLY ),
      _chkGuestAccess( this, IDVP_CHK_GUEST_ACCESS ),
      _mgrpUserLimit( this, IDVP_RB_UNLIMITED, 2, IDVP_RB_UNLIMITED),
      _spsleUsers( this, IDVP_SLE_USERS,1,1,AFP_VOLUME_UNLIMITED_USES-1,
                   TRUE, IDVP_SLE_USERS_GROUP ),
      _spgrpUsers(this,IDVP_SB_USERS_GROUP,IDVP_SB_USERS_UP,IDVP_SB_USERS_DOWN),
      _pbPermissions( this, IDVP_PB_PERMISSIONS ),
      _pbOK( this, IDOK ),
      _pbCancel( this, IDCANCEL ),
      _nlsVolumePath(),
      _nlsVolumeName( pszVolumeName ),
      _nlsServerName( pszServerName ),
      _fCalledBySrvMgr( fCalledBySrvMgr ),
      _hServer( hServer )
{

    //
    // Make sure everything constructed OK
    //

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _sltpVolumeName.QueryError()) != NERR_Success )
       || ((err = _sltpVolumePath.QueryError()) != NERR_Success )
       || ((err = _nlsVolumePath.QueryError()) != NERR_Success )
       || ((err = _nlsVolumeName.QueryError()) != NERR_Success )
       || ((err = _nlsServerName.QueryError()) != NERR_Success )
       || ((err = _slePassword.QueryError()) != NERR_Success )
       || ((err = _slePasswordConfirm.QueryError()) != NERR_Success )
       || ((err = _mgrpUserLimit.QueryError()) != NERR_Success )
       || ((err = _spgrpUsers.AddAssociation( &_spsleUsers )) != NERR_Success )
       || ((err = _mgrpUserLimit.AddAssociation( IDVP_RB_USERS, &_spgrpUsers ))
	          != NERR_Success )
       || ((err = _chkReadOnly.QueryError()) != NERR_Success )
       || ((err = _chkGuestAccess.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    // 
    // This may take a while
    //

    AUTO_CURSOR Cursor;

    if ( fCalledBySrvMgr )
    {
    	//
    	//  Set the caption to "Volume Properties on Server".
    	//

    	err = ::SetCaption(this, IDS_CAPTION_VOLUME_PROPERTIES, pszServerName);

    	if( err != NERR_Success )
    	{
            ReportError( err );
            return;
	}
    }

    //
    // Get the volume information
    //

    PAFP_VOLUME_INFO pAfpVolumeInfo;

    DWORD error = ::AfpAdminVolumeGetInfo( _hServer,
					   (LPWSTR)pszVolumeName,
					   (LPBYTE*)&pAfpVolumeInfo );
				

    if ( error != NO_ERROR )
    {
        ReportError( error );
        return;
    }
	
    //
    // Set the name
    //

    _sltpVolumeName.SetText( pszVolumeName );

    //
    // Set the path
    //

    if ((( err = _sltpVolumePath.SetText(pAfpVolumeInfo->afpvol_path))
						!= NERR_Success ) ||
    	(( err = _nlsVolumePath.CopyFrom( pAfpVolumeInfo->afpvol_path ) )
						!= NERR_Success ))
    {
        ReportError( err );
        return;
    }

    //
    // Set the password SLE to AFP_NULL_PASSWORD if there is a password
    //

    if ( ( pAfpVolumeInfo->afpvol_password != NULL ) &&
         ( (pAfpVolumeInfo->afpvol_password)[0] != TEXT('\0') ))
    {
    	_slePassword.SetText( (LPWSTR)AFP_NULL_PASSWORD );

    	_slePasswordConfirm.SetText( (LPWSTR)AFP_NULL_PASSWORD );

    	_slePassword.SelectString();
    }


    //
    // Set the security options
    //

    _chkReadOnly.SetCheck( (INT)( pAfpVolumeInfo->afpvol_props_mask &
			          AFP_VOLUME_READONLY ));

    //
    // If this is a CDFS volume, then disable this checkbox
    // The way we find out if this is CDFS partition is by calling
    // AfpAdminDirectoryGetInfo. If it returns AFPERR_SecurityNotSupported
    // then we know that is is CDFS and is readonly
    //

    PAFP_DIRECTORY_INFO pDirInfo;
    err = AfpAdminDirectoryGetInfo( _hServer,
				    pAfpVolumeInfo->afpvol_path,
				    (LPBYTE*)&pDirInfo );

    if ( err == AFPERR_SecurityNotSupported || err == AFPERR_UnsupportedFS )
    {
	_chkReadOnly.Enable( FALSE );
    }
    else if ( err != NO_ERROR )
    {
        ReportError( err );
        return;
    }
    else
    {
	::AfpAdminBufferFree( pDirInfo );
    }

    _chkGuestAccess.SetCheck( (INT)( pAfpVolumeInfo->afpvol_props_mask &
			             AFP_VOLUME_GUESTACCESS ));

    //
    // Set the max uses limit
    //

    SetUserLimit( pAfpVolumeInfo->afpvol_max_uses ) ;

    //
    // Free the returned buffer
    //

    ::AfpAdminBufferFree( pAfpVolumeInfo );

    _slePassword.ClaimFocus();

    _fPasswordChanged = FALSE;

}


/*******************************************************************

    NAME:       VOLUME_PROPERTIES_DIALOG::OnCommand

    SYNOPSIS:   Handle the case where the user clicked the permission button

    ENTRY:      event - the CONTROL_EVENT that occurred

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

BOOL VOLUME_PROPERTIES_DIALOG::OnCommand( const CONTROL_EVENT &event )
{

    DWORD err;


    if ( event.QueryCid() == IDVP_PB_PERMISSIONS )
    {
    	// 
    	// This may take a while
    	//

    	AUTO_CURSOR Cursor;

    	//
    	//  Get the password if there is one.
    	//

    	DIRECTORY_PERMISSIONS_DLG *pdlg = new DIRECTORY_PERMISSIONS_DLG(
						QueryHwnd(),
						_hServer,
						_nlsServerName.QueryPch(),
						_fCalledBySrvMgr,
						_nlsVolumePath.QueryPch(),
						_nlsVolumePath.QueryPch() );

        if (( pdlg == NULL )
            || (( err = pdlg->QueryError()) != NERR_Success )
            || (( err = pdlg->Process()) != NERR_Success ))
        {
            err = err ? err: ERROR_NOT_ENOUGH_MEMORY;
        }

        delete pdlg;

    	if ( err != NERR_Success )
	{
            ::MsgPopup( this, AFPERR_TO_STRINGID( err ) );
	}

        return TRUE;
    }

    if ( ( event.QueryCid() == IDVP_SLE_PASSWORD ) ||
         ( event.QueryCid() == IDVP_SLE_CONFIRM_PASSWORD ) )
    {
	if ( event.QueryCode() == EN_CHANGE )
	{
	    _fPasswordChanged = TRUE;
	}
    }

    return DIALOG_WINDOW::OnCommand( event );

}

/*******************************************************************

    NAME:	VOLUME_PROPERTIES_DIALOG::OnOK	

    SYNOPSIS:   Validate all the information and create the volume.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

BOOL VOLUME_PROPERTIES_DIALOG::OnOK( VOID )
{
    APIERR err;

    // 
    // This may take a while
    //

    AUTO_CURSOR Cursor;

    DWORD   dwParmNum = AFP_VOL_PARMNUM_MAXUSES | AFP_VOL_PARMNUM_PROPSMASK;
    NLS_STR nlsPassword;
    NLS_STR nlsPasswordConfirm;

    //
    // This is not a loop.
    //

    do {

    	//
    	//  Get the password if there is one.
    	//

    	if ( ( err = nlsPassword.QueryError() ) != NERR_Success )
	    break;

    	if ( ( err = _slePassword.QueryText( &nlsPassword )) != NERR_Success )
	    break;

    	//
    	//  Get the password confirmation.
    	//

    	if ( ( err = nlsPasswordConfirm.QueryError() ) != NERR_Success )
	    break;

    	if ( ( err = _slePasswordConfirm.QueryText( &nlsPasswordConfirm ))
							     != NERR_Success )
	    break;


    } while ( FALSE );


    if ( err != NERR_Success )
    {
        ::MsgPopup( this,  err );

    	return TRUE;
    }

    //
    // Set up the volume structure
    //

    AFP_VOLUME_INFO AfpVolume;

    AfpVolume.afpvol_name = (LPWSTR)(_nlsVolumeName.QueryPch());


    //
    // Validate the password that was typed in
    //

    if ( nlsPassword.strcmp( nlsPasswordConfirm ) )
    {
    	::MsgPopup( this, IDS_PASSWORD_MISMATCH  );

	SetFocusOnPasswordConfirm();

    	return TRUE;
    }

    //
    // If the user changed the password then set it to the new one.
    //

    AfpVolume.afpvol_password = (LPWSTR)NULL;

    if ( _fPasswordChanged )
    {
        dwParmNum |= AFP_VOL_PARMNUM_PASSWORD;

    	AfpVolume.afpvol_password = (LPWSTR)(nlsPassword.QueryPch());
    }


    //
    // Set the properties
    //
    AfpVolume.afpvol_props_mask = _chkReadOnly.QueryCheck()
				  ? AFP_VOLUME_READONLY
				  : 0;

    AfpVolume.afpvol_props_mask |= _chkGuestAccess.QueryCheck()
				  ? AFP_VOLUME_GUESTACCESS
				  : 0;

    AfpVolume.afpvol_max_uses = QueryUserLimit();

    //
    //  Try to set the information
    //

    DWORD  error = ::AfpAdminVolumeSetInfo( _hServer,
					    (LPBYTE)&AfpVolume,
					    dwParmNum );

    if ( error == NO_ERROR )
    {
    	Dismiss( TRUE );
    }
    else
    {
        ::MsgPopup( this, AFPERR_TO_STRINGID( error ) );
    }

    return TRUE;
}


/*******************************************************************

    NAME:	VOLUME_PROPERTIES_DIALOG::QueryUserLimit

    SYNOPSIS:   Get the user limit from the magic group

    ENTRY:

    EXIT:

    RETURNS:    The user limit stored in the user limit magic group

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

DWORD VOLUME_PROPERTIES_DIALOG::QueryUserLimit( VOID ) const
{

    switch ( _mgrpUserLimit.QuerySelection() )
    {

    case IDVP_RB_UNLIMITED:

    	return( AFP_VOLUME_UNLIMITED_USES );

    case IDVP_RB_USERS:

        return( _spsleUsers.QueryValue() );

    default:

	//	
	// Should never get here but in case we do, return unlimited
	//

        return( AFP_VOLUME_UNLIMITED_USES );
    }

}

/*******************************************************************

    NAME:	VOLUME_PROPERTIES_DIALOG::SetUserLimit	

    SYNOPSIS:   Sets the user limit on the magic group

    ENTRY:      dwUserLimit - maximum number of users allowed

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

VOID VOLUME_PROPERTIES_DIALOG::SetUserLimit( DWORD dwUserLimit )
{

     if ( dwUserLimit == AFP_VOLUME_UNLIMITED_USES )
     {
         //
         // Set selection to the  Unlimited button
         //

         _mgrpUserLimit.SetSelection( IDVP_RB_UNLIMITED );

     }
     else
     {
	//
        // Set the Users button to the value
	//
	
        _mgrpUserLimit.SetSelection( IDVP_RB_USERS );

        _spsleUsers.SetValue( dwUserLimit );

        _spsleUsers.Update();

     }

}

/*******************************************************************

    NAME:	VOLUME_PROPERTIES_DIALOG::QueryHelpContext	

    SYNOPSIS:   Query the help context of the dialog

    ENTRY:

    EXIT:

    RETURNS:    Return the help context of the dialog

    NOTES:

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

ULONG VOLUME_PROPERTIES_DIALOG::QueryHelpContext( VOID )
{
    return HC_VOLUME_PROPERTIES_DIALOG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\afp\ui\cmdline\parse.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1991          **/
/********************************************************************/

//***
//
// Filename: Parse.c
//
// Description:
//	This module contains the entry point of DIAL.EXE.
//	This module will parse the command line. It will validate the syntax
//	and the arguments on the command line. On any error, the exit
//	module will be invoked with the appropriate error code.
//	If any default values are required, they will be supplied by
//	this module.
//
// History:
//	September 1, 1990	Narendra Gidwani 	Created original version
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#ifdef DBCS
#include <locale.h>
#endif /* DBCS */
#include "cmd.h"

//** Global data structures and variables used. **

//*  These variables are pointers to ASCIIZ which will be set to
//   point to switch values of the command line by GetSwitchValue.
//   These pointers are global within this module.

CHAR * gblEntity    		= NULL;
CHAR * gblCommand    		= NULL;
CHAR * gblServer  		= NULL;
CHAR * gblName     		= NULL;
CHAR * gblPath     		= NULL;
CHAR * gblPassword  		= NULL;
CHAR * gblReadOnly      	= NULL;
CHAR * gblMaxUses 		= NULL;
CHAR * gblOwnerName		= NULL;
CHAR * gblGroupName		= NULL;
CHAR * gblPermissions		= NULL;
CHAR * gblLoginMessage		= NULL;
CHAR * gblMaxSessions		= NULL;
CHAR * gblGuestsAllowed	 	= NULL;
CHAR * gblMacServerName	 	= NULL;
CHAR * gblUAMRequired		= NULL;
CHAR * gblAllowSavedPasswords	= NULL;
CHAR * gblType			= NULL;
CHAR * gblCreator		= NULL;
CHAR * gblDataFork		= NULL;
CHAR * gblResourceFork		= NULL;
CHAR * gblTargetFile		= NULL;
CHAR * gblHelp		        = NULL;


// Non translatable text
//

CHAR * pszVolume 	= "Volume";
CHAR * pszAdd 	 	= "/Add";
CHAR * pszDelete 	= "/Remove";
CHAR * pszSet    	= "/Set";
CHAR * pszDirectory 	= "Directory";
CHAR * pszServer 	= "Server";
CHAR * pszForkize 	= "Forkize";

CMD_FMT DelVolArgFmt[] = {

{ "/Server", 		(CHAR *)&gblServer,		0},
{ "/Name",        	(CHAR *)&gblName,		0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};

CMD_FMT AddVolArgFmt[] = {

{ "/Server", 	  	(CHAR *)&gblServer,		0},
{ "/Name",        	(CHAR *)&gblName,		0},
{ "/Path",        	(CHAR *)&gblPath,		0},
{ "/Password",    	(CHAR *)&gblPassword,		0},
{ "/ReadOnly",    	(CHAR *)&gblReadOnly,		0},
{ "/GuestsAllowed",	(CHAR *)&gblGuestsAllowed,	0},
{ "/MaxUsers",		(CHAR *)&gblMaxUses,		0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};

CMD_FMT SetVolArgFmt[] = {

{ "/Server", 	  	(CHAR *)&gblServer,		0},
{ "/Name",        	(CHAR *)&gblName,		0},
{ "/Password",    	(CHAR *)&gblPassword,		0},
{ "/ReadOnly",    	(CHAR *)&gblReadOnly,		0},
{ "/GuestsAllowed",	(CHAR *)&gblGuestsAllowed,	0},
{ "/MaxUsers",		(CHAR *)&gblMaxUses,		0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};

CMD_FMT DirArgFmt[] = {

{ "/Server", 	  	(CHAR *)&gblServer,		0},
{ "/Path",        	(CHAR *)&gblPath,		0},
{ "/Owner",    		(CHAR *)&gblOwnerName,		0},
{ "/Group",    		(CHAR *)&gblGroupName,		0},
{ "/Permissions",	(CHAR *)&gblPermissions,	0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};

CMD_FMT ServerArgFmt[] = {

{ "/Server", 	  	(CHAR *)&gblServer,		0},
{ "/MaxSessions",       (CHAR *)&gblMaxSessions,	0},
{ "/LoginMessage",    	(CHAR *)&gblLoginMessage,	0},
{ "/GuestsAllowed",    	(CHAR *)&gblGuestsAllowed,	0},
{ "/UAMRequired",	(CHAR *)&gblUAMRequired,	0},
{ "/AllowSavedPasswords",(CHAR *)&gblAllowSavedPasswords,0},
{ "/MacServerName",	(CHAR *)&gblMacServerName,	0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};

CMD_FMT ForkizeArgFmt[] = {		

{ "/Server", 	  	(CHAR *)&gblServer,		0},
{ "/Type", 	  	(CHAR *)&gblType,		0},
{ "/Creator",       	(CHAR *)&gblCreator,		0},
{ "/DataFork",    	(CHAR *)&gblDataFork,		0},
{ "/ResourceFork",    	(CHAR *)&gblResourceFork,	0},
{ "/TargetFile",	(CHAR *)&gblTargetFile,		0},
{ "/Help",        	(CHAR *)&gblHelp,		0},
{ "/?",        	        (CHAR *)&gblHelp,	        0},
{ NULL,			(CHAR *)NULL,			0}
};


//**
//
// Call: 	main
//
// Entry:  	int argc; 	- Number of command line arguments	
//		char *argv[];	- Array of pointers to ASCIIZ command line
//				  arguments.
//
// Exit:	none.
//
// Returns:	none.
//
// Description: Calls the command line parser with the command line
//		arguments.
//
VOID _cdecl
main( INT argc, CHAR * argv[] )
{

#ifdef DBCS
    setlocale( LC_ALL, "" );
#endif /* DBCS */

    // This will act like xacc or yacc. It will parse the command line
    // and call the appropriate function to carry out an action.
    // Thus this procedure will never return.

    ParseCmdArgList( argc, argv );
}

//**
//
// Call:	ParseCmdArgList
//
// Entry:	int argc;	- Number of command line arguments.
//		char *argv[];   - Array of pointers to ASCIIZ command line
//				  arguments.
//
// Exit:	none.
//
// Returns:	none.
//
// Description:
//	 	Will parse command line for any errors and determine
//		from the syntax what the user wishes to do. Command
//		line arguments will be validated.
//
VOID
ParseCmdArgList(
    INT argc,
    CHAR * argv[]
)
{
    DWORD   ArgCount = 0;

    if ( argc == 1 )
	PrintMessageAndExit( IDS_GENERAL_SYNTAX, NULL );

    //
    // What is the entity being operated on ?
    //

    gblEntity = argv[++ArgCount];

    if ( _strnicmp( pszVolume, gblEntity, strlen( gblEntity ) ) == 0 )
    {
	if ( argc == 2 )
	    PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

    	gblCommand = argv[++ArgCount];

    	if ( _strnicmp( pszAdd, gblCommand, strlen( gblCommand ) ) == 0 )
	{
	    GetArguments( AddVolArgFmt, argv, argc, ArgCount );

            if ( gblHelp != (CHAR*)NULL )
	        PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

	    DoVolumeAdd( gblServer, gblName, gblPath, gblPassword, gblReadOnly,
			 gblGuestsAllowed, gblMaxUses );
     	}
    	else if ( _strnicmp( pszDelete, gblCommand, strlen( gblCommand ) ) == 0 )
	{
	    GetArguments( DelVolArgFmt, argv, argc, ArgCount );

            if ( gblHelp != (CHAR*)NULL )
	        PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

	    DoVolumeDelete( gblServer, gblName );
	}
    	else if ( _strnicmp( pszSet, gblCommand, strlen( gblCommand ) ) == 0 )
	{
	    GetArguments( SetVolArgFmt, argv, argc, ArgCount );

            if ( gblHelp != (CHAR*)NULL )
	        PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );

	    DoVolumeSet( gblServer, gblName, gblPassword, gblReadOnly,
			 gblGuestsAllowed, gblMaxUses );
	}
	else
	    PrintMessageAndExit( IDS_VOLUME_SYNTAX, NULL );
    }
    else if ( _strnicmp( pszDirectory, gblEntity, strlen( gblEntity ) ) == 0 )
    {
	if ( argc == 2 )
	    PrintMessageAndExit( IDS_DIRECTORY_SYNTAX, NULL );

	GetArguments( DirArgFmt, argv, argc, ArgCount );

        if ( gblHelp != (CHAR*)NULL )
	    PrintMessageAndExit( IDS_DIRECTORY_SYNTAX, NULL );

	DoDirectorySetInfo( gblServer, gblPath, gblOwnerName, gblGroupName,
			    gblPermissions );
    }

    else if ( _strnicmp( pszServer, gblEntity, strlen( gblEntity ) ) == 0 )
    {
	if ( argc == 2 )
	    PrintMessageAndExit( IDS_SERVER_SYNTAX, NULL );

	GetArguments( ServerArgFmt, argv, argc, ArgCount );

        if ( gblHelp != (CHAR*)NULL )
	    PrintMessageAndExit( IDS_SERVER_SYNTAX, NULL );

	DoServerSetInfo( gblServer, gblMaxSessions, gblLoginMessage,
			 gblGuestsAllowed, gblUAMRequired,
			 gblAllowSavedPasswords, gblMacServerName );
    }
    else if ( _strnicmp( pszForkize, gblEntity, strlen( gblEntity ) ) == 0 )
    {
	GetArguments( ForkizeArgFmt, argv, argc, ArgCount );

        if ( gblHelp != (CHAR*)NULL )
	    PrintMessageAndExit( IDS_FORKIZE_SYNTAX, NULL );

	DoForkize( gblServer, gblType, gblCreator, gblDataFork,
		   gblResourceFork, gblTargetFile );
    }
    else
	PrintMessageAndExit( IDS_GENERAL_SYNTAX, NULL );
}

VOID
GetArguments(
    CMD_FMT * pArgFmt,
    CHAR *    argv[],
    DWORD     argc,
    DWORD     ArgCount
)
{

    //
    //  To determine by the syntax what the user wishes to do we first
    //  run through the arguments and get switch values.
    //

    while ( ++ArgCount < argc )
    {
	//
	// If it is a switch, get its value.
	//

	if ( argv[ArgCount][0] == '/' )
	    GetSwitchValue( pArgFmt, argv[ArgCount] );
	else
	    PrintMessageAndExit( IDS_GENERAL_SYNTAX, NULL );
    }
}

//**
//
// Call:	GetSwitchValue
//
// Entry:	CHAR * SwitchPtr; - Pointer to ASCIIZ containing a command
//				    line argument.
//				    ex. - /phoneb:c:\subdir
//
//		CHAR ** LastArg;  - Nothing.
//
// Exit:	CHAR * SwitchPtr; - same as entry.
//
//		CHAR ** LastArg;  - Pointer to a pointer to ASCIIZ containig
//				    the text of the first bad switch if
//				    there were any.
//
// Returns:	0 - Success.
//		AMBIGIOUS_SWITCH_ERRROR  - failure.
//		UNKNOWN_SWITCH_ERROR 	 - failure.
//		MEM_ALLOC_ERROR 	 - failure.
//		MULTIPLE_SWITCH_ERROR 	 - failure.
//
// Description: This procedure will run through all the valid switches
//		in the cmdfmt structure and retrieve the value of the
//		the switch. The value of the switch will be inserted into the
//		cmdfmt structure. It will expand abbreviated switches. If
//		the switch had no value, it will insert a null character
//		as the value. If the switch did not appear, the value
//		pointer of the switch (in the cmdfmt structure)
//	 	will remain unchanged ( should be initialized to NULL ).
//		This procedure uses the same data structure as GetCmdArgs5,
//		hence some fields may be ignored. This is done to make the
//		functionality of this procedure extendable.
//		
//
VOID
GetSwitchValue(
    CMD_FMT * pArgFmt,
    IN CHAR * pchSwitchPtr
)
{
    INT     intFound = -1;
    DWORD   dwIndex;
    DWORD   dwSwitchLen;
    CHAR *  pchSeparatorPtr;

    //
    // Get length of the switch part of the argument.
    //

    if ( ( pchSeparatorPtr = strchr( pchSwitchPtr, ':' )) != NULL )
        dwSwitchLen = (DWORD)(pchSeparatorPtr - pchSwitchPtr);
    else
	//
	// If the switch had no value.
	//

    	dwSwitchLen = strlen( pchSwitchPtr );


    //
    // Run through all switches.
    //

    for ( dwIndex = 0; pArgFmt[dwIndex].cf_parmstr != NULL; dwIndex++ )
    {

	//
	// If this switch matches (partly or completely) one of the
	// valid switches.
	//

	if ( !_strnicmp(  pArgFmt[dwIndex].cf_parmstr,
			 pchSwitchPtr,
			 dwSwitchLen ) )
	{

	    if ( intFound < 0 )
	    	intFound = dwIndex;
	    else
	    {
		//
		// If this argument has matched another switch also.
		//

		if ( pchSeparatorPtr )
		    *pchSeparatorPtr = '\0';

	        PrintMessageAndExit( IDS_AMBIGIOUS_SWITCH_ERROR, pchSwitchPtr );
	    }
	}
    }

    //
    // If we could not find a match for this switch.
    //

    if ( intFound < 0 )
    {

	if ( pchSeparatorPtr )
	    *pchSeparatorPtr = '\0';

	PrintMessageAndExit( IDS_UNKNOWN_SWITCH_ERROR, pchSwitchPtr );
    }

    //
    // If this switch is appearing for the second time.
    //

    if ( pArgFmt[intFound].cf_usecount > 0 )
    {
	if ( pchSeparatorPtr )
	    *pchSeparatorPtr = '\0';

	PrintMessageAndExit( IDS_DUPLICATE_SWITCH_ERROR, pchSwitchPtr );
    }
    else
        pArgFmt[intFound].cf_usecount++;

    //
    // Get the switch value if there is one.
    //

    if ( ( pchSeparatorPtr ) && ((CHAR *)(pchSeparatorPtr + 1)) )
    {
	*(CHAR **)pArgFmt[intFound].cf_ptr =  ++pchSeparatorPtr;
    }
    else
    {
	*(CHAR **)pArgFmt[intFound].cf_ptr = (CHAR *)"";
    }

}


/*******************************************************************

    NAME:	IsDriveGreaterThan2Gig

    SYNOPSIS:	Determines if the disk is bigger than 2Gig.  If it, return
		TRUE so that a warning can be displayed to the user

    RETURNS:	TRUE if disk is larger than 2Gig
		FALSE otherwise

    HISTORY:
	NarenG		11/18/92	Modified for AFPMGR

********************************************************************/

BOOL IsDriveGreaterThan2Gig( LPSTR lpDrivePath )
{
    DWORD         SectorsPerCluster;
    DWORD         BytesPerSector;
    DWORD         NumberOfFreeClusters;
    DWORD         TotalNumberOfClusters;
    DWORDLONG       DriveSize;
    DWORDLONG       TwoGig = MAXLONG;


    //
    // If this drive volume is greater than 2G then we print warning
    //

    if ( !GetDiskFreeSpace( lpDrivePath,
                              &SectorsPerCluster,
                              &BytesPerSector,
                              &NumberOfFreeClusters,
                              &TotalNumberOfClusters
                            ))
    {
        // some error: can't do much, so just assume this drive is smaller than 2GB.  That's
        // probably better than alarming the customer by putting the warning?
	    return FALSE;
    }

    DriveSize = UInt32x32To64( SectorsPerCluster * BytesPerSector,
                               TotalNumberOfClusters ) ;

    if ( DriveSize > TwoGig )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\messages\makefile.inc ===
..\driver\h\atkmsg.h atkmsg.rc: atkmsg.mc
    mc -v -h ..\driver\h atkmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\perfctrs\atkctrnm.h ===
//
//  atkctrnm.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values fo the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define ATKOBJ				0

#define PKTSIN				2
#define PKTSOUT				4

#define DATAIN				6
#define DATAOUT				8

#define DDPAVGTIME			10
#define DDPPKTIN			12

#define AARPAVGTIME			14
#define AARPPKTIN			16

#define	ATPAVGTIME			18
#define ATPPKTIN			20

#define NBPAVGTIME			22
#define NBPPKTIN			24

#define ZIPAVGTIME			26
#define ZIPPKTIN			28

#define RTMPAVGTIME			30
#define RTMPPKTIN			32

#define ATPRETRIESLOCAL		34
#define ATPRETRIESREMOTE	36
#define ATPRESPTIMEOUT		38
#define ATPXORESP			40
#define ATPALORESP			42
#define ATPRECDREL			44

#define CURPOOL				46

#define PKTROUTEDIN			48
#define PKTROUTEDOUT		50
#define PKTDROPPED			52



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\perfctrs\perfatk.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfatk.c

Abstract:

    This file implements the Extensible Objects for
    the Appletalk object types

Created:

    10/11/93	Sue Adams (suea)

Revision History

	02/23/94	Sue Adams - No longer need to open registry key
							\AppleTalk\Performance to query FirstCounter and
							FirstHelp indices.  These are now hardcoded as
							part of the base NT system.
							ATKOBJ = 1050, ATKOBJ_HELP = 1051,
							PKTDROPPED = 1096, PKTDROPPED_HELP = 1097
--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntprfctr.h>
#include <windows.h>
#include <string.h>
#include <wcstr.h>
#include <winperf.h>

#define GLOBAL	extern
#define EQU ; /##/
#define ATALK_SPIN_LOCK LONG
#define	PMDL			PVOID
#include <atkstat.h>
#include <tdi.h>

#include <atalktdi.h>

#include "atkctrs.h" // error message definition
#include "perfmsg.h"
#include "perfutil.h"
#include "dataatk.h"
#include <atkstat.h>

//
//  References to constants which initialize the Object type definitions
//	(see dataatk.h & .c)
//

#define	MAX_PORTS	32
extern ATK_DATA_DEFINITION AtkDataDefinition;

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK
HANDLE	AddressHandle = NULL;	// handle to appletalk driver
DWORD	LengthOfInstanceNames = 0;	// including padding to DWORD length
int     NumOfDevices = 0;		// Number of appletalk ports with stats

PATALK_STATS				pAtalkStats;
PATALK_PORT_STATS			pAtalkPortStats;
CHAR						Buffer[ sizeof(ATALK_STATS) +
									sizeof(ATALK_PORT_STATS) * MAX_PORTS +
									sizeof(GET_STATISTICS_ACTION)];
PGET_STATISTICS_ACTION		GetStats = (PGET_STATISTICS_ACTION)Buffer;

//
//  Function Prototypes
//

PM_OPEN_PROC    OpenAtkPerformanceData;
PM_COLLECT_PROC CollectAtkPerformanceData;
PM_CLOSE_PROC   CloseAtkPerformanceData;

DWORD
OpenAtkPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open the Appletalk driver and remember the handle
    returned to be used in subsequent Ioctls for performance data to the
	driver.  Each device name exported by Appletalk will be mapped to an
	array index into the performance data arrays for all the ports handled
	by Appletalk.  These indices will then be used in the collect routine
	to know which set of performance data belongs to which device.

Arguments:

    Pointer to each device to be opened.  Note that for Appletalk, we do not
	actually open each device (port), we only open one Tdi provider name to
	use when ioctling the driver for performance data on all ports.

Return Value:

    None.

--*/

{
    NTSTATUS Status = ERROR_SUCCESS;
    UNICODE_STRING  DriverName;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LPWSTR   lpLocalDeviceNames;
    int      i;

	if (!dwOpenCount)
	{

		if ((lpLocalDeviceNames = lpDeviceNames) == NULL)
			return ERROR_INVALID_NAME; // There are no devices to query

		MonOpenEventLog();

		// Open the Appletalk driver and obtain the device (port)/index
		// mappings for performance data table
		RtlInitUnicodeString(&DriverName, ATALKPAP_DEVICENAME);
		InitializeObjectAttributes (
			&ObjectAttributes,
			&DriverName,
			0,
			NULL,
			NULL);
	
		Status = NtCreateFile(
					 &AddressHandle,
					 GENERIC_READ | SYNCHRONIZE,	// desired access.
					 &ObjectAttributes,			 	// object attributes.
					 &IoStatusBlock,				// returned status information.
					 0,							 	// block size (unused).
					 0,							 	// file attributes.
					 FILE_SHARE_READ,				// share access.
					 FILE_OPEN,					 	// create disposition.
					 FILE_SYNCHRONOUS_IO_NONALERT,	// create options.
					 NULL,
					 0);
	
		if (!NT_SUCCESS(Status))
		{
            REPORT_ERROR_DATA (ATK_OPEN_FILE_ERROR, LOG_USER,
                &IoStatusBlock, sizeof(IoStatusBlock));
			return RtlNtStatusToDosError(Status);
		}
			
		//
		//	Now make a NtDeviceIoControl file (corresponding to TdiAction) to
		//	get the statistics - here we are only interested in the array
		//  of device/port names
		//
	
		GetStats->ActionHeader.ActionCode = COMMON_ACTION_GETSTATISTICS;
		GetStats->ActionHeader.TransportId = MATK;
		Status = NtDeviceIoControlFile(
						AddressHandle,
						NULL,
						NULL,
						NULL,
						&IoStatusBlock,
						IOCTL_TDI_ACTION,
						NULL,
						0,
						(PVOID)GetStats,
						sizeof(Buffer));
		if (!NT_SUCCESS(Status))
		{
			REPORT_ERROR_DATA (ATK_IOCTL_FILE_ERROR, LOG_DEBUG,
                       &IoStatusBlock, sizeof(IoStatusBlock));
			NtClose(AddressHandle);
			return RtlNtStatusToDosError(Status);
		}

		pAtalkStats = (PATALK_STATS)(Buffer + sizeof(GET_STATISTICS_ACTION));
		pAtalkPortStats = (PATALK_PORT_STATS)(  Buffer +
												sizeof(GET_STATISTICS_ACTION) +
												sizeof(ATALK_STATS));
		NumOfDevices = pAtalkStats->stat_NumActivePorts;
		for (i = 0; i < NumOfDevices; i++, pAtalkPortStats ++)
		{
			LengthOfInstanceNames +=
				DWORD_MULTIPLE((lstrlenW(pAtalkPortStats->prtst_PortName) * sizeof(WCHAR)));
		}


        bInitOK = TRUE; // ok to use this function

	} // end if dwOpenCount is zero (first opener)


	if (!NT_SUCCESS(Status))
	{
		if (AddressHandle != NULL)
		{
			NtClose(AddressHandle);
		}
		return RtlNtStatusToDosError(Status);

	}
	else
	{
		dwOpenCount++; // increment OPEN counter
		REPORT_INFORMATION (ATK_OPEN_PERFORMANCE_DATA, LOG_DEBUG);
	}

	return Status;
}

DWORD
CollectAtkPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)


/*++

Routine Description:

    This routine will return the data for the AppleTalk counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updates the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

    ULONG SpaceNeeded;
    PDWORD pdwCounter;
    LARGE_INTEGER UNALIGNED *pliCounter;
    LARGE_INTEGER	li1000;
    PERF_COUNTER_BLOCK *pPerfCounterBlock;
    ATK_DATA_DEFINITION *pAtkDataDefinition;
    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
	int i;
	UNICODE_STRING UCurDeviceName;

    // Variables for collecting the data from Appletalk

    NTSTATUS		Status;
    IO_STATUS_BLOCK IoStatusBlock;
    DWORD           dwQueryType;


	li1000.QuadPart = 1000;
    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK) {
        // unable to continue because open failed.
	    *lpcbTotalBytes = (DWORD) 0;
	    *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

	if (lpValueName == NULL) {
        REPORT_INFORMATION (ATK_COLLECT_ENTERED, LOG_VERBOSE);
    } else {
        REPORT_INFORMATION_DATA (ATK_COLLECT_ENTERED,
                                 LOG_VERBOSE,
                                 lpValueName,
                                 (DWORD)(lstrlenW(lpValueName)*sizeof(WCHAR)));
    }

    //
    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if ((dwQueryType == QUERY_COSTLY) || (dwQueryType == QUERY_FOREIGN)) {
        // ATK foreign data requests are not supported so bail out
        REPORT_INFORMATION (ATK_FOREIGN_DATA_REQUEST, LOG_VERBOSE);
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
        if ( !(IsNumberInUnicodeList (AtkDataDefinition.AtkObjectType.ObjectNameTitleIndex,
                                      lpValueName)))
        {
            // request received for data object not provided by this routine
            REPORT_INFORMATION (ATK_UNSUPPORTED_ITEM_REQUEST, LOG_VERBOSE);

            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pAtkDataDefinition = (ATK_DATA_DEFINITION *) *lppData;

    // Compute space needed to hold AppleTalk performance Data
	SpaceNeeded = sizeof(ATK_DATA_DEFINITION) +
				  (NumOfDevices *
					(SIZE_ATK_PERFORMANCE_DATA +
					 sizeof(PERF_INSTANCE_DEFINITION))) +
				  LengthOfInstanceNames;

    if ( *lpcbTotalBytes < SpaceNeeded ) {
        *lpcbTotalBytes = (DWORD) SpaceNeeded;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //

    RtlMoveMemory(pAtkDataDefinition,
				  &AtkDataDefinition,
				  sizeof(ATK_DATA_DEFINITION));

    //
	// Format and collect SFM data from IOCTL
	//

	GetStats->ActionHeader.ActionCode = COMMON_ACTION_GETSTATISTICS;
	GetStats->ActionHeader.TransportId = MATK;
	Status = NtDeviceIoControlFile(
					AddressHandle,
					NULL,
					NULL,
					NULL,
					&IoStatusBlock,
					IOCTL_TDI_ACTION,
					NULL,
					0,
					(PVOID)GetStats,
					sizeof(Buffer));
	if ((!NT_SUCCESS(Status)) || (!NT_SUCCESS(IoStatusBlock.Status)))
	{
		REPORT_ERROR_DATA (ATK_IOCTL_FILE_ERROR, LOG_DEBUG,
                   &IoStatusBlock, sizeof(IoStatusBlock));
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;
		return ERROR_SUCCESS;
	}
	// The real statistics data starts after the TDI action header
	pAtalkStats = (ATALK_STATS *)(Buffer + sizeof(GET_STATISTICS_ACTION));
	pAtalkPortStats = (PATALK_PORT_STATS)(  Buffer +
											sizeof(GET_STATISTICS_ACTION) +
											sizeof(ATALK_STATS));

    //
    // due to some PnP event, if one more adapter has come in, make adjustments!
    //
    if (pAtalkStats->stat_NumActivePorts > (DWORD)NumOfDevices)
    {
        NumOfDevices = pAtalkStats->stat_NumActivePorts;
        LengthOfInstanceNames = 0;

		for (i = 0; i < NumOfDevices; i++, pAtalkPortStats ++)
		{
			LengthOfInstanceNames +=
				DWORD_MULTIPLE((lstrlenW(pAtalkPortStats->prtst_PortName) * sizeof(WCHAR)));
		}

	    SpaceNeeded = sizeof(ATK_DATA_DEFINITION) +
				      (NumOfDevices * (SIZE_ATK_PERFORMANCE_DATA +
                                       sizeof(PERF_INSTANCE_DEFINITION))) +
				      LengthOfInstanceNames;

        if ( *lpcbTotalBytes < SpaceNeeded ) {
            *lpcbTotalBytes = (DWORD) SpaceNeeded;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_MORE_DATA;
        }
    }


    // Now point to the location where the first instance definition will go
    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pAtkDataDefinition[1];
	
    for (i = 0; i < NumOfDevices; i++, pAtalkPortStats ++)
	{
		//
        //  Format Appletalk statistics for each active port (instance)
        //

		RtlInitUnicodeString(&UCurDeviceName, pAtalkPortStats->prtst_PortName);
        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pPerfCounterBlock,
			0,
			0,
            i,
            &UCurDeviceName);


        pPerfCounterBlock->ByteLength = SIZE_ATK_PERFORMANCE_DATA;

        pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

		// Begin filling in the actual counter data
        *pdwCounter++ = pAtalkPortStats->prtst_NumPacketsIn;
        *pdwCounter++ = pAtalkPortStats->prtst_NumPacketsOut;

        pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
        *pliCounter++ = pAtalkPortStats->prtst_DataIn;
        *pliCounter++ = pAtalkPortStats->prtst_DataOut;

		*pliCounter = pAtalkPortStats->prtst_DdpPacketInProcessTime;
		// convert this to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart/pAtalkStats->stat_PerfFreq.QuadPart);
		pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkPortStats->prtst_NumDdpPacketsIn;

        pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
		*pliCounter = pAtalkPortStats->prtst_AarpPacketInProcessTime;
		// convert this  to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart/pAtalkStats->stat_PerfFreq.QuadPart);
		pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkPortStats->prtst_NumAarpPacketsIn;

        pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
		*pliCounter = pAtalkStats->stat_AtpPacketInProcessTime;
		// convert this  to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart, pAtalkStats->stat_PerfFreq.QuadPart);
		pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkStats->stat_AtpNumPackets;

		*pdwCounter++ = pAtalkStats->stat_AtpNumRespTimeout;
		*pdwCounter++ = pAtalkStats->stat_AtpNumLocalRetries;
		*pdwCounter++ = pAtalkStats->stat_AtpNumRemoteRetries;
		*pdwCounter++ = pAtalkStats->stat_AtpNumXoResponse;
		*pdwCounter++ = pAtalkStats->stat_AtpNumAloResponse;
		*pdwCounter++ = pAtalkStats->stat_AtpNumRecdRelease;

		pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
		*pliCounter = pAtalkPortStats->prtst_NbpPacketInProcessTime;
		// convert this  to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart, pAtalkStats->stat_PerfFreq.QuadPart);
        pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkPortStats->prtst_NumNbpPacketsIn;

        pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
		*pliCounter = pAtalkPortStats->prtst_ZipPacketInProcessTime;
		// convert this  to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart, pAtalkStats->stat_PerfFreq.QuadPart);
        pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkPortStats->prtst_NumZipPacketsIn;

        pliCounter = (LARGE_INTEGER UNALIGNED *) pdwCounter;
		*pliCounter = pAtalkPortStats->prtst_RtmpPacketInProcessTime;
		// convert this  to 1msec time base
		pliCounter->QuadPart = li1000.QuadPart * (pliCounter->QuadPart, pAtalkStats->stat_PerfFreq.QuadPart);
        pdwCounter  = (PDWORD) ++pliCounter;
        *pdwCounter++ = pAtalkPortStats->prtst_NumRtmpPacketsIn;

        *pdwCounter++ = pAtalkStats->stat_CurAllocSize;

        *pdwCounter++ = pAtalkPortStats->prtst_NumPktRoutedIn;
        *pdwCounter++ = pAtalkPortStats->prtst_NumPktRoutedOut;
        *pdwCounter++ = pAtalkPortStats->prtst_NumPktDropped;

		pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  ((PBYTE) pPerfCounterBlock +
                                   SIZE_ATK_PERFORMANCE_DATA);
    }

    pAtkDataDefinition->AtkObjectType.NumInstances = NumOfDevices;
    pAtkDataDefinition->AtkObjectType.TotalByteLength =
						(DWORD)((PBYTE) pdwCounter - (PBYTE) pAtkDataDefinition);

    *lppData = pdwCounter;
    *lpcbTotalBytes = (DWORD)((PBYTE) pdwCounter - (PBYTE) pAtkDataDefinition);
	*lpNumObjectTypes = 1;

    REPORT_INFORMATION (ATK_COLLECT_DATA, LOG_DEBUG);
    return ERROR_SUCCESS;
}

DWORD
CloseAtkPerformanceData(
)

/*++

Routine Description:

    This routine closes the open handles to Appletalk driver and eventlog.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/

{
    REPORT_INFORMATION (ATK_CLOSE_ENTERED, LOG_VERBOSE);

   if (!(--dwOpenCount)) { // when this is the last thread...

	    NtClose(AddressHandle);
		MonCloseEventLog();
   }

    return ERROR_SUCCESS;

}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\perfctrs\dataatk.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dataatk.c

Abstract:

    a file containing the constant data structures
    for the Performance Monitor data for the Appletalk
    Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the Appletalk Extensible Objects.  This is an
    example of how other such objects could be defined.

Created:

    Russ Blake  07/31/92

Revision History:

    Sue Adams 02/23/94	- Hard code the Counter and Help indices as these are
						  now defined values in the base NT system.

--*/
//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winperf.h>
#include "dataatk.h"

//
//  Constant structure initializations defined in dataatk.h
//

ATK_DATA_DEFINITION AtkDataDefinition = {

    {
		// TotalByteLength
		sizeof(ATK_DATA_DEFINITION) + SIZE_ATK_PERFORMANCE_DATA,

		// DefinitionLength
		sizeof(ATK_DATA_DEFINITION),

		// HeaderLength
		sizeof(PERF_OBJECT_TYPE),

		// ObjectNameTitleIndex
		1050,

		// ObjectNameTitle
        0,

		// ObjectHelpTitleIndex
        1051,

		// ObjectHelpTitle
        0,

		// DetailLevel
        PERF_DETAIL_ADVANCED,

		// NumCounters
		(sizeof(ATK_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE)) / sizeof(PERF_COUNTER_DEFINITION),

		// Defaultcounter
		0,

		// NumInstances
        0,

		// CodePage
        0,

		// PerfTime
		{0,0},

		// PerfFreq
		{0,0}
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1052,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1053,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1054,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1055,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_PKTS_OUT_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1056,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1057,

		// CounterHelpTitle
		0,

		// DefaultScale
		-4,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_BULK_COUNT,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		NUM_DATAIN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1058,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1059,

		// CounterHelpTitle
		0,

		// DefaultScale
		-4,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_BULK_COUNT,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		NUM_DATAOUT_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1060,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1061,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		DDP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1062,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1063,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_DDP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1064,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1065,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		AARP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1066,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1067,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_AARP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1068,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1069,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		ATP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1070,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1071,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1072,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1073,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		NBP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1074,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1075,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_NBP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1076,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1077,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		ZIP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1078,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1079,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ZIP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1080,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1081,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_AVERAGE_BULK,

		// CounterSize
		sizeof(LARGE_INTEGER),

		// CounterOffset
		RTMP_PKT_PROCTIME_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1082,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1083,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_RTMP_PKTS_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1084,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1085,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_RAWCOUNT,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_LOCAL_RETRY_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1100,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1101,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_RAWCOUNT,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_REMOTE_RETRY_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1086,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1087,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_RAWCOUNT,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_RESP_TIMEOUT_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1088,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1089,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_XO_RESPONSE_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1090,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1091,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_ALO_RESPONSE_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1092,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1093,

		// CounterHelpTitle
		0,

		// DefaultScale
		-1,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_ATP_RECD_REL_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1094,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1095,

		// CounterHelpTitle
		0,

		// DefaultScale
		-4,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_RAWCOUNT,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		CUR_MEM_USAGE_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1096,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1097,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_PKT_ROUTED_IN_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1102,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1103,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_COUNTER,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_PKT_ROUTED_OUT_OFFSET
    },
	{
		// ByteLength
		sizeof(PERF_COUNTER_DEFINITION),

		// CounterNameTitleIndex
		1098,

		// CounterNameTitle
		0,

		// CounterHelpTitleIndex
		1099,

		// CounterHelpTitle
		0,

		// DefaultScale
		0,

		// DetailLevel
		PERF_DETAIL_NOVICE,

		// CounterType
		PERF_COUNTER_RAWCOUNT,

		// CounterSize
		sizeof(DWORD),

		// CounterOffset
		NUM_PKT_DROPPED_OFFSET
    }
};






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\perfctrs\perfmsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfmsg.h

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "atkctrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging
//             LOG_VERBOSE = Maximum Debugging
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the
//
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\perfctrs\dataatk.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993 Microsoft Corporation

Module Name:

      dataatk.h

Abstract:

    Header file for the VGA Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

   Sue Adams

Revision History:

	04-Oct-93	Sue Adams (suea)	- Created based on datavga.h

--*/

#ifndef _DATAATK_H_
#define _DATAATK_H_

/****************************************************************************\
								   18 Jan 92
								   russbl

           Adding a Counter to the Extensible Objects Code



1.  Modify the object definition in extdata.h:

    a.	Add a define for the offset of the counter in the
	data block for the given object type.

    b.	Add a PERF_COUNTER_DEFINITION to the <object>_DATA_DEFINITION.

2.  Add the Titles to the Registry in perfctrs.ini and perfhelp.ini:

    a.	Add Text for the Counter Name and the Text for the Help.

    b.	Add them to the bottom so we don't have to change all the
        numbers.

    c.  Change the Last Counter and Last Help entries under
        PerfLib in software.ini.

    d.  To do this at setup time, see section in pmintrnl.txt for
        protocol.

3.  Now add the counter to the object definition in extdata.c.
    This is the initializing, constant data which will actually go
    into the structure you added to the <object>_DATA_DEFINITION in
    step 1.b.	The type of the structure you are initializing is a
    PERF_COUNTER_DEFINITION.  These are defined in winperf.h.

4.  Add code in extobjct.c to collect the data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define ATK_NUM_PERF_OBJECT_TYPES 2

//----------------------------------------------------------------------------

//
//  Atk Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//

#define NUM_PKTS_IN_OFFSET	 	   	sizeof(PERF_COUNTER_BLOCK)
#define NUM_PKTS_OUT_OFFSET	    	NUM_PKTS_IN_OFFSET + sizeof(DWORD)
#define	NUM_DATAIN_OFFSET			NUM_PKTS_OUT_OFFSET + sizeof(DWORD)
#define NUM_DATAOUT_OFFSET			NUM_DATAIN_OFFSET + sizeof(LARGE_INTEGER)

#define DDP_PKT_PROCTIME_OFFSET		NUM_DATAOUT_OFFSET + sizeof(LARGE_INTEGER)
#define NUM_DDP_PKTS_IN_OFFSET		DDP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define AARP_PKT_PROCTIME_OFFSET	NUM_DDP_PKTS_IN_OFFSET + sizeof(DWORD)
#define NUM_AARP_PKTS_IN_OFFSET		AARP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define ATP_PKT_PROCTIME_OFFSET		NUM_AARP_PKTS_IN_OFFSET + sizeof(DWORD)
#define NUM_ATP_PKTS_IN_OFFSET		ATP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define NUM_ATP_RESP_TIMEOUT_OFFSET	NUM_ATP_PKTS_IN_OFFSET + sizeof(DWORD)
#define NUM_ATP_LOCAL_RETRY_OFFSET	NUM_ATP_RESP_TIMEOUT_OFFSET + sizeof(DWORD)
#define NUM_ATP_REMOTE_RETRY_OFFSET	NUM_ATP_LOCAL_RETRY_OFFSET + sizeof(DWORD)

#define NUM_ATP_XO_RESPONSE_OFFSET	NUM_ATP_REMOTE_RETRY_OFFSET + sizeof(DWORD)
#define NUM_ATP_ALO_RESPONSE_OFFSET	NUM_ATP_XO_RESPONSE_OFFSET + sizeof(DWORD)
#define NUM_ATP_RECD_REL_OFFSET		NUM_ATP_ALO_RESPONSE_OFFSET + sizeof(DWORD)
		
#define NBP_PKT_PROCTIME_OFFSET		NUM_ATP_RECD_REL_OFFSET + sizeof(DWORD)
#define NUM_NBP_PKTS_IN_OFFSET		NBP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define ZIP_PKT_PROCTIME_OFFSET		NUM_NBP_PKTS_IN_OFFSET + sizeof(DWORD)
#define NUM_ZIP_PKTS_IN_OFFSET		ZIP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define RTMP_PKT_PROCTIME_OFFSET	NUM_ZIP_PKTS_IN_OFFSET + sizeof(DWORD)
#define NUM_RTMP_PKTS_IN_OFFSET		RTMP_PKT_PROCTIME_OFFSET + sizeof(LARGE_INTEGER)

#define CUR_MEM_USAGE_OFFSET		NUM_RTMP_PKTS_IN_OFFSET + sizeof(DWORD)

#define NUM_PKT_ROUTED_IN_OFFSET	CUR_MEM_USAGE_OFFSET + sizeof(DWORD)
#define NUM_PKT_ROUTED_OUT_OFFSET	NUM_PKT_ROUTED_IN_OFFSET + sizeof(DWORD)
#define NUM_PKT_DROPPED_OFFSET		NUM_PKT_ROUTED_OUT_OFFSET + sizeof(DWORD)

#define SIZE_ATK_PERFORMANCE_DATA	NUM_PKT_DROPPED_OFFSET + sizeof(DWORD)


//
//  This is the counter structure presently returned by Nbf for
//  each Resource.  Each Resource is an Instance, named by its number.
//

typedef struct _ATK_DATA_DEFINITION {
    PERF_OBJECT_TYPE		AtkObjectType;

	PERF_COUNTER_DEFINITION	NumPacketsIn;		// per second
    PERF_COUNTER_DEFINITION	NumPacketsOut;		// per second
    PERF_COUNTER_DEFINITION	DataBytesIn;		// per second
    PERF_COUNTER_DEFINITION	DataBytesOut;		// per second

    PERF_COUNTER_DEFINITION	AverageDDPTime;		// millisec/packet
	PERF_COUNTER_DEFINITION	NumDDPPacketsIn;	// per second

    PERF_COUNTER_DEFINITION	AverageAARPTime;	// millisec/packet
	PERF_COUNTER_DEFINITION	NumAARPPacketsIn;	// per second

    PERF_COUNTER_DEFINITION	AverageATPTime;		// millisec/packet
	PERF_COUNTER_DEFINITION	NumATPPacketsIn;	// per second

    PERF_COUNTER_DEFINITION	AverageNBPTime;		// millisec/packet
	PERF_COUNTER_DEFINITION	NumNBPPacketsIn;	// per second

    PERF_COUNTER_DEFINITION	AverageZIPTime;		// millisec/packet
	PERF_COUNTER_DEFINITION	NumZIPPacketsIn;	// per second

    PERF_COUNTER_DEFINITION	AverageRTMPTime;	// millisec/packet
	PERF_COUNTER_DEFINITION	NumRTMPPacketsIn;	// per second

	PERF_COUNTER_DEFINITION	NumATPLocalRetries;	// number
	PERF_COUNTER_DEFINITION	NumATPRemoteRetries;// number
    PERF_COUNTER_DEFINITION	NumATPRespTimeout;	// number
    PERF_COUNTER_DEFINITION	ATPXoResponse;		// per second
    PERF_COUNTER_DEFINITION	ATPAloResponse;		// per second
    PERF_COUNTER_DEFINITION	ATPRecdRelease;		// per second

	PERF_COUNTER_DEFINITION	CurNonPagedPoolUsage;

	PERF_COUNTER_DEFINITION	NumPktRoutedIn;		// Packets in to be routed
	PERF_COUNTER_DEFINITION	NumPktRoutedOut;	// packets routed out
	PERF_COUNTER_DEFINITION	NumPktDropped;		// Packets dropped
	
} ATK_DATA_DEFINITION;

#pragma pack ()

#endif //_DATAATK_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\perfctrs\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  07/30/92
	Sue Adams	06/07/93
Revision History:

--*/
//
//  include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "atkctrs.h"	 // error message definition
#include "perfmsg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    PUNICODE_STRING Name
    )
/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
{
    DWORD NameLength;
    WCHAR *pName;

    //
    //  Include trailing null in name size
    //

    NameLength = Name->Length;
    if ( !NameLength ||
         Name->Buffer[(NameLength/sizeof(WCHAR))-1] != UNICODE_NULL ) {
        NameLength += sizeof(WCHAR);
    }

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    pName = (PWCHAR)&pBuffer[1];
    RtlMoveMemory(pName,Name->Buffer,Name->Length);

    //  Always null terminated.  Space for this reserved above.

    pName[(NameLength/sizeof(WCHAR))-1] = UNICODE_NULL;

    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);
    return 0;
}


HANDLE
MonOpenEventLog (
)
/*++

Routine Description:

    Reads the level of event logging from the registry and opens the
        channel to the event logger for subsequent event log entries.

Arguments:

      None

Return Value:

    Handle to the event log for reporting events.
    NULL if open not successful.

--*/
{
    HKEY hAppKey;
    TCHAR LogLevelKeyName[] = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib";
    TCHAR LogLevelValueName[] = "EventLogLevel";

    LONG lStatus;

    DWORD dwLogLevel;
    DWORD dwValueType;
    DWORD dwValueSize;

    // if global value of the logging level not initialized or is disabled,
    //  check the registry to see if it should be updated.

    if (!MESSAGE_LEVEL) {

       lStatus = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               LogLevelKeyName,
                               0,
                               KEY_READ,
                               &hAppKey);

       dwValueSize = sizeof (dwLogLevel);

       if (lStatus == ERROR_SUCCESS) {
            lStatus = RegQueryValueEx (hAppKey,
                               LogLevelValueName,
                               (LPDWORD)NULL,
                               &dwValueType,
                               (LPBYTE)&dwLogLevel,
                               &dwValueSize);

            if (lStatus == ERROR_SUCCESS) {
               MESSAGE_LEVEL = dwLogLevel;
            } else {
               MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
            }
            RegCloseKey (hAppKey);
       } else {
         MESSAGE_LEVEL = MESSAGE_LEVEL_DEFAULT;
       }
    }

    if (hEventLog == NULL){
         hEventLog = RegisterEventSource (
            (LPTSTR)NULL,            // Use Local Machine
            APP_NAME);               // event log app name to find in registry

         if (hEventLog != NULL) {
            REPORT_INFORMATION (UTIL_LOG_OPEN, LOG_DEBUG);
         }
    }

    if (hEventLog != NULL) {
         dwLogUsers++;           // increment count of perfctr log users
    }
    return (hEventLog);
}


VOID
MonCloseEventLog (
)
/*++

Routine Description:

      Closes the handle to the event logger if this is the last caller

Arguments:

      None

Return Value:

      None

--*/
{
    if (hEventLog != NULL) {
        dwLogUsers--;         // decrement usage
        if (dwLogUsers <= 0) {    // and if we're the last, then close up log
            REPORT_INFORMATION (UTIL_CLOSING_LOG, LOG_DEBUG);
            DeregisterEventSource (hEventLog);
        }
    }
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\perfctrs\perfutil.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992 Microsoft Corporation

Module Name:

    perfutil.h

Abstract:

    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:

    Russ Blake  7/30/92

Revision History:


--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

// enable this define to log process heap data to the event log
#ifdef PROBE_HEAP_USAGE
#undef PROBE_HEAP_USAGE
#endif
//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//
#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

//    (assumes dword is 4 bytes long and pointer is a dword in size)
#define ALIGN_ON_DWORD(x) ((VOID *)( ((DWORD) x & 0x00000003) ? ( ((DWORD) x & 0xFFFFFFFC) + 4 ) : ( (DWORD) x ) ))

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

//
// The definition of the only routine of perfutil.c, It builds part of a
// performance data instance (PERF_INSTANCE_DEFINITION) as described in
// winperf.h
//

HANDLE MonOpenEventLog ();
VOID MonCloseEventLog ();
DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    PUNICODE_STRING Name
);

typedef struct _LOCAL_HEAP_INFO_BLOCK {
    DWORD   AllocatedEntries;
    DWORD   AllocatedBytes;
    DWORD   FreeEntries;
    DWORD   FreeBytes;
} LOCAL_HEAP_INFO, *PLOCAL_HEAP_INFO;


//
//  Memory Probe macro
//
#ifdef PROBE_HEAP_USAGE

#define HEAP_PROBE()    { \
    DWORD   dwHeapStatus[5]; \
    NTSTATUS CallStatus; \
    dwHeapStatus[4] = __LINE__; \
    if (!(CallStatus = memprobe (dwHeapStatus, 16L, NULL))) { \
        REPORT_INFORMATION_DATA (TCP_HEAP_STATUS, LOG_DEBUG,    \
            &dwHeapStatus, sizeof(dwHeapStatus));  \
    } else {  \
        REPORT_ERROR_DATA (TCP_HEAP_STATUS_ERROR, LOG_DEBUG, \
            &CallStatus, sizeof (DWORD)); \
    } \
}

#else

#define HEAP_PROBE()    ;

#endif

#endif  //_PERFUTIL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\aep.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aep.h

Abstract:

	This module contains the echo protocol definitions

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_AEP_
#define	_AEP_

#define		EP_COMMAND_OFFSET		0
#define		EP_COMMAND_REQUEST		1
#define		EP_COMMAND_REPLY		2

VOID
AtalkAepPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDestAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizePath,
	IN	PVOID				OptimizeCtx
);

VOID FASTCALL
atalkAepSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
);


#endif	// _AEP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\adsp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	adsp.c

Abstract:

	This module implements the ADSP protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	30 Mar 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ADSP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitAdspInitialize)
#pragma alloc_text(PAGE, AtalkAdspCreateAddress)
#pragma alloc_text(PAGEADSP, AtalkAdspCreateConnection)
#pragma alloc_text(PAGEADSP, AtalkAdspCleanupAddress)
#pragma alloc_text(PAGEADSP, AtalkAdspCloseAddress)
#pragma alloc_text(PAGEADSP, AtalkAdspCloseConnection)
#pragma alloc_text(PAGEADSP, AtalkAdspCleanupConnection)
#pragma alloc_text(PAGEADSP, AtalkAdspAssociateAddress)
#pragma alloc_text(PAGEADSP, AtalkAdspDissociateAddress)
#pragma alloc_text(PAGEADSP, AtalkAdspPostListen)
#pragma alloc_text(PAGEADSP, AtalkAdspCancelListen)
#pragma alloc_text(PAGEADSP, AtalkAdspPostConnect)
#pragma alloc_text(PAGEADSP, AtalkAdspDisconnect)
#pragma alloc_text(PAGEADSP, AtalkAdspRead)
#pragma alloc_text(PAGEADSP, AtalkAdspProcessQueuedSend)
#pragma alloc_text(PAGEADSP, AtalkAdspWrite)
#pragma alloc_text(PAGEADSP, AtalkAdspQuery)
#pragma alloc_text(PAGEADSP, atalkAdspPacketIn)
#pragma alloc_text(PAGEADSP, atalkAdspHandleOpenControl)
#pragma alloc_text(PAGEADSP, atalkAdspHandleAttn)
#pragma alloc_text(PAGEADSP, atalkAdspHandlePiggyBackAck)
#pragma alloc_text(PAGEADSP, atalkAdspHandleControl)
#pragma alloc_text(PAGEADSP, atalkAdspHandleData)
#pragma alloc_text(PAGEADSP, atalkAdspHandleOpenReq)
#pragma alloc_text(PAGEADSP, atalkAdspListenIndicateNonInterlock)
#pragma alloc_text(PAGEADSP, atalkAdspSendExpedited)
#pragma alloc_text(PAGEADSP, atalkAdspSendOpenControl)
#pragma alloc_text(PAGEADSP, atalkAdspSendControl)
#pragma alloc_text(PAGEADSP, atalkAdspSendDeny)
#pragma alloc_text(PAGEADSP, atalkAdspSendAttn)
#pragma alloc_text(PAGEADSP, atalkAdspSendData)
#pragma alloc_text(PAGEADSP, atalkAdspRecvData)
#pragma alloc_text(PAGEADSP, atalkAdspRecvAttn)
#pragma alloc_text(PAGEADSP, atalkAdspConnSendComplete)
#pragma alloc_text(PAGEADSP, atalkAdspAddrSendComplete)
#pragma alloc_text(PAGEADSP, atalkAdspSendAttnComplete)
#pragma alloc_text(PAGEADSP, atalkAdspSendDataComplete)
#pragma alloc_text(PAGEADSP, atalkAdspConnMaintenanceTimer)
#pragma alloc_text(PAGEADSP, atalkAdspRetransmitTimer)
#pragma alloc_text(PAGEADSP, atalkAdspAttnRetransmitTimer)
#pragma alloc_text(PAGEADSP, atalkAdspOpenTimer)
#pragma alloc_text(PAGEADSP, atalkAdspAddrRefNonInterlock)
#pragma alloc_text(PAGEADSP, atalkAdspConnRefByPtrNonInterlock)
#pragma alloc_text(PAGEADSP, atalkAdspConnRefByCtxNonInterlock)
#pragma alloc_text(PAGEADSP, atalkAdspConnRefBySrcAddr)
#pragma alloc_text(PAGEADSP, atalkAdspConnRefNextNc)
#pragma alloc_text(PAGEADSP, atalkAdspMaxSendSize)
#pragma alloc_text(PAGEADSP, atalkAdspMaxNextReadSize)
#pragma alloc_text(PAGEADSP, atalkAdspDescribeFromBufferQueue)
#pragma alloc_text(PAGEADSP, atalkAdspBufferQueueSize)
#pragma alloc_text(PAGEADSP, atalkAdspMessageSize)
#pragma alloc_text(PAGEADSP, atalkAdspAllocCopyChunk)
#pragma alloc_text(PAGEADSP, atalkAdspGetLookahead)
#pragma alloc_text(PAGEADSP, atalkAdspAddToBufferQueue)
#pragma alloc_text(PAGEADSP, atalkAdspReadFromBufferQueue)
#pragma alloc_text(PAGEADSP, atalkAdspDiscardFromBufferQueue)
#pragma alloc_text(PAGEADSP, atalkAdspBufferChunkReference)
#pragma alloc_text(PAGEADSP, atalkAdspBufferChunkDereference)
#pragma alloc_text(PAGEADSP, atalkAdspDecodeHeader)
#pragma alloc_text(PAGEADSP, atalkAdspGetNextConnId)
#pragma alloc_text(PAGEADSP, atalkAdspConnDeQueueAssocList)
#pragma alloc_text(PAGEADSP, atalkAdspConnDeQueueConnectList)
#pragma alloc_text(PAGEADSP, atalkAdspConnDeQueueListenList)
#pragma alloc_text(PAGEADSP, atalkAdspConnDeQueueActiveList)
#pragma alloc_text(PAGEADSP, atalkAdspAddrDeQueueGlobalList)
#pragma alloc_text(PAGEADSP, atalkAdspAddrDeQueueGlobalList)
#pragma alloc_text(PAGEADSP, atalkAdspConnDeQueueGlobalList)
#pragma alloc_text(PAGEADSP, atalkAdspAddrDeQueueOpenReq)
#pragma alloc_text(PAGEADSP, atalkAdspIsDuplicateOpenReq)
#pragma alloc_text(PAGEADSP, atalkAdspGenericComplete)
#pragma alloc_text(PAGEADSP, atalkAdspConnFindInConnect)
#endif

//
//	The model for ADSP calls in this module is as follows:
//	- For create calls (CreateAddress & CreateSession), a pointer to the created
//	 object is returned. This structure is referenced for creation.
//	- For all other calls, it expects a referenced pointer to the object.
//




VOID
AtalkInitAdspInitialize(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	INITIALIZE_SPIN_LOCK(&atalkAdspLock);
}




ATALK_ERROR
AtalkAdspCreateAddress(
	IN	PATALK_DEV_CTX		pDevCtx	OPTIONAL,
	IN	BYTE				SocketType,
	OUT	PADSP_ADDROBJ	*	ppAdspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_ADDROBJ		pAdspAddr = NULL;
	ATALK_ERROR			error;

	do
	{
		// Allocate memory for the Adsp address object
		if ((pAdspAddr = AtalkAllocZeroedMemory(sizeof(ADSP_ADDROBJ))) == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}

		// Create a Ddp Socket on the port
		error = AtalkDdpOpenAddress(AtalkDefaultPort,
									0,					// Dynamic socket
									NULL,
									atalkAdspPacketIn,
									pAdspAddr,			// Context for packet in.
									DDPPROTO_ADSP,
									pDevCtx,
									&pAdspAddr->adspao_pDdpAddr);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspCreateAddress: AtalkDdpOpenAddress fail %ld\n", error));
			break;
		}

		// Initialize the Adsp address object
		pAdspAddr->adspao_Signature = ADSPAO_SIGNATURE;

		INITIALIZE_SPIN_LOCK(&pAdspAddr->adspao_Lock);

		//	Is this a message mode socket?
		if (SocketType != SOCKET_TYPE_STREAM)
		{
			pAdspAddr->adspao_Flags	|= ADSPAO_MESSAGE;
		}

		//	Creation reference
		pAdspAddr->adspao_RefCount = 1;

	} while (FALSE);

	if (ATALK_SUCCESS(error))
	{
		//	Insert into the global address list.
		atalkAdspAddrQueueGlobalList(pAdspAddr);

		*ppAdspAddr = pAdspAddr;
	}
	else if (pAdspAddr != NULL)
	{
		AtalkFreeMemory(pAdspAddr);
	}

	return error;
}




ATALK_ERROR
AtalkAdspCleanupAddress(
	IN	PADSP_ADDROBJ			pAdspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT			i;
	KIRQL			OldIrql;
	PADSP_CONNOBJ	pAdspConn, pAdspConnNext;
	ATALK_ERROR		error;

	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);

	//	Shutdown all connections on this address object.
	for (i = 0; i < ADSP_CONN_HASH_SIZE; i++)
	{
		if ((pAdspConn = pAdspAddr->adspao_pActiveHash[i]) == NULL)
		{
			//	If empty, go on to the next index in hash table.
			continue;
		}

		//	Includes the one we are starting with.
		atalkAdspConnRefNextNc(pAdspConn, &pAdspConnNext, &error);
		if (!ATALK_SUCCESS(error))
		{
			//	No connections left on this index. Go to the next one.
			continue;
		}

		while (TRUE)
		{
			if ((pAdspConn = pAdspConnNext) == NULL)
			{
				break;
			}

			if ((pAdspConnNext = pAdspConn->adspco_pNextActive) != NULL)
			{
				atalkAdspConnRefNextNc(pAdspConnNext, &pAdspConnNext, &error);
				if (!ATALK_SUCCESS(error))
				{
					//	No requests left on this index. Go to the next one.
					pAdspConnNext = NULL;
				}
			}

			//	Shutdown this connection
			RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("AtalkAdspCloseAddress: Stopping conn %lx\n", pAdspConn));

			AtalkAdspCleanupConnection(pAdspConn);

			AtalkAdspConnDereference(pAdspConn);
			ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
		}
	}
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkAdspCloseAddress(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;
	PADSP_CONNOBJ	pAdspConn;
	PADSP_CONNOBJ	pAdspConnNext;
    DWORD           dwAssocRefCounts=0;


	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	if (pAdspAddr->adspao_Flags & ADSPAO_CLOSING)
	{
		//	We are already closing! This should never happen!
		ASSERT(0);
	}
	pAdspAddr->adspao_Flags |= ADSPAO_CLOSING;

	//	Set the completion info.
	pAdspAddr->adspao_CloseComp	= CompletionRoutine;
	pAdspAddr->adspao_CloseCtx	= pCloseCtx;

	// Implicitly dissociate any connection objects
	for (pAdspConn = pAdspAddr->adspao_pAssocConn;
		 pAdspConn != NULL;
		 pAdspConn = pAdspConnNext)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
		pAdspConnNext = pAdspConn->adspco_pNextAssoc;

		// reset associated flag
		if (pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED)
        {
            dwAssocRefCounts++;
            pAdspConn->adspco_Flags	&= ~ADSPCO_ASSOCIATED;
        }

		pAdspConn->adspco_pAssocAddr	= NULL;

		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	}

    // ok to subtract: at least Creation refcount is still around
    pAdspAddr->adspao_RefCount -= dwAssocRefCounts;

	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	//	Remove the creation reference count
	AtalkAdspAddrDereference(pAdspAddr);

	return ATALK_PENDING;
}




ATALK_ERROR
AtalkAdspCreateConnection(
	IN	PVOID					pConnCtx,	// Context to associate with the session
	IN	PATALK_DEV_CTX			pDevCtx		OPTIONAL,
	OUT	PADSP_CONNOBJ	*		ppAdspConn
	)
/*++

Routine Description:

	Create an ADSP session. The created session starts off being an orphan, i.e.
	it has no parent address object. It gets one when it is associated.

Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	PADSP_CONNOBJ	pAdspConn;

	// Allocate memory for a connection object
	if ((pAdspConn = AtalkAllocZeroedMemory(sizeof(ADSP_CONNOBJ))) == NULL)
	{
		return ATALK_RESR_MEM;
	}

	pAdspConn->adspco_Signature = ADSPCO_SIGNATURE;

	INITIALIZE_SPIN_LOCK(&pAdspConn->adspco_Lock);
	pAdspConn->adspco_ConnCtx	= pConnCtx;
	// pAdspConn->adspco_Flags		= 0;
	pAdspConn->adspco_RefCount	= 1;					// Creation reference

	*ppAdspConn = pAdspConn;

	// Delay remote disconnects to avoid race condn. between rcv/disconnect since
	// this can cause AFD to get extremely unhappy.
	AtalkTimerInitialize(&pAdspConn->adspco_DisconnectTimer,
						 atalkAdspDisconnectTimer,
						 ADSP_DISCONNECT_DELAY);

	//	Insert into the global connection list.
	ACQUIRE_SPIN_LOCK(&atalkAdspLock, &OldIrql);
	pAdspConn->adspco_pNextGlobal	= atalkAdspConnList;
	atalkAdspConnList				= pAdspConn;
	RELEASE_SPIN_LOCK(&atalkAdspLock, OldIrql);

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkAdspCloseConnection(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx
	)
/*++

Routine Description:

	Shutdown a session.

Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ASSERT(VALID_ADSPCO(pAdspConn));

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("AtalkAdspStopConnection: Close for %lx.%lx\n", pAdspConn, pAdspConn->adspco_Flags));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	if (pAdspConn->adspco_Flags & ADSPCO_CLOSING)
	{
		//	We are already closing! This should never happen!
		KeBugCheck(0);
	}
	pAdspConn->adspco_Flags |= ADSPCO_CLOSING;

	//	Set the completion info.
	pAdspConn->adspco_CloseComp	= CompletionRoutine;
	pAdspConn->adspco_CloseCtx	= pCloseCtx;
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	//	Remove the creation reference count
	AtalkAdspConnDereference(pAdspConn);
	return ATALK_PENDING;
}




ATALK_ERROR
AtalkAdspCleanupConnection(
	IN	PADSP_CONNOBJ			pAdspConn
	)
/*++

Routine Description:

	Shutdown a session.

Arguments:


Return Value:


--*/
{
	KIRQL		OldIrql;
	BOOLEAN		stopping	= FALSE;
	ATALK_ERROR	error		= ATALK_NO_ERROR;

	ASSERT(VALID_ADSPCO(pAdspConn));

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("AtalkAdspStopConnection: Cleanup for %lx.%lx\n", pAdspConn, pAdspConn->adspco_Flags));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	if ((pAdspConn->adspco_Flags & ADSPCO_STOPPING) == 0)
	{
		//	So Deref can complete cleanup irp.
		pAdspConn->adspco_Flags |= ADSPCO_STOPPING;

		//	If already effectively stopped, just return.
		if (pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED)
		{
			stopping = TRUE;
		}
		else
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspStopConnection: Called for a stopped conn %lx.%lx\n",
					pAdspConn, pAdspConn->adspco_Flags));
		}
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	//	Close the DDP Address Object if this was a server connection and
	//	opened its own socket.
	if (stopping)
	{
		//	If we are already disconnecting this will return an error which
		//	we ignore. But if we were only in the ASSOCIATED state, then we
		//	need to call disassociate here.
		error = AtalkAdspDisconnect(pAdspConn,
									ATALK_LOCAL_DISCONNECT,
									NULL,
									NULL);

		//	We were already disconnected.
		if (error == ATALK_INVALID_REQUEST)
		{
			AtalkAdspDissociateAddress(pAdspConn);
		}
	}

	return ATALK_NO_ERROR;
}




ATALK_ERROR
AtalkAdspAssociateAddress(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn
	)
/*++

Routine Description:

	Removed reference for the address for this connection. Causes deadlock in AFD where
	AFD blocks on close of the address object and we wait for connections to be closed
	first

Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;

	ASSERT(VALID_ADSPAO(pAdspAddr));
	ASSERT(VALID_ADSPCO(pAdspConn));

	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

	error = ATALK_ALREADY_ASSOCIATED;
	if ((pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED) == 0)
	{
		error = ATALK_NO_ERROR;

		//	Link it in.
		pAdspConn->adspco_pNextAssoc	= pAdspAddr->adspao_pAssocConn;
		pAdspAddr->adspao_pAssocConn	= pAdspConn;

		//	Remove not associated flag.
		pAdspConn->adspco_Flags |= ADSPCO_ASSOCIATED;
		pAdspConn->adspco_pAssocAddr = pAdspAddr;

        // put Association refcount
        pAdspAddr->adspao_RefCount++;
	}

	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	return error;
}




ATALK_ERROR
AtalkAdspDissociateAddress(
	IN	PADSP_CONNOBJ			pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_ADDROBJ	pAdspAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	ASSERT(VALID_ADSPCO(pAdspConn));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	if ((pAdspConn->adspco_Flags & (ADSPCO_LISTENING	|
									ADSPCO_CONNECTING	|
									ADSPCO_ACTIVE		|
									ADSPCO_ASSOCIATED)) != ADSPCO_ASSOCIATED)
	{
		//	ASSERTMSG("AtalkAdspDissociateAddress: Disassociate not valid\n", 0);
		error = ATALK_INVALID_CONNECTION;
	}
	else
	{
		pAdspAddr = pAdspConn->adspco_pAssocAddr ;

        if (pAdspAddr == NULL)
        {
		    ASSERT(0);
            error = ATALK_CANNOT_DISSOCIATE;
        }

		//	Set not associated flag. Don't reset the stopping flag.
		pAdspConn->adspco_Flags	&= ~ADSPCO_ASSOCIATED;

        // don't null it out yet: we'll do when we disconnect the connection
		// pAdspConn->adspco_pAssocAddr	= NULL;
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	//	Unlink it if ok.
	if (ATALK_SUCCESS(error))
	{
		ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
		atalkAdspConnDeQueueAssocList(pAdspAddr, pAdspConn);
		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
		RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

        // remove the Association refcount
        AtalkAdspAddrDereference(pAdspAddr);
	}
	return error;
}




ATALK_ERROR
AtalkAdspPostListen(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PVOID					pListenCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_ADDROBJ	pAdspAddr = pAdspConn->adspco_pAssocAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	//	This will also insert the connection object in the address objects
	//	list of connection which have a listen posted on them. When open
	//	connection requests come in, the first connection is taken off the list
	//	and the request satisfied.

	ASSERT(VALID_ADSPCO(pAdspConn));
	ASSERT(VALID_ADSPAO(pAdspAddr));

	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	do
	{
		if ((pAdspConn->adspco_Flags & (ADSPCO_LISTENING	|
										ADSPCO_CONNECTING	|
										ADSPCO_HALF_ACTIVE	|
										ADSPCO_ACTIVE		|
										ADSPCO_ASSOCIATED)) != ADSPCO_ASSOCIATED)
		{
			error = ATALK_INVALID_CONNECTION;
			break;
		}

		//	Verify the address object is not a connect address type.
		if (pAdspAddr->adspao_Flags & ADSPAO_CONNECT)
		{
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		//	Make the address object a listener.
		pAdspAddr->adspao_Flags			|= ADSPAO_LISTENER;

		pAdspConn->adspco_Flags			|= ADSPCO_LISTENING;
		pAdspConn->adspco_ListenCtx		= pListenCtx;
		pAdspConn->adspco_ListenCompletion	= CompletionRoutine;

		//	Insert into the listen list.
		pAdspConn->adspco_pNextListen		= pAdspAddr->adspao_pListenConn;
		pAdspAddr->adspao_pListenConn		= pAdspConn;

		//	Inherits the address objects ddp address
		pAdspConn->adspco_pDdpAddr			= pAdspAddr->adspao_pDdpAddr;

		//	Initialize pended sends list
		InitializeListHead(&pAdspConn->adspco_PendedSends);

		error = ATALK_PENDING;
	} while (FALSE);
	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	return error;
}




ATALK_ERROR
AtalkAdspCancelListen(
	IN	PADSP_CONNOBJ			pAdspConn
	)
/*++

Routine Description:

	Cancel a previously posted listen.

Arguments:


Return Value:


--*/
{
	PADSP_ADDROBJ		pAdspAddr	= pAdspConn->adspco_pAssocAddr;
	KIRQL				OldIrql;
	ATALK_ERROR			error		= ATALK_NO_ERROR;
	GENERIC_COMPLETION	completionRoutine = NULL;
	PVOID				completionCtx = NULL;

	ASSERT(VALID_ADSPCO(pAdspConn));
	ASSERT(VALID_ADSPAO(pAdspAddr));
	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	if (!atalkAdspConnDeQueueListenList(pAdspAddr, pAdspConn))
	{
		error = ATALK_INVALID_CONNECTION;
	}
	else
	{
		//	We complete the listen routine
		ASSERT(pAdspConn->adspco_Flags & ADSPCO_LISTENING);
		pAdspConn->adspco_Flags	&= ~ADSPCO_LISTENING;
		completionRoutine	= pAdspConn->adspco_ListenCompletion;
		completionCtx		= pAdspConn->adspco_ListenCtx;
	}
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	if (*completionRoutine != NULL)
	{
		(*completionRoutine)(ATALK_REQUEST_CANCELLED, completionCtx);
	}

	return error;
}




ATALK_ERROR
AtalkAdspPostConnect(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PATALK_ADDR				pRemote_Addr,
	IN	PVOID					pConnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;
	BOOLEAN			DerefConn = FALSE;
	PADSP_ADDROBJ	pAdspAddr = pAdspConn->adspco_pAssocAddr;

	ASSERT(VALID_ADSPCO(pAdspConn));
	ASSERT(VALID_ADSPAO(pAdspAddr));
	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	do
	{
		if ((pAdspConn->adspco_Flags & (ADSPCO_LISTENING	|
										ADSPCO_CONNECTING	|
										ADSPCO_HALF_ACTIVE	|
										ADSPCO_ACTIVE		|
										ADSPCO_ASSOCIATED)) != ADSPCO_ASSOCIATED)
		{
			error = ATALK_INVALID_CONNECTION;
			break;
		}

		//	Verify the address object is not a listener address type.
		if (pAdspAddr->adspao_Flags & ADSPAO_LISTENER)
		{
			error = ATALK_INVALID_ADDRESS;
			break;
		}

		//	Reference the connection for this call and for the timer.
		AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 2, &error);
		if (!ATALK_SUCCESS(error))
		{
			ASSERTMSG("AtalkAdspPostConnect: Connection ref failed\n", 0);
			break;
		}

		DerefConn = TRUE;

		pAdspConn->adspco_LocalConnId = atalkAdspGetNextConnId(pAdspAddr,
															   &error);

		if (ATALK_SUCCESS(error))
		{
			pAdspConn->adspco_Flags |= (ADSPCO_CONNECTING | ADSPCO_OPEN_TIMER);
			pAdspConn->adspco_ConnectCtx		= pConnectCtx;
			pAdspConn->adspco_ConnectCompletion = CompletionRoutine;
			pAdspConn->adspco_RemoteAddr		= *pRemote_Addr;
			pAdspConn->adspco_ConnectAttempts	= ADSP_MAX_OPEN_ATTEMPTS;

			//	Insert into the connect list.
			pAdspConn->adspco_pNextConnect		= pAdspAddr->adspao_pConnectConn;
			pAdspAddr->adspao_pConnectConn		= pAdspConn;
			pAdspAddr->adspao_Flags			   |= ADSPAO_CONNECT;

			pAdspConn->adspco_RecvWindow=
			pAdspConn->adspco_SendQueueMax	=
			pAdspConn->adspco_RecvQueueMax	= ADSP_DEF_SEND_RX_WINDOW_SIZE;

			//	Inherits the address objects ddp address
			pAdspConn->adspco_pDdpAddr			= pAdspAddr->adspao_pDdpAddr;

			//	Initialize pended sends list
			InitializeListHead(&pAdspConn->adspco_PendedSends);

			//	Start the open timer
			AtalkTimerInitialize(&pAdspConn->adspco_OpenTimer,
								 atalkAdspOpenTimer,
								 ADSP_OPEN_INTERVAL);
			AtalkTimerScheduleEvent(&pAdspConn->adspco_OpenTimer);
		}
		else
		{
			ASSERTMSG("AtalkAdspPostConnect: Unable to get conn id\n", 0);
			error = ATALK_RESR_MEM;
			RES_LOG_ERROR();
			break;
		}

	} while (FALSE);
	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		//	Send connect packet to the remote end. This will add its
		//	own references.
		atalkAdspSendOpenControl(pAdspConn);

		error = ATALK_PENDING;
	}
	else
	{
		if (DerefConn)
		{
			//	Remove the reference for timer only if error.
			AtalkAdspConnDereference(pAdspConn);
		}
	}

	if (DerefConn)
	{
		//	Remove the reference for call
		AtalkAdspConnDereference(pAdspConn);
	}

	return error;
}


#define	atalkAdspCompleteQueuedSends(_pAdspConn, _error)								\
	{																					\
		ULONG		writeBufLen;														\
		PVOID		writeCtx;															\
																						\
		while (!IsListEmpty(&(_pAdspConn)->adspco_PendedSends))							\
		{                                                                               \
			writeCtx = LIST_ENTRY_TO_WRITECTX((_pAdspConn)->adspco_PendedSends.Flink);  \
			writeBufLen = WRITECTX_SIZE(writeCtx);                                      \
	                                                                                    \
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,                                     \
					("AtalkAdspCompleteQueuedSends: %lx WriteLen %x\n",                 \
					writeCtx, writeBufLen));                                            \
	                                                                                    \
			RemoveEntryList(WRITECTX_LINKAGE(writeCtx));                                \
	                                                                                    \
			RELEASE_SPIN_LOCK(&(_pAdspConn)->adspco_Lock, OldIrql);                     \
			atalkTdiGenericWriteComplete(_error,                                        \
										 (PAMDL)(WRITECTX_TDI_BUFFER(writeCtx)),        \
										 (USHORT)writeBufLen,                           \
										 WRITECTX(writeCtx));                           \
			ACQUIRE_SPIN_LOCK(&(_pAdspConn)->adspco_Lock, &OldIrql);                    \
		}                                                                               \
	}


ATALK_ERROR
AtalkAdspDisconnect(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	ATALK_DISCONNECT_TYPE	DisconnectType,
	IN	PVOID					pDisconnectCtx,
	IN	GENERIC_COMPLETION		DisconnectRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PAMDL						readBuf					= NULL,
								exReadBuf				= NULL;
	GENERIC_READ_COMPLETION		readCompletion			= NULL,
								exReadCompletion		= NULL;
	PVOID						readCtx					= NULL,
								exReadCtx				= NULL;
	PAMDL						exWriteBuf				= NULL;
	GENERIC_WRITE_COMPLETION	exWriteCompletion		= NULL;
	PVOID						exWriteCtx				= NULL;
	PBYTE						exWriteChBuf			= NULL,
								exRecdBuf				= NULL;
	GENERIC_COMPLETION			completionRoutine		= NULL;
	PVOID						completionCtx			= NULL;
	ATALK_ERROR					error					= ATALK_PENDING;
	BOOLEAN						connTimerCancelled		= FALSE,
								openTimerCancelled	= FALSE,
								sendAttnTimerCancelled	= FALSE,
								rexmitTimerCancelled	= FALSE,
								connectCancelled		= FALSE;
	KIRQL						OldIrql;

	ASSERT(VALID_ADSPCO(pAdspConn));

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("AtalkAdspDisconnectConnection: %lx.%lx\n", pAdspConn, DisconnectType));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);

	//	Support for graceful disconnect. We only drop the received
	//	data when the local end does a disconnect. This will happen
	//	regardless of whether this routine was previously called or
	//	not. Note that attentions are not acknowledged until our client
	//	reads them, so there isnt an issue with them. Also, this means
	//	that we must satisfy a read if disconnect is pending.
	if ((DisconnectType == ATALK_LOCAL_DISCONNECT) ||
		(DisconnectType == ATALK_TIMER_DISCONNECT))
	{
		atalkAdspDiscardFromBufferQueue(&pAdspConn->adspco_RecvQueue,
										atalkAdspBufferQueueSize(&pAdspConn->adspco_RecvQueue),
										NULL,
										DISCONN_STATUS(DisconnectType),
										NULL);
	}

	if ((pAdspConn->adspco_Flags & ADSPCO_DISCONNECTING) == 0)
	{
		if ((pAdspConn->adspco_Flags & (ADSPCO_LISTENING	|
										ADSPCO_CONNECTING	|
										ADSPCO_HALF_ACTIVE	|
										ADSPCO_ACTIVE)) == 0)
		{
			error = ATALK_INVALID_REQUEST;
		}
		else
		{
			pAdspConn->adspco_Flags |= ADSPCO_DISCONNECTING;
			if (DisconnectType == ATALK_LOCAL_DISCONNECT)
				pAdspConn->adspco_Flags |= ADSPCO_LOCAL_DISCONNECT;
			if (DisconnectType == ATALK_REMOTE_DISCONNECT)
				pAdspConn->adspco_Flags |= ADSPCO_REMOTE_DISCONNECT;

			if (pAdspConn->adspco_Flags & ADSPCO_LISTENING)
			{
				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
				AtalkAdspCancelListen(pAdspConn);
				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}
			else if (pAdspConn->adspco_Flags & ADSPCO_CONNECTING)
			{
				//	Cancel open timer
				ASSERT(pAdspConn->adspco_Flags & ADSPCO_OPEN_TIMER);
				openTimerCancelled = AtalkTimerCancelEvent(&pAdspConn->adspco_OpenTimer,
															NULL);

				completionRoutine	= pAdspConn->adspco_ConnectCompletion;
				completionCtx		= pAdspConn->adspco_ConnectCtx;

				//	We can only be here if the connect is not done yet. Complete
				//	as if timer is done, always.
				pAdspConn->adspco_DisconnectStatus = ATALK_TIMEOUT;
				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
				connectCancelled = atalkAdspConnDeQueueConnectList(pAdspConn->adspco_pAssocAddr,
																   pAdspConn);

				if (!connectCancelled)
				{
					completionRoutine	= NULL;
					completionCtx		= NULL;
				}

				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}

			//	Both of the above could have failed as the connection
			//	might have become active before the cancel succeeded.
			//	In that case (or if we were active to begin with), do
			//	a disconnect here.
			if (pAdspConn->adspco_Flags & (ADSPCO_HALF_ACTIVE | ADSPCO_ACTIVE))
			{
				//	Get the completion routines for a pending accept
				if (pAdspConn->adspco_Flags & ADSPCO_ACCEPT_IRP)
				{
					completionRoutine		= pAdspConn->adspco_ListenCompletion;
					completionCtx			= pAdspConn->adspco_ListenCtx;

					//	Dequeue the open request that must be queued on
					//	this connection object to filter duplicates.

					pAdspConn->adspco_Flags	&= ~ADSPCO_ACCEPT_IRP;
				}

				//	First cancel the conection maintainance timer. Only if
				//	we are not called from the timer.
				if ((DisconnectType != ATALK_TIMER_DISCONNECT) &&
					(connTimerCancelled =
						AtalkTimerCancelEvent(&pAdspConn->adspco_ConnTimer,
											  NULL)))
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
							("AtalkAdspDisconnect: Cancelled timer successfully\n"));
				}

				//	Cancel retransmit timer if started. Could be called from
				//	OpenTimer.
				if	(pAdspConn->adspco_Flags & ADSPCO_RETRANSMIT_TIMER)
				{
					rexmitTimerCancelled =
						AtalkTimerCancelEvent(&pAdspConn->adspco_RetransmitTimer,
											  NULL);
				}

				//	Remember completion routines as appropriate.
				if (DisconnectType == ATALK_INDICATE_DISCONNECT)
				{
					if (pAdspConn->adspco_DisconnectInform == NULL)
					{
						pAdspConn->adspco_DisconnectInform		= DisconnectRoutine;
						pAdspConn->adspco_DisconnectInformCtx	= pDisconnectCtx;
					}
					else
					{
						DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
								("AtalkAdspDisconnect: duplicate disc comp rou%lx\n", pAdspConn));

						error = ATALK_TOO_MANY_COMMANDS;
					}
				}
				else if (DisconnectType == ATALK_LOCAL_DISCONNECT)
				{
					//	Replace completion routines only if previous ones are
					//	NULL.
					if (*pAdspConn->adspco_DisconnectCompletion == NULL)
					{
						pAdspConn->adspco_DisconnectCompletion	= DisconnectRoutine;
						pAdspConn->adspco_DisconnectCtx			= pDisconnectCtx;
					}
					else
					{
						DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
								("AtalkAdspDisconnect: duplicate disc comp rou%lx\n", pAdspConn));

						error = ATALK_TOO_MANY_COMMANDS;
					}
				}

				//	Figure out the disconnect status and remember it in the
				//	connection object.
				pAdspConn->adspco_DisconnectStatus = DISCONN_STATUS(DisconnectType);

				if (pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD)
				{
					exRecdBuf			= pAdspConn->adspco_ExRecdData;
					pAdspConn->adspco_Flags	&= ~ADSPCO_ATTN_DATA_RECD;
				}

				//	Is there a pending send attention?
				if (pAdspConn->adspco_Flags & ADSPCO_EXSEND_IN_PROGRESS)
				{
					exWriteCompletion	= pAdspConn->adspco_ExWriteCompletion;
					exWriteCtx			= pAdspConn->adspco_ExWriteCtx;
					exWriteBuf			= pAdspConn->adspco_ExWriteBuf;
					exWriteChBuf		= pAdspConn->adspco_ExWriteChBuf;

					ASSERT(exWriteChBuf	!= NULL);
					sendAttnTimerCancelled =
							AtalkTimerCancelEvent(&pAdspConn->adspco_ExRetryTimer,
												  NULL);

					pAdspConn->adspco_Flags &= ~ADSPCO_EXSEND_IN_PROGRESS;
				}


				//	Are there any pending receives?
				if (pAdspConn->adspco_Flags & ADSPCO_READ_PENDING)
				{
					readBuf			= pAdspConn->adspco_ReadBuf;
					readCompletion	= pAdspConn->adspco_ReadCompletion;
					readCtx			= pAdspConn->adspco_ReadCtx;

					pAdspConn->adspco_Flags &= ~ADSPCO_READ_PENDING;
				}

				if (pAdspConn->adspco_Flags & ADSPCO_EXREAD_PENDING)
				{
					exReadBuf			= pAdspConn->adspco_ExReadBuf;
					exReadCompletion	= pAdspConn->adspco_ExReadCompletion;
					exReadCtx			= pAdspConn->adspco_ExReadCtx;

					pAdspConn->adspco_Flags &= ~ADSPCO_EXREAD_PENDING;
				}

				//	Discard the send queue. This will complete pending sends.
				atalkAdspDiscardFromBufferQueue(&pAdspConn->adspco_SendQueue,
												atalkAdspBufferQueueSize(&pAdspConn->adspco_SendQueue),
												NULL,
												pAdspConn->adspco_DisconnectStatus,
												pAdspConn);

				atalkAdspCompleteQueuedSends(pAdspConn,
											 pAdspConn->adspco_DisconnectStatus);

				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

				//	Send out disconnect packet if this was a timer or local close.
				if ((DisconnectType == ATALK_LOCAL_DISCONNECT) ||
					(DisconnectType == ATALK_TIMER_DISCONNECT))
				{

					ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
					atalkAdspSendControl(pAdspConn,
										 ADSP_CONTROL_FLAG + ADSP_CLOSE_CONN_CODE);
					RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
				}

				//	Call the send attention completion
				if (*exWriteCompletion != NULL)
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkDisconnect: ExWrite\n"));

					(*exWriteCompletion)(pAdspConn->adspco_DisconnectStatus,
										 exWriteBuf,
										 0,
										 exWriteCtx);

					AtalkFreeMemory(exWriteChBuf);
				}

				//	If we had received an attention packet, and had
				//	saved it away, free it.
				if (exRecdBuf != NULL)
				{
					AtalkFreeMemory(exRecdBuf);
				}

				if (*readCompletion != NULL)
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkDisconnect: Read %lx\n", pAdspConn->adspco_DisconnectStatus));

					(*readCompletion)(pAdspConn->adspco_DisconnectStatus,
									  readBuf,
									  0,
									  0,
									  readCtx);

					//	Deref connection for the read
					AtalkAdspConnDereference(pAdspConn);
				}

				if (*exReadCompletion != NULL)
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkDisconnect: ExRead\n"));

					(*exReadCompletion)(pAdspConn->adspco_DisconnectStatus,
										exReadBuf,
										0,
										0,
										exReadCtx);

					//	Deref connection for the read
					AtalkAdspConnDereference(pAdspConn);
				}

				//	Call the disconnect indication routine if present for a timer/
				//	remote disconnect.
				if ((DisconnectType == ATALK_REMOTE_DISCONNECT) ||
					(DisconnectType == ATALK_TIMER_DISCONNECT))
				{
					PTDI_IND_DISCONNECT	discHandler;
					PVOID					discCtx;
					PADSP_ADDROBJ			pAdspAddr = pAdspConn->adspco_pAssocAddr;

					ASSERT(VALID_ADSPAO(pAdspAddr));

					//	Acquire lock so we get a consistent handler/ctx.
					ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
					discHandler = pAdspAddr->adspao_DisconnectHandler;
					discCtx	= pAdspAddr->adspao_DisconnectHandlerCtx;
					RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

					if (*discHandler != NULL)
					{
						(*discHandler)(discCtx,
									   pAdspConn->adspco_ConnCtx,
									   0,						//	DisconnectDataLength
									   NULL,					//	DisconnectData
									   0,						//	DisconnectInfoLength
									   NULL,					//	DisconnectInfo
									   TDI_DISCONNECT_ABORT);	//	Disconnect flags.
					}
				}

				//	Stop the ddp address.
				AtalkDdpCleanupAddress(pAdspConn->adspco_pDdpAddr);
				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}
		}
	}
	else
	{
		//	Do we need to remember the completion routines?
		//	Yes, if this is a disconnect or a indicate disconnect request,
		//	and our current disconnect was started due to the address object
		//	being closed.
		if (DisconnectType == ATALK_INDICATE_DISCONNECT)
		{
			if (pAdspConn->adspco_DisconnectInform == NULL)
			{
				pAdspConn->adspco_DisconnectInform		= DisconnectRoutine;
				pAdspConn->adspco_DisconnectInformCtx	= pDisconnectCtx;
			}
			else
			{
				error = ATALK_TOO_MANY_COMMANDS;
			}
		}
		else if (DisconnectType == ATALK_LOCAL_DISCONNECT)
		{
			//	Replace completion routines only if previous ones are
			//	NULL.
			if (*pAdspConn->adspco_DisconnectCompletion == NULL)
			{
				pAdspConn->adspco_DisconnectCompletion	= DisconnectRoutine;
				pAdspConn->adspco_DisconnectCtx			= pDisconnectCtx;
			}
			else
			{
				error = ATALK_TOO_MANY_COMMANDS;
			}
		}
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	//	If there was a completion routine to call, call it now.
	if (*completionRoutine != NULL)
	{
		(*completionRoutine)(pAdspConn->adspco_DisconnectStatus,
							 completionCtx);
	}

	//	If we cancelled any timers, remove their references.
	if (connTimerCancelled)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	if (sendAttnTimerCancelled)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	if (openTimerCancelled)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	if (rexmitTimerCancelled)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	return error;
}




ATALK_ERROR
AtalkAdspRead(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PAMDL					pReadBuf,
	IN	USHORT					ReadBufLen,
	IN	ULONG					ReadFlags,
	IN	PVOID					pReadCtx,
	IN	GENERIC_READ_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	ATALK_ERROR		error;

	ASSERT(VALID_ADSPCO(pAdspConn));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	do
	{
		//	We allow reads when disconnecting if the receive data
		//	queue is non-empty. Since none of the receive chunks ref
		//	the connection, the active flag and the disconnect
		//	flags could have gone away. So we cue of the receive buffer
		//	size. We also dont allow exdata recvs unless we are active.
		if (((pAdspConn->adspco_Flags & (ADSPCO_CLOSING | ADSPCO_STOPPING)))	||
			((((pAdspConn->adspco_Flags & ADSPCO_ACTIVE) == 0) ||
			   (pAdspConn->adspco_Flags & ADSPCO_DISCONNECTING)) &&
				(((atalkAdspBufferQueueSize(&pAdspConn->adspco_RecvQueue) == 0)) ||
				 (ReadFlags & TDI_RECEIVE_EXPEDITED))))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
					("AtalkAdspRead: Failing on %lx Flg %lx.%lx\n",
					pAdspConn, pAdspConn->adspco_Flags, ReadFlags));

			error = ATALK_ADSP_CONN_NOT_ACTIVE;
			break;
		}

		//	Depending on the kind of read we are posting...
		if (((ReadFlags & TDI_RECEIVE_NORMAL) &&
			 (pAdspConn->adspco_Flags & ADSPCO_READ_PENDING)) ||
			 ((ReadFlags & TDI_RECEIVE_EXPEDITED) &&
			  (pAdspConn->adspco_Flags & ADSPCO_EXREAD_PENDING)))
		{
			error = ATALK_TOO_MANY_COMMANDS;
			break;
		}

		AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspRead: ConnRef Failing on %lx Flg %lx.%lx\n",
					pAdspConn, pAdspConn->adspco_Flags, ReadFlags));
			break;
		}

		//	Remember the read completion information
		if (ReadFlags & TDI_RECEIVE_NORMAL)
		{
			pAdspConn->adspco_Flags			   |= ADSPCO_READ_PENDING;
			pAdspConn->adspco_ReadFlags			= ReadFlags;
			pAdspConn->adspco_ReadBuf			= pReadBuf;
			pAdspConn->adspco_ReadBufLen		= ReadBufLen;
			pAdspConn->adspco_ReadCompletion	= CompletionRoutine;
			pAdspConn->adspco_ReadCtx			= pReadCtx;
		}
		else
		{
			ASSERT(ReadFlags & TDI_RECEIVE_EXPEDITED);
			pAdspConn->adspco_Flags			   |= ADSPCO_EXREAD_PENDING;
			pAdspConn->adspco_ExReadFlags		= ReadFlags;
			pAdspConn->adspco_ExReadBuf			= pReadBuf;
			pAdspConn->adspco_ExReadBufLen		= ReadBufLen;
			pAdspConn->adspco_ExReadCompletion	= CompletionRoutine;
			pAdspConn->adspco_ExReadCtx			= pReadCtx;
		}
	} while (FALSE);

	if (ATALK_SUCCESS(error))
	{
		//	Try to complete the read. This will also handle received
		//	attention data.
		atalkAdspRecvData(pAdspConn);
		error = ATALK_PENDING;
	}

	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
	return error;
}




VOID
AtalkAdspProcessQueuedSend(
	IN	PADSP_CONNOBJ				pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG			sendSize, windowSize, writeBufLen, writeFlags;
	KIRQL			OldIrql;
	PVOID			writeCtx;
	ATALK_ERROR		error;
	BOOLEAN			eom;
	PBUFFER_CHUNK	pChunk	  = NULL;

	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID			sendPossibleHandlerCtx;

	//	Walk through pended list.
	while (!IsListEmpty(&pAdspConn->adspco_PendedSends))
	{
		writeCtx = LIST_ENTRY_TO_WRITECTX(pAdspConn->adspco_PendedSends.Flink);
		writeBufLen = WRITECTX_SIZE(writeCtx);
		writeFlags	= WRITECTX_FLAGS(writeCtx);

		eom = (writeFlags & TDI_SEND_PARTIAL) ? FALSE : TRUE;
		eom = (eom && (pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE));

		windowSize	= (LONG)(pAdspConn->adspco_SendWindowSeq	-
							 pAdspConn->adspco_SendSeq			+
							 (LONG)1);

		sendSize =	MIN(atalkAdspMaxSendSize(pAdspConn), windowSize);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
				("AtalkAdspProcessQueuedSend: %lx SendSize %lx, WriteBufLen %x Flags %lx\n",
				writeCtx, sendSize, writeBufLen, writeFlags));

		//	While looping through requests, we might exhaust window.
		if (sendSize == 0)
		{
			//	Call send possible handler indicating sends are not ok.
			//	Needs to be within spinlock to avoid raceconditions where
			//	an ack has come in and opened the window. And it needs to
			//	be before atalkAdspSendData() as that will release the lock.
			sendPossibleHandler		=
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandler;
			sendPossibleHandlerCtx	=
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandlerCtx;

			if (*sendPossibleHandler != NULL)
			{
				(*sendPossibleHandler)(sendPossibleHandlerCtx,
									   pAdspConn->adspco_ConnCtx,
									   0);

				pAdspConn->adspco_Flags	|= ADSPCO_SEND_WINDOW_CLOSED;
			}
			break;
		}

		//	!!!	The client can do a send with 0 bytes and eom only also.
		if ((ULONG)(writeBufLen + BYTECOUNT(eom)) > sendSize)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
					("AtalkAdspProcessQueuedSend: WriteBufLen %lx > sendsize %lx\n",
					writeBufLen, sendSize));

			//	Adjust send to send as much as it can. Winsock loop will pend
			//	it again with remaining data.
			writeBufLen = (USHORT)(sendSize - BYTECOUNT(eom));

			//	If we hit the weird case where now we are trying to send 0 bytes and
			//	no eom, while the actual send does have an eom, then we just wait
			//	for window to open up more.
			if (eom && (writeBufLen == 0))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
						("AtalkAdspProcessQueuedSend: WriteBufLen %lx.%d.%lx %lx\n",
						writeBufLen, eom, sendSize, pAdspConn));
				break;
			}

			ASSERT(writeBufLen > 0);
			eom	= FALSE;
		}

		ASSERT((writeBufLen > 0) || eom);

		//	Yippee, can send it now. Either it goes in send queue or is completed
		//	right away.
		RemoveEntryList(WRITECTX_LINKAGE(writeCtx));

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
				("AtalkAdspProcessQueuedSend: Processing queued send %lx.%lx\n",
				pAdspConn, writeCtx));

		//	Think positive! Assume everything will go well and allocate
		//	the buffer chunk that would be needed for this data. Copy the
		//	data into the buffer chunk. We cant do this in the beginning as
		//	we need to get WriteBufLen set up.
		pChunk = (PBUFFER_CHUNK)
					atalkAdspAllocCopyChunk((PAMDL)(WRITECTX_TDI_BUFFER(writeCtx)),
											(USHORT)writeBufLen,
											eom,
											FALSE);

		error = ATALK_RESR_MEM;
		if (pChunk != NULL)
		{
			//	Set the completion information in the chunk. This will
			//	be called when the last reference on the chunk goes away.
			pChunk->bc_Flags			|= BC_SEND;
			pChunk->bc_WriteBuf			 = (PAMDL)(WRITECTX_TDI_BUFFER(writeCtx));
			pChunk->bc_WriteCompletion	 = atalkTdiGenericWriteComplete;
			pChunk->bc_WriteCtx			 = writeCtx;
			pChunk->bc_ConnObj			 = pAdspConn;

			atalkAdspAddToBufferQueue(&pAdspConn->adspco_SendQueue,
									  pChunk,
									  &pAdspConn->adspco_NextSendQueue);

			//	Try to send the data
			atalkAdspSendData(pAdspConn);
			error = ATALK_PENDING;
		}

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspProcessQueuedSend: Error queued send %lx.%lx\n",
					pAdspConn, writeCtx));

#if DBG
            (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
			//	Complete send request with insufficient resources error.
			RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
			atalkTdiGenericWriteComplete(error,
										 (PAMDL)(WRITECTX_TDI_BUFFER(writeCtx)),
										 (USHORT)writeBufLen,
										 WRITECTX(writeCtx));
			ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
            (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif
		}
	}
}




ATALK_ERROR
AtalkAdspWrite(
	IN	PADSP_CONNOBJ				pAdspConn,
	IN	PAMDL						pWriteBuf,
	IN	USHORT						WriteBufLen,
	IN	ULONG						SendFlags,
	IN	PVOID						pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	BOOLEAN					eom;
	ULONG					sendSize, windowSize;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID					sendPossibleHandlerCtx;
	KIRQL					OldIrql;
	PBUFFER_CHUNK			pChunk	  = NULL;
	BOOLEAN					DerefConn = FALSE,
							callComp  = FALSE;


	ASSERT(VALID_ADSPCO(pAdspConn));

	eom = (SendFlags & TDI_SEND_PARTIAL) ? FALSE : TRUE;
	if ((WriteBufLen == 0) && !eom)
	{
		return ATALK_BUFFER_TOO_SMALL;
	}

	if (SendFlags & TDI_SEND_EXPEDITED)
	{
		return (atalkAdspSendExpedited(pAdspConn,
									   pWriteBuf,
									   WriteBufLen,
									   SendFlags,
									   pWriteCtx,
									   CompletionRoutine));
	}

	//	We atleast have one byte of data or eom to send.
	ASSERT(eom || (WriteBufLen != 0));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	do
	{
		if ((pAdspConn->adspco_Flags & (ADSPCO_ACTIVE	|
										ADSPCO_CLOSING	|
										ADSPCO_STOPPING	|
										ADSPCO_DISCONNECTING)) != ADSPCO_ACTIVE)
		{
			error = ATALK_ADSP_CONN_NOT_ACTIVE;
			break;
		}

		if (pAdspConn->adspco_Flags & ADSPCO_SEND_IN_PROGRESS)
		{
			error = ATALK_TOO_MANY_COMMANDS;
			break;
		}

		AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		eom = (eom && (pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE));

		DerefConn = TRUE;

		windowSize	= (LONG)(pAdspConn->adspco_SendWindowSeq	-
							 pAdspConn->adspco_SendSeq			+
							 (LONG)1);

		sendSize =	MIN(atalkAdspMaxSendSize(pAdspConn), windowSize);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("AtalkAdspWrite: SendSize %lx, WriteBufLen %x\n", sendSize, WriteBufLen));

		//	For a blocking send, queue in any sends that exceed window size.
		if ((SendFlags & TDI_SEND_NON_BLOCKING) == 0)
		{
			if ((!IsListEmpty(&pAdspConn->adspco_PendedSends)) ||
				(sendSize < (WriteBufLen + BYTECOUNT(eom))))
			{
				//	Stop sends whenever a send gets queued.
				sendPossibleHandler		=
							pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandler;
				sendPossibleHandlerCtx	=
							pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandlerCtx;

				if (*sendPossibleHandler != NULL)
				{
					(*sendPossibleHandler)(sendPossibleHandlerCtx,
										   pAdspConn->adspco_ConnCtx,
										   0);

					pAdspConn->adspco_Flags	|= ADSPCO_SEND_WINDOW_CLOSED;
				}

				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("AtalkAdspWrite: Wdw %lx, WriteLen %x on BLOCKING QUEUEING !\n",
						sendSize, WriteBufLen));

				InsertTailList(&pAdspConn->adspco_PendedSends, WRITECTX_LINKAGE(pWriteCtx));

				if (sendSize > 0)
				{
					AtalkAdspProcessQueuedSend(pAdspConn);
				}
				error = ATALK_PENDING;
				break;
			}
		}
		else
		{
			//	If there are pended blocking sends complete them with
			//	ATALK_REQUEST_NOT_ACCEPTED (WSAEWOULDBLOCK).
			//
			//	!!!This is data corruption, but app shouldn't be doing this.
			//
			if (!IsListEmpty(&pAdspConn->adspco_PendedSends))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
						("AtalkAdspWrite: ABORTING PENDED SENDS CORRUPTION %lx\n", pAdspConn));

				atalkAdspCompleteQueuedSends(pAdspConn, ATALK_REQUEST_NOT_ACCEPTED);
			}
		}

		if (sendSize == 0)
		{
			//	Call send possible handler indicating sends are not ok.
			//	Needs to be within spinlock to avoid raceconditions where
			//	an ack has come in and opened the window. And it needs to
			//	be before atalkAdspSendData() as that will release the lock.
			sendPossibleHandler		=
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandler;
			sendPossibleHandlerCtx	=
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandlerCtx;

			if (*sendPossibleHandler != NULL)
			{
				(*sendPossibleHandler)(sendPossibleHandlerCtx,
									   pAdspConn->adspco_ConnCtx,
									   0);

				pAdspConn->adspco_Flags	|= ADSPCO_SEND_WINDOW_CLOSED;
			}

			if (SendFlags & TDI_SEND_NON_BLOCKING)
			{
				//	!!!NOTE!!!
				//	To avoid the race condition in AFD where an incoming
				//	send data indication setting send's possible to true
				//	is overwritten by this read's unwinding and setting it
				//	to false, we return ATALK_REQUEST_NOT_ACCEPTED, which
				//	will map to STATUS_REQUEST_NOT_ACCEPTED and then to
				//	WSAEWOULDBLOCK.
				//	error = ATALK_DEVICE_NOT_READY;

				error = ATALK_REQUEST_NOT_ACCEPTED;
			}

			//	We have no open send window, try to send data in the retransmit
			//	queue.
			atalkAdspSendData(pAdspConn);
			break;
		}

		//	Because of the sequence numbers, we need to copy the data
		//	into our buffers while holding the spinlock. If we cant send it all
		//	send as much as we can.

		//	!!! TDI doesn't count the eom as taking up a count, so we need to
		//		make allowances for that. If we are able to send just the data
		//		but not the eom, we should send one less byte than requested, so
		//		the client retries again.

		//	!!!	The client can do a send with 0 bytes and eom only also.
		if ((ULONG)(WriteBufLen + BYTECOUNT(eom)) > sendSize)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("AtalkAdspSend: WriteBufLen being decreased %x.%lx\n",
					WriteBufLen, sendSize-BYTECOUNT(eom)));

			WriteBufLen = (USHORT)(sendSize - BYTECOUNT(eom));
			eom			= FALSE;
		}

		if ((WriteBufLen == 0) && !eom)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspSend: SEND 0 bytes NO EOM %lx\n", pAdspConn));

			callComp	= TRUE;
			error		= ATALK_PENDING;
			break;
		}

		//	pAdspConn->adspco_Flags	|= ADSPCO_SEND_IN_PROGRESS;
		//	If we release the spin lock here we have a race condition
		//	where the sendsize is still not accounting for this send,
		//	and so another posted send could come in when it really
		//	shouldn't. We avoid it using the flag above, which when
		//	set will prevent further sends from happening.
		//	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

		//	Think positive! Assume everything will go well and allocate
		//	the buffer chunk that would be needed for this data. Copy the
		//	data into the buffer chunk. We cant do this in the beginning as
		//	we need to get WriteBufLen set up.
		pChunk = (PBUFFER_CHUNK)atalkAdspAllocCopyChunk(pWriteBuf,
														WriteBufLen,
														eom,
														FALSE);

		//	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		//	pAdspConn->adspco_Flags	&= ~ADSPCO_SEND_IN_PROGRESS;

		error = ATALK_RESR_MEM;
		if (pChunk != NULL)
		{
			//	Set the completion information in the chunk. This will
			//	be called when the last reference on the chunk goes away.
			pChunk->bc_Flags			|= BC_SEND;
			pChunk->bc_WriteBuf			 = pWriteBuf;
			pChunk->bc_WriteCompletion	 = CompletionRoutine;
			pChunk->bc_WriteCtx			 = pWriteCtx;
			pChunk->bc_ConnObj			 = pAdspConn;

			atalkAdspAddToBufferQueue(&pAdspConn->adspco_SendQueue,
									  pChunk,
									  &pAdspConn->adspco_NextSendQueue);

			//	Try to send the data
			atalkAdspSendData(pAdspConn);
			error = ATALK_PENDING;
		}
	} while (FALSE);

	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if ((error == ATALK_PENDING) && callComp)
	{
		ASSERT(WriteBufLen	== 0);
		ASSERT(pChunk		== NULL);

		(*CompletionRoutine)(ATALK_NO_ERROR,
							 pWriteBuf,
							 WriteBufLen,
							 pWriteCtx);
	}
	else if (!ATALK_SUCCESS(error) && (pChunk != NULL))
	{
	   AtalkFreeMemory(pChunk);
	}

	if (DerefConn)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	return error;
}




VOID
AtalkAdspQuery(
	IN	PVOID			pObject,
	IN	ULONG			ObjectType,
	IN	PAMDL			pAmdl,
	OUT	PULONG			BytesWritten
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	switch (ObjectType)
	{
	case TDI_TRANSPORT_ADDRESS_FILE :
		ASSERT(VALID_ADSPAO((PADSP_ADDROBJ)pObject));
		AtalkDdpQuery(AtalkAdspGetDdpAddress((PADSP_ADDROBJ)pObject),
					  pAmdl,
					  BytesWritten);

		break;

	case TDI_CONNECTION_FILE :
		{
			KIRQL			OldIrql;
			PADSP_CONNOBJ	pAdspConn;

			pAdspConn	= (PADSP_CONNOBJ)pObject;
			ASSERT(VALID_ADSPCO(pAdspConn));

			*BytesWritten = 0;
			//	Get the address from the associated address if any.
			ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			if (pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED)
			{
				AtalkDdpQuery(AtalkAdspGetDdpAddress(pAdspConn->adspco_pAssocAddr),
							  pAmdl,
							  BytesWritten);
			}
			RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
		}
		break;

	case TDI_CONTROL_CHANNEL_FILE :
	default:
		break;
	}

}



//
//	ADSP PACKET IN (HANDLE ROUTINES)
//

VOID
atalkAdspPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDestAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PADSP_ADDROBJ		pAdspAddr,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PADSP_CONNOBJ	pAdspConn;
	USHORT			remoteConnId;
	ULONG			remoteFirstByteSeq, remoteNextRecvSeq;
	LONG			remoteRecvWindow;
	BYTE			descriptor, controlCode;
	BOOLEAN			DerefConn = FALSE;

	do
	{
		if ((!ATALK_SUCCESS(ErrorCode))	||
			(DdpType != DDPPROTO_ADSP)	||
			(PktLen  <  ADSP_DATA_OFF))
		{
			ASSERT(0);
			break;
		}

		//	Decode the header.
		atalkAdspDecodeHeader(pPkt,
							  &remoteConnId,
							  &remoteFirstByteSeq,
							  &remoteNextRecvSeq,
							  &remoteRecvWindow,
							  &descriptor);

		controlCode = (descriptor & ADSP_CONTROL_MASK);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspPacketIn: Recd packet %lx.%x\n", remoteConnId, descriptor));


		//	If this is a open connection request we handle it in here,
		//	else we find the connection it is meant for and pass it on.
		if ((descriptor & ADSP_CONTROL_FLAG) &&
			(controlCode == ADSP_OPENCONN_REQ_CODE))
		{
			//	Handle the open connection.
			if (PktLen < (ADSP_NEXT_ATTEN_SEQNUM_OFF + sizeof(ULONG)))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
						("atalkAdspPacketIn: Incorrect len for pkt\n"));

				break;
			}

			atalkAdspHandleOpenReq(pAdspAddr,
								   pPkt,
								   PktLen,
								   pSrcAddr,
								   remoteConnId,
								   remoteFirstByteSeq,
								   remoteNextRecvSeq,
								   remoteRecvWindow,
								   descriptor);

			break;
		}


		if ((descriptor & ADSP_CONTROL_FLAG) &&
			(controlCode >	ADSP_OPENCONN_REQ_CODE) &&
			(controlCode <= ADSP_OPENCONN_DENY_CODE))
		{
			//	Handle the open connection.
			if (PktLen < (ADSP_NEXT_ATTEN_SEQNUM_OFF + sizeof(ULONG)))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
						("atalkAdspPacketIn: Incorrect len for pkt\n"));
				break;
			}

			atalkAdspHandleOpenControl(pAdspAddr,
									   pPkt,
									   PktLen,
									   pSrcAddr,
									   remoteConnId,
									   remoteFirstByteSeq,
									   remoteNextRecvSeq,
									   remoteRecvWindow,
									   descriptor);

			break;
		}

		//	This was not an open connection request, find the connection
		//	this is meant for.
		ACQUIRE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);
		atalkAdspConnRefBySrcAddr(pAdspAddr,
								  pSrcAddr,
								  remoteConnId,
								  &pAdspConn,
								  &error);
		RELEASE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);

		if (!ATALK_SUCCESS(error))
		{
			//	Not one of our active/half open connections.
			break;
		}

		DerefConn = TRUE;
		pAdspConn->adspco_LastContactTime	= AtalkGetCurrentTick();

		if (descriptor & ADSP_ATTEN_FLAG)
		{
			//	Handle attention packets
			atalkAdspHandleAttn(pAdspConn,
								pPkt,
								PktLen,
								pSrcAddr,
								remoteFirstByteSeq,
								remoteNextRecvSeq,
								remoteRecvWindow,
								descriptor);
			break;
		}

		//	Check if we got a piggybacked ack. This will call the
		//	send possible handler too if the send window opens up.
		//	It will also change the send sequence number.
		atalkAdspHandlePiggyBackAck(pAdspConn,
									remoteNextRecvSeq,
									remoteRecvWindow);

		if (descriptor & ADSP_CONTROL_FLAG)
		{
			//	Handle the other control packets
			atalkAdspHandleControl(pAdspConn,
								   pPkt,
								   PktLen,
								   pSrcAddr,
								   remoteFirstByteSeq,
								   remoteNextRecvSeq,
								   remoteRecvWindow,
								   descriptor);

			break;
		}

		//	If we got something that didnt fit any of the above, we might
		//	have some data.
		atalkAdspHandleData(pAdspConn,
							pPkt,
							PktLen,
							pSrcAddr,
							remoteFirstByteSeq,
							remoteNextRecvSeq,
							remoteRecvWindow,
							descriptor);
	} while (FALSE);

	if (DerefConn)
	{
		AtalkAdspConnDereference(pAdspConn);
	}
}



LOCAL VOID
atalkAdspHandleOpenControl(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PBYTE			pPkt,
	IN	USHORT			PktLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	USHORT			RemoteConnId,
	IN	ULONG			RemoteFirstByteSeq,
	IN	ULONG			RemoteNextRecvSeq,
	IN	ULONG			RemoteRecvWindow,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:

	!!!WE ONLY SUPPORT THE LISTENER PARADIGM FOR CONNECTION ESTABLISHMENT!!!
	!!!A OpenConnectionRequest will always open a new connection! Remote !!!
	!!!MUST send a Open Connection Request & Acknowledgement			 !!!

Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ		pAdspConn;
	BYTE				controlCode;
	USHORT				adspVersionStamp, destConnId;
	KIRQL				OldIrql;
	ULONG				recvAttnSeq;
	PADSP_OPEN_REQ		pOpenReq			= NULL;
	ATALK_ERROR			error				= ATALK_NO_ERROR;
	GENERIC_COMPLETION	completionRoutine	= NULL;
	PVOID				completionCtx		= NULL;
	BOOLEAN				sendAck			= FALSE,
						openTimerCancelled	= FALSE,
						relAddrLock		= FALSE;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler	= NULL;
	PVOID			sendPossibleHandlerCtx;

	controlCode = (Descriptor & ADSP_CONTROL_MASK);

	ASSERT(controlCode !=  ADSP_OPENCONN_REQ_CODE);

	//	Get the other information from the adsp header
	GETSHORT2SHORT(&adspVersionStamp,
				   pPkt + ADSP_VERSION_STAMP_OFF);

	GETSHORT2SHORT(&destConnId,
				   pPkt + ADSP_DEST_CONNID_OFF);

	GETDWORD2DWORD(&recvAttnSeq,
				   pPkt + ADSP_NEXT_ATTEN_SEQNUM_OFF);

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspHandleOpenControl: OpenControl %lx.%lx.%lx.%lx.%lx\n",
			RemoteConnId, RemoteFirstByteSeq, RemoteNextRecvSeq, RemoteRecvWindow, recvAttnSeq));

	//	Drop request if version isnt right.
	if (adspVersionStamp != ADSP_VERSION)
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspPacketIn: Version incorrect\n"));

		return;
	}

	//	Find the connection, since this could be a deny, we cant
	//	use the remote values as they would not be valid. The
	//	connection should be in the connecting list for a reqandack/deny.
	//	For ack the remote values should be valid and the
	//	connection will be in the active list with the flags indicating
	//	that it is only half open.

	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	relAddrLock = TRUE;

	if (controlCode == ADSP_OPENCONN_ACK_CODE)
	{
		//	The connection will be in the active list.
		atalkAdspConnRefBySrcAddr(pAdspAddr,
								  pSrcAddr,
								  RemoteConnId,
								  &pAdspConn,
								  &error);
	}
	else
	{
		atalkAdspConnFindInConnect(pAdspAddr,
								   destConnId,
								   pSrcAddr,
								   &pAdspConn,
								   &error);
	}

	if (ATALK_SUCCESS(error))
	{
		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

		switch (controlCode)
		{
		case ADSP_OPENCONN_DENY_CODE:

			//	Cancel open timer if this was a CONNECTING connection. If
			//	we had send out a ACK&REQ and then received a DENY just drop
			//	this and let the connection age out.
			if ((pAdspConn->adspco_Flags & ADSPCO_CONNECTING) &&
				((pAdspConn->adspco_Flags & ADSPCO_DISCONNECTING) == 0))
			{
				ASSERT(pAdspConn->adspco_Flags & ADSPCO_OPEN_TIMER);

				//	Turn of the connecting flag as we are completing the request.
				//	If OpenTimer calls disconnect, then we wont end up trying to
				//	complete the request twice.
				pAdspConn->adspco_Flags &=	~ADSPCO_CONNECTING;
				openTimerCancelled = AtalkTimerCancelEvent(&pAdspConn->adspco_OpenTimer,
															NULL);

				//	Connection Denied.
				atalkAdspConnDeQueueConnectList(pAdspAddr, pAdspConn);
				completionRoutine	= pAdspConn->adspco_ConnectCompletion;
				completionCtx		= pAdspConn->adspco_ConnectCtx;
				error				= ATALK_ADSP_SERVER_BUSY;
			}

			break;

		case ADSP_OPENCONN_REQANDACK_CODE:

			//	Connection Request Accepted By Remote. If we are disconnecting
			//	drop this.
			if ((pAdspConn->adspco_Flags & (ADSPCO_SEEN_REMOTE_OPEN |
											ADSPCO_DISCONNECTING)) == 0)
			{
				ULONG	index;

				//	If the connecting connection has not already seen
				//	the remote open request, then get all the relevent
				//	remote info for the connection.
				pAdspConn->adspco_Flags |= (ADSPCO_SEEN_REMOTE_OPEN |
											ADSPCO_HALF_ACTIVE);

				atalkAdspConnDeQueueConnectList(pAdspAddr, pAdspConn);

				pAdspConn->adspco_RemoteConnId	= RemoteConnId;
				pAdspConn->adspco_RemoteAddr	= *pSrcAddr;
				pAdspConn->adspco_SendSeq		= RemoteNextRecvSeq;
				pAdspConn->adspco_FirstRtmtSeq	= RemoteNextRecvSeq;
				pAdspConn->adspco_RecvAttnSeq	= recvAttnSeq;
				pAdspConn->adspco_SendWindowSeq	= RemoteNextRecvSeq +
												  RemoteRecvWindow	-
												  (ULONG)1;

				//	Thread the connection object into addr lookup by session id.
				index	= HASH_ID_SRCADDR(RemoteConnId, pSrcAddr);

				index  %= ADSP_CONN_HASH_SIZE;

				pAdspConn->adspco_pNextActive = pAdspAddr->adspao_pActiveHash[index];
				pAdspAddr->adspao_pActiveHash[index] = pAdspConn;
			}
			else
			{
				//	We've already seen the remote request.
				break;
			}

		case ADSP_OPENCONN_ACK_CODE:

			//	Ensure we are not closing, so we can reference properly. Drop
			//	if we are disconnecting.
			if ((pAdspConn->adspco_Flags & ADSPCO_HALF_ACTIVE) &&
				((pAdspConn->adspco_Flags & (	ADSPCO_DISCONNECTING	|
												ADSPCO_STOPPING		|
												ADSPCO_CLOSING)) == 0))
			{
				//	Cancel open timer
				ASSERT(pAdspConn->adspco_Flags & ADSPCO_OPEN_TIMER);
				openTimerCancelled = AtalkTimerCancelEvent(&pAdspConn->adspco_OpenTimer,
															NULL);

				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkAdspHandleOpenControl: OpenTimer %d\n", openTimerCancelled));

				pAdspConn->adspco_Flags &= ~(ADSPCO_HALF_ACTIVE |
											 ADSPCO_CONNECTING	|
											 ADSPCO_LISTENING);

				pAdspConn->adspco_Flags |=	ADSPCO_ACTIVE;

				//	Prepare to say sends ok
				sendPossibleHandler	=
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandler;
				sendPossibleHandlerCtx =
						pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandlerCtx;

				//	Get the completion routines
				if (pAdspConn->adspco_Flags &
						(ADSPCO_ACCEPT_IRP | ADSPCO_LISTEN_IRP))
				{
					atalkAdspAddrDeQueueOpenReq(pAdspAddr,
												pAdspConn->adspco_RemoteConnId,
												&pAdspConn->adspco_RemoteAddr,
												&pOpenReq);

					pAdspConn->adspco_Flags	&= ~(ADSPCO_ACCEPT_IRP |
												 ADSPCO_LISTEN_IRP);
					completionRoutine		= pAdspConn->adspco_ListenCompletion;
					completionCtx			= pAdspConn->adspco_ListenCtx;
				}
				else
				{
					ASSERT(pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_CONNECT);

					completionRoutine		= pAdspConn->adspco_ConnectCompletion;
					completionCtx			= pAdspConn->adspco_ConnectCtx;
				}

				//	Start the probe and the retransmit timers
				//	Set the flags
				pAdspConn->adspco_Flags |= (ADSPCO_CONN_TIMER | ADSPCO_RETRANSMIT_TIMER);
				AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 2, &error);
				if (!ATALK_SUCCESS(error))
				{
					KeBugCheck(0);
				}
				AtalkTimerInitialize(&pAdspConn->adspco_ConnTimer,
									 atalkAdspConnMaintenanceTimer,
									 ADSP_PROBE_INTERVAL);
				AtalkTimerScheduleEvent(&pAdspConn->adspco_ConnTimer);

				AtalkTimerInitialize(&pAdspConn->adspco_RetransmitTimer,
									 atalkAdspRetransmitTimer,
									 ADSP_RETRANSMIT_INTERVAL);
				AtalkTimerScheduleEvent(&pAdspConn->adspco_RetransmitTimer);
			}
			break;

		default:
			KeBugCheck(0);
			break;
		}

		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
		RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
		relAddrLock = FALSE;

		//	If a open request was dequeue free it now
		if (pOpenReq != NULL)
		{
			AtalkFreeMemory(pOpenReq);
		}

		//	Set last contact time. ConnMaintenanceTimer is in order of seconds.
		pAdspConn->adspco_LastContactTime = AtalkGetCurrentTick();

		if (controlCode == ADSP_OPENCONN_REQANDACK_CODE)
		{
			//	If we received a req&ack
			atalkAdspSendOpenControl(pAdspConn);
		}

		//	Call connect routine
		if (*completionRoutine != NULL)
		{
			(*completionRoutine)(error, completionCtx);
		}

		//	Are sends ok?
		if (*sendPossibleHandler != NULL)
		{
			(*sendPossibleHandler)(sendPossibleHandlerCtx,
								   pAdspConn->adspco_ConnCtx,
								   atalkAdspMaxSendSize(pAdspConn));
		}

		if (openTimerCancelled)
		{
			AtalkAdspConnDereference(pAdspConn);
		}

		AtalkAdspConnDereference(pAdspConn);
	}
#if DBG
	else
	{
		ASSERT(0);
	}
#endif

	if (relAddrLock)
	{
		RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);
	}
}




LOCAL VOID
atalkAdspHandleAttn(
	IN	PADSP_CONNOBJ	pAdspConn,
	IN	PBYTE			pPkt,
	IN	USHORT			PktLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	ULONG			RemoteAttnSendSeq,
	IN	ULONG			RemoteAttnRecvSeq,
	IN	ULONG			RemoteRecvWindow,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE						controlCode;
	KIRQL						OldIrql;
	PIRP						exRecvIrp;
	PTDI_IND_RECEIVE_EXPEDITED	exRecvHandler;
	PVOID						exRecvHandlerCtx;
	ULONG						exIndicateFlags;
	NTSTATUS					ntStatus;
	PBYTE						exReadBuf;
	ULONG						bytesTaken;
	USHORT						exWriteBufLen;
	PBYTE						exWriteChBuf		= NULL;
	BOOLEAN						freeBuf				= FALSE,
								timerCancelled		= FALSE;
	PAMDL						exWriteBuf			= NULL;
	GENERIC_WRITE_COMPLETION	exWriteCompletion	= NULL;
	PVOID						exWriteCtx			= NULL;

	UNREFERENCED_PARAMETER(RemoteRecvWindow);

	controlCode = (Descriptor & ADSP_CONTROL_MASK);

	//	Skip the adsp header
	pPkt	+= ADSP_DATA_OFF;
	PktLen	-= ADSP_DATA_OFF;

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspHandleAttn: PktLen %d\n", PktLen));

	//	Drop if we are not active! Pkt must atleast contain
	//	attention code if it is not a control packet.
	if (((pAdspConn->adspco_Flags & ADSPCO_ACTIVE) == 0) ||
		(controlCode != 0)	||
		(((Descriptor & ADSP_CONTROL_FLAG) == 0) &&
		 (PktLen < ADSP_MIN_ATTEN_PKT_SIZE)))
	{
		return;
	}

	//	Allocate if we have some data, ie. we are not just an ack.
	if ((Descriptor & ADSP_CONTROL_FLAG) == 0)
	{
		if ((exReadBuf = AtalkAllocMemory(PktLen)) == NULL)
		{
			return;
		}

		freeBuf	= TRUE;

		//	Copy the attention code from wire-to-host format
		GETSHORT2SHORT((PUSHORT)exReadBuf, pPkt);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspHandleAttn: Recd Attn Code %lx\n", *(PUSHORT)exReadBuf));

		//	Copy the rest of the data
		RtlCopyMemory(exReadBuf + sizeof(USHORT),
					  pPkt + sizeof(USHORT),
					  PktLen - sizeof(USHORT));
	}

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);

	do
	{
		if (RemoteAttnRecvSeq == (pAdspConn->adspco_SendAttnSeq + 1))
		{
			//	This implies an ack of our last attention
			pAdspConn->adspco_SendAttnSeq += 1;

			//	Check if we are waiting for an attention ack.
			if (pAdspConn->adspco_Flags & ADSPCO_EXSEND_IN_PROGRESS)
			{
				exWriteCompletion	= pAdspConn->adspco_ExWriteCompletion;
				exWriteCtx			= pAdspConn->adspco_ExWriteCtx;
				exWriteBuf			= pAdspConn->adspco_ExWriteBuf;
				exWriteBufLen		= pAdspConn->adspco_ExWriteBufLen;
				exWriteChBuf		= pAdspConn->adspco_ExWriteChBuf;

				timerCancelled = AtalkTimerCancelEvent(&pAdspConn->adspco_ExRetryTimer,
														NULL);

				pAdspConn->adspco_Flags &= ~ADSPCO_EXSEND_IN_PROGRESS;
			}
		}

		if (RemoteAttnSendSeq != pAdspConn->adspco_RecvAttnSeq)
		{
			break;
		}

		if (Descriptor & ADSP_CONTROL_FLAG)
		{
			//	Ack only, no data to handle
			break;
		}

		//	Get the expedited receive handler.
		exRecvHandler		= pAdspConn->adspco_pAssocAddr->adspao_ExpRecvHandler;
		exRecvHandlerCtx	= pAdspConn->adspco_pAssocAddr->adspao_ExpRecvHandlerCtx;

		if (((pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD) == 0) &&
			(*exRecvHandler != NULL))
		{
			exIndicateFlags				 = TDI_RECEIVE_EXPEDITED |
										   TDI_RECEIVE_PARTIAL;

			pAdspConn->adspco_Flags		|= ADSPCO_ATTN_DATA_RECD;
			if (Descriptor & ADSP_EOM_FLAG)
			{
				exIndicateFlags			&= ~TDI_RECEIVE_PARTIAL;
				exIndicateFlags			|= TDI_RECEIVE_ENTIRE_MESSAGE;
				pAdspConn->adspco_Flags	|= ADSPCO_ATTN_DATA_EOM;
			}

			pAdspConn->adspco_ExRecdData = exReadBuf;
			pAdspConn->adspco_ExRecdLen	 = PktLen;
			freeBuf						 = FALSE;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspHandleAttn: Indicating exp data %ld\n", PktLen));

			RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
			ntStatus = (*exRecvHandler)(exRecvHandlerCtx,
										pAdspConn->adspco_ConnCtx,
										exIndicateFlags,
										PktLen,
										PktLen,
										&bytesTaken,
										pPkt,
										&exRecvIrp);

			ASSERT((bytesTaken == 0) || (bytesTaken == PktLen));
			if (ntStatus == STATUS_MORE_PROCESSING_REQUIRED)
			{
				if (exRecvIrp != NULL)
				{
					//  Post the receive as if it came from the io system
					ntStatus = AtalkDispatchInternalDeviceControl(
									(PDEVICE_OBJECT)AtalkDeviceObject[ATALK_DEV_ADSP],
									exRecvIrp);

					ASSERT(ntStatus == STATUS_PENDING);
				}
				else
				{
					ASSERTMSG("atalkAdspReadComplete: No receive irp!\n", 0);
					KeBugCheck(0);
				}
				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}
			else if (ntStatus == STATUS_SUCCESS)
			{
				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
				if (bytesTaken != 0)
				{
					//	Assume all of the data was read.
					ASSERT(bytesTaken == PktLen);
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkAdspHandleAttn: All bytes read %lx\n", bytesTaken));

					//	Attention has been accepted, we need to ack it.
					//	Since spinlock was released, recheck flag.
					if (pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD)
					{
						pAdspConn->adspco_Flags		&= ~(ADSPCO_ATTN_DATA_RECD |
														 ADSPCO_ATTN_DATA_EOM);
						freeBuf = TRUE;
					}

					//	Send ack for the attention
					atalkAdspSendControl(pAdspConn,
										 ADSP_CONTROL_FLAG + ADSP_ATTEN_FLAG);
				}
			}
			else if (ntStatus == STATUS_DATA_NOT_ACCEPTED)
			{
				//	Client may have posted a receive in the indication. Or
				//	it will post a receive later on. Do nothing here.
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkAdspHandleAttn: Indication status %lx\n", ntStatus));

				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}
		}

		if (pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD)
		{
			atalkAdspRecvAttn(pAdspConn);
		}

	} while (FALSE);
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if (*exWriteCompletion != NULL)
	{
		if (exWriteChBuf != NULL)
		{
			AtalkFreeMemory(exWriteChBuf);
		}

		(*exWriteCompletion)(ATALK_NO_ERROR,
							 exWriteBuf,
							 exWriteBufLen,
							 exWriteCtx);
	}

	if (timerCancelled)
	{
		AtalkAdspConnDereference(pAdspConn);
	}

	if (freeBuf)
	{
		ASSERT(exReadBuf != NULL);
		AtalkFreeMemory(exReadBuf);
	}
}




LOCAL VOID
atalkAdspHandlePiggyBackAck(
	IN	PADSP_CONNOBJ	pAdspConn,
	IN	ULONG			RemoteNextRecvSeq,
	IN	ULONG			RemoteRecvWindow
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG					newSendWindowSeq, sendSize, windowSize;
	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	KIRQL					OldIrql;
	PVOID					sendPossibleHandlerCtx;

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspHandlePiggyBackAck: Recd ack %lx - %lx.%lx\n",
			pAdspConn, RemoteNextRecvSeq, RemoteRecvWindow));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	if (UNSIGNED_BETWEEN_WITH_WRAP(pAdspConn->adspco_FirstRtmtSeq,
								   pAdspConn->adspco_SendSeq,
								   RemoteNextRecvSeq))
	{
		ULONG	size;

		//	Discard acked data from the send queue
		size = (ULONG)(RemoteNextRecvSeq - pAdspConn->adspco_FirstRtmtSeq);
		pAdspConn->adspco_FirstRtmtSeq = RemoteNextRecvSeq;

		atalkAdspDiscardFromBufferQueue(&pAdspConn->adspco_SendQueue,
										size,
										&pAdspConn->adspco_NextSendQueue,
										ATALK_NO_ERROR,
										pAdspConn);
	}


	//	We almost always can use the header values to update the
	//	sendwindowseqnum
	newSendWindowSeq =	RemoteNextRecvSeq			+
						(ULONG)RemoteRecvWindow	-
						(ULONG)1;

	if (UNSIGNED_GREATER_WITH_WRAP(newSendWindowSeq,
								   pAdspConn->adspco_SendWindowSeq))
	{
		pAdspConn->adspco_SendWindowSeq = newSendWindowSeq;
	}

	if (!IsListEmpty(&pAdspConn->adspco_PendedSends))
	{
		AtalkAdspProcessQueuedSend(pAdspConn);
	}

	sendPossibleHandler		=
				pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandler;
	sendPossibleHandlerCtx	=
				pAdspConn->adspco_pAssocAddr->adspao_SendPossibleHandlerCtx;

	//	Call sendok handler for the size of the connection if non-zero
	windowSize	= (LONG)(pAdspConn->adspco_SendWindowSeq	-
						 pAdspConn->adspco_SendSeq			+
						 (LONG)1);

	sendSize =	MIN(atalkAdspMaxSendSize(pAdspConn), windowSize);

	if ((sendSize != 0) &&
		IsListEmpty(&pAdspConn->adspco_PendedSends) &&
		(pAdspConn->adspco_Flags & ADSPCO_SEND_WINDOW_CLOSED) &&
		(*sendPossibleHandler != NULL))
	{
		(*sendPossibleHandler)(sendPossibleHandlerCtx,
							   pAdspConn->adspco_ConnCtx,
							   sendSize);

		pAdspConn->adspco_Flags	&= ~ADSPCO_SEND_WINDOW_CLOSED;
	}

	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
}




LOCAL VOID
atalkAdspHandleControl(
	IN	PADSP_CONNOBJ	pAdspConn,
	IN	PBYTE			pPkt,
	IN	USHORT			PktLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	ULONG			RemoteFirstByteSeq,
	IN	ULONG			RemoteNextRecvSeq,
	IN	ULONG			RemoteRecvWindow,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE		controlCode;
	KIRQL		OldIrql;
	ATALK_ERROR	Error;

	//	The ack request flag can be set in any control packet. Send
	//	an immediately. We will also send any data if possible.
	if (Descriptor & ADSP_ACK_REQ_FLAG)
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspHandleControl: Recd ackreq for %lx\n", pAdspConn));

		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		atalkAdspSendData(pAdspConn);
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
	}

	controlCode = (Descriptor & ADSP_CONTROL_MASK);
	switch (controlCode)
	{
	  case ADSP_PROBE_OR_ACK_CODE:
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspHandleControl: Recd probe for %lx\n", pAdspConn));

		//	A PROBE has its ACKRequest flag set, so we would have handled
		//	that above. Also, we've already set the lastContactTime in the
		//	packet in routine. So if this is an ack we've handled it.
		//	Check to see if some data was acked and if we have data to send.
		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		if (!(Descriptor & ADSP_ACK_REQ_FLAG) &&
			 (atalkAdspBufferQueueSize(&pAdspConn->adspco_NextSendQueue) != 0) &&
			 (pAdspConn->adspco_SendSeq != (pAdspConn->adspco_SendWindowSeq + 1)))
		{
			atalkAdspSendData(pAdspConn);
		}
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
		break;

	  case ADSP_CLOSE_CONN_CODE:
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspHandleControl: Recd CLOSE for %lx\n", pAdspConn));

		AtalkAdspConnReferenceByPtr(pAdspConn, &Error);
		if (ATALK_SUCCESS(Error))
		{
			AtalkTimerScheduleEvent(&pAdspConn->adspco_DisconnectTimer);
		}
		else
		{
			AtalkAdspDisconnect(pAdspConn,
								ATALK_REMOTE_DISCONNECT,
								NULL,
								NULL);
		}
		break;

	  case ADSP_FORWARD_RESET_CODE:
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspHandleControl: Recd FWDRESET for %lx\n", pAdspConn));

		pAdspConn->adspco_Flags	|= ADSPCO_FORWARD_RESET_RECD;
		AtalkAdspDisconnect(pAdspConn,
							ATALK_LOCAL_DISCONNECT,
							NULL,
							NULL);
		break;

	  case ADSP_FORWARD_RESETACK_CODE:
		//	We never send forward resets (interface not exposed), so
		//	we should never be getting these. Drop if we do.
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspHandleControl: Recd ForwardReset ACK!!\n"));
		break;

	  case ADSP_RETRANSMIT_CODE:
		//	Any acks should have been processed by now. Back up and
		//	do a retransmit by rewinding sequence number.
		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		if (UNSIGNED_BETWEEN_WITH_WRAP(pAdspConn->adspco_FirstRtmtSeq,
									   pAdspConn->adspco_SendSeq,
									   RemoteNextRecvSeq))
		{
			pAdspConn->adspco_SendSeq		= pAdspConn->adspco_FirstRtmtSeq;
			pAdspConn->adspco_NextSendQueue = pAdspConn->adspco_SendQueue;
			atalkAdspSendData(pAdspConn);
		}
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
		break;

	  default:
		break;
	}
}




LOCAL VOID
atalkAdspHandleData(
	IN	PADSP_CONNOBJ	pAdspConn,
	IN	PBYTE			pPkt,
	IN	USHORT			PktLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	ULONG			RemoteFirstByteSeq,
	IN	ULONG			RemoteNextRecvSeq,
	IN	ULONG			RemoteRecvWindow,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN			eom, tdiEom;
	PBUFFER_CHUNK	pBufferChunk;
	KIRQL			OldIrql;
	ULONG			dataSize;
	BOOLEAN			freeChunk = FALSE,
					sendAck = (Descriptor & ADSP_ACK_REQ_FLAG);

	eom		= (Descriptor & ADSP_EOM_FLAG) ? TRUE : FALSE;
	dataSize	= PktLen - ADSP_DATA_OFF;

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);

	do
	{
		//	Drop if we are not active! And if there is no data
		if ((pAdspConn->adspco_Flags & ADSPCO_ACTIVE) == 0)
		{
			sendAck = FALSE;
			break;
		}

		tdiEom = (eom && (pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE));

		//	We can only access addr object when active.
		if ((dataSize == 0) && !tdiEom)
		{
			//	Increment seqnumbers and we have consumed this packet.
			pAdspConn->adspco_RecvSeq		+= (ULONG)(BYTECOUNT(eom));
			pAdspConn->adspco_RecvWindow	-= (LONG)(BYTECOUNT(eom));
			break;
		}

		//	Preallocate the buffer chunk
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("Recd Data %d Eom %d\n", dataSize, eom));

		pBufferChunk = atalkAdspAllocCopyChunk(pPkt + ADSP_DATA_OFF,
											   (USHORT)dataSize,
											   tdiEom,
											   TRUE);
		if (pBufferChunk == NULL)
			break;

		freeChunk = TRUE;

		if (RemoteFirstByteSeq != pAdspConn->adspco_RecvSeq)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
					("atalkAdspHandleData: Dropping out of sequence adsp packet\n"));

			if ((pAdspConn->adspco_OutOfSeqCount += 1) >= ADSP_OUT_OF_SEQ_PACKETS_MAX)
			{
				atalkAdspSendControl(pAdspConn,
									 ADSP_CONTROL_FLAG + ADSP_RETRANSMIT_CODE);

				pAdspConn->adspco_OutOfSeqCount = 0;
			}

			break;
		}

		//	Handle a > receive window packet
		if ((dataSize + BYTECOUNT(eom)) > (ULONG)pAdspConn->adspco_RecvWindow)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspHandleData: Recd > window data %d.%ld\n",
					dataSize, pAdspConn->adspco_RecvWindow));

			break;
		}

		//	Accept the data
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspHandleData: accepting data adsp packet %d\n", dataSize));

		atalkAdspAddToBufferQueue(&pAdspConn->adspco_RecvQueue,
								  pBufferChunk,
								  NULL);

		//	Put it in the queue successfully
		freeChunk = FALSE;

		//	Update the receive sequence numbers
		pAdspConn->adspco_RecvSeq		+= (ULONG)(dataSize + BYTECOUNT(eom));
		pAdspConn->adspco_RecvWindow	-= (LONG)(dataSize + BYTECOUNT(eom));

		//	The receive windows should never go below zero! If it does, we could have
		//	memory overruns.
		ASSERT(pAdspConn->adspco_RecvWindow >= 0);
		if (pAdspConn->adspco_RecvWindow < 0)
		{
			KeBugCheck(0);
		}

		//	Do indications/handle pending receives etc.
		atalkAdspRecvData(pAdspConn);

	} while (FALSE);

	//	ACK if requested, and send any data at the same time too.
	if (sendAck)
	{
		atalkAdspSendData(pAdspConn);
	}

	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if (freeChunk)
	{
		ASSERT(pBufferChunk != NULL);
		AtalkFreeMemory(pBufferChunk);
	}
}



//
//	ADSP SUPPORT ROUTINES
//


#define		SLS_OPEN_CONN_REF			0x0008
#define		SLS_ACCEPT_IRP				0x0010
#define		SLS_CONN_TIMER_REF			0x0040
#define		SLS_LISTEN_DEQUEUED			0x0080

LOCAL VOID
atalkAdspHandleOpenReq(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PBYTE			pPkt,
	IN	USHORT			PktLen,
	IN	PATALK_ADDR		pSrcAddr,
	IN	USHORT			RemoteConnId,
	IN	ULONG			RemoteFirstByteSeq,
	IN	ULONG			RemoteNextRecvSeq,
	IN	ULONG			RemoteRecvWindow,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ			pAdspConn;

	PTDI_IND_SEND_POSSIBLE  sendPossibleHandler;
	PVOID					sendPossibleHandlerCtx;

	USHORT					adspVersionStamp, destConnId, localConnId;
	ULONG					recvAttnSeq;
	ULONG					index;

	BOOLEAN					DerefConn	= FALSE;
	PADSP_OPEN_REQ			pOpenReq	= NULL;
	USHORT					openResr	= 0;
	KIRQL					OldIrql;
	ATALK_ERROR				error = ATALK_NO_ERROR;

	//	Are there any listening connections? Or do we have a
	//	set handler?
	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	do
	{
		//	Get the other information from the adsp header
		GETSHORT2SHORT(&adspVersionStamp, pPkt + ADSP_VERSION_STAMP_OFF);

		GETSHORT2SHORT(&destConnId, pPkt + ADSP_DEST_CONNID_OFF);

		GETDWORD2DWORD(&recvAttnSeq, pPkt + ADSP_NEXT_ATTEN_SEQNUM_OFF);

		//	Drop request if version isnt right.
		if (adspVersionStamp != ADSP_VERSION)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("atalkAdspPacketIn: Version incorrect\n"));

			error = ATALK_INVALID_REQUEST;
			break;
		}

		//	Is this a duplicate request - same remote address/id?
		if (atalkAdspIsDuplicateOpenReq(pAdspAddr,
										RemoteConnId,
										pSrcAddr))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("atalkAdspPacketIn: Duplicate open req\n"));

			error = ATALK_INVALID_REQUEST;
			break;
		}

		//	Allocate the open request structure. Do it here to avoid
		//	sending in a whole lot of parameters.
		if ((pOpenReq = (PADSP_OPEN_REQ)AtalkAllocMemory(sizeof(ADSP_OPEN_REQ))) == NULL)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("atalkAdspPacketIn: Could not alloc\n"));

			error = ATALK_RESR_MEM;
			RES_LOG_ERROR();
			break;
		}

		//	Initialize the structure. This will be queued into the address
		//	object by listenindicate if successful.
		pOpenReq->or_Next			= NULL;
		pOpenReq->or_RemoteAddr	= *pSrcAddr;
		pOpenReq->or_RemoteConnId	= RemoteConnId;
		pOpenReq->or_FirstByteSeq	= RemoteFirstByteSeq;
		pOpenReq->or_NextRecvSeq	= RemoteNextRecvSeq;
		pOpenReq->or_RecvWindow		= RemoteRecvWindow;

		localConnId	= atalkAdspGetNextConnId(pAdspAddr, &error);
		ASSERT(ATALK_SUCCESS(error));

		if (ATALK_SUCCESS(error))
		{
			atalkAdspListenIndicateNonInterlock(pAdspAddr,
												pOpenReq,
												&pAdspConn,
												&error);
		}

	} while (FALSE);

	//	If either the indication or listen didnt happen well,
	//	break out of the main while loop.
	if (!ATALK_SUCCESS(error))
	{
		RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

		if (pOpenReq != NULL)
		{
			AtalkFreeMemory(pOpenReq);
		}
		return;
	}

	ASSERT(ATALK_SUCCESS(error));

	//	Common for both listen and indicate. The connection object
	//	should be referenced.
	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspOpenReq: ConnId %lx Rem %lx.%lx.%lx\n",
			pOpenReq->or_RemoteConnId,
			pOpenReq->or_RemoteAddr.ata_Network,
			pOpenReq->or_RemoteAddr.ata_Node,
			pOpenReq->or_RemoteAddr.ata_Socket));

	//	Thread the connection object into addr lookup by session id.
	index	= HASH_ID_SRCADDR(pOpenReq->or_RemoteConnId,
							  &pOpenReq->or_RemoteAddr);

	index  %= ADSP_CONN_HASH_SIZE;

	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

	pAdspConn->adspco_Flags &= ~ADSPCO_LISTENING;
	pAdspConn->adspco_Flags |= (ADSPCO_HALF_ACTIVE		|
								ADSPCO_SEEN_REMOTE_OPEN	|
								ADSPCO_OPEN_TIMER);

	pAdspConn->adspco_ConnectAttempts	= ADSP_MAX_OPEN_ATTEMPTS;

	//	Store the information in the connection structure given by
	//	the connection object thats passed back in the indication
	//	or is part of the listen structure.
	pAdspConn->adspco_RecvWindow=
	pAdspConn->adspco_SendQueueMax	=
	pAdspConn->adspco_RecvQueueMax	= ADSP_DEF_SEND_RX_WINDOW_SIZE;

	//	Store the remote information
	pAdspConn->adspco_RemoteAddr	= pOpenReq->or_RemoteAddr;
	pAdspConn->adspco_RemoteConnId	= pOpenReq->or_RemoteConnId;
	pAdspConn->adspco_LocalConnId	= localConnId;

	pAdspConn->adspco_SendSeq		= pOpenReq->or_FirstByteSeq;
	pAdspConn->adspco_FirstRtmtSeq	= pOpenReq->or_NextRecvSeq;
	pAdspConn->adspco_SendWindowSeq	= pOpenReq->or_NextRecvSeq	+
										pOpenReq->or_RecvWindow	- 1;

	pAdspConn->adspco_RecvAttnSeq	= recvAttnSeq;

	pAdspConn->adspco_pNextActive	= pAdspAddr->adspao_pActiveHash[index];
	pAdspAddr->adspao_pActiveHash[index] = pAdspConn;

	//	Remember the ddp socket.
	pAdspConn->adspco_pDdpAddr		= pAdspAddr->adspao_pDdpAddr;

	//	Initialize pended sends list
	InitializeListHead(&pAdspConn->adspco_PendedSends);

	//	Call the send data event handler on the associated address with
	//	0 to turn off selects on writes. We do this before we complete the
	//	accept.
	sendPossibleHandler	= pAdspAddr->adspao_SendPossibleHandler;
	sendPossibleHandlerCtx	= pAdspAddr->adspao_SendPossibleHandlerCtx;

	//	Start open timer. Reference is the reference
	//	at the beginning.
	AtalkTimerInitialize(&pAdspConn->adspco_OpenTimer,
						 atalkAdspOpenTimer,
						 ADSP_OPEN_INTERVAL);
	AtalkTimerScheduleEvent(&pAdspConn->adspco_OpenTimer);

	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	//	Connection is all set up, send ack to remote and wait
	//	for its ack before switching state to active.
	if (*sendPossibleHandler != NULL)
	{
		(*sendPossibleHandler)(sendPossibleHandlerCtx,
							   pAdspConn->adspco_ConnCtx,
							   0);
	}

	//	Send the open control.
	atalkAdspSendOpenControl(pAdspConn);

	//	Remove the reference on the connection added during
	//	indicate/listen if we did not start the open timer.
	if (DerefConn)
	{
		AtalkAdspConnDereference(pAdspConn);
	}
}



LOCAL VOID
atalkAdspListenIndicateNonInterlock(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PADSP_OPEN_REQ	pOpenReq,
	IN	PADSP_CONNOBJ *	ppAdspConn,
	IN	PATALK_ERROR	pError
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	TA_APPLETALK_ADDRESS	tdiAddr;
	PTDI_IND_CONNECT		indicationRoutine;
	PVOID					indicationCtx;
	NTSTATUS				status;
	CONNECTION_CONTEXT	ConnCtx;
	PIRP					acceptIrp;
	PADSP_CONNOBJ			pAdspConn;
	ATALK_ADDR				remoteAddr;
	USHORT					remoteConnId;
	BOOLEAN					indicate	= TRUE;

	//	If no listens posted, no handler, drop the request.
	error	= ATALK_RESR_MEM;

	//	Queue in the open request to the address. Cant release the
	//	addrlock without doing this.
	pOpenReq->or_Next = pAdspAddr->adspao_OpenReq;
	pAdspAddr->adspao_OpenReq = pOpenReq;

	pAdspConn		= pAdspAddr->adspao_pListenConn;
	remoteAddr		= pOpenReq->or_RemoteAddr;
	remoteConnId	= pOpenReq->or_RemoteConnId;
	if (pAdspConn != NULL)
	{
		ASSERT(VALID_ADSPCO(pAdspConn));

		indicate	= FALSE;

		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

		//	Ok, now its possible the connection object is already
		//	disconnecting/closing. Check for that, if so,
		//	drop this request
		if (pAdspConn->adspco_Flags & (	ADSPCO_CLOSING	|
										ADSPCO_STOPPING |
										ADSPCO_DISCONNECTING))
		{
			//	dequeue open request, still first in list.
			pAdspAddr->adspao_OpenReq = pAdspAddr->adspao_OpenReq->or_Next;

			*pError = ATALK_INVALID_CONNECTION;
			RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
			return;
		}

		//	There a connection with a pending listen. use it.
		pAdspAddr->adspao_pListenConn = pAdspConn->adspco_pNextListen;

		//	Reference the connection object with a listen posted on it.
		AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
		if (!ATALK_SUCCESS(error))
		{
			KeBugCheck(0);
		}

		//	The listen request will also be completed when the
		//	ack is received.
		pAdspConn->adspco_Flags	|= ADSPCO_LISTEN_IRP;

		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	}
	else if ((indicationRoutine = pAdspAddr->adspao_ConnHandler) != NULL)
	{
		indicationCtx	= pAdspAddr->adspao_ConnHandlerCtx;

		//	Convert remote atalk address to tdi address
		ATALKADDR_TO_TDI(&tdiAddr, &pOpenReq->or_RemoteAddr);

#if DBG
        (&pAdspAddr->adspao_Lock)->FileLineLock |= 0x80000000;
#endif
		RELEASE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);
		status = (*indicationRoutine)(indicationCtx,
									  sizeof(tdiAddr),
									  (PVOID)&tdiAddr,
									  0,					  // User data length
									  NULL,				   // User data
									  0,					  // Option length
									  NULL,				   // Options
									  &ConnCtx,
									  &acceptIrp);

		ACQUIRE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);
#if DBG
        (&pAdspAddr->adspao_Lock)->FileLineLock &= ~0x80000000;
#endif

		ASSERT(acceptIrp != NULL);
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspSlsHandler: indicate status %lx\n", status));

		error = ATALK_RESR_MEM;
		if (status == STATUS_MORE_PROCESSING_REQUIRED)
		{
			//  Find the connection and accept the connection using that
			//	connection object.

			AtalkAdspConnReferenceByCtxNonInterlock(pAdspAddr,
													ConnCtx,
													&pAdspConn,
													&error);

			if (!ATALK_SUCCESS(error))
			{
				//	The connection object is closing, or is not found
				//	in our list. The accept irp must have had the same
				//	connection object. AFD isnt behaving well.
				KeBugCheck(0);
			}

			if (acceptIrp != NULL)
			{
				// AFD re-uses connection objects. Make sure ths one is in
				// the right state
				pAdspConn->adspco_Flags &= ~(ADSPCO_LISTENING			|
											 ADSPCO_CONNECTING			|
											 ADSPCO_ACCEPT_IRP			|
											 ADSPCO_LISTEN_IRP			|
											 ADSPCO_ACTIVE				|
											 ADSPCO_HALF_ACTIVE			|
											 ADSPCO_SEEN_REMOTE_OPEN	|
											 ADSPCO_DISCONNECTING		|
											 ADSPCO_REMOTE_CLOSE		|
											 ADSPCO_SEND_IN_PROGRESS	|
											 ADSPCO_SEND_DENY			|
											 ADSPCO_SEND_OPENACK		|
											 ADSPCO_SEND_WINDOW_CLOSED	|
											 ADSPCO_READ_PENDING		|
											 ADSPCO_EXREAD_PENDING		|
											 ADSPCO_FORWARD_RESET_RECD	|
											 ADSPCO_ATTN_DATA_RECD		|
											 ADSPCO_ATTN_DATA_EOM		|
											 ADSPCO_EXSEND_IN_PROGRESS	|
											 ADSPCO_OPEN_TIMER			|
											 ADSPCO_RETRANSMIT_TIMER	|
											 ADSPCO_CONN_TIMER);



				pAdspConn->adspco_ListenCompletion	= atalkAdspGenericComplete;
				pAdspConn->adspco_ListenCtx			= (PVOID)acceptIrp;

				//	This will be completed when we receive an ack
				//	for the open from the remote, i.e. both ends of the
				//	connection are open.
				pAdspConn->adspco_Flags |= ADSPCO_ACCEPT_IRP;
			}
		}
	}

	if (ATALK_SUCCESS(*pError = error))
	{
		*ppAdspConn = pAdspConn;
	}
	else
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspListenIndicateNonInterlock: No listen %lx\n", status));

		if (indicate)
		{
			//	Dequeue the open request.
			atalkAdspAddrDeQueueOpenReq(pAdspAddr,
										remoteConnId,
										&remoteAddr,
										&pOpenReq);
		}

#if DBG
        (&pAdspAddr->adspao_Lock)->FileLineLock |= 0x80000000;
#endif
		RELEASE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);
		atalkAdspSendDeny(pAdspAddr,
						  &remoteAddr,
						  remoteConnId);
		ACQUIRE_SPIN_LOCK_DPC(&pAdspAddr->adspao_Lock);
#if DBG
        (&pAdspAddr->adspao_Lock)->FileLineLock &= ~0x80000000;
#endif
	}
}




ATALK_ERROR
atalkAdspSendExpedited(
	IN	PADSP_CONNOBJ				pAdspConn,
	IN	PAMDL						pWriteBuf,
	IN	USHORT						WriteBufLen,
	IN	ULONG						SendFlags,
	IN	PVOID						pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:

	The first two bytes of the writebuffer will contain the ushort
	attention code. We need to put this back in the on-the-wire format
	before sending it out.

Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;
	PBYTE			pExWriteChBuf;
	USHORT			attnCode;
	NTSTATUS		status;
	ULONG			bytesCopied;
	BOOLEAN			DerefConn = FALSE;

	if ((WriteBufLen < ADSP_MIN_ATTEN_PKT_SIZE) ||
		(WriteBufLen > ADSP_MAX_ATTEN_PKT_SIZE))
	{
		return ATALK_BUFFER_TOO_SMALL;
	}

	if ((pExWriteChBuf = AtalkAllocMemory(WriteBufLen)) == NULL)
	{
		return ATALK_RESR_MEM;
	}

	status = TdiCopyMdlToBuffer((PMDL)pWriteBuf,
								0,
								pExWriteChBuf,
								0,
								WriteBufLen,
								&bytesCopied);

	ASSERT(!NT_ERROR(status) && (bytesCopied == (ULONG)WriteBufLen));

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	do
	{
		if (((pAdspConn->adspco_Flags & ADSPCO_ACTIVE) == 0) ||
			 ((pAdspConn->adspco_Flags & (ADSPCO_CLOSING |
										  ADSPCO_STOPPING|
										  ADSPCO_DISCONNECTING))))
		{
			error = ATALK_ADSP_CONN_NOT_ACTIVE;
			break;
		}

		if (pAdspConn->adspco_Flags & ADSPCO_EXSEND_IN_PROGRESS)
		{
			if (SendFlags & TDI_SEND_NON_BLOCKING)
			{
				//	!!!NOTE!!!
				//	To avoid the race condition in AFD where an incoming
				//	send data indication setting send's possible to true
				//	is overwritten by this read's unwinding and setting it
				//	to false, we return ATALK_REQUEST_NOT_ACCEPTED, which
				//	will map to STATUS_REQUEST_NOT_ACCEPTED and then to
				//	WSAEWOULDBLOCK.
				//	error = ATALK_DEVICE_NOT_READY;

				error = ATALK_REQUEST_NOT_ACCEPTED;
			}
			else
			{
				error		= ATALK_TOO_MANY_COMMANDS;
			}

			break;
		}

		//	Verify the attention code, this will a ushort in the first
		//	two bytes of the buffer, in host format.
		attnCode = *(PUSHORT)pExWriteChBuf;

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspSendExpedited: attnCode %lx\n", attnCode));

		if ((attnCode < ADSP_MIN_ATTENCODE) ||
			(attnCode > ADSP_MAX_ATTENCODE))
		{
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		//	Put it back in machine format
		PUTSHORT2SHORT(pExWriteChBuf, attnCode);

		//	Try to reference for the attention retransmit timer
		AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		DerefConn	= TRUE;

		//	Remember all the information in the connection object
		pAdspConn->adspco_ExWriteFlags		= SendFlags;
		pAdspConn->adspco_ExWriteBuf		= pWriteBuf;
		pAdspConn->adspco_ExWriteBufLen		= WriteBufLen;
		pAdspConn->adspco_ExWriteCompletion	= CompletionRoutine;
		pAdspConn->adspco_ExWriteCtx		= pWriteCtx;
		pAdspConn->adspco_ExWriteChBuf		= pExWriteChBuf;

		pAdspConn->adspco_Flags			   |= ADSPCO_EXSEND_IN_PROGRESS;

		//	Start the retry timer
		AtalkTimerInitialize(&pAdspConn->adspco_ExRetryTimer,
							 atalkAdspAttnRetransmitTimer,
							 ADSP_ATTENTION_INTERVAL);
		AtalkTimerScheduleEvent(&pAdspConn->adspco_ExRetryTimer);

		error = ATALK_PENDING;

	} while (FALSE);
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		atalkAdspSendAttn(pAdspConn);
		error	= ATALK_PENDING;
	}
	else
	{
		if (DerefConn)
		{
			AtalkAdspConnDereference(pAdspConn);
		}

		AtalkFreeMemory(pExWriteChBuf);
	}

	return error;
}




LOCAL VOID
atalkAdspSendOpenControl(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PBUFFER_DESC	pBuffDesc;
	BYTE			descriptor;
	KIRQL			OldIrql;
	BOOLEAN			DerefConn = FALSE;
	USHORT			remoteConnId = 0;
	SEND_COMPL_INFO	SendInfo;

	descriptor = ADSP_CONTROL_FLAG;
	if (pAdspConn->adspco_Flags & ADSPCO_SEND_DENY)
	{
		descriptor += ADSP_OPENCONN_DENY_CODE;
		remoteConnId = pAdspConn->adspco_RemoteConnId;
	}
	else if (pAdspConn->adspco_Flags & ADSPCO_ACTIVE)
	{
		descriptor += ADSP_OPENCONN_ACK_CODE;
		remoteConnId = pAdspConn->adspco_RemoteConnId;
	}
	else  if (pAdspConn->adspco_Flags & ADSPCO_SEEN_REMOTE_OPEN)
	{
		descriptor += ADSP_OPENCONN_REQANDACK_CODE;
		remoteConnId = pAdspConn->adspco_RemoteConnId;
	}
	else
	{
		descriptor += ADSP_OPENCONN_REQ_CODE;
	}

	//	Allocate the datagram buffer
	pBuffDesc = AtalkAllocBuffDesc(NULL,
								   ADSP_NEXT_ATTEN_SEQNUM_OFF + sizeof(ULONG),
								   BD_CHAR_BUFFER | BD_FREE_BUFFER);

	if (pBuffDesc == NULL)
	{
		DBGPRINT(DBG_COMP_RTMP, DBG_LEVEL_ERR,
			("AtalkAdspSendOpenControl: AtalkAllocBuffDesc failed\n"));

		RES_LOG_ERROR();
		return;
	}

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);

	//	Try to reference connection for this call.
	AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
	if (ATALK_SUCCESS(error))
	{
		DerefConn = TRUE;

		PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_SRC_CONNID_OFF,
					   pAdspConn->adspco_LocalConnId);

		PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_FIRST_BYTE_SEQNUM_OFF,
					   pAdspConn->adspco_SendSeq);

		PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_NEXT_RX_BYTESEQNUM_OFF,
					   pAdspConn->adspco_RecvSeq);

		PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_RX_WINDOW_SIZE_OFF,
					   pAdspConn->adspco_RecvWindow);

		//	Set the descriptor
		pBuffDesc->bd_CharBuffer[ADSP_DESCRIPTOR_OFF] = descriptor;

		PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_VERSION_STAMP_OFF,
					   ADSP_VERSION);

		PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_DEST_CONNID_OFF,
					   remoteConnId);

		PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_NEXT_ATTEN_SEQNUM_OFF,
					   pAdspConn->adspco_RecvAttnSeq);
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		//	We let the completion routine Deref the conn.
		DerefConn = FALSE;

		SendInfo.sc_TransmitCompletion = atalkAdspConnSendComplete;
		SendInfo.sc_Ctx1 = pAdspConn;
		SendInfo.sc_Ctx2 = pBuffDesc;
		// SendInfo.sc_Ctx3 = NULL;
		if(!ATALK_SUCCESS(AtalkDdpSend(pAdspConn->adspco_pDdpAddr,
									   &pAdspConn->adspco_RemoteAddr,
									   DDPPROTO_ADSP,
									   FALSE,
									   pBuffDesc,
									   NULL,
									   0,
									   NULL,
									   &SendInfo)))
		{
			atalkAdspConnSendComplete(NDIS_STATUS_FAILURE, &SendInfo);
		}
	}
	else
	{
		//	Free the buffer descriptor
		AtalkFreeBuffDesc(pBuffDesc);
	}

	if (DerefConn)
	{
		AtalkAdspConnDereference(pAdspConn);
	}
}



LOCAL VOID
atalkAdspSendControl(
	IN	PADSP_CONNOBJ	pAdspConn,
	IN	BYTE			Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PBUFFER_DESC	pBuffDesc;
	ULONG			sendSeq, recvSeq, recvWindow;
	BOOLEAN			DerefConn = FALSE;
	SEND_COMPL_INFO	SendInfo;

	//	Try to reference connection for this call.
	AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, &error);
	if (ATALK_SUCCESS(error))
	{
		DerefConn	= TRUE;
		if ((Descriptor & ADSP_ATTEN_FLAG) == 0)
		{
			sendSeq		= pAdspConn->adspco_SendSeq;
			recvSeq		= pAdspConn->adspco_RecvSeq;
			recvWindow	= pAdspConn->adspco_RecvWindow;
		}
		else
		{
			sendSeq		= pAdspConn->adspco_SendAttnSeq;
			recvSeq		= pAdspConn->adspco_RecvAttnSeq;
			recvWindow	= 0;
		}

		//	Allocate the datagram buffer
		if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
											ADSP_DATA_OFF,
											BD_CHAR_BUFFER | BD_FREE_BUFFER)) != NULL)
		{
			PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_SRC_CONNID_OFF,
						   pAdspConn->adspco_LocalConnId);

			PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_FIRST_BYTE_SEQNUM_OFF,
						   sendSeq);

			PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_NEXT_RX_BYTESEQNUM_OFF,
						   recvSeq);

			PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_RX_WINDOW_SIZE_OFF,
						   recvWindow);

			//	Set the descriptor
			pBuffDesc->bd_CharBuffer[ADSP_DESCRIPTOR_OFF] = Descriptor;
		}
		else
		{
			error = ATALK_RESR_MEM;
		}
	}

#if DBG
    (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

	if (ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("AtalkAdspSendControl: %lx.%lx\n", pAdspConn, Descriptor));

		//	We let the completion routine Deref the conn.
		SendInfo.sc_TransmitCompletion = atalkAdspConnSendComplete;
		SendInfo.sc_Ctx1 = pAdspConn;
		SendInfo.sc_Ctx2 = pBuffDesc;
		// SendInfo.sc_Ctx3 = NULL;
		if (!ATALK_SUCCESS(AtalkDdpSend(pAdspConn->adspco_pDdpAddr,
										&pAdspConn->adspco_RemoteAddr,
										DDPPROTO_ADSP,
										FALSE,
										pBuffDesc,
										NULL,
										0,
										NULL,
										&SendInfo)))
		{
			atalkAdspConnSendComplete(NDIS_STATUS_FAILURE, &SendInfo);
		}
	}
	else
	{
		if (DerefConn)
		{
			AtalkAdspConnDereference(pAdspConn);
		}
	}

	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
    (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif
}



LOCAL VOID
atalkAdspSendDeny(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PATALK_ADDR		pRemoteAddr,
	IN	USHORT			RemoteConnId
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PBUFFER_DESC	pBuffDesc;
	SEND_COMPL_INFO	SendInfo;

	//	Allocate the datagram buffer
	if ((pBuffDesc = AtalkAllocBuffDesc(NULL,
										ADSP_NEXT_ATTEN_SEQNUM_OFF + sizeof(ULONG),
										BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
			("AtalkAdspSendControl: AtalkAllocBuffDesc failed\n"));

		RES_LOG_ERROR();
		return;
	}

	//	Try to reference address for this call.
	AtalkAdspAddrReference(pAdspAddr, &error);
	if (!ATALK_SUCCESS(error))
	{
		AtalkFreeBuffDesc(pBuffDesc);
		return;
	}

	PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_SRC_CONNID_OFF, 0);

	PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_FIRST_BYTE_SEQNUM_OFF, 0);

	PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_NEXT_RX_BYTESEQNUM_OFF, 0);

	PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_RX_WINDOW_SIZE_OFF, 0);

	//	Set the descriptor
	pBuffDesc->bd_CharBuffer[ADSP_DESCRIPTOR_OFF] = ADSP_CONTROL_FLAG |
													ADSP_OPENCONN_DENY_CODE;

	PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_VERSION_STAMP_OFF,
				   ADSP_VERSION);

	PUTSHORT2SHORT(pBuffDesc->bd_CharBuffer + ADSP_DEST_CONNID_OFF,
				   RemoteConnId);

	PUTDWORD2DWORD(pBuffDesc->bd_CharBuffer + ADSP_NEXT_ATTEN_SEQNUM_OFF,
				   0);

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("AtalkAdspSendDeny: %lx.%lx\n", pAdspAddr, pBuffDesc));

	//	We let the completion routine Deref the conn.
	SendInfo.sc_TransmitCompletion = atalkAdspAddrSendComplete;
	SendInfo.sc_Ctx1 = pAdspAddr;
	SendInfo.sc_Ctx2 = pBuffDesc;
	// SendInfo.sc_Ctx3 = NULL;
	if(!ATALK_SUCCESS(AtalkDdpSend(AtalkAdspGetDdpAddress(pAdspAddr),
								   pRemoteAddr,
								   DDPPROTO_ADSP,
								   FALSE,
								   pBuffDesc,
								   NULL,
								   0,
								   NULL,
								   &SendInfo)))
	{
		atalkAdspAddrSendComplete(NDIS_STATUS_FAILURE, &SendInfo);
	}
}




LOCAL VOID
atalkAdspSendAttn(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL				OldIrql;
	PBYTE				adspHeader;
	ATALK_ERROR			error		= ATALK_NO_ERROR;
	PBUFFER_DESC		pBuffDesc	= NULL;
	SEND_COMPL_INFO		SendInfo;

	do
	{
		pBuffDesc = AtalkAllocBuffDesc(NULL,
									   ADSP_DATA_OFF + ADSP_MAX_DATA_SIZE,
									   BD_CHAR_BUFFER | BD_FREE_BUFFER);

		if (pBuffDesc == NULL)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("AtalkAdspSendAttn: AtalkAllocBuffDesc failed\n"));

			RES_LOG_ERROR();
			break;
		}

		adspHeader	= pBuffDesc->bd_CharBuffer;

		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		if (pAdspConn->adspco_Flags & ADSPCO_EXSEND_IN_PROGRESS)
		{
			PUTSHORT2SHORT(adspHeader + ADSP_SRC_CONNID_OFF,
						   pAdspConn->adspco_LocalConnId);

			PUTDWORD2DWORD(adspHeader + ADSP_THIS_ATTEN_SEQNUM_OFF,
						   pAdspConn->adspco_SendAttnSeq);

			PUTDWORD2DWORD(adspHeader + ADSP_NEXT_RX_ATTNSEQNUM_OFF,
						   pAdspConn->adspco_RecvAttnSeq);

			PUTSHORT2SHORT(adspHeader + ADSP_RX_ATTEN_SIZE_OFF, 0);

			//	Set the descriptor
			adspHeader[ADSP_DESCRIPTOR_OFF] = ADSP_ATTEN_FLAG + ADSP_ACK_REQ_FLAG;

			//	Send eom?
			if (((pAdspConn->adspco_ExWriteFlags & TDI_SEND_PARTIAL) == 0) &&
				(pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE))
			{
				adspHeader[ADSP_DESCRIPTOR_OFF]	+= ADSP_EOM_FLAG;
			}

			//	Copy the attention data
			RtlCopyMemory(&adspHeader[ADSP_DATA_OFF],
						  pAdspConn->adspco_ExWriteChBuf,
						  pAdspConn->adspco_ExWriteBufLen);

			//	Set the size in the buffer descriptor
			AtalkSetSizeOfBuffDescData(pBuffDesc,
									   ADSP_DATA_OFF +
											pAdspConn->adspco_ExWriteBufLen);
		}
		else
		{
			error = ATALK_FAILURE;
		}
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

		if (ATALK_SUCCESS(error))
		{
			//	Send the packet
			SendInfo.sc_TransmitCompletion = atalkAdspSendAttnComplete;
			SendInfo.sc_Ctx1 = pAdspConn;
			SendInfo.sc_Ctx2 = pBuffDesc;
			// SendInfo.sc_Ctx3 = NULL;
			error = AtalkDdpSend(pAdspConn->adspco_pDdpAddr,
								 &pAdspConn->adspco_RemoteAddr,
								 (BYTE)DDPPROTO_ADSP,
								 FALSE,
								 pBuffDesc,
								 NULL,
								 0,
								 NULL,
								 &SendInfo);

			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspSendAttn: DdpSend failed %ld\n", error));

				atalkAdspSendAttnComplete(NDIS_STATUS_FAILURE, &SendInfo);
			}

			error = ATALK_PENDING;
		}

	} while (FALSE);

	if (!ATALK_SUCCESS(error) && (pBuffDesc != NULL))
	{
		AtalkFreeBuffDesc(pBuffDesc);
	}
}




LOCAL VOID
atalkAdspSendData(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:

	MUST BE ENTERED WITH CONNECTION LOCK HELD !!!

Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	BYTE					descriptor;
	ULONG					dataSize;
	BOOLEAN					eom;
	BYTE					adspHeader[ADSP_DATA_OFF];
	LONG					windowSize		= 0;
	PBUFFER_CHUNK			pBufferChunk	= NULL;
	PBUFFER_DESC			pBuffDesc		= NULL;
	SEND_COMPL_INFO			SendInfo;


	//	If there is no data to send or if the remote cannot handle any more
	//	data, just send an ack.

	SendInfo.sc_TransmitCompletion = atalkAdspSendDataComplete;
	SendInfo.sc_Ctx1 = pAdspConn;

	while (TRUE)
	{
		if ((pAdspConn->adspco_Flags & (ADSPCO_ACTIVE	|
										ADSPCO_CLOSING	|
										ADSPCO_STOPPING	|
										ADSPCO_DISCONNECTING)) != ADSPCO_ACTIVE)
		{
			break;
		}

		//	dataSize includes count of eom if present
		dataSize	= atalkAdspBufferQueueSize(&pAdspConn->adspco_NextSendQueue);
		windowSize	= (LONG)(pAdspConn->adspco_SendWindowSeq	-
							 pAdspConn->adspco_SendSeq			+
							 (LONG)1);

		ASSERTMSG("WindowSize incorrect!\n",
					((windowSize >= 0) || (dataSize == 0)));

		if ((dataSize == 0) || (windowSize == 0))
		{
			//	Send a ack request to the remote end.
			descriptor = ADSP_CONTROL_FLAG + ADSP_PROBE_OR_ACK_CODE +
						 ((windowSize == 0) ? ADSP_ACK_REQ_FLAG : 0);

			atalkAdspSendControl(pAdspConn, descriptor);
			break;
		}

		ASSERTMSG("WindowSize incorrect!\n", (windowSize >= 0));
		if (windowSize < 0)
		{
			//	This should never happen. It can be negative, but only if
			//	the datasize is 0.
		}


		//	We have some data to send
		windowSize = MIN((ULONG)windowSize, dataSize);

		//	compute the amount of data to be sent. This will only get
		//	the data in one buffer chunk, i.e. if the current buffer chunk
		//	has only one byte to be sent, it will return just that, although
		//	the next buffer chunk might still have some data to be sent. It will
		//	return a built buffer chunk with the proper amount of data in it.
		//	Given checks above there is guaranteed to be dataSize amount of data
		//	in queue.
		dataSize = atalkAdspDescribeFromBufferQueue(&pAdspConn->adspco_NextSendQueue,
													&eom,
													windowSize,
													&pBufferChunk,
													&pBuffDesc);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspSendData: DataSize %ld\n", dataSize));

		ASSERT(dataSize <= (ULONG)windowSize);

		descriptor = (eom ? ADSP_EOM_FLAG : 0);
		if (windowSize == (LONG)(dataSize + BYTECOUNT(eom)))
		{
			descriptor += ADSP_ACK_REQ_FLAG;
		}

		PUTSHORT2SHORT(adspHeader + ADSP_SRC_CONNID_OFF,
					   pAdspConn->adspco_LocalConnId);

		PUTDWORD2DWORD(adspHeader + ADSP_FIRST_BYTE_SEQNUM_OFF,
					   pAdspConn->adspco_SendSeq);

		PUTDWORD2DWORD(adspHeader + ADSP_NEXT_RX_BYTESEQNUM_OFF,
					   pAdspConn->adspco_RecvSeq);

		PUTSHORT2SHORT(adspHeader + ADSP_RX_WINDOW_SIZE_OFF,
					   pAdspConn->adspco_RecvWindow);

		//	Set the descriptor
		adspHeader[ADSP_DESCRIPTOR_OFF] = descriptor;

		//	Move up our seq num. We should do it before we release the lock
		//	so that other calls to this routine do not mess it up.
		//	!!!NOTE!!! Due to calling describe, dataSize *does not* include
		//	eom in its count.
		pAdspConn->adspco_SendSeq	+= (ULONG)dataSize + BYTECOUNT(eom);

		windowSize					-= dataSize;


#if DBG
        (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

		//	Send the packet
		SendInfo.sc_Ctx2 = pBuffDesc;
		SendInfo.sc_Ctx3 = pBufferChunk;
		error = AtalkDdpSend(pAdspConn->adspco_pDdpAddr,
							 &pAdspConn->adspco_RemoteAddr,
							 (BYTE)DDPPROTO_ADSP,
							 FALSE,
							 pBuffDesc,
							 adspHeader,
							 sizeof(adspHeader),
							 NULL,
							 &SendInfo);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
					("AtalkAdspSendData: DdpSend failed %ld\n", error));

			atalkAdspSendDataComplete(NDIS_STATUS_FAILURE, &SendInfo);
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
        (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif
	}
}




LOCAL VOID
atalkAdspRecvData(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:

	MUST HAVE THE CONNECTION LOCK HELD BEFORE ENTERING HERE !!!

	SHOULD THIS ROUTINE HAVE ITS OWN REFERENCE FOR THE CONNECTION?

Arguments:


Return Value:


--*/
{
	BOOLEAN					eom;
	ULONG					msgSize, readSize, bytesTaken, bytesRead;
	ULONG					lookaheadSize;
	PBYTE					lookaheadData;
	ULONG					readFlags;
	PAMDL					readBuf;
	USHORT					readBufLen;
	GENERIC_READ_COMPLETION	readCompletion;
	PVOID					readCtx;
	PIRP					recvIrp;
	PTDI_IND_RECEIVE		recvHandler;
	PVOID					recvHandlerCtx;
	NTSTATUS				ntStatus;
	BOOLEAN					callComp = FALSE, fWdwChanged = FALSE;
        ATALK_ERROR                             ErrorCode;

	do
	{
		if ((pAdspConn->adspco_Flags &
				(ADSPCO_READ_PENDING | ADSPCO_FORWARD_RESET_RECD)) ==
				(ADSPCO_READ_PENDING | ADSPCO_FORWARD_RESET_RECD))
		{
			readFlags	= pAdspConn->adspco_ReadFlags;
			readBuf		= pAdspConn->adspco_ReadBuf;
			readBufLen	= pAdspConn->adspco_ReadBufLen;
			readCompletion	= pAdspConn->adspco_ReadCompletion;
			readCtx			= pAdspConn->adspco_ReadCtx;

			pAdspConn->adspco_Flags &= ~ADSPCO_READ_PENDING;

#if DBG
            (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
			RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

			if (*readCompletion != NULL)
			{
				(*readCompletion)(ATALK_ADSP_CONN_RESET,
								  readBuf,
								  readBufLen,
								  readFlags,
								  readCtx);
			}

			//	Deref connection for the read
			AtalkAdspConnDereference(pAdspConn);

			ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
            (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif
			break;
		}

		//	Check for pending attention data
		if (pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD)
		{
			atalkAdspRecvAttn(pAdspConn);
		}

		//	Get the receive handler.
		recvHandler	= pAdspConn->adspco_pAssocAddr->adspao_RecvHandler;
		recvHandlerCtx	= pAdspConn->adspco_pAssocAddr->adspao_RecvHandlerCtx;

		//	!!!NOTE!!!
		//	Its possible that when we get a disconnect packet before we
		//	get previously sent data, we could end up indicating disconnect
		//	to afd before indicating the received data. This hits an assertion
		//	in afd on a checked build, but afd still behaves as it should.
		msgSize	= atalkAdspMessageSize(&pAdspConn->adspco_RecvQueue, &eom);
		bytesRead	= 1;	// A Non-zero value so we enter the loop
		while (((msgSize > 0) || eom) && (bytesRead > 0))
		{
			bytesRead	= 0;

			//	Check for no pending reads, but we have new data to indicate, and the
			//	client has read all the previously indicated data.
			if (((pAdspConn->adspco_Flags & ADSPCO_READ_PENDING) == 0) &&
				(*recvHandler != NULL) &&
				(pAdspConn->adspco_PrevIndicatedData == 0))
			{
				pAdspConn->adspco_PrevIndicatedData = msgSize;

				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkAdspRecvData: PrevInd1 %d\n", pAdspConn->adspco_PrevIndicatedData));

				lookaheadData	= atalkAdspGetLookahead(&pAdspConn->adspco_RecvQueue,
														&lookaheadSize);

				readFlags	= ((eom) ?
								(TDI_RECEIVE_NORMAL  | TDI_RECEIVE_ENTIRE_MESSAGE) :
								(TDI_RECEIVE_PARTIAL | TDI_RECEIVE_NORMAL));

				if (*recvHandler != NULL)
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkAdspRecvData: Indicating data %ld.%ld!\n", lookaheadSize, msgSize));

#if DBG
                    (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
					RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
					ntStatus = (*recvHandler)(recvHandlerCtx,
											  pAdspConn->adspco_ConnCtx,
											  readFlags,
											  lookaheadSize,
											  msgSize,
											  &bytesTaken,
											  lookaheadData,
											  &recvIrp);

					ASSERT((bytesTaken == 0) || (bytesTaken == msgSize));
					if (ntStatus == STATUS_MORE_PROCESSING_REQUIRED)
					{
						if (recvIrp != NULL)
						{
							//  Post the receive as if it came from the io system
							ntStatus = AtalkDispatchInternalDeviceControl(
											(PDEVICE_OBJECT)AtalkDeviceObject[ATALK_DEV_ADSP],
											recvIrp);

							ASSERT(ntStatus == STATUS_PENDING);
						}
						else
						{
							ASSERTMSG("atalkAdspRecvData: No receive irp!\n", 0);
							KeBugCheck(0);
						}
					}
					else if (ntStatus == STATUS_SUCCESS)
					{
						if (bytesTaken != 0)
						{
							//	Assume all of the data was read.
							ASSERT(bytesTaken == msgSize);
							DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
									("atalkAdspRecvData: All bytes read %lx\n", bytesTaken));

							//	Discard data from queue (msgSize + BYTECOUNT(eom))
							//	amount of data).
						}
					}
					else if (ntStatus == STATUS_DATA_NOT_ACCEPTED)
					{
						//	Client may have posted a receive in the indication. Or
						//	it will post a receive later on. Do nothing here.
						DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
								("atalkAdspRecvData: Indication status %lx\n", ntStatus));
					}
					ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
                    (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif
				}
			}

			//	Check for any posted receives, this may have happened during
			//	the receive indication.
			if (pAdspConn->adspco_Flags & ADSPCO_READ_PENDING)
			{
				readFlags		= pAdspConn->adspco_ReadFlags;
				readBuf			= pAdspConn->adspco_ReadBuf;
				readBufLen		= pAdspConn->adspco_ReadBufLen;
				readCompletion	= pAdspConn->adspco_ReadCompletion;
				readCtx			= pAdspConn->adspco_ReadCtx;

				//	For a message-based socket, we do not complete
				//	a read until eom, or the buffer fills up.
				if ((pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE) &&
					(!eom && (msgSize < readBufLen)))
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkAdspRecv: MsgSize < readLen %lx.%lx\n", msgSize, readBufLen));

					//	If we are disconnected and this data is just the last
					//	remnant from remote, we just copy what we got and leave.
					//	There may not have been an EOM from the remote.
                                        //  Also, if the msg is bigger than what transport can hold (8K),
                                        //  give whatever we have so far to the app so that our recv window
                                        //  can open up.  That is, break out of the loop only if recv window
                                        //  has room to accept more data
					if ( (pAdspConn->adspco_Flags & ADSPCO_ACTIVE) &&
                                             (pAdspConn->adspco_RecvWindow > 1))
					{
						break;
					}

					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
							("AtalkAdspRead: READ AFTER DISC %lx Flg %lx\n",
							pAdspConn, pAdspConn->adspco_Flags));
				}


				//	This will return the data in the mdl from the
				//	receive queue.
				readSize = atalkAdspReadFromBufferQueue(&pAdspConn->adspco_RecvQueue,
														readFlags,
														readBuf,
														&readBufLen,
														&eom);

				if ((readSize == 0) && !eom)
				{
					pAdspConn->adspco_PrevIndicatedData = 0;
					break;
				}

				bytesRead	+= (readSize + BYTECOUNT(eom));
				pAdspConn->adspco_Flags &= ~ADSPCO_READ_PENDING;

				//	If this is not a PEEK receive, the data will be
				//	discarded from the queue. If so, increase our window size, do a
				//	senddata to let remote know of the change.
				if ((readFlags & TDI_RECEIVE_PEEK) == 0)
				{
					pAdspConn->adspco_RecvWindow += (readSize + BYTECOUNT(eom));

					ASSERT(pAdspConn->adspco_RecvWindow <=
							pAdspConn->adspco_RecvQueueMax);

					fWdwChanged = TRUE;
				}

#if DBG
                (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
				RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
				if (*readCompletion != NULL)
				{
					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkAdspRecvData: Read for %d, %x\n", readBufLen, readFlags));

					ErrorCode = ATALK_NO_ERROR;

		                        if ((pAdspConn->adspco_pAssocAddr->adspao_Flags & ADSPAO_MESSAGE) && !eom)
                                        {
					    ErrorCode = ATALK_ADSP_PARTIAL_RECEIVE;
                                        }
					(*readCompletion)(ErrorCode,
							  readBuf,
							  readBufLen,
							  readFlags,
							  readCtx);
				}

				//	Deref connection for the read
				AtalkAdspConnDereference(pAdspConn);

				ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
                (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif

				//	Now change our prev indicated field. Until we
				//	complete the read, we musn't indicate new data.
				//	If the read was PEEK, then we don't want to do
				//	any more indications until a *real* read happens.
				if ((readFlags & TDI_RECEIVE_PEEK) == 0)
				{
					pAdspConn->adspco_PrevIndicatedData	-=
						MIN(readSize, pAdspConn->adspco_PrevIndicatedData);
				}

				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkAdspRecvData: PrevInd2 %d\n",
						pAdspConn->adspco_PrevIndicatedData));
			}

			msgSize	= atalkAdspMessageSize(&pAdspConn->adspco_RecvQueue, &eom);
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("Second msg %d.%d\n", msgSize, eom));
		}

	} while (FALSE);

	if (fWdwChanged &&
		(pAdspConn->adspco_PrevIndicatedData == 0))
	{
		atalkAdspSendData(pAdspConn);
	}
}




LOCAL VOID
atalkAdspRecvAttn(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:

	!!!THIS ROUTINE MUST PRESERVE THE STATE OF THE CONNECTION LOCK!!!

	SHOULD THIS ROUTINE HAVE ITS OWN REFERENCE FOR THE CONNECTION?

Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	PAMDL					readBuf;
	USHORT					readBufLen;
	ULONG					readFlags;
	GENERIC_READ_COMPLETION	readCompletion;
	PVOID					readCtx;
	PBYTE					attnData;
	USHORT					attnDataSize;
	ULONG					bytesRead;
	NTSTATUS				status;

	do
	{
		if ((pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_RECD) == 0)
		{
			break;
		}

		if (pAdspConn->adspco_Flags & ADSPCO_EXREAD_PENDING)
		{
			//	Use the expedited receive posted
			readFlags		= pAdspConn->adspco_ExReadFlags;
			readBuf			= pAdspConn->adspco_ExReadBuf;
			readBufLen		= pAdspConn->adspco_ExReadBufLen;
			readCompletion	= pAdspConn->adspco_ExReadCompletion;
			readCtx			= pAdspConn->adspco_ExReadCtx;

			pAdspConn->adspco_Flags &= ~ADSPCO_EXREAD_PENDING;
		}
		else if ((pAdspConn->adspco_Flags & ADSPCO_READ_PENDING) &&
				 (pAdspConn->adspco_ReadFlags & TDI_RECEIVE_EXPEDITED))
		{
			//	Use the normal receive
			readFlags		= pAdspConn->adspco_ReadFlags;
			readBuf			= pAdspConn->adspco_ReadBuf;
			readBufLen		= pAdspConn->adspco_ReadBufLen;
			readCompletion	= pAdspConn->adspco_ReadCompletion;
			readCtx			= pAdspConn->adspco_ReadCtx;

			pAdspConn->adspco_Flags &= ~ADSPCO_READ_PENDING;
		}
		else
		{
			break;
		}

		attnData		= pAdspConn->adspco_ExRecdData;
		attnDataSize	= pAdspConn->adspco_ExRecdLen;

		//	Copy received attention data into the read buffer
		error	= ATALK_ADSP_PAREXPED_RECEIVE;
		if (pAdspConn->adspco_Flags & ADSPCO_ATTN_DATA_EOM)
		{
			error = ATALK_ADSP_EXPED_RECEIVE;
		}

		if (attnDataSize > readBufLen)
		{
			attnDataSize	= readBufLen;
		}

		status = TdiCopyBufferToMdl(attnData,
									0,
									attnDataSize,
									readBuf,
									0,
									&bytesRead);

		ASSERT(NT_SUCCESS(status) && (attnDataSize == bytesRead));

		//	Update sequence number etc., only if this was not a peek.
		if ((readFlags & TDI_RECEIVE_PEEK) == 0)
		{
			pAdspConn->adspco_ExRecdData	= NULL;

			//	Advance our receive attention sequence number
			pAdspConn->adspco_RecvAttnSeq  += 1;

			pAdspConn->adspco_Flags		   &= ~(ADSPCO_ATTN_DATA_RECD |
												ADSPCO_ATTN_DATA_EOM);
		}

#if DBG
        (&pAdspConn->adspco_Lock)->FileLineLock |= 0x80000000;
#endif
		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

		//	Complete receive
		ASSERT(*readCompletion != NULL);
		(*readCompletion)(error,
						  readBuf,
						  attnDataSize,
						  TDI_RECEIVE_EXPEDITED,
						  readCtx);

		//	Free the allocated buffer if this was not a peek
		if ((readFlags & TDI_RECEIVE_PEEK) == 0)
		{
			AtalkFreeMemory(attnData);
		}

		//	Deref connection for the read
		AtalkAdspConnDereference(pAdspConn);

		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
#if DBG
        (&pAdspConn->adspco_Lock)->FileLineLock &= ~0x80000000;
#endif

		//	Send ack for the attention only if this was not a peek
		if ((readFlags & TDI_RECEIVE_PEEK) == 0)
		{
			atalkAdspSendControl(pAdspConn,
								 ADSP_CONTROL_FLAG + ADSP_ATTEN_FLAG);
		}

	} while (FALSE);
}




VOID FASTCALL
atalkAdspConnSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));
	}

	AtalkAdspConnDereference((PADSP_CONNOBJ)(pSendInfo->sc_Ctx1));
}



VOID FASTCALL
atalkAdspAddrSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));
	}

	AtalkAdspAddrDereference((PADSP_ADDROBJ)(pSendInfo->sc_Ctx1));
}




VOID FASTCALL
atalkAdspSendAttnComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));
	}
}



VOID FASTCALL
atalkAdspSendDataComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	if (pSendInfo->sc_Ctx2 != NULL)
	{
		AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx2));
	}

	if (pSendInfo->sc_Ctx3 != NULL)
	{
		atalkAdspBufferChunkDereference((PBUFFER_CHUNK)(pSendInfo->sc_Ctx3),
										FALSE,
										NULL);
	}
}



//
//	ADSP TIMER ROUTINES
//

LOCAL LONG FASTCALL
atalkAdspConnMaintenanceTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;
	LONG			now;
	BOOLEAN			done = FALSE;

	pAdspConn = (PADSP_CONNOBJ)CONTAINING_RECORD(pTimer, ADSP_CONNOBJ, adspco_ConnTimer);

	ASSERT(VALID_ADSPCO(pAdspConn));

	if (TimerShuttingDown)
	{
		done = TRUE;
	}
	else
	{
		ASSERT(VALID_ADSPCO(pAdspConn));
		ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
		if (pAdspConn->adspco_Flags & (	ADSPCO_CLOSING	|
										ADSPCO_STOPPING |
										ADSPCO_DISCONNECTING))
		{
			done = TRUE;
		}
		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	}

	if (done)
	{
		//	Dereference connection for the timer.
		AtalkAdspConnDereference(pAdspConn);
		return ATALK_TIMER_NO_REQUEUE;
	}

	now = AtalkGetCurrentTick();
	if ((now - pAdspConn->adspco_LastContactTime) > ADSP_CONNECTION_INTERVAL)
	{
		//	Connection has expired.
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspConnMaintenanceTimer: Connection %lx.%lx expired\n",
				pAdspConn, pAdspConn->adspco_LocalConnId));

		AtalkAdspDisconnect(pAdspConn,
							ATALK_TIMER_DISCONNECT,
							NULL,
							NULL);

		//	Dereference connection for the timer.
		AtalkAdspConnDereference(pAdspConn);
		return ATALK_TIMER_NO_REQUEUE;
	}

	//	If we have not heard from the other side recently, send out a
	//	probe.
	if ((now - pAdspConn->adspco_LastContactTime) > (ADSP_PROBE_INTERVAL/ATALK_TIMER_FACTOR))
	{
		KIRQL		OldIrql;

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_WARN,
				("atalkAdspConnMaintenanceTimer: Connection %lx.%lx sending probe\n",
				pAdspConn, pAdspConn->adspco_LocalConnId));

		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		atalkAdspSendControl(pAdspConn,
							 ADSP_CONTROL_FLAG + ADSP_ACK_REQ_FLAG + ADSP_PROBE_OR_ACK_CODE);
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
	}

	return ATALK_TIMER_REQUEUE;
}




LOCAL LONG FASTCALL
atalkAdspRetransmitTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;
	BOOLEAN			done = FALSE;
	KIRQL			OldIrql;

	pAdspConn = (PADSP_CONNOBJ)CONTAINING_RECORD(pTimer, ADSP_CONNOBJ, adspco_RetransmitTimer);

	ASSERT(VALID_ADSPCO(pAdspConn));

	//	BUG #19777: Since this routine could end up calling SendData which
	//	releases/acquires lock and assumes lock was acquired using the normal
	//	acquire spin lock, we can't use ACQUIRE_SPIN_LOCK_DPC here. Not a big
	//	deal as this is the retransmit case.
	//	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
	if (TimerShuttingDown)
	{
		done = TRUE;
	}
	else
	{
		ASSERT(VALID_ADSPCO(pAdspConn));
		if (pAdspConn->adspco_Flags & (	ADSPCO_CLOSING	|
										ADSPCO_STOPPING |
										ADSPCO_DISCONNECTING))
		{
			done = TRUE;
		}
	}

	if (done)
	{
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

		//	Dereference connection for the timer.
		AtalkAdspConnDereference(pAdspConn);
		return ATALK_TIMER_NO_REQUEUE;
	}

	//	We only send data if the remote has not accepted any data from the last
	//	time we fired. AND we have previously sent but still unacked data pending.
	if ((pAdspConn->adspco_FirstRtmtSeq == pAdspConn->adspco_LastTimerRtmtSeq) &&
		(atalkAdspBufferQueueSize(&pAdspConn->adspco_SendQueue) >
			atalkAdspBufferQueueSize(&pAdspConn->adspco_NextSendQueue)))
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspConnRetransmitTimer: Conn %lx Sending Data from %lx\n",
				pAdspConn, pAdspConn->adspco_FirstRtmtSeq));

		//	Rewind sequence number and resend
		pAdspConn->adspco_SendSeq		= pAdspConn->adspco_FirstRtmtSeq;
		pAdspConn->adspco_NextSendQueue = pAdspConn->adspco_SendQueue;
		atalkAdspSendData(pAdspConn);
	}
	else
	{
		pAdspConn->adspco_LastTimerRtmtSeq	= pAdspConn->adspco_FirstRtmtSeq;
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	return ATALK_TIMER_REQUEUE;
}




LOCAL LONG FASTCALL
atalkAdspAttnRetransmitTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;

	pAdspConn = (PADSP_CONNOBJ)CONTAINING_RECORD(pTimer, ADSP_CONNOBJ, adspco_ExRetryTimer);

	ASSERT(VALID_ADSPCO(pAdspConn));

	if (TimerShuttingDown)
	{
		return ATALK_TIMER_NO_REQUEUE;
	}

	atalkAdspSendAttn(pAdspConn);

	return ATALK_TIMER_REQUEUE;
}




LOCAL LONG FASTCALL
atalkAdspOpenTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;
	ATALK_ERROR		error;
	BOOLEAN			done = FALSE;

	pAdspConn = (PADSP_CONNOBJ)CONTAINING_RECORD(pTimer, ADSP_CONNOBJ, adspco_OpenTimer);

	ASSERT(VALID_ADSPCO(pAdspConn));

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspOpenTimer: Entered \n"));


	ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
	//	If the timer is shutting down, or if we have gone active, return
	if ((TimerShuttingDown) ||
		(pAdspConn->adspco_Flags & ADSPCO_ACTIVE) ||
		((pAdspConn->adspco_Flags & ADSPCO_OPEN_TIMER) == 0))
	{
		pAdspConn->adspco_Flags &= ~ADSPCO_OPEN_TIMER;
		RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

		AtalkAdspConnDereference(pAdspConn);
		return ATALK_TIMER_NO_REQUEUE;
	}

	if ((pAdspConn->adspco_Flags & (ADSPCO_CLOSING	|
									ADSPCO_STOPPING |
									ADSPCO_DISCONNECTING))	||

		(pAdspConn->adspco_ConnectAttempts == 0))
	{
		done = TRUE;
	}
	else
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspOpenTimer: Connect attempt %d\n", pAdspConn->adspco_ConnectAttempts));

		ASSERT(pAdspConn->adspco_ConnectAttempts > 0);
		pAdspConn->adspco_ConnectAttempts--;
	}
	RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

	if (!done)
	{
		//	Resend the open request.
		atalkAdspSendOpenControl(pAdspConn);
	}
	else
	{
		error = AtalkAdspDisconnect(pAdspConn,
									ATALK_TIMER_DISCONNECT,
									NULL,
									NULL);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_ERR,
				("atalkAdspOpenTimer: Disconnect %lx\n", error));

		AtalkAdspConnDereference(pAdspConn);
	}

	return (done ? ATALK_TIMER_NO_REQUEUE : ATALK_TIMER_REQUEUE);
}



LOCAL LONG FASTCALL
atalkAdspDisconnectTimer(
	IN	PTIMERLIST		pTimer,
	IN	BOOLEAN			TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;

	pAdspConn = (PADSP_CONNOBJ)CONTAINING_RECORD(pTimer, ADSP_CONNOBJ, adspco_DisconnectTimer);

	ASSERT(VALID_ADSPCO(pAdspConn));

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspDisconnectTimer: Entered \n"));

	AtalkAdspDisconnect(pAdspConn,
						ATALK_REMOTE_DISCONNECT,
						NULL,
						NULL);
	AtalkAdspConnDereference(pAdspConn);

	return ATALK_TIMER_NO_REQUEUE;
}


//
//	ADSP REFERENCE/DerefERENCE ROUTINES
//

VOID
atalkAdspAddrRefNonInterlock(
	IN	PADSP_ADDROBJ		pAdspAddr,
	OUT	PATALK_ERROR		pError
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	*pError = ATALK_NO_ERROR;

    if (pAdspAddr == NULL)
    {
        *pError = ATALK_INVALID_ADDRESS;
        return;
    }

	if ((pAdspAddr->adspao_Flags & ADSPAO_CLOSING) == 0)
	{
		ASSERT(pAdspAddr->adspao_RefCount >= 1);
		pAdspAddr->adspao_RefCount++;
	}
	else
	{
		*pError = ATALK_ADSP_ADDR_CLOSING;
	}
}




VOID
atalkAdspAddrDeref(
	IN	PADSP_ADDROBJ		pAdspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN			done = FALSE;
	KIRQL			OldIrql;

	ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
	ASSERT(pAdspAddr->adspao_RefCount > 0);
	if (--pAdspAddr->adspao_RefCount == 0)
	{
		done = TRUE;
		ASSERT(pAdspAddr->adspao_Flags & ADSPAO_CLOSING);
	}

	RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

	if (done)
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspAddrDeref: Addr %lx done with.\n", pAdspAddr));

		//	Close the DDP Address Object. This should only be done after
		//	all the connections are gone.
		AtalkDdpCloseAddress(pAdspAddr->adspao_pDdpAddr, NULL, NULL);

		if (*pAdspAddr->adspao_CloseComp != NULL)
		{
			(*pAdspAddr->adspao_CloseComp)(ATALK_NO_ERROR,
										   pAdspAddr->adspao_CloseCtx);
		}

		//	Remove from the global list.
		atalkAdspAddrDeQueueGlobalList(pAdspAddr);

		AtalkFreeMemory(pAdspAddr);

		AtalkUnlockAdspIfNecessary();
	}
}




VOID
atalkAdspConnRefByPtrNonInterlock(
	IN	PADSP_CONNOBJ		pAdspConn,
	IN	ULONG				NumCount,
	OUT	PATALK_ERROR		pError
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	*pError = ATALK_NO_ERROR;
	ASSERT(VALID_ADSPCO(pAdspConn));

    if (pAdspConn == NULL)
    {
        *pError = ATALK_INVALID_CONNECTION;
        return;
    }

	if ((pAdspConn->adspco_Flags & ADSPCO_CLOSING) == 0)
	{
		ASSERT(pAdspConn->adspco_RefCount >= 1);
		ASSERT(NumCount > 0);

		pAdspConn->adspco_RefCount += NumCount;
	}
	else
	{
		*pError = ATALK_ADSP_CONN_CLOSING;
	}
}




VOID
atalkAdspConnRefByCtxNonInterlock(
	IN	PADSP_ADDROBJ		pAdspAddr,
	IN	CONNECTION_CONTEXT	Ctx,
	OUT	PADSP_CONNOBJ	*	pAdspConn,
	OUT	PATALK_ERROR		pError
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE ADDRESS LOCK HELD!!!

Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspChkConn;

	*pError = ATALK_ADSP_CONN_NOT_FOUND;

	for (pAdspChkConn = pAdspAddr->adspao_pAssocConn;
		 pAdspChkConn != NULL;
		 pAdspChkConn = pAdspChkConn->adspco_pNextAssoc)
	{
		if (pAdspChkConn->adspco_ConnCtx == Ctx)
		{
			AtalkAdspConnReferenceByPtr(pAdspChkConn, pError);
			if (ATALK_SUCCESS(*pError))
			{
				*pAdspConn = pAdspChkConn;
			}

			break;
		}
	}
}




VOID
atalkAdspConnRefBySrcAddr(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PATALK_ADDR		pRemoteAddr,
	IN	USHORT			RemoteConnId,
	OUT	PADSP_CONNOBJ *	ppAdspConn,
	OUT	PATALK_ERROR	pError
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE ADDRESS LOCK HELD!!!

Arguments:


Return Value:


--*/
{
	ULONG			index;
	PADSP_CONNOBJ	pAdspConn;

	//	Thread the connection object into addr lookup by session id.
	index	= HASH_ID_SRCADDR(RemoteConnId, pRemoteAddr);

	index  %= ADSP_CONN_HASH_SIZE;

	for (pAdspConn = pAdspAddr->adspao_pActiveHash[index];
		 pAdspConn != NULL;
		 pAdspConn = pAdspConn->adspco_pNextActive)
	{
		if ((pAdspConn->adspco_RemoteConnId == RemoteConnId) &&
			(ATALK_ADDRS_EQUAL(&pAdspConn->adspco_RemoteAddr, pRemoteAddr)))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnRefBySrcAddr: Found %lx\n", pAdspConn));
			break;
		}
	}

	*pError = ATALK_INVALID_CONNECTION;
	if (pAdspConn != NULL)
	{
		KIRQL	OldIrql;

		//	Check state to make sure we are not disconnecting/stopping/closing.
		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		if ((pAdspConn->adspco_Flags & (ADSPCO_ACTIVE | ADSPCO_HALF_ACTIVE)) &&
			((pAdspConn->adspco_Flags & (ADSPCO_CLOSING |
										ADSPCO_STOPPING|
										ADSPCO_DISCONNECTING)) == 0))
		{
			pAdspConn->adspco_RefCount++;
			*pError = ATALK_NO_ERROR;
			*ppAdspConn = pAdspConn;
		}
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
	}
}




VOID
atalkAdspConnRefNextNc(
	IN		PADSP_CONNOBJ		pAdspConn,
	IN		PADSP_CONNOBJ	*	ppAdspConnNext,
	OUT		PATALK_ERROR		pError
	)
/*++

Routine Description:

	MUST BE CALLED WITH THE ASSOCIATED ADDRESS LOCK HELD!

Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pNextConn	= NULL;

	*pError		= ATALK_FAILURE;

	ASSERT(VALID_ADSPCO(pAdspConn));

	for (; pAdspConn != NULL; pAdspConn = pAdspConn->adspco_pNextActive)
	{
		AtalkAdspConnReferenceByPtr(pAdspConn, pError);
		if (ATALK_SUCCESS(*pError))
		{
			//	Ok, this connection is referenced!
			*ppAdspConnNext = pAdspConn;
			break;
		}
	}
}



VOID
atalkAdspConnDeref(
	IN	PADSP_CONNOBJ		pAdspConn
	)
/*++

Routine Description:

	Disconnect completion happens when the reference count goes from
	2->1 if the creation reference is not already removed. If the creation
	reference is already removed, it will be done when the refcount goes
	from 1->0.

	Creation reference is never removed until cleanup completes.

Arguments:


Return Value:


--*/
{
	BOOLEAN			fEndProcessing = FALSE;
	KIRQL			OldIrql;

	ASSERT(VALID_ADSPCO(pAdspConn));
	ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);

	ASSERT(pAdspConn->adspco_RefCount > 0);
	--pAdspConn->adspco_RefCount;

	if (pAdspConn->adspco_RefCount > 1)
	{
		fEndProcessing = TRUE;
	}
	RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

	if (fEndProcessing)
	{
		return;
	}
	else
	{
		ATALK_ERROR				disconnectStatus;
		PADSP_ADDROBJ			pAdspAddr	= pAdspConn->adspco_pAssocAddr;
		BOOLEAN					done		= FALSE;
		BOOLEAN					disconnDone = FALSE;
		BOOLEAN					pendingRead = FALSE;
		BOOLEAN					pendingWrite= FALSE;
		BOOLEAN					stopping	= FALSE;
		GENERIC_COMPLETION		disconnectInform		= NULL;
		PVOID					disconnectInformCtx		= NULL;
		GENERIC_COMPLETION		disconnectCompletion	= NULL;
		PVOID					disconnectCtx			= NULL;
		PVOID					cleanupCtx				= NULL;
		GENERIC_COMPLETION		cleanupCompletion		= NULL;

		//	We allow stopping phase to happen only after disconnecting is done.
		//	If disconnecting is not set and stopping is, it implies we are only
		//	in an associated state.
		ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
		stopping	= (pAdspConn->adspco_Flags & ADSPCO_STOPPING) ? TRUE : FALSE;
		if (pAdspConn->adspco_Flags & ADSPCO_DISCONNECTING)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeref: Disconnect set for %lx\n", pAdspConn));

			//	Are we done disconnecting? Since cleanup wont complete until disc
			//	does, we don't have to worry about the creation ref having gone
			//	away.
			if (pAdspConn->adspco_RefCount == 1)
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkAdspConnDeref: Disconnect done (1) %lx\n", pAdspConn));

				//	Avoid multiple disconnect completions/close atp addresses
				//	Remember all the disconnect info before we release the lock
				disconnectInform		= pAdspConn->adspco_DisconnectInform;
				disconnectInformCtx		= pAdspConn->adspco_DisconnectInformCtx;
				disconnectStatus		= pAdspConn->adspco_DisconnectStatus;
				disconnectCompletion	= pAdspConn->adspco_DisconnectCompletion;
				disconnectCtx			= pAdspConn->adspco_DisconnectCtx;

				//	Reset all the be null, so next request doesnt get any
				pAdspConn->adspco_DisconnectInform		= NULL;
				pAdspConn->adspco_DisconnectInformCtx	= NULL;
				pAdspConn->adspco_DisconnectCompletion	= NULL;
				pAdspConn->adspco_DisconnectCtx			= NULL;

				disconnDone = TRUE;
				stopping	= (pAdspConn->adspco_Flags & ADSPCO_STOPPING) ? TRUE : FALSE;
			}
			else
			{
				//	Set stopping to false as disconnect is not done yet.
				stopping = FALSE;
			}
		}

		if (pAdspConn->adspco_RefCount == 0)
		{
			done = TRUE;
			ASSERT(pAdspConn->adspco_Flags & ADSPCO_CLOSING);
		}
		RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

		if (disconnDone)
		{
			//	Remove from the active queue.
			//	Reset all relevent flags.
			ACQUIRE_SPIN_LOCK(&pAdspAddr->adspao_Lock, &OldIrql);
			ACQUIRE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);

			pAdspConn->adspco_Flags	&=	~(ADSPCO_LISTENING	|
										  ADSPCO_CONNECTING	|
										  ADSPCO_HALF_ACTIVE|
										  ADSPCO_ACTIVE		|
										  ADSPCO_DISCONNECTING);

			atalkAdspConnDeQueueActiveList(pAdspAddr, pAdspConn);

            // if the address has been disassociated, time to unlink it.
            if (!(pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED))
            {
		        pAdspConn->adspco_pAssocAddr = NULL;
            }

			RELEASE_SPIN_LOCK_DPC(&pAdspConn->adspco_Lock);
			RELEASE_SPIN_LOCK(&pAdspAddr->adspao_Lock, OldIrql);

			//	Call the disconnect completion routines.
			if (*disconnectInform != NULL)
			{
				(*disconnectInform)(disconnectStatus, disconnectInformCtx);
			}

			if (*disconnectCompletion != NULL)
			{
				(*disconnectCompletion)(disconnectStatus, disconnectCtx);
			}
		}

		if (stopping)
		{
			ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			if ((pAdspConn->adspco_Flags & ADSPCO_STOPPING) != 0)
			{
				BOOLEAN	fDisassoc = FALSE;

				//	See if we do the cleanup irp completion.
				if (pAdspConn->adspco_RefCount == 1)
				{
					cleanupCtx			= pAdspConn->adspco_CleanupCtx;
					cleanupCompletion	= pAdspConn->adspco_CleanupComp;
					pAdspConn->adspco_CleanupComp = NULL;
					pAdspConn->adspco_Flags &= ~ADSPCO_STOPPING;

					DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
							("atalkAdspConnDeref: Cleanup on %lx.%lx\n", pAdspConn, cleanupCtx));

					if ((pAdspConn->adspco_Flags & (ADSPCO_LISTENING	|
													ADSPCO_CONNECTING	|
													ADSPCO_ACTIVE)) == 0)
					{
						DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
								("atalkAdspConnDeref: Stopping - do disassoc for %lx\n", pAdspConn));

						fDisassoc = (pAdspConn->adspco_Flags & ADSPCO_ASSOCIATED) ? TRUE: FALSE;
					}
				}
				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);

				if (fDisassoc)
				{
					//	Call the disassociate routine. This should just fail, if the
					//	connection is still active or any other state than just
					//	plain associated.
					AtalkAdspDissociateAddress(pAdspConn);
				}
			}
			else
			{
				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
			}
		}

		if (done)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeref: Close done for %lx\n", pAdspConn));

			//	Call the close completion routines
			ASSERT(*pAdspConn->adspco_CloseComp != NULL);
			if (*pAdspConn->adspco_CloseComp != NULL)
			{
				(*pAdspConn->adspco_CloseComp )(ATALK_NO_ERROR,
												pAdspConn->adspco_CloseCtx);
			}

			//	Remove from the global list.
			atalkAdspConnDeQueueGlobalList(pAdspConn);

			//	Free up the connection memory.
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeref: Freeing up connection %lx\n", pAdspConn));

			AtalkUnlockAdspIfNecessary();
			AtalkFreeMemory(pAdspConn);
		}

		if (*cleanupCompletion != NULL)
		{
			(*cleanupCompletion)(ATALK_NO_ERROR, cleanupCtx);
		}
	}
}




//
//	ADSP BUFFER QUEUE MANAGEMENT ROUTINES
//

ULONG
atalkAdspMaxSendSize(
	IN	PADSP_CONNOBJ		pAdspConn
	)
/*++

Routine Description:

	The answer is the remaining available (to fill) space in the retransmit
	queue -- this includes data we're saving for possible retransmit as well
	as data we haven't sent yet.  Actually, this could go negative because
	BufferQueueSize counts EOMs and sendQueueMax doesn't -- answer with zero
	if this happens.

Arguments:


Return Value:


--*/
{
	LONG	sendSize;

	sendSize = pAdspConn->adspco_SendQueueMax -
			   atalkAdspBufferQueueSize(&pAdspConn->adspco_SendQueue);

	if (sendSize < 0)
	{
		sendSize = 0;
	}

	return ((ULONG)sendSize);
}




ULONG
atalkAdspMaxNextReadSize(
	IN	PBUFFER_QUEUE	pQueue,
	OUT	PBOOLEAN		pEom,
	OUT	PBUFFER_CHUNK *	pBufferChunk
	)
/*++

Routine Description:

	Return the size of data in a buffer queue; upto the end of the
	current chunk, or to the eom.

Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	ULONG			nextReadSize;
	ULONG			startIndex		= pQueue->bq_StartIndex;

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	*pEom = FALSE;

	//	Walk the queue.
	for (pCurrentChunk = pQueue->bq_Head;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pCurrentChunk->bc_Next)
	{
		//	Check for nothing in the current chunk
		if (startIndex == (ULONG)(pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM)))
		{
			startIndex = 0;
			continue;
		}

		nextReadSize = pCurrentChunk->bc_DataSize - startIndex;
		if (pCurrentChunk->bc_Flags & BC_EOM)
		{
			*pEom	   = TRUE;
		}

		*pBufferChunk = pCurrentChunk;
		break;
	}

	//	Return the size.
	return nextReadSize;
}




ULONG
atalkAdspDescribeFromBufferQueue(
	IN	PBUFFER_QUEUE	pQueue,
	OUT	PBOOLEAN		pEom,
	IN	ULONG			WindowSize,
	OUT	PBUFFER_CHUNK *	ppBufferChunk,
	OUT	PBUFFER_DESC  * ppBuffDesc
	)
/*++

Routine Description:

	In order to avoid pQueue (nextSendQueue) to go to null when all the data available
	is being sent, we make it logically be at the end while still pointing to the
	buffer chunk. This is the reason, we have all the datasize == (startindex + eom)
	checks. This is where such a condition will be created.

	NO! We let pQueue go to null when all the data is done, otherwise we will have
	pointers to a buffer chunk that will be freed during discard, and we dont want to
	make discard dependent upon the auxqueue.

Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	PBUFFER_DESC	pBuffDesc;
	ULONG			nextReadSize	= 0;
	ULONG			startIndex		= pQueue->bq_StartIndex;

	*pEom			= FALSE;
	*ppBufferChunk	= NULL;
	*ppBuffDesc		= NULL;

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	//	Walk the queue.
	for (pCurrentChunk = pQueue->bq_Head;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pCurrentChunk->bc_Next)
	{
		//	Check for nothing in the current chunk
		if (startIndex == (ULONG)(pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM)))
		{
			ASSERT(0);
			startIndex = 0;
			continue;
		}

		nextReadSize	= pCurrentChunk->bc_DataSize - startIndex;

		//	Look at eom only if chunk is consumed.
		*pEom			= FALSE;
		ASSERT(nextReadSize <= pCurrentChunk->bc_DataSize);

		//	Make sure dataSize is within bounds
		if (nextReadSize > ADSP_MAX_DATA_SIZE)
		{
			nextReadSize = ADSP_MAX_DATA_SIZE;
		}

		if (nextReadSize > (ULONG)WindowSize)
		{
			nextReadSize = (ULONG)WindowSize;
		}

		if (nextReadSize > 0)
		{
			//	First try to reference the buffer chunk. This should always succeed.
			atalkAdspBufferChunkReference(pCurrentChunk);

			//	Create a descriptor for the data. The above reference goes away in a send
			//	complete.
			pBuffDesc = AtalkDescribeBuffDesc((PBYTE)pCurrentChunk + sizeof(BUFFER_CHUNK) + startIndex,
											   NULL,
											   (USHORT)nextReadSize,
											   BD_CHAR_BUFFER);

			*ppBufferChunk	= pCurrentChunk;
			*ppBuffDesc		= pBuffDesc;
		}

		//	Also update the queue for this data. Either we have consumed
		//	this chunk or we have just used a portion of it.
		if ((nextReadSize + startIndex) == pCurrentChunk->bc_DataSize)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspDescribeFromBufferQueue: Chunk consumed %d\n",
					pCurrentChunk->bc_DataSize));

			ASSERT(pQueue->bq_Head != NULL);

			//	Set EOM if chunk had one.
			if (pCurrentChunk->bc_Flags & BC_EOM)
			{
				*pEom	   = TRUE;
			}

			if (pQueue->bq_Head == pQueue->bq_Tail)
			{
				ASSERT(pQueue->bq_Head->bc_Next == NULL);
				pQueue->bq_Tail = pQueue->bq_Head->bc_Next;
				ASSERT(pQueue->bq_Tail == NULL);
			}

			pQueue->bq_Head		= pQueue->bq_Head->bc_Next;
			pQueue->bq_StartIndex	= (ULONG)0;
		}
		else
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspDescribeFromBufferQueue: Chunk not consumed %d.%d\n",
					pCurrentChunk->bc_DataSize, nextReadSize+startIndex));

			//	Just set the start index
			pQueue->bq_StartIndex  += (ULONG)nextReadSize;
		}

		break;
	}

	//	Return the size.
	return nextReadSize;
}



ULONG
atalkAdspBufferQueueSize(
	IN	PBUFFER_QUEUE	pQueue
	)
/*++

Routine Description:

	Return the total size of a buffer queue; each EOM counts as a single
	byte.

Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	ULONG			startIndex;
	ULONG			queueSize;

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	//	Walk the queue.
	for (queueSize	= 0, startIndex	= pQueue->bq_StartIndex, pCurrentChunk = pQueue->bq_Head;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pCurrentChunk->bc_Next)
	{
		//	Check for nothing in the current chunk.
		if (startIndex == (ULONG)(pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM)))
		{
			startIndex = 0;
			continue;
		}

		queueSize += (	pCurrentChunk->bc_DataSize -
						startIndex +
						BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM));

		//	StartIndex only counts in first chunk
		startIndex = 0;
	}

	//	Return the size.
	return queueSize;
}




ULONG
atalkAdspMessageSize(
	IN	PBUFFER_QUEUE	pQueue,
	OUT	PBOOLEAN		pEom
	)
/*++

Routine Description:

	Return the total size of the data in the buffer queue, stopping at eom
	or end of data. EOM is not part of the count.

Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	ULONG			msgSize	= 0;
	ULONG			startIndex	= pQueue->bq_StartIndex;

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	*pEom	= FALSE;

	//	Walk the queue.
	for (pCurrentChunk = pQueue->bq_Head;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pCurrentChunk->bc_Next)
	{
		//	Check for nothing in the current chunk.
		if (startIndex == (ULONG)(pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM)))
		{
			startIndex = 0;
			continue;
		}

		msgSize += (pCurrentChunk->bc_DataSize - startIndex);
		if (pCurrentChunk->bc_Flags & BC_EOM)
		{
			*pEom	= TRUE;
			break;
		}

		//	StartIndex only counts in first chunk
		startIndex = 0;
	}

	//	Return the size.
	return msgSize;
}




PBUFFER_CHUNK
atalkAdspAllocCopyChunk(
	IN	PVOID	pWriteBuf,
	IN	USHORT	WriteBufLen,
	IN	BOOLEAN	Eom,
	IN	BOOLEAN	IsCharBuffer
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pChunk;
	PBYTE			pData;
	NTSTATUS		status;
	ULONG			bytesCopied;

	if ((pChunk = (PBUFFER_CHUNK)AtalkAllocMemory(sizeof(BUFFER_CHUNK) + WriteBufLen)) != NULL)
	{

		pChunk->bc_DataSize = WriteBufLen;
		pChunk->bc_Flags	= (Eom ? BC_EOM : 0);
		pChunk->bc_Next		= NULL;
		pChunk->bc_RefCount	= 1;			// Creation ref count

		INITIALIZE_SPIN_LOCK(&pChunk->bc_Lock);

		//	Copy the data over if its greater than zero
		if (WriteBufLen > 0)
		{
			pData = (PBYTE)pChunk + sizeof(BUFFER_CHUNK);
			if (IsCharBuffer)
			{
				RtlCopyMemory(pData,
							  (PBYTE)pWriteBuf,
							  WriteBufLen);
			}
			else
			{
				status = TdiCopyMdlToBuffer((PMDL)pWriteBuf,
											0,
											pData,
											0,
											WriteBufLen,
											&bytesCopied);

				ASSERT(!NT_ERROR(status) && (bytesCopied == (ULONG)WriteBufLen));
			}
		}
	}

	return pChunk;
}




PBYTE
atalkAdspGetLookahead(
	IN	PBUFFER_QUEUE	pQueue,
	OUT	PULONG			pLookaheadSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	ULONG			startIndex	= pQueue->bq_StartIndex;

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	pCurrentChunk = pQueue->bq_Head;
	if (pCurrentChunk != NULL)
	{
		//	Do we need to go past the current chunk?
		if (startIndex == (ULONG)(pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM)))
		{
			pCurrentChunk	= pCurrentChunk->bc_Next;
			startIndex		= 0;
		}
	}

	ASSERT(pCurrentChunk != NULL);
	if (pCurrentChunk == NULL)
	{
		KeBugCheck(0);
	}

	*pLookaheadSize = pCurrentChunk->bc_DataSize - startIndex;
	return((*pLookaheadSize == 0) ?
			NULL	:
			(PBYTE)pCurrentChunk + sizeof(BUFFER_CHUNK) + startIndex);
}




VOID
atalkAdspAddToBufferQueue(
	IN	OUT	PBUFFER_QUEUE	pQueue,
	IN		PBUFFER_CHUNK	pChunk,
	IN	OUT	PBUFFER_QUEUE	pAuxQueue	OPTIONAL
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE CONNECTION LOCK HELD!!!

Arguments:


Return Value:


--*/
{
	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	if (pQueue->bq_Head != NULL)
	{
		//	Add the chunk to the end of the queue
		ASSERT(pQueue->bq_Tail != NULL);
		pQueue->bq_Tail->bc_Next = pChunk;
		pQueue->bq_Tail	= pChunk;

		ASSERT(pChunk->bc_Next == NULL);

		//	The auxiliary queue is the nextsend queue, which can go to null
		//	if we have sent all the data. If that is the case, we need to
		//	reset the head also.
		if (ARGUMENT_PRESENT(pAuxQueue))
		{
			if (pAuxQueue->bq_Head	== NULL)
			{
				pAuxQueue->bq_Head	= pChunk;
			}

			pAuxQueue->bq_Tail	= pChunk;
		}
	}
	else
	{
		pQueue->bq_Head			= pQueue->bq_Tail	= pChunk;
		pQueue->bq_StartIndex	= (ULONG)0;
		if (ARGUMENT_PRESENT(pAuxQueue))
		{
			//	Initialize the next send queue only if this is a send queue
			pAuxQueue->bq_Head		= pAuxQueue->bq_Tail = pChunk;
			pAuxQueue->bq_StartIndex= (ULONG)0;
		}
	}
}




ULONG
atalkAdspReadFromBufferQueue(
	IN		PBUFFER_QUEUE	pQueue,
	IN		ULONG			ReadFlags,
	OUT		PAMDL			pReadBuf,
	IN	OUT	PUSHORT			pReadLen,
	OUT		PBOOLEAN		pEom
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk;
	ULONG			bytesRead, copySize, dataIndex, dataSize, lastReadIndex;
	NTSTATUS		status;
	LONG			startIndex	= pQueue->bq_StartIndex;
	ATALK_ERROR		error		= ATALK_NO_ERROR;
	ULONG			readSize	= 0;					// size counting eom

	ASSERT(((pQueue->bq_Head == NULL) && (pQueue->bq_Tail == NULL)) ||
		   ((pQueue->bq_Head != NULL) && (pQueue->bq_Tail != NULL)));

	*pEom			= FALSE;
	readSize		= 0;
	pCurrentChunk	= pQueue->bq_Head;
	if ((pCurrentChunk == NULL) ||
		((pCurrentChunk->bc_Next == NULL) &&
		 ((ULONG)startIndex ==	pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM))))
	{
		*pReadLen	= 0;
		return 0;
	}

	dataIndex	= 0;
	dataSize	= *pReadLen;

	//	Copy data until we exhaust src/dest buffers or hit an eom
	for (;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pCurrentChunk->bc_Next)
	{
		if ((ULONG)startIndex == pCurrentChunk->bc_DataSize +
									BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM))
		{
			ASSERT(0);
			startIndex = 0;
			continue;
		}

		copySize = MIN((ULONG)(pCurrentChunk->bc_DataSize - startIndex), dataSize);
		if (copySize > 0)
		{
			status = TdiCopyBufferToMdl((PBYTE)pCurrentChunk +
											sizeof(BUFFER_CHUNK) +
											startIndex,
										0,
										copySize,
										pReadBuf,
										dataIndex,
										&bytesRead);

			ASSERT(NT_SUCCESS(status) && (copySize == bytesRead));
		}

		dataIndex		+= copySize;
		readSize		+= copySize;
		dataSize		-= copySize;
		lastReadIndex	=  startIndex + copySize;

		//	Check for terminating conditions
		startIndex = 0;

		//	Check EOM only if chunk consumed.
		if ((lastReadIndex == pCurrentChunk->bc_DataSize) &&
			(pCurrentChunk->bc_Flags & BC_EOM))
		{
			readSize	+= 1;
			*pEom = TRUE;
			break;
		}

		if (dataSize == 0)		//	Is the user buffer full?
		{
			break;
		}
	}

	*pReadLen	= (USHORT)dataIndex;

	//	Free any chunks that we are done with, only if this was not a peek request.
	if ((ReadFlags & TDI_RECEIVE_PEEK) == 0)
	{
		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspReadFromBufferQueue: Discarding data %lx\n", dataIndex));

		atalkAdspDiscardFromBufferQueue(pQueue,
										readSize,
										NULL,
										ATALK_NO_ERROR,
										NULL);
	}

	return dataIndex;
}




BOOLEAN
atalkAdspDiscardFromBufferQueue(
	IN		PBUFFER_QUEUE	pQueue,
	IN		ULONG			DataSize,
	OUT		PBUFFER_QUEUE	pAuxQueue,
	IN		ATALK_ERROR		Error,
	IN		PADSP_CONNOBJ	pAdspConn	OPTIONAL	//	Required for send queue
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_CHUNK	pCurrentChunk, pNextChunk;
	ULONG			chunkSize, startIndex = pQueue->bq_StartIndex;

	//	BUBBUG:	error checks

	//	Walk along the queue discarding the data we have already read
	for (pCurrentChunk = pQueue->bq_Head, pNextChunk = NULL;
		 pCurrentChunk != NULL;
		 pCurrentChunk = pNextChunk)
	{
		pNextChunk = pCurrentChunk->bc_Next;

		chunkSize = pCurrentChunk->bc_DataSize -
						startIndex + BYTECOUNT(pCurrentChunk->bc_Flags & BC_EOM);

		DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
				("atalkAdspDiscardFromBufferQueue: Discarding %ld.%ld\n", DataSize, chunkSize));

		//	If we finished discarding but there is still some data left in the
		//	current chunk, just reset the start index.
		if (DataSize < chunkSize)
		{
			// Already done: pQueue->bq_Head = pCurrentChunk;
			pQueue->bq_StartIndex	= startIndex + DataSize;

			ASSERT((pQueue->bq_Head != pQueue->bq_Tail) ||
					(pCurrentChunk->bc_Next == NULL));

			return TRUE;
		}

		//	Otherwise, we have discarded a whole chunk
		if ((pAuxQueue != NULL) &&
			(pAuxQueue->bq_Head == pCurrentChunk) &&
			((pAuxQueue->bq_Head->bc_Next != NULL) ||
			 (pAuxQueue->bq_StartIndex <
				(pAuxQueue->bq_Head->bc_DataSize +
					(ULONG)BYTECOUNT(pAuxQueue->bq_Head->bc_Flags & BC_EOM)))))
		{
			ASSERT(0);
			pAuxQueue->bq_Head			= pAuxQueue->bq_Tail = NULL;
			pAuxQueue->bq_StartIndex	= (ULONG)0;
		}

		//	If SEND chunk, set error for the send to be success
		if (pCurrentChunk->bc_Flags & BC_SEND)
		{
			pCurrentChunk->bc_WriteError	= Error;
			ASSERT(pAdspConn != NULL);
		}

                //
                // make our head point to the next guy since this chunk is going away.
                //
                pQueue->bq_Head = pNextChunk;
                pQueue->bq_StartIndex = 0;

                if (pQueue->bq_Tail == pCurrentChunk)
                {
                    pQueue->bq_Tail = NULL;
                }

		//	Deref for creation.
		atalkAdspBufferChunkDereference(pCurrentChunk,
										TRUE,
										pAdspConn);

		//	Move on to the next chunk
		DataSize	-= chunkSize;
		startIndex	 = 0;
	}

	//	If we are here, then the whole queue has been discarded, mark
	//	it as empty
	ASSERT(DataSize == 0);

	//pQueue->bq_Head = pQueue->bq_Tail = NULL;
	//pQueue->bq_StartIndex = 0;

        //
        // if the last chunk gets freed above, we release the spinlock to complete the
        // irp associated with the chunk and then grab it again.  It's possible to get
        // a new send in that window, so bq_head may not necessarily be NULL at this
        // point (in fact, bug #16660 turned out to be exactly this!!)
        //
	if (pQueue->bq_Head == NULL)
        {
            ASSERT(pQueue->bq_Tail == NULL);

            if (pAuxQueue != NULL)
	    {
		pAuxQueue->bq_Head = pAuxQueue->bq_Tail = NULL;
		pAuxQueue->bq_StartIndex = (LONG)0;
            }
	}

	return TRUE;
}




VOID
atalkAdspBufferChunkReference(
	IN	PBUFFER_CHUNK		pBufferChunk
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&pBufferChunk->bc_Lock, &OldIrql);
	if ((pBufferChunk->bc_Flags & BC_CLOSING) == 0)
	{
		pBufferChunk->bc_RefCount++;
	}
	else
	{
		//	Should never be trying to reference this when closing. The retransmit
		//	timer should have been cancelled.
		KeBugCheck(0);
	}
	RELEASE_SPIN_LOCK(&pBufferChunk->bc_Lock, OldIrql);
}




VOID
atalkAdspBufferChunkDereference(
	IN	PBUFFER_CHUNK		pBufferChunk,
	IN	BOOLEAN				CreationDeref,
	IN	PADSP_CONNOBJ		pAdspConn	OPTIONAL	//	Required for send chunk
													//	If spinlock held
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN	done		= FALSE;
	BOOLEAN	sendChunk	= FALSE;
	KIRQL	OldIrql;


	ACQUIRE_SPIN_LOCK(&pBufferChunk->bc_Lock, &OldIrql);
	if (!CreationDeref ||
		((pBufferChunk->bc_Flags & BC_CLOSING) == 0))
	{
		if (CreationDeref)
		{
			pBufferChunk->bc_Flags |= BC_CLOSING;
		}

		if (--pBufferChunk->bc_RefCount == 0)
		{
			ASSERT(pBufferChunk->bc_Flags & BC_CLOSING);
			done		= TRUE;
			sendChunk	= (pBufferChunk->bc_Flags & BC_SEND) ? TRUE : FALSE;
		}
	}
	RELEASE_SPIN_LOCK(&pBufferChunk->bc_Lock, OldIrql);

	if (done)
	{
		//	Call send completion if this is a send buffer chunk
		if (sendChunk)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkChunkDereference: Completing send %lx. %lx - %d.%d\n",
					pAdspConn, pBufferChunk->bc_WriteCtx,
					pBufferChunk->bc_DataSize, pBufferChunk->bc_WriteError));

			if (pAdspConn != NULL)
			{
				DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
						("atalkChunkDereference: Completing send %lx.%lx\n",
						pAdspConn, pBufferChunk->bc_WriteCtx));

				//	Release connection lock
				RELEASE_SPIN_LOCK(&pAdspConn->adspco_Lock, OldIrql);
			}

			//	Call the completion routine. We complete with no error, but
			//	need to return pending.
			ASSERT((*pBufferChunk->bc_WriteCompletion) != NULL);
			(*pBufferChunk->bc_WriteCompletion)(pBufferChunk->bc_WriteError,
												pBufferChunk->bc_WriteBuf,
												pBufferChunk->bc_DataSize,
												pBufferChunk->bc_WriteCtx);

			if (pAdspConn != NULL)
			{
				ACQUIRE_SPIN_LOCK(&pAdspConn->adspco_Lock, &OldIrql);
			}
		}


		//	This better not be part of the queues at this point, we should
		//	just be able to free it up. The idea is that if a particular
		//	buffer descriptor has its creation reference removed, its only
		//	because the data is being discarded or the connection is shutting
		//	down, in both cases, the data previous to this must be also being
		//	discarded and the buffer queue pointers will be set to the chunks
		//	following the ones being discarded. If this wont be true, walk the
		//	list (need more info coming in) and unlink this chunk before freeing
		//	it.
		AtalkFreeMemory(pBufferChunk);
	}
}




//
//	ADSP UTILITY ROUTINES
//


VOID
atalkAdspDecodeHeader(
	IN	PBYTE	Datagram,
	OUT	PUSHORT	RemoteConnId,
	OUT	PULONG	FirstByteSeq,
	OUT	PULONG	NextRecvSeq,
	OUT	PLONG	Window,
	OUT	PBYTE	Descriptor
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	GETSHORT2SHORT(RemoteConnId, Datagram + ADSP_SRC_CONNID_OFF);

	GETDWORD2DWORD(FirstByteSeq, Datagram + ADSP_FIRST_BYTE_SEQNUM_OFF);

	GETDWORD2DWORD(NextRecvSeq, Datagram + ADSP_NEXT_RX_BYTESEQNUM_OFF);

	GETSHORT2DWORD(Window, Datagram + ADSP_RX_WINDOW_SIZE_OFF);

	//	Set the descriptor
	*Descriptor = Datagram[ADSP_DESCRIPTOR_OFF];
}




LOCAL USHORT
atalkAdspGetNextConnId(
	IN	PADSP_ADDROBJ	pAdspAddr,
	OUT	PATALK_ERROR	pError
	)
/*++

Routine Description:

	CALLED WITH THE ADDRESS SPIN LOCK HELD!

Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspConn;
	USHORT			i;
	USHORT			startConnId, connId;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	startConnId = connId = ++pAdspAddr->adspao_NextConnId;
	while (TRUE)
	{
		for (i = 0; i < ADSP_CONN_HASH_SIZE; i++)
		{
			for (pAdspConn = pAdspAddr->adspao_pActiveHash[i];
				((pAdspConn != NULL) && (pAdspConn->adspco_LocalConnId != connId));
				pAdspConn = pAdspConn->adspco_pNextActive);

			if (pAdspConn != NULL)
				break;
		}

		if (pAdspConn == NULL)
		{
			break;
		}
		else
		{
			if (connId == (startConnId - 1))
			{
				ASSERT(0);

				//	We wrapped around and there are no more conn ids.
				error = ATALK_RESR_MEM;
				break;
			}
			connId++;
		}
	}

	DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
			("atalkAdspGetNextConnId: ConnId %lx for %lx\n", connId, pAdspAddr));

	*pError = error;
	return(ATALK_SUCCESS(error) ? connId : 0);
}




LOCAL	BOOLEAN
atalkAdspConnDeQueueAssocList(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspRemConn, *ppAdspRemConn;
	BOOLEAN			removed = FALSE;

	for (ppAdspRemConn = &pAdspAddr->adspao_pAssocConn;
		 ((pAdspRemConn = *ppAdspRemConn) != NULL); )
	{
		if (pAdspRemConn == pAdspConn)
		{
			removed = TRUE;
			*ppAdspRemConn = pAdspRemConn->adspco_pNextAssoc;
			break;
		}
		else
		{
			ppAdspRemConn = &pAdspRemConn->adspco_pNextAssoc;
		}
	}

	return removed;
}




LOCAL	BOOLEAN
atalkAdspConnDeQueueConnectList(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspRemConn, *ppAdspRemConn;
	BOOLEAN			removed = FALSE;

	ASSERT(pAdspAddr->adspao_Flags & ADSPAO_CONNECT);

	for (ppAdspRemConn = &pAdspAddr->adspao_pConnectConn;
			((pAdspRemConn = *ppAdspRemConn) != NULL); )
	{
		if (pAdspRemConn == pAdspConn)
		{
			removed = TRUE;
			*ppAdspRemConn = pAdspRemConn->adspco_pNextConnect;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeQueueConnectList: Removed connect conn %lx\n", pAdspConn));
			break;
		}
		else
		{
			ppAdspRemConn = &pAdspRemConn->adspco_pNextConnect;
		}
	}

	return removed;
}




LOCAL	BOOLEAN
atalkAdspConnDeQueueListenList(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspRemConn, *ppAdspRemConn;
	BOOLEAN			removed = FALSE;

	ASSERT(pAdspAddr->adspao_Flags & ADSPAO_LISTENER);

	for (ppAdspRemConn = &pAdspAddr->adspao_pListenConn;
			((pAdspRemConn = *ppAdspRemConn) != NULL); )
	{
		if (pAdspRemConn == pAdspConn)
		{
			removed = TRUE;
			*ppAdspRemConn = pAdspRemConn->adspco_pNextListen;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeQueueListenList: Removed listen conn %lx\n", pAdspConn));
		}
		else
		{
			ppAdspRemConn = &pAdspRemConn->adspco_pNextListen;
		}
	}

	return removed;
}




LOCAL	BOOLEAN
atalkAdspConnDeQueueActiveList(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspRemConn, *ppAdspRemConn;
	ULONG			index;
	BOOLEAN			removed = FALSE;

	index	= HASH_ID_SRCADDR(
				pAdspConn->adspco_RemoteConnId,
				&pAdspConn->adspco_RemoteAddr);

	index  %= ADSP_CONN_HASH_SIZE;

	for (ppAdspRemConn = &pAdspAddr->adspao_pActiveHash[index];
			((pAdspRemConn = *ppAdspRemConn) != NULL); )
	{
		if (pAdspRemConn == pAdspConn)
		{
			removed = TRUE;
			*ppAdspRemConn = pAdspRemConn->adspco_pNextActive;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeQueueActiveList: Removed active conn %lx\n", pAdspConn));
			break;
		}
		else
		{
			ppAdspRemConn = &pAdspRemConn->adspco_pNextActive;
		}
	}

	return removed;
}




LOCAL	VOID
atalkAdspAddrQueueGlobalList(
	IN	PADSP_ADDROBJ	pAdspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkAdspLock, &OldIrql);
	pAdspAddr->adspao_pNextGlobal	= atalkAdspAddrList;
	atalkAdspAddrList				= pAdspAddr;
	RELEASE_SPIN_LOCK(&atalkAdspLock, OldIrql);
}


LOCAL	VOID
atalkAdspAddrDeQueueGlobalList(
	IN	PADSP_ADDROBJ	pAdspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	PADSP_ADDROBJ	pAdspRemAddr, *ppAdspRemAddr;

	ACQUIRE_SPIN_LOCK(&atalkAdspLock, &OldIrql);
	for (ppAdspRemAddr = &atalkAdspAddrList;
			((pAdspRemAddr = *ppAdspRemAddr) != NULL); )
	{
		if (pAdspRemAddr == pAdspAddr)
		{
			*ppAdspRemAddr = pAdspRemAddr->adspao_pNextGlobal;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspAddrDeQueueGlobalList: Removed global conn %lx\n",pAdspAddr));
			break;
		}
		else
		{
			ppAdspRemAddr = &pAdspRemAddr->adspao_pNextGlobal;
		}
	}
	RELEASE_SPIN_LOCK(&atalkAdspLock, OldIrql);
}




LOCAL	VOID
atalkAdspConnDeQueueGlobalList(
	IN	PADSP_CONNOBJ	pAdspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	PADSP_CONNOBJ	pAdspRemConn, *ppAdspRemConn;

	ACQUIRE_SPIN_LOCK(&atalkAdspLock, &OldIrql);
	for (ppAdspRemConn = &atalkAdspConnList;
			((pAdspRemConn = *ppAdspRemConn) != NULL); )
	{
		if (pAdspRemConn == pAdspConn)
		{
			*ppAdspRemConn = pAdspRemConn->adspco_pNextGlobal;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspConnDeQueueGlobalList: Removed global conn %lx\n", pAdspConn));
			break;
		}
		else
		{
			ppAdspRemConn = &pAdspRemConn->adspco_pNextGlobal;
		}
	}
	RELEASE_SPIN_LOCK(&atalkAdspLock, OldIrql);
}




LOCAL	BOOLEAN
atalkAdspAddrDeQueueOpenReq(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	USHORT			RemoteConnId,
	IN	PATALK_ADDR		pSrcAddr,
	OUT	PADSP_OPEN_REQ *ppAdspOpenReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PADSP_OPEN_REQ	pOpenReq, *ppOpenReq;
	BOOLEAN			removed = FALSE;

	for (ppOpenReq = &pAdspAddr->adspao_OpenReq;
			((pOpenReq = *ppOpenReq) != NULL); )
	{
		if ((pOpenReq->or_RemoteConnId == RemoteConnId) &&
			(ATALK_ADDRS_EQUAL(&pOpenReq->or_RemoteAddr, pSrcAddr)))
		{
			removed = TRUE;
			*ppOpenReq = pOpenReq->or_Next;

			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspAddrDeQueueOpenReq: Removed OpenReq %lx\n", pOpenReq));
			break;
		}
		else
		{
			ppOpenReq = &pOpenReq->or_Next;
		}
	}

	*ppAdspOpenReq	= NULL;
	if (removed)
	{
		*ppAdspOpenReq	= pOpenReq;
	}

	return removed;
}




LOCAL	BOOLEAN
atalkAdspIsDuplicateOpenReq(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	USHORT			RemoteConnId,
	IN	PATALK_ADDR		pSrcAddr
	)
/*++

Routine Description:

	!!!MUST BE CALLED WITH THE ADDRESS LOCK HELD!!!

Arguments:


Return Value:


--*/
{
	PADSP_OPEN_REQ	pOpenReqChk;
	BOOLEAN			found = FALSE;

	for (pOpenReqChk = pAdspAddr->adspao_OpenReq;
		 pOpenReqChk != NULL;
		 pOpenReqChk = pOpenReqChk->or_Next)
	{
		if ((pOpenReqChk->or_RemoteConnId == RemoteConnId) &&
			(ATALK_ADDRS_EQUAL(&pOpenReqChk->or_RemoteAddr, pSrcAddr)))
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspIsDuplicateOpenReq: Found\n"));
			found = TRUE;
			break;
		}
	}

	return found;
}




LOCAL VOID
atalkAdspGenericComplete(
	IN	ATALK_ERROR	ErrorCode,
	IN	PIRP		pIrp
	)
{
	DBGPRINT(DBG_COMP_TDI, DBG_LEVEL_INFO,
			("atalkTdiGenericComplete: Completing %lx with %lx\n",
			pIrp, AtalkErrorToNtStatus(ErrorCode)));

	ASSERT (ErrorCode != ATALK_PENDING);
	TdiCompleteRequest(pIrp, AtalkErrorToNtStatus(ErrorCode));
}




VOID
atalkAdspConnFindInConnect(
	IN	PADSP_ADDROBJ	pAdspAddr,
	IN	USHORT			DestConnId,
	IN	PATALK_ADDR		pRemoteAddr,
	OUT	PADSP_CONNOBJ *	ppAdspConn,
	IN	PATALK_ERROR	pError
	)
/*++

Routine Description:

	The MAC could respond with a REQ&ACK from a different socket than
	the one we sent the REQ to. But the network/node id must be the
	same. We don't check for that though, and only use the destination
	connection id.

	This routine will replace the remote address with the new remote
	address passed in.

Arguments:


Return Value:


--*/
{
	PADSP_CONNOBJ	pAdspRemConn;

	ASSERT(pAdspAddr->adspao_Flags & ADSPAO_CONNECT);

	*pError = ATALK_INVALID_CONNECTION;
	for (pAdspRemConn = pAdspAddr->adspao_pConnectConn;
			pAdspRemConn != NULL; )
	{
		if (pAdspRemConn->adspco_LocalConnId == DestConnId)
		{
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,
					("atalkAdspFindInConnectList: connect conn %lx\n",
					pAdspRemConn));

			//	Try to reference this.
			AtalkAdspConnReferenceByPtr(pAdspRemConn, pError);
			if (ATALK_SUCCESS(*pError))
			{
				//	Change remote address to be the passed in address
				pAdspRemConn->adspco_RemoteAddr = *pRemoteAddr;
				*ppAdspConn = pAdspRemConn;
			}
			break;
		}
		else
		{
			pAdspRemConn = pAdspRemConn->adspco_pNextConnect;
		}
	}
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\adsp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	adsp.h

Abstract:

	This module contains definitions for the ADSP code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	20 May 1993		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ADSP_
#define	_ADSP_

// ADSP_ version.

#define ADSP_VERSION	 				0x0100

// ADSP_ field offsets within a Ddp datagram.
#define ADSP_SRC_CONNID_OFF				0
#define ADSP_FIRST_BYTE_SEQNUM_OFF		2
#define ADSP_THIS_ATTEN_SEQNUM_OFF		2
#define ADSP_NEXT_RX_BYTESEQNUM_OFF		6
#define ADSP_NEXT_RX_ATTNSEQNUM_OFF		6
#define ADSP_RX_WINDOW_SIZE_OFF			10
#define ADSP_RX_ATTEN_SIZE_OFF			10
#define ADSP_DESCRIPTOR_OFF				12
#define ADSP_DATA_OFF					13
#define ADSP_VERSION_STAMP_OFF			13
#define ADSP_ATTEN_CODE_OFF				13
#define ADSP_ATTEN_DATA_OFF				15
#define ADSP_DEST_CONNID_OFF			15
#define ADSP_NEXT_ATTEN_SEQNUM_OFF		17

// Bit fields in the ADSP_ descriptor
#define ADSP_CONTROL_FLAG	    		0x80
#define ADSP_ACK_REQ_FLAG				0x40
#define ADSP_EOM_FLAG 					0x20
#define ADSP_ATTEN_FLAG					0x10

// Control codes in the ADSP_ descriptor:
#define ADSP_CONTROL_MASK				0x0F
#define ADSP_PROBE_OR_ACK_CODE			0
#define ADSP_OPENCONN_REQ_CODE			1
#define ADSP_OPENCONN_ACK_CODE			2
#define ADSP_OPENCONN_REQANDACK_CODE	3
#define ADSP_OPENCONN_DENY_CODE			4
#define ADSP_CLOSE_CONN_CODE			5
#define ADSP_FORWARD_RESET_CODE			6
#define ADSP_FORWARD_RESETACK_CODE		7
#define ADSP_RETRANSMIT_CODE			8

// Data sizes:
#define ADSP_MAX_DATA_SIZE				572
#define ADSP_MAX_ATTEN_DATA_SIZE		570
#define ADSP_MAX_ATTEN_PKT_SIZE			572
#define	ADSP_MIN_ATTEN_PKT_SIZE			sizeof(USHORT)

// Largest allowed send/receive window size.
#define ADSP_MAX_SEND_RX_WINDOW_SIZE	0xFFFF
#define ADSP_DEF_SEND_RX_WINDOW_SIZE	((1024*8)+1)		// 8K + 1 (EOM)

// Attention code info:
#define ADSP_MIN_ATTENCODE			    0x0000
#define ADSP_MAX_ATTENCODE			    0xEFFF

// How long do we try Open's for?
#define ADSP_MAX_OPEN_ATTEMPTS			10
#define ADSP_OPEN_INTERVAL				20		// In 100ms units

// Connection maintenance timer values:
#define ADSP_PROBE_INTERVAL 			30
#define ADSP_CONNECTION_INTERVAL		1200	// In 100ms units

// Retransmit timer values:
#define ADSP_RETRANSMIT_INTERVAL		20		// In 100ms units

// How often do we retransmit attentions?
#define ADSP_ATTENTION_INTERVAL			20		// In 100ms units

#define ADSP_DISCONNECT_DELAY			7		// In 100ms units

// How often do we retransmit forward resets?
#define ADSP_FORWARD_RESET_INTERVAL		20		// In 100ms units

// How many out of sequence packets do we allow before requesting a retransmition.
#define ADSP_OUT_OF_SEQ_PACKETS_MAX		3

// For resolving forward references
struct _ADSP_CONNOBJ;
struct _ADSP_ADDROBJ;

typedef	enum
{
	ADSP_SEND_QUEUE,
	ADSP_RECV_QUEUE

} ADSP_QUEUE_TYPE;


#define		BC_EOM			(USHORT)0x0001
#define		BC_SEND			(USHORT)0x0002
#define		BC_DISCONNECT	(USHORT)0x4000
#define		BC_CLOSING		(USHORT)0x8000

//	We use buffer chunks for the send receive queues
typedef	struct _BUFFER_CHUNK
{
	struct _BUFFER_CHUNK *	bc_Next;
	ATALK_SPIN_LOCK			bc_Lock;
	ULONG					bc_RefCount;

	//	Size of data copied over from the users mdl. This
	//	could be less than the size of the users data.
	USHORT					bc_DataSize;
	USHORT					bc_Flags;

	//	Write completion information. This is only valid if
	//	the BC_SEND bit is set. With a week left to ship, i'm
	//	wimping out and making a copy to keep things as consistent
	//	and stable as possible. Eventually though, we should just
	//	use the User's buffer to make mdl's out of.
	PAMDL						bc_WriteBuf;
	GENERIC_WRITE_COMPLETION	bc_WriteCompletion;
	PVOID						bc_WriteCtx;
	ATALK_ERROR					bc_WriteError;

	//	Backpointer to the connection object on which this is queued
	struct _ADSP_CONNOBJ 	*	bc_ConnObj;

	//
	//	BYTE	bc_Data[]
	//

} BUFFER_CHUNK, *PBUFFER_CHUNK;



//	Buffer queues used for send/receive
typedef struct _BUFFER_QUEUE
{
	ULONG					bq_StartIndex;
	PBUFFER_CHUNK			bq_Head;
	PBUFFER_CHUNK			bq_Tail;

} BUFFER_QUEUE, *PBUFFER_QUEUE;


#define	ADSP_CONN_HASH_SIZE		23


// ADSP ADDRESS OBJECT STATES
#define	ADSPAO_LISTENER			0x00000001
#define	ADSPAO_CONNECT			0x00000002
#define	ADSPAO_MESSAGE			0x00000010
#define	ADSPAO_CLOSING			0x80000000

#define	ADSPAO_SIGNATURE		(*(PULONG)"ADAO")

#define	VALID_ADSPAO(pAdspAddr)	(((pAdspAddr) != NULL) && \
		(((struct _ADSP_ADDROBJ *)(pAdspAddr))->adspao_Signature == ADSPAO_SIGNATURE))

typedef struct _ADSP_ADDROBJ
{
	ULONG					adspao_Signature;

	//	Global list of address objects.
	struct _ADSP_ADDROBJ  *	adspao_pNextGlobal;

	ULONG					adspao_Flags;
	ULONG					adspao_RefCount;
	ATALK_SPIN_LOCK			adspao_Lock;
	PATALK_DEV_CTX			adspao_pDevCtx;

	//	List of connections associated with this address object.
	//	Potentially greater than one if this address object is a listener.
	struct	_ADSP_CONNOBJ *	adspao_pAssocConn;

	//	List of connections that are associated, but also have a listen/connect
	//	posted on them.
	union
	{
		struct	_ADSP_CONNOBJ *	adspao_pListenConn;
		struct	_ADSP_CONNOBJ *	adspao_pConnectConn;
	};

	//	List of indicated connections waiting for acceptance.
	struct _ADSP_OPEN_REQ *	adspao_OpenReq;

	//	Lookup list of all active connections hashed by connId and remote
	//	address.
	struct	_ADSP_CONNOBJ *	adspao_pActiveHash[ADSP_CONN_HASH_SIZE];

	//	Next connection to use.
	USHORT					adspao_NextConnId;

	//	Event support routines.
    //
    // This function pointer points to a connection indication handler for this
    // Address. Any time a connect request is received on the address, this
    // routine is invoked.
    PTDI_IND_CONNECT 			adspao_ConnHandler;
    PVOID 						adspao_ConnHandlerCtx;

    PTDI_IND_DISCONNECT 		adspao_DisconnectHandler;
    PVOID 						adspao_DisconnectHandlerCtx;

    PTDI_IND_RECEIVE 			adspao_RecvHandler;
    PVOID 						adspao_RecvHandlerCtx;

    PTDI_IND_RECEIVE_EXPEDITED	adspao_ExpRecvHandler;
    PVOID 						adspao_ExpRecvHandlerCtx;

    PTDI_IND_SEND_POSSIBLE  	adspao_SendPossibleHandler;
    PVOID   					adspao_SendPossibleHandlerCtx;

	//	DDP Address for this adsp address. If this is a listener, then the DDP
	//	address will be what the listens effectively will be posted on. This
	//	will also be the address over which the connections will be active.
    //	if this is a connect address object, then this ddp address will be what the
	//	associated connection be active over.
	PDDP_ADDROBJ				adspao_pDdpAddr;

	// Completion routine to be called when address is closed
	GENERIC_COMPLETION		adspao_CloseComp;
	PVOID					adspao_CloseCtx;

} ADSP_ADDROBJ, *PADSP_ADDROBJ;


#define	ADSPCO_ASSOCIATED			0x00000001
#define	ADSPCO_IND_RECV				0x00000002
#define	ADSPCO_LISTENING			0x00000004
#define	ADSPCO_CONNECTING			0x00000008
#define	ADSPCO_ACCEPT_IRP			0x00000010
#define	ADSPCO_LISTEN_IRP			0x00000020
#define	ADSPCO_HALF_ACTIVE			0x00000040
#define	ADSPCO_ACTIVE				0x00000080
#define	ADSPCO_SEEN_REMOTE_OPEN		0x00000100
#define	ADSPCO_DISCONNECTING		0x00000200
#define	ADSPCO_SERVER_JOB			0x00000400
#define	ADSPCO_REMOTE_CLOSE			0x00000800
#define	ADSPCO_SEND_IN_PROGRESS		0x00001000
#define	ADSPCO_SEND_DENY			0x00002000
#define	ADSPCO_SEND_OPENACK			0x00004000
#define	ADSPCO_SEND_WINDOW_CLOSED	0x00008000
#define	ADSPCO_READ_PENDING			0x00010000
#define	ADSPCO_EXREAD_PENDING		0x00020000
#define	ADSPCO_FORWARD_RESET_RECD	0x00040000
#define	ADSPCO_ATTN_DATA_RECD		0x00080000
#define	ADSPCO_ATTN_DATA_EOM		0x00100000
#define	ADSPCO_EXSEND_IN_PROGRESS	0x00200000
#define	ADSPCO_OPEN_TIMER			0x01000000
#define	ADSPCO_RETRANSMIT_TIMER		0x02000000
#define	ADSPCO_CONN_TIMER			0x04000000
#define	ADSPCO_LOCAL_DISCONNECT		0x08000000
#define	ADSPCO_REMOTE_DISCONNECT	0x10000000
#define	ADSPCO_DELAYED_DISCONNECT	0x20000000
#define	ADSPCO_STOPPING				0x40000000
#define	ADSPCO_CLOSING				0x80000000

#define	ADSPCO_SIGNATURE			(*(PULONG)"ADCO")

#define	VALID_ADSPCO(pAdspConn)	(((pAdspConn) != NULL) && \
		(((struct _ADSP_CONNOBJ *)(pAdspConn))->adspco_Signature == ADSPCO_SIGNATURE))

// This will represent a 'job' on the Pap address. This could either be a
// workstation job or a server job. In the latter case it could either
// be in a 'listen' state or active state. In the former case it is either
// active or 'waiting'
typedef struct _ADSP_CONNOBJ
{
	ULONG						adspco_Signature;

	//	Used to queue into the address object's associated list.
	struct	_ADSP_CONNOBJ *		adspco_pNextAssoc;

	ULONG						adspco_Flags;
	ULONG						adspco_RefCount;
	ATALK_SPIN_LOCK				adspco_Lock;
	PATALK_DEV_CTX				adspco_pDevCtx;

	//	!!!NOTE!!!
	//	The address this connection uses will be the address object's DDP address.
	PDDP_ADDROBJ				adspco_pDdpAddr;

	//	Used to queue into the address object's listen/connect list. When it
	//	is removed from the listen/connect, it goes into the active list of the
	//	address object.
	union
	{
		struct	_ADSP_CONNOBJ *	adspco_pNextListen;
		struct	_ADSP_CONNOBJ *	adspco_pNextConnect;
		struct	_ADSP_CONNOBJ *	adspco_pNextActive;
	};

	//	Global list of connection objects.
	struct _ADSP_CONNOBJ	*	adspco_pNextGlobal;

	//	Used to queue into the lookup by remote connid/remote address
	//	list in address obj.
	struct	_ADSP_CONNOBJ *		adspco_pHashNext;

	//	Backpointer to the associated address
	struct _ADSP_ADDROBJ  *		adspco_pAssocAddr;

	//	Address of remote end of the connection
	ATALK_ADDR					adspco_RemoteAddr;

	//	Connection ids
	USHORT						adspco_LocalConnId;
	USHORT						adspco_RemoteConnId;

	//	Connection timer. During open time this will be the open timer.
	union
	{
		TIMERLIST				adspco_ConnTimer;
		TIMERLIST				adspco_OpenTimer;
	};

	TIMERLIST					adspco_RetransmitTimer;
	ULONG						adspco_LastTimerRtmtSeq;
	LONG						adspco_LastContactTime;

	//	Connection context
	PVOID						adspco_ConnCtx;

	//	List of pended sends
	LIST_ENTRY					adspco_PendedSends;

	//	Sequence numbers
	ULONG						adspco_SendSeq;
	ULONG						adspco_FirstRtmtSeq;
	ULONG						adspco_SendWindowSeq;
	ULONG						adspco_SendAttnSeq;

	ULONG						adspco_RecvSeq;
	ULONG						adspco_RecvAttnSeq;

	//	Window/buffers
	LONG						adspco_RecvWindow;
	LONG						adspco_SendQueueMax;
	LONG						adspco_RecvQueueMax;

	//	Previously indicated data
	ULONG						adspco_PrevIndicatedData;

	//	Buffer queues
	BUFFER_QUEUE				adspco_SendQueue;
	BUFFER_QUEUE				adspco_NextSendQueue;
	BUFFER_QUEUE				adspco_RecvQueue;

	//	Number of out of sequence packets received
	ULONG						adspco_OutOfSeqCount;

	//	The connection object can have either a CONNECT or a LISTEN posted
	//	on it, but not both.
	union
	{
		struct
		{
			//	Pending Listen routine.
			GENERIC_COMPLETION	adspco_ListenCompletion;
			PVOID				adspco_ListenCtx;
		};

		struct
		{
			//	Pending Connect routine. The status buffer is remember and
			//	returned via socket options. The pConnectRespBuf is remembered
			//	to avoid having to get the system address for it. It is freed
			//	when connection is taken off the connectlist.
			GENERIC_COMPLETION	adspco_ConnectCompletion;
			PVOID				adspco_ConnectCtx;
			ULONG				adspco_ConnectAttempts;
		};
	};

	//	Read completion information
	ULONG						adspco_ReadFlags;
	PAMDL						adspco_ReadBuf;
	USHORT						adspco_ReadBufLen;
	GENERIC_READ_COMPLETION		adspco_ReadCompletion;
	PVOID						adspco_ReadCtx;

	PBYTE						adspco_ExRecdData;
	USHORT						adspco_ExRecdLen;

	//	Expedited Read completion information
	ULONG						adspco_ExReadFlags;
	USHORT						adspco_ExReadBufLen;
	PAMDL						adspco_ExReadBuf;
	GENERIC_READ_COMPLETION		adspco_ExReadCompletion;
	PVOID						adspco_ExReadCtx;

	//	Expedited Write completion information
	TIMERLIST					adspco_ExRetryTimer;
	PBYTE						adspco_ExWriteChBuf;

	ULONG						adspco_ExWriteFlags;
	USHORT						adspco_ExWriteBufLen;
	PAMDL						adspco_ExWriteBuf;
	GENERIC_WRITE_COMPLETION	adspco_ExWriteCompletion;
	PVOID						adspco_ExWriteCtx;

	//	Disconnect inform routine
	GENERIC_COMPLETION			adspco_DisconnectInform;
	PVOID						adspco_DisconnectInformCtx;

	//	Disconnect request completion
	ATALK_ERROR					adspco_DisconnectStatus;
	GENERIC_COMPLETION			adspco_DisconnectCompletion;
	PVOID						adspco_DisconnectCtx;

	// The following is a hack to get around the problem of rcv/disconnet race condn.
	// Since this involves major rework, a safe approach is taken
	TIMERLIST					adspco_DisconnectTimer;

	//	Cleanup irp completion
	GENERIC_COMPLETION			adspco_CleanupComp;
	PVOID						adspco_CleanupCtx;

	// Completion routine to be called when socket is closed
	GENERIC_COMPLETION			adspco_CloseComp;
	PVOID						adspco_CloseCtx;

} ADSP_CONNOBJ, *PADSP_CONNOBJ;


//	Used for the list of indicated connections waiting acceptance
typedef struct _ADSP_OPEN_REQ
{
    struct _ADSP_OPEN_REQ  *	or_Next;
	ATALK_ADDR					or_RemoteAddr;
	ULONG						or_FirstByteSeq;
	ULONG						or_NextRecvSeq;
	LONG						or_RecvWindow;
	USHORT						or_RemoteConnId;

} ADSP_OPEN_REQ, *PADSP_OPEN_REQ;



//	Routine prototypes
VOID
AtalkInitAdspInitialize(
	VOID);

ATALK_ERROR
AtalkAdspCreateAddress(
	IN	PATALK_DEV_CTX			pDevCtx	OPTIONAL,
	IN	BYTE					SocketType,
	OUT	PADSP_ADDROBJ	*		ppAdspAddr);

ATALK_ERROR
AtalkAdspCleanupAddress(
	IN	PADSP_ADDROBJ			pAdspAddr);

ATALK_ERROR
AtalkAdspCloseAddress(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx);

ATALK_ERROR
AtalkAdspCreateConnection(
	IN	PVOID					pConnCtx,	// Context to associate with the session
	IN	PATALK_DEV_CTX			pDevCtx		OPTIONAL,
	OUT	PADSP_CONNOBJ 	*		ppAdspConn);

ATALK_ERROR
AtalkAdspCloseConnection(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					pCloseCtx);

ATALK_ERROR
AtalkAdspCleanupConnection(
	IN	PADSP_CONNOBJ			pAdspConn);

ATALK_ERROR
AtalkAdspAssociateAddress(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn);

ATALK_ERROR
AtalkAdspDissociateAddress(
	IN	PADSP_CONNOBJ			pAdspConn);

ATALK_ERROR
AtalkAdspPostListen(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PVOID					pListenCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine);

ATALK_ERROR
AtalkAdspCancelListen(
	IN	PADSP_CONNOBJ			pAdspConn)		;

ATALK_ERROR
AtalkAdspPostConnect(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	PVOID					pConnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine);

ATALK_ERROR
AtalkAdspDisconnect(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	ATALK_DISCONNECT_TYPE	DisconnectType,
	IN	PVOID					pDisconnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine);

ATALK_ERROR
AtalkAdspRead(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PAMDL					pReadBuf,
	IN	USHORT					ReadBufLen,
	IN	ULONG					ReadFlags,
	IN	PVOID					pReadCtx,
	IN	GENERIC_READ_COMPLETION	CompletionRoutine);

ATALK_ERROR
AtalkAdspWrite(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PAMDL					pWriteBuf,
	IN	USHORT					WriteBufLen,
	IN	ULONG					SendFlags,
	IN	PVOID					pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION CompletionRoutine);

VOID
AtalkAdspQuery(
	IN	PVOID					pObject,
	IN	ULONG					ObjectType,
	IN	PAMDL					pAmdl,
	OUT	PULONG					BytesWritten);

VOID
atalkAdspAddrRefNonInterlock(
	IN	PADSP_ADDROBJ			pAdspAddr,
	OUT	PATALK_ERROR			pError);

VOID
atalkAdspAddrDeref(
	IN	PADSP_ADDROBJ			pAdspAddr);

VOID
atalkAdspConnRefByPtrNonInterlock(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	ULONG					NumCount,
	OUT	PATALK_ERROR			pError);

VOID
atalkAdspConnRefByCtxNonInterlock(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	CONNECTION_CONTEXT		Ctx,
	OUT	PADSP_CONNOBJ	*		pAdspConn,
	OUT	PATALK_ERROR			pError);

VOID
atalkAdspConnRefBySrcAddr(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	USHORT					RemoteConnId,
	OUT	PADSP_CONNOBJ *			ppAdspConn,
	OUT	PATALK_ERROR			pError);

VOID
atalkAdspConnRefNextNc(
	IN		PADSP_CONNOBJ		pAdspConn,
	IN		PADSP_CONNOBJ	*	ppAdspConnNext,
	OUT		PATALK_ERROR		pError);

VOID
AtalkAdspProcessQueuedSend(
	IN	PADSP_CONNOBJ			pAdspConn);

VOID
atalkAdspConnDeref(
	IN	PADSP_CONNOBJ			pAdspConn);




//	MACROS
#define	UNSIGNED_BETWEEN_WITH_WRAP(Low, High, Target)				\
		((Low <= High) ? ((Target >= Low) && (Target <= High))	:	\
						 ((Target >= Low) || (Target <= High)))

//	This didnt make sense until JameelH explained what was going on.
//	This is with the assumption that the window size will never be greater
//	than the difference of 0x80000 and 0x10000. If High is < 10000 and Low
//	is > 80000 then we can assume a wrap happened. Otherwise, we assume no
//	wrap and do a straight compare.
#define UNSIGNED_GREATER_WITH_WRAP(High, Low)							\
		(((High < 0x10000) && (Low > 0x80000)) ? TRUE : (High > Low))
		//	(((High < 0x80000) && (Low > 0x10000)) ? TRUE : (High > Low))


#define	AtalkAdspGetDdpAddress(pAdspAddr)								\
		((pAdspAddr)->adspao_pDdpAddr)

#define	AtalkAdspAddrReferenceNonInterlock(pAdspAddr, pError)			\
		{																\
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO, ("RefAddr %lx at %s %d - %d\n",	\
			pAdspAddr, __FILE__, __LINE__, ((pAdspAddr)->adspao_RefCount)));		\
			atalkAdspAddrRefNonInterlock(pAdspAddr, pError);			\
		}

#define	AtalkAdspAddrReference(pAdspAddr, pError)						\
		{																\
			KIRQL	OldIrql;											\
																		\
			ACQUIRE_SPIN_LOCK(&(pAdspAddr)->adspao_Lock, &OldIrql);		\
			AtalkAdspAddrReferenceNonInterlock(pAdspAddr, pError);		\
			RELEASE_SPIN_LOCK(&(pAdspAddr)->adspao_Lock, OldIrql);		\
		}

#define	AtalkAdspAddrDereference(pAdspAddr)											\
		{																			\
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO, ("DerefAddr %lx at %s %d - %d\n",\
			pAdspAddr, __FILE__, __LINE__, ((pAdspAddr)->adspao_RefCount)));	\
			atalkAdspAddrDeref(pAdspAddr);											\
		}

#define	AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, NumCount, pError)		\
		{																			\
			atalkAdspConnRefByPtrNonInterlock(pAdspConn, NumCount, pError);			\
		}

#define	AtalkAdspConnReferenceByPtr(pAdspConn, pError)					\
		{																\
			KIRQL	OldIrql;											\
																		\
			ACQUIRE_SPIN_LOCK(&(pAdspConn)->adspco_Lock, &OldIrql);		\
			AtalkAdspConnReferenceByPtrNonInterlock(pAdspConn, 1, pError);\
			RELEASE_SPIN_LOCK(&(pAdspConn)->adspco_Lock, OldIrql);		\
		}

#define	AtalkAdspConnReferenceByCtxNonInterlock(pAdspAddr, Ctx, ppAdspConn, pError)	\
		atalkAdspConnRefByCtxNonInterlock(pAdspAddr, Ctx, ppAdspConn, pError)

#define	AtalkAdspConnReferenceBySrcAddr(pAdspAddr, pSrc, SessId, pErr)		\
		atalkAdspConnRefBySrcAddr(pAdspAddr, pSrc, SessId, pErr)

#define	AtalkAdspConnDereference(pAdspConn)							\
		{															\
			DBGPRINT(DBG_COMP_ADSP, DBG_LEVEL_INFO,					\
					("DerefConn %lx at %s %d - %d\n",				\
					pAdspConn, __FILE__, __LINE__,					\
					(pAdspConn)->adspco_RefCount));					\
			atalkAdspConnDeref(pAdspConn);							\
		}

//	How many bytes/seqnums does eom occupy?
#define	BYTECOUNT(eom)		((ULONG)((eom) ? 1 : 0))

//
// PLIST_ENTRY
// WRITECTX_LINKAGE(
//     IN PVOID WriteCtx
// );
//
// Returns a pointer to a linkage field in the write context (Assumed to be IRP).
//

#define WRITECTX_LINKAGE(_Request) \
    (&(((PIRP)_Request)->Tail.Overlay.ListEntry))


#define	WRITECTX(_Request)	((PIRP)(_Request))

//
// PVOID
// LIST_ENTRY_TO_WRITECTX(
//     IN PLIST_ENTRY ListEntry
// );
//
// Returns a request given a linkage field in it.
//

#define LIST_ENTRY_TO_WRITECTX(_ListEntry) \
    ((PVOID)(CONTAINING_RECORD(_ListEntry, IRP, Tail.Overlay.ListEntry)))

//
// PVOID
// WRITECTX_TDI_BUFFER
//     IN PVOID Request
// );
//
// Returns the TDI buffer chain associated with a request.
//

#define WRITECTX_TDI_BUFFER(_Request) \
    ((PVOID)(((PIRP)(_Request))->MdlAddress))


//
// ULONG
// WRITECTX_SIZE(
//     IN PVOID Request
// );
//
// Obtains size of send
//

#define WRITECTX_SIZE(_Request) 		\
	(((PTDI_REQUEST_KERNEL_SEND)(&((IoGetCurrentIrpStackLocation((PIRP)_Request))->Parameters)))->SendLength)

//
// ULONG
// WRITECTX_FLAGS(
//     IN PVOID Request
// );
//
// Obtains size of send
//

#define WRITECTX_FLAGS(_Request) 		\
	(((PTDI_REQUEST_KERNEL_SEND)(&((IoGetCurrentIrpStackLocation((PIRP)_Request))->Parameters)))->SendFlags)

extern	PADSP_ADDROBJ	atalkAdspAddrList;
extern	PADSP_CONNOBJ	atalkAdspConnList;
extern	ATALK_SPIN_LOCK	atalkAdspLock;

PBUFFER_CHUNK
atalkAdspAllocCopyChunk(
	IN	PVOID					pWriteBuf,
	IN	USHORT					WriteBufLen,
	IN	BOOLEAN					Eom,
	IN	BOOLEAN					IsCharBuffer);

VOID
atalkAdspPacketIn(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	PDDP_ADDROBJ			pDdpAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	PATALK_ADDR				pDestAddr,
	IN	ATALK_ERROR				ErrorCode,
	IN	BYTE					DdpType,
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	BOOLEAN					OptimizePath,
	IN	PVOID               	OptimizeCtx);

LOCAL VOID
atalkAdspHandleOpenControl(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	USHORT					RemoteConnId,
	IN	ULONG					RemoteFirstByteSeq,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspHandleAttn(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	ULONG					RemoteFirstByteSeq,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspHandlePiggyBackAck(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow);

LOCAL VOID
atalkAdspHandleControl(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	ULONG					RemoteFirstByteSeq,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspHandleData(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	ULONG					RemoteFirstByteSeq,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspHandleOpenReq(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PBYTE					pPkt,
	IN	USHORT					PktLen,
	IN	PATALK_ADDR				pSrcAddr,
	IN	USHORT					RemoteConnId,
	IN	ULONG					RemoteFirstByteSeq,
	IN	ULONG					RemoteNextRecvSeq,
	IN	ULONG					RemoteRecvWindow,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspListenIndicateNonInterlock(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_OPEN_REQ			pOpenReq,
	IN	PADSP_CONNOBJ *			ppAdspConn,
	IN	PATALK_ERROR			pError);

ATALK_ERROR
atalkAdspSendExpedited(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	PAMDL					pWriteBuf,
	IN	USHORT					WriteBufLen,
	IN	ULONG					SendFlags,
	IN	PVOID					pWriteCtx,
	IN	GENERIC_WRITE_COMPLETION CompletionRoutine);

LOCAL VOID
atalkAdspSendOpenControl(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL VOID
atalkAdspSendControl(
	IN	PADSP_CONNOBJ			pAdspConn,
	IN	BYTE					Descriptor);

LOCAL VOID
atalkAdspSendAttn(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL VOID
atalkAdspSendData(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL VOID
atalkAdspRecvAttn(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL VOID
atalkAdspRecvData(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL VOID
atalkAdspSendDeny(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	USHORT					pRemoteConnId);

VOID FASTCALL
atalkAdspSendAttnComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID FASTCALL
atalkAdspConnSendComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID FASTCALL
atalkAdspAddrSendComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

VOID FASTCALL
atalkAdspSendDataComplete(
	IN	NDIS_STATUS				Status,
	IN	PSEND_COMPL_INFO		pSendInfo);

LOCAL LONG FASTCALL
atalkAdspConnMaintenanceTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

LOCAL LONG FASTCALL
atalkAdspRetransmitTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

LOCAL LONG FASTCALL
atalkAdspAttnRetransmitTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

LOCAL LONG FASTCALL
atalkAdspOpenTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

LOCAL LONG FASTCALL
atalkAdspDisconnectTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown);

VOID
atalkAdspDecodeHeader(
	IN	PBYTE					Datagram,
	OUT	PUSHORT					RemoteConnId,
	OUT	PULONG					FirstByteSeq,
	OUT	PULONG					NextRecvSeq,
	OUT	PLONG					Window,
	OUT	PBYTE					Descriptor);

LOCAL USHORT
atalkAdspGetNextConnId(
	IN	PADSP_ADDROBJ			pAdspAddr,
	OUT	PATALK_ERROR			pError);

LOCAL	BOOLEAN
atalkAdspConnDeQueueAssocList(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL	BOOLEAN
atalkAdspConnDeQueueConnectList(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL	BOOLEAN
atalkAdspConnDeQueueListenList(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL	BOOLEAN
atalkAdspConnDeQueueActiveList(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL	VOID
atalkAdspAddrQueueGlobalList(
	IN	PADSP_ADDROBJ	pAdspAddr);

LOCAL	VOID
atalkAdspAddrDeQueueGlobalList(
	IN	PADSP_ADDROBJ			pAdspAddr);

LOCAL	VOID
atalkAdspConnDeQueueGlobalList(
	IN	PADSP_CONNOBJ			pAdspConn);

LOCAL	BOOLEAN
atalkAdspAddrDeQueueOpenReq(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	USHORT					RemoteConnId,
	IN	PATALK_ADDR				pSrcAddr,
	OUT	PADSP_OPEN_REQ *		ppOpenReq);

LOCAL	BOOLEAN
atalkAdspIsDuplicateOpenReq(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	USHORT					RemoteConnId,
	IN	PATALK_ADDR				pSrcAddr);

LOCAL VOID
atalkAdspGenericComplete(
	IN	ATALK_ERROR				ErrorCode,
	IN	PIRP					pIrp);

ULONG
atalkAdspMaxSendSize(
	IN	PADSP_CONNOBJ			pAdspConn);

ULONG
atalkAdspMaxNextReadSize(
	IN	PBUFFER_QUEUE			pQueue,
	OUT	PBOOLEAN				pEom,
	OUT	PBUFFER_CHUNK *			pBufferChunk);

ULONG
atalkAdspBufferQueueSize(
	IN	PBUFFER_QUEUE			pQueue);

ULONG
atalkAdspMessageSize(
	IN	PBUFFER_QUEUE			pQueue,
	IN	PBOOLEAN				pEom);

PBYTE
atalkAdspGetLookahead(
	IN	PBUFFER_QUEUE			pQueue,
	OUT	PULONG					pLookaheadSize);

ULONG
atalkAdspReadFromBufferQueue(
	IN		PBUFFER_QUEUE		pQueue,
	IN		ULONG				pFlags,
	OUT		PAMDL				pReadBuf,
	IN 	OUT	PUSHORT				pReadLen,
	OUT		PBOOLEAN			pEom);

BOOLEAN
atalkAdspDiscardFromBufferQueue(
	IN		PBUFFER_QUEUE		pQueue,
	IN 		ULONG				DataSize,
	OUT		PBUFFER_QUEUE		pAuxQueue,
	IN		ATALK_ERROR			Error,
	IN	PADSP_CONNOBJ			pAdspConn	OPTIONAL);

VOID
atalkAdspAddToBufferQueue(
	IN	OUT	PBUFFER_QUEUE		pQueue,
	IN		PBUFFER_CHUNK		pChunk,
	IN 	OUT	PBUFFER_QUEUE		pAuxQueue	OPTIONAL);

VOID
atalkAdspBufferChunkReference(
	IN	PBUFFER_CHUNK			pBufferChunk);

VOID
atalkAdspBufferChunkDereference(
	IN	PBUFFER_CHUNK			pBufferChunk,
	IN	BOOLEAN					CreationDeref,
	IN	PADSP_CONNOBJ			pAdspConn	OPTIONAL);

VOID
atalkAdspConnFindInConnect(
	IN	PADSP_ADDROBJ			pAdspAddr,
	IN	USHORT					DestConnId,
	IN	PATALK_ADDR				pRemoteAddr,
	OUT	PADSP_CONNOBJ *			ppAdspConn,
	IN	PATALK_ERROR			pError);

ULONG
atalkAdspDescribeFromBufferQueue(
	IN	PBUFFER_QUEUE			pQueue,
	OUT	PBOOLEAN				pEom,
	IN	ULONG					WindowSize,
	OUT	PBUFFER_CHUNK *			ppBufferChunk,
	OUT	PBUFFER_DESC  * 		ppBufDesc);

#endif	// _ADSP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\aep.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aep.c

Abstract:

	This module contains the echo protocol support code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#define	FILENUM		AEP
#include <atalk.h>
#pragma hdrstop


VOID
AtalkAepPacketIn(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	PDDP_ADDROBJ		pDdpAddr,
	IN	PBYTE				pPkt,
	IN	USHORT				PktLen,
	IN	PATALK_ADDR			pSrcAddr,
	IN	PATALK_ADDR			pDestAddr,
	IN	ATALK_ERROR			ErrorCode,
	IN	BYTE				DdpType,
	IN	PVOID				pHandlerCtx,
	IN	BOOLEAN				OptimizedPath,
	IN	PVOID				OptimizeCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_DESC	pBufDesc;
	SEND_COMPL_INFO	SendInfo;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	//	Turn around and send the packet back to the destination address.
	if (ATALK_SUCCESS(ErrorCode))
	{
		if ((DdpType == DDPPROTO_EP) &&
			(PktLen > 0))
		{
			if (*pPkt == EP_COMMAND_REQUEST)
			{
				//	This is an echo request, we have some data that needs
				//	to be echoed back! Do it.
				pBufDesc = AtalkAllocBuffDesc(
										NULL,
										PktLen,
										(BD_CHAR_BUFFER | BD_FREE_BUFFER));

                if (pBufDesc)
                {
				    //	Change command to be Reply
				    *pPkt = EP_COMMAND_REPLY;

				    //	This *does not* set the PktLen in pBufDesc. Set it.
				    AtalkCopyBufferToBuffDesc(
    					pPkt,
	    				PktLen,
		    			pBufDesc,
			    		0);

				    AtalkSetSizeOfBuffDescData(pBufDesc, PktLen);

				    //	Call AtalkDdpSend.
				    SendInfo.sc_TransmitCompletion = atalkAepSendComplete;
				    SendInfo.sc_Ctx1 = pBufDesc;
				    // SendInfo.sc_Ctx2 = NULL;
				    // SendInfo.sc_Ctx3 = NULL;
				    if (!ATALK_SUCCESS(AtalkDdpSend(pDdpAddr,
					    							pSrcAddr,
						    						(BYTE)DDPPROTO_EP,
							    					FALSE,
								    				pBufDesc,
									    			NULL,
										    		0,
											    	NULL,
												    &SendInfo)))
				    {
					    AtalkFreeBuffDesc(pBufDesc);
				    }
                }
			}
		}
	}
	else
	{
		DBGPRINT(DBG_COMP_AEP, DBG_LEVEL_ERR,
				("AtalkAepPacketIn: Ignoring incoming packet AepPacketIn %lx\n",
				ErrorCode));
	}

}




VOID FASTCALL
atalkAepSendComplete(
	IN	NDIS_STATUS			Status,
	IN	PSEND_COMPL_INFO	pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	AtalkFreeBuffDesc((PBUFFER_DESC)(pSendInfo->sc_Ctx1));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\aarp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aarp.c

Abstract:

	This module contains the Appletalk Address Resolution Protocol code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop

//	Define the file number for this module for errorlogging.
#define	FILENUM	AARP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEINIT, AtalkInitAarpForNodeOnPort)
#pragma alloc_text(PAGEINIT, AtalkInitAarpForNodeInRange)
#pragma alloc_text(PAGEINIT, atalkInitAarpForNode)
#endif

VOID
AtalkAarpPacketIn(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				pLinkHdr,
	IN		PBYTE				pPkt,				// Only aarp data
	IN		USHORT				Length
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBYTE				srcAddr;
	PBYTE				startOfPkt;
	ATALK_NODEADDR		srcNode, dstNode;

	PBYTE				pRouteInfo 		= NULL;
	USHORT				routeInfoLen 	= 0;
	ULONG				logEventPlace 	= 0;

	USHORT				hardwareLen, protocolLength, aarpCommand;
	PBUFFER_DESC		pBuffDesc;
	ATALK_ERROR			error;
    PVOID               pRasConn;
    PATCPCONN           pAtcpConn=NULL;
    PARAPCONN           pArapConn=NULL;
    DWORD               dwFlags;
    BOOLEAN             fDialInNode=TRUE;
    BOOLEAN             fThisIsPPP;

	TIME				TimeS, TimeE, TimeD;

	ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

	TimeS = KeQueryPerformanceCounter(NULL);

	if (PORT_CLOSING(pPortDesc))
	{
		//	If we are not active, return!
		return;
	}

	if (pPortDesc->pd_NdisPortType == NdisMedium802_5)
	{
		if (pLinkHdr[TLAP_SRC_OFFSET] & TLAP_SRC_ROUTING_MASK)
		{
			routeInfoLen = (pLinkHdr[TLAP_ROUTE_INFO_OFFSET] & TLAP_ROUTE_INFO_SIZE_MASK);

			//  First, glean any AARP information that we can, then handle the DDP
			//  packet.  This guy also makes sure we have a good 802.2 header...
			//
			//  Need to make a localcopy of the source address and then turn
			//  the source routing bit off before calling AarpGleanInfo
			//
			//	(HdrBuf)[TLAP_SRC_OFFSET] =	((HdrBuf)[TLAP_SRC_OFFSET] & ~TLAP_SRC_ROUTING_MASK);
		
			pLinkHdr[TLAP_SRC_OFFSET] &= ~TLAP_SRC_ROUTING_MASK;
			pRouteInfo = pLinkHdr + TLAP_ROUTE_INFO_OFFSET;
		}
	}

	startOfPkt = pPkt;

	ASSERT(routeInfoLen <= TLAP_MAX_ROUTING_BYTES);

	//	Pull out the information we'll be playing with. All three valid AARP
	//  commands use the same packet format. But have some variable length
	//	fields.

	//	The packet will not include the 802.2 header!
	//	pPkt	+= IEEE8022_HDR_LEN;
	//	Length	-= IEEE8022_HDR_LEN;

	pPkt += AARP_HW_LEN_OFFSET;			// Skip the hardware type

	do
	{
		GETBYTE2SHORT (&hardwareLen, pPkt);
        pPkt++ ;
	
		if ((hardwareLen < AARP_MIN_HW_ADDR_LEN ) ||
			(hardwareLen > AARP_MAX_HW_ADDR_LEN))
		{
			logEventPlace = (FILENUM | __LINE__);
			break;
		}
	
		GETBYTE2SHORT(&protocolLength, pPkt);
		pPkt ++;

		if (protocolLength != AARP_PROTO_ADDR_LEN)
		{
			logEventPlace = (FILENUM | __LINE__);
			break;
		}
	
		GETSHORT2SHORT(&aarpCommand, pPkt);
		pPkt += 2;
	
		//	Remember where the source address is in the packet for
		//	entering it into the mapping table
		srcAddr = pPkt;

		// Skip over the source hardware length
		// Skip over to leading null pad on logical address.
		pPkt += (hardwareLen + 1);
	
		GETSHORT2SHORT(&srcNode.atn_Network, pPkt);
		pPkt += 2;
	
		srcNode.atn_Node = *pPkt++;
	
		// Skip the destination hardware address
		// Skip over to leading null pad on logical destination address.
		pPkt += (hardwareLen + 1);

		GETSHORT2SHORT(&dstNode.atn_Network, pPkt);
		pPkt += 2;
	
		dstNode.atn_Node = *pPkt++;
		
		// We should have eaten the whole packet...
		if ((ULONG)(pPkt - startOfPkt) != Length)
		{
			logEventPlace = (FILENUM | __LINE__);
			break;
		}
		
		// Ignore any AARPs from us.

		ASSERT(hardwareLen == TLAP_ADDR_LEN);
		if (AtalkFixedCompareCaseSensitive(srcAddr,
										   hardwareLen,
										   pPortDesc->pd_PortAddr,
										   hardwareLen))
		{
			break;
		}

		// Handle the Aarp command packets
		switch(aarpCommand)
		{
		  case AARP_REQUEST:
	
			// We can get valid mapping info from a request, use it!
			// We are guaranteed routing info is positive and is not odd
			// (atleast 2 bytes).

			ASSERT((routeInfoLen >= 0) && (routeInfoLen != 1));
			if (routeInfoLen > 0)
				atalkAarpTuneRouteInfo(pPortDesc, pRouteInfo);
			
			atalkAarpEnterIntoAmt(pPortDesc,
								  &srcNode,
								  srcAddr,
								  hardwareLen,
								  pRouteInfo,
								  routeInfoLen);
			
			// After that, we can ignore any request not destined for us.
			if (!AtalkNodeExistsOnPort(pPortDesc, &dstNode))
			{
                // our dial-in clients can only be in the network range of the
                // default port.  If another adapter is plugged into the same net
                // as the default adapter, we don't want dial-in clients to
                // mess things up: ignore anything not coming on default adapter
                // (as far as dial-in clients go)
                if (pPortDesc != AtalkDefaultPort)
                {
                    break;
                }

                //
			    // is this one of our dial-in "nodes"?  If so, we must send out
                // a proxy response from our DefaultPort.
                //
			    if ((pRasConn = FindAndRefRasConnByAddr(dstNode,
                                                        &dwFlags,
                                                        &fThisIsPPP)) != NULL)
			    {
                    if (fThisIsPPP)
                    {
                        ASSERT(((PATCPCONN)pRasConn)->Signature == ATCPCONN_SIGNATURE);
                        DerefPPPConn((PATCPCONN)pRasConn);
                    }
                    else
                    {
                        ASSERT(((PARAPCONN)pRasConn)->Signature == ARAPCONN_SIGNATURE);
                        DerefArapConn((PARAPCONN)pRasConn);
                    }
			    }

                //
                // nope, a dial-in client with such a node addr doesn't exist either..
                //
                else
                {
				    break;
                }
			}

			// The're asking about us, speak the truth.
			pBuffDesc = BUILD_AARPRESPONSE(pPortDesc,
										   hardwareLen,
										   srcAddr,
										   pRouteInfo,
										   routeInfoLen,
										   dstNode,
										   srcNode);

			if (pBuffDesc == NULL)
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
						("AtalkAarpPacketIn: Mem alloc failed %d\n", __LINE__));

				break;
			}

			if (!ATALK_SUCCESS(AtalkNdisSendPacket(pPortDesc,
												   pBuffDesc,
												   AtalkAarpSendComplete,
												   NULL)))
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
						("AtalkAarpPacketIn: SendPkt %lx failed %d\n",
						pBuffDesc->bd_CharBuffer, __LINE__));

				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_AARP_SEND_FAIL,
								STATUS_INSUFFICIENT_RESOURCES,
								pBuffDesc->bd_CharBuffer,
								Length);

				//	We allocated the packet.
				AtalkAarpSendComplete(NDIS_STATUS_FAILURE,
									  pBuffDesc,
									  NULL);

			}
			break;
		
		  case AARP_RESPONSE:

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			if (pPortDesc->pd_Flags & PD_FINDING_NODE)
			{
				//	No doubt, this is a response to our probe, check to make sure
				//  the address matches, if so set the "used" flag.
				if (ATALK_NODES_EQUAL(&dstNode, &pPortDesc->pd_TentativeNodeAddr))
				{
					pPortDesc->pd_Flags |= PD_NODE_IN_USE;

					//	Wakeup the blocking thread...
					KeSetEvent(&pPortDesc->pd_NodeAcquireEvent, IO_NETWORK_INCREMENT, FALSE);
				}
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			// is this one of our dial-in "nodes"?  If so, check if we are probing
			if ((pRasConn = FindAndRefRasConnByAddr(dstNode,
                                                    &dwFlags,
                                                    &fThisIsPPP)) != NULL)
			{
                //
                // our dial-in clients can only be in the network range of the
                // default port
                //
                ASSERT(pPortDesc == AtalkDefaultPort);

                pAtcpConn = NULL;
                pArapConn = NULL;

                if (fThisIsPPP)
                {
                    pAtcpConn = (PATCPCONN)pRasConn;
                    ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);
                }
                else
                {
                    pArapConn = (PARAPCONN)pRasConn;
                    ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);
                }

                // PPP client?
                if (pAtcpConn)
                {
                    if (dwFlags & ATCP_FINDING_NODE)
                    {
                        ACQUIRE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);

				        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
						    ("AtalkAarpPacketIn: PPP: someone owns %lx %x, retrying\n",
                                dstNode.atn_Network,dstNode.atn_Node));

                        pAtcpConn->Flags |= ATCP_NODE_IN_USE;

				        //	Wakeup the blocking thread...
				        KeSetEvent(&pAtcpConn->NodeAcquireEvent,
                                   IO_NETWORK_INCREMENT,
                                   FALSE);

                        RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                    }

                    // remove refcount put by FindAndRefRasConnByAddr
                    DerefPPPConn(pAtcpConn);
                }
                // nope, ARAP client
                else
                {
                    if (dwFlags & ARAP_FINDING_NODE)
                    {
                        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

				        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
						    ("AtalkAarpPacketIn: ARAP: someone owns %lx %x, retrying\n",
                                dstNode.atn_Network,dstNode.atn_Node));

                        pArapConn->Flags |= ARAP_NODE_IN_USE;

				        //	Wakeup the blocking thread...
				        KeSetEvent(&pArapConn->NodeAcquireEvent,
                                   IO_NETWORK_INCREMENT,
                                   FALSE);

                        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
                    }

                    // remove refcount put by FindAndRefRasConnByAddr
                    DerefArapConn(pArapConn);
                }
            }

			//	This must have been a response to a probe or request... update our
			//  mapping table.
			if (routeInfoLen != 0)
			{
				atalkAarpTuneRouteInfo(pPortDesc, pRouteInfo);
			}

			atalkAarpEnterIntoAmt(pPortDesc,
								  &srcNode,
								  srcAddr,
								  hardwareLen,
								  pRouteInfo,
								  routeInfoLen);
			break;
	
		  case AARP_PROBE:

			ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			if (pPortDesc->pd_Flags & PD_FINDING_NODE)
			{
				// If we get a probe for our current tentative address, set the
				// "used" flag.
				if (ATALK_NODES_EQUAL(&dstNode, &pPortDesc->pd_TentativeNodeAddr))
				{
					pPortDesc->pd_Flags |= PD_NODE_IN_USE;

					KeSetEvent(&pPortDesc->pd_NodeAcquireEvent,
							   IO_NETWORK_INCREMENT,
							   FALSE);
				}
			}
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	
            if (pPortDesc != AtalkDefaultPort)
            {
                break;
            }

            fDialInNode = FALSE;

            // is the probe asking about one of our dial-in nodes? if so, we
            // must defend that address (or, if we are trying to acquire this
            // node addr, stop that since someone else is doing the same)
            //
            // our dial-in clients can only be in the network range of the
            // default port.  If another adapter is plugged into the same net
            // as the default adapter, we don't want dial-in clients to
            // mess things up: ignore anything not coming on default adapter
            // (as far as dial-in clients go)
			if ((pPortDesc == AtalkDefaultPort) &&
                ((pRasConn = FindAndRefRasConnByAddr(dstNode,
                                                     &dwFlags,
                                                     &fThisIsPPP)) != NULL))
			{

                pAtcpConn = NULL;
                pArapConn = NULL;

                if (fThisIsPPP)
                {
                    pAtcpConn = (PATCPCONN)pRasConn;
                    ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);
                }
                else
                {
                    pArapConn = (PARAPCONN)pRasConn;
                    ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);
                }

                // PPP client?
                if (pAtcpConn)
                {
                    if (dwFlags & ATCP_FINDING_NODE)
                    {
                        ACQUIRE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);

				        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
						    ("AtalkAarpPacketIn: PPP: someone trying to acquire %lx %x, retrying\n",
                                dstNode.atn_Network,dstNode.atn_Node));

                        pAtcpConn->Flags |= ATCP_NODE_IN_USE;

				        //	Wakeup the blocking thread...
				        KeSetEvent(&pAtcpConn->NodeAcquireEvent,
                                   IO_NETWORK_INCREMENT,
                                   FALSE);

                        RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
                    }
                    else
                    {
                        fDialInNode = TRUE;
                    }

                    // remove refcount put by FindAndRefRasConnByAddr
                    DerefPPPConn(pAtcpConn);

                }
                // nope, ARAP client
                else
                {
                    if (dwFlags & ARAP_FINDING_NODE)
                    {
                        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

				        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
						    ("AtalkAarpPacketIn: ARAP: someone trying to acquire %lx %x, retrying\n",
                                dstNode.atn_Network,dstNode.atn_Node));

                        pArapConn->Flags |= ARAP_NODE_IN_USE;

				        //	Wakeup the blocking thread...
				        KeSetEvent(&pArapConn->NodeAcquireEvent,
                                   IO_NETWORK_INCREMENT,
                                   FALSE);

                        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
                    }
                    else
                    {
                        fDialInNode = TRUE;
                    }

                    // remove refcount put by FindAndRefRasConnByAddr
                    DerefArapConn(pArapConn);
                }
            }

			//	If the probe isn't asking about one of our AppleTalk addresses,
			//  and it's not one of our dial-in nodes either, drop it on the floor.
			if (!fDialInNode && !AtalkNodeExistsOnPort(pPortDesc, &dstNode))
			{
				break;
			}

			// The're talking to us! Build and send the response.
			if (routeInfoLen != 0)
			{
				atalkAarpTuneRouteInfo(pPortDesc, pRouteInfo);
			}

            if (fDialInNode)
            {
				DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
						("AtalkAarpPacketIn: defending dial-in client's addr %x %x\n",
                        dstNode.atn_Network,dstNode.atn_Node));
            }

			pBuffDesc = BUILD_AARPRESPONSE(pPortDesc,
										   hardwareLen,
										   srcAddr,
										   pRouteInfo,
										   routeInfoLen,
										   dstNode,
										   srcNode);
												
			if (pBuffDesc == NULL)
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
						("AtalkAarpPacketIn: Mem alloc failed %d\n", __LINE__));

				break;
			}

			if (!ATALK_SUCCESS(AtalkNdisSendPacket(pPortDesc,
												  pBuffDesc,
												  AtalkAarpSendComplete,
												  NULL)))
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
						("AtalkAarpPacketIn: SendPkt %lx failed %d\n",
						pBuffDesc->bd_CharBuffer, __LINE__));

				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_AARP_SEND_FAIL,
								STATUS_INSUFFICIENT_RESOURCES,
								pBuffDesc->bd_CharBuffer,
								Length);

				//	We allocated the packet. This will free it up.
				AtalkAarpSendComplete(NDIS_STATUS_FAILURE,
									  pBuffDesc,
									  NULL);

			}
			break;
	
		  default:
			logEventPlace = (FILENUM | __LINE__);
			break;
		}
	} while (FALSE);

	if (logEventPlace)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_INVALIDAARPPACKET,
						logEventPlace,
						startOfPkt,
						Length);
	}

	TimeE = KeQueryPerformanceCounter(NULL);

	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_AarpPacketInProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(
		&pPortDesc->pd_PortStats.prtst_NumAarpPacketsIn,
		&AtalkStatsLock.SpinLock);
}




VOID
AtalkAarpSendComplete(
	NDIS_STATUS				Status,
	PBUFFER_DESC			pBuffDesc,
	PSEND_COMPL_INFO		pSendInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ASSERT(pBuffDesc->bd_Next == NULL);
	ASSERT(pBuffDesc->bd_Flags & BD_CHAR_BUFFER);

	AtalkNdisFreeBuf(pBuffDesc);
}




#define	AtalkAarpUpdateBre(_pPortDesc,									\
						   _Network,									\
						   _SrcAddr,									\
						   _AddrLen,									\
						   _RouteInfo,									\
						   _RouteInfoLen)								\
{																		\
	PBRE	pBre, *ppBre;												\
	int		index;														\
	BLKID	BlkId;														\
																		\
	DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,								\
			("AtalkAarpUpdateBre: Entering %x in brc\n", _Network));	\
																		\
	index = (int)((_Network) & (PORT_BRC_HASH_SIZE - 1));				\
																		\
	ACQUIRE_SPIN_LOCK_DPC(&(_pPortDesc)->pd_Lock);						\
																		\
	for (ppBre = &(_pPortDesc)->pd_Brc[index];							\
		 (pBre = *ppBre) != NULL;										\
		 ppBre = &pBre->bre_Next)										\
	{																	\
		if (pBre->bre_Network == (_Network))							\
		{																\
			 /*															\
			 * Unlink it from the list since it could potentially		\
			 * be freed if the routeinfolen grew and also we want		\
			 * to link it again at the head of the list					\
			 */															\
			*ppBre = pBre->bre_Next;									\
			break;														\
		}																\
	}																	\
																		\
	if ((pBre != NULL) &&												\
		(pBre->bre_RouteInfoLen < (BYTE)(_RouteInfoLen)))				\
	{																	\
		AtalkBPFreeBlock(pBre);											\
		pBre = NULL;													\
	}																	\
																		\
	if (pBre == NULL)													\
	{																	\
		BlkId = BLKID_BRE;												\
		if ((_RouteInfoLen) != 0)										\
			BlkId = BLKID_BRE_ROUTE;									\
		pBre = (PBRE)AtalkBPAllocBlock(BlkId);							\
	}																	\
																		\
	if (pBre != NULL)													\
	{																	\
		pBre->bre_Age = 0;												\
		pBre->bre_Network = (_Network);									\
																		\
		COPY_NETWORK_ADDR(pBre->bre_RouterAddr,							\
						  _SrcAddr);									\
																		\
		pBre->bre_RouteInfoLen =(BYTE)(_RouteInfoLen);					\
																		\
		if ((_RouteInfoLen) > 0)										\
			RtlCopyMemory((PBYTE)pBre + sizeof(BRE),					\
						  _RouteInfo,									\
						  _RouteInfoLen);								\
																		\
		pBre->bre_Next = *ppBre;										\
		*ppBre = pBre;													\
	}																	\
																		\
	RELEASE_SPIN_LOCK_DPC(&(_pPortDesc)->pd_Lock);						\
}

BOOLEAN
AtalkAarpGleanInfo(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				SrcAddr,
	IN		SHORT				AddrLen,
	IN  OUT	PBYTE				RouteInfo,
	IN		USHORT				RouteInfoLen,
	IN		PBYTE				pPkt,
	IN		USHORT				Length
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_NODEADDR		srcNode, dstNode;
	PBYTE				startOfPkt;
	ULONG				logEventPlace = 0;
	BYTE				offCableInfo;
	BOOLEAN				result = TRUE;
	
	if (PORT_CLOSING(pPortDesc))
	{
		//	If we are not active, return!
		return FALSE;
	}

	//	Packet will not include the 802.2 header!
	//	pPkt += IEEE8022_HDR_LEN;
	//	Length -= IEEE8022_HDR_LEN;

	//	Remember the start of the packet
	startOfPkt = pPkt;

	//	Get the off cable information
	offCableInfo = *pPkt;

	//	Skip the datagram length and checksum fields
	pPkt += (2 + 2);

	//	Get the destination network number
	GETSHORT2SHORT(&dstNode.atn_Network, pPkt);
	pPkt += sizeof(USHORT);

	//	Get the source network number
	GETSHORT2SHORT(&srcNode.atn_Network, pPkt);
	pPkt += sizeof(USHORT);

	//	Get the destination node id
	dstNode.atn_Node = *pPkt++;

	//	Get the source node id
	srcNode.atn_Node = *pPkt++;

	do
	{
		//	Do a little verification.
		if ((srcNode.atn_Node < MIN_USABLE_ATALKNODE) ||
			(srcNode.atn_Node > MAX_USABLE_ATALKNODE) ||
			(srcNode.atn_Network < FIRST_VALID_NETWORK) ||
			(srcNode.atn_Network > LAST_VALID_NETWORK))
		{
			//	Only bother logging this if we are in some routing capacity,
			//  otherwise, let A-ROUTER worry about it
			if (AtalkRouter)
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
						("AtalkAarpGleanInfo: dstNode invalid %x.%x\n",
						srcNode.atn_Network, srcNode.atn_Node));
				logEventPlace = FILENUM | __LINE__;
			}
			break;
		}
	
		if (dstNode.atn_Network > LAST_VALID_NETWORK)
		{
			DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
					("AtalkAarpGleanInfo: srcNode invalid %x.%x\n",
					dstNode.atn_Network, dstNode.atn_Node));
			logEventPlace = FILENUM | __LINE__;
			break;
		}
		
		//	Did the packet come from off this cable?  Look at the hop count.  If so,
		//  enter it into our best-router cache.
		//
		//	**NOTE** We assume that the RouteInfo buffer can be written to!

		if (RouteInfoLen > 0)
			atalkAarpTuneRouteInfo(pPortDesc, RouteInfo);

		if ((offCableInfo >> 2) & AARP_OFFCABLE_MASK)
		{
			AtalkAarpUpdateBre(pPortDesc,
							   srcNode.atn_Network,
							   SrcAddr,
							   AddrLen,
							   RouteInfo,
							   RouteInfoLen);
		}
		else
		{
			DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
					("AtalkAarpGleanInfo: Entering %x.%x info in Amt tables\n",
					srcNode.atn_Network, srcNode.atn_Node));

			// "Glean" AARP information from on-cable packets.
			atalkAarpEnterIntoAmt(pPortDesc,
								  &srcNode,
								  SrcAddr,
								  AddrLen,
								  RouteInfo,
								  RouteInfoLen);
		}
	} while (FALSE);

	if (logEventPlace)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_INVALIDAARPPACKET,
						logEventPlace,
						startOfPkt,
						Length);
	}
	
	return (logEventPlace == 0);
}


VOID
AtalkAarpOptGleanInfo(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				pLinkHdr,
	IN		PATALK_ADDR			pSrcAddr,
	IN		PATALK_ADDR			pDestAddr,
	IN		BOOLEAN				OffCablePkt
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_NODEADDR		srcNode, dstNode;
	int					index;
	PBYTE				pRouteInfo;
	USHORT				routeLen = 0, srcOffset;
	
	if (PORT_CLOSING(pPortDesc))
	{
		//	If we are not active, return!
		return;
	}

	switch (pPortDesc->pd_NdisPortType)
	{
	  case NdisMedium802_5:

		if (pLinkHdr[TLAP_SRC_OFFSET] & TLAP_SRC_ROUTING_MASK)
		{
			routeLen = (pLinkHdr[TLAP_ROUTE_INFO_OFFSET] & TLAP_ROUTE_INFO_SIZE_MASK);

			//
			//  First, glean any AARP information that we can, then handle the DDP
			//  packet.  This guy also makes sure we have a good 802.2 header...
			//
			//  Need to make a localcopy of the source address and then turn
			//  the source routing bit off before calling AarpGleanInfo
			//
			//	(HdrBuf)[TLAP_SRC_OFFSET] = ((HdrBuf)[TLAP_SRC_OFFSET] & ~TLAP_SRC_ROUTING_MASK);
			//
		
			pLinkHdr[TLAP_SRC_OFFSET] &= ~TLAP_SRC_ROUTING_MASK;
			pRouteInfo = pLinkHdr + TLAP_ROUTE_INFO_OFFSET;
		}
		srcOffset = TLAP_SRC_OFFSET;
		break;

	  case NdisMedium802_3:
		srcOffset	 = ELAP_SRC_OFFSET;
		break;

	  case NdisMediumFddi:
		srcOffset	 = FDDI_SRC_OFFSET;
		break;

	  default:
		KeBugCheck(0);
		break;
	}

	//	Get the destination network number
	dstNode.atn_Network	= pDestAddr->ata_Network;
	dstNode.atn_Node	= pDestAddr->ata_Node;
	srcNode.atn_Network	= pSrcAddr->ata_Network;
	srcNode.atn_Node	= pSrcAddr->ata_Node;

	do
	{
		//	Do a little verification.
		if ((srcNode.atn_Node < MIN_USABLE_ATALKNODE) ||
			(srcNode.atn_Node > MAX_USABLE_ATALKNODE) ||
			(srcNode.atn_Network < FIRST_VALID_NETWORK) ||
			(srcNode.atn_Network > LAST_VALID_NETWORK))
		{
			break;
		}
	
		if (dstNode.atn_Network > LAST_VALID_NETWORK)
		{
			break;
		}
		
		//	Did the packet come from off this cable?  Look at the hop count.  If so,
		//  enter it into our best-router cache.
		//
		//	**NOTE** We assume that the pRouteInfo buffer can be written to!

		if (routeLen > 0)
			atalkAarpTuneRouteInfo(pPortDesc, pRouteInfo);

		if (OffCablePkt)
		{
			AtalkAarpUpdateBre(pPortDesc,
							   srcNode.atn_Network,
							   pLinkHdr + srcOffset,
							   ELAP_ADDR_LEN,
							   pRouteInfo,
							   routeLen);
		}
		else
		{
			DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
					("AtalkAarpGleanInfo: Entering %x.%x info in Amt tables\n",
					srcNode.atn_Network, srcNode.atn_Node));

			// "Glean" AARP information from on-cable packets.
			atalkAarpEnterIntoAmt(pPortDesc,
								  &srcNode,
								  pLinkHdr + srcOffset,
								  ELAP_ADDR_LEN,
								  pRouteInfo,
								  routeLen);
		}

	} while (FALSE);
}


ATALK_ERROR
AtalkInitAarpForNodeOnPort(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		BOOLEAN				AllowStartupRange,
	IN		ATALK_NODEADDR		DesiredNode,
	IN OUT	PATALK_NODE		*	ppAtalkNode
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR			error;
	PDDP_ADDROBJ		pDdpAddr;
	ATALK_NODEADDR		newNode;
	PATALK_NODE			pAtalkNode;
	KIRQL				OldIrql;
	BOOLEAN				foundNode = FALSE;
	BOOLEAN				inStartupRange = FALSE, result = TRUE;

	if (!ATALK_SUCCESS(AtalkInitNodeAllocate(pPortDesc, &pAtalkNode)))
	{
		return ATALK_RESR_MEM;
	}

	//	Try to find a new extended Node on the given port; first try for the
	//  requested address (if specified), else try in this port's cable range
	//  (if it's known) or in the default cable range (if any), then try the
	//  start-up range (if allowed).

	do
	{
		if (DesiredNode.atn_Network != UNKNOWN_NETWORK)
		{
			if (((pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY) == 0) ||
				(WITHIN_NETWORK_RANGE(DesiredNode.atn_Network, &pPortDesc->pd_NetworkRange)))
			{
				foundNode = atalkInitAarpForNode(pPortDesc,
                                                 NULL,      // not a dial-in client
                                                 FALSE,     // don't care
												 DesiredNode.atn_Network,
												 DesiredNode.atn_Node);
	
			}
			// leave if we found a node.
			if (foundNode)
			{
				newNode = DesiredNode;
				break;
			}
		}
	
		if (pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
		{
			foundNode = AtalkInitAarpForNodeInRange(pPortDesc,
                                                    NULL,   // not a dial-in client
                                                    FALSE,  // don't care
													pPortDesc->pd_NetworkRange,
													&newNode);

			// leave if we found a node.
			if (foundNode)
			{
				break;
			}
		}

		if (pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK)
		{
			foundNode = AtalkInitAarpForNodeInRange(pPortDesc,
                                                    NULL,   // not a dial-in client
                                                    FALSE,  // don't care
													pPortDesc->pd_InitialNetworkRange,
													&newNode);

			// leave if we found a node.
			if (foundNode)
			{
				break;
			}
		}

		//	If no place else to try, try the start-up range.  Do this even if
		//  we don't want to end up there.
		//
		//	The idea is that this happens only when we are starting the router
		//	on one of our ports. So we do not want the router started in the
		//	startup range. If we do start in the startup range, and we see later
		//	that we did not see a router in the process,
		//	we will release the node. Of course, if we are a seed router, we will
		//	never be here, as the if statement above will be true.
		//
	
		inStartupRange = TRUE;
		foundNode = AtalkInitAarpForNodeInRange(pPortDesc,
                                                NULL,   // not a dial-in client
                                                FALSE,  // don't care
												AtalkStartupNetworkRange,
												&newNode);
		break;

	} while (FALSE);
	
	//	If we have a tentative Node, go on.
	if (foundNode)
	{
		do
		{
			//	Use the allocated structure to set the info.
			//	Thread this into the port structure.
			pAtalkNode->an_NodeAddr = newNode;

			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

			//	Reference the port for this node.
			AtalkPortRefByPtrNonInterlock(pPortDesc, &error);
			if (!ATALK_SUCCESS(error))
			{
				result = FALSE;
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
				AtalkFreeMemory(pAtalkNode);
				break;
			}

			//	Now put it in the port descriptor
            pAtalkNode->an_Next = pPortDesc->pd_Nodes;
            pPortDesc->pd_Nodes = pAtalkNode;
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	
			//	See who's out there.  We need to open the ZIP socket in order to be
			//  able to hear replies.
			if (!ATALK_SUCCESS(AtalkDdpOpenAddress(pPortDesc,
												   ZONESINFORMATION_SOCKET,
												   &newNode,
												   AtalkZipPacketIn,
												   NULL,
												   DDPPROTO_ANY,
												   NULL,
												   &pDdpAddr)))
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_OPENZIPSOCKET,
								0,
								NULL,
								0);
	
				AtalkNodeReleaseOnPort(pPortDesc, pAtalkNode);
	
				result = FALSE;
				break;
			}

            // mark the fact that this is an "internal" socket
            pDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;


			if (!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY))
			{
				// Get the default zone
				AtalkZipGetNetworkInfoForNode(pPortDesc, &pAtalkNode->an_NodeAddr, TRUE);

				// Validate the desired zone
				AtalkZipGetNetworkInfoForNode(pPortDesc, &pAtalkNode->an_NodeAddr, FALSE);
			}
			
			//	If nobody was out there and our tentative Node was in the
			//	startup range and our caller doesn't want to be there, return
			//	an error now.
			//
			//	Note: this means that we were trying to start the router on
			//	a non-seeding port, and since there is not router on the net,
			//	it means the net is not seeded and so, we exit.
			
			if (inStartupRange &&
				!(pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY) &&
				!AllowStartupRange)
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_STARTUPRANGENODE,
								0,
								NULL,
								0);
	
				AtalkNodeReleaseOnPort(pPortDesc, pAtalkNode);
	
				result = FALSE;
				break;
			}
	
			//	If we have seen SeenRouterRecently is not true, that means we have
			//	used the InitialNetworkRange to AARP. If now SeenRouterRecently is
			//	true that means we have gotten the address in the InitialNetworkRange,
			//	but now there is a seeded range on the net that we must use. So redo
			//	the GetNode work.
			
			if ((pPortDesc->pd_Flags & PD_SEEN_ROUTER_RECENTLY) &&
				!WITHIN_NETWORK_RANGE(newNode.atn_Network,
									  &pPortDesc->pd_NetworkRange))
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_INITIALRANGENODE,
								0,
								NULL,
								0);
	
				// Release the node we obtained.
				AtalkNodeReleaseOnPort(pPortDesc, pAtalkNode);

				// Get another node and retry in the correct range.
				ASSERTMSG("NetworkRange still set to startup!\n",
							pPortDesc->pd_NetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK);

				foundNode = AtalkInitAarpForNodeInRange(pPortDesc,
                                                        NULL,   // not a dial-in client
                                                        FALSE,  // don't care
														pPortDesc->pd_NetworkRange,
														&newNode);

				if (foundNode)
				{
					ASSERTMSG("New node is not within NetworkRange!\n",
								WITHIN_NETWORK_RANGE(newNode.atn_Network,
													 &pPortDesc->pd_NetworkRange));

					if (!ATALK_SUCCESS(AtalkInitNodeAllocate(pPortDesc, &pAtalkNode)))
					{
						result = FALSE;
						break;
					}

					//	Use the allocated structure to set the info.
					//	Thread this into the port structure.
					pAtalkNode->an_NodeAddr = newNode;
			
					//	Reference the port for this node.
					AtalkPortReferenceByPtr(pPortDesc, &error);
					if (!ATALK_SUCCESS(error))
					{
						result = FALSE;
						AtalkFreeMemory(pAtalkNode);
						break;
					}
		
					//	Now put it in the port descriptor
					ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
					pAtalkNode->an_Next = pPortDesc->pd_Nodes;
					pPortDesc->pd_Nodes = pAtalkNode;
					RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			
					//	Open the zip socket to be consistent
					if (!ATALK_SUCCESS(AtalkDdpOpenAddress(pPortDesc,
														   ZONESINFORMATION_SOCKET,
														   &newNode,
														   AtalkZipPacketIn,
														   NULL,
														   DDPPROTO_ANY,
														   NULL,
														   &pDdpAddr)))
					{
						LOG_ERRORONPORT(pPortDesc,
										EVENT_ATALK_OPENZIPSOCKET,
										0,
										NULL,
										0);
			
						AtalkNodeReleaseOnPort(pPortDesc, pAtalkNode);
			
						result = FALSE;
						break;
					}

                    // mark the fact that this is an "internal" socket
                    pDdpAddr->ddpao_Flags |= DDPAO_SOCK_INTERNAL;
				}
			}

		} while (FALSE);
	}
	else
	{
		//	Free the allocated node structure. This has not yet been
		//	inserted into the port descriptor, so we can just free it.
		AtalkFreeMemory(pAtalkNode);
	}

	if (foundNode && result)
	{
		// All set!
		ASSERT(ppAtalkNode != NULL);
		*ppAtalkNode = pAtalkNode;

		// atalkAarpEnterIntoAmt() expects to be called at DISPATCH_LEVEL. Make it so.
		KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

		atalkAarpEnterIntoAmt(pPortDesc,
							  &newNode,
							  pPortDesc->pd_PortAddr,
							  MAX_HW_ADDR_LEN,
							  NULL,
							  0);
		KeLowerIrql(OldIrql);


	}

	return ((foundNode && result) ? ATALK_NO_ERROR : ATALK_FAILURE);
}



BOOLEAN
AtalkInitAarpForNodeInRange(
	IN	PPORT_DESCRIPTOR	pPortDesc,
    IN  PVOID               pRasConn,
    IN  BOOLEAN             fThisIsPPP,
	IN	ATALK_NETWORKRANGE	NetworkRange,
	OUT	PATALK_NODEADDR		Node
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE	currentNode;
	USHORT	currentNetwork;
	int		firstNode, lastNode;
	long	netTry;
	int		nodeTry;
	USHORT	nodeWidth, nodeChange, nodeIndex;
	USHORT	netWidth, netChange, netIndex;
	BOOLEAN	found = FALSE;
	
	//	Pick the node number range we'll try for (we do not pay attention to the
	//	"ServerNode" concept for LocalTalk). Our node is obtained by the
	//	localtalk driver anyways.
	firstNode = MIN_USABLE_ATALKNODE;
	lastNode = MAX_EXT_ATALKNODE;
	
	//	Okay, now some fun starts. Plow through our options trying to find an
	//  unused extended node number.
	
	//	Compute the width of our network range, and pick a random start point.
	netWidth = (USHORT)((NetworkRange.anr_LastNetwork + 1) - NetworkRange.anr_FirstNetwork);
	netTry = GET_RANDOM(NetworkRange.anr_FirstNetwork, NetworkRange.anr_LastNetwork);
	
	//	Come up with a random decrement, making sure it's odd (to avoid repeats)
	//  and large enough to appear pretty random.
	netChange = (USHORT)(GET_RANDOM(1, netWidth) | 1);
	while ((netWidth % netChange == 0) ||
			(!AtalkIsPrime((long)netChange)))
	{
		netChange += 2;
	}
	
	//	Now walk trough the range decrementing the starting network by the
	//  choosen change (with wrap, of course) until we find an address or
	//  we've processed every available network in the range.
	for (netIndex = 0; netIndex < netWidth; netIndex ++)
	{
		currentNetwork = (USHORT) netTry;
	
		// Compute the width of our node range, and pick a random start point.
		nodeWidth = (USHORT)((lastNode + 1) - firstNode);
		nodeTry = (int)GET_RANDOM(firstNode, lastNode);

		//	Come up with a random decrement, making sure it's odd (to avoid repeats)
		//  and large enough to appear pretty random.
		nodeChange = (USHORT)(GET_RANDOM(1, nodeWidth) | 1);
		while ((nodeWidth % nodeChange == 0) || !(AtalkIsPrime((long)nodeChange)))
			nodeChange += 2;
	
		//	Now walk trough the range decrementing the starting network by the
		//  choosen change (with wrap, of course) until we find an address or
		//  we've processed every available node in the range.
		for (nodeIndex = 0; nodeIndex < nodeWidth; nodeIndex ++)
		{
			currentNode = (BYTE )nodeTry;

			// Let AARP have a crack at it.
			if ((found = atalkInitAarpForNode(pPortDesc,
                                              pRasConn,
                                              fThisIsPPP,
                                              currentNetwork,
                                              currentNode)))
            {
				break;
            }
	
			// Okay, try again, bump down with wrap.
			nodeTry -= nodeChange;
			while (nodeTry < firstNode)
				nodeTry += nodeWidth;
	
		}  // Node number loop

		//	If we found a node, break on thru to the other side.
		if (found)
			break;
	
		// Okay, try again, bump down with wrap.
		netTry -= netChange;
		while (netTry < (long)NetworkRange.anr_FirstNetwork)
			netTry += netWidth;
	
	}  // Network number loop

	// Okay if we found one return all's well, otherwise no luck.
	if (found)
	{
		if (Node != NULL)
		{
			Node->atn_Network = currentNetwork;
			Node->atn_Node	= currentNode;
		}
	}
	return found;
	
}  // AarpForNodeInRange



LOCAL BOOLEAN
atalkInitAarpForNode(
	IN	PPORT_DESCRIPTOR	pPortDesc,
    IN  PVOID               pRasConn,
    IN  BOOLEAN             fThisIsPPP,
	IN	USHORT				Network,
	IN	BYTE				Node
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	SHORT			probeAttempt;
	PBUFFER_DESC	pBuffDesc;
    PVOID           pTmpConn;
    PATCPCONN       pAtcpConn;
    PARAPCONN       pArapConn;
	ATALK_NODEADDR	tryNode;
	KIRQL			OldIrql;
    PKEVENT         pWaitEvent;
    DWORD           dwFlags;
	BOOLEAN			nodeInUse;
    BOOLEAN         fNoOneHasResponded=TRUE;
    BOOLEAN         fPPPConn;


	DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
			("atalkAarpForNode: AARPing for %x.%x on port %Z\n",
			Network, Node, &pPortDesc->pd_AdapterKey));

	// First make sure we don't own this node.
	tryNode.atn_Network = Network;
	tryNode.atn_Node	= Node;

	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	nodeInUse = AtalkNodeExistsOnPort(pPortDesc, &tryNode);

	KeLowerIrql(OldIrql);

	if (nodeInUse)
	{
		return(FALSE);
	}

    // is this node used by one of the dial in clients?
	if ((pTmpConn = FindAndRefRasConnByAddr(tryNode, &dwFlags, &fPPPConn)) != NULL)
	{
	    DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
		    ("atalkAarpForNode: %x.%x already a dial in client (%lx)\n",
			    Network, Node, pTmpConn));

        // our dial-in clients can only be in the network range of the
        // default port
        ASSERT(pPortDesc == AtalkDefaultPort);

        if (fPPPConn)
        {
            ASSERT(((PATCPCONN)pTmpConn)->Signature == ATCPCONN_SIGNATURE);
            DerefPPPConn((PATCPCONN)pTmpConn);
        }
        else
        {
            ASSERT(((PARAPCONN)pTmpConn)->Signature == ARAPCONN_SIGNATURE);
            DerefArapConn((PARAPCONN)pTmpConn);
        }
		return(FALSE);
	}

    pAtcpConn = NULL;
    pArapConn = NULL;

    //
    // if we are acquiring a node addr for a dial-in client...
    //

    if (pRasConn != NULL)
    {
        if (fThisIsPPP)
        {
            pAtcpConn = (PATCPCONN)pRasConn;
        }
        else
        {
            pArapConn = (PARAPCONN)pRasConn;
        }
    }

    // PPP client?
    if (pAtcpConn)
    {
        ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);
        pAtcpConn->NetAddr.atn_Network = Network;
        pAtcpConn->NetAddr.atn_Node = Node;
        pAtcpConn->Flags &= ~ATCP_NODE_IN_USE;
        pWaitEvent = &pAtcpConn->NodeAcquireEvent;
        RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);
    }

    // nope, ARAP client?
    else if (pArapConn)
    {
        ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);
        pArapConn->NetAddr.atn_Network = Network;
        pArapConn->NetAddr.atn_Node = Node;
        pArapConn->Flags &= ~ARAP_NODE_IN_USE;
        pWaitEvent = &pArapConn->NodeAcquireEvent;
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
    }
    // no, this is node acquisition for one of the server nodes
    else
    {
	    // Use AARP to probe for a particular network/node address.
	    ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	    pPortDesc->pd_Flags &= ~PD_NODE_IN_USE;
	    pPortDesc->pd_TentativeNodeAddr.atn_Network = Network;
	    pPortDesc->pd_TentativeNodeAddr.atn_Node = Node;
        pWaitEvent = &pPortDesc->pd_NodeAcquireEvent;
	    RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
    }
	
    fNoOneHasResponded = TRUE;

	// Build the packet and blast it out the specified number of times.
	for (probeAttempt = 0;
		 ((probeAttempt < pPortDesc->pd_AarpProbes) && (fNoOneHasResponded));
		 probeAttempt ++)
	{
		pBuffDesc = BUILD_AARPPROBE(pPortDesc, MAX_HW_ADDR_LEN, tryNode);

		if (pBuffDesc == NULL)
		{
			RES_LOG_ERROR();
			break;
		}

		if (!ATALK_SUCCESS(AtalkNdisSendPacket(pPortDesc,
											   pBuffDesc,
											   AtalkAarpSendComplete,
											   NULL)))
		{
	        DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
			    ("atalkAarpForNode: AtalkNdisSendPacket failed while AARPing for %x.%x\n",
			    Network, Node));

			//	We allocated the packet.		
			AtalkAarpSendComplete(NDIS_STATUS_FAILURE, pBuffDesc, NULL);
			break;
		}

		AtalkWaitTE(pWaitEvent, AARP_PROBE_TIMER_MS);

        // node addr for a PPP client?
        if (pAtcpConn)
        {
            ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);
            if (pAtcpConn->Flags & ATCP_NODE_IN_USE)
            {
                fNoOneHasResponded = FALSE;
            }
            RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);
        }
        // node addr for a ARAP client?
        else if (pArapConn)
        {
            ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);
            if (pArapConn->Flags & ARAP_NODE_IN_USE)
            {
                fNoOneHasResponded = FALSE;
            }
            RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        }
        // nope, node addr for one of the server nodes
        else
        {
            ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
            if (pPortDesc->pd_Flags & PD_NODE_IN_USE)
            {
                fNoOneHasResponded = FALSE;
            }
            RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
        }

	}  // Probe attempts loop


	// We win if the current tentenative node has not been used
    // (i.e. no one responds to our probes)

	return (fNoOneHasResponded);
	
}  // atalkAarpForNode



LOCAL VOID
atalkAarpEnterIntoAmt(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PATALK_NODEADDR		pSrcNode,
	IN		PBYTE				SrcAddr,
	IN		SHORT				AddrLen,
	IN		PBYTE				RouteInfo,
	IN		SHORT				RouteInfoLen
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	int					index;
	PAMT				pAmt, *ppAmt;

	if ((pSrcNode->atn_Node < MIN_USABLE_ATALKNODE)	||
		(pSrcNode->atn_Node > MAX_USABLE_ATALKNODE)	||
		(pSrcNode->atn_Network < FIRST_VALID_NETWORK) ||
		(pSrcNode->atn_Network > LAST_VALID_NETWORK))
	{
		UCHAR	AtalkAndMacAddress[sizeof(ATALK_NODEADDR) + MAX_HW_ADDR_LEN];
		DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
				("atalkAarpEnterIntoAmt: Bad Node %x, %x\n",
				pSrcNode->atn_Node, pSrcNode->atn_Network));
			
		RtlCopyMemory(AtalkAndMacAddress, pSrcNode, sizeof(ATALK_NODEADDR));
		RtlCopyMemory(AtalkAndMacAddress + sizeof(ATALK_NODEADDR), SrcAddr, MAX_HW_ADDR_LEN);
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_AMT_INVALIDSOURCE,
						0,
						AtalkAndMacAddress,
						sizeof(AtalkAndMacAddress));
		return;
	}
	
	DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
			("AtalkAarpEnterIntoAmt: Entering %x.%x in amt\n",
				pSrcNode->atn_Network, pSrcNode->atn_Node));

	// Do we already know about this mapping?
	index = HASH_ATALK_NODE(pSrcNode) & (PORT_AMT_HASH_SIZE - 1);

	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	for (ppAmt = &pPortDesc->pd_Amt[index];
		 (pAmt = *ppAmt) != NULL;
		 ppAmt = &pAmt->amt_Next)
	{
		ASSERT(VALID_AMT(pAmt));
		if (ATALK_NODES_EQUAL(pSrcNode, &pAmt->amt_Target))
		{
			DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
					("atalkAarpEnterIntoAmt: Address %x.%x exists in tables\n",
					pSrcNode->atn_Network, pSrcNode->atn_Node));

			if ((pAmt->amt_RouteInfoLen == 0) ^ (RouteInfoLen == 0))
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_WARN,
						("atalkAarpEnterIntoAmt: %x.%x has wrong routing info\n",
						pSrcNode->atn_Network, pSrcNode->atn_Node));

				*ppAmt = pAmt->amt_Next;
				AtalkBPFreeBlock(pAmt);
				pAmt = NULL;
			}
			break;
		}
	}
	
	// If not, allocate a new mapping Node.
	if (pAmt == NULL)
	{
		BLKID	BlkId;

		DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_WARN,
				("atalkAarpEnterIntoAmt: Address %x.%x DOES NOT exist in tables\n",
				pSrcNode->atn_Network, pSrcNode->atn_Node));

		ASSERT(RouteInfoLen <= TLAP_MAX_ROUTING_BYTES);
	
		BlkId = BLKID_AMT;
		if (RouteInfoLen != 0)
			BlkId = BLKID_AMT_ROUTE;
		if ((pAmt = (PAMT)AtalkBPAllocBlock(BlkId)) != NULL)
		{
#if	DBG
			pAmt->amt_Signature = AMT_SIGNATURE;
#endif
			// Link it in. Fill in below
			pAmt->amt_Target.atn_Network = pSrcNode->atn_Network;
			pAmt->amt_Target.atn_Node = pSrcNode->atn_Node;
			pAmt->amt_Next = pPortDesc->pd_Amt[index];
			pPortDesc->pd_Amt[index] = pAmt;
		}
	}

	if (pAmt != NULL)
	{
		// Update mapping table! Do this if we knew about the mapping OR
		// if we allocated a new node

		ASSERTMSG("HWAddrLen is not right!\n", (AddrLen == MAX_HW_ADDR_LEN));

		RtlCopyMemory(pAmt->amt_HardwareAddr, SrcAddr, AddrLen);

		ASSERTMSG("RouteLen is not right!\n", (RouteInfoLen <= MAX_ROUTING_BYTES));

		if (RouteInfoLen > 0)
			RtlCopyMemory((PBYTE)pAmt + sizeof(AMT), RouteInfo, RouteInfoLen);

		pAmt->amt_RouteInfoLen = (BYTE)RouteInfoLen;
		pAmt->amt_Age = 0;
	}

	RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
}




VOID
AtalkAarpReleaseAmt(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	int		index;
	PAMT	pAmt, *ppAmt;

	//	Free up all the AMT entries. No need to acquire spinlock at this
	//	point. We are unloading and all binding etc are gone.
	for (index = 0; index < PORT_AMT_HASH_SIZE; index ++)
	{
		for (ppAmt = &pPortDesc->pd_Amt[index];
			 (pAmt = *ppAmt) != NULL;
			 NOTHING)
		{
			ASSERT(VALID_AMT(pAmt));
			*ppAmt = pAmt->amt_Next;
			AtalkBPFreeBlock(pAmt);
		}
	}
}




VOID
AtalkAarpReleaseBrc(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	int		index;
	PBRE	pBre, *ppBre;

	//	Free up all the BRC entries. No need to acquire spinlock at this
	//	point. We are unloading and all binding etc are gone.
	for (index = 0; index < PORT_BRC_HASH_SIZE; index ++)
	{
		for (ppBre = &pPortDesc->pd_Brc[index];
			 (pBre = *ppBre) != NULL;
			 NOTHING)
		{
			*ppBre = pBre->bre_Next;
			AtalkBPFreeBlock(pBre);
		}
	}
}




LONG FASTCALL
AtalkAarpAmtTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PAMT					pAmt, *ppAmt;
    PPORT_DESCRIPTOR		pPortDesc;
	int						index;

	pPortDesc = (PPORT_DESCRIPTOR)CONTAINING_RECORD(pTimer, PORT_DESCRIPTOR, pd_AmtTimer);
	ASSERT(VALID_PORT(pPortDesc));

	ASSERT(EXT_NET(pPortDesc));

	//	Walk though all address mapping entries on this port aging the entries.
	//	We need to protect the mapping tables with critical sections, but don't
	//	stay in a critical section too long.

	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	if (TimerShuttingDown ||
		((pPortDesc->pd_Flags & PD_CLOSING) != 0))
	{
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		//	Remove the reference we added to this port at the time of
		//	starting the timer. Return;
		AtalkPortDereferenceDpc(pPortDesc);
		return ATALK_TIMER_NO_REQUEUE;
	}

	for (index = 0; index < PORT_AMT_HASH_SIZE; index ++)
	{
		for (ppAmt = &pPortDesc->pd_Amt[index];
			 (pAmt = *ppAmt) != NULL;
			 NOTHING)
		{
			ASSERT(VALID_AMT(pAmt));
			if (pAmt->amt_Age < AMT_MAX_AGE)
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_INFO,
						("atalkAarpAmtTimer: Entry for %x.%x %lx OK\n",
						pAmt->amt_Target.atn_Network, pAmt->amt_Target.atn_Node,
						pAmt));
				pAmt->amt_Age ++;
				ppAmt = &pAmt->amt_Next;
			}
			else
			{
				DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_WARN,
						("atalkAarpAmtTimer: Freeing node %x.%x from list\n",
						pAmt->amt_Target.atn_Network,
						pAmt->amt_Target.atn_Node));
				*ppAmt = pAmt->amt_Next;
				AtalkBPFreeBlock(pAmt);
			}
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	return ATALK_TIMER_REQUEUE;
}




LONG FASTCALL
AtalkAarpBrcTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	int					index;
    PPORT_DESCRIPTOR	pPortDesc;
	BOOLEAN				DerefPort = FALSE;

	pPortDesc = (PPORT_DESCRIPTOR)CONTAINING_RECORD(pTimer, PORT_DESCRIPTOR, pd_BrcTimer);
	
	ASSERT(VALID_PORT(pPortDesc));
	ASSERT(EXT_NET(pPortDesc));

	//	Walk though all best router entries on this port aging the entries.
	//	We need to protect the brc tables with critical sections, but don't
	//	stay in a critical section too long.

	ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	if (TimerShuttingDown ||
		((pPortDesc->pd_Flags & PD_CLOSING) != 0))
	{
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		//	Remove the reference we added to this port at the time of
		//	starting the timer. Return;
		AtalkPortDereferenceDpc(pPortDesc);
		return ATALK_TIMER_NO_REQUEUE;
	}

	for (index = 0; index < PORT_BRC_HASH_SIZE; index ++)
	{
		PBRE	pBre, *ppBre;

		for (ppBre = &pPortDesc->pd_Brc[index];
			 (pBre = *ppBre) != NULL;
			 NOTHING)
		{
			if (pBre->bre_Age < BRC_MAX_AGE)
			{
				pBre->bre_Age ++;
				ppBre = &pBre->bre_Next;
			}
			else
			{
				*ppBre = pBre->bre_Next;
				AtalkBPFreeBlock(pBre);
			}
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

	return ATALK_TIMER_REQUEUE;
}




PBUFFER_DESC
AtalkAarpBuildPacket(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		USHORT				Type,
	IN		USHORT				HardwareLen,
	IN		PBYTE				SrcHardwareAddr,
	IN		ATALK_NODEADDR		SrcLogicalAddr,
	IN		PBYTE				DestHardwareAddr,
	IN		ATALK_NODEADDR		DestLogicalAddr,
	IN		PBYTE				TrueDest,
	IN		PBYTE				RouteInfo,
	IN		USHORT				RouteInfoLen
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBYTE			aarpData;
	USHORT			linkLen;

	PBUFFER_DESC	pBuffDesc = NULL;
	BYTE			protocolLength 	= AARP_PROTO_ADDR_LEN;
    PVOID           pRasConn;
    DWORD           dwFlags;
    BOOLEAN         fThisIsPPP;


	//	Read only.
	static	BYTE	zeroAddr[MAX_HW_ADDR_LEN] =
	{
		0, 0, 0, 0, 0, 0
	};

#if DBG
    // make sure we aren't sending AARP request/probe for our own dial-in client
    if ((Type == AARP_REQUEST) || (Type == AARP_PROBE))
    {
        pRasConn = FindAndRefRasConnByAddr(DestLogicalAddr, &dwFlags, &fThisIsPPP);
        if (pRasConn)
        {
            if (fThisIsPPP)
            {
                ASSERT(((PATCPCONN)pRasConn)->Signature == ATCPCONN_SIGNATURE);

                if (dwFlags & ATCP_NODE_IN_USE)
                {
			        DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
				    ("AtalkAarpBuildPacket: PPP client (%lx) owns %x.%x (Type=%x)\n",
			        pRasConn,DestLogicalAddr.atn_Network, DestLogicalAddr.atn_Node,Type));
                }

                DerefPPPConn((PATCPCONN)pRasConn);
            }
            else
            {
                ASSERT(((PARAPCONN)pRasConn)->Signature == ARAPCONN_SIGNATURE);

                if (dwFlags & ARAP_NODE_IN_USE)
                {
			        DBGPRINT(DBG_COMP_AARP, DBG_LEVEL_ERR,
				    ("AtalkAarpBuildPacket: ARA client (%lx) owns %x.%x (Type=%x)\n",
			        pRasConn,DestLogicalAddr.atn_Network, DestLogicalAddr.atn_Node,Type));
                }

                DerefArapConn((PARAPCONN)pRasConn);
            }
        }
    }
#endif

	//	If no destination hardware address is specified, set it
	//	to all zeros.
	if (DestHardwareAddr == NULL)
	{
		DestHardwareAddr = zeroAddr;
	}

	//	Get a header buffer allocated from link routines. Tell it we want
	//	maximum aarp data size as the required size.
	AtalkNdisAllocBuf(&pBuffDesc);
	if (pBuffDesc == NULL)
	{
		return(pBuffDesc);
	}

	//	Build the LAP header.
	AtalkNdisBuildHdr(pPortDesc,
					  pBuffDesc->bd_CharBuffer,
					  linkLen,
					  AARP_MIN_DATA_SIZE,
					  TrueDest,
					  RouteInfo,
					  RouteInfoLen,
					  AARP_PROTOCOL);

	aarpData	=	pBuffDesc->bd_CharBuffer + linkLen;

	//	Build the specified type of AARP packet with the specified information;
	PUTSHORT2SHORT((PUSHORT)aarpData,
					pPortDesc->pd_AarpHardwareType);

	aarpData	+= sizeof(USHORT);

	PUTSHORT2SHORT((PUSHORT)aarpData,
					pPortDesc->pd_AarpProtocolType);

	aarpData	+= sizeof(USHORT);

	*aarpData++	= (BYTE)HardwareLen;
	*aarpData++ = (BYTE)AARP_PROTO_ADDR_LEN;
	
	PUTSHORT2SHORT((PUSHORT)aarpData, Type);
	
	aarpData	+= sizeof(USHORT);

	// Source hardware address.
	RtlCopyMemory(aarpData, SrcHardwareAddr, HardwareLen);

	aarpData += HardwareLen;

	// Source logical address pad
	*aarpData++ = 0;

	// Network number
	PUTSHORT2SHORT(aarpData, SrcLogicalAddr.atn_Network);

	aarpData += sizeof(USHORT);

	// Node number
	*aarpData++ = SrcLogicalAddr.atn_Node;

	// Destination hardware address.
	RtlCopyMemory(aarpData, DestHardwareAddr, HardwareLen);

	aarpData += HardwareLen;
	
	// Destination logical address, null pad
	*aarpData++ = 0;

	// Network number
	PUTSHORT2SHORT(aarpData, DestLogicalAddr.atn_Network);

	aarpData += sizeof(USHORT);

	// Node number
	*aarpData++ = DestLogicalAddr.atn_Node;

	//	Set length in the buffer descriptor. Pad it to max data size. Some devices seem
	// to drop the aarp responses if they see less, Macs dictate their behavior.
	// Also zero out the extra space.
	AtalkSetSizeOfBuffDescData(pBuffDesc,
							   (SHORT)(aarpData - pBuffDesc->bd_CharBuffer + AARP_MAX_DATA_SIZE - AARP_MIN_DATA_SIZE));
	RtlZeroMemory(aarpData, AARP_MAX_DATA_SIZE - AARP_MIN_DATA_SIZE);

	return pBuffDesc;
}




LOCAL VOID FASTCALL
atalkAarpTuneRouteInfo(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN	OUT	PBYTE				RouteInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Given an incoming TokenRing routing info, tune it to make it valid
	//  for outing routing info.  Do this in place!
	ASSERT(pPortDesc->pd_PortType == TLAP_PORT);
	
	// Set to "non-broadcast" and invert "direction".
	RouteInfo[0] &= TLAP_NON_BROADCAST_MASK;
	RouteInfo[1] ^= TLAP_DIRECTION_MASK;
}


#if DBG

VOID
AtalkAmtDumpTable(
	VOID
)
{
	int					j, k;
	KIRQL				OldIrql;
	PPORT_DESCRIPTOR	pPortDesc;
	PAMT				pAmt;

	ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

	for (pPortDesc = AtalkPortList;
		 pPortDesc != NULL;
		 pPortDesc = pPortDesc = pPortDesc->pd_Next)
	{
		DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
				("AMT Table for port %Z\n", &pPortDesc->pd_AdapterKey));

		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

		for (j = 0; j < PORT_AMT_HASH_SIZE; j++)
		{
			for (pAmt = pPortDesc->pd_Amt[j];
				 pAmt != NULL;
				 pAmt = pAmt->amt_Next)
			{
				DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
								("\t%d:  %lx.%lx", j,
								pAmt->amt_Target.atn_Network, pAmt->amt_Target.atn_Node));

				for (k = 0; k < MAX_HW_ADDR_LEN; k++)
				{
					DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
						("%02x", pAmt->amt_HardwareAddr[k]));
				}

				if (pAmt->amt_RouteInfoLen != 0)
				{
					PBYTE	pRouteInfo;

					pRouteInfo = (PBYTE)pAmt + sizeof(AMT);

					DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
									(" ("));
					for (k = 0; k < pAmt->amt_RouteInfoLen; k++)
					{
						DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
							(" %02x", pRouteInfo[k]));
					}
					DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL, (" )"));
				}
				DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("\n"));
			}
		}
		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
		DBGPRINTSKIPHDR(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("\n"));
	}

	RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\aarp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aarp.h

Abstract:

	This module contains information for the Appletalk Address Resolution Protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_AARP_
#define	_AARP_

#define	AARP_MAX_HW_ADDR_LEN 				(MAX_HW_ADDR_LEN)
#define AARP_MIN_HW_ADDR_LEN 				1

#define	AARP_PROTO_ADDR_LEN 				4

// AARP offsets (skipping Link/Hardware headers):
#define AARP_HW_TYPE_OFFSET        			0
#define AARP_PROTO_TYPE_OFFSET         		2
#define AARP_HW_LEN_OFFSET       			4
#define AARP_PROTO_LEN_OFFSET       		5
#define AARP_COMMAND_OFFSET              	6
#define AARP_SRC_ADDR_OFFSET     	   		8

// AARP Command types:
#define AARP_REQUEST  						1
#define AARP_RESPONSE 						2
#define AARP_PROBE    						3

// 	Supposed to be (for AppleTalk phase II) 10 * 1/5 seconds... but we'll be
//  a little more patient.
#define AARP_PROBETIMER			 			20	// In 100ths of a second
#define	AARP_PROBE_TIMER_MS					200	// In milliseconds
#define AARP_NUM_PROBES	        			15

#define	AARP_OFFCABLE_MASK					0x0F

VOID
AtalkAarpPacketIn(
	IN	OUT	PPORT_DESCRIPTOR		pPortDesc,
	IN		PBYTE					pLinkHdr,
	IN		PBYTE					pPkt,				// Only Aarp data
	IN		USHORT					Length);

VOID
AtalkAarpSendComplete(
	NDIS_STATUS						Status,
	PBUFFER_DESC					pBufDesc,
	struct _SEND_COMPL_INFO	*		pSendInfo);

BOOLEAN
AtalkAarpGleanInfo(
	IN	OUT	PPORT_DESCRIPTOR		pPortDesc,
	IN		PBYTE 					SrcAddr,
	IN		SHORT 					AddrLen,
	IN	OUT	PBYTE 					RouteInfo,
	IN		USHORT					RouteInfoLen,
	IN		PBYTE 					Pkt,
	IN		USHORT 					Length);

VOID
AtalkAarpOptGleanInfo(
	IN	OUT	PPORT_DESCRIPTOR		pPortDesc,
	IN		PBYTE					pLinkHdr,
	IN		PATALK_ADDR				pSrcAddr,
	IN		PATALK_ADDR				pDestAddr,
	IN		BOOLEAN					OffCablePkt);

ATALK_ERROR
AtalkInitAarpForNodeOnPort(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		BOOLEAN 				AllowStartupRange,
	IN		ATALK_NODEADDR 			DesiredNode,
	IN	OUT	struct _ATALK_NODE	**	ppAtalkNode);

BOOLEAN
AtalkInitAarpForNodeInRange(
	IN	PPORT_DESCRIPTOR			pPortDesc,
    IN  PVOID                       pRasConn,
    IN  BOOLEAN                     fThisIsPPP,
	IN	ATALK_NETWORKRANGE 			NetworkRange,
	OUT	PATALK_NODEADDR 			Node);

VOID
AtalkAarpReleaseAmt(
	IN	OUT	PPORT_DESCRIPTOR		pPortDesc);

VOID
AtalkAarpReleaseBrc(
	IN	OUT	PPORT_DESCRIPTOR		pPortDesc);

PBUFFER_DESC
AtalkAarpBuildPacket(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		USHORT 					Type,
	IN		USHORT              	HardwareLen,
	IN		PBYTE					SrcHardwareAddr,
	IN		ATALK_NODEADDR 			SrcLogicalAddr,
	IN		PBYTE 					DestHardwareAddr,
	IN		ATALK_NODEADDR 			DestLogicalAddr,
	IN		PBYTE					TrueDest,
	IN		PBYTE					RouteInfo,
	IN		USHORT					RouteInfoLen);

#define	BUILD_AARPPROBE(pPortDesc,hardwareLength,Node)					\
		AtalkAarpBuildPacket(											\
			pPortDesc,													\
			AARP_PROBE,													\
			hardwareLength, 											\
			pPortDesc->pd_PortAddr,										\
			Node,														\
			NULL,														\
			Node,														\
			NULL,														\
			NULL,														\
			0);


#define	BUILD_AARPRESPONSE(pPortDesc,hardwareLength,hardwareAddress,	\
							RoutingInfo,RoutingInfoLength,SourceNode,	\
							destinationNode) 							\
																		\
		AtalkAarpBuildPacket( 											\
			pPortDesc,													\
			AARP_RESPONSE,												\
			hardwareLength,												\
			pPortDesc->pd_PortAddr,										\
			SourceNode,													\
			hardwareAddress,											\
			destinationNode,											\
			hardwareAddress,											\
			RoutingInfo,												\
			RoutingInfoLength);

#define	BUILD_AARPREQUEST(pPortDesc,hardwareLength,SourceNode,			\
							destinationNode )							\
        AtalkAarpBuildPacket(											\
			pPortDesc,													\
			AARP_REQUEST,												\
			hardwareLength,												\
			pPortDesc->pd_PortAddr,										\
			SourceNode,													\
			NULL,														\
			destinationNode,											\
			NULL,														\
			NULL,														\
			0);

LONG FASTCALL
AtalkAarpAmtTimer(
	IN	PTIMERLIST					pTimer,
	IN	BOOLEAN						TimerShuttingDown);

LONG FASTCALL
AtalkAarpBrcTimer(
	IN	PTIMERLIST					pTimer,
	IN	BOOLEAN						TimerShuttingDown);

LOCAL VOID
atalkAarpEnterIntoAmt(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PATALK_NODEADDR 		pSrcNode,
	IN		PBYTE					SrcAddr,
	IN		SHORT					AddrLen,
	IN		PBYTE					RouteInfo,
	IN		SHORT					RouteInfoLen);

LOCAL BOOLEAN
atalkInitAarpForNode(
	IN	PPORT_DESCRIPTOR	        pPortDesc,
    IN  PVOID                       pRasConn,
    IN  BOOLEAN                     fThisIsPPP,
	IN	USHORT				        Network,
	IN	BYTE				        Node);

LOCAL VOID FASTCALL
atalkAarpTuneRouteInfo(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN	OUT	PBYTE					RouteInfo);


#define GET_RANDOM(min, max) (((long)AtalkRandomNumber() %              \
                              (long)(((max+1) - (min))) + (min)))

#endif	// _AARP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\arap.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arap.c

Abstract:

	This module implements routines specific to ARAP

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/


#include 	<atalk.h>
#pragma hdrstop


#define	FILENUM		ARAP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,      ArapProcessIoctl)
#pragma alloc_text(PAGE_ARAP, ArapMarkConnectionUp)
#pragma alloc_text(PAGE_ARAP, ArapIoctlRecv)
#pragma alloc_text(PAGE_ARAP, ArapExchangeParms)
#pragma alloc_text(PAGE_ARAP, ArapConnect)
#pragma alloc_text(PAGE_ARAP, ArapConnectComplete)
#pragma alloc_text(PAGE_ARAP, ArapDisconnect)
#pragma alloc_text(PAGE_ARAP, ArapGetAddr)
#pragma alloc_text(PAGE_ARAP, ArapGetStats)
#pragma alloc_text(PAGE_ARAP, ArapIoctlSend)
#pragma alloc_text(PAGE_ARAP, ArapSendPrepare)
#pragma alloc_text(PAGE_ARAP, ArapMnpSendComplete)
#pragma alloc_text(PAGE_ARAP, ArapIoctlSendComplete)
#pragma alloc_text(PAGE_ARAP, ArapDataToDll)
#pragma alloc_text(PAGE_ARAP, MnpSendAckIfReqd)
#pragma alloc_text(PAGE_ARAP, MnpSendLNAck)
#pragma alloc_text(PAGE_ARAP, ArapSendLDPacket)
#pragma alloc_text(PAGE_ARAP, ArapRetryTimer)
#endif


//***
//
// Function: ArapProcessIoctl
//              Process all ioctls coming from the Ras-ARAP module
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapProcessIoctl(
	IN PIRP 			pIrp
)
{
	NTSTATUS				status=STATUS_SUCCESS;
	PIO_STACK_LOCATION 		pIrpSp;
    ULONG                   IoControlCode;
    PARAP_SEND_RECV_INFO    pSndRcvInfo=NULL;
    PATCPCONN               pAtcpConn=NULL;
    PARAPCONN               pArapConn=NULL;
    ATALK_NODEADDR          ClientNode;
    DWORD                   dwBytesToDll;
    DWORD                   dwOrgIrql;
    DWORD                   dwFlags;
    DWORD                   dwInputBufLen;
    DWORD                   dwOutputBufLen;
    BOOLEAN                 fDerefDefPort=FALSE;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    PAGED_CODE ();

    dwOrgIrql = KeGetCurrentIrql();

    ASSERT(dwOrgIrql < DISPATCH_LEVEL);

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);

    IoControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    dwInputBufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;

    dwOutputBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    ARAPTRACE(("Entered ArapProcessIoctl (%lx %lx)\n",pIrp, IoControlCode));

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    if (!pSndRcvInfo)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: SystemBuffer is NULL!! (ioctl = %lx,pIrp = %lx)\n",
            pIrp,IoControlCode));

        ARAP_COMPLETE_IRP(pIrp, 0, STATUS_INVALID_PARAMETER, &ReturnStatus);
        return( ReturnStatus );
    }

    if (dwInputBufLen < sizeof(ARAP_SEND_RECV_INFO))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: irp %lx, too small input buffer (%d bytes)!\n",
            pIrp,dwInputBufLen));

        ARAP_COMPLETE_IRP(pIrp, 0, STATUS_INVALID_PARAMETER, &ReturnStatus);
        return( ReturnStatus );
    }

    if (dwOutputBufLen < sizeof(ARAP_SEND_RECV_INFO))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: irp %lx, too small output buffer (%d bytes)!\n",
            pIrp,dwOutputBufLen));

        ARAP_COMPLETE_IRP(pIrp, 0, STATUS_INVALID_PARAMETER, &ReturnStatus);
        return( ReturnStatus );
    }

    //
    // handle PPP (ATCP) ioctls separately
    //
    if ((IoControlCode == IOCTL_ATCP_SETUP_CONNECTION) ||
        (IoControlCode == IOCTL_ATCP_SUPPRESS_BCAST) ||
        (IoControlCode == IOCTL_ATCP_CLOSE_CONNECTION))
    {
        if (IoControlCode == IOCTL_ATCP_SETUP_CONNECTION)
        {
            AtalkLockPPPIfNecessary();
            ReturnStatus = PPPProcessIoctl(pIrp, pSndRcvInfo, IoControlCode, NULL);
			return (ReturnStatus);
        }
        else
        {
            ClientNode.atn_Network = pSndRcvInfo->ClientAddr.ata_Network;
            ClientNode.atn_Node = (BYTE)pSndRcvInfo->ClientAddr.ata_Node;

            if (ClientNode.atn_Node != 0)
            {
                // find the right connection
                pAtcpConn = FindAndRefPPPConnByAddr(ClientNode, &dwFlags);
            }
            else
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapProcessIoctl: excuse me?  Node is 0! Irp=%lx\n",pIrp));
                ASSERT(0);
            }

            if (pAtcpConn)
            {
                PPPProcessIoctl(pIrp, pSndRcvInfo, IoControlCode, pAtcpConn);

                // remove the refcount put in by FindAndRefPPPConnByAddr
                DerefPPPConn(pAtcpConn);
            }
            else
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapProcessIoctl: PPP Ioctl %lx but can't find conn %x.%x\n",
                    IoControlCode,pSndRcvInfo->ClientAddr.ata_Network,
                    pSndRcvInfo->ClientAddr.ata_Node));

                pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
                ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), 
									STATUS_SUCCESS, &ReturnStatus);
				return (ReturnStatus);
            }
        }

        return( STATUS_SUCCESS);
    }

//
// NOTE: ALL THE ARAP CODE IS NOW DEFUNCT.  To minimize code-churn, only small changes
// are done to disable ARAP.  At some point in time, all the code needs to be cleaned up
// so ARAP-specific stuff is completely removed
//
else
{
    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("ArapProcessIoctl: ARAP not supported anymore!!\n"));
    ASSERT(0);

    ARAP_COMPLETE_IRP(pIrp, 0, STATUS_INVALID_PARAMETER, &ReturnStatus);
    return( ReturnStatus );
}


    if (!ArapAcceptIrp(pIrp, IoControlCode, &fDerefDefPort))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: irp %lx not accepted (%lx)\n", pIrp,IoControlCode));

        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS, &ReturnStatus);

        // remove that IrpProcess refcount
        if (fDerefDefPort)
        {
            AtalkPortDereference(AtalkDefaultPort);
        }

        return( ReturnStatus);
    }

    if ((IoControlCode != IOCTL_ARAP_EXCHANGE_PARMS) &&
        (IoControlCode != IOCTL_ARAP_GET_ZONE_LIST))
    {
        pArapConn = pSndRcvInfo->AtalkContext;
    }

    //
    // if ths irp is for a specific connection, validate the connection first!
    //
    if ((pArapConn != NULL) && (!ArapConnIsValid(pArapConn)))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: conn %lx is gone! (ioctl = %lx)\n",
            pArapConn,IoControlCode));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;

        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS, &ReturnStatus);

        // remove that IrpProcess refcount
        if (fDerefDefPort)
        {
            AtalkPortDereference(AtalkDefaultPort);
        }

        return( ReturnStatus);
    }

    dwBytesToDll = sizeof(ARAP_SEND_RECV_INFO);

    // in most likelihood, we're going to return pending: mark it so
    IoMarkIrpPending(pIrp);

    switch (IoControlCode)
    {
        //
        // receive parameters from the user-level, and return some of our own
        //
        case IOCTL_ARAP_EXCHANGE_PARMS:

            // exchange of parms: if not already done, lock arap pages
            AtalkLockArapIfNecessary();

            status = ArapExchangeParms( pIrp );
            dwBytesToDll = sizeof(EXCHGPARMS);

            // exchange of parms done: unlock if possible
            AtalkUnlockArapIfNecessary();
            break;

        case IOCTL_ARAP_SETUP_CONNECTION:

            // new connection being established: if not already done, lock arap pages
            AtalkLockArapIfNecessary();
            pSndRcvInfo->StatusCode = ARAPERR_NO_ERROR;
            status = STATUS_SUCCESS;
            break;

        //
        // setup the low level arap connection link (aka Point-to-Point Link)
        // (first time client dials in, we respond. At callback, we initiate;
        // at callback time, we initiate the connection here)
        //
        case IOCTL_ARAP_MNP_CONN_RESPOND:
        case IOCTL_ARAP_MNP_CONN_INITIATE:

            status = ArapConnect( pIrp, IoControlCode );
            break;

        //
        // obtain (or make up) an appletalk address for the client and return it
        //
        case IOCTL_ARAP_GET_ADDR:

            status = ArapGetAddr( pIrp );
            break;

        //
        // just mark the Arap connection as being established
        //
        case IOCTL_ARAP_CONNECTION_UP:

            status = ArapMarkConnectionUp( pIrp );
            break;

        //
        // dll wants the connection blown away: disconnect it
        //
        case IOCTL_ARAP_DISCONNECT:

            status = ArapDisconnect( pIrp );
            break;

        //
        // send the buffer given by the dll
        //
        case IOCTL_ARAP_SEND:

            status = ArapIoctlSend( pIrp );
            break;

        //
        // "direct irp": get data for the connection specified
        //
        case IOCTL_ARAP_RECV:

            status = ArapIoctlRecv( pIrp );
            break;

        //
        // "select irp": get data if there is for any connection
        //
        case IOCTL_ARAP_SELECT:

            status = ArapProcessSelect( pIrp );
            break;

#if DBG
        //
        // "sniff irp": return all the sniff info
        //
        case IOCTL_ARAP_SNIFF_PKTS:

            status = ArapProcessSniff( pIrp );
            break;
#endif

        //
        // engine wants the select irp unblocked (either because it's shutting
        // down or because we want to shutdown)
        //
        case IOCTL_ARAP_CONTINUE_SHUTDOWN:

            ArapUnblockSelect();
            status = STATUS_SUCCESS;
            break;

        //
        // get names of all the zones in the entire network
        //
        case IOCTL_ARAP_GET_ZONE_LIST:

            ArapZipGetZoneStat( (PZONESTAT)pSndRcvInfo );

            // (-4 to avoid 4 bytes from ZoneNames[1] field)
            dwBytesToDll = ((PZONESTAT)pSndRcvInfo)->BufLen + sizeof(ZONESTAT) - 4;
            status = STATUS_SUCCESS;
            break;

        default:

            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapProcessIoctl: Invalid Request %lx\n", IoControlCode));

            status = STATUS_INVALID_PARAMETER;
    }


    if( status != STATUS_PENDING )
    {
        pIrpSp->Control &= ~SL_PENDING_RETURNED;

        ARAP_COMPLETE_IRP(pIrp, dwBytesToDll, STATUS_SUCCESS, &ReturnStatus);
		status = ReturnStatus;
    }

    //
    // if this irp was for a specific connection, validation refcount was put
    // on it: take that away
    //
    if (pArapConn)
    {
        DerefArapConn(pArapConn);
    }

    // remove that IrpProcess refcount
    if (fDerefDefPort)
    {
        AtalkPortDereference(AtalkDefaultPort);
    }

    ASSERT(KeGetCurrentIrql() == dwOrgIrql);

    return( status );

}




//***
//
// Function: ArapMarkConnectionUp
//              Set the flags in our connection to mark that Arap connection
//              has been established (by the dll)  (we don't route until this
//              happens)
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapMarkConnectionUp(
    IN PIRP                 pIrp
)
{

    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    KIRQL                   OldIrql;


    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapMarkConnectionUp: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("  Yippeee! %s connection is up! (%x.%x @%lx)\n",
        (pArapConn->Flags & ARAP_V20_CONNECTION)? "ARAP v2.0":"ARAP v1.0",
        pArapConn->NetAddr.atn_Network,pArapConn->NetAddr.atn_Node,pArapConn));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pArapConn->Flags |= ARAP_CONNECTION_UP;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    pSndRcvInfo->StatusCode = ARAPERR_NO_ERROR;

    return( STATUS_SUCCESS );
}


//***
//
// Function: ArapIoctlRecv
//              Try to get data for the specified connection.  If there is no
//              data available, irp is just "queued"
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapIoctlRecv(
    IN PIRP                 pIrp
)
{

    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    KIRQL                   OldIrql;



    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapIoctlRecv: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    ARAPTRACE(("Entered ArapIoctlRecv (%lx %lx)\n",pIrp,pArapConn));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    if (pArapConn->State >= MNP_LDISCONNECTING)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapIoctlRecv: rejecting recv ioctl recvd during disconnect %lx\n", pArapConn));

        pSndRcvInfo->StatusCode = ARAPERR_DISCONNECT_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return(STATUS_SUCCESS);
    }

    // we only allow one irp to be in progress at a time
    if (pArapConn->pRecvIoctlIrp != NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("ArapIoctlRecv: rejecting recv \
             (irp already in progress) %lx\n", pArapConn));

        pSndRcvInfo->StatusCode = ARAPERR_IRP_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return(STATUS_SUCCESS);
    }

    pArapConn->pRecvIoctlIrp = pIrp;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    // see if we can satisfy this request
    ArapDataToDll( pArapConn );

    return( STATUS_PENDING );
}


//***
//
// Function: ArapExchangeParms
//              Get configuration parameters from the dll, and return some info
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapExchangeParms(
    IN PIRP         pIrp
)
{
    ZONESTAT        ZoneStat;
    KIRQL           OldIrql;
    PADDRMGMT       pAddrMgmt;
    PEXCHGPARMS     pExchgParms;


    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered ArapExchangeParms (%lx)\n",pIrp));

    pExchgParms = (PEXCHGPARMS)pIrp->AssociatedIrp.SystemBuffer;

    // we enter this routine only if AtalkDefaultPort is referenced

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    ArapGlobs.LowVersion       = pExchgParms->Parms.LowVersion;
    ArapGlobs.HighVersion      = pExchgParms->Parms.HighVersion;
    ArapGlobs.MnpInactiveTime  = pExchgParms->Parms.MnpInactiveTime;
    ArapGlobs.V42bisEnabled    = pExchgParms->Parms.V42bisEnabled;
    ArapGlobs.SmartBuffEnabled = pExchgParms->Parms.SmartBuffEnabled;
    ArapGlobs.NetworkAccess    = pExchgParms->Parms.NetworkAccess;
    ArapGlobs.DynamicMode      = pExchgParms->Parms.DynamicMode;
    ArapGlobs.NetRange.LowEnd  = pExchgParms->Parms.NetRange.LowEnd;
    ArapGlobs.NetRange.HighEnd = pExchgParms->Parms.NetRange.HighEnd;
    ArapGlobs.MaxLTFrames      = (BYTE)pExchgParms->Parms.MaxLTFrames;
    ArapGlobs.SniffMode        = pExchgParms->Parms.SniffMode;

    ArapGlobs.pAddrMgmt = NULL;

    // we only support dynamic mode
    ASSERT(ArapGlobs.DynamicMode);

#if ARAP_STATIC_MODE
    //
    // allocate and initialize the bitmap for node allocation
    //
    if (!(ArapGlobs.DynamicMode))
    {
        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

        if (!ArapValidNetrange(ArapGlobs.NetRange))
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapExchangeParms: Netrange %lx - %lx is invalid\n",
                ArapGlobs.NetRange.LowEnd,ArapGlobs.NetRange.HighEnd));

            pExchgParms->StatusCode = ARAPERR_BAD_NETWORK_RANGE;

            return (STATUS_SUCCESS);
        }

        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        if ( (pAddrMgmt = AtalkAllocZeroedMemory(sizeof(ADDRMGMT))) == NULL)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapExchangeParms: alloc for pAddrMgmt failed\n"));

            RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
            pExchgParms->StatusCode = ARAPERR_OUT_OF_RESOURCES;

            return (STATUS_SUCCESS);
        }

        //
        // node numbers 0 and 255 are reserved, so mark them as occupied.
        //
        pAddrMgmt->NodeBitMap[0] |= 0x1;
        pAddrMgmt->NodeBitMap[31] |= 0x80;

        pAddrMgmt->Network = ArapGlobs.NetRange.LowEnd;

        ArapGlobs.pAddrMgmt = pAddrMgmt;
    }
#endif //ARAP_STATIC_MODE


    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    //
    // now, time to return some stack info to the dll.
    //

    // just an initial guess: dll will figure out the real number when an
    // actual connection comes in
    //
    pExchgParms->Parms.NumZones = 50;

    pExchgParms->Parms.ServerAddr.ata_Network =
                    AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Network;

    pExchgParms->Parms.ServerAddr.ata_Node =
                    AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Node;

    // copy the server zone in Pascal string format
    if (AtalkDesiredZone)
    {
        pExchgParms->Parms.ServerZone[0] = AtalkDesiredZone->zn_ZoneLen;

        RtlCopyMemory( &pExchgParms->Parms.ServerZone[1],
                       &AtalkDesiredZone->zn_Zone[0],
                       AtalkDesiredZone->zn_ZoneLen );
    }
    else if (AtalkDefaultPort->pd_DefaultZone)
    {
        pExchgParms->Parms.ServerZone[0] = AtalkDefaultPort->pd_DefaultZone->zn_ZoneLen;

        RtlCopyMemory( &pExchgParms->Parms.ServerZone[1],
                       &AtalkDefaultPort->pd_DefaultZone->zn_Zone[0],
                       AtalkDefaultPort->pd_DefaultZone->zn_ZoneLen );
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("Arap: Server not in any zone?? Client won't see any zones!!\n"));

        pExchgParms->Parms.ServerZone[0] = 0;
    }

    ArapGlobs.OurNetwkNum =
            AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Network;

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("Arap: ready to accept connections (Router net=%x node=%x)\n",
            AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Network,
            AtalkDefaultPort->pd_Nodes->an_NodeAddr.atn_Node));

    pExchgParms->StatusCode = ARAPERR_NO_ERROR;

    // complete the irp successfully
    return (STATUS_SUCCESS);

}


//***
//
// Function: ArapConnect
//              Setup the MNP level connection with the client
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapConnect(
    IN PIRP                 pIrp,
    IN ULONG                IoControlCode
)
{
    KIRQL                   OldIrql;
    PBYTE                   pFrame;
    SHORT                   MnpLen;
    SHORT                   FrameLen;
    DWORD                   StatusCode=ARAPERR_NO_ERROR;
    PMNPSENDBUF             pMnpSendBuf=NULL;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    PARAPCONN               pArapConn;
    PNDIS_PACKET            ndisPacket;
    NDIS_STATUS             ndisStatus;


    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered ArapConnect (%lx)\n",pIrp));

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = FindArapConnByContx(pSndRcvInfo->pDllContext);

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapConnect: couldn't find pArapConn!\n"));
        ASSERT(0);
        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);
    ArapConnections++;
    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

#if ARAP_STATIC_MODE
    // This will add a route (one-time only) for the ARAP network range
    ArapAddArapRoute();
#endif //ARAP_STATIC_MODE


    // first, write stack's context for dll's future use
    pSndRcvInfo->AtalkContext = (PVOID)pArapConn;

    //
    // put a refcount for the connection (deref only when the connection gets
    // disconnected *and* the dll is told about it).
    // Also, initialize the v42bis stuff for this connection
    //
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    if (pArapConn->pIoctlIrp != NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("ArapConnect: rejecting connect \
             (irp already in progress) %lx\n", pArapConn));

        pSndRcvInfo->StatusCode = ARAPERR_IRP_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return(STATUS_SUCCESS);
    }

    ASSERT(pArapConn->State == MNP_IDLE);

    if (IoControlCode == IOCTL_ARAP_MNP_CONN_RESPOND)
    {
        pArapConn->State = MNP_RESPONSE;
    }

    //
    // we're doing callback: do some fixing up
    //
    else
    {
        pArapConn->State = MNP_REQUEST;
        pArapConn->Flags |= ARAP_CALLBACK_MODE;
        pArapConn->MnpState.SendCredit = 8;
    }


    // Connect refcount: remove only after we tell dll that connection died
    pArapConn->RefCount++;

    // put MNPSend refcount
    pArapConn->RefCount++;

    pArapConn->pIoctlIrp = pIrp;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    KeInitializeEvent(&pArapConn->NodeAcquireEvent, NotificationEvent, FALSE);


    StatusCode = ARAPERR_NO_ERROR;

    //
    // allocate buf to send out the connection response/request
    //
	if ((pMnpSendBuf = AtalkBPAllocBlock(BLKID_MNP_SMSENDBUF)) != NULL)
    {
        // get an ndis packet for this puppy
        StatusCode = ArapGetNdisPacket(pMnpSendBuf);
    }

	if ((pMnpSendBuf == NULL) || (StatusCode != ARAPERR_NO_ERROR))
	{
        if (pMnpSendBuf)
        {
            ArapNdisFreeBuf(pMnpSendBuf);
        }
        else
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("ArapConnect: AtalkBPAllocBlock failed on %lx\n", pArapConn));
        }

        ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);
        pArapConn->State = MNP_IDLE;
        pSndRcvInfo->StatusCode = ARAPERR_OUT_OF_RESOURCES;
        pSndRcvInfo->AtalkContext = ARAP_INVALID_CONTEXT;
        pArapConn->pIoctlIrp = NULL;

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

        // didn't succeed: remove that connection refcount
        DerefArapConn(pArapConn);

        // and the MNPSend refcount
        DerefArapConn(pArapConn);

        // return success: we have already set our StatusCode to the right thing
        return( STATUS_SUCCESS );
	}

#if DBG
    pMnpSendBuf->Signature = MNPSMSENDBUF_SIGNATURE;
#endif

    // yes, we need this, in case we bail out
    InitializeListHead(&pMnpSendBuf->Linkage);

    pMnpSendBuf->SeqNum = 0;               // Indication code expects this to be 0
    pMnpSendBuf->RetryCount = 1;
    pMnpSendBuf->RefCount = 1;             // 1 MNP refcount
    pMnpSendBuf->pArapConn = pArapConn;
    pMnpSendBuf->ComplRoutine = ArapConnectComplete;
    pMnpSendBuf->Flags = 1;

    // when should we retransmit this pkt?
    pMnpSendBuf->RetryTime = pArapConn->SendRetryTime + AtalkGetCurrentTick();

	pFrame = &pMnpSendBuf->Buffer[0];

	AtalkNdisBuildARAPHdr(pFrame, pArapConn);

    pFrame += WAN_LINKHDR_LEN;

    FrameLen = WAN_LINKHDR_LEN;

    //
    // are we just responding to a connection request?
    //
    if (IoControlCode == IOCTL_ARAP_MNP_CONN_RESPOND)
    {
        //
        // pSndRcvInfo contains the client's connect request.  Parse it and
        // prepare a response as appropriate
        //

        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        StatusCode = PrepareConnectionResponse( pArapConn,
                                                &pSndRcvInfo->Data[0],
                                                pSndRcvInfo->DataLen,
                                                pFrame,
                                                &MnpLen);

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

        if (StatusCode != ARAPERR_NO_ERROR)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("ArapConnect: (%lx) response prep failed %ld\n", pArapConn,StatusCode));

            ArapConnectComplete(pMnpSendBuf, StatusCode);

            return( STATUS_PENDING );
        }

        FrameLen += MnpLen;
    }

    //
    // no, actually we are initiating a connection (callback time)
    // copy the frame we used in earlier setup (that dll kindly saved for us)
    //
    else
    {
        RtlCopyMemory(pFrame, (PBYTE)&pSndRcvInfo->Data[0], pSndRcvInfo->DataLen);

        FrameLen += (USHORT)pSndRcvInfo->DataLen;

#if DBG
        pArapConn->MnpState.SynByte = pSndRcvInfo->Data[0];
        pArapConn->MnpState.DleByte = pSndRcvInfo->Data[1];
        pArapConn->MnpState.StxByte = pSndRcvInfo->Data[2];
        pArapConn->MnpState.EtxByte = MNP_ETX;
#endif

    }

	AtalkSetSizeOfBuffDescData(&pMnpSendBuf->sb_BuffDesc, FrameLen);

    pMnpSendBuf->RefCount++;             // 1 ndis count, since we'll send now
    pMnpSendBuf->DataSize = FrameLen;

	NdisAdjustBufferLength(pMnpSendBuf->sb_BuffHdr.bh_NdisBuffer,
                           pMnpSendBuf->DataSize);

    // put this connection response on the retransmission queue
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    InsertTailList(&pArapConn->RetransmitQ, &pMnpSendBuf->Linkage);

    pArapConn->SendsPending += pMnpSendBuf->DataSize;

    pArapConn->MnpState.UnAckedSends++;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    ndisPacket = pMnpSendBuf->sb_BuffHdr.bh_NdisPkt;

    NdisSend(&ndisStatus, RasPortDesc->pd_NdisBindingHandle, ndisPacket);

    // if there was a problem sending, call the completion routine here
    // retransmit logic will send it again
    //
    if (ndisStatus != NDIS_STATUS_PENDING)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("MnpSendAck: NdisSend failed %lx\n",ndisStatus));

        ArapNdisSendComplete(ARAPERR_SEND_FAILED, (PBUFFER_DESC)pMnpSendBuf, NULL);
    }

    //
    // done.  we'll complete the irp when the client responds (acks or response)
    //
    return( STATUS_PENDING );
}


//***
//
// Function: ArapConnectComplete
//              Completion routine for the ArapConnect routine.  This routine
//              is called by the ArapRcvComplete routine when we get an ack
//              for our Connection response (LR) frame
//
// Parameters:  pMnpSendBuf - the send buff that contained the LR response
//              StatusCode - how did it go?
//
// Return:      none
//
//***$

VOID
ArapConnectComplete(
    IN PMNPSENDBUF  pMnpSendBuf,
    IN DWORD        StatusCode
)
{
    KIRQL                   OldIrql;
    PIRP                    pIrp;
    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;



    DBG_ARAP_CHECK_PAGED_CODE();

    pArapConn = pMnpSendBuf->pArapConn;

    if (StatusCode != ARAPERR_NO_ERROR)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapConnectComplete: (%x): conn setup failed (%d)!\n",
                pArapConn,StatusCode));
        //
        // BUGBUG: change ArapCleanup to accept StatusCode as a parm (currently,
        // the real reason behind disconnect is lost, so dll doesn't get it)
        //
        ArapCleanup(pArapConn);

        DerefMnpSendBuf(pMnpSendBuf, FALSE);

        return;
    }

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pIrp = pArapConn->pIoctlIrp;

    pArapConn->pIoctlIrp = NULL;

    pArapConn->SendsPending -= pMnpSendBuf->DataSize;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    ARAPTRACE(("Entered ArapConnectComplete (%lx %lx)\n",pIrp,pArapConn));

    // if there is an irp (under normal conditions, should be), complete it
    if (pIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

        pSndRcvInfo->StatusCode = StatusCode;

        if (StatusCode != ARAPERR_NO_ERROR)
        {
            pSndRcvInfo->StatusCode = ARAPERR_DISCONNECT_IN_PROGRESS;
        }

        //
        // copy the frame we used to establish the connection.  In case of
        // callback, dll will pass this back to initiate the connection
        //
        if (pSndRcvInfo->IoctlCode == IOCTL_ARAP_MNP_CONN_RESPOND)
        {
            pSndRcvInfo->DataLen = (DWORD)pMnpSendBuf->DataSize;

            RtlCopyMemory((PBYTE)&pSndRcvInfo->Data[0],
                          (PBYTE)&pMnpSendBuf->Buffer[0],
                          (DWORD)pMnpSendBuf->DataSize);
        }

        ARAP_COMPLETE_IRP(pIrp,
                          pSndRcvInfo->DataLen + sizeof(ARAP_SEND_RECV_INFO),
                          STATUS_SUCCESS, &ReturnStatus);
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapConnectComplete: (%x): no irp available!\n",pArapConn));
    }

    DerefMnpSendBuf(pMnpSendBuf, FALSE);

}



//***
//
// Function: ArapDisconnect
//              Disconnect the connection
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapDisconnect(
    IN PIRP                 pIrp
)
{
    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;


    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    if ((pArapConn == NULL) || (pArapConn == ARAP_INVALID_CONTEXT))
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapDisconnect: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("ArapDisconnect: rcvd DISCONNECT on %lx (irp=%lx)\n",pArapConn,pIrp));

    // UserCode = 0xFF
    pSndRcvInfo->StatusCode = ArapSendLDPacket(pArapConn, 0xFF);

    ArapCleanup(pArapConn);

    //
    // done.  let this irp complete: we'll notify the dll of
    // 'disconnect-complete' (via select irp) when our cleanup completes
    //
    return(STATUS_SUCCESS);
}


//***
//
// Function: ArapGetAddr
//              Get a network address for the remote client
//              (if doing dynamic addressing, go to the net; otherwise, get one
//              from the table we maintain)
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapGetAddr(
    IN PIRP                 pIrp
)
{
    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    DWORD                   StatusCode = ARAPERR_NO_NETWORK_ADDR;


    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    ARAPTRACE(("Entered ArapGetAddr (%lx %lx)\n",pIrp,pArapConn));

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapGetAddr: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    if (ArapGlobs.DynamicMode)
    {
        StatusCode = ArapGetDynamicAddr(pArapConn);
    }

#if ARAP_STATIC_MODE
    else
    {
        StatusCode = ArapGetStaticAddr(pArapConn);
    }
#endif //ARAP_STATIC_MODE

    pSndRcvInfo->StatusCode = StatusCode;

    if (StatusCode == ARAPERR_NO_ERROR)
    {
        pSndRcvInfo->ClientAddr.ata_Network = pArapConn->NetAddr.atn_Network;
        pSndRcvInfo->ClientAddr.ata_Node = pArapConn->NetAddr.atn_Node;
    }
    else
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapGetAddr: returning %d\n", StatusCode));
    }

    return( STATUS_SUCCESS );

}


// we don't really support this: why have the code!
#if 0

//***
//
// Function: ArapGetStats
//              Return statistics (bytes in, bytes out, compressed etc.) about
//              the specified connection
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapGetStats(
    IN PIRP                 pIrp
)
{

    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    KIRQL                   OldIrql;
    PSTAT_INFO              pStatInfo;


    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapGetStats: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("ArapGetStats: returning stats for (%lx)\n",pArapConn));

    pStatInfo = (PSTAT_INFO)&pSndRcvInfo->Data[0];

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    *pStatInfo = pArapConn->StatInfo;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    pSndRcvInfo->StatusCode = ARAPERR_NO_ERROR;

    return( STATUS_SUCCESS );
}

#endif  // #if 0 around ArapGetStats


//***
//
// Function: ArapIoctlSend
//              Send the buffer given by the dll to the remote client.
//              This routine calls the routine to prepare the send (v42bis
//              compression and MNP bookkeeping) and then sends it out
//
// Parameters:  pIrp - the irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapIoctlSend(
    IN PIRP                    pIrp
)
{
    KIRQL                   OldIrql;
    BUFFER_DESC             OrgBuffDesc;
    PARAPCONN               pArapConn;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    DWORD                   StatusCode=ARAPERR_NO_ERROR;


    DBG_ARAP_CHECK_PAGED_CODE();

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = (PARAPCONN)pSndRcvInfo->AtalkContext;

    if (pArapConn == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapIoctlSend: null conn\n"));

        pSndRcvInfo->StatusCode = ARAPERR_NO_SUCH_CONNECTION;
        return(STATUS_SUCCESS);
    }

    ARAPTRACE(("Entered ArapIoctlSend (%lx %lx)\n",pIrp,pArapConn));

    // save the irp so we can complete it in the completion routine
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    // we only allow one irp to be in progress at a time
    if (pArapConn->pIoctlIrp != NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("ArapIoctlSend: rejecting send \
             (irp already in progress) %lx\n", pArapConn));

        pSndRcvInfo->StatusCode = ARAPERR_IRP_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return(STATUS_SUCCESS);
    }

    pArapConn->pIoctlIrp = pIrp;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    ASSERT(pSndRcvInfo->DataLen <= 618);

    DBGDUMPBYTES("Dll send:", &pSndRcvInfo->Data[0],pSndRcvInfo->DataLen,1);

    //
    // get the send ready (compression, MNP bookkeeping etc.)
    //
	OrgBuffDesc.bd_Next = NULL;
	OrgBuffDesc.bd_Length = (SHORT)pSndRcvInfo->DataLen;
	OrgBuffDesc.bd_CharBuffer = &pSndRcvInfo->Data[0];
	OrgBuffDesc.bd_Flags = BD_CHAR_BUFFER;

    StatusCode = ArapSendPrepare( pArapConn,
                                  &OrgBuffDesc,
                                  ARAP_SEND_PRIORITY_HIGH );

    if (StatusCode == ARAPERR_NO_ERROR)
    {
        //
        // now, send that send over.  Note that we don't care about the return
        // code here: if this particular send fails, we still tell the dll that
        // the send succeeded because our retransmission logic will take care
        // of ensuring that the send gets there.
        //
        ArapNdisSend( pArapConn, &pArapConn->HighPriSendQ );
    }
    else
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapIoctlSend (%lx): ArapSendPrepare failed (%ld)\n",
                pArapConn,StatusCode));
    }

    ArapIoctlSendComplete(StatusCode, pArapConn);

    return( STATUS_PENDING );
}


//***
//
// Function: ArapProcessSelect
//              Process the select irp issued by the dll
//              This routine saves the select irp so that any connection that
//              needs it can take it.  Also, it sees if any of the connections
//              is waiting for an irp to indicate a disconnect-complete or
//              data to the dll.  If so, that is completed here.
//
// Parameters:  pIrp - the select irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapProcessSelect(
    IN  PIRP  pIrp
)
{
    KIRQL                   OldIrql;
    KIRQL                   OldIrql2;
    PARAPCONN               pDiscArapConn=NULL;
    PARAPCONN               pRcvArapConn=NULL;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    PLIST_ENTRY             pList;
    DWORD                   dwBytesToDll;
    DWORD                   StatusCode;
	NTSTATUS				ReturnStatus;



    ARAPTRACE(("Entered ArapProcessSelect (%lx)\n",pIrp));

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;


    pDiscArapConn = NULL;
    pRcvArapConn = NULL;

    //
    // it's possible that between the time the last select irp completed and
    // this select came down, some activity that needs a select irp occured
    // (e.g. a disconnect).  See if we have hit such a condition
    //

    ArapDelayedNotify(&pDiscArapConn, &pRcvArapConn);

    //
    // if we found an arapconn that was waiting for a select irp to notify the
    // dll of disconnect, do the good deed!
    //
    if (pDiscArapConn)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapProcessSelect: completing delayed disconnect on %lx!\n", pDiscArapConn));

        dwBytesToDll = 0;
#if DBG
        //
        // if we have some sniff info that we couldn't deliver earlier through
        // the sniff irp, then give them through this irp: it's going back
        // "empty" anyway!
        //
        if (pDiscArapConn->pDbgTraceBuffer && pDiscArapConn->SniffedBytes > 0)
        {
            dwBytesToDll = ArapFillIrpWithSniffInfo(pDiscArapConn,pIrp);
        }
#endif

        dwBytesToDll += sizeof(ARAP_SEND_RECV_INFO);

        //
        // no need for spinlock here
        //
        if (pDiscArapConn->Flags & ARAP_REMOTE_DISCONN)
        {
            StatusCode = ARAPERR_RDISCONNECT_COMPLETE;
        }
        else
        {
            StatusCode = ARAPERR_LDISCONNECT_COMPLETE;
        }

        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;
        pSndRcvInfo->pDllContext = pDiscArapConn->pDllContext;

        pSndRcvInfo->StatusCode = StatusCode;

        pSndRcvInfo->DataLen = dwBytesToDll;

        // we told (rather, will very shortly tell) dll: remove this link
        pDiscArapConn->pDllContext = NULL;

        // now that we told dll, remove 1 refcount
        DerefArapConn( pDiscArapConn );

        return(STATUS_SUCCESS);
    }



	IoAcquireCancelSpinLock(&OldIrql);

    if (pIrp->Cancel)
	{
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapProcessSelect: select irp %lx already cancelled!\n", pIrp));

	    IoReleaseCancelSpinLock(OldIrql);
        ARAP_COMPLETE_IRP(pIrp, 0, STATUS_CANCELLED, &ReturnStatus);
        return(ReturnStatus);
    }

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql2);

    if (ArapSelectIrp != NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapProcessSelect: select irp %lx already in progress!\n", ArapSelectIrp));
        ASSERT(0);

        pSndRcvInfo->StatusCode = ARAPERR_IRP_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql2);
        IoReleaseCancelSpinLock(OldIrql);
        return( STATUS_SUCCESS );
    }

    //
    // does arap engine need to be told about some change?
    //
    if ( (ArapStackState == ARAP_STATE_ACTIVE_WAITING) ||
         (ArapStackState == ARAP_STATE_INACTIVE_WAITING) )
    {
        if (ArapStackState == ARAP_STATE_ACTIVE_WAITING)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapProcessSelect: delayed notify: stack is now active!\n"));

            ArapStackState = ARAP_STATE_ACTIVE;
            pSndRcvInfo->StatusCode = ARAPERR_STACK_IS_ACTIVE;
        }
        else if (ArapStackState == ARAP_STATE_INACTIVE_WAITING)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapProcessSelect: delayed notify: stack is now inactive!\n"));

            ArapStackState = ARAP_STATE_INACTIVE;
            pSndRcvInfo->StatusCode = ARAPERR_STACK_IS_NOT_ACTIVE;
        }

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql2);
	    IoReleaseCancelSpinLock(OldIrql);
        return( STATUS_SUCCESS );
    }

    //
    // ok, most common case: we just need to stash this select irp!
    //
    ArapSelectIrp = pIrp;

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql2);

	IoSetCancelRoutine(pIrp, (PDRIVER_CANCEL)AtalkTdiCancel);

	IoReleaseCancelSpinLock(OldIrql);


    //
    // if there was an arapconn waiting for a select irp, pass on the data!
    //
    if (pRcvArapConn)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
		    ("ArapProcessSelect: getting delayed data on %lx at %ld\n",
            pRcvArapConn,AtalkGetCurrentTick()));

        ARAP_DBG_TRACE(pRcvArapConn,11105,0,0,0,0);

        ArapDataToDll( pRcvArapConn );
    }

    return(STATUS_PENDING);
}



//***
//
// Function: ArapDelayedNotify
//              This routine checks to see if any of the arap connections was
//              waiting for a select irp to come down to notify the dll that
//              either the connection went away, or if there was any data waiting on a
//              connection.
//
// Parameters:  ppDiscArapConn - if a "disconnected" connection exists, it's returned
//                               in this pointer.  If many exist, the first one lucks out.
//                               If none exists, null is returned here
//              ppRecvArapConn - same as above except that the connection returned is
//                               the one where some data is waiting
//
// Return:      none
//
//***$
VOID
ArapDelayedNotify(
    OUT PARAPCONN   *ppDiscArapConn,
    OUT PARAPCONN   *ppRecvArapConn
)
{

    KIRQL                   OldIrql;
    PARAPCONN               pArapConn=NULL;
    PLIST_ENTRY             pList;
    PARAPCONN               pDiscArapConn=NULL;
    PARAPCONN               pRecvArapConn=NULL;


    *ppDiscArapConn = NULL;
    *ppRecvArapConn = NULL;

    if (!RasPortDesc)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapDelayedNotify: RasPortDesc is NULL!\n"));
        ASSERT(0);

        return;
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pArapConn = CONTAINING_RECORD(pList, ARAPCONN, Linkage);
        pList = pArapConn->Linkage.Flink;

        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

        //
        // if a connection has been disconnected and is waiting for a select
        // irp to show up, find out who that is and let the caller know
        //
        if ((pArapConn->State == MNP_DISCONNECTED) &&
            (pArapConn->Flags & DISCONNECT_NO_IRP))
        {
            pArapConn->Flags &= ~DISCONNECT_NO_IRP;
            pDiscArapConn = pArapConn;

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
            break;
        }

        //
        // if a connection has some data come in on it while select irp wasn't
        // down yet, note down this connection
        //
        if ((pArapConn->State == MNP_UP) &&
            (pArapConn->Flags & ARAP_CONNECTION_UP) &&
            (!IsListEmpty(&pArapConn->ArapDataQ)))
        {
            pRecvArapConn = pArapConn;
        }

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock,OldIrql);

    if (pDiscArapConn)
    {
        *ppDiscArapConn = pDiscArapConn;
    }
    else if (pRecvArapConn)
    {
        *ppRecvArapConn = pRecvArapConn;
    }

}


//***
//
// Function: ArapSendPrepare
//              This routine takes an incoming buffer descriptor, compresses
//              each of the buffers in it and passes the compressed data on to
//              another routine which splits (or stuffs) the compressed bytes
//              into MNP-level packets.
//
// Parameters:  pArapConn    - the connection in question
//              pOrgBuffDesc - the buffer descriptor containing data buffer(s)
//              Priority     - how important is the data (highest priority = 1)
//                               1 - directed DDP dgrams (all except NBP)
//                               2 - directed DDP dgrams (NBP)
//                               3 - all DDP-level broadcast (NBP only)
//
// Return:      ARAPERR_NO_ERROR if things go well, otherwise errorcode
//
//***$

DWORD
ArapSendPrepare(
    IN  PARAPCONN       pArapConn,
    IN  PBUFFER_DESC    pOrgBuffDesc,
    IN  DWORD           Priority
)
{

    KIRQL                   OldIrql;
    DWORD                   StatusCode=ARAPERR_NO_ERROR;
    SHORT                   EthLen, MnpLen;
    PBYTE                   pCurrBuff;
    DWORD                   CurrBuffLen;
    DWORD                   UncompressedDataLen;
    PBYTE                   pCompressedData;
    PBYTE                   pCompressedDataBuffer;
    DWORD                   CompressedDataLen;
    DWORD                   CDataLen;
    PBUFFER_DESC            pBuffDesc;
    DWORD                   CompBufDataSize;



    DBG_ARAP_CHECK_PAGED_CODE();

// BUGBUG: this line put in for now: remove it and make sure priority queue stuff works
Priority = ARAP_SEND_PRIORITY_HIGH;


    ARAPTRACE(("Entered ArapSendPrepare (%lx %lx)\n",pArapConn,pOrgBuffDesc));

    //
    // it's essential to hold this lock until the entire send is compressed and
    // put on the queue (Otherwise, we risk mixing up different sends!)
    //
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    // are we disconnecting (or not up yet)?  if so, don't accept this send
    if (pArapConn->State != MNP_UP)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapSendPrepare: (%lx) state=%d, rejecting send\n",
                pArapConn,pArapConn->State));

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return( ARAPERR_DISCONNECT_IN_PROGRESS );
    }

    // do we have too many sends queued up? if so, just drop this send
    if (pArapConn->SendsPending > ARAP_SENDQ_UPPER_LIMIT)
    {
        // make sure it's not gone negative..
        ASSERT(pArapConn->SendsPending < 0x100000);

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return( ARAPERR_OUT_OF_RESOURCES );
    }

    //
    // allocate memory to store the compressed data
    //

    pCompressedDataBuffer = AtalkBPAllocBlock(BLKID_ARAP_SNDPKT);

    if (pCompressedDataBuffer == NULL)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapSendPrepare: alloc for compressing data failed (%lx)\n", pArapConn));

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return( ARAPERR_OUT_OF_RESOURCES );
    }


    pBuffDesc = pOrgBuffDesc;                  // first buffer
    CompressedDataLen = 0;                     // length of compressed data
    CompBufDataSize = ARAP_SENDBUF_SIZE;       // size of buffer in which to compress
    pCompressedData = pCompressedDataBuffer;   // ptr to buffer in which to compress
    UncompressedDataLen = 0;                   // size of uncompressed data

#if DBG
    //
    // put in a guard signature to catch buffer overrun
    //
    *((DWORD *)&(pCompressedDataBuffer[ARAP_SENDBUF_SIZE-4])) = 0xdeadbeef;
#endif


    //
    // first, walk through the buffer descriptor chain and compress all the
    // buffers.
    //
    while (pBuffDesc)
    {
        //
        // is this a buffer?
        //
        if (pBuffDesc->bd_Flags & BD_CHAR_BUFFER)
        {
            pCurrBuff = pBuffDesc->bd_CharBuffer;
            CurrBuffLen = pBuffDesc->bd_Length;
        }

        //
        // nope, it's an mdl!
        //
        else
        {
            pCurrBuff = MmGetSystemAddressForMdlSafe(
                            pBuffDesc->bd_OpaqueBuffer,
                            NormalPagePriority);

            if (pCurrBuff == NULL)
            {
                ASSERT(0);
                RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
                AtalkBPFreeBlock(pCompressedDataBuffer);
                return( ARAPERR_OUT_OF_RESOURCES );
            }

            CurrBuffLen = MmGetMdlByteCount(pBuffDesc->bd_OpaqueBuffer);
        }

        DBGDUMPBYTES("ArapSendPrepare (current buffer): ",pCurrBuff,CurrBuffLen,2);

        UncompressedDataLen += CurrBuffLen;

        ASSERT(UncompressedDataLen <= ARAP_LGPKT_SIZE);

        // exclude the 2 srp length bytes
        if (UncompressedDataLen > ARAP_MAXPKT_SIZE_OUTGOING+2)
        {
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapSendPrepare (%lx): send pkt exceeds limit\n",pArapConn));

            ASSERT(0);
        }

        //
        // compress the packet (if v42bis is on, that is)
        //
        if (pArapConn->Flags & MNP_V42BIS_NEGOTIATED)
        {
            StatusCode = v42bisCompress(pArapConn,
                                        pCurrBuff,
                                        CurrBuffLen,
                                        pCompressedData,
                                        CompBufDataSize,
                                        &CDataLen);

        }

        //
        // hmmm, no v42bis!  just copy it as is and skip compression!
        //
        else
        {
            ASSERT(CompBufDataSize >= CurrBuffLen);

            RtlCopyMemory(pCompressedData,
                          pCurrBuff,
                          CurrBuffLen);

            CDataLen = CurrBuffLen;

            StatusCode = ARAPERR_NO_ERROR;
        }


#if DBG
    // ... and, check our guard signature
    ASSERT (*((DWORD *)&(pCompressedDataBuffer[ARAP_SENDBUF_SIZE-4])) == 0xdeadbeef);
#endif

        if (StatusCode != ARAPERR_NO_ERROR)
        {
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("ArapSendPrepare (%lx):\
                 v42bisCompress returned %ld\n", pArapConn,StatusCode));

            ASSERT(0);

            RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

            AtalkBPFreeBlock(pCompressedDataBuffer);
            return(StatusCode);
        }

        pCompressedData += CDataLen;
        CompressedDataLen += CDataLen;
        CompBufDataSize -= CDataLen;

        pBuffDesc = pBuffDesc->bd_Next;
    }


    // we are about to send so many uncompressed bytes: update stats
    pArapConn->StatInfo.BytesTransmittedUncompressed += UncompressedDataLen;

    // this is how many bytes will go out on the wire: update stats
    pArapConn->StatInfo.BytesTransmittedCompressed += CompressedDataLen;

    //
    // this is how many bytes will go out on the wire: update stats
    // Note that we will be adding the start/stop etc. bytes to this count somewhere else
    //
    pArapConn->StatInfo.BytesSent += CompressedDataLen;

#if DBG
    ArapStatistics.SendPreCompMax =
            (UncompressedDataLen > ArapStatistics.SendPreCompMax)?
            UncompressedDataLen : ArapStatistics.SendPreCompMax;

    ArapStatistics.SendPostCompMax =
            (CompressedDataLen > ArapStatistics.SendPostCompMax)?
            CompressedDataLen : ArapStatistics.SendPostCompMax;

    ArapStatistics.SendPreCompMin =
            (UncompressedDataLen < ArapStatistics.SendPreCompMin)?
            UncompressedDataLen : ArapStatistics.SendPreCompMin;

    ArapStatistics.SendPostCompMin =
            (CompressedDataLen < ArapStatistics.SendPostCompMin)?
            CompressedDataLen : ArapStatistics.SendPostCompMin;
#endif


    ARAP_DBG_TRACE(pArapConn,11205,pOrgBuffDesc,Priority,0,0);

    // now go put the send on the queue (And yes: hold that lock)
    StatusCode = ArapQueueSendBytes(pArapConn,
                                    pCompressedDataBuffer,
                                    CompressedDataLen,
                                    Priority);

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    AtalkBPFreeBlock(pCompressedDataBuffer);

    return(StatusCode);
}



//***
//
// Function: ArapMnpSendComplete
//              Free up the buffer used for the MNP send.  If the send failed
//              then kill the connection (remember, it's not just one send
//              failing but a failure after all the retransmission jing-bang)
//
// Parameters:  pMnpSendBuf - the send buff that contained the LR response
//              StatusCode  - how did it go?
//
// Return:      none
//
//***$

VOID ArapMnpSendComplete(
    IN PMNPSENDBUF   pMnpSendBuf,
    IN DWORD         StatusCode
)
{
    PARAPCONN           pArapConn;
    DWORD               State;
    KIRQL               OldIrql;


    DBG_ARAP_CHECK_PAGED_CODE();

    pArapConn = pMnpSendBuf->pArapConn;

    ARAPTRACE(("Entered ArapMnpSendComplete (%lx %lx %lx)\n",
        pMnpSendBuf,StatusCode,pArapConn));

    // the send buffer is getting freed up: update the counter
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    State = pArapConn->State;

    pArapConn->SendsPending -= pMnpSendBuf->DataSize;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    if ((StatusCode != ARAPERR_NO_ERROR) && (State < MNP_LDISCONNECTING))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapMnpSendComplete (%lx %lx): bad link? Tearing down connection\n",
                StatusCode,pArapConn));

        // link must have gone down: kill the connection!
        ArapCleanup(pArapConn);
    }

    // mark that compl. routine has run
#if DBG
    pMnpSendBuf->Signature -= 0x100;
#endif

    // the send has been acked: take away the MNP refcount on the send
    DerefMnpSendBuf(pMnpSendBuf, FALSE);
}



//***
//
// Function: ArapIoctlSendComplete
//              This routine is called right after the send is done in
//              ArapIoctlSend, to let the dll know what happened to the send.
//
// Parameters:  Status    - did the send actually succeed
//              pArapConn - the connection in quesion
//
// Return:      none
//
//***$

VOID
ArapIoctlSendComplete(
	DWORD                   StatusCode,
    PARAPCONN               pArapConn
)
{

    PIRP                    pIrp;
    KIRQL                   OldIrql;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    DBG_ARAP_CHECK_PAGED_CODE();

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pIrp = pArapConn->pIoctlIrp;
    pArapConn->pIoctlIrp = NULL;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    ARAPTRACE(("Entered ArapIoctlSendComplete (%lx %lx)\n",pArapConn,pIrp));

    //
    // if there is a user-level irp pending, complete it here
    //
    if (pIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

        pSndRcvInfo->StatusCode = StatusCode;

        // complete the irp (irp always completes successfully!)
        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS, &ReturnStatus);
    }

}


//***
//
// Function: ArapDataToDll
//              This routine tries to complete a receive posted on a connection.
//              When data arrives, if the Arap connection is established then
//              this routine tries to complete a receive via the "select" irp.
//              If the Arap connection is not yet established, then a receive
//              is completed via a "direct" irp.
//
// Parameters:  pArapConn - connection element in question
//
// Return:      Number of bytes transferred to the dll
//
//***$

DWORD
ArapDataToDll(
	IN	PARAPCONN    pArapConn
)
{

    KIRQL                   OldIrql;
    PLIST_ENTRY             pRcvList;
    PARAPBUF                pArapBuf;
    PARAP_SEND_RECV_INFO    pSndRcvInfo=NULL;
    PIRP                    pIrp;
    USHORT                  SrpModLen;
    DWORD                   dwBytesToDll;
    DWORD                   StatusCode;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered ArapDataToDll (%lx)\n",pArapConn));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    if (IsListEmpty(&pArapConn->ArapDataQ))
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return( 0 );
    }

    pRcvList = pArapConn->ArapDataQ.Flink;

    pArapBuf = CONTAINING_RECORD(pRcvList, ARAPBUF, Linkage);

    //
    // if the ARAP connection is established, we can hand the data only
    // to a select irp (dll won't post direct rcv's anymore)
    //
    if ( pArapConn->Flags & ARAP_CONNECTION_UP )
    {
        ArapGetSelectIrp(&pIrp);
        StatusCode = ARAPERR_DATA;
    }

    //
    // if the ARAP connection is not established yet, we must guarantee that
    // we hand the data only to a direct rcv irp for this connection
    //
    else
    {
        pIrp = pArapConn->pRecvIoctlIrp;
        pArapConn->pRecvIoctlIrp = NULL;
        StatusCode = ARAPERR_NO_ERROR;
    }

    // no irp?  just have to wait then
    if (!pIrp)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
		    ("ArapDataToDll: no select irp, data waiting %lx at %ld\n", pArapConn,AtalkGetCurrentTick()));

        ARAP_DBG_TRACE(pArapConn,11505,0,0,0,0);

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return( 0 );
    }

    //
    // now that we have irp, fill in the info, after unlinking the recv buf
    //
    RemoveEntryList(&pArapBuf->Linkage);

    ASSERT(pArapConn->RecvsPending >= pArapBuf->DataSize);
    pArapConn->RecvsPending -= pArapBuf->DataSize;

    ARAP_ADJUST_RECVCREDIT(pArapConn);

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    ASSERT(pSndRcvInfo->DataLen >= pArapBuf->DataSize);

    SrpModLen = pArapBuf->DataSize;

    // ok, copy the data in
    RtlCopyMemory( &pSndRcvInfo->Data[0],
                   pArapBuf->CurrentBuffer,
                   pArapBuf->DataSize );


    // set the info (contexts need to be set each time in case of select)
    pSndRcvInfo->AtalkContext = pArapConn;
    pSndRcvInfo->pDllContext =  pArapConn->pDllContext;
    pSndRcvInfo->DataLen = SrpModLen;
    pSndRcvInfo->StatusCode = StatusCode;

    dwBytesToDll = SrpModLen + sizeof(ARAP_SEND_RECV_INFO);

    DBGDUMPBYTES("Dll recv:", &pSndRcvInfo->Data[0],pSndRcvInfo->DataLen,1);

    // ok, complete that irp now!
    ARAP_COMPLETE_IRP(pIrp, dwBytesToDll, STATUS_SUCCESS, &ReturnStatus);

    // done with that buffer: free it here
    ARAP_FREE_RCVBUF(pArapBuf);

    return(SrpModLen);
}


//***
//
// Function: MnpSendAckIfReqd
//              This routine sends an ack to the remote client after making
//              sure that condition(s) do exist warranting sending of an Ack.
//
// Parameters:  pArapConn - connection element in question
//
// Return:      none
//
//***$

VOID
MnpSendAckIfReqd(
	IN	PARAPCONN    pArapConn,
    IN  BOOLEAN      fForceAck
)
{
    KIRQL           OldIrql;
    BYTE            SeqToAck;
    BYTE            RecvCredit;
    PMNPSENDBUF     pMnpSendBuf;
    PBYTE           pFrame, pFrameStart;
    BOOLEAN         fOptimized=TRUE;
    USHORT          FrameLen;
    PNDIS_PACKET    ndisPacket;
    NDIS_STATUS     ndisStatus;
    DWORD           StatusCode;
    BOOLEAN         fMustSend;



    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered MnpSendAckIfReqd (%lx)\n",pArapConn));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    //
    // if we are not up yet (or are disconnecting), forget about this ack
    //
    if (pArapConn->State != MNP_UP)
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return;
    }

    fMustSend = FALSE;

    //
    // first, find out if we need to send an ack at all
    //


    //
    // if we are told to send, just send it: don't question the decision!
    //
    if (fForceAck)
    {
        fMustSend = TRUE;
    }


    //
    // spec says if we have one or more unacked pkts and there is no user data
    // to send, then send it (what's user data got to do with this??)
    //
// BUGBUG: for now, don't check for IsListEmpty(&pArapConn->HighPriSendQ)
#if 0
    else if ( (pArapConn->MnpState.UnAckedRecvs > 0) &&
              (IsListEmpty(&pArapConn->HighPriSendQ)) )
    {
        fMustSend = TRUE;
    }
#endif
    else if (pArapConn->MnpState.UnAckedRecvs > 0)
    {
        fMustSend = TRUE;
    }

    //
    // if we haven't acked for a while (i.e. have received more than the
    // acceptable number of unacked packets) then send it
    //
    else if (pArapConn->MnpState.UnAckedRecvs >= pArapConn->MnpState.UnAckedLimit)
    {
        fMustSend = TRUE;
    }

    if (!fMustSend)
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return;
    }


    StatusCode = ARAPERR_NO_ERROR;

    // first, allocate a buff descriptor (before we change the state variables)
	if ((pMnpSendBuf = AtalkBPAllocBlock(BLKID_MNP_SMSENDBUF)) != NULL)
    {
        StatusCode = ArapGetNdisPacket(pMnpSendBuf);
    }

    if ((pMnpSendBuf == NULL) || (StatusCode != ARAPERR_NO_ERROR))
    {
        if (pMnpSendBuf)
        {
            ArapNdisFreeBuf(pMnpSendBuf);
        }
        else
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("MnpSendAckIfReqd: AtalkBPAllocBlock failed on %lx\n", pArapConn))
        }

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return;
    }


    // BUGBUG: for now, always send full size
    //RecvCredit = pArapConn->MnpState.RecvCredit;
    RecvCredit = pArapConn->MnpState.WindowSize;

    // tell the client which is the last packet we got successfully
    SeqToAck = pArapConn->MnpState.LastSeqRcvd;

#if DBG
    if ((SeqToAck == pArapConn->MnpState.LastAckSent) && (pArapConn->MnpState.HoleInSeq++ > 1))
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
            ("MnpSendAckIfReqd: ack %x already sent earlier\n",SeqToAck));
    }
#endif

    pArapConn->MnpState.LastAckSent = pArapConn->MnpState.LastSeqRcvd;

    // with this ack, we will be acking all the outstanding recv's
    pArapConn->MnpState.UnAckedRecvs = 0;

    // "stop" the 402 timer
    pArapConn->LATimer = 0;

    // reset the flow-control timer
    pArapConn->FlowControlTimer = AtalkGetCurrentTick() +
                                    pArapConn->T404Duration;

    if (!(pArapConn->Flags & MNP_OPTIMIZED_DATA))
    {
        fOptimized = FALSE;
    }

    ARAP_DBG_TRACE(pArapConn,11605,0,SeqToAck,RecvCredit,0);

    MNP_DBG_TRACE(pArapConn,SeqToAck,MNP_LA);

    // put MNPSend refcount
    pArapConn->RefCount++;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

#if DBG
    pMnpSendBuf->Signature = MNPSMSENDBUF_SIGNATURE;
    InitializeListHead(&pMnpSendBuf->Linkage);
#endif

    pMnpSendBuf->RetryCount = 0;  // not relevant here
    pMnpSendBuf->RefCount = 1;    // remove when send completes
    pMnpSendBuf->pArapConn = pArapConn;
    pMnpSendBuf->ComplRoutine = NULL;
    pMnpSendBuf->Flags = 1;

    pFrame = pFrameStart = &pMnpSendBuf->Buffer[0];

    AtalkNdisBuildARAPHdr(pFrame, pArapConn);

    pFrame += WAN_LINKHDR_LEN;

    //
    // put the start flags
    //
    *pFrame++ = pArapConn->MnpState.SynByte;
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.StxByte;

    //
    // now, put the body of the Ack frame
    //
    if (fOptimized)
    {
        *pFrame++ = 3;              // length indication
        *pFrame++ = 5;              // type indication
        *pFrame++ = SeqToAck;       // Receive seq number ( N(R) )
        *pFrame++ = RecvCredit;     // receive credit ( N(k) )
    }
    else
    {
        *pFrame++ = 7;              // length indication
        *pFrame++ = 5;              // type indication
        *pFrame++ = 1;              // var type
        *pFrame++ = 1;              // var len
        *pFrame++ = SeqToAck;       // receive seq number ( N(R) )
        *pFrame++ = 2;              // var type
        *pFrame++ = 1;              // var len
        *pFrame++ = RecvCredit;     // receive credit ( N(k) )
    }

    //
    // now finally, put the stop flags (no need for spinlock: this won't change!)
    //
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.EtxByte;

    FrameLen = (USHORT)(pFrame - pFrameStart);

    AtalkSetSizeOfBuffDescData(&pMnpSendBuf->sb_BuffDesc, FrameLen);

    NdisAdjustBufferLength(pMnpSendBuf->sb_BuffHdr.bh_NdisBuffer,FrameLen);

    //
    // send the packet over.  We need to go directly, and not via ArapNdisSend
    // because this packet needs to be delivered just once, regardless of
    // whether send window is open
    //

    ndisPacket = pMnpSendBuf->sb_BuffHdr.bh_NdisPkt;

    NdisSend(&ndisStatus, RasPortDesc->pd_NdisBindingHandle, ndisPacket);

    // if there was a problem sending, call the completion routine here
    if (ndisStatus != NDIS_STATUS_PENDING)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("MnpSendAckIfReqd: NdisSend failed %lx\n",ndisStatus));

	    ArapNdisSendComplete(ARAPERR_SEND_FAILED, (PBUFFER_DESC)pMnpSendBuf, NULL);
	}
}



//***
//
// Function: MnpSendLNAck
//              This routine sends an LN ack to the remote client, acknowleding
//              receipt of an LN frame
//
// Parameters:  pArapConn - connection element in question
//
// Return:      none
//
//***$

VOID
MnpSendLNAck(
	IN	PARAPCONN    pArapConn,
    IN  BYTE         LnSeqToAck
)
{
    KIRQL           OldIrql;
    PMNPSENDBUF     pMnpSendBuf;
    PBYTE           pFrame, pFrameStart;
    USHORT          FrameLen;
    PNDIS_PACKET    ndisPacket;
    NDIS_STATUS     ndisStatus;
    DWORD           StatusCode;



    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered MnpSendLNAck (%lx), %d\n",pArapConn,LnSeqToAck));

    StatusCode = ARAPERR_NO_ERROR;

    // first, allocate a buff descriptor
	if ((pMnpSendBuf = AtalkBPAllocBlock(BLKID_MNP_SMSENDBUF)) != NULL)
    {
        StatusCode = ArapGetNdisPacket(pMnpSendBuf);
    }


    if (pMnpSendBuf == NULL || (StatusCode != ARAPERR_NO_ERROR))
    {
        if (pMnpSendBuf)
        {
            ArapNdisFreeBuf(pMnpSendBuf);
        }
        else
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("MnpSendLNAck: AtalkBPAllocBlock failed on %lx\n", pArapConn))
        }
        return;
    }

#if DBG
    pMnpSendBuf->Signature = MNPSMSENDBUF_SIGNATURE;
    InitializeListHead(&pMnpSendBuf->Linkage);
#endif

    pMnpSendBuf->RetryCount = 0;  // not relevant here
    pMnpSendBuf->RefCount = 1;    // remove when send completes
    pMnpSendBuf->pArapConn = pArapConn;
    pMnpSendBuf->ComplRoutine = NULL;
    pMnpSendBuf->Flags = 1;

    pFrame = pFrameStart = &pMnpSendBuf->Buffer[0];

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    // if we are disconnecting, forget about sending this ack
    if (pArapConn->State >= MNP_LDISCONNECTING)
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        ArapNdisFreeBuf(pMnpSendBuf);
        return;
    }

    // put MNPSend refcount
    pArapConn->RefCount++;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    AtalkNdisBuildARAPHdr(pFrame, pArapConn);

    pFrame += WAN_LINKHDR_LEN;

    //
    // put the start flags
    //
    *pFrame++ = pArapConn->MnpState.SynByte;
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.StxByte;

    //
    // now, put the body of the Ack frame
    //
    *pFrame++ = 4;              // length indication
    *pFrame++ = 7;              // type indication
    *pFrame++ = 1;              // var type
    *pFrame++ = 1;              // var len
    *pFrame++ = LnSeqToAck;     //

    //
    // now finally, put the stop flags
    //
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.EtxByte;

    FrameLen = (USHORT)(pFrame - pFrameStart);

    AtalkSetSizeOfBuffDescData(&pMnpSendBuf->sb_BuffDesc, FrameLen);

    NdisAdjustBufferLength(pMnpSendBuf->sb_BuffHdr.bh_NdisBuffer,FrameLen);

    //
    // send the packet over.  We need to go directly, and not via ArapNdisSend
    // because this packet needs to be delivered just once, regardless of
    // whether send window is open
    //

    ndisPacket = pMnpSendBuf->sb_BuffHdr.bh_NdisPkt;

    NdisSend(&ndisStatus, RasPortDesc->pd_NdisBindingHandle, ndisPacket);

    // if there was a problem sending, call the completion routine here
    if (ndisStatus != NDIS_STATUS_PENDING)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("MnpSendLNAck: NdisSend failed %lx\n",ndisStatus));

	    ArapNdisSendComplete(ARAPERR_SEND_FAILED, (PBUFFER_DESC)pMnpSendBuf, NULL);
	}
}


//***
//
// Function: ArapSendLDPacket
//              This routine sends a Disconnect (LD) packet to the client
//
// Parameters:  pArapConn - the connection
//
// Return:      result of the operation
//
//***$

DWORD
ArapSendLDPacket(
    IN PARAPCONN    pArapConn,
    IN BYTE         UserCode
)
{
    PBYTE                   pFrame, pFrameStart;
    USHORT                  FrameLen;
    PNDIS_PACKET            ndisPacket;
    NDIS_STATUS             ndisStatus;
    PMNPSENDBUF             pMnpSendBuf;
    KIRQL                   OldIrql;
    DWORD                   StatusCode;


    DBG_ARAP_CHECK_PAGED_CODE();

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("ArapSendLDPacket: sending DISCONNECT on %lx\n",pArapConn));

    StatusCode = ARAPERR_NO_ERROR;

    //
    // allocate buf to send out the disconnection request
    //
	if ((pMnpSendBuf = AtalkBPAllocBlock(BLKID_MNP_SMSENDBUF)) != NULL)
    {
        StatusCode = ArapGetNdisPacket(pMnpSendBuf);
    }

	if ((pMnpSendBuf == NULL) || (StatusCode != ARAPERR_NO_ERROR))
	{
        if (pMnpSendBuf)
        {
            ArapNdisFreeBuf(pMnpSendBuf);
        }
        else
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("ArapSendLDPacket: AtalkBPAllocBlock failed on %lx\n", pArapConn));
        }

		return(ARAPERR_OUT_OF_RESOURCES);
	}

#if DBG
    pMnpSendBuf->Signature = MNPSMSENDBUF_SIGNATURE;
    InitializeListHead(&pMnpSendBuf->Linkage);
#endif
    pMnpSendBuf->RetryCount = 0;  // not relevant here
    pMnpSendBuf->RefCount = 1;    // remove when send completes
    pMnpSendBuf->pArapConn = pArapConn;
    pMnpSendBuf->ComplRoutine = NULL;
    pMnpSendBuf->Flags = 1;

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    //
    // if we are already disconnecting (say remote disconnected), just say ok
    //
    if (pArapConn->State >= MNP_LDISCONNECTING)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("ArapSendLDPacket: silently \
             discarding disconnect (already in progress) %lx\n", pArapConn));

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        ArapNdisFreeBuf(pMnpSendBuf);
        return(ARAPERR_DISCONNECT_IN_PROGRESS);
    }

    // Disconnect refcount: protect pArapConn until disconnect is complete
    pArapConn->RefCount++;

    // put MNPSend refcount
    pArapConn->RefCount++;

    pArapConn->State = MNP_LDISCONNECTING;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    pFrame = pFrameStart = &pMnpSendBuf->Buffer[0];

	AtalkNdisBuildARAPHdr(pFrame, pArapConn);

    pFrame += WAN_LINKHDR_LEN;

    //
    // put the start flags
    //
    *pFrame++ = pArapConn->MnpState.SynByte;
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.StxByte;

    //
    // now, put the body of the LD frame
    //
    *pFrame++ = 7;              // length indication
    *pFrame++ = 2;              // type indication for LD
    *pFrame++ = 1;              // var type
    *pFrame++ = 1;              // var len
    *pFrame++ = 0xFF;           // User-initiated disconnect

    *pFrame++ = 2;              // var type
    *pFrame++ = 1;              // var len
    *pFrame++ = UserCode;

    //
    // now finally, put the stop flags
    //
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.EtxByte;

    FrameLen = (USHORT)(pFrame - pFrameStart);

    AtalkSetSizeOfBuffDescData(&pMnpSendBuf->sb_BuffDesc, FrameLen);

	NdisAdjustBufferLength(pMnpSendBuf->sb_BuffHdr.bh_NdisBuffer,FrameLen);

    ARAP_SET_NDIS_CONTEXT(pMnpSendBuf, NULL);

    ndisPacket = pMnpSendBuf->sb_BuffHdr.bh_NdisPkt;

    // send the packet over (and don't bother checking return code!)
	NdisSend(&ndisStatus, RasPortDesc->pd_NdisBindingHandle, ndisPacket);

    // if there was a problem sending, call the completion routine here
    if (ndisStatus != NDIS_STATUS_PENDING)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapSendLDPacket: NdisSend failed %lx\n",ndisStatus));

        ArapNdisSendComplete(ARAPERR_SEND_FAILED, (PBUFFER_DESC)pMnpSendBuf, NULL);
    }

    // remove the disconnect refcount
    DerefArapConn(pArapConn);

    return(ARAPERR_NO_ERROR);
}


//***
//
// Function: ArapRetryTimer
//              This is the general purpose timer routine for ARAP.
//              It checks
//                  if the ack timer (LATimer) has expired (if yes, send ack)
//                  if the flowcontrol timer has expired (if yes, send ack)
//                  if the inactivity timer has expired (if yes, send ack)
//                  if the retransmit timer has expired (if yes, retransmit)
//
// Parameters:  pTimer            - the context for the timer that just fired
//              TimerShuttingDown - this is TRUE if timer is shutting down
//
// Return:      none
//
//***$

LONG FASTCALL
ArapRetryTimer(
	IN	PTIMERLIST			pTimer,
	IN	BOOLEAN				TimerShuttingDown
)
{

    PARAPCONN       pArapConn;
    PLIST_ENTRY     pList;
    PMNPSENDBUF     pMnpSendBuf;
    BOOLEAN         fRetransmit=FALSE;
    BOOLEAN         fMustSendAck = FALSE;
    BOOLEAN         fKill=FALSE;
    BOOLEAN         fMustFlowControl=FALSE;
    BOOLEAN         fInactiveClient=FALSE;
    LONG            CurrentTime;
    PIRP            pIrp=NULL;
	NTSTATUS		ReturnStatus=STATUS_SUCCESS;


    DBG_ARAP_CHECK_PAGED_CODE();

    pArapConn = CONTAINING_RECORD(pTimer, ARAPCONN, RetryTimer);

    ARAPTRACE(("Entered ArapRetryTimer (%lx)\n",pArapConn));

	ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

    //
    // if the global timer is shutting down, or if the connection isn't in the
    // right state (e.g. it is disconnecting), then don't requeue the timer
    //
	if ( TimerShuttingDown ||
		(pArapConn->State <= MNP_IDLE) || (pArapConn->State > MNP_UP) )
	{
        pArapConn->Flags &= ~RETRANSMIT_TIMER_ON;

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

        if (TimerShuttingDown)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRetryTimer: timer shut down, killing conn (%lx)\n",pArapConn));

            ArapCleanup(pArapConn);
        }
        else
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRetryTimer: (%lx) invalid state (%d), not requeing timer\n",
                    pArapConn,pArapConn->State));
        }

        // remove the timer refcount
        DerefArapConn(pArapConn);

		return ATALK_TIMER_NO_REQUEUE;
	}

	CurrentTime = AtalkGetCurrentTick();

    //
    // has the 402 timer expired?  if yes, we must send an ack
    // (a value of 0 signifies that the 402 timer is not "running")
    //
    if ( (pArapConn->LATimer != 0) && (CurrentTime >= pArapConn->LATimer) )
    {
        //
        // make sure there is a receive that needs to be acked (if sent the ack
        // just before this timer fired, don't send the ack again)
        //
        if (pArapConn->MnpState.UnAckedRecvs)
        {
            fMustSendAck = TRUE;

		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRetryTimer: 402 timer fired, forcing ack out (%d, now %d)\n",
                    pArapConn->LATimer,CurrentTime));
        }
        else
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRetryTimer: saved on on ack (UnAckedRecvs = 0)\n",pArapConn));
        }
    }

    //
    // has the flow control timer "expired"?  If so, we must send an ack and
    // reset the timer
    // (a value of 0 signifies that the flow control timer is not "running")
    //
    else if ( (pArapConn->FlowControlTimer != 0) &&
              (CurrentTime >= pArapConn->FlowControlTimer) )
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
            ("ArapRetryTimer: flow-control timer, forcing ack (%d, now %d)\n",
                pArapConn->FlowControlTimer,CurrentTime));

        fMustFlowControl = TRUE;

        pArapConn->FlowControlTimer = CurrentTime + pArapConn->T404Duration;
    }

    //
    // if the client been inactive for a long time, we must tell dll
    //
    else if (CurrentTime >= pArapConn->InactivityTimer)
    {
        // first make sure we can get the select irp
        ArapGetSelectIrp(&pIrp);

        // if we managed to get a select irp, reset the timer so we don't keep
        // informing the dll after every tick after this point!
        //
        if (pIrp)
        {
            pArapConn->InactivityTimer = pArapConn->T403Duration + CurrentTime;

            fInactiveClient = TRUE;
        }
    }

    //
    // Has the retransmit timer expired?  If so, we need to retransmit
    //
    else
    {
        //
        // look at the first entry of the retransmit queue.  If it's time is up, do
        // the retransmit thing.  Otherwise, we are done.  (All others in the queue
        // will be retransmitted after this first one is acked, so ignore for now)
        //
        pList = pArapConn->RetransmitQ.Flink;

        // no entries on the retransmit queue?  we're done!
        if (pList == &pArapConn->RetransmitQ)
        {
    	    RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
	        return ATALK_TIMER_REQUEUE;
        }

        pMnpSendBuf = CONTAINING_RECORD(pList, MNPSENDBUF, Linkage);

        // is it time to retransmit yet?
        if (CurrentTime >= pMnpSendBuf->RetryTime)
        {
            if (pMnpSendBuf->RetryCount >= ARAP_MAX_RETRANSMITS)
            {
                fKill = TRUE;
                RemoveEntryList(&pMnpSendBuf->Linkage);

                ASSERT(pArapConn->MnpState.UnAckedSends >= 1);

                // not really important, since we're about to disconnect!
                pArapConn->MnpState.UnAckedSends--;

                ASSERT(pArapConn->SendsPending >= pMnpSendBuf->DataSize);

                InitializeListHead(&pMnpSendBuf->Linkage);
            }
            else
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                    ("ArapRetryTimer: timer fired, retransmitting....%x (%ld now %ld)\n",
                        pMnpSendBuf->SeqNum,pMnpSendBuf->RetryTime,CurrentTime));

                if (pMnpSendBuf->RetryCount > 8)
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		                ("ArapRetryTimer: buf %lx of %lx retransmitted %d times!\n",
                        pMnpSendBuf,pArapConn,pMnpSendBuf->RetryCount));
                }

                pArapConn->MnpState.RetransmitMode = TRUE;
                pArapConn->MnpState.MustRetransmit = TRUE;

                fRetransmit = TRUE;
            }
        }
    }

	RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

    // force an ack out (that's what TRUE does)
    if (fMustSendAck || fMustFlowControl)
    {
        MnpSendAckIfReqd(pArapConn, TRUE);
    }

    // if we must retransmit, go for it.
    //
    else if (fRetransmit)
    {
        ArapNdisSend(pArapConn, &pArapConn->RetransmitQ);
    }

    //
    // if we retransmitted too many times, let the completion routine know.
    // (it will probably kill the connection)
    //
    else if (fKill)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapRetryTimer: too many retransmits (%lx), disconnecting %lx\n",
                pMnpSendBuf,pArapConn));

        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf, ARAPERR_SEND_FAILED);
    }

    //
    // if the connection has been inactive for longer than the limit (given to
    // us by the dll), then tell dll about it
    //
    else if (fInactiveClient)
    {
        PARAP_SEND_RECV_INFO    pSndRcvInfo;

	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapRetryTimer: (%lx) inactive, telling dll (%lx)\n",pArapConn, pIrp));

        ASSERT(pIrp != NULL);

        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

        pSndRcvInfo->pDllContext = pArapConn->pDllContext;
        pSndRcvInfo->AtalkContext = pArapConn;
        pSndRcvInfo->StatusCode = ARAPERR_CONN_INACTIVE;

        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS, &ReturnStatus);
		return ReturnStatus;
    }

	return ATALK_TIMER_REQUEUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\arap.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arap.h

Abstract:

	This module has defines, prototypes etc. specific to ARAP functionality

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/


//
// enable asserts when running checked stack on free builds
//
#if DBG
#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(exp)                                                     \
{                                                                       \
    if (!(exp))                                                         \
    {                                                                   \
        DbgPrint( "\n*** Assertion failed: %s (File %s, line %ld)\n",   \
              (exp),__FILE__, __LINE__);                                \
                                                                        \
        DbgBreakPoint();                                                \
    }                                                                   \
}
#endif



#define ATALK_CC_METHOD(_ControlCode)  ((_ControlCode) & 0x03)


//
// Possible states for the connection (State field in ARAPCONN structure)
// IMPORTANT: order of these states matters!  (comparisons other than == used)
//
#define MNP_IDLE             0  // creation state, after Ndiswan Line_Up
#define MNP_REQUEST          1  // this state never reached (client-side only)
#define MNP_RESPONSE         2  // sent LR response to the client
#define MNP_UP               3  // MNP connection is in data-phase
#define MNP_LDISCONNECTING   4  // disconnect from local (user ioctl)
#define MNP_RDISC_RCVD       5  // disconnect from remote received
#define MNP_RDISCONNECTING   6  // cleanup underway because of MNP_RDISC_RCVD
#define MNP_DISCONNECTED     7  // cleanup done, waiting for Ndiswan Line_Down

//
// possible header types (from the v42 alternative procedure spec)
//
#define MNP_LR             0x1
#define MNP_LD             0x2
#define MNP_LT             0x4
#define MNP_LT_V20CLIENT   0x84
#define MNP_LA             0x5
#define MNP_LN             0x6
#define MNP_LNA            0x7

#define MNP_MINPKT_SIZE     64
#define MNP_MAXPKT_SIZE     256

#define MNP_LR_CONST1       2
// type values for the various "variable" parms
#define MNP_LR_CONST2       1
#define MNP_LR_FRAMING      2
#define MNP_LR_NUMLTFRMS    3
#define MNP_LR_INFOLEN      4
#define MNP_LR_DATAOPT      8
#define MNP_LR_V42BIS       14

#define MNP_FRMMODE_OCTET   2
#define MNP_FRMMODE_BIT     3

#define MNP_FRMTYPE_OFFSET  4
#define ARAP_DGROUP_OFFSET  2
#define ARAP_DATA_OFFSET    3

// bit 6 is set for appletalk data, is clear for arap data
#define ARAP_SFLAG_PKT_DATA       0x40
#define ARAP_SFLAG_LAST_GROUP     0x10


//
// Flags bits (in ARAPCONN structure)
//
#define MNP_OPTIMIZED_DATA    0x00000001 // MNP negotiated for optimized data
#define MNP_V42BIS_NEGOTIATED 0x00000002 // MNP negotiated v42bis compression
#define ARAP_V20_CONNECTION   0x00000004 // v2.0 if bit set, v1.0 otherwise
#define ARAP_NODE_IN_USE      0x00000008 // used while acquiring node (dynamic mode)
#define ARAP_FINDING_NODE     0x00000010 // used while acquiring node (dynamic mode)
#define ARAP_CALLBACK_MODE    0x00000020 // used if we are calling back
#define ARAP_CONNECTION_UP    0x00000040 // ARAP connection is up, data phase entered
#define ARAP_DATA_WAITING     0x00000080 // data arrived, but no irp to fill it in
#define ARAP_REMOTE_DISCONN   0x00000100 // remote side issued the disconnect
#define DISCONNECT_NO_IRP     0x00000200 // waiting for irp to tell dll about disc.
#define RETRANSMIT_TIMER_ON   0x00000400 // retransmit timer is running
#define ARAP_LINK_DOWN        0x00000800 // link went down
#define ARAP_GOING_AWAY       0x00001000 // the connection is about to be freed!

// BUGBUG: currently set to be 200ms (1 => 100 ms)
#define ARAP_TIMER_INTERVAL   2

#define ARAP_MAX_RETRANSMITS       12
#define ARAP_HALF_MAX_RETRANSMITS  (ARAP_MAX_RETRANSMITS/2)

// retry time will depend on link speed (also on how many retranmits of the
// same send have happened so far), but we'll fix min (1sec) and max (5sec)
#define ARAP_MIN_RETRY_INTERVAL    10
#define ARAP_MAX_RETRY_INTERVAL    50

// our limits (in bytes) for outstanding sends that are sitting on the queue
#define ARAP_SENDQ_LOWER_LIMIT  10000
#define ARAP_SENDQ_UPPER_LIMIT  12000

// our limits (in bytes) for outstanding recvs that are sitting on the queue
#define ARAP_RECVQ_LOWER_LIMIT  20000
#define ARAP_RECVQ_UPPER_LIMIT  30000

// on low-priority sends, we wait until we collect at least these many bytes
#define ARAP_SEND_COALESCE_SIZE_LIMIT  150
// max number of SRPs we will put in a low-priority MNP send
#define ARAP_SEND_COALESCE_SRP_LIMIT   200
// on low-priority sends, we wait until so much time has passed (in 100ms units)
#define ARAP_SEND_COALESCE_TIME_LIMIT  10


// BUGBUG: adjust these numbers for optimum usage/perf
#define ARAP_SMPKT_SIZE     100
#define ARAP_MDPKT_SIZE     300
#define ARAP_LGPKT_SIZE     ARAP_MAXPKT_SIZE_INCOMING+10
#define ARAP_SENDBUF_SIZE   1000
#define ARAP_LGBUF_SIZE     4000
#define ARAP_HGBUF_SIZE     8100

// LAP src byte, LAP dest byte, LAP type byte
#define ARAP_LAP_HDRSIZE    3

// 2 srplen bytes, 1 Dgroup byte
#define ARAP_HDRSIZE        3

#define ARAP_NBP_BRRQ               0x11
#define ARAP_NBP_LKRQ               0x21

// 3rd and 4th bytes in the NBP pkt are the source network bytes
#define ARAP_NBP_SRCNET_OFFSET  LDDP_DGRAM_OFFSET + 2
#define ARAP_NBP_OBJLEN_OFFSET  LDDP_DGRAM_OFFSET + 7

#define ARAP_FAKE_ETHNET_HDRLEN     14
#define MNP_START_FLAG_LEN          3
#define MNP_STOP_FLAG_LEN           2
#define MNP_LT_HDR_LN(_pCon)  ((_pCon->Flags & MNP_OPTIMIZED_DATA)? 3 : 5)

#define ARAP_SEND_PRIORITY_HIGH     1
#define ARAP_SEND_PRIORITY_MED      2
#define ARAP_SEND_PRIORITY_LOW      3

#define MNP_OVERHD(_pConn)                              \
                            ( ARAP_FAKE_ETHNET_HDRLEN + \
                              MNP_START_FLAG_LEN      + \
                              MNP_LT_HDR_LN(_pConn)   + \
                              MNP_STOP_FLAG_LEN  )

#define ADD_ONE(_x)         (_x) = (((_x) == 0xff) ? 0 : ((_x)+1))

// seq num on LT frame: 5th byte if it's an Optimized data phase: 7th otherwise
#define  LT_SEQ_NUM(_p, _pCon)  \
                (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? (_p)[5] : (_p)[7])

#define  LT_SEQ_OFFSET(_pCon) (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? 5: 7)

#define  LT_SRP_OFFSET(_pCon) (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? 6: 8)

// this includes 2 bytes of crc bytes
#define  LT_OVERHEAD(_pCon) (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? 10 : 12)

// BUGBUG modify this to include any packet in the window
#define  LT_OK_TO_ACCEPT(_sq, _pCon, _ok) \
                (_ok = (_sq == _pCon->MnpState.NextToReceive))

//
// basically, (a > b)? except that a,b are seq numbers and wrap at 255
// Within a window of 8 pkts either side of 0, we have special cases
// we have assumed windowsize to be 8 here.  Even if a different window
// size is negotiated, this should work just fine
// BUGBUG: should we use a bigger range, just to be sure?
//
#define LT_GREATER_THAN(_a,_b,_result)                  \
{                                                       \
    if ( (_a) >= 248 && (_b) >= 0 && (_b) < 8 )         \
    {                                                   \
        _result = FALSE;                                \
    }                                                   \
    else if ( (_a) >= 0  && (_a) < 8 && (_b) >= 248 )   \
    {                                                   \
        _result = TRUE;                                 \
    }                                                   \
    else                                                \
    {                                                   \
        _result = ((_a) > (_b));                        \
    }                                                   \
}

#define LT_LESS_OR_EQUAL(_x,_y,_rslt)                   \
{                                                       \
    LT_GREATER_THAN(_x,_y,_rslt);                       \
    _rslt = !(_rslt);                                   \
}


#define LT_MIN_LENGTH(_pCon)    (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? 6 : 8)
#define LA_MIN_LENGTH(_pCon)    (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? 7 : 9)
#define LN_MIN_LENGTH           8

// seq num on LA frame: 5th byte if it's an Optimized data phase: 7th otherwise
#define  LA_SEQ_NUM(_p, _pCon)  \
                (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? (_p)[5] : (_p)[7])

// rcv credit on LA frame: 6th byte if it's an Optimized data phase: 8th otherwise
#define  LA_CREDIT(_p, _pCon)  \
                (((_pCon)->Flags & MNP_OPTIMIZED_DATA) ? (_p)[6] : (_p)[8])

// overhead for LT (optimized): 8  = 3(start flag)+3(LT hdr)+2(stop flag)
//              (nonoptimized): 10 = 3(start flag)+5(LT hdr)+2(stop flag)


#define LN_ATTN_TYPE(_p)   ((_p)[7])
#define LN_ATTN_SEQ(_p)    ((_p)[4])

#define LN_DESTRUCTIVE     1
#define LN_NON_D_E         2
#define LN_NON_D_NON_E     3


// The states that the stack can assume (with respect to ARAP)
//
// ARAP_STATE_INIT              -- arap engine (dll) hasn't open the stack
// ARAP_STATE_INACTIVE_WAITING  -- stack inactive, but engine not notified yet
// ARAP_STATE_INACTIVE          -- stack inactive, and engine notified
// ARAP_STATE_ACTIVE_WAITING    -- stack ready, engine not notified yet (select not available)
// ARAP_STATE_ACTIVE            -- stack ready, engine notified about it (via select)
//
#define ARAP_STATE_INACTIVE_WAITING     1
#define ARAP_STATE_INACTIVE             2
#define ARAP_STATE_ACTIVE_WAITING       3
#define ARAP_STATE_ACTIVE               4


#define ARAP_PORT_READY ( (AtalkDefaultPort != NULL) &&                 \
                          (AtalkDefaultPort->pd_Flags & PD_ACTIVE) &&   \
                          (RasPortDesc != NULL) &&                      \
                          (RasPortDesc->pd_Flags & PD_ACTIVE) )

#define ARAP_PNP_IN_PROGRESS ( ((AtalkDefaultPort != NULL) &&                           \
                                (AtalkDefaultPort->pd_Flags & PD_PNP_RECONFIGURE)) ||   \
                               ((RasPortDesc != NULL) &&                                \
                               (RasPortDesc->pd_Flags & PD_PNP_RECONFIGURE)) )

#define ARAP_INVALID_CONTEXT    (PVOID)0x01020304

#define ARAP_GET_SNIFF_IRP(_pIrp)                   \
{                                                   \
    KIRQL   _OldIrqlX;                              \
                                                    \
    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &_OldIrqlX);   \
    *(_pIrp) = ArapSniffIrp;                        \
    ArapSniffIrp = NULL;                            \
    RELEASE_SPIN_LOCK(&ArapSpinLock, _OldIrqlX);    \
}



#if DBG
#define ARAP_COMPLETE_IRP(_pIrp, _dwBytesToDll, _status, _returnStatus)                        \
{                                                                               \
    PIO_STACK_LOCATION  _pIrpSp;                                                \
    ULONG _IoControlCode;                                                       \
                                                                                \
	_pIrpSp = IoGetCurrentIrpStackLocation(_pIrp);                              \
    _IoControlCode = _pIrpSp->Parameters.DeviceIoControl.IoControlCode;         \
                                                                                \
    _pIrp->IoStatus.Information = _dwBytesToDll;                                \
    _pIrp->IoStatus.Status = _status;                                           \
                                                                                \
    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,                                      \
        ("Arap: completing pIrp %lx, Ioctl %lx, Status=%ld, DataLen=%ld\n",     \
                _pIrp,_IoControlCode,_status,_dwBytesToDll));                   \
                                                                                \
    _pIrp->CancelRoutine = NULL;                                                \
    *_returnStatus = _pIrp->IoStatus.Status;                                      \
    IoCompleteRequest(_pIrp,IO_NETWORK_INCREMENT);                              \
}
#else
#define ARAP_COMPLETE_IRP(_pIrp, _dwBytesToDll, _status, _returnStatus)                        \
{                                                                               \
    PIO_STACK_LOCATION  _pIrpSp;                                                \
                                                                                \
	_pIrpSp = IoGetCurrentIrpStackLocation(_pIrp);                              \
                                                                                \
    _pIrp->IoStatus.Information = _dwBytesToDll;                                \
    _pIrp->IoStatus.Status = _status;                                           \
                                                                                \
                                                                                \
    _pIrp->CancelRoutine = NULL;                                                \
    *_returnStatus= _pIrp->IoStatus.Status;                                       \
    IoCompleteRequest(_pIrp,IO_NETWORK_INCREMENT);                              \
}
#endif

#define ARAP_SET_NDIS_CONTEXT(_pSndBuf,_pSndContxt)                            \
{                                                                              \
	PPROTOCOL_RESD  _pResd;                                                    \
	PNDIS_PACKET	_nPkt;                                                     \
                                                                               \
	_nPkt	= (_pSndBuf)->sb_BuffHdr.bh_NdisPkt;                               \
	_pResd = (PPROTOCOL_RESD)&_nPkt->ProtocolReserved;                         \
                                                                               \
	_pResd->Send.pr_Port         = RasPortDesc;                                \
    _pResd->Send.pr_SendCompletion = ArapNdisSendComplete;                     \
	_pResd->Send.pr_BufferDesc   = (PBUFFER_DESC)(_pSndBuf);                   \
	if ((_pSndContxt) != NULL)                                                 \
    {                                                                          \
        RtlCopyMemory(&_pResd->Send.pr_SendInfo,                               \
                      (_pSndContxt),                                           \
                      sizeof(SEND_COMPL_INFO));                                \
    }                                                                          \
	else                                                                       \
    {                                                                          \
        RtlZeroMemory(&_pResd->Send.pr_SendInfo, sizeof(SEND_COMPL_INFO));     \
    }                                                                          \
}

//
// we take a very simplistic view!
//
#define ARAP_ADJUST_RECVCREDIT(_pConn)                                         \
{                                                                              \
    if (_pConn->RecvsPending >= ARAP_RECVQ_UPPER_LIMIT)                        \
    {                                                                          \
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,                                  \
        ("ARAP (%lx): recv credit dropped to 0 (%d)\n",_pConn,_pConn->RecvsPending));\
                                                                               \
        _pConn->MnpState.RecvCredit = 0;                                       \
    }                                                                          \
    else if (_pConn->RecvsPending >= ARAP_RECVQ_LOWER_LIMIT)                   \
    {                                                                          \
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,                                  \
        ("ARAP (%lx): recv credit dropped to 1 (%d)\n",_pConn,_pConn->RecvsPending));\
                                                                               \
        _pConn->MnpState.RecvCredit = 1;                                       \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        _pConn->MnpState.RecvCredit = _pConn->MnpState.WindowSize;             \
    }                                                                          \
}

#if DBG
#define ARAP_GET_RIGHTSIZE_RCVBUF(_size, _ppNewBuf)                            \
{                                                                              \
    UCHAR       _BlkId;                                                        \
    PARAPBUF    _pRcvBuf;                                                      \
    USHORT      _BufSize;                                                      \
    DWORD       _Signature;                                                    \
                                                                               \
    *(_ppNewBuf) = NULL;                                                       \
    _pRcvBuf = NULL;                                                           \
                                                                               \
    if ((_size) <= ARAP_SMPKT_SIZE)                                            \
    {                                                                          \
        _BlkId = BLKID_ARAP_SMPKT;                                             \
        _BufSize = ARAP_SMPKT_SIZE;                                            \
        _Signature = ARAPSMPKT_SIGNATURE;                                      \
    }                                                                          \
    else if ((_size) <= ARAP_MDPKT_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_MDPKT;                                             \
        _BufSize = ARAP_MDPKT_SIZE;                                            \
        _Signature = ARAPMDPKT_SIGNATURE;                                      \
    }                                                                          \
    else if ((_size) <= ARAP_LGPKT_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_LGPKT;                                             \
        _BufSize = ARAP_LGPKT_SIZE;                                            \
        _Signature = ARAPLGPKT_SIGNATURE;                                      \
    }                                                                          \
    else if ((_size) <= ARAP_LGBUF_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_LGBUF;                                             \
        _BufSize = ARAP_LGBUF_SIZE;                                            \
        _Signature = ARAPLGBUF_SIGNATURE;                                      \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        _BlkId = ARAP_UNLMTD_BUFF_ID;                                          \
        _BufSize = (USHORT)(_size);                                            \
        _Signature = ARAPUNLMTD_SIGNATURE;                                     \
    }                                                                          \
                                                                               \
    if (_BlkId == ARAP_UNLMTD_BUFF_ID)                                         \
    {                                                                          \
        if ((_size) > 5000)                                                    \
        {                                                                      \
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,                              \
               ("Arap: allocating %ld bytes rcv buf\n",_size));                \
        }                                                                      \
                                                                               \
        _pRcvBuf = (PARAPBUF)AtalkAllocMemory((_size) + sizeof(ARAPBUF));      \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        _pRcvBuf = (PARAPBUF)AtalkBPAllocBlock(_BlkId);                        \
    }                                                                          \
                                                                               \
    if (_pRcvBuf != NULL)                                                      \
    {                                                                          \
        _pRcvBuf->Signature = _Signature;                                      \
        _pRcvBuf->BlockId = _BlkId;                                            \
        _pRcvBuf->BufferSize = _BufSize;                                       \
	    _pRcvBuf->DataSize = 0;                                                \
	    _pRcvBuf->CurrentBuffer = &(_pRcvBuf->Buffer[0]);                      \
        *(_ppNewBuf) = _pRcvBuf;                                               \
    }                                                                          \
}

#define ARAP_FREE_RCVBUF(_pBuf)                                                \
{                                                                              \
    ASSERT( (_pBuf->Signature == ARAPSMPKT_SIGNATURE) ||                       \
            (_pBuf->Signature == ARAPMDPKT_SIGNATURE) ||                       \
            (_pBuf->Signature == ARAPLGPKT_SIGNATURE) ||                       \
            (_pBuf->Signature == ARAPLGBUF_SIGNATURE) ||                       \
            (_pBuf->Signature == ARAPUNLMTD_SIGNATURE) );                      \
                                                                               \
    _pBuf->Signature -= 0x10210000;                                            \
    if (_pBuf->BlockId == ARAP_UNLMTD_BUFF_ID)                                 \
    {                                                                          \
        AtalkFreeMemory(_pBuf);                                                \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        AtalkBPFreeBlock(_pBuf);                                               \
    }                                                                          \
}

#define ARAP_CHECK_RCVQ_INTEGRITY(_pConn)                                      \
{                                                                              \
    ASSERT( (DbgChkRcvQIntegrity(_pConn)) );                                   \
}

#define MNP_DBG_TRACE(_pConn,_Seq,_FrmType)                                    \
{                                                                              \
    ArapDbgMnpHist(_pConn,_Seq,(_FrmType));                                    \
}                                                                              \

#define ARAP_DBG_TRACE(_pConn,_Loc,_Ptr,_D1,_D2,_D3)                           \
{                                                                              \
    ArapDbgTrace(_pConn,_Loc,_Ptr,_D1,_D2,_D3);                                \
}

#define ARAP_DUMP_DBG_TRACE(_pConn)     ArapDumpSniffInfo(_pConn)

#else
#define ARAP_GET_RIGHTSIZE_RCVBUF(_size, _ppNewBuf)                            \
{                                                                              \
    UCHAR       _BlkId;                                                        \
    PARAPBUF    _pRcvBuf;                                                      \
    USHORT      _BufSize;                                                      \
                                                                               \
    *(_ppNewBuf) = NULL;                                                       \
    _pRcvBuf = NULL;                                                           \
                                                                               \
    if ((_size) <= ARAP_SMPKT_SIZE)                                            \
    {                                                                          \
        _BlkId = BLKID_ARAP_SMPKT;                                             \
        _BufSize = ARAP_SMPKT_SIZE;                                            \
    }                                                                          \
    else if ((_size) <= ARAP_MDPKT_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_MDPKT;                                             \
        _BufSize = ARAP_MDPKT_SIZE;                                            \
    }                                                                          \
    else if ((_size) <= ARAP_LGPKT_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_LGPKT;                                             \
        _BufSize = ARAP_LGPKT_SIZE;                                            \
    }                                                                          \
    else if ((_size) <= ARAP_LGBUF_SIZE)                                       \
    {                                                                          \
        _BlkId = BLKID_ARAP_LGBUF;                                             \
        _BufSize = ARAP_LGBUF_SIZE;                                            \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        _BlkId = ARAP_UNLMTD_BUFF_ID;                                          \
        _BufSize = (USHORT)(_size);                                            \
    }                                                                          \
                                                                               \
    if (_BlkId == ARAP_UNLMTD_BUFF_ID)                                         \
    {                                                                          \
        _pRcvBuf = (PARAPBUF)AtalkAllocMemory((_size) + sizeof(ARAPBUF));      \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        _pRcvBuf = (PARAPBUF)AtalkBPAllocBlock(_BlkId);                        \
    }                                                                          \
                                                                               \
    if (_pRcvBuf != NULL)                                                      \
    {                                                                          \
        _pRcvBuf->BlockId = _BlkId;                                            \
        _pRcvBuf->BufferSize = _BufSize;                                       \
	    _pRcvBuf->DataSize = 0;                                                \
	    _pRcvBuf->CurrentBuffer = &(_pRcvBuf->Buffer[0]);                      \
        *(_ppNewBuf) = _pRcvBuf;                                               \
    }                                                                          \
}

#define ARAP_FREE_RCVBUF(_pBuf)                                                \
{                                                                              \
    if (_pBuf->BlockId == ARAP_UNLMTD_BUFF_ID)                                 \
    {                                                                          \
        AtalkFreeMemory(_pBuf);                                                \
    }                                                                          \
    else                                                                       \
    {                                                                          \
        AtalkBPFreeBlock(_pBuf);                                               \
    }                                                                          \
}

#define ARAP_CHECK_RCVQ_INTEGRITY(_pConn)

#define MNP_DBG_TRACE(_pConn,_Seq,_FrmType)
#define ARAP_DBG_TRACE(_pConn,_Loc,_Ptr,_D1,_D2,_D3)
#define ARAP_DUMP_DBG_TRACE(_pConn)

#endif  // #if DBG



#define ARAP_BYTES_ON_RECVQ(_pConn,_BytesOnQ)                                  \
{                                                                              \
    DWORD       _BytesSoFar=0;                                                 \
    PLIST_ENTRY _pList;                                                        \
    PARAPBUF    _pArapBuf;                                                     \
                                                                               \
    *(_BytesOnQ) = 0;                                                          \
                                                                               \
    _pList = _pConn->ReceiveQ.Flink;                                           \
    while (_pList != &_pConn->ReceiveQ)                                        \
    {                                                                          \
        _pArapBuf = CONTAINING_RECORD(_pList, ARAPBUF, Linkage);               \
        _BytesSoFar += _pArapBuf->DataSize;                                    \
                                                                               \
        _pList = _pArapBuf->Linkage.Flink;                                     \
    }                                                                          \
                                                                               \
    *(_BytesOnQ) = _BytesSoFar;                                                \
}


#if DBG
#define  ARAPTRACE(_x)             DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO, _x)
#define  DBGDUMPBYTES(_a,_b,_c,_d) DbgDumpBytes(_a,_b,_c,_d)
#define  DBGTRACK_SEND_SIZE(_pConn,_Size)   DbgTrackInfo(_pConn,_Size,1)
#else
#define  ARAPTRACE(_x)
#define  DBGDUMPBYTES(_a,_b,_c,_d)
#define  DBGTRACK_SEND_SIZE(_pConn,_Size)
#endif

#define ARAPACTION_COMPLETE_IRP     1
#define ARAPACTION_CALL_COMPLETION  2

typedef struct _ADDRMGMT
{
    struct _ADDRMGMT  * Next;
    USHORT              Network;
    BYTE                NodeBitMap[32];    // 255 nodes per net
}ADDRMGMT, *PADDRMGMT;

typedef struct _ARAPGLOB
{
    DWORD           LowVersion;
    DWORD           HighVersion;
    DWORD           MnpInactiveTime;    // tell dll after Mnp is inactive for this time
    BOOLEAN         V42bisEnabled;      //
    BOOLEAN         SmartBuffEnabled;   //
    BOOLEAN         NetworkAccess;      // if FALSE, no routing (only this machine)
    BOOLEAN         DynamicMode;        // we want the stack to get node address
    NETWORKRANGE    NetRange;
    PADDRMGMT       pAddrMgmt;          // addr allocation to clients (in static mode)
    USHORT          OurNetwkNum;        // Network number of our default port
    BYTE            MaxLTFrames;        // max LT frames outstanding (rcv window)
    BOOLEAN         SniffMode;          // if TRUE, all pkts will be given to ARAP to "sniff"
    BOOLEAN         RouteAdded;         // if in static mode, have we added a route?
} ARAPGLOB, *PARAPGLOB;


typedef struct _ARAPSTATS
{
    DWORD   SendPreCompMax;    // largest packet we have sent (before comp)
    DWORD   SendPostCompMax;   // largest packet we have sent (after comp)
    DWORD   SendPreCompMin;    // smallest packet we have sent (before comp)
    DWORD   SendPostCompMin;   // smallest packet we have sent (after comp)
    DWORD   RecvPostDecompMax; // largest packet we have received (after decomp)
    DWORD   RecvPostDecomMin;  // smallest packet we have received (after decomp)
} ARAPSTATS, *PARAPSTATS;


typedef VOID (*PARAP_SEND_COMPLETION)(
              struct _MNPSENDBUF * pMnpSendBuf,
              DWORD                Status
);


typedef struct _MNPSTATE
{
    // sequence numbers when we are receiving
    BYTE    NextToReceive;      // next frame we expect to receive
    BYTE    LastSeqRcvd;        // seq num of last pkt we successfully rcvd
    BYTE    LastAckSent;        // seq num for which we sent the last ack
    BYTE    UnAckedRecvs;       // how many packets we've recvd but not acked yet
    BYTE    RecvCredit;         // how many more we can receive
    BYTE    HoleInSeq;          // TRUE when we get a hole in receive sequence
    BYTE    ReceivingDup;       // TRUE the moment we start receiving dup(s)
    BYTE    FirstDupSeq;        // seq num where we started getting dup's
    BYTE    DupSeqBitMap;       // bitmap of which seq nums we've got dups for
                                // BUGBUG: if we ever want windowsize of more than 8,
                                //         we must make this a DWORD or something!
    // sequence numbers when we are sending
    BYTE    LastAckRcvd;        // last frame we have received ack for
    BYTE    NextToSend;         // next frame we will send
    BYTE    SendCredit;         // how many more we can send
    BYTE    UnAckedSends;       // basically, number of sends on retransmitQ
    BYTE    MustRetransmit;     // TRUE when we want retransmission to occur
    BYTE    RetransmitMode;     // TRUE if we are in retransmit mode

    // when we are processing the receives
    BYTE    NextToProcess;      // next sequence we will process
    BYTE    MustAck;            // if TRUE, send ack

    // static info that we negotiated at connection time
    BYTE    WindowSize;         // max pkts we can buffer (parm k)
    BYTE    UnAckedLimit;       // num of unacked pkts after which we must ack
    USHORT  MaxPktSize;         // N401 parm: this can be max 256
    BYTE    SynByte;
    BYTE    DleByte;
    BYTE    StxByte;
    BYTE    EtxByte;
    BYTE    LTByte;

} MNPSTATE, *PMNPSTATE;


typedef struct _ARAPDBGHISTORY
{
    USHORT      TimeStamp;    // when did this happen (relative to prev event)
    USHORT      Location;     // where did this happen
    BYTE        Info[1];      // info specific to what/where happened
} ARAPDBGHISTORY, *PARAPDBGHISTORY;

#define DBG_HISTORY_BUF_SIZE   4000

typedef struct _DBGMNPHIST
{
    DWORD       TimeStamp;
    DWORD       FrameInfo;
} DBGMNPHIST, *PDBGMNPHIST;

#define DBG_MNP_HISTORY_SIZE   80


typedef struct _ARAPCONN
{
    LIST_ENTRY                Linkage;
#if DBG
    DWORD                     Signature;
#endif
    DWORD                     State;             // connected, connecting etc
    DWORD                     RefCount;          // memory freed when this goes to 0
    MNPSTATE                  MnpState;          // MNP state info
    DWORD                     Flags;             // general flag kind of info
    ATALK_NODEADDR            NetAddr;           // network address of the Arap client
    PVOID                     pDllContext;       // Araps context
    PIRP                      pIoctlIrp;         // irp sent down by the ARAP dll
    PIRP                      pRecvIoctlIrp;     // receive irp from ARAP dll
    LIST_ENTRY                MiscPktsQ;         // pkts other than LT queued here
    LIST_ENTRY                ReceiveQ;          // data indicated but not yet processed
    LIST_ENTRY                ArapDataQ;         // data that's waiting for an irp from Arap
    LIST_ENTRY                HighPriSendQ;      // high priority sends
    LIST_ENTRY                MedPriSendQ;       // medium priority sends
    LIST_ENTRY                LowPriSendQ;       // low priority sends
    LIST_ENTRY                SendAckedQ;        // got ack, need to complete this send
    LIST_ENTRY                RetransmitQ;       // data sent out, but not acked yet
    DWORD                     SendsPending;      // unacked/unsent sends (bytes) pending
    DWORD                     RecvsPending;      // rcvs (bytes) yet to be delivered
    TIMERLIST                 RetryTimer;        // the 401 timer (retransmit timer)
    LONG                      LATimer;           // the 402 timer
    LONG                      T402Duration;      // timer value for the 402 timer
    LONG                      InactivityTimer;   // the 403 timer
    LONG                      T403Duration;      // timer value for the 403 timer
    LONG                      FlowControlTimer;  // the 404 timer
    LONG                      T404Duration;      // timer value for the 404 timer
    BYTE                      NdiswanHeader[14]; // 14 byte ethernet-like header
    BYTE                      BlockId;           // basically what size sends to use
    BYTE                      UnUsed;
    ULONG                     LinkSpeed;         // link speed in 100 bps units
    STAT_INFO                 StatInfo;          // statistics for this connection
    LONG                      SendRetryTime;     // send timer to fire after how much time
    LONG                      SendRetryBaseTime; // send timer interval at init
    ATALK_SPIN_LOCK           SpinLock;
    KEVENT                    NodeAcquireEvent;  // use while acquiring node (dynamic mode)
    LONG                      LastNpbBrrq;       // time we sent out a NBP_BRRQ pkt last
    v42bis_connection_t      *pV42bis;
#if DBG
    LARGE_INTEGER             LastTimeStamp;     // when did we last record history
    DWORD                     DbgMnpIndex;
    DBGMNPHIST                DbgMnpHist[DBG_MNP_HISTORY_SIZE];
    PBYTE                     pDbgTraceBuffer;   // where the sniff buffer starts
    PBYTE                     pDbgCurrPtr;       // currently pointing here in sniff buf
    DWORD                     SniffedBytes;      // how much does sniff buffer contain
#endif

} ARAPCONN, *PARAPCONN;


typedef struct _ARAPSNIFF
{
    DWORD   Signature;
    DWORD   TimeStamp;
    USHORT  Length;
    BYTE    StartSeq;
    BYTE    EndSeq;
    DWORD   UncompBytesSoFar;
} ARAPSNIFF, *PARAPSNIFF;



typedef struct _ARAPQITEM
{
    WORK_QUEUE_ITEM     WorkQItem;
    DWORD               Action;
    PVOID               Context1;
    PVOID               Context2;
} ARAPQITEM, *PARAPQITEM;


#if DBG
#define  DBG_ARAP_CHECK_PAGED_CODE()                           \
{                                                              \
    if (AtalkPgLkSection[ARAP_SECTION].ls_LockCount <= 0)      \
    {                                                          \
        DbgPrint("Arap code section not locked, count=%d\n",   \
            AtalkPgLkSection[ARAP_SECTION].ls_LockCount);      \
        ASSERT(0);                                             \
    }                                                          \
}
#define  DBG_PPP_CHECK_PAGED_CODE()                            \
{                                                              \
    if (AtalkPgLkSection[PPP_SECTION].ls_LockCount <= 0)       \
    {                                                          \
        DbgPrint("PPP code section not locked, count=%d\n",    \
            AtalkPgLkSection[PPP_SECTION].ls_LockCount);       \
        ASSERT(0);                                             \
    }                                                          \
}
#else
#define  DBG_ARAP_CHECK_PAGED_CODE()
#define  DBG_PPP_CHECK_PAGED_CODE()
#endif


#define ARAP_ID_BYTE1   0xAA
#define ARAP_ID_BYTE2   0xBB

#define PPP_ID_BYTE1    0xCC
#define PPP_ID_BYTE2    0xDD

typedef struct _ATCPCONN
{
    LIST_ENTRY                Linkage;
#if DBG
    DWORD                     Signature;
#endif
    DWORD                     Flags;             // general flag kind of info
    DWORD                     RefCount;          // memory freed when this goes to 0
    ATALK_NODEADDR            NetAddr;           // network address of the Arap client
    PVOID                     pDllContext;       // Araps context
    BYTE                      NdiswanHeader[14]; // 14 byte ethernet-like header
    ATALK_SPIN_LOCK           SpinLock;
    KEVENT                    NodeAcquireEvent;  // use while acquiring node (dynamic mode)
} ATCPCONN, *PATCPCONN;

#define ATCP_NODE_IN_USE        0x1
#define ATCP_FINDING_NODE       0x2
#define ATCP_SUPPRESS_RTMP      0x4
#define ATCP_SUPPRESS_ALLBCAST  0x8
#define ATCP_DLL_SETUP_DONE     0x10
#define ATCP_LINE_UP_DONE       0x20
#define ATCP_CONNECTION_UP      0x40
#define ATCP_CONNECTION_CLOSING 0x80

// globals

extern  struct _PORT_DESCRIPTOR  *RasPortDesc;

// spinlock to guard the all the Arap global things
extern  ATALK_SPIN_LOCK ArapSpinLock;

// global configuration info
extern  ARAPGLOB        ArapGlobs;

extern  PIRP            ArapSelectIrp;
extern  DWORD           ArapConnections;
extern  DWORD           ArapStackState;

extern  DWORD           PPPConnections;

#if DBG

extern  PIRP            ArapSniffIrp;
extern  ARAPSTATS       ArapStatistics;
extern  DWORD           ArapDumpLevel;
extern  DWORD           ArapDumpLen;
extern  DWORD           ArapDbgMnpSendSizes[30];
extern  DWORD           ArapDbgMnpRecvSizes[30];
extern  DWORD           ArapDbgArapSendSizes[15];
extern  DWORD           ArapDbgArapRecvSizes[15];
extern  LARGE_INTEGER   ArapDbgLastTraceTime;
extern  UCHAR           ArapDbgLRPacket[30];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\arapatk.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arapatk.c

Abstract:

	This module implements routines that directly interface with Atalk stack

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/

#define		ARAP_LOCALS
#include 	<atalk.h>
#pragma hdrstop

#define	FILENUM		ARAPATK

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_ARAP, ArapRoutePacketFromWan)
#pragma alloc_text(PAGE_ARAP, ArapRoutePacketToWan)
#pragma alloc_text(PAGE_ARAP, ArapOkToForward)
#pragma alloc_text(PAGE_ARAP, ArapAddArapRoute)
#pragma alloc_text(PAGE_ARAP, ArapDeleteArapRoute)
#pragma alloc_text(PAGE_ARAP, ArapGetDynamicAddr)
#pragma alloc_text(PAGE_ARAP, ArapGetStaticAddr)
#pragma alloc_text(PAGE_ARAP, ArapValidNetrange)
#pragma alloc_text(PAGE_ARAP, ArapZipGetZoneStat)
#pragma alloc_text(PAGE_ARAP, ArapZipGetZoneStatCompletion)
#endif


//***
//
// Function: ArapRoutePacketFromWan
//              This routine picks up a packet from the phone line and forwards
//              it on to the lan.  It does some "fixing up" of the packet so that
//              to the stack, it looks like any other packet from the lan
//
// Parameters:  pArapConn - connection element for whom data has come in
//              pArapBuf  - buffer containing the packet
//
// Return:      none
//
//***$

VOID
ArapRoutePacketFromWan(
    IN  PARAPCONN    pArapConn,
    IN  PARAPBUF     pArapBuf
)
{

    PBYTE   packet;
    USHORT  DataSize;
    USHORT  checksum;
    USHORT  RevNet;
    BYTE    RevNode;
    PBYTE   pZoneNamePtr;
    USHORT  BytesToZoneName=0;
    LONG    CurrentTime;


    DBG_ARAP_CHECK_PAGED_CODE();

    DBGDUMPBYTES("ArapRoutePacketFromWan:",&pArapBuf->Buffer[0], pArapBuf->DataSize,4);

    packet  = pArapBuf->CurrentBuffer;
    DataSize = pArapBuf->DataSize;

    ASSERT(packet[2] == 0x50);

    ASSERT(packet[3] == 0 && packet[4] == 0 && packet[5] == 2);

    // skip 3 bytes (past the SrpLen (2) and Dgroup (1) bytes)
    packet += ARAP_DATA_OFFSET;
    DataSize -= ARAP_DATA_OFFSET;

    //
    // see if we need to calculate the checksum.  The LAP header is 0's if
    // checksum is not included in the pkt, 1's otherwise.
    //
    checksum = 0;
    if (*packet == 1 && *(packet+1) == 1)
    {
        checksum = 1;
    }

    // skip the LAP header
    packet += ARAP_LAP_HDRSIZE;
    DataSize -= ARAP_LAP_HDRSIZE;


#if DBG
    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_RTMPRESPONSEORDATA)
    {
        DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	        ("ArapRoutePacketFromWan: got RTMPRESPONSEORDATA pkt!!\n"));
        ASSERT(0);
    }

    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_RTMPREQUEST)
    {
        DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	        ("ArapRoutePacketFromWan: got RTMPREQUEST pkt!!\n"));
        ASSERT(0);
    }

    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_ZIP)
    {
        DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	        ("ArapRoutePacketFromWan: got ZIP pkt!!\n"));
        ASSERT(0);
    }
#endif


    // fill in the length and checksum in the ddp header ("fix-up" ddp hdr)
    PUTSHORT2SHORT(&packet[LDDP_LEN_OFFSET], DataSize);
    PUTSHORT2SHORT(&packet[LDDP_CHECKSUM_OFFSET], 0);

    //
    // we need to "fix up" NBP requests.  If this is a BrRq request (Function=1,
    // and TupleCount=1), we need to patch up the datagram
    //
    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_NBP &&
        packet[LDDP_DGRAM_OFFSET] == ARAP_NBP_BRRQ)
    {

        //
        // let's treat nbp lookups as lower priority items!
        // if we have a lot of stuff sitting on the recv or the send the queue
        // then drop this nbp lookup broadcast (because otherwise it will only
        // generate more packets (and chooser won't deal with them anyway!)
        //
        if ((packet[LDDP_DEST_NODE_OFFSET] == ATALK_BROADCAST_NODE) &&
            ((pArapConn->SendsPending > ARAP_SENDQ_LOWER_LIMIT)  ||
             (pArapConn->RecvsPending > ARAP_SENDQ_LOWER_LIMIT)) )
        {
            DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	            ("ArapRoutePacketFromWan: dropping NBP bcast to lan (%d %d bytes)\n",
                    pArapConn->SendsPending,pArapConn->RecvsPending));
            return;
        }


#if 0

need to save old packet.  Drop this packet only if it compares with the old one
        If something changed (say zone name!), send the packet over even if it's less than
        5 sec.  Also, delta should be probably 35 or something (for 3 pkts)

        CurrentTime = AtalkGetCurrentTick();

        //
        // Chooser keeps sending the Brrq request out.  Cut it out!  If we have
        // sent a request out (on Mac's behalf) less than 5 seconds ago, drop this!
        //
        if (CurrentTime - pArapConn->LastNpbBrrq < 50)
        {
            DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	            ("ArapRoutePacketFromWan: dropping NBP_BRRQ (last %ld now %ld)\n",
                    pArapConn->LastNpbBrrq,CurrentTime));
            return;
        }

        pArapConn->LastNpbBrrq = CurrentTime;
#endif


#if 0
        // get to where the zone name is

        BytesToZoneName = ARAP_NBP_OBJLEN_OFFSET;

        // skip the object (along with the object len byte)
        BytesToZoneName += packet[ARAP_NBP_OBJLEN_OFFSET] + 1;

        // skip the type (along with the object len byte)
        BytesToZoneName += packet[BytesToZoneName] + 1;

        // this is where the zonelen field starts
        pZoneNamePtr = packet + BytesToZoneName;

        if (*pZoneNamePtr == 0 || *(pZoneNamePtr+1) == '*')
        {
            DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	            ("ArapRoutePacketFromWan: * zone name (%lx,%lx)\n",packet,pZoneNamePtr));
        }

#endif

        if (ArapGlobs.NetworkAccess)
        {
            //
            // if router is running, fix the packet so that the router thinks this
            // is a pkt from any other net client on the lan
            //
            if (AtalkDefaultPort->pd_Flags & PD_ROUTER_RUNNING)
            {
                RevNet  = AtalkDefaultPort->pd_RouterNode->an_NodeAddr.atn_Network;
                RevNode = AtalkDefaultPort->pd_RouterNode->an_NodeAddr.atn_Node;
            }

            //
            // router is not running.  Do we know who the router is?
            //
            else if (AtalkDefaultPort->pd_Flags & PD_SEEN_ROUTER_RECENTLY)
            {
                RevNet  = AtalkDefaultPort->pd_ARouter.atn_Network;
                RevNode = AtalkDefaultPort->pd_ARouter.atn_Node;
            }

            //
            // nope, send it to cable-wide bcast
            //
            else
            {
                // "fix-up" the nbp request
                packet[LDDP_DGRAM_OFFSET] = ARAP_NBP_LKRQ;

                RevNet  = CABLEWIDE_BROADCAST_NETWORK;
                RevNode = ATALK_BROADCAST_NODE;
            }
        }

        //
        // hmmm: client is not allowed to access network resources: just pretend
        // it's local broadcast, and pkt-forwarding logic will take care of it
        //
        else
        {
            // "fix-up" the nbp request
            packet[LDDP_DGRAM_OFFSET] = ARAP_NBP_LKRQ;

            RevNet  = CABLEWIDE_BROADCAST_NETWORK;
            RevNode = ATALK_BROADCAST_NODE;
        }

        PUTSHORT2SHORT(&packet[LDDP_DEST_NETWORK_OFFSET], RevNet);
        packet[LDDP_DEST_NODE_OFFSET] = RevNode;
    }

    if (checksum)
    {
        checksum = AtalkDdpCheckSumBuffer(packet, DataSize, 0);
        PUTSHORT2SHORT(&packet[LDDP_CHECKSUM_OFFSET], checksum);
    }

    AtalkDdpPacketIn(AtalkDefaultPort, NULL, packet, DataSize, TRUE);

}




//***
//
// Function: ArapRoutePacketToWan
//              This routine picks up a packet from the lan, checks to see if
//              it must be forwarded to any of the ARAP clients and does the
//              good deed.
//
// Parameters:  pDestAddr - who is this packet addressed to? (potentially bcast)
//              pSrcAddr  - who sent this packet
//              Protocol  - what packet is it? (ATP, NBP, etc.)
//              packet    - buffer containing the packet
//              PktLen    - how big is the packet
//              broadcast - is this a broadcast packet?
//              pDelivered - set on return: did we forward it to any dial-in
//                           client (set to TRUE only for directed dgrams)
//
// Return:      none
//
//***$

VOID
ArapRoutePacketToWan(
	IN  ATALK_ADDR	*pDestAddr,
	IN  ATALK_ADDR	*pSrcAddr,
    IN  BYTE         Protocol,
	IN	PBYTE		 packet,
	IN	USHORT		 PktLen,
    IN  BOOLEAN      broadcast,
    OUT PBOOLEAN     pDelivered
)
{

    KIRQL           OldIrql;
    PARAPCONN       pArapConn;
    PARAPCONN       pPrevArapConn;
    PLIST_ENTRY     pConnList;
    BUFFER_DESC     InBuffDesc;
    BUFFER_DESC     BuffDesc;
    BYTE            ArapHdr[ARAP_LAP_HDRSIZE + ARAP_HDRSIZE];
    PBYTE           pArapHdrPtr;
    ATALK_NODEADDR  DestNode;
    DWORD           StatusCode;
    DWORD           dwFlags;
    USHORT          SrpLen;
    DWORD           Priority;


    DBG_ARAP_CHECK_PAGED_CODE();

    // assume for now
    *pDelivered = FALSE;

    // no network access for dial-in guys?  don't send this out to them
    if (!ArapGlobs.NetworkAccess)
    {
        return;
    }

    //
    // if this is an RTMP or ZIP bcast, drop it since ARAP clients don't
    // care for these packets
    //

    if (broadcast)
    {
        if ((packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_RTMPREQUEST) ||
            (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_RTMPRESPONSEORDATA) )
        {
            DBGDUMPBYTES("ArapFrmLan: bcast pkt:",packet, LDDP_HDR_LEN+4,6);
            return;
        }

        if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_ZIP)
        {
            DBGDUMPBYTES("ArapFrmLan: bcast pkt:",packet, LDDP_HDR_LEN+4,6);
            return;
        }
    }

    //
    // this is a unicast: see if this addr belongs to an ARAP client
    //
    else
    {
        DestNode.atn_Network = pDestAddr->ata_Network;
        DestNode.atn_Node    = pDestAddr->ata_Node;

        pArapConn = FindAndRefArapConnByAddr(DestNode, &dwFlags);

        // no ARAP client for this dest. address?  Done here
        if (pArapConn == NULL)
        {
            return;
        }

        if (!(dwFlags & ARAP_CONNECTION_UP))
        {
            DerefArapConn(pArapConn);
            return;
        }
    }



    // setup a buffer descriptor for the incoming packet
    InBuffDesc.bd_Next = NULL;
    InBuffDesc.bd_Length = PktLen;
    InBuffDesc.bd_CharBuffer = packet;
    InBuffDesc.bd_Flags = BD_CHAR_BUFFER;

    //
    // setup the header
    //
    pArapHdrPtr = &ArapHdr[0];

    // don't count the 2 length bytes
    SrpLen = PktLen + ARAP_LAP_HDRSIZE + ARAP_HDRSIZE - sizeof(USHORT);

    PUTSHORT2SHORT(pArapHdrPtr, SrpLen);
    pArapHdrPtr += sizeof(USHORT);

    // the Dgroup byte
    *pArapHdrPtr++ = (ARAP_SFLAG_PKT_DATA | ARAP_SFLAG_LAST_GROUP);

    // the LAP hdr
    *pArapHdrPtr++ = 0;
    *pArapHdrPtr++ = 0;
    *pArapHdrPtr++ = 2;


    // setup a buffer descriptor for the header we are going to put
    BuffDesc.bd_Next = &InBuffDesc;
    BuffDesc.bd_Length = ARAP_LAP_HDRSIZE + ARAP_HDRSIZE;
    BuffDesc.bd_CharBuffer = &ArapHdr[0];
    BuffDesc.bd_Flags = BD_CHAR_BUFFER;


    //
    // if this datagram is not a broadcast, see if we can find a dial-in client
    // with this destination address
    //
    if (!broadcast)
    {
        //
        // ok, we found a connection: whether or not we actually give data to
        // him, let the caller know that we found who this data was meant for
        //
        *pDelivered = TRUE;

        //
        // some packets can't be sent to the dial-in client: how about this one?
        //
        if (!ArapOkToForward(pArapConn,packet,PktLen, &Priority))
        {
            DerefArapConn(pArapConn);
            return;
        }

        DBGDUMPBYTES("ArapRoutePacketToWan Directed Dgram:",packet,PktLen,4);

        //
        // ok, this packet is for the dial-in guy: send it
        //
        StatusCode = ArapSendPrepare(pArapConn, &BuffDesc, Priority);

        if (StatusCode == ARAPERR_NO_ERROR)
        {
            //  Send the packet(s)
            ArapNdisSend(pArapConn, &pArapConn->HighPriSendQ);
        }
        else
        {
            DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	            ("ArapRoutePacketToWan: (%lx) Prep failed %d\n",pArapConn,StatusCode));
        }

        // remove that refcount put in by FindAndRefArapConnByAddr
        DerefArapConn(pArapConn);

        return;
    }

    DBGDUMPBYTES("ArapRoutePacketToWan Broadcast Dgram:",packet,PktLen,4);


    //
    // it's a broadcast packet: must send it to all the dial-in guys
    //

    pArapConn = NULL;
    pPrevArapConn = NULL;

    while (1)
    {
        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        //
        // first, let's find the right connection to work on
        //
        while (1)
        {
            // if we're in the middle of the list, get to the next guy
            if (pArapConn != NULL)
            {
                pConnList = pArapConn->Linkage.Flink;
            }
            // we're just starting: get the guy at the head of the list
            else
            {
                pConnList = RasPortDesc->pd_ArapConnHead.Flink;
            }

            // finished all?
            if (pConnList == &RasPortDesc->pd_ArapConnHead)
            {
                RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

                if (pPrevArapConn)
                {
                    DerefArapConn(pPrevArapConn);
                }
                return;
            }

            pArapConn = CONTAINING_RECORD(pConnList, ARAPCONN, Linkage);

            // make sure this connection needs rcv processing
            ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

            //
            // if this connection is being disconnected, skip it
            //
            if (pArapConn->State >= MNP_LDISCONNECTING)
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_WARN,
		            ("ArapRoutePacketToWan: (%lx) invalid state %d, skipping\n",
                        pArapConn,pArapConn->State));

                RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

                // go try the next connection
                continue;
            }

            // let's make sure this connection stays around till we finish
            pArapConn->RefCount++;

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

            break;
        }

        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

        //
        // remove the refcount on the previous connection we put in earlier
        //
        if (pPrevArapConn)
        {
            DerefArapConn(pPrevArapConn);
        }

        ASSERT(pPrevArapConn != pArapConn);

        pPrevArapConn = pArapConn;


        //
        // if the connection isn't up yet, don't forward this
        // (note that we don't hold spinlock here, this being a hot path:
        // the worst that can happen is we'll drop a broadcast: big deal!)
        //
        if (!(pArapConn->Flags & ARAP_CONNECTION_UP))
        {
            continue;
        }


        //
        // is it ok for us send this packet to this client ?
        //
        if (!ArapOkToForward(pArapConn,packet,PktLen, &Priority))
        {
            continue;
        }

        StatusCode = ArapSendPrepare(pArapConn, &BuffDesc, Priority);

        if (StatusCode == ARAPERR_NO_ERROR)
        {
            //  Send the packet(s)
            ArapNdisSend(pArapConn, &pArapConn->HighPriSendQ);
        }
        else
        {
            DBGPRINT(DBG_COMP_ROUTER, DBG_LEVEL_ERR,
	            ("Arap...FromLan: (%lx) Arap..Prep failed %d\n",pArapConn,StatusCode));
        }

    }
}



//***
//
// Function: ArapOkToForward
//              This routine checks to see if we can (or must) forward this
//              packet to the dial-in client.  Certain packets (e.g. a bcast pkt
//              that originated from this client) shouldn't be sent back to the
//              client: this routine makes those checks.
//
// Parameters:  pArapConn - the connection in question
//              packet    - buffer containing the packet
//              packetLen - how big is the packet
//              pPriority - set on return:
//                            1 - all non-NBP data directed to this client
//                            2 - all NBP data directed to this client
//                            3 - all broadcast data
//
// Return:      TRUE if it's ok to (or if we must!) forward the packet,
//              FALSE otherwise
//
//***$

BOOLEAN
ArapOkToForward(
    IN  PARAPCONN   pArapConn,
    IN  PBYTE       packet,
    IN  USHORT      packetLen,
    OUT DWORD      *pPriority
)
{

    ATALK_NODEADDR  NetAddr;
    BOOLEAN         fBcastPkt=FALSE;
    BOOLEAN         fNbpPkt=FALSE;



    DBG_ARAP_CHECK_PAGED_CODE();

    GETSHORT2SHORT(&NetAddr.atn_Network, &packet[LDDP_SRC_NETWORK_OFFSET]);
    NetAddr.atn_Node = packet[LDDP_SRC_NODE_OFFSET];

    //
    // packet has client's own addr as DDP src addr?  if so, drop it
    //
    if (NODEADDR_EQUAL(&NetAddr, &pArapConn->NetAddr))
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
	        ("ArapOkToForward: dropping pkt: DDP src=client's addr (%lx)\n",pArapConn));

        return(FALSE);
    }


    if (packet[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_NBP)
    {
        fNbpPkt = TRUE;
    }

    if (packet[LDDP_DEST_NODE_OFFSET] == ATALK_BROADCAST_NODE)
    {
        fBcastPkt = TRUE;

        //
        // is this an nbp query packet?
        //
        if (fNbpPkt && (packet[LDDP_DGRAM_OFFSET] == 0x21))
        {
            GETSHORT2SHORT(&NetAddr.atn_Network, &packet[15]);
            NetAddr.atn_Node = packet[17];

            // originated from the client? if so, we shouldn't return this!
            if (NODEADDR_EQUAL(&NetAddr, &pArapConn->NetAddr))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
	                ("ArapOkToForward: dropping pkt originating from client!\n"));

                return(FALSE);
            }
        }
    }

    //
    // if this is a broadcast packet, then we drop it under certain conditions:
    // (no need for spinlock here: if we make a wrong decision, no big deal)
    //
    if (fBcastPkt)
    {

        // are in currently in the retransmit mode?  if so, drop this bcast pkt
        if (pArapConn->MnpState.RetransmitMode)
        {
            return(FALSE);
        }
        //
        // queue getting full? drop this broadcast packet to make room for more
        // important pkts
        //
        if (pArapConn->SendsPending >= ARAP_SENDQ_LOWER_LIMIT)
        {
            // make sure it's not gone negative..
            ASSERT(pArapConn->SendsPending < 0x100000);

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	            ("ArapOkToForward: (%lx) send getting full (%ld), dropping nbp pkt\n",
                    pArapConn,pArapConn->SendsPending));

            return(FALSE);
        }
    }


    //
    // now that we are forwarding the packet to the client, set the priority
    // right. All broadcast packets are lowest priority, no big deal if they are
    // delivered late (or never).  Nbp packets are usually for chooser: put them
    // after the directed data packets
    //

    if (fBcastPkt)
    {
        *pPriority = ARAP_SEND_PRIORITY_LOW;
    }
    else if (fNbpPkt)
    {
        *pPriority = ARAP_SEND_PRIORITY_MED;
    }
    else
    {
        *pPriority = ARAP_SEND_PRIORITY_HIGH;
    }


    return(TRUE);
}



//***
//
// Function: ArapGetDynamicAddr
//              This routine gets a network address for a dial-in client.
//              It does the same AARP logic as if it were acquiring a
//              node-address for the host itself.
//              This routine is called only if we are in the dynamic mode.
//
// Parameters:  pArapConn - the connection for which we need a network addr
//
// Return:      ARAPERR_NO_ERROR if all went well.
//
//***$

DWORD
ArapGetDynamicAddr(
    IN PARAPCONN       pArapConn
)
{
    ATALK_NODEADDR      NetAddr;
    ATALK_NETWORKRANGE  NetRange;
    BOOLEAN             fFound=FALSE;
    KIRQL               OldIrql;
    DWORD               StatusCode=ARAPERR_STACK_NOT_UP;



    DBG_ARAP_CHECK_PAGED_CODE();

    ASSERT(AtalkDefaultPort != NULL);

    //
    // go find a node address on the default port (we'll never get this far if
    // default port isn't up yet)
    //
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    ASSERT(!(pArapConn->Flags & ARAP_FINDING_NODE));

    pArapConn->Flags |= ARAP_FINDING_NODE;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    AtalkLockInitIfNecessary();

    // if we are stuck in the startup range, use that range for dial-in guys, too
    if (WITHIN_NETWORK_RANGE(AtalkDefaultPort->pd_NetworkRange.anr_LastNetwork,
                             &AtalkStartupNetworkRange))
    {
        NetRange = AtalkStartupNetworkRange;
    }
    else
    {
        NetRange = AtalkDefaultPort->pd_NetworkRange;
    }

    fFound = AtalkInitAarpForNodeInRange(AtalkDefaultPort,
                                         (PVOID)pArapConn,
                                         FALSE,
                                         NetRange,
                                         &NetAddr);

    AtalkUnlockInitIfNecessary();

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pArapConn->Flags &= ~ARAP_FINDING_NODE;

    if (fFound)
    {
        // store that adddr!
        pArapConn->NetAddr.atn_Network = NetAddr.atn_Network;
        pArapConn->NetAddr.atn_Node = NetAddr.atn_Node;

        pArapConn->Flags |= ARAP_NODE_IN_USE;
        StatusCode = ARAPERR_NO_ERROR;

	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
    	    ("ArapGetDynamicAddr: found addr for ARAP client = %lx %lx\n",
                NetAddr.atn_Network,NetAddr.atn_Node));
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	        ("ArapGetDynamicAddr: ARAP: no more network addr left?\n"));

        pArapConn->Flags &= ~ARAP_NODE_IN_USE;
        pArapConn->NetAddr.atn_Network = 0;
        pArapConn->NetAddr.atn_Node = 0;
        StatusCode = ARAPERR_NO_NETWORK_ADDR;
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    return(StatusCode);
}



//***
//
// Function: ArapZipGetZoneStat
//              This routine is called to find out the names (or number) of all
//              the zones on the network.
//
// Parameters:  pZoneStat - on return, we fill this structure in with the
//                          requested info (number and/or names of all the zones)
//              Request   - caller wants just the number of zones or names, too
//
// Return:      Nothing
//
//***$

VOID
ArapZipGetZoneStat(
    IN OUT PZONESTAT pZoneStat
)
{
    int                     i;
    PZONE                   pZone;
    DWORD                   NumZones;
    DWORD                   StatusCode;
	KIRQL	                OldIrql;
    PBYTE                   pBufPtr;
    PBYTE                   pAllocedBuf=NULL;
    DWORD                   BufferSize;
    DWORD                   BytesCopied;
    DWORD                   BytesNeeded;
    ATALK_ERROR             Status;
    PZIPCOMPLETIONINFO      pZci;
    PMDL                    pMdl=NULL;
    ACTREQ                  ActReq;
    ZIP_GETZONELIST_PARAMS  ZipParms;
    KEVENT                  ZoneComplEvent;


    DBG_ARAP_CHECK_PAGED_CODE();

    BufferSize = pZoneStat->BufLen;

    pBufPtr = &pZoneStat->ZoneNames[0];

    StatusCode = ARAPERR_NO_ERROR;
    BytesCopied = 0;
    NumZones = 0;

    if (AtalkDefaultPort->pd_Flags & PD_ROUTER_RUNNING)
    {
        BytesNeeded = 0;

	    ACQUIRE_SPIN_LOCK(&AtalkZoneLock, &OldIrql);

        for (i = 0; (i < NUM_ZONES_HASH_BUCKETS); i++)
        {
        	for (pZone = AtalkZonesTable[i]; pZone != NULL; pZone = pZone->zn_Next)
    	    {
                NumZones++;

                BytesNeeded += (pZone->zn_ZoneLen + 1);

                // if there is room, copy it in
                if (BufferSize >= BytesNeeded)
                {
                    RtlCopyMemory(pBufPtr,
                                  &pZone->zn_Zone[0],
                                  pZone->zn_ZoneLen);

                    pBufPtr += pZone->zn_ZoneLen;

                    *pBufPtr++ = '\0';

                    BytesCopied += (pZone->zn_ZoneLen + 1);
                }
                else
                {
                    StatusCode = ARAPERR_BUF_TOO_SMALL;
                    break;
                }
    	    }
        }

        RELEASE_SPIN_LOCK(&AtalkZoneLock, OldIrql);
    }

    //
    // we are not a router: send the request over to the A-router
    //
    else
    {
        BytesNeeded = BufferSize;

        pMdl = AtalkAllocAMdl(pBufPtr,BufferSize);
        if (pMdl == NULL)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapZipGetZoneStat: couldn't allocate Mdl\n"));

            StatusCode = ARAPERR_OUT_OF_RESOURCES;
            goto ArapZipGetZoneStat_Exit;
        }


        KeInitializeEvent(&ZoneComplEvent, NotificationEvent, FALSE);

        pZci = (PZIPCOMPLETIONINFO)AtalkAllocMemory(sizeof(ZIPCOMPLETIONINFO));
        if (pZci == NULL)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapZipGetZoneStat: couldn't allocate pZci\n"));

            StatusCode = ARAPERR_OUT_OF_RESOURCES;
            goto ArapZipGetZoneStat_Exit;
        }

        ZipParms.ZonesAvailable = 0;
        ActReq.ar_StatusCode = ARAPERR_NO_ERROR;

#if	DBG
        ActReq.ar_Signature = ACTREQ_SIGNATURE;
#endif
        ActReq.ar_pIrp = NULL;
        ActReq.ar_pParms = &ZipParms;
        ActReq.ar_pAMdl = NULL;
        ActReq.ar_MdlSize = 0;
        ActReq.ar_ActionCode = 0;
        ActReq.ar_DevType = 0;
        ActReq.ar_Completion = ArapZipGetZoneStatCompletion;
        ActReq.ar_CmplEvent = &ZoneComplEvent;
        ActReq.ar_pZci = (PVOID)pZci;


		// Initialize completion info
#if	DBG
		pZci->zci_Signature = ZCI_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pZci->zci_Lock);
		pZci->zci_RefCount = 1;
		pZci->zci_pPortDesc = AtalkDefaultPort;
		pZci->zci_pDdpAddr = NULL;
		pZci->zci_pAMdl = pMdl;
		pZci->zci_BufLen = BufferSize;
		pZci->zci_pActReq = &ActReq;
		pZci->zci_Router.ata_Network = AtalkDefaultPort->pd_ARouter.atn_Network;
		pZci->zci_Router.ata_Node = AtalkDefaultPort->pd_ARouter.atn_Node;
		pZci->zci_Router.ata_Socket = ZONESINFORMATION_SOCKET;
		pZci->zci_ExpirationCount = ZIP_GET_ZONEINFO_RETRIES;
		pZci->zci_NextZoneOff = 0;
		pZci->zci_ZoneCount = 0;
		pZci->zci_AtpRequestType = ZIP_GET_ZONE_LIST;
		AtalkTimerInitialize(&pZci->zci_Timer,
							 atalkZipZoneInfoTimer,
							 ZIP_GET_ZONEINFO_TIMER);

		pZci->zci_Handler = atalkZipGetZoneListReply;

        // completion routine will unlock
        AtalkLockZipIfNecessary();

		Status = atalkZipSendPacket(pZci, TRUE);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
					("ArapZipGetZoneStat: atalkZipSendPacket failed %ld\n", Status));
			pZci->zci_FinalStatus = Status;
			atalkZipDereferenceZci(pZci);
		}

        KeWaitForSingleObject(&ZoneComplEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        NumZones = ZipParms.ZonesAvailable;
        StatusCode = ActReq.ar_StatusCode;

        if (StatusCode == ARAPERR_BUF_TOO_SMALL)
        {
            BytesNeeded = (2*BufferSize);
        }

        BytesCopied = BufferSize;

        AtalkFreeAMdl(pMdl);
    }


ArapZipGetZoneStat_Exit:

    pZoneStat->NumZones = NumZones;
    pZoneStat->BufLen = BytesCopied;
    pZoneStat->BytesNeeded = BytesNeeded;

    pZoneStat->StatusCode = StatusCode;

}



//***
//
// Function: ArapZipGetZoneStatCompletion
//              This routine is the completion routine: after we get all the
//              responses for the zone query, this gets called.  Simply set an
//              event so the caller is unblocked
//
// Parameters:  pActReq - context
//
// Return:      Nothing
//
//***$

VOID
ArapZipGetZoneStatCompletion(
    IN ATALK_ERROR  ErrorCode,
    IN PACTREQ      pActReq
)
{

    PKEVENT                 pEvent;
    PZIPCOMPLETIONINFO      pZci;


    DBG_ARAP_CHECK_PAGED_CODE();

    if (ErrorCode != ATALK_NO_ERROR && ErrorCode != ATALK_BUFFER_TOO_SMALL)
    {
		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
			("ArapZipGetZoneStatCompletion: failure %lx\n", ErrorCode));
    }

    pZci = (PZIPCOMPLETIONINFO)(pActReq->ar_pZci);

    pEvent = pActReq->ar_CmplEvent;

    ASSERT((pZci->zci_FinalStatus == ATALK_NO_ERROR) ||
           (pZci->zci_FinalStatus == ATALK_BUFFER_TOO_SMALL));

    if (pZci->zci_FinalStatus == ATALK_NO_ERROR)
    {
        pActReq->ar_StatusCode = ARAPERR_NO_ERROR;
    }
    else if (pZci->zci_FinalStatus == ATALK_BUFFER_TOO_SMALL)
    {
        pActReq->ar_StatusCode = ARAPERR_BUF_TOO_SMALL;
    }
    else
    {
        pActReq->ar_StatusCode = ARAPERR_UNEXPECTED_RESPONSE;

		DBGPRINT(DBG_COMP_ZIP, DBG_LEVEL_ERR,
				("ArapZipGetZoneStat: failure %lx\n", pZci->zci_FinalStatus));
    }

    KeSetEvent(pEvent,IO_NETWORK_INCREMENT,FALSE);
}


#if ARAP_STATIC_MODE

//***
//
// Function: ArapGetStaticAddr
//              Get a network address for the remote client when we are
//              configured for static addressing
//              We represent every client as one bit: if the bit is on, the
//              corresponding address is taken, otherwise it's free.
//              So, 255 clients represented using 32 bytes.  Each pAddrMgmt
//              block represents 255 clients (scalability not a problem here!)
//
// Parameters:  pArapConn - connection element for the remote client in question
//
// Return:      status of the operation (ARAPERR_....)
//
//***$

DWORD
ArapGetStaticAddr(
    IN PARAPCONN  pArapConn
)
{
    KIRQL           OldIrql;
    PADDRMGMT       pAddrMgmt;
    PADDRMGMT       pPrevAddrMgmt;
    USHORT          Network;
    BYTE            Node;
    BOOLEAN         found=FALSE;
    BYTE            BitMask;
    DWORD           i;


    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered ArapGetStaticAddr (%lx)\n",pArapConn));

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    pAddrMgmt = ArapGlobs.pAddrMgmt;

    while (1)
    {
        Network = pAddrMgmt->Network;

        // see if there is any open slot.  255 nodes represented by 32x8 bits
        for (i=0; i<32; i++)
        {
            if (pAddrMgmt->NodeBitMap[i] != 0xff)
            {
                found = TRUE;
                break;
            }
        }

        if (found)
        {
            // find out the first bit in this byte that is off
            BitMask = 0x1;
            Node = 0;
            while (pAddrMgmt->NodeBitMap[i] & BitMask)
            {
                BitMask <<= 1;
                Node += 1;
            }

            // we are taking this node: set that bit!
            pAddrMgmt->NodeBitMap[i] |= BitMask;

            // now, account for all the previous bytes that were full
            Node += (BYTE)(i*8);

            break;
        }

        // all the nodes on this network are taken!  move to the next network
        pPrevAddrMgmt = pAddrMgmt;
        pAddrMgmt = pAddrMgmt->Next;

        // looks like we need to allocate the next network structure
        if (pAddrMgmt == NULL)
        {
            //
            // we just finished looking at the high end of the permissible network
            // range?  well, out of luck then!
            //
            if (Network == ArapGlobs.NetRange.HighEnd)
            {
                RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		            ("ArapGetStaticAddr: no more network addr left\n"));

                return(ARAPERR_NO_NETWORK_ADDR);
            }

            if ( (pAddrMgmt = AtalkAllocZeroedMemory(sizeof(ADDRMGMT))) == NULL)
            {
                RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		            ("ArapGetStaticAddr: alloc failed\n"));

                return(ARAPERR_OUT_OF_RESOURCES);
            }

            Network++;
            pAddrMgmt->Next = NULL;
            pAddrMgmt->Network = Network;
            pPrevAddrMgmt->Next = pAddrMgmt;

            Node = 1;
            //
            // node numbers 0 and 255 are reserved, so mark them as occupied.
            // Also, we just took node 1, so mark that as well
            //
            pAddrMgmt->NodeBitMap[0] |= (0x1 | 0x2);
            pAddrMgmt->NodeBitMap[31] |= 0x80;

            break;
        }

    }

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    // store that adddr!
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);
    pArapConn->NetAddr.atn_Network = Network;
    pArapConn->NetAddr.atn_Node = Node;
    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    return( ARAPERR_NO_ERROR );
}


//***
//
// Function: ArapAddArapRoute
//              If we are in the static mode of network address allocation, we
//              need to add a route in our table corresponding to the network
//              range allocated for the dial-in clients.
//              This routine does that.  In case of dynamic mode, it's a no-op.
//              This is a one-time thing, and we only do it when the first
//              connection comes in (instead of doing at startup).
//
// Parameters:  None
//
// Return:      None
//
//***$

VOID
ArapAddArapRoute(
    IN VOID
)
{

    ATALK_NETWORKRANGE  NwRange;
    KIRQL               OldIrql;
    BOOLEAN             fAddRoute = FALSE;


    DBG_ARAP_CHECK_PAGED_CODE();

    //
    // add a route only if router is enabled, and we are in the Static mode of
    // network allocation, and we haven't already added it
    //

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    if ((AtalkDefaultPort->pd_Flags & PD_ROUTER_RUNNING) &&
        (!ArapGlobs.DynamicMode) &&
        (!ArapGlobs.RouteAdded))
    {
        ArapGlobs.RouteAdded = TRUE;
        fAddRoute = TRUE;

        ASSERT(ArapConnections >= 1);
    }

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);


    if (fAddRoute)
    {
        NwRange.anr_FirstNetwork = ArapGlobs.NetRange.LowEnd;
        NwRange.anr_LastNetwork  = ArapGlobs.NetRange.HighEnd;

        atalkRtmpCreateRte(NwRange,
                           RasPortDesc,
                           &AtalkDefaultPort->pd_Nodes->an_NodeAddr,
                           0);
    }
}



//***
//
// Function: ArapDeleteArapRoute
//              If there is a routine called ArapAddArapRoute, we have got to
//              have a routine called ArapDeleteArapRoute.
//
// Parameters:  None
//
// Return:      None
//
//***$

VOID
ArapDeleteArapRoute(
    IN VOID
)
{

    KIRQL               OldIrql;
    BOOLEAN             fDeleteRoute = FALSE;


    DBG_ARAP_CHECK_PAGED_CODE();

    //
    // delete a route only if added it earlier and the connections went to 0
    //
    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);
    if (ArapGlobs.RouteAdded && ArapConnections == 0)
    {
        ArapGlobs.RouteAdded = FALSE;
        fDeleteRoute = TRUE;
    }
    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    if (fDeleteRoute)
    {
        atalkRtmpRemoveRte(ArapGlobs.NetRange.LowEnd);
    }

}



//***
//
// Function: ArapValidNetrange
//              This routine is called if we configured to be in the static
//              mode of addr allocation, when the dll first "binds" to us.
//              It verifies that the network range allocated by the admin is
//              valid and doesn't overlap with any of the network ranges known
//              to us through the route table.
//
// Parameters:  NetRange - the network range configured for dial-in clients
//
// Return:      TRUE if the range is valid,
//              FALSE if it overlaps with any of the existing network ranges
//
//***$

BOOLEAN
ArapValidNetrange(
    IN NETWORKRANGE NetRange
)
{
    BOOLEAN     fRangeIsValid=TRUE;
    KIRQL       OldIrql;
	PRTE	    pRte, pNext;
	int		    i;



    DBG_ARAP_CHECK_PAGED_CODE();

    if (NetRange.LowEnd == 0 || NetRange.HighEnd == 0)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapValidNetrange: Invalid network range\n"));
#if DBG
        DbgDumpNetworkNumbers();
#endif

        return(FALSE);
    }

    fRangeIsValid = TRUE;

	ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);

	for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
	{
		for (pRte = AtalkRoutingTable[i]; pRte != NULL; pRte = pNext)
		{
			pNext = pRte->rte_Next;

			ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);

            if ( (IN_NETWORK_RANGE(NetRange.LowEnd,pRte)) ||
                 (IN_NETWORK_RANGE(NetRange.HighEnd,pRte)) )
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapValidNetrange: range in conflict\n"));

                fRangeIsValid = FALSE;
                RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
                break;
            }

            RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
		}

        if (!fRangeIsValid)
        {
            break;
        }
	}

	RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);

#if DBG
    if (!fRangeIsValid)
    {
        DbgDumpNetworkNumbers();
    }
#endif

    return(fRangeIsValid);
}
#endif //ARAP_STATIC_MODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\arapndis.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arap.c

Abstract:

	This module implements routines specific to ARAP

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/

#include 	<atalk.h>
#pragma hdrstop

#define	FILENUM		ARAPNDIS

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_ARAP, ArapRcvIndication)
#pragma alloc_text(PAGE_ARAP, ArapNdisSend)
#pragma alloc_text(PAGE_ARAP, ArapNdisSendComplete)
#pragma alloc_text(PAGE_ARAP, ArapGetNdisPacket)
#endif


//***
//
// Function: ArapRcvIndication
//              This routine is called whenever Ndis calls the stack to indicate
//              data on a port.  We find out our context (pArapConn) from the
//              the 'fake' ethernet header that NdisWan cooks up.
//
// Parameters:  pArapConn - connection element for whom data has come in
//              LkBuf - buffer containing the (most likely, compressed) data
//              LkBufSize - size of the lookahead buffer
//
// Return:      none
//
// NOTE:        NdisWan always gives the entire buffer as the lookahead buffer,
//              and we rely on that fact!
//***$


VOID
ArapRcvIndication(
    IN PARAPCONN    pArapConn,
    IN PVOID        LkBuf,
    IN UINT         LkBufSize
)
{

    BYTE            MnpFrameType;
    BYTE            SeqNum = (BYTE)-1;
    BYTE            LastAckRcvd;
    BOOLEAN         fCopyPacket;
    BOOLEAN         fValidPkt;
    BOOLEAN         fMustAck;
    PLIST_ENTRY     pSendList;
    PLIST_ENTRY     pRecvList;
    PMNPSENDBUF     pMnpSendBuf;
    PARAPBUF        pArapBuf;
    PARAPBUF        pFirstArapBuf=NULL;
    BOOLEAN         fLessOrEqual;
    BOOLEAN         fAcceptPkt;
    BOOLEAN         fGreater;
    DWORD           DecompressedDataLen;
    DWORD           dwDataOffset=0;
    DWORD           dwFrameOverhead=0;
    DWORD           dwMaxAcceptableLen;
    DWORD           StatusCode;
    BOOLEAN         fSendLNAck=FALSE;
    BYTE            ClientCredit;
    BYTE            AttnType;
    BYTE            LNSeqToAck;
    DWORD           BufSizeEstimate;
    DWORD           DecompSize;
    DWORD           BytesDecompressed;
    DWORD           BytesToDecompress;
    DWORD           BytesRemaining;
    PBYTE           CompressedDataBuf;
    BYTE            BitMask;
    BYTE            RelSeq;



    DBG_ARAP_CHECK_PAGED_CODE();

    DBGDUMPBYTES("ArapRcvInd pkt rcvd: ",LkBuf,LkBufSize,3);

    //
    // we're at indicate time, so dpc
    //
    ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

    //
    // if the connection is going away, drop the packet
    //
    if ( (pArapConn->State == MNP_IDLE) || (pArapConn->State > MNP_UP) )
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapRcvIndication: invalid state = %d, returning (%lx %lx)\n",
                pArapConn,pArapConn->State));

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        return;
    }

    // one more frame came in
    pArapConn->StatInfo.FramesRcvd++;

    //
    // if a dup LR comes in, SynByte, DleByte etc. aren't set yet, and we hit
    // this assert. just check to see if we are in MNP_RESPONSE state
    //
    ASSERT( ((((PUCHAR)LkBuf)[0] == pArapConn->MnpState.SynByte) &&
             (((PUCHAR)LkBuf)[1] == pArapConn->MnpState.DleByte) &&
             (((PUCHAR)LkBuf)[2] == pArapConn->MnpState.StxByte) &&
             (((PUCHAR)LkBuf)[LkBufSize-4] == pArapConn->MnpState.DleByte) &&
             (((PUCHAR)LkBuf)[LkBufSize-3] == pArapConn->MnpState.EtxByte)) ||
            (pArapConn->State == MNP_RESPONSE) );

    ARAP_DBG_TRACE(pArapConn,30105,LkBuf,LkBufSize,0,0);

    // we just heard from the client: "reset" the inactivity timer
    pArapConn->InactivityTimer = pArapConn->T403Duration + AtalkGetCurrentTick();

    MnpFrameType = ((PUCHAR)LkBuf)[MNP_FRMTYPE_OFFSET];

    if ( MnpFrameType == MNP_LT_V20CLIENT )
    {
        MnpFrameType = (BYTE)MNP_LT;
    }

    fCopyPacket = FALSE;
    fValidPkt = TRUE;
    fMustAck = FALSE;

    dwDataOffset = 3;      // at the least, we'll ignore the 3 start flag bytes
    dwFrameOverhead = 7;   // at the least, ignore 3 start, 2 stop, 2 crc bytes

    switch(MnpFrameType)
    {
        //
        // if this is a duplicate LT frame, don't waste time decompressing and
        // copying (also, make sure we have room to accept this packet!)
        //
        case MNP_LT:

            fValidPkt = FALSE;

            if (LkBufSize < (UINT)LT_MIN_LENGTH(pArapConn))
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapRcv: (%lx) LT pkt, but length invalid: dropping!\n",pArapConn));
                ASSERT(0);
                break;
            }

            SeqNum = LT_SEQ_NUM((PBYTE)LkBuf, pArapConn);

            MNP_DBG_TRACE(pArapConn,SeqNum,(0x10|MNP_LT));

            dwMaxAcceptableLen = (pArapConn->BlockId == BLKID_MNP_SMSENDBUF) ?
                                    MNP_MINPKT_SIZE : MNP_MAXPKT_SIZE;

            if ((pArapConn->State == MNP_UP) &&
                (pArapConn->MnpState.RecvCredit > 0) )
            {
                LT_OK_TO_ACCEPT(SeqNum, pArapConn, fAcceptPkt);

                if (fAcceptPkt)
                {
                    fCopyPacket = TRUE;

                    fValidPkt = TRUE;

                    dwDataOffset = LT_SRP_OFFSET(pArapConn);
                    dwFrameOverhead = LT_OVERHEAD(pArapConn);

                    // make sure the packet isn't too big (in other words,invalid!)
                    if (LkBufSize-dwFrameOverhead > dwMaxAcceptableLen)
                    {
                        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                            ("ArapInd: (%lx) too big a pkt (%d vs %d), dropped\n",
                                pArapConn,LkBufSize-dwFrameOverhead,dwMaxAcceptableLen));

                        fValidPkt = FALSE;
                    }

                    pArapConn->MnpState.HoleInSeq = FALSE;
                }
                else
                {
                    //
                    // packet is valid, just not in the right sequence (make note
                    // of that or else we'll send out an ack!)
                    //
                    fValidPkt = TRUE;

                    //
                    // did we get an out-of-sequence packet (e.g. we lost B5,
                    // so we're still expecting B5 but B6 came in)
                    //
                    LT_GREATER_THAN(SeqNum,
                                    pArapConn->MnpState.NextToReceive,
                                    fGreater);
                    if (fGreater)
                    {
                        //
                        // we have already sent an ack out when we first got
                        // this hole: don't send ack again
                        //
                        if (pArapConn->MnpState.HoleInSeq)
                        {
                            fMustAck = FALSE;
                        }
                        else
                        {
                            pArapConn->MnpState.HoleInSeq = TRUE;

                            fMustAck = TRUE;

                            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                                ("ArapRcvInd: (%lx) got a hole, dropping seq=%x vs. %x\n",
                                    pArapConn, SeqNum, pArapConn->MnpState.NextToReceive));
                        }

                        break;
                    }

                    //
                    // spec says that we must ignore the first duplicate of any
                    // seq.  What happens most often when we receive a duplicate is
                    // that the Mac sends the whole window full of dups.  e.g. if
                    // seq num B1 is retransmitted then Mac will also retransmit
                    // B2, .. B8.  We should ignore all of them, but if we get B1
                    // (or anything upto B8) again, then we must send out an ack.
                    //

                    //
                    // is this the first time (since we successfully received a
                    // new frame) that we are getting a dup?  If so, we must find
                    // out what's the smallest seq number we can get as a dup
                    //
                    if (!pArapConn->MnpState.ReceivingDup)
                    {
                        //
                        // e.g. if we're expecting seq 79 then 0x71 is the
                        // smallest dup that we can get (for window size = 8)
                        //
                        if (pArapConn->MnpState.NextToReceive >=
                            pArapConn->MnpState.WindowSize)
                        {
                            pArapConn->MnpState.FirstDupSeq =
                                (pArapConn->MnpState.NextToReceive -
                                 pArapConn->MnpState.WindowSize);
                        }

                        //
                        // e.g. if we're expecting seq 3 then 0xfb is the
                        // smallest dup that we can get (for window size = 8)
                        //
                        else
                        {
                            pArapConn->MnpState.FirstDupSeq =
                                (0xff -
                                (pArapConn->MnpState.WindowSize -
                                 pArapConn->MnpState.NextToReceive) +
                                 1);
                        }

                        pArapConn->MnpState.ReceivingDup = TRUE;
                        pArapConn->MnpState.DupSeqBitMap = 0;
                        RelSeq = 0;
                    }

                    //
                    // find the relative seq number (relative to the first dup)
                    //
                    if (SeqNum >= pArapConn->MnpState.FirstDupSeq)
                    {
                        RelSeq = (SeqNum - pArapConn->MnpState.FirstDupSeq);
                    }
                    else
                    {
                        RelSeq = (0xff - pArapConn->MnpState.FirstDupSeq) +
                                 SeqNum;
                    }

                    //
                    // 8-frame window: relseq can be 0 through 7
                    //
                    if (RelSeq >= 8)
                    {
                        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                            ("ArapRcvInd: (%lx) RelSeq > 8!! (%x %x %x)\n",
                                pArapConn, SeqNum, pArapConn->MnpState.FirstDupSeq,
                                pArapConn->MnpState.DupSeqBitMap));

                        fMustAck = TRUE;
                        break;
                    }

                    BitMask = (1 << RelSeq);

                    //
                    // is this a second (or more) retransmission of this seq num?
                    //
                    if (pArapConn->MnpState.DupSeqBitMap & BitMask)
                    {
                        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                            ("ArapRcvInd: (%lx) dup pkt, seq=%x vs. %x (%x)\n",
                                pArapConn, SeqNum, pArapConn->MnpState.FirstDupSeq,
                                pArapConn->MnpState.DupSeqBitMap));

                        fMustAck = TRUE;
                    }

                    //
                    // no, this is the first time: don't send out an ack
                    //
                    else
                    {
                        pArapConn->MnpState.DupSeqBitMap |= BitMask;

                        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                            ("ArapRcvInd: (%lx) first dup pkt, seq=%x vs. %x (%x)\n",
                                pArapConn, SeqNum, pArapConn->MnpState.FirstDupSeq,
                                pArapConn->MnpState.DupSeqBitMap));
                    }
                }
            }
            else
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapInd: (%lx) pkt dropped (state %ld, credit %ld)\n",
                    pArapConn,pArapConn->State,pArapConn->MnpState.RecvCredit));
            }

            break;

        //
        // we got an ACK: process it
        //
        case MNP_LA:

            if (LkBufSize < (UINT)LA_MIN_LENGTH(pArapConn))
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapRcv: (%lx) LA pkt, but length invalid: dropping!\n",pArapConn));
                ASSERT(0);
                break;
            }

            // client's receive credit (it's our send credit)
            ClientCredit = LA_CREDIT((PBYTE)LkBuf, pArapConn);

            ASSERT((pArapConn->State == MNP_UP) || (pArapConn->State == MNP_RESPONSE));

            // last pkt the client recvd successfully from us
            LastAckRcvd = LA_SEQ_NUM((PBYTE)LkBuf, pArapConn);

            MNP_DBG_TRACE(pArapConn,LastAckRcvd,(0x10|MNP_LA));

            //
            // in the normal case, the ack we got should be for a bigger seq num
            // than the one we got earlier.
            // (special case the MNP_RESPONSE state to complete conn setup)
            //
            LT_GREATER_THAN(LastAckRcvd,pArapConn->MnpState.LastAckRcvd,fGreater);

            if (fGreater || (pArapConn->State == MNP_RESPONSE))
            {
                pArapConn->MnpState.LastAckRcvd = LastAckRcvd;

                //
                // remove all the sends upto and including LastAckRcvd and put
                // them on SendAckedQ so that RcvCompletion can finish up the job
                //
                ASSERT(!IsListEmpty(&pArapConn->RetransmitQ));

                ASSERT(pArapConn->SendsPending > 0);

                //
                // if we sent a response to LR and were waiting for client's
                // ack, this is it!  (RcvCompletion will do the remaining work)
                //
                if (pArapConn->State == MNP_RESPONSE)
                {
                    pArapConn->State = MNP_UP;
                    pArapConn->MnpState.NextToReceive = 1;
                    pArapConn->MnpState.NextToProcess = 1;
                    pArapConn->MnpState.NextToSend = 1;

                    pArapConn->FlowControlTimer = AtalkGetCurrentTick() +
                                                    pArapConn->T404Duration;
                }

                //
                // remove all the sends that are now acked with this ack from the
                // retransmit queue
                //
                while (1)
                {
                    pSendList = pArapConn->RetransmitQ.Flink;

                    // no more sends left on the retransmit queue? if so, done
                    if (pSendList == &pArapConn->RetransmitQ)
                    {
                        break;
                    }

                    pMnpSendBuf = CONTAINING_RECORD(pSendList,MNPSENDBUF,Linkage);

                    LT_LESS_OR_EQUAL(pMnpSendBuf->SeqNum,LastAckRcvd,fLessOrEqual);

                    if (fLessOrEqual)
                    {
                        ASSERT(pArapConn->SendsPending >= pMnpSendBuf->DataSize);

                        RemoveEntryList(&pMnpSendBuf->Linkage);

	                    InsertTailList(&pArapConn->SendAckedQ,
				                       &pMnpSendBuf->Linkage);

                        ASSERT(pArapConn->MnpState.UnAckedSends >= 1);

                        pArapConn->MnpState.UnAckedSends--;
                    }
                    else
                    {
                        // all other sends have higher seq nums: done here
                        break;
                    }
                }

                //
                // if we were in the retransmit mode and the retransmit Q is
                // now empty, get out of retransmit mode!
                //
                if (pArapConn->MnpState.RetransmitMode)
                {
                    if (pArapConn->MnpState.UnAckedSends == 0)
                    {
                        pArapConn->MnpState.RetransmitMode = FALSE;
                        pArapConn->MnpState.MustRetransmit = FALSE;

                        // in case we had gone on a "exponential backoff", reset it
                        pArapConn->SendRetryTime = pArapConn->SendRetryBaseTime;

		                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
			                ("ArapRcvInd: ack %x for xmitted pkt, out of re-xmit mode\n",
                            LastAckRcvd));
                    }
                    else
                    {
		                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
			                ("ArapRcvInd: ack %x for xmitted pkt, still %d more\n",
                            LastAckRcvd,pArapConn->MnpState.UnAckedSends));

                        pArapConn->MnpState.MustRetransmit = TRUE;
                    }
                }
            }

            //
            // the ack we got is for the same seq num as we got earlier: we need
            // to retransmit the send we were hoping this ack was for!
            //
            else
            {
                if (!IsListEmpty(&pArapConn->RetransmitQ))
                {
                    pArapConn->MnpState.RetransmitMode = TRUE;
                    pArapConn->MnpState.MustRetransmit = TRUE;

		            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
			            ("\nArapRcvInd: ack %x again, (%d pkts) entering re-xmit mode\n",
                        LastAckRcvd,pArapConn->MnpState.UnAckedSends));
                }
            }

            ASSERT(pArapConn->MnpState.UnAckedSends <= pArapConn->MnpState.WindowSize);

            //
            // spec says our credit is what the client tells us minus the number
            // of unacked sends on our Q.
            //
            //
            if (ClientCredit > pArapConn->MnpState.UnAckedSends)
            {
                ASSERT((ClientCredit - pArapConn->MnpState.UnAckedSends) <= pArapConn->MnpState.WindowSize);

                pArapConn->MnpState.SendCredit =
                    (ClientCredit - pArapConn->MnpState.UnAckedSends);
            }

            //
            // But if the client tells us say 3 and we have 4 sends pending,
            // be conservative and close the window until sends get cleared up
            //
            else
            {
                pArapConn->MnpState.SendCredit = 0;
            }

            break;

        //
        // if we sent an LR response, this must be a retry by client: retransmit
        // our response.  If we sent in the request (in case of callback) then
        // this is the response: send the ack
        //
        case MNP_LR:

            MNP_DBG_TRACE(pArapConn,0,(0x10|MNP_LR));

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRcvInd: got LR pkt on %lx, state=%d\n",
                    pArapConn,pArapConn->State));

            if (pArapConn->State == MNP_RESPONSE)
            {
		        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			        ("ArapRcvInd: excuse me?  got an LR! (setting reX)\n"));

                pArapConn->MnpState.RetransmitMode = TRUE;
                pArapConn->MnpState.MustRetransmit = TRUE;
            }
            else if (pArapConn->State == MNP_REQUEST)
            {
                //
                // we got an LR response to our LR request (we are doing callback)
                // Make sure all the parms that the dial-in client gives are ok
                // with us, and configure pArapConn appropriately
                //
                StatusCode = PrepareConnectionResponse( pArapConn,
                                                        LkBuf,
                                                        LkBufSize,
                                                        NULL,
                                                        NULL);
                if (StatusCode == ARAPERR_NO_ERROR)
                {
                    pArapConn->State = MNP_UP;
                    pArapConn->MnpState.NextToReceive = 1;
                    pArapConn->MnpState.NextToProcess = 1;
                    pArapConn->MnpState.NextToSend = 1;

                    pArapConn->FlowControlTimer = AtalkGetCurrentTick() +
                                                    pArapConn->T404Duration;

                    pSendList = pArapConn->RetransmitQ.Flink;

                    // treat the connection request as a send here
                    if (pSendList != &pArapConn->RetransmitQ)
                    {
                        pMnpSendBuf = CONTAINING_RECORD(pSendList,
                                                        MNPSENDBUF,
                                                        Linkage);

                        RemoveEntryList(&pMnpSendBuf->Linkage);

	                    InsertTailList(&pArapConn->SendAckedQ,
				                       &pMnpSendBuf->Linkage);

                        ASSERT(pArapConn->MnpState.UnAckedSends >= 1);

                        pArapConn->MnpState.UnAckedSends--;
                    }
                    else
                    {
		                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			                ("ArapRcvInd: (%lx) can't find LR request\n",pArapConn));
                        ASSERT(0);
                    }

                    fMustAck = TRUE;
                }
                else
                {
		            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			            ("ArapRcvInd: (%lx) invalid LR response %ld\n",
                            pArapConn,StatusCode));
                }
            }
            else
            {
                fValidPkt = FALSE;
            }

            break;

        //
        // remote sent a disconnect request.  Though we'll process it at
        // RcvCompletion time, mark it so that we don't attempt send/recv anymore
        //
        case MNP_LD:

            MNP_DBG_TRACE(pArapConn,0,(0x10|MNP_LD));

            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRcvIndication: recvd disconnect from remote on (%lx)\n",pArapConn));

            pArapConn->State = MNP_RDISC_RCVD;
            fCopyPacket = TRUE;

            break;

        //
        // remote sent a Link Attention request.  See what we need to do
        //
        case MNP_LN:

            if (LkBufSize < (dwDataOffset+LN_MIN_LENGTH))
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapRcv: (%lx) LN pkt, but length invalid: dropping!\n",pArapConn));
                ASSERT(0);
                break;
            }

            MNP_DBG_TRACE(pArapConn,0,(0x10|MNP_LN));

            AttnType = LN_ATTN_TYPE((PBYTE)LkBuf+dwDataOffset);

            LNSeqToAck = LN_ATTN_SEQ((PBYTE)LkBuf+dwDataOffset);

            //
            // is this a destructive type LN frame?  Treat this as a LD frame so
            // that we disconnect and cleanup the connection
            //
            if (AttnType == LN_DESTRUCTIVE)
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapRcv: (%lx) got an LN pkt, sending LNAck!\n",pArapConn));

                pArapConn->State = MNP_RDISC_RCVD;
            }

            //
            // ok, he just wants to know if we are doing ok: tell him so
            //
            else
            {
                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapRcv: (%lx) got an LN pkt, sending LNAck!\n",pArapConn));

                fSendLNAck = TRUE;
            }

            break;

        //
        // we only ack an LN packet, but never generate an LN packet
        // so we should never get this LNA packet.  Quietly drop it.
        //
        case MNP_LNA:

            MNP_DBG_TRACE(pArapConn,0,(0x10|MNP_LNA));

            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRcv: (%lx) got LNA. Now, when did we send LN??\n",pArapConn));

            break;

        default:

            MNP_DBG_TRACE(pArapConn,0,MnpFrameType);

            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapRcvIndication: (%lx) dropping packet with unknown type %d\n",
                    pArapConn,MnpFrameType));

            break;
    }

    //
    // if it's a packet that we don't need to copy (e.g. ack) then we're done here.
    // Also, if it's an invalid pkt (e.g. out of seq packet) then we must send an ack
    //
    if ((!fCopyPacket) || (!fValidPkt))
    {
        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)

        //
        // if we got an invalid packet or if we have a condition where we must ack,
        // do the needful
        //
        if (!fValidPkt || fMustAck)
        {
            MnpSendAckIfReqd(pArapConn, TRUE);
        }
        else if (fSendLNAck)
        {
            MnpSendLNAck(pArapConn, LNSeqToAck);
        }

        return;
    }

    //
    // if it's not an LT packet, treat it separately
    //
    if (MnpFrameType != MNP_LT)
    {
        // right now LD is the only packet we put on the Misc Q
        ASSERT(MnpFrameType == MNP_LD);

        ARAP_GET_RIGHTSIZE_RCVBUF((LkBufSize-dwFrameOverhead), &pArapBuf);
        if (pArapBuf == NULL)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapInd: (%lx) alloc failed, dropping packet (type=%x, seq=%x)\n",
                pArapConn,MnpFrameType,SeqNum));

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)
            return;
        }

	    TdiCopyLookaheadData( &pArapBuf->Buffer[0],
                              (PUCHAR)LkBuf+dwDataOffset,
                              LkBufSize-dwFrameOverhead,
                              TDI_RECEIVE_COPY_LOOKAHEAD);

        pArapBuf->MnpFrameType = MnpFrameType;
        pArapBuf->DataSize = (USHORT)(LkBufSize-dwFrameOverhead);

	    InsertTailList(&pArapConn->MiscPktsQ, &pArapBuf->Linkage);

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)
        return;
    }


    //
    // ok, we're dealing with the LT packet (the most common packet)
    //

    // reset the flow control timer
    pArapConn->FlowControlTimer = AtalkGetCurrentTick() + pArapConn->T404Duration;


    // update the receive state...

    ASSERT(pArapConn->MnpState.UnAckedRecvs <= pArapConn->MnpState.WindowSize);

    pArapConn->MnpState.UnAckedRecvs++;

    // set LastSeqRcvd to what we received successfully just now
    pArapConn->MnpState.LastSeqRcvd = pArapConn->MnpState.NextToReceive;

    // successfully rcvd the expected packet.  Update to next expected
    ADD_ONE(pArapConn->MnpState.NextToReceive);

    //
    // if the 402 timer isn't already "running", "start" it
    // Also, shut the flow-control timer: starting T402 timer here will ensure
    // that ack goes out, and at that time we'll restart the flow-control timer
    //
    if (pArapConn->LATimer == 0)
    {
        pArapConn->LATimer = pArapConn->T402Duration + AtalkGetCurrentTick();
        pArapConn->FlowControlTimer = 0;
    }

    //
    // 0-length data is not permissible
    // (for some reason, Mac sends a 0-datalength frame: for now, we'll
    // "accept" the frame, though we can't do anything with it!)
    //
    if ((LkBufSize-dwFrameOverhead) == 0)
    {
        ARAP_DBG_TRACE(pArapConn,30106,LkBuf,LkBufSize,0,0);

        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
           ("ArapInd: (%lx) is the client on drugs?  it's sending 0-len data!\n",pArapConn));

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)

        return;
    }


    pFirstArapBuf = NULL;

    BytesToDecompress  = (DWORD)LkBufSize-dwFrameOverhead;
    CompressedDataBuf = (PUCHAR)LkBuf+dwDataOffset;

    DecompressedDataLen = 0;

    //
    // for now, assume decompressed data will be 4 times the compressed size
    // (if that assumption isn't true, we'll alloc more again)
    //
    BufSizeEstimate = (BytesToDecompress << 2);

    if (!(pArapConn->Flags & MNP_V42BIS_NEGOTIATED))
    {
        BufSizeEstimate = BytesToDecompress;
    }

    while (1)
    {
        // get a receive buffer for this size
        ARAP_GET_RIGHTSIZE_RCVBUF(BufSizeEstimate, &pArapBuf);

        if (pArapBuf == NULL)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapInd: (%lx) %d bytes alloc failed, dropping seq=%x\n",
                    pArapConn,BufSizeEstimate,SeqNum));

            //
            // if we put any stuff on the queue for this MNP packet, remove
            // them all: we can't have a partially decompressed packet!
            //
            if (pFirstArapBuf)
            {
                pRecvList = &pFirstArapBuf->Linkage;

                while (pRecvList != &pArapConn->ReceiveQ)
                {
                    RemoveEntryList(pRecvList);

                    pArapBuf = CONTAINING_RECORD(pRecvList,ARAPBUF,Linkage);

                    ARAP_FREE_RCVBUF(pArapBuf);

                    pRecvList = pRecvList->Flink;
                }
            }

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)

            // force ack so the client gets a hint that we dropped a pkt
            MnpSendAckIfReqd(pArapConn, TRUE);

            return;
        }

        if (!pFirstArapBuf)
        {
            pFirstArapBuf = pArapBuf;
        }

        //
        // ok, do that v42bis decompression thing if v42bis is negotiated
        //
        if (pArapConn->Flags & MNP_V42BIS_NEGOTIATED)
        {
            StatusCode = v42bisDecompress(
                                pArapConn,
                                CompressedDataBuf,
                                BytesToDecompress,
                                pArapBuf->CurrentBuffer,
                                pArapBuf->BufferSize,
                                &BytesRemaining,
                                &DecompSize);
        }

        //
        // v42bis is not negotiated: skip decompression
        //
        else
        {
            if (BytesToDecompress)
            {
	            TdiCopyLookaheadData( &pArapBuf->Buffer[0],
                                      (PUCHAR)LkBuf+dwDataOffset,
                                      BytesToDecompress,
                                      TDI_RECEIVE_COPY_LOOKAHEAD);
            }

            DecompSize = BytesToDecompress;
            StatusCode = ARAPERR_NO_ERROR;
        }

        ASSERT((StatusCode == ARAPERR_NO_ERROR) ||
               (StatusCode == ARAPERR_BUF_TOO_SMALL));

        if ((StatusCode != ARAPERR_NO_ERROR) &&
            (StatusCode != ARAPERR_BUF_TOO_SMALL))
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapInd: (%lx) v42bisDecompress returned %lx, dropping pkt\n",
                    pArapConn,StatusCode));

            ASSERT(0);

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock)

            // force ack so the client gets a hint that we dropped a pkt
            MnpSendAckIfReqd(pArapConn, TRUE);

            return;
        }

        //
        // if we got any bytes decompressed, put them on the queue
        //
        if (DecompSize > 0)
        {
            ASSERT(pArapBuf->BufferSize >= DecompSize);

            pArapBuf->DataSize = (USHORT)DecompSize;

            // Debug only: make sure q looks ok before we put this stuff on the q
            ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);

            // queue these bytes on to the ReceiveQ
	        InsertTailList(&pArapConn->ReceiveQ, &pArapBuf->Linkage);

            // Debug only: make sure q looks ok after we put this stuff on the q
            ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);
        }

        DecompressedDataLen += DecompSize;

        // are we done decompressing?
        if (StatusCode == ARAPERR_NO_ERROR)
        {
            //
            // if there was no output data and there was no error, we didn't
            // really need this buffer.
            //
            if (DecompSize == 0)
            {
                ARAP_FREE_RCVBUF(pArapBuf);
            }

            break;
        }


        //
        // ok, we're here because our assumption about how big a buffer we
        // needed for decompression wasn't quite right: we must decompress the
        // remaining bytes now
        //

        BytesDecompressed = (BytesToDecompress - BytesRemaining);
        BytesToDecompress = BytesRemaining;
        CompressedDataBuf += BytesDecompressed;

        //
        // we ran out of room:double our initial estimate
        //
        BufSizeEstimate <<= 1;
    }

    ARAP_DBG_TRACE(pArapConn,30110,pFirstArapBuf,DecompressedDataLen,0,0);

    // update statitics on incoming bytes:
    pArapConn->StatInfo.BytesRcvd += (DWORD)LkBufSize;
    pArapConn->StatInfo.BytesReceivedCompressed += ((DWORD)LkBufSize-dwFrameOverhead);
    pArapConn->StatInfo.BytesReceivedUncompressed += DecompressedDataLen;

#if DBG
    ArapStatistics.RecvPostDecompMax =
            (DecompressedDataLen > ArapStatistics.RecvPostDecompMax)?
            DecompressedDataLen : ArapStatistics.RecvPostDecompMax;

    ArapStatistics.RecvPostDecomMin =
            (DecompressedDataLen < ArapStatistics.RecvPostDecomMin)?
            DecompressedDataLen : ArapStatistics.RecvPostDecomMin;
#endif


    // we successfully received a brand new packet, so we aren't getting dup's
    pArapConn->MnpState.ReceivingDup = FALSE;

    // we have these many bytes more waiting to be processed
    pArapConn->RecvsPending += DecompressedDataLen;

    ARAP_ADJUST_RECVCREDIT(pArapConn);

    RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

    // see if ack needs to be sent for the packet we just received
    MnpSendAckIfReqd(pArapConn, FALSE);

}




//***
//
// Function: ArapRcvComplete
//              This is the RcvComplete routine for the Arap port.
//              We look through all the clients on this port (i.e. all the
//              Arap clients) to see who needs work done, and finish it.
//
// Parameters:  none
//
// Return:      none
//
//***$

VOID
ArapRcvComplete(
    IN VOID
)
{
    PARAPCONN           pArapConn;
    PARAPCONN           pPrevArapConn;
    PLIST_ENTRY         pConnList;
    PLIST_ENTRY         pSendAckedList;
    PLIST_ENTRY         pList;
    KIRQL               OldIrql;
    BOOLEAN             fRetransmitting;
    BOOLEAN             fReceiveQEmpty;
    PMNPSENDBUF         pMnpSendBuf=NULL;
    PMNPSENDBUF         pRetransmitBuf=NULL;
    PARAPBUF            pArapBuf=NULL;
    DWORD               BytesProcessed=0;
    BOOLEAN             fArapDataWaiting;
    BOOLEAN             fArapConnUp=FALSE;



    //
    // walk through all the Arap clients to see if anyone has data to be
    // processed.
    // Start from the head of the list
    //  1 if the connection state is not ok, try the next connection
    //      else up the refcount (to make sure it stays around until we're done)
    //  2  see if we need to disconnect: if yes, do so and move on
    //  3  see if retransmits are needed
    //  4  see if ack needs to be sent
    //  5  see if any sends need to be completed
    //  6  see if any receives need to be completed
    //  7 Find the next connection which we will move to next
    //  8 remove the refcount on the previous connection that we put in step 1
    //

    pArapConn = NULL;
    pPrevArapConn = NULL;

    while (1)
    {
        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        //
        // first, let's find the right connection to work on
        //
        while (1)
        {
            // if we're in the middle of the list, get to the next guy
            if (pArapConn != NULL)
            {
                pConnList = pArapConn->Linkage.Flink;
            }
            // we're just starting: get the guy at the head of the list
            else
            {
                pConnList = RasPortDesc->pd_ArapConnHead.Flink;
            }

            // finished all?
            if (pConnList == &RasPortDesc->pd_ArapConnHead)
            {
                RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

                if (pPrevArapConn)
                {
                    DerefArapConn(pPrevArapConn);
                }
                return;
            }

            pArapConn = CONTAINING_RECORD(pConnList, ARAPCONN, Linkage);

            // make sure this connection needs rcv processing
            ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

            //
            // if this connection is being disconnected, skip it (unless we
            // just received disconnect from remote, in which case we need to
            // process that)
            //
            if ((pArapConn->State >= MNP_LDISCONNECTING) &&
                (pArapConn->State != MNP_RDISC_RCVD))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
		            ("ArapRcvComplete: (%lx) invalid state %d, no rcv processing done\n",
                        pArapConn,pArapConn->State));

                RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

                // go try the next connection
                continue;
            }

            // let's make sure this connection stays around till we finish
            pArapConn->RefCount++;

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

            break;
        }

        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

        //
        // remove the refcount on the previous connection we put in for the Rcv
        //
        if (pPrevArapConn)
        {
            DerefArapConn(pPrevArapConn);
        }

        ASSERT(pPrevArapConn != pArapConn);

        pPrevArapConn = pArapConn;

        fRetransmitting = FALSE;
        fArapConnUp = FALSE;

        // if our sniff buffer has enough bytes, give them to dll and make room
        ARAP_DUMP_DBG_TRACE(pArapConn);

        ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

        //
        // if we got a disconnect from remote (LD frame), we have cleanup to do
        //
        if (pArapConn->State == MNP_RDISC_RCVD)
        {
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapRcvComplete: (%lx) disconnect rcvd from remote, calling cleanup\n",
                    pArapConn));

            pArapConn->State = MNP_RDISCONNECTING;

            RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

            ArapCleanup(pArapConn);

            // go process the next connection
            continue;
        }

        //
        // do we need to retransmit the sends queued up on the retransmit Q?
        //
        if (pArapConn->MnpState.MustRetransmit)
        {
            pList = pArapConn->RetransmitQ.Flink;

            if (pList != &pArapConn->RetransmitQ)
            {
                pRetransmitBuf = CONTAINING_RECORD(pList, MNPSENDBUF, Linkage);

                fRetransmitting = TRUE;

                if (pRetransmitBuf->RetryCount >= ARAP_MAX_RETRANSMITS)
                {
                    RemoveEntryList(&pRetransmitBuf->Linkage);

                    ASSERT(pArapConn->MnpState.UnAckedSends >= 1);

                    // not really important, since we're about to disconnect!
                    pArapConn->MnpState.UnAckedSends--;

                    ASSERT(pArapConn->SendsPending >= pRetransmitBuf->DataSize);

#if DBG
                    InitializeListHead(&pRetransmitBuf->Linkage);
#endif

	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		                ("ArapRcvComplete: (%lx) too many retransmits (%lx).  Killing %lx\n",
                            pRetransmitBuf,pArapConn));

                    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

                    (pRetransmitBuf->ComplRoutine)(pRetransmitBuf,ARAPERR_SEND_FAILED);

                    continue;
                }
            }
        }

        //
        // See if any sends can be completed as a result of an ack coming in
        // (now that we have the spinlock, move the list away and mark the list as
        // empty before we release the lock.  Idea is to avoid grab-release-grab..
        // of spinlock as we complete all the sends).
        //
        pSendAckedList = pArapConn->SendAckedQ.Flink;
        InitializeListHead(&pArapConn->SendAckedQ);

        // is ARAP connection up yet?  we'll use this fact very soon...
        if (pArapConn->Flags & ARAP_CONNECTION_UP)
        {
            fArapConnUp = TRUE;
        }

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);


        //
        // next, handle any retransmissions if needed
        //
        if (fRetransmitting)
        {
            ArapNdisSend(pArapConn, &pArapConn->RetransmitQ);
        }

        //
        // next, complete all our sends for which we received ack(s)
        //
        while (pSendAckedList != &pArapConn->SendAckedQ)
        {
            pMnpSendBuf = CONTAINING_RECORD(pSendAckedList,MNPSENDBUF,Linkage);

            pSendAckedList = pSendAckedList->Flink;

            InitializeListHead(&pMnpSendBuf->Linkage);

            //
            // call the completion routine for this send buffer
            //
            (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_NO_ERROR);
        }


        // see if ack needs to be sent, for any packets we received
        MnpSendAckIfReqd(pArapConn, FALSE);


        //
        // and finally, process all the packets on the recieve queue!
        //

        BytesProcessed = 0;
        while (1)
        {
            if ((pArapBuf = ArapExtractAtalkSRP(pArapConn)) == NULL)
            {
                // no more data left (or no complete SRP yet): done here
                break;
            }

            // is ARAP connection up?  route only if it's up, otherwise drop it!
            if (fArapConnUp)
            {
                ArapRoutePacketFromWan( pArapConn, pArapBuf );
            }

            // we received AppleTalk data but connection wasn't/isn't up!  Drop pkt
            else
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		            ("ArapRcvComplete: (%lx) AT data, but conn not up\n",pArapConn));
            }

            BytesProcessed += pArapBuf->DataSize;

            // done with this buffer
            ARAP_FREE_RCVBUF(pArapBuf);
        }

        //
        // ok, we freed up space: update the counters
        //
        ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

        ASSERT(pArapConn->RecvsPending >= BytesProcessed);
        pArapConn->RecvsPending -= BytesProcessed;

        ARAP_ADJUST_RECVCREDIT(pArapConn);

#if DBG
        if ((IsListEmpty(&pArapConn->RetransmitQ)) &&
            (IsListEmpty(&pArapConn->HighPriSendQ)) &&
            (IsListEmpty(&pArapConn->MedPriSendQ)) &&
            (IsListEmpty(&pArapConn->LowPriSendQ)) &&
            (IsListEmpty(&pArapConn->SendAckedQ)) )
        {
            ASSERT(pArapConn->SendsPending == 0);
        }
#endif
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

        ArapDataToDll(pArapConn);

        //
        // see if any more packets can/should be sent
        //
        ArapNdisSend(pArapConn, &pArapConn->HighPriSendQ);
    }
}



//***
//
// Function: ArapNdisSend
//              This routine is called when we need to send data out to the
//              client, whether it's a fresh send or a retransmit.
//
// Parameters:  pArapConn - connection element for whom data has come in
//              pSendHead - from which queue (new send or retransmit) to send
//
// Return:      none
//
//***$

VOID
ArapNdisSend(
    IN  PARAPCONN       pArapConn,
    IN  PLIST_ENTRY     pSendHead
)
{

    KIRQL           OldIrql;
    PMNPSENDBUF     pMnpSendBuf=NULL;
	PNDIS_PACKET	ndisPacket;
    NDIS_STATUS     ndisStatus;
    PLIST_ENTRY     pSendList;
    BOOLEAN         fGreaterThan;
    BYTE            SendCredit;
    BYTE            PrevSeqNum;
    BOOLEAN         fFirstSend=TRUE;
    BOOLEAN         fRetransmitQ;
    DWORD           StatusCode;



    DBG_ARAP_CHECK_PAGED_CODE();

    //
    // before we begin, let's see if any of the lower priority queue sends
    // can be moved ("refilled") on to the high priority queue (the real queue)
    //
    ArapRefillSendQ(pArapConn);


    fRetransmitQ = (pSendHead == &pArapConn->RetransmitQ);

    //
    // while we have sends queued up and send-credits available,
    // keep sending
    //

    while (1)
    {
        ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

        pSendList = pSendHead->Flink;

        if (pArapConn->MnpState.RetransmitMode)
        {
            //
            // if we are asked to retransmit, we only retransmit the first
            // packet (until it is acked)
            //
            if (!fFirstSend)
            {
                goto ArapNdisSend_Exit;
            }

            //
            // if we are in the retransmit mode, we can't accept any fresh sends
            //
            if (!fRetransmitQ)
            {
    	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                    ("ArapNdisSend: in retransmit mode, dropping fresh send\n"));

                goto ArapNdisSend_Exit;
            }

            // we will go down and retransmit (if we can): turn this off here
            pArapConn->MnpState.MustRetransmit = FALSE;
        }

#if 0
        //
        // if this is a retransmit, find the next send that we must retransmit
        //
        if ((fRetransmitQ) && (!fFirstSend))
        {
            while (pSendList != pSendHead)
            {
                pMnpSendBuf = CONTAINING_RECORD(pSendList,MNPSENDBUF,Linkage);

                // find the seq number larger than the one we just retransmitted
                LT_GREATER_THAN(pMnpSendBuf->SeqNum,PrevSeqNum,fGreaterThan);

                if (fGreaterThan)
                {
                    break;
                }

                pSendList = pSendList->Flink;
            }
        }
#endif

        // no more to send? then we're done
        if (pSendList == pSendHead)
        {
            goto ArapNdisSend_Exit;
        }

        pMnpSendBuf = CONTAINING_RECORD(pSendList,MNPSENDBUF,Linkage);

        ASSERT( (pMnpSendBuf->Signature == MNPSMSENDBUF_SIGNATURE) ||
                (pMnpSendBuf->Signature == MNPLGSENDBUF_SIGNATURE) );

        fFirstSend = FALSE;
        PrevSeqNum = pMnpSendBuf->SeqNum;

        SendCredit = pArapConn->MnpState.SendCredit;

        //
        // if we are disconnecting, don't send
        //
        if (pArapConn->State >= MNP_LDISCONNECTING)
        {
    	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapNdisSend: disconnecting, or link-down: dropping send\n"));

            ARAP_DBG_TRACE(pArapConn,30305,NULL,pArapConn->State,0,0);

            goto ArapNdisSend_Exit;
        }

        //
        // if this is a fresh send (i.e. not a retransmit) then make sure we have
        // send credits available
        //
        if ( (SendCredit == 0) && (!fRetransmitQ) )
        {
    	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                ("ArapNdisSend: send credit 0, dropping send\n"));

            ARAP_DBG_TRACE(pArapConn,30310,NULL,0,0,0);

            goto ArapNdisSend_Exit;
        }

        //
        // if this send is already in NDIS (rare case, but can happen) then return
        //
        if (pMnpSendBuf->Flags != 0)
        {
    	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                ("ArapNdisSend: send %lx already in NDIS!!! (seq=%x, %d times)\n",
                pMnpSendBuf,pMnpSendBuf->SeqNum,pMnpSendBuf->RetryCount));

            goto ArapNdisSend_Exit;
        }

        // Mark that this send is in Ndis
        pMnpSendBuf->Flags = 1;

        //
        // Move it to the RetransmitQ for that "reliable" thing to work
        // and set the length so that ndis knows how much to send!
        //
        if (!fRetransmitQ)
        {
            ASSERT(pMnpSendBuf->DataSize <= MNP_MAXPKT_SIZE);

            DBGTRACK_SEND_SIZE(pArapConn,pMnpSendBuf->DataSize);

            //
            // get ndis packet for this send, since this is the first time we
            // are sending this send out
            //
            StatusCode = ArapGetNdisPacket(pMnpSendBuf);

            if (StatusCode != ARAPERR_NO_ERROR)
            {
    	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapNdisSend: (%lx) couldn't alloc NdisPacket\n",pArapConn));

                pMnpSendBuf->Flags = 0;
                goto ArapNdisSend_Exit;
            }

            // one more frame going outcame in
            pArapConn->StatInfo.FramesSent++;

            RemoveEntryList(&pMnpSendBuf->Linkage);

            InsertTailList(&pArapConn->RetransmitQ, &pMnpSendBuf->Linkage);

            pArapConn->MnpState.UnAckedSends++;

            ASSERT(pArapConn->MnpState.UnAckedSends <= pArapConn->MnpState.WindowSize);

            ASSERT( (pArapConn->MnpState.SendCredit > 0) &&
                    (pArapConn->MnpState.SendCredit <= pArapConn->MnpState.WindowSize));

            // we are going to use up one send credit now
            pArapConn->MnpState.SendCredit--;

		    NdisAdjustBufferLength(pMnpSendBuf->sb_BuffHdr.bh_NdisBuffer,
                              (pMnpSendBuf->DataSize + MNP_OVERHD(pArapConn)));

            ASSERT( (pMnpSendBuf->Buffer[14] == pArapConn->MnpState.SynByte) &&
                    (pMnpSendBuf->Buffer[15] == pArapConn->MnpState.DleByte) &&
                    (pMnpSendBuf->Buffer[16] == pArapConn->MnpState.StxByte));

            ASSERT((pMnpSendBuf->Buffer[20 + pMnpSendBuf->DataSize] ==
                                               pArapConn->MnpState.DleByte) &&
                   (pMnpSendBuf->Buffer[20 + pMnpSendBuf->DataSize+1] ==
                                               pArapConn->MnpState.EtxByte));
        }

        //
        //  this is a retransmit
        //
        else
        {
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
		        ("ArapNdisSend: (%lx) retransmitting %x size=%d\n",
                    pArapConn,pMnpSendBuf->SeqNum,pMnpSendBuf->DataSize));

            //
            // reset it: it's possible we had changed it for an earlier retransmit
            //
            if (pMnpSendBuf->RetryCount < ARAP_HALF_MAX_RETRANSMITS)
            {
                pArapConn->SendRetryTime = pArapConn->SendRetryBaseTime;
            }

            //
            // hmmm: we have retransmitted quite a few times.  Time to increase
            // our retry time so we do some exponential back off.  Increase the
            // retry time by 50%, with an upper bound of 5 seconds
            //
            else
            {
                pArapConn->SendRetryTime += (pArapConn->SendRetryTime>>1);

                if (pArapConn->SendRetryTime > ARAP_MAX_RETRY_INTERVAL)
                {
                    pArapConn->SendRetryTime = ARAP_MAX_RETRY_INTERVAL;
                }
            }
        }

        // bump this to note our attempt to send this pkt
        pMnpSendBuf->RetryCount++;

        // put an ndis refcount (remove when ndis completes this send)
        pMnpSendBuf->RefCount++;

        // when should we retransmit this pkt?
        pMnpSendBuf->RetryTime = pArapConn->SendRetryTime + AtalkGetCurrentTick();

        // reset the flow-control timer: we're sending something over
        pArapConn->FlowControlTimer = AtalkGetCurrentTick() +
                                        pArapConn->T404Duration;

        ARAP_DBG_TRACE(pArapConn,30320,pMnpSendBuf,fRetransmitQ,0,0);

        MNP_DBG_TRACE(pArapConn,pMnpSendBuf->SeqNum,MNP_LT);

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

        ndisPacket = pMnpSendBuf->sb_BuffHdr.bh_NdisPkt;

        DBGDUMPBYTES("ArapNdisSend sending pkt: ",
            &pMnpSendBuf->Buffer[0],(pMnpSendBuf->DataSize + MNP_OVERHD(pArapConn)),3);

		//  Now send the packet descriptor
		NdisSend(&ndisStatus, RasPortDesc->pd_NdisBindingHandle, ndisPacket);

		// if there was a problem sending, call the completion routine here
		if (ndisStatus != NDIS_STATUS_PENDING)
		{
    	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapNdisSend: NdisSend failed (%lx %lx)\n", pArapConn,ndisStatus));

			ArapNdisSendComplete(ARAPERR_SEND_FAILED, (PBUFFER_DESC)pMnpSendBuf, NULL);

            // might as well stop here for now if we are having trouble sending!
            goto ArapNdisSend_Exit_NoLock;
		}
    }


ArapNdisSend_Exit:

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

ArapNdisSend_Exit_NoLock:

    ;

    // if our sniff buffer has enough bytes, give them to dll and make room
    ARAP_DUMP_DBG_TRACE(pArapConn);

}





//***
//
// Function: ArapNdisSendComplete
//              This routine is the completion routine called by Ndis to tell
//              us that the send completed (i.e. just went out on the wire)
//
// Parameters:  Status - did it go out on wire?
//              pMnpSendBuf - the buffer that was sent out. We dereference the
//                            buffer here.  When this send gets acked, that's
//                            when the other deref happens.
//
// Return:      none
//
//***$

VOID
ArapNdisSendComplete(
	IN NDIS_STATUS		    Status,
	IN PBUFFER_DESC         pBufferDesc,
    IN PSEND_COMPL_INFO     pSendInfo
)
{

    PARAPCONN           pArapConn;
	PMNPSENDBUF         pMnpSendBuf;


    DBG_ARAP_CHECK_PAGED_CODE();

    pMnpSendBuf = (PMNPSENDBUF)pBufferDesc;
    pArapConn = pMnpSendBuf->pArapConn;

    ARAPTRACE(("Entered ArapNdisSendComplete (%lx %lx %lx)\n",
        Status,pMnpSendBuf,pArapConn));

    if (Status != NDIS_STATUS_SUCCESS)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapNdisSendComplete (%lx): send failed %lx\n",pArapConn,Status));
    }

    // ndis send completed: take away the ndis refcount
    DerefMnpSendBuf(pMnpSendBuf, TRUE);
}



//***
//
// Function: ArapGetNdisPacket
//              This function gets an Ndis Packet for the ARAP send buffer
//
// Parameters:  pMnpSendBuf - the send buffer for which we need Ndis Packet
//
// Return:      error code
//
//***$
DWORD
ArapGetNdisPacket(
    IN PMNPSENDBUF     pMnpSendBuf
)
{

		
	PBUFFER_HDR	    pBufHdr;
    NDIS_STATUS     ndisStatus;


    DBG_ARAP_CHECK_PAGED_CODE();

	pBufHdr = (PBUFFER_HDR)pMnpSendBuf;

	pBufHdr->bh_NdisPkt = NULL;

	//  Allocate an NDIS packet descriptor from the global packet pool
	NdisAllocatePacket(&ndisStatus,
					   &pBufHdr->bh_NdisPkt,
					   AtalkNdisPacketPoolHandle);
	
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERROR(EVENT_ATALK_NDISRESOURCES, ndisStatus, NULL, 0);

	    DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
		    ("ArapGetNdisPacket: Ndis Out-of-Resource condition hit\n"));

        ASSERT(0);

		return(ARAPERR_OUT_OF_RESOURCES);
	}

	//  Link the buffer descriptor into the packet descriptor
	RtlZeroMemory(pBufHdr->bh_NdisPkt->ProtocolReserved, sizeof(PROTOCOL_RESD));
	NdisChainBufferAtBack(pBufHdr->bh_NdisPkt,
						  pBufHdr->bh_NdisBuffer);
	((PPROTOCOL_RESD)(pBufHdr->bh_NdisPkt->ProtocolReserved))->Receive.pr_BufHdr = pBufHdr;

    ARAP_SET_NDIS_CONTEXT(pMnpSendBuf, NULL);

    return(ARAPERR_NO_ERROR);
}

//***
//
// Function: RasStatusIndication
//              This is the status indication routine for the Arap port.
//              When line-up, line-down indications come from NdisWan, we
//              execute this routine.
//
// Parameters:  GeneralStatus - what is this indication for
//              StatusBuf - the buffer containig the indication info
//              StatusBufLen - length of this buffer
//
// Return:      none
//
//***$

VOID
RasStatusIndication(
	IN	NDIS_STATUS 	GeneralStatus,
	IN	PVOID			StatusBuf,
	IN	UINT 			StatusBufLen
)
{

    KIRQL                   OldIrql;
    PNDIS_WAN_LINE_UP	    pLineUp;
    PNDIS_WAN_LINE_DOWN     pLineDown;
    PNDIS_WAN_FRAGMENT      pFragment;
    ATALK_NODEADDR          ClientNode;
    PARAPCONN               pArapConn;
    PATCPCONN               pAtcpConn;
    PARAP_BIND_INFO         pArapBindInfo;
    PNDIS_WAN_GET_STATS     pWanStats;
    DWORD                   dwFlags;
    BOOLEAN                 fKillConnection=FALSE;


    switch (GeneralStatus)
    {
        case NDIS_STATUS_WAN_LINE_UP:

            if (StatusBufLen < sizeof(NDIS_WAN_LINE_UP))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("RasStatusIndication:\
                                line-up buff too small (%ld)\n", StatusBufLen));
                break;
            }

            pLineUp = (PNDIS_WAN_LINE_UP)StatusBuf;

            pArapBindInfo = (PARAP_BIND_INFO)pLineUp->ProtocolBuffer;

            //
            // is this a PPP connection?
            //
            if (pArapBindInfo->fThisIsPPP)
            {
                ClientNode.atn_Network = pArapBindInfo->ClientAddr.ata_Network;
                ClientNode.atn_Node = (BYTE)pArapBindInfo->ClientAddr.ata_Node;

                pAtcpConn = FindAndRefPPPConnByAddr(ClientNode, &dwFlags);

                ASSERT(pAtcpConn == pArapBindInfo->AtalkContext);

                if (pAtcpConn)
                {
                    ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);

	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			            ("PPP: Line-Up received on %lx: link-speed = %lx, net addr %x.%x\n",
                        pAtcpConn,pLineUp->LinkSpeed,ClientNode.atn_Network,ClientNode.atn_Node));

                    ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

                    ASSERT(!((dwFlags & ATCP_LINE_UP_DONE) || (dwFlags & ATCP_CONNECTION_UP)));

                    pAtcpConn->Flags |= ATCP_LINE_UP_DONE;
                    pAtcpConn->Flags |= ATCP_CONNECTION_UP;

                    // put NDISWAN refcount
                    pAtcpConn->RefCount++;

                    //
                    // put our context for ndiswan
                    //


                    // mark that this is a PPP connection
                    pLineUp->LocalAddress[0] = PPP_ID_BYTE1;
                    pLineUp->LocalAddress[1] = PPP_ID_BYTE2;

                    pLineUp->LocalAddress[2] = 0x0;
                    pLineUp->LocalAddress[3] = ClientNode.atn_Node;
		            *((USHORT UNALIGNED *)(&pLineUp->LocalAddress[4])) =
                        ClientNode.atn_Network;

                    //
                    // copy the header since this is what we'll use throughout the
                    // life of the connection
                    //
                    RtlCopyMemory( &pAtcpConn->NdiswanHeader[0],
                                   pLineUp->RemoteAddress,
                                   6 );

                    RtlCopyMemory( &pAtcpConn->NdiswanHeader[6],
                                   pLineUp->LocalAddress,
                                   6 );

                    // these two bytes don't really mean much, but might as well set'em
                    pAtcpConn->NdiswanHeader[12] = 0x80;
                    pAtcpConn->NdiswanHeader[13] = 0xf3;

                    RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

                    // remove the refcount put in by FindAndRefPPPConnByAddr
                    DerefPPPConn(pAtcpConn);

                    // tell dll we bound ok
                    pArapBindInfo->ErrorCode = ARAPERR_NO_ERROR;
                }
                else
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("RasStatusIndication: PPP line-up, but no conn for %ld.%ld\n",
                        ClientNode.atn_Network,ClientNode.atn_Node));
                    ASSERT(0);
                    pArapBindInfo->ErrorCode = ARAPERR_NO_SUCH_CONNECTION;
                }
            }

            //
            // nope, this is an ARAP connection!
            //
            else
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			        ("Arap: Line-Up received: link-speed = %lx, dll context = %lx\n",
                    pLineUp->LinkSpeed,pArapBindInfo->pDllContext));

                ASSERT(FindArapConnByContx(pArapBindInfo->pDllContext) == NULL);

                //
                // alloc a connection.  If we fail, tell dll sorry
                //

                pArapConn = AllocArapConn(pLineUp->LinkSpeed);
                if (pArapConn == NULL)
                {
    	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("RasStatusIndication: AllocArapConn failed\n"));

                    pArapBindInfo->AtalkContext = NULL;
                    pArapBindInfo->ErrorCode = ARAPERR_OUT_OF_RESOURCES;
                    break;
                }

                // do the legendary "binding" (exchange contexts!)
                pArapConn->pDllContext = pArapBindInfo->pDllContext;

                pArapBindInfo->AtalkContext = pArapConn;

                //
                // insert this connection in the list of all Arap connections
                //
                ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

                InsertTailList(&RasPortDesc->pd_ArapConnHead, &pArapConn->Linkage);

                RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);


                // mark that this is an ARAP connection
                pLineUp->LocalAddress[0] = ARAP_ID_BYTE1;
                pLineUp->LocalAddress[1] = ARAP_ID_BYTE2;

                // put our context for ndiswan
		        *((ULONG UNALIGNED *)(&pLineUp->LocalAddress[2])) =
    		        *((ULONG UNALIGNED *)(&pArapConn));

                //
                // copy the header since this is what we'll use throughout the
                // life of the connection
                //
                RtlCopyMemory( &pArapConn->NdiswanHeader[0],
                            pLineUp->RemoteAddress,
                            6 );

                RtlCopyMemory( &pArapConn->NdiswanHeader[6],
                            pLineUp->LocalAddress,
                            6 );

                // these two bytes don't really mean much, but might as well set'em
                pArapConn->NdiswanHeader[12] = 0x80;
                pArapConn->NdiswanHeader[13] = 0xf3;

                // tell dll we bound ok
                pArapBindInfo->ErrorCode = ARAPERR_NO_ERROR;

            }  // if (pArapBindInfo->fThisIsPPP)

            break;


        case NDIS_STATUS_WAN_LINE_DOWN:

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("RasStatusIndication: Line-Down received\n"));

            if (StatusBufLen < sizeof(NDIS_WAN_LINE_DOWN))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("RasStatusIndication: line-down buff too small (%ld)\n",
                    StatusBufLen));
                break;
            }

            pLineDown = (PNDIS_WAN_LINE_DOWN)StatusBuf;

            //
            // is this a PPP connection?
            //
            if ((pLineDown->LocalAddress[0] == PPP_ID_BYTE1) &&
                (pLineDown->LocalAddress[1] == PPP_ID_BYTE2))
            {
                ClientNode.atn_Node = pLineDown->LocalAddress[3];
                ClientNode.atn_Network =
                          *((USHORT UNALIGNED *)(&pLineDown->LocalAddress[4]));

                pAtcpConn = FindAndRefPPPConnByAddr(ClientNode, &dwFlags);
                if (pAtcpConn)
                {
                    ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);

                    ACQUIRE_SPIN_LOCK(&pAtcpConn->SpinLock, &OldIrql);

                    ASSERT(dwFlags & ATCP_LINE_UP_DONE);

                    pAtcpConn->Flags &= ~(ATCP_CONNECTION_UP | ATCP_LINE_UP_DONE);
                    RELEASE_SPIN_LOCK(&pAtcpConn->SpinLock, OldIrql);

	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			            ("PPP line-down: killing %lx in line-down\n",pAtcpConn));

                    // line-down: take away the NDISWAN refcount
                    DerefPPPConn(pAtcpConn);

                    // remove the refcount put in by FindAndRefPPPConnByAddr
                    DerefPPPConn(pAtcpConn);
                }
                else
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("RasStatusIndication: PPP line-down, but no conn for %ld.%ld\n",
                        ClientNode.atn_Network,ClientNode.atn_Node));
                }
            }

            //
            // no, this is an ARAP connection
            //
            else
            {

                ASSERT((pLineDown->LocalAddress[0] == ARAP_ID_BYTE1) &&
                       (pLineDown->LocalAddress[1] == ARAP_ID_BYTE2));

		        *((ULONG UNALIGNED *)(&pArapConn)) =
		                    *((ULONG UNALIGNED *)(&pLineDown->LocalAddress[2]));

		        // this had better be a line-down for an existing connection!
                if (ArapConnIsValid(pArapConn))
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			            ("Arap line-down: killing %lx in line-down\n",pArapConn));

                    ArapCleanup(pArapConn);

                    // remove validation refcount
                    DerefArapConn(pArapConn);

                    // remove line-up refcount
                    DerefArapConn(pArapConn);
                }
                else
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("RasStatusIndication: line-down, can't find pArapConn\n"));
                }
            }

            break;


        case NDIS_STATUS_WAN_GET_STATS:

            if (StatusBufLen < sizeof(NDIS_WAN_GET_STATS))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("RasStatusIndication: GetStats buff too small (%ld)\n", StatusBufLen));
                break;
            }

            pWanStats = (PNDIS_WAN_GET_STATS)StatusBuf;

            //
            // is this a PPP connection?  If so, ignore it: we don't keep stats
            // for PPP connection
            //
            if ((pWanStats->LocalAddress[0] == PPP_ID_BYTE1) &&
                (pWanStats->LocalAddress[1] == PPP_ID_BYTE2))
            {
                break;
            }

            //
            // no, this is an ARAP connection
            //
            else
            {
                ASSERT((pWanStats->LocalAddress[0] == ARAP_ID_BYTE1) &&
                       (pWanStats->LocalAddress[1] == ARAP_ID_BYTE2));

		        *((ULONG UNALIGNED *)(&pArapConn)) =
		                    *((ULONG UNALIGNED *)(&pWanStats->LocalAddress[2]));

		        // the connection had better be a valid one!
                if (ArapConnIsValid(pArapConn))
                {
                    //
                    // copy those stats in!
                    //
                    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

                    pWanStats->BytesSent =
                                    pArapConn->StatInfo.BytesSent;
                    pWanStats->BytesRcvd =
                                    pArapConn->StatInfo.BytesRcvd;
                    pWanStats->FramesSent =
                                    pArapConn->StatInfo.FramesSent;
                    pWanStats->FramesRcvd =
                                    pArapConn->StatInfo.FramesRcvd;
                    pWanStats->BytesTransmittedUncompressed =
                                    pArapConn->StatInfo.BytesTransmittedUncompressed;
                    pWanStats->BytesReceivedUncompressed =
                                    pArapConn->StatInfo.BytesReceivedUncompressed;
                    pWanStats->BytesTransmittedCompressed =
                                    pArapConn->StatInfo.BytesTransmittedCompressed;
                    pWanStats->BytesReceivedCompressed =
                                    pArapConn->StatInfo.BytesReceivedCompressed;

                    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

                    // remove validation refcount
                    DerefArapConn(pArapConn);
                }
                else
                {
	                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("RasStatusIndication: GetStats on bad connection %lx\n",pArapConn));
                }
            }

            break;

        case NDIS_STATUS_WAN_FRAGMENT:

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("RasStatusIndication: Wan-Fragment received\n"));

            if (StatusBufLen < sizeof(NDIS_WAN_FRAGMENT))
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("RasStatusIndication:\
                              fragment: buff too small (%ld)\n", StatusBufLen));
                break;
            }

            pFragment = (PNDIS_WAN_FRAGMENT)StatusBuf;

		    *((ULONG UNALIGNED *)(&pArapConn)) =
		                    *((ULONG UNALIGNED *)(&pFragment->LocalAddress[2]));

            if (pArapConn == NULL)
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("RasStatusIndication:\
                    fragment, can't find pArapConn\n"));

                break;
            }

            //
            // a frame got fragmented (wrong crc or resync or something bad)
            // Send an ack to the remote client so he might recover quickly
            //
            MnpSendAckIfReqd(pArapConn, TRUE);

        default:

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
			    ("RasStatusIndication: unknown status %lx\n", GeneralStatus));
            break;
    }

}



//***
//
// Function: ArapAdapterInit
//              This routine, called at init time, sets up protocol type info
//              etc. with ndiswan
//
// Parameters:  pPortDesc - the port descriptor corresponding to the "Adapter"
//
// Return:      none
//
//***$

ATALK_ERROR
ArapAdapterInit(
	IN OUT PPORT_DESCRIPTOR	pPortDesc
)
{
    ATALK_ERROR             error;
    NDIS_REQUEST            request;
    NDIS_STATUS             ndisStatus = NDIS_STATUS_SUCCESS;
    UCHAR WanProtocolId[6] = { 0x80, 0x00, 0x00, 0x00, 0x80, 0xf3 };
    ULONG                   WanHeaderFormat;
    NDIS_WAN_PROTOCOL_CAPS  WanProtCap;


    //
    // set the protocol info
    //
    request.RequestType = NdisRequestSetInformation;
    request.DATA.QUERY_INFORMATION.Oid = OID_WAN_PROTOCOL_TYPE;
    request.DATA.QUERY_INFORMATION.InformationBuffer = WanProtocolId;
    request.DATA.QUERY_INFORMATION.InformationBufferLength = 6;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
	    								&request,
										TRUE,
										NULL,
										NULL);
	
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ARAP_BIND_FAIL,
						ndisStatus,
						NULL,
						0);
	}


    //
    // set the protocol caps
    //
    WanProtCap.Flags = WAN_PROTOCOL_KEEPS_STATS;
    request.RequestType = NdisRequestSetInformation;
    request.DATA.QUERY_INFORMATION.Oid = OID_WAN_PROTOCOL_CAPS;
    request.DATA.QUERY_INFORMATION.InformationBuffer = &WanProtCap;
    request.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(NDIS_WAN_PROTOCOL_CAPS);

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
	    								&request,
										TRUE,
										NULL,
										NULL);
	
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ARAP_BIND_FAIL,
						ndisStatus,
						NULL,
						0);
	}

    //
    // set the header info
    //
    WanHeaderFormat = NdisWanHeaderEthernet;
    request.RequestType = NdisRequestSetInformation;
    request.DATA.QUERY_INFORMATION.Oid = OID_WAN_HEADER_FORMAT;
    request.DATA.QUERY_INFORMATION.InformationBuffer = &WanHeaderFormat;
    request.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
	    								&request,
										TRUE,
										NULL,
										NULL);
	
	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ARAP_BIND_FAIL,
						ndisStatus,
						NULL,
						0);
	}


    //
    // Now query the line count.
    //
    request.RequestType = NdisRequestQueryInformation;
    request.DATA.QUERY_INFORMATION.Oid = OID_WAN_LINE_COUNT;
    request.DATA.QUERY_INFORMATION.InformationBuffer = &pPortDesc->pd_RasLines,
    request.DATA.QUERY_INFORMATION.InformationBufferLength = 4;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
	    								&request,
										TRUE,
										NULL,
										NULL);
	

    if (ndisStatus != NDIS_STATUS_SUCCESS)
    {
        pPortDesc->pd_RasLines = 1;
    }

    if (pPortDesc->pd_RasLines == 0) {

		LOG_ERRORONPORT(pPortDesc,
						EVENT_ARAP_NO_RESRC,
						ndisStatus,
						NULL,
						0);
    }

	return AtalkNdisToAtalkError(ndisStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\asp.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	asp.c

Abstract:

	This module implements the ASP protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	30 Mar 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ASP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitAspInitialize)
#pragma alloc_text(PAGE, AtalkAspCreateAddress)
#pragma alloc_text(PAGE_ASP, AtalkAspCloseAddress)
#pragma alloc_text(PAGE_ASP, AtalkAspSetStatus)
#pragma alloc_text(PAGE_ASP, AtalkAspListenControl)
#pragma alloc_text(PAGE_ASP, AtalkAspCloseConnection)
#pragma alloc_text(PAGE_ASP, AtalkAspFreeConnection)
#pragma alloc_text(PAGE_ASP, AtalkAspCleanupConnection)
#pragma alloc_text(PAGE_ASP, AtalkAspWriteContinue)
#pragma alloc_text(PAGE_ASP, AtalkAspReply)
#pragma alloc_text(PAGE_ASP, atalkAspPostWriteContinue)
#pragma alloc_text(PAGE_ASP, AtalkAspSendAttention)
#pragma alloc_text(PAGE_ASP, AtalkAspReferenceAddr)
#pragma alloc_text(PAGE_ASP, atalkAspReferenceConnBySrcAddr)
#pragma alloc_text(PAGE_ASP, AtalkAspDereferenceConn)
#pragma alloc_text(PAGE_ASP, atalkAspSlsXHandler)
#pragma alloc_text(PAGE_ASP, atalkAspSssXHandler)
#pragma alloc_text(PAGE_ASP, atalkAspReplyRelease)
#pragma alloc_text(PAGE_ASP, atalkAspWriteContinueResp)
#pragma alloc_text(PAGE_ASP, atalkAspSendAttentionResp)
#pragma alloc_text(PAGE_ASP, atalkAspSessionClose)
#pragma alloc_text(PAGE_ASP, atalkAspReturnResp)
#pragma alloc_text(PAGE_ASP, atalkAspRespComplete)
#pragma alloc_text(PAGE_ASP, atalkAspCloseComplete)
#endif

/*
 * The model for ASP calls in this module is as follows:
 *
 * - For create calls (CreateAddress & CreateSession), a pointer to the created
 *	 object is returned. This structure is referenced for creation.
 * - For all other calls, it expects a referenced pointer to the object.
 */


VOID
AtalkInitAspInitialize(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	LONG	i;

	INITIALIZE_SPIN_LOCK(&atalkAspLock);

	for (i = 0; i < NUM_ASP_CONN_LISTS; i++)
	{
		AtalkTimerInitialize(&atalkAspConnMaint[i].ascm_SMTTimer,
							 atalkAspSessionMaintenanceTimer,
							 (SHORT)(ASP_SESSION_MAINTENANCE_TIMER - i*ASP_SESSION_TIMER_STAGGER));
		AtalkTimerScheduleEvent(&atalkAspConnMaint[i].ascm_SMTTimer);
	}
}




ATALK_ERROR
AtalkAspCreateAddress(
	OUT	PASP_ADDROBJ	*	ppAspAddr
	)
/*++

Routine Description:

 	Create an ASP address object (aka listener). This object is associated with
 	two seperate Atp sockets, one each for the Sls and the Sss. The Sls accepts
 	the tickle, getstatus and opensession requests from the client end. The
 	Sss accepts requests.

 	Currently only the server side ASP is implemented and hence the ASP address
 	object is only a listener.

Arguments:


Return Value:


--*/
{
	PASP_ADDROBJ		pAspAddr = NULL;
	ATALK_ERROR			Status;
	int					i;

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCreateAddr: Entered\n"));

	do
	{
		// Allocate memory for the Asp address object
		if ((pAspAddr = AtalkAllocZeroedMemory(sizeof(ASP_ADDROBJ))) == NULL)
		{
			Status = ATALK_RESR_MEM;
			break;
		}

		// Initialize the Asp address object
#if	DBG
		pAspAddr->aspao_Signature = ASPAO_SIGNATURE;
#endif
		INITIALIZE_SPIN_LOCK(&pAspAddr->aspao_Lock);

		// Refcounts for creation, Sls & Sss sockets and request handlers
		pAspAddr->aspao_RefCount = 1 + 2 + 2;
		pAspAddr->aspao_NextSessionId = 1;
		pAspAddr->aspao_EnableNewConnections = TRUE;

		// Create an Atp Socket on the port for the Sls
		Status = AtalkAtpOpenAddress(AtalkDefaultPort,
									 0,
									 NULL,
									 ATP_DEF_MAX_SINGLE_PKT_SIZE,
									 ATP_DEF_SEND_USER_BYTES_ALL,
									 NULL,
									 TRUE,		// CACHE this address
									 &pAspAddr->aspao_pSlsAtpAddr);

		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCreateAddress: AtalkAtpOpenAddress for Sls failed %ld\n", Status));
			break;
		}

		// Set Request handler for the SLS to handle GetStatus, OpenSession and Tickle
		AtalkAtpSetReqHandler(pAspAddr->aspao_pSlsAtpAddr,
							  atalkAspSlsXHandler,
							  pAspAddr);

		// Create the Atp Socket on the port for the Sss
		Status = AtalkAtpOpenAddress(AtalkDefaultPort,
									 0,
									 NULL,
									 ATP_DEF_MAX_SINGLE_PKT_SIZE,
									 ATP_DEF_SEND_USER_BYTES_ALL,
									 NULL,
									 TRUE,		// CACHE this address
									 &pAspAddr->aspao_pSssAtpAddr);

		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCreateAddress: AtalkAtpOpenAddress for Sss failed %ld\n", Status));
			break;
		}

		// Set Request handler for the SSS to handle Cmd/Write/Close
		AtalkAtpSetReqHandler(pAspAddr->aspao_pSssAtpAddr,
							  atalkAspSssXHandler,
							  pAspAddr);
	} while (FALSE);

	if (!ATALK_SUCCESS(Status))
	{
		if (pAspAddr != NULL)
		{
			if (pAspAddr->aspao_pSlsAtpAddr != NULL)
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("AtalkAspCreateAddress: Closing SLS Atp Address %lx\n",
						pAspAddr->aspao_pSlsAtpAddr));
				AtalkAtpCloseAddress(pAspAddr->aspao_pSlsAtpAddr, NULL, NULL);
			}
			if (pAspAddr->aspao_pSssAtpAddr != NULL)
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("AtalkAspCreateAddress: Closing SSS Atp Address %lx\n",
						pAspAddr->aspao_pSssAtpAddr));
				AtalkAtpCloseAddress(pAspAddr->aspao_pSssAtpAddr, NULL, NULL);
			}
			AtalkFreeMemory(pAspAddr);
		}
	}
	else
	{
		*ppAspAddr = pAspAddr;
	}

	return Status;
}




ATALK_ERROR
AtalkAspCloseAddress(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn;
	KIRQL			OldIrql;
	int				i;
	ATALK_ERROR		Status = ATALK_PENDING;
    PBYTE           pStatusBuf;

	ASSERT(VALID_ASPAO(pAspAddr));
	ASSERT(pAspAddr->aspao_RefCount > 1);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCloseAddr: Entered for Addr %lx\n", pAspAddr));

	ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);

	pAspAddr->aspao_Flags |= ASPAO_CLOSING;

	pAspAddr->aspao_CloseCompletion = CompletionRoutine;
	pAspAddr->aspao_CloseContext = CloseContext;

    pStatusBuf = pAspAddr->aspao_pStatusBuf;
    pAspAddr->aspao_pStatusBuf = NULL;

	RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

	// Close down the atp sockets for Sls and Sss
	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkAspCloseAddress: Closing SLS Atp Address %lx\n",
			pAspAddr->aspao_pSlsAtpAddr));

	AtalkAtpCloseAddress(pAspAddr->aspao_pSlsAtpAddr,
						 atalkAspCloseComplete,
						 pAspAddr);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkAspCloseAddress: Closing SSS Atp Address %lx\n",
			pAspAddr->aspao_pSssAtpAddr));

	AtalkAtpCloseAddress(pAspAddr->aspao_pSssAtpAddr,
						 atalkAspCloseComplete,
						 pAspAddr);

	// Free the status buffer if any
	if (pStatusBuf != NULL)
	{
		AtalkFreeMemory(pStatusBuf);
	}

	// Shut down the active sessions now.
	for (i = 0; i < ASP_CONN_HASH_BUCKETS; i++)
	{
		ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);
		pAspConn = pAspAddr->aspao_pSessions[i];
		while (pAspConn != NULL)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

            // if we have visited this guy, skip it
            if (pAspConn->aspco_Flags & ASPCO_SHUTDOWN)
            {
			    RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

	            DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
			        ("AtalkAspCloseAddress: VISITED: skipping conn %lx Flags %lx RefCount %d\n",
			        pAspConn,pAspConn->aspco_Flags,pAspConn->aspco_RefCount));

                // we still have the pAspAddr->aspao_Lock spinlock held!
                pAspConn = pAspConn->aspco_NextOverflow;
                continue;
            }

			pAspConn->aspco_Flags |= (ASPCO_LOCAL_CLOSE | ASPCO_SHUTDOWN);

			// Reference this since atalkAspSessionClose() expects it.
			pAspConn->aspco_RefCount ++;

			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

			RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

			atalkAspSessionClose(pAspConn);

			ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);
		}
		RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);
	}

	ASSERT(KeGetCurrentIrql() == LOW_LEVEL);

	// Let remaining cleanup happen during the Derefernce
	AtalkAspDereferenceAddr(pAspAddr);		// Remove the creation reference

	return Status;
}




ATALK_ERROR
AtalkAspBind(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	PASP_BIND_PARAMS		pBindParms,
	IN	PACTREQ					pActReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{

    KIRQL   OldIrql;

	ASSERT (VALID_ASPAO(pAspAddr));

    // copy network addr

	ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);
    pBindParms->pXportEntries->asp_AtalkAddr.Network =
                pAspAddr->aspao_pSlsAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Network;
    pBindParms->pXportEntries->asp_AtalkAddr.Node =
                pAspAddr->aspao_pSlsAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Node;
    pBindParms->pXportEntries->asp_AtalkAddr.Socket =
                pAspAddr->aspao_pSlsAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Socket;
	RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

	// Fill in our entry points into the client buffer
	pBindParms->pXportEntries->asp_AspCtxt = pAspAddr;
	pBindParms->pXportEntries->asp_SetStatus = AtalkAspSetStatus;
	pBindParms->pXportEntries->asp_CloseConn = AtalkAspCloseConnection;
	pBindParms->pXportEntries->asp_FreeConn  = AtalkAspFreeConnection;
	pBindParms->pXportEntries->asp_ListenControl = AtalkAspListenControl;
	pBindParms->pXportEntries->asp_WriteContinue = AtalkAspWriteContinue;
	pBindParms->pXportEntries->asp_Reply = AtalkAspReply;
	pBindParms->pXportEntries->asp_SendAttention = AtalkAspSendAttention;

	// Get the clients entry points
	pAspAddr->aspao_ClientEntries = pBindParms->ClientEntries;

	// Call the completion routine before returning.
	(*pActReq->ar_Completion)(ATALK_NO_ERROR, pActReq);

	return ATALK_PENDING;
}


NTSTATUS
AtalkAspSetStatus(
	IN	PASP_ADDROBJ	pAspAddr,
	IN	PUCHAR			pStatusBuf,
	IN	USHORT			StsBufSize
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	NTSTATUS		Status = STATUS_SUCCESS;
	PUCHAR			pOldBuf = NULL, pNewBuf = NULL;

	ASSERT(VALID_ASPAO(pAspAddr));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspSetStatus: Entered for Addr %lx\n", pAspAddr));

	do
	{
		if (pStatusBuf != NULL)
		{
			// Allocate a buffer and copy the contents of the passed in
			// buffer descriptor in it. Free an existing status buffer if one exists
			if (StsBufSize >= ASP_MAX_STATUS_SIZE)
			{
				Status = STATUS_BUFFER_TOO_SMALL;
				break;
			}

			if ((pNewBuf = AtalkAllocMemory(StsBufSize)) == NULL)
			{
				Status = STATUS_INSUFFICIENT_RESOURCES;
				break;
			}
			RtlCopyMemory(pNewBuf, pStatusBuf, StsBufSize);
		}

		ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);

		if (pAspAddr->aspao_pStatusBuf != NULL)
		{
			ASSERT(pAspAddr->aspao_StsBufSize != 0);
			pOldBuf = pAspAddr->aspao_pStatusBuf;
		}

		pAspAddr->aspao_pStatusBuf = pNewBuf;
		pAspAddr->aspao_StsBufSize = StsBufSize;

		RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

		if (pOldBuf != NULL)
			AtalkFreeMemory(pOldBuf);
	} while (FALSE);

	return Status;
}




NTSTATUS FASTCALL
AtalkAspListenControl(
	IN	PASP_ADDROBJ	pAspAddr,
	IN	BOOLEAN			Enable
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL		OldIrql;
	NTSTATUS	Status = STATUS_UNSUCCESSFUL;

	if (AtalkAspReferenceAddr(pAspAddr))
	{
		ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);
		pAspAddr->aspao_EnableNewConnections = Enable;
		RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

		AtalkAspDereferenceAddr(pAspAddr);
		Status = STATUS_SUCCESS;
	}

	return Status;
}


NTSTATUS
AtalkAspCloseConnection(
	IN	PASP_CONNOBJ			pAspConn
	)
/*++

Routine Description:

 	Shutdown a session.

Arguments:


Return Value:


--*/
{
	KIRQL		OldIrql;
	BOOLEAN		CompListen = FALSE;

	ASSERT(VALID_ASPCO(pAspConn));
	ASSERT(pAspConn->aspco_RefCount > 0);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCloseConn: Entered for Conn %lx\n", pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkCloseConnection: Close session from %d.%d for Session %d\n",
			pAspConn->aspco_WssRemoteAddr.ata_Network,
			pAspConn->aspco_WssRemoteAddr.ata_Node,
			pAspConn->aspco_SessionId));

	AtalkAspCleanupConnection(pAspConn);

	ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);

	pAspConn->aspco_Flags |= (ASPCO_CLOSING | ASPCO_LOCAL_CLOSE);

	RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);


	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCloseConnection: Done for %lx (%ld)\n",
			pAspConn, pAspConn->aspco_RefCount));

	// Let remaining cleanup happen during the Derefernce
	AtalkAspDereferenceConn(pAspConn);	// Remove the creation reference

#ifdef	PROFILING
	INTERLOCKED_DECREMENT_LONG( &AtalkStatistics.stat_CurAspSessions,
								&AtalkStatsLock.SpinLock);
#endif

	return STATUS_PENDING;
}


NTSTATUS
AtalkAspFreeConnection(
	IN	PASP_CONNOBJ			pAspConn
	)
/*++

Routine Description:

 	Shutdown a session.

Arguments:


Return Value:


--*/
{
	return STATUS_SUCCESS;
}



ATALK_ERROR
AtalkAspCleanupConnection(
	IN	PASP_CONNOBJ			pAspConn
	)
/*++

Routine Description:
	Cancel all I/O on this session. Complete pending replies and write
	continues with error.

Arguments:


Return Value:


--*/
{
	PASP_REQUEST	pAspReq;
	PASP_ADDROBJ	pAspAddr;
	ATALK_ERROR		Status;
	KIRQL			OldIrql;
	USHORT			XactId;
	BYTE			UserBytes[ATP_USERBYTES_SIZE];
	ATALK_ADDR		RemoteAddr;
	BOOLEAN			CancelTickle, AlreadyCleaning, fConnActive;
    ATALK_ERROR     error;


	ASSERT(VALID_ASPCO(pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCleanupConnection: For %lx\n", pAspConn));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
	CancelTickle = ((pAspConn->aspco_Flags & ASPCO_TICKLING) != 0);

    AlreadyCleaning = (pAspConn->aspco_Flags & ASPCO_CLEANING_UP) ? TRUE : FALSE;

	if (AlreadyCleaning)
    {
		pAspConn->aspco_Flags &= ~ASPCO_TICKLING;
    }
    fConnActive = (pAspConn->aspco_Flags & ASPCO_ACTIVE) ? TRUE : FALSE;

    pAspConn->aspco_Flags &= ~ASPCO_ACTIVE;

	pAspConn->aspco_Flags |= ASPCO_CLEANING_UP;
	RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

	if (AlreadyCleaning)
		return ATALK_NO_ERROR;

	pAspAddr = pAspConn->aspco_pAspAddr;
	ASSERT(VALID_ASPAO(pAspAddr));

	// Send a session close request, if this is an active connection
	if (fConnActive)
	{
		UserBytes[ASP_CMD_OFF] = ASP_CLOSE_SESSION;
		UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspco_SessionId;
		PUTSHORT2SHORT(UserBytes + ASP_ATTN_WORD_OFF, 0);
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("AtalkAspCleanupConnection: Sending close req for %lx\n",
				pAspConn));
		Status = AtalkAtpPostReq(pAspAddr->aspao_pSssAtpAddr,
								 &pAspConn->aspco_WssRemoteAddr,
								 &XactId,
								 ATP_REQ_REMOTE,		// Close session request is ALO
								 NULL,
								 0,
								 UserBytes,
								 NULL,
								 0,
								 ATP_RETRIES_FOR_ASP,
								 ATP_MAX_INTERVAL_FOR_ASP,
								 THIRTY_SEC_TIMER,
								 NULL,
								 NULL);

		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCleanupConn: AtalkAtpPostReq %ld\n", Status));
		}
	}

	// Cancel tickle packets
	if (CancelTickle)
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("AtalkAspCleanupConnection: Cancel tickle for %lx\n", pAspConn));
		Status = AtalkAtpCancelReq(pAspAddr->aspao_pSlsAtpAddr,
								   pAspConn->aspco_TickleXactId,
								   &pAspConn->aspco_WssRemoteAddr);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCleanupConn: AtalkAtpCancelReq %ld\n", Status));
		}
	}

	do
	{
		BOOLEAN		CancelReply = FALSE;

		ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
		for (pAspReq = pAspConn->aspco_pActiveReqs;
			 pAspReq != NULL;
			 pAspReq = pAspReq->asprq_Next)
		{
			ASSERT (VALID_ASPRQ(pAspReq));

			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
					("AtalkAspCleanupConnection: Found req %lx (%lx) for %lx\n",
					pAspReq, pAspReq->asprq_Flags, pAspConn));

			CancelReply = FALSE;

			if ((pAspReq->asprq_Flags & (ASPRQ_WRTCONT | ASPRQ_WRTCONT_CANCELLED)) == ASPRQ_WRTCONT)
			{
				pAspReq->asprq_Flags |= ASPRQ_WRTCONT_CANCELLED;
				RemoteAddr = pAspConn->aspco_WssRemoteAddr;
				break;
			}
			if ((pAspReq->asprq_Flags & (ASPRQ_REPLY | ASPRQ_REPLY_CANCELLED)) == ASPRQ_REPLY)
			{
				CancelReply = TRUE;
				pAspReq->asprq_Flags |= ASPRQ_REPLY_CANCELLED;
				break;
			}
		}

		RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

		if (pAspReq != NULL)
		{
			if (CancelReply)
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
						("AtalkAspCleanupConnection: Cancel reply for %lx, flag=%lx\n",
						pAspReq,pAspReq->asprq_Flags));

				error = AtalkAtpCancelResp(pAspReq->asprq_pAtpResp);

                if (!ATALK_SUCCESS(error))
                {
				    DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("AtalkAspCleanupConnection: AtalkAtpCancelResp failed %lx\n",error));
                }
			}
            else
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
						("AtalkAspCleanupConnection: Cancel wrtcont for %lx, flag=%lx\n",
						pAspReq,pAspReq->asprq_Flags));

				error = AtalkAtpCancelReq(pAspConn->aspco_pAspAddr->aspao_pSssAtpAddr,
								  pAspReq->asprq_WCXactId,
								  &RemoteAddr);

                if (!ATALK_SUCCESS(error))
                {
				    DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("AtalkAspCleanupConnection: AtalkAtpCancelReq failed %lx\n",error));
                }
			}
		}
		else
        {
            break;
        }
	} while (TRUE);

	return ATALK_NO_ERROR;
}

NTSTATUS FASTCALL
AtalkAspWriteContinue(
	IN	PREQUEST	  pRequest
    )
/*++

Routine Description:

	The response buffer is in the request itself.

Arguments:


Return Value:


--*/
{

	PASP_REQUEST	pAspReq;


	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
		("AtalkAspWriteContinue: Entered with pRequest %lx\n", pRequest));

	pAspReq = CONTAINING_RECORD(pRequest, ASP_REQUEST, asprq_Request);
	ASSERT (VALID_ASPRQ(pAspReq));

    if (pRequest->rq_WriteMdl != NULL)
    {
        atalkAspPostWriteContinue(pAspReq);
        return(STATUS_SUCCESS);
    }
    else
    {
	    DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
		    ("AtalkAspWriteContinue: buffer alloc failed, completing write with error\n"));

        atalkAspWriteContinueResp(ATALK_RESR_MEM, pAspReq, NULL, NULL, 0, NULL);
    }


    return(STATUS_SUCCESS);
}


NTSTATUS FASTCALL
AtalkAspReply(
	IN	PREQUEST				pRequest,	// Pointer to request
	IN	PBYTE					pResultCode	// Pointer to the 4-byte result
	)
/*++

Routine Description:

	The response buffer is in the request itself.

Arguments:


Return Value:


--*/
{
	PASP_REQUEST	pAspReq, *ppAspReq;
	PASP_CONNOBJ	pAspConn;
	PASP_ADDROBJ	pAspAddr;
	ATALK_ERROR		error;
	KIRQL			OldIrql;
	USHORT			ReplySize;

	pAspReq = CONTAINING_RECORD(pRequest, ASP_REQUEST, asprq_Request);
	ASSERT (VALID_ASPRQ(pAspReq));

	pAspConn = pAspReq->asprq_pAspConn;
	ASSERT(VALID_ASPCO(pAspConn));

	pAspAddr = pAspConn->aspco_pAspAddr;
	ASSERT(VALID_ASPAO(pAspAddr));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspReply: Entered for session %lx\n", pAspConn));
	
	ASSERT ((pAspReq->asprq_Flags & (ASPRQ_WRTCONT | ASPRQ_REPLY)) == 0);

	do
	{
		// Find and de-queue this request from the list
		ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
		
		for (ppAspReq = &pAspConn->aspco_pActiveReqs;
			 *ppAspReq != NULL;
			 ppAspReq = &(*ppAspReq)->asprq_Next)
		{
			if (pAspReq == *ppAspReq)
			{
				*ppAspReq = pAspReq->asprq_Next;
				pAspConn->aspco_cReqsInProcess --;
				pAspReq->asprq_Flags |= ASPRQ_REPLY;
				break;
			}
		}
		
		ASSERT(*ppAspReq == pAspReq->asprq_Next);
		
		if (pAspConn->aspco_Flags & (ASPCO_CLEANING_UP |
									 ASPCO_CLOSING |
									 ASPCO_LOCAL_CLOSE |
									 ASPCO_REMOTE_CLOSE))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspReply: Session Closing - session %x\n", pAspConn->aspco_SessionId));
			RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);
			pAspReq->asprq_Flags &= ~ASPRQ_REPLY;
			pAspReq->asprq_Flags |= ASPRQ_REPLY_ABORTED;
			error = ATALK_LOCAL_CLOSE;
			break;
		}
	
		RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);
	
		ReplySize = (USHORT)AtalkSizeMdlChain(pAspReq->asprq_Request.rq_ReplyMdl);
	
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("AtalkAspReply: Posting AtalkAtpPostResp for request %lx\n", pAspReq));
	
		error = AtalkAtpPostResp(pAspReq->asprq_pAtpResp,
								 &pAspReq->asprq_RemoteAddr,
								 pAspReq->asprq_Request.rq_ReplyMdl,
								 ReplySize,
								 pResultCode,
								 atalkAspReplyRelease,
								 pAspReq);

		if (!ATALK_SUCCESS(error))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspReply: AtalkAtpPostResp %ld\n", error));
		}
	} while (FALSE);

	if (!ATALK_SUCCESS(error))
	{
        if (error != ATALK_ATP_RESP_TOOMANY)
        {
		    atalkAspReplyRelease(error, pAspReq);
        }
	}

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspReply: Completing request %lx, Status %ld\n",
			pAspReq, error));

	return STATUS_PENDING;
}




LOCAL ATALK_ERROR FASTCALL
atalkAspPostWriteContinue(
	IN	PASP_REQUEST			pAspReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	PASP_CONNOBJ	pAspConn;
	PAMDL			pAMdl = NULL;
	BYTE			UserBytes[ATP_USERBYTES_SIZE];
	USHORT			RespSize;

	ASSERT (VALID_ASPRQ(pAspReq));

	pAspConn = pAspReq->asprq_pAspConn;
	ASSERT(VALID_ASPCO(pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspPostWriteContinue: Entered for session %lx\n", pAspConn));

	RespSize = (USHORT)AtalkSizeMdlChain(pAspReq->asprq_Request.rq_WriteMdl);
	ASSERT (RespSize <= ATP_MAX_TOTAL_RESPONSE_SIZE);

	if (RespSize > ATP_MAX_TOTAL_RESPONSE_SIZE)
		RespSize = ATP_MAX_TOTAL_RESPONSE_SIZE;

	ASSERT (!(pAspReq->asprq_Flags & (ASPRQ_WRTCONT | ASPRQ_WRTCONT_CANCELLED)));

	pAspReq->asprq_Flags |= ASPRQ_WRTCONT;

	do
	{
		// We need to build an AMdl for two bytes of response which
		// indicates how much data we are expecting !!!
		if ((pAMdl = AtalkAllocAMdl(pAspReq->asprq_WrtContRespBuf,
									ASP_WRITE_DATA_SIZE)) == NULL)
		{
			error = ATALK_RESR_MEM;
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspWriteContinue: AtalkAllocMdl failed for 2 bytes !!\n"));
		}

		else
		{
			PBYTE	pWrtData;

			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
					("AtalkAspWriteContinue: Posting AtalkAtpPostReq for request %lx\n",
					pAspReq));

			pWrtData = AtalkGetAddressFromMdlSafe(pAMdl, NormalPagePriority);
			if (pWrtData == NULL)
			{
				if (pAMdl != NULL)
                {
					AtalkFreeAMdl(pAMdl);
                }
				error = ATALK_RESR_MEM;
                break;
			}

			UserBytes[ASP_CMD_OFF] = ASP_WRITE_DATA;
			UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspco_SessionId;
			PUTSHORT2SHORT(UserBytes+ASP_SEQUENCE_NUM_OFF, pAspReq->asprq_SeqNum);
			PUTSHORT2SHORT(pWrtData, RespSize);

			// Snapshot the current tick count. We use this to adjust the retry times on
			// write continue.
			pAspConn->aspco_RT.rt_New = AtalkGetCurrentTick();
			error = AtalkAtpPostReq(pAspConn->aspco_pAspAddr->aspao_pSssAtpAddr,
									&pAspConn->aspco_WssRemoteAddr,
									&pAspReq->asprq_WCXactId,
									ATP_REQ_EXACTLY_ONCE | ATP_REQ_REMOTE,
									pAMdl,
									ASP_WRITE_DATA_SIZE,
									UserBytes,
									pAspReq->asprq_Request.rq_WriteMdl,
									RespSize,
									ATP_INFINITE_RETRIES,
									pAspConn->aspco_RT.rt_Base,
									THIRTY_SEC_TIMER,
									atalkAspWriteContinueResp,
									pAspReq);
			if (!ATALK_SUCCESS(error))
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("AtalkAspWriteContinue: AtalkAtpPostReq %ld\n", error));
			}
		}

		if (!ATALK_SUCCESS(error))
		{
			if (pAMdl != NULL)
				AtalkFreeAMdl(pAMdl);
		}
	} while (FALSE);

	return error;
}




NTSTATUS
AtalkAspSendAttention(
	IN	PASP_CONNOBJ			pAspConn,
	IN	USHORT					AttentionWord,
	IN	PVOID					pContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	NTSTATUS		Status = STATUS_SUCCESS;
	KIRQL			OldIrql;
	PAMDL			pAMdl = NULL;
	BYTE			UserBytes[ATP_USERBYTES_SIZE];
	USHORT			XactId, RespSize = 16;		// Some small number (see comment below)


	ASSERT(VALID_ASPCO(pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspSendAttention: Entered for session %lx\n", pAspConn));

	// Reference by src addr here instead of by pointer since the former will
	// fail when the session is in one of the stages of death whereas the
	// latter will not. Also this assumes that it is called at dispatch so raise irql.
	KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
	pAspConn = atalkAspReferenceConnBySrcAddr(pAspConn->aspco_pAspAddr,
											  &pAspConn->aspco_WssRemoteAddr,
											  pAspConn->aspco_SessionId);
	KeLowerIrql(OldIrql);

	if (pAspConn == NULL)
		return STATUS_REQUEST_NOT_ACCEPTED;

	UserBytes[ASP_CMD_OFF] = ASP_ATTENTION;
	UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspco_SessionId;
	PUTSHORT2SHORT(UserBytes+ASP_ATTN_WORD_OFF, AttentionWord);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspSendAttention: Posting AtalkAtpPostReq for Conn %lx\n", pAspConn));

	// We need to build an AMdl for a dummy buffer to hold the response.
	// There is no real response but some clients fry their
	// machines if we don't !!! If we cannot allocate the mdl we we go
	// ahead anyway.
	if ((pAMdl = AtalkAllocAMdl(NULL, RespSize)) == NULL)
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("AtalkAspSendAttention: AtalkAllocMdl failed for dummy buffer !!\n"));
		RespSize = 0;
	}
	pAspConn->aspco_AttentionContext = pContext;

	error = AtalkAtpPostReq(pAspConn->aspco_pAspAddr->aspao_pSssAtpAddr,
							&pAspConn->aspco_WssRemoteAddr,
							&XactId,
							ATP_REQ_REMOTE,		// SendAttention is ALO
							NULL,
							0,
							UserBytes,
							pAMdl,
							RespSize,
							ATP_RETRIES_FOR_ASP,
							ATP_MAX_INTERVAL_FOR_ASP,
							THIRTY_SEC_TIMER,
							atalkAspSendAttentionResp,
							pAspConn);
	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("AtalkAspSendAttention: AtalkAtpPostReq %ld\n", Status));
		Status = AtalkErrorToNtStatus(error);
		atalkAspSendAttentionResp(error,
								  pAspConn,
								  NULL,
								  pAMdl,
								  RespSize,
								  UserBytes);
	}

	return Status;
}




PASP_ADDROBJ FASTCALL
AtalkAspReferenceAddr(
	IN	PASP_ADDROBJ		pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	PASP_ADDROBJ	pRefAddr;

	ASSERT(VALID_ASPAO(pAspAddr));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspReferenceAddr: Addr %lx, PreCount %ld\n",
			pAspAddr, pAspAddr->aspao_RefCount));

	pRefAddr = pAspAddr;
	ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);

	ASSERT(pAspAddr->aspao_RefCount > 1);

	if (pAspAddr->aspao_Flags & ASPAO_CLOSING)
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("AtalkAspReferenceAddr: Referencing closing object %lx!!\n",
				pAspAddr));
		pRefAddr = NULL;
	}
	else pAspAddr->aspao_RefCount ++;

	RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

	return pRefAddr;
}




VOID FASTCALL
AtalkAspDereferenceAddr(
	IN	PASP_ADDROBJ		pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL			OldIrql;
	BOOLEAN			Cleanup;

	ASSERT(VALID_ASPAO(pAspAddr));

	ASSERT (pAspAddr->aspao_RefCount > 0);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspDereferenceAddr: Addr %lx, PreCount %ld\n",
			pAspAddr, pAspAddr->aspao_RefCount));

	ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);

	pAspAddr->aspao_RefCount --;

	Cleanup = FALSE;
	if (pAspAddr->aspao_RefCount == 0)
	{
		ASSERT (pAspAddr->aspao_Flags & ASPAO_CLOSING);
		Cleanup = TRUE;
	}

	RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

	// Check if this address object is history. Do all the processing needed to make this go
	// away. When all is done, clear the event to signal close is complete
	if (Cleanup)
	{
		// At this point we are sure that no active sessions exist on this
		// address.
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
				("AtalkAspDereferenceAddr: Cleaning up addr %lx\n", pAspAddr));

		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
				("AtalkAspDereferenceAddr: Indicating close for %lx\n", pAspAddr));

		ASSERT(KeGetCurrentIrql() == LOW_LEVEL);

		// Call the completion routine to indicate close is successfull
		if (pAspAddr->aspao_CloseCompletion != NULL)
			(*pAspAddr->aspao_CloseCompletion)(ATALK_NO_ERROR,
											   pAspAddr->aspao_CloseContext);
		// Finally free the memory
		AtalkFreeMemory(pAspAddr);

		AtalkUnlockAspIfNecessary();
	}
}



LOCAL PASP_CONNOBJ
atalkAspReferenceConnBySrcAddr(
	IN	PASP_ADDROBJ	pAspAddr,
	IN	PATALK_ADDR		pSrcAddr,
	IN	BYTE			SessionId
	)
/*++

Routine Description:

 	ASP has the concept of 8-bit session ids which uniquely identifies a
 	session on a listener. This effectively restricts the number of sessions
 	to 255 (0 is invalid). To eliminate the restriction, the following
 	strategy is used.
 	a, Atp is modified to isolate the transaction ids on a per addr basis
 	   i.e. it monotonically increases for each <net,node,socket> combination.
 	b, We create session ids on a per <net,node> basis.

 	Given the following observed facts:
 	1, That macintoshes use the sockets starting from the top of the range.
 	2, Most network addresses have the same high byte - macintoshes tend
 	   to start from the bottom of the range.
 	3, We allocate session ids starting from 1 and most (all) clients will
 	   not have more than one session with us.

 	It does not make any sense to take either the socket, session id or the
 	high byte of the network number into account. That leaves only the low
 	byte of the network, and node id - a nice 16-bit number to hash.

Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn, pRefConn = NULL;
	int				index;

	ASSERT(VALID_ASPAO(pAspAddr));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspReferenceConnBySrcAddr: Addr %lx, Source %x.%x SessionId %d\n",
			pAspAddr, pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));

	index = HASH_SRCADDR(pSrcAddr);
	ACQUIRE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

	for (pAspConn = pAspAddr->aspao_pSessions[index];
		 pAspConn != NULL;
		 pAspConn = pAspConn->aspco_NextOverflow)
	{
		if ((pSrcAddr->ata_Network == pAspConn->aspco_WssRemoteAddr.ata_Network) &&
			(pSrcAddr->ata_Node == pAspConn->aspco_WssRemoteAddr.ata_Node) &&
			(pAspConn->aspco_SessionId == SessionId))
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
			if ((pAspConn->aspco_Flags & (ASPCO_CLOSING |
										  ASPCO_CLEANING_UP |
										  ASPCO_LOCAL_CLOSE |
										  ASPCO_REMOTE_CLOSE)) == 0)
			{
				ASSERT(pAspConn->aspco_RefCount > 0);
				pAspConn->aspco_RefCount ++;

				pRefConn = pAspConn;
			}
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
			break;
		}
	}

	RELEASE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

	return pRefConn;
}




VOID FASTCALL
AtalkAspDereferenceConn(
	IN	PASP_CONNOBJ		pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASP_ADDROBJ		pAspAddr = pAspConn->aspco_pAspAddr;
	KIRQL				OldIrql;
	PASP_REQUEST		pAspReq;
	BOOLEAN				Cleanup = FALSE;

	ASSERT(VALID_ASPCO(pAspConn));

	ASSERT (pAspConn->aspco_RefCount > 0);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspDereferenceConn: Conn %lx, PreCount %ld\n",
			pAspConn, pAspConn->aspco_RefCount));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);

	pAspConn->aspco_RefCount --;

	if (pAspConn->aspco_RefCount == 0)
	{
		Cleanup = TRUE;
	}

	RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

	if (!Cleanup)
	{
		return;
	}

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkAspDereferenceConn: Last for %lx\n", pAspConn));

	// The connection is all but dead. Perform the last rites. If its an
	// active session that we're about to shut down, send a close notification
	// to the other side. If it is a remote close, we've already responded to it.

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkAspDereferenceConn: Cleaning up Conn %lx\n", pAspConn));

	ASSERT(VALID_ASPAO(pAspAddr));

	// The connection is in one of the following states:
	// a, Closed remotely - idle
	// b, Active
	//
	// In either case it is in the hash bucket so unlink it
	{
		PASP_CONNOBJ *	ppAspConn;
		int				index;

		// The connection was active. This is linked into two different
		// lists. Unlink from the hash table here and from the global
		// list later.
		ASSERT(pAspConn->aspco_pActiveReqs == NULL);
		index = HASH_SRCADDR(&pAspConn->aspco_WssRemoteAddr);

		ACQUIRE_SPIN_LOCK(&pAspAddr->aspao_Lock, &OldIrql);
		for (ppAspConn = &pAspAddr->aspao_pSessions[index];
			 *ppAspConn != NULL;
			 ppAspConn = &(*ppAspConn)->aspco_NextOverflow)
		{
			if (pAspConn == *ppAspConn)
			{
				*ppAspConn = pAspConn->aspco_NextOverflow;
				break;
			}
		}
		RELEASE_SPIN_LOCK(&pAspAddr->aspao_Lock, OldIrql);

		ASSERT (*ppAspConn == pAspConn->aspco_NextOverflow);
	}

	ACQUIRE_SPIN_LOCK(&atalkAspLock, &OldIrql);

    ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

	AtalkUnlinkDouble(pAspConn,
					  aspco_NextSession,
					  aspco_PrevSession)


	// Free any requests on the free list
	while ((pAspReq = pAspConn->aspco_pFreeReqs) != NULL)
	{
		pAspConn->aspco_pFreeReqs = pAspReq->asprq_Next;
		AtalkBPFreeBlock(pAspReq);
	}

    RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

	RELEASE_SPIN_LOCK(&atalkAspLock, OldIrql);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("AtalkAspDereferenceConn: Indicating close for Conn %lx\n", pAspConn));

	// Call the completion routine to indicate close is successful.
	(*pAspAddr->aspao_ClientEntries.clt_CloseCompletion)(STATUS_SUCCESS,
														 pAspConn->aspco_ConnContext);

	// Now Dereference the address object, before we are history
	AtalkAspDereferenceAddr(pAspAddr);

	// Finally free the memory.
	AtalkFreeMemory(pAspConn);
}




LOCAL VOID
atalkAspSlsXHandler(
	IN	ATALK_ERROR			ErrorCode,
	IN	PASP_ADDROBJ		pAspAddr,		// Listener (our context)
	IN	PATP_RESP			pAtpResp,		// Atp Response context
	IN	PATALK_ADDR			pSrcAddr,		// Address of requestor
	IN	USHORT				PktLen,
	IN	PBYTE				pPkt,
	IN	PBYTE				pUserBytes
	)
/*++

Routine Description:

 	Handler for incoming requests on the Sls. It handles session opens, tickles
 	and get status on the session.

Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ		pAspConn;
	ATALK_ERROR			Status;
	PASP_POSTSTAT_CTX	pStsCtx;
	int					index;
	USHORT				StsBufSize;
	BYTE				AspCmd, SessionId, StartId;
    BOOLEAN             fAddrRefed=FALSE;


	if (!ATALK_SUCCESS(ErrorCode))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
				("atalkAspSlsXHandler: Error %ld\n", ErrorCode));

		// Take away the reference on the Sls now that the atp address is closing
		if (ErrorCode == ATALK_ATP_CLOSING)
			AtalkAspDereferenceAddr(pAspAddr);
		return;
	}

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspSlsXHandler: Entered for Function %x from %x.%x\n",
			pUserBytes[ASP_CMD_OFF], pSrcAddr->ata_Network, pSrcAddr->ata_Node));

	switch (AspCmd = pUserBytes[ASP_CMD_OFF])
	{
	  case ASP_OPEN_SESSION:
		// Is the version number ok ?
		if ((pUserBytes[ASP_VERSION_OFF] != ASP_VERSION[0]) ||
			(pUserBytes[ASP_VERSION_OFF+1] != ASP_VERSION[1]))
		{
			atalkAspReturnResp( pAtpResp,
								pSrcAddr,
								0,					// SSS
								0,					// SessionId
								ASP_BAD_VERSION);	// ErrorCode
			break;
		}

		// Create a connection object corres. to this listen and then notify
		// the client that it needs to handle a new session
		// Allocate memory for a connection object
		if ((pAspConn = AtalkAllocZeroedMemory(sizeof(ASP_CONNOBJ))) != NULL)
		{
#if	DBG
			pAspConn->aspco_Signature = ASPCO_SIGNATURE;
#endif
			INITIALIZE_SPIN_LOCK(&pAspConn->aspco_Lock);
			pAspConn->aspco_RefCount = 1;				// Creation reference
			pAspConn->aspco_pAspAddr = pAspAddr;		// Owning address object
			AtalkInitializeRT(&pAspConn->aspco_RT,
							  ATP_INITIAL_INTERVAL_FOR_ASP,
							  ATP_MIN_INTERVAL_FOR_ASP,
							  ATP_MAX_INTERVAL_FOR_ASP);
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

		if (pAspConn != NULL)
		{
			PASP_CONNOBJ	pTmp;

			// Find a session id that we can use for this session. We use
			// the next assignable id, if that is not in use. Otherwise we
			// use the next id not in use by that session. In most cases
			// we have only one session from any client.
			index = HASH_SRCADDR(pSrcAddr);

			// If we do not find any, we use this
			SessionId = StartId = pAspAddr->aspao_NextSessionId++;
			ASSERT (SessionId != 0);
			if (pAspAddr->aspao_NextSessionId == 0)
				pAspAddr->aspao_NextSessionId = 1;

			for (pTmp = pAspAddr->aspao_pSessions[index];
				 pTmp != NULL;
				 NOTHING)
			{
				if ((pTmp->aspco_WssRemoteAddr.ata_Node == pSrcAddr->ata_Node) &&
					(pTmp->aspco_WssRemoteAddr.ata_Network == pSrcAddr->ata_Network))
				{
					if (pTmp->aspco_SessionId == SessionId)
					{
                        // if we have cycled through all, get out!
                        if (SessionId == (StartId - 1))
                        {
                            break;
                        }

						SessionId ++;
                        if (SessionId == 0)
                        {
                            // all sessions are taken: quit here!
                            if (StartId == 1)
                            {
                                break;
                            }
                            SessionId = 1;
                        }
						pTmp = pAspAddr->aspao_pSessions[index];
						continue;
					}
				}
				pTmp = pTmp->aspco_NextOverflow;
			}

			// if there are 255 sessions already from this address, then
			// we can't have any more, sorry !!!
			if (SessionId != (StartId - 1))
			{
				// Link it into the hash table
				pAspAddr->aspao_RefCount ++;
                fAddrRefed = TRUE;

				pAspConn->aspco_SessionId = SessionId;
				pAspConn->aspco_cReqsInProcess = 0;
				pAspConn->aspco_WssRemoteAddr.ata_Address = pSrcAddr->ata_Address;
				pAspConn->aspco_WssRemoteAddr.ata_Socket = pUserBytes[ASP_WSS_OFF];
				pAspConn->aspco_LastContactTime = AtalkGetCurrentTick();
				pAspConn->aspco_NextExpectedSeqNum = 0;
				pAspConn->aspco_Flags |= (ASPCO_ACTIVE | ASPCO_TICKLING);

				// The session should be linked *after* all of the above
				// are initialized
				pAspConn->aspco_NextOverflow = pAspAddr->aspao_pSessions[index];
				pAspAddr->aspao_pSessions[index] = pAspConn;
#ifdef	PROFILING
				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_CurAspSessions,
											   &AtalkStatsLock.SpinLock);

				INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_TotalAspSessions,
											   &AtalkStatsLock.SpinLock);
#endif
			}
			else
			{
				AtalkFreeMemory(pAspConn);
				pAspConn = NULL;
			}
		}

		RELEASE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

		if (pAspConn != NULL)
		{
			BYTE	Socket;
			BYTE	UserBytes[ATP_USERBYTES_SIZE];

			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
					("atalkAspSlsXHandler: Opening session from %d.%d for Session %d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));


			// Call the open completion routine and get a context. This is needed
			// before we do anything else. Once we send out an open success it'll
			// be too late.
            // FALSE says this is not over TCP/IP
			pAspConn->aspco_ConnContext =
				(*pAspAddr->aspao_ClientEntries.clt_SessionNotify)(pAspConn,FALSE);

			if (pAspConn->aspco_ConnContext != NULL)
			{
				// Now link the session into the global list
				ACQUIRE_SPIN_LOCK_DPC(&atalkAspLock);
				AtalkLinkDoubleAtHead(atalkAspConnMaint[SessionId & (NUM_ASP_CONN_LISTS-1)].ascm_ConnList,
									  pAspConn,
									  aspco_NextSession,
									  aspco_PrevSession)
				RELEASE_SPIN_LOCK_DPC(&atalkAspLock);
	
				// Send an open session response - XO
				Socket = pAspAddr->aspao_pSssAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Socket;
				atalkAspReturnResp( pAtpResp,
									pSrcAddr,
									Socket,
									pAspConn->aspco_SessionId,
									0);				// Success
	
				// Send a tickle out every ASP_TICKLE_INTERVAL seconds
				UserBytes[ASP_CMD_OFF] = ASP_TICKLE;
				UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspco_SessionId;
				PUTSHORT2SHORT(UserBytes + ASP_ERRORCODE_OFF, 0);
				Status = AtalkAtpPostReq(pAspAddr->aspao_pSlsAtpAddr,
										&pAspConn->aspco_WssRemoteAddr,
										&pAspConn->aspco_TickleXactId,
										ATP_REQ_REMOTE,		// Tickle packets are ALO
										NULL,
										0,
										UserBytes,
										NULL,
										0,
										ATP_INFINITE_RETRIES,
										ASP_TICKLE_INTERVAL,
										THIRTY_SEC_TIMER,
										NULL,
										NULL);
				if (!ATALK_SUCCESS(Status))
				{
					pAspConn->aspco_Flags &= ~ASPCO_TICKLING;
					DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
							("atalkAspSlsXHandler: AtalkAtpPostReq %ld\n", Status));
				}
			}
			else
			{
				PASP_CONNOBJ *	ppAspConn;

				// Unlink it from the hash table
				ACQUIRE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

				for (ppAspConn = &pAspAddr->aspao_pSessions[index];
					 *ppAspConn != NULL;
					 ppAspConn = &(*ppAspConn)->aspco_NextOverflow)
				{
					if (*ppAspConn == pAspConn)
					{
						*ppAspConn = pAspConn->aspco_NextOverflow;
						break;
					}
				}

				ASSERT (*ppAspConn == pAspConn->aspco_NextOverflow);

				RELEASE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

				AtalkFreeMemory(pAspConn);
				pAspConn = NULL;
#ifdef	PROFILING
				INTERLOCKED_DECREMENT_LONG_DPC(&AtalkStatistics.stat_CurAspSessions,
											   &AtalkStatsLock.SpinLock);

				INTERLOCKED_DECREMENT_LONG_DPC(&AtalkStatistics.stat_TotalAspSessions,
											   &AtalkStatsLock.SpinLock);
#endif
			}
		}

		// If we are set to disable listens or could not allocate memory, drop it
		if (pAspConn == NULL)
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSlsXHandler: No conn objects available\n"));

			atalkAspReturnResp( pAtpResp,
								pSrcAddr,
								0,
								0,
								ASP_SERVER_BUSY);

            // remove that refcount if we put it in hoping afp would accept the request
            if (fAddrRefed)
            {
                AtalkAspDereferenceAddr(pAspAddr);
            }
		}
		break;

	  case ASP_GET_STATUS:
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("atalkAspSssXHandler: Received GetStat from %x.%x\n",
				pSrcAddr->ata_Network, pSrcAddr->ata_Node));
		// Create an Mdl to describe the status buffer and post a response
		// to the GetStatus request
		StsBufSize = 0;
        pStsCtx = NULL;
		ACQUIRE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);
		if (pAspAddr->aspao_pStatusBuf != NULL)
		{
			pStsCtx = (PASP_POSTSTAT_CTX)AtalkAllocMemory(sizeof(ASP_POSTSTAT_CTX) +
														  pAspAddr->aspao_StsBufSize);
			if (pStsCtx != NULL)
			{
				pStsCtx->aps_pAMdl = AtalkAllocAMdl((PBYTE)pStsCtx + sizeof(ASP_POSTSTAT_CTX),
													pAspAddr->aspao_StsBufSize);
				if (pStsCtx->aps_pAMdl != NULL)
				{
					pStsCtx->aps_pAtpResp = pAtpResp;
					StsBufSize = pAspAddr->aspao_StsBufSize;
					RtlCopyMemory((PBYTE)pStsCtx + sizeof(ASP_POSTSTAT_CTX),
								  pAspAddr->aspao_pStatusBuf,
								  StsBufSize);
				}
				else
                {
                    AtalkFreeMemory(pStsCtx);
                    pStsCtx = NULL;
                    StsBufSize = 0;
                }
			}
		}
		RELEASE_SPIN_LOCK_DPC(&pAspAddr->aspao_Lock);

		Status = AtalkAtpPostResp(pAtpResp,
								  pSrcAddr,
								  (pStsCtx != NULL) ?
									pStsCtx->aps_pAMdl : NULL,
								  StsBufSize,
								  NULL,
								  atalkAspRespComplete,
								  pStsCtx);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSlsXHandler: AtalkAtpPostResp %ld\n", Status));
			atalkAspRespComplete(Status, pStsCtx);
		}
		break;

	  case ASP_TICKLE:
		SessionId = pUserBytes[ASP_SESSIONID_OFF];
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("atalkAspSssXHandler: Received tickle from %x.%x Session %d\n",
				pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));

		if ((pAspConn = atalkAspReferenceConnBySrcAddr(pAspAddr, pSrcAddr, SessionId)) != NULL)
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

			pAspConn->aspco_LastContactTime = AtalkGetCurrentTick();
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
			AtalkAspDereferenceConn(pAspConn);
		}
		else
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSssXHandler: Conn not found for addr %d.%d Session %d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));
		}
		// Fall through to the default case

	  default:
		// Cancel this response since we never respond to it and we want this to go away
		AtalkAtpCancelResp(pAtpResp);

	  	if (AspCmd != ASP_TICKLE)
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSlsXHandler: Invalid command\n"));
		}
		break;
	}
}




LOCAL VOID
atalkAspSssXHandler(
	IN	ATALK_ERROR			ErrorCode,
	IN	PASP_ADDROBJ		pAspAddr,		// Listener (our context)
	IN	PATP_RESP			pAtpResp,		// Atp Response context
	IN	PATALK_ADDR			pSrcAddr,		// Address of requestor
	IN	USHORT				PktLen,
	IN	PBYTE				pPkt,
	IN	PBYTE				pUserBytes
	)
/*++

Routine Description:

 	Handler for incoming requests on the Sss. It handles incoming requests, close
 	and write continue.

Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn;		// Session which will handle this request
	PASP_REQUEST	pAspReq;		// The request that will be satisfied
	ATALK_ERROR		Status;
    NTSTATUS        retStatus;
	USHORT			SequenceNum;	// From the incoming packet
	BYTE			SessionId;		// -- ditto --
	BYTE			RequestType;	// -- ditto --
	BOOLEAN			CancelResp = FALSE,
	                CancelTickle;
    BOOLEAN         fTellAfp=TRUE;

	do
	{
		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
					("atalkAspSssXHandler: Error %ld\n", ErrorCode));
			// Take away the reference on the Sls now that the atp address is closing
			if (ErrorCode == ATALK_ATP_CLOSING)
				AtalkAspDereferenceAddr(pAspAddr);
			break;
		}
	
		// Get the session id out of the packet and reference the session that this
		// request is targeted to.
		SessionId = pUserBytes[ASP_SESSIONID_OFF];
		RequestType = pUserBytes[ASP_CMD_OFF];
		GETSHORT2SHORT(&SequenceNum, pUserBytes+ASP_SEQUENCE_NUM_OFF);
	
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("atalkAspSssXHandler: Entered for Request %x from %x.%x\n",
				RequestType, pSrcAddr->ata_Network, pSrcAddr->ata_Node));
	
		// The reference for this connection is passed down to the request
		// for the ASP_CMD & ASP_WRITE case.
		pAspConn = atalkAspReferenceConnBySrcAddr(pAspAddr, pSrcAddr, SessionId);
		if (pAspConn == NULL)
		{
			CancelResp = TRUE;
			break;
		}
	
		ASSERT (pAspConn->aspco_pAspAddr == pAspAddr);
	
		ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
		pAspConn->aspco_LastContactTime = AtalkGetCurrentTick();
	
		switch (RequestType)
		{
		  case ASP_CMD:
		  case ASP_WRITE:
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
					("atalkAspSssXHandler: %s\n",
					(RequestType == ASP_CMD) ? "Command" : "Write"));
			// Create a request for this and notify the client to handle this
			// Validate the incoming sequence number. Reject if out of sequence
			if (SequenceNum == pAspConn->aspco_NextExpectedSeqNum)
			{
				// We now have a request to be handled.
				// The reference to the connection above will be passed on
				// to the request. This will get de-referenced when the
				// request is replied to. See if we have a free request to pick up
				// Allocate a request structure if not and link it in the listener object
				if ((pAspReq = pAspConn->aspco_pFreeReqs) != NULL)
					 pAspConn->aspco_pFreeReqs = pAspReq->asprq_Next;
				else pAspReq = AtalkBPAllocBlock(BLKID_ASPREQ);
	
				if (pAspReq != NULL)
				{
					pAspConn->aspco_NextExpectedSeqNum ++;
#if	DBG
					pAspReq->asprq_Signature = ASPRQ_SIGNATURE;
#endif
					pAspReq->asprq_pAtpResp = pAtpResp;
					pAspReq->asprq_pAspConn = pAspConn;
					pAspReq->asprq_ReqType = RequestType;
					pAspReq->asprq_SeqNum = SequenceNum;
					pAspReq->asprq_RemoteAddr = *pSrcAddr;
					pAspReq->asprq_Flags = 0;
					pAspReq->asprq_Request.rq_WriteMdl = NULL;
					pAspReq->asprq_Request.rq_CacheMgrContext = NULL;
					pAspReq->asprq_Request.rq_RequestSize = PktLen;
					pAspReq->asprq_Next = pAspConn->aspco_pActiveReqs;
					pAspConn->aspco_cReqsInProcess ++;
					pAspConn->aspco_pActiveReqs = pAspReq;

		            ASSERT ((pAspConn->aspco_Flags & (ASPCO_CLEANING_UP |
									                 ASPCO_CLOSING |
									                 ASPCO_LOCAL_CLOSE |
									                 ASPCO_REMOTE_CLOSE)) == 0);
				}
			}
			else
			{
				pAspReq = NULL;
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("atalkAspSssXHandler: Sequence mismatch exp %x, act %x\n",
						pAspConn->aspco_NextExpectedSeqNum, SequenceNum));
			}
	
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
	
			// If we do not have an request to handle this, cancel the
			// response. Otherwise the client will keep retrying and atp
			// will not tell us since it already has.
			if (pAspReq == NULL)
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("atalkAspSssXHandler: Dropping request for session %d from %d.%d\n",
						SessionId, pSrcAddr->ata_Network, pSrcAddr->ata_Node));

				CancelResp = TRUE;
				AtalkAspDereferenceConn(pAspConn);
				break;
			}
	
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
					("atalkAspSssXHandler: Indicating Request %lx\n", pAspReq));
	
			if (RequestType == ASP_WRITE)
			{
                if (PktLen > MAX_WRITE_REQ_SIZE)
                {
                    PASP_REQUEST  *ppTmpAspReq;

                    ASSERT(0);
                    ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
                    for (ppTmpAspReq = &pAspConn->aspco_pActiveReqs;
                         *ppTmpAspReq != NULL; ppTmpAspReq = &(*ppTmpAspReq)->asprq_Next )
                    {
                        if (pAspReq == *ppTmpAspReq)
                        {
                            *ppTmpAspReq = pAspReq->asprq_Next;
                            break;
                        }
                    }
                    RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
				    AtalkAspDereferenceConn(pAspConn);
                    AtalkBPFreeBlock(pAspReq);
                    pAspReq = NULL;
                    CancelResp = TRUE;
                    break;
                }

				RtlCopyMemory(pAspReq->asprq_ReqBuf, pPkt, PktLen);
				pAspReq->asprq_Request.rq_RequestBuf = pAspReq->asprq_ReqBuf;

				retStatus = (*pAspAddr->aspao_ClientEntries.clt_GetWriteBuffer)
                            (pAspConn->aspco_ConnContext,&pAspReq->asprq_Request);

                //
                // most common case: file server will pend it so it can go to cache mgr
                //
                if (retStatus == STATUS_PENDING)
                {
                    fTellAfp = FALSE;
                    break;
                }
                else if (retStatus == STATUS_SUCCESS)
                {
                    if (pAspReq->asprq_Request.rq_WriteMdl != NULL)
                    {
					    atalkAspPostWriteContinue(pAspReq);

                        // we informed (or will inform) AFP about this request: don't
                        // inform again below!
                        fTellAfp = FALSE;
                    }
                }
				else
				{
			        DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					    ("atalkAspSssXHandler: GetWriteBuffer returned %lx on %lx\n",
                        retStatus,pAspConn));
				}
			}

            // TRUE for CMD as well
			if ((pAspReq->asprq_Request.rq_WriteMdl == NULL) &&
                (fTellAfp))
			{
				pAspReq->asprq_Request.rq_RequestBuf = pPkt;

                ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

				// Notify the client that it has a request to handle
				retStatus = (*pAspAddr->aspao_ClientEntries.clt_RequestNotify)
                                (STATUS_SUCCESS,
								 pAspConn->aspco_ConnContext,
								 &pAspReq->asprq_Request);

                if (!NT_SUCCESS(retStatus))
                {
                    PASP_REQUEST  *ppTmpAspReq;

			        DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					    ("atalkAspSssXHandler: Afp didn't accept request %lx on conn %lx\n",
                        pAspReq,pAspConn));

                    ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
                    for (ppTmpAspReq = &pAspConn->aspco_pActiveReqs;
                         *ppTmpAspReq != NULL; ppTmpAspReq = &(*ppTmpAspReq)->asprq_Next )
                    {
                        if (pAspReq == *ppTmpAspReq)
                        {
                            *ppTmpAspReq = pAspReq->asprq_Next;
                            break;
                        }
                    }
                    RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

				    AtalkAspDereferenceConn(pAspConn);
                    AtalkBPFreeBlock(pAspReq);
                    pAspReq = NULL;
                    CancelResp = TRUE;
                }
			}
			break;
	
		  case ASP_CLOSE_SESSION:
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
					("atalkAspSssXHandler: Close request from %d.%d for Session %d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));
	
#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AspSessionsClosed,
										   &AtalkStatsLock.SpinLock);
#endif

			CancelTickle = ((pAspConn->aspco_Flags &ASPCO_TICKLING) != 0);
			pAspConn->aspco_Flags &= ~(ASPCO_ACTIVE | ASPCO_TICKLING);
			pAspConn->aspco_Flags |= ASPCO_REMOTE_CLOSE;
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
	
			// Send a CloseSession reply and close the session
			Status = AtalkAtpPostResp(pAtpResp,
									  pSrcAddr,
									  NULL,
									  0,
									  NULL,
									  AtalkAtpGenericRespComplete,
									  pAtpResp);
			if (!ATALK_SUCCESS(Status))
			{
				AtalkAtpGenericRespComplete(Status, pAtpResp);
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("atalkAspSssXHandler: AtalkAtpPostResp failed %ld\n", Status));
			}
	
			// Cancel the tickle requests for this session
			if (CancelTickle)
			{
				Status = AtalkAtpCancelReq(pAspAddr->aspao_pSlsAtpAddr,
										   pAspConn->aspco_TickleXactId,
										   &pAspConn->aspco_WssRemoteAddr);
		
				if (!ATALK_SUCCESS(Status))
				{
					DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
							("atalkAspSssXHandler: AtalkAtpCancelReq %ld\n", Status));
				}
			}
	
			// Shut down this session, well almost ... Note that we have a reference
			// to this connection which will be Dereferenced by atalkAspSessionClose.
			atalkAspSessionClose(pAspConn);
			break;
	
		  default:
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);
			CancelResp = TRUE;
			AtalkAspDereferenceConn(pAspConn);
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSssXHandler: Invalid command %d\n", RequestType));
			break;
		}
	} while (FALSE);

	if (CancelResp)
	{
		Status = AtalkAtpCancelResp(pAtpResp);
		if (!ATALK_SUCCESS(Status))
		{
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("atalkAspSssXHandler: AtalkAspCancelResp %ld\n", Status));
		}
	}
}




LOCAL VOID FASTCALL
atalkAspReplyRelease(
	IN	ATALK_ERROR		ErrorCode,
	IN	PASP_REQUEST	pAspReq
	)
/*++

Routine Description:

 	Handler for incoming release for reply

Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn;
	PASP_ADDROBJ	pAspAddr;
	KIRQL			OldIrql;
	NTSTATUS		Status = STATUS_SUCCESS;

	ASSERT (VALID_ASPRQ(pAspReq));
	pAspConn = pAspReq->asprq_pAspConn;
	ASSERT (VALID_ASPCO(pAspConn));

	pAspAddr = pAspConn->aspco_pAspAddr;
	ASSERT (VALID_ASPAO(pAspAddr));

	ASSERT ((pAspReq->asprq_Flags & ASPRQ_REPLY) || !ATALK_SUCCESS(ErrorCode));

	if (!NT_SUCCESS(ErrorCode))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
				("atalkAspReplyRelease: Failure %ld\n", ErrorCode));
		Status = AtalkErrorToNtStatus(ErrorCode);
	}

	// We complete here
	(*pAspAddr->aspao_ClientEntries.clt_ReplyCompletion)(Status,
														 pAspConn->aspco_ConnContext,
														 &pAspReq->asprq_Request);

	// Based on whether a reply was actually sent or not, either deref the response
	// or cancel it.
	if (pAspReq->asprq_Flags & ASPRQ_REPLY)
	{
		AtalkAtpRespDereference(pAspReq->asprq_pAtpResp);
	}
	else
	{
		AtalkAtpCancelResp(pAspReq->asprq_pAtpResp);
	}

    // make sure we aren't hanging on to cache mgr's mdl!
	ASSERT(pAspReq->asprq_Request.rq_CacheMgrContext == NULL);

#if	DBG
	pAspReq->asprq_Signature = 0x28041998;
	pAspReq->asprq_pAtpResp = (PATP_RESP)(pAspReq->asprq_Request.rq_WriteMdl);
	pAspReq->asprq_pAspConn = (PASP_CONNOBJ)(pAspReq->asprq_Request.rq_CacheMgrContext);
	pAspReq->asprq_Request.rq_WriteMdl = (PMDL)0x44556677;
	pAspReq->asprq_Request.rq_CacheMgrContext = (PVOID)66778899;
#endif


	// Free this as we are done with this request now
	ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);

	if (pAspConn->aspco_pFreeReqs == NULL)
	{
		pAspReq->asprq_Next = NULL;
		pAspConn->aspco_pFreeReqs = pAspReq;
	}
	else AtalkBPFreeBlock(pAspReq);

	RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

	// We are done with this request.
	AtalkAspDereferenceConn(pAspConn);
}




LOCAL VOID
atalkAspWriteContinueResp(
	IN	ATALK_ERROR		ErrorCode,
	IN	PASP_REQUEST	pAspReq,
	IN	PAMDL			pReqAMdl,
	IN	PAMDL			pRespAMdl,
	IN	USHORT			RespSize,
	IN	PBYTE			RespUserBytes
	)
/*++

Routine Description:

 	Handler for incoming write continue response.

Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn;
	PASP_ADDROBJ	pAspAddr;
	NTSTATUS		Status;
	NTSTATUS		retStatus;
    KIRQL           OldIrql;
	PASP_REQUEST *	ppAspReq;
    PVOID           pClientContxt;


	ASSERT (VALID_ASPRQ(pAspReq));

	ASSERT(pAspReq->asprq_Flags & ASPRQ_WRTCONT);

	pAspConn = pAspReq->asprq_pAspConn;
	ASSERT(VALID_ASPCO(pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspWriteContinueResp: Entered for request %lx\n", pAspReq));

	pAspAddr = pAspConn->aspco_pAspAddr;
	ASSERT(VALID_ASPAO(pAspAddr));

	pAspReq->asprq_Flags &= ~ASPRQ_WRTCONT;

	pClientContxt = pAspConn->aspco_ConnContext;

	if (ATALK_SUCCESS(ErrorCode))
	{
		pAspConn->aspco_RT.rt_New = AtalkGetCurrentTick() - pAspConn->aspco_RT.rt_New;
	
		// Estimate the retry interval for next time.
		AtalkCalculateNewRT(&pAspConn->aspco_RT);
		Status = STATUS_SUCCESS;
	}
	else
	{
		Status = AtalkErrorToNtStatus(ErrorCode);
	}

#ifdef	PROFILING
	{
		KIRQL	OldIrql;

		ACQUIRE_SPIN_LOCK(&AtalkStatsLock, &OldIrql);

		AtalkStatistics.stat_LastAspRTT = (ULONG)(pAspConn->aspco_RT.rt_Base);
		if ((ULONG)(pAspConn->aspco_RT.rt_Base) > AtalkStatistics.stat_MaxAspRTT)
			AtalkStatistics.stat_MaxAspRTT = (ULONG)(pAspConn->aspco_RT.rt_Base);

		RELEASE_SPIN_LOCK(&AtalkStatsLock, OldIrql);
	}
#endif
	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspWriteContinueResp: Indicating request %lx\n", pAspReq));

	// Notify the client that it has a request to handle
    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);

	retStatus = (*pAspAddr->aspao_ClientEntries.clt_RequestNotify)
                            (Status,
							 pClientContxt,
							 &pAspReq->asprq_Request);

    KeLowerIrql(OldIrql);

    //
	// In case the writecontinue returned an error, this request needs to go away
	// since there will never be a call to AtalkAspReply(). Also deref the conn.
    // Alternately, if the response came in fine, but the server didn't want to accept
    // it, it's the same deal
    //
    if ( (!NT_SUCCESS(Status)) || (!NT_SUCCESS(retStatus)) )
    {
	    DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
			("atalkAspWriteContinueResp: incoming %lx, Afp %lx req: %lx on %lx, cancelling\n",
            Status,retStatus,pAspReq,pAspConn));

		ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
	
		for (ppAspReq = &pAspConn->aspco_pActiveReqs;
			 *ppAspReq != NULL;
			 ppAspReq = &(*ppAspReq)->asprq_Next)
		{
			if (pAspReq == *ppAspReq)
			{
				*ppAspReq = pAspReq->asprq_Next;
				pAspConn->aspco_cReqsInProcess --;
				break;
			}
		}

		ASSERT (*ppAspReq == pAspReq->asprq_Next);
	
		RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

		AtalkAspDereferenceConn(pAspConn);

		// Cancel the response for the original request that caused wrtcont to be posted
		AtalkAtpCancelResp(pAspReq->asprq_pAtpResp);

		// Free this request as well
		AtalkBPFreeBlock(pAspReq);
    }


    if (pReqAMdl)
    {
	    ASSERT (AtalkGetAddressFromMdlSafe(pReqAMdl, NormalPagePriority) == pAspReq->asprq_WrtContRespBuf);
	    ASSERT (AtalkSizeMdlChain(pReqAMdl) == ASP_WRITE_DATA_SIZE);

	    AtalkFreeAMdl(pReqAMdl);
    }

}




LOCAL VOID
atalkAspSendAttentionResp(
	IN	ATALK_ERROR		ErrorCode,
	IN	PVOID			pContext,
	IN	PAMDL			pReqAMdl,
	IN	PAMDL			pRespAMdl,
	IN	USHORT			RespSize,
	IN	PBYTE			RespUserBytes
	)
/*++

Routine Description:

 	Handler for incoming write continue response.

Arguments:


Return Value:


--*/
{
	PBYTE			pBuf;
	PASP_CONNOBJ	pAspConn = (PASP_CONNOBJ)pContext;

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspSendAttentionResp: Entered for conn %lx\n", pAspConn));

	if (!ATALK_SUCCESS(ErrorCode))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("atalkAspSendAttentionResp: Failure %ld\n", ErrorCode));
	}

	if (pRespAMdl != NULL)
	{
		pBuf = AtalkGetAddressFromMdlSafe(
				pRespAMdl,
				NormalPagePriority);

		if (pBuf != NULL)
        {
			AtalkFreeMemory(pBuf);
        }
		AtalkFreeAMdl(pRespAMdl);
	}

	// Call the completion routine
	(*pAspConn->aspco_pAspAddr->aspao_ClientEntries.clt_AttnCompletion)(pAspConn->aspco_AttentionContext);

	pAspConn->aspco_AttentionContext = NULL;

	// Finally Dereference the connection
	AtalkAspDereferenceConn(pAspConn);
}



LOCAL LONG FASTCALL
atalkAspSessionMaintenanceTimer(
	IN	PTIMERLIST	pTimer,
	IN	BOOLEAN		TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASP_CONNOBJ	pAspConn, pAspConnNext;
    PASP_CONN_MAINT	pAspCM;
	BOOLEAN			Close = FALSE;
	LONG			CurrentTick =  AtalkGetCurrentTick();
#ifdef	PROFILING
	TIME			TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspSessionMaintenanceTimer: Entered\n"));

	if (TimerShuttingDown)
		return ATALK_TIMER_NO_REQUEUE;

	pAspCM = CONTAINING_RECORD(pTimer, ASP_CONN_MAINT, ascm_SMTTimer);

	ACQUIRE_SPIN_LOCK_DPC(&atalkAspLock);

	// Walk the list of sessions on the global list and shut down
	// sessions that have not tickle'd for a while
	for (pAspConn = pAspCM->ascm_ConnList; pAspConn != NULL; pAspConn = pAspConnNext)
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("atalkAspSessionMaintenanceTimer: Checking out session %d from %x.%x\n",
				pAspConn->aspco_SessionId,
				pAspConn->aspco_WssRemoteAddr.ata_Network,
				pAspConn->aspco_WssRemoteAddr.ata_Node));

		pAspConnNext = pAspConn->aspco_NextSession;

		Close = FALSE;
		ASSERT (VALID_ASPCO(pAspConn));

		ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

		if ((pAspConn->aspco_Flags & ASPCO_ACTIVE)	&&
			((CurrentTick - pAspConn->aspco_LastContactTime) > ASP_MAX_SESSION_IDLE_TIME))
		{
			pAspConn->aspco_Flags |= (ASPCO_REMOTE_CLOSE | ASPCO_DROPPED);
			pAspConn->aspco_Flags &= ~ASPCO_ACTIVE;
			pAspConn->aspco_RefCount ++;	// Since atalkAspSessionClose Derefs it

			Close = TRUE;
		}

		RELEASE_SPIN_LOCK_DPC(&pAspConn->aspco_Lock);

		if (Close)
		{
			PASP_ADDROBJ	pAspAddr;
			ATALK_ERROR		Status;

#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AspSessionsDropped,
										   &AtalkStatsLock.SpinLock);
#endif
			pAspAddr = pAspConn->aspco_pAspAddr;
			ASSERT (VALID_ASPAO(pAspAddr));

			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspSessionMaintenanceTimer: Shutting down session %d from %x.%x\n",
					pAspConn->aspco_SessionId,
					pAspConn->aspco_WssRemoteAddr.ata_Network,
					pAspConn->aspco_WssRemoteAddr.ata_Node));

			RELEASE_SPIN_LOCK_DPC(&atalkAspLock);

			// This session is being punted. Cancel tickles on this and notify the
			// server that this session is history.
			Status = AtalkAtpCancelReq(pAspAddr->aspao_pSlsAtpAddr,
									   pAspConn->aspco_TickleXactId,
									   &pAspConn->aspco_WssRemoteAddr);
			if (!ATALK_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
						("atalkAspSessionMaintenanceTimer: AtalkAtpCancelReq %ld\n", Status));
			}

			// Shut down this session, well almost ...
			atalkAspSessionClose(pAspConn);

			ACQUIRE_SPIN_LOCK_DPC(&atalkAspLock);
			pAspConnNext = pAspCM->ascm_ConnList;
		}
	}

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_AspSmtProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC( &AtalkStatistics.stat_AspSmtCount,
									&AtalkStatsLock.SpinLock);
#endif

	RELEASE_SPIN_LOCK_DPC(&atalkAspLock);

	// Reschedule ourselves
	return ATALK_TIMER_REQUEUE;
}




LOCAL VOID
atalkAspSessionClose(
	IN	PASP_CONNOBJ	pAspConn
	)
/*++

Routine Description:

	This should be called with a reference to the connection which is Dereferenced
	here.

Arguments:


Return Value:


--*/
{
	PASP_REQUEST	pAspReq, pAspReqNext;
	PASP_ADDROBJ	pAspAddr = pAspConn->aspco_pAspAddr;
	REQUEST			Request;
	KIRQL			OldIrql;
	NTSTATUS		Status = STATUS_REMOTE_DISCONNECT;

	ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
   	pAspConn->aspco_Flags &= ~ASPCO_ACTIVE;

	// Cancel any Write-continues pending. Do not bother cancelling
	// replies as they will time out anyway. Also atalkAspReplyRelease()
	// will attempt to acquire the connection lock and we're already
	// holding it
	for (pAspReq = pAspConn->aspco_pActiveReqs;
		 pAspReq != NULL;
		 pAspReq = pAspReqNext)
	{
	    pAspReqNext = pAspReq->asprq_Next;
		if ((pAspReq->asprq_Flags & (ASPRQ_WRTCONT | ASPRQ_WRTCONT_CANCELLED)) == ASPRQ_WRTCONT)
		{
			pAspReq->asprq_Flags |= ASPRQ_WRTCONT_CANCELLED;

			RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

			AtalkAtpCancelReq(pAspAddr->aspao_pSssAtpAddr,
							  pAspReq->asprq_WCXactId,
							  &pAspConn->aspco_WssRemoteAddr);

			ACQUIRE_SPIN_LOCK(&pAspConn->aspco_Lock, &OldIrql);
			pAspReqNext = pAspConn->aspco_pActiveReqs;
		}
	}

	RELEASE_SPIN_LOCK(&pAspConn->aspco_Lock, OldIrql);

	if (pAspConn->aspco_Flags & ASPCO_DROPPED)
	{
		Status = STATUS_LOCAL_DISCONNECT;
	}

	// Indicate a request with an error to indicate that the session closed remotely.
	// Pass the remote address of the client so that the server can log an event if
	// the session did not shutdown gracefully.

	Request.rq_RequestSize = (LONG)(pAspConn->aspco_WssRemoteAddr.ata_Address);
	Request.rq_RequestBuf = NULL;
	Request.rq_WriteMdl = NULL;
    Request.rq_CacheMgrContext = NULL;

	(*pAspAddr->aspao_ClientEntries.clt_RequestNotify)(Status,
													   pAspConn->aspco_ConnContext,
													   &Request);
	// Finally Dereference the session
	AtalkAspDereferenceConn(pAspConn);
}


LOCAL VOID
atalkAspReturnResp(
	IN	PATP_RESP		pAtpResp,
	IN	PATALK_ADDR		pDstAddr,
	IN	BYTE			Byte0,
	IN	BYTE			Byte1,
	IN	USHORT			Word2
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BYTE		UserBytes[ATP_USERBYTES_SIZE];
	ATALK_ERROR	Status;

	UserBytes[0] = Byte0;
	UserBytes[1] = Byte1;
	PUTSHORT2SHORT(UserBytes+2, Word2);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspReturnResp: For Resp %lx\n", pAtpResp));

	Status = AtalkAtpPostResp(pAtpResp,
							  pDstAddr,
							  NULL,
							  0,
							  UserBytes,
							  AtalkAtpGenericRespComplete,
							  pAtpResp);
	if (!ATALK_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("atalkAspReturnResp: AtalkAtpPostResp failed %ld\n", Status));
		AtalkAtpGenericRespComplete(Status, pAtpResp);
	}
}




LOCAL VOID FASTCALL
atalkAspRespComplete(
	IN	ATALK_ERROR				ErrorCode,
	IN	PASP_POSTSTAT_CTX		pStsCtx
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("atalkAspRespComplete: Entered pStsCtx %lx\n", pStsCtx));

	if (!ATALK_SUCCESS(ErrorCode))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("atalkAspRespComplete: Failed %ld, pStsCtx %lx\n", ErrorCode, pStsCtx));
	}

	if (pStsCtx != NULL)
	{
		AtalkFreeAMdl(pStsCtx->aps_pAMdl);
		AtalkAtpRespDereferenceDpc(pStsCtx->aps_pAtpResp);
		AtalkFreeMemory(pStsCtx);
	}
}




LOCAL VOID
atalkAspCloseComplete(
	IN	ATALK_ERROR		Status,
	IN	PASP_ADDROBJ	pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_WARN,
			("atalkAspCloseComplete: AtalkAtpCloseAddr returned %ld\n",  Status));
	AtalkAspDereferenceAddr(pAspAddr);
}


#if	DBG

VOID
AtalkAspDumpSessions(
	VOID
)
{
	PASP_CONNOBJ	pAspConn;
	KIRQL			OldIrql;
	LONG			i;

	DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL, ("ASP SESSION LIST:\n"));

	ACQUIRE_SPIN_LOCK(&atalkAspLock, &OldIrql);

	for (i = 0; i < NUM_ASP_CONN_LISTS; i++)
	{
		for (pAspConn = atalkAspConnMaint[i].ascm_ConnList;
			 pAspConn != NULL;
			 pAspConn = pAspConn->aspco_NextSession)
		{
			DBGPRINT(DBG_COMP_DUMP, DBG_LEVEL_FATAL,
					("\tRemote Addr %4d.%3d.%2d SessionId %2d Flags %4x RefCount %ld\n",
					pAspConn->aspco_WssRemoteAddr.ata_Network,
					pAspConn->aspco_WssRemoteAddr.ata_Node,
					pAspConn->aspco_WssRemoteAddr.ata_Socket,
					pAspConn->aspco_SessionId,
					pAspConn->aspco_Flags,
					pAspConn->aspco_RefCount));
		}
	}
	RELEASE_SPIN_LOCK(&atalkAspLock, OldIrql);
}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\asp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	asp.h

Abstract:

	This module contains definitions for the server side ASP code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ASP_
#define	_ASP_

// This defines only the server side ASP protocol solely for the consumption of the
// AFP Server. Hence any functionality not needed by the AFP Server is missing here

// ASP command type bytes:
#define ASP_CLOSE_SESSION				1
#define ASP_CMD							2
#define ASP_GET_STATUS					3
#define ASP_OPEN_SESSION				4
#define ASP_TICKLE						5
#define ASP_WRITE						6
#define ASP_WRITE_DATA					7
#define ASP_ATTENTION					8

// ASP version:
#define ASP_VERSION						"\001\000"

// Asp error codes that are visible on the wire
#define	ASP_BAD_VERSION					(USHORT)-1066
#define	ASP_BUFFER_TOO_SMALL			(USHORT)-1067
#define	ASP_NO_MORE_SESSIONS			(USHORT)-1068
#define	ASP_NO_SERVERS					(USHORT)-1069
#define	ASP_PARAM_ERROR					(USHORT)-1070
#define	ASP_SERVER_BUSY					(USHORT)-1071
#define	ASP_SIZE_ERROR					(USHORT)-1073
#define	ASP_TOO_MANY_CLIENTS			(USHORT)-1074
#define	ASP_NO_ACK						(USHORT)-1075

// Offsets into the ATP user bytes for finding various fields:
#define ASP_CMD_OFF						0
#define ASP_CMD_RESULT_OFF				0
#define ASP_SSS_OFF						0
#define ASP_SESSIONID_OFF				1
#define ASP_WSS_OFF						1
#define ASP_VERSION_OFF					2
#define ASP_ERRORCODE_OFF				2
#define ASP_ATTN_WORD_OFF				2
#define ASP_SEQUENCE_NUM_OFF			2

#define ASP_CMD_RESULT_SIZE				4

// ASP timer values:
#define ATP_MAX_INTERVAL_FOR_ASP		20		// In 100ms units
#define ATP_MIN_INTERVAL_FOR_ASP		3		// In 100ms units
#define	ATP_INITIAL_INTERVAL_FOR_ASP	3

#define ASP_TICKLE_INTERVAL				300		// In 100ms units
#define ASP_MAX_SESSION_IDLE_TIME		1200	// In 100ms units. How long before we kill it
#define ASP_SESSION_MAINTENANCE_TIMER	1200	// In 100ms units. How often the timer runs
#define ASP_SESSION_TIMER_STAGGER		50		// In 100ms units. How are different queues staggered
#define ATP_RETRIES_FOR_ASP				10		// For open, status, close;
										    	// infinite for others.
#define ASP_WRITE_DATA_SIZE				2		// WriteData command has two
												// bytes of data with it.
// Session status size:
#define ASP_MAX_STATUS_SIZE				ATP_MAX_TOTAL_RESPONSE_SIZE
#define	MAX_WRITE_REQ_SIZE				20

#define	ASP_CONN_HASH_BUCKETS			37	// Hashed by NodeAddr

#define	HASH_SRCADDR(pSrcAddr)	\
			((((pSrcAddr)->ata_Node >> 2) +	\
			  ((pSrcAddr)->ata_Network & 0xFF)) % ASP_CONN_HASH_BUCKETS)

// For resolving forward references
struct _AspAddress;
struct _AspConnxn;
struct _AspRequest;

#define	ASPAO_CLOSING			0x8000
#define	ASPAO_SIGNATURE			*(PULONG)"ASAO"

#if	DBG
#define	VALID_ASPAO(pAspAddr)	(((pAspAddr) != NULL) && \
								 ((pAspAddr)->aspao_Signature == ASPAO_SIGNATURE))
#else
#define	VALID_ASPAO(pAspAddr)	((pAspAddr) != NULL)
#endif

typedef struct _AspAddress
{
#if	DBG
	ULONG					aspao_Signature;
#endif
	LONG					aspao_RefCount;		// References to the address obj
	ULONG					aspao_Flags;
	PATP_ADDROBJ			aspao_pSlsAtpAddr;	// Sls Atp Socket
	PATP_ADDROBJ			aspao_pSssAtpAddr;	// Sss Atp Socket
	struct _AspConnxn	*	aspao_pSessions[ASP_CONN_HASH_BUCKETS];
												// List of open sessions
	PBYTE					aspao_pStatusBuf;	// Status buffer
	USHORT					aspao_StsBufSize;	// Size of the status buffer
	BYTE					aspao_NextSessionId;// Id of the next session that comes in
	BOOLEAN					aspao_EnableNewConnections;
	GENERIC_COMPLETION		aspao_CloseCompletion;
	PVOID					aspao_CloseContext;
	ASP_CLIENT_ENTRIES		aspao_ClientEntries;// Entry points from the client
	ATALK_SPIN_LOCK			aspao_Lock;
} ASP_ADDROBJ, *PASP_ADDROBJ;

#define	ASPCO_ACTIVE			0x0001
#define	ASPCO_TICKLING			0x0002
#define	ASPCO_CLEANING_UP		0x0010
#define	ASPCO_LOCAL_CLOSE		0x0020
#define	ASPCO_REMOTE_CLOSE		0x0040
#define	ASPCO_DROPPED			0x0080
#define	ASPCO_SHUTDOWN		    0x0100
#define	ASPCO_CLOSING			0x8000
#define	ASPCO_SIGNATURE			*(PULONG)"ASCO"

#if	DBG
#define	VALID_ASPCO(pAspConn)	(((pAspConn) != NULL) && \
								 ((pAspConn)->aspco_Signature == ASPCO_SIGNATURE))
#else
#define	VALID_ASPCO(pAspConn)	((pAspConn) != NULL)
#endif

typedef struct _AspConnxn
{
#if	DBG
	ULONG					aspco_Signature;
#endif
	struct _AspConnxn	*	aspco_NextOverflow;	// Overflow link for hash bucket
												// These is non NULL only when on
												// active list
	struct _AspConnxn	*	aspco_NextSession;	// Linked to active session list
	struct _AspConnxn	**	aspco_PrevSession;	// Linked to active session list

	LONG					aspco_RefCount;		// References to the conn obj
	struct _AspAddress	*	aspco_pAspAddr;		// Back pointer to the listener

	struct _AspRequest	*	aspco_pActiveReqs;	// List of requests being processed
	struct _AspRequest	*	aspco_pFreeReqs;	// Free requests
	PVOID					aspco_ConnContext;	// User context associated with this conn.
	LONG					aspco_LastContactTime;
	ATALK_ADDR				aspco_WssRemoteAddr;// This is the remote addr which
												// issues the commands/writes
	BYTE					aspco_SessionId;
	BYTE					aspco_cReqsInProcess;// Count of requests in process
	USHORT					aspco_Flags;		// ASPCO_xxx values
	USHORT					aspco_NextExpectedSeqNum;
	USHORT					aspco_TickleXactId;	// Transaction id for tickles
	RT						aspco_RT;			// Used for adaptive round-trip time calculation
	PVOID					aspco_CloseContext;
	CLIENT_CLOSE_COMPLETION	aspco_CloseCompletion;
	PVOID					aspco_AttentionContext;
	ATALK_SPIN_LOCK			aspco_Lock;
} ASP_CONNOBJ, *PASP_CONNOBJ;

#define	ASPRQ_WRTCONT			0x01		// Set if we are doing a write continue
#define	ASPRQ_WRTCONT_CANCELLED	0x10		// Set if a write continue was cancelled
#define	ASPRQ_REPLY				0x02		// Set if a reply is being processed
#define	ASPRQ_REPLY_CANCELLED	0x20		// Set if a reply is cancelled
#define	ASPRQ_REPLY_ABORTED		0x40		// Reply aborted due to a closing session

// The request gets created when an incoming request arrives.
#define	ASPRQ_SIGNATURE			*(PULONG)"ASRQ"
#if	DBG
#define	VALID_ASPRQ(pAspReq)	(((pAspReq) != NULL) && \
								 ((pAspReq)->asprq_Signature == ASPRQ_SIGNATURE))
#else
#define	VALID_ASPRQ(pAspReq)	((pAspReq) != NULL)
#endif

typedef struct _AspRequest
{
#if	DBG
	ULONG					asprq_Signature;
#endif
	struct _AspRequest	*	asprq_Next;     // Link to next request
	struct _AspConnxn	*	asprq_pAspConn;	// Owning connection
	USHORT					asprq_SeqNum;	// As generated by the wksta end
	USHORT					asprq_WCXactId;	// Transaction Id of the write
											// continue in progress
	PATP_RESP				asprq_pAtpResp;	// Used by PostResp/Cancel
	BYTE					asprq_ReqType;	// Cmd/WrtCont
	BYTE					asprq_Flags;	// Various ASPRQ_xxx values
	ATALK_ADDR				asprq_RemoteAddr;// This address is used for
											// future communications but only
											// for this request
	REQUEST					asprq_Request;	// Request parameters

	UCHAR					asprq_ReqBuf[MAX_WRITE_REQ_SIZE];
											// The request is copied here during a
											// write request
	BYTE					asprq_WrtContRespBuf[ASP_WRITE_DATA_SIZE];
} ASP_REQUEST, *PASP_REQUEST;

//	MACROS
#define	AtalkAspGetDdpAddress(pAspAddr)	\
							AtalkAtpGetDdpAddress((pAspAddr)->aspao_pSlsAtpAddr)

extern
VOID
AtalkInitAspInitialize(
	VOID
);

extern
ATALK_ERROR
AtalkAspCreateAddress(
	OUT	PASP_ADDROBJ	*		ppAspAddr
);

extern
ATALK_ERROR
AtalkAspCloseAddress(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
);

extern
ATALK_ERROR
AtalkAspBind(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	PASP_BIND_PARAMS		pBindParms,
	IN	PACTREQ					pActReq
);

NTSTATUS FASTCALL
AtalkAspWriteContinue(
	IN	PREQUEST	  pRequest
    );

ATALK_ERROR FASTCALL
AtalkAspReply(
	IN	PREQUEST				pRequest,
	IN	PBYTE					pResultCode	// Pointer to the 4-byte result
);

extern
NTSTATUS
AtalkAspSetStatus(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	PUCHAR					pStatusBuf,
	IN	USHORT					StsBufSize
);

extern
NTSTATUS FASTCALL
AtalkAspListenControl(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	BOOLEAN					Enable
);

extern
PASP_ADDROBJ FASTCALL
AtalkAspReferenceAddr(
	IN	PASP_ADDROBJ			pAspAddr
);

extern
VOID FASTCALL
AtalkAspDereferenceAddr(
	IN	PASP_ADDROBJ			pAspAddr
);

extern
ATALK_ERROR
AtalkAspCleanupConnection(
	IN	PASP_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspCloseConnection(
	IN	PASP_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspFreeConnection(
	IN	PASP_CONNOBJ			pAspConn
);

extern
NTSTATUS
AtalkAspSendAttention(
	IN	PASP_CONNOBJ			pAspConn,
	IN	USHORT					AttentionWord,
	IN	PVOID					pContext
);

extern
VOID FASTCALL
AtalkAspDereferenceConn(
	IN	PASP_CONNOBJ			pAspConn
);

// This is a list of all active connections. This is scanned by the session
// maintenance timer.
#define	NUM_ASP_CONN_LISTS		4
typedef	struct
{
	PASP_CONNOBJ	ascm_ConnList;
    TIMERLIST		ascm_SMTTimer;
} ASP_CONN_MAINT, *PASP_CONN_MAINT;
extern	ASP_CONN_MAINT	atalkAspConnMaint[NUM_ASP_CONN_LISTS];

extern	ATALK_SPIN_LOCK	atalkAspLock;

typedef	struct
{
	PATP_RESP		aps_pAtpResp;
	PAMDL			aps_pAMdl;
} ASP_POSTSTAT_CTX, *PASP_POSTSTAT_CTX;

LOCAL ATALK_ERROR FASTCALL
atalkAspPostWriteContinue(
	IN	PASP_REQUEST			pAspReq
);

LOCAL PASP_CONNOBJ
atalkAspReferenceConnBySrcAddr(
	IN	PASP_ADDROBJ			pAspAddr,
	IN	PATALK_ADDR				pSrcAddr,
	IN	BYTE					SessionId
);

LOCAL VOID
atalkAspSlsXHandler(
	IN	ATALK_ERROR				ErrorCode,
	IN	PASP_ADDROBJ			pAspAddr,		// Listener (our context)
	IN	PATP_RESP				RespCtxt,		// Used by PostResp/CancelResp
	IN	PATALK_ADDR				pSrcAddr,		// Address of requestor
	IN	USHORT					PktLen,
	IN	PBYTE					pPkt,
	IN	PBYTE					pUserBytes
);

LOCAL VOID
atalkAspSssXHandler(
	IN	ATALK_ERROR				ErrorCode,
	IN	PASP_ADDROBJ			pAspAddr,		// Listener (our context)
	IN	PATP_RESP				RespCtxt,		// Used by PostResp/CancelResp
	IN	PATALK_ADDR				pSrcAddr,		// Address of requestor
	IN	USHORT					PktLen,
	IN	PBYTE					pPkt,
	IN	PBYTE					pUserBytes
);

LOCAL VOID FASTCALL
atalkAspReplyRelease(
	IN	ATALK_ERROR				Error,
	IN	PASP_REQUEST			pAspReq
);

LOCAL VOID
atalkAspWriteContinueResp(
	IN	ATALK_ERROR				Error,
	IN	PASP_REQUEST			pAspReq,
	IN	PAMDL					pReqAMdl,
	IN	PAMDL					pRespAMdl,
	IN	USHORT					RespSize,
	IN	PBYTE					RespUserBytes
);

LOCAL VOID
atalkAspSendAttentionResp(
	IN	ATALK_ERROR				Error,
	IN	PVOID					pContext,
	IN	PAMDL					pReqAMdl,
	IN	PAMDL					pRespAMdl,
	IN	USHORT					RespSize,
	IN	PBYTE					RespUserBytes
);

LOCAL VOID
atalkAspSessionClose(
	IN	PASP_CONNOBJ			pAspConn
);

LOCAL LONG FASTCALL
atalkAspSessionMaintenanceTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown
);

LOCAL VOID FASTCALL
atalkAspRespComplete(
	IN	ATALK_ERROR				Error,
	IN	PASP_POSTSTAT_CTX		pStsCtx
);

LOCAL VOID
atalkAspCloseComplete(
	IN	ATALK_ERROR				Status,
	IN	PASP_ADDROBJ			pAspAddr
);

LOCAL VOID
atalkAspReturnResp(
	IN	PATP_RESP				pAtpResp,
	IN	PATALK_ADDR				pDstAddr,
	IN	BYTE					Byte0,
	IN	BYTE					Byte1,
	IN	USHORT					Word2
);

#endif	// _ASP_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\aspc.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aspc.c

Abstract:

	This module implements the ASP client protocol.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	30 Mar 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ASPC

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitAspCInitialize)
#pragma alloc_text(PAGE, AtalkAspCCreateAddress)
#pragma alloc_text(PAGEASPC, AtalkAspCCleanupAddress)
#pragma alloc_text(PAGEASPC, AtalkAspCCloseAddress)
#pragma alloc_text(PAGEASPC, AtalkAspCCreateConnection)
#pragma alloc_text(PAGEASPC, AtalkAspCCleanupConnection)
#pragma alloc_text(PAGEASPC, AtalkAspCCloseConnection)
#pragma alloc_text(PAGEASPC, AtalkAspCAssociateAddress)
#pragma alloc_text(PAGEASPC, AtalkAspCDissociateAddress)
#pragma alloc_text(PAGEASPC, AtalkAspCPostConnect)
#pragma alloc_text(PAGEASPC, AtalkAspCDisconnect)
#pragma alloc_text(PAGEASPC, AtalkAspCGetStatus)
#pragma alloc_text(PAGEASPC, AtalkAspCGetAttn)
#pragma alloc_text(PAGEASPC, AtalkAspCCmdOrWrite)
#pragma alloc_text(PAGEASPC, atalkAspCIncomingOpenReply)
#pragma alloc_text(PAGEASPC, atalkAspCIncomingStatus)
#pragma alloc_text(PAGEASPC, atalkAspCIncomingCmdReply)
#pragma alloc_text(PAGEASPC, atalkAspCHandler)
#pragma alloc_text(PAGEASPC, AtalkAspCAddrDereference)
#pragma alloc_text(PAGEASPC, AtalkAspCConnDereference)
#pragma alloc_text(PAGEASPC, atalkAspCSessionMaintenanceTimer)
#pragma alloc_text(PAGEASPC, atalkAspCQueueAddrGlobalList)
#pragma alloc_text(PAGEASPC, atalkAspCDeQueueAddrGlobalList)
#pragma alloc_text(PAGEASPC, atalkAspCQueueConnGlobalList)
#pragma alloc_text(PAGEASPC, atalkAspCDeQueueConnGlobalList)
#endif

VOID
AtalkInitAspCInitialize(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	AtalkTimerInitialize(&atalkAspCConnMaint.ascm_SMTTimer,
						 atalkAspCSessionMaintenanceTimer,
						 ASP_SESSION_MAINTENANCE_TIMER);
	INITIALIZE_SPIN_LOCK(&atalkAspCLock);
}


ATALK_ERROR
AtalkAspCCreateAddress(
	IN	PATALK_DEV_CTX		pDevCtx	OPTIONAL,
	OUT	PASPC_ADDROBJ	*	ppAspAddr
	)
/*++

Routine Description:

 	Create an ASP address object.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR			Status;
	PASPC_ADDROBJ		pAspAddr;
	int					i;

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
			("AtalkAspCCreateAddr: Entered\n"));

	// Allocate memory for the Asp address object
	*ppAspAddr = NULL;
	if ((pAspAddr = AtalkAllocZeroedMemory(sizeof(ASPC_ADDROBJ))) == NULL)
	{
		return ATALK_RESR_MEM;
	}

	// Create an Atp Socket on the port for the Sls
	Status = AtalkAtpOpenAddress(AtalkDefaultPort,
								 0,
								 NULL,
								 ATP_DEF_MAX_SINGLE_PKT_SIZE,
								 ATP_DEF_SEND_USER_BYTES_ALL,
								 NULL,
								 FALSE,
								 &pAspAddr->aspcao_pAtpAddr);

	if (!ATALK_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("AtalkAspCCreateAddress: AtalkAtpOpenAddress %ld\n", Status));
		AtalkFreeMemory(pAspAddr);
		return Status;
	}

	// Initialize the Asp address object
#if	DBG
	pAspAddr->aspcao_Signature = ASPCAO_SIGNATURE;
#endif
	INITIALIZE_SPIN_LOCK(&pAspAddr->aspcao_Lock);

	atalkAspCQueueAddrGlobalList(pAspAddr);

	// Refcount for creation and atp address. This goes away when atp address is closed
    // pAspAddr->aspcao_Flags = 0;
	pAspAddr->aspcao_RefCount = 1 + 1;
	*ppAspAddr = pAspAddr;

	return ATALK_NO_ERROR;
}


ATALK_ERROR
AtalkAspCCleanupAddress(
	IN	PASPC_ADDROBJ			pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	return(ATALK_NO_ERROR);
}


ATALK_ERROR
AtalkAspCCloseAddress(
	IN	PASPC_ADDROBJ			pAspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	return(ATALK_NO_ERROR);
}


ATALK_ERROR
AtalkAspCCreateConnection(
	IN	PVOID					pConnCtx,	// Context to associate with the session
	IN	PATALK_DEV_CTX			pDevCtx		OPTIONAL,
	OUT	PASPC_CONNOBJ 	*		ppAspConn
	)
/*++

Routine Description:

 	Create an ASP session. The created session starts off being an orphan, i.e.
 	it has no parent address object. It gets one when it is associated.

Arguments:


Return Value:


--*/
{
	PASPC_CONNOBJ		pAspConn;

	// Allocate memory for a connection object
	if ((pAspConn = AtalkAllocZeroedMemory(sizeof(ASPC_CONNOBJ))) == NULL)
	{
		return ATALK_RESR_MEM;
	}

#if	DBG
	pAspConn->aspcco_Signature = ASPCCO_SIGNATURE;
#endif

	INITIALIZE_SPIN_LOCK(&pAspConn->aspcco_Lock);
	pAspConn->aspcco_ConnCtx 	= pConnCtx;
	// pAspConn->aspcco_Flags 		= 0;
	pAspConn->aspcco_RefCount 	= 1;			// Creation reference
	pAspConn->aspcco_NextSeqNum = 1;			// Set to 1, not 0.
	AtalkInitializeRT(&pAspConn->aspcco_RT,
					  ASP_INIT_REQ_INTERVAL,
                      ASP_MIN_REQ_INTERVAL,
                      ASP_MAX_REQ_INTERVAL);

	*ppAspConn = pAspConn;

	//	Insert into the global connection list.
	atalkAspCQueueConnGlobalList(pAspConn);

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
				("AtalkAspCreateConnection: %lx\n", pAspConn));

	return ATALK_NO_ERROR;
}


ATALK_ERROR
AtalkAspCCleanupConnection(
	IN	PASPC_CONNOBJ			pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	return ATALK_NO_ERROR;
}


ATALK_ERROR
AtalkAspCCloseConnection(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	return ATALK_NO_ERROR;
}


ATALK_ERROR
AtalkAspCAssociateAddress(
	IN	PASPC_ADDROBJ			pAspAddr,
	IN	PASPC_CONNOBJ			pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error;
	KIRQL			OldIrql;

	ASSERT(VALID_ASPCAO(pAspAddr));
	ASSERT(VALID_ASPCCO(pAspConn));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

	error = ATALK_ALREADY_ASSOCIATED;
	if ((pAspConn->aspcco_Flags & ASPCCO_ASSOCIATED) == 0)
	{
		error = ATALK_NO_ERROR;

		pAspConn->aspcco_Flags 	   |= ASPCCO_ASSOCIATED;
		pAspConn->aspcco_pAspCAddr	= pAspAddr;
	}

	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	return error;
}


ATALK_ERROR
AtalkAspCDissociateAddress(
	IN	PASPC_CONNOBJ			pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASPC_ADDROBJ	pAspAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error = ATALK_NO_ERROR;

	ASSERT(VALID_ASPCCO(pAspConn));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);
	if ((pAspConn->aspcco_Flags & (ASPCCO_CONNECTING	|
								   ASPCCO_ACTIVE 		|
								   ASPCCO_ASSOCIATED)) != ASPCCO_ASSOCIATED)
	{
		error = ATALK_INVALID_CONNECTION;
	}
	else
	{
		pAspAddr = pAspConn->aspcco_pAspCAddr ;
		ASSERT(VALID_ASPCAO(pAspAddr));

		//	Clear associated flag.
		pAspConn->aspcco_Flags 	   &= ~ASPCCO_ASSOCIATED;
		pAspConn->aspcco_pAspCAddr	= NULL;
	}
	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	return error;
}


ATALK_ERROR
AtalkAspCPostConnect(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	PVOID					pConnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error	= ATALK_NO_ERROR;
	BOOLEAN			DerefConn = FALSE;
	KIRQL			OldIrql;
	BYTE			UserBytes[ATP_USERBYTES_SIZE];
	PBYTE			pOpenPkt = NULL, pRespPkt = NULL;
	PAMDL			pOpenAmdl = NULL, pRespAmdl = NULL;
	PASPC_ADDROBJ	pAspAddr = pAspConn->aspcco_pAspCAddr;

	ASSERT(VALID_ASPCAO(pAspAddr));
	ASSERT(VALID_ASPCCO(pAspConn));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

	do
	{
		if ((pAspConn->aspcco_Flags & (ASPCCO_CONNECTING	|
									   ASPCCO_ACTIVE 		|
									   ASPCCO_ASSOCIATED)) != ASPCCO_ASSOCIATED)
		{
			error = ATALK_INVALID_CONNECTION;
			break;
		}

		//	Reference the connection for the request we will be posting
		AtalkAspCConnReferenceByPtrNonInterlock(pAspConn, &error);
		if (ATALK_SUCCESS(error))
		{
			DerefConn = TRUE;

			//	Make sure flags are clean.
			pAspConn->aspcco_Flags 			   |= ASPCCO_CONNECTING;
			pAspConn->aspcco_ConnectCtx 		= pConnectCtx;
			pAspConn->aspcco_ConnectCompletion 	= CompletionRoutine;
			pAspConn->aspcco_ServerSlsAddr		= *pRemoteAddr;

			//	Copy the atp address object for efficiency
			pAspConn->aspcco_pAtpAddr			= pAspAddr->aspcao_pAtpAddr;
		}
		else
		{
			ASSERTMSG("AtalkAspCPostConnect: Connection ref failed\n", 0);
		}
	} while (FALSE);

	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	if (ATALK_SUCCESS(error))
	{
		UserBytes[ASP_CMD_OFF]	= ASP_OPEN_SESSION;
		UserBytes[ASP_WSS_OFF]	= pAspAddr->aspcao_pAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Socket;
        UserBytes[ASP_VERSION_OFF] = ASP_VERSION[0];
        UserBytes[ASP_VERSION_OFF+1] = ASP_VERSION[1];
	
		//	Post the open session request.
		error = AtalkAtpPostReq(pAspConn->aspcco_pAtpAddr,
								&pAspConn->aspcco_ServerSlsAddr,
								&pAspConn->aspcco_OpenSessTid,
								ATP_REQ_EXACTLY_ONCE,				// ExactlyOnce request
								NULL,
								0,
								UserBytes,
								NULL,
								0,
								ATP_RETRIES_FOR_ASP,
								ATP_MAX_INTERVAL_FOR_ASP,
								THIRTY_SEC_TIMER,
								atalkAspCIncomingOpenReply,
								pAspConn);

		if (ATALK_SUCCESS(error))
		{
			error = ATALK_PENDING;
			DerefConn = FALSE;
		}
		else
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCPostConnect: AtalkAtpPostReq: failed %ld\n", error));

			//	Remove connection from the connect list and reset states.
			ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

			pAspConn->aspcco_Flags 			   &= ~ASPCCO_CONNECTING;
			pAspConn->aspcco_ConnectCtx 		= NULL;
			pAspConn->aspcco_ConnectCompletion 	= NULL;
			pAspConn->aspcco_pAtpAddr			= NULL;

			RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCPostConnect: failed %ld\n", error));
		}
	}

	if (DerefConn)
	{
		AtalkAspCConnDereference(pAspConn);
	}

	return error;
}


ATALK_ERROR
AtalkAspCDisconnect(
	IN	PASPC_CONNOBJ				pAspConn,
	IN	ATALK_DISCONNECT_TYPE		DisconnectType,
	IN	PVOID						pDisconnectCtx,
	IN	GENERIC_COMPLETION			CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASPC_REQUEST	pAspReq, pAspReqNext;
	KIRQL			OldIrql;
	ATALK_ERROR		Error;

	// Abort all pending requests.
	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

	pAspConn->aspcco_Flags |= ASPCCO_DISCONNECTING;
	for (pAspReq = pAspConn->aspcco_pActiveReqs;
		 pAspReq = pAspReq->aspcrq_Next;
		 pAspReq = pAspReqNext)
	{
		pAspReqNext = pAspReq->aspcrq_Next;
	}

	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	// Send a close session request to the other end
	// Error = AtalKAtpPostReq(pAspConn->aspcco_ServerSlsAddr);

	return ATALK_NO_ERROR;
}


ATALK_ERROR
AtalkAspCGetStatus(
	IN	PASPC_ADDROBJ				pAspAddr,
	IN	PATALK_ADDR					pRemoteAddr,
	IN	PAMDL						pStatusAmdl,
	IN	USHORT						AmdlSize,
	IN	PACTREQ						pActReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error;
	BYTE		UserBytes[ATP_USERBYTES_SIZE];
	USHORT		tid;

	if ((pRemoteAddr->ata_Network == 0) ||
        (pRemoteAddr->ata_Node == 0)	||
        (pRemoteAddr->ata_Socket == 0))
	{
		return ATALK_SOCKET_INVALID;
	}

	*(DWORD *)UserBytes = 0;
	UserBytes[ASP_CMD_OFF]	= ASP_GET_STATUS;

	error = AtalkAtpPostReq(pAspAddr->aspcao_pAtpAddr,
							pRemoteAddr,
							&tid,
							0,							// ExactlyOnce request
							NULL,
							0,
							UserBytes,
							pStatusAmdl,
							AmdlSize,
							ATP_RETRIES_FOR_ASP,
							ATP_MAX_INTERVAL_FOR_ASP,
							THIRTY_SEC_TIMER,
							atalkAspCIncomingStatus,
							(PVOID)pActReq);

	if (ATALK_SUCCESS(error))
	{
		error = ATALK_PENDING;
	}

	return error;
}


ATALK_ERROR
AtalkAspCGetAttn(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	PAMDL					pReadBuf,
	IN	USHORT					ReadBufLen,
	IN	ULONG					ReadFlags,
	IN	PVOID					pReadCtx,
	IN	GENERIC_READ_COMPLETION	CompletionRoutine
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error = ATALK_NO_ERROR;
	KIRQL			OldIrql;

	ASSERT(VALID_ASPCCO(pAspConn));
	ASSERT(*CompletionRoutine != NULL);

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

	do
	{
		if ((pAspConn->aspcco_Flags & ASPCCO_ACTIVE) == 0)
		{
			error = ATALK_ASPC_CONN_NOT_ACTIVE;
			break;
		}

		if ((ReadFlags & TDI_RECEIVE_EXPEDITED) == 0)
		{
			error = ATALK_INVALID_PARAMETER;
			break;
		}

		if (pAspConn->aspcco_Flags & ASPCCO_ATTN_PENDING)
		{
			error = ATALK_ASPC_TOO_MANY_READS;
			break;
		}

		//	PEEK not supported for ASPC
		if (ReadFlags & TDI_RECEIVE_PEEK)
		{
			error = ATALK_INVALID_REQUEST;
			break;
		}

		// We should have space for atleast one attention word
		if (ReadBufLen < sizeof(USHORT))
		{
			error = ATALK_BUFFER_TOO_SMALL;
			break;
		}

		// Check if we have any outstanding attention words
		if (pAspConn->aspcco_AttnOutPtr < pAspConn->aspcco_AttnInPtr)
		{
			PUSHORT	AttnBuf;
			USHORT	BufSize = 0;

			AttnBuf = AtalkGetAddressFromMdlSafe(
					pReadBuf,
					NormalPagePriority);
			if (AttnBuf == NULL) {
				error = ATALK_FAILURE;
				break;
			}
			while (pAspConn->aspcco_AttnOutPtr < pAspConn->aspcco_AttnInPtr)
			{
				*AttnBuf++ = pAspConn->aspcco_AttnBuf[pAspConn->aspcco_AttnOutPtr % MAX_ASPC_ATTNS];
                pAspConn->aspcco_AttnOutPtr++;
				BufSize += sizeof(USHORT);
			}
			(*CompletionRoutine)(error,
								pReadBuf,
								BufSize,
								ReadFlags,
								pReadCtx);

			error = ATALK_PENDING;
			break;
		}
		error = ATALK_INVALID_CONNECTION;
		if ((pAspConn->aspcco_Flags & (ASPCCO_CLOSING | ASPCCO_DISCONNECTING)) == 0)
		{
			AtalkAspCConnReferenceByPtrNonInterlock(pAspConn, &error);
		}

		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		pAspConn->aspcco_Flags 	|= ASPCCO_ATTN_PENDING;

		//	Remember read information in the connection object.
		pAspConn->aspcco_ReadCompletion	= CompletionRoutine;
		pAspConn->aspcco_ReadCtx		= pReadCtx;

	} while (FALSE);

	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	return error;
}


ATALK_ERROR
AtalkAspCCmdOrWrite(
	IN	PASPC_CONNOBJ				pAspConn,
	IN	PAMDL						pCmdMdl,
	IN	USHORT						CmdSize,
	IN	PAMDL						pReplyMdl,
	IN	USHORT						ReplySize,
	IN	BOOLEAN						fWrite,		// If TRUE, its a write else command
	IN	PACTREQ						pActReq
	)
/*++

Routine Description:


Arguments:
	Reply and Write buffers are overlaid.

Return Value:

--*/
{
	ATALK_ERROR		Error;
	KIRQL			OldIrql;
	PASPC_REQUEST	pAspReq;
	BYTE			UserBytes[ATP_USERBYTES_SIZE];

	do
	{
		if (((pAspConn->aspcco_Flags & (ASPCCO_ACTIVE		|
									   ASPCCO_CONNECTING 	|
									   ASPCCO_LOCAL_CLOSE	|
									   ASPCCO_REMOTE_CLOSE	|
									   ASPCCO_CLOSING)) != ASPCCO_ACTIVE))
		{
			Error = ATALK_INVALID_REQUEST;
			break;
		}

		AtalkAspCConnReference(pAspConn, &Error);
		if (!ATALK_SUCCESS(Error))
		{
			break;
		}

		if ((pAspReq = (PASPC_REQUEST)AtalkAllocZeroedMemory(sizeof(ASPC_REQUEST))) == NULL)
		{
			Error = ATALK_RESR_MEM;
			break;
		}
#if DBG
		pAspReq->aspcrq_Signature = ASPCRQ_SIGNATURE;
#endif
		pAspReq->aspcrq_Flags = fWrite ? ASPCRQ_WRITE : ASPCRQ_COMMAND;
		pAspReq->aspcrq_pReplyMdl = pReplyMdl;
		pAspReq->aspcrq_ReplySize = ReplySize;
		pAspReq->aspcrq_RefCount = 2;	// Creation+incoming reply handler

		ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);

		pAspReq->aspcrq_SeqNum = pAspConn->aspcco_NextSeqNum ++;
		pAspReq->aspcrq_Next = pAspConn->aspcco_pActiveReqs;
		pAspConn->aspcco_pActiveReqs = pAspReq;
		pAspReq->aspcrq_pAspConn = pAspConn;

		RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

		// Build user bytes and send our request over
		UserBytes[ASP_CMD_OFF] = fWrite ? ASP_CMD : ASP_WRITE;
		UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspcco_SessionId;
		PUTSHORT2SHORT(&UserBytes[ASP_SEQUENCE_NUM_OFF], pAspReq->aspcrq_SeqNum);

		Error = AtalkAtpPostReq(pAspConn->aspcco_pAtpAddr,
								&pAspConn->aspcco_ServerSssAddr,
								&pAspReq->aspcrq_ReqXactId,
								ATP_REQ_EXACTLY_ONCE,		// XO request
								pCmdMdl,
								CmdSize,
								UserBytes,
								pReplyMdl,
								ReplySize,
								ATP_RETRIES_FOR_ASP,		// Retry count
								pAspConn->aspcco_RT.rt_Base,// Retry interval
								THIRTY_SEC_TIMER,
								atalkAspCIncomingCmdReply,
								pAspReq);

		if (!ATALK_SUCCESS(Error))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("AtalkAspCCmdOrWrite: AtalkAtpPostReq failed %lx\n", Error));
			atalkAspCIncomingCmdReply(Error,
									  pAspReq,
									  pCmdMdl,
									  pReplyMdl,
									  ReplySize,
									  UserBytes);
		}

	} while (FALSE);

	return Error;
}


BOOLEAN
AtalkAspCConnectionIsValid(
	IN	PASPC_CONNOBJ	pAspConn
)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	        OldIrql;
    PASPC_CONNOBJ   pTmpConn;
    BOOLEAN         fConnIsValid=FALSE;

	ACQUIRE_SPIN_LOCK(&atalkAspCLock, &OldIrql);

    pTmpConn = atalkAspCConnList;

    while (pTmpConn)
    {
        if (pTmpConn == pAspConn)
        {
            fConnIsValid = TRUE;
            break;
        }

        pTmpConn = pTmpConn->aspcco_Next;
    }
	RELEASE_SPIN_LOCK(&atalkAspCLock, OldIrql);

    return(fConnIsValid);
}

LOCAL VOID
atalkAspCCloseSession(
	IN	PASPC_CONNOBJ				pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	
}


LOCAL VOID
atalkAspCIncomingOpenReply(
	IN	ATALK_ERROR					ErrorCode,
	IN	PASPC_CONNOBJ				pAspConn,		// Our context
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pReadAmdl,
	IN	USHORT						ReadLen,
	IN	PBYTE						ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR				error;
	USHORT					OpenStatus;
	BYTE					UserBytes[ATP_USERBYTES_SIZE];
	BOOLEAN					DerefConn = FALSE;
	PASPC_ADDROBJ			pAspAddr = pAspConn->aspcco_pAspCAddr;

	ASSERT(VALID_ASPCCO(pAspConn));

	if (ATALK_SUCCESS(ErrorCode))
	do
	{
		//	Check for open reply code in packet.
		GETSHORT2SHORT(&OpenStatus, &ReadUserBytes[ASP_ERRORCODE_OFF]);
		if (OpenStatus != 0)
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspCIncomingOpenReply: Failed %ld, %lx\n", OpenStatus, pAspConn));

			DerefConn = TRUE;	// Since we are not queuing a request handler
			ErrorCode = ATALK_REMOTE_CLOSE;
			break;
		}

		ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);

		//	Save the socket the server's SSS
		pAspConn->aspcco_ServerSssAddr = pAspConn->aspcco_ServerSlsAddr;
		pAspConn->aspcco_ServerSssAddr.ata_Socket = ReadUserBytes[ASP_SSS_OFF];
		pAspConn->aspcco_SessionId = ReadUserBytes[ASP_SESSIONID_OFF];
		pAspConn->aspcco_Flags &= ~ASPCCO_CONNECTING;
		pAspConn->aspcco_Flags |= ASPCCO_ACTIVE;

		pAspConn->aspcco_LastContactTime = AtalkGetCurrentTick();

		//	Reference for the request handler
		AtalkAspCConnReferenceByPtrNonInterlock(pAspConn, &error);

		//	Build up userBytes to start tickling the other end.
		UserBytes[ASP_CMD_OFF]	= ASP_TICKLE;
		UserBytes[ASP_SESSIONID_OFF] = pAspConn->aspcco_SessionId;
		PUTSHORT2SHORT(UserBytes + ASP_ERRORCODE_OFF, 0);

		RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);

		//	Set the request handler on this connection.
		//	It will handle tickle's, close's and write-continue
		AtalkAtpSetReqHandler(pAspAddr->aspcao_pAtpAddr,
							  atalkAspCHandler,
							  pAspConn);

		error = AtalkAtpPostReq(pAspConn->aspcco_pAtpAddr,
								&pAspConn->aspcco_ServerSlsAddr,
								&pAspConn->aspcco_TickleTid,
								0,						// ALO transaction
								NULL,
								0,
								UserBytes,
								NULL,
								0,
								ATP_INFINITE_RETRIES,
								ASP_TICKLE_INTERVAL,
								THIRTY_SEC_TIMER,
								NULL,
								NULL);

		if (ATALK_SUCCESS(error))
		{
			ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
			pAspConn->aspcco_Flags |= ASPCCO_TICKLING;
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
		}
		else
		{
			DerefConn = TRUE;	// Since we are not queuing a request handler
		}
	} while (FALSE);

	if (!ATALK_SUCCESS(ErrorCode))
	{
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
				("atalkAspCIncomingOpenReply: Incoming connect fail %lx\n", ErrorCode));

		AtalkAspCConnDereference(pAspConn);	

		//	Mark it as inactive
		ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
		pAspConn->aspcco_Flags &= ~ASPCCO_ACTIVE;
		RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
	}

	//	Call the completion routine.
	(*pAspConn->aspcco_ConnectCompletion)(ErrorCode, pAspConn->aspcco_ConnectCtx);
}


LOCAL VOID
atalkAspCIncomingStatus(
	IN	ATALK_ERROR					ErrorCode,
	IN	PACTREQ						pActReq,		// Our Ctx
	IN	PAMDL						pReqAmdl,
	IN	PAMDL						pStatusAmdl,
	IN	USHORT						StatusLen,
	IN	PBYTE						ReadUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Call the action completion routine
	(*pActReq->ar_Completion)(ErrorCode, pActReq);
}




LOCAL VOID
atalkAspCIncomingCmdReply(
	IN	ATALK_ERROR				Error,
	IN	PASPC_REQUEST			pAspReq,
	IN	PAMDL					pReqAMdl,
	IN	PAMDL					pRespAMdl,
	IN	USHORT					RespSize,
	IN	PBYTE					RespUserBytes
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PASPC_CONNOBJ	pAspConn;
	PASPC_REQUEST *	ppAspReq;
	KIRQL			OldIrql;

	pAspConn = pAspReq->aspcrq_pAspConn;

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);
	// Unlink the request from the active list
	for (ppAspReq = &pAspConn->aspcco_pActiveReqs;
		 *ppAspReq != NULL;
		 ppAspReq = &((*ppAspReq)->aspcrq_Next))
	{
		if (pAspReq == *ppAspReq)
		{
			*ppAspReq = pAspReq->aspcrq_Next;
			break;
		}
	}

	ASSERT(*ppAspReq == pAspReq->aspcrq_Next);

	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	// Complete the request
	(*pAspReq->aspcrq_pActReq->ar_Completion)(Error, pAspReq->aspcrq_pActReq);

	//  and dereference the connection
	AtalkAspCConnDereference(pAspConn);

	// and finally free the request
	AtalkFreeMemory(pAspReq);
}


LOCAL VOID
atalkAspCHandler(
	IN	ATALK_ERROR					ErrorCode,
	IN	PASPC_CONNOBJ				pAspConn,
	IN	PATP_RESP					pAtpResp,		// Used by PostResp/CancelResp
	IN	PATALK_ADDR					pSrcAddr,		// Address of requestor
	IN	USHORT						PktLen,
	IN	PBYTE						pPkt,
	IN	PBYTE						pUserBytes
	)
/*++

Routine Description:
	Handle tickle, write-continue requests, attentions and close from the server.

Arguments:


Return Value:


--*/
{
	USHORT						SequenceNum;	// From the incoming packet
	BYTE						SessionId;		// -- ditto --
	BYTE						RequestType;	// -- ditto --
	BOOLEAN						CancelTickle, ReleaseLock = TRUE, CancelResp = FALSE, Deref = FALSE;
	PIRP						exRecvIrp;
	PTDI_IND_RECEIVE_EXPEDITED	exRecvHandler;
	PVOID						exRecvHandlerCtx;
	ULONG						exIndicateFlags;
	PASPC_REQUEST				pAspReq;
	ATALK_ERROR					Error;

	do
	{
		if (!ATALK_SUCCESS(ErrorCode))
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspCHandler: Error %ld\n", ErrorCode));
			// Take away the reference on the Conn now that the atp address is closing
			if (ErrorCode == ATALK_ATP_CLOSING)
				AtalkAspCConnDereference(pAspConn);
			break;
		}

		ASSERT(VALID_ASPCCO(pAspConn));

		ACQUIRE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);

		SessionId = pUserBytes[ASP_SESSIONID_OFF];
		RequestType = pUserBytes[ASP_CMD_OFF];
		GETSHORT2SHORT(&SequenceNum, pUserBytes+ASP_SEQUENCE_NUM_OFF);

		AtalkAspCConnReferenceByPtrNonInterlock(pAspConn, &Error);
		if (ATALK_SUCCESS(Error) && (pAspConn->aspcco_SessionId == SessionId))
		{
			pAspConn->aspcco_LastContactTime = AtalkGetCurrentTick();
		
			switch (RequestType)
			{
			  case ASP_CLOSE_SESSION:
				// Cancel all outstanding requests (and any posted replies to write continue)
				// and shut down the session. Start off by sending a close response.
				CancelTickle = ((pAspConn->aspcco_Flags &ASPCO_TICKLING) != 0);
				pAspConn->aspcco_Flags &= ~(ASPCCO_ACTIVE | ASPCCO_TICKLING);
				pAspConn->aspcco_Flags |= ASPCO_REMOTE_CLOSE;
				RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
				ReleaseLock = FALSE;
		
				// Send a CloseSession reply and close the session
				Error = AtalkAtpPostResp(pAtpResp,
										 pSrcAddr,
										 NULL,
										 0,
										 NULL,
										 AtalkAtpGenericRespComplete,
										 pAtpResp);
				if (!ATALK_SUCCESS(Error))
				{
					AtalkAtpGenericRespComplete(Error, pAtpResp);
					DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
							("atalkAspSssXHandler: AtalkAtpPostResp failed %ld\n", Error));
				}
		
				// Cancel the tickle requests for this session
				if (CancelTickle)
				{
					Error = AtalkAtpCancelReq(pAspConn->aspcco_pAtpAddr,
											  pAspConn->aspcco_TickleXactId,
											  &pAspConn->aspcco_ServerSssAddr);
			
					if (!ATALK_SUCCESS(Error))
					{
						DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
								("atalkAspSssXHandler: AtalkAtpCancelReq %ld\n", Error));
					}
				}
		
				// Shut down this session, well almost ... Note that we have a reference
				// to this connection which will be Dereferenced by atalkAspSessionClose.
				atalkAspCCloseSession(pAspConn);
				break;

			  case ASP_ATTENTION:
				// Server is sending us an attention. If we already have a getattn posted
				// complete that. If not, just save the attention word and indicate to AFD
				// that we have recvd. expedited data
				if ((pAspConn->aspcco_AttnInPtr - pAspConn->aspcco_AttnOutPtr) < MAX_ASPC_ATTNS)
				{
					pAspConn->aspcco_AttnBuf[pAspConn->aspcco_AttnInPtr % MAX_ASPC_ATTNS] = SequenceNum;
					pAspConn->aspcco_AttnInPtr++;

					RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
					ReleaseLock = FALSE;
				}
				break;

			  case ASP_WRITE_DATA:
				// We need to find the request for which we sent a Write command. The
				// server now needs the data. Post a response for this.
				for (pAspReq = pAspConn->aspcco_pActiveReqs;
					 pAspReq != NULL;
					 pAspReq = pAspReq->aspcrq_Next)
				{
					if (pAspReq->aspcrq_SeqNum == SequenceNum)
					{
						RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
						ReleaseLock = FALSE;
						Error = AtalkAtpPostResp(pAtpResp,
												 pSrcAddr,
												 pAspReq->aspcrq_pWriteMdl,
												 pAspReq->aspcrq_WriteSize,
												 NULL,
												 AtalkAtpGenericRespComplete,
												 pAtpResp);
						Deref = TRUE;
						break;
					}
				}
				break;

			  case ASP_TICKLE:
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
						("atalkAspCHandler: Received tickle from %x.%x Session %d\n",
						pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));
				CancelResp = TRUE;
				Deref = TRUE;
				break;
			
			  default:
				DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_INFO,
						("atalkAspCHandler: Invalid commnd %d from %x.%x Session %d\n",
						RequestType, pSrcAddr->ata_Network, pSrcAddr->ata_Node, SessionId));
				CancelResp = TRUE;
				Deref = TRUE;
				break;
			}
		}
		else
		{
			DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_ERR,
					("atalkAspCHandler: Mismatched session id from %d.%d, expected %d, recvd. %d\n",
					pSrcAddr->ata_Network, pSrcAddr->ata_Node,
					pAspConn->aspcco_SessionId, SessionId));
		}

		if (ReleaseLock)
		{
			RELEASE_SPIN_LOCK_DPC(&pAspConn->aspcco_Lock);
		}
		if (CancelResp)
		{
			AtalkAtpCancelResp(pAtpResp);
		}
		if (Deref)
		{
			AtalkAspCConnDereference(pAspConn);
		}
	} while (FALSE);
}


LOCAL LONG FASTCALL
atalkAspCSessionMaintenanceTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	
	return ATALK_TIMER_REQUEUE;
}


VOID FASTCALL
AtalkAspCAddrDereference(
	IN	PASPC_ADDROBJ			pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN	Close = FALSE;
	KIRQL	OldIrql;

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_REFASPADDR,
			("AtalkAspCAddrDereference: %lx, %d\n",
			pAspAddr, pAspAddr->aspcao_RefCount-1));

	ASSERT (VALID_ASPCAO(pAspAddr));

	ACQUIRE_SPIN_LOCK(&pAspAddr->aspcao_Lock, &OldIrql);
	if (--(pAspAddr->aspcao_RefCount) == 0)
	{
		ASSERT(pAspAddr->aspcao_Flags & ASPCAO_CLOSING);
		Close = TRUE;
	}
	RELEASE_SPIN_LOCK(&pAspAddr->aspcao_Lock, OldIrql);

	if (Close)
	{
		if (pAspAddr->aspcao_CloseCompletion != NULL)
			(*pAspAddr->aspcao_CloseCompletion)(ATALK_NO_ERROR,
											    pAspAddr->aspcao_CloseContext);
		// Finally free the memory
		AtalkFreeMemory(pAspAddr);

		AtalkUnlockAspCIfNecessary();
	}
}


VOID FASTCALL
AtalkAspCConnDereference(
	IN	PASPC_CONNOBJ			pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	BOOLEAN	Close = FALSE;
	KIRQL	OldIrql;

	ASSERT (VALID_ASPCCO(pAspConn));

	DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_REFASPADDR,
			("AtalkAspCConnDereference: %lx, %d\n",
			pAspConn, pAspConn->aspcco_RefCount-1));

	ACQUIRE_SPIN_LOCK(&pAspConn->aspcco_Lock, &OldIrql);
	if (--(pAspConn->aspcco_RefCount) == 0)
	{
		ASSERT(pAspConn->aspcco_Flags & ASPCCO_CLOSING);
		Close = TRUE;
	}
	RELEASE_SPIN_LOCK(&pAspConn->aspcco_Lock, OldIrql);

	if (Close)
	{
		if (pAspConn->aspcco_CloseComp != NULL)
			(*pAspConn->aspcco_CloseComp)(ATALK_NO_ERROR,
											    pAspConn->aspcco_CloseCtx);

        atalkAspCDeQueueConnGlobalList(pAspConn);

		// Finally free the memory
		AtalkFreeMemory(pAspConn);

		AtalkUnlockAspCIfNecessary();
	}
}


LOCAL	VOID
atalkAspCQueueAddrGlobalList(
	IN	PASPC_ADDROBJ	pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkAspCLock, &OldIrql);
	AtalkLinkDoubleAtHead(atalkAspCAddrList, pAspAddr, aspcao_Next, aspcao_Prev);
	RELEASE_SPIN_LOCK(&atalkAspCLock, OldIrql);
}


LOCAL	VOID
atalkAspCDeQueueAddrGlobalList(
	IN	PASPC_ADDROBJ	pAspAddr
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkAspCLock, &OldIrql);
	AtalkUnlinkDouble(pAspAddr, aspcao_Next, aspcao_Prev);
	RELEASE_SPIN_LOCK(&atalkAspCLock, OldIrql);
}


LOCAL	VOID
atalkAspCQueueConnGlobalList(
	IN	PASPC_CONNOBJ	pAspConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkAspCLock, &OldIrql);
	AtalkLinkDoubleAtHead(atalkAspCConnList, pAspConn, aspcco_Next, aspcco_Prev);
	RELEASE_SPIN_LOCK(&atalkAspCLock, OldIrql);
}


LOCAL	VOID
atalkAspCDeQueueConnGlobalList(
	IN	PASPC_CONNOBJ	pAspCConn
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkAspCLock, &OldIrql);
	AtalkUnlinkDouble(pAspCConn, aspcco_Next, aspcco_Prev);
	RELEASE_SPIN_LOCK(&atalkAspCLock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\arapdbg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	arapdbg.c

Abstract:

	This module implements all debug utilities used by ARAP

Author:

	Shirish Koti

Revision History:
	26 March 1997		Initial Version

--*/

#include 	<atalk.h>

#pragma hdrstop

//	File module number for errorlogging
#define	FILENUM		ARAPDBG


#define ALIGN8(Ptr) ( (((ULONG_PTR)(Ptr))+7) & (~7) )
//
// The following are debug-only routines.  These routines help us catch bad
// things before they do damage, and help us sleep better at night.
//


#if DBG

DWORD   ArapDbgDumpOnDisconnect = 0;

//***
//
// Function: ArapProcessSniff
//              Stores the sniff irp.  Next time some connection needs to return
//              the sniff info, use this irp.
//
// Parameters:  pIrp - the Sniff irp to process
//
// Return:      result of the operation
//
//***$

NTSTATUS
ArapProcessSniff(
    IN  PIRP  pIrp
)
{
    KIRQL                   OldIrql;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;


    ARAPTRACE(("Entered ArapProcessSniff (%lx)\n",pIrp));

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    // store the irp (we can only have one Sniff irp at a time)
    ASSERT (ArapSniffIrp == NULL);

    if (ArapSniffIrp != NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapProcessSniff: Sniff irp %lx already in progress!\n", ArapSniffIrp));

        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;
        pSndRcvInfo->StatusCode = ARAPERR_IRP_IN_PROGRESS;
        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
        return( STATUS_SUCCESS );
    }

    ArapSniffIrp = pIrp;

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);


    return(STATUS_PENDING);
}


//***
//
// Function: ArapDumpSniffInfo
//              If we have collected enough sniff info, complete the sniff irp
//
// Parameters:  pArapConn - connection in question
//
// Return:      TRUE if we returned info to dll, FALSE otherwise
//
//***$

BOOLEAN
ArapDumpSniffInfo(
    IN PARAPCONN    pArapConn
)
{

    PIRP                    pIrp;
    DWORD                   dwBytesToDll;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    // if we don't have a sniff buffer (or no bytes in it), get out
    if (!pArapConn->pDbgTraceBuffer || pArapConn->SniffedBytes == 0)
    {
        return(FALSE);
    }

    //
    // if we have less than 500 bytes in the buffer, and we aren't disconnecting
    // or disconnected, don't complete the irp as yet
    // (it's ok not have spinlock here)
    //
    if ((pArapConn->SniffedBytes < 500) &&
        (pArapConn->State == MNP_UP ))
    {
        return(FALSE);
    }

    ARAP_GET_SNIFF_IRP(&pIrp);

    // no sniff irp available? can't do much, leave
    if (!pIrp)
    {
        return(FALSE);
    }

    dwBytesToDll = ArapFillIrpWithSniffInfo(pArapConn,pIrp) +
                   sizeof(ARAP_SEND_RECV_INFO);

    // ok, complete that irp now!
    ARAP_COMPLETE_IRP(pIrp, dwBytesToDll, STATUS_SUCCESS, &ReturnStatus);

    return(TRUE);

}


//***
//
// Function: ArapFillIrpWithSniffInfo
//              Copy the sniff bytes into the irp
//
// Parameters:  pArapConn - connection in question
//              pIrp - the irp to fill data in
//                     (except in one case, this irp will be the sniff irp.
//                     The exception case is where disconnect has occured and
//                     and at that time, a sniff irp wasn't available.  In that
//                     case, we use the select irp that's carrying the disconnect
//                     info to send the remaining sniff bytes).
//
// Return:      Number of sniff bytes that were copied in
//
//***$

DWORD
ArapFillIrpWithSniffInfo(
    IN PARAPCONN    pArapConn,
    IN PIRP         pIrp
)
{
    PARAP_SEND_RECV_INFO    pSndRcvInfo=NULL;
    KIRQL                   OldIrql;
    DWORD                   SniffedBytes;
    PBYTE                   pStartData;
    DWORD                   dwBytesToDll;


    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    //
    // if buffer is smaller than how much data we have, adjust by ignoring
    // bytes in the beginning of the buffer
    //
    if (pSndRcvInfo->DataLen < pArapConn->SniffedBytes)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapFill...Info: chopping %d bytes in the beginning\n",
                (pArapConn->SniffedBytes - pSndRcvInfo->DataLen)));

        pStartData = pArapConn->pDbgTraceBuffer +
                        (pArapConn->SniffedBytes - pSndRcvInfo->DataLen);

        pArapConn->SniffedBytes = pSndRcvInfo->DataLen;
    }
    else
    {
        pStartData = pArapConn->pDbgTraceBuffer;
    }

    SniffedBytes = pArapConn->SniffedBytes;

    // ok, copy the data in
    RtlCopyMemory( &pSndRcvInfo->Data[0],
                   pStartData,
                   SniffedBytes );

    pArapConn->pDbgCurrPtr = pArapConn->pDbgTraceBuffer;

    pArapConn->SniffedBytes = 0;

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    // set the info (contexts need to be set each time in case of select)
    pSndRcvInfo->AtalkContext = pArapConn;
    pSndRcvInfo->pDllContext =  pArapConn->pDllContext;
    pSndRcvInfo->DataLen = SniffedBytes;
    pSndRcvInfo->StatusCode = ARAPERR_NO_ERROR;

    return(SniffedBytes);

}


//***
//
// Function: DbgChkRcvQIntegrity
//              This routine looks at the first buffer on the receive queue and
//              verifies that things look reasonable
//
// Parameters:  pArapConn - the connection in question
//
// Return:      TRUE if things look reasonable, FALSE otherwise
//
// NOTES:       IMPORTANT: spinlock must be held before calling this routine
//
//***$

BOOLEAN
DbgChkRcvQIntegrity(
    IN  PARAPCONN       pArapConn
)
{
    PLIST_ENTRY     pList;
    PARAPBUF        pArapBuf;
    PBYTE           packet;
    USHORT          SrpLen;


    pList = pArapConn->ReceiveQ.Flink;
    if (pList == &pArapConn->ReceiveQ)
    {
        return( TRUE );
    }

    if (!(pArapConn->Flags & ARAP_CONNECTION_UP))
    {
        return( TRUE );
    }

    pArapBuf = CONTAINING_RECORD(pList, ARAPBUF, Linkage);

    // wait until more bytes show up
    if (pArapBuf->DataSize < 6)
    {
        return( TRUE );
    }

    packet = pArapBuf->CurrentBuffer;

    GETSHORT2SHORT(&SrpLen, pArapBuf->CurrentBuffer);

    if (SrpLen > ARAP_MAXPKT_SIZE_INCOMING)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ARAP: packet too big (%d bytes) in %lx)\n",SrpLen,pArapBuf));

        return(FALSE);
    }

    if ((packet[2] != 0x50) && (packet[2] != 0x10))
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ARAP: wrong DGroup byte (%x) in %lx)\n",packet[2],pArapBuf));

        return(FALSE);
    }

    if (packet[2] == 0x50)
    {
        if ((packet[3] != 0) || (packet[4] != 0) || (packet[5] != 2))
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ARAP (%lx): wrong LAP hdr in %lx)\n",pArapBuf));

            return(FALSE);
        }
    }

    return( TRUE );
}



//***
//
// Function: DbgDumpBytes
//              This routine dumps first 64 bytes from a buffer to the debugger
//
// Parameters:  pDbgMsg - string to print before the bytes (optional)
//              pBuffer - buffer from which to dump the bytes
//              BufLen - how big is the buffer
//              DumpLevel - if this matches ArapDumpLevel, we dump the bytes
//
// Return:      Nothing
//
//***$

VOID
DbgDumpBytes(
    IN PBYTE  pDbgMsg,
    IN PBYTE  pBuffer,
    IN DWORD  BufLen,
    IN DWORD  DumpLevel
)
{
    BYTE        OutBuf[400];
    DWORD       NextIndex;
    DWORD       dwBytesToDump;


    if (ArapDumpLevel != DumpLevel)
    {
        return;
    }

    if (pDbgMsg)
    {
        DbgPrint("%s (pkt len = %d)\n",pDbgMsg,BufLen);
    }
    else
    {
        DbgPrint("Dumping packet (pkt len = %d)\n",BufLen);
    }

    // dump the first 64 bytes

    dwBytesToDump = (BufLen <= 64)? BufLen : 64;

    dwBytesToDump = (dwBytesToDump < ArapDumpLen)?dwBytesToDump:ArapDumpLen;

    DbgDumpBytesPart2( pBuffer, OutBuf, dwBytesToDump, &NextIndex );

    OutBuf[NextIndex] = '\n';
    OutBuf[NextIndex+1] = 0;

    DbgPrint("%s",OutBuf);
}


//***
//
// Function: DbgDumpBytesPart2
//              This is a helper routine for the DbgDumpBytes routine
//***$

VOID
DbgDumpBytesPart2(
    IN  PBYTE  pBuffer,
    OUT PBYTE  OutBuf,
    IN  DWORD  BufLen,
    OUT DWORD *NextIndex
)
{
    BYTE        Byte;
    BYTE        nibble;
    DWORD       i, j;


    j = 0;
    OutBuf[j++] = ' '; OutBuf[j++] = ' '; OutBuf[j++] = ' '; OutBuf[j++] = ' ';

    for (i=0; i<BufLen; i++ )
    {
        Byte = pBuffer[i];

        nibble = (Byte >> 4);
        OutBuf[j++] = (nibble < 10) ? ('0' + nibble) : ('a' + (nibble-10));

        nibble = (Byte & 0x0f);
        OutBuf[j++] = (nibble < 10) ? ('0' + nibble) : ('a' + (nibble-10));

        OutBuf[j++] = ' ';

        if (((i+1) % 16) == 0)
        {
            OutBuf[j++] = '\n'; OutBuf[j++] = ' ';
            OutBuf[j++] = ' '; OutBuf[j++] = ' '; OutBuf[j++] = ' ';
        }
        else if (((i+1) % 8) == 0)
        {
            OutBuf[j++] = ' ';
        }
    }

    *NextIndex = j;

    return;
}



//***
//
// Function: DbgDumpNetworkNumbers
//              This routine dumps out all the network ranges that exist on the
//              network.
//
// Parameters:  None
//
// Return:      Nothing
//
//***$

VOID
DbgDumpNetworkNumbers(
    IN VOID
)
{
    KIRQL       OldIrql;
	PRTE	    pRte, pNext;
	int		    i;


	ACQUIRE_SPIN_LOCK(&AtalkRteLock, &OldIrql);

	for (i = 0; i < NUM_RTMP_HASH_BUCKETS; i++)
	{
		for (pRte = AtalkRoutingTable[i]; pRte != NULL; pRte = pNext)
		{
			pNext = pRte->rte_Next;

			ACQUIRE_SPIN_LOCK_DPC(&pRte->rte_Lock);

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("    pRte: %lx  LowEnd %lx  HighEnd %lx\n",
                    pRte,pRte->rte_NwRange.anr_FirstNetwork,pRte->rte_NwRange.anr_LastNetwork));
            RELEASE_SPIN_LOCK_DPC(&pRte->rte_Lock);
		}
	}

	RELEASE_SPIN_LOCK(&AtalkRteLock, OldIrql);
}


//***
//
// Function: DbgTrackInfo
//              This routine tracks various information, useful in arriving at
//              optimum buffer sizes, etc.
//
// Parameters:  pArapConn - the connection in question
//              Size - size of the buffer (incoming, outgoing, as appropriate)
//              TrackingWhat - what are we tracking (sends, recvs etc.)
//
// Return:      Nothing
//
//***$

VOID
DbgTrackInfo(
    IN PARAPCONN    pArapConn,
    IN DWORD        Size,
    IN DWORD        TrackingWhat
)
{
    //
    // track the MNP send sizes (how many are 0-10 bytes, 11-20 bytes, etc.)
    //
    if (TrackingWhat == 1)
    {
        ArapDbgMnpSendSizes[Size/10]++;

        return;
    }
}



//***
//
// Function: ArapDbgTrace
//              This routine traces (keeps a log) of all the events (data going
//              in/out, acks going in/out, error conditions etc.
//
// Parameters:  pArapConn - the connection in question
//              Location  - who is logging this event (the location decides what
//                          the other parms are going to be)
//              Context   - depends on Location (e.g.could be data buffer)
//              dwInfo1   - depends on Location
//              dwInfo2   - depends on Location
//              dwInfo3   - depends on Location
//
// Return:      Nothing
//
// NOTE:        Spinlock is assumed to be held
//
//***$

VOID
ArapDbgTrace(
    IN PARAPCONN    pArapConn,
    IN DWORD        Location,
    IN PVOID        Context,
    IN DWORD        dwInfo1,
    IN DWORD        dwInfo2,
    IN DWORD        dwInfo3
)
{
    LARGE_INTEGER   CurrTime;
    LARGE_INTEGER   DiffTime;
    PBYTE           pStartTrace;
    PBYTE           pTrace;
    PBUFFER_DESC    pBuffDesc;
    PARAPBUF        pArapBuf;
    PMNPSENDBUF     pMnpSendBuf;
    PBYTE           pCurrBuff;
    DWORD           BufLenSoFar=0;
    USHORT          Delta;
    BYTE            Priority;
    DWORD           BytesCopied=0;
    DWORD           BytesAvailable;
    USHORT          DbgInfoLen;
    PSNIFF_INFO     pSniff;
    DWORD           i;



    if (!pArapConn->pDbgTraceBuffer)
    {
        return;
    }

    KeQuerySystemTime(&CurrTime);

    DiffTime = RtlLargeIntegerSubtract(CurrTime, ArapDbgLastTraceTime);

    ArapDbgLastTraceTime = CurrTime;

    // do the conversion to get ms
    Delta = (USHORT)(DiffTime.LowPart);

    pSniff = (PSNIFF_INFO)(pArapConn->pDbgCurrPtr);

    pTrace = pStartTrace = &pSniff->Frame[0];

    // put signature (starting of a "frame")
    pSniff->Signature = ARAP_SNIFF_SIGNATURE;

    // time since last event
    pSniff->TimeStamp = (DWORD)AtalkGetCurrentTick();

    // who is logging this info
    pSniff->Location = (USHORT)Location;

    //
    // ok, now see who has called us and log the relevant info
    // If we can't find the Location, it's ok: we have the Location number
    // logged and and that's adequate (that's why we can't find Location)
    //
    switch (Location)
    {
        // data to client is about to be compressed: copy some info
        case 11205:

            pBuffDesc = (PBUFFER_DESC)Context;
            Priority = (BYTE)dwInfo1;

            while (pBuffDesc)
            {
                if (pBuffDesc->bd_Flags & BD_CHAR_BUFFER)
                {
                    pCurrBuff = pBuffDesc->bd_CharBuffer;
                    BytesAvailable = pBuffDesc->bd_Length;
                }

                else
                {
                    pCurrBuff = MmGetSystemAddressForMdlSafe(
                                    pBuffDesc->bd_OpaqueBuffer,
                                    NormalPagePriority);

					if (pCurrBuff == NULL) {
						goto error_end;
					}
                    BytesAvailable = MmGetMdlByteCount(pBuffDesc->bd_OpaqueBuffer);
                }

                //
                // if this buffer descriptor contains (usually exclusively) the
                // ARAP header, then get some info out of it and skip those bytes
                //
                if ((pCurrBuff[2] == 0x10 || pCurrBuff[2] == 0x50) &&
                    (pCurrBuff[3] == 0) && (pCurrBuff[4] == 0) && (pCurrBuff[5] == 2))
                {
                    *pTrace++ = pCurrBuff[0];   // srplen byte 1
                    *pTrace++ = pCurrBuff[1];   // srplen byte 2
                    *pTrace++ = pCurrBuff[2];   // ARAP or Atalk packet
                    *pTrace++ = Priority;
                    BytesAvailable -= 6;
                    pCurrBuff += 6;
                }

                // copy first 48 bytes of the data packet
                while (BytesAvailable && BytesCopied < 48)
                {
                    *pTrace++ = *pCurrBuff++;
                    BytesCopied++;
                    BytesAvailable--;
                }

                pBuffDesc = pBuffDesc->bd_Next;
            }

            break;

        // we are sending out an ack
        case 11605:

            *pTrace++ = (BYTE)dwInfo1;    // sequence num in our ack
            *pTrace++ = (BYTE)dwInfo2;    // rcv credit in our ack
            break;


        // we are queuing compressed send bytes
        case 21205:

            *pTrace++ = (BYTE)dwInfo2;    // priority of the send
            *pTrace++ = (BYTE)dwInfo3;    // Start sequence for this send
            *pTrace++ = (BYTE)(pArapConn->MnpState.NextToSend-1);  // end sequence

            BytesAvailable = dwInfo1;        // len of compressed data
            pCurrBuff = (PBYTE)Context;       // buffer with compressed data

            // copy first 24 bytes of the compressed data
            while (BytesAvailable && BytesCopied < 24)
            {
                *pTrace++ = *pCurrBuff++;
                BytesCopied++;
                BytesAvailable--;
            }

            break;


        // ArapExtractSRP: we're handing over 1 srp for routing or to dll
        case 21105:

            pArapBuf = (PARAPBUF)Context;
            pCurrBuff = pArapBuf->CurrentBuffer;
            BytesAvailable = pArapBuf->DataSize;

            // copy first 48 bytes of the decompressed data
            while (BytesAvailable && BytesCopied < 48)
            {
                *pTrace++ = *pCurrBuff++;
                BytesCopied++;
                BytesAvailable--;
            }
            break;


        // we just recvd a packet in ArapRcvIndication
        case 30105:

            BytesAvailable = dwInfo1-7;    // lookahead size, minus start,stop,crc
            pCurrBuff = ((PBYTE)Context)+3; // lookahead buffer plus 3 start

            PUTSHORT2SHORT(pTrace,(USHORT)BytesAvailable);
            pTrace += sizeof(USHORT);

            // copy first 24 bytes of the compressed data
            while (BytesAvailable && BytesCopied < 24)
            {
                *pTrace++ = *pCurrBuff++;
                BytesCopied++;
                BytesAvailable--;
            }

            break;

        // we recvd a 0-len packet!
        case 30106:

            break;

        // we decompressed the incoming data
        case 30110:

            // how much was the decompressed length
            PUTSHORT2SHORT(pTrace,(USHORT)dwInfo1);
            pTrace += sizeof(USHORT);

            if (dwInfo1 == 0)
            {
                break;
            }

            pArapBuf = (PARAPBUF)Context;

            BytesAvailable = pArapBuf->DataSize;      // len of decompressed data
            pCurrBuff = pArapBuf->CurrentBuffer;

            // copy first 48 bytes of the decompressed data
            while (BytesAvailable && BytesCopied < 48)
            {
                *pTrace++ = *pCurrBuff++;
                BytesCopied++;
                BytesAvailable--;
            }

            break;

        // attempting send when state was >= MNP_LDISCONNECTING
        case 30305:

            *pTrace = (BYTE)dwInfo1;       // store pArapConn->State
            break;

        // we just sent out a packet in ArapNdisSend()
        case 30320:

            pMnpSendBuf = (PMNPSENDBUF)Context;
            *pTrace++ = pMnpSendBuf->SeqNum;

            // how big is the MNP packet
            PUTSHORT2SHORT(pTrace,pMnpSendBuf->DataSize);
            pTrace += sizeof(USHORT);

            *pTrace++ = (BYTE)dwInfo1;    // is this a retransmission

            BytesAvailable = pMnpSendBuf->DataSize;
            pCurrBuff = (&pMnpSendBuf->Buffer[0]) + 3;  // skip start bytes

            // copy first 24 bytes of the compressed data
            while (BytesAvailable && BytesCopied < 24)
            {
                *pTrace++ = *pCurrBuff++;
                BytesCopied++;
                BytesAvailable--;
            }

        default:

            break;

    }

    DbgInfoLen = (USHORT)(pTrace - pStartTrace);

    pSniff->FrameLen = DbgInfoLen;

    pArapConn->pDbgCurrPtr = (PBYTE)ALIGN8(pTrace);

    // fill up the round-up space with 0s
    for (NOTHING; pTrace < pArapConn->pDbgCurrPtr; pTrace++)
    {
        *pTrace = 0;
    }

    // make sure we haven't overrun this buffer
    ASSERT(*((DWORD *)&(pArapConn->pDbgTraceBuffer[ARAP_SNIFF_BUFF_SIZE-4])) == 0xcafebeef);

    // how many more bytes did we add to the sniff buff?
    pArapConn->SniffedBytes += (DWORD)(pArapConn->pDbgCurrPtr - (PBYTE)pSniff);

    //
    // if we are about to overflow, just reset the pointer to beginning
    // (do it while we have still 200 bytes left)
    //
    BufLenSoFar = (DWORD)(pArapConn->pDbgCurrPtr - pArapConn->pDbgTraceBuffer);

error_end:

    if (BufLenSoFar > ARAP_SNIFF_BUFF_SIZE-200)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,
                ("ArapDbgTrace: resetting debug buffer, Sniff data LOST!\n"));

        pArapConn->pDbgCurrPtr = pArapConn->pDbgTraceBuffer;

        pArapConn->SniffedBytes = 0;
    }
}

//***
//
// Function: ArapDbgTrace
//              This routine records history of MNP level packet exchange
//
// Parameters:  pArapConn - the connection in question
//              Seq - sequence number (if applicable)
//              FrameType - LT, LA etc.
//
// Return:      Nothing
//
// NOTE:        Spinlock is assumed to be held
//
//***$

VOID
ArapDbgMnpHist(
    IN PARAPCONN    pArapConn,
    IN BYTE         Seq,
    IN BYTE         FrameType
)
{
    LARGE_INTEGER   TimeNow;
    DWORD           ThisDelta;
    DWORD           DbgMnpIndex;


    KeQuerySystemTime(&TimeNow);

    if (TimeNow.HighPart == pArapConn->LastTimeStamp.HighPart)
    {
        ThisDelta = (TimeNow.LowPart - pArapConn->LastTimeStamp.LowPart);
    }
    else
    {
        ThisDelta = (0xffffffff - pArapConn->LastTimeStamp.LowPart + TimeNow.LowPart);
    }

    // convert 100's ns to ms
    ThisDelta = (ThisDelta/10000);

    pArapConn->LastTimeStamp = TimeNow;

    pArapConn->DbgMnpHist[pArapConn->DbgMnpIndex].TimeStamp = ThisDelta;
    pArapConn->DbgMnpHist[pArapConn->DbgMnpIndex].FrameInfo = (FrameType << 16);
    pArapConn->DbgMnpHist[pArapConn->DbgMnpIndex].FrameInfo |= Seq;

    // wrap-around if necessary
    if ((++pArapConn->DbgMnpIndex) >= DBG_MNP_HISTORY_SIZE)
    {
        pArapConn->DbgMnpIndex = 0;
    }

}


//***
//
// Function: ArapDbgDumpMnpHistory
//              This routine dumps history of MNP level packet exchange
//
// Parameters:  pArapConn - the connection in question
//
// Return:      Nothing
//
//***$

VOID
ArapDbgDumpMnpHist(
    IN PARAPCONN    pArapConn
)
{
    DWORD       i;
    DWORD       dwTmp;
    DWORD       dwDelta;
    BYTE        TmpSeq;


    if (!ArapDbgDumpOnDisconnect)
    {
        return;
    }

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("DerefArapConn: Past history on %lx .....\n", pArapConn));

    // dump all info: old info first
    for (i=pArapConn->DbgMnpIndex; i<DBG_MNP_HISTORY_SIZE; i++)
    {
        dwDelta = pArapConn->DbgMnpHist[i].TimeStamp;
        dwTmp = (pArapConn->DbgMnpHist[i].FrameInfo & 0xffff0000);
        TmpSeq = (BYTE)(pArapConn->DbgMnpHist[i].FrameInfo & 0x000000ff);
        switch (dwTmp)
        {
            case 0x40000 : DbgPrint("   %6ld   NT sends %x\n",dwDelta,TmpSeq);break;
            case 0x50000 : DbgPrint("   %6ld                 NT acks %x\n",dwDelta,TmpSeq);break;
            case 0x140000: DbgPrint("   %6ld                 Mac sends %x\n",dwDelta,TmpSeq);break;
            case 0x150000: DbgPrint("   %6ld   Mac acks %x\n",dwDelta,TmpSeq);break;
            default      : DbgPrint("   %6ld   Unknown: %lx\n",dwDelta,pArapConn->DbgMnpHist[i].FrameInfo);
        }
    }

    // dump the current info
    for (i=0; i<pArapConn->DbgMnpIndex; i++)
    {
        dwDelta = pArapConn->DbgMnpHist[i].TimeStamp;
        dwTmp = (pArapConn->DbgMnpHist[i].FrameInfo & 0xffff0000);
        TmpSeq = (BYTE)(pArapConn->DbgMnpHist[i].FrameInfo & 0x000000ff);
        switch (dwTmp)
        {
            case 0x40000 : DbgPrint("   %6ld   NT sends %x\n",dwDelta,TmpSeq);break;
            case 0x50000 : DbgPrint("   %6ld                 NT acks %x\n",dwDelta,TmpSeq);break;
            case 0x140000: DbgPrint("   %6ld                 Mac sends %x\n",dwDelta,TmpSeq);break;
            case 0x150000: DbgPrint("   %6ld   Mac acks %x\n",dwDelta,TmpSeq);break;
            default      : DbgPrint("   %6ld   Unknown: %lx\n",dwDelta,pArapConn->DbgMnpHist[i].FrameInfo);
        }
    }
}

//***
//
// Function: ArapDumpNdisPktInfo
//              walk the ARAP connections list and find out how many Ndis packets
//              are in use right now
//
// Parameters:  nothing
//
// Return:      nothing
//
//***$

VOID
ArapDumpNdisPktInfo(
    IN VOID
)
{
    PARAPCONN       pArapConn;
    PLIST_ENTRY     pConnList;
    PLIST_ENTRY     pList;
    PMNPSENDBUF     pMnpSendBuf;
    KIRQL           OldIrql;
    DWORD           GrandTotal;
    DWORD           ReXmit;
    DWORD           ReXmitInNdis;
    DWORD           Fresh;
    DWORD           FreshInNdis;
    DWORD           ThisConn;
    DWORD           NumConns;



    if (!RasPortDesc)
    {
        return;
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    pConnList = RasPortDesc->pd_ArapConnHead.Flink;

    GrandTotal = 0;
    NumConns = 0;

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("NdisPacketInfo: counting total number of ndis packets used by ARAP....\n"));

    //
    // first, let's find the right connection to work on
    //
    while (pConnList != &RasPortDesc->pd_ArapConnHead)
    {
        ReXmit = 0;
        ReXmitInNdis = 0;
        Fresh = 0;
        FreshInNdis = 0;
        ThisConn = 0;

        pConnList = pConnList->Flink;

        pArapConn = CONTAINING_RECORD(pConnList, ARAPCONN, Linkage);

        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);


        pList = pArapConn->RetransmitQ.Flink;

        // collect all buffers on the retransmit queue first
        while (pList != &pArapConn->RetransmitQ)
        {
            pList = pList->Flink;

            pMnpSendBuf = CONTAINING_RECORD(pList, MNPSENDBUF, Linkage);
            ReXmit++;
            if (pMnpSendBuf->Flags == 1)
            {
                ReXmitInNdis++;
            }
        }

        pList = pArapConn->HighPriSendQ.Flink;

        // collect all buffers on the fresh send
        while (pList != &pArapConn->HighPriSendQ)
        {
            pList = pList->Flink;

            pMnpSendBuf = CONTAINING_RECORD(pList, MNPSENDBUF, Linkage);
            Fresh++;
            if (pMnpSendBuf->Flags == 1)
            {
                FreshInNdis++;
            }
        }

        ThisConn = ReXmit+ReXmitInNdis+Fresh+FreshInNdis;

    	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("     %ld packets on %lx, %d in Ndis (%d+%d+%d+%d)\n",
            ThisConn,pArapConn,ReXmitInNdis,ReXmit,ReXmitInNdis,Fresh,FreshInNdis));

        GrandTotal += ThisConn;
        NumConns++;

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("NdisPacketInfo: total of %ld Ndis Packets on %d connections\n",
        GrandTotal, NumConns));

}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\araputil.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	araputil.c

Abstract:

	This module implements utility routines needed for the ARAP functionality

Author:

	Shirish Koti

Revision History:
	15 Nov 1996		Initial Version

--*/

#include 	<atalk.h>
#pragma hdrstop

//	File module number for errorlogging
#define	FILENUM		ARAPUTIL

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_ARAP, DerefMnpSendBuf)
#pragma alloc_text(PAGE_ARAP, DerefArapConn)
#pragma alloc_text(PAGE_ARAP, ArapReleaseAddr)
#pragma alloc_text(PAGE_ARAP, ArapCleanup)
#pragma alloc_text(PAGE_ARAP, PrepareConnectionResponse)
#pragma alloc_text(PAGE_ARAP, ArapExtractAtalkSRP)
#pragma alloc_text(PAGE_ARAP, ArapQueueSendBytes)
#pragma alloc_text(PAGE_ARAP, ArapGetSendBuf)
#pragma alloc_text(PAGE_ARAP, ArapRefillSendQ)
#endif

//***
//
// Function: AllocArapConn
//              Allocate a connection element and initialize fields
//
// Parameters:  none
//
// Return:      pointer to a newly allocated connection element
//
//***$

PARAPCONN
AllocArapConn(
    IN ULONG    LinkSpeed
)
{

    PARAPCONN               pArapConn;
    v42bis_connection_t    *pV42bis;
    PUCHAR                  pBuf;
    LONG                    RetryTime;



    if ( (pArapConn = AtalkAllocZeroedMemory(sizeof(ARAPCONN))) == NULL)
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR, ("AllocArapConn: alloc failed\n"));

        return(NULL);
    }

    //
    // allocate v42bis buffers (it v42bis is enabled that is)
    //
    if (ArapGlobs.V42bisEnabled)
    {
        pV42bis = AtalkAllocZeroedMemory(sizeof(v42bis_connection_t));

        if (pV42bis == NULL)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AllocArapConn: alloc for v42 failed\n"));

            AtalkFreeMemory(pArapConn);

            return(NULL);
        }

        //
        // allocate overflow buffer for the decode side
        //
        if ((pBuf = AtalkAllocZeroedMemory(MAX_P2)) == NULL)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AllocArapConn: alloc for v42-2 failed\n"));

            AtalkFreeMemory(pArapConn);

            AtalkFreeMemory(pV42bis);

            return(NULL);
        }

        pV42bis->decode.OverFlowBuf = pBuf;
        pV42bis->decode.OverFlowBytes = 0;

        pV42bis->encode.OverFlowBuf = pBuf;
        pV42bis->encode.OverFlowBytes = 0;

        pArapConn->pV42bis = pV42bis;
    }

    //
    // if v42bis is not enabled, don't need no buffers!
    //
    else
    {
        pArapConn->pV42bis = NULL;
    }


#if DBG
    pArapConn->Signature = ARAPCONN_SIGNATURE;

    //
    // for debug builds, we can set registry parm to keep a trace of events
    // If that setting is enabled, alloc a buffer to store the trace
    //
    if (ArapGlobs.SniffMode)
    {
        pBuf = AtalkAllocZeroedMemory(ARAP_SNIFF_BUFF_SIZE);
        if (pBuf == NULL)
        {
		    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AllocArapConn: alloc for trace buffer failed\n"));

            // don't fail the call if this alloc fails
        }

        pArapConn->pDbgTraceBuffer = pArapConn->pDbgCurrPtr = pBuf;

        // put in a guard signature, to catch overrun
        if (pArapConn->pDbgTraceBuffer)
        {
            *((DWORD *)&(pArapConn->pDbgTraceBuffer[ARAP_SNIFF_BUFF_SIZE-4])) = 0xcafebeef;
        }
    }
#endif

    pArapConn->State = MNP_IDLE;

    // Creation refcount and a line-up refcount
    pArapConn->RefCount = 2;

    pArapConn->MnpState.WindowSize = ArapGlobs.MaxLTFrames;
    pArapConn->MnpState.RecvCredit = pArapConn->MnpState.WindowSize;

    pArapConn->LinkSpeed = LinkSpeed;

    //
    // T401 timer value in tick counts (1 tick = 100ms).
    // we'll keep this at 1 second (i.e. 10 ticks) for a 33.6 (and faster) modem.
    // If we are on a slower modem, increase it proportionately.  So, a 28.8 modem
    // would get RetryTime=2.0sec, 14.4 would get 3.7sec, 9600 baud would get 4.2sec etc.
    //
    RetryTime = 15;
    if (LinkSpeed < 336)
    {
        RetryTime += (((336 - LinkSpeed) + 5)/10);
    }

    // make sure our calculation didn't go haywire...

    if (RetryTime < ARAP_MIN_RETRY_INTERVAL)
    {
        RetryTime = ARAP_MIN_RETRY_INTERVAL;
    }
    else if (RetryTime > ARAP_MAX_RETRY_INTERVAL)
    {
        RetryTime = ARAP_MAX_RETRY_INTERVAL;
    }

    pArapConn->SendRetryTime = RetryTime;
    pArapConn->SendRetryBaseTime = RetryTime;

    // T402 is 0.5 times T401 value
    pArapConn->T402Duration = (pArapConn->SendRetryTime/2);

    //
    // T403 should be at least 59 seconds.  We don't really kill after this
    // period of inactivity.  We simply tell the dll and it does whatever is the
    // policy: so just use whatever time period the dll tells us
    //
    pArapConn->T403Duration = ArapGlobs.MnpInactiveTime;

    //
    // T404: spec says 3 sec for 2400 baud and faster, 7 sec for anything slower
    // Let's use 4 seconds here
    //
    pArapConn->T404Duration = 30;

    // initialize all the timer values
    pArapConn->LATimer = 0;
    pArapConn->InactivityTimer = pArapConn->T403Duration + AtalkGetCurrentTick();

    // set this to a high value for now: we'll set it when the conn is up
    pArapConn->FlowControlTimer = AtalkGetCurrentTick() + 36000;

    InitializeListHead(&pArapConn->MiscPktsQ);
    InitializeListHead(&pArapConn->ReceiveQ);
    InitializeListHead(&pArapConn->ArapDataQ);
    InitializeListHead(&pArapConn->RetransmitQ);
    InitializeListHead(&pArapConn->HighPriSendQ);
    InitializeListHead(&pArapConn->MedPriSendQ);
    InitializeListHead(&pArapConn->LowPriSendQ);
    InitializeListHead(&pArapConn->SendAckedQ);

    INITIALIZE_SPIN_LOCK(&pArapConn->SpinLock);

    // start the retransmit timer for this connection
    AtalkTimerInitialize( &pArapConn->RetryTimer,
                          (TIMER_ROUTINE)ArapRetryTimer,
                          ARAP_TIMER_INTERVAL) ;

    AtalkTimerScheduleEvent(&pArapConn->RetryTimer);

    pArapConn->Flags |= RETRANSMIT_TIMER_ON;

    // put a timer refcount
    pArapConn->RefCount++;

    return( pArapConn );
}


//***
//
// Function: ArapAcceptIrp
//              Determine if the irp submitted by the dll is acceptable now
//
// Parameters:  pIrp  - the incoming irp
//              IoControlCode - the control code (what's the irp for?)
//              pfDerefDefPort - was default adapter referenced?
//
// Return:      TRUE if the irp is acceptable, FALSE otherwise
//
//***$

BOOLEAN
ArapAcceptIrp(
    IN PIRP     pIrp,
    IN ULONG    IoControlCode,
    IN BOOLEAN  *pfDerefDefPort
)
{

    KIRQL                   OldIrql;
    PARAP_SEND_RECV_INFO    pSndRcvInfo=NULL;
    PARAPCONN               pArapConn;
    BOOLEAN                 fAccept=FALSE;
    BOOLEAN                 fUnblockPnP=FALSE;


    *pfDerefDefPort = FALSE;

    //
    // we allow these ioctls to come in any time
    //
    if ((IoControlCode == IOCTL_ARAP_SELECT) ||
        (IoControlCode == IOCTL_ARAP_DISCONNECT) ||
        (IoControlCode == IOCTL_ARAP_CONTINUE_SHUTDOWN) )
    {
        return(TRUE);
    }


    pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

    pArapConn = pSndRcvInfo->AtalkContext;

    //
    // put a IrpProcess refcount on the default port so it won't go away via pnp etc.
    //
    if (!AtalkReferenceRasDefPort())
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapProcessIoctl: Default port gone, or going %lx not accepted (%lx)\n",
            pIrp,IoControlCode));

        pSndRcvInfo->StatusCode = ARAPERR_STACK_IS_NOT_ACTIVE;
        return(FALSE);
    }

    // note the fact that we have referenced the default adapter
    *pfDerefDefPort = TRUE;

    //
    // now it's simple to decide whether we want to accept this irp or not
    //

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    fAccept = (ArapStackState == ARAP_STATE_ACTIVE) ? TRUE : FALSE;

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    return(fAccept);
}

//***
//
// Function: ArapCancelIrp
//              Cancel the irp.  Currently, only select irps are cancellable
//
// Parameters:  pIrp  - the incoming irp
//
// Return:      none
//
//***$
VOID
ArapCancelIrp(
    IN  PIRP    pIrp
)
{

    KIRQL           OldIrql;
    PLIST_ENTRY     pList;
    PARAPCONN       pArapConn;
	NTSTATUS		ReturnStatus=STATUS_SUCCESS;


    //
    // kill all connections and don't accept any more irps:
    // cancelling a select irp is a blasphemy!
    //

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    if (ArapSelectIrp == NULL)
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,("ArapCancelIrp: weird race condition!\n"));
        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
        return;
    }

    ASSERT (pIrp == ArapSelectIrp);

    ArapSelectIrp = NULL;

    if (ArapStackState == ARAP_STATE_ACTIVE)
    {
        ArapStackState = ARAP_STATE_ACTIVE_WAITING;
    }
    else if (ArapStackState == ARAP_STATE_INACTIVE)
    {
        ArapStackState = ARAP_STATE_INACTIVE_WAITING;
    }

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

    if (RasPortDesc == NULL)
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,("ArapCancelIrp: RasPortDesc is null!\n"));

        ARAP_COMPLETE_IRP(pIrp, 0, STATUS_CANCELLED, &ReturnStatus);
        return;
    }

    //
    // now, go kill all the arap connections
    //
    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pArapConn = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

        // if this connection is already disconnected, skip it
        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        if (pArapConn->State == MNP_DISCONNECTED)
        {
            pList = pArapConn->Linkage.Flink;
            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
            continue;
        }

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("ArapCancelIrp: killing ARAP connection %lx\n",pArapConn));

        ArapCleanup(pArapConn);

        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        pList = RasPortDesc->pd_ArapConnHead.Flink;
    }

    //
    // walk through the list to see if any connection(s) disconnected but is
    // waiting for a select irp to come down.  We know the select irp is never
    // going to come down, so pretend that dll has been told and deref the puppy
    // for telling the dll (which will probably free the connection)
    //

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pArapConn = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

        if (pArapConn->Flags & DISCONNECT_NO_IRP)
        {
            pArapConn->Flags &= ~DISCONNECT_NO_IRP;

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
            RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
    	        ("ArapCancelIrp: faking dll-completion for dead connection %lx\n",pArapConn));

            DerefArapConn(pArapConn);

            ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);
            pList = RasPortDesc->pd_ArapConnHead.Flink;
        }
        else
        {
            pList = pArapConn->Linkage.Flink;
            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        }
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    // finally, complete that cancelled irp!
    ARAP_COMPLETE_IRP(pIrp, 0, STATUS_CANCELLED, &ReturnStatus);

	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	    ("ArapCancelIrp: select irp cancelled and completed (%lx)\n",pIrp));
}



//***
//
// Function: ArapGetSelectIrp
//              Get the select irp, after some checks
//
// Parameters:  ppIrp  - pointer to irp pointer, contains select irp on return
//
// Return:      none
//
//***$
VOID
ArapGetSelectIrp(
    IN  PIRP    *ppIrp
)
{
    KIRQL   OldIrql;
    KIRQL   OldIrql2;


    *(ppIrp) = NULL;

	IoAcquireCancelSpinLock(&OldIrql);

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql2);

    if (ArapSelectIrp && (!ArapSelectIrp->Cancel))
    {
        ArapSelectIrp->CancelRoutine = NULL;
        *(ppIrp) = ArapSelectIrp;
        ArapSelectIrp = NULL;
    }

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql2);

	IoReleaseCancelSpinLock(OldIrql);
}



//***
//
// Function: FindArapConnByContx
//              Finds the corresponding connection element, given the dll's
//              context
//
// Parameters:  pDllContext - the dll context for the connection
//
// Return:      pointer to the corresponding connection element, if found
//
//***$

PARAPCONN
FindArapConnByContx(
    IN  PVOID   pDllContext
)
{
    PARAPCONN    pArapConn=NULL;
    PARAPCONN    pWalker;
    PLIST_ENTRY  pList;
    KIRQL        OldIrql;


    // ARAP not configured?
    if (!RasPortDesc)
    {
        return(NULL);
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    if (!(RasPortDesc->pd_Flags & PD_ACTIVE))
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("FindArapConnByContx: ArapPort not active, ignoring\n"));
			
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
        return(NULL);
    }

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    //
    // walk through all the Arap clients to see if we find ours
    //
    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pWalker = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        pList = pWalker->Linkage.Flink;

        if (pWalker->pDllContext == pDllContext)
        {
            pArapConn = pWalker;
            break;
        }
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    return( pArapConn );
}


//***
//
// Function: FindAndRefArapConnByAddr
//              Finds the corresponding connection element, given the network
//              address (of the remote client)
//
// Parameters:  destNode - network addr of the destination (remote client)
//              pdwFlags - pointer to a dword to return Flags field
//
// Return:      pointer to the corresponding connection element, if found
//
//***$

PARAPCONN
FindAndRefArapConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD              *pdwFlags
)
{
    PARAPCONN    pArapConn=NULL;
    PARAPCONN    pWalker;
    PLIST_ENTRY  pList;
    KIRQL        OldIrql;


    // ARAP not configured?
    if (!RasPortDesc)
    {
        return(NULL);
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    if (!(RasPortDesc->pd_Flags & PD_ACTIVE))
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("FindAndRefArapConnByAddr: ArapPort not active, ignoring\n"));
			
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
        return(NULL);
    }

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    //
    // walk through all the Arap clients to see if we find ours
    //
    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pWalker = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        pList = pWalker->Linkage.Flink;

        if (ATALK_NODES_EQUAL(&pWalker->NetAddr, &destNode))
        {
            ACQUIRE_SPIN_LOCK_DPC(&pWalker->SpinLock);

            //
            // we return the pArapConn only if the MNP connection is up and
            // and the ARAP connection is also up (or, if ARAP connection isn't
            // up yet then only if we are searching for a node)
            //
            //
            if ((pWalker->State == MNP_UP) &&
                ((pWalker->Flags & ARAP_CONNECTION_UP) ||
                  (pWalker->Flags & ARAP_FINDING_NODE)) )
            {
                pArapConn = pWalker;
                pArapConn->RefCount++;
                *pdwFlags = pWalker->Flags;
            }
            else if (pWalker->Flags & ARAP_CONNECTION_UP)
            {
				DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
				    ("FindAndRefArapConnByAddr: found pArapConn (%lx), but state=%ld,Flags=%lx\n",
						pWalker,pWalker->State,pWalker->Flags));
            }

            RELEASE_SPIN_LOCK_DPC(&pWalker->SpinLock);

            break;
        }
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    return(pArapConn);

}

//***
//
// Function: FindAndRefRasConnByAddr
//              Finds the corresponding connection element, given the network
//              address (of the remote client)
//
// Parameters:  destNode - network addr of the destination (remote client)
//              pdwFlags - pointer to a dword to return Flags field
//              pfThisIsPPP - pointer to a bool: is this PPP or ARAP connection?
//
// Return:      pointer to the corresponding connection element, if found
//
//***$

PVOID
FindAndRefRasConnByAddr(
    IN  ATALK_NODEADDR      destNode,
    OUT DWORD              *pdwFlags,
    OUT BOOLEAN            *pfThisIsPPP
)
{
    PVOID        pRasConn;


    // RAS not configured?
    if (!RasPortDesc)
    {
        return(NULL);
    }

    pRasConn = (PVOID)FindAndRefPPPConnByAddr(destNode,pdwFlags);

    if (pRasConn)
    {
        *pfThisIsPPP = TRUE;
        return(pRasConn);
    }

    pRasConn = FindAndRefArapConnByAddr(destNode, pdwFlags);

    *pfThisIsPPP = FALSE;

    return(pRasConn);

}


//***
//
// Function: ArapConnIsValid
//              Make sure that what we think is a connection is indeed a
//              connection (i.e., it's there in our list of connections)
//
// Parameters:  pArapConn -  the connection in question
//
// Return:      TRUE if the connection is valid, FALSE otherwise
//
//***$

BOOLEAN
ArapConnIsValid(
    IN  PARAPCONN  pArapConn
)
{
    PARAPCONN    pWalker;
    PLIST_ENTRY  pList;
    KIRQL        OldIrql;
    BOOLEAN      fIsValid=FALSE;


    // ARAP not configured?
    if (!RasPortDesc)
    {
        return(FALSE);
    }

    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    pList = RasPortDesc->pd_ArapConnHead.Flink;

    //
    // walk through all the Arap conns and see if we find the given conn
    //
    while (pList != &RasPortDesc->pd_ArapConnHead)
    {
        pWalker = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        pList = pWalker->Linkage.Flink;

        if (pWalker == pArapConn)
        {
            ACQUIRE_SPIN_LOCK_DPC(&pWalker->SpinLock);

            ASSERT(pWalker->Signature == ARAPCONN_SIGNATURE);

            if (!(pWalker->Flags & ARAP_GOING_AWAY))
            {
                // put a validation refcount
                pWalker->RefCount++;

                fIsValid = TRUE;
            }

            RELEASE_SPIN_LOCK_DPC(&pWalker->SpinLock);

            break;
        }
    }

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

    return( fIsValid );
}




//***
//
// Function: DerefMnpSendBuf
//              This routine dereferences the MNP send.  When the refcount
//              goes to zero, we free it
//
// Parameters:  pMnpSendBuf - the MNP send to be dereferenced
//
// Return:      Nothing
//
//***$

VOID
DerefMnpSendBuf(
    IN PMNPSENDBUF   pMnpSendBuf,
    IN BOOLEAN       fNdisSendComplete
)
{
    KIRQL           OldIrql;
    PARAPCONN       pArapConn;
    BOOLEAN         fFreeIt=FALSE;


    DBG_ARAP_CHECK_PAGED_CODE();

    pArapConn = pMnpSendBuf->pArapConn;

    ARAPTRACE(("Entered DerefMnpSendBuf (%lx %lx refcount=%d ComplFn=%lx)\n",
        pArapConn,pMnpSendBuf,pMnpSendBuf->RefCount,pMnpSendBuf->ComplRoutine));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    //
    // catch weird things like freeing twice
    // (we subtract 0x100 in completion routine, to mark that it has run)
    //
    ASSERT((pMnpSendBuf->Signature == MNPSMSENDBUF_SIGNATURE) ||
           (pMnpSendBuf->Signature == MNPSMSENDBUF_SIGNATURE-0x100) ||
           (pMnpSendBuf->Signature == MNPLGSENDBUF_SIGNATURE) ||
           (pMnpSendBuf->Signature == MNPLGSENDBUF_SIGNATURE-0x100));

    ASSERT(pMnpSendBuf->RefCount > 0);

    // Mark that Ndis completed our send
    if (fNdisSendComplete)
    {
        pMnpSendBuf->Flags = 0;
    }

    pMnpSendBuf->RefCount--;

    if (pMnpSendBuf->RefCount == 0)
    {
        fFreeIt = TRUE;
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    if (!fFreeIt)
    {
        return;
    }

    // make sure it's not still sitting on retransmit queue
    ASSERT(IsListEmpty(&pMnpSendBuf->Linkage));

#if DBG
    pMnpSendBuf->Signature--;
#endif

    ArapNdisFreeBuf(pMnpSendBuf);

    // remove that MNPSend refcount
    DerefArapConn(pArapConn);
}



//***
//
// Function: DerefArapConn
//              Decrements the refcount of the connection element by 1.  If the
//              refcount goes to 0, releases network addr and frees it
//
// Parameters:  pArapConn - connection element in question
//
// Return:      none
//
//***$

VOID
DerefArapConn(
	IN	PARAPCONN    pArapConn
)
{

    KIRQL       OldIrql;
    BOOLEAN     fKill = FALSE;


    DBG_ARAP_CHECK_PAGED_CODE();

    ARAPTRACE(("Entered DerefArapConn (%lx refcount=%d)\n",pArapConn,pArapConn->RefCount));

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

    ASSERT(pArapConn->RefCount > 0);

    pArapConn->RefCount--;

    if (pArapConn->RefCount == 0)
    {
        fKill = TRUE;
        pArapConn->Flags |= ARAP_GOING_AWAY;
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    if (!fKill)
    {
        return;
    }

    ASSERT(pArapConn->pRecvIoctlIrp == NULL);

    ASSERT(pArapConn->pIoctlIrp == NULL);

    ASSERT(IsListEmpty(&pArapConn->HighPriSendQ));

    ASSERT(IsListEmpty(&pArapConn->MedPriSendQ));

    ASSERT(IsListEmpty(&pArapConn->LowPriSendQ));

    ASSERT(IsListEmpty(&pArapConn->SendAckedQ));

    ASSERT(IsListEmpty(&pArapConn->ReceiveQ));

    ASSERT(IsListEmpty(&pArapConn->ArapDataQ));

    ASSERT(IsListEmpty(&pArapConn->RetransmitQ));

    /* ASSERT(pArapConn->SendsPending == 0); */

    ASSERT(!(pArapConn->Flags & RETRANSMIT_TIMER_ON));

	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("DerefArapConn: refcount 0, freeing %lx\n", pArapConn));


    ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

    RemoveEntryList(&pArapConn->Linkage);

    RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

#if ARAP_STATIC_MODE
    // "release" the network addr used by this client
    ArapReleaseAddr(pArapConn);
#endif //ARAP_STATIC_MODE

    // free that v42bis buffer
    if (pArapConn->pV42bis)
    {
        // free the decode-side overflow buffer
        AtalkFreeMemory(pArapConn->pV42bis->decode.OverFlowBuf);

        AtalkFreeMemory(pArapConn->pV42bis);
    }

#if DBG

    ArapDbgDumpMnpHist(pArapConn);

    // if we had allocated a sniff buffer, free it
    if (pArapConn->pDbgTraceBuffer)
    {
        AtalkFreeMemory(pArapConn->pDbgTraceBuffer);
    }

    //
    // let's catch if someone tries to access this after a free
    //
    RtlFillMemory(pArapConn,sizeof(ARAPCONN),0x7);
    pArapConn->Signature = 0xDEADBEEF;
#endif

    // and finally, we say good bye
    AtalkFreeMemory(pArapConn);


    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);
    ArapConnections--;
    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);

#if ARAP_STATIC_MODE
    // This will delete a route if this is the last connection that vanished
    ArapDeleteArapRoute();
#endif //ARAP_STATIC_MODE

    // connection is completely gone: see if arap pages can be unlocked
    AtalkUnlockArapIfNecessary();

}


//***
//
// Function: ArapCleanup
//              Once the client goes into the disconnecting state (as a result
//              of either local side or remote side initiating the disconnect)
//              this routine gets called.  This does all the cleanup, such as
//              completing all unacked sends, uncompleted receives, stopping
//              retransmit timers, completing any irp in progress.
//
// Parameters:  pArapConn - connection element being cleaned up
//
// Return:      none
//
//***$

VOID
ArapCleanup(
    IN PARAPCONN    pArapConn
)
{

    KIRQL                   OldIrql;
    PIRP                    pIrp;
    PIRP                    pRcvIrp;
    PIRP                    pDiscIrp;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    PARAP_SEND_RECV_INFO    pDiscSndRcvInfo;
    PLIST_ENTRY             pSendHighList;
    PLIST_ENTRY             pSendMedList;
    PLIST_ENTRY             pSendLowList;
    PLIST_ENTRY             pSendAckList;
    PLIST_ENTRY             pRcvList;
    PLIST_ENTRY             pArapList;
    PLIST_ENTRY             pReXmitList;
    PLIST_ENTRY             pMiscPktList;
    PMNPSENDBUF             pMnpSendBuf;
    PARAPBUF                pArapBuf;
    DWORD                   StatusCode;
    BOOLEAN                 fStopTimer=FALSE;
    BOOLEAN                 fArapConnUp=FALSE;
    DWORD                   dwBytesToDll;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;



    DBG_ARAP_CHECK_PAGED_CODE();

    // first thing, see if we should send out a disconnect message
    // we make this check without holding the lock because ArapSendLDPacket does
    // the right thing.  If, due to an extremely tiny window, we don't call
    // ArapSendLDPacket, no big deal!
    if (pArapConn->State < MNP_LDISCONNECTING)
    {
        ArapSendLDPacket(pArapConn, 0xFF);
    }

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

    // if we have already run the cleanup, nothing to do!
    if (pArapConn->State == MNP_DISCONNECTED)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapCleanup: cleanup already done once on (%lx)\n",pArapConn));

        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return;
    }

    pSendHighList = pArapConn->HighPriSendQ.Flink;
    InitializeListHead(&pArapConn->HighPriSendQ);

    pSendMedList = pArapConn->MedPriSendQ.Flink;
    InitializeListHead(&pArapConn->MedPriSendQ);

    pSendLowList = pArapConn->LowPriSendQ.Flink;
    InitializeListHead(&pArapConn->LowPriSendQ);

    pSendAckList = pArapConn->SendAckedQ.Flink;
    InitializeListHead(&pArapConn->SendAckedQ);

    pRcvList = pArapConn->ReceiveQ.Flink;
    InitializeListHead(&pArapConn->ReceiveQ);

    pArapList = pArapConn->ArapDataQ.Flink;
    InitializeListHead(&pArapConn->ArapDataQ);

    pReXmitList = pArapConn->RetransmitQ.Flink;
    InitializeListHead(&pArapConn->RetransmitQ);

    pMiscPktList = pArapConn->MiscPktsQ.Flink;
    InitializeListHead(&pArapConn->MiscPktsQ);

    pIrp = pArapConn->pIoctlIrp;
    pArapConn->pIoctlIrp = NULL;

    pRcvIrp = pArapConn->pRecvIoctlIrp;
    pArapConn->pRecvIoctlIrp = NULL;

    if (pArapConn->State == MNP_RDISCONNECTING)
    {
        pArapConn->Flags |= ARAP_REMOTE_DISCONN;
        StatusCode = ARAPERR_RDISCONNECT_COMPLETE;
    }
    else
    {
        StatusCode = ARAPERR_LDISCONNECT_COMPLETE;
    }

    pArapConn->State = MNP_DISCONNECTED;
    pArapConn->Flags &= ~ARAP_DATA_WAITING;

    // if the timer is running, stop it
    if (pArapConn->Flags & RETRANSMIT_TIMER_ON)
    {
        fStopTimer = TRUE;
        pArapConn->Flags &= ~RETRANSMIT_TIMER_ON;

        // creation refcount and timer refcount better be on here
        ASSERT(pArapConn->RefCount >= 2);
    }

    fArapConnUp = FALSE;

    // was ARAP connection up?
    if (pArapConn->Flags & ARAP_CONNECTION_UP)
    {
        fArapConnUp = TRUE;
    }

#if DBG
    //
    // if we are sniffing, mark the sniff to indicate the end (so dll knows it
    // got all the sniff info)
    //
    if (pArapConn->pDbgCurrPtr)
    {
        PSNIFF_INFO     pSniff;

        pSniff = (PSNIFF_INFO)(pArapConn->pDbgCurrPtr);
        pSniff->Signature = ARAP_SNIFF_SIGNATURE;
        pSniff->TimeStamp = (DWORD)AtalkGetCurrentTick();
        pSniff->Location = 0xfedc;
        pSniff->FrameLen = 0;
        pArapConn->SniffedBytes += sizeof(SNIFF_INFO);
        pArapConn->pDbgCurrPtr += sizeof(SNIFF_INFO);
    }
#endif

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    if (fStopTimer)
    {
        if (AtalkTimerCancelEvent(&pArapConn->RetryTimer, NULL))
        {
            // remove the timer refcount
            DerefArapConn(pArapConn);
        }
    }

    //
    // call completion routine for all the sends that have been acked
    //
    while (pSendAckList != &pArapConn->SendAckedQ)
    {
        pMnpSendBuf = CONTAINING_RECORD(pSendAckList,MNPSENDBUF,Linkage);

        pSendAckList = pSendAckList->Flink;

#if DBG
        InitializeListHead(&pMnpSendBuf->Linkage);
#endif
        // call the completion routine which will do cleanup for this buffer
        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_NO_ERROR);
    }

    // whatever is on the ReceiveQ, try and send it off to the destination
    // since this data came before the disconnect came in

    while (1)
    {
        if ((pArapBuf = ArapExtractAtalkSRP(pArapConn)) == NULL)
        {
            // no more data left (or no complete SRP): done here
            break;
        }

        // was ARAP connection up?  route only if it's up, otherwise drop it!
        if (fArapConnUp)
        {
            ArapRoutePacketFromWan( pArapConn, pArapBuf );
        }

        // we received AppleTalk data but connection wasn't up!  Drop pkt
        else
        {
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	            ("ArapCleanup: (%lx) AT data, but conn not up\n",pArapConn));
        }

#if DBG
        //
        // yeah, there is no spinlock: given our state, no one else will be
        // touching this field.  Besides, this is debug-only!
        //
        pArapConn->RecvsPending -= pArapBuf->DataSize;
#endif

        // done with this buffer
        ARAP_FREE_RCVBUF(pArapBuf);
    }

    //
    // if there are any buffers left on the ReceiveQ, they are basically
    // incomplete SRP's: throw them away
    //
    while (pRcvList != &pArapConn->ReceiveQ)
    {
	    pArapBuf = CONTAINING_RECORD(pRcvList, ARAPBUF, Linkage);

        pRcvList = pRcvList->Flink;

#if DBG
        // same deal again with spinlock again...
        pArapConn->RecvsPending -= pArapBuf->DataSize;
#endif

		ARAP_FREE_RCVBUF(pArapBuf);
    }

    //
    // free up all the packets on ArapDataQ: these are not going to be of
    // any use, whether or not the connection was up, so best just to throw
    // them away (why complicate life?)
    //
    while (pArapList != &pArapConn->ArapDataQ)
    {
	    pArapBuf = CONTAINING_RECORD(pArapList, ARAPBUF, Linkage);

        pArapList = pArapList->Flink;

#if DBG
        // same deal again with spinlock again...
        pArapConn->RecvsPending -= pArapBuf->DataSize;
#endif

		ARAP_FREE_RCVBUF(pArapBuf);
    }

    //
    // free up all the packets on the MiscPktsQ
    //
    while (pMiscPktList != &pArapConn->MiscPktsQ)
    {
	    pArapBuf = CONTAINING_RECORD(pMiscPktList, ARAPBUF, Linkage);

        pMiscPktList = pMiscPktList->Flink;

		ARAP_FREE_RCVBUF(pArapBuf);
    }

    //
    // call completion routine for all the sends that were waiting to be sent
    // on the high priority Q
    //
    while (pSendHighList != &pArapConn->HighPriSendQ)
    {
        pMnpSendBuf = CONTAINING_RECORD(pSendHighList,MNPSENDBUF,Linkage);

        pSendHighList = pSendHighList->Flink;

#if DBG
        InitializeListHead(&pMnpSendBuf->Linkage);
#endif
        // call the completion routine which will do cleanup for this buffer
        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_DISCONNECT_IN_PROGRESS);
    }

    //
    // call completion routine for all the sends that were waiting to be sent
    // on the Med priority Q
    //
    while (pSendMedList != &pArapConn->MedPriSendQ)
    {
        pMnpSendBuf = CONTAINING_RECORD(pSendMedList,MNPSENDBUF,Linkage);

        pSendMedList = pSendMedList->Flink;

#if DBG
        InitializeListHead(&pMnpSendBuf->Linkage);
#endif
        // call the completion routine which will do cleanup for this buffer
        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_DISCONNECT_IN_PROGRESS);
    }

    //
    // call completion routine for all the sends that were waiting to be sent
    // on the Low priority Q
    //
    while (pSendLowList != &pArapConn->LowPriSendQ)
    {
        pMnpSendBuf = CONTAINING_RECORD(pSendLowList,MNPSENDBUF,Linkage);

        pSendLowList = pSendLowList->Flink;

#if DBG
        InitializeListHead(&pMnpSendBuf->Linkage);
#endif
        // call the completion routine which will do cleanup for this buffer
        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_DISCONNECT_IN_PROGRESS);
    }



    //
    // free up all the packets on RetransmitQ that were waiting to be acked
    //
    while (pReXmitList != &pArapConn->RetransmitQ)
    {
	    pMnpSendBuf = CONTAINING_RECORD(pReXmitList, MNPSENDBUF, Linkage);

        pReXmitList = pReXmitList->Flink;

#if DBG
        InitializeListHead(&pMnpSendBuf->Linkage);
#endif
        // call the completion routine which will do cleanup for this buffer
        (pMnpSendBuf->ComplRoutine)(pMnpSendBuf,ARAPERR_DISCONNECT_IN_PROGRESS);
    }


    // if there was an irp in progress, complete it first!
    if (pIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;

        pSndRcvInfo->StatusCode = ARAPERR_DISCONNECT_IN_PROGRESS;

        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS,
							&ReturnStatus);
    }

    // if there was an irp in progress, complete it first!
    if (pRcvIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pRcvIrp->AssociatedIrp.SystemBuffer;

        pSndRcvInfo->StatusCode = ARAPERR_DISCONNECT_IN_PROGRESS;

        ARAP_COMPLETE_IRP(pRcvIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS, 
							&ReturnStatus);
    }

    // if we have any sniff info, give it to dll.
    ARAP_DUMP_DBG_TRACE(pArapConn);

    //
    // now, try telling the dll that the connection went away.  (We can do this
    // only using a "select" irp)
    //
    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    ArapGetSelectIrp(&pDiscIrp);

    // no select irp?  just mark that fact, so on next select we'll tell dll
    if (!pDiscIrp)
    {
        pArapConn->Flags |= DISCONNECT_NO_IRP;
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    //
    // if we did find select irp, go ahead and tell the dll
    //
    if (pDiscIrp)
    {
        dwBytesToDll = 0;

#if DBG
        //
        // if we have some sniff info that we couldn't deliver earlier through
        // the sniff irp, then give them through this irp: it's going back
        // "empty" anyway!
        //
        if (pArapConn->pDbgTraceBuffer && pArapConn->SniffedBytes > 0)
        {
            dwBytesToDll = ArapFillIrpWithSniffInfo(pArapConn,pDiscIrp);
        }
#endif

        pDiscSndRcvInfo = (PARAP_SEND_RECV_INFO)pDiscIrp->AssociatedIrp.SystemBuffer;

        pDiscSndRcvInfo->pDllContext = pArapConn->pDllContext;
        pDiscSndRcvInfo->AtalkContext = ARAP_INVALID_CONTEXT;
        pDiscSndRcvInfo->DataLen = dwBytesToDll;
        pDiscSndRcvInfo->StatusCode = StatusCode;

        dwBytesToDll += sizeof(ARAP_SEND_RECV_INFO);

        ARAP_COMPLETE_IRP(pDiscIrp, dwBytesToDll, STATUS_SUCCESS,
							&ReturnStatus);

        // we told dll: remove this link
        pArapConn->pDllContext = NULL;

        // we told the dll, remove the connect refcount
        DerefArapConn(pArapConn);

	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapCleanup: told dll (%lx refcount=%d)\n",pArapConn,pArapConn->RefCount));
    }
    else
    {
		DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		    ("ArapCleanup: no select irp, dll doesn't yet know (%lx) died\n", pArapConn));
    }

    // remove the creation refcount
    DerefArapConn(pArapConn);
}



//***
//
// Function: PrepareConnectionResponse
//              This routine parses the connect request that is first sent by
//              the remote client and forms a connection response (LR frame)
//              based on the options negotiated.
//              This routine basically does the MNP negotiation.
//
// Parameters:  pArapConn - connection element being cleaned up
//              pReq - buffer containting client's original connect request
//              pFrame - buffer in which we put the response
//              BytesWritten - how big is the connection response
//
// Return:      result of the operation (ARAPERR_....)
//
//***$

DWORD
PrepareConnectionResponse(
    IN  PARAPCONN  pArapConn,
    IN  PBYTE      pReq,              // buffer with client's request
    IN  DWORD      ReqLen,            // how big is the request
    OUT PBYTE      pFrame,            // buffer with our response to the client
    OUT USHORT   * pMnpLen
)
{
    PBYTE       pReqEnd;
    PBYTE       pFrameStart;
    BYTE        VarLen;
    KIRQL       OldIrql;
    BYTE        NumLTFrames=0;
    USHORT      MaxInfoLen=0;
    USHORT      FrameLen;
    BYTE        Mandatory[5];
    BOOLEAN     fOptimized=FALSE;
    BOOLEAN     fMaxLen256=FALSE;
    BOOLEAN     fV42Bis=FALSE;
    BOOLEAN     fArapV20=TRUE;
    DWORD       dwReqToSkip;
    DWORD       dwFrameToSkip;
    BYTE        JunkBuffer[MNP_MINPKT_SIZE+1];
    DWORD       i;
    BOOLEAN     fNonStd=FALSE;


    DBG_ARAP_CHECK_PAGED_CODE();

#if DBG

    //
    // validate our assumption that all the clients always send out the same
    // LR request packet
    //
    for (i=0; i<sizeof(ArapDbgLRPacket); i++ )
    {
        if (pReq[3+i] != ArapDbgLRPacket[i])
        {
            fNonStd = TRUE;
        }
    }

    if (fNonStd)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("Arap Prepare..Response: non-standard LR-request packet\n"));
        DbgPrint("  Std : ");
        for (i=0; i<sizeof(ArapDbgLRPacket); i++)
        {
            DbgPrint("%2X ",ArapDbgLRPacket[i]);
        }
        DbgPrint("\n");
        DbgPrint("  This: ");
        for (i=0; i<sizeof(ArapDbgLRPacket); i++)
        {
            DbgPrint("%2X ",pReq[3+i]);
        }
        DbgPrint("\n");
    }
#endif


    for (i=0; i<5; i++)
    {
        Mandatory[i] = 0;
    }


    //
    // in case of callback, we get an LR response from the dial-in client. When
    // that happens, we still want to run through this routine to make sure all
    // parameters are legal, etc., and also to "configure" the connection based
    // on the parms negotiated.  In that case, however, there is no output frame
    // needed.  So, we just write the output frame to junkbuffer
    // which is obviously never used.
    //
    if (pFrame == NULL)
    {
        pFrame = &JunkBuffer[0];
    }

    pFrameStart = pFrame;

    //
    // see if this is ARAP v2.0 or v1.0 connection: we know the frame is good,
    // so just look at the first byte
    //
    if (*pReq == MNP_SYN)
    {
        fArapV20 = FALSE;
    }

    // now copy those three start flag bytes
    *pFrame++ = *pReq++;
    *pFrame++ = *pReq++;
    *pFrame++ = *pReq++;

    // first byte (after the start flag, that is) is the length byte
    FrameLen = *pReq;

    if ((FrameLen > ReqLen) || (FrameLen > MNP_MINPKT_SIZE))
    {
        ASSERT(0);
        return(ARAPERR_BAD_FORMAT);
    }

    pReqEnd = pReq + FrameLen;

    pReq += 2;                   // skip over length ind. and type ind.

    // Constant parameter 1 must have a value of 2
    if ((*pReq++) != MNP_LR_CONST1 )
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("Error: MNP_LR_CONST1 missing in conn req %lx:\n",pArapConn));

        return(ARAPERR_BAD_FORMAT);
    }

    // we build the return frame as we parse the incoming frame: we are supposed
    // to return only those options that we both receive and understand.
    //

    pFrame++;      // we'll put the length byte at the end
    *pFrame++ = MNP_LR;
    *pFrame++ = MNP_LR_CONST1;

    // parse all the "variable" parms until we reach end of the frame
    //
    while (pReq < pReqEnd)
    {
        switch (*pReq++)
        {
            //
            // nothing to do here, other than verify it's valid
            //
            case MNP_LR_CONST2:

                VarLen = *pReq++;
                if ( (VarLen == 6) &&
                     (*(pReq  ) == 1) && (*(pReq+1) == 0) &&
                     (*(pReq+2) == 0) && (*(pReq+3) == 0) &&
                     (*(pReq+4) == 0) && (*(pReq+5) == 255) )
                {
                    *pFrame++ = MNP_LR_CONST2;
                    *pFrame++ = VarLen;
                    RtlCopyMemory(pFrame, pReq, VarLen);
                    pFrame += VarLen;
                    pReq += VarLen;
                }
                else
                {
                    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("Error: bad MNP_LR_CONST2 in conn req %lx:\n",pArapConn));
                    return(ARAPERR_BAD_FORMAT);
                }

                Mandatory[0] = 1;

                break;

            //
            // octet-oriented or bit-oriented framing
            //
            case MNP_LR_FRAMING:

                pReq++;      // skip over length byte

                //
                // we only support octet-oriented framing mode
                //
                if (*pReq++ < MNP_FRMMODE_OCTET)
                {
                    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("Error: (%lx) unsupported framing mode %d requested:\n",
                        pArapConn,*(pReq-1)));

                    ASSERT(0);
                    return(ARAPERR_BAD_FORMAT);
                }

                *pFrame++ = MNP_LR_FRAMING;
                *pFrame++ = 1;
                *pFrame++ = MNP_FRMMODE_OCTET;

                Mandatory[1] = 1;
                break;

            //
            // Max. number of outstanding LT frames, k
            //
            case MNP_LR_NUMLTFRMS:

                pReq++;      // skip over length byte
                NumLTFrames = *pReq++;

                if (NumLTFrames > ArapGlobs.MaxLTFrames)
                {
                    NumLTFrames = ArapGlobs.MaxLTFrames;
                }

                *pFrame++ = MNP_LR_NUMLTFRMS;
                *pFrame++ = 1;
                *pFrame++ = NumLTFrames;

                Mandatory[2] = 1;
                break;

            //
            // Max. information field length, N401
            //
            case MNP_LR_INFOLEN:

                pReq++;      // skip over length byte
                MaxInfoLen = *((USHORT *)pReq);

                ASSERT(MaxInfoLen <= 256);

                *pFrame++ = MNP_LR_INFOLEN;
                *pFrame++ = 2;

                // we are just copying whatever client gave
                *pFrame++ = *pReq++;
                *pFrame++ = *pReq++;

                Mandatory[3] = 1;
                break;

            //
            // data optimization info
            //
            case MNP_LR_DATAOPT:

                pReq++;      // skip over length byte

                if ((*pReq) & 0x1)
                {
                    fMaxLen256 = TRUE;
                }

                if ((*pReq) & 0x2)
                {
                    fOptimized = TRUE;
                }

                *pFrame++ = MNP_LR_DATAOPT;
                *pFrame++ = 1;
                *pFrame++ = *pReq++;

                Mandatory[4] = 1;

                break;

            //
            // v42 parameter negotiation
            //
            case MNP_LR_V42BIS:

                fV42Bis = v42bisInit( pArapConn,
                                      pReq,
                                      &dwReqToSkip,
                                      pFrame,
                                      &dwFrameToSkip );

                pReq += dwReqToSkip;
                pFrame += dwFrameToSkip;

                break;

            //
            // what the heck is this option?  just skip over it!
            //
            default:

                DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("Prepare..Response (%lx): unknown option %lx len=%ld type=%ld\n",
                    pArapConn, *(pReq-1), *pReq, *(pReq+1)));

                VarLen = *pReq++;
                pReq += VarLen;
                break;
        }
    }

    //
    // make sure we got all the mandatory parameters
    //
    for (i=0; i<5; i++)
    {
        if (Mandatory[i] == 0)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("PrepareConnectionResponse: parm %d missing (%lx):\n",i,pArapConn));

            return(ARAPERR_BAD_FORMAT);
        }
    }

    // copy the stop flag
    *pFrame++ = (fArapV20)? MNP_ESC : MNP_DLE;
    *pFrame++ = MNP_ETX;

    // store all the negotiated info
    pArapConn->BlockId = (fMaxLen256)? BLKID_MNP_LGSENDBUF : BLKID_MNP_SMSENDBUF;

    if (fOptimized)
    {
        pArapConn->Flags |= MNP_OPTIMIZED_DATA;
    }

    if (fV42Bis)
    {
        pArapConn->Flags |= MNP_V42BIS_NEGOTIATED;
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("Prepare..Response: WARNING!! v42bis NOT negotiated on (%lx):\n",pArapConn));
    }

    if (fArapV20)
    {
        pArapConn->Flags |= ARAP_V20_CONNECTION;

        // save the Syn,Dle,Stx,Etx bytes depeding on what connection this is
        pArapConn->MnpState.SynByte = MNP_SOH;
        pArapConn->MnpState.DleByte = MNP_ESC;
        pArapConn->MnpState.StxByte = MNP_STX;
        pArapConn->MnpState.EtxByte = MNP_ETX;
    }
    else
    {
        pArapConn->MnpState.SynByte = MNP_SYN;
        pArapConn->MnpState.DleByte = MNP_DLE;
        pArapConn->MnpState.StxByte = MNP_STX;
        pArapConn->MnpState.EtxByte = MNP_ETX;
    }

    //
    // if we are doing callback, we should act like the client
    //
    if ((pArapConn->Flags & ARAP_CALLBACK_MODE) && fArapV20)
    {
        pArapConn->MnpState.LTByte = MNP_LT_V20CLIENT;
    }
    else
    {
        pArapConn->MnpState.LTByte = MNP_LT;
    }

    pArapConn->MnpState.WindowSize = NumLTFrames;

    pArapConn->MnpState.UnAckedLimit = (NumLTFrames/2);

    if (pArapConn->MnpState.UnAckedLimit == 0)
    {
        pArapConn->MnpState.UnAckedLimit = 1;
    }

    pArapConn->MnpState.MaxPktSize = MaxInfoLen;
    pArapConn->MnpState.SendCredit = NumLTFrames;

    // how big is the mnp frame
    if (pMnpLen)
    {
        *pMnpLen = (USHORT)(pFrame - pFrameStart);

        // write the length byte
        // (length byte is after the 3 start flag bytes: that's why (pFrameStart+3))
        // (and exclude (3 start + 2 stop + 1 len bytes):that's why (*pMnpLen) - 6)

        *(pFrameStart+3) = (*pMnpLen) - 6;

    }

    return( ARAPERR_NO_ERROR );
}




//***
//
// Function: ArapExtractAtalkSRP
//              This routine extracts one complete SRP out of the receive
//              buffer queue.  One SRP could be split up into multiple receive
//              buffers, or one receive buffer could contain several SRPs: it
//              depends on how the client sent the data.
//
// Parameters:  pArapConn - connection element in question
//
// Return:      Pointer to a buffer containing one complete SRP
//              NULL if there is no data, or if a complete SRP hasn't yet arrived
//
//***$

PARAPBUF
ArapExtractAtalkSRP(
    IN PARAPCONN    pArapConn
)
{
    KIRQL                   OldIrql;
    USHORT                  BytesInThisBuffer;
    USHORT                  SrpLen;
    USHORT                  SrpModLen;
    PARAPBUF                pArapBuf=NULL;
    PARAPBUF                pRecvBufNew=NULL;
    PARAPBUF                pReturnBuf=NULL;
    PARAPBUF                pNextRecvBuf=NULL;
    PLIST_ENTRY             pRcvList;
    DWORD                   BytesOnQ;
    USHORT                  BytesRemaining;
    USHORT                  BytesToCopy;
    BYTE                    DGroupByte;
    BYTE                    TmpArray[4];
    USHORT                  i;


    DBG_ARAP_CHECK_PAGED_CODE();

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);

ArapSRP_TryNext:

    // list is empty?
	if ((pRcvList = pArapConn->ReceiveQ.Flink) == &pArapConn->ReceiveQ)
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
        return(NULL);
    }

    pArapBuf = CONTAINING_RECORD(pRcvList, ARAPBUF, Linkage);

    // Debug only: make sure first few bytes are right...
    ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);

	BytesInThisBuffer = pArapBuf->DataSize;

    //
    // if datasize goes to 0, we free the buffer right away.  Also, at indicate time
    // if datasize is 0, we never insert a buffer: so this had better be non-zero!
    //
	ASSERT(BytesInThisBuffer > 0);

    //
    // most common case: we at least have the 2 length bytes in the first buffer
    //
    if (BytesInThisBuffer >= sizeof(USHORT))
    {
        // get the SRP length from the length field (network to host order)
        GETSHORT2SHORT(&SrpLen, pArapBuf->CurrentBuffer);
    }
    //
    // alright, last byte of the first buffer is the 1st length byte.
    // pick up the 2nd length byte from the next buffer
    //
    else
    {
        ARAP_BYTES_ON_RECVQ(pArapConn, &BytesOnQ);

        if (BytesOnQ < sizeof(USHORT))
        {
            RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);
            return(NULL);
        }

        pRcvList = pArapBuf->Linkage.Flink;

        ASSERT(pRcvList != &pArapConn->ReceiveQ);

        pNextRecvBuf = CONTAINING_RECORD(pRcvList, ARAPBUF, Linkage);

        TmpArray[0] = pArapBuf->CurrentBuffer[0];
        TmpArray[1] = pNextRecvBuf->CurrentBuffer[0];

        GETSHORT2SHORT(&SrpLen, &TmpArray[0]);
    }

    if (SrpLen > ARAP_MAXPKT_SIZE_INCOMING)
    {
        RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	        ("ArapExtractSRP: (%lx) too big a packet (%ld)\n",pArapConn,SrpLen));

        // can't recover! kill connection here
        ArapCleanup(pArapConn);

        return(NULL);
    }

    // add the 2 len bytes.  We will always deal with an SRP along
    // with these 2 len bytes
    SrpModLen = SrpLen + sizeof(USHORT);

    //
    // let's deal with the simplest case first
    // (the whole pkt is just one complete SRP):
    //
    if (SrpModLen == BytesInThisBuffer)
    {
        RemoveEntryList(&pArapBuf->Linkage);

        // length of the SRP pkt, plus the 2 length bytes
        pArapBuf->DataSize = SrpModLen;

        pReturnBuf = pArapBuf;
    }

    //
    // The packet contains more than one SRP
    // allocate a new buffer and copy the SRP, leaving remaining bytes behind
    //
    else if (SrpModLen < BytesInThisBuffer)
    {
        ARAP_GET_RIGHTSIZE_RCVBUF(SrpModLen, &pRecvBufNew);
        if (pRecvBufNew == NULL)
        {
    	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	            ("ArapExtractSRP: (%lx) mem alloc failed\n",pArapConn));

            return(NULL);
        }

        RtlCopyMemory( &pRecvBufNew->Buffer[0],
                       pArapBuf->CurrentBuffer,
                       SrpModLen);

        pRecvBufNew->DataSize = SrpModLen;

        // changes to reflect the bytes we 'removed' in the original buffer
        pArapBuf->DataSize -= SrpModLen;
        pArapBuf->CurrentBuffer = pArapBuf->CurrentBuffer + SrpModLen;

        pReturnBuf = pRecvBufNew;

        // Debug only: make sure what we're leaving behind is good...
        ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);
    }

    //
    // packet contains a partial SRP (this is a rare case, but possible)
    // we must traverse the queue until we "collect" the whole SRP.  If we still
    // can't get one complete SRP, it's not arrived yet!
    //
    else    // if (SrpModLen > BytesInThisBuffer)
    {
        ARAP_BYTES_ON_RECVQ(pArapConn, &BytesOnQ);

        //
        // if we have a full srp (split up across multiple buffers on the Q)
        //
        if (BytesOnQ >= SrpModLen)
        {

            //
            // allocate a new buffer to hold this fragmented SRP
            //
            ARAP_GET_RIGHTSIZE_RCVBUF(SrpModLen, &pRecvBufNew);

            if (pRecvBufNew == NULL)
            {
    	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
	                ("ArapExtractSRP: (%lx) mem alloc failed at II\n",pArapConn));

                return(NULL);
            }

            pRecvBufNew->DataSize = SrpModLen;

            pNextRecvBuf = pArapBuf;

            BytesRemaining = SrpModLen;

            while (BytesRemaining)
            {
                BytesToCopy = (BytesRemaining > pNextRecvBuf->DataSize) ?
                                pNextRecvBuf->DataSize : BytesRemaining;

                RtlCopyMemory( pRecvBufNew->CurrentBuffer,
                               pNextRecvBuf->CurrentBuffer,
                               BytesToCopy );

                pRecvBufNew->CurrentBuffer += BytesToCopy;

                pNextRecvBuf->CurrentBuffer += BytesToCopy;

                pNextRecvBuf->DataSize -= BytesToCopy;

                BytesRemaining -= BytesToCopy;

                pRcvList = pNextRecvBuf->Linkage.Flink;

                // are we done with this buffer?  if so, unlink it and free it
                if (pNextRecvBuf->DataSize == 0)
                {
                    RemoveEntryList(&pNextRecvBuf->Linkage);

                    ARAP_FREE_RCVBUF(pNextRecvBuf);
                }
                else
                {
                    // didn't free up the buffer? we had better be done!
                    ASSERT(BytesRemaining == 0);

                    // Debug only: make sure what we're leaving behind is good...
                    ARAP_CHECK_RCVQ_INTEGRITY(pArapConn);
                }

                // there should be more data on the queue or we should be done
                ASSERT(pRcvList != &pArapConn->ReceiveQ || BytesRemaining == 0);

                pNextRecvBuf = CONTAINING_RECORD(pRcvList, ARAPBUF, Linkage);
            }

            pRecvBufNew->CurrentBuffer = &pRecvBufNew->Buffer[0];

            pReturnBuf = pRecvBufNew;
        }
        else
        {
            pReturnBuf = NULL;
        }
    }

    if (pReturnBuf)
    {
        DGroupByte = pReturnBuf->CurrentBuffer[ARAP_DGROUP_OFFSET];

#if DBG

        ARAP_DBG_TRACE(pArapConn,21105,pReturnBuf,0,0,0);

        GETSHORT2SHORT(&SrpLen, pReturnBuf->CurrentBuffer);

        ASSERT(pReturnBuf->DataSize == SrpLen+2);
        ASSERT(SrpLen <= ARAP_MAXPKT_SIZE_INCOMING);

        if (DGroupByte != 0x10 && DGroupByte != 0x50 &&
           (pArapConn->Flags & ARAP_CONNECTION_UP))
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("ArapExtract: DGrpByte %x\n",DGroupByte));
            ASSERT(0);
        }

        //
        // see if we have an arap packet embedded inside another arap packet
        // This is an expensive way, but it's debug only: who cares!
        //
        for (i=6; i<(pReturnBuf->DataSize-6); i++)
        {
            if ((pReturnBuf->CurrentBuffer[i] == 0x10) ||
                (pReturnBuf->CurrentBuffer[i] == 0x50))
            {
                if (pReturnBuf->CurrentBuffer[i+1] == 0)
                {
                    if (pReturnBuf->CurrentBuffer[i+2] == 0)
                    {
                        if (pReturnBuf->CurrentBuffer[i+3] == 0x2)
                        {
                            if (pReturnBuf->CurrentBuffer[i+4] == 0)
                            {
                                if (pReturnBuf->CurrentBuffer[i+5] == 0)
                                {
                                    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                                        ("ArapExtract: ERROR?: embedded arap packet at %lx? (%lx)\n",
                                        &pReturnBuf->CurrentBuffer[i],pReturnBuf));
                                }
                            }
                        }
                    }
                }
            }
        }
#endif

        //
        // is it out-of-band ARAP data?  If so, put it on its own queue, and
        // try to extract another SRP
        //
        if (!(DGroupByte & ARAP_SFLAG_PKT_DATA))
        {
            InsertTailList(&pArapConn->ArapDataQ, &pReturnBuf->Linkage);
            goto ArapSRP_TryNext;
        }
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    return(pReturnBuf);

}



//***
//
// Function: ArapQueueSendBytes
//              This routine takes compressed data and puts it into MNP packets
//              ready to be sent out.  If the last unsent buffer on the queue
//              has some room left, it first stuffs as many bytes as possible
//              in that buffer.  After that, if necessary, it allocates a new
//              buffer and puts the remaining bytes in that buffer.
//              The max data in any buffer can only be the negotiated maximum
//              MNP data length (64 or 256 bytes)
//
// Parameters:  pArapConn - connection element in question
//              pCompressedDataBuffer - pointer to the data to be sent out
//              CompressedDataLen - size of the outgoing data
//              Priority - priority of the send
//
// Return:      Error code
//
//
// NOTES:       IMPORTANT: spinlock must be held before calling this routine
//
//***$

DWORD
ArapQueueSendBytes(
    IN PARAPCONN    pArapConn,
    IN PBYTE        pCompressedDataBuffer,
    IN DWORD        CompressedDataLen,
    IN DWORD        Priority
)
{
    DWORD                   StatusCode;
    PLIST_ENTRY             pSendQHead;
    PMNPSENDBUF             pMnpSendBuf=NULL;
    PBYTE                   pFrame, pFrameStart;
    DWORD                   dwRemainingBytes;
    PMNPSENDBUF             pTailMnpSendBuf=NULL;
    PMNPSENDBUF             pFirstMnpSendBuf=NULL;
    USHORT                  DataLenInThisPkt;
    PLIST_ENTRY             pList;
    USHORT                  DataSizeOfOrgTailSend;
    PBYTE                   FreeBufferOfOrgTailSend;
    BYTE                    NumSendsOfOrgTailSend;
    BOOLEAN                 fNeedNewBuffer;
    PLIST_ENTRY             pSendList;
    USHORT                  BytesFree;
    PBYTE                   pCompressedData;
    BYTE                    DbgStartSeq;



    DBG_ARAP_CHECK_PAGED_CODE();

    if (Priority == ARAP_SEND_PRIORITY_HIGH)
    {
        pSendQHead = &pArapConn->HighPriSendQ;
    }
    else if (Priority == ARAP_SEND_PRIORITY_MED)
    {
        pSendQHead = &pArapConn->MedPriSendQ;
    }
    else
    {
        pSendQHead = &pArapConn->LowPriSendQ;
    }

#if DBG
    DbgStartSeq = pArapConn->MnpState.NextToSend;
#endif

    //
    // first, find the last send-buffer on the queue and see if its buffer has
    // any bytes free that we can use
    //

    fNeedNewBuffer = TRUE;

    if (!IsListEmpty(pSendQHead))
    {
        pList = pSendQHead->Blink;

        pTailMnpSendBuf = CONTAINING_RECORD(pList, MNPSENDBUF, Linkage);

        BytesFree = pTailMnpSendBuf->BytesFree;

        //
        // if there are more than 3 bytes free, we will use the part of this
        // buffer that's free: otherwise, let's go for a new one
        //
        if (BytesFree > ARAP_HDRSIZE)
        {
            pMnpSendBuf = pTailMnpSendBuf;

            pFrame = pTailMnpSendBuf->FreeBuffer;

            pFrameStart = pFrame;

            fNeedNewBuffer = FALSE;

            // save these, in case we have to bail out
            DataSizeOfOrgTailSend = pTailMnpSendBuf->DataSize;
            FreeBufferOfOrgTailSend = pTailMnpSendBuf->FreeBuffer;
            NumSendsOfOrgTailSend = pMnpSendBuf->NumSends;

            // mark that we are stuffing one more send into this buffer
            pMnpSendBuf->NumSends++;
        }
        else
        {
            pTailMnpSendBuf = NULL;
        }
    }


    dwRemainingBytes = CompressedDataLen;

    pCompressedData = pCompressedDataBuffer;

    // we are adding so many more bytes to our send queue
    pArapConn->SendsPending += CompressedDataLen;

    while (dwRemainingBytes)
    {
        if (fNeedNewBuffer)
        {
            pMnpSendBuf = ArapGetSendBuf(pArapConn, Priority);
            if (pMnpSendBuf == NULL)
            {
	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                    ("ArapQueueSendBytes: ArapGetSendBuf failed (%lx)\n", pArapConn));

                StatusCode = ARAPERR_OUT_OF_RESOURCES;
                goto ArapQueueSendBytes_ErrExit;
            }

            // put MNPSend refcount
            pArapConn->RefCount++;

            BytesFree = pMnpSendBuf->BytesFree;

            pFrameStart = pFrame = pMnpSendBuf->FreeBuffer;

            //
            // remeber the first buffer, in case we have to bail out!
            //
            if (!pFirstMnpSendBuf)
            {
                pFirstMnpSendBuf = pMnpSendBuf;
            }

            // put this send on the appropriate send queue
            InsertTailList(pSendQHead, &pMnpSendBuf->Linkage);

            pMnpSendBuf->NumSends = 1;
        }

        if (dwRemainingBytes > BytesFree)
        {
            DataLenInThisPkt = BytesFree;
        }
        else
        {
            DataLenInThisPkt = (USHORT)dwRemainingBytes;
        }

        ASSERT(DataLenInThisPkt <= MNP_MAXPKT_SIZE);

        ASSERT(DataLenInThisPkt <= pMnpSendBuf->BytesFree);

        RtlCopyMemory(pFrame, pCompressedData, DataLenInThisPkt);

        dwRemainingBytes -= DataLenInThisPkt;

        pCompressedData += DataLenInThisPkt;

        ASSERT(pCompressedData <= pCompressedDataBuffer + CompressedDataLen);

        pMnpSendBuf->BytesFree -= DataLenInThisPkt;

        pMnpSendBuf->DataSize += DataLenInThisPkt;

        ASSERT(pMnpSendBuf->DataSize <= MNP_MAXPKT_SIZE);

        pFrame += DataLenInThisPkt;

        // buffer from this point on is free: we could (in a subsequent call)
        // stuff more bytes, starting from this point
        pMnpSendBuf->FreeBuffer = pFrame;

        //
        // we are either done with copying the entire send, or done with this
        // buffer: in either case, put those stop flag bytes
        //
        *pFrame++ = pArapConn->MnpState.DleByte;
        *pFrame++ = pArapConn->MnpState.EtxByte;

        ASSERT(pMnpSendBuf->FreeBuffer <=
                        (&pMnpSendBuf->Buffer[0] + 20 + MNP_MAXPKT_SIZE));

    	AtalkSetSizeOfBuffDescData(&pMnpSendBuf->sb_BuffDesc,
                                   (pMnpSendBuf->DataSize + MNP_OVERHD(pArapConn)));

        fNeedNewBuffer = TRUE;
    }

    ARAP_DBG_TRACE(pArapConn,21205,pCompressedDataBuffer,CompressedDataLen,
                    Priority,DbgStartSeq);

    return( ARAPERR_NO_ERROR );


ArapQueueSendBytes_ErrExit:

    //
    // we failed somewhere.  Undo whatever we did, to restore the original
    // state and free up whatever resources were allocated.
    //

	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
        ("ArapQueueSendBytes_ErrExit (%lx): taking _ErrExit! %ld\n",
            pArapConn,StatusCode));

    pArapConn->SendsPending -= CompressedDataLen;

    // did we fill any bytes in the older buf before allocating new one?
    if (pTailMnpSendBuf)
    {
        pTailMnpSendBuf->DataSize = DataSizeOfOrgTailSend;
        pTailMnpSendBuf->FreeBuffer = pFrame = FreeBufferOfOrgTailSend;
        pTailMnpSendBuf->NumSends = NumSendsOfOrgTailSend;

        // and don't forget those stop flag bytes we overwrote
        *pFrame++ = pArapConn->MnpState.DleByte;
        *pFrame++ = pArapConn->MnpState.EtxByte;
    }

    // did we allocate any new buffers? if so, remove and free them
    if (pFirstMnpSendBuf)
    {
        // restore the next-to-send seq num
        pArapConn->MnpState.NextToSend = pFirstMnpSendBuf->SeqNum;

        while (1)
        {
            // get the next guy first
            pSendList = pFirstMnpSendBuf->Linkage.Flink;

            // remove this one
            RemoveEntryList(&pFirstMnpSendBuf->Linkage);

            ArapNdisFreeBuf(pFirstMnpSendBuf);

            // the guy we thought was next might be the head of list: is he?
            if (pSendList == pSendQHead)
            {
                break;
            }

            pFirstMnpSendBuf = CONTAINING_RECORD(pSendList, MNPSENDBUF, Linkage);
        }
    }

    return(StatusCode);
}


//***
//
// Function: ArapGetSendBuf
//              This routine allocates a buffer for MNP send and sets it up
//              sending.
//              The max data in any buffer can only be the negotiated maximum
//              MNP data length (64 or 256 bytes)
//
// Parameters:  pArapConn - connection element in question
//              Priority  - priority of the send
//
// Return:      Pointer to the newly allocated send buffer
//
//
// NOTES:       IMPORTANT: spinlock must be held before calling this routine
//
//***$

PMNPSENDBUF
ArapGetSendBuf(
    IN PARAPCONN pArapConn,
    IN DWORD     Priority
)
{

    PBYTE           pFrame;
    PBYTE           pFrameStart;
    BYTE            SeqNum;
    PMNPSENDBUF     pMnpSendBuf;


    DBG_ARAP_CHECK_PAGED_CODE();

    // allocate an arap send buffer
	pMnpSendBuf = AtalkBPAllocBlock(pArapConn->BlockId);
    if (pMnpSendBuf == NULL)
    {
	    DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapGetSendBuf: alloc failed (%lx)\n", pArapConn));

        ASSERT(0);

        return( NULL );
    }

#if DBG
    pMnpSendBuf->Signature = (pArapConn->BlockId == BLKID_MNP_LGSENDBUF)?
                        MNPLGSENDBUF_SIGNATURE : MNPSMSENDBUF_SIGNATURE;
    InitializeListHead(&pMnpSendBuf->Linkage);
#endif

    pFrameStart = pFrame = &pMnpSendBuf->Buffer[0];

    AtalkNdisBuildARAPHdr(pFrame, pArapConn);
    pFrame += WAN_LINKHDR_LEN;


    // put the start flag bytes
    *pFrame++ = pArapConn->MnpState.SynByte;
    *pFrame++ = pArapConn->MnpState.DleByte;
    *pFrame++ = pArapConn->MnpState.StxByte;

    //
    // find out what's going to be the seq num for this send if this is a high
    // priority send.
    //
    //
    if (Priority == ARAP_SEND_PRIORITY_HIGH)
    {
        SeqNum = pArapConn->MnpState.NextToSend;
        ADD_ONE(pArapConn->MnpState.NextToSend);
    }

    //
    // For the medium and low priority send, we'll put the seq number when we
    // move it to the high-priority queue
    //
    else
    {
        SeqNum = 0;
    }

    // Optimized? put the header-length, type indication and the seq num
    if (pArapConn->Flags & MNP_OPTIMIZED_DATA)
    {
        *pFrame++ = 2;
        *pFrame++ = pArapConn->MnpState.LTByte;
        *pFrame++ = SeqNum;
    }

    // ok, non-optimized. put the header-length, type indication, type+len for
    // the variable parm and then the seq num
    else
    {
        *pFrame++ = 4;
        *pFrame++ = pArapConn->MnpState.LTByte;
        *pFrame++ = 1;
        *pFrame++ = 1;
        *pFrame++ = SeqNum;
    }

    pMnpSendBuf->BytesFree = (pArapConn->BlockId == BLKID_MNP_SMSENDBUF) ?
                                MNP_MINPKT_SIZE : MNP_MAXPKT_SIZE;

    pMnpSendBuf->DataSize = 0;
    pMnpSendBuf->FreeBuffer = pFrame;

    // store info that's used in retransmission and send completion
    pMnpSendBuf->SeqNum = SeqNum;
    pMnpSendBuf->RetryCount = 0;
    pMnpSendBuf->pArapConn = pArapConn;
    pMnpSendBuf->ComplRoutine = ArapMnpSendComplete;
    pMnpSendBuf->TimeAlloced = AtalkGetCurrentTick();
    pMnpSendBuf->Flags = 0;

    // MNP refcount: removed when this MNP pkt is acked
    pMnpSendBuf->RefCount = 1;

	((PBUFFER_HDR)pMnpSendBuf)->bh_NdisPkt = NULL;

    pArapConn->StatInfo.BytesSent += LT_OVERHEAD(pArapConn);

    return(pMnpSendBuf);
}



//***
//
// Function: ArapRefillSendQ
//              This routine removes bytes accumulated in the medium and the
//              low-priority send queues, and puts them on to the high priority
//              queue from where bytes are actually sent out.  If sufficient
//              bytes haven't accumulated as yet on either of the queus and we
//              haven't waited long enough as yet, then we skip that queue (to
//              allow more bytes to accumulate)
//              The idea behind this is: there are just too many NBP packets
//              - directed as well as broadcast - going toward the remote client.
//              If we send such a packet as soon as it arrives, we end up sending
//              numerous small sized (like 6 or 8 byte) sends to the client and
//              that really hurts throughput as typically the max size is 256!
//
// Parameters:  pArapConn - connection element in question
//
// Return:      TRUE if we moved any data to the higher priority queue
//
//***$

BOOLEAN
ArapRefillSendQ(
    IN PARAPCONN    pArapConn
)
{
    KIRQL           OldIrql;
    PMNPSENDBUF     pMnpSendBuf=NULL;
    PLIST_ENTRY     pSendHead;
    PLIST_ENTRY     pSendList;
    LONG            TimeWaited;
    BYTE            SeqNum;
    BOOLEAN         fMovedSomething=FALSE;
    BOOLEAN         fWaitLonger=FALSE;
    DWORD           SeqOffset;


    DBG_ARAP_CHECK_PAGED_CODE();

    ACQUIRE_SPIN_LOCK(&pArapConn->SpinLock, &OldIrql);

    pSendHead = &pArapConn->MedPriSendQ;

    while (1)
    {
        pSendList = pSendHead->Flink;

        //
        // if the list is not empty, take a look at the first send.  If we have
        // accumulated enough bytes, or if we have waited long enough, then it's
        // time has come to be moved to the HighPriSendQ.  Otherwise, we let it
        // stay on the queue for some more coalescing
        //
        if (pSendList != pSendHead)
        {
            pMnpSendBuf = CONTAINING_RECORD(pSendList,MNPSENDBUF,Linkage);

            TimeWaited = AtalkGetCurrentTick() - pMnpSendBuf->TimeAlloced;

            fWaitLonger =
                ((pMnpSendBuf->DataSize < ARAP_SEND_COALESCE_SIZE_LIMIT) &&
                 (pMnpSendBuf->NumSends < ARAP_SEND_COALESCE_SRP_LIMIT) &&
                 (TimeWaited < ARAP_SEND_COALESCE_TIME_LIMIT) );
        }

        //
        // if this list is empty or if this send must wait for some more time
        // then we must move to the LOW pri queue.  If that's also done, quit
        //
        if ((pSendList == pSendHead) || fWaitLonger )
        {
            // if we were on MedPriSendQ, go to the LowPriSendQ
            if (pSendHead == &pArapConn->MedPriSendQ)
            {
                pSendHead = &pArapConn->LowPriSendQ;
                continue;
            }
            else
            {
                break;
            }
        }

        ASSERT(!fWaitLonger);

        //
        // time to move this send over to the high pri queue:
        // put that seq number we had postponed putting earlier
        //
        SeqNum = pArapConn->MnpState.NextToSend;

        ADD_ONE(pArapConn->MnpState.NextToSend);

        SeqOffset = WAN_LINKHDR_LEN + LT_SEQ_OFFSET(pArapConn);

        pMnpSendBuf->Buffer[SeqOffset] = SeqNum;

        pMnpSendBuf->SeqNum = SeqNum;

        RemoveEntryList(&pMnpSendBuf->Linkage);

        InsertTailList(&pArapConn->HighPriSendQ, &pMnpSendBuf->Linkage);

        fMovedSomething = TRUE;

    	DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapRefill: moved %s seq %lx size = %d wait = %d (%d SRPs)\n",
                (pSendHead == &pArapConn->MedPriSendQ)? "MED":"LOW",
                pMnpSendBuf->SeqNum,pMnpSendBuf->DataSize,TimeWaited,
                pMnpSendBuf->NumSends));
    }

    RELEASE_SPIN_LOCK(&pArapConn->SpinLock, OldIrql);

    return(fMovedSomething);
}




//***
//
// Function: ArapUnblockSelect
//              This function is called when the DLL (ARAP Engine) tells us that
//              it's going away.  In ideal world, select irp is the only thing
//              that should get completed here.  If any connection was left
//              or any irp wasn't complete yet, this is where we would cleanup!
//
// Parameters:  None
//
// Return:      result of the operation (ARAPERR_....)
//
//***$

DWORD
ArapUnblockSelect(
    IN  VOID
)
{

    KIRQL                   OldIrql;
    PIRP                    pIrp;
    PIRP                    pSniffIrp;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;



    ARAPTRACE(("Entered ArapUnblockSelect\n"));

    ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

    pIrp = ArapSelectIrp;
    ArapSelectIrp = NULL;

#if DBG
    pSniffIrp = ArapSniffIrp;
    ArapSniffIrp = NULL;
#endif

    if (ArapStackState == ARAP_STATE_ACTIVE)
    {
        ArapStackState = ARAP_STATE_ACTIVE_WAITING;
    }
    else if (ArapStackState == ARAP_STATE_INACTIVE)
    {
        ArapStackState = ARAP_STATE_INACTIVE_WAITING;
    }

    RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);


#if DBG
    //
    // if we had sniffing going, complete the sniff irp since dll is shutting down
    //
    if (pSniffIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pSniffIrp->AssociatedIrp.SystemBuffer;
        pSndRcvInfo->StatusCode = ARAPERR_SHUTDOWN_COMPLETE;

        // complete the irp
        ARAP_COMPLETE_IRP(pSniffIrp, sizeof(ARAP_SEND_RECV_INFO), 
							STATUS_SUCCESS, &ReturnStatus);

        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapUnblockSelect: unblocked the sniff irp\n"));
    }
#endif

    //
    // complete the select irp, now that the engine tells us that it wants to
    // shutdown
    //
    if (pIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;
        pSndRcvInfo->StatusCode = ARAPERR_SHUTDOWN_COMPLETE;

        // complete the irp
        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS,
							&ReturnStatus);

        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapUnblockSelect: unblocked the select irp\n"));
    }
    else
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapUnblockSelect: select irp not yet unblocked\n"));
    }

    return(ARAPERR_NO_ERROR);
}


//***
//
// Function: ArapReleaseResources
//              This routine frees up any global resources we had allocated
//
// Parameters:  None
//
// Return:      result of the operation (ARAPERR_....)
//
//***$

DWORD
ArapReleaseResources(
    IN  VOID
)
{
    KIRQL               OldIrql;
    PLIST_ENTRY         pList;
    PADDRMGMT           pAddrMgmt;
    PADDRMGMT           pNextAddrMgmt;
    PARAPCONN           pArapConn;


    ARAPTRACE(("Entered ArapReleaseResources\n"));

    if (RasPortDesc == NULL)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapReleaseResources: arap engine never initialized; returning\n"));
        return(ARAPERR_NO_ERROR);
    }

#if ARAP_STATIC_MODE
    //
    // if we were in the static mode of network address allocation, we
    // allocated memory for our network address "bitmap": free that here.
    //
    if (!(ArapGlobs.DynamicMode))
    {
        pAddrMgmt = ArapGlobs.pAddrMgmt;

        ASSERT(pAddrMgmt);

        while (pAddrMgmt)
        {
            pNextAddrMgmt = pAddrMgmt->Next;
            AtalkFreeMemory(pAddrMgmt);
            pAddrMgmt = pNextAddrMgmt;
        }
    }
#endif


    //
    // By the time this routine is called, all the connections should have been
    // completely closed.  If, however, some connection got stuck in some weird
    // state, at least make sure that we don't have a memory leak
    //
    ASSERT(IsListEmpty(&RasPortDesc->pd_ArapConnHead));

    while (1)
    {
        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        if (IsListEmpty(&RasPortDesc->pd_ArapConnHead))
        {
            RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
            break;
        }

        pList = RasPortDesc->pd_ArapConnHead.Flink;

        pArapConn = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

        // protect against it going away while we do this
        pArapConn->RefCount++;

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

        ArapCleanup(pArapConn);

        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);
        ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);

        RemoveEntryList(&pArapConn->Linkage);
        InitializeListHead(&pArapConn->Linkage);

        // force this connection to be freed
        pArapConn->RefCount = 1;

        RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

        DerefArapConn(pArapConn);
    }

    return(ARAPERR_NO_ERROR);
}


//***
//
// Function: AtalkReferenceRasDefPort
//              This routine puts a refcount on the Default adapter so it doesn't go away
//              with PnP while we are busy doing some ARAP/PPP connection setup
//              It also makes sure that RasPortDesc is indeed present
//
// Parameters:  None
//
// Return:      TRUE (most cases) if port is all ok, FALSE if PnP in progress or something
//
//***$

BOOLEAN
AtalkReferenceRasDefPort(
    IN  VOID
)
{
    KIRQL       OldIrql;
    BOOLEAN     fDefPortOk = FALSE;


    ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

    if ((RasPortDesc != NULL) && (!(RasPortDesc->pd_Flags & PD_PNP_RECONFIGURE)))
    {
        if (AtalkDefaultPort)
        {
            ACQUIRE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
            if ((AtalkDefaultPort->pd_Flags &
                    (PD_ACTIVE | PD_PNP_RECONFIGURE | PD_CLOSING)) == PD_ACTIVE)
            {
                // put a IrpProcess refcount, so AtalkDefaultPort doesn't go away in PnP
                AtalkDefaultPort->pd_RefCount++;
                fDefPortOk = TRUE;
            }
            else
            {
	            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	                ("AtalkReferenceRasDefPort: port going away, no can do (%lx)\n",
                    AtalkDefaultPort->pd_Flags));
            }
            RELEASE_SPIN_LOCK_DPC(&AtalkDefaultPort->pd_Lock);
        }
        else
        {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	            ("AtalkReferenceRasDefPort: no default adapter configured!\n"));
        }
    }
    else
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AtalkReferenceRasDefPort: RasPortDesc not configured\n"));
    }

    RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

    return(fDefPortOk);
}



VOID
AtalkPnPInformRas(
    IN  BOOLEAN     fEnableRas
)
{

    PIRP                    pIrp=NULL;
    PARAP_SEND_RECV_INFO    pSndRcvInfo;
    DWORD                   StatusCode;
    KIRQL                   OldIrql;
	NTSTATUS				ReturnStatus=STATUS_SUCCESS;


    //
    // fEnableRas = TRUE: we are asked to inform RAS (aka dll, engine) that the stack
    // is now "active" (i.e. available for RAS connections)
    //
    if (fEnableRas)
    {
        //
        // make sure both the adapters are ready.  We don't really need spinlock to
        // check the flag since all PnP operations are guaranteed to be serialized
        //
        if ( (AtalkDefaultPort == NULL) ||
             (AtalkDefaultPort->pd_Flags & PD_PNP_RECONFIGURE) ||
             (RasPortDesc == NULL) ||
             (RasPortDesc->pd_Flags & PD_PNP_RECONFIGURE) )
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: not both adapters are ready %lx %lx, returning\n",
                AtalkDefaultPort,RasPortDesc));
            return;
        }

        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        //
        // if we are already active, nothing to do!
        //
        if (ArapStackState == ARAP_STATE_ACTIVE)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: stack already active, nothing to do\n"));

            RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
            return;
        }

        pIrp = ArapSelectIrp;
        ArapSelectIrp = NULL;

        if (pIrp)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: informing dll that stack is ready\n"));

            ArapStackState = ARAP_STATE_ACTIVE;
            StatusCode = ARAPERR_STACK_IS_ACTIVE;
        }
        else
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: no select irp. stack ready, but dll not knoweth\n"));

            ArapStackState = ARAP_STATE_ACTIVE_WAITING;
        }

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
    }

    //
    // fEnableRas = FALSE: we are asked to inform RAS (aka dll, engine) that the stack
    // is now "inactive" (i.e. not available for RAS connections)
    //
    else
    {
        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        //
        // if we are already inactive, nothing to do!
        //
        if (ArapStackState == ARAP_STATE_INACTIVE)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: stack already inactive, nothing to do\n"));

            RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
            return;
        }

        pIrp = ArapSelectIrp;
        ArapSelectIrp = NULL;

        if (pIrp)
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: informing dll that stack is unavailable\n"));

            ArapStackState = ARAP_STATE_INACTIVE;
            StatusCode = ARAPERR_STACK_IS_NOT_ACTIVE;
        }
        else
        {
            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                ("AtalkPnPInformRas: no select irp. stack unavailable, but dll not knoweth\n"));

            ArapStackState = ARAP_STATE_INACTIVE_WAITING;
        }

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
    }

    if (pIrp)
    {
        pSndRcvInfo = (PARAP_SEND_RECV_INFO)pIrp->AssociatedIrp.SystemBuffer;
        pSndRcvInfo->StatusCode = StatusCode;

        // complete the irp
        ARAP_COMPLETE_IRP(pIrp, sizeof(ARAP_SEND_RECV_INFO), STATUS_SUCCESS,
							&ReturnStatus);
    }
}


#if ARAP_STATIC_MODE

//***
//
// Function: ArapReleaseAddr
//              This routine releases the network address that was being used
//              by the client (corresponding to this connection).  In case of
//              dynamic mode, we don't do anything.
//              In case of static mode, we clear the bit corresponding to this
//              particular network address.
//
// Parameters:  pArapConn - connection element in question
//
// Return:      none
//
//***$

VOID
ArapReleaseAddr(
    IN PARAPCONN    pArapConn
)
{

    KIRQL               OldIrql;
    PADDRMGMT           pAddrMgmt;
    BYTE                Node;
    BYTE                ByteNum;
    BYTE                BitMask;
    DWORD               i;


    DBG_ARAP_CHECK_PAGED_CODE();

    //
    // if we are in static mode, we need to "release" the node so that someone
    // else can use it.  Find the bit for this node and clear it (i.e. "release")
    //
    if (!(ArapGlobs.DynamicMode))
    {
        ACQUIRE_SPIN_LOCK(&ArapSpinLock, &OldIrql);

        // first, find the right pAddrMgmt (1st one if we have <255 clients)
        pAddrMgmt = ArapGlobs.pAddrMgmt;

        ASSERT(pAddrMgmt);

        while (pAddrMgmt->Network != pArapConn->NetAddr.atn_Network)
        {
            pAddrMgmt = pAddrMgmt->Next;

            ASSERT(pAddrMgmt);
        }

        Node = pArapConn->NetAddr.atn_Node;

        // find out which of the 32 bytes we should be looking at
        ByteNum = Node/8;
        Node -= (ByteNum*8);

        // generate the bitmask to represent the node
        BitMask = 0x1;
        for (i=0; i<Node; i++ )
        {
            BitMask <<= 1;
        }

        // now, clear that bit!
        pAddrMgmt->NodeBitMap[ByteNum] &= ~BitMask;

        RELEASE_SPIN_LOCK(&ArapSpinLock, OldIrql);
    }


}
#endif //ARAP_STATIC_MODE



//
// not used anymore: leave them in, in case we need to use them sometime...
//
#if 0

DWORD
ArapScheduleWorkerEvent(
    IN DWORD Action,
    IN PVOID Context1,
    IN PVOID Context2
)
{
    PARAPQITEM  pArapQItem;

    if ((pArapQItem = AtalkAllocMemory(sizeof(ARAPQITEM))) == NULL)
    {
        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
            ("ArapScheduleWorkerEvent: mem alloc failed!\n"));
        return(ARAPERR_OUT_OF_RESOURCES);
    }

    pArapQItem->Action = Action;
    pArapQItem->Context1 = Context1;
    pArapQItem->Context2 = Context2;

    ExInitializeWorkItem(&pArapQItem->WorkQItem,
                         (PWORKER_THREAD_ROUTINE)ArapDelayedEventHandler,
                         pArapQItem);
    ExQueueWorkItem(&pArapQItem->WorkQItem, CriticalWorkQueue);

    return(ARAPERR_NO_ERROR);
}


VOID
ArapDelayedEventHandler(
    IN PARAPQITEM  pArapQItem
)
{
    DWORD               Action;
    PIRP                pIrp;
    PIO_STACK_LOCATION  pIrpSp;
    ULONG               IoControlCode;
    PMNPSENDBUF         pMnpSendBuf;
    DWORD               StatusCode;
    NTSTATUS            status;
    KIRQL               OldIrq;


    Action = pArapQItem->Action;
    switch (Action)
    {
        case ARAPACTION_COMPLETE_IRP:

            pIrp = (PIRP)pArapQItem->Context1;
            status = (NTSTATUS)pArapQItem->Context2;


            ASSERT(pIrp != NULL);

#if DBG
	        pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
            IoControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapDelayedEventHandler: completing irp %lx, Ioctl %lx, Status=%lx at irql=%d\n",
                    pIrp,IoControlCode,status,KeGetCurrentIrql()));
#endif
            //TdiCompleteRequest(pIrp, status);

            pIrp->IoStatus.Status = status;

            IoCompleteRequest(pIrp,IO_NETWORK_INCREMENT);

            break;

        case ARAPACTION_CALL_COMPLETION:

            pMnpSendBuf = (PMNPSENDBUF )pArapQItem->Context1;
            StatusCode = (DWORD)pArapQItem->Context2;

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapDelayedEventHandler: calling compl. %lx with %lx, %ld\n",
                 pMnpSendBuf->ComplRoutine,pMnpSendBuf, StatusCode));

            (pMnpSendBuf->ComplRoutine)(pMnpSendBuf, StatusCode);

            break;

        default:

	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
		        ("ArapDelayedEventHandler: invalid action %ld\n",Action));
    }

    AtalkFreeMemory(pArapQItem);
}

#endif // #if 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atalk.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atalk.h

Abstract:

	This module is the main include file for the Appletalk protocol stack.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#pragma warning(disable:4010)

#ifndef	_ATALK_
#define	_ATALK_

#include <ntosp.h>
#include <zwapi.h>
#include <tdikrnl.h>
#include <ndis.h>

#define EQU           =
#if	DBG
// Turn off FASTCALL for checked builds
#undef	FASTCALL
#define	FASTCALL
#define	LOCAL
#else
//	#define	LOCAL	static
#define	LOCAL
#endif

//	Basic types for appletalk
#include "fwddecl.h"
#include "lists.h"
#include "atktypes.h"

//	The exported tdi interface file.
#include <atalktdi.h>

//	Main driver file
#include "atkdrvr.h"

//	Now the basic stuff
#include "atktimer.h"

// ARAP support
#include "v42bis.h"
#include "arapio.h"
#include "arap.h"

#include "atkerror.h"
#include "atkmsg.h"
#include "atkmem.h"
#include "atkstat.h"
#include "ports.h"
#include "node.h"
#include "atktdi.h"
#include "ddp.h"
#include "aarp.h"
#include "atkndis.h"
#include "atkutils.h"
#include "router.h"
#include "atktdi.h"
#include "atkinit.h"
#include "atkquery.h"
#include "nbp.h"
#include "rtmp.h"
#include "zip.h"
#include "aep.h"
#include "atp.h"
#include "asp.h"
#include "aspc.h"
#include "pap.h"
#include "adsp.h"
#include "blkpool.h"

#include "rasproto.h"
#endif	// _ATALK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\aspc.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	aspc.h

Abstract:

	This module contains definitions for the client side ASP code.

Author:

	Jameel Hyder (jameelh@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ASPC_
#define	_ASPC_

#define	ASPC_CONN_HASH_BUCKETS		13	// Hashed by NodeAddr

#define	HASH_ASPC_SRCADDR(pSrcAddr)	\
			((((pSrcAddr)->ata_Node >> 2) +	\
			  ((pSrcAddr)->ata_Network & 0xFF)) % ASPC_CONN_HASH_BUCKETS)

// For resolving forward references
struct _AspCAddress;
struct _AspCConnxn;
struct _AspCRequest;

#define ASP_MIN_REQ_INTERVAL	5		// In 100ms units
#define ASP_MAX_REQ_INTERVAL	20		// In 100ms units
#define ASP_INIT_REQ_INTERVAL	5		// In 100ms units

#define	ASPCAO_CLOSING			0x8000
#define	ASPCAO_SIGNATURE		*(PULONG)"ACAO"

#define	VALID_ASPCAO(pAspCAddr)	(((pAspCAddr) != NULL) && \
			(((struct _AspCAddress *)(pAspCAddr))->aspcao_Signature == ASPCAO_SIGNATURE))

// Also known as the listener.
typedef struct _AspCAddress
{
	ULONG						aspcao_Signature;
	struct _AspCAddress *		aspcao_Next;			// Links to global list
	struct _AspCAddress **		aspcao_Prev;
	LONG						aspcao_RefCount;		// References to the address obj
	ULONG						aspcao_Flags;

	PATP_ADDROBJ				aspcao_pAtpAddr;		// Atp Socket for this asp conn
	GENERIC_COMPLETION			aspcao_CloseCompletion;
	PVOID						aspcao_CloseContext;
    PTDI_IND_DISCONNECT 		aspcao_DisconnectHandler;
    PVOID 						aspcao_DisconnectHandlerCtx;
    PTDI_IND_RECEIVE_EXPEDITED	aspcao_ExpRecvHandler;	// Used to indicate attention
    PVOID 						aspcao_ExpRecvHandlerCtx;
	ATALK_SPIN_LOCK				aspcao_Lock;
} ASPC_ADDROBJ, *PASPC_ADDROBJ;

#define	ASPCCO_ASSOCIATED		0x0001
#define	ASPCCO_ACTIVE			0x0002
#define	ASPCCO_TICKLING			0x0004
#define	ASPCCO_CONNECTING		0x0008
#define	ASPCCO_CLEANING_UP		0x0010
#define	ASPCCO_LOCAL_CLOSE		0x0020
#define	ASPCCO_REMOTE_CLOSE		0x0040
#define	ASPCCO_DROPPED			0x0080
#define	ASPCCO_ATTN_PENDING		0x0100
#define	ASPCCO_DISCONNECTING	0x0200
#define	ASPCCO_CLOSING			0x8000
#define	ASPCCO_SIGNATURE		*(PULONG)"ACCO"
#define	MAX_ASPC_ATTNS			8

#define	VALID_ASPCCO(pAspConn)	(((pAspConn) != NULL) && \
			(((struct _AspCConnxn *)(pAspConn))->aspcco_Signature == ASPCCO_SIGNATURE))

typedef struct _AspCConnxn
{
	ULONG						aspcco_Signature;

	struct _AspCConnxn *		aspcco_Next;		// Links to global list
	struct _AspCConnxn **		aspcco_Prev;
	LONG						aspcco_RefCount;	// References to the conn obj
	struct _AspCAddress	*		aspcco_pAspCAddr;	// Back pointer to the address

	struct _AspCRequest	*		aspcco_pActiveReqs;	// List of requests being processed
	PATP_ADDROBJ				aspcco_pAtpAddr;	// Atp Socket for this asp conn
													// Copy of aspcao_pAtpAddr for efficiency
	LONG						aspcco_LastContactTime;
	ATALK_ADDR					aspcco_ServerSlsAddr;//This is the server addr to which we send
													// the tickles/open/getstatus
	ATALK_ADDR					aspcco_ServerSssAddr;//This is the server addr to which we send
													// the commands/writes
	BYTE						aspcco_SessionId;
	BYTE						aspcco_cReqsInProcess;// Count of requests in process
	USHORT						aspcco_Flags;		// aspcco_xxx values
	USHORT						aspcco_NextSeqNum;
	USHORT						aspcco_OpenSessTid;
	USHORT						aspcco_TickleTid;
	union
	{
		USHORT					aspcco_TickleXactId;// Transaction id for tickles
		USHORT					aspcco_OpenSessId;	// Transaction id for open-session request
	};

	// We keep a circular buffer for storing attentions. If full further attention
	// bytes overwrite it
	USHORT						aspcco_AttnBuf[MAX_ASPC_ATTNS];
	USHORT						aspcco_AttnInPtr;
	USHORT						aspcco_AttnOutPtr;

	RT							aspcco_RT;			// Used for adaptive round-trip time calculation

	PVOID						aspcco_ConnCtx;

	//	Read (GetAttn) Completion routine
	GENERIC_READ_COMPLETION		aspcco_ReadCompletion;
	PVOID						aspcco_ReadCtx;

	//	Connect inform routine
	GENERIC_COMPLETION			aspcco_ConnectCompletion;
	PVOID						aspcco_ConnectCtx;

	//	Disconnect inform routine
	GENERIC_COMPLETION			aspcco_DisconnectInform;
	PVOID						aspcco_DisconnectInformCtx;

	//	Disconnect request completion
	ATALK_ERROR					aspcco_DisconnectStatus;
	GENERIC_COMPLETION			aspcco_DisconnectCompletion;
	PVOID						aspcco_DisconnectCtx;

	// Completion routine to be called when socket is cleaned-up
	GENERIC_COMPLETION			aspcco_CleanupComp;
	PVOID						aspcco_CleanupCtx;

	// Completion routine to be called when socket is closed
	GENERIC_COMPLETION			aspcco_CloseComp;
	PVOID						aspcco_CloseCtx;

	PATALK_DEV_CTX				aspcco_pDevCtx;
	ATALK_SPIN_LOCK				aspcco_Lock;
} ASPC_CONNOBJ, *PASPC_CONNOBJ;

#define	ASPCRQ_COMMAND				0x0001		// Asp Command
#define	ASPCRQ_WRITE				0x0002		// Asp Write
#define	ASPCRQ_WRTCONT				0x0004		// Write continue recvd. and replied

// The request gets created when a Command or Write is posted
#define	ASPCRQ_SIGNATURE			*(PULONG)"ACRQ"
#if	DBG
#define	VALID_ASPCRQ(pAspCReq)	(((pAspCReq) != NULL) && \
								 ((pAspCReq)->aspcrq_Signature == ASPRQ_SIGNATURE))
#else
#define	VALID_ASPCRQ(pAspCReq)	((pAspCReq) != NULL)
#endif

typedef struct _AspCRequest
{
#if	DBG
	ULONG						aspcrq_Signature;
#endif
	struct _AspCRequest	*		aspcrq_Next;	// Link to next request
	LONG						aspcrq_RefCount;// Reference Count
	struct _AspCConnxn	*		aspcrq_pAspConn;// Owning connection
	PATP_RESP					aspcrq_pAtpResp;// Used to reply to a wrtcont request
	PACTREQ						aspcrq_pActReq;	// Request completion
	union
	{
		PAMDL					aspcrq_pReplyMdl;
		PAMDL					aspcrq_pWriteMdl;
	};
	USHORT						aspcrq_SeqNum;
	USHORT						aspcrq_ReqXactId;// Transaction Id of the request/command
	USHORT						aspcrq_Flags;	// Various ASPRQ_xxx values
	union
	{
		USHORT					aspcrq_ReplySize;
		USHORT					aspcrq_WriteSize;
	};

	ATALK_SPIN_LOCK				aspcrq_Lock;	// Spin-lock
} ASPC_REQUEST, *PASPC_REQUEST;

//	MACROS
#define	AtalkAspCGetDdpAddress(pAspAddr)	\
							AtalkAtpGetDdpAddress((pAspAddr)->aspcao_pAtpAddr)

extern
VOID
AtalkInitAspCInitialize(
	VOID
);

extern
ATALK_ERROR
AtalkAspCCreateAddress(
	IN	PATALK_DEV_CTX			pDevCtx	OPTIONAL,
	OUT	PASPC_ADDROBJ	*		ppAspAddr
);

extern
ATALK_ERROR
AtalkAspCCleanupAddress(
	IN	PASPC_ADDROBJ			pAspAddr
);

extern
ATALK_ERROR
AtalkAspCCloseAddress(
	IN	PASPC_ADDROBJ			pAspAddr,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
);

extern
ATALK_ERROR
AtalkAspCCreateConnection(
	IN	PVOID					ConnCtx,
	IN	PATALK_DEV_CTX			pDevCtx	OPTIONAL,
	OUT	PASPC_CONNOBJ	*		ppAspConn
);

extern
ATALK_ERROR
AtalkAspCCleanupConnection(
	IN	PASPC_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspCCloseConnection(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	GENERIC_COMPLETION		CompletionRoutine,
	IN	PVOID					CloseContext
);

//	MACROS
#define	AtalkAspCAddrReferenceNonInterlock(_pAspAddr, _pError)	\
{																\
	if (((_pAspAddr)->aspcao_Flags & ASPCAO_CLOSING) == 0)		\
	{															\
		ASSERT((_pAspAddr)->aspcao_RefCount >= 1);				\
		(_pAspAddr)->aspcao_RefCount++;							\
		*(_pError) = ATALK_NO_ERROR;							\
	}															\
	else														\
	{															\
		*(_pError) = ATALK_ASPC_ADDR_CLOSING;					\
	}															\
	if (ATALK_SUCCESS(*(_pError)))								\
	{															\
		DBGPRINT(DBG_COMP_ASP, DBG_LEVEL_REFASPADDR,			\
				("RefAddr %lx at %s(%d) = %d\n",				\
				_pAspAddr, __FILE__, __LINE__,					\
				((_pAspAddr)->aspcao_RefCount)));				\
	}															\
}

#define	AtalkAspCAddrReference(_pAspAddr, _pError)				\
	{															\
		KIRQL	OldIrql;										\
																\
		ACQUIRE_SPIN_LOCK(&(_pAspAddr)->aspcao_Lock, &OldIrql);	\
		AtalkAspCAddrReferenceNonInterlock(_pAspAddr, _pError);	\
		RELEASE_SPIN_LOCK(&(_pAspAddr)->aspcao_Lock, OldIrql);	\
	}

#define	AtalkAspCConnReferenceByPtrNonInterlock(_pAspConn, _pError)	\
	{															\
		if (((_pAspConn)->aspcco_Flags & ASPCCO_CLOSING) == 0)	\
		{														\
			ASSERT((_pAspConn)->aspcco_RefCount >= 1);			\
			(_pAspConn)->aspcco_RefCount++;						\
			*(_pError) = ATALK_NO_ERROR;						\
		}														\
		else													\
		{														\
			*(_pError) = ATALK_ASPC_ADDR_CLOSING;				\
		}														\
	}

#define	AtalkAspCConnReference(_pAspConn, _pError)				\
	{															\
		KIRQL	OldIrql;										\
																\
		ACQUIRE_SPIN_LOCK(&(_pAspConn)->aspcco_Lock, &OldIrql);	\
		AtalkAspCConnReferenceByPtrNonInterlock(_pAspConn, _pError);\
		RELEASE_SPIN_LOCK(&(_pAspConn)->aspcco_Lock, OldIrql);	\
	}

extern
VOID FASTCALL
AtalkAspCAddrDereference(
	IN	PASPC_ADDROBJ			pAspAddr
);

extern
VOID FASTCALL
AtalkAspCConnDereference(
	IN	PASPC_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspCAssociateAddress(
	IN	PASPC_ADDROBJ			pAspAddr,
	IN	PASPC_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspCDissociateAddress(
	IN	PASPC_CONNOBJ			pAspConn
);

extern
ATALK_ERROR
AtalkAspCPostConnect(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	PVOID					pConnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
);

extern
ATALK_ERROR
AtalkAspCDisconnect(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	ATALK_DISCONNECT_TYPE	DisconnectType,
	IN	PVOID					pDisconnectCtx,
	IN	GENERIC_COMPLETION		CompletionRoutine
);

extern
ATALK_ERROR
AtalkAspCGetStatus(
	IN	PASPC_ADDROBJ			pAspAddr,
	IN	PATALK_ADDR				pRemoteAddr,
	IN	PAMDL					pStatusAmdl,
	IN	USHORT					AmdlSize,
	IN	PACTREQ					pActReq
);

extern
ATALK_ERROR
AtalkAspCGetAttn(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	PAMDL					pReadBuf,
	IN	USHORT					ReadBufLen,
	IN	ULONG					ReadFlags,
	IN	PVOID					pReadCtx,
	IN	GENERIC_READ_COMPLETION	CompletionRoutine
);

extern
ATALK_ERROR
AtalkAspCCmdOrWrite(
	IN	PASPC_CONNOBJ			pAspConn,
	IN	PAMDL					pCmdMdl,
	IN	USHORT					CmdSize,
	IN	PAMDL					pReplyMdl,
	IN	USHORT					ReplySize,
	IN	BOOLEAN					fWrite,		// If TRUE, its a write else command
	IN	PACTREQ					pActReq
);


BOOLEAN
AtalkAspCConnectionIsValid(
	IN	PASPC_CONNOBJ	pAspConn
);

// This is a list of all active connections. This is scanned by the session
// maintenance timer.
typedef	struct
{
	PASP_CONNOBJ	ascm_ConnList;
    TIMERLIST		ascm_SMTTimer;
} ASPC_CONN_MAINT, *PASPC_CONN_MAINT;

extern	ASPC_CONN_MAINT	atalkAspCConnMaint;

extern	ATALK_SPIN_LOCK	atalkAspCLock;
extern	PASPC_ADDROBJ	atalkAspCAddrList;
extern	PASPC_CONNOBJ	atalkAspCConnList;

LOCAL VOID
atalkAspCCloseSession(
	IN	PASPC_CONNOBJ			pAspConn
);

LOCAL VOID
atalkAspCHandler(
	IN	ATALK_ERROR				ErrorCode,
	IN	PASPC_CONNOBJ			pAspConn,		// Listener (our context)
	IN	PATP_RESP				RespCtxt,		// Used by PostResp/CancelResp
	IN	PATALK_ADDR				pSrcAddr,		// Address of requestor
	IN	USHORT					PktLen,
	IN	PBYTE					pPkt,
	IN	PBYTE					pUserBytes
);

LOCAL VOID
atalkAspCIncomingOpenReply(
	IN	ATALK_ERROR				ErrorCode,
	IN	PASPC_CONNOBJ			pAspConn,		// Our context
	IN	PAMDL					pReqAmdl,
	IN	PAMDL					pReadAmdl,
	IN	USHORT					ReadLen,
	IN	PBYTE					ReadUserBytes
);

LOCAL VOID
atalkAspCIncomingStatus(
	IN	ATALK_ERROR				ErrorCode,
	IN	PACTREQ					pActReq,		// Our Ctx
	IN	PAMDL					pReqAmdl,
	IN	PAMDL					pStatusAmdl,
	IN	USHORT					StatusLen,
	IN	PBYTE					ReadUserBytes
);

LOCAL VOID
atalkAspCIncomingCmdReply(
	IN	ATALK_ERROR				Error,
	IN	PASPC_REQUEST			pAspReq,
	IN	PAMDL					pReqAMdl,
	IN	PAMDL					pRespAMdl,
	IN	USHORT					RespSize,
	IN	PBYTE					RespUserBytes
);

LOCAL LONG FASTCALL
atalkAspCSessionMaintenanceTimer(
	IN	PTIMERLIST				pTimer,
	IN	BOOLEAN					TimerShuttingDown
);

LOCAL VOID FASTCALL
atalkAspCGenericRespComplete(
	IN	ATALK_ERROR				ErrorCode,
	IN	PATP_RESP				pAtpResp
);

LOCAL	VOID
atalkAspCQueueAddrGlobalList(
	IN	PASPC_ADDROBJ			pAspCAddr
);

LOCAL	VOID
atalkAspCDeQueueAddrGlobalList(
	IN	PASPC_ADDROBJ			pAspCAddr
);

LOCAL	VOID
atalkAspCQueueConnGlobalList(
	IN	PASPC_CONNOBJ			pAspConn
);

LOCAL	VOID
atalkAspCDeQueueConnGlobalList(
	IN	PASPC_CONNOBJ			pAspCConn
);

#endif	// _ASPC_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkdrvr.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkdrvr.h

Abstract:

	This module contains the driver related information.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKDRVR_
#define	_ATKDRVR_

//  The following are the types of devices the Atalk driver will open
//
//  WARNING:
//  Note that the ordering of the below is very important in
//  ATKDRVR.C's DriverEntry routine, where it is assumed that the order
//  of the device names in their array corresponds to the order of types here

#define  ATALK_NO_DEVICES   6

typedef enum
{
   ATALK_DEV_DDP = 0,
   ATALK_DEV_ADSP,
   ATALK_DEV_ASP,
   ATALK_DEV_PAP,
   ATALK_DEV_ARAP,
   ATALK_DEV_ASPC,

   //   The following device type is used only for the tdi action dispatch.
   //   It *should not* be included in the ATALK_NODEVICES count.
   ATALK_DEV_ANY

} ATALK_DEV_TYPE;

//  Atalk Device Context
typedef struct _ATALK_DEV_CTX
{

   ATALK_DEV_TYPE 		adc_DevType;

   //   Provider info and provider statistics.
   TDI_PROVIDER_INFO    	adc_ProvInfo;
   TDI_PROVIDER_STATISTICS  adc_ProvStats;

} ATALK_DEV_CTX, *PATALK_DEV_CTX;


//  Atalk device object
typedef struct _ATALK_DEV_OBJ
{

   DEVICE_OBJECT 		DevObj;
   ATALK_DEV_CTX	 	Ctx;

} ATALK_DEV_OBJ, *PATALK_DEV_OBJ;

#define ATALK_DEV_EXT_LEN \
			(sizeof(ATALK_DEV_OBJ) - sizeof(DEVICE_OBJECT))


//	Define the type for the TDI Control Channel object.
#define		TDI_CONTROL_CHANNEL_FILE	3


//
// The address of the atalk device objects are kept
// in global storage. These are the device names the driver
// will create
//
// IMPORTANT:
// There is a strong connection between the names listed here and the
// ATALK_DEVICE_TYPE enum. They must correspond exactly.
//

extern	PWCHAR				AtalkDeviceNames[];

extern	PATALK_DEV_OBJ  	AtalkDeviceObject[ATALK_NO_DEVICES];

#define    ATALK_UNLOADING          0x000000001
#define    ATALK_BINDING	        0x000000002
#define    ATALK_PNP_IN_PROGRESS    0x000000004

extern	DWORD				AtalkBindnUnloadStates;
extern  PVOID               TdiAddressChangeRegHandle;


#if DBG
extern	ATALK_SPIN_LOCK		AtalkDebugSpinLock;

extern  DWORD               AtalkDbgMdlsAlloced;
extern  DWORD               AtalkDbgIrpsAlloced;

#define ATALK_DBG_INC_COUNT(_Val)  AtalkDbgIncCount(&_Val)
#define ATALK_DBG_DEC_COUNT(_Val)  AtalkDbgDecCount(&_Val)
#else
#define ATALK_DBG_INC_COUNT(_Val)
#define ATALK_DBG_DEC_COUNT(_Val)
#endif


NTSTATUS
AtalkDispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

VOID
AtalkCleanup(
    VOID);

//  LOCAL Function prototypes

VOID
atalkUnload(
    IN PDRIVER_OBJECT DriverObject);

NTSTATUS
AtalkDispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
AtalkDispatchCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
AtalkDispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

NTSTATUS
AtalkDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

#endif	// _ATKDRVR_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkerror.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkerror.c

Abstract:

	This module contains the event logging and all error log code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKERROR


LONG		AtalkLastRawDataLen	= 0;
NTSTATUS	AtalkLastErrorCode	= STATUS_SUCCESS;
ULONG		AtalkLastErrorCount	= 0;
LONG		AtalkLastErrorTime  = 0;
BYTE		AtalkLastRawData[PORT_MAXIMUM_MESSAGE_LENGTH - \
							 sizeof(IO_ERROR_LOG_PACKET)]	= {0};

VOID
AtalkWriteErrorLogEntry(
	IN	PPORT_DESCRIPTOR	pPortDesc			OPTIONAL,
    IN	NTSTATUS 			UniqueErrorCode,
    IN	ULONG    			UniqueErrorValue,
    IN	NTSTATUS 			NtStatusCode,
    IN	PVOID    			RawDataBuf			OPTIONAL,
    IN	LONG     			RawDataLen
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{

    PIO_ERROR_LOG_PACKET 	errorLogEntry;
    int 					AdapterNameLen = 0;
    PUNICODE_STRING         pAdapterName = NULL;

    if (pPortDesc != NULL)
	{
        // do we have the friendly name (always yes, unless mem alloc failed)
        if (pPortDesc->pd_FriendlyAdapterName.Buffer)
        {
            pAdapterName = &pPortDesc->pd_FriendlyAdapterName;
        }
        else
        {
            pAdapterName = &pPortDesc->pd_AdapterKey;
        }

		AdapterNameLen += pAdapterName->Length;
	}

	//ASSERT ((AdapterNameLen + sizeof(IO_ERROR_LOG_PACKET)) <
							//PORT_MAXIMUM_MESSAGE_LENGTH);

#if DBG
    if ((AdapterNameLen + sizeof(IO_ERROR_LOG_PACKET)) > PORT_MAXIMUM_MESSAGE_LENGTH)
    {
        DBGPRINT(DBG_COMP_UTILS, DBG_LEVEL_ERR,
				("AtalkWriteErrorLogEntry: Adapter Name for Port Descriptor has length = %d, which is greater than space allocated for it in the port message buffer = %d. The adapter name will be truncated in the log.\n", AdapterNameLen, PORT_MAXIMUM_MESSAGE_LENGTH-sizeof(IO_ERROR_LOG_PACKET)));
	}
#endif

    // make sure the adaptername isn't huge: if it is, chop it
    if ((AdapterNameLen + sizeof(IO_ERROR_LOG_PACKET)) > PORT_MAXIMUM_MESSAGE_LENGTH)
    {
        AdapterNameLen = PORT_MAXIMUM_MESSAGE_LENGTH - sizeof(IO_ERROR_LOG_PACKET);
    }

    //
    if ((RawDataLen + AdapterNameLen + sizeof(IO_ERROR_LOG_PACKET)) >
											PORT_MAXIMUM_MESSAGE_LENGTH)
    {
		RawDataLen = PORT_MAXIMUM_MESSAGE_LENGTH -
				        (AdapterNameLen + sizeof(IO_ERROR_LOG_PACKET));
    }

	// Filter out events such that the same event recurring close together does not
	// cause errorlog clogging. The scheme is - if the event is same as the last event
	// and the elapsed time is > THRESHOLD and ERROR_CONSEQ_FREQ simulataneous errors
	// have happened, then log it else skip
	if (UniqueErrorCode == AtalkLastErrorCode)
	{
		AtalkLastErrorCount++;
		if ((AtalkLastRawDataLen == RawDataLen)					&&
			(AtalkFixedCompareCaseSensitive(AtalkLastRawData,
											RawDataLen,
											RawDataBuf,
											RawDataLen))		&&
			((AtalkLastErrorCount % ERROR_CONSEQ_FREQ) != 0)	&&
			((AtalkGetCurrentTick() - AtalkLastErrorTime) < ERROR_CONSEQ_TIME))
		{
			return;
		}
	}

	AtalkLastErrorCode	= UniqueErrorCode;
	AtalkLastErrorCount	= 0;
	AtalkLastErrorTime  = AtalkGetCurrentTick();
	ASSERT(RawDataLen < (PORT_MAXIMUM_MESSAGE_LENGTH -
						 sizeof(IO_ERROR_LOG_PACKET)));

	if (RawDataLen != 0)
	{
	    AtalkLastRawDataLen = RawDataLen;
		RtlCopyMemory(
			AtalkLastRawData,
			RawDataBuf,
			RawDataLen);
	}

	errorLogEntry =
        (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                                    (PDEVICE_OBJECT)AtalkDeviceObject[0],
                                    (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) +
									AdapterNameLen + RawDataLen));

    if (errorLogEntry != NULL)
    {
        // Fill in the Error log entry
        errorLogEntry->ErrorCode = UniqueErrorCode;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->FinalStatus = NtStatusCode;
        errorLogEntry->IoControlCode = 0;
        errorLogEntry->DeviceOffset.LowPart = 0;
        errorLogEntry->DeviceOffset.HighPart = 0;
        errorLogEntry->DumpDataSize = (USHORT)RawDataLen;

        errorLogEntry->StringOffset =
            (USHORT)(FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + RawDataLen);

        errorLogEntry->NumberOfStrings = (ARGUMENT_PRESENT(pPortDesc)) ? 1 : 0;

        if (ARGUMENT_PRESENT(RawDataBuf))
        {
			ASSERT(RawDataLen > 0);
            RtlCopyMemory((PCHAR)&errorLogEntry->DumpData[0], RawDataBuf, RawDataLen);
        }

        if (ARGUMENT_PRESENT(pPortDesc))
		{
            RtlCopyMemory((PCHAR)errorLogEntry->DumpData + RawDataLen,
						  pAdapterName->Buffer,
						  AdapterNameLen);
        }

        // Write the entry
        IoWriteErrorLogEntry(errorLogEntry);
    }
	else
	{
		DBGPRINT(DBG_ALL, DBG_LEVEL_FATAL,
			("AtalkWriteErrorLogEntry: IoAllocErrorlogEntry Failed %d = %d+%d+%d\n",
            sizeof(IO_ERROR_LOG_PACKET)+AdapterNameLen+RawDataLen,
            sizeof(IO_ERROR_LOG_PACKET),AdapterNameLen,RawDataLen));
	}
}



VOID
AtalkLogBadPacket(
	IN	struct _PORT_DESCRIPTOR	*	pPortDesc,
	IN	PATALK_ADDR					pSrcAddr,
	IN	PATALK_ADDR					pDstAddr	OPTIONAL,
	IN	PBYTE						pPkt,
	IN	USHORT	 					PktLen
	)
{
	PBYTE	RawData;

	if ((RawData = AtalkAllocMemory(PktLen + sizeof(ATALK_ADDR) + sizeof(ATALK_ADDR))) != NULL)
	{
		RtlCopyMemory(RawData,
					  pSrcAddr,
					  sizeof(ATALK_ADDR));
		if (ARGUMENT_PRESENT(pDstAddr))
		{
			RtlCopyMemory(RawData + sizeof(ATALK_ADDR),
						  pDstAddr,
						  sizeof(ATALK_ADDR));
		}
		else RtlZeroMemory(RawData + sizeof(ATALK_ADDR), sizeof(ATALK_ADDR));
		RtlCopyMemory(RawData + sizeof(ATALK_ADDR) + sizeof(ATALK_ADDR),
					  pPkt,
					  PktLen);
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_PACKETINVALID,
						0,
						RawData,
						PktLen + sizeof(ATALK_ADDR) + sizeof(ATALK_ADDR));
		AtalkFreeMemory(RawData);
	}
}

struct _NdisToAtalkCodes
{
	NDIS_STATUS	_NdisCode;
	ATALK_ERROR	_AtalkCode;
} atalkNdisToAtalkCodes[] =
	{
		{ NDIS_STATUS_SUCCESS,				ATALK_NO_ERROR				},
		{ NDIS_STATUS_PENDING,				ATALK_PENDING               },
		{ NDIS_STATUS_RESOURCES,			ATALK_RESR_MEM              },
		{ NDIS_STATUS_UNSUPPORTED_MEDIA,	ATALK_INIT_MEDIA_INVALID    },
		{ NDIS_STATUS_BAD_VERSION,			ATALK_INIT_REGPROTO_FAIL    },
		{ NDIS_STATUS_BAD_CHARACTERISTICS,	ATALK_INIT_REGPROTO_FAIL    },
		{ NDIS_STATUS_BUFFER_TOO_SHORT,		ATALK_BUFFER_TOO_SMALL      },
		{ NDIS_STATUS_ADAPTER_NOT_FOUND,	ATALK_INIT_BINDFAIL         },
		{ NDIS_STATUS_OPEN_FAILED,			ATALK_INIT_BINDFAIL         },
		{ NDIS_STATUS_OPEN_LIST_FULL,		ATALK_INIT_BINDFAIL         },
		{ NDIS_STATUS_ADAPTER_NOT_READY,	ATALK_INIT_BINDFAIL         }
	};

ATALK_ERROR FASTCALL
AtalkNdisToAtalkError(
	IN	NDIS_STATUS	Error
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_ERROR	err = ATALK_FAILURE;	// default
	int			i;
	struct _NdisToAtalkCodes *pCodes;

	for (i = 0, pCodes = &atalkNdisToAtalkCodes[0];
		 i < sizeof(atalkNdisToAtalkCodes)/sizeof(struct _NdisToAtalkCodes);
		 i++, pCodes++)
	{
		if (pCodes->_NdisCode == Error)
		{
			err = pCodes->_AtalkCode;
			break;
		}
	}

	return(err);
}




struct _AtalkToNtCodes
{
	ATALK_ERROR	_AtalkCode;
	NTSTATUS	_NtCode;
} atalkToNtCodes[] =
	{
		{ ATALK_NO_ERROR,				STATUS_SUCCESS							},
		{ ATALK_PENDING,				STATUS_PENDING                          },
		{ ATALK_RESR_MEM,				STATUS_INSUFFICIENT_RESOURCES           },
		{ ATALK_CONNECTION_TIMEOUT,		STATUS_REMOTE_DISCONNECT                },
		{ ATALK_LOCAL_CLOSE,			STATUS_LOCAL_DISCONNECT                 },
		{ ATALK_REMOTE_CLOSE,			STATUS_REMOTE_DISCONNECT                },
		{ ATALK_INVALID_PARAMETER,		STATUS_INVALID_PARAMETER                },
		{ ATALK_BUFFER_TOO_SMALL,		STATUS_BUFFER_TOO_SMALL                 },
		{ ATALK_INVALID_REQUEST,		STATUS_REQUEST_NOT_ACCEPTED             },
		{ ATALK_DEVICE_NOT_READY,		STATUS_DEVICE_NOT_READY                 },
		{ ATALK_REQUEST_NOT_ACCEPTED,	STATUS_REQUEST_NOT_ACCEPTED             },
		{ ATALK_NEW_SOCKET,				STATUS_INVALID_ADDRESS                  },
		{ ATALK_TIMEOUT,				STATUS_IO_TIMEOUT                       },
		{ ATALK_SHARING_VIOLATION,		STATUS_SHARING_VIOLATION                },
		{ ATALK_INIT_BINDFAIL,			(NTSTATUS)NDIS_STATUS_OPEN_FAILED       },
		{ ATALK_INIT_REGPROTO_FAIL,		(NTSTATUS)NDIS_STATUS_BAD_VERSION       },
		{ ATALK_INIT_MEDIA_INVALID,		(NTSTATUS)NDIS_STATUS_UNSUPPORTED_MEDIA },
		{ ATALK_PORT_INVALID,			STATUS_INVALID_PORT_HANDLE              },
		{ ATALK_PORT_CLOSING,			STATUS_PORT_DISCONNECTED                },
		{ ATALK_NODE_FINDING,			STATUS_TOO_MANY_COMMANDS                },
		{ ATALK_NODE_NONEXISTENT,		STATUS_INVALID_ADDRESS_COMPONENT        },
		{ ATALK_NODE_CLOSING,			STATUS_ADDRESS_CLOSED                   },
		{ ATALK_NODE_NOMORE,			STATUS_TOO_MANY_NODES                   },
		{ ATALK_SOCKET_INVALID,			STATUS_INVALID_ADDRESS_COMPONENT        },
		{ ATALK_SOCKET_NODEFULL,		STATUS_TOO_MANY_ADDRESSES               },
		{ ATALK_SOCKET_EXISTS,			STATUS_ADDRESS_ALREADY_EXISTS           },
		{ ATALK_SOCKET_CLOSED,			STATUS_ADDRESS_CLOSED                   },
		{ ATALK_DDP_CLOSING,			STATUS_ADDRESS_CLOSED                   },
		{ ATALK_DDP_NOTFOUND,			STATUS_INVALID_ADDRESS                  },
		{ ATALK_DDP_INVALID_LEN,		STATUS_INVALID_PARAMETER                },
		{ ATALK_DDP_INVALID_SRC,		STATUS_INVALID_ADDRESS                  },
		{ ATALK_DDP_INVALID_DEST,		STATUS_INVALID_ADDRESS                  },
		{ ATALK_DDP_INVALID_ADDR,		STATUS_INVALID_ADDRESS                  },
		{ ATALK_DDP_INVALID_PARAM,		STATUS_INVALID_PARAMETER                },
		{ ATALK_ATP_RESP_TIMEOUT,		STATUS_SUCCESS                          },
		{ ATALK_ATP_INVALID_RETRYCNT,	STATUS_INVALID_PARAMETER                },
		{ ATALK_ATP_INVALID_TIMERVAL,	STATUS_INVALID_PARAMETER                },
		{ ATALK_ATP_INVALID_RELINT,		STATUS_INVALID_PARAMETER                },
		{ ATALK_ATP_RESP_CANCELLED,		STATUS_CANCELLED                        },
		{ ATALK_ATP_REQ_CANCELLED,		STATUS_CANCELLED                        },
		{ ATALK_ATP_GET_REQ_CANCELLED,	STATUS_CANCELLED                        },
		{ ATALK_ASP_INVALID_REQUEST,	STATUS_REQUEST_NOT_ACCEPTED             },
    	{ ATALK_PAP_INVALID_REQUEST,	STATUS_REQUEST_NOT_ACCEPTED             },
    	{ ATALK_PAP_TOO_MANY_READS,		STATUS_TOO_MANY_COMMANDS                },
    	{ ATALK_PAP_TOO_MANY_WRITES,	STATUS_TOO_MANY_COMMANDS                },
    	{ ATALK_PAP_CONN_NOT_ACTIVE,	STATUS_INVALID_CONNECTION               },
    	{ ATALK_PAP_ADDR_CLOSING,		STATUS_INVALID_HANDLE                   },
    	{ ATALK_PAP_CONN_CLOSING,		STATUS_INVALID_HANDLE                   },
    	{ ATALK_PAP_CONN_NOT_FOUND,		STATUS_INVALID_HANDLE                   },
		{ ATALK_PAP_SERVER_BUSY,		STATUS_REMOTE_NOT_LISTENING             },
    	{ ATALK_PAP_INVALID_STATUS,		STATUS_INVALID_PARAMETER                },
		{ ATALK_PAP_PARTIAL_RECEIVE,	STATUS_RECEIVE_PARTIAL                  },
		{ ATALK_ADSP_INVALID_REQUEST,	STATUS_REQUEST_NOT_ACCEPTED             },
		{ ATALK_ADSP_CONN_NOT_ACTIVE,	STATUS_INVALID_CONNECTION               },
		{ ATALK_ADSP_ADDR_CLOSING,		STATUS_INVALID_HANDLE                   },
		{ ATALK_ADSP_CONN_CLOSING,		STATUS_INVALID_HANDLE                   },
		{ ATALK_ADSP_CONN_NOT_FOUND,	STATUS_INVALID_HANDLE                   },
		{ ATALK_ADSP_CONN_RESET,		STATUS_CONNECTION_RESET                 },
		{ ATALK_ADSP_SERVER_BUSY,		STATUS_REMOTE_NOT_LISTENING             },
		{ ATALK_ADSP_PARTIAL_RECEIVE,	STATUS_RECEIVE_PARTIAL                  },
		{ ATALK_ADSP_EXPED_RECEIVE,		STATUS_RECEIVE_EXPEDITED                },
		{ ATALK_ADSP_PAREXPED_RECEIVE,	STATUS_RECEIVE_PARTIAL_EXPEDITED        },
		{ ATALK_ADSP_REMOTE_RESR,		STATUS_REMOTE_RESOURCES        			}
	};

NTSTATUS FASTCALL
AtalkErrorToNtStatus(
    ATALK_ERROR	AtalkError
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS    Status = STATUS_UNSUCCESSFUL;	// default
	int			i;
	struct _AtalkToNtCodes *pCodes;

	for (i = 0, pCodes = &atalkToNtCodes[0];
		 i < sizeof(atalkToNtCodes)/sizeof(struct _AtalkToNtCodes);
		 i++, pCodes++)
	{
		if (pCodes->_AtalkCode == AtalkError)
		{
			Status = pCodes->_NtCode;
			break;
		}
	}

    return(Status);
}




#if	DBG

struct
{
	ULONG			DumpMask;
	DUMP_ROUTINE	DumpRoutine;
} AtalkDumpTable[32] =
{
	{ DBG_DUMP_PORTINFO,			AtalkPortDumpInfo },
	{ DBG_DUMP_AMT,					AtalkAmtDumpTable },
	{ DBG_DUMP_ZONETABLE,			AtalkZoneDumpTable },
	{ DBG_DUMP_RTES,				AtalkRtmpDumpTable },
	{ DBG_DUMP_TIMERS,				AtalkTimerDumpList },
	{ DBG_DUMP_ATPINFO,				NULL },
	{ DBG_DUMP_ASPSESSIONS,			AtalkAspDumpSessions },
	{ DBG_DUMP_PAPJOBS,				NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL },
	{ 0,							NULL }
};

LONG FASTCALL
AtalkDumpComponents(
	IN	PTIMERLIST	Context,
	IN	BOOLEAN		TimerShuttingDown
)
{
	int		i;

	if (!TimerShuttingDown)
	{
		for (i = 0;AtalkDebugDump && (i < 32); i++)
		{
			if ((AtalkDebugDump & AtalkDumpTable[i].DumpMask) &&
				(AtalkDumpTable[i].DumpRoutine != NULL))
			{
				(*AtalkDumpTable[i].DumpRoutine)();
			}
		}
	
		if (AtalkDumpInterval == 0)
		{
			AtalkDumpInterval = DBG_DUMP_DEF_INTERVAL;
		}
	}
	else AtalkDumpInterval = ATALK_TIMER_NO_REQUEUE;

	return AtalkDumpInterval;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkind.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkind.c

Abstract:

	This module contains the Appletalk Internal Indication support.

Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)
	Jameel Hyder (jameelh@microsoft.com)

Revision History:
	22	Oct 1993		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ATKIND


ATALK_ERROR
AtalkIndAtpPkt(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				pLookahead,
	IN		USHORT				PktLen,
	IN	OUT	PUINT				pXferOffset,
	IN		PBYTE				pLinkHdr,
	IN		BOOLEAN				ShortDdpHdr,
	OUT		PBYTE				pSubType,
	OUT		PBYTE			* 	ppPacket,
	OUT		PNDIS_PACKET	*	pNdisPkt
	)
/*++

Routine Description:

	This routine clumps together DDP and ATP packet in functionality for
	optimizing response packet reception.

Arguments:


Return Value:


--*/
{
	USHORT			dgramLen, hopCnt;
	ATALK_ADDR		destAddr, srcAddr;
	PBYTE			pAtpHdr, pDdpPkt;

	//	Only for localtalk
	BYTE			alapSrcNode=0;
	BYTE			alapDestNode=0;
	NDIS_STATUS		ndisStatus;
	PNDIS_PACKET	ndisPkt;
	PNDIS_BUFFER	ndisBuffer=NULL;
	USHORT			atpDataSize, DataSize;
	USHORT			seqNum, tid, startOffset;
	BYTE			controlInfo, function, eomFlag;
	BYTE			RespType;
	PPROTOCOL_RESD  protocolResd;		// Protocolresd field in ndisPkt

	PATP_ADDROBJ	pAtpAddrObj;
	PATP_REQ		pAtpReq;

	BOOLEAN			refAtpAddr 	= FALSE, refAtpReq = FALSE;
	BOOLEAN			Deref = FALSE;
	ATALK_ERROR		error = ATALK_NO_ERROR;
#ifdef	PROFILING
	LARGE_INTEGER	TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	do
	{
#if 0	// Receive indication has already verified this !!
		//	If we dont have atleast the ddp header and atp header, we
		//	cant figure much out.
		if (LookaheadLen < ((ShortDdpHdr ? SDDP_HDR_LEN : LDDP_HDR_LEN) + ATP_HEADER_SIZE))
		{
			error 	= ATALK_FAILURE;
			break;
		}

		if (PktLen > (MAX_DGRAM_SIZE + LDDP_HDR_LEN))
		{
			error	= ATALK_INVALID_PKT;
			break;
		}
#endif
		//	Short and long header formats have the length in the same place,
		pDdpPkt	 = pLookahead;
		dgramLen = DDP_GET_LEN(pDdpPkt);
		hopCnt	 = DDP_GET_HOP_COUNT(pDdpPkt);

		//	Is the packet too long?
		if ((hopCnt > RTMP_MAX_HOPS) || (dgramLen > PktLen))
		{
			error	= ATALK_INVALID_PKT;
			break;
		}

		switch (pPortDesc->pd_NdisPortType)
		{
		  case NdisMedium802_5:
		  case NdisMedium802_3:
		  case NdisMediumFddi:

			//	Check the length.
			if ((dgramLen < LDDP_HDR_LEN) ||
				(dgramLen > (MAX_DGRAM_SIZE + LDDP_HDR_LEN)))
			{
				error	= ATALK_INVALID_PKT;
				break;
			}

			pAtpHdr		= pDdpPkt + LDDP_HDR_LEN;
			atpDataSize	= dgramLen 	- (LDDP_HDR_LEN + ATP_HEADER_SIZE);
			break;
	
		  case NdisMediumLocalTalk:
	
			if (ShortDdpHdr)
			{
				//	Short DDP header! If we are not the default port, dont indicate
				//	packet, as we shouldn't be routing it to the default port, on
				//	which all our cached sockets reside.
				if (!DEF_PORT(pPortDesc))
				{
					error = ATALK_FAILURE;
					break;
				}
	
				if ((alapDestNode = *(pLinkHdr + ALAP_DEST_OFFSET)) == ATALK_BROADCAST_NODE)
				{
					error = ATALK_FAILURE;
					break;
				}
				else if (alapDestNode != NODE_ON_NONEXTPORT(pPortDesc))
				{
					error = ATALK_FAILURE;
					break;
				}

				alapSrcNode = *(pLinkHdr + ALAP_SRC_OFFSET);

				if ((dgramLen < SDDP_HDR_LEN) ||
					(dgramLen > MAX_DGRAM_SIZE + SDDP_HDR_LEN))
				{
					error = ATALK_INVALID_PKT;
					break;
				}
	
				pAtpHdr	= pDdpPkt 	+ SDDP_HDR_LEN;
				atpDataSize	= dgramLen 	- (SDDP_HDR_LEN + ATP_HEADER_SIZE);
			}
			else
			{
				pAtpHdr	= pDdpPkt + LDDP_HDR_LEN;
				atpDataSize	= dgramLen 	- (LDDP_HDR_LEN + ATP_HEADER_SIZE);
			}
			break;
	
		  default:
			KeBugCheck(0);
			break;
		}

		if (!ATALK_SUCCESS(error))
		{
			break;
		}

		DataSize	= atpDataSize + ATP_HEADER_SIZE;
		pDdpPkt += 2;
		if (ShortDdpHdr)
		{
			destAddr.ata_Node  	= alapDestNode;
			srcAddr.ata_Network = destAddr.ata_Network = NET_ON_NONEXTPORT(pPortDesc);
			srcAddr.ata_Node 	= alapSrcNode;

			//	Get the socket numbers from the ddp header.
			destAddr.ata_Socket = *pDdpPkt++;
			srcAddr.ata_Socket	= *pDdpPkt;

			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
					("AtalkDdpPacketIn: NonExtended Dest Net.Node %lx.%lx\n",
					destAddr.ata_Network, destAddr.ata_Node));

			//	Now the destination node address could be
			//	ALAP_BROADCAST_NODE (0xFF).
			if ((srcAddr.ata_Node < MIN_USABLE_ATALKNODE) ||
				(srcAddr.ata_Node > MAX_USABLE_ATALKNODE) ||
				(destAddr.ata_Node == UNKNOWN_NODE))
			{
				error	= ATALK_INVALID_PKT;
				break;
			}

			if (destAddr.ata_Node == ATALK_BROADCAST_NODE)
			{
				error = ATALK_FAILURE;
				break;
			}
		}
		else
		{
			//	If we have a checksum, we cannot optimize.
			if ((*pDdpPkt++ != 0) || (*pDdpPkt++ != 0))
			{
				error = ATALK_FAILURE;
				break;
			}

			//	Build full source and destination AppleTalk address structures
			//	from our DDP header.
			GETSHORT2SHORT(&destAddr.ata_Network, pDdpPkt);
			pDdpPkt += 2;

			GETSHORT2SHORT(&srcAddr.ata_Network, pDdpPkt);
			pDdpPkt += 2;

			destAddr.ata_Node 	= *pDdpPkt++;
			srcAddr.ata_Node 	= *pDdpPkt++;
			destAddr.ata_Socket	= *pDdpPkt++;
			srcAddr.ata_Socket 	= *pDdpPkt;

			if (destAddr.ata_Node == ATALK_BROADCAST_NODE)
			{
				error = ATALK_FAILURE;
				break;
			}

			//	Do we like what we see?  Note "nnnn00" is now allowed and used by NBP.
			
			if ((srcAddr.ata_Network > LAST_VALID_NETWORK)	||
				(srcAddr.ata_Network < FIRST_VALID_NETWORK) ||
				(srcAddr.ata_Node < MIN_USABLE_ATALKNODE)	||
				(srcAddr.ata_Node > MAX_USABLE_ATALKNODE))
			{
				error = ATALK_INVALID_PKT;
				break;
			}
		} 	//	Long DDP header
	} while (FALSE);

	if (!ATALK_SUCCESS(error))
	{
		DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_WARN,
				("AtalkDdpPacketIn: drop packet in indication%lx\n", error));

		return error;
	}

	//	Now for the ATP processing. We need to copy header into ndispkt.
	//	Get the static fields from the ATP header.
	controlInfo = pAtpHdr[ATP_CMD_CONTROL_OFF];
	function = (controlInfo & ATP_FUNC_MASK);
	eomFlag = ((controlInfo & ATP_EOM_MASK) != 0);

	//	Get the sequence number
	seqNum = (USHORT)(pAtpHdr[ATP_SEQ_NUM_OFF]);

	//	Get the transaction id
	GETSHORT2SHORT(&tid, &pAtpHdr[ATP_TRANS_ID_OFF]);

	DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
			("AtalkIndAtpPkt: Packet tid %x func %x ctrlinfo %x\n",
			tid, function, controlInfo));

	do
	{
		//	See if we have a a cached ATP address for this destination address.
		AtalkIndAtpCacheLkUpSocket(&destAddr, &pAtpAddrObj, &error);
		if (!ATALK_SUCCESS(error))
		{
			error = ATALK_FAILURE;
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkIndAtpPkt: CacheLkup failed - tid %x, func %x, ctrlinfo %x\n",
					tid, function, controlInfo));
			break;
		}

		refAtpAddr = TRUE;

		if (function != ATP_RESPONSE) // Is this a request or a release?
		{
			PBYTE				packet;
			PBUFFER_HDR			pBufferHdr = NULL;
			PPROTOCOL_RESD  	protocolResd;
			BLKID				BlkId;

			//	Allocate a small or large ddp buffer as appropriate.
			BlkId = BLKID_DDPSM;
			if (DataSize > (sizeof(DDP_SMBUFFER) - sizeof(BUFFER_HDR)))
				BlkId = BLKID_DDPLG;

			if ((pBufferHdr = (PBUFFER_HDR)AtalkBPAllocBlock(BlkId)) == NULL)
			{
				error = ATALK_FAILURE;
				break;
			}

			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
					("AtalkIndAtpPkt: Indicating request\n"));

			//	Setup the ndis packet.
			packet		= (PBYTE)pBufferHdr + sizeof(BUFFER_HDR);
		
			//  Get a pointer to the NDIS packet descriptor from the buffer header.
			ndisPkt			= pBufferHdr->bh_NdisPkt;
			protocolResd 	= (PPROTOCOL_RESD)(ndisPkt->ProtocolReserved);

			//	All set! Set appropriate values in the packet descriptor.
			protocolResd->Receive.pr_OptimizeType	= INDICATE_ATP;
			protocolResd->Receive.pr_OptimizeSubType= ATP_ALLOC_BUF;
			protocolResd->Receive.pr_AtpAddrObj		= pAtpAddrObj;
			protocolResd->Receive.pr_SrcAddr		= srcAddr;
			protocolResd->Receive.pr_DestAddr		= destAddr;
			protocolResd->Receive.pr_DataLength		= DataSize;
			protocolResd->Receive.pr_OptimizeCtx	= (PVOID)NULL;
			protocolResd->Receive.pr_OffCablePkt	= (BOOLEAN)(hopCnt > 0);

			*pNdisPkt	= ndisPkt;
			*ppPacket	= packet;
			*pSubType	= function;
			*pXferOffset += (ShortDdpHdr ? SDDP_HDR_LEN : LDDP_HDR_LEN);

			//	Done, break out.
			error = ATALK_NO_ERROR;
			break;
		}

		ASSERT (function == ATP_RESPONSE);

		DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
				("AtalkIndAtpPkt: RESPONSE SeqNum %d tid %lx\n", seqNum, tid));

		if (seqNum > (ATP_MAX_RESP_PKTS-1))
		{
			error	= ATALK_INVALID_PKT;
			break;
		}

		//	See if there is a pending request.
		ACQUIRE_SPIN_LOCK_DPC(&pAtpAddrObj->atpao_Lock);
		atalkAtpReqReferenceByAddrTidDpc(pAtpAddrObj,
										 &srcAddr,
										 tid,
										 &pAtpReq,
										 &error);
		RELEASE_SPIN_LOCK_DPC(&pAtpAddrObj->atpao_Lock);

		if (!ATALK_SUCCESS(error))
		{
			//	We dont have a corresponding pending request. Ignore.
			DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_ERR,
					("AtalkIndAtpPkt: NO pending request for tid %lx\n", tid));
			error	= ATALK_DUP_PKT;	// Do not add this to dropped packet statistic
			break;
		}

		refAtpReq = TRUE;

		do
		{
			//	Check the request bitmap, which could be zero if the user only
			//	wanted the user bytes and passed in a null response buffer.
			//	Do we want to keep this response? Check the corresponding
			//	bit in our current bitmap set.
			ACQUIRE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

			pAtpReq->req_Flags |= ATP_REQ_REMOTE;

			do
			{
				if (((pAtpReq->req_RecdBitmap & AtpBitmapForSeqNum[seqNum]) != 0) ||
					((pAtpReq->req_Bitmap & AtpBitmapForSeqNum[seqNum]) == 0))
				{
					error	= ATALK_DUP_PKT;	// Not an error condition
					break;
				}

				if (atpDataSize > 0)
				{
					startOffset = (USHORT)seqNum * pAtpAddrObj->atpao_MaxSinglePktSize;
					if (pAtpReq->req_RespBufLen < (startOffset + atpDataSize))
					{
						error = ATALK_FAILURE;
						break;
					}
				}

				//	If we are the first packet, copy the response user bytes.
				if (seqNum == 0)
				{
					DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
							("AtalkIndAtpPkt: Copying user bytes for tid %x\n", tid));
					RtlCopyMemory(pAtpReq->req_RespUserBytes,
								  pAtpHdr + ATP_USER_BYTES_OFF,
								  ATP_USERBYTES_SIZE);
				}

				// If this response packet does not cause the req_Bitmap to go to ZERO
				// i.e. we have not recvd. all the packets, just copy the data into
				// user's buffer, adjust the bitmaps (req_Bitmap & req_RecdBitmap) and
				// not indicate this packet up to Atp.
				pAtpReq->req_RecdBitmap |= AtpBitmapForSeqNum[seqNum];
				pAtpReq->req_Bitmap &= ~AtpBitmapForSeqNum[seqNum];
				pAtpReq->req_RespRecdLen += atpDataSize;

				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
						("AtalkIndAtpPkt: Bitmap %x, RecdBitmap %x, RecdLen %d for tid %x\n",
						pAtpReq->req_Bitmap, pAtpReq->req_RecdBitmap,
						pAtpReq->req_RespRecdLen, tid));

				//	Now if eom is set, we need to reset all high order bits
				//	of the req_Bitmap. req_RecdBitmap should now indicate all
				//	the buffers we received. The two should be mutually exclusive
				//	at this point.
				if (eomFlag)
				{
					pAtpReq->req_Bitmap &= AtpEomBitmapForSeqNum[seqNum];
					ASSERT((pAtpReq->req_Bitmap & pAtpReq->req_RecdBitmap) == 0);
				}

				RespType = ATP_USER_BUF;
				if (pAtpReq->req_Bitmap != 0)
				{
					RespType = ATP_USER_BUFX;
					Deref = TRUE;
				}
				else
				{
					pAtpReq->req_Flags |= ATP_REQ_RESPONSE_COMPLETE;
					DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
							("AtalkIndAtpPkt: LAST Response for tid %x\n", tid));
				}

				//	Allocate an NDIS packet descriptor.
				NdisDprAllocatePacket(&ndisStatus,
									  &ndisPkt,
									  AtalkNdisPacketPoolHandle);
				if (ndisStatus == NDIS_STATUS_SUCCESS)
				{
					RtlZeroMemory(ndisPkt->ProtocolReserved, sizeof(PROTOCOL_RESD));
					//	It will be freed by receive completion now.
					ndisBuffer = pAtpReq->req_NdisBuf[seqNum];
					pAtpReq->req_NdisBuf[seqNum]	= NULL;
				}
				else
				{
					error = ATALK_FAILURE;
					break;
				}
			} while (FALSE);

			RELEASE_SPIN_LOCK_DPC(&pAtpReq->req_Lock);

			if (!ATALK_SUCCESS(error))
			{
				break;
			}

			//	Copy the data into the users buffer. Check if there's room.
			if ((atpDataSize > 0) || (ndisBuffer != NULL))
			{
				if (ndisBuffer == NULL)
				{
					//	Allocate an NDIS buffer descriptor and chain into pkt desc.
					NdisCopyBuffer(&ndisStatus,
								   &ndisBuffer,
								   AtalkNdisBufferPoolHandle,
								   (PVOID)pAtpReq->req_RespBuf,
								   startOffset,  			//	Offset
								   (UINT)atpDataSize);
	
					if (ndisStatus != NDIS_STATUS_SUCCESS)
					{
						NdisDprFreePacket(ndisPkt);
	
						error = ATALK_FAILURE;
						break;
					}

                    ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);
				}

				//	Chain in the buffer.
				NdisChainBufferAtBack(ndisPkt, ndisBuffer);
			}

			//	All set! Set appropriate values in the packet descriptor.
			protocolResd 	= (PPROTOCOL_RESD)&ndisPkt->ProtocolReserved;
			protocolResd->Receive.pr_OptimizeType	= INDICATE_ATP;
			protocolResd->Receive.pr_OptimizeSubType= RespType;
			protocolResd->Receive.pr_AtpAddrObj		= pAtpAddrObj;
			protocolResd->Receive.pr_SrcAddr		= srcAddr;
			protocolResd->Receive.pr_DestAddr		= destAddr;
			protocolResd->Receive.pr_DataLength		= atpDataSize;
			protocolResd->Receive.pr_OptimizeCtx	= (PVOID)pAtpReq;
			protocolResd->Receive.pr_OffCablePkt	= (BOOLEAN)(hopCnt > 0);

			// Do not copy the Atp header unless AtalkAtpPacketIn will be called.
			if (RespType == ATP_USER_BUF)
			{
				ATALK_RECV_INDICATION_COPY(pPortDesc,
										   protocolResd->Receive.pr_AtpHdr,
										   pAtpHdr,
										   ATP_HEADER_SIZE);
				DBGPRINT(DBG_COMP_ATP, DBG_LEVEL_INFO,
						("AtalkIndAtpPkt: Last packet for request, indicating tid %x\n", tid));
			}
	
			*pNdisPkt = ndisPkt;
			*ppPacket = NULL;
			*pSubType = function;
			*pXferOffset += ((ShortDdpHdr ? SDDP_HDR_LEN : LDDP_HDR_LEN) + ATP_HEADER_SIZE);
		} while (FALSE);
	} while (FALSE);

	if (!ATALK_SUCCESS(error) || Deref)
	{
		if (refAtpReq)
		{
			AtalkAtpReqDereferenceDpc(pAtpReq);
		}

		if (refAtpAddr)
		{
			AtalkAtpAddrDereferenceDpc(pAtpAddrObj);
		}
	}

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_AtpIndicationProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC(&AtalkStatistics.stat_AtpNumIndications,
								   &AtalkStatsLock.SpinLock);
#endif

	return error;
}


ATALK_ERROR
AtalkIndAtpCacheSocket(
	IN	PATP_ADDROBJ		pAtpAddr,
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

	Cache ATP socket routine. Have another one for ADSP when that is done.

Arguments:


Return Value:

	None
--*/
{
	USHORT			i;
	KIRQL			OldIrql;
	PDDP_ADDROBJ	pDdpAddr;
	ATALK_ERROR		error = ATALK_FAILURE;

	//	Only cache if the net and node match the current net and node.
	ACQUIRE_SPIN_LOCK(&AtalkSktCacheLock, &OldIrql);
	pDdpAddr	= pAtpAddr->atpao_DdpAddr;

	if ((AtalkSktCache.ac_Network == 0)	&&
		(AtalkSktCache.ac_Node == 0)	&&
		(AtalkDefaultPort	== pPortDesc))
	{
		AtalkSktCache.ac_Network = pDdpAddr->ddpao_Addr.ata_Network;
		AtalkSktCache.ac_Node	 = pDdpAddr->ddpao_Addr.ata_Node;
	}

	if ((AtalkSktCache.ac_Network == pDdpAddr->ddpao_Addr.ata_Network) &&
		(AtalkSktCache.ac_Node == pDdpAddr->ddpao_Addr.ata_Node))
	{
		//	First try to get a free slot
		for (i = 0; i < ATALK_CACHE_SKTMAX; i++)
		{
			if (AtalkSktCache.ac_Cache[i].Type == ATALK_CACHE_NOTINUSE)
			{
				ASSERT(AtalkSktCache.ac_Cache[i].u.pAtpAddr	== NULL);

				//	Use this slot
				AtalkSktCache.ac_Cache[i].Type = (ATALK_CACHE_INUSE | ATALK_CACHE_ATPSKT);
				AtalkSktCache.ac_Cache[i].Socket = pDdpAddr->ddpao_Addr.ata_Socket;
	
				//	The caller must have referenced these before calling cache AND
				//	must called uncache before removing those references. Also, if we
				//	returned error from this routine, Caller must Dereference them.
				AtalkSktCache.ac_Cache[i].u.pAtpAddr	= pAtpAddr;
				error = ATALK_NO_ERROR;
				break;
			}
		}
	}
	RELEASE_SPIN_LOCK(&AtalkSktCacheLock, OldIrql);

	return error;
}


VOID
AtalkIndAtpUnCacheSocket(
	IN	PATP_ADDROBJ		pAtpAddr
	)
/*++

Routine Description:

	Cache ATP socket routine. Have another one for ADSP when that is done.

Arguments:


Return Value:

	None
--*/
{
	USHORT	i;
	KIRQL	OldIrql;

	ACQUIRE_SPIN_LOCK(&AtalkSktCacheLock, &OldIrql);
	for (i = 0; i < ATALK_CACHE_SKTMAX; i++)
	{
		if ((AtalkSktCache.ac_Cache[i].Type == (ATALK_CACHE_INUSE | ATALK_CACHE_ATPSKT)) &&
			(AtalkSktCache.ac_Cache[i].Socket == pAtpAddr->atpao_DdpAddr->ddpao_Addr.ata_Socket))
		{
			ASSERT(AtalkSktCache.ac_Cache[i].u.pAtpAddr	== pAtpAddr);
		
			AtalkSktCache.ac_Cache[i].Type = ATALK_CACHE_NOTINUSE;
			AtalkSktCache.ac_Cache[i].u.pAtpAddr = NULL;
			break;
		}
	}

	if (i == ATALK_CACHE_SKTMAX)
	{
		//	We didnt find the socket! References will get all messed up!
		ASSERT(0);
	}

	RELEASE_SPIN_LOCK(&AtalkSktCacheLock, OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkact.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkact.c

Abstract:

	This module contains the TDI action support code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ATKACT

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE_NZ, AtalkNbpTdiAction)
#pragma alloc_text(PAGE_NZ, AtalkZipTdiAction)
#pragma alloc_text(PAGE, AtalkAspTdiAction)
#pragma alloc_text(PAGE, AtalkAdspTdiAction)
#pragma alloc_text(PAGE_PAP, AtalkPapTdiAction)
#pragma alloc_text(PAGEASPC, AtalkAspCTdiAction)
#endif

ATALK_ERROR
AtalkStatTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	struct _ActionReq *	pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for Statistics TdiAction call. There are no input parameters.
 	The statistics structure is returned.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR			Error = ATALK_NO_ERROR;
	PPORT_DESCRIPTOR	pPortDesc;
	KIRQL				OldIrql;
	ULONG				BytesCopied;
	LONG				Offset;

	if (pActReq->ar_MdlSize < (SHORT)(sizeof(ATALK_STATS) +
								 sizeof(ATALK_PORT_STATS) * AtalkNumberOfPorts))
		Error = ATALK_BUFFER_TOO_SMALL;
	else
	{
#ifdef	PROFILING
		//	This is the only place where this is changed. And it always increases.
		//	Also the stats are changed using ExInterlocked calls. Acquiring a lock
		//	does little in terms of protection anyways.
		AtalkStatistics.stat_ElapsedTime = AtalkTimerCurrentTick/ATALK_TIMER_FACTOR;
#endif
		TdiCopyBufferToMdl(&AtalkStatistics,
						   0,
						   sizeof(ATALK_STATS),
						   pActReq->ar_pAMdl,
						   0,
						   &BytesCopied);
		ASSERT(BytesCopied == sizeof(ATALK_STATS));

		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

		for (pPortDesc = AtalkPortList, Offset = sizeof(ATALK_STATS);
			 pPortDesc != NULL;
			 pPortDesc = pPortDesc->pd_Next)
		{
			TdiCopyBufferToMdl(&pPortDesc->pd_PortStats,
							   0,
							   sizeof(ATALK_PORT_STATS),
							   pActReq->ar_pAMdl,
							   Offset,
							   &BytesCopied);
			Offset += sizeof(ATALK_PORT_STATS);
			ASSERT(BytesCopied == sizeof(ATALK_PORT_STATS));
		}

		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);
	}
	
	(*pActReq->ar_Completion)(Error, pActReq);
	return ATALK_PENDING;
}


ATALK_ERROR
AtalkNbpTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for NBP TdiAction calls. The parameters are validated and
 	the calls are dispacthed to the appropriate NBP routines.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR		error = ATALK_NO_ERROR;
	PDDP_ADDROBJ	pDdpAddr;
	PNBPTUPLE		pNbpTuple;

	PAGED_CODE ();

	// Lock the Nbp stuff, if this is the first nbp action
	AtalkLockNbpIfNecessary();

	ASSERT (VALID_ACTREQ(pActReq));
	// First get the Ddp address out of the pObject for the device
	switch (pActReq->ar_DevType)
	{
	  case ATALK_DEV_DDP:
		pDdpAddr = (PDDP_ADDROBJ)pObject;
  		break;

	  case ATALK_DEV_ASPC:
		pDdpAddr = AtalkAspCGetDdpAddress((PASPC_ADDROBJ)pObject);
		break;

	  case ATALK_DEV_ASP:
  		pDdpAddr = AtalkAspGetDdpAddress((PASP_ADDROBJ)pObject);
		break;

	  case ATALK_DEV_PAP:
 		pDdpAddr = AtalkPapGetDdpAddress((PPAP_ADDROBJ)pObject);
		break;

	  case ATALK_DEV_ADSP:
 		pDdpAddr = AtalkAdspGetDdpAddress((PADSP_ADDROBJ)pObject);
		break;

	  default:
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkNbpTdiAction: Invalid device type !!\n"));
		error = ATALK_INVALID_REQUEST;
		break;
	}

	// reference the Ddp address.
	if ((pActReq->ar_ActionCode == COMMON_ACTION_NBPREGISTER_BY_ADDR) ||
		(pActReq->ar_ActionCode == COMMON_ACTION_NBPREMOVE_BY_ADDR))
	{
		// In this case, we don't want to access the object related to
		// the filehandle in the IO request, we want to access the object
		// related to a specific user socket address.
		pNbpTuple = (PNBPTUPLE)(&((PNBP_REGDEREG_PARAMS)(pActReq->ar_pParms))->RegisterTuple);
		AtalkDdpReferenceByAddr(AtalkDefaultPort,
								&(pNbpTuple->tpl_Address),
								&pDdpAddr,
								&error);
	}
	else
	{
		AtalkDdpReferenceByPtr(pDdpAddr, &error);
	}

	if (!ATALK_SUCCESS(error))
	{
		AtalkUnlockNbpIfNecessary();
		return error;
	}

	// Call Nbp to do the right stuff
	switch (pActReq->ar_ActionCode)
	{
	  case COMMON_ACTION_NBPLOOKUP:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_LOOKUP_PARAMS)(pActReq->ar_pParms))->LookupTuple);
		error = AtalkNbpAction(pDdpAddr,
							   FOR_LOOKUP,
							   pNbpTuple,
							   pActReq->ar_pAMdl,
							   (USHORT)(pActReq->ar_MdlSize/sizeof(NBPTUPLE)),
							   pActReq);
		break;

	  case COMMON_ACTION_NBPCONFIRM:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_CONFIRM_PARAMS)(pActReq->ar_pParms))->ConfirmTuple);
		error = AtalkNbpAction(pDdpAddr,
							   FOR_CONFIRM,
							   pNbpTuple,
							   NULL,
							   0,
							   pActReq);
		break;

	  case COMMON_ACTION_NBPREGISTER:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_REGDEREG_PARAMS)(pActReq->ar_pParms))->RegisterTuple);
		error = AtalkNbpAction(pDdpAddr,
								FOR_REGISTER,
								pNbpTuple,
								NULL,
								0,
								pActReq);
  		break;

	  case COMMON_ACTION_NBPREMOVE:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_REGDEREG_PARAMS)(pActReq->ar_pParms))->RegisteredTuple);
		error = AtalkNbpRemove(pDdpAddr,
							   pNbpTuple,
							   pActReq);
		break;

	  case COMMON_ACTION_NBPREGISTER_BY_ADDR:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_REGDEREG_PARAMS)(pActReq->ar_pParms))->RegisterTuple);
		error = AtalkNbpAction(pDdpAddr,
							   FOR_REGISTER,
							   pNbpTuple,
							   NULL,
							   0,
							   pActReq);
  		break;

	  case COMMON_ACTION_NBPREMOVE_BY_ADDR:
		pNbpTuple = (PNBPTUPLE)(&((PNBP_REGDEREG_PARAMS)(pActReq->ar_pParms))->RegisteredTuple);
		error = AtalkNbpRemove(pDdpAddr,
							   pNbpTuple,
							   pActReq);
		break;

	  default:
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkNbpTdiAction: Invalid Nbp Action !!\n"));
		error = ATALK_INVALID_REQUEST;
		break;
	}

	AtalkDdpDereference(pDdpAddr);

	if (error != ATALK_PENDING)
	{
		AtalkUnlockNbpIfNecessary();
	}

	return error;
}




ATALK_ERROR
AtalkZipTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for ZIP TdiAction calls. The parameters are validated and
 	the calls are dispacthed to the appropriate ZIP routines.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR			error = ATALK_INVALID_PARAMETER;
	PPORT_DESCRIPTOR	pPortDesc = AtalkDefaultPort;
	PWCHAR				PortName = NULL;
    USHORT              PortNameLen;
	UNICODE_STRING		AdapterName, UpcaseAdapterName;
	WCHAR				UpcaseBuffer[MAX_INTERNAL_PORTNAME_LEN];
	KIRQL				OldIrql;
	int					i;

	PAGED_CODE ();

	// Lock the Zip stuff, if this is the first zip action
	AtalkLockZipIfNecessary();
	
	ASSERT (VALID_ACTREQ(pActReq));
	if ((pActReq->ar_ActionCode == COMMON_ACTION_ZIPGETLZONESONADAPTER) ||
		(pActReq->ar_ActionCode == COMMON_ACTION_ZIPGETADAPTERDEFAULTS))
	{
		// Map the port name to the port descriptor
		if ((pActReq->ar_pAMdl != NULL) && (pActReq->ar_MdlSize > 0))
		{
			PortName = (PWCHAR)AtalkGetAddressFromMdlSafe(
					pActReq->ar_pAMdl,
					NormalPagePriority);

		}

		if (PortName == NULL)
        {
            AtalkUnlockZipIfNecessary();
            return ATALK_INVALID_PARAMETER;
        }

        PortNameLen = pActReq->ar_MdlSize/sizeof(WCHAR);

        // make sure there is a NULL char in the buffer
        for (i=0; i<PortNameLen; i++)
        {
            if (PortName[i] == UNICODE_NULL)
            {
                break;
            }
        }

        // didn't find null char within limit?  bad parameter..
        if (i >= MAX_INTERNAL_PORTNAME_LEN)
        {
		    DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkZipTdiAction: port name too big (%d) for %lx\n",PortNameLen,PortName));

            ASSERT(0);
            return ATALK_INVALID_PARAMETER;
        }

        PortNameLen = (USHORT)i;

		AdapterName.Buffer = PortName;
		AdapterName.Length = (PortNameLen)*sizeof(WCHAR);
		AdapterName.MaximumLength = (PortNameLen+1)*sizeof(WCHAR);

		UpcaseAdapterName.Buffer = UpcaseBuffer;
		UpcaseAdapterName.Length =
		UpcaseAdapterName.MaximumLength = sizeof(UpcaseBuffer);
		RtlUpcaseUnicodeString(&UpcaseAdapterName,
							   &AdapterName,
							   FALSE);

		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

		// Find the port corres. to the port descriptor
		for (pPortDesc = AtalkPortList;
			 pPortDesc != NULL;
			 pPortDesc = pPortDesc->pd_Next)
		{
			if ((UpcaseAdapterName.Length == pPortDesc->pd_AdapterName.Length) &&
				RtlEqualMemory(UpcaseAdapterName.Buffer,
							   pPortDesc->pd_AdapterName.Buffer,
							   UpcaseAdapterName.Length))
			{
				break;
			}
		}

		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

		if (pPortDesc == NULL)
        {
            AtalkUnlockZipIfNecessary();
            return ATALK_INVALID_PARAMETER;
        }
	}
	else if (pActReq->ar_ActionCode == COMMON_ACTION_ZIPGETZONELIST)
	{
			PPORT_DESCRIPTOR	pTempPortDesc = NULL;

			// This is to take care of cases when zone list is requested
			// but the default adapter has gone away during PnP, and
			// AtalkDefaultPort points to NULL
			if (pPortDesc == NULL)
			{
				DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
					("COMMON_ACTION_ZIPGETZONELIST: PortDesc points to NULL\n"));
			    AtalkUnlockZipIfNecessary();
			    return ATALK_PORT_INVALID;
			}

			// Check if the AtalkDefaultPort is still in the list
			// It is possible that AtalkDefaultPort holds a non-NULL value, but
			// the adapter has gone away during a PnP

			ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

			// Find the port corres. to the port descriptor
			for (pTempPortDesc = AtalkPortList;
			 	pTempPortDesc != NULL;
			 	pTempPortDesc = pTempPortDesc->pd_Next)
			{
					if (pTempPortDesc == pPortDesc)
					{
						break;
					}
			}

			RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

			if (pTempPortDesc == NULL)
       		{
				DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
					("COMMON_ACTION_ZIPGETZONELIST: PortDesc structure has gone away during PnP\n"));
            	AtalkUnlockZipIfNecessary();
            	return ATALK_PORT_INVALID;
        	}
	}

	switch (pActReq->ar_ActionCode)
	{
	  case COMMON_ACTION_ZIPGETMYZONE:
		error = AtalkZipGetMyZone( pPortDesc,
								   TRUE,
								   pActReq->ar_pAMdl,
								   pActReq->ar_MdlSize,
								   pActReq);
		break;

	  case COMMON_ACTION_ZIPGETZONELIST:
		error = AtalkZipGetZoneList(pPortDesc,
									FALSE,
									pActReq->ar_pAMdl,
									pActReq->ar_MdlSize,
									pActReq);
		break;

	  case COMMON_ACTION_ZIPGETADAPTERDEFAULTS:
		// Copy the network range from the port and fall through
		((PZIP_GETPORTDEF_PARAMS)(pActReq->ar_pParms))->NwRangeLowEnd =
							pPortDesc->pd_NetworkRange.anr_FirstNetwork;
		((PZIP_GETPORTDEF_PARAMS)(pActReq->ar_pParms))->NwRangeHighEnd =
							pPortDesc->pd_NetworkRange.anr_LastNetwork;

		error = AtalkZipGetMyZone(pPortDesc,
								  FALSE,
								  pActReq->ar_pAMdl,
								  pActReq->ar_MdlSize,
								  pActReq);
		break;

	  case COMMON_ACTION_ZIPGETLZONESONADAPTER:
	  case COMMON_ACTION_ZIPGETLZONES:
		error = AtalkZipGetZoneList(pPortDesc,
									TRUE,
									pActReq->ar_pAMdl,
									pActReq->ar_MdlSize,
									pActReq);
		break;

	  default:
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkZipTdiAction: Invalid Zip Action !!\n"));
		error = ATALK_INVALID_REQUEST;
		break;
	}

	if (error != ATALK_PENDING)
	{
		AtalkUnlockZipIfNecessary();
	}

	return error;
}




ATALK_ERROR
AtalkAspTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for ASP TdiAction calls. The parameters are validated and
 	the calls are dispacthed to the appropriate ASP routines.

 	The only ASP Action is: ASP_XCHG_ENTRIES

Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error = ATALK_INVALID_REQUEST;

	PAGED_CODE ();

	ASSERT(VALID_ACTREQ(pActReq));

	if (pActReq->ar_ActionCode == ACTION_ASP_BIND)
	{
		if (AtalkAspReferenceAddr((PASP_ADDROBJ)pObject) != NULL)
		{
			error = AtalkAspBind((PASP_ADDROBJ)pObject,
								 (PASP_BIND_PARAMS)(pActReq->ar_pParms),
								 pActReq);
			AtalkAspDereferenceAddr((PASP_ADDROBJ)pObject);	
		}
	}

	return error;
}




ATALK_ERROR
AtalkAdspTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for ADSP TdiAction calls. The parameters are validated and
 	the calls are dispacthed to the appropriate ADSP routines.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error = ATALK_NO_ERROR;

	PAGED_CODE ();

	ASSERT (VALID_ACTREQ(pActReq));

	return error;
}




ATALK_ERROR
AtalkAspCTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for ASP Client TdiAction calls. The parameters are validated
 	and the calls are dispatched to the appropriate ASP routines.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error = ATALK_NO_ERROR;
	PAMDL		pReplyMdl;
	ATALK_ADDR	atalkAddr;
	BOOLEAN		fWrite;

	PAGED_CODE ();

	ASSERT (VALID_ACTREQ(pActReq));

	switch (pActReq->ar_ActionCode)
	{
	  case ACTION_ASPCGETSTATUS:
  		AtalkAspCAddrReference((PASPC_ADDROBJ)pObject, &error);
		if (ATALK_SUCCESS(error))
		{
			TDI_TO_ATALKADDR(&atalkAddr,
							 &(((PASPC_GETSTATUS_PARAMS)pActReq->ar_pParms)->ServerAddr));

			error = AtalkAspCGetStatus((PASPC_ADDROBJ)pObject,
										&atalkAddr,
										pActReq->ar_pAMdl,
										pActReq->ar_MdlSize,
										pActReq);

			AtalkAspCAddrDereference((PASPC_ADDROBJ)pObject);
		}
		break;

	  case ACTION_ASPCCOMMAND:
	  case ACTION_ASPCWRITE:
		// Split the mdl into command and reply/write mdls. The already constructed mdl
		// serves as the command mdl
		// First validate that the sizes are valid
		if (pActReq->ar_MdlSize < (((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->CmdSize +
								   ((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->WriteAndReplySize))
		{
			error = ATALK_BUFFER_TOO_SMALL;
			break;
		}
		pReplyMdl = AtalkSubsetAmdl(pActReq->ar_pAMdl,
									((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->CmdSize,
									((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->WriteAndReplySize);
		if (pReplyMdl == NULL)
		{
			error = ATALK_RESR_MEM;
			break;
		}

		AtalkAspCConnReference((PASPC_CONNOBJ)pObject, &error);
		if (ATALK_SUCCESS(error))
		{
			fWrite = (pActReq->ar_ActionCode == ACTION_ASPCWRITE) ? TRUE : FALSE;
			error = AtalkAspCCmdOrWrite((PASPC_CONNOBJ)pObject,
										pActReq->ar_pAMdl,
										((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->CmdSize,
										pReplyMdl,
										((PASPC_COMMAND_OR_WRITE_PARAMS)pActReq->ar_pParms)->WriteAndReplySize,
										fWrite,
										pActReq);
			AtalkAspCConnDereference((PASPC_CONNOBJ)pObject);
		}
		break;

	  default:
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkAspCTdiAction: Invalid Asp Client Action !!\n"));
		error = ATALK_INVALID_REQUEST;
		break;
	}

	return error;
}




ATALK_ERROR
AtalkPapTdiAction(
	IN	PVOID				pObject,	// Address or Connection object
	IN	PACTREQ				pActReq		// Pointer to action request
	)
/*++

Routine Description:

 	This is the entry for PAP TdiAction calls. The parameters are validated and
 	the calls are dispacthed to the appropriate PAP routines.

Arguments:


Return Value:


--*/
{
	ATALK_ERROR	error;
	ATALK_ADDR	atalkAddr;

	PAGED_CODE ();

	ASSERT (VALID_ACTREQ(pActReq));

	switch (pActReq->ar_ActionCode)
	{
	  case ACTION_PAPGETSTATUSSRV:
  		AtalkPapAddrReference((PPAP_ADDROBJ)pObject, &error);
		if (ATALK_SUCCESS(error))
		{
			TDI_TO_ATALKADDR(
				&atalkAddr,
				&(((PPAP_GETSTATUSSRV_PARAMS)pActReq->ar_pParms)->ServerAddr));

			error = AtalkPapGetStatus((PPAP_ADDROBJ)pObject,
									   &atalkAddr,
									   pActReq->ar_pAMdl,
									   pActReq->ar_MdlSize,
									   pActReq);

			AtalkPapAddrDereference((PPAP_ADDROBJ)pObject);
		}
		break;

	  case ACTION_PAPSETSTATUS:
  		AtalkPapAddrReference((PPAP_ADDROBJ)pObject, &error);
		if (ATALK_SUCCESS(error))
		{
			error = AtalkPapSetStatus((PPAP_ADDROBJ)pObject,
										pActReq->ar_pAMdl,
										pActReq);
			AtalkPapAddrDereference((PPAP_ADDROBJ)pObject);
		}
		break;

	  case ACTION_PAPPRIMEREAD:
		AtalkPapConnReferenceByPtr((PPAP_CONNOBJ)pObject, &error);
		if (ATALK_SUCCESS(error))
		{
			error = AtalkPapPrimeRead((PPAP_CONNOBJ)pObject, pActReq);
			AtalkPapConnDereference((PPAP_CONNOBJ)pObject);
		}
		break;

	  default:
		DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_FATAL,
				("AtalkPapTdiAction: Invalid Pap Action !!\n"));
		error = ATALK_INVALID_REQUEST;
		break;
	}

	return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkdrvr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkdrvr.c

Abstract:

	This module implements Appletalk Transport Provider driver interfaces
	for NT

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include 	<atalk.h>
#pragma hdrstop

//	File module number for errorlogging
#define	FILENUM		ATKDRVR

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT	DriverObject,
	IN	PUNICODE_STRING RegistryPath
);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGEINIT, AtalkCleanup)
#pragma alloc_text(PAGE, atalkUnload)
#pragma alloc_text(PAGE, AtalkDispatchCreate)
#pragma alloc_text(PAGE, AtalkDispatchCleanup)
#pragma alloc_text(PAGE, AtalkDispatchClose)
#pragma alloc_text(PAGE, AtalkDispatchDeviceControl)
#endif

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT	DriverObject,
	IN	PUNICODE_STRING	RegistryPath
)
/*++

Routine Description:

	This is the initialization routine for the Windows NT Appletalk
	driver. This routine creates the device object for the Atalk
	device and performs all other driver initialization.

Arguments:

	DriverObject - Pointer to driver object created by the system.
	RegistryPath-  Path to the root of the section in the registry for this
					driver

Return Value:

	The function value is the final status from the initialization operation. If
	this is not STATUS_SUCCESS the driver will not load.

--*/
{
	NTSTATUS 		status;
	UNICODE_STRING	deviceName;
	USHORT			i, j;


	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("Appletalk DriverEntry - Entered !!!\n"));


    TdiInitialize();

    INITIALIZE_SPIN_LOCK(&AtalkStatsLock);

	INITIALIZE_SPIN_LOCK(&AtalkSktCacheLock);

	INITIALIZE_SPIN_LOCK(&ArapSpinLock);

#if DBG
    INITIALIZE_SPIN_LOCK(&AtalkDebugSpinLock);
#endif

	// Initialize event for locking/unlocking pageable sections. Set it to signalled state
	// so that the first wait is satisfied.
	KeInitializeMutex(&AtalkPgLkMutex, 0xFFFF);

	// Create the device object. (IoCreateDevice zeroes the memory
	// occupied by the object.)
	for (i = 0; i < ATALK_NO_DEVICES; i++)
	{
		RtlInitUnicodeString(&deviceName, AtalkDeviceNames[i]);
		status = IoCreateDevice(
					DriverObject,								// DriverObject
					ATALK_DEV_EXT_LEN,							// DeviceExtension
					&deviceName,								// DeviceName
					FILE_DEVICE_NETWORK,						// DeviceType
					FILE_DEVICE_SECURE_OPEN,					// DeviceCharacteristics
					(BOOLEAN)FALSE,								// Exclusive
					(PDEVICE_OBJECT *) &AtalkDeviceObject[i]);	// DeviceObject

		if (!NT_SUCCESS(status))
		{
			LOG_ERROR(EVENT_ATALK_CANT_CREATE_DEVICE, status, NULL, 0);

			//	Delete all the devices created so far, if any
			for (j = 0; j < i; j++)
			{
				IoDeleteDevice((PDEVICE_OBJECT)AtalkDeviceObject[j]);
			}

			return status;
		}

		//	Assumption:
		//	'i' will correspond to the Device type in the ATALK_DEVICE_TYPE enum
		AtalkDeviceObject[i]->Ctx.adc_DevType = (ATALK_DEV_TYPE)i;

		// Initialize the provider info and statistics structures for this device
		AtalkQueryInitProviderInfo((ATALK_DEV_TYPE)i,
									&AtalkDeviceObject[i]->Ctx.adc_ProvInfo);

#if 0
		// NOTE: Implement
		AtalkQueryInitProviderStatistics((ATALK_DEV_TYPE)i,
										 &AtalkDeviceObject[i]->Ctx.adc_ProvStats);
#endif
	}

	// Initialize the driver object for this driver's entry points.
	DriverObject->MajorFunction[IRP_MJ_CREATE]  = AtalkDispatchCreate;
	DriverObject->MajorFunction[IRP_MJ_CLEANUP] = AtalkDispatchCleanup;
	DriverObject->MajorFunction[IRP_MJ_CLOSE]   = AtalkDispatchClose;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = AtalkDispatchDeviceControl;
	DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = AtalkDispatchInternalDeviceControl;

	DriverObject->DriverUnload = atalkUnload;

	// Get lock handles to all the conditional pageable sections
	AtalkLockInit(&AtalkPgLkSection[NBP_SECTION], AtalkNbpAction);
	AtalkLockInit(&AtalkPgLkSection[ZIP_SECTION], AtalkZipGetMyZone);
	AtalkLockInit(&AtalkPgLkSection[TDI_SECTION], AtalkTdiCleanupAddress);
	AtalkLockInit(&AtalkPgLkSection[ATP_SECTION], AtalkAtpCloseAddress);
	AtalkLockInit(&AtalkPgLkSection[ASP_SECTION], AtalkAspCloseAddress);
	AtalkLockInit(&AtalkPgLkSection[PAP_SECTION], AtalkPapCleanupAddress);
	AtalkLockInit(&AtalkPgLkSection[ASPC_SECTION], AtalkAspCCloseAddress);
	AtalkLockInit(&AtalkPgLkSection[ADSP_SECTION], AtalkAdspCleanupAddress);
	AtalkLockInit(&AtalkPgLkSection[ROUTER_SECTION], AtalkRtmpPacketInRouter);
	AtalkLockInit(&AtalkPgLkSection[INIT_SECTION], AtalkInitRtmpStartProcessingOnPort);
	AtalkLockInit(&AtalkPgLkSection[ARAP_SECTION], ArapExchangeParms);
	AtalkLockInit(&AtalkPgLkSection[PPP_SECTION], AllocPPPConn);

	AtalkLockInitIfNecessary();

	status = AtalkInitializeTransport(DriverObject, RegistryPath);

	AtalkUnlockInitIfNecessary();

	if (!NT_SUCCESS(status))
	{
#if	DBG
		// Make sure we are not unloading with any locked sections
		for (i = 0; i < LOCKABLE_SECTIONS; i++)
		{
			ASSERT (AtalkPgLkSection[i].ls_LockCount == 0);
		}
#endif
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("DriverEntry: AtalkInitializeTransport failed %lx\n",status));
	}
	else
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("DriverEntry: AtalkInitializeTransport complete %lx\n",status));
	}

	return status;
} // DriverEntry




NTSTATUS
AtalkDispatchCreate(
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			pIrp
)
/*++

Routine Description:

	This is the dispatch routine for Create functions for the Appletalk driver.

Arguments:

	DeviceObject - Pointer to device object for target device

	pIrp - Pointer to I/O request packet

Return Value:

	NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
	NTSTATUS					status;
	PIO_STACK_LOCATION 			pIrpSp;
	PFILE_FULL_EA_INFORMATION 	ea;

	INT 						createObject;
	TA_APPLETALK_ADDRESS		tdiAddress;
	CONNECTION_CONTEXT			connectionContext;
	PATALK_DEV_OBJ				atalkDeviceObject;

	UCHAR						protocolType, socketType;

	DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_INFO,
			("AtalkDispatchCreate: entered for irp %lx\n", pIrp));

	// Make sure status information is consistent every time.
	IoMarkIrpPending(pIrp);
	pIrp->IoStatus.Status = STATUS_PENDING;
	pIrp->IoStatus.Information = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	atalkDeviceObject = (PATALK_DEV_OBJ)DeviceObject;

	//  Both opens must complete synchronously. It is possible we return
	//  status_pending to the system, but it will not return to the caller
	//  until the call actually completes. In our case, we block until the
	//	actions are complete. So we can be assured that we can complete the irp
	//	upon return from these calls.

	createObject = AtalkIrpGetEaCreateType(pIrp);
	ea = (PFILE_FULL_EA_INFORMATION)pIrp->AssociatedIrp.SystemBuffer;

	switch (createObject)
	{
	  case TDI_TRANSPORT_ADDRESS_FILE :
		if (ea->EaValueLength < sizeof(TA_APPLETALK_ADDRESS))
		{

			DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_ERR,
					("AtalkDispatchCreate: addr size %d\n", ea->EaValueLength));

			status = STATUS_EA_LIST_INCONSISTENT;
			break;
		}

		//  We have the AtalkTdiOpenAddress routine look at only the first
		//  address in the list of addresses by casting the passed address
		//  to TA_APPLETALK_ADDRESS.
		RtlCopyMemory(
			&tdiAddress,
			(PBYTE)(&ea->EaName[ea->EaNameLength+1]),
			sizeof(TA_APPLETALK_ADDRESS));

		//  Also, get the protocol type field for the socket
		DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_INFO,
				("AtalkDispatchCreate: Remaining File Name : %S\n",
				&pIrpSp->FileObject->FileName));

		if (!NT_SUCCESS(AtalkGetProtocolSocketType(&atalkDeviceObject->Ctx,
												   &pIrpSp->FileObject->FileName,
												   &protocolType,
												   &socketType)))
		{
			status = STATUS_NO_SUCH_DEVICE;
			break;
		}

		status = AtalkTdiOpenAddress(
					pIrp,
					pIrpSp,
					&tdiAddress,
					protocolType,
					socketType,
					&atalkDeviceObject->Ctx);

		break;

	  case TDI_CONNECTION_FILE :
		if (ea->EaValueLength < sizeof(CONNECTION_CONTEXT))
		{

			DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_ERR,
					("AtalkDispatchCreate: Context size %d\n", ea->EaValueLength));

			status = STATUS_EA_LIST_INCONSISTENT;
			break;
		}

		RtlCopyMemory(&connectionContext,
					  &ea->EaName[ea->EaNameLength+1],
					  sizeof(CONNECTION_CONTEXT));

		status = AtalkTdiOpenConnection(pIrp,
										pIrpSp,
										connectionContext,
										&atalkDeviceObject->Ctx);
		break;


	  case TDI_CONTROL_CHANNEL_FILE :
		status = AtalkTdiOpenControlChannel(pIrp,
											pIrpSp,
											&atalkDeviceObject->Ctx);
		break;

	  default:
		DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_ERR,
				("AtalkDispatchCreate: unknown EA passed!\n"));

		status = STATUS_INVALID_EA_NAME;
		break;
	}

	// Successful completion.

	DBGPRINT(DBG_COMP_CREATE, DBG_LEVEL_INFO,
			("AtalkDispatchCreate complete irp %lx status %lx\n", pIrp, status));

	if (NT_SUCCESS(status))
		INTERLOCKED_INCREMENT_LONG(&AtalkHandleCount, &AtalkStatsLock);

	if (status != STATUS_PENDING)
	{
		pIrpSp->Control &= ~SL_PENDING_RETURNED;

		ASSERT (status != STATUS_PENDING);
		TdiCompleteRequest(pIrp, status);
	}

	return status;

} // AtalkDispatchCreate




NTSTATUS
AtalkDispatchCleanup(
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			pIrp
)
/*++

Routine Description:

	This is the dispatch routine for Cleanup functions for the Appletalk driver.

Arguments:

	DeviceObject - Pointer to device object for target device
	pIrp - Pointer to I/O request packet

Return Value:

	NTSTATUS -- Indicates whether the request was successfully
				started/completed

--*/
{
	NTSTATUS				status;
	PATALK_DEV_OBJ			atalkDeviceObject;
	PIO_STACK_LOCATION 		pIrpSp;

	DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_INFO,
			("AtalkDispatchCleanup: entered irp %lx\n", pIrp));

	// Make sure status information is consistent every time.
	IoMarkIrpPending (pIrp);
	pIrp->IoStatus.Status = STATUS_PENDING;
	pIrp->IoStatus.Information = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	atalkDeviceObject = (PATALK_DEV_OBJ)DeviceObject;

	switch ((ULONG_PTR)(pIrpSp->FileObject->FsContext2) & 0xFF)
	{
	  case TDI_TRANSPORT_ADDRESS_FILE :
		status = AtalkTdiCleanupAddress(pIrp,
										pIrpSp,
										&atalkDeviceObject->Ctx);

		break;

	  case TDI_CONNECTION_FILE :
		status = AtalkTdiCleanupConnection(pIrp,
										   pIrpSp,
										   &atalkDeviceObject->Ctx);

		break;

	  case TDI_CONTROL_CHANNEL_FILE :
		status = STATUS_SUCCESS;
		break;		

	  default:
		DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_ERR,
				("AtalkDispatchCleaup: Invalid object %s\n",
				pIrpSp->FileObject->FsContext));

		status = STATUS_INVALID_HANDLE;
		break;
	}

	DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_INFO,
			("AtalkDispatchCleanup complete irp %lx status %lx\n", pIrp, status));

	if (status != STATUS_PENDING)
	{
		pIrpSp->Control &= ~SL_PENDING_RETURNED;

		ASSERT (status != STATUS_PENDING);
		TdiCompleteRequest(pIrp, status);
	}

	return(status);

} // AtalkDispatchCleanup




NTSTATUS
AtalkDispatchClose(
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			pIrp
)
/*++

Routine Description:

	This is the dispatch routine for Close functions for the Appletalk driver.

Arguments:

	DeviceObject - Pointer to device object for target device
	irp - Pointer to I/O request packet

Return Value:

	NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
	NTSTATUS				status;
	PIO_STACK_LOCATION 		pIrpSp;
	PATALK_DEV_OBJ			atalkDeviceObject;

	DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_INFO,
			("AtalkDispatchClose: entered for IRP %lx\n", pIrp));

	// Make sure status information is consistent every time.
	IoMarkIrpPending(pIrp);
	pIrp->IoStatus.Status = STATUS_PENDING;
	pIrp->IoStatus.Information = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	atalkDeviceObject = (PATALK_DEV_OBJ)DeviceObject;

	switch ((ULONG_PTR)(pIrpSp->FileObject->FsContext2) & 0xFF)
	{
	  case TDI_TRANSPORT_ADDRESS_FILE :
		status = AtalkTdiCloseAddress(pIrp,
									  pIrpSp,
									  &atalkDeviceObject->Ctx);

		break;

	  case TDI_CONNECTION_FILE :
		status = AtalkTdiCloseConnection(pIrp,
										 pIrpSp,
										 &atalkDeviceObject->Ctx);

		break;

	  case TDI_CONTROL_CHANNEL_FILE :
		status = AtalkTdiCloseControlChannel(pIrp,
											 pIrpSp,
											 &atalkDeviceObject->Ctx);
		break;		

	  default:
		DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_ERR,
				("AtalkDispatchClose: Invalid object %s\n",
				pIrpSp->FileObject->FsContext));

		status = STATUS_INVALID_HANDLE;
		break;
	}

	DBGPRINT(DBG_COMP_CLOSE, DBG_LEVEL_INFO,
			("AtalkDispatchClose complete irp %lx status %lx\n", pIrp, status));

	if (status != STATUS_PENDING)
	{
		pIrpSp->Control &= ~SL_PENDING_RETURNED;

		ASSERT (status != STATUS_PENDING);
		TdiCompleteRequest(pIrp, status);
	}

	INTERLOCKED_DECREMENT_LONG(&AtalkHandleCount, &AtalkStatsLock);

	return(status);

} // AtalkDispatchClose




NTSTATUS
AtalkDispatchDeviceControl(
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			pIrp
)
/*++

Routine Description:

	This is the dispatch routine for Device Control functions for the Appletalk driver.

Arguments:

	DeviceObject - Pointer to device object for target device
	pIrp - Pointer to I/O request packet

Return Value:

	NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
	NTSTATUS				status;
	PATALK_DEV_OBJ			atalkDeviceObject;
	PIO_STACK_LOCATION 		pIrpSp;
    ULONG                   IoControlCode;

	DBGPRINT(DBG_COMP_DISPATCH, DBG_LEVEL_INFO,
			("AtalkDispatchDeviceControl: irp %lx\n", pIrp));

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	atalkDeviceObject = (PATALK_DEV_OBJ)DeviceObject;


    IoControlCode = pIrpSp->Parameters.DeviceIoControl.IoControlCode;

    //
    // if it's a request from ARAP, process it here and return
    //
    if (IoControlCode > IOCTL_ARAP_START && IoControlCode < IOCTL_ARAP_END)
    {
        status = ArapProcessIoctl(pIrp);

	    return(status);
    }

	//  Do a map and call the internal device io control function.
	//  That will also perform the completion.
	status = TdiMapUserRequest(DeviceObject,
							   pIrp,
							   pIrpSp);

	if (status == STATUS_SUCCESS)
	{
		status = AtalkDispatchInternalDeviceControl(
					DeviceObject,
					pIrp);

		//
		//  AtalkDispatchInternalDeviceControl expects to complete the
		//  irp
		//
	}
	else
	{
		DBGPRINT(DBG_COMP_DISPATCH, DBG_LEVEL_WARN,
				("AtalkDispatchDeviceControl: TdiMap failed %lx\n", status));

		pIrpSp->Control &= ~SL_PENDING_RETURNED;

		ASSERT (status != STATUS_PENDING);
		TdiCompleteRequest(pIrp, status);
	}

	return(status);

} // AtalkDispatchDeviceControl




NTSTATUS
AtalkDispatchInternalDeviceControl(
	IN PDEVICE_OBJECT 	DeviceObject,
	IN PIRP 			pIrp
)
/*++

Routine Description:

	This is the dispatch routine for Internal Device Control functions
	for the Appletalk driver.

Arguments:

	DeviceObject - Pointer to device object for target device

	pIrp - Pointer to I/O request packet

Return Value:

	NTSTATUS -- Indicates whether the request was successfully queued.

--*/
{
	NTSTATUS				status;
	PIO_STACK_LOCATION 		pIrpSp;
	PATALK_DEV_OBJ			atalkDeviceObject;
	KIRQL					oldIrql;

	DBGPRINT(DBG_COMP_DISPATCH, DBG_LEVEL_INFO,
			("AtalkDispatchInternalDeviceControl entered for IRP %lx\n", pIrp));

	// Make sure status information is consistent every time.
	IoMarkIrpPending (pIrp);
	pIrp->IoStatus.Status = STATUS_PENDING;
	pIrp->IoStatus.Information = 0;

	pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
	atalkDeviceObject = (PATALK_DEV_OBJ)DeviceObject;


	IoAcquireCancelSpinLock(&oldIrql);
    if (!pIrp->Cancel)
	{
		IoSetCancelRoutine(pIrp, (PDRIVER_CANCEL)AtalkTdiCancel);
	}
    else
    {
	    IoReleaseCancelSpinLock(oldIrql);
        status = STATUS_CANCELLED;
        TdiCompleteRequest(pIrp, status);
        return(status);
    }

	IoReleaseCancelSpinLock(oldIrql);

	//  Branch to the appropriate request handler.
	switch (pIrpSp->MinorFunction)
	{
	  case TDI_ACCEPT:
		status = AtalkTdiAccept(pIrp,
								pIrpSp,
								&atalkDeviceObject->Ctx);
		break;

	  case TDI_RECEIVE_DATAGRAM:
		status = AtalkTdiReceiveDgram(pIrp,
									  pIrpSp,
									  &atalkDeviceObject->Ctx);
		break;

	  case TDI_SEND_DATAGRAM:
		status = AtalkTdiSendDgram(pIrp,
								   pIrpSp,
								   &atalkDeviceObject->Ctx);
		break;

	  case TDI_SET_EVENT_HANDLER:
		status = AtalkTdiSetEventHandler(pIrp,
										 pIrpSp,
										 &atalkDeviceObject->Ctx);
		break;

	  case TDI_RECEIVE:
		status = AtalkTdiReceive(pIrp,
								 pIrpSp,
								 &atalkDeviceObject->Ctx);
		break;

	  case TDI_SEND:
		status = AtalkTdiSend(pIrp,
							  pIrpSp,
							  &atalkDeviceObject->Ctx);
		break;

	  case TDI_ACTION:
		ASSERT(pIrp->MdlAddress != NULL);
		status = AtalkTdiAction(pIrp,
								pIrpSp,
								&atalkDeviceObject->Ctx);
		break;

	  case TDI_ASSOCIATE_ADDRESS:
		status = AtalkTdiAssociateAddress(pIrp,
										  pIrpSp,
										  &atalkDeviceObject->Ctx);
		break;

	  case TDI_DISASSOCIATE_ADDRESS:
		status = AtalkTdiDisassociateAddress(pIrp,
											 pIrpSp,
											 &atalkDeviceObject->Ctx);
		break;

	  case TDI_CONNECT:
		status = AtalkTdiConnect(pIrp,
								 pIrpSp,
								 &atalkDeviceObject->Ctx);
		break;

	  case TDI_DISCONNECT:
		status = AtalkTdiDisconnect(pIrp,
									pIrpSp,
									&atalkDeviceObject->Ctx);
		break;

	  case TDI_LISTEN:
		status = AtalkTdiListen(pIrp,
								pIrpSp,
								&atalkDeviceObject->Ctx);
		break;

	  case TDI_QUERY_INFORMATION:
		ASSERT(pIrp->MdlAddress != NULL);
		status = AtalkTdiQueryInformation(pIrp,
										  pIrpSp,
										  &atalkDeviceObject->Ctx);
		break;

	  case TDI_SET_INFORMATION:
		status = AtalkTdiSetInformation(pIrp,
										pIrpSp,
										&atalkDeviceObject->Ctx);
		break;

	  default:
		// Something we don't know about was submitted.
		DBGPRINT(DBG_COMP_DISPATCH, DBG_LEVEL_ERR,
				("AtalkDispatchInternal: fnct %lx\n", pIrpSp->MinorFunction));

		status = STATUS_INVALID_DEVICE_REQUEST;
	}

	DBGPRINT(DBG_COMP_DISPATCH, DBG_LEVEL_INFO,
			("AtalkDispatchInternal complete irp %lx status %lx\n", pIrp, status));

	// Return the immediate status code to the caller.
	if (status != STATUS_PENDING)
	{
		pIrpSp->Control &= ~SL_PENDING_RETURNED;

		//  Complete the request, this will also dereference it.
		pIrp->CancelRoutine = NULL;
		ASSERT (status != STATUS_PENDING);
		TdiCompleteRequest(pIrp, status);
	}

	return status;
} // AtalkDispatchInternalDeviceControl




VOID
atalkUnload(
	IN PDRIVER_OBJECT DriverObject
)
/*++

Routine Description:

	This is the unload routine for the Appletalk driver.

	NOTE: Unload will not be called until all the handles have been
		  closed successfully. We just shutdown all the ports, and do
		  misc. cleanup.


Arguments:

	DriverObject - Pointer to driver object for this driver.

Return Value:

	None.

--*/
{
	UNREFERENCED_PARAMETER (DriverObject);

    AtalkBindnUnloadStates |= ATALK_UNLOADING;

    // if we hit that timing window where binding or PnP event is going on,
    // sleep (for a second each time) until that action completes
    while (AtalkBindnUnloadStates & (ATALK_BINDING | ATALK_PNP_IN_PROGRESS))
    {
        AtalkSleep(1000);
    }

	AtalkLockInitIfNecessary();

	AtalkCleanup();

	AtalkUnlockInitIfNecessary();

#if	DBG
	{
		int i;

		// Make sure we are not unloading with any locked sections
		for (i = 0; i < LOCKABLE_SECTIONS; i++)
		{
			ASSERT (AtalkPgLkSection[i].ls_LockCount == 0);
		}
	}

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		("Appletalk driver unloaded\n"));

#endif
} // atalkUnload



VOID
AtalkCleanup(
	VOID
	)
/*++

Routine Description:

	This is synchronous and will block until Unload Completes


Arguments:

	None.

Return Value:

	None.

--*/
{
	PPORT_DESCRIPTOR	pPortDesc;
	LONG				i;
	KIRQL				OldIrql;


	//	Stop the timer subsystem
	AtalkTimerFlushAndStop();

	ASSERT(KeGetCurrentIrql() == LOW_LEVEL);

	ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);

	//	Shut down all ports
	while ((pPortDesc = AtalkPortList) != NULL)
	{
		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

		AtalkPortShutdown(pPortDesc);

		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
	}

	RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

	if (AtalkRegPath.Buffer != NULL)
	{
		AtalkFreeMemory(AtalkRegPath.Buffer);
	}

	if (AtalkDefaultPortName.Buffer != NULL)
	{
		AtalkFreeMemory(AtalkDefaultPortName.Buffer);
	}

	for (i = 0; i < ATALK_NO_DEVICES; i++)
	{
		//
		//	Delete all the devices created
		//
		IoDeleteDevice((PDEVICE_OBJECT)AtalkDeviceObject[i]);
	}

	// Deinitialize the Block Package
	AtalkDeInitMemorySystem();

	// Check if routing is on, if so unlock the router code now
	if (AtalkRouter)
		AtalkUnlockRouterIfNecessary();

	// Free the rtmp tables
	AtalkRtmpInit(FALSE);

	// Free the zip tables
	AtalkZipInit(FALSE);

	//	Release ndis resources (buffer/packet pools)
	AtalkNdisReleaseResources();

	//	Deregister the protocol from ndis if handle is non-null
	if (AtalkNdisProtocolHandle != (NDIS_HANDLE)NULL)
		AtalkNdisDeregisterProtocol();

	ASSERT(AtalkStatistics.stat_CurAllocSize == 0);

    ASSERT(AtalkDbgMdlsAlloced == 0);
    ASSERT(AtalkDbgIrpsAlloced == 0);

#ifdef	PROFILING
	ASSERT(AtalkStatistics.stat_CurAllocCount == 0);
	ASSERT(AtalkStatistics.stat_CurMdlCount == 0);
#endif
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkerror.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkerror.h

Abstract:

	This module contains some error definitions for appletalk.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKERROR_
#define	_ATKERROR_

//	Define the modules names for Appletalk - use the high bits.
#define		ATKINIT				0x00010000
#define		ATKDRVR				0x00020000
#define		ATKNDIS				0x00030000
#define		ATKTDI				0x00040000
#define		ATKACT				0x00050000
#define		ATKUTILS			0x00060000
#define		ATKTIMER			0x00070000
#define		ATKMEM				0x00080000
#define		ATKERROR			0x00090000

#define		ROUTER				0x000A0000
#define		SOCKET				0x000B0000
#define		PORTS				0x000C0000
#define		NODE				0x000D0000
#define		AARP				0x000E0000
#define		AEP					0x000F0000
#define		DDP					0x00100000
#define		RTMP				0x00200000
#define		NBP					0x00300000
#define		ZIP					0x00400000
#define		ATP					0x00500000
#define		ASP					0x00600000
#define		PAP					0x00700000
#define		ADSP				0x00800000
#define		ATKIND				0x00900000
#define		ASPC				0x00A00000
#define		DATAX				0x00B00000
#define     RAS                 0x00C00000
#define     ARAP                0x00D00000
#define     ARAPNDIS            0x00E00000
#define     ARAPUTIL            0x00F00000
#define     ARAPATK             0x01000000
#define     ARAPDBG             0x02000000
#define     ATKPNP              0x03000000
#define     PPP                 0x04000000


// DEBUGGING SUPPORT:
// Debugging messages are provided per-subsystem defined here, and within
// the subsystems, there are 4 levels of messages.
//
// The four levels of debug messages are:
//
// INFO:		Informational messages, eg., entry exit in routines
// WARN:		Something went wrong, but its not an error, eg., packet was not ours
// ERR:		Error situations, but we can still run if a retry happens
// FATAL:		In this situation, the driver is not operational

// These give the ref/deref dbgprints if DBG is defined. LOTS of output.
// Defined as a hierarchy of the stack objects.
#define	DBG_LEVEL_REFDDP		0x2000
#define	DBG_LEVEL_REFNODE		0x3000
#define	DBG_LEVEL_REFPORT		0x4000
#define	DBG_LEVEL_REFATP		0x4100
#define	DBG_LEVEL_REFPAPADDR	0x4200
#define	DBG_LEVEL_REFPAPCONN	0x4300
#define	DBG_LEVEL_REFASPADDR	0x4400
#define	DBG_LEVEL_REFASPCONN	0x4500

#define	DBG_LEVEL_INFO			0x5000
#define	DBG_LEVEL_WARN			0x6000
#define	DBG_LEVEL_ERR			0x7000
#define	DBG_LEVEL_FATAL			0x8000

// SUBSYSTEMS
#define DBG_COMP_INIT			0x00000001
#define DBG_COMP_DISPATCH		0x00000002
#define DBG_COMP_CREATE			0x00000004
#define DBG_COMP_CLOSE			0x00000008
#define DBG_COMP_ACTION			0x00000010
#define DBG_COMP_ADDROBJ		0x00000020
#define DBG_COMP_CONNOBJ		0x00000040
#define DBG_COMP_CHANOBJ		0x00000080
#define DBG_COMP_RESOURCES		0x00000100
#define DBG_COMP_UNLOAD			0x00000200

#define	DBG_COMP_NODE			0x00000400
#define	DBG_COMP_AARP			0x00000800

#define	DBG_COMP_AEP			0x00001000
#define DBG_COMP_DDP			0x00002000
#define DBG_COMP_ATP			0x00004000
#define DBG_COMP_ADSP			0x00008000
#define DBG_COMP_ZIP			0x00010000
#define DBG_COMP_NBP			0x00020000
#define DBG_COMP_PAP			0x00040000
#define DBG_COMP_ASP			0x00080000
#define DBG_COMP_RTMP			0x00100000
#define	DBG_COMP_ROUTER			0x00200000

#define	DBG_COMP_DUMP			0x00400000
#define DBG_COMP_REFCOUNTS		0x00800000
#define DBG_COMP_SYSTEM			0x01000000
#define DBG_COMP_CRITSEC		0x02000000
#define DBG_COMP_UTILS			0x04000000

#define DBG_COMP_NDISSEND		0x08000000
#define DBG_COMP_NDISRECV		0x10000000
#define DBG_COMP_NDISREQ		0x20000000
#define DBG_COMP_TDI			0x40000000
#define DBG_COMP_RAS            0x80000000

#define DBG_MOST			   (DBG_COMP_INIT			|	\
								DBG_COMP_DISPATCH		|	\
								DBG_COMP_CREATE			|	\
								DBG_COMP_CLOSE			|	\
								DBG_COMP_ACTION			|	\
								DBG_COMP_ADDROBJ		|	\
								DBG_COMP_CONNOBJ		|	\
								DBG_COMP_CHANOBJ		|	\
								DBG_COMP_RESOURCES		|	\
								DBG_COMP_UNLOAD			|	\
								DBG_COMP_NODE			|	\
								DBG_COMP_AARP			|	\
								DBG_COMP_AEP			|	\
								DBG_COMP_DDP			|	\
								DBG_COMP_ATP			|	\
								DBG_COMP_ADSP			|	\
								DBG_COMP_ZIP			|	\
								DBG_COMP_NBP			|	\
								DBG_COMP_PAP			|	\
								DBG_COMP_ASP			|	\
								DBG_COMP_RTMP			|	\
								DBG_COMP_ROUTER			|	\
								DBG_COMP_DUMP			|	\
								DBG_COMP_UTILS			|	\
								DBG_COMP_REFCOUNTS		|	\
								DBG_COMP_SYSTEM			|	\
								DBG_COMP_TDI            |	\
                                DBG_COMP_RAS)

// past here are debug things that are really frequent; don't use them
// unless you want LOTS of output


#define DBG_ALL			 		(DBG_MOST | DBG_COMP_CRITSEC)


// More debugging support. These values define the dumping components.
// There are a max of 32 such components that can be defined. Each of
// these are associated with a dump routine. It one is specified and
// enabled, periodically it is called. It is upto that component to
// decide what it wants to do

#define	DBG_DUMP_DEF_INTERVAL			300			// In 100ms units

#define	DBG_DUMP_PORTINFO				0x00000001
#define	DBG_DUMP_AMT					0x00000002
#define	DBG_DUMP_ZONETABLE				0x00000004
#define	DBG_DUMP_RTES					0x00000008
#define	DBG_DUMP_TIMERS					0x00000010
#define	DBG_DUMP_ATPINFO				0x00000020
#define	DBG_DUMP_ASPSESSIONS			0x00000040
#define	DBG_DUMP_PAPJOBS				0x00000080

typedef	LONG	ATALK_ERROR, *PATALK_ERROR;

#define	ATALK_SUCCESS(error)			((ATALK_ERROR)(error) >= 0)

#define	ATALK_NO_ERROR					0x00000000
#define	ATALK_PENDING					0x00000001

#define	ATALK_RESR_MEM					-1000

#define	ATALK_INVALID_PARAMETER			-1050
#define	ATALK_BUFFER_TOO_SMALL			-1051
#define	ATALK_BUFFER_TOO_BIG			-1052
#define	ATALK_ALREADY_ASSOCIATED		-1053
#define	ATALK_CANNOT_DISSOCIATE			-1054
#define	ATALK_CANNOT_CANCEL				-1055
#define	ATALK_INVALID_REQUEST			-1056
#define	ATALK_REQUEST_NOT_ACCEPTED		-1057
#define	ATALK_DEVICE_NOT_READY			-1058
#define	ATALK_INVALID_CONNECTION		-1059
#define	ATALK_INVALID_ADDRESS			-1060
#define	ATALK_TOO_MANY_COMMANDS			-1061
#define	ATALK_CONNECTION_TIMEOUT		-1062
#define	ATALK_REMOTE_CLOSE				-1063
#define	ATALK_LOCAL_CLOSE				-1064
#define	ATALK_BUFFER_INVALID_SIZE		-1065
#define	ATALK_REQUEST_CANCELLED			-1066
#define	ATALK_NEW_SOCKET				-1067
#define	ATALK_TIMEOUT					-1068
#define	ATALK_SHARING_VIOLATION			-1069
#define	ATALK_INVALID_PKT				-1070
#define	ATALK_DUP_PKT					-1071

#define	ATALK_INIT_BINDFAIL				-1100
#define	ATALK_INIT_REGPROTO_FAIL		-1101
#define	ATALK_INIT_MEDIA_INVALID		-1102

#define	ATALK_PORT_INVALID				-1200
#define	ATALK_PORT_CLOSING				-1201

#define	ATALK_NODE_FINDING				-1300
#define	ATALK_NODE_NONEXISTENT			-1301
#define	ATALK_NODE_CLOSING				-1302
#define	ATALK_NODE_NOMORE				-1303

#define	ATALK_SOCKET_INVALID			-1400
#define	ATALK_SOCKET_NODEFULL			-1401
#define	ATALK_SOCKET_EXISTS				-1402
#define	ATALK_SOCKET_CLOSED				-1403

#define	ATALK_DDP_CLOSING				-1500
#define	ATALK_DDP_NOTFOUND				-1501
#define	ATALK_DDP_INVALID_LEN			-1502
#define	ATALK_DDP_SHORT_HDR				-1503
#define	ATALK_DDP_INVALID_SRC			-1504
#define	ATALK_DDP_INVALID_DEST			-1505
#define	ATALK_DDP_INVALID_ADDR			-1506
#define	ATALK_DDP_INVALID_PROTO	 		-1507
#define	ATALK_DDP_INVALID_PARAM	 		-1508
#define	ATALK_DDP_NO_ROUTER				-1509
#define	ATALK_DDP_NO_AMT_ENTRY			-1510
#define	ATALK_DDP_NO_BRC_ENTRY			-1511
#define	ATALK_DDP_PKT_DROPPED			-1512

#define	ATALK_ATP_NOT_FOUND				-1600
#define	ATALK_ATP_INVALID_PKT			-1601
#define	ATALK_ATP_INVALID_REQ			-1602
#define	ATALK_ATP_REQ_CLOSING			-1603
#define	ATALK_ATP_RESP_CLOSING			-1604
#define	ATALK_ATP_INVALID_RETRYCNT		-1605
#define	ATALK_ATP_INVALID_TIMERVAL		-1606
#define	ATALK_ATP_INVALID_RELINT		-1607
#define	ATALK_ATP_CLOSING				-1608
#define	ATALK_ATP_RESP_TOOMANY			-1609
#define	ATALK_ATP_NO_MATCH_REQ			-1610
#define	ATALK_ATP_NO_GET_REQ			-1611
#define	ATALK_ATP_RESP_TIMEOUT			-1612
#define	ATALK_ATP_RESP_CANCELLED		-1613
#define	ATALK_ATP_REQ_CANCELLED			-1614
#define	ATALK_ATP_GET_REQ_CANCELLED		-1615
#define	ATALK_ATP_NO_VALID_RESP			-1616
#define	ATALK_ATP_REQ_TIMEOUT			-1617

#define	ATALK_ASP_INVALID_REQUEST		-1700

#define	ATALK_PAP_LOCAL_CLOSE			-1800
#define	ATALK_PAP_REMOTE_CLOSE			-1801
#define	ATALK_PAP_INVALID_REQUEST		-1802
#define	ATALK_PAP_TOO_MANY_READS		-1803
#define	ATALK_PAP_TOO_MANY_WRITES		-1804
#define	ATALK_PAP_CONN_NOT_ACTIVE		-1805
#define	ATALK_PAP_ADDR_CLOSING			-1806
#define	ATALK_PAP_CONN_CLOSING			-1807
#define	ATALK_PAP_CONN_NOT_FOUND		-1808
#define	ATALK_PAP_INVALID_USERBYTES		-1809
#define	ATALK_PAP_SERVER_BUSY			-1810
#define	ATALK_PAP_INVALID_STATUS		-1811
#define	ATALK_PAP_PARTIAL_RECEIVE		-1812
#define	ATALK_PAP_CONN_RESET			-1813

#define	ATALK_ADSP_INVALID_REQUEST		-1900
#define	ATALK_ADSP_CONN_NOT_ACTIVE		-1903
#define	ATALK_ADSP_ADDR_CLOSING			-1904
#define	ATALK_ADSP_CONN_CLOSING			-1905
#define	ATALK_ADSP_CONN_NOT_FOUND		-1906
#define	ATALK_ADSP_CONN_RESET			-1907
#define	ATALK_ADSP_SERVER_BUSY			-1908

#define	ATALK_ADSP_PARTIAL_RECEIVE		-1912
#define	ATALK_ADSP_EXPED_RECEIVE		-1913
#define	ATALK_ADSP_PAREXPED_RECEIVE		-1914
#define	ATALK_ADSP_REMOTE_RESR			-1915

#define	ATALK_TIMER_CANCEL_FAIL			-2000
#define	ATALK_TIMER_SCHEDULE_FAIL		-2001

#define	ATALK_ASPC_LOCAL_CLOSE			-2100
#define	ATALK_ASPC_REMOTE_CLOSE			-2101
#define	ATALK_ASPC_INVALID_REQUEST		-2102
#define	ATALK_ASPC_TOO_MANY_READS		-2103
#define	ATALK_ASPC_TOO_MANY_WRITES		-2104
#define	ATALK_ASPC_CONN_NOT_ACTIVE		-2105
#define	ATALK_ASPC_ADDR_CLOSING			-2106
#define	ATALK_ASPC_CONN_CLOSING			-2107
#define	ATALK_ASPC_CONN_NOT_FOUND		-2108
#define	ATALK_ASPC_INVALID_USERBYTES	-2109
#define	ATALK_ASPC_SERVER_BUSY			-2110
#define	ATALK_ASPC_INVALID_STATUS		-2111
#define	ATALK_ASPC_PARTIAL_RECEIVE		-2112
#define	ATALK_ASPC_CONN_RESET			-2113

#define	ATALK_FAILURE					-5000

//	This defines the number of times an error has to happen consecutively before
//	it gets logged again.
#define		ERROR_CONSEQ_FREQ			200
#define		ERROR_CONSEQ_TIME			18000	// 30 minutes in 100ns intervals


#if	DBG
extern	ULONG		AtalkDebugDump;
extern	LONG		AtalkDumpInterval;
extern	ULONG		AtalkDebugLevel;
extern	ULONG		AtalkDebugSystems;
extern	TIMERLIST	AtalkDumpTimerList;
typedef VOID	(*DUMP_ROUTINE)(VOID);

extern
LONG FASTCALL
AtalkDumpComponents(
	IN	PTIMERLIST	Context,
	IN	BOOLEAN		TimerShuttingDown
);

extern
VOID
AtalkAmtDumpTable(
	VOID
);

extern
VOID
AtalkPortDumpInfo(
	VOID
);

extern
VOID
AtalkRtmpDumpTable(
	VOID
);

extern
VOID
AtalkTimerDumpList(
	VOID
);

extern
VOID
AtalkZoneDumpTable(
	VOID
);

extern
VOID
AtalkAspDumpSessions(
	VOID
);

#endif


#define LOG_ERROR(AtalkError, NtStatus, RawData, RawDataLen)				\
		LOG_ERRORONPORT(NULL, AtalkError, NtStatus, RawData, RawDataLen)

#define RES_LOG_ERROR()														\
		LOG_ERROR(EVENT_ATALK_RESOURCES, STATUS_INSUFFICIENT_RESOURCES, NULL, 0)

#define LOG_ERRORONPORT(Port, AtalkError, NtStatus, RawData, RawDataLen)	\
	{																		\
		if (!NT_SUCCESS(NtStatus))											\
		{																	\
			DBGPRINT(DBG_ALL, DBG_LEVEL_ERR,								\
					("LOG_ERROR: File %s Line %ld Event %lx Error %lx\n",	\
					__FILE__, __LINE__, AtalkError, NtStatus));			    \
		}																	\
		AtalkWriteErrorLogEntry(Port,										\
								AtalkError,									\
								(__LINE__ | FILENUM),  					    \
								NtStatus,									\
								RawData,									\
								RawDataLen);								\
	}

#if DBG
// ERROR and above ignore the Component part
#define DBGPRINT(Component, Level, Fmt)										\
		{																	\
			if ((Level >= AtalkDebugLevel) &&								\
				((AtalkDebugSystems & Component) == Component))				\
			{																\
				DbgPrint("***ATALK*** ");									\
				DbgPrint Fmt;												\
			}																\
		}

#define DBGPRINTSKIPHDR(Component, Level, Fmt)								\
		{																	\
			if ((Level >= AtalkDebugLevel) &&								\
				((AtalkDebugSystems & Component) == Component))				\
			{																\
				DbgPrint Fmt;												\
			}																\
		}

#define DBGBRK(Level)														\
		{																	\
			if (Level >= AtalkDebugLevel)									\
				DbgBreakPoint();											\
		}

#define	TMPLOGERR()		DBGPRINT(DBG_MOST, DBG_LEVEL_ERR,					\
								("TempErrLog: %s, Line %ld\n",				\
								__FILE__, __LINE__));

#else
#define DBGPRINTSKIPHDR(Component, Level, Fmt)
#define DBGPRINT(Component, Level, Fmt)
#define DBGBRK(Level)
#define	TMPLOGERR()
#endif

extern
VOID
AtalkWriteErrorLogEntry(
	IN	struct _PORT_DESCRIPTOR	*	pPortDesc,
	IN	NTSTATUS 					UniqueErrorCode,
	IN	ULONG						UniqueErrorValue,
	IN	NTSTATUS 					NtStatusCode,
	IN	PVOID						RawDataBuf OPTIONAL,
	IN	LONG	 					RawDataLen);

extern
VOID
AtalkLogBadPacket(
	IN	struct _PORT_DESCRIPTOR	*	pPortDesc,
	IN	PATALK_ADDR					pSrcAddr,
	IN	PATALK_ADDR					pDstAddr	OPTIONAL,
	IN	PBYTE						pPkt,
	IN	USHORT	 					PktLen);

extern
ATALK_ERROR FASTCALL
AtalkNdisToAtalkError(
	IN	NDIS_STATUS					Error);

extern
NTSTATUS FASTCALL
AtalkErrorToNtStatus(
	IN	ATALK_ERROR					AtalkError);

#endif	// _ATKERROR_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkind.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkind.h

Abstract:


Author:

	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	22 Oct 1993		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKIND_
#define	_ATKIND_

//	Different subtypes for ATP indication type.
#define	ATP_ALLOC_BUF	0
#define	ATP_USER_BUF	1
#define	ATP_USER_BUFX	2		// Do not indicate the packet to Atp with this.

ATALK_ERROR
AtalkIndAtpPkt(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE				pLookahead,
	IN		USHORT				PktLen,
	IN	OUT	PUINT				pXferOffset,
	IN		PBYTE				pLinkHdr,
	IN		BOOLEAN				ShortDdpHdr,
	OUT		PBYTE				SubType,
	OUT		PBYTE			* 	ppPacket,
	OUT		PNDIS_PACKET	*	pNdisPkt);

ATALK_ERROR
AtalkIndAtpCacheSocket(
	IN	struct _ATP_ADDROBJ	*	pAtpAddr,
	IN	PPORT_DESCRIPTOR		pPortDesc);

VOID
AtalkIndAtpUnCacheSocket(
	IN	struct _ATP_ADDROBJ	*	pAtpAddr);

//	VOID
//	AtalkIndAtpSetupNdisBuffer(
//		IN	OUT	PATP_REQ		pAtpReq,
//		IN		ULONG			MaxSinglePktSize);
//
#define	AtalkIndAtpSetupNdisBuffer(pAtpReq, MaxSinglePktSize)	\
	{															\
		NDIS_STATUS		ndisStatus;								\
		PNDIS_BUFFER	ndisBuffer;								\
		USHORT			seqNum		= 0;						\
		USHORT			startOffset = 0;						\
		SHORT			BufLen = (SHORT)pAtpReq->req_RespBufLen;\
																\
		RtlZeroMemory(pAtpReq->req_NdisBuf,						\
					  sizeof(PVOID) * ATP_MAX_RESP_PKTS);		\
																\
		while (BufLen > 0)										\
		{														\
			NdisCopyBuffer(&ndisStatus,							\
						   &ndisBuffer,							\
						   AtalkNdisBufferPoolHandle,			\
						   (PVOID)pAtpReq->req_RespBuf,			\
						   startOffset,							\
						   (UINT)MIN(BufLen,					\
						   (SHORT)MaxSinglePktSize));			\
																\
			if (ndisStatus != NDIS_STATUS_SUCCESS)				\
				break;											\
																\
			pAtpReq->req_NdisBuf[seqNum++] = ndisBuffer;		\
			startOffset  += (USHORT)MaxSinglePktSize;			\
			BufLen -= (SHORT)MaxSinglePktSize;					\
		}														\
	}

//	VOID
//	AtalkIndAtpReleaseNdisBuffer(
//		IN	OUT	PATP_REQ		pAtpReq);
//
#define	AtalkIndAtpReleaseNdisBuffer(pAtpReq)					\
	{															\
		LONG	_i;												\
																\
		for (_i = 0; _i < ATP_MAX_RESP_PKTS; _i++)				\
		{														\
			if ((pAtpReq)->req_NdisBuf[_i] != NULL)				\
				NdisFreeBuffer((pAtpReq)->req_NdisBuf[_i]);		\
		}														\
	}


//	ATALK_ERROR
//	AtalkIndAtpCacheLkUpSocket(
//		IN	PATALK_ADDR				pDestAddr,
//		OUT	struct _ATP_ADDROBJ	**	ppAtpAddr,
//		OUT	ATALK_ERROR			*	pError);
//
#define	AtalkIndAtpCacheLkUpSocket(pDestAddr, ppAtpAddr, pError)	\
	{																\
		USHORT					i;									\
		struct ATALK_CACHED_SKT	*pCachedSkt;						\
																	\
		*(pError) = ATALK_FAILURE;									\
																	\
		if (((pDestAddr)->ata_Network == AtalkSktCache.ac_Network) &&	\
			((pDestAddr)->ata_Node	== AtalkSktCache.ac_Node))		\
		{															\
			ACQUIRE_SPIN_LOCK_DPC(&AtalkSktCacheLock);				\
																	\
			for (i = 0, pCachedSkt = &AtalkSktCache.ac_Cache[0];	\
				 i < ATALK_CACHE_SKTMAX;							\
				 i++, pCachedSkt++)									\
			{														\
				if ((pCachedSkt->Type == (ATALK_CACHE_INUSE | ATALK_CACHE_ATPSKT))	&&	\
					(pCachedSkt->Socket == (pDestAddr)->ata_Socket))\
				{													\
					AtalkAtpAddrReferenceDpc(pCachedSkt->u.pAtpAddr,\
											 pError);				\
																	\
					if (ATALK_SUCCESS(*pError))						\
					{												\
						*(ppAtpAddr) = pCachedSkt->u.pAtpAddr;		\
					}												\
					break;											\
				}													\
			}														\
																	\
			RELEASE_SPIN_LOCK_DPC(&AtalkSktCacheLock);				\
		}															\
	}

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkinit.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkinit.c

Abstract:

	This module contains the initialization code for the Appletalk stack.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM		ATKINIT

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitializeTransport)
#pragma alloc_text(PAGEINIT, atalkInitGetHandleToKey)
#pragma alloc_text(PAGEINIT, atalkInitGlobal)
#pragma alloc_text(PAGEINIT, atalkInitPort)
#pragma alloc_text(PAGEINIT, atalkInitNetRangeCheck)
#pragma alloc_text(PAGEINIT, atalkInitNetRange)
#pragma alloc_text(PAGEINIT, atalkInitZoneList)
#pragma alloc_text(PAGEINIT, atalkInitDefZone)
#pragma alloc_text(PAGEINIT, atalkInitSeeding)
#pragma alloc_text(PAGEINIT, atalkInitPortParameters)
#pragma alloc_text(PAGEINIT, atalkInitStartPort)
#pragma alloc_text(PAGEINIT, AtalkInitAdapter)
#pragma alloc_text(PAGEINIT, AtalkDeinitAdapter)
#pragma alloc_text(PAGEINIT, atalkInitStartPort)
#endif

NTSTATUS
AtalkInitializeTransport(
	IN	PDRIVER_OBJECT		pDrvObj,
	IN	PUNICODE_STRING		pRegPath
	)
/*++

Routine Description:

	This routine is called during initialization time to
	initialize the transport.

Arguments:

Return Value:

	Status - STATUS_SUCCESS if initialized,
			 Appropriate NT error code otherwise
--*/
{
	PPORT_DESCRIPTOR	pPortDesc;
	NTSTATUS			status;				

	do
	{
		// Initialize the default-port event
		KeInitializeEvent(&AtalkDefaultPortEvent, NotificationEvent, FALSE);

		// Save our registry path
		if ((AtalkRegPath.Buffer = AtalkAllocMemory(pRegPath->Length)) == NULL)
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
			RES_LOG_ERROR();
			break;
		}
		AtalkRegPath.MaximumLength =
		AtalkRegPath.Length = pRegPath->Length;
		RtlCopyMemory(AtalkRegPath.Buffer,
					  pRegPath->Buffer,
				      pRegPath->Length);

		AtalkInitMemorySystem();
	
		// Get the frequency of the performance counters
		KeQueryPerformanceCounter(&AtalkStatistics.stat_PerfFreq);

		//	Initialize the timer subsystem
		if (!NT_SUCCESS(status = AtalkTimerInit()) ||
			!NT_SUCCESS(status = AtalkZipInit(TRUE)))
		{
			RES_LOG_ERROR();
			break;
		}


		//	Initialize the global port descriptors
		AtalkPortList = NULL;
		AtalkDefaultPort = NULL;
		AtalkNumberOfPorts = 0;
		AtalkRouter = FALSE;
	

		// Get the global parameters
		status = atalkInitGlobal();

		if (!NT_SUCCESS(status))
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("AtalkInitializeTransport: AtalkInitGlobal failed %ul\n", status));
			break;
		}

		if (!NT_SUCCESS(status = AtalkNdisInitRegisterProtocol()))
		{
			break;
		}

	} while (FALSE);

	if (NT_SUCCESS(status))
	{
#if	DBG
		AtalkTimerInitialize(&AtalkDumpTimerList,
							 AtalkDumpComponents,
							 DBG_DUMP_DEF_INTERVAL);
		AtalkTimerScheduleEvent(&AtalkDumpTimerList);
#endif

		// Initialize the other subsystems now
		AtalkInitAspInitialize();
		AtalkInitPapInitialize();
		AtalkInitAdspInitialize();
	}
	else
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("Initialization failed!\n"));

		//	We are not loading. Stop everything and return.
		//	Stop all ports, release port resources
		//	Stop the timer subsystem if it was started
		AtalkCleanup();
	}

	return status;
}


NTSTATUS
atalkInitGetHandleToKey(
	IN	PUNICODE_STRING		KeyName,
	OUT	PHANDLE				KeyHandle
	)
/*++

Routine Description:

	Returns the handle for the key specified using SectionHandle as the
	root.

Arguments:

	SectionHandle - Key to registry tree root
	KeyNameString - name of key to be opened
	KeyHandle - Returns the handle for KeyNameString

Return Value:

	The status of the request.

--*/
{
	HANDLE				ConfigHandle;
	NTSTATUS			status;
	OBJECT_ATTRIBUTES	ObjectAttributes;

	*KeyHandle = NULL;

	InitializeObjectAttributes(&ObjectAttributes,
							   &AtalkRegPath,			// name
							   OBJ_CASE_INSENSITIVE,	// attributes
							   NULL,					// root
							   NULL);					// security descriptor

	status = ZwOpenKey(&ConfigHandle,
					   KEY_READ,
					   &ObjectAttributes);

	if (NT_SUCCESS(status))
	{
		InitializeObjectAttributes(&ObjectAttributes,
								   KeyName,					// name
								   OBJ_CASE_INSENSITIVE,	// attributes
								   ConfigHandle,			// root
								   NULL);					// security descriptor

		status = ZwOpenKey(KeyHandle,
						   KEY_READ,
						   &ObjectAttributes);
		ZwClose(ConfigHandle);
	}

	return status;
}


NTSTATUS
atalkInitGlobal(
	VOID
	)
/*++

Routine Description:

	Reads the Parameters key to get the global parameters. These are:
	- DefaultPort
	- DesiredZOne
	- EnableRouter
	- FilterOurNames

Arguments:

Return Value:

	Status - STATUS_SUCCESS
			 Or other NT status codes
--*/
{
	UNICODE_STRING		valueName, unicodePortName, unicodeZone;
    UNICODE_STRING      rasName;
	HANDLE				ParametersHandle;
	ANSI_STRING			ansiZone;
	BYTE				ansiBuf[MAX_ENTITY_LENGTH+1];
	NTSTATUS			status;
	ULONG				bytesWritten;
	PWCHAR				portName;
	PWCHAR				desiredZoneValue;
	PCHAR				asciiDesiredZone = NULL;
	BYTE				Storage[2*2*MAX_ENTITY_LENGTH+sizeof(KEY_VALUE_FULL_INFORMATION)];
	PKEY_VALUE_FULL_INFORMATION Info = (PKEY_VALUE_FULL_INFORMATION)Storage;
	PULONG				Value;

	do
	{
		// Open the parameters key.
		RtlInitUnicodeString(&valueName, PARAMETERS_STRING);
		status = atalkInitGetHandleToKey(&valueName,
										 &ParametersHandle);
		if (!NT_SUCCESS(status))
		{
			break;
		}

		// Read the "EnableRouter" value name
		RtlInitUnicodeString (&valueName, VALUENAME_ENABLEROUTER);
		status = ZwQueryValueKey(ParametersHandle,
								 &valueName,
								 KeyValueFullInformation,
								 Info,
								 sizeof(Storage),
								 &bytesWritten);
	
		if (status == STATUS_SUCCESS)
		{
			Value = (PULONG)((PBYTE)Info + Info->DataOffset);
			if (*Value != 0)
			{
                // if router wasn't running before, change that! (PnP case)
                if (!AtalkRouter)
                {
				    AtalkRouter = TRUE;
				    AtalkRtmpInit(TRUE);
				    AtalkLockRouterIfNecessary();
                }
			}
            else
            {
                AtalkRouter = FALSE;
            }
		}
		else
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitGlobal: EnableRouter value not found, assuming false\n"));
		}
	
		// Read the "FilterOurNames" value name
		RtlInitUnicodeString (&valueName, VALUENAME_FILTEROURNAMES);
		status = ZwQueryValueKey(ParametersHandle,
								 &valueName,
								 KeyValueFullInformation,
								 Info,
								 sizeof(Storage),
								 &bytesWritten);
	
		if (status == STATUS_SUCCESS)
		{
			Value = (PULONG)((PBYTE)Info + Info->DataOffset);
			if (*Value == 0)
			{
				AtalkFilterOurNames = FALSE;
			}
		}
		else
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
					("atalkInitGlobal: FilterOurNames value not found, assuming true\nq"));
		}
		// Get the default port value
		RtlInitUnicodeString (&valueName, VALUENAME_DEFAULTPORT);
		status = ZwQueryValueKey(ParametersHandle,
								 &valueName,
								 KeyValueFullInformation,
								 Info,
								 sizeof(Storage),
								 &bytesWritten);

		if (status != STATUS_SUCCESS)
		{
			// No default port keyword specified! ABORT
			LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, status, NULL, 0);
			ZwClose(ParametersHandle);
            // let appletalk run: it's just that it won't have default adapter
            status = STATUS_SUCCESS;
			break;
		}

		portName = (PWCHAR)((PBYTE)Info + Info->DataOffset);
        AtalkDefaultPortName.Buffer = NULL;
		if (*portName != 0)
		{
			RtlInitUnicodeString(&unicodePortName, portName);
            RtlInitUnicodeString(&rasName,RAS_ADAPTER_NAME);

            // make sure this isn't RAS adapter (setup bug)
		    if (RtlEqualUnicodeString(&unicodePortName,&rasName,TRUE))
		    {
			    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitGlobal: can't have RAS adapter as default adapter!\n"));

			    // No default port keyword specified! ABORT
			    LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, status, NULL, 0);
			    ZwClose(ParametersHandle);
                status = STATUS_INVALID_PARAMETER;
			    break;
		    }

			AtalkDefaultPortName.Buffer = AtalkAllocMemory(unicodePortName.Length);
			if (AtalkDefaultPortName.Buffer != NULL)
			{
				AtalkDefaultPortName.Length =
                AtalkDefaultPortName.MaximumLength = unicodePortName.Length;
				RtlCopyMemory(AtalkDefaultPortName.Buffer,
							  unicodePortName.Buffer,
							  unicodePortName.Length);
			}
		}

		if (AtalkDefaultPortName.Buffer == NULL)
		{
			LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, status, NULL, 0);
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("WARNING!!! Appletalk driver running, but no default port configured\n"));
			ZwClose(ParametersHandle);

            // let appletalk run: it's just that it won't have default adapter
            status = STATUS_SUCCESS;
			break;
		}
	
		// Get the desired zone value in the form of an asciiz string
		RtlInitUnicodeString (&valueName, VALUENAME_DESIREDZONE);
		status = ZwQueryValueKey(ParametersHandle,
								 &valueName,
								 KeyValueFullInformation,
								 Info,
								 sizeof(Storage),
								 &bytesWritten);
	
		// Close this handle now - we do not need it anymore
		ZwClose(ParametersHandle);
		ParametersHandle = NULL;

		if (status != STATUS_SUCCESS)
		{
			LOG_ERROR(EVENT_ATALK_INVALID_DESIREDZONE, status, NULL, 0);
			status = STATUS_SUCCESS;
			break;
		}

		desiredZoneValue = (PWCHAR)((PBYTE)Info + Info->DataOffset);
		if (*desiredZoneValue != 0)
		{
			RtlInitUnicodeString(&unicodeZone, desiredZoneValue);
			ansiZone.Length = (USHORT)RtlUnicodeStringToAnsiSize(&unicodeZone)-1;
			if (ansiZone.Length > MAX_ENTITY_LENGTH)
			{
				status = STATUS_UNSUCCESSFUL;

				//	Incorrect zone name!
				LOG_ERROR(EVENT_ATALK_INVALID_DESIREDZONE, status, NULL, 0);
				break;
			}
	
			ansiZone.Buffer = ansiBuf;
			ansiZone.MaximumLength = sizeof(ansiBuf);
		
			status = RtlUnicodeStringToAnsiString(&ansiZone,
												  &unicodeZone,
												  (BOOLEAN)FALSE);
	
			if (status == STATUS_SUCCESS)
			{
				AtalkDesiredZone = AtalkZoneReferenceByName(ansiBuf, (BYTE)(ansiZone.Length));
			}
			if ((status != STATUS_SUCCESS) ||
				(AtalkDesiredZone == NULL))
			{
				LOG_ERROR(EVENT_ATALK_RESOURCES, status, NULL, 0);
			}
		}
	} while (FALSE);

	return status;
}


NTSTATUS
atalkInitPort(
	IN	PPORT_DESCRIPTOR	pPortDesc,
	IN	HANDLE				AdaptersHandle
	)
/*++

Routine Description:

	This routine is called during initialization time to get the per port
	parameters from the registry. It will store the per port parameters
	in the port information structures readying them to be passed to the main
	initialize() routine

Arguments:

	AdaptersHandle- Handle to the ...\Parameters\Adapters key in registry

Return Value:

	Status - STATUS_SUCCESS
			 STATUS_INSUFFICIENT_RESOURCES
--*/
{
	OBJECT_ATTRIBUTES	ObjectAttributes;
	NTSTATUS			status;
	BOOLEAN				seeding;

	// Get the key to the adapter for this port
	InitializeObjectAttributes(&ObjectAttributes,
							   &pPortDesc->pd_AdapterKey,		// name
							   OBJ_CASE_INSENSITIVE,			// attributes
							   AdaptersHandle,					// root
							   NULL);							// security descriptor

	status = ZwOpenKey(&pPortDesc->pd_AdapterInfoHandle,
					   KEY_READ,
					   &ObjectAttributes);

	if (!NT_SUCCESS(status))
	{
		if (!AtalkRouter)
			status = STATUS_SUCCESS;

		return status;
	}

    //
    // if this is the first time the adapter is being initialized (usually the case),
    // read the PramNodes from the registry.  If we are initializing this adapter on
    // a PnP event, then there is a good chance our network config has changed, so
    // ignore the registry values and get fresh ones)
    //
    if (!(pPortDesc->pd_Flags & PD_CONFIGURED_ONCE))
    {
        pPortDesc->pd_Flags |= PD_CONFIGURED_ONCE;

	    // Get PRAM Information
	    AtalkInitNodeGetPramAddr(pPortDesc,
		    					 ROUTER_NODE_VALUE,
			    				 &pPortDesc->pd_RoutersPramNode);

	    AtalkInitNodeGetPramAddr(pPortDesc,
		    					 USER_NODE1_VALUE,
			    				 &pPortDesc->pd_UsersPramNode1);

	    AtalkInitNodeGetPramAddr(pPortDesc,
		    					 USER_NODE2_VALUE,
			    				 &pPortDesc->pd_UsersPramNode2);
    }
    else
    {
        ASSERT(pPortDesc->pd_RoutersPramNode.atn_Network == 0);
        ASSERT(pPortDesc->pd_RoutersPramNode.atn_Node == 0);
        ASSERT(pPortDesc->pd_UsersPramNode1.atn_Network == 0);
        ASSERT(pPortDesc->pd_UsersPramNode1.atn_Node == 0);
        ASSERT(pPortDesc->pd_UsersPramNode2.atn_Network == 0);
        ASSERT(pPortDesc->pd_UsersPramNode2.atn_Node == 0);
    }

	// If we are a router, get the following information
	if (AtalkRouter)
	{
		if (!DEF_PORT(pPortDesc))
		{
			AtalkZapPramValue(pPortDesc, USER_NODE1_VALUE);
			AtalkZapPramValue(pPortDesc, USER_NODE2_VALUE);
		}
		atalkInitSeeding(pPortDesc, &seeding);

		//	Check following values only if the seeding flag	is set.
		if (seeding) do
		{
			// Get the Network range information. Value names are
			// NetworkRangeLowerEnd & NetworkRangeUpperEnd
			status = atalkInitNetRange(pPortDesc);

			if (!NT_SUCCESS(status))
			{
				LOG_ERRORONPORT(pPortDesc,
			                    EVENT_ATALK_SEEDROUTER_NONETRANGE,
								0,
								NULL,
								0);
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitPort: Could not get network range\n"));

				break;
			}
	
			status = atalkInitNetRangeCheck(pPortDesc);

			if (!NT_SUCCESS(status))
			{
				break;
			}

			// Get the Zone list information. Value name is ZoneList
			status = atalkInitZoneList(pPortDesc);

			if (!NT_SUCCESS(status))
			{
				LOG_ERRORONPORT(pPortDesc,
			                    EVENT_ATALK_SEEDROUTER_NOZONELIST,
								0,
								NULL,
								0);
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitPort: Could not get zone list\n"));

				break;
			}
	
			// Get the default zone specification. Value name is DefaultZone
			status = atalkInitDefZone(pPortDesc);

			if (!NT_SUCCESS(status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitPort: Could not get default zone\n"));

				break;
			}

			//	Check for default zone being in the zone list for the port
			//	Also make sure that a localtalk port is not specified
			//	as the default port. And that a default zone was not
			//	specified for a localtalk port. We can only do this after
			//	bind as we do not know until then the media type.
			if (pPortDesc->pd_Flags & PD_SEED_ROUTER)
			{
				if (pPortDesc->pd_InitialDefaultZone == NULL)
				{
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_NO_DEFZONE,
									0,
									NULL,
									0);
					status = STATUS_UNSUCCESSFUL;
					break;
				}
				if (pPortDesc->pd_InitialZoneList == NULL)
				{
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_SEEDROUTER_NOZONELIST,
									0,
									NULL,
									0);
					status = STATUS_UNSUCCESSFUL;
					break;
				}
				if (!AtalkZoneOnList(pPortDesc->pd_InitialDefaultZone,
									 pPortDesc->pd_InitialZoneList))
				{
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_ZONE_NOTINLIST,
									0,
									NULL,
									0);
					status = STATUS_UNSUCCESSFUL;
					break;
				}
			}
		} while (FALSE);
	}
	else
	{
		AtalkZapPramValue(pPortDesc, ROUTER_NODE_VALUE);
	}

	if (NT_SUCCESS(status)) do
	{
		// Get the per-Port parameters
		status = atalkInitPortParameters(pPortDesc);
	
		if (!NT_SUCCESS(status))
		{
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitPort: Could not get port parameters\n"));
		}
	
		//	None of the above affect us loading.
		status = STATUS_SUCCESS;
		break;

	} while (FALSE);

	return status;
}


NTSTATUS
atalkInitNetRangeCheck(
	IN	PPORT_DESCRIPTOR		pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPORT_DESCRIPTOR	pTmp;
	NTSTATUS			status = STATUS_SUCCESS;

	do
	{
		//	Check for network range overlap among all the ports
		for (pTmp = AtalkPortList;
			 pTmp != NULL;
			 pTmp = pTmp->pd_Next)
		{
			if (pTmp != pPortDesc)
			{
				if ((pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK) &&
					(pTmp->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK))
				{
					if (AtalkRangesOverlap(&pPortDesc->pd_InitialNetworkRange,
										   &pTmp->pd_InitialNetworkRange))
					{
						LOG_ERRORONPORT(pPortDesc,
										EVENT_ATALK_INITIAL_RANGEOVERLAP,
										status,
										NULL,
										0);
		
						status = STATUS_UNSUCCESSFUL;
						break;
					}
				}
			}
		}

		if (!NT_SUCCESS(status))
		{
			break;
		}

		//	Make sure any PRAM values we might have are in this range
		if ((pPortDesc->pd_RoutersPramNode.atn_Network != UNKNOWN_NETWORK) &&
            (pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK) &&
			!(WITHIN_NETWORK_RANGE(pPortDesc->pd_RoutersPramNode.atn_Network,
								   &pPortDesc->pd_InitialNetworkRange)))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_PRAM_OUTOFSYNC,
							status,
							NULL,
							0);
		
			pPortDesc->pd_RoutersPramNode.atn_Network = UNKNOWN_NETWORK;
			pPortDesc->pd_RoutersPramNode.atn_Node	  = UNKNOWN_NODE;
		}
		
		if ((pPortDesc->pd_UsersPramNode1.atn_Network != UNKNOWN_NETWORK) &&
	        (pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK) &&
			!(WITHIN_NETWORK_RANGE(pPortDesc->pd_UsersPramNode1.atn_Network,
								   &pPortDesc->pd_InitialNetworkRange)))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_PRAM_OUTOFSYNC,
							status,
							NULL,
							0);
		
			pPortDesc->pd_UsersPramNode1.atn_Network = UNKNOWN_NETWORK;
			pPortDesc->pd_UsersPramNode1.atn_Node	 = UNKNOWN_NODE;
		}
		if ((pPortDesc->pd_UsersPramNode2.atn_Network != UNKNOWN_NETWORK) &&
	        (pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork != UNKNOWN_NETWORK) &&
			!(WITHIN_NETWORK_RANGE(pPortDesc->pd_UsersPramNode2.atn_Network,
								   &pPortDesc->pd_InitialNetworkRange)))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_PRAM_OUTOFSYNC,
							status,
							NULL,
							0);
		
			pPortDesc->pd_UsersPramNode2.atn_Network = UNKNOWN_NETWORK;
			pPortDesc->pd_UsersPramNode2.atn_Node	 = UNKNOWN_NODE;
		}
	} while (FALSE);

	return status;
}




NTSTATUS
atalkInitNetRange(
	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

	Gets the network range for the port defined by AdapterInfoHandle

Arguments:

	AdapterInfoHandle- Handle to ...Atalk\Adapters\<adapterName>
	pPortDesc- Pointer to port information structure for the port

Return Value:

	Status - STATUS_SUCCESS or system call returned status codes
--*/
{
	UNICODE_STRING	valueName;
	NTSTATUS		registryStatus;
	ULONG			bytesWritten;
	PULONG			netNumber;

	BYTE			netNumberStorage[sizeof(KEY_VALUE_FULL_INFORMATION) + 80];
	PKEY_VALUE_FULL_INFORMATION netValue = (PKEY_VALUE_FULL_INFORMATION)netNumberStorage;

	do
	{
		// Read the "NetworkRangeLowerEnd" value name
		RtlInitUnicodeString (&valueName, VALUENAME_NETLOWEREND);
		registryStatus = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
										 &valueName,
										 KeyValueFullInformation,
										 netValue,
										 sizeof(netNumberStorage),
										 &bytesWritten);

		//	This should change with the routing flags.
		if (registryStatus != STATUS_SUCCESS)
		{
			// Set defaults
			pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork = UNKNOWN_NETWORK;
			pPortDesc->pd_InitialNetworkRange.anr_LastNetwork  = UNKNOWN_NETWORK;
	
			registryStatus = STATUS_SUCCESS;
			break;
		}

		netNumber = (PULONG)((PBYTE)netValue + netValue->DataOffset);
		pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork = (USHORT)(*netNumber);

		// Get the upper number only if lower was specified
		RtlInitUnicodeString (&valueName, VALUENAME_NETUPPEREND);
		registryStatus = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
										 &valueName,
										 KeyValueFullInformation,
										 netValue,
										 sizeof(netNumberStorage),
										 &bytesWritten);

		if (registryStatus != STATUS_SUCCESS)
		{
			// Do not load if lower end specified but upper end was not
			break;
		}

		// Set the upper end of the network range
		netNumber = (PULONG)((PBYTE)netValue + netValue->DataOffset);
		pPortDesc->pd_InitialNetworkRange.anr_LastNetwork =(USHORT)(*netNumber);

		if (!AtalkCheckNetworkRange(&pPortDesc->pd_InitialNetworkRange))
		{
			registryStatus = STATUS_UNSUCCESSFUL;
			break;
		}
	} while (FALSE);

	if (registryStatus != STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_INVALID_NETRANGE,
						registryStatus,
						NULL,
						0);
	}

	return registryStatus;
}




NTSTATUS
atalkInitZoneList(
	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

	Gets the zone list for the port defined by AdapterInfoHandle

Arguments:

	AdapterInfoHandle- Handle to ...Atalk\Adapters\<adapterName>
	pPortDesc- Pointer to port information structure for the port

Return Value:

	Status - STATUS_SUCCESS or system call returned status codes
--*/
{
	UNICODE_STRING	valueName;
	NTSTATUS		status;
	ULONG			bytesWritten;
	PWCHAR			curZoneValue;

	// Anticipate about 10 zones and get space for those, if more then do a
	// dynamic alloc. Note that the below *does not* guarantee 10 zones...
	BYTE			zoneStorage[10*2*(MAX_ENTITY_LENGTH)+sizeof(KEY_VALUE_FULL_INFORMATION)];
	PKEY_VALUE_FULL_INFORMATION zoneValue = (PKEY_VALUE_FULL_INFORMATION)zoneStorage;

	RtlInitUnicodeString (&valueName, VALUENAME_ZONELIST);
	status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 zoneValue,
							 sizeof(zoneStorage),
							 &bytesWritten);

	if (status == STATUS_BUFFER_OVERFLOW)
	{
		// If error was a buffer overrun, then allocate space and try again
		zoneValue = (PKEY_VALUE_FULL_INFORMATION)AtalkAllocMemory(bytesWritten);
		if (zoneValue == NULL)
		{
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
								 &valueName,
								 KeyValueFullInformation,
								 zoneValue,
								 bytesWritten,
								 &bytesWritten);
	}

	do
	{
		if (status != STATUS_SUCCESS)
		{
			break;
		}
	
		// Proceed to get zone list
		pPortDesc->pd_InitialZoneList = NULL;
		curZoneValue = (PWCHAR)((PBYTE)zoneValue + zoneValue->DataOffset);
		while (*curZoneValue != 0)
		{
			UNICODE_STRING	Us;
			ANSI_STRING		As;
			BYTE			ansiBuf[MAX_ENTITY_LENGTH + 1];

			RtlInitUnicodeString(&Us, curZoneValue);

			As.Buffer = ansiBuf;
			As.Length = (USHORT)RtlUnicodeStringToAnsiSize(&Us) - 1;
			As.MaximumLength = sizeof(ansiBuf);

			if (As.Length > MAX_ENTITY_LENGTH)
			{
				//	Incorrect zone name!
				LOG_ERROR(EVENT_ATALK_INVALID_ZONEINLIST, status, NULL, 0);
			}

			status = RtlUnicodeStringToAnsiString(&As, &Us, FALSE);

			if (!NT_SUCCESS(status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitZoneList: RtlUnicodeStringToAnsiSize %lx\n", status));
	
				break;
			}
	
			// Insert the zone in the list in Port
			pPortDesc->pd_InitialZoneList = AtalkZoneAddToList(pPortDesc->pd_InitialZoneList,
															   ansiBuf,
															   (BYTE)(As.Length));

			if (pPortDesc->pd_InitialZoneList == NULL)
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitZoneList: AtalkZoneAddToList failed\n"));
				break;
			}
	
			// Now advance the curZoneValue value to next zone
			curZoneValue = (PWCHAR)((PBYTE)curZoneValue + Us.Length + sizeof(WCHAR));
		}

	} while (FALSE);

	if ((PVOID)zoneValue != (PVOID)zoneStorage)
	{
		AtalkFreeMemory(zoneValue);
	}

	return status;
}




NTSTATUS
atalkInitDefZone(
	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

	Gets the default zone for the port defined by AdapterInfoHandle

Arguments:

	AdapterInfoHandle- Handle to ...Atalk\Adapters\<adapterName>
	pPort- Pointer to port information structure for the port

Return Value:

	Status - STATUS_SUCCESS or system call returned status codes
--*/
{
	UNICODE_STRING	valueName;
	NTSTATUS		status;
	ULONG			bytesWritten;
	PWCHAR			defZoneValue;
	BYTE			zoneStorage[2*MAX_ENTITY_LENGTH+sizeof(KEY_VALUE_FULL_INFORMATION)];
	PKEY_VALUE_FULL_INFORMATION zoneValue = (PKEY_VALUE_FULL_INFORMATION)zoneStorage;

	RtlInitUnicodeString (&valueName, VALUENAME_DEFAULTZONE);
	status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 zoneValue,
							 sizeof(zoneStorage),
							 &bytesWritten);
	if (status == STATUS_BUFFER_OVERFLOW)
	{
		// If error was a buffer overrun, then allocate space and try again
		zoneValue = (PKEY_VALUE_FULL_INFORMATION)AtalkAllocMemory(bytesWritten);
		if (zoneValue == NULL)
		{
			return STATUS_INSUFFICIENT_RESOURCES;
		}

		status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
								 &valueName,
								 KeyValueFullInformation,
								 zoneValue,
								 bytesWritten,
								 &bytesWritten);
	}

	do
	{
		if (status != STATUS_SUCCESS)
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NO_DEFZONE,
							status,
							NULL,
							0);

			status = STATUS_SUCCESS;
			break;
		}
		else
		{
			ANSI_STRING		ansiZone;
			UNICODE_STRING	unicodeZone;
			BYTE			ansiBuf[MAX_ENTITY_LENGTH+1];
			NTSTATUS		status;

			defZoneValue = (PWCHAR)((PBYTE)zoneValue + zoneValue->DataOffset);
			if (*defZoneValue != 0)
			{
				RtlInitUnicodeString(&unicodeZone, defZoneValue);
				ansiZone.Length = (USHORT)RtlUnicodeStringToAnsiSize(&unicodeZone) - 1;
				if (ansiZone.Length > MAX_ENTITY_LENGTH+1)
				{
					status = STATUS_UNSUCCESSFUL;

					//	Incorrect zone name!
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_INVALID_DEFZONE,
									status,
									NULL,
									0);
					break;
				}
	
				ansiZone.Buffer = ansiBuf;
				ansiZone.MaximumLength = sizeof(ansiBuf);
			
				status = RtlUnicodeStringToAnsiString(&ansiZone, &unicodeZone, (BOOLEAN)FALSE);
	
				if (status == STATUS_SUCCESS)
				{
					PZONE		pZone;
					PZONE_LIST 	pZoneList;

					// Ensure that the zone exists in the zone list, We are seed-routing
					ASSERT(pPortDesc->pd_Flags & PD_SEED_ROUTER);
					for (pZoneList = pPortDesc->pd_InitialZoneList;
						 pZoneList != NULL;
						 pZoneList = pZoneList->zl_Next)
					{
						pZone = pZoneList->zl_pZone;

						if (AtalkFixedCompareCaseInsensitive(pZone->zn_Zone,
															 pZone->zn_ZoneLen,
															 ansiBuf,
															 ansiZone.Length))
						{
							break;
						}
					}
					if (pZone == NULL)
					{
						//	Incorrect zone name - not in the list
						LOG_ERRORONPORT(pPortDesc,
										EVENT_ATALK_INVALID_DEFZONE,
										status,
										NULL,
										0);
					}
					pPortDesc->pd_InitialDefaultZone = AtalkZoneReferenceByName(ansiBuf,
																				(BYTE)(ansiZone.Length));
				}
				if ((status != STATUS_SUCCESS) ||
					(pPortDesc->pd_InitialDefaultZone == NULL))
				{
					LOG_ERROR(EVENT_ATALK_RESOURCES, status, NULL, 0);
				}
			}
		}
	} while (FALSE);

	if ((PVOID)zoneValue != (PVOID)zoneStorage)
	{
		AtalkFreeMemory(zoneValue);
	}

	return status;
}




NTSTATUS
atalkInitSeeding(
	IN OUT	PPORT_DESCRIPTOR	pPortDesc,
	OUT		PBOOLEAN			Seeding
	)
/*++

Routine Description:

	Gets the value of the enable router flag from the registry. Sets the
	startRouter value in PortInfo based on this flag.

Arguments:

	AdapterHandle- Handle to the Adapter in registry

Return Value:

	Value of the flag:  TRUE/FALSE
--*/
{

	UNICODE_STRING	valueName;
	NTSTATUS		registryStatus;
	ULONG			bytesWritten;
	PULONG			seedingPortFlag;
	BYTE			flagStorage[sizeof(KEY_VALUE_FULL_INFORMATION)+32];

	PKEY_VALUE_FULL_INFORMATION flagValue = (PKEY_VALUE_FULL_INFORMATION)flagStorage;

	*Seeding = FALSE;

	// Read the "seedingPort" value name
	RtlInitUnicodeString (&valueName, VALUENAME_SEEDROUTER);
	registryStatus = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
									 &valueName,
									 KeyValueFullInformation,
									 flagValue,
									 sizeof(flagStorage),
									 &bytesWritten);

	if (registryStatus == STATUS_SUCCESS)
	{
		seedingPortFlag = (PULONG)((PBYTE)flagValue + flagValue->DataOffset);
		if (*seedingPortFlag != 0)
		{
			*Seeding = TRUE;
			pPortDesc->pd_Flags |= PD_SEED_ROUTER;
		}
	}

	return registryStatus;
}


NTSTATUS
atalkInitPortParameters(
	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

	Gets the per-port parameters for the port

Arguments:

	pPortDesc- Pointer to port information structure for the port

Return Value:

	Status - STATUS_SUCCESS or system call returned status codes
--*/
{
	UNICODE_STRING	valueName;
	NTSTATUS		status;
	ULONG			bytesWritten;
	BYTE			Storage[sizeof(KEY_VALUE_FULL_INFORMATION)+4*MAX_ENTITY_LENGTH];
	PKEY_VALUE_FULL_INFORMATION pInfo = (PKEY_VALUE_FULL_INFORMATION)Storage;

	// Read the "DdpChecksums" value name
	RtlInitUnicodeString (&valueName, VALUENAME_DDPCHECKSUMS);
	status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 pInfo,
							 sizeof(Storage),
							 &bytesWritten);

	if (status == STATUS_SUCCESS)
	{
		PULONG	ddpChecksumFlag;

		ddpChecksumFlag = (PULONG)((PBYTE)pInfo + pInfo->DataOffset);
		if ((*ddpChecksumFlag) != 0)
		{
			pPortDesc->pd_Flags |= PD_SEND_CHECKSUMS;
		}
	}

	// Read the "AarpRetries" value name
	RtlInitUnicodeString (&valueName, VALUENAME_AARPRETRIES);
	status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 pInfo,
							 sizeof(Storage),
							 &bytesWritten);

	if (status == STATUS_SUCCESS)
	{
		PULONG	aarpRetries;

		aarpRetries = (PULONG)((PBYTE)pInfo + pInfo->DataOffset);
		pPortDesc->pd_AarpProbes = (USHORT)*aarpRetries;
	}

	RtlInitUnicodeString (&valueName, VALUENAME_PORTNAME);
	status = ZwQueryValueKey(pPortDesc->pd_AdapterInfoHandle,
							 &valueName,
							 KeyValueFullInformation,
							 pInfo,
							 sizeof(Storage),
							 &bytesWritten);

	do
	{
		if (status == STATUS_SUCCESS)
		{
			PWCHAR			portName;
			ANSI_STRING		ansiPort;
			UNICODE_STRING	unicodePort;
			ULONG			ansiSize;
			NTSTATUS		status;
	
			portName = (PWCHAR)((PBYTE)pInfo + pInfo->DataOffset);
			if (*portName != 0)
			{
	
				RtlInitUnicodeString(&unicodePort, portName);
				ansiSize = RtlUnicodeStringToAnsiSize(&unicodePort);
				if (ansiSize > MAX_ENTITY_LENGTH+1)
				{
					status = STATUS_UNSUCCESSFUL;

					//	Incorrect port name!
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_INVALID_PORTNAME,
									status,
									NULL,
									0);
					break;
				}
	
				ansiPort.Buffer = pPortDesc->pd_PortName;
				ansiPort.MaximumLength = (USHORT)ansiSize+1;
				ansiPort.Length = 0;
			
				status = RtlUnicodeStringToAnsiString(&ansiPort,
													  &unicodePort,
													  (BOOLEAN)FALSE);
	
				if (status != STATUS_SUCCESS)
				{
					LOG_ERROR(EVENT_ATALK_RESOURCES,status, NULL, 0);
				}
			}
			else
			{
				//	NULL Port Name! Set status to unsuccessful so we copy
				//	default name at the end.
				status = STATUS_UNSUCCESSFUL;
			}
		}

	} while (FALSE);

	//	Do we need to copy the default port name?
	if (!NT_SUCCESS(status))
	{
		RtlCopyMemory(pPortDesc->pd_PortName, ATALK_PORT_NAME, ATALK_PORT_NAME_SIZE);
	}

	return status;
}


NTSTATUS
atalkInitStartPort(
	IN	OUT	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ATALK_NODEADDR	Node;
	ATALK_ADDR		AtalkAddr;
	PDDP_ADDROBJ	pDdpAddr;
	KIRQL			OldIrql;
	ATALK_ERROR		error;
	ULONG			length;
	NTSTATUS		status = STATUS_UNSUCCESSFUL;
    INT             LookaheadSize;
    BOOLEAN         fPnpReconfigure;


    fPnpReconfigure = (pPortDesc->pd_Flags & PD_PNP_RECONFIGURE)? TRUE : FALSE;

	do
	{
		//	Initialize NetworkRange. We can do this here, only *after*
		//	we bind, as we dont know our port type until then.
		if (EXT_NET(pPortDesc))
		{
			pPortDesc->pd_NetworkRange.anr_FirstNetwork = FIRST_VALID_NETWORK;
			pPortDesc->pd_NetworkRange.anr_LastNetwork = LAST_STARTUP_NETWORK;
		}
		else
		{
			pPortDesc->pd_NetworkRange.anr_FirstNetwork =
			pPortDesc->pd_NetworkRange.anr_LastNetwork = UNKNOWN_NETWORK;
			pPortDesc->pd_LtNetwork = UNKNOWN_NETWORK;
		}

        //
        // only when the adapter is initialized for the first time, we need
        // to all the initialization stuff (like set lookahead size etc.).
        // If we are here because of a PnPReconfigure event, don't do it
        //
        if (!fPnpReconfigure)
        {
		    error = AtalkInitNdisQueryAddrInfo(pPortDesc);
		    if (!ATALK_SUCCESS(error))
		    {
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitStartPort: Error in AtalkInitNdisQueryAddrInfo %lx\n", error));
			    break;
		    }

            LookaheadSize = AARPLINK_MAX_PKT_SIZE;
            if (pPortDesc->pd_NdisPortType == NdisMedium802_5)
            {
                LookaheadSize = AARPLINK_MAX_PKT_SIZE + TLAP_MAX_LINKHDR_LEN;
            }
            else if (pPortDesc->pd_NdisPortType == NdisMediumWan)
            {
                LookaheadSize = AARPLINK_MAX_PKT_SIZE + TLAP_MAX_LINKHDR_LEN;
            }

		    //	Set lookahead to be the max of the complete aarp packet including link
		    error = AtalkInitNdisSetLookaheadSize(pPortDesc, LookaheadSize);
		    if (!ATALK_SUCCESS(error))
		    {
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitStartPort: Error in AtalkInitNdisSetLookaheadSize %lx\n", error));
			    break;
		    }

            //
            // if this is an ARAP port, we need to do a little more work (e.g. set the
            // protocol type, etc.
            //
            if (pPortDesc->pd_Flags & PD_RAS_PORT)
            {
                error = ArapAdapterInit( pPortDesc );
		        if (!ATALK_SUCCESS(error))
		        {
    	            DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_ERR,
                        ("ArapAdapterInit: failed (%d)\n",error));
			        break;
		        }
            }

		    if (pPortDesc->pd_AddMulticastAddr)
		    {
    			error = (*pPortDesc->pd_AddMulticastAddr)(pPortDesc,
													    pPortDesc->pd_BroadcastAddr,
													    TRUE,
													    NULL,
													    NULL);

			    if (!ATALK_SUCCESS(error))
			    {
					DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitStartPort: Error in pd_AddMulticastAddr %lx\n", error));
    				break;
			    }
		    }
    			
		    error = AtalkInitNdisStartPacketReception(pPortDesc);

		    if (!ATALK_SUCCESS(error))
		    {
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("atalkInitStartPort: Error in AtalkInitNdisStartPacketReception %lx\n", error));
    			LOG_ERRORONPORT(pPortDesc,
							    EVENT_ATALK_RECEPTION,
							    0,
							    NULL,
							    0);
			    break;
		    }

        }  // if (!fPnpReconfigure)

		//	Set flag to active here. Until then all packets will be dropped
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		pPortDesc->pd_Flags |= PD_ACTIVE;
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

        // if this is arap port, we are done at this point
        if (pPortDesc->pd_Flags & PD_RAS_PORT)
        {
            RtlZeroMemory(pPortDesc->pd_PortStats.prtst_PortName,
                          sizeof(pPortDesc->pd_PortStats.prtst_PortName));

		    //	Set up the name in the statistics structure.
		    length = MIN(pPortDesc->pd_AdapterKey.Length,
                         ((MAX_INTERNAL_PORTNAME_LEN * sizeof(WCHAR)) - sizeof(WCHAR)));
	
		    RtlCopyMemory(pPortDesc->pd_PortStats.prtst_PortName,
					      pPortDesc->pd_AdapterKey.Buffer,
					      length);
	
		    AtalkStatistics.stat_NumActivePorts++;
	
		    AtalkNumberOfActivePorts ++;
		    status = STATUS_SUCCESS;
            break;
        }

		//	is localtalk our default port? if so, we make sure routing is not on.
		if (AtalkRouter && !EXT_NET(pPortDesc) && DEF_PORT(pPortDesc))
		{
			//	No can do.
			break;
		}

		//	We need to have a node created on every single port. If routing
		//	is on, then this will be the router node. The Default port will
		//	also have an additional user node. In the case, where we are non-
		//	routing, we should only create the user node on the default port.
		//	The other nodes will be created on the other ports as usual.
		//
		//	!!!	AtalkNodeCreateOnPort should set the pointer to the router
		//		node in the port descriptor. !!!

		//	Make sure we do not create this node if localtalk default port.
		if (!DEF_PORT(pPortDesc) || AtalkRouter)
		{
			BOOLEAN	allowstartuprange = !AtalkRouter;

			//	If router then startup range is not allowed!
			error = AtalkInitNodeCreateOnPort(pPortDesc,
											  allowstartuprange,
											  AtalkRouter,
											  &Node);
			if (!ATALK_SUCCESS(error))
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_INIT_COULDNOTGETNODE,
								0,
								NULL,
								0);
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitStartPort: Failed to open node on port %lx (%Z)\n",
						pPortDesc, &pPortDesc->pd_AdapterKey));
				break;
			}
	
			if (AtalkRouter)
			{
				//	Start RTMP/ZIP Processing on this port.
				if (!AtalkInitRtmpStartProcessingOnPort(pPortDesc, &Node) ||
					!AtalkInitZipStartProcessingOnPort(pPortDesc, &Node))
				{
					break;
				}
			}

			//	Register the port name on the NIS on this node.
			AtalkAddr.ata_Network = Node.atn_Network;
			AtalkAddr.ata_Node	=   Node.atn_Node;
			AtalkAddr.ata_Socket  = NAMESINFORMATION_SOCKET;
		
			AtalkDdpReferenceByAddr(pPortDesc,
									&AtalkAddr,
									&pDdpAddr,
									&error);
		
			if (ATALK_SUCCESS(error))
			{
				PACTREQ		pActReq;
				NBPTUPLE	NbpTuple;
				
				NbpTuple.tpl_Zone[0] = '*';
				NbpTuple.tpl_ZoneLen = 1;
                NbpTuple.tpl_ObjectLen = (BYTE)strlen(pPortDesc->pd_PortName);
				RtlCopyMemory(NbpTuple.tpl_Object,
							  pPortDesc->pd_PortName,
							  NbpTuple.tpl_ObjectLen);
				if (AtalkRouter)
				{
					RtlCopyMemory(NbpTuple.tpl_Type,
								  ATALK_ROUTER_NBP_TYPE,
								  sizeof(ATALK_ROUTER_NBP_TYPE) - 1);
					NbpTuple.tpl_TypeLen = sizeof(ATALK_ROUTER_NBP_TYPE) - 1;
				}
				else
				{
					RtlCopyMemory(NbpTuple.tpl_Type,
								  ATALK_NONROUTER_NBP_TYPE,
								  sizeof(ATALK_NONROUTER_NBP_TYPE) - 1);
					NbpTuple.tpl_TypeLen = sizeof(ATALK_NONROUTER_NBP_TYPE) - 1;
				}
	
				// Initialize parameters and call AtalkNbpAction
				if ((pActReq = AtalkAllocZeroedMemory(sizeof(ACTREQ))) == NULL)
					error = ATALK_RESR_MEM;
				else
				{
#if	DBG
					pActReq->ar_Signature = ACTREQ_SIGNATURE;
#endif
					pActReq->ar_Completion = atalkRegNbpComplete;
					pActReq->ar_pParms = pPortDesc;
					AtalkLockNbpIfNecessary();
					error = AtalkNbpAction(pDdpAddr,
										   FOR_REGISTER,
										   &NbpTuple,
										   NULL,
										   0,
										   pActReq);
			
                    if (!ATALK_SUCCESS(error))
                    {
					    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
							("atalkInitStartPort: AtalkNbpAction returned %lx\n",
							error));
                        ASSERT(0);
                        AtalkFreeMemory(pActReq);
                        AtalkUnlockNbpIfNecessary();
                    }
                    else
                    {
					    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
							("atalkInitStartPort: AtalkNbpAction(Register) %lx\n",
							error));
                    }
				}
				//	Remove the reference added here.
				AtalkDdpDereference(pDdpAddr);
			}
			else
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_INIT_NAMEREGISTERFAILED,
								AtalkErrorToNtStatus(error),
								NULL,
								0);
			}
		}

		//	If this is the default port, open the user node on it.
		if (DEF_PORT(pPortDesc))
		{
			ASSERT(!AtalkRouter || EXT_NET(pPortDesc));

			if (!ATALK_SUCCESS(AtalkInitNodeCreateOnPort(pPortDesc,
														 TRUE,
														 FALSE,
														 &Node)))
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_INIT_COULDNOTGETNODE,
								0,
								NULL,
								0);
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
						("atalkInitStartPort: Failed to open node on port %lx (%Z)\n",
						pPortDesc, &pPortDesc->pd_AdapterKey));
				break;
			}

			ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
			pPortDesc->pd_Flags |= PD_USER_NODE_1;
			AtalkUserNode1 = Node;
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

			//	Register the port name on the NIS on this node.
			AtalkAddr.ata_Network = Node.atn_Network;
			AtalkAddr.ata_Node	= Node.atn_Node;
			AtalkAddr.ata_Socket  = NAMESINFORMATION_SOCKET;
			AtalkDdpReferenceByAddr(pPortDesc,
									&AtalkAddr,
									&pDdpAddr,
									&error);

			if (ATALK_SUCCESS(error))
			{
				PACTREQ		pActReq;
				NBPTUPLE	NbpTuple;
				
				NbpTuple.tpl_Zone[0] = '*';
				NbpTuple.tpl_ZoneLen = 1;
                RtlCopyMemory(NbpTuple.tpl_Object,
							  pPortDesc->pd_PortName,
							  NbpTuple.tpl_ObjectLen = (BYTE)strlen(pPortDesc->pd_PortName));
				RtlCopyMemory(NbpTuple.tpl_Type,
							  ATALK_NONROUTER_NBP_TYPE,
							  sizeof(ATALK_NONROUTER_NBP_TYPE) - 1);
				NbpTuple.tpl_TypeLen = sizeof(ATALK_NONROUTER_NBP_TYPE) - 1;

				// Initialize parameters and call AtalkNbpAction
				if ((pActReq = AtalkAllocZeroedMemory(sizeof(ACTREQ))) == NULL)
					error = ATALK_RESR_MEM;
				else
				{
#if	DBG
					pActReq->ar_Signature = ACTREQ_SIGNATURE;
#endif
					pActReq->ar_Completion = atalkRegNbpComplete;
					pActReq->ar_pParms = pPortDesc;
					AtalkLockNbpIfNecessary();
					error = AtalkNbpAction(pDdpAddr,
											FOR_REGISTER,
											&NbpTuple,
											NULL,
											0,
											pActReq);

                    if (!ATALK_SUCCESS(error))
                    {
					    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
							("atalkInitStartPort: AtalkNbpAction returned %lx\n",
							error));
                        AtalkFreeMemory(pActReq);
                        AtalkUnlockNbpIfNecessary();
                    }
                    else
                    {
					    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
							("atalkInitStartPort: AtalkNbpAction(Register) %lx\n",
							error));
                    }
				}
				//	Remove the reference added here.
				AtalkDdpDereference(pDdpAddr);
			}
			else
			{
				LOG_ERRORONPORT(pPortDesc,
								EVENT_ATALK_INIT_NAMEREGISTERFAILED,
								STATUS_UNSUCCESSFUL,
								NULL,
								0);
			}

			//	If we are an extended port, we open a second node on the port.
			if (EXT_NET(pPortDesc))
			{
				if (ATALK_SUCCESS(AtalkInitNodeCreateOnPort(pPortDesc,
															 TRUE,
															 FALSE,
															 &Node)))
				{
					ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
					pPortDesc->pd_Flags |= PD_USER_NODE_2;
					AtalkUserNode2 = Node;
					RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
				}
				else
				{
					LOG_ERRORONPORT(pPortDesc,
									EVENT_ATALK_INIT_COULDNOTGETNODE,
									0,
									NULL,
									0);

					DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
							("atalkInitStartPort: Fail 2nd node port %lx (%Z)\n",
							pPortDesc, &pPortDesc->pd_AdapterKey));
				}
			}
		}

		// Start the Amt and Brc timers for the port, only for extended ports
		if (EXT_NET(pPortDesc))
		{
			AtalkPortReferenceByPtr(pPortDesc, &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkTimerInitialize(&pPortDesc->pd_BrcTimer,
									 AtalkAarpBrcTimer,
									 BRC_AGE_TIME);
				AtalkTimerScheduleEvent(&pPortDesc->pd_BrcTimer);
			}
	
			AtalkPortReferenceByPtr(pPortDesc, &error);
			if (ATALK_SUCCESS(error))
			{
				AtalkTimerInitialize(&pPortDesc->pd_AmtTimer,
									 AtalkAarpAmtTimer,
									 AMT_AGE_TIME);
				AtalkTimerScheduleEvent(&pPortDesc->pd_AmtTimer);
			}
		}

		// Start the Rtmp aging timer for non-routing case
		if (!AtalkRouter)
		{
			AtalkPortReferenceByPtr(pPortDesc, &error);
			if (!ATALK_SUCCESS(error))
			{
				break;
			}

			AtalkTimerInitialize(&pPortDesc->pd_RtmpAgingTimer,
								 AtalkRtmpAgingTimer,
								 RTMP_AGING_TIMER);
			AtalkTimerScheduleEvent(&pPortDesc->pd_RtmpAgingTimer);
		}

        RtlZeroMemory(pPortDesc->pd_PortStats.prtst_PortName,
                      sizeof(pPortDesc->pd_PortStats.prtst_PortName));

		//	Set up the name in the statistics structure.
		length = MIN(pPortDesc->pd_AdapterKey.Length,
                     ((MAX_INTERNAL_PORTNAME_LEN * sizeof(WCHAR)) - sizeof(WCHAR)));

		RtlCopyMemory(pPortDesc->pd_PortStats.prtst_PortName,
					  pPortDesc->pd_AdapterKey.Buffer,
					  length);
	
		status = STATUS_SUCCESS;

	} while (FALSE);

    //
    // in case of PnP, we want to get the stats right even in case of failure
    //
    if (fPnpReconfigure || NT_SUCCESS(status))
    {
		AtalkStatistics.stat_NumActivePorts++;
	
		AtalkNumberOfActivePorts ++;
    }

	if (!NT_SUCCESS(status))
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("atalkInitStartPort: Start port failed %lx %s\n",
                status, (fPnpReconfigure)?"(during PnP)" : " "));
	}

	return status;
}




VOID
atalkRegNbpComplete(
	IN	ATALK_ERROR		Status,
	IN	PACTREQ			pActReq
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ASSERT (VALID_ACTREQ(pActReq));

	if (ATALK_SUCCESS(Status))
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("atalkInitNbpCompletion: NBP Name registered on port %Z\n",
				&((PPORT_DESCRIPTOR)(pActReq->ar_pParms))->pd_AdapterKey));
		LOG_ERRORONPORT((PPORT_DESCRIPTOR)(pActReq->ar_pParms),
						EVENT_ATALK_INIT_NAMEREGISTERED,
						STATUS_SUCCESS,
						NULL,
						0);
	}
	else
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
				("atalkInitNbpCompletion: Failed to register name on port %Z (%ld)\n",
				&((PPORT_DESCRIPTOR)(pActReq->ar_pParms))->pd_AdapterKey, Status));
		LOG_ERRORONPORT((PPORT_DESCRIPTOR)(pActReq->ar_pParms),
						EVENT_ATALK_INIT_NAMEREGISTERFAILED,
						STATUS_UNSUCCESSFUL,
						NULL,
						0);
	}

	AtalkFreeMemory(pActReq);
}


NTSTATUS
AtalkInitAdapter(
	IN	PUNICODE_STRING	    AdapterName,
	IN	PPORT_DESCRIPTOR	pExistingPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PPORT_DESCRIPTOR	pPortDesc;
	KIRQL				OldIrql;
	PWCHAR				devicePrefix = L"\\Device\\";
#define					prefixLength	(sizeof(L"\\Device\\") - sizeof(WCHAR))
	UCHAR               Address[sizeof(TA_ADDRESS) + sizeof(TDI_ADDRESS_APPLETALK)];
    PTA_ADDRESS         AddressPtr;
    NTSTATUS            Status;
    UNICODE_STRING      Us;
    UNICODE_STRING      AspDeviceName;
    HANDLE              RegHandle;
    BOOLEAN             fMustBindToNdis;
    BOOLEAN             IsDefaultPort = FALSE;


    if (AdapterName)
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AtalkInitAdapter: Initiating bind for adapter %Z\n", AdapterName));
    }

	do
	{
		// Open the adapters section key.
		RtlInitUnicodeString(&Us, ADAPTERS_STRING);
		Status = atalkInitGetHandleToKey(&Us,
										 &RegHandle);
	
		if (!NT_SUCCESS(Status))
		{
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
    			("AtalkInitAdapter: Failed to open %ws key\n", ADAPTERS_STRING));
			break;
		}

        if (pExistingPortDesc == NULL)
        {
		    //	Get the size of the string, and make sure that is it atleast
		    //	greater than the \Device prefix. Fail if not.
		    if (AdapterName->Length <= prefixLength)
		    {
			    break;
		    }

		    // Allocate space for the port descriptors. Allocate an extra DWORD
            // and set port descriptor past the first DWORD_PTR. This is a kludge to
            // force LONGLONG alignment.
		    pPortDesc =
                (PPORT_DESCRIPTOR)AtalkAllocZeroedMemory(sizeof(PORT_DESCRIPTOR) +
														 AdapterName->Length +
														 sizeof(WCHAR) +
														 sizeof(DWORD_PTR));
		    if (pPortDesc == NULL)
		    {
			    Status = STATUS_INSUFFICIENT_RESOURCES;
			    break;
		    }
	
		    // Reference the port for creation
		    pPortDesc->pd_RefCount = 1;
	
#if	DBG
		    pPortDesc->pd_Signature = PD_SIGNATURE;
#endif
		    // Copy the AdapterName and AdapterKey strings into the portdesc
		    pPortDesc->pd_AdapterName.Buffer =
                        (PWCHAR)((PBYTE)pPortDesc + sizeof(PORT_DESCRIPTOR));
		    pPortDesc->pd_AdapterName.Length = AdapterName->Length;
		    pPortDesc->pd_AdapterName.MaximumLength =
                        AdapterName->Length + sizeof(WCHAR);
		    RtlUpcaseUnicodeString(&pPortDesc->pd_AdapterName,
							   AdapterName,
							   FALSE);
		
		    pPortDesc->pd_AdapterKey.Buffer =
                (PWCHAR)((PBYTE)pPortDesc->pd_AdapterName.Buffer + prefixLength);
		    pPortDesc->pd_AdapterKey.Length =
                pPortDesc->pd_AdapterName.Length - prefixLength;
		    pPortDesc->pd_AdapterKey.MaximumLength =
                pPortDesc->pd_AdapterName.MaximumLength - prefixLength;

            // buffer for this will be allocated later
            pPortDesc->pd_FriendlyAdapterName.Buffer = NULL;
            pPortDesc->pd_FriendlyAdapterName.MaximumLength = 0;
            pPortDesc->pd_FriendlyAdapterName.Length = 0;

		    //	Now initialize any other fields that need to be.
		    INITIALIZE_SPIN_LOCK(&pPortDesc->pd_Lock);
		
		    InitializeListHead(&pPortDesc->pd_ReceiveQueue);

            // only in case of a Ras port will these lists head be used
		    InitializeListHead(&pPortDesc->pd_ArapConnHead);
		    InitializeListHead(&pPortDesc->pd_PPPConnHead);
		
		    //	Initialize the events in the port descriptor
		    KeInitializeEvent(&pPortDesc->pd_RequestEvent, NotificationEvent, FALSE);
		
		    KeInitializeEvent(&pPortDesc->pd_SeenRouterEvent, NotificationEvent, FALSE);
		
		    KeInitializeEvent(&pPortDesc->pd_NodeAcquireEvent, NotificationEvent, FALSE);

		    fMustBindToNdis = TRUE;
        }
        else
        {
            pPortDesc = pExistingPortDesc;
		    fMustBindToNdis = FALSE;
        }

		if ((AtalkDefaultPortName.Buffer != NULL) &&
				(RtlEqualUnicodeString(&pPortDesc->pd_AdapterName,
		    					  &AtalkDefaultPortName,
			    				  TRUE)))
		{
			// Used for tracking Default Port for error message logging
			IsDefaultPort = TRUE;
			pPortDesc->pd_Flags |= PD_DEF_PORT;
	
		    pPortDesc->pd_InitialDesiredZone = AtalkDesiredZone;
		    if (AtalkDesiredZone != NULL)
			    AtalkZoneReferenceByPtr(pPortDesc->pd_InitialDesiredZone);
		}

		// Link it in the global list
		ACQUIRE_SPIN_LOCK(&AtalkPortLock, &OldIrql);
		pPortDesc->pd_Next = AtalkPortList;
		AtalkPortList = pPortDesc;
		AtalkNumberOfPorts ++;
		RELEASE_SPIN_LOCK(&AtalkPortLock, OldIrql);

        if (fMustBindToNdis)
        {
            // bind to the adapter
		    Status = AtalkNdisInitBind(pPortDesc);

            if (NT_SUCCESS(Status))
            {
	            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("Bind done for %Z\n", (pPortDesc->pd_FriendlyAdapterName.Buffer) ?
                        (&pPortDesc->pd_FriendlyAdapterName) :
                        (&pPortDesc->pd_AdapterName)));
            }
            else
            {
	            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkInitAdapter: AtalkNdisInitBind failed (0x%lx) for adapter %Z\n",
                    Status,AdapterName));
            }
        }
        else
        {
            Status = STATUS_SUCCESS;
        }

		if (Status == NDIS_STATUS_SUCCESS)
		{
            Status = STATUS_SUCCESS;
	
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			        ("AtalkInitAdapter: Going into atalkInitPort (0x%lx) for adapter %Z\n",
                    Status,AdapterName));

		    // Get per port parameters (ARAP port doesn't have any parms to get)
            if (!(pPortDesc->pd_Flags & PD_RAS_PORT))
            {
		        Status = atalkInitPort(pPortDesc, RegHandle);
            }

		    if (NT_SUCCESS(Status))
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			        ("AtalkInitAdapter: atalkInitPort succeeded (0x%lx) for adapter %Z\n",
                    Status,AdapterName));
				// And start the port
				Status = atalkInitStartPort(pPortDesc);
				if (NT_SUCCESS(Status) && (pPortDesc->pd_Flags & PD_DEF_PORT))
				{
					DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			        	("AtalkInitAdapter: atalkInitStartPort succeeded (0x%lx) for adapter %Z\n",
                    Status,AdapterName));
                    //
                    // if we were doing PnP, we are done with the PnP at this point:
                    // clear the flag, so macfile can do its things...
                    //
	                ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	                pPortDesc->pd_Flags &= ~PD_PNP_RECONFIGURE;
	                RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

					//	Set the global default port value
					AtalkDefaultPort = pPortDesc;
					KeSetEvent(&AtalkDefaultPortEvent, IO_NETWORK_INCREMENT, FALSE);

                    // Now tell TDI that we are up and ready for binding
		            RtlInitUnicodeString(&AspDeviceName, ATALKASPS_DEVICENAME);

					DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			        	("AtalkInitAdapter: Calling TdiRegisterDeviceObject for adapter %Z\n",
                    AdapterName));

                    Status = TdiRegisterDeviceObject(
                                    &AspDeviceName,
                                    &TdiRegistrationHandle);

                    if (!NT_SUCCESS(Status))
                    {
                        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                            ( "TdiRegisterDeviceObject failed with %lx\n", Status));

                        TdiRegistrationHandle = NULL;
                    }
                    else
                    {
                        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                            ( "TdiRegisterDeviceObject succeeded\n"));

                        AddressPtr = (PTA_ADDRESS)Address;
                        RtlZeroMemory(Address, sizeof(Address));
                        AddressPtr->AddressLength = sizeof(TDI_ADDRESS_APPLETALK);
                        AddressPtr->AddressType = TDI_ADDRESS_TYPE_APPLETALK;

                        Status = TdiRegisterNetAddress(AddressPtr,
                                                       &pPortDesc->pd_AdapterName,
                                                       NULL,
                                                       &TdiAddressChangeRegHandle);
                        if (!NT_SUCCESS(Status))
                        {
	                        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	                            ("AtalkInitAdapter: TdiRegisterNetAddress failed %lx\n",Status));

                            TdiAddressChangeRegHandle = NULL;
                        }
                        else
                        {

                            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                                ("AtalkInitAdapter: TdiRegisterNetAddress on %Z done\n",
                                &pPortDesc->pd_AdapterName));

                            ASSERT(TdiAddressChangeRegHandle != NULL);
                        }

                    }
				}
                else if (!NT_SUCCESS(Status))
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					    ( "AtalkInitBinding: atalkInitStartPort failed (%lx) on %Z\n",
                        Status, &pPortDesc->pd_AdapterName));
                }
			}
			else
			{
				DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkInitAdapter: atalkInitPort failed (0x%lx) for adapter %Z\n",
                    Status,AdapterName));
			}

			if (pPortDesc->pd_AdapterInfoHandle != NULL)
			{
				ZwClose(pPortDesc->pd_AdapterInfoHandle);
				pPortDesc->pd_AdapterInfoHandle = NULL;
			}
		}

		else
		{
            ASSERT(AdapterName != NULL);

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					( "AtalkInitBinding failed (%lx) on %Z\n", Status, AdapterName));

            if (pPortDesc->pd_FriendlyAdapterName.Buffer)
            {
                AtalkFreeMemory(pPortDesc->pd_FriendlyAdapterName.Buffer);
            }

            AtalkFreeMemory(pPortDesc);
		}
	} while (FALSE);

	// Close the Adapters Key
	if (RegHandle != NULL)
		ZwClose (RegHandle);

    //
    // if we just successfully initialized default adapter or the RAS adapter,
    // let RAS know about it
    //
    if ( (NT_SUCCESS(Status)) &&
         (pPortDesc->pd_Flags & (PD_RAS_PORT | PD_DEF_PORT)) )
    {
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			("AtalkInitAdapter: %s adapter initialized (%lx), informing RAS\n",
            (pPortDesc->pd_Flags & PD_RAS_PORT)? "RAS" : "Default",pPortDesc));

        AtalkPnPInformRas(TRUE);
    }
    else
    {
        if (IsDefaultPort)
        {
            LOG_ERROR(EVENT_ATALK_NO_DEFAULTPORT, Status, NULL, 0);
            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                ("WARNING!!! Appletalk driver running, but no default port configured\n"));
        }
    }

    return Status;
}


NTSTATUS
AtalkDeinitAdapter(
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
			("AtalkDeinitAdapter: Initiating un-bind for adapter %Z\n",
			&pPortDesc->pd_AdapterName));


	AtalkPortShutdown(pPortDesc);

	return STATUS_SUCCESS;
}


#ifdef	ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

ACTION_DISPATCH	AtalkActionDispatch[MAX_ALLACTIONCODES+1] =
{
	//
	// NBP dispatch functions
	//

	{
		sizeof(NBP_LOOKUP_ACTION),
		COMMON_ACTION_NBPLOOKUP,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(NBP_LOOKUP_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},
	{
		sizeof(NBP_CONFIRM_ACTION),
		COMMON_ACTION_NBPCONFIRM,
		(DFLAG_CNTR | DFLAG_ADDR),
		sizeof(NBP_CONFIRM_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},
	{
		sizeof(NBP_REGDEREG_ACTION),
		COMMON_ACTION_NBPREGISTER,
		DFLAG_ADDR,
		sizeof(NBP_REGDEREG_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},
	{
		sizeof(NBP_REGDEREG_ACTION),
		COMMON_ACTION_NBPREMOVE,
		DFLAG_ADDR,
		sizeof(NBP_REGDEREG_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},

	//
	// ZIP dispatch functions
	//

	{
		sizeof(ZIP_GETMYZONE_ACTION),
		COMMON_ACTION_ZIPGETMYZONE,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(ZIP_GETMYZONE_ACTION),
		ATALK_DEV_ANY,
		AtalkZipTdiAction
	},
	{
		sizeof(ZIP_GETZONELIST_ACTION),
		COMMON_ACTION_ZIPGETZONELIST,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(ZIP_GETZONELIST_ACTION),
		ATALK_DEV_ANY,
		AtalkZipTdiAction
	},
	{
		sizeof(ZIP_GETZONELIST_ACTION),
		COMMON_ACTION_ZIPGETLZONES,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(ZIP_GETZONELIST_ACTION),
		ATALK_DEV_ANY,
		AtalkZipTdiAction
	},
	{
		sizeof(ZIP_GETZONELIST_ACTION),
		COMMON_ACTION_ZIPGETLZONESONADAPTER,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(ZIP_GETZONELIST_ACTION),
		ATALK_DEV_ANY,
		AtalkZipTdiAction
	},
	{
		sizeof(ZIP_GETPORTDEF_ACTION),
		COMMON_ACTION_ZIPGETADAPTERDEFAULTS,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(ZIP_GETPORTDEF_ACTION),
		ATALK_DEV_ANY,
		AtalkZipTdiAction
	},
	{
		sizeof(ATALK_STATS) +
		sizeof(GET_STATISTICS_ACTION),
		COMMON_ACTION_GETSTATISTICS,
		(DFLAG_CNTR | DFLAG_ADDR | DFLAG_MDL),
		sizeof(GET_STATISTICS_ACTION),
		ATALK_DEV_ANY,
		AtalkStatTdiAction
	},

	//
	// ADSP dispatch functions
	//

	{
		sizeof(ADSP_FORWARDRESET_ACTION),
		ACTION_ADSPFORWARDRESET,
		(DFLAG_CONN),
		sizeof(ADSP_FORWARDRESET_ACTION),
		ATALK_DEV_ADSP,
		AtalkAdspTdiAction
	},

	//
	// ASPC Dispatch functions
	//

	{
		sizeof(ASPC_GETSTATUS_ACTION),
		ACTION_ASPCGETSTATUS,
		(DFLAG_ADDR | DFLAG_MDL),
		sizeof(ASPC_GETSTATUS_ACTION),
		ATALK_DEV_ASPC,
		AtalkAspCTdiAction
	},
	{
		sizeof(ASPC_COMMAND_OR_WRITE_ACTION),
		ACTION_ASPCCOMMAND,
		(DFLAG_CONN | DFLAG_MDL),
		sizeof(ASPC_COMMAND_OR_WRITE_ACTION),
		ATALK_DEV_ASPC,
		AtalkAspCTdiAction
	},
	{
		sizeof(ASPC_COMMAND_OR_WRITE_ACTION),
		ACTION_ASPCWRITE,
		(DFLAG_CONN | DFLAG_MDL),
		sizeof(ASPC_COMMAND_OR_WRITE_ACTION),
		ATALK_DEV_ASPC,
		AtalkAspCTdiAction
	},
	//
	// NBP dispatch functions used by atalk
	// winsock helper dll's SetService Api
	//
	{
		sizeof(NBP_REGDEREG_ACTION),
		COMMON_ACTION_NBPREGISTER_BY_ADDR,
		DFLAG_ADDR,
		sizeof(NBP_REGDEREG_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},
	{
		sizeof(NBP_REGDEREG_ACTION),
		COMMON_ACTION_NBPREMOVE_BY_ADDR,
		DFLAG_ADDR,
		sizeof(NBP_REGDEREG_ACTION),
		ATALK_DEV_ANY,
		AtalkNbpTdiAction
	},
	{
		sizeof(ASPC_RESERVED_ACTION),
		ACTION_ASPCRESERVED3,
		(DFLAG_ADDR),
		sizeof(ASPC_RESERVED_ACTION),
		ATALK_DEV_ASPC,
		AtalkAspCTdiAction
	},

	//
	// ASP Dispatch functions
	//

	{
		sizeof(ASP_BIND_ACTION),
		ACTION_ASP_BIND,
		(DFLAG_ADDR),
		sizeof(ASP_BIND_ACTION),
		ATALK_DEV_ASP,
		AtalkAspTdiAction
	},

	//
	// PAP dispatch routines
	//
	{
		sizeof(PAP_GETSTATUSSRV_ACTION),
		ACTION_PAPGETSTATUSSRV,
		(DFLAG_ADDR | DFLAG_CNTR | DFLAG_MDL),
		sizeof(PAP_GETSTATUSSRV_ACTION),
		ATALK_DEV_PAP,
		AtalkPapTdiAction
	},
	{
		sizeof(PAP_SETSTATUS_ACTION),
		ACTION_PAPSETSTATUS,
		(DFLAG_ADDR | DFLAG_MDL),
		sizeof(PAP_SETSTATUS_ACTION),
		ATALK_DEV_PAP,
		AtalkPapTdiAction
	},
	{
		sizeof(PAP_PRIMEREAD_ACTION),
		ACTION_PAPPRIMEREAD,
		(DFLAG_CONN | DFLAG_MDL),
		0,								// !!!NOTE!!!
		ATALK_DEV_PAP,					// We set the offset to be 0. We want the
		AtalkPapTdiAction				// complete buffer to be used for read data
										// overwriting action header to preserve
	}									// winsock read model.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkmem.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkmem.h

Abstract:

	This module contains memory allocator routines for the stack

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	23 Feb 1993		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKMEM_
#define	_ATKMEM_

#define	DWORDSIZEBLOCK(Size)	(((Size)+sizeof(ULONG)-1) & ~(sizeof(ULONG)-1))
#define	ATALK_MEMORY_SIGNATURE	*(PULONG)"ATKM"
#define	ZEROED_MEMORY_TAG		0xF0000000
#define	ATALK_TAG				*(PULONG)"Atk "

//
// Definitions for the block management package
//
typedef	UCHAR	BLKID;

// Add a BLKID_xxx and an entry to atalkBlkSize for every block client
#define	BLKID_BUFFDESC				(BLKID)0
#define	BLKID_AMT					(BLKID)1
#define	BLKID_AMT_ROUTE				(BLKID)2
#define	BLKID_BRE					(BLKID)3
#define	BLKID_BRE_ROUTE				(BLKID)4
#define	BLKID_ATPREQ				(BLKID)5
#define	BLKID_ATPRESP				(BLKID)6
#define	BLKID_ASPREQ				(BLKID)7
#define	BLKID_ARAP_SMPKT  	        (BLKID)8
#define	BLKID_ARAP_MDPKT	        (BLKID)9
#define	BLKID_ARAP_LGPKT		    (BLKID)10
#define BLKID_ARAP_SNDPKT           (BLKID)11
#define	BLKID_ARAP_LGBUF		    (BLKID)12
#define	BLKID_NEED_NDIS_INT			BLKID_AARP		// All ids above this needs Ndis Initialization
													// See AtalkBPAllocBlock
#define	BLKID_AARP					(BLKID)13
#define	BLKID_DDPSM					(BLKID)14
#define	BLKID_DDPLG					(BLKID)15
#define	BLKID_SENDBUF				(BLKID)16
#define	BLKID_MNP_SMSENDBUF		    (BLKID)17
#define	BLKID_MNP_LGSENDBUF		    (BLKID)18
#define	NUM_BLKIDS					(BLKID)19

//
// if we need huge buffers, we just do an alloc ourselves (rather than using the
// above BLKID mechanism.  So that we know it is something we allocated, we use
// this as the "block id".  Now, make sure NUM_BLKIDS never exceeds 250!
//
#define ARAP_UNLMTD_BUFF_ID         (NUM_BLKIDS+5)


//	BUFFER DESCRIPTORS
//	These will be used by callers into the DDP layer. They can be
//	chained together. They contain either an opaque (MDL on NT) or
//	a PBYTE buffer. All outside callers *must* pass in an MDL. Only
//	DDP/AARP will have the right to create a buffer descriptor which
//	will hold a PBYTE buffer.
//
//	MODEL OF OPERATION FOR DDP:
//	DDP/AARP will call the link AllocBuildLinkHeader routine. This will
//	allocate the space that DDP/AARP says it needs. The link header will
//	then be built from the start of the buffer. A pointer to the beginning
//	and to the place where the caller can fill in their headers is returned.
//	DDP/AARP will then fill in its header, make a buffer descriptor for
//	this buffer, prepend to the buffer descriptor its received from its
//	client, and then call the packet out routines.

#define		BD_CHAR_BUFFER		(USHORT)0x0001
#define		BD_FREE_BUFFER		(USHORT)0x0002

#define		BD_SIGNATURE		*((PULONG)"BDES")
#if	DBG
#define	VALID_BUFFDESC(pBuffDesc)	\
				(((pBuffDesc) != NULL) && ((pBuffDesc)->bd_Signature == BD_SIGNATURE))
#else
#define	VALID_BUFFDESC(pBuffDesc)	((pBuffDesc) != NULL)
#endif
typedef	struct _BUFFER_DESC
{
#if DBG
	ULONG					bd_Signature;
#endif
	struct _BUFFER_DESC *	bd_Next;
	USHORT					bd_Flags;
	SHORT					bd_Length;

	union
	{
		PAMDL				bd_OpaqueBuffer;
		struct
		{
			//	bd_FreeBuffer is the beginning of the allocated buffer.
			//	bd_CharBuffer is from some offset (0 or >) within it
			//	from where the data starts.
			PBYTE			bd_CharBuffer;
			PBYTE			bd_FreeBuffer;
		};
	};
} BUFFER_DESC, *PBUFFER_DESC;

#ifdef	TRACK_MEMORY_USAGE

#define	AtalkAllocMemory(Size)	AtalkAllocMem(Size, FILENUM | __LINE__)

extern
PVOID FASTCALL
AtalkAllocMem(
	IN	ULONG	Size,
	IN	ULONG	FileLine
);

extern
VOID
AtalkTrackMemoryUsage(
	IN	PVOID	pMem,
    IN  ULONG   Size,
	IN	BOOLEAN	Alloc,
	IN	ULONG	FileLine
);

#else

#define	AtalkAllocMemory(Size)	AtalkAllocMem(Size)

#define	AtalkTrackMemoryUsage(pMem, Size, Alloc, FileLine)

extern
PVOID FASTCALL
AtalkAllocMem(
	IN	ULONG	Size
);

#endif	// TRACK_MEMORY_USAGE

#ifdef	TRACK_BUFFDESC_USAGE

#define	AtalkAllocBuffDesc(Ptr, Length, Flags)	\
				AtalkAllocBufferDesc(Ptr, Length, Flags, FILENUM | __LINE__)

#define	AtalkDescribeBuffDesc(DataPtr, FreePtr, Length, Flags)	\
				AtalkDescribeBufferDesc(DataPtr, FreePtr, Length, Flags, FILENUM | __LINE__)

extern
VOID
AtalkTrackBuffDescUsage(
	IN	PVOID	pBuffDesc,
	IN	BOOLEAN	Alloc,
	IN	ULONG	FileLine
);

extern
PBUFFER_DESC
AtalkAllocBufferDesc(
	IN	PVOID	Ptr,		// Either a PAMDL or a PBYTE
	IN	USHORT	Length,
	IN	USHORT	Flags,
	IN	ULONG	FileLine
);

extern
PBUFFER_DESC
AtalkDescribeBufferDesc(
	IN	PVOID	DataPtr,
	IN	PVOID	FreePtr,
	IN	USHORT	Length,
	IN	USHORT	Flags,
	IN	ULONG	FileLine
);

#else

#define	AtalkAllocBuffDesc(Ptr, Length, Flags)	\
						AtalkAllocBufferDesc(Ptr, Length, Flags)

#define	AtalkDescribeBuffDesc(DataPtr, FreePtr, Length, Flags)	\
						AtalkDescribeBufferDesc(DataPtr, FreePtr, Length, Flags)

#define	AtalkTrackBuffDescUsage(pBuffDesc, Alloc, FileLine)

extern
PBUFFER_DESC
AtalkAllocBufferDesc(
	IN	PVOID	Ptr,		// Either a PAMDL or a PBYTE
	IN	USHORT	Length,
	IN	USHORT	Flags
);

extern
PBUFFER_DESC
AtalkDescribeBufferDesc(
	IN	PVOID	DataPtr,
	IN	PVOID	FreePtr,
	IN	USHORT	Length,
	IN	USHORT	Flags
);

#endif	// TRACK_BUFFDESC_USAGE

#define	AtalkAllocZeroedMemory(Size)		AtalkAllocMemory((Size) | ZEROED_MEMORY_TAG)

extern
VOID FASTCALL
AtalkFreeMemory(
	IN	PVOID pBuffer
);

extern
VOID FASTCALL
AtalkFreeBuffDesc(
	IN	PBUFFER_DESC	pBuffDesc
);

extern
VOID
AtalkCopyBuffDescToBuffer(
	IN	PBUFFER_DESC	pBuffDesc,
	IN	LONG			SrcOff,
	IN	LONG			BytesToCopy,
	IN	PBYTE			DstBuf
);

extern
VOID
AtalkCopyBufferToBuffDesc(
	IN	PBYTE			SrcBuf,
	IN	LONG			BytesToCopy,
	IN	PBUFFER_DESC	pBuffDesc,
	IN	LONG			DstOff
);

extern
LONG FASTCALL
AtalkSizeBuffDesc(
	IN	PBUFFER_DESC	pBuffDesc
);

extern
VOID
AtalkInitMemorySystem(
	VOID
);

extern
VOID
AtalkDeInitMemorySystem(
	VOID
);

//	Macros
#define		GET_MDL_FROM_OPAQUE(x)		((PMDL)x)

#define	AtalkPrependBuffDesc(pNode, pList)			\
			pNode->bd_Next = pList;

#define	AtalkAppendBuffDesc(pNode, pList)			\
		{											\
			PBUFFER_DESC	_L = pList;				\
													\
			if (_L == NULL)							\
			{										\
				pNode->bd_Next = NULL;				\
			}										\
			else									\
			{										\
				while (_L->bd_Next != NULL)			\
					_L = _L->bd_Next;				\
													\
				_L->bd_Next = pNode;				\
				pNode->bd_Next = NULL;				\
			}										\
		}

#define	AtalkSizeOfBuffDescData(pBuf, pLen)			\
		{			 								\
			PBUFFER_DESC	_B = (pBuf);			\
			USHORT			_L = 0;					\
													\
			while (_B)								\
			{										\
				_L += _B->bd_Length;				\
				_B  = _B->bd_Next;					\
			}										\
			*(pLen) = _L;							\
		}

#define	AtalkSetSizeOfBuffDescData(pBuf, Len)	((pBuf)->bd_Length = (Len))

extern
PAMDL
AtalkAllocAMdl(
	IN	PBYTE	pBuffer OPTIONAL,
	IN	LONG	Size
);

extern
PAMDL
AtalkSubsetAmdl(
	IN	PAMDL	pStartingMdl,
	IN	ULONG	TotalOffset,
	IN	ULONG	DesiredLength);

#define	AtalkGetAddressFromMdl(pAMdl)		MmGetSystemAddressForMdl(pAMdl)
#define	AtalkGetAddressFromMdlSafe(pAMdl, PagePriority)		MmGetSystemAddressForMdlSafe(pAMdl, PagePriority)

#ifdef	PROFILING
#define	AtalkFreeAMdl(pAmdl)						\
		{											\
			PAMDL	_N;								\
			PAMDL	_L = pAmdl;						\
			while (_L != NULL)						\
			{										\
				_N = _L->Next;						\
				ExInterlockedDecrementLong(			\
					&AtalkStatistics.stat_CurMdlCount,\
					&AtalkKeStatsLock);				\
				IoFreeMdl(_L);						\
                ATALK_DBG_DEC_COUNT(AtalkDbgMdlsAlloced); \
				_L = _N;							\
			}										\
		}
#else
#define	AtalkFreeAMdl(pAmdl)						\
		{											\
			PAMDL	_N;								\
			PAMDL	_L = pAmdl;						\
			while (_L != NULL)						\
			{										\
				_N = _L->Next;						\
				IoFreeMdl(_L);						\
                ATALK_DBG_DEC_COUNT(AtalkDbgMdlsAlloced); \
				_L = _N;							\
			}										\
		}
#endif

#define	AtalkIsMdlFragmented(pMdl)	((pMdl)->Next != NULL)

extern
LONG FASTCALL
AtalkSizeMdlChain(
	IN	PAMDL		pAMdlChain
);

PVOID FASTCALL
AtalkBPAllocBlock(
	IN	BLKID		BlockId
);

VOID FASTCALL
AtalkBPFreeBlock(
	IN	PVOID		pBlock
);

#endif	// _ATKMEM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkndis.c ===
/*++										

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkndis.c

Abstract:

	This module contains the support code for the stack dealing with
	the NDIS 3.0 interface. The NDIS Init/Deinit and the ndis-protocol
	interface code.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKNDIS


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkNdisInitRegisterProtocol)
#pragma alloc_text(INIT, atalkNdisInitInitializeResources)
#pragma alloc_text(PAGEINIT, AtalkNdisInitBind)
#pragma alloc_text(PAGEINIT, AtalkInitNdisQueryAddrInfo)
#pragma alloc_text(PAGEINIT, AtalkInitNdisSetLookaheadSize)
#pragma alloc_text(PAGEINIT, AtalkInitNdisStartPacketReception)
#pragma alloc_text(PAGEINIT, AtalkBindAdapter)
#pragma alloc_text(PAGEINIT, AtalkUnbindAdapter)
#endif


ATALK_ERROR
AtalkNdisInitRegisterProtocol(
	VOID
	)
/*++

Routine Description:

	This routine is called during initialization time to register the protocol
	with NDIS.

Arguments:

	NameString- The name to be registered for this protocol- human-readable form

Return Value:

	Status - TRUE if register went ok, FALSE otherwise.
--*/
{
	NDIS_STATUS		ndisStatus;
	UNICODE_STRING	RegName;
	NDIS_PROTOCOL_CHARACTERISTICS protocolInfo;

	RtlZeroMemory(&protocolInfo, sizeof(protocolInfo));
	RtlInitUnicodeString(&RegName, PROTOCOL_REGISTER_NAME);

	// Set up the characteristics for the protocol for registering with NDIS
	protocolInfo.MajorNdisVersion = PROTOCOL_MAJORNDIS_VERSION;
	protocolInfo.MinorNdisVersion = PROTOCOL_MINORNDIS_VERSION;
	protocolInfo.Name.Length = RegName.Length;
	protocolInfo.Name.Buffer = (PVOID)RegName.Buffer;

	protocolInfo.OpenAdapterCompleteHandler	 = AtalkOpenAdapterComplete;
	protocolInfo.CloseAdapterCompleteHandler = AtalkCloseAdapterComplete;
	protocolInfo.ResetCompleteHandler		 = AtalkResetComplete;
	protocolInfo.RequestCompleteHandler		 = AtalkRequestComplete;

	protocolInfo.SendCompleteHandler		 = AtalkSendComplete;
	protocolInfo.TransferDataCompleteHandler = AtalkTransferDataComplete;

	protocolInfo.ReceiveHandler				 = AtalkReceiveIndication;
	protocolInfo.ReceiveCompleteHandler		 = AtalkReceiveComplete;
	protocolInfo.StatusHandler				 = AtalkStatusIndication;
	protocolInfo.StatusCompleteHandler		 = AtalkStatusComplete;

	protocolInfo.BindAdapterHandler			 = AtalkBindAdapter;
	protocolInfo.UnbindAdapterHandler		 = AtalkUnbindAdapter;

    protocolInfo.PnPEventHandler             = AtalkPnPHandler;

	ndisStatus = atalkNdisInitInitializeResources();

	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
		NdisRegisterProtocol(&ndisStatus,
							 &AtalkNdisProtocolHandle,
							 &protocolInfo,
							 (UINT)sizeof(NDIS_PROTOCOL_CHARACTERISTICS)+RegName.Length);

		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			LOG_ERROR(EVENT_ATALK_REGISTERPROTOCOL, ndisStatus, NULL, 0);
	
			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
					("AtalkNdisRegister: failed %ul\n", ndisStatus));
		}
	}

	return AtalkNdisToAtalkError(ndisStatus);
}



VOID
AtalkNdisDeregisterProtocol(
	VOID
	)
/*++

Routine Description:

	This routine is called to deregister the protocol

Arguments:

	NONE

Return Value:

	NONE
--*/
{
	NDIS_STATUS ndisStatus;

	if (AtalkNdisProtocolHandle != (NDIS_HANDLE)NULL)
	{
		NdisDeregisterProtocol(&ndisStatus, AtalkNdisProtocolHandle);

		AtalkNdisProtocolHandle = (NDIS_HANDLE)NULL;
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			LOG_ERROR(EVENT_ATALK_DEREGISTERPROTOCOL, ndisStatus, NULL, 0);
		}
	}
	else
	{
		ASSERTMSG("AtalkNdisDeregisterProtocol: NULL ProtocolHandle\n", FALSE);
	}
}



LOCAL NDIS_STATUS
atalkNdisInitInitializeResources(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:

	Status - STATUS_SUCCESS if all resources were allocated
			 STATUS_INSUFFICIENT_RESOURCES otherwise.
--*/
{
	NDIS_STATUS ndisStatus;
	LONG		numPktDescs, numBufDescs;

	numPktDescs = NUM_PACKET_DESCRIPTORS;
	if (AtalkRouter)
	{
		numPktDescs *= ROUTING_FACTOR;
	}

	numBufDescs = NUM_BUFFER_DESCRIPTORS;
	if (AtalkRouter)
	{
		numBufDescs *= ROUTING_FACTOR;
	}

	do
	{
		// Setup the ndis packet descriptor pools in the Port descriptor
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("atalkNdisInitInitializeResources: Allocating %ld Packets\n",
				numPktDescs));

        AtalkNdisPacketPoolHandle = (PVOID)NDIS_PACKET_POOL_TAG_FOR_APPLETALK;

		NdisAllocatePacketPoolEx(&ndisStatus,
								 &AtalkNdisPacketPoolHandle,
								 numPktDescs,
								 numPktDescs*200,	// Overflow descriptors
								 sizeof(PROTOCOL_RESD));
	
		if ((ndisStatus != NDIS_STATUS_SUCCESS) && (ndisStatus != NDIS_STATUS_PENDING))
		{
			break;
		}

		//  Setup the ndis buffer descriptor pool
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
				("atalkNdisInitInitializeResources: Allocating %ld buffers\n",
				numBufDescs));
		NdisAllocateBufferPool(&ndisStatus,
							   &AtalkNdisBufferPoolHandle,
							   numBufDescs);

		if ((ndisStatus != NDIS_STATUS_SUCCESS) && (ndisStatus != NDIS_STATUS_PENDING))
		{
			NdisFreePacketPool(AtalkNdisPacketPoolHandle);
			AtalkNdisPacketPoolHandle = NULL;
		}
	} while (FALSE);

	if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERROR(EVENT_ATALK_NDISRESOURCES, ndisStatus, NULL, 0);
	}

	return ndisStatus;
}




NDIS_STATUS
AtalkNdisInitBind(
	IN OUT PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
	NDIS_STATUS     ndisStatus, openStatus, queryStatus;
	ATALK_ERROR	    error;
	UINT 		    selectedMediumIndex;
    NDIS_STRING     FriendlyName;

	// reference the port for bind
	AtalkPortReferenceByPtr(pPortDesc, &error);
	if (error != ATALK_NO_ERROR)
	{
		return(STATUS_UNSUCCESSFUL);
	}

	//	Reset event before possible wait
	KeClearEvent(&pPortDesc->pd_RequestEvent);

	NdisOpenAdapter(&ndisStatus,			// open status
					&openStatus,			// more info not used
					&pPortDesc->pd_NdisBindingHandle,
					&selectedMediumIndex,
					AtalkSupportedMedia,
					AtalkSupportedMediaSize,
					AtalkNdisProtocolHandle,
					(NDIS_HANDLE)pPortDesc,
					(PNDIS_STRING)&pPortDesc->pd_AdapterName,
					0,						//	Open options
					NULL);					//	Addressing information


	if (ndisStatus == NDIS_STATUS_PENDING)
	{
		DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_WARN,
				("AtalkNdisInitBind: OpenAdapter is pending for %Z\n",
				&pPortDesc->pd_AdapterKey));

		//  Make sure we are not at or above dispatch level
		ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

		// 	Wait on event, completion routine will set NdisRequestEvent
		//	Use wrappers
		KeWaitForSingleObject(&pPortDesc->pd_RequestEvent,
							  Executive,
							  KernelMode,
							  FALSE,
							  NULL);

		ndisStatus = pPortDesc->pd_RequestStatus;
	}

	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
		PPORT_HANDLERS	pPortHandler;

		pPortDesc->pd_Flags 		|= 	PD_BOUND;
		pPortDesc->pd_NdisPortType 	= 	AtalkSupportedMedia[selectedMediumIndex];
		pPortDesc->pd_PortType 		= 	GET_PORT_TYPE(pPortDesc->pd_NdisPortType);

		if (pPortDesc->pd_PortType != ALAP_PORT)
		{
			pPortDesc->pd_Flags |= PD_EXT_NET;
		}
		else if (pPortDesc->pd_Flags & PD_SEED_ROUTER)
		{
			pPortDesc->pd_InitialNetworkRange.anr_LastNetwork =
								pPortDesc->pd_InitialNetworkRange.anr_FirstNetwork;
		}

        // is this a RAS port?
        if (pPortDesc->pd_NdisPortType == NdisMediumWan)
        {
			pPortDesc->pd_Flags |= PD_RAS_PORT;
            RasPortDesc = pPortDesc;
        }

		// Set stuff from the PortHandler structure to the port descriptor
		pPortHandler = &AtalkPortHandlers[pPortDesc->pd_PortType];
		pPortDesc->pd_AddMulticastAddr = pPortHandler->ph_AddMulticastAddr;
		pPortDesc->pd_RemoveMulticastAddr = pPortHandler->ph_RemoveMulticastAddr;
		pPortDesc->pd_AarpProtocolType = pPortHandler->ph_AarpProtocolType;
		pPortDesc->pd_AarpHardwareType = pPortHandler->ph_AarpHardwareType;
        pPortDesc->pd_BroadcastAddrLen = pPortHandler->ph_BroadcastAddrLen;
		RtlCopyMemory(pPortDesc->pd_BroadcastAddr,
					  pPortHandler->ph_BroadcastAddr,
					  pPortHandler->ph_BroadcastAddrLen);

        FriendlyName.MaximumLength = FriendlyName.Length = 0;
        FriendlyName.Buffer = NULL;

        queryStatus = NdisQueryAdapterInstanceName(&FriendlyName,
                                                   pPortDesc->pd_NdisBindingHandle);
        if (queryStatus == NDIS_STATUS_SUCCESS)
        {
            ASSERT((FriendlyName.Buffer != NULL) && (FriendlyName.Length > 0));

            pPortDesc->pd_FriendlyAdapterName.Buffer =
                AtalkAllocZeroedMemory(FriendlyName.Length + sizeof(WCHAR));

            if (pPortDesc->pd_FriendlyAdapterName.Buffer != NULL)
            {
                pPortDesc->pd_FriendlyAdapterName.MaximumLength =
                                                    FriendlyName.MaximumLength;
                pPortDesc->pd_FriendlyAdapterName.Length = FriendlyName.Length;

                RtlCopyMemory(pPortDesc->pd_FriendlyAdapterName.Buffer,
                              FriendlyName.Buffer,
                              FriendlyName.Length);
            }

            NdisFreeString(FriendlyName);
        }
	}
	else
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_OPENADAPTER,
						ndisStatus,
						NULL,
						0);
		AtalkPortDereference(pPortDesc);
	}

	return ndisStatus;
}




VOID
AtalkNdisUnbind(
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
	NDIS_STATUS	ndisStatus;
	KIRQL		OldIrql;

	//	Reset event before possible wait
	KeClearEvent(&pPortDesc->pd_RequestEvent);

	ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
	NdisCloseAdapter(&ndisStatus, pPortDesc->pd_NdisBindingHandle);

	if (ndisStatus == NDIS_STATUS_PENDING)
	{
		DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_WARN,
				("AtalkNdisUnbind: pending for close!\n"));

		//  Make sure we are not at or above dispatch level
		ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

		// Wait on event, completion routine will set NdisRequestEvent
		KeWaitForSingleObject(&pPortDesc->pd_RequestEvent,
							  Executive,
							  KernelMode,
							  FALSE,
							  NULL);

		ndisStatus = pPortDesc->pd_RequestStatus;
	}

	if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		    ("AtalkNdisUnbind: CloseAdapter on %Z completed successfully\n",
            ((pPortDesc->pd_FriendlyAdapterName.Buffer) ?
                (&pPortDesc->pd_FriendlyAdapterName) : (&pPortDesc->pd_AdapterName))
            ));


		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
		pPortDesc->pd_Flags &= ~PD_BOUND;
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		// Remove the reference added at bind time
		AtalkPortDereference(pPortDesc);
	}
	else
	{
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		    ("AtalkNdisUnbind: CloseAdapter on %Z failed %lx\n",
            ((pPortDesc->pd_FriendlyAdapterName.Buffer) ?
                (&pPortDesc->pd_FriendlyAdapterName) : (&pPortDesc->pd_AdapterName)),
            ndisStatus
            ));


		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_CLOSEADAPTER,
						ndisStatus,
						NULL,
						0);
	}
}



VOID
AtalkNdisReleaseResources(
	VOID
	)
/*++

Routine Description:


Arguments:


Return Value:

	None
--*/
{
	if (AtalkNdisPacketPoolHandle != NULL)
	{
		NdisFreePacketPool(AtalkNdisPacketPoolHandle);
		AtalkNdisPacketPoolHandle = NULL;
	}
	if (AtalkNdisBufferPoolHandle)
	{
		NdisFreeBufferPool(AtalkNdisBufferPoolHandle);
		AtalkNdisBufferPoolHandle = NULL;
	}
}




ATALK_ERROR
AtalkInitNdisQueryAddrInfo(
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{							
	NDIS_OID		ndisOid;
	ULONG			macOptions;
	PBYTE			address;
	UINT			addressLength;

	//	We assume a single thread/init time behavior
	NDIS_REQUEST	request;
	NDIS_STATUS	 	ndisStatus = NDIS_STATUS_SUCCESS;

	do
	{
		//  Check to see it we bound successfully to this adapter
		if (!PORT_BOUND(pPortDesc))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NOTBOUNDTOMAC,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);

			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
		}

		switch (pPortDesc->pd_NdisPortType)
		{
		  case NdisMedium802_3 :
			ndisOid = OID_802_3_CURRENT_ADDRESS;
			address = &pPortDesc->pd_PortAddr[0];
			addressLength = MAX_HW_ADDR_LEN;
			break;

		  case NdisMediumFddi :
			ndisOid = OID_FDDI_LONG_CURRENT_ADDR;
			address = &pPortDesc->pd_PortAddr[0];
			addressLength = MAX_HW_ADDR_LEN;
			break;

		  case NdisMedium802_5:
			ndisOid = OID_802_5_CURRENT_ADDRESS;
			address = &pPortDesc->pd_PortAddr[0];
			addressLength = MAX_HW_ADDR_LEN;
			break;

		  case NdisMediumLocalTalk :
			ndisOid = OID_LTALK_CURRENT_NODE_ID;
			address = (PBYTE)&pPortDesc->pd_AlapNode;
			addressLength = sizeof(pPortDesc->pd_AlapNode);
			break;

          case NdisMediumWan:
			ndisOid = OID_WAN_CURRENT_ADDRESS;
            // NOTE: the following two fields not relevant for RAS
			address = &pPortDesc->pd_PortAddr[0];
			addressLength = MAX_HW_ADDR_LEN;
			break;

		  default:
			KeBugCheck(0);
			break;
		}

		//  Setup request
		request.RequestType = NdisRequestQueryInformation;
		request.DATA.QUERY_INFORMATION.Oid = ndisOid;
		request.DATA.QUERY_INFORMATION.InformationBuffer = address;
		request.DATA.QUERY_INFORMATION.InformationBufferLength = addressLength;

		ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
											&request,
											TRUE,
											NULL,
											NULL);
	
	
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_STATIONADDRESS,
							ndisStatus,
							NULL,
							0);
		}

		//  Setup request to get the mac options information
		request.RequestType = NdisRequestQueryInformation;
		request.DATA.QUERY_INFORMATION.Oid = OID_GEN_MAC_OPTIONS;
		request.DATA.QUERY_INFORMATION.InformationBuffer = &macOptions;
		request.DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(ULONG);

		ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
											&request,
											TRUE,
											NULL,
											NULL);
	
	
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			//	No mac options.
			ndisStatus = NDIS_STATUS_SUCCESS;
			macOptions = 0;
		}

		pPortDesc->pd_MacOptions	= macOptions;
		DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
				("AtalkNdisQueryAddrInfo: MacOptions %lx\n", macOptions));
	} while (FALSE);

	return AtalkNdisToAtalkError(ndisStatus);
}




ATALK_ERROR
AtalkInitNdisSetLookaheadSize(
	IN  PPORT_DESCRIPTOR	pPortDesc,
	IN  INT					LookaheadSize		// Has to be INT
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NDIS_REQUEST  	request;
	NDIS_STATUS		ndisStatus = NDIS_STATUS_SUCCESS;

	do
	{
		//  Check to see it we bound successfully to this adapter
		if (!PORT_BOUND(pPortDesc))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NOTBOUNDTOMAC,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);

			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
		}

		//  Setup request
		request.RequestType = NdisRequestSetInformation;
		request.DATA.SET_INFORMATION.Oid = OID_GEN_CURRENT_LOOKAHEAD;
		request.DATA.SET_INFORMATION.InformationBuffer = (PBYTE)&LookaheadSize;
		request.DATA.SET_INFORMATION.InformationBufferLength = sizeof(LookaheadSize);

		ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
											&request,
											TRUE,
											NULL,
											NULL);
	
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_LOOKAHEADSIZE,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);
		}

	} while (FALSE);

	return AtalkNdisToAtalkError(ndisStatus);
}



ATALK_ERROR
AtalkInitNdisStartPacketReception(
	IN	PPORT_DESCRIPTOR	pPortDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NDIS_REQUEST  	request;
	ULONG   		packetFilter;
	NDIS_STATUS	 	ndisStatus = NDIS_STATUS_SUCCESS;
	KIRQL			OldIrql;

	do
	{
		//  Check to see it we bound successfully to this adapter
		if (!PORT_BOUND(pPortDesc))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NOTBOUNDTOMAC,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);

			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
		}

		switch (pPortDesc->pd_NdisPortType)
		{
		  case NdisMedium802_3 :
		  case NdisMediumFddi :
			packetFilter = NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_MULTICAST;
			break;

		  case NdisMedium802_5:
			packetFilter = NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_FUNCTIONAL;
			break;

		  case NdisMediumLocalTalk :
			packetFilter = NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_BROADCAST;
			break;

          case NdisMediumWan:
			packetFilter = NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_MULTICAST;
			break;

		  default:
			KeBugCheck(0);
			break;
		}

		//  Setup request
		request.RequestType = NdisRequestSetInformation;
		request.DATA.SET_INFORMATION.Oid =OID_GEN_CURRENT_PACKET_FILTER;
		request.DATA.SET_INFORMATION.InformationBuffer = (PBYTE)&packetFilter;
		request.DATA.SET_INFORMATION.InformationBufferLength = sizeof(packetFilter);

		ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
											&request,
											TRUE,
											NULL,
											NULL);
	
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_PACKETFILTER,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);
		}
	} while (FALSE);

	return AtalkNdisToAtalkError(ndisStatus);
}




NDIS_STATUS
AtalkNdisSubmitRequest(
	PPORT_DESCRIPTOR	pPortDesc,
	PNDIS_REQUEST		Request,
	BOOLEAN				ExecuteSync,
	REQ_COMPLETION		CompletionRoutine,
	PVOID				Ctx
	)
/*++

Routine Description:


Arguments:


Return Value:

	None
--*/
{
	NDIS_STATUS			ndisStatus;
	PATALK_NDIS_REQ		atalkNdisRequest;

	//	Allocate an atalk request packet
	if ((atalkNdisRequest = AtalkAllocMemory(sizeof(ATALK_NDIS_REQ))) == NULL)
	{
		return NDIS_STATUS_RESOURCES;
	}

	atalkNdisRequest->nr_Request 			= *Request;
	atalkNdisRequest->nr_Sync				= ExecuteSync;
	atalkNdisRequest->nr_RequestCompletion 	= CompletionRoutine;
	atalkNdisRequest->nr_Ctx				= Ctx;

	if (ExecuteSync)
	{
		//  Make sure we are not at or above dispatch level
		//	Also assert that the completion routine is NULL
		ASSERT(KeGetCurrentIrql() == LOW_LEVEL);
		ASSERT(CompletionRoutine == NULL);

		//	Initialize event to not signalled before possible wait.
		KeInitializeEvent(&atalkNdisRequest->nr_Event,
						  NotificationEvent,
						  FALSE);
	}

	NdisRequest(&ndisStatus,
				pPortDesc->pd_NdisBindingHandle,
				&atalkNdisRequest->nr_Request);

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("atalkNdisSubmitRequest: status NdisRequest %lx\n", ndisStatus));

	if (ndisStatus == NDIS_STATUS_PENDING)
	{
		if (ExecuteSync)
		{
			KeWaitForSingleObject(&atalkNdisRequest->nr_Event,
								  Executive,
								  KernelMode,
								  FALSE,
								  NULL);
	
			ndisStatus = atalkNdisRequest->nr_RequestStatus;
			AtalkFreeMemory((PVOID)atalkNdisRequest);
		}
	}
	else if (ndisStatus == NDIS_STATUS_SUCCESS)
	{
		//	Ndis will not call the completion routine.
		if (!ExecuteSync)
		{
			//	Call the users completion routine if specified.
			if (CompletionRoutine != NULL)
			{
				(*CompletionRoutine)(NDIS_STATUS_SUCCESS, Ctx);
			}
		}
		AtalkFreeMemory((PVOID)atalkNdisRequest);
	}
	else
	{
		//	There was an error. Just free up the atalk ndis request.
		AtalkFreeMemory((PVOID)atalkNdisRequest);
	}

	return ndisStatus;
}




//  Protocol/NDIS interaction code

VOID
AtalkOpenAdapterComplete(
	IN	NDIS_HANDLE NdisBindCtx,
	IN	NDIS_STATUS Status,
	IN	NDIS_STATUS OpenErrorStatus
	)
/*++

Routine Description:

	This routine is called during by NDIS to indicate that an open adapter
	is complete. This happens only during initialization and single-file. Clear
	the event, so the blocked init thread can go on to the next adapter. Set the
	status in the ndis port descriptor for this adapter.

Arguments:

	NdisBindCtx- Pointer to a port descriptor for this port
	Status- completion status of open adapter
	OpenErrorStatus- Extra status information

Return Value:

	None

--*/
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)NdisBindCtx;

	pPortDesc->pd_RequestStatus = Status;
	KeSetEvent(&pPortDesc->pd_RequestEvent, IO_NETWORK_INCREMENT, FALSE);
}




VOID
AtalkCloseAdapterComplete(
	IN	NDIS_HANDLE NdisBindCtx,
	IN	NDIS_STATUS Status
	)
/*++

Routine Description:

	This routine is called by NDIS to indicate that a close adapter is complete.

Arguments:

	NdisBindCtx- Pointer to a port descriptor for this port
	Status- completion status of close adapter

Return Value:

	None

--*/
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)NdisBindCtx;

	pPortDesc->pd_RequestStatus = Status;
	KeSetEvent(&pPortDesc->pd_RequestEvent, IO_NETWORK_INCREMENT, FALSE);
}




VOID
AtalkResetComplete(
	IN	NDIS_HANDLE NdisBindCtx,
	IN	NDIS_STATUS Status
	)
/*++

Routine Description:

	This routine is called by NDIS to indicate that a reset is complete.

Arguments:

	NdisBindCtx- Pointer to a port descriptor for this port
	Status- completion status of close adapter

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(NdisBindCtx);
}




VOID
AtalkRequestComplete(
	IN	NDIS_HANDLE			NdisBindCtx,
	IN	PNDIS_REQUEST		NdisRequest,
	IN	NDIS_STATUS 		Status
	)
/*++

Routine Description:

	This routine is called by NDIS to indicate that a NdisRequest is complete.

Arguments:

	NdisBindCtx- Pointer to a port descriptor for this port
	NdisRequest- Block identifying the request
	Status- completion status of close adapter

Return Value:

	None

--*/
{
	PATALK_NDIS_REQ		atalkRequest;

	//  Get the AtalkRequest block
	atalkRequest = CONTAINING_RECORD(NdisRequest, ATALK_NDIS_REQ, nr_Request);

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("AtalkRequestComplete: %lx status %lx\n", atalkRequest, Status));

	if (atalkRequest->nr_Sync)
	{
		//	This was a sync request
		//  Set status and clear event

		ASSERT(atalkRequest->nr_RequestCompletion == NULL);
		atalkRequest->nr_RequestStatus = Status;
		KeSetEvent(&atalkRequest->nr_Event, IO_NETWORK_INCREMENT, FALSE);
	}

	//  Call the completion routine if specified
	if (atalkRequest->nr_RequestCompletion != NULL)
	{
		(*atalkRequest->nr_RequestCompletion)(Status, atalkRequest->nr_Ctx);
	}

	if (!atalkRequest->nr_Sync)
		AtalkFreeMemory(atalkRequest);
}




VOID
AtalkStatusIndication(
	IN	NDIS_HANDLE 	NdisBindCtx,
	IN	NDIS_STATUS 	GeneralStatus,
	IN	PVOID			StatusBuf,
	IN	UINT 			StatusBufLen
	)
/*++

Routine Description:

	This routine is called by NDIS to indicate a status change.

Arguments:

	NdisBindCtx- Pointer to a port descriptor for this port
	GeneralStatus- A general status value
	StatusBuffer - A more specific status value

Return Value:

	None

--*/
{

    PPORT_DESCRIPTOR    pPortDesc;


    pPortDesc = (PPORT_DESCRIPTOR)NdisBindCtx;

    // line-up, line-down or stat request from ndiswan?  deal with it!
    if (pPortDesc == RasPortDesc)
    {
        RasStatusIndication(GeneralStatus, StatusBuf, StatusBufLen);
    }

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_ERR,
			("AtalkStatusIndication: Status indication called %lx\n", GeneralStatus));
}




VOID
AtalkStatusComplete (
	IN	NDIS_HANDLE ProtoBindCtx
	)
/*++

Routine Description:

	This routine is called by NDIS to allow postprocessing after a status event.

Arguments:

	ProtoBindCtx- Value associated with the binding with the adapter

Return Value:

	None

--*/
{
	UNREFERENCED_PARAMETER(ProtoBindCtx);

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_WARN,
			("AtalkStatusComplete: Status complete called\n"));
}




typedef	struct
{
	REQ_COMPLETION		AddCompletion;
	PVOID				AddContext;
	PBYTE				Buffer;
} ADDMC, *PADDMC;

LOCAL VOID
atalkNdisAddMulticastCompletion(
	IN	NDIS_STATUS 	Status,
	IN	PADDMC			pAmc
)
{
	if (pAmc->Buffer != NULL)
		AtalkFreeMemory(pAmc->Buffer);
	if (pAmc->AddCompletion != NULL)
		(*pAmc->AddCompletion)(Status, pAmc->AddContext);
	AtalkFreeMemory(pAmc);
}


ATALK_ERROR
AtalkNdisAddMulticast(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PBYTE					Address,
	IN  BOOLEAN					ExecuteSynchronously,
	IN  REQ_COMPLETION			AddCompletion,
	IN  PVOID					AddContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	INT				sizeOfList;
	PBYTE			addressData, tempList;
	KIRQL			OldIrql;
	NDIS_OID		ndisOid;
	NDIS_REQUEST	request;
	NDIS_STATUS		ndisStatus;
	PADDMC			pAmc;

	//  Check to see it we bound successfully to this adapter
	if (!PORT_BOUND(pPortDesc))
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_NOTBOUNDTOMAC,
						STATUS_INSUFFICIENT_RESOURCES,
						NULL,
						0);

		return ATALK_FAILURE;
	}

	//  Grab the perport spinlock. We need to allocate within a
	//	critical section as the size might change. This routine
	//	is called very infrequently, during init and when we
	//	receive our default zone from zip.

	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	sizeOfList = pPortDesc->pd_MulticastListSize + ELAP_ADDR_LEN;

	ASSERTMSG("AtalkNdisAddMulticast: Size is not > 0\n", (sizeOfList > 0));

	//	Allocate/reallocate the list for the port descriptor, and also
	//	for a copy to be used in the NDIS request function.
	tempList = (PBYTE)AtalkAllocZeroedMemory(sizeOfList);
	addressData = (PBYTE)AtalkAllocZeroedMemory(sizeOfList);
	pAmc = (PADDMC)AtalkAllocZeroedMemory(sizeof(ADDMC));

	if ((tempList == NULL) || (addressData == NULL) || (pAmc == NULL))
	{
		//  Release the spinlock
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

		if (pAmc != NULL)
			AtalkFreeMemory(pAmc);
		if (tempList != NULL)
			AtalkFreeMemory(tempList);
		if (addressData != NULL)
			AtalkFreeMemory(addressData);

		return ATALK_RESR_MEM;
	}

	if (pPortDesc->pd_MulticastList == NULL)
	{
		//	No old addresses to work with.
		pPortDesc->pd_MulticastListSize = 0;
	}
	else
	{
		//  Copy the old list over to the new space
		RtlCopyMemory(tempList,
					  pPortDesc->pd_MulticastList,
					  pPortDesc->pd_MulticastListSize);
	
		//  Set the proper values back into PortDesc after freeing the old list
		AtalkFreeMemory(pPortDesc->pd_MulticastList);
	}

	//  Guaranteed space is available to copy the new address
	//  Ready to copy our new address here and then do the set!
	RtlCopyMemory(tempList + pPortDesc->pd_MulticastListSize,
				  Address,
				  ELAP_ADDR_LEN);

	pPortDesc->pd_MulticastList = tempList;
	pPortDesc->pd_MulticastListSize = sizeOfList;

	switch (pPortDesc->pd_NdisPortType)
	{
	  case NdisMedium802_3 :

		ndisOid = OID_802_3_MULTICAST_LIST;
		break;

	  case NdisMediumFddi:

		//  FDDI supports 2byte and 6byte multicast addresses. We use the
		//  6byte multicast addresses for appletalk.
		ndisOid = OID_FDDI_LONG_MULTICAST_LIST;
		break;

	  default:

		KeBugCheck(0);
		break;
	}

	//  Setup request
	//  Move the list to our buffer

	ASSERTMSG("AtalkNdisAddMulticast: Size incorrect!\n",
			 ((ULONG)sizeOfList == pPortDesc->pd_MulticastListSize));
	
	RtlCopyMemory(addressData,
				  pPortDesc->pd_MulticastList,
				  pPortDesc->pd_MulticastListSize);

	//  Release the spinlock
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	request.RequestType = NdisRequestSetInformation;
	request.DATA.SET_INFORMATION.Oid = ndisOid;
	request.DATA.SET_INFORMATION.InformationBuffer = addressData;
	request.DATA.SET_INFORMATION.InformationBufferLength = sizeOfList;
	pAmc->AddCompletion = AddCompletion;
	pAmc->AddContext = AddContext;
	pAmc->Buffer = addressData;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
										&request,
										FALSE,
										atalkNdisAddMulticastCompletion,
										pAmc);

	//	NOTE: Sumbit calls completion if success is being returned.
	if ((ndisStatus != NDIS_STATUS_SUCCESS) &&
		(ndisStatus != NDIS_STATUS_PENDING))
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_NDISREQUEST,
						ndisStatus,
						NULL,
						0);
	}

	return AtalkNdisToAtalkError(ndisStatus);
}




ATALK_ERROR
AtalkNdisRemoveMulticast(
	IN  PPORT_DESCRIPTOR	pPortDesc,
	IN  PBYTE				Address,
	IN  BOOLEAN				ExecuteSynchronously,
	IN  REQ_COMPLETION		RemoveCompletion,
	IN  PVOID				RemoveContext
	)
{
	INT				sizeOfList, i, numberInList;
	PBYTE			addressData, currentList;
	KIRQL			OldIrql;
	NDIS_REQUEST	request;
	NDIS_OID		ndisOid;
	NDIS_STATUS		ndisStatus;
	PADDMC			pAmc;

	do
	{
		//  Check to see it we bound successfully to this adapter
		if (!PORT_BOUND(pPortDesc))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NOTBOUNDTOMAC,
							STATUS_INSUFFICIENT_RESOURCES,
							NULL,
							0);

			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
		}

		//  Grab the perport spinlock. Again, a very infrequent operation.
		//	Probably just twice in the lifetime of the stack.
		ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

		ASSERT(pPortDesc->pd_MulticastList != NULL);
		if (pPortDesc->pd_MulticastList == NULL)
		{
			//   Nothing to remove!
			ndisStatus = NDIS_STATUS_SUCCESS;
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			break;
		}
	
		numberInList = pPortDesc->pd_MulticastListSize/ELAP_ADDR_LEN;
		currentList  = pPortDesc->pd_MulticastList;
		for (i = 0; i < numberInList; i++, currentList += ELAP_ADDR_LEN)
		{
			//	Search for the address and remember the index if found
			if (RtlCompareMemory(currentList,
								 Address,
								 ELAP_ADDR_LEN) == ELAP_ADDR_LEN)
			{
				//	Move all address following this overwriting this address
				//	we ignore wasted space that will never be touched anymore.
				//	This could turn out to be a NOP if we are removing the last
				//	address in the list.
				RtlMoveMemory(currentList,
							  currentList + ELAP_ADDR_LEN,
							  pPortDesc->pd_MulticastListSize-((i+1)*ELAP_ADDR_LEN));
	
				pPortDesc->pd_MulticastListSize -= ELAP_ADDR_LEN;
	
				//	Have we removed the last address. If so, reset values.
				if (pPortDesc->pd_MulticastListSize == 0)
				{
					AtalkFreeMemory(pPortDesc->pd_MulticastList);
					pPortDesc->pd_MulticastList = NULL;
				}
	
				break;
			}
		}
	
		//	We assume address was found and the list is changed as expected
		//	Set this new list
		switch (pPortDesc->pd_NdisPortType)
		{
		  case NdisMedium802_3 :
	
			ndisOid = OID_802_3_MULTICAST_LIST;
			break;
	
		  case NdisMediumFddi:
	
			//  FDDI supports 2byte and 6byte multicast addresses. We use the
			//  6byte multicast addresses for appletalk.
			ndisOid = OID_FDDI_LONG_MULTICAST_LIST;
			break;
	
		  default:
	
			KeBugCheck(0);
			break;
		}
	
		addressData = NULL;
		sizeOfList  = pPortDesc->pd_MulticastListSize;
	
	    pAmc = (PADDMC)AtalkAllocZeroedMemory(sizeof(ADDMC));

		if (pAmc == NULL)
        {
			RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
        }

		if (sizeOfList > 0)
		{
			//	Allocate addressData and copy list to it
			addressData = (PBYTE)AtalkAllocMemory(sizeOfList);
			if (addressData == NULL)
			{
				//  Release the spinlock
				RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
			    AtalkFreeMemory(pAmc);
				ndisStatus = NDIS_STATUS_RESOURCES;
				break;
			}

			//  Move the list to our buffer
			RtlCopyMemory(addressData,
						  pPortDesc->pd_MulticastList,
						  pPortDesc->pd_MulticastListSize);
		}
	
		//  Release the spinlock
		RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);
	
		request.RequestType = NdisRequestSetInformation;
		request.DATA.SET_INFORMATION.Oid = ndisOid;
		request.DATA.SET_INFORMATION.InformationBuffer = addressData;
		request.DATA.SET_INFORMATION.InformationBufferLength = sizeOfList;
		pAmc->AddCompletion = RemoveCompletion;
		pAmc->AddContext = RemoveContext;
		pAmc->Buffer = addressData;
		
		ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
											&request,
											FALSE,
											atalkNdisAddMulticastCompletion,
											pAmc);
	
		if ((ndisStatus != NDIS_STATUS_SUCCESS) &&
			(ndisStatus != NDIS_STATUS_PENDING))
		{
			LOG_ERRORONPORT(pPortDesc,
							EVENT_ATALK_NDISREQUEST,
							ndisStatus,
							NULL,
							0);
		}

	} while (FALSE);

	return AtalkNdisToAtalkError(ndisStatus);
}



ATALK_ERROR
AtalkNdisSendPacket(
	IN  PPORT_DESCRIPTOR			pPortDesc,
	IN  PBUFFER_DESC				BufferChain,
	IN  SEND_COMPLETION				SendCompletion	OPTIONAL,
	IN  PSEND_COMPL_INFO			pSendInfo		OPTIONAL
	)
/*++

Routine Description:

	This routine is called by the portable code to send a packet out on
	ethernet. It will build the NDIS packet descriptor for the passed in
	chain and then send the packet on the specified port.

Arguments:


Return Value:

	TRUE- If sent/pending, FALSE otherwise
		  TransmitComplete is called if this call pended by completion code

--*/
{
	PNDIS_PACKET	ndisPacket;
	PNDIS_BUFFER	ndisBuffer;
	PPROTOCOL_RESD  protocolResd;
	ATALK_ERROR		error;
	PSENDBUF		pSendBuf;
	NDIS_STATUS	 	ndisStatus	= NDIS_STATUS_SUCCESS;
    PMDL            pMdl;
    PMDL            pFirstMdl=NULL;

	if (PORT_CLOSING(pPortDesc))
	{
		//	If we are not active, return!
		return ATALK_PORT_CLOSING;
	}

	do
	{
		pSendBuf	= (PSENDBUF)((PBYTE)BufferChain - sizeof(BUFFER_HDR));
		ndisPacket	= pSendBuf->sb_BuffHdr.bh_NdisPkt;

		//  Store the information needed in the packet descriptor
		protocolResd = (PPROTOCOL_RESD)&ndisPacket->ProtocolReserved;
		protocolResd->Send.pr_Port 				= pPortDesc;
		protocolResd->Send.pr_BufferDesc 		= BufferChain;
		protocolResd->Send.pr_SendCompletion 	= SendCompletion;
		if (pSendInfo != NULL)
			 protocolResd->Send.pr_SendInfo 	= *pSendInfo;
		else RtlZeroMemory(&protocolResd->Send.pr_SendInfo, sizeof(SEND_COMPL_INFO));

		//	For the first buffer, set up the length of the NDIS buffer to be
		//	the same as in indicated in the descriptor.
		NdisAdjustBufferLength(pSendBuf->sb_BuffHdr.bh_NdisBuffer,
							   BufferChain->bd_Length);
	
		//	NOTE: There is either a PBYTE being pointed to, or a PAMDL
		//		  being pointed to by the buffer descriptor. Also, the
		//		  size of the data will be the size that is to be
		//		  used. At the end, just assert that the total length
		//		  equals length passed in.
		if (BufferChain->bd_Next != NULL)
		{
			if (BufferChain->bd_Next->bd_Flags & BD_CHAR_BUFFER)
			{
				NdisAllocateBuffer(&ndisStatus,
								   &ndisBuffer,
								   AtalkNdisBufferPoolHandle,
								   (PVOID)BufferChain->bd_Next->bd_CharBuffer,
								   (UINT)BufferChain->bd_Next->bd_Length);
	
				if (ndisStatus != NDIS_STATUS_SUCCESS)
				{
					DBGPRINT(DBG_COMP_NDISSEND, DBG_LEVEL_ERR,
							("AtalkNdisSendPacket: NdisAllocateBuffer %lx\n", ndisStatus));
					// LOG_ERROR(EVENT_ATALK_NDISRESOURCES, ndisStatus, NULL, 0);
					break;
				}

                ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

			    NdisChainBufferAtBack(ndisPacket, ndisBuffer);
			}
			else
			{
				//  It is an MDL
                pMdl = (PMDL)BufferChain->bd_Next->bd_OpaqueBuffer;

                ASSERT(AtalkSizeMdlChain(pMdl) == BufferChain->bd_Next->bd_Length);
                while (pMdl)
                {
				    NdisCopyBuffer(&ndisStatus,
					    		   &ndisBuffer,
						    	   AtalkNdisBufferPoolHandle,
    							   (PVOID)pMdl,
	    						   0,  				//Offset
		    					   (UINT)MmGetMdlByteCount(pMdl));

				    if (ndisStatus != NDIS_STATUS_SUCCESS)
				    {
                        if (pFirstMdl)
                        {
                            AtalkNdisFreeBuffer(pFirstMdl);
                        }
					    break;
				    }
	
                    ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

                    if (!pFirstMdl)
                    {
                        pFirstMdl = pMdl;
                    }

			        NdisChainBufferAtBack(ndisPacket, ndisBuffer);

                    pMdl = pMdl->Next;
                }

				if (ndisStatus != NDIS_STATUS_SUCCESS)
				{
				    DBGPRINT(DBG_COMP_NDISSEND, DBG_LEVEL_ERR,
					    ("AtalkNdisSendPacket: NdisCopyBuffer %lx\n", ndisStatus));
				    break;
				}
			}
		}
	
#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_CurSendsOutstanding,
			&AtalkStatsLock.SpinLock);
#endif
		INTERLOCKED_INCREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_NumPacketsOut,
			&AtalkStatsLock.SpinLock);

		//  Now send the built packet descriptor
		NdisSend(&ndisStatus,
				 pPortDesc->pd_NdisBindingHandle,
				 ndisPacket);

		//	Completion will dereference the port!
		if (ndisStatus != NDIS_STATUS_PENDING)
		{
			//  Call the completion handler
			AtalkSendComplete(pPortDesc->pd_NdisBindingHandle,
							  ndisPacket,
							  ndisStatus);
			ndisStatus	= NDIS_STATUS_PENDING;
		}
	} while (FALSE);

	return AtalkNdisToAtalkError(ndisStatus);
}



ATALK_ERROR
AtalkNdisAddFunctional(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PBYTE					Address,
	IN  BOOLEAN					ExecuteSynchronously,
	IN  REQ_COMPLETION			AddCompletion,
	IN  PVOID					AddContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG			i;
	NDIS_REQUEST	request;
	NDIS_STATUS		ndisStatus;
	KIRQL			OldIrql;

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("Current %02x%02x%02x%02x, Adding %02x%02x%02x%02x\n",
			 pPortDesc->pd_FunctionalAddr[0], pPortDesc->pd_FunctionalAddr[1],
             pPortDesc->pd_FunctionalAddr[2], pPortDesc->pd_FunctionalAddr[3],
			 Address[2], Address[3], Address[4], Address[5]));

	//  Grab the perport spinlock
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	//  We only need the last four bytes of the address assuming that the
	//  first two bytes always remain the same (C000) and that the MAC assumes
	//  the same- NDIS 3.0 OID length = 4
	for (i = 0;
		 i < sizeof(ULONG);
		 i++)
		pPortDesc->pd_FunctionalAddr[i] |= Address[2+i];

	//  Release the spinlock
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("After Add %02x%02x%02x%02x\n",
			 pPortDesc->pd_FunctionalAddr[0], pPortDesc->pd_FunctionalAddr[1],
             pPortDesc->pd_FunctionalAddr[2], pPortDesc->pd_FunctionalAddr[3]));

	request.RequestType = NdisRequestSetInformation;
	request.DATA.SET_INFORMATION.Oid = OID_802_5_CURRENT_FUNCTIONAL;
	request.DATA.SET_INFORMATION.InformationBuffer = pPortDesc->pd_FunctionalAddr;
	request.DATA.SET_INFORMATION.InformationBufferLength = TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
										&request,
										ExecuteSynchronously,
										AddCompletion,
										AddContext);

	if (ndisStatus == NDIS_STATUS_PENDING)
	{
		ASSERT(ExecuteSynchronously != TRUE);
	}
	else if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_NDISREQUEST,
						ndisStatus,
						NULL,
						0);
	}

	return AtalkNdisToAtalkError(ndisStatus);
}




ATALK_ERROR
AtalkNdisRemoveFunctional(
	IN  PPORT_DESCRIPTOR		pPortDesc,
	IN  PBYTE					Address,
	IN  BOOLEAN					ExecuteSynchronously,
	IN  REQ_COMPLETION			RemoveCompletion,
	IN  PVOID					RemoveContext
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ULONG			i;
	KIRQL			OldIrql;
	NDIS_REQUEST	request;
	NDIS_STATUS		ndisStatus;

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("Current %02x%02x%02x%02x, Removing %02x%02x%02x%02x\n",
			pPortDesc->pd_FunctionalAddr[0], pPortDesc->pd_FunctionalAddr[1],
            pPortDesc->pd_FunctionalAddr[2], pPortDesc->pd_FunctionalAddr[3],
			Address[2], Address[3], Address[4], Address[5]));

	//  Grab the perport spinlock
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);

	//  We only need the last four bytes of the address assuming that the
	//  first two bytes always remain the same (C000) and that the MAC assumes
	//  the same- NDIS 3.0 OID length = 4
	for (i = 0; i < sizeof(ULONG); i++)
		pPortDesc->pd_FunctionalAddr[i] &= ~Address[2+i];

	//  Release the spinlock
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

	DBGPRINT(DBG_COMP_NDISREQ, DBG_LEVEL_INFO,
			("After Remove %02x%02x%02x%02x\n",
			 pPortDesc->pd_FunctionalAddr[0], pPortDesc->pd_FunctionalAddr[1],
             pPortDesc->pd_FunctionalAddr[2], pPortDesc->pd_FunctionalAddr[3]));

	request.RequestType = NdisRequestSetInformation;
	request.DATA.SET_INFORMATION.Oid = OID_802_5_CURRENT_FUNCTIONAL;
	request.DATA.SET_INFORMATION.InformationBuffer = pPortDesc->pd_FunctionalAddr;
	request.DATA.SET_INFORMATION.InformationBufferLength = TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN;

	ndisStatus = AtalkNdisSubmitRequest(pPortDesc,
										&request,
										ExecuteSynchronously,
										RemoveCompletion,
										RemoveContext);

	if (ndisStatus == NDIS_STATUS_PENDING)
	{
		ASSERT(ExecuteSynchronously != TRUE);
	}
	else if (ndisStatus != NDIS_STATUS_SUCCESS)
	{
		LOG_ERRORONPORT(pPortDesc,
						EVENT_ATALK_NDISREQUEST,
						ndisStatus,
						NULL,
						0);
	}

	return AtalkNdisToAtalkError(ndisStatus);
}




USHORT
AtalkNdisBuildEthHdr(
	IN		PUCHAR				PortAddr,			// 802 address of port
	IN 		PBYTE				pLinkHdr,			// Start of link header
	IN		PBYTE				pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL	Protocol,			// Logical protocol
	IN		USHORT				ActualDataLen		// Length for ethernet packets
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT			len;

	//  Set destination address.
	if (pDestHwOrMcastAddr == NULL)
		pDestHwOrMcastAddr = AtalkElapBroadcastAddr;

	RtlCopyMemory(pLinkHdr,
				  pDestHwOrMcastAddr,
				  ELAP_ADDR_LEN);

	//  Set source address.
	RtlCopyMemory(pLinkHdr += ELAP_ADDR_LEN,
				  PortAddr,
				  ELAP_ADDR_LEN);

	//  Set length, excluding Ethernet hardware header.
	len = ActualDataLen + IEEE8022_HDR_LEN;
	pLinkHdr += ELAP_ADDR_LEN;
	PUTSHORT2SHORT(pLinkHdr, len);
	pLinkHdr += sizeof(USHORT);

	ATALK_BUILD8022_HDR(pLinkHdr, Protocol);

	//	Return the link header length.
	return (ELAP_LINKHDR_LEN + IEEE8022_HDR_LEN);
}




USHORT
AtalkNdisBuildTRHdr(
	IN		PUCHAR				PortAddr,			// 802 address of port
	IN 		PBYTE				pLinkHdr,			// Start of link header
	IN		PBYTE				pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL	Protocol,			// Logical protocol
	IN		PBYTE				pRouteInfo,			// Routing info for tokenring
	IN		USHORT				RouteInfoLen		// Length of above
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	USHORT			linkLen;

	//	Here we need to worry about the routing info.
	//	If we currently do not have any, set the values
	if (pDestHwOrMcastAddr == NULL)
	{
		// Broadcast?
		pRouteInfo = AtalkBroadcastRouteInfo;
		RouteInfoLen = TLAP_MIN_ROUTING_BYTES;

	}
	else if (RouteInfoLen != 0)
	{
		//	We are all set
	}
	else if (AtalkFixedCompareCaseSensitive(pDestHwOrMcastAddr,
											TLAP_BROADCAST_DEST_LEN,
											AtalkBroadcastDestHdr,
											TLAP_BROADCAST_DEST_LEN))
	{
		// Multicast?
		pRouteInfo = AtalkBroadcastRouteInfo;
		RouteInfoLen = TLAP_MIN_ROUTING_BYTES;
	}
	else
	{
		// No routing know; use simple non-broadcast
		pRouteInfo = AtalkSimpleRouteInfo;
		RouteInfoLen = TLAP_MIN_ROUTING_BYTES;
	}							

	linkLen = TLAP_MIN_LINKHDR_LEN + RouteInfoLen + IEEE8022_HDR_LEN;

	// Set the first two bytes in the header
	*pLinkHdr++	= TLAP_ACCESS_CTRL_VALUE;
	*pLinkHdr++ = TLAP_FRAME_CTRL_VALUE ;

	// Set detination address.
	if (pDestHwOrMcastAddr == NULL)
		pDestHwOrMcastAddr = AtalkTlapBroadcastAddr;

	RtlCopyMemory(pLinkHdr,
				  pDestHwOrMcastAddr ,
				  TLAP_ADDR_LEN);

	// Set source address.
	RtlCopyMemory(pLinkHdr += TLAP_ADDR_LEN,
				  PortAddr,
				  TLAP_ADDR_LEN);

	ASSERTMSG("AtalkNdisBuildTRHdr: Routing Info is 0!\n", (RouteInfoLen > 0));
	*pLinkHdr |= TLAP_SRC_ROUTING_MASK;

	// Move in routing info.
	RtlCopyMemory(pLinkHdr += TLAP_ADDR_LEN,
				  pRouteInfo,
				  RouteInfoLen);

	pLinkHdr += RouteInfoLen;
	ATALK_BUILD8022_HDR(pLinkHdr, Protocol);

	//	Return the link header length.
	return linkLen;
}




USHORT
AtalkNdisBuildFDDIHdr(
	IN		PUCHAR				PortAddr,			// 802 address of port
	IN 		PBYTE				pLinkHdr,			// Start of link header
	IN		PBYTE				pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL	Protocol			// Logical protocol
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	*pLinkHdr++ = FDDI_HEADER_BYTE;

	//  Set destination address.
	if (pDestHwOrMcastAddr == NULL)
		pDestHwOrMcastAddr = AtalkElapBroadcastAddr;

	//  Set destination address.
	RtlCopyMemory(pLinkHdr,
				  pDestHwOrMcastAddr,
				  FDDI_ADDR_LEN);

	//  Set source address.
	RtlCopyMemory(pLinkHdr += FDDI_ADDR_LEN,
				  PortAddr,
				  FDDI_ADDR_LEN);

	pLinkHdr += FDDI_ADDR_LEN;

	//  NOTE: No Length field for FDDI, unlike Ethernet.
	ATALK_BUILD8022_HDR(pLinkHdr, Protocol);

	//	Return the link header length.
	return (FDDI_LINKHDR_LEN + IEEE8022_HDR_LEN);
}




USHORT
AtalkNdisBuildLTHdr(
	IN 		PBYTE				pLinkHdr,			// Start of link header
	IN		PBYTE				pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		BYTE				AlapSrc,			// Localtalk source node
	IN		BYTE				AlapType			// Localtalk ddp header type
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	// Fill in LAP header.
	if (pDestHwOrMcastAddr == NULL)
		pLinkHdr = AtalkAlapBroadcastAddr;

	*pLinkHdr++ = *pDestHwOrMcastAddr;

	*pLinkHdr++ = AlapSrc;
	*pLinkHdr   = AlapType;

	//	Return the link header length.
	return ALAP_LINKHDR_LEN;
}

VOID
AtalkNdisSendTokRingTestResp(
	IN		PPORT_DESCRIPTOR	pPortDesc,
	IN		PBYTE 				HdrBuf,
	IN		UINT 				HdrBufSize,
	IN		PBYTE 				LkBuf,
	IN		UINT 				LkBufSize,
	IN		UINT 				PktSize
	)
{
	PBUFFER_DESC	pBufDesc, pHdrDesc;
	PBYTE			pResp;
	UINT			routeInfoLen	= 0;

	//	Allocate a buffer to hold the response and call NdisSend
	//	providing a completion routine which will free up the buffer.
	ASSERT(PktSize == LkBufSize);

    // make sure there are at least 14 bytes!
    if (HdrBufSize < TLAP_ROUTE_INFO_OFFSET)
    {
        ASSERT(0);
        return;
    }

	//	First allocate a buffer to hold the link header.
	AtalkNdisAllocBuf(&pHdrDesc);
	if (pHdrDesc == NULL)
	{
		return;
	}

	if ((pBufDesc = AtalkAllocBuffDesc(NULL,
									   (USHORT)LkBufSize,
									   BD_CHAR_BUFFER | BD_FREE_BUFFER)) == NULL)
		
	{
		AtalkNdisFreeBuf(pHdrDesc);

		RES_LOG_ERROR();
		return;
	}

	pResp		= pHdrDesc->bd_CharBuffer;
	*pResp++	= TLAP_ACCESS_CTRL_VALUE;
	*pResp++	= TLAP_FRAME_CTRL_VALUE;

	// Set destination address to be the incoming src addr.
	ATALK_RECV_INDICATION_COPY(pPortDesc,
							   pResp,
							   HdrBuf+TLAP_SRC_OFFSET,
							   TLAP_ADDR_LEN);

	//	Make sure we do not have the routing bit set.
	*pResp	&= ~TLAP_SRC_ROUTING_MASK;
	pResp	+= TLAP_ADDR_LEN;

	// Set source address to be the incoming destination address.
	ATALK_RECV_INDICATION_COPY(pPortDesc,
							   pResp,
							   HdrBuf+TLAP_DEST_OFFSET,
							   TLAP_ADDR_LEN);

	//	Is there routing info present?
	if (HdrBuf[TLAP_SRC_OFFSET] & TLAP_SRC_ROUTING_MASK)
	{
		routeInfoLen = (HdrBuf[TLAP_ROUTE_INFO_OFFSET] & TLAP_ROUTE_INFO_SIZE_MASK);
		ASSERT(routeInfoLen != 0);
		ASSERTMSG("RouteInfo incorrect!\n",
				 (routeInfoLen <= TLAP_MAX_ROUTING_BYTES));

        if (HdrBufSize < (TLAP_ROUTE_INFO_OFFSET+routeInfoLen))
        {
            ASSERT(0);
		    AtalkNdisFreeBuf(pHdrDesc);
            AtalkFreeBuffDesc(pBufDesc);
            return;
        }

		//	Copy it in the response packet and then tune it.
		ATALK_RECV_INDICATION_COPY(pPortDesc,
								   pResp + TLAP_ADDR_LEN,
								   HdrBuf+TLAP_ROUTE_INFO_OFFSET,
								   routeInfoLen);

		// Set to "non-broadcast" and invert "direction".
		*(pResp+TLAP_ADDR_LEN) 		&= TLAP_NON_BROADCAST_MASK;
		*(pResp+TLAP_ADDR_LEN+1) 	^= TLAP_DIRECTION_MASK;

		//	Set the routing info bit in the source address
		*pResp	|= TLAP_SRC_ROUTING_MASK;
	}

	//	Set the length for this buffer descriptor.
	AtalkSetSizeOfBuffDescData(pHdrDesc, TLAP_ROUTE_INFO_OFFSET + routeInfoLen);

	//	Copy the remaining data
	ATALK_RECV_INDICATION_COPY(pPortDesc,
							   pBufDesc->bd_CharBuffer,
							   LkBuf,
							   LkBufSize);

	//	Set the source SAP to indicate FINAL (0xAB instead of 0xAA)
	pBufDesc->bd_CharBuffer[IEEE8022_SSAP_OFFSET] = SNAP_SAP_FINAL;

	//	Chain the passed in buffer desc onto the tail of the one
	//	returned above.
	AtalkPrependBuffDesc(pHdrDesc, pBufDesc);

	//	Call send at this point
	if (!ATALK_SUCCESS(AtalkNdisSendPacket(pPortDesc,
										   pHdrDesc,
										   AtalkNdisSendTokRingTestRespComplete,
										   NULL)))
	{
		AtalkNdisSendTokRingTestRespComplete(NDIS_STATUS_RESOURCES,
											 pHdrDesc,
											 NULL);
	}
}




VOID
AtalkNdisSendTokRingTestRespComplete(
	IN	NDIS_STATUS				Status,
	IN	PBUFFER_DESC			pBufDesc,
	IN	PSEND_COMPL_INFO		pInfo
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	//	Free up the buffer descriptor
	ASSERT((pBufDesc != NULL) && (pBufDesc->bd_Next != NULL));
	ASSERT(pBufDesc->bd_Flags & BD_CHAR_BUFFER);
	AtalkFreeBuffDesc(pBufDesc->bd_Next);
	AtalkNdisFreeBuf(pBufDesc);
}


NDIS_STATUS
AtalkReceiveIndication(
	IN	NDIS_HANDLE 	BindingCtx,
	IN	NDIS_HANDLE 	ReceiveCtx,
	IN	PVOID 			HdrBuf,
	IN	UINT 			HdrBufSize,
	IN	PVOID 			LkBuf,
	IN	UINT 			LkBufSize,
	IN	UINT 			PktSize
	)
/*++

Routine Description:

	This routine is called by NDIS to indicate a receive

Arguments:

	BindingCtx- Pointer to a port descriptor for this port
	ReceiveCtx- To be used in a transfer data if necessary
	LkBuf- buffer with lookahead data
	LkBufSize- Size of the above buffer
	PktSize- Size of whole packet

Return Value:

	STATUS_SUCCESS- Packet accepted
	STATUS_NOT_RECOGNIZED- Not our packet
	Other

--*/
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)BindingCtx;
	PNDIS_PACKET		ndisPkt;
	PBUFFER_HDR			pBufferHdr = NULL;
	PPROTOCOL_RESD  	protocolResd;		// Protocolresd field in ndisPkt
	UINT				actualPktSize;		// Size of data to copy
	UINT				bytesTransferred;	// Number of bytes transferred in XferData
	BOOLEAN				result;
	UINT				xferOffset;
	PBYTE				lkBufOrig	= (PBYTE)LkBuf;
	ATALK_ERROR			error		= ATALK_NO_ERROR;
	BOOLEAN				shortDdpHdr	= FALSE;
	BYTE				indicate	= 0,
						subType		= 0;
	NDIS_MEDIUM			Media;
	PBYTE				packet		= NULL;	// Where we will copy the packet
	NDIS_STATUS 		ndisStatus 	= NDIS_STATUS_SUCCESS;
	LOGICAL_PROTOCOL	protocol 	= UNKNOWN_PROTOCOL;
    PARAPCONN           pArapConn;
    PATCPCONN           pAtcpConn;
    ATALK_NODEADDR      ClientNode;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	do
	{
		if ((pPortDesc->pd_Flags & (PD_ACTIVE | PD_CLOSING)) != PD_ACTIVE)
		{
			//	If we are not active, return!
			ndisStatus = ATALK_PORT_CLOSING;
			break;
		}
	
		ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
	
		Media = pPortDesc->pd_NdisPortType;

		//	Reduce 802.2 code, avoid making it a routine. First 802.2.
		switch (Media)
		{
		  case NdisMedium802_3:
		  case NdisMediumFddi:
		  case NdisMedium802_5:
			ATALK_VERIFY8022_HDR((PBYTE)LkBuf, LkBufSize, protocol, result);
	
			if (!result)
			{
				ndisStatus	= NDIS_STATUS_NOT_RECOGNIZED;

                if (LkBufSize < IEEE8022_CONTROL_OFFSET+1)
                {
                    ASSERT(0);
                    break;
                }

				if (Media == NdisMedium802_5)
				{
					//	BUG #16002
					//	On tokenring the macs also send out a Unnumbered format
					//	TEST frame to which we need to respond. Check for that
					//	here.
		
					if ((((PBYTE)LkBuf)[IEEE8022_DSAP_OFFSET]	== SNAP_SAP)	&&
						(((PBYTE)LkBuf)[IEEE8022_SSAP_OFFSET]	== SNAP_SAP)	&&
						(((PBYTE)LkBuf)[IEEE8022_CONTROL_OFFSET] == UNNUMBERED_FORMAT))
					{
						DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_INFO,
								("atalkNdisAcceptTlapPacket: LLC TEST FRAME RECD!\n"));
			
						RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

						//	Due to the aarp lookahead size setting, we are guaranteed
						//	the entire frame is contained in the lookahead data.
						AtalkNdisSendTokRingTestResp(pPortDesc,
													(PBYTE)HdrBuf,
													HdrBufSize,
													(PBYTE)LkBuf,
													LkBufSize,
													PktSize);

						ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
					}
				}
				break;
			}

			if (protocol == APPLETALK_PROTOCOL)
			{
				//  Do we at least have a 802.2 and DDP header in the indicated packet?
				if ((PktSize < (IEEE8022_HDR_LEN + LDDP_HDR_LEN)) ||
					(PktSize > (IEEE8022_HDR_LEN + MAX_LDDP_PKT_SIZE)))
				{
					ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
					break;
				}
			}
			else	// AARP
			{
				UINT	routeInfoLen = 0; // length of routing info if present (802.5)

				switch (Media)
				{
				  case NdisMediumFddi:
					//  For fddi, there could be padding included in the packet. Shrink
					//  the length if so. Note header length is not included in packetlength.
					//
					if (PktSize >= (MIN_FDDI_PKT_LEN - FDDI_LINKHDR_LEN))
					{
						PktSize = (IEEE8022_HDR_LEN + AARP_MIN_DATA_SIZE);
					}
					break;

				  case NdisMedium802_5:
		
					//  Remember- routing info is in the header buffer
					if (((PBYTE)HdrBuf)[TLAP_SRC_OFFSET] & TLAP_SRC_ROUTING_MASK)
					{
						routeInfoLen = (((PBYTE)HdrBuf)[TLAP_ROUTE_INFO_OFFSET] &
																TLAP_ROUTE_INFO_SIZE_MASK);
						ASSERTMSG("RouteInfo incorrect!\n",
								 ((routeInfoLen > 0) && (routeInfoLen <= TLAP_MAX_ROUTING_BYTES)));
		
						//	Routing info must be of reasonable size, and not odd.
						if ((routeInfoLen & 1) ||
							(routeInfoLen > TLAP_MAX_ROUTING_BYTES))
						{
							ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
							break;
						}
					}
					// Fall through to 802.3 case
		
				  case NdisMedium802_3:
					if (PktSize >= (ELAP_MIN_PKT_LEN - ELAP_LINKHDR_LEN))
					{
						PktSize = (IEEE8022_HDR_LEN + AARP_MIN_DATA_SIZE);
					}
				}

				if (((PktSize - IEEE8022_HDR_LEN) > AARP_MAX_DATA_SIZE) ||
					((PktSize - IEEE8022_HDR_LEN) < AARP_MIN_DATA_SIZE))
				{
					ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
					break;
				}
			}
			actualPktSize = (PktSize + HdrBufSize - IEEE8022_HDR_LEN);
			(PBYTE)LkBuf += IEEE8022_HDR_LEN;
			xferOffset	  = IEEE8022_HDR_LEN;

			break;
	
		  case NdisMediumLocalTalk:

			//  No AARP/802.2 header on localtalk
			protocol = APPLETALK_PROTOCOL;

            // we should have enough bytes to have at least the short-header
            if (LkBufSize < SDDP_PROTO_TYPE_OFFSET+1)
            {
				ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
                ASSERT(0);
				break;
            }

			if (((PBYTE)HdrBuf)[ALAP_TYPE_OFFSET] == ALAP_SDDP_HDR_TYPE)
			{
				shortDdpHdr = TRUE;
			}
			else if (((PBYTE)HdrBuf)[ALAP_TYPE_OFFSET] != ALAP_LDDP_HDR_TYPE)
			{
				ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
				break;
			}
			actualPktSize = PktSize + HdrBufSize;
			xferOffset		= 0;
			break;

          case NdisMediumWan:

            if (pPortDesc->pd_Flags & PD_RAS_PORT)
            {
                //
                // 1st byte 0x01 tells us it's a PPP connection
                //
                if ((((PBYTE)HdrBuf)[0] == PPP_ID_BYTE1) &&
                    (((PBYTE)HdrBuf)[1] == PPP_ID_BYTE2))
                {
                    RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

                    DBGDUMPBYTES("Packet from PPP client:", (PBYTE)LkBuf,LkBufSize,4);

                    if (AtalkReferenceDefaultPort())
                    {
                        AtalkDdpPacketIn(AtalkDefaultPort,  // came on which port
                                         NULL,              // Link Hdr
                                         (PBYTE)LkBuf,      // packet
                                         (USHORT)LkBufSize, // how big is the pkt
                                         TRUE);             // did this come on WAN?

                        AtalkPortDereference(AtalkDefaultPort);
                    }
                }

                //
                // this is ARAP connection: lot of stuff to be done before pkt
                // can be given to the right destination...
                //
                else
                {
                    ASSERT ((((PBYTE)HdrBuf)[0] == ARAP_ID_BYTE1) &&
                            (((PBYTE)HdrBuf)[1] == ARAP_ID_BYTE2));

                    *((ULONG UNALIGNED *)(&pArapConn)) =
                                  *((ULONG UNALIGNED *)(&((PBYTE)HdrBuf)[2]));

                    RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

                    ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

                    //
                    // NDISWAN guarantees that all the data is in the LookAhead buffer
                    //
                    ArapRcvIndication( pArapConn,
                                       LkBuf,
                                       LkBufSize );
                }
            }

            break;

		  default:
			//  Should never happen!
			DBGPRINT(DBG_COMP_DDP, DBG_LEVEL_FATAL,
					("AtalkReceiveIndication: Unknown media\n"));
			ASSERT(0);
            ndisStatus = NDIS_STATUS_NOT_RECOGNIZED;
			break;
		}

        // we have already taken care of the Wan case: quit here
        if (Media == NdisMediumWan)
        {
            break;
        }

        //
        // if pkt not interesting, quit., if this is ras adapter, quit
        //
		if (ndisStatus != NDIS_STATUS_SUCCESS)
		{
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			break;
		}
	
		INTERLOCKED_INCREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_NumPacketsIn,
			&AtalkStatsLock.SpinLock);

		INTERLOCKED_ADD_STATISTICS(&pPortDesc->pd_PortStats.prtst_DataIn,
								   (LONG)actualPktSize,
								   &AtalkStatsLock.SpinLock);

		ASSERT ((protocol == APPLETALK_PROTOCOL) || (protocol == AARP_PROTOCOL));

		//	At this point, the IEEE802.2 header has been skipped in the lookahead
		//	buffer.
		//  Packet is to be accepted! Get an appropriate buffer and set the
		//	fields.
		switch (protocol)
		{
		  case APPLETALK_PROTOCOL:
			//	We either need to receive this packet on the default port, or
			//	we must be a router.
			if ((pPortDesc == AtalkDefaultPort) || AtalkRouter)
			{
				if (shortDdpHdr)
				{
					//	Check to see if we can indicate this to ATP/ADSP.
					if ((((PBYTE)LkBuf)[SDDP_PROTO_TYPE_OFFSET] == DDPPROTO_ATP) &&
						((USHORT)(LkBufSize - xferOffset) >= (SDDP_HDR_LEN + ATP_HEADER_SIZE)))
					{
						indicate = INDICATE_ATP;
					}
				}
				else
				{
					//	Check to see if we can indicate this to ATP/ADSP.
					if ((((PBYTE)LkBuf)[LDDP_PROTO_TYPE_OFFSET] == DDPPROTO_ATP) &&
						((USHORT)(LkBufSize - xferOffset) >= (LDDP_HDR_LEN + ATP_HEADER_SIZE)))
					{
						indicate = INDICATE_ATP;
					}
				}
			}
		
			//	First check for optimizing ATP/ADSP packets.
			if (indicate == INDICATE_ATP)
			{
				error = AtalkIndAtpPkt(pPortDesc,
									   (PBYTE)LkBuf,
									   (USHORT)(PktSize - xferOffset),
									   &xferOffset,	//	IN/OUT parameter
									   HdrBuf,
									   shortDdpHdr,
									   &subType,
									   &packet,
									   &ndisPkt);
							
				if (ATALK_SUCCESS(error))
				{
					break;
				}
				else if (error == ATALK_INVALID_PKT)
				{
					//	This indicates that the indication code has figured out that
					//	the packet is bad.
					break;
				}
				else
				{
					//	This is the case where the indication code cannot figure out
					//	if this packet qualifies.
					indicate = 0;
					error 	 = ATALK_NO_ERROR;
				}
			}
	
			if (actualPktSize > (sizeof(DDP_SMBUFFER) - sizeof(BUFFER_HDR)))
			{
				pBufferHdr = (PBUFFER_HDR)AtalkBPAllocBlock(BLKID_DDPLG);
			}
			else
			{
				pBufferHdr = (PBUFFER_HDR)AtalkBPAllocBlock(BLKID_DDPSM);
			}
			break;
	
		  case AARP_PROTOCOL:
			pBufferHdr = (PBUFFER_HDR)AtalkBPAllocBlock(BLKID_AARP);
			break;
	
		  default:
			KeBugCheck(0);
			break;
		}
	
		if (!ATALK_SUCCESS(error) || ((pBufferHdr == NULL) && (indicate == 0)))
		{
#if	DBG
			UINT	i;			

			DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
					("AtalkReceiveIndication: Dropping packet (2) %ld\n", error));
			for (i = 0; i < HdrBufSize; i++)
				DBGPRINTSKIPHDR(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
								("%02x ", ((PUCHAR)HdrBuf)[i]));
			for (i = 0; i < LkBufSize; i++)
				DBGPRINTSKIPHDR(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
								("%02x ", ((PUCHAR)LkBuf)[i]));
	
#endif
			//	No logging in this critical path.
			//	LOG_ERRORONPORT(pPortDesc,
			//					EVENT_ATALK_AARPPACKET,
			//					actualPktSize,
			//					HdrBuf,
			//					HdrBufSize);
	
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

			if (error != ATALK_DUP_PKT)
			{
				INTERLOCKED_INCREMENT_LONG_DPC(
					&pPortDesc->pd_PortStats.prtst_NumPktDropped,
					&AtalkStatsLock.SpinLock);
			}
	
			ndisStatus = NDIS_STATUS_RESOURCES;
			break;
		}
	
		if (indicate == 0)
		{
			packet = (PBYTE)pBufferHdr + sizeof(BUFFER_HDR);
		
			//  Get a pointer to the NDIS packet descriptor from the buffer header.
			ndisPkt	= pBufferHdr->bh_NdisPkt;
		}
	
		protocolResd = (PPROTOCOL_RESD)(ndisPkt->ProtocolReserved);

		//  Store the information needed in the packet descriptor
		protocolResd->Receive.pr_Port 		= pPortDesc;
		protocolResd->Receive.pr_Protocol 	= protocol;
		protocolResd->Receive.pr_Processed 	= FALSE;
	
		//  Queue up the packet in the receive queue on this port
		//  Then, go ahead with the transfer data etc. For Atp response
		//	case when SubType == ATP_USER_BUFX, we do not want any
		//	Recv. completion processing, do not queue. In this case
		//	TransferData completion frees up the Ndis resources.
		if ((indicate != INDICATE_ATP) ||
			(protocolResd->Receive.pr_OptimizeSubType != ATP_USER_BUFX))
		{
			ATALK_RECV_INDICATION_COPY(pPortDesc,
									   protocolResd->Receive.pr_LinkHdr,
									   (PBYTE)HdrBuf,
									   HdrBufSize);
			InsertTailList(&pPortDesc->pd_ReceiveQueue,
						   &protocolResd->Receive.pr_Linkage);
		}
		else
		{
			DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
					("AtalkReceiveIndication: Skipping link hdr !!!\n"));
		}

		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG_DPC(
				&pPortDesc->pd_PortStats.prtst_CurReceiveQueue,
				&AtalkStatsLock.SpinLock);
#endif
	
		//	Adjust for the link header size. Set size in protocol reserved. We want
		//	to avoid changing the size described by the NDIS buffer descriptor.
		if (indicate == 0)
		{
			actualPktSize 					   -= HdrBufSize;
			protocolResd->Receive.pr_DataLength	= (USHORT)actualPktSize;
		}
		else
		{
			actualPktSize = protocolResd->Receive.pr_DataLength;
		}
	
		ASSERT(ndisStatus == NDIS_STATUS_SUCCESS);
	
		if ((PktSize <= LkBufSize) 	&&
			((indicate != INDICATE_ATP) || (subType != ATP_RESPONSE)))
		{
			//	LkBuf has already been advanced to skip the ieee 802.2 header.
			//	We may need to skip more. Use the original lkbuf and xfer offset.
			ATALK_RECV_INDICATION_COPY(pPortDesc,
									   packet,
									   (PBYTE)lkBufOrig + xferOffset,
									   actualPktSize);
			bytesTransferred = actualPktSize;
		}
		else
		{
			//	Skip 802.2 header (both AARP and Appletalk), localtalk doesnt have one!
			if (actualPktSize > 0)
			{
				NdisTransferData(&ndisStatus,
								 pPortDesc->pd_NdisBindingHandle,
								 ReceiveCtx,
								 xferOffset,
								 actualPktSize,
								 ndisPkt,
								 &bytesTransferred);
				ASSERT(bytesTransferred == actualPktSize);
			}
		}
	
		if (ndisStatus == NDIS_STATUS_PENDING)
		{
			ndisStatus = NDIS_STATUS_SUCCESS;
		}
		else
		{
			//  Transfer data completed, call the transfer data completion
			//  routine to do rest of the work. If an error happened, ReceiveCompletion
			//	will drop the packet.
			protocolResd->Receive.pr_ReceiveStatus = ndisStatus;
			protocolResd->Receive.pr_Processed = TRUE;
		
			// In case of intermediate Atp response, the packet is not actually linked
			// into the receive queue, just free it.
			if ((protocolResd->Receive.pr_OptimizeType == INDICATE_ATP) &&
                (protocolResd->Receive.pr_OptimizeSubType == ATP_USER_BUFX))
			{
				PNDIS_BUFFER	ndisBuffer;

				//	Free NDIS buffers if any are present.
				NdisUnchainBufferAtFront(ndisPkt, &ndisBuffer);
			
				if (ndisBuffer != NULL)
				{
					AtalkNdisFreeBuffer(ndisBuffer);
				}
				NdisDprFreePacket(ndisPkt);
			}
		}
	} while (FALSE);

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(&pPortDesc->pd_PortStats.prtst_RcvIndProcessTime,
									TimeD,
									&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC( &pPortDesc->pd_PortStats.prtst_RcvIndCount,
									&AtalkStatsLock.SpinLock);
#endif

	return ndisStatus;
}


VOID
AtalkTransferDataComplete(
	IN	NDIS_HANDLE		BindingCtx,
	IN	PNDIS_PACKET	NdisPkt,
	IN	NDIS_STATUS		Status,
	IN	UINT			BytesTransferred
)
/*++

Routine Description:

	This routine is called by NDIS to indicate completion of a TransferData

Arguments:

	BindingCtx- Pointer to a port descriptor for this port
	NdisPkt- Ndis packet into which data was transferred
	Status- Status of request
	bytesTransferred- Actual number of bytes transferred

Return Value:

	None

--*/
{
	PPROTOCOL_RESD  	protocolResd;
	PNDIS_BUFFER		ndisBuffer;

	protocolResd = (PPROTOCOL_RESD)(NdisPkt->ProtocolReserved);

	protocolResd->Receive.pr_ReceiveStatus = Status;
	protocolResd->Receive.pr_Processed = TRUE;

	// In case of intermediate Atp response, the packet is not actually linked
	// into the receive queue, just free it.
	if (protocolResd->Receive.pr_OptimizeSubType == ATP_USER_BUFX)
	{
		//	Free NDIS buffers if any are present.
		NdisUnchainBufferAtFront(NdisPkt, &ndisBuffer);
	
		if (ndisBuffer != NULL)
		{
			AtalkNdisFreeBuffer(ndisBuffer);
		}
		NdisDprFreePacket(NdisPkt);
	}
}




VOID
AtalkReceiveComplete(
	IN	NDIS_HANDLE	BindingCtx
	)
/*++

Routine Description:

	We experimented with queueing up a work item for receive completion. It really
	KILLED performance with multiple clients as apparently the receive completion
	kept getting interrupted with receive indications. AS the optimization was
	put in for slow cards like the ELNKII which do not have adequate buffering,
	we decided to take it out. The retry values (or timeout trimming) should be
	enough for the slow cards. They will inevitably drop packets.

Arguments:


Return Value:


--*/
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)BindingCtx;
	PPROTOCOL_RESD  	protocolResd;
	PNDIS_PACKET 		ndisPkt;
	PNDIS_BUFFER		ndisBuffer;
	PBUFFER_HDR			pBufHdr;
	NDIS_MEDIUM			Media;
	PLIST_ENTRY 		p;
	PBYTE				packet;
	LOGICAL_PROTOCOL	protocol;
	UINT				packetLength;
    BOOLEAN             fDerefDefPort=FALSE;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;
#endif


    if (pPortDesc->pd_Flags & PD_RAS_PORT)
    {
        // give ARAP guys a chance
        ArapRcvComplete();

        if (!AtalkReferenceDefaultPort())
        {
            return;
        }

        fDerefDefPort = TRUE;

        // give PPP guys a chance
        pPortDesc = AtalkDefaultPort;
    }

	//  Get the stuff off the receive queue for the port and send it up. Do not
	//	enter if the queue is initially empty.
	if (IsListEmpty(&pPortDesc->pd_ReceiveQueue))
	{
        if (fDerefDefPort)
        {
            AtalkPortDereference(AtalkDefaultPort);
        }
		return;
	}

#ifdef	PROFILING
	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	while (TRUE)
	{
		ACQUIRE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
		p = pPortDesc->pd_ReceiveQueue.Flink;
		if (p == &pPortDesc->pd_ReceiveQueue)
		{
			//	Queue is empty
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			break;
		}

		ndisPkt = CONTAINING_RECORD(p, NDIS_PACKET, ProtocolReserved[0]);
		protocolResd = (PPROTOCOL_RESD)(ndisPkt->ProtocolReserved);

		//  Check if the queued receive is done processing. Since we are looping
		//	through the queue and since receive complete only checks if the first
		//	is done, we need this check here for subsequent queued up receives.
		if (!protocolResd->Receive.pr_Processed)
		{
			//	Queue is empty
			RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);
			break;
		}

		//  Dequeue and indicate this packet to the ddp/atp layer
		p = RemoveHeadList(&pPortDesc->pd_ReceiveQueue);
		pBufHdr = protocolResd->Receive.pr_BufHdr;

		RELEASE_SPIN_LOCK_DPC(&pPortDesc->pd_Lock);

#ifdef	PROFILING
		INTERLOCKED_DECREMENT_LONG_DPC(
			&pPortDesc->pd_PortStats.prtst_CurReceiveQueue,
			&AtalkStatsLock.SpinLock);
#endif
		Media = pPortDesc->pd_NdisPortType;
		protocol = protocolResd->Receive.pr_Protocol;

		if ((protocol == APPLETALK_PROTOCOL) &&
			(protocolResd->Receive.pr_OptimizeType == INDICATE_ATP))
		{
			protocolResd->Receive.pr_OptimizeType = 0;
			ASSERT(protocolResd->Receive.pr_OptimizeSubType != ATP_USER_BUFX);

			//  Check the receive status- accept only if ok
			if (protocolResd->Receive.pr_ReceiveStatus == NDIS_STATUS_SUCCESS)
			{
				//	Glean information. Check for route info if tokenring network.
				if (Media != NdisMediumLocalTalk)
				{
					AtalkAarpOptGleanInfo(pPortDesc,
										  protocolResd->Receive.pr_LinkHdr,
										  &protocolResd->Receive.pr_SrcAddr,
										  &protocolResd->Receive.pr_DestAddr,
										  protocolResd->Receive.pr_OffCablePkt);
				}
		
				//	Different calls for response & non-response packets.
				if (protocolResd->Receive.pr_OptimizeSubType == ATP_USER_BUF)
				{
					AtalkAtpPacketIn(AtalkDefaultPort,
									protocolResd->Receive.pr_AtpAddrObj->atpao_DdpAddr,
									protocolResd->Receive.pr_AtpHdr,
									(USHORT)(protocolResd->Receive.pr_DataLength + 8),
									&protocolResd->Receive.pr_SrcAddr,
									&protocolResd->Receive.pr_DestAddr,
									ATALK_NO_ERROR,
									DDPPROTO_ATP,
									protocolResd->Receive.pr_AtpAddrObj,
									TRUE,
									protocolResd->Receive.pr_OptimizeCtx);
				}
				else
				{
					ASSERT (protocolResd->Receive.pr_OptimizeSubType == ATP_ALLOC_BUF);

					packet = (PBYTE)pBufHdr + sizeof(BUFFER_HDR);
					ASSERT(packet != NULL);
			
					AtalkAtpPacketIn(AtalkDefaultPort,
									protocolResd->Receive.pr_AtpAddrObj->atpao_DdpAddr,
									packet,
									(USHORT)protocolResd->Receive.pr_DataLength,
									&protocolResd->Receive.pr_SrcAddr,
									&protocolResd->Receive.pr_DestAddr,
									ATALK_NO_ERROR,
									DDPPROTO_ATP,
									protocolResd->Receive.pr_AtpAddrObj,
									TRUE,
									protocolResd->Receive.pr_OptimizeCtx);
				}
			}

			//	Different calls for user buffer/allocated packets
			if (protocolResd->Receive.pr_OptimizeSubType == ATP_USER_BUF)
			{
				//	Free NDIS buffers if any are present.
				NdisUnchainBufferAtFront(ndisPkt, &ndisBuffer);
	
				if (ndisBuffer != NULL)
				{
					AtalkNdisFreeBuffer(ndisBuffer);
				}
				NdisDprFreePacket(ndisPkt);
			}
			else
			{
				AtalkBPFreeBlock(packet-sizeof(BUFFER_HDR));
			}
			continue;
		}

		//  IMPORTANT:
		//  We know that the buffer is virtually contiguous since we allocated
		//  it. And we also know that only one buffer is allocated. So we use
		//  that knowledge to get the actual address and pass that onto the
		//  higher level routines.
		//	!!!!
		//	Although, the allocated buffer contains the link header tagged on at
		//	the end, we do not have the packet descriptor describing that. As
		//	far as we are concerned here, that tagged entity does not exist and
		//	is independently pointed to by protocolResd->pr_LinkHdr.
		//	!!!!
		packet = (PBYTE)pBufHdr + sizeof(BUFFER_HDR);
		ASSERT(packet != NULL);

		packetLength = protocolResd->Receive.pr_DataLength;

		//  Check the receive status- accept only if ok
		if (protocolResd->Receive.pr_ReceiveStatus != NDIS_STATUS_SUCCESS)
		{
			DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
					("AtalkReceiveComplete: ReceiveStatus FAILURE %lx!\n",
					protocolResd->Receive.pr_ReceiveStatus));

			AtalkBPFreeBlock(packet-sizeof(BUFFER_HDR));
			continue;
		}

		//  The packet descriptor is now associate with the buffer, and we cant
		//	release the buffer (and hence the descriptor) until after we indicate to
		//  the higher levels

		switch (Media)
		{
		  case NdisMedium802_3 :
		  case NdisMediumFddi :
		  case NdisMedium802_5 :
		  case NdisMediumLocalTalk :

			if (protocol == APPLETALK_PROTOCOL)
			{
				DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_INFO,
						("AtalkReceiveComplete: Indicating DDP Ethernet\n"));

				AtalkDdpPacketIn(pPortDesc,
								 protocolResd->Receive.pr_LinkHdr,
								 packet,
								 (USHORT)packetLength,
                                 FALSE);
			}
			else
			{
				//  AARP Packet
				DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_INFO,
						("AtalkReceiveComplete: Indicating AARP Ethernet\n"));

				ASSERT(Media != NdisMediumLocalTalk);
				AtalkAarpPacketIn(pPortDesc,
								  protocolResd->Receive.pr_LinkHdr,
								  packet,
								  (USHORT)packetLength);
			}
			break;

		  default:
			KeBugCheck(0);
			break;
		}

		//	!!!!
		//	We dont have to free the link header. This follows the packet
		//	buffer (and was allocated along with it) and will be freed when
		//	the packet is freed.
		AtalkBPFreeBlock(packet-sizeof(BUFFER_HDR));
	}

    if (fDerefDefPort)
    {
        AtalkPortDereference(AtalkDefaultPort);
    }

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;

	INTERLOCKED_ADD_LARGE_INTGR_DPC(
		&pPortDesc->pd_PortStats.prtst_RcvCompProcessTime,
		TimeD,
		&AtalkStatsLock.SpinLock);

	INTERLOCKED_INCREMENT_LONG_DPC( &pPortDesc->pd_PortStats.prtst_RcvCompCount,
									&AtalkStatsLock.SpinLock);
#endif
}



VOID
AtalkSendComplete(
	IN	NDIS_HANDLE		ProtoBindCtx,
	IN	PNDIS_PACKET	NdisPkt,
	IN	NDIS_STATUS		NdisStatus
	)
/*++

Routine Description:


Arguments:

	ProtoBindCtx- Binding associated with mac
	NdisPkt- Packet which was sent
	NdisStatus- Final status of send

Return Value:

	None

--*/
{
	PPROTOCOL_RESD  		pProtocolResd;
	PNDIS_BUFFER			pNdisBuffer=NULL, pNdisFirstBuffer=NULL;
	PPORT_DESCRIPTOR		pPortDesc;
	PBUFFER_DESC			pBufferDesc;
	SEND_COMPLETION			pSendComp;
	SEND_COMPL_INFO			sendInfo;

	//  Call the completion routine, we don't care about status now
	pProtocolResd = (PPROTOCOL_RESD)(NdisPkt->ProtocolReserved);
	ASSERT(pProtocolResd != NULL);

	pPortDesc	= pProtocolResd->Send.pr_Port;
	sendInfo	= pProtocolResd->Send.pr_SendInfo;
	pBufferDesc	= pProtocolResd->Send.pr_BufferDesc;
	pSendComp	= pProtocolResd->Send.pr_SendCompletion;

	//	We free up all the ndis buffer descriptors except the first one.
	//	NOTE: The presence of a second buffer descriptor indicates that more
	//		  than one NdisBuffer is present. But not necessarily just two. If
	//		  the client had passed in a MDL chain, we would create a corresponding
	// 		  NDIS buffer descriptor chain. Therefore, remove the first, free up
	//		  all remaining ones, then queue back the first.

	NdisUnchainBufferAtFront(NdisPkt, &pNdisFirstBuffer);

	if (pProtocolResd->Send.pr_BufferDesc->bd_Next != NULL)
	{
		while (TRUE)
		{
			NdisUnchainBufferAtBack(NdisPkt,
									&pNdisBuffer);

			if (pNdisBuffer == NULL)
			{
				break;
			}

			//	Free up the ndis buffer descriptor.
			AtalkNdisFreeBuffer(pNdisBuffer);
		}
	}

	//	Reintialize the packet descriptor.
	NdisReinitializePacket(NdisPkt);

	//	Put first buffer back in.
	if (pNdisFirstBuffer != NULL)
	{
		NdisChainBufferAtFront(NdisPkt, pNdisFirstBuffer);
	}

	//	Call the completion routine for the transmit. This invalidates NdisPkt.
    if (pSendComp)
    {
	    (*pSendComp)(NdisStatus, pBufferDesc, &sendInfo);
    }

	//	Dereference the port
	ASSERT(pPortDesc != NULL);

#ifdef	PROFILING
	INTERLOCKED_DECREMENT_LONG(
		&pPortDesc->pd_PortStats.prtst_CurSendsOutstanding,
		&AtalkStatsLock.SpinLock);
#endif
}


VOID
AtalkBindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE	 BindContext,
	IN	PNDIS_STRING DeviceName,
	IN	PVOID		 SystemSpecific1,
	IN	PVOID		 SystemSpecific2
)
{
    // are we unloading?  if so, just return
    if (AtalkBindnUnloadStates & ATALK_UNLOADING)
    {
		DBGPRINT(DBG_COMP_NDISRECV, DBG_LEVEL_ERR,
			("AtalkBindAdapter: nothing to do: driver unloading\n"));
        return;
    }

    AtalkBindnUnloadStates |= ATALK_BINDING;

	AtalkLockInitIfNecessary();
	*Status = AtalkInitAdapter(DeviceName, NULL);

	ASSERT(*Status != NDIS_STATUS_PENDING);
	AtalkUnlockInitIfNecessary();

    AtalkBindnUnloadStates &= ~ATALK_BINDING;
}


VOID
AtalkUnbindAdapter(
	OUT PNDIS_STATUS Status,
	IN	NDIS_HANDLE ProtocolBindingContext,
	IN	NDIS_HANDLE	UnbindContext
)
{
	PPORT_DESCRIPTOR	pPortDesc = (PPORT_DESCRIPTOR)ProtocolBindingContext;


	DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
	    ("AtalkUnbindAdapter on %lx\n",ProtocolBindingContext));

    ASSERT( VALID_PORT(pPortDesc) );

	AtalkLockInitIfNecessary();

    // First and foremost: tell guys above so they can cleanup
    if ((pPortDesc->pd_Flags & PD_DEF_PORT) ||
        (pPortDesc->pd_Flags & PD_RAS_PORT))
    {
        if (pPortDesc->pd_Flags & PD_DEF_PORT)
        {
            ASSERT(pPortDesc == AtalkDefaultPort);

            if (TdiAddressChangeRegHandle)
            {
                TdiDeregisterNetAddress(TdiAddressChangeRegHandle);
                TdiAddressChangeRegHandle = NULL;

                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                    ("AtalkUnbindAdapter: TdiDeregisterNetAddress on %Z done\n",
                    &pPortDesc->pd_AdapterName));

            }

            // this will tell AFP
            if (TdiRegistrationHandle)
            {
	            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkUnbindAdapter: default adapter unbound, telling AFP, RAS\n"));

                TdiDeregisterDeviceObject(TdiRegistrationHandle);
                TdiRegistrationHandle = NULL;
            }
        }
        else
        {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		        ("AtalkUnbindAdapter: RAS adapter unbound! telling AFP, RAS\n"));
        }

        // this will take care of informing ARAP and PPP engine above
        AtalkPnPInformRas(FALSE);
    }


	*Status = AtalkDeinitAdapter(pPortDesc);

	ASSERT(*Status != NDIS_STATUS_PENDING);
	AtalkUnlockInitIfNecessary();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkmem.c ===
/*

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkmem.c

Abstract:

	This module contains the routines which allocates and free memory. Only
	the non-paged pool is used.

	!!! For profiling, we use spinlock acquire/release for CurAllocCount/CurAllocSize

Author:

	Nikhil Kamkolkar	(NikhilK@microsoft.com)
	Jameel Hyder (JameelH@microsoft.com)

Revision History:
	25 Apr 1992	 Initial Version (JameelH)

--*/

#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKMEM

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, AtalkInitMemorySystem)
#pragma alloc_text(PAGE, AtalkDeInitMemorySystem)
#endif


VOID
AtalkInitMemorySystem(
	VOID
)
{
	LONG	i;

	for (i = 0; i < NUM_BLKIDS; i++)
		INITIALIZE_SPIN_LOCK(&atalkBPLock[i]);

	AtalkTimerInitialize(&atalkBPTimer,
						 atalkBPAgePool,
						 BLOCK_POOL_TIMER);
	AtalkTimerScheduleEvent(&atalkBPTimer);
}


VOID
AtalkDeInitMemorySystem(
	VOID
)
{
	LONG		i, j, NumBlksPerChunk;
	PBLK_CHUNK	pChunk, pFree;
	
	for (i = 0; i < NUM_BLKIDS; i++)
	{
		NumBlksPerChunk = atalkNumBlks[i];
		for (pChunk = atalkBPHead[i];
			 pChunk != NULL;
			 NOTHING)
		{
			DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_INFO,
					("AtalkDeInitMemorySystem: Freeing %lx\n", pChunk));
			if ((pChunk->bc_NumFree != NumBlksPerChunk) ||
				(pChunk->bc_NumAlloc != 0))
			{
				DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_ERR,
						("AtalkDeInitMemorySystem: Unfreed blocks from blockid %d, Chunk %lx\n",
						i, pChunk));
				ASSERT(0);
			}

			if (pChunk->bc_BlkId >= BLKID_NEED_NDIS_INT)
			{
				PBLK_HDR	pBlkHdr;

				// We need to free the Ndis stuff for these guys
				for (j = 0, pBlkHdr = pChunk->bc_FreeHead;
					 j < NumBlksPerChunk;
					 j++, pBlkHdr = pBlkHdr->bh_Next)
				{
					PBUFFER_HDR	pBufHdr;

					pBufHdr = (PBUFFER_HDR)((PBYTE)pBlkHdr + sizeof(BLK_HDR));
					ASSERT(pBufHdr->bh_NdisPkt == NULL);
					AtalkNdisFreeBuffer(pBufHdr->bh_NdisBuffer);
				}
			}
			pFree = pChunk;
			pChunk = pChunk->bc_Next;
			AtalkFreeMemory(pFree);
		}
		atalkBPHead[i] = NULL;
	}
}


PVOID FASTCALL
AtalkAllocMem(
#ifdef	TRACK_MEMORY_USAGE
	IN	ULONG	Size,
	IN	ULONG	FileLine
#else
	IN	ULONG	Size
#endif	// TRACK_MEMORY_USAGE
)
/*++

Routine Description:

	Allocate a block of non-paged memory. This is just a wrapper over ExAllocPool.
 	Allocation failures are error-logged. We always allocate a ULONG more than
 	the specified size to accomodate the size. This is used by AtalkFreeMemory
 	to update the statistics.

Arguments:


Return Value:


--*/
{
	PBYTE	pBuf;
	BOOLEAN	zeroed;
#ifdef	PROFILING
	TIME	TimeS, TimeE, TimeD;
#endif

	//	round up the size so that we can put a signature at the end
	//	that is on a ULONG boundary
	zeroed = ((Size & ZEROED_MEMORY_TAG) == ZEROED_MEMORY_TAG);

	Size = DWORDSIZEBLOCK(Size & ~ZEROED_MEMORY_TAG) +
#if	DBG
			sizeof(DWORD) +				// For the signature
#endif
			sizeof(ULONG_PTR);

#ifdef	PROFILING
	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	// Do the actual memory allocation. Allocate four extra bytes so
	// that we can store the size of the allocation for the free routine.
	if ((pBuf = ExAllocatePoolWithTag(NonPagedPool, Size, ATALK_TAG)) == NULL)
	{
		LOG_ERROR(EVENT_ATALK_MEMORYRESOURCES, STATUS_INSUFFICIENT_RESOURCES, NULL, 0);
		DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_FATAL,
				("AtalkAllocMemory: failed - size %lx\n", Size));
		return NULL;
	}

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AtalkStatistics.stat_CurAllocCount,
							   &AtalkStatsLock.SpinLock);
	INTERLOCKED_INCREMENT_LONG(&AtalkStatistics.stat_ExAllocPoolCount,
							   &AtalkStatsLock.SpinLock);
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AtalkStatistics.stat_ExAllocPoolTime,
								 TimeD,
								 &AtalkStatsLock.SpinLock);
#endif

	INTERLOCKED_ADD_ULONG(&AtalkStatistics.stat_CurAllocSize,
						  Size,
						  &AtalkStatsLock.SpinLock);

	ASSERTMSG("AtalkAllocMemory: Allocation has exceeded Limit !!!\n",
				AtalkStatistics.stat_CurAllocSize < (ULONG)AtalkMemLimit);

	// Save the size of this block in the four extra bytes we allocated.
	*((PULONG)pBuf) = Size;

#if DBG
	*((PULONG)(pBuf+Size-sizeof(ULONG))) = ATALK_MEMORY_SIGNATURE;
	DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_INFO,
			("AtalkAllocMemory: Allocated %lx bytes @%lx\n", Size, pBuf));
#endif

	AtalkTrackMemoryUsage((PVOID)pBuf, Size, TRUE, FileLine);

#if	DBG
	Size -= sizeof(ULONG);
#endif

	pBuf += sizeof(ULONG_PTR);

	if (zeroed)
	{
		RtlZeroMemory(pBuf, Size - sizeof(ULONG_PTR));
	}

	// Return a pointer to the memory after the size longword.
	return (pBuf);
}




VOID FASTCALL
AtalkFreeMemory(
	IN	PVOID	pBuf
	)
/*++

Routine Description:

 	Free the block of memory allocated via AtalkAllocMemory. This is
 	a wrapper around ExFreePool.

Arguments:


Return Value:


--*/
{
	PULONG 	pRealBuffer;
	ULONG	Size;
#ifdef	PROFILING
	TIME	TimeS, TimeE, TimeD;
#endif

	// Get a pointer to the block allocated by ExAllocatePool.
	pRealBuffer = (PULONG)((PCHAR)pBuf - sizeof(ULONG_PTR));
	Size = *pRealBuffer;

	AtalkTrackMemoryUsage(pRealBuffer, Size, FALSE, 0);

#if	DBG
	*pRealBuffer = 0;
	// Check the signature at the end
	if (*(PULONG)((PCHAR)pRealBuffer + Size - sizeof(ULONG))
											!= ATALK_MEMORY_SIGNATURE)
	{
		DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_FATAL,
				("AtalkFreeMemory: Memory overrun on block %lx\n", pRealBuffer));
		ASSERT(0);
	}
	*(PULONG)((PCHAR)pRealBuffer + Size - sizeof(ULONG)) = 0;
#endif

	INTERLOCKED_ADD_ULONG(&AtalkStatistics.stat_CurAllocSize,
						  -(LONG)Size,
						  &AtalkStatsLock.SpinLock);
#ifdef	PROFILING
	INTERLOCKED_DECREMENT_LONG(&AtalkStatistics.stat_CurAllocCount,
							   &AtalkStatsLock);
	INTERLOCKED_INCREMENT_LONG(&AtalkStatistics.stat_ExFreePoolCount,
							   &AtalkStatsLock);
	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	// Free the pool and return.
	ExFreePool(pRealBuffer);

#ifdef	PROFILING
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AtalkStatistics.stat_ExFreePoolTime,
								 TimeD,
								 &AtalkStatsLock.SpinLock);
#endif
}




PBUFFER_DESC
AtalkDescribeBufferDesc(
	IN	PVOID	DataPtr,
	IN	PVOID	FreePtr,
	IN	USHORT	Length,
#ifdef	TRACK_BUFFDESC_USAGE
	IN	USHORT	Flags,
	IN	ULONG	FileLine
#else
	IN	USHORT	Flags
#endif
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_DESC	pBuffDesc;

	if ((pBuffDesc = AtalkAllocBufferDesc(DataPtr,
										  Length,
#ifdef	TRACK_BUFFDESC_USAGE
										  Flags,
										  FileLine
#else
										  Flags
#endif
		)) != NULL)
	{
		pBuffDesc->bd_FreeBuffer = FreePtr;
	}

	return pBuffDesc;
}




PBUFFER_DESC
AtalkAllocBufferDesc(
	IN	PVOID	Ptr	OPTIONAL,
	IN	USHORT	Length,
#ifdef	TRACK_BUFFDESC_USAGE
	IN	USHORT	Flags,
	IN	ULONG	FileLine
#else
	IN	USHORT	Flags
#endif
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PBUFFER_DESC	pBuffDesc = NULL;

	DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_INFO,
			("AtalkAllocBuffDesc: Ptr %lx, Length %x, Flags %x\n",
			Ptr, Length, Flags));


	pBuffDesc = AtalkBPAllocBlock(BLKID_BUFFDESC);

	if (pBuffDesc != NULL)
	{
#if	DBG
		pBuffDesc->bd_Signature = BD_SIGNATURE;
#endif
		pBuffDesc->bd_Length = Length;
		pBuffDesc->bd_Flags = Flags;
		pBuffDesc->bd_Next = NULL;

		//	Depending on whether a char buffer or a PAMDL is being
		//	passed in...
		if (Flags & BD_CHAR_BUFFER)
		{
			if ((Ptr == NULL) &&
				((Ptr = AtalkAllocMemory(Length)) == NULL))
			{
				pBuffDesc->bd_Flags = 0;
				pBuffDesc->bd_CharBuffer = NULL;
				AtalkFreeBuffDesc(pBuffDesc);
				pBuffDesc = NULL;
			}
			else
			{
				pBuffDesc->bd_CharBuffer = pBuffDesc->bd_FreeBuffer = Ptr;
				AtalkTrackBuffDescUsage(pBuffDesc, TRUE, FileLine);
			}
		}
		else
		{
			pBuffDesc->bd_OpaqueBuffer = (PAMDL)Ptr;
		}
	}

	return pBuffDesc;
}




VOID FASTCALL
AtalkFreeBuffDesc(
	IN	PBUFFER_DESC	pBuffDesc
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	ASSERT(VALID_BUFFDESC(pBuffDesc));

	if ((pBuffDesc->bd_Flags & (BD_FREE_BUFFER | BD_CHAR_BUFFER)) ==
									(BD_FREE_BUFFER | BD_CHAR_BUFFER))
		AtalkFreeMemory(pBuffDesc->bd_FreeBuffer);
	AtalkTrackBuffDescUsage(pBuffDesc, FALSE, 0);

	AtalkBPFreeBlock(pBuffDesc);
}




VOID
AtalkCopyBuffDescToBuffer(
	IN	PBUFFER_DESC	pBuffDesc,
	IN	LONG			SrcOff,
	IN	LONG			BytesToCopy,
	IN	PBYTE			DstBuf
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS	Status;
	ULONG		BytesCopied;
	LONG		Index = 0;

	ASSERT(VALID_BUFFDESC(pBuffDesc));

	while ((pBuffDesc != NULL) &&
		   (SrcOff > (LONG)pBuffDesc->bd_Length))
	{
		SrcOff -= pBuffDesc->bd_Length;
		pBuffDesc = pBuffDesc->bd_Next;
	}

	do
	{
		LONG	ThisCopy;

		if (pBuffDesc == NULL)
			break;

		ThisCopy = BytesToCopy;
		if (ThisCopy > ((LONG)pBuffDesc->bd_Length - SrcOff))
			ThisCopy = ((LONG)pBuffDesc->bd_Length - SrcOff);
		BytesToCopy -= ThisCopy;

		if (pBuffDesc->bd_Flags & BD_CHAR_BUFFER)
		{
			RtlCopyMemory(DstBuf + Index,
						  pBuffDesc->bd_CharBuffer + SrcOff,
						  ThisCopy);
		}
		else
		{
			Status = TdiCopyMdlToBuffer(pBuffDesc->bd_OpaqueBuffer,
										SrcOff,
										DstBuf + Index,
										0,
										ThisCopy,
										&BytesCopied);
			ASSERT(NT_SUCCESS(Status) && (BytesCopied == (ULONG)ThisCopy));
		}
		Index += ThisCopy;
		SrcOff -= (pBuffDesc->bd_Length - ThisCopy);
		pBuffDesc = pBuffDesc->bd_Next;
	} while (BytesToCopy > 0);
}




VOID
AtalkCopyBufferToBuffDesc(
	IN	PBYTE			SrcBuf,
	IN	LONG			BytesToCopy,
	IN	PBUFFER_DESC	pBuffDesc,
	IN	LONG			DstOff
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	NTSTATUS	Status;
	LONG		Index = 0;

	ASSERT(VALID_BUFFDESC(pBuffDesc));

	while ((DstOff > (LONG)pBuffDesc->bd_Length) &&
		   (pBuffDesc != NULL))
	{
		DstOff -= pBuffDesc->bd_Length;
		pBuffDesc = pBuffDesc->bd_Next;
	}

	do
	{
		LONG	ThisCopy;

		if (pBuffDesc == NULL)
			break;

		ThisCopy = BytesToCopy;
		if (ThisCopy > ((LONG)pBuffDesc->bd_Length - DstOff))
			ThisCopy = ((LONG)pBuffDesc->bd_Length - DstOff);
		BytesToCopy -= ThisCopy;

		if (pBuffDesc->bd_Flags & BD_CHAR_BUFFER)
		{
			RtlCopyMemory(pBuffDesc->bd_CharBuffer + DstOff,
						  SrcBuf + Index,
						  ThisCopy);
		}
		else
		{
			Status = TdiCopyBufferToMdl(SrcBuf,
										Index,
										ThisCopy,
										pBuffDesc->bd_OpaqueBuffer,
										DstOff,
										(PULONG)&ThisCopy);
			ASSERT(NT_SUCCESS(Status) && (ThisCopy == BytesToCopy));
		}
		Index += ThisCopy;
		DstOff -= (pBuffDesc->bd_Length - ThisCopy);
		pBuffDesc = pBuffDesc->bd_Next;
	} while (BytesToCopy > 0);
}




LONG FASTCALL
AtalkSizeBuffDesc(
	IN	PBUFFER_DESC	pBuffDesc
	)
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
	LONG	Size;

	ASSERT(VALID_BUFFDESC(pBuffDesc));

	for (Size = 0; pBuffDesc != NULL; pBuffDesc = pBuffDesc->bd_Next)
		Size += (LONG)pBuffDesc->bd_Length;
	return(Size);
}


PAMDL
AtalkSubsetAmdl(
	IN	PAMDL	pStartingMdl,
	IN	ULONG	TotalOffset,
	IN	ULONG	DesiredLength
	)
/*++

Routine Description:

	This routine is called to build an Mdl chain from a source Mdl chain and
	offset into it. We assume we don't know the length of the source Mdl chain,
	and we must allocate and build the Mdls for the destination chain, which
	we do from non-paged pool. Note that this routine, unlike the IO subsystem
	routines, sets the SystemVaMapped bit in the generated Mdls to the same
	value as that in the source Mdls.
	
	IT WOULD BE BAD TO USE MmMapLockedPages OR MmProbeAndLockPages ON THE
	DESTINATION MDLS UNLESS YOU TAKE RESPONSIBILITY FOR UNMAPPING THEM!
	
	The MDLs that are returned are mapped and locked. (Actually, the pages in
	them are in the same state as those in the source MDLs.)
	
	If the system runs out of memory while we are building the destination
	MDL chain, we completely clean up the built chain and return with
	NewCurrentMdl and NewByteOffset set to the current values of CurrentMdl
	and TotalOffset. TRUELength is set to 0.

Environment:

	Kernel Mode, Source Mdls locked. It is recommended, although not required,
	that the source Mdls be mapped and locked prior to calling this routine.

Arguments:

	pStartingMdl			- the source appletalk mdl ( == nt mdl)
	TotalOffset 		- Offset within this MDL to start the packet at.
	DesiredLength 	- The number of bytes to insert into the packet.

Return Value:

	pointer to build mdl, NULL if out of resources, or lengths inconsistent.

--*/
{
	PMDL 	Destination=NULL;

	PBYTE 	BaseVa;
	ULONG 	NewMdlLength;
	PMDL 	NewMdl;
    PMDL    pMdl;

	PMDL 	CurrentMdl = (PMDL)pStartingMdl;
    ULONG   CurrentOffset = TotalOffset;
    ULONG   BytesToDescribe = DesiredLength;


    //
    // first make sure that we have enough bytes!
    //
    if (DesiredLength > (ULONG)AtalkSizeMdlChain(pStartingMdl))
    {
	    DBGPRINT(DBG_COMP_UTILS, DBG_LEVEL_ERR,
		    ("AtalkSubsetMdl: req len (%ld) exceeds avl len (%ld) for mdl %lx\n",
		    DesiredLength, AtalkSizeMdlChain(pStartingMdl),pStartingMdl));

        ASSERT(0);
	    return(NULL);
    }

    //
    // first, get to the right Mdl (in most cases, the same as pStartingMdl)
    //
    while (CurrentMdl && (CurrentOffset >= MmGetMdlByteCount (CurrentMdl)))
    {
        CurrentOffset -= MmGetMdlByteCount (CurrentMdl);
        CurrentMdl = CurrentMdl->Next;
        ASSERT(CurrentMdl != NULL);
    }

    while (BytesToDescribe)
    {
        ASSERT(CurrentMdl != NULL);

	    BaseVa = (PBYTE)MmGetMdlVirtualAddress(CurrentMdl) + CurrentOffset;
	    NewMdlLength 	= MmGetMdlByteCount (CurrentMdl) - CurrentOffset;

        // if Mdl has more bytes than what's needed, set available to what's needed
        if (NewMdlLength > BytesToDescribe)
        {
            NewMdlLength = BytesToDescribe;
        }

	    pMdl = IoAllocateMdl(BaseVa,
		    			     NewMdlLength,
			    			 FALSE,
				    		 FALSE,
					    	 NULL);

        // store the first mdl for return
        if (!Destination)
        {
	        Destination = pMdl;

            // subsequent Mdl's must start with offset 0!!
            CurrentOffset = 0;
        }
        else
        {
            // link-in to the earlier mdl
            NewMdl->Next = pMdl;
        }

        NewMdl = pMdl;

        if (pMdl != NULL)
        {
            ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

#ifdef	PROFILING
		    INTERLOCKED_INCREMENT_LONG(
			    &AtalkStatistics.stat_CurMdlCount,
			    &AtalkStatsLock.SpinLock);
#endif
		    IoBuildPartialMdl(CurrentMdl,
			    			  pMdl,
				    		  BaseVa,
					    	  NewMdlLength);
        }
        else
        {
            // free up whatever was allocated so far
            while (Destination)
            {
                pMdl = Destination->Next;
                IoFreeMdl(Destination);
                ATALK_DBG_DEC_COUNT(AtalkDbgMdlsAlloced);
                Destination = pMdl;
            }
        }

        BytesToDescribe -= NewMdlLength;
        CurrentMdl = CurrentMdl->Next;
    }

    return(Destination);

}




PAMDL
AtalkAllocAMdl(
	IN	PBYTE	pBuffer	OPTIONAL,
	IN	LONG	Size
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	PMDL	pMdl = NULL;

	if (pBuffer == NULL)
	{
		pBuffer = AtalkAllocMemory(Size);
	}

	if ((pBuffer == NULL) ||
		((pMdl = IoAllocateMdl(pBuffer, Size, FALSE, FALSE, NULL)) == NULL))
	{
		LOG_ERROR(EVENT_ATALK_RESOURCES, STATUS_INSUFFICIENT_RESOURCES, NULL, 0);
	}
#ifdef	PROFILING
	else
	{
		INTERLOCKED_INCREMENT_LONG(
			&AtalkStatistics.stat_CurMdlCount,
			&AtalkStatsLock.SpinLock);
	}
#endif

	if (pMdl != NULL)
    {
        ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

		MmBuildMdlForNonPagedPool(pMdl);
    }

	return(pMdl);
}




LONG FASTCALL
AtalkSizeMdlChain(
	IN	PAMDL	pAMdlChain
	)
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
	LONG	Size;

	for (Size = 0; pAMdlChain != NULL; pAMdlChain = pAMdlChain->Next)
	{
		Size += MmGetMdlByteCount(pAMdlChain);
	}
	return(Size);
}



/***	AtalkBPAllocBlock
 *
 *	Alloc a block of memory from the block pool package. This is written to speed up
 *	operations where a lot of small fixed size allocations/frees happen. Going to
 *	ExAllocPool() in these cases is expensive.
 *
 *	It is important to keep the list of blocks in such a way that all completely free
 *	blocks are at the tail end of the list.
 */
PVOID FASTCALL
AtalkBPAllocBlock(
	IN	BLKID	BlockId
)
{
	PBLK_HDR			pBlk = NULL;
	PBLK_CHUNK			pChunk, *ppChunkHead;
	KIRQL				OldIrql;
	USHORT				BlkSize;
	ATALK_SPIN_LOCK *	pLock;
	NDIS_STATUS			ndisStatus;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	ASSERT (BlockId < NUM_BLKIDS);

	BlkSize = atalkBlkSize[BlockId];
	ppChunkHead = &atalkBPHead[BlockId];

	pLock = &atalkBPLock[BlockId];
	ACQUIRE_SPIN_LOCK(pLock, &OldIrql);

	if ((pChunk = *ppChunkHead) != NULL)
	{
		ASSERT(VALID_BC(pChunk));
		ASSERT(pChunk->bc_BlkId == BlockId);
		ASSERT((pChunk->bc_NumFree + pChunk->bc_NumAlloc) == atalkNumBlks[BlockId]);

		if (pChunk->bc_NumFree > 0)
		{
			// This is where we take it off from
			DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
					("AtalkBPAllocBlock: Found space in Chunk %lx\n", pChunk));
#ifdef	PROFILING
			INTERLOCKED_INCREMENT_LONG( &AtalkStatistics.stat_NumBPHits,
										&AtalkStatsLock.SpinLock);
#endif
		}

		if (pChunk->bc_NumFree == 0)
		{
			// We do not have space on any of the chunks on this list
			ASSERT(pChunk->bc_NumAlloc == atalkNumBlks[BlockId]);
			pChunk = NULL;
		}
	}
	
	if (pChunk == NULL)
	{
		DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
				("AtalkBPAllocBlock: Allocating a new chunk for Id %d\n", BlockId));

#ifdef	PROFILING
		INTERLOCKED_INCREMENT_LONG( &AtalkStatistics.stat_NumBPMisses,
									&AtalkStatsLock.SpinLock);
#endif
		pChunk = AtalkAllocMemory(atalkChunkSize[BlockId]);
		if (pChunk != NULL)
		{
			LONG		i, j;
			PBLK_HDR	pBlkHdr;
			PBUFFER_HDR	pBufHdr;
			USHORT		NumBlksPerChunk;

#if	DBG
			pChunk->bc_Signature = BC_SIGNATURE;
			pChunk->bc_NumAlloc = 0;
#endif
			NumBlksPerChunk = atalkNumBlks[BlockId];
			ASSERT (NumBlksPerChunk <= 0xFF);
			pChunk->bc_NumFree = (BYTE)NumBlksPerChunk;
			pChunk->bc_BlkId = BlockId;
			pChunk->bc_FreeHead = (PBLK_HDR)((PBYTE)pChunk + sizeof(BLK_CHUNK));

			DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
			    ("AtalkBPAllocBlock: Initializing chunk %lx, BlkId=%d\n", pChunk,BlockId));

			// Initialize the blocks in the chunk
			for (i = 0, pBlkHdr = pChunk->bc_FreeHead;
				 i < NumBlksPerChunk;
				 i++, pBlkHdr = pBlkHdr->bh_Next)
			{
				LONG		Size;
#if	DBG
				pBlkHdr->bh_Signature = BH_SIGNATURE;
#endif
				pBlkHdr->bh_Next = (i == (NumBlksPerChunk-1)) ?
										NULL :
										(PBLK_HDR)((PBYTE)pBlkHdr + BlkSize);

				if (BlockId >= BLKID_NEED_NDIS_INT)
				{
                    PCHAR   pStartOfBuf;

					// We need to initialize the Ndis stuff for these guys
					pBufHdr = (PBUFFER_HDR)((PBYTE)pBlkHdr + sizeof(BLK_HDR));

					pBufHdr->bh_NdisPkt = NULL;

                    if (BlockId == BLKID_SENDBUF)
                    {
                        Size = sizeof(BUFFER_HDR) + sizeof(BUFFER_DESC);
                        pStartOfBuf = (PCHAR)pBufHdr + Size;
                    }
                    else if ((BlockId == BLKID_MNP_SMSENDBUF) ||
                             (BlockId == BLKID_MNP_LGSENDBUF) )
                    {
                        // NOTE: the 1 byte of Buffer[1], combined with aligning
                        // effect screws up Size (it's 3 more than what we think!)
                        Size = sizeof(MNPSENDBUF);
                        pStartOfBuf = &(((PMNPSENDBUF)pBufHdr)->Buffer[0]);
                    }
                    else
                    {
                        Size = sizeof(BUFFER_HDR);
                        pStartOfBuf = (PCHAR)pBufHdr + Size;
                    }

					//  Make a NDIS buffer descriptor for this data
					NdisAllocateBuffer(&ndisStatus,
									   &pBufHdr->bh_NdisBuffer,
									   AtalkNdisBufferPoolHandle,
									   pStartOfBuf,
									   (UINT)(BlkSize - sizeof(BLK_HDR) - Size));
				
					if (ndisStatus != NDIS_STATUS_SUCCESS)
					{
						LOG_ERROR(EVENT_ATALK_NDISRESOURCES, ndisStatus, NULL, 0);

		                DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
				            ("NdisAllocateBuffer: Ndis Out-of-Resource condition hit\n"));

                        ASSERT(0);
						break;
					}
				
                    ATALK_DBG_INC_COUNT(AtalkDbgMdlsAlloced);

					// More processing for send buffers
					if ((BlockId == BLKID_SENDBUF) ||
                        (BlockId == BLKID_MNP_SMSENDBUF) ||
                        (BlockId == BLKID_MNP_LGSENDBUF))
					{
						PSENDBUF		pSendBuf;
						PBUFFER_DESC	pBuffDesc;
	                    PMNPSENDBUF	    pMnpSendBuf;

					    if (BlockId == BLKID_SENDBUF)
                        {
						    pSendBuf = (PSENDBUF)pBufHdr;
						    pBuffDesc = &pSendBuf->sb_BuffDesc;
						    pBuffDesc->bd_Length 	= MAX_SENDBUF_LEN;
						    pBuffDesc->bd_CharBuffer= pSendBuf->sb_Space;
                        }
                        else if (BlockId == BLKID_MNP_SMSENDBUF)
                        {
						    pMnpSendBuf = (PMNPSENDBUF)pBufHdr;
                            pMnpSendBuf->DataSize = 0;
                            pMnpSendBuf->FreeBuffer = &pMnpSendBuf->Buffer[0];
						    pBuffDesc = &pMnpSendBuf->sb_BuffDesc;
						    pBuffDesc->bd_Length 	= MNP_MINSEND_LEN;
						    pBuffDesc->bd_CharBuffer= &pMnpSendBuf->Buffer[0];
                        }
                        else // if (BlockId == BLKID_MNP_LGSENDBUF)
                        {
						    pMnpSendBuf = (PMNPSENDBUF)pBufHdr;
                            pMnpSendBuf->DataSize = 0;
                            pMnpSendBuf->FreeBuffer = &pMnpSendBuf->Buffer[0];
						    pBuffDesc = &pMnpSendBuf->sb_BuffDesc;
						    pBuffDesc->bd_Length 	= MNP_MAXSEND_LEN;
						    pBuffDesc->bd_CharBuffer= &pMnpSendBuf->Buffer[0];
                        }
#if	DBG
						pBuffDesc->bd_Signature = BD_SIGNATURE;
#endif
						pBuffDesc->bd_Flags 	= BD_CHAR_BUFFER;
						pBuffDesc->bd_Next 		= NULL;
						pBuffDesc->bd_FreeBuffer= NULL;
					}
				}

			}
			if (i != NumBlksPerChunk)
			{
				// This has to be a failure from Ndis !!!
				// Undo a bunch of stuff
				ASSERT (BlockId >= BLKID_NEED_NDIS_INT);
				DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
						("AtalkBPAllocBlock: Freeing new chunk (Ndis failure) Id %d\n",
						BlockId));
				pBlkHdr = pChunk->bc_FreeHead;
				for (j = 0, pBlkHdr = pChunk->bc_FreeHead;
					 j < i; j++, pBlkHdr = pBlkHdr->bh_Next)
				{
					PBUFFER_HDR	pBufHdr;

					pBufHdr = (PBUFFER_HDR)((PBYTE)pBlkHdr + sizeof(BLK_HDR));
					AtalkNdisFreeBuffer(pBufHdr->bh_NdisBuffer);
				}
				AtalkFreeMemory(pChunk);
				pChunk = NULL;
			}
			else
			{
				// Successfully initialized the chunk, link it in
				AtalkLinkDoubleAtHead(*ppChunkHead, pChunk, bc_Next, bc_Prev);
#if	DBG
				atalkNumChunksForId[BlockId] ++;
#endif
			}
		}
	}	
	if (pChunk != NULL)
	{
		PBLK_CHUNK	pTmp;

		ASSERT(VALID_BC(pChunk));
		ASSERT(pChunk->bc_BlkId == BlockId);
		DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_INFO,
				("AtalkBPAllocBlock: Allocating a block out of chunk %lx(%d,%d) for Id %d\n",
				pChunk, pChunk->bc_NumFree, pChunk->bc_NumAlloc, BlockId));

		pBlk = pChunk->bc_FreeHead;
		ASSERT(VALID_BH(pBlk));

		pChunk->bc_FreeHead = pBlk->bh_Next;
		pBlk->bh_pChunk = pChunk;
		pChunk->bc_Age = 0;			// Reset age
		pChunk->bc_NumFree --;
#if	DBG
		pChunk->bc_NumAlloc ++;
#endif
		// If the block is now empty, unlink it from here and move it
		// to the first empty slot. We know that all blocks 'earlier' than
		// this are non-empty.
		if ((pChunk->bc_NumFree == 0) &&
			((pTmp = pChunk->bc_Next) != NULL) &&
			(pTmp->bc_NumFree > 0))
		{
			ASSERT(pChunk->bc_NumAlloc == atalkNumBlks[BlockId]);
			AtalkUnlinkDouble(pChunk, bc_Next, bc_Prev);
			for (; pTmp != NULL; pTmp = pTmp->bc_Next)
			{
				ASSERT(VALID_BC(pTmp));
				if (pTmp->bc_NumFree == 0)
				{
					ASSERT(pTmp->bc_NumAlloc == atalkNumBlks[BlockId]);
					// Found a free one. Park it right here.
					AtalkInsertDoubleBefore(pChunk, pTmp, bc_Next, bc_Prev);
					break;
				}
				else if (pTmp->bc_Next == NULL)	// We reached the end
				{
					AtalkLinkDoubleAtEnd(pChunk, pTmp, bc_Next, bc_Prev);
					break;
				}
			}
		}
	}

	if (pBlk != NULL)
	{
        //
        // we allocate Ndis Packets for ARAP guys later, when we really need
        //
		if ((BlockId >= BLKID_NEED_NDIS_INT) &&
            (BlockId != BLKID_MNP_SMSENDBUF) &&
            (BlockId != BLKID_MNP_LGSENDBUF))
		{
			PBUFFER_HDR	pBufHdr;

			// We need to initialize the Ndis stuff for these guys
			pBufHdr = (PBUFFER_HDR)((PBYTE)pBlk + sizeof(BLK_HDR));

			pBufHdr->bh_NdisPkt = NULL;

			//  Allocate an NDIS packet descriptor from the global packet pool
			NdisDprAllocatePacket(&ndisStatus,
								  &pBufHdr->bh_NdisPkt,
								  AtalkNdisPacketPoolHandle);
			
			if (ndisStatus != NDIS_STATUS_SUCCESS)
			{
				LOG_ERROR(EVENT_ATALK_NDISRESOURCES, ndisStatus, NULL, 0);

		        DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_ERR,
				    ("NdisDprAllocatePacket: Ndis Out-of-Resource condition hit\n"));

                ASSERT(0);

                RELEASE_SPIN_LOCK(pLock, OldIrql);
				AtalkBPFreeBlock(pBufHdr);
				return(NULL);
			}

			//  Link the buffer descriptor into the packet descriptor
			RtlZeroMemory(pBufHdr->bh_NdisPkt->ProtocolReserved, sizeof(PROTOCOL_RESD));
			NdisChainBufferAtBack(pBufHdr->bh_NdisPkt,
								  pBufHdr->bh_NdisBuffer);
			((PPROTOCOL_RESD)(pBufHdr->bh_NdisPkt->ProtocolReserved))->Receive.pr_BufHdr = pBufHdr;
		}
		++pBlk;
#if	DBG
		atalkBlksForId[BlockId] ++;
#endif
	}

	RELEASE_SPIN_LOCK(pLock, OldIrql);

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AtalkStatistics.stat_BPAllocCount,
							   &AtalkStatsLock.SpinLock);
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR(&AtalkStatistics.stat_BPAllocTime,
								 TimeD,
								 &AtalkStatsLock.SpinLock);
#endif
	return pBlk;
}


/***	atalkBPFreeBlock
 *
 *	Return a block to its owning chunk.
 */
VOID FASTCALL
AtalkBPFreeBlock(
	IN	PVOID		pBlock
)
{
	PBLK_CHUNK			pChunk;
	PBLK_HDR			pBlkHdr;
	BLKID				BlockId;
	KIRQL				OldIrql;
	ATALK_SPIN_LOCK *	pLock;
#ifdef	PROFILING
	TIME				TimeS, TimeE, TimeD;

	TimeS = KeQueryPerformanceCounter(NULL);
#endif

	pBlkHdr = (PBLK_HDR)((PCHAR)pBlock - sizeof(BLK_HDR));
	ASSERT(VALID_BH(pBlkHdr));

	pChunk = pBlkHdr->bh_pChunk;
	ASSERT(VALID_BC(pChunk));

	BlockId = pChunk->bc_BlkId;
	pLock = &atalkBPLock[BlockId];

	ACQUIRE_SPIN_LOCK(pLock, &OldIrql);

	if (BlockId >= BLKID_NEED_NDIS_INT)
	{
		PBUFFER_HDR	pBufHdr;

		// We need to free the ndis packet here - if present
		pBufHdr = (PBUFFER_HDR)pBlock;

		if (pBufHdr->bh_NdisPkt != NULL)
		{
		    NdisDprFreePacket(pBufHdr->bh_NdisPkt);
		    pBufHdr->bh_NdisPkt = NULL;
		}
	}

	DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_INFO,
			("AtalkBPFreeBlock: Returning Block %lx to chunk %lx for Id %d\n",
			pBlkHdr, pChunk, BlockId));

	ASSERT (pChunk->bc_NumFree < atalkNumBlks[BlockId]);
#if	DBG
	atalkBlksForId[BlockId] --;
	pChunk->bc_NumAlloc --;
#endif

	pChunk->bc_NumFree ++;
	ASSERT((pChunk->bc_NumFree + pChunk->bc_NumAlloc) == atalkNumBlks[BlockId]);
	pBlkHdr->bh_Next = pChunk->bc_FreeHead;
	pChunk->bc_FreeHead = pBlkHdr;

	// If this block's status is changing from a 'none available' to 'available'
	// move him to the head of the list
	if (pChunk->bc_NumFree == 1)
	{
		AtalkUnlinkDouble(pChunk, bc_Next, bc_Prev);
		AtalkLinkDoubleAtHead(atalkBPHead[BlockId],
							pChunk,
							bc_Next,
							bc_Prev);
	}

#ifdef	PROFILING
	INTERLOCKED_INCREMENT_LONG(&AtalkStatistics.stat_BPFreeCount,
							   &AtalkStatsLock.SpinLock);
	TimeE = KeQueryPerformanceCounter(NULL);
	TimeD.QuadPart = TimeE.QuadPart - TimeS.QuadPart;
	INTERLOCKED_ADD_LARGE_INTGR_DPC(&AtalkStatistics.stat_BPFreeTime,
									TimeD,
									&AtalkStatsLock.SpinLock);
#endif

	RELEASE_SPIN_LOCK(pLock, OldIrql);
}



/***	atalkBPAgePool
 *
 *	Age out the block pool of unused blocks
 */
LOCAL LONG FASTCALL
atalkBPAgePool(
	IN PTIMERLIST 	Context,
	IN BOOLEAN		TimerShuttingDown
)
{
	PBLK_CHUNK	pChunk;
	LONG		i, j, NumBlksPerChunk;

	if (TimerShuttingDown)
	{
		return ATALK_TIMER_NO_REQUEUE;
	}

	for (i = 0; i < NUM_BLKIDS; i++)
	{
		NumBlksPerChunk = atalkNumBlks[i];
		ACQUIRE_SPIN_LOCK_DPC(&atalkBPLock[i]);
	
		for (pChunk = atalkBPHead[i];
			 pChunk != NULL; )
		{
			PBLK_CHUNK	pFree;

			ASSERT(VALID_BC(pChunk));

			pFree = pChunk;
			pChunk = pChunk->bc_Next;

			// Since all blocks which are completely used up are at the tail end of
			// the list, if we encounter one, we are done.
			if (pFree->bc_NumFree == 0)
				break;

			if (pFree->bc_NumFree == NumBlksPerChunk)
			{
				DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_WARN,
						("atalkBPAgePool: Aging Chunk %lx, Id %d NumFree %d\n",
						pFree, pFree->bc_BlkId,pFree->bc_NumFree));
	
				if (++(pFree->bc_Age) >= MAX_BLOCK_POOL_AGE)
				{
					DBGPRINT(DBG_COMP_SYSTEM, DBG_LEVEL_WARN,
							("atalkBPAgePool: freeing Chunk %lx, Id %d\n",
							pFree, pFree->bc_BlkId));
					AtalkUnlinkDouble(pFree, bc_Next, bc_Prev);
#ifdef	PROFILING
					INTERLOCKED_INCREMENT_LONG( &AtalkStatistics.stat_NumBPAge,
											&AtalkStatsLock.SpinLock);
#endif
					if (pFree->bc_BlkId >= BLKID_NEED_NDIS_INT)
					{
						PBLK_HDR	pBlkHdr;
	
						// We need to free Ndis stuff for these guys
						pBlkHdr = pFree->bc_FreeHead;
						for (j = 0, pBlkHdr = pFree->bc_FreeHead;
							 j < NumBlksPerChunk;
							 j++, pBlkHdr = pBlkHdr->bh_Next)
						{
							PBUFFER_HDR	pBufHdr;
	
							pBufHdr = (PBUFFER_HDR)((PBYTE)pBlkHdr + sizeof(BLK_HDR));
	
							ASSERT(pBufHdr->bh_NdisPkt == NULL);
							AtalkNdisFreeBuffer(pBufHdr->bh_NdisBuffer);
						}
					}
					AtalkFreeMemory(pFree);
#if	DBG
					atalkNumChunksForId[i] --;
#endif
				}
			}
		}
		RELEASE_SPIN_LOCK_DPC(&atalkBPLock[i]);
	}

	return ATALK_TIMER_REQUEUE;
}

#ifdef	TRACK_MEMORY_USAGE

#define	MAX_PTR_COUNT		4*1024
#define	MAX_MEM_USERS		512
LOCAL	ATALK_SPIN_LOCK		atalkMemTrackLock	= {0};
LOCAL	struct
{
	PVOID	mem_Ptr;
	ULONG	mem_FileLine;
} atalkMemPtrs[MAX_PTR_COUNT]	= {0};

LOCAL	struct
{
	ULONG	mem_FL;
	ULONG	mem_Count;
} atalkMemUsage[MAX_MEM_USERS]	= {0};

BOOLEAN NeverBeenFull=TRUE;

VOID
AtalkTrackMemoryUsage(
	IN	PVOID	pMem,
    IN  ULONG   Size,
	IN	BOOLEAN	Alloc,
	IN	ULONG	FileLine
	)
/*++

Routine Description:

 	Keep track of memory usage by storing and clearing away pointers as and
 	when they are allocated or freed. This helps in keeping track of memory
 	leaks.

Arguments:


Return Value:


--*/
{
	static int		i = 0;
	int				j, k;
	KIRQL				OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkMemTrackLock, &OldIrql);

	if (Alloc)
	{
		for (j = 0; j < MAX_PTR_COUNT; i++, j++)
		{
			i = i & (MAX_PTR_COUNT-1);
			if (atalkMemPtrs[i].mem_Ptr == NULL)
			{
				atalkMemPtrs[i].mem_Ptr = pMem;
				atalkMemPtrs[i++].mem_FileLine = FileLine;
				break;
			}
		}

		for (k = 0; k < MAX_MEM_USERS; k++)
		{
			if (atalkMemUsage[k].mem_FL == FileLine)
			{
				atalkMemUsage[k].mem_Count += Size;
				break;
			}
		}
		if (k == MAX_MEM_USERS)
		{
			for (k = 0; k < MAX_MEM_USERS; k++)
			{
				if (atalkMemUsage[k].mem_FL == 0)
				{
					atalkMemUsage[k].mem_FL = FileLine;
					atalkMemUsage[k].mem_Count = Size;
					break;
				}
			}
			if (k == MAX_MEM_USERS)
			{
				DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_ERR,
					("AtalkTrackMemoryUsage: Out of space on atalkMemUsage !!!\n"));
			}
		}
	}
	else
	{
		for (j = 0, k = i; j < MAX_PTR_COUNT; j++, k--)
		{
			k = k & (MAX_PTR_COUNT-1);
			if (atalkMemPtrs[k].mem_Ptr == pMem)
			{
				atalkMemPtrs[k].mem_Ptr = 0;
				atalkMemPtrs[k].mem_FileLine = 0;
				break;
			}
		}

		for (k = 0; k < MAX_MEM_USERS; k++)
		{
			if (atalkMemUsage[k].mem_FL == FileLine)
			{
                if (atalkMemUsage[k].mem_Count >= Size)
                {
				    atalkMemUsage[k].mem_Count -= Size;
                }
				break;
			}
		}

	}

	RELEASE_SPIN_LOCK(&atalkMemTrackLock, OldIrql);

	if (j == MAX_PTR_COUNT)
	{
        if (NeverBeenFull)
        {
            NeverBeenFull = FALSE;
		    DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_ERR,
			    ("AtalkTrackMemoryUsage: %s\n", Alloc ? "Table Full" : "Can't find"));
        }
	}
}

#endif	// TRACK_MEMORY_USAGE

#ifdef	TRACK_BUFFDESC_USAGE

#define	MAX_BD_COUNT		1024*2
LOCAL	ATALK_SPIN_LOCK	atalkBdTrackLock	= {0};
LOCAL	struct
{
	PVOID	bdesc_Ptr;
	ULONG	bdesc_FileLine;
} atalkBuffDescPtrs[MAX_BD_COUNT]			= {0};


VOID
AtalkTrackBuffDescUsage(
	IN	PVOID	pBuffDesc,
	IN	BOOLEAN	Alloc,
	IN	ULONG	FileLine
	)
/*++

Routine Description:

 	Keep track of buffer-desc usage by storing and clearing away pointers as and
 	when they are allocated or freed. This helps in keeping track of memory
 	leaks.

Arguments:


Return Value:


--*/
{
	static int		i = 0;
	int				j, k;
	KIRQL				OldIrql;

	ACQUIRE_SPIN_LOCK(&atalkBdTrackLock, &OldIrql);

	if (Alloc)
	{
		for (j = 0; j < MAX_BD_COUNT; i++, j++)
		{
			i = i & (MAX_BD_COUNT-1);
			if (atalkBuffDescPtrs[i].bdesc_Ptr == NULL)
			{
				atalkBuffDescPtrs[i].bdesc_Ptr = pBuffDesc;
				atalkBuffDescPtrs[i++].bdesc_FileLine = FileLine;
				break;
			}
		}
	}
	else
	{
		for (j = 0, k = i; j < MAX_BD_COUNT; j++, k--)
		{
			k = k & (MAX_BD_COUNT-1);
			if (atalkBuffDescPtrs[k].bdesc_Ptr == pBuffDesc)
			{
				atalkBuffDescPtrs[k].bdesc_Ptr = 0;
				atalkBuffDescPtrs[k].bdesc_FileLine = 0;
				break;
			}
		}
	}

	RELEASE_SPIN_LOCK(&atalkBdTrackLock, OldIrql);

	if (j == MAX_BD_COUNT)
	{
		DBGPRINT(DBG_COMP_RESOURCES, DBG_LEVEL_INFO,
			("AtalkTrackBuffDescUsage: %s\n", Alloc ? "Table Full" : "Can't find"));
		ASSERT(0);
	}
}

#endif	// TRACK_BUFFDESC_USAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkinit.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkinit.h

Abstract:

	This module contains definitions for init time routines.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKINIT_
#define	_ATKINIT_

//  Winsock related constants used during initialization util routines
#define PROTOCOLTYPE_PREFIX	 		L"\\"
#define SOCKETSTREAM_SUFFIX	 		L"\\Stream"
#define SOCKET_TYPE_UNDEFINED		0
#define PROTOCOL_TYPE_UNDEFINED 	0
#define SOCKET_TYPE_STREAM			1
#define SOCKET_TYPE_RDM		 		2

#define	ATALK_PORT_NAME				"Microsoft\250 Windows 2000\252 Prt"
#define	ATALK_PORT_NAME_SIZE		(strlen(ATALK_PORT_NAME) + 1)
#define	ATALK_ROUTER_NBP_TYPE		"Microsoft\250 Windows 2000\252 Rtr"
#define	ATALK_ROUTER_NBP_SIZE		(strlen(ATALK_ROUTER_NBP_TYPE) + 1)
#define	ATALK_NONROUTER_NBP_TYPE	ATALK_PORT_NAME
#define	ATALK_NONROUTER_NBP_SIZE	(strlen(ATALK_NONROUTER_NBP_TYPE) + 1)

//	Registry parameters keys that we use and expect

#define LINKAGE_STRING				L"Linkage"
#define PARAMETERS_STRING			L"Parameters"
#define ADAPTERS_STRING				L"Parameters\\Adapters"
#define RAS_ADAPTER_NAME            L"\\DEVICE\\NDISWANATALK"
#define BIND_STRING					L"Bind"

#define VALUENAME_NETUPPEREND		L"NetworkRangeUpperEnd"
#define VALUENAME_NETLOWEREND		L"NetworkRangeLowerEnd"
#define VALUENAME_ZONELIST			L"ZoneList"
#define VALUENAME_DEFAULTZONE		L"DefaultZone"
#define VALUENAME_PORTNAME			L"PortName"
#define VALUENAME_DDPCHECKSUMS		L"DdpChecksums"
#define VALUENAME_AARPRETRIES		L"AarpRetries"
#define	VALUENAME_SEEDROUTER		L"SeedingNetwork"

#define VALUENAME_ENABLEROUTER		L"EnableRouter"
#define VALUENAME_DEFAULTPORT		L"DefaultPort"
#define VALUENAME_DESIREDZONE		L"DesiredZone"
#define VALUENAME_FILTEROURNAMES	L"FilterOurNames"

NTSTATUS
AtalkInitializeTransport (
	IN	PDRIVER_OBJECT			pDrvObj,
	IN	PUNICODE_STRING			pRegPath
);

NTSTATUS
AtalkInitAdapter(
	IN	PUNICODE_STRING			AdapterName,
	IN	PPORT_DESCRIPTOR		pExistingPortDesc
);

NTSTATUS
AtalkDeinitAdapter(
	IN	PPORT_DESCRIPTOR		pPortDesc
);

NTSTATUS
atalkInitGetHandleToKey(
	IN	PUNICODE_STRING			KeyName,
	OUT	PHANDLE 				KeyHandle
);

NTSTATUS
atalkInitGlobal(
	VOID
);

NTSTATUS
atalkInitPort(
	IN	PPORT_DESCRIPTOR		pPortDesc,
	IN	HANDLE					AdaptersKeyHandle
);

NTSTATUS
atalkInitNetRangeCheck(
	IN	PPORT_DESCRIPTOR		pPortDesc
);

NTSTATUS
atalkInitNetRange(
	OUT		PPORT_DESCRIPTOR	pPortDesc
);

NTSTATUS
atalkInitZoneList(
	OUT		PPORT_DESCRIPTOR	pPortDesc
);

NTSTATUS
atalkInitDefZone(
	OUT		PPORT_DESCRIPTOR	pPortDesc
);

NTSTATUS
atalkInitSeeding(
	IN OUT	PPORT_DESCRIPTOR	pPortDesc,
	OUT		PBOOLEAN			Seeding
);

NTSTATUS
atalkInitPortParameters(
	OUT		PPORT_DESCRIPTOR	pPortDesc
);

NTSTATUS
atalkInitStartPort(
	IN	PPORT_DESCRIPTOR		pPortDesc
);

VOID
atalkRegNbpComplete(
	IN	ATALK_ERROR				Status,
	IN	PACTREQ					pActReq
);

#if DBG

VOID
atalkInitPrintPortInfo(
	VOID
);

#endif

#endif	// _ATKINIT_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkpnp.c ===
/*++										

Copyright (c) 1997  Microsoft Corporation

Module Name:

	atkpnp.c

Abstract:

	This module contains the support code for handling PnP events

Author:

	Shirish Koti

Revision History:
	16 Jun 1997		Initial Version

--*/


#include <atalk.h>
#pragma hdrstop
#define	FILENUM	ATKPNP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, AtalkPnPHandler)
#pragma alloc_text(PAGE, AtalkPnPReconfigure)
#pragma alloc_text(PAGE, AtalkPnPEnableAdapter)
#endif

NDIS_STATUS
AtalkPnPHandler(
    IN  NDIS_HANDLE    NdisBindCtx,
    IN  PNET_PNP_EVENT pPnPEvent
)
{

    NDIS_STATUS     Status=STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(pPnPEvent);

    ASSERT(KeGetCurrentIrql() == 0);

    switch (pPnPEvent->NetEvent)
    {
        case NetEventReconfigure:

	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_INFO,
		            ("AtalkPnPHandler: NetEventReconfigure event\n"));

                Status = AtalkPnPReconfigure(NdisBindCtx,pPnPEvent);

                break;

        case NetEventCancelRemoveDevice:

	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventCancelRemoveDevice event\n"));
                break;

        case NetEventQueryRemoveDevice:

	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventQueryRemoveDevice event\n"));
                break;

        case NetEventQueryPower:

	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventQueryPower event\n"));
                break;

        case NetEventSetPower:

	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventSetPower event\n"));
                break;

        case NetEventBindsComplete:
	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventBindsComplete event\n"));
                break;

        case NetEventBindList:
	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: NetEventBindList event\n"));
                break;

        default:
	            DBGPRINT(DBG_COMP_ACTION, DBG_LEVEL_ERR,
		            ("AtalkPnPHandler: what is this event?, verify if it is valid/new = %ld\n", pPnPEvent->NetEvent));

		break;
    }

    ASSERT(Status == STATUS_SUCCESS);

    return(STATUS_SUCCESS);
}


NDIS_STATUS
AtalkPnPReconfigure(
    IN  NDIS_HANDLE    NdisBindCtx,
    IN  PNET_PNP_EVENT pPnPEvent
)
{

    NTSTATUS            Status=STATUS_SUCCESS;
    NTSTATUS            LocStatus=STATUS_SUCCESS;
    PPORT_DESCRIPTOR    pPortDesc;
    PPORT_DESCRIPTOR    pPrevPortDesc;
    PPORT_DESCRIPTOR    pNextPortDesc;
    PPORT_DESCRIPTOR    pFirstPortDesc;
    PPORT_DESCRIPTOR    pWalkerPortDesc;
    PATALK_PNP_EVENT    pPnpBuf;
    BOOLEAN             fWeFoundOut;


    pPortDesc = (PPORT_DESCRIPTOR)NdisBindCtx;

    pPnpBuf = (PATALK_PNP_EVENT)(pPnPEvent->Buffer);

    //
    // if it's a global configuration message, just ignore it because we will
    // be getting (or have already got) specific messages
    //
    if (pPnpBuf == NULL)
    {
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		    ("AtalkPnPReconfigure: ignoring global config message\n"));
        return(STATUS_SUCCESS);
    }

    if ((!pPortDesc) &&
        (pPnpBuf->PnpMessage != AT_PNP_SWITCH_ROUTING) &&
        (pPnpBuf->PnpMessage != AT_PNP_SWITCH_DEFAULT_ADAPTER))
    {
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		    ("AtalkPnPReconfigure: ignoring NULL context (pnp msg = %d)\n",
            pPnpBuf->PnpMessage));
        return(STATUS_SUCCESS);
    }

    if (AtalkBindnUnloadStates & ATALK_UNLOADING)
    {
		DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
		    ("AtalkPnPReconfigure: stack is shutting down, ignoring pnp\n"));
        return(STATUS_SUCCESS);
    }

    AtalkBindnUnloadStates |= ATALK_PNP_IN_PROGRESS;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR, ("\n\nProcessing PnP Event....\n\n"));

    AtalkLockInitIfNecessary();

    ASSERT(pPnpBuf != NULL);

    switch (pPnpBuf->PnpMessage)
    {
        //
        // user just checked (or unchecked) the router checkbox!  If we are
        // currently not routing, we must start routing.  If we are currently
        // routing, we must stop routing.  "Disable" all the adapters, go read
        // the global config info and "Enable" all the adapters back.
        //
        case AT_PNP_SWITCH_ROUTING:

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("AtalkPnPReconfigure: AT_PNP_SWITCH_ROUTING. Currently, routing is %s\n"
                ,(AtalkRouter)? "ON" : "OFF" ));

            pPortDesc = pFirstPortDesc = AtalkPortList;
            pPrevPortDesc = pPortDesc;

            if (!pPortDesc)
            {
			    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkPnPReconfigure: no adapter configured! no action taken\n"));
                break;
            }

            //
            // if we are currently running the router, first stop the global
            // rtmp and zip timers
            //
            if (AtalkRouter)
            {
                if (AtalkTimerCancelEvent(&atalkRtmpVTimer, NULL))
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			            ("AtalkPnPReconfigure: cancelled atalkRtmpValidityTimer\n"));
                }
                else
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			            ("AtalkPnPReconfigure: couldn't cancel atalkRtmpValidityTimer\n"));
                }

                if (AtalkTimerCancelEvent(&atalkZipQTimer, NULL))
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			            ("AtalkPnPReconfigure: cancelled atalkZipQueryTimer\n"));
                }
                else
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			            ("AtalkPnPReconfigure: couldn't cancel atalkZipQueryTimer\n"));
                }
            }

            atalkRtmpVdtTmrRunning  = FALSE;

            atalkZipQryTmrRunning   = FALSE;

            //
            // now, disable all the ports in the list one by one.  This actually
            // removes the adapter from the list as well.  Link all these adapters
            // together so we can enable all of them.
            // (NDIS guaranteed that no ndis event (pnp, unbind etc.) can happen
            // when one is in progress, so we don't need lock here)
            //
            while (pPortDesc != NULL)
            {

                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                    ("AtalkPnPReconfigure: disabling pPortDesc %lx\n",pPortDesc));

                Status = AtalkPnPDisableAdapter(pPortDesc);

                pPortDesc = AtalkPortList;
                pPrevPortDesc->pd_Next = pPortDesc;
                pPrevPortDesc = pPortDesc;
            }

            // unlock the pages that we locked when router was first started
            if (AtalkRouter)
            {
                AtalkUnlockRouterIfNecessary();
            }

            if (AtalkDefaultPortName.Buffer)
            {
                AtalkFreeMemory(AtalkDefaultPortName.Buffer);
                AtalkDefaultPortName.Buffer = NULL;
            }

            if (AtalkDesiredZone)
            {
                ASSERT(AtalkDesiredZone->zn_RefCount >= 1);
                AtalkZoneDereference(AtalkDesiredZone);
                AtalkDesiredZone = NULL;
            }

            // get rid of routing table, if one exists
            AtalkRtmpInit(FALSE);

            // go read all the parms again: registry must have changed
            LocStatus = atalkInitGlobal();

            ASSERT(NT_SUCCESS(LocStatus));

            // now, enable all the adapters back!
            pPortDesc = pFirstPortDesc;

            while (pPortDesc != NULL)
            {
                pNextPortDesc = pPortDesc->pd_Next;
                pPortDesc->pd_Next = NULL;

                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                    ("AtalkPnPReconfigure: enabling pPortDesc %lx\n",pPortDesc));

                Status = AtalkPnPEnableAdapter(pPortDesc);

                pPortDesc = pNextPortDesc;
            }

            break;

        //
        // user has changed the default adapter.  First, "disable" our
        // current default adapter and the wannabe default adapter.  Then,
        // "enable" both the adapters, and that should take care of everything!
        //
        case AT_PNP_SWITCH_DEFAULT_ADAPTER:

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("AtalkPnPReconfigure: AT_PNP_SWITCH_DEFAULT_ADAPTER (old=(%lx) new=(%lx)\n",
                AtalkDefaultPort,pPortDesc));

            pPrevPortDesc = AtalkDefaultPort;

            // check if default adapter exists: it's possible that at this moment there isn't one
            if (pPrevPortDesc)
            {
                Status = AtalkPnPDisableAdapter(pPrevPortDesc);
            }

            // release the default adapter name buffer, and desired zone buffer
            if (AtalkDefaultPortName.Buffer)
            {
                AtalkFreeMemory(AtalkDefaultPortName.Buffer);
                AtalkDefaultPortName.Buffer = NULL;
            }

            if (AtalkDesiredZone)
            {
                ASSERT(AtalkDesiredZone->zn_RefCount >= 1);
                AtalkZoneDereference(AtalkDesiredZone);
                AtalkDesiredZone = NULL;
            }

            // go read all the parms again: registry must have changed
            LocStatus = atalkInitGlobal();

            ASSERT(NT_SUCCESS(LocStatus));

            fWeFoundOut = FALSE;

            ASSERT(AtalkDefaultPortName.Buffer != NULL);

            // if we know who the new default adapter is going to be, disable him now
            if (pPortDesc != NULL)
            {
                Status = AtalkPnPDisableAdapter(pPortDesc);
            }

            //
            // UI doesn't know who the default adapter is, so let's find out
            // AtalkDefaultPortName.Buffer can not be null, but let's not bugcheck if
            // there is some problem in how UI does things.
            //
            else if (AtalkDefaultPortName.Buffer != NULL)
            {
                //
                // note that we aren't holding AtalkPortLock here.  The only way
                // the list can change is if an adapter binds or unbinds.  Since ndis
                // guarantees that all bind/unbind/pnp operations are serialized, and
                // since ndis has already called us here, the list can't change.
                //
                pPortDesc = AtalkPortList;

                while (pPortDesc != NULL)
                {
	                if (RtlEqualUnicodeString(&pPortDesc->pd_AdapterName,
		    		            	          &AtalkDefaultPortName,
			    		                      TRUE))
	                {
                        fWeFoundOut = TRUE;
	                    break;
	                }

                    pPortDesc = pPortDesc->pd_Next;
                }

                if (pPortDesc == NULL)
                {
			        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			            ("AtalkPnPReconfigure: still no default port????\n"));
                }
            }

            //
            // if there default adapter existed before this, reenable it (to be
            // a non-default adapter)
            //
            if (pPrevPortDesc)
            {
                Status = AtalkPnPEnableAdapter(pPrevPortDesc);
            }

            //
            // if we were told who the default adapter is, or if we found out
            // ourselves and one of the existing adapters is the default adatper,
            // disable it and reenable
            //
            if (pPortDesc)
            {
                // disable this guy if we found him out
                if (fWeFoundOut)
                {
                    Status = AtalkPnPDisableAdapter(pPortDesc);
                }

                // reenable the new adapter so that it is now the default adatper
                Status = AtalkPnPEnableAdapter(pPortDesc);

			    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkPnPReconfigure: %lx is the new default adapter\n",pPortDesc));
                ASSERT(AtalkDefaultPort == pPortDesc);
            }
            else
            {
			    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			        ("AtalkPnPReconfigure: no default adapter configured!\n"));
            }

            break;

        //
        // user has changed some parameter on the adapter (e.g. the desired zone,
        // or some seeding info etc.).  Just "disable" and then "enable" this
        // adapter, and everything should just work!
        //
        case AT_PNP_RECONFIGURE_PARMS:

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("AtalkPnPReconfigure: AT_PNP_RECONFIGURE_PARMS on pPortDesc %lx\n",pPortDesc));

            Status = AtalkPnPDisableAdapter(pPortDesc);

            // release the default adapter name buffer, and desired zone buffer
            if (AtalkDefaultPortName.Buffer)
            {
                AtalkFreeMemory(AtalkDefaultPortName.Buffer);
                AtalkDefaultPortName.Buffer = NULL;
            }

            if (AtalkDesiredZone)
            {
                ASSERT(AtalkDesiredZone->zn_RefCount >= 1);
                AtalkZoneDereference(AtalkDesiredZone);
                AtalkDesiredZone = NULL;
            }

            // go read all the parms again: registry must have changed
            LocStatus = atalkInitGlobal();

            ASSERT(NT_SUCCESS(LocStatus));

            Status = AtalkPnPEnableAdapter(pPortDesc);

            break;


        default:

			DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("AtalkPnPReconfigure: and what msg is this (%ld) ??\n",pPnpBuf->PnpMessage));

            ASSERT(0);

            break;
    }


    AtalkUnlockInitIfNecessary();

    ASSERT(Status == STATUS_SUCCESS);

    AtalkBindnUnloadStates &= ~ATALK_PNP_IN_PROGRESS;

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	    ("\n\n.... completed processing PnP Event\n\n"));

    return(STATUS_SUCCESS);
}



NTSTATUS
AtalkPnPDisableAdapter(
	IN	PPORT_DESCRIPTOR	pPortDesc
)
{

    NTSTATUS        Status;
    KIRQL           OldIrql;
    PLIST_ENTRY     pList;
    PARAPCONN       pArapConn;
    PATCPCONN       pAtcpConn;
    BOOLEAN         fDllDeref;
    BOOLEAN         fLineDownDeref;


    if (!pPortDesc)
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AtalkPnPDisableAdapter: pPortDesc is NULL!!!\n"));

        return(STATUS_SUCCESS);
    }

    ASSERT(VALID_PORT(pPortDesc));

	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	    ("AtalkPnPDisableAdapter: entered with %lx\n",pPortDesc));

    //
    // we are going to "disable" this port due to PnP: note that fact!
    //
	ACQUIRE_SPIN_LOCK(&pPortDesc->pd_Lock, &OldIrql);
	pPortDesc->pd_Flags |= PD_PNP_RECONFIGURE;
	RELEASE_SPIN_LOCK(&pPortDesc->pd_Lock, OldIrql);

    // First and foremost: tell guys above so they can cleanup
    if (pPortDesc->pd_Flags & PD_DEF_PORT)
    {
        ASSERT(pPortDesc == AtalkDefaultPort);

        if (TdiAddressChangeRegHandle)
        {
            TdiDeregisterNetAddress(TdiAddressChangeRegHandle);
            TdiAddressChangeRegHandle = NULL;

            DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                ("AtalkPnPDisableAdapter: TdiDeregisterNetAddress on %Z done\n",
                &pPortDesc->pd_AdapterName));

        }

        // this will tell AFP
        if (TdiRegistrationHandle)
        {
	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
			    ("AtalkPnPDisableAdapter: telling AFP about PnP\n"));

            TdiDeregisterDeviceObject(TdiRegistrationHandle);
            TdiRegistrationHandle = NULL;
        }

        // this will take care of informing ARAP and PPP engine above
        AtalkPnPInformRas(FALSE);
    }

    //
    // if this is RAS port or the Default port, kill all the ARAP and PPP
    // connections if any are left.
    // Since we've marked that PnpReconfigure is in progress, no more
    // new connections will be allowed
    //
    if ((pPortDesc == RasPortDesc) ||
        ((pPortDesc->pd_Flags & PD_DEF_PORT) && (RasPortDesc != NULL)))
    {
        ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

        pList = RasPortDesc->pd_ArapConnHead.Flink;

        // first, the ARAP guys
        while (pList != &RasPortDesc->pd_ArapConnHead)
        {
            pArapConn = CONTAINING_RECORD(pList, ARAPCONN, Linkage);

            ASSERT(pArapConn->Signature == ARAPCONN_SIGNATURE);

            // if this connection is already disconnected, skip it
            ACQUIRE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
            if (pArapConn->State == MNP_DISCONNECTED)
            {
                pList = pArapConn->Linkage.Flink;
                RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
                continue;
            }

            RELEASE_SPIN_LOCK_DPC(&pArapConn->SpinLock);
            RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	            ("AtalkPnPDisableAdapter: killing ARAP connection %lx\n",pArapConn));

            ArapCleanup(pArapConn);

            ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);

            pList = RasPortDesc->pd_ArapConnHead.Flink;
        }

        // and now, the PPP guys

        // if there are any ppp guys, remove them from this list and dereference
        // them.  In most cases, they will get freed right away.  If someone had
        // a refcount, it will get freed when that refcount goes away
        while (!(IsListEmpty(&RasPortDesc->pd_PPPConnHead)))
        {
            pList = RasPortDesc->pd_PPPConnHead.Flink;
            pAtcpConn = CONTAINING_RECORD(pList, ATCPCONN, Linkage);

            ASSERT(pAtcpConn->Signature == ATCPCONN_SIGNATURE);

            ACQUIRE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);

            RemoveEntryList(&pAtcpConn->Linkage);
            InitializeListHead(&pAtcpConn->Linkage);

            fDllDeref = (pAtcpConn->Flags & ATCP_DLL_SETUP_DONE)? TRUE : FALSE;
            fLineDownDeref = (pAtcpConn->Flags & ATCP_LINE_UP_DONE)? TRUE : FALSE;

            pAtcpConn->Flags &= ~(ATCP_DLL_SETUP_DONE|ATCP_LINE_UP_DONE);

            RELEASE_SPIN_LOCK_DPC(&pAtcpConn->SpinLock);
            RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);

	        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	            ("AtalkPnPDisableAdapter: deref'ing PPP conn %lx (%d+%d times)\n",
                pAtcpConn,fDllDeref,fLineDownDeref));

            // remove the DLL refcount
            if (fDllDeref)
            {
                DerefPPPConn(pAtcpConn);
            }

            // remove the NDISWAN refcount
            if (fLineDownDeref)
            {
                DerefPPPConn(pAtcpConn);
            }

            ACQUIRE_SPIN_LOCK(&RasPortDesc->pd_Lock, &OldIrql);
        }

        RELEASE_SPIN_LOCK(&RasPortDesc->pd_Lock, OldIrql);
    }

    //
    // "Disable" the adapter (basically we do everything except close the
    // adapter with ndis and freeing up the pPortDesc memory)
    //
	Status = AtalkDeinitAdapter(pPortDesc);

    if (!NT_SUCCESS(Status))
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AtalkPnPDisableAdapter: AtalkDeinitAdapter failed %lx\n",Status));
        ASSERT(0);
    }
    return(Status);
}


NTSTATUS
AtalkPnPEnableAdapter(
	IN	PPORT_DESCRIPTOR	pPortDesc
)
{

    NTSTATUS        Status;


    if (!pPortDesc)
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AtalkPnPDisableAdapter: pPortDesc is NULL!!!\n"));

        return(STATUS_SUCCESS);
    }


	DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	    ("AtalkPnPEnableAdapter: entered with %lx\n",pPortDesc));

    //
    // "Enable" the adapter (we do everything except that we don't
    // allocate memory for pPortDesc - since we didn't free it, and we don't
    // open the adapter with ndis - since we didn't close it).
    //

	Status = AtalkInitAdapter(NULL, pPortDesc);

    // we are done with the PnPReconfigure evnet: reset that bit
    AtalkPortSetResetFlag(pPortDesc, TRUE, PD_PNP_RECONFIGURE);

    // tell ARAP everything is ok
    if (pPortDesc->pd_Flags & (PD_DEF_PORT | PD_RAS_PORT))
    {
        ASSERT((pPortDesc == AtalkDefaultPort) || (pPortDesc == RasPortDesc));

        // this will take care of informing ARAP and PPP engine above
        AtalkPnPInformRas(TRUE);
    }


    if (!NT_SUCCESS(Status))
    {
	    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
	        ("AtalkPnPEnableAdapter: AtalkInitAdapter failed %lx\n",Status));
        ASSERT(0);
    }

    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
        ("AtalkPnPEnableAdapter: completed PnP on %lx (flag %lx)\n",
        pPortDesc,pPortDesc->pd_Flags));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\sfm\atalk\sys\atkndis.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	atkndis.h

Abstract:

	This module contains the ndis init/deint and protocol-support
	for	ndis definitions.

Author:

	Jameel Hyder (jameelh@microsoft.com)
	Nikhil Kamkolkar (nikhilk@microsoft.com)

Revision History:
	19 Jun 1992		Initial Version

Notes:	Tab stop: 4
--*/

#ifndef	_ATKNDIS_
#define	_ATKNDIS_

// This is the name that will be used in NdisRegisterProtocol. This has to match the
// registry section for PnP to work !!!
#define	PROTOCOL_REGISTER_NAME		L"Appletalk"

//	NDIS Version (4.0)
#define	PROTOCOL_MAJORNDIS_VERSION 	4
#define	PROTOCOL_MINORNDIS_VERSION 	0

// IEEE802.2 Definitions
// Offsets within the Extended 802.2 header:
#define IEEE8022_DSAP_OFFSET				0
#define IEEE8022_SSAP_OFFSET				1
#define IEEE8022_CONTROL_OFFSET				2
#define IEEE8022_PROTO_OFFSET				3

// 808.2 header length: DSAP, SSAP, UI, and PID (protocol ID).
#define IEEE8022_HDR_LEN					8

// Values for SSAP and DSAP (the SNAP SAP) indicating 802.2 Extended.
#define SNAP_SAP							((BYTE)0xAA)
#define	SNAP_SAP_FINAL						((BYTE)0xAB)

// Value for Control Field:
#define UNNUMBERED_INFO						0x03
#define	UNNUMBERED_FORMAT					0xF3

// Length of 802.2 SNAP protocol discriminators.
#define IEEE8022_PROTO_TYPE_LEN				5

//	The MAX_OPTHDR_LEN should be such that it holds the maximum header following
//	the ddp header from the upper layers (ADSP 13/ATP 8) and also it should allow a
//	full aarp packet to be held in the buffer when including the DDP header buffer.
//	i.e. 28. Ddp long header is 13. So the max works out to 15.
#define	MAX_OPTHDR_LEN						15

// AARP hardware types:
#define AARP_ELAP_HW_TYPE					1
#define AARP_TLAP_HW_TYPE					2

// Packet sizes.
#define AARP_MAX_DATA_SIZE					38		// Var fields... Enet is max
#define AARP_MIN_DATA_SIZE					28
#define AARP_MAX_PKT_SIZE					(IEEE8022_HDR_LEN +	AARP_MAX_DATA_SIZE)
#define	AARPLINK_MAX_PKT_SIZE				AARP_MAX_PKT_SIZE

#define AARP_ATALK_PROTO_TYPE				0x809B

#define	NUM_PACKET_DESCRIPTORS				300
#define	NUM_BUFFER_DESCRIPTORS				600
#define	ROUTING_FACTOR						4

// ETHERNET
#define ELAP_MIN_PKT_LEN					60
#define ELAP_ADDR_LEN						6

#define ELAP_DEST_OFFSET					0
#define ELAP_SRC_OFFSET						6
#define ELAP_LEN_OFFSET						12
#define ELAP_8022_START_OFFSET				14

#define ELAP_LINKHDR_LEN					14

// Ethernet multicast address:
#define ELAP_BROADCAST_ADDR_INIT			\
	{	0x09, 0x00, 0x07, 0xFF, 0xFF, 0xFF	}

#define ELAP_ZONE_MULTICAST_ADDRS			253

#define	ELAP_NUM_INIT_AARP_BUFFERS			 10

#define AtalkNdisFreeBuffer(_ndisBuffer)        \
{                                               \
    PNDIS_BUFFER    _ThisBuffer, _NextBuffer;   \
                                                \
    _ThisBuffer = _ndisBuffer;                  \
    while (_ThisBuffer)                         \
    {                                           \
        _NextBuffer = _ThisBuffer->Next;        \
        _ThisBuffer->Next = NULL;               \
        NdisFreeBuffer(_ThisBuffer);            \
        ATALK_DBG_DEC_COUNT(AtalkDbgMdlsAlloced);\
        _ThisBuffer = _NextBuffer;              \
    }                                           \
}

//	Values that are global to ndis routines
//	These are the media the stack will support
extern	NDIS_MEDIUM AtalkSupportedMedia[];


extern	ULONG		AtalkSupportedMediaSize;

extern	NDIS_HANDLE		AtalkNdisProtocolHandle;

extern	BYTE			AtalkElapBroadcastAddr[ELAP_ADDR_LEN];

extern	BYTE			AtalkAlapBroadcastAddr[];

extern	BYTE			AtalkAarpProtocolType[IEEE8022_PROTO_TYPE_LEN];

extern	BYTE			AtalkAppletalkProtocolType[IEEE8022_PROTO_TYPE_LEN];

extern	ATALK_NETWORKRANGE	AtalkStartupNetworkRange;
																
#define	ELAP_MCAST_HDR_LEN		(ELAP_ADDR_LEN - 1)

extern	BYTE	AtalkEthernetZoneMulticastAddrsHdr[ELAP_MCAST_HDR_LEN];

extern	BYTE	AtalkEthernetZoneMulticastAddrs[ELAP_ZONE_MULTICAST_ADDRS];

//	TOKENRING

#define TLAP_ADDR_LEN						6

//	For the following offsets we assume that a TokenRing packet as handed to
//	us will be complete EXCEPT for the "non-data" portions: Starting Delimiter
//	(SD), Frame Check Sequence (FCS), End of Frame Sequence (EFS), and Ending
//	Delimiter (ED).
#define TLAP_ACCESS_CTRL_OFFSET				0
#define TLAP_FRAME_CTRL_OFFSET				1
#define TLAP_DEST_OFFSET					2
#define TLAP_SRC_OFFSET						8
#define TLAP_ROUTE_INFO_OFFSET				14

//		A few "magic" values:
#define TLAP_ACCESS_CTRL_VALUE				0x00	// Priority zero frame.
#define TLAP_FRAME_CTRL_VALUE				0x40	// LLC frame, priority zero.
#define TLAP_SRC_ROUTING_MASK				0x80	// In first byte of source
													// address.

// Token ring source routing info stuff:
#define TLAP_ROUTE_INFO_SIZE_MASK			0x1F	// In first byte of routing
													// info, if present.

#define TLAP_MIN_ROUTING_BYTES				2
#define TLAP_MAX_ROUTING_BYTES				MAX_ROUTING_BYTES
#define TLAP_MAX_ROUTING_SPACE				MAX_ROUTING_SPACE
													// Previously defined in ports.h
#define TLAP_BROADCAST_INFO_MASK			0xE0	// In first byte of routing
													// info.
#define TLAP_NON_BROADCAST_MASK				0x1F	// To reset above bits.
#define TLAP_DIRECTION_MASK					0x80	// In second byte of routing
													// info.

#define TLAP_MIN_LINKHDR_LEN				TLAP_ROUTE_INFO_OFFSET
#define TLAP_MAX_LINKHDR_LEN				(TLAP_ROUTE_INFO_OFFSET + MAX_ROUTING_SPACE)

#define TLAP_BROADCAST_DEST_LEN				2

// TokenRing multicast address:
#define TLAP_BROADCAST_ADDR_INIT			{	0xC0, 0x00, 0x40, 0x00, 0x00, 0x00	}

#define TLAP_ZONE_MULTICAST_ADDRS			19

#define	TLAP_NUM_INIT_AARP_BUFFERS			6

#define	TLAP_MCAST_HDR_LEN					2

extern	BYTE	AtalkTokenRingZoneMulticastAddrsHdr[TLAP_MCAST_HDR_LEN];

extern	BYTE	AtalkTokenRingZoneMulticastAddrs[TLAP_ZONE_MULTICAST_ADDRS]
												[TLAP_ADDR_LEN - TLAP_MCAST_HDR_LEN];

extern	BYTE			AtalkTlapBroadcastAddr[TLAP_ADDR_LEN];

extern	BYTE			AtalkBroadcastRouteInfo[TLAP_MIN_ROUTING_BYTES];

extern	BYTE			AtalkSimpleRouteInfo[TLAP_MIN_ROUTING_BYTES];

extern	BYTE			AtalkBroadcastDestHdr[TLAP_BROADCAST_DEST_LEN];

//	FDDI
#define	FDDI_HEADER_BYTE					0x57	// Highest priority
#define MIN_FDDI_PKT_LEN					53		// From emperical data
#define FDDI_ADDR_LEN						6

#define FDDI_DEST_OFFSET					1
#define FDDI_SRC_OFFSET						7
#define FDDI_802DOT2_START_OFFSET			13
#define FDDI_LINKHDR_LEN					13

#define	FDDI_NUM_INIT_AARP_BUFFERS			10

//	LOCALTALK
#define ALAP_DEST_OFFSET					0
#define ALAP_SRC_OFFSET						1
#define ALAP_TYPE_OFFSET					2

#define ALAP_LINKHDR_LEN					3	// src, dest, lap type

#define ALAP_SDDP_HDR_TYPE					1
#define ALAP_LDDP_HDR_TYPE					2

#define	ALAP_NUM_INIT_AARP_BUFFERS			0

// WAN
#define WAN_LINKHDR_LEN                     14

// For send buffers, define a max. linkhdr len which is max of ELAP, TLAP, FDDI & ALAP
#define	MAX_LINKHDR_LEN				(IEEE8022_HDR_LEN + TLAP_MAX_LINKHDR_LEN)
											

#define	MAX_SENDBUF_LEN				(MAX_OPTHDR_LEN + MAX_LINKHDR_LEN + LDDP_HDR_LEN)

//
// 14 for "fake" ethernet hdr, 5 (worst case, with non-optimized phase) for
// MNP LT hdr, 5 for Start,Stop flags)
//
#define MNP_MINSEND_LEN         (MNP_MINPKT_SIZE + WAN_LINKHDR_LEN + 5 + 5 + 40)
#define MNP_MAXSEND_LEN         (MNP_MAXPKT_SIZE + WAN_LINKHDR_LEN + 5 + 5 + 40)

// Localtalk broadcast address: (only the first byte - 0xFF)
#define ALAP_BROADCAST_ADDR_INIT					\
		{ 0xFF, 0x00, 0x00,	0x00, 0x00, 0x00 }

// there is no broadcast addr for Arap: just put 0's
#define ARAP_BROADCAST_ADDR_INIT					\
		{ 0x00, 0x00, 0x00,	0x00, 0x00, 0x00 }

//	Completion routine type for ndis requests
typedef	struct _SEND_COMPL_INFO
{
	TRANSMIT_COMPLETION	sc_TransmitCompletion;
	PVOID				sc_Ctx1;
	PVOID				sc_Ctx2;
	PVOID				sc_Ctx3;

} SEND_COMPL_INFO, *PSEND_COMPL_INFO;

typedef VOID (*SEND_COMPLETION)(
						NDIS_STATUS				Status,
						PBUFFER_DESC			BufferChain,
						PSEND_COMPL_INFO		SendInfo	OPTIONAL
);

//	For incoming packets:
//	The structure of our ddp packets will be
//			+-------+
//			|Header |
//Returned->+-------+
//Ptr		| DDP	|
//			| HDR   |
//			| DATA	|
//			| AARP  |
//			| DATA	|
//			+-------+
//	
//	The link header is stored in the ndis packet descriptor.
//

typedef	struct _BUFFER_HDR
{
	PNDIS_PACKET				bh_NdisPkt;
	PNDIS_BUFFER				bh_NdisBuffer;
} BUFFER_HDR, *PBUFFER_HDR;

typedef	struct _AARP_BUFFER
{
	BUFFER_HDR					ab_Hdr;
	BYTE						ab_Data[AARP_MAX_DATA_SIZE];

} AARP_BUFFER, *PAARP_BUFFER;


typedef	struct _DDP_SMBUFFER
{
	BUFFER_HDR					dsm_Hdr;
	BYTE						dsm_Data[LDDP_HDR_LEN +
										 8 +	// ATP header size
										 64];	// ASP Data size (Average)

} DDP_SMBUFFER, *PDDP_SMBUFFER;

typedef	struct _DDP_LGBUFFER
{
	BUFFER_HDR					dlg_Hdr;
	BYTE						dlg_Data[MAX_LDDP_PKT_SIZE];

} DDP_LGBUFFER, *PDDP_LGBUFFER;


//	BUFFERING for sends
//	For outgoing packets, we preallocate buffer headers with buffer descriptors
//	following it, and the link/ddp/max opt hdr len memory following it.
//			+-------+
//			|Header	|
//			+-------+
//			|BuffDes|
//			+-------+
//			|MAXLINK|
//			+-------+
//			|MAX DDP|
//			+-------+
//			|MAX OPT|
//			+-------+
//
//	The header will contain a ndis buffer descriptor which will describe the
//	MAXLINK/MAXDDP/MAXOPT area. Set the size before sending. And reset when
//	Freeing. The next pointer in the buffer descriptor is used for chaining in
//	free list.
//
//	NOTE: Since for receives, we store the link header in the packet descriptor,
//		  the question arises, why not for sends? Because we want to use just one
//		  ndis buffer descriptor to describe all the non-data part.
//
//	!!!!IMPORTANT!!!!
//	The buffer descriptor header is accessed by going back from the buffer descriptor
//	pointer, so its important that the buffer descriptor header start from an
//	aligned address, i.e. make sure the structure does not contain elements that
//	could throw it out of alignment.
typedef struct _SENDBUF
{
	// NOTE: BUFFER_HDR must be the first thing. Look at AtalkBPAllocBlock();
	BUFFER_HDR						sb_BuffHdr;
	BUFFER_DESC						sb_BuffDesc;
	BYTE							sb_Space[MAX_SENDBUF_LEN];
} SENDBUF, *PSENDBUF;


//
// !!!!IMPORTANT!!!!
// This structure needs to stay aligned (i.e. Buffer[1] field MUST start on an
// aligned addr! If necessary, add a padding!)
//
typedef struct _MNPSENDBUF
{
    // NOTE: BUFFER_HDR must be the first thing. Look at AtalkBPAllocBlock();
    BUFFER_HDR            sb_BuffHdr;
    BUFFER_DESC           sb_BuffDesc;
    LIST_ENTRY            Linkage;      // to queue in ArapRetransmitQ
#if DBG
    DWORD                 Signature;
#endif
    LONG                  RetryTime;    // at this time, we will retransmit this send

    PARAPCONN             pArapConn;    // who owns this send
    PARAP_SEND_COMPLETION ComplRoutine; // routine to call when this send completes
    LONG                  TimeAlloced;  // time the first send came in on this buf

    USHORT                DataSize;     // how much of the buffer is data
    USHORT                BytesFree;    // can we stuff more packet(s)?

    // NOTE: (Remember: Buffer[1] must start on DWORD boundary) see if we can make Flags a byte
    DWORD                 Flags;

    BYTE                  SeqNum;       // sequence number used for this send
    BYTE                  RetryCount;   // how many times we have retransmitted this
    BYTE                  RefCount;     // free this buffer when refcount goes to 0
    BYTE                  NumSends;     // how many sends do we have stuffed here
    PBYTE                 FreeBuffer;   // pointer to free space
    BYTE                  Buffer[1];
} MNPSENDBUF, *PMNPSENDBUF;

typedef struct _ARAPBUF
{
    LIST_ENTRY            Linkage;       // to queue in ReceiveQ
#if DBG
    DWORD                 Signature;
#endif
    BYTE                  MnpFrameType;  // type of frame this is (LT, LN etc.)
    BYTE                  BlockId;       // what kind of buffer is this
    USHORT                BufferSize;    // how big is the buffer (set at init only)
	USHORT				  DataSize;      // how many bytes are valid (possible >1 srp)
    PBYTE                 CurrentBuffer; // where does data begin...
    BYTE                  Buffer[1];     // the buffer (with v42bis compressed pkt)
} ARAPBUF, *PARAPBUF;


#define ARAPCONN_SIGNATURE      0x99999999
#define ATCPCONN_SIGNATURE      0x88888888

#define MNPSMSENDBUF_SIGNATURE  0xbeef1111
#define MNPLGSENDBUF_SIGNATURE  0xbeef8888

#define ARAPSMPKT_SIGNATURE     0xcafe2222
#define ARAPMDPKT_SIGNATURE     0xcafe3333
#define ARAPLGPKT_SIGNATURE     0xcafe4444

#define ARAPLGBUF_SIGNATURE     0xdeebacad
#define ARAPUNLMTD_SIGNATURE    0xfafababa


//	PROTOCOL RESERVED Structure
//	This is what we expect to be in the packet descriptor. And we use it
//	to store information to be used during the completion of the send/
//	receives.

typedef struct
{
	//	!!!WARNING!!!
	//	pr_Linkage must be the first element in this structure for the
	//	CONTAINING_RECORD macro to work in receive completion.

	union
	{
		struct
		{
			PPORT_DESCRIPTOR		pr_Port;
			PBUFFER_DESC			pr_BufferDesc;
			SEND_COMPLETION			pr_SendCompletion;
			SEND_COMPL_INFO			pr_SendInfo;
		} Send;

		struct
		{
			LIST_ENTRY				pr_Linkage;
			PPORT_DESCRIPTOR		pr_Port;
			LOGICAL_PROTOCOL		pr_Protocol;
			NDIS_STATUS				pr_ReceiveStatus;
			PBUFFER_HDR				pr_BufHdr;
			BYTE					pr_LinkHdr[TLAP_MAX_LINKHDR_LEN];
			USHORT					pr_DataLength;
			BOOLEAN					pr_Processed;
			BYTE					pr_OptimizeType;
			BYTE					pr_OptimizeSubType;
			PVOID					pr_OptimizeCtx;
			ATALK_ADDR				pr_SrcAddr;
			ATALK_ADDR				pr_DestAddr;
			BOOLEAN					pr_OffCablePkt;
			union
			{
				//	ATP Structure
				struct
				{
					BYTE					pr_AtpHdr[8];	// ATP header size
					struct _ATP_ADDROBJ *	pr_AtpAddrObj;
				};

				//	ADSP Structure

			};
		} Receive;
	};
} PROTOCOL_RESD, *PPROTOCOL_RESD;


//	ATALK NDIS REQUEST
//	Used to store completion routine information for NDIS requests.

typedef struct _ATALK_NDIS_REQ
{
	NDIS_REQUEST					nr_Request;
	REQ_COMPLETION					nr_RequestCompletion;
	PVOID							nr_Ctx;
	KEVENT							nr_Event;
	NDIS_STATUS		 				nr_RequestStatus;
	BOOLEAN							nr_Sync;

} ATALK_NDIS_REQ, *PATALK_NDIS_REQ;


#define GET_PORT_TYPE(medium) \
			((medium == NdisMedium802_3) ? ELAP_PORT :\
			((medium == NdisMediumFddi)	? FDDI_PORT :\
			((medium == NdisMedium802_5) ? TLAP_PORT :\
			((medium == NdisMediumLocalTalk) ? ALAP_PORT : \
			((medium == NdisMediumWan) ? ARAP_PORT : \
			0)))))


//	Handlers for the different port types.
typedef struct _PORT_HANDLERS
{
	ADDMULTICASTADDR	ph_AddMulticastAddr;
	REMOVEMULTICASTADDR	ph_RemoveMulticastAddr;
	BYTE				ph_BroadcastAddr[MAX_HW_ADDR_LEN];
	USHORT				ph_BroadcastAddrLen;
	USHORT				ph_AarpHardwareType;
	USHORT				ph_AarpProtocolType;
} PORT_HANDLERS, *PPORT_HANDLERS;


typedef enum
{
    AT_PNP_SWITCH_ROUTING=0,
    AT_PNP_SWITCH_DEFAULT_ADAPTER,
    AT_PNP_RECONFIGURE_PARMS

} ATALK_PNP_MSGTYPE;

typedef struct _ATALK_PNP_EVENT
{
    ATALK_PNP_MSGTYPE   PnpMessage;
} ATALK_PNP_EVENT, *PATALK_PNP_EVENT;

//	MACROS for building/verifying 802.2 headers
#define	ATALK_VERIFY8022_HDR(pPkt, PktLen, Protocol, Result)				\
		{																	\
			Result = TRUE;													\
			if ((PktLen >= (IEEE8022_PROTO_OFFSET+IEEE8022_PROTO_TYPE_LEN))	&&	\
				(*(pPkt + IEEE8022_DSAP_OFFSET)	== SNAP_SAP)		&&		\
				(*(pPkt + IEEE8022_SSAP_OFFSET)	== SNAP_SAP)		&&		\
				(*(pPkt + IEEE8022_CONTROL_OFFSET)== UNNUMBERED_INFO))		\
			{																\
				if (!memcmp(pPkt + IEEE8022_PROTO_OFFSET,					\
						   AtalkAppletalkProtocolType,						\
						   IEEE8022_PROTO_TYPE_LEN))						\
				{															\
					Protocol = APPLETALK_PROTOCOL;							\
				}															\
				else if (!memcmp(pPkt + IEEE8022_PROTO_OFFSET,				\
								 AtalkAarpProtocolType,						\
								 IEEE8022_PROTO_TYPE_LEN))					\
				{															\
					Protocol = AARP_PROTOCOL;								\
				}															\
				else														\
				{															\
					Result	= FALSE;										\
				}															\
			}																\
			else															\
			{																\
				Result	= FALSE;											\
			}																\
		}


#define	ATALK_BUILD8022_HDR(Packet,	Protocol)									\
		{																		\
			PUTBYTE2BYTE(														\
				Packet + IEEE8022_DSAP_OFFSET,									\
				SNAP_SAP);														\
																				\
			PUTBYTE2BYTE(														\
				Packet + IEEE8022_SSAP_OFFSET,									\
				SNAP_SAP);														\
																				\
			PUTBYTE2BYTE(														\
				Packet + IEEE8022_CONTROL_OFFSET,								\
				UNNUMBERED_INFO);												\
																				\
			RtlCopyMemory(														\
				Packet + IEEE8022_PROTO_OFFSET,									\
				((Protocol == APPLETALK_PROTOCOL) ?								\
						AtalkAppletalkProtocolType : AtalkAarpProtocolType),	\
				IEEE8022_PROTO_TYPE_LEN);										\
		}																		
																				


//	Allocating and freeing send buffers
#define	AtalkNdisAllocBuf(_ppBuffDesc)										\
		{																		\
			PSENDBUF		_pSendBuf;											\
																				\
			_pSendBuf = AtalkBPAllocBlock(BLKID_SENDBUF);						\
			if ((_pSendBuf) != NULL)											\
			{																	\
				*(_ppBuffDesc) = &(_pSendBuf)->sb_BuffDesc;						\
				(_pSendBuf)->sb_BuffDesc.bd_Next = NULL;						\
				(_pSendBuf)->sb_BuffDesc.bd_Length = MAX_SENDBUF_LEN;			\
				(_pSendBuf)->sb_BuffDesc.bd_Flags  = BD_CHAR_BUFFER;			\
				(_pSendBuf)->sb_BuffDesc.bd_CharBuffer= (_pSendBuf)->sb_Space;	\
				(_pSendBuf)->sb_BuffDesc.bd_FreeBuffer= NULL;					\
			}																	\
			else																\
			{																	\
				*(_ppBuffDesc)	= NULL;											\
																				\
				DBGPRINT(DBG_COMP_NDISSEND, DBG_LEVEL_ERR,						\
						("AtalkNdisAllocBuf: AtalkBPAllocBlock failed\n"));	\
																				\
				LOG_ERROR(EVENT_ATALK_NDISRESOURCES,							\
						  NDIS_STATUS_RESOURCES,								\
						  NULL,													\
						  0);													\
			}																	\
		}																		
																				
#define	AtalkNdisFreeBuf(_pBuffDesc)											\
		{																		\
			PSENDBUF	_pSendBuf;												\
																				\
			ASSERT(VALID_BUFFDESC(_pBuffDesc));									\
			_pSendBuf = (PSENDBUF)((PBYTE)(_pBuffDesc) - sizeof(BUFFER_HDR));	\
			NdisAdjustBufferLength(												\
				(_pSendBuf)->sb_BuffHdr.bh_NdisBuffer,							\
				MAX_SENDBUF_LEN);												\
			AtalkBPFreeBlock((_pSendBuf));										\
		}																		


#define	ArapNdisFreeBuf(_pMnpSendBuf)											\
		{																		\
            PBUFFER_DESC    _pBufDes;                                           \
            _pBufDes = &_pMnpSendBuf->sb_BuffDesc;                              \
                                                                                \
	        DBGPRINT(DBG_COMP_RAS, DBG_LEVEL_INFO,   					        \
		        ("ArapNdisFreeBuf: freeing %lx  NdisPkt=%lx\n",                 \
                    _pMnpSendBuf,_pMnpSendBuf->sb_BuffHdr.bh_NdisPkt));	        \
                                                                                \
			NdisAdjustBufferLength(												\
				(_pMnpSendBuf)->sb_BuffHdr.bh_NdisBuffer,						\
				(_pBufDes)->bd_Length);							                \
                                                                                \
			AtalkBPFreeBlock((_pMnpSendBuf));									\
		}																		


//	Exported Prototypes
ATALK_ERROR
AtalkInitNdisQueryAddrInfo(
	IN	PPORT_DESCRIPTOR			pPortDesc
);

ATALK_ERROR
AtalkInitNdisStartPacketReception(
	IN	PPORT_DESCRIPTOR			pPortDesc
);

ATALK_ERROR
AtalkInitNdisSetLookaheadSize(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	INT							LookaheadSize
);

ATALK_ERROR
AtalkNdisAddMulticast(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PBYTE						Address,
	IN	BOOLEAN						ExecuteSynchronously,
	IN	REQ_COMPLETION				AddCompletion,
	IN	PVOID						AddContext
);

ATALK_ERROR
AtalkNdisRemoveMulticast(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PBYTE						Address,
	IN	BOOLEAN						ExecuteSynchronously,
	IN	REQ_COMPLETION				RemoveCompletion,
	IN	PVOID						RemoveContext
);

ATALK_ERROR
AtalkNdisSendPacket(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PBUFFER_DESC				BufferChain,
	IN	SEND_COMPLETION				SendCompletion	OPTIONAL,
	IN	PSEND_COMPL_INFO			pSendInfo		OPTIONAL
);

ATALK_ERROR
AtalkNdisAddFunctional(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PUCHAR						Address,
	IN	BOOLEAN						ExecuteSynchronously,
	IN	REQ_COMPLETION				AddCompletion,
	IN	PVOID						AddContext
);

ATALK_ERROR
AtalkNdisRemoveFunctional(
	IN	PPORT_DESCRIPTOR			pPortDesc,
	IN	PUCHAR						Address,
	IN	BOOLEAN						ExecuteSynchronously,
	IN	REQ_COMPLETION				RemoveCompletion,
	IN	PVOID						RemoveContext
);

USHORT
AtalkNdisBuildEthHdr(
	IN		PUCHAR					PortAddr,			// 802 address of port
	IN 		PBYTE					pLinkHdr,			// Start of link header
	IN		PBYTE					pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL		Protocol,			// Logical protocol
	IN		USHORT					ActualDataLen		// Length for ethernet packets
);

USHORT
AtalkNdisBuildTRHdr(
	IN		PUCHAR					PortAddr,			// 802 address of port
	IN 		PBYTE					pLinkHdr,			// Start of link header
	IN		PBYTE					pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL		Protocol,			// Logical protocol
	IN		PBYTE					pRouteInfo,			// Routing info for tokenring
	IN		USHORT					RouteInfoLen		// Length of above
);

USHORT
AtalkNdisBuildFDDIHdr(
	IN		PUCHAR					PortAddr,			// 802 address of port
	IN 		PBYTE					pLinkHdr,			// Start of link header
	IN		PBYTE					pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		LOGICAL_PROTOCOL		Protocol			// Logical protocol
);

USHORT
AtalkNdisBuildLTHdr(
	IN 		PBYTE					pLinkHdr,			// Start of link header
	IN		PBYTE					pDestHwOrMcastAddr,	// Destination or multicast addr
	IN		BYTE					AlapSrc,			// Localtalk source node
	IN		BYTE					AlapType			// Localtalk ddp header type
);


#define AtalkNdisBuildARAPHdr(_pLnkHdr, _pConn)             \
    RtlCopyMemory(_pLnkHdr, _pConn->NdiswanHeader, WAN_LINKHDR_LEN)

#define AtalkNdisBuildPPPPHdr(_pLnkHdr, _pConn)             \
    RtlCopyMemory(_pLnkHdr, _pConn->NdiswanHeader, WAN_LINKHDR_LEN)

#define	AtalkNdisBuildHdr(pPortDesc,						\
						  pLinkHdr,							\
						  linkLen,							\
						  ActualDataLen,					\
						  pDestHwOrMcastAddr,				\
						  pRouteInfo,						\
						  RouteInfoLen,						\
						  Protocol)							\
	{														\
		switch (pPortDesc->pd_NdisPortType)					\
		{													\
		  case NdisMedium802_3:								\
			linkLen = AtalkNdisBuildEthHdr(					\
								(pPortDesc)->pd_PortAddr,	\
								pLinkHdr,					\
								pDestHwOrMcastAddr,			\
								Protocol,					\
								ActualDataLen);				\
			break;											\
															\
		  case NdisMedium802_5:								\
			linkLen = AtalkNdisBuildTRHdr(					\
								(pPortDesc)->pd_PortAddr,	\
								pLinkHdr,					\
								pDestHwOrMcastAddr,			\
								Protocol,					\
								pRouteInfo,					\
								RouteInfoLen);				\
			break;											\
															\
		  case NdisMediumFddi:								\
			linkLen = AtalkNdisBuildFDDIHdr(				\
								(pPortDesc)->pd_PortAddr,	\
								pLinkHdr,					\
								pDestHwOrMcastAddr,			\
								Protocol);					\
			break;											\
															\
		  case NdisMediumLocalTalk:							\
			ASSERTMSG("AtalkNdisBuildHdr called for LT\n", 0);	\
			break;											\
															\
		  default:											\
			ASSERT (0);										\
			KeBugCheck(0);									\
			break;											\
		}													\
	}

VOID
AtalkNdisSendTokRingTestRespComplete(
	IN	NDIS_STATUS					Status,
	IN	PBUFFER_DESC				pBuffDesc,
	IN	PSEND_COMPL_INFO			pInfo	OPTIONAL);

VOID
AtalkNdisSendTokRingTestResp(
	IN		PPORT_DESCRIPTOR		pPortDesc,
	IN		PBYTE					HdrBuf,
	IN		UINT					HdrBufSize,
	IN		PBYTE					LkBuf,
	IN		UINT					LkBufSize,
	IN		UINT					pPktSize);

//	PORT HANDLERS
//	
extern	PORT_HANDLERS	AtalkPortHandlers[LAST_PORTTYPE];

//	Exported Prototypes

ATALK_ERROR
AtalkNdisInitRegisterProtocol(
	VOID
);

VOID
AtalkNdisDeregisterProtocol(
	VOID
);

VOID
AtalkNdisReleaseResources(
	VOID
);

NDIS_STATUS
AtalkNdisInitBind(
	IN	PPORT_DESCRIPTOR			pPortDesc
);

VOID
AtalkNdisUnbind(
	IN	PPORT_DESCRIPTOR		pPortDesc
);

NDIS_STATUS
AtalkNdisSubmitRequest(
	PPORT_DESCRIPTOR			pPortDesc,
	PNDIS_REQUEST				Request,
	BOOLEAN						ExecuteSync,
	REQ_COMPLETION				CompletionRoutine,
	PVOID						Ctx
);

VOID
AtalkOpenAdapterComplete(
	IN	NDIS_HANDLE				NdisBindCtx,
	IN	NDIS_STATUS				Status,
	IN	NDIS_STATUS				OpenErrorStatus
);

VOID
AtalkCloseAdapterComplete(
	IN	NDIS_HANDLE				NdisBindCtx,
	IN	NDIS_STATUS				Status
);

VOID
AtalkResetComplete(
	IN	NDIS_HANDLE				NdisBindCtx,
	IN	NDIS_STATUS				Status
);

VOID
AtalkRequestComplete(
	IN	NDIS_HANDLE				NdisBindCtx,
	IN	PNDIS_REQUEST			NdisRequest,
	IN	NDIS_STATUS				Status
);

VOID
AtalkStatusIndication (
	IN	NDIS_HANDLE				NdisBindCtx,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuf,
	IN	UINT					StatusBufLen
);

VOID
AtalkStatusComplete (
	IN	NDIS_HANDLE				ProtoBindCtx
);

VOID
AtalkReceiveComplete (
	IN	NDIS_HANDLE 			BindingCtx
);

VOID
AtalkTransferDataComplete(
	IN	NDIS_HANDLE				BindingCtx,
	IN	PNDIS_PACKET			NdisPkt,
	IN	NDIS_STATUS				Status,
	IN	UINT					BytesTransferred
);

NDIS_STATUS
AtalkReceiveIndication(
	IN	NDIS_HANDLE				BindingCtx,
	IN	NDIS_HANDLE				ReceiveCtx,
	IN	PVOID	   				HdrBuf,
	IN	UINT					HdrBufS