  AUXCAPS_AUXIN


PTSTR gaszAuxCapsSupport[32] =
{
    TEXT("Volume"),         // Bit 0    AUXCAPS_VOLUME
    TEXT("L/R Volume"),     // Bit 1    AUXCAPS_LRVOLUME
    NULL,                   // Bit 2
    NULL,                   // Bit 3
    NULL,                   // Bit 4
    NULL,                   // Bit 5
    NULL,                   // Bit 6
    NULL,                   // Bit 7
    NULL,                   // Bit 8
    NULL,                   // Bit 9
    NULL,                   // Bit 10
    NULL,                   // Bit 11
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};



//
//  MIDI[IN|OUT]CAPS
//
//
//
PTSTR gaszMidiOutCapsTechnology[] =
{
    gszNotSpecified,
    TEXT("MIDI Port"),                  // MOD_MIDIPORT
    TEXT("Internal Synth"),             // MOD_SYNTH
    TEXT("Internal Square Wave Synth"), // MOD_SQSYNTH
    TEXT("Internal FM Synth"),          // MOD_FMSYNTH
    TEXT("MIDI Mapper")                 // MOD_MAPPER
};

#define MIDIOUTCAPS_TECHNOLOGY_LAST     MOD_MAPPER


PTSTR gaszMidiOutCapsSupport[32] =
{
    TEXT("Volume"),         // Bit 0    MIDICAPS_VOLUME
    TEXT("L/R Volume"),     // Bit 1    MIDICAPS_LRVOLUME
    TEXT("Patch Caching"),  // Bit 2    MIDICAPS_CACHE
    TEXT("Poly Message"),   // Bit 3    MIDICAPS_POLYMSG (Win 4)
    NULL,                   // Bit 4
    NULL,                   // Bit 5
    NULL,                   // Bit 6
    NULL,                   // Bit 7
    NULL,                   // Bit 8
    NULL,                   // Bit 9
    NULL,                   // Bit 10
    NULL,                   // Bit 11
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};




//
//  MIXERCAPS
//
//
//
PTSTR gaszMixerCapsSupport[32] =
{
    NULL,                   // Bit 0
    NULL,                   // Bit 1
    NULL,                   // Bit 2
    NULL,                   // Bit 3
    NULL,                   // Bit 4
    NULL,                   // Bit 5
    NULL,                   // Bit 6
    NULL,                   // Bit 7
    NULL,                   // Bit 8
    NULL,                   // Bit 9
    NULL,                   // Bit 10
    NULL,                   // Bit 11
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};





//
//  WAVE[IN|OUT]CAPS
//
//
//
PTSTR gaszWaveInOutCapsFormats[32] =
{
    TEXT("8M11"),           // Bit 0    WAVE_FORMAT_1M08
    TEXT("8S11"),           // Bit 1    WAVE_FORMAT_1S08
    TEXT("16M11"),          // Bit 2    WAVE_FORMAT_1M16
    TEXT("16S11"),          // Bit 3    WAVE_FORMAT_1S16
    TEXT("8M22"),           // Bit 4    WAVE_FORMAT_2M08
    TEXT("8S22"),           // Bit 5    WAVE_FORMAT_2S08
    TEXT("16M22"),          // Bit 6    WAVE_FORMAT_2M16
    TEXT("16S22"),          // Bit 7    WAVE_FORMAT_2S16
    TEXT("8M44"),           // Bit 8    WAVE_FORMAT_4M08
    TEXT("8S44"),           // Bit 9    WAVE_FORMAT_4S08
    TEXT("16M44"),          // Bit 10   WAVE_FORMAT_4M16
    TEXT("16S44"),          // Bit 11   WAVE_FORMAT_4S16
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};

PTSTR gaszWaveOutCapsSupport[32] =
{
    TEXT("Pitch"),          // Bit 0    WAVECAPS_PITCH
    TEXT("Playback Rate"),  // Bit 1    WAVECAPS_PLAYBACKRATE
    TEXT("Volume"),         // Bit 2    WAVECAPS_VOLUME
    TEXT("L/R Volume"),     // Bit 3    WAVECAPS_LRVOLUME
    TEXT("Sync"),           // Bit 4    WAVECAPS_SYNC
    NULL,                   // Bit 5
    NULL,                   // Bit 6
    NULL,                   // Bit 7
    NULL,                   // Bit 8
    NULL,                   // Bit 9
    NULL,                   // Bit 10
    NULL,                   // Bit 11
    NULL,                   // Bit 12
    NULL,                   // Bit 13
    NULL,                   // Bit 14
    NULL,                   // Bit 15
    NULL,                   // Bit 16
    NULL,                   // Bit 17
    NULL,                   // Bit 18
    NULL,                   // Bit 19
    NULL,                   // Bit 20
    NULL,                   // Bit 21
    NULL,                   // Bit 22
    NULL,                   // Bit 23
    NULL,                   // Bit 24
    NULL,                   // Bit 25
    NULL,                   // Bit 26
    NULL,                   // Bit 27
    NULL,                   // Bit 28
    NULL,                   // Bit 29
    NULL,                   // Bit 30
    NULL                    // Bit 31
};


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDetailAuxiliary
//
//  Description:
//
//
//  Arguments:
//      HWND hedit:
//
//      int nDevId:
//
//  Return (BOOL):
//
//  History:
//      05/11/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailAuxiliary
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR               ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    PSTR                psz;
    MMRESULT            mmr;
    AUXCAPS2            ac2;
    UINT                u;
    DWORD               dw;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
         (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_AUXILIARY]);

    if (-1 == nDevId)
        AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
        AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);

    _fmemset(&ac2, 0, sizeof(ac2));
    mmr = auxGetDevCaps(nDevId, (PAUXCAPS)&ac2, sizeof(ac2));
    if (MMSYSERR_NOERROR != mmr)
    {
        _fmemset(&ac2, 0, sizeof(ac2));
        if (-1 != nDevId)
        {
            lstrcpy(ac2.szPname, gszBogusCaps);
        }
        else
        {
            if (0 != auxGetNumDevs())
            {
                ac2.wMid           = MM_MICROSOFT;
                ac2.vDriverVersion = (MMVERSION)GetVersion();
                lstrcpy(ac2.szPname, gszDefaultMapper);
                mmr = MMSYSERR_NOERROR;
            }
        }
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)ac2.szPname);

    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    //
    //
    //
    //
    AppMEditPrintF(hedit, "  Name GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   ac2.NameGuid.Data1,
                   ac2.NameGuid.Data2,
                   ac2.NameGuid.Data3,
                   ac2.NameGuid.Data4[0],
                   ac2.NameGuid.Data4[1],
                   ac2.NameGuid.Data4[2],
                   ac2.NameGuid.Data4[3],
                   ac2.NameGuid.Data4[4],
                   ac2.NameGuid.Data4[5],
                   ac2.NameGuid.Data4[6],
                   ac2.NameGuid.Data4[7]);

    //
    //
    //
    //
    MMCapsMidAndPid(ac2.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Manufacturer GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   ac2.ManufacturerGuid.Data1,
                   ac2.ManufacturerGuid.Data2,
                   ac2.ManufacturerGuid.Data3,
                   ac2.ManufacturerGuid.Data4[0],
                   ac2.ManufacturerGuid.Data4[1],
                   ac2.ManufacturerGuid.Data4[2],
                   ac2.ManufacturerGuid.Data4[3],
                   ac2.ManufacturerGuid.Data4[4],
                   ac2.ManufacturerGuid.Data4[5],
                   ac2.ManufacturerGuid.Data4[6],
                   ac2.ManufacturerGuid.Data4[7]);

    MMCapsMidAndPid(ac2.wMid, NULL, ac2.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Product GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   ac2.ProductGuid.Data1,
                   ac2.ProductGuid.Data2,
                   ac2.ProductGuid.Data3,
                   ac2.ProductGuid.Data4[0],
                   ac2.ProductGuid.Data4[1],
                   ac2.ProductGuid.Data4[2],
                   ac2.ProductGuid.Data4[3],
                   ac2.ProductGuid.Data4[4],
                   ac2.ProductGuid.Data4[5],
                   ac2.ProductGuid.Data4[6],
                   ac2.ProductGuid.Data4[7]);


    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
         (ac2.vDriverVersion >> 8), (BYTE)ac2.vDriverVersion);


    if (ac2.wTechnology > AUXCAPS_TECHNOLOGY_LAST)
    {
        wsprintf(ach, "[%u], Unknown", ac2.wTechnology);
        psz = ach;
    }
    else
    {
        psz = gaszAuxCapsTechnology[ac2.wTechnology];
    }

    AppMEditPrintF(hedit, "       Technology: %s\r\n", (LPSTR)psz);

    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", ac2.dwSupport);
    for (u = 0, dw = ac2.dwSupport; dw; u++)
    {
        if ((BYTE)dw & (BYTE)1)
        {
            psz = gaszAuxCapsSupport[u];
            if (NULL == psz)
            {
                wsprintf(ach, "Unknown%u", u);
                psz = ach;
            }

            AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
        }

        dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");

    return (TRUE);
} // MMCapsDetailAuxiliary()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDetailJoystick
//
//  Description:
//
//
//  Arguments:
//      HWND hedit:
//
//      int nDevId:
//
//  Return (BOOL):
//
//  History:
//      05/11/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailJoystick
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR               ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    MMRESULT            mmr;
    JOYCAPS2            jc2;


    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
         (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_JOYSTICK]);

    AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);


    //
    //
    //
    _fmemset(&jc2, 0, sizeof(jc2));
    mmr = joyGetDevCaps(nDevId, (PJOYCAPS)&jc2, sizeof(jc2));
    if (MMSYSERR_NOERROR != mmr)
    {
        lstrcpy(jc2.szPname, gszBogusCaps);
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)jc2.szPname);

    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    AppMEditPrintF(hedit, "  Name GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   jc2.NameGuid.Data1,
                   jc2.NameGuid.Data2,
                   jc2.NameGuid.Data3,
                   jc2.NameGuid.Data4[0],
                   jc2.NameGuid.Data4[1],
                   jc2.NameGuid.Data4[2],
                   jc2.NameGuid.Data4[3],
                   jc2.NameGuid.Data4[4],
                   jc2.NameGuid.Data4[5],
                   jc2.NameGuid.Data4[6],
                   jc2.NameGuid.Data4[7]);

    //
    //
    //
    //
    MMCapsMidAndPid(jc2.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Manufacturer GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   jc2.ManufacturerGuid.Data1,
                   jc2.ManufacturerGuid.Data2,
                   jc2.ManufacturerGuid.Data3,
                   jc2.ManufacturerGuid.Data4[0],
                   jc2.ManufacturerGuid.Data4[1],
                   jc2.ManufacturerGuid.Data4[2],
                   jc2.ManufacturerGuid.Data4[3],
                   jc2.ManufacturerGuid.Data4[4],
                   jc2.ManufacturerGuid.Data4[5],
                   jc2.ManufacturerGuid.Data4[6],
                   jc2.ManufacturerGuid.Data4[7]);


    MMCapsMidAndPid(jc2.wMid, NULL, jc2.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Product GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   jc2.ProductGuid.Data1,
                   jc2.ProductGuid.Data2,
                   jc2.ProductGuid.Data3,
                   jc2.ProductGuid.Data4[0],
                   jc2.ProductGuid.Data4[1],
                   jc2.ProductGuid.Data4[2],
                   jc2.ProductGuid.Data4[3],
                   jc2.ProductGuid.Data4[4],
                   jc2.ProductGuid.Data4[5],
                   jc2.ProductGuid.Data4[6],
                   jc2.ProductGuid.Data4[7]);


    AppMEditPrintF(hedit, "   Driver Version: (sigh)\r\n");

    AppMEditPrintF(hedit, "          Buttons: %u\r\n", jc2.wNumButtons);
    AppMEditPrintF(hedit, "    Minimum X Pos: %u\r\n", jc2.wXmin);
    AppMEditPrintF(hedit, "    Maximum X Pos: %u\r\n", jc2.wXmax);
    AppMEditPrintF(hedit, "    Minimum Y Pos: %u\r\n", jc2.wYmin);
    AppMEditPrintF(hedit, "    Maximum Y Pos: %u\r\n", jc2.wYmax);
    AppMEditPrintF(hedit, "    Minimum Z Pos: %u\r\n", jc2.wZmin);
    AppMEditPrintF(hedit, "    Maximum Z Pos: %u\r\n", jc2.wZmax);
    AppMEditPrintF(hedit, "   Minimum Period: %u\r\n", jc2.wPeriodMin);
    AppMEditPrintF(hedit, "   Maximum Period: %u\r\n", jc2.wPeriodMax);

    return (TRUE);
} // MMCapsDetailJoystick()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDetailMidiIn
//
//  Description:
//
//
//  Arguments:
//      HWND hedit:
//
//      int nDevId:
//
//  Return (BOOL):
//
//  History:
//      05/11/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailMidiIn
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR                   ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    MMRESULT                mmr;
    MIDIINCAPS2             mic2;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
         (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_MIDIIN]);

    if (-1 == nDevId)
        AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
        AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);


    //
    //
    //
    _fmemset(&mic2, 0, sizeof(mic2));
    mmr = midiInGetDevCaps(nDevId, (PMIDIINCAPS)&mic2, sizeof(mic2));
    if (MMSYSERR_NOERROR != mmr)
    {
        _fmemset(&mic2, 0, sizeof(mic2));
        if (-1 != nDevId)
        {
            lstrcpy(mic2.szPname, gszBogusCaps);
        }
        else
        {
            if (0 != midiInGetNumDevs())
            {
                mic2.wMid           = MM_MICROSOFT;
                mic2.vDriverVersion = (MMVERSION)GetVersion();
                lstrcpy(mic2.szPname, gszDefaultMapper);
                mmr = MMSYSERR_NOERROR;
            }
        }
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)mic2.szPname);

    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    //
    //
    //
    //
    AppMEditPrintF(hedit, "  Name GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   mic2.NameGuid.Data1,
                   mic2.NameGuid.Data2,
                   mic2.NameGuid.Data3,
                   mic2.NameGuid.Data4[0],
                   mic2.NameGuid.Data4[1],
                   mic2.NameGuid.Data4[2],
                   mic2.NameGuid.Data4[3],
                   mic2.NameGuid.Data4[4],
                   mic2.NameGuid.Data4[5],
                   mic2.NameGuid.Data4[6],
                   mic2.NameGuid.Data4[7]);

    //
    //
    //
    //
    MMCapsMidAndPid(mic2.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Manufacturer GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   mic2.ManufacturerGuid.Data1,
                   mic2.ManufacturerGuid.Data2,
                   mic2.ManufacturerGuid.Data3,
                   mic2.ManufacturerGuid.Data4[0],
                   mic2.ManufacturerGuid.Data4[1],
                   mic2.ManufacturerGuid.Data4[2],
                   mic2.ManufacturerGuid.Data4[3],
                   mic2.ManufacturerGuid.Data4[4],
                   mic2.ManufacturerGuid.Data4[5],
                   mic2.ManufacturerGuid.Data4[6],
                   mic2.ManufacturerGuid.Data4[7]);

    MMCapsMidAndPid(mic2.wMid, NULL, mic2.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Product GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   mic2.ProductGuid.Data1,
                   mic2.ProductGuid.Data2,
                   mic2.ProductGuid.Data3,
                   mic2.ProductGuid.Data4[0],
                   mic2.ProductGuid.Data4[1],
                   mic2.ProductGuid.Data4[2],
                   mic2.ProductGuid.Data4[3],
                   mic2.ProductGuid.Data4[4],
                   mic2.ProductGuid.Data4[5],
                   mic2.ProductGuid.Data4[6],
                   mic2.ProductGuid.Data4[7]);


    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
         (mic2.vDriverVersion >> 8), (BYTE)mic2.vDriverVersion);

    return (TRUE);
} // MMCapsDetailMidiIn()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDetailMidiOut
//
//  Description:
//
//
//  Arguments:
//      HWND hedit:
//
//      int nDevId:
//
//  Return (BOOL):
//
//  History:
//      05/11/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailMidiOut
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR                   ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    PSTR                    psz;
    MMRESULT                mmr;
    MIDIOUTCAPS2            moc2;
    UINT                    u;
    DWORD                   dw;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
         (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_MIDIOUT]);

    if (-1 == nDevId)
        AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
        AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);


    //
    //
    //
    _fmemset(&moc2, 0, sizeof(moc2));
    mmr = midiOutGetDevCaps(nDevId, (PMIDIOUTCAPS)&moc2, sizeof(moc2));
    if (MMSYSERR_NOERROR != mmr)
    {
        _fmemset(&moc2, 0, sizeof(moc2));
        if (-1 != nDevId)
        {
            lstrcpy(moc2.szPname, gszBogusCaps);
        }
        else
        {
            if (0 != midiOutGetNumDevs())
            {
                moc2.wMid           = MM_MICROSOFT;
                moc2.vDriverVersion = (MMVERSION)GetVersion();
                lstrcpy(moc2.szPname, gszDefaultMapper);
                mmr = MMSYSERR_NOERROR;
            }
        }
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)moc2.szPname);

    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    //
    //
    //
    //
    AppMEditPrintF(hedit, "  Name GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   moc2.NameGuid.Data1,
                   moc2.NameGuid.Data2,
                   moc2.NameGuid.Data3,
                   moc2.NameGuid.Data4[0],
                   moc2.NameGuid.Data4[1],
                   moc2.NameGuid.Data4[2],
                   moc2.NameGuid.Data4[3],
                   moc2.NameGuid.Data4[4],
                   moc2.NameGuid.Data4[5],
                   moc2.NameGuid.Data4[6],
                   moc2.NameGuid.Data4[7]);

    //
    //
    //
    //
    MMCapsMidAndPid(moc2.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Manufacturer GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   moc2.ManufacturerGuid.Data1,
                   moc2.ManufacturerGuid.Data2,
                   moc2.ManufacturerGuid.Data3,
                   moc2.ManufacturerGuid.Data4[0],
                   moc2.ManufacturerGuid.Data4[1],
                   moc2.ManufacturerGuid.Data4[2],
                   moc2.ManufacturerGuid.Data4[3],
                   moc2.ManufacturerGuid.Data4[4],
                   moc2.ManufacturerGuid.Data4[5],
                   moc2.ManufacturerGuid.Data4[6],
                   moc2.ManufacturerGuid.Data4[7]);


    MMCapsMidAndPid(moc2.wMid, NULL, moc2.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Product GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   moc2.ProductGuid.Data1,
                   moc2.ProductGuid.Data2,
                   moc2.ProductGuid.Data3,
                   moc2.ProductGuid.Data4[0],
                   moc2.ProductGuid.Data4[1],
                   moc2.ProductGuid.Data4[2],
                   moc2.ProductGuid.Data4[3],
                   moc2.ProductGuid.Data4[4],
                   moc2.ProductGuid.Data4[5],
                   moc2.ProductGuid.Data4[6],
                   moc2.ProductGuid.Data4[7]);


    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
         (moc2.vDriverVersion >> 8), (BYTE)moc2.vDriverVersion);


    if (moc2.wTechnology > MIDIOUTCAPS_TECHNOLOGY_LAST)
    {
        wsprintf(ach, "[%u], Unknown", moc2.wTechnology);
        psz = ach;
    }
    else
    {
        psz = gaszMidiOutCapsTechnology[moc2.wTechnology];
    }

    AppMEditPrintF(hedit, "       Technology: %s\r\n", (LPSTR)psz);
    AppMEditPrintF(hedit, " Voices (Patches): %u (if internal synth)\r\n", moc2.wVoices);
    AppMEditPrintF(hedit, "        Polyphony: %u (if internal synth)\r\n", moc2.wNotes);
    AppMEditPrintF(hedit, "     Channel Mask: %.04Xh (if internal synth)\r\n", moc2.wChannelMask);

    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", moc2.dwSupport);
    for (u = 0, dw = moc2.dwSupport; dw; u++)
    {
        if ((BYTE)dw & (BYTE)1)
        {
            psz = gaszMidiOutCapsSupport[u];
            if (NULL == psz)
            {
                wsprintf(ach, "Unknown%u", u);
                psz = ach;
            }

            AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
        }

        dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");

    return (TRUE);
} // MMCapsDetailMidiOut()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDetailMixer
//
//  Description:
//
//
//  Arguments:
//      HWND hedit:
//
//      int nDevId:
//
//  Return (BOOL):
//
//  History:
//      05/11/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailMixer
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR               ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    PSTR                psz;
    MMRESULT            mmr;
    MIXERCAPS2          mxc2;
    UINT                u;
    DWORD               dw;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
         (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_MIXER]);

#ifdef MIXER_MAPPER
    if (-1 == nDevId)
    AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
    AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);
#else
    AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);
#endif

    //
    //
    //
    _fmemset(&mxc2, 0, sizeof(mxc2));
    mmr = mixerGetDevCaps(nDevId, (PMIXERCAPS)&mxc2, sizeof(mxc2));
    if (MMSYSERR_NOERROR != mmr)
    {
        _fmemset(&mxc2, 0, sizeof(mxc2));
        if (-1 != nDevId)
        {
            lstrcpy(mxc2.szPname, gszBogusCaps);
        }
        else
        {
            if (0 != mixerGetNumDevs())
            {
                mxc2.wMid           = MM_MICROSOFT;
                mxc2.vDriverVersion = (MMVERSION)GetVersion();
                lstrcpy(mxc2.szPname, gszDefaultMapper);
                mmr = MMSYSERR_NOERROR;
            }
        }
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)mxc2.szPname);

    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    //
    //
    //
    //
    AppMEditPrintF(hedit, "  Name GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   mxc2.NameGuid.Data1,
                   mxc2.NameGuid.Data2,
                   mxc2.NameGuid.Data3,
                   mxc2.NameGuid.Data4[0],
                   mxc2.NameGuid.Data4[1],
                   mxc2.NameGuid.Data4[2],
                   mxc2.NameGuid.Data4[3],
                   mxc2.NameGuid.Data4[4],
                   mxc2.NameGuid.Data4[5],
                   mxc2.NameGuid.Data4[6],
                   mxc2.NameGuid.Data4[7]);

    //
    //
    //
    //
    MMCapsMidAndPid(mxc2.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Manufacturer GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   mxc2.ManufacturerGuid.Data1,
                   mxc2.ManufacturerGuid.Data2,
                   mxc2.ManufacturerGuid.Data3,
                   mxc2.ManufacturerGuid.Data4[0],
                   mxc2.ManufacturerGuid.Data4[1],
                   mxc2.ManufacturerGuid.Data4[2],
                   mxc2.ManufacturerGuid.Data4[3],
                   mxc2.ManufacturerGuid.Data4[4],
                   mxc2.ManufacturerGuid.Data4[5],
                   mxc2.ManufacturerGuid.Data4[6],
                   mxc2.ManufacturerGuid.Data4[7]);


    MMCapsMidAndPid(mxc2.wMid, NULL, mxc2.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Product GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   mxc2.ProductGuid.Data1,
                   mxc2.ProductGuid.Data2,
                   mxc2.ProductGuid.Data3,
                   mxc2.ProductGuid.Data4[0],
                   mxc2.ProductGuid.Data4[1],
                   mxc2.ProductGuid.Data4[2],
                   mxc2.ProductGuid.Data4[3],
                   mxc2.ProductGuid.Data4[4],
                   mxc2.ProductGuid.Data4[5],
                   mxc2.ProductGuid.Data4[6],
                   mxc2.ProductGuid.Data4[7]);


    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
         (mxc2.vDriverVersion >> 8), (BYTE)mxc2.vDriverVersion);

    AppMEditPrintF(hedit, "     Destinations: %u\r\n", mxc2.cDestinations);

    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", mxc2.fdwSupport);
    for (u = 0, dw = mxc2.fdwSupport; dw; u++)
    {
        if ((BYTE)dw & (BYTE)1)
        {
            psz = gaszMixerCapsSupport[u];
            if (NULL == psz)
            {
                wsprintf(ach, "Unknown%u", u);
                psz = ach;
            }

            AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
        }

        dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");

    return (TRUE);
} // MMCapsDetailMixer()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDetailTimer
//
//  Description:
//
//
//  Arguments:
//      HWND hedit:
//
//      int nDevId:
//
//  Return (BOOL):
//
//  History:
//      05/11/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailTimer
(
    HWND            hedit,
    int             nDevId
)
{
    MMRESULT        mmr;
    TIMECAPS        tc;
    MMVERSION       uMMSysVer;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
         (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_TIMER]);

    AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);
    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)gszTimerDevice);

    mmr = timeGetDevCaps(&tc, sizeof(tc));
    if (MMSYSERR_NOERROR != mmr)
    return (TRUE);

    //
    //
    //
    //
    uMMSysVer = (MMVERSION)GetVersion();
    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
         (uMMSysVer >> 8), (BYTE)uMMSysVer);

    AppMEditPrintF(hedit, "   Minimum Period: %u\r\n", tc.wPeriodMin);
    AppMEditPrintF(hedit, "   Maximum Period: %u\r\n", tc.wPeriodMax);

    return (TRUE);
} // MMCapsDetailTimer()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDetailWaveIn
//
//  Description:
//
//
//  Arguments:
//      HWND hedit:
//
//      int nDevId:
//
//  Return (BOOL):
//
//  History:
//      05/11/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailWaveIn
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR                   ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    PSTR                    psz;
    MMRESULT                mmr;
    WAVEINCAPS2             wic2;
    UINT                    u;
    DWORD                   dw;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
         (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_WAVEIN]);

    if (-1 == nDevId)
        AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
        AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);


    //
    //
    //
    _fmemset(&wic2, 0, sizeof(wic2));
    mmr = waveInGetDevCaps(nDevId, (PWAVEINCAPS)&wic2, sizeof(wic2));
    if (MMSYSERR_NOERROR != mmr)
    {
        _fmemset(&wic2, 0, sizeof(wic2));
        if (-1 != nDevId)
        {
            lstrcpy(wic2.szPname, gszBogusCaps);
        }
        else
        {
            if (0 != waveInGetNumDevs())
            {
                wic2.wMid           = MM_MICROSOFT;
                wic2.vDriverVersion = (MMVERSION)GetVersion();
                lstrcpy(wic2.szPname, gszDefaultMapper);
                mmr = MMSYSERR_NOERROR;
            }
        }
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)wic2.szPname);

    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    //
    //
    //
    //
    AppMEditPrintF(hedit, "  Name GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   wic2.NameGuid.Data1,
                   wic2.NameGuid.Data2,
                   wic2.NameGuid.Data3,
                   wic2.NameGuid.Data4[0],
                   wic2.NameGuid.Data4[1],
                   wic2.NameGuid.Data4[2],
                   wic2.NameGuid.Data4[3],
                   wic2.NameGuid.Data4[4],
                   wic2.NameGuid.Data4[5],
                   wic2.NameGuid.Data4[6],
                   wic2.NameGuid.Data4[7]);

    //
    //
    //
    //
    MMCapsMidAndPid(wic2.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Manufacturer GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   wic2.ManufacturerGuid.Data1,
                   wic2.ManufacturerGuid.Data2,
                   wic2.ManufacturerGuid.Data3,
                   wic2.ManufacturerGuid.Data4[0],
                   wic2.ManufacturerGuid.Data4[1],
                   wic2.ManufacturerGuid.Data4[2],
                   wic2.ManufacturerGuid.Data4[3],
                   wic2.ManufacturerGuid.Data4[4],
                   wic2.ManufacturerGuid.Data4[5],
                   wic2.ManufacturerGuid.Data4[6],
                   wic2.ManufacturerGuid.Data4[7]);


    MMCapsMidAndPid(wic2.wMid, NULL, wic2.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Product GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   wic2.ProductGuid.Data1,
                   wic2.ProductGuid.Data2,
                   wic2.ProductGuid.Data3,
                   wic2.ProductGuid.Data4[0],
                   wic2.ProductGuid.Data4[1],
                   wic2.ProductGuid.Data4[2],
                   wic2.ProductGuid.Data4[3],
                   wic2.ProductGuid.Data4[4],
                   wic2.ProductGuid.Data4[5],
                   wic2.ProductGuid.Data4[6],
                   wic2.ProductGuid.Data4[7]);


    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
         (wic2.vDriverVersion >> 8), (BYTE)wic2.vDriverVersion);

    AppMEditPrintF(hedit, "         Channels: %u\r\n", wic2.wChannels);

    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Formats: [%.08lXh]", wic2.dwFormats);
    for (u = 0, dw = wic2.dwFormats; dw; u++)
    {
        if ((BYTE)dw & (BYTE)1)
        {
            psz = gaszWaveInOutCapsFormats[u];
            if (NULL == psz)
            {
                wsprintf(ach, "Unknown%u", u);
                psz = ach;
            }

            AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
        }

        dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");

    return (TRUE);
} // MMCapsDetailWaveIn()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDetailWaveOut
//
//  Description:
//
//
//  Arguments:
//      HWND hedit:
//
//      int nDevId:
//
//  Return (BOOL):
//
//  History:
//      05/11/93
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL MMCapsDetailWaveOut
(
    HWND            hedit,
    int             nDevId
)
{
    TCHAR                   ach[MMCAPS_MAX_STRING_MIDPID_CHARS];
    PSTR                    psz;
    MMRESULT                mmr;
    WAVEOUTCAPS2            woc2;
    UINT                    u;
    DWORD                   dw;

    AppMEditPrintF(hedit, "      Device Type: %s\r\n",
         (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_WAVEOUT]);

    if (-1 == nDevId)
        AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId);
    else
        AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId);

    //
    //
    //
    _fmemset(&woc2, 0, sizeof(woc2));
    mmr = waveOutGetDevCaps(nDevId, (PWAVEOUTCAPS)&woc2, sizeof(woc2));
    if (MMSYSERR_NOERROR != mmr)
    {
        _fmemset(&woc2, 0, sizeof(woc2));
        if (-1 != nDevId)
        {
            lstrcpy(woc2.szPname, gszBogusCaps);
        }
        else
        {
            if (0 != waveOutGetNumDevs())
            {
                woc2.wMid           = MM_MICROSOFT;
                woc2.vDriverVersion = (MMVERSION)GetVersion();
                lstrcpy(woc2.szPname, gszDefaultMapper);
                mmr = MMSYSERR_NOERROR;
            }
        }
    }

    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)woc2.szPname);

    if (MMSYSERR_NOERROR != mmr)
    {
        return (TRUE);
    }

    //
    //
    //
    //
    AppMEditPrintF(hedit, "  Name GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   woc2.NameGuid.Data1,
                   woc2.NameGuid.Data2,
                   woc2.NameGuid.Data3,
                   woc2.NameGuid.Data4[0],
                   woc2.NameGuid.Data4[1],
                   woc2.NameGuid.Data4[2],
                   woc2.NameGuid.Data4[3],
                   woc2.NameGuid.Data4[4],
                   woc2.NameGuid.Data4[5],
                   woc2.NameGuid.Data4[6],
                   woc2.NameGuid.Data4[7]);


    //
    //
    //
    //
    MMCapsMidAndPid(woc2.wMid, ach, 0, NULL);
    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Manufacturer GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   woc2.ManufacturerGuid.Data1,
                   woc2.ManufacturerGuid.Data2,
                   woc2.ManufacturerGuid.Data3,
                   woc2.ManufacturerGuid.Data4[0],
                   woc2.ManufacturerGuid.Data4[1],
                   woc2.ManufacturerGuid.Data4[2],
                   woc2.ManufacturerGuid.Data4[3],
                   woc2.ManufacturerGuid.Data4[4],
                   woc2.ManufacturerGuid.Data4[5],
                   woc2.ManufacturerGuid.Data4[6],
                   woc2.ManufacturerGuid.Data4[7]);


    MMCapsMidAndPid(woc2.wMid, NULL, woc2.wPid, ach);
    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach);
    AppMEditPrintF(hedit, "  Product GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\r\n",
                   woc2.ProductGuid.Data1,
                   woc2.ProductGuid.Data2,
                   woc2.ProductGuid.Data3,
                   woc2.ProductGuid.Data4[0],
                   woc2.ProductGuid.Data4[1],
                   woc2.ProductGuid.Data4[2],
                   woc2.ProductGuid.Data4[3],
                   woc2.ProductGuid.Data4[4],
                   woc2.ProductGuid.Data4[5],
                   woc2.ProductGuid.Data4[6],
                   woc2.ProductGuid.Data4[7]);


    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n",
         (woc2.vDriverVersion >> 8), (BYTE)woc2.vDriverVersion);

    AppMEditPrintF(hedit, "         Channels: %u\r\n", woc2.wChannels);

    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Formats: [%.08lXh]", woc2.dwFormats);
    for (u = 0, dw = woc2.dwFormats; dw; u++)
    {
        if ((BYTE)dw & (BYTE)1)
        {
            psz = gaszWaveInOutCapsFormats[u];
            if (NULL == psz)
            {
                wsprintf(ach, "Unknown%u", u);
                psz = ach;
            }

            AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
        }

        dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");


    //
    //
    //
    //
    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", woc2.dwSupport);
    for (u = 0, dw = woc2.dwSupport; dw; u++)
    {
        if ((BYTE)dw & (BYTE)1)
        {
            psz = gaszWaveOutCapsSupport[u];
            if (NULL == psz)
            {
                wsprintf(ach, "Unknown%u", u);
                psz = ach;
            }

            AppMEditPrintF(hedit, ", %s", (LPSTR)psz);
        }

        dw >>= 1;
    }
    AppMEditPrintF(hedit, "\r\n");

    return (TRUE);
} // MMCapsDetailWaveOut()

//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  BOOL MMCapsDetailLowLevel
//
//  Description:
//
//
//  Arguments:
//      HWND hedit:
//
//      LPARAM lParam:
//
//  Return (BOOL):
//
//  History:
//      05/16/93
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL MMCapsDetailLowLevel
(
    HWND            hedit,
    LPARAM          lParam
)
{
    int         nDevId;
    UINT        uDevType;

    //
    //  HIWORD(lParam): MMCAPS_DEVTYPE_*
    //  LOWORD(lParam): Device index (id)
    //
    nDevId   = (int)(short)LOWORD(lParam);
    uDevType = HIWORD(lParam);

    //
    //
    //
    //
    switch (uDevType)
    {
    case MMCAPS_DEVTYPE_AUXILIARY:
        MMCapsDetailAuxiliary(hedit, nDevId);
        break;

    case MMCAPS_DEVTYPE_JOYSTICK:
        MMCapsDetailJoystick(hedit, nDevId);
        break;

    case MMCAPS_DEVTYPE_MIDIIN:
        MMCapsDetailMidiIn(hedit, nDevId);
        break;

    case MMCAPS_DEVTYPE_MIDIOUT:
        MMCapsDetailMidiOut(hedit, nDevId);
        break;

    case MMCAPS_DEVTYPE_MIXER:
        MMCapsDetailMixer(hedit, nDevId);
        break;

    case MMCAPS_DEVTYPE_TIMER:
        MMCapsDetailTimer(hedit, nDevId);
        break;

    case MMCAPS_DEVTYPE_WAVEIN:
        MMCapsDetailWaveIn(hedit, nDevId);
        break;

    case MMCAPS_DEVTYPE_WAVEOUT:
        MMCapsDetailWaveOut(hedit, nDevId);
        break;
    }


    //
    //
    //
    return (TRUE);
} // MMCapsDetailLowLevel()


//--------------------------------------------------------------------------;
//
//  BOOL MMCapsEnumerateLowLevel
//
//  Description:
//
//
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//
//      BOOL fComplete:
//
//  Return (BOOL):
//
//  History:
//      05/18/93
//
//--------------------------------------------------------------------------;

BOOL FNGLOBAL MMCapsEnumerateLowLevel
(
    PZYZTABBEDLISTBOX   ptlb,
    BOOL                fComplete
)
{
    TCHAR       ach[128];
    MMRESULT    mmr;
    int         n;
    int         nDevs;
    int         nIndex;
    LPARAM      lParam;
    UINT        uDevType;
    MMVERSION   uMMSysVer;
    HWND        hlb;


    //
    //
    //
    //
    //
    if (fComplete)
    {
    TlbSetTitleAndTabs(ptlb, gszDeviceFormatTitle, FALSE);
    }

    hlb = ptlb->hlb;

    uMMSysVer = (MMVERSION)GetVersion();


    //
    //
    //
    nDevs = auxGetNumDevs();
    for (n = -1; n < nDevs; n++)
    {
    AUXCAPS         ac;

    mmr = auxGetDevCaps(n, &ac, sizeof(ac));
    if (MMSYSERR_NOERROR != mmr)
    {
        if (-1 != n)
        {
        ac.vDriverVersion = 0;
        lstrcpy(ac.szPname, gszBogusCaps);
        }
        else
        {
        if (0 == nDevs)
            break;

        ac.vDriverVersion = uMMSysVer;
        lstrcpy(ac.szPname, gszDefaultMapper);
        }
    }

    //
    //
    //
    uDevType = MMCAPS_DEVTYPE_AUXILIARY;
    wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
         n, (ac.vDriverVersion >> 8), (BYTE)ac.vDriverVersion,
         (LPSTR)ac.szPname);

    nIndex = ListBox_AddString(hlb, ach);
    lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
    ListBox_SetItemData(hlb, nIndex, lParam);
    }


    //
    //
    //
    nDevs = joyGetNumDevs();
    for (n = 0; n < nDevs; n++)
    {
    JOYCAPS         jc;

    mmr = joyGetDevCaps(n, &jc, sizeof(jc));
    if (MMSYSERR_NOERROR != mmr)
    {
        lstrcpy(jc.szPname, gszBogusCaps);
    }

    //
    //
    //
    uDevType = MMCAPS_DEVTYPE_JOYSTICK;
    wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
         n, 0, 0, (LPSTR)jc.szPname);

    nIndex = ListBox_AddString(hlb, ach);
    lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
    ListBox_SetItemData(hlb, nIndex, lParam);
    }



    //
    //
    //
    nDevs = midiInGetNumDevs();
    for (n = -1; n < nDevs; n++)
    {
    MIDIINCAPS      mic;

    mmr = midiInGetDevCaps(n, &mic, sizeof(mic));
    if (MMSYSERR_NOERROR != mmr)
    {
        if (-1 != n)
        {
        mic.vDriverVersion = 0;
        lstrcpy(mic.szPname, gszBogusCaps);
        }
        else
        {
        if (0 == nDevs)
            break;

        mic.vDriverVersion = uMMSysVer;
        lstrcpy(mic.szPname, gszDefaultMapper);
        }
    }

    //
    //
    //
    uDevType = MMCAPS_DEVTYPE_MIDIIN;
    wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
         n, (mic.vDriverVersion >> 8), (BYTE)mic.vDriverVersion,
         (LPSTR)mic.szPname);

    nIndex = ListBox_AddString(hlb, ach);
    lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
    ListBox_SetItemData(hlb, nIndex, lParam);
    }

    //
    //
    //
    nDevs = midiOutGetNumDevs();
    for (n = -1; n < nDevs; n++)
    {
    MIDIOUTCAPS     moc;

    mmr = midiOutGetDevCaps(n, &moc, sizeof(moc));
    if (MMSYSERR_NOERROR != mmr)
    {
        if (-1 != n)
        {
        moc.vDriverVersion = 0;
        lstrcpy(moc.szPname, gszBogusCaps);
        }
        else
        {
        if (0 == nDevs)
            break;

        moc.vDriverVersion = uMMSysVer;
        lstrcpy(moc.szPname, gszDefaultMapper);
        }
    }

    //
    //
    //
    uDevType = MMCAPS_DEVTYPE_MIDIOUT;
    wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
         n, (moc.vDriverVersion >> 8), (BYTE)moc.vDriverVersion,
         (LPSTR)moc.szPname);

    nIndex = ListBox_AddString(hlb, ach);
    lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
    ListBox_SetItemData(hlb, nIndex, lParam);
    }


    //
    //
    //
    //
    //
//#ifndef WIN32
    nDevs = mixerGetNumDevs();
#ifdef MIXER_MAPPER
    for (n = -1; n < nDevs; n++)
#else
    for (n = 0; n < nDevs; n++)
#endif
    {
    MIXERCAPS       mxc;

    mmr = mixerGetDevCaps(n, &mxc, sizeof(mxc));
    if (MMSYSERR_NOERROR != mmr)
    {
        if (-1 != n)
        {
        mxc.vDriverVersion = 0;
        lstrcpy(mxc.szPname, gszBogusCaps);
        }
        else
        {
        if (0 == nDevs)
            break;

        mxc.vDriverVersion = uMMSysVer;
        lstrcpy(mxc.szPname, gszDefaultMapper);
        }
    }

    //
    //
    //
    uDevType = MMCAPS_DEVTYPE_MIXER;
    wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
         n, (mxc.vDriverVersion >> 8), (BYTE)mxc.vDriverVersion,
         (LPSTR)mxc.szPname);

    nIndex = ListBox_AddString(hlb, ach);
    lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
    ListBox_SetItemData(hlb, nIndex, lParam);
    }
//#endif



    //
    //
    //
    {
    TIMECAPS    tc;

    mmr = timeGetDevCaps(&tc, sizeof(tc));
    if (MMSYSERR_NOERROR == mmr)
    {
        //
        //
        //
        uDevType = MMCAPS_DEVTYPE_TIMER;
        wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
             0, (uMMSysVer >> 8), (BYTE)uMMSysVer,
             (LPSTR)gszTimerDevice);

        nIndex = ListBox_AddString(hlb, ach);
        lParam = MAKELPARAM(0, (WORD)uDevType);
        ListBox_SetItemData(hlb, nIndex, lParam);
    }
    }



    //
    //
    //
    nDevs = waveInGetNumDevs();
    for (n = -1; n < nDevs; n++)
    {
    WAVEINCAPS      wic;

    mmr = waveInGetDevCaps(n, &wic, sizeof(wic));
    if (MMSYSERR_NOERROR != mmr)
    {
        if (-1 != n)
        {
        wic.vDriverVersion = 0;
        lstrcpy(wic.szPname, gszBogusCaps);
        }
        else
        {
        if (0 == nDevs)
            break;

        wic.vDriverVersion = uMMSysVer;
        lstrcpy(wic.szPname, gszDefaultMapper);
        }
    }

    //
    //
    //
    uDevType = MMCAPS_DEVTYPE_WAVEIN;
    wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
         n, (wic.vDriverVersion >> 8), (BYTE)wic.vDriverVersion,
         (LPSTR)wic.szPname);

    nIndex = ListBox_AddString(hlb, ach);
    lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
    ListBox_SetItemData(hlb, nIndex, lParam);
    }

    //
    //
    //
    nDevs = waveOutGetNumDevs();
    for (n = -1; n < nDevs; n++)
    {
    WAVEOUTCAPS     woc;

    mmr = waveOutGetDevCaps(n, &woc, sizeof(woc));
    if (MMSYSERR_NOERROR != mmr)
    {
        if (-1 != n)
        {
        woc.vDriverVersion = 0;
        lstrcpy(woc.szPname, gszBogusCaps);
        }
        else
        {
        if (0 == nDevs)
            break;

        woc.vDriverVersion = uMMSysVer;
        lstrcpy(woc.szPname, gszDefaultMapper);
        }
    }

    //
    //
    //
    uDevType = MMCAPS_DEVTYPE_WAVEOUT;
    wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType],
         n, (woc.vDriverVersion >> 8), (BYTE)woc.vDriverVersion,
         (LPSTR)woc.szPname);

    nIndex = ListBox_AddString(hlb, ach);
    lParam = MAKELPARAM((WORD)n, (WORD)uDevType);
    ListBox_SetItemData(hlb, nIndex, lParam);
    }

    //
    //
    //
    return (TRUE);
} // MMCapsEnumerateLowLevel()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mmcapsex\zyztlb.c ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  zyztlb.c
//
//  Description:
//
//
//  History:
//       5/18/93
//
//==========================================================================;

#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>

#include "appport.h"
#include "zyztlb.h"

#include "debug.h"


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  int GetRealTextMetrics
//  
//  Description:
//      This function gets the textmetrics of the font currently selected
//      into the hdc.  It returns the average char width as the return value.
//
//      This function computes the average character width correctly by
//      using GetTextExtent() on the string "abc...xzyABC...XYZ" which works
//      out much better for proportional fonts. This is also necessary
//      for correct alignment between dialog and client units.
//
//      Note that this function returns the same TEXTMETRIC values that
//      GetTextMetrics() does, it simply has a different return value.
//
//  Arguments:
//      HDC hdc:
//  
//      LPTEXTMETRIC ptm:
//  
//  Return (int):
//  
//  History:
//      05/11/93
//  
//--------------------------------------------------------------------------;

int FNGLOBAL GetRealTextMetrics
(
    HDC             hdc,
    LPTEXTMETRIC    ptm
)
{
    TCHAR       achAlphabet[26 * 2];    // upper and lower case
    SIZE        sSize;
    UINT        u;
    int         nAveWidth;

    //
    //  get the text metrics of the current font. note that GetTextMetrics
    //  gets the incorrect nAveCharWidth value for proportional fonts.
    //
    GetTextMetrics(hdc, ptm);
    nAveWidth = ptm->tmAveCharWidth;

    //
    //  if it's not a variable pitch font GetTextMetrics was correct
    //  so just return.
    //
    if (ptm->tmPitchAndFamily & FIXED_PITCH)
    {
	//
	//
	//
	for (u = 0; u < 26; u++)
	{
	    achAlphabet[u]      = (TCHAR)(u + (UINT)'a');
	    achAlphabet[u + 26] = (TCHAR)(u + (UINT)'A');
	}

	//
	//  round up
	//
	GetTextExtentPoint(hdc, achAlphabet, SIZEOF(achAlphabet), &sSize);
	nAveWidth = ((sSize.cx / 26) + 1) / 2;
    }

    //
    //  return the calculated average char width
    //
    return (nAveWidth);
} // GetRealTextMetrics()


//==========================================================================;
//
//
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//  
//  BOOL TlbPaint
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//      HWND hwnd:
//  
//      HDC hdc:
//  
//  Return (BOOL):
//  
//  History:
//      05/17/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL TlbPaint
(
    PZYZTABBEDLISTBOX   ptlb,
    HWND                hwnd,
    HDC                 hdc
)
{
    RECT        rc;
    HFONT       hfont;
    COLORREF    crBk;
    COLORREF    crText;
    int         nHeight;

    //
    //
    //
    hfont = GetWindowFont(ptlb->hlb);
    if (NULL == hfont)
	hfont = GetStockFont(SYSTEM_FONT);

    hfont = SelectObject(hdc, hfont);

    crBk   = SetBkColor(hdc, GetSysColor(COLOR_ACTIVECAPTION));
    crText = SetTextColor(hdc, GetSysColor(COLOR_CAPTIONTEXT));

    //
    //  compute bounding rect for title only
    //
    rc = ptlb->rc;
    nHeight = min(ptlb->nFontHeight, rc.bottom - rc.top);
    rc.bottom = rc.top + nHeight;

    ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE, &rc, NULL, 0, NULL);
    TabbedTextOut(hdc, rc.left, rc.top,
		  ptlb->pszTitleText,
		  ptlb->cchTitleText,
		  ptlb->uTabStops,
		  ptlb->panTitleTabs, 0);

    //
    //  restore the dc
    //
    SetBkColor(hdc, crBk);
    SetTextColor(hdc, crText);

    SelectObject(hdc, hfont);

    return (TRUE);
} // TlbPaint()


//--------------------------------------------------------------------------;
//  
//  BOOL TlbMove
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//      PRECT prc:
//  
//      BOOL fRedraw:
//  
//  Return (BOOL):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL TlbMove
(
    PZYZTABBEDLISTBOX   ptlb,
    PRECT               prc,
    BOOL                fRedraw
)
{
    RECT        rc;
    int         nHeight;
    HWND        hwnd;


    hwnd = GetParent(ptlb->hlb);

    //
    //  invalidate only the region occupied by the current title bar. this
    //  will make sure that area gets repainted. the listbox portion will
    //  be invalidated correctly by the SetWindowPos() function below..
    //
    rc = ptlb->rc;

    nHeight = min(ptlb->nFontHeight, rc.bottom - rc.top);
    rc.bottom = rc.top + nHeight;

    InvalidateRect(hwnd, &rc, TRUE);


    //
    //  now move the listbox--we modify values in the rect structure, so
    //  copy to local storage
    //
    rc = *prc;

    //
    //  leave room at the top of the bounding rect for the title text
    //
    nHeight = min(ptlb->nFontHeight, rc.bottom - rc.top);
    rc.top += nHeight;

    SetWindowPos(ptlb->hlb, NULL, rc.left, rc.top, rc.right - rc.left,
		 rc.bottom - rc.top, SWP_NOZORDER);

    //
    //  save the new location and invalidate the area so it is repainted
    //
    ptlb->rc = *prc;
    InvalidateRect(hwnd, prc, TRUE);

    if (fRedraw)
    {
	UpdateWindow(hwnd);
    }

    return (TRUE);
} // TlbMove()


//--------------------------------------------------------------------------;
//  
//  BOOL TlbRecalcTabs
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//  Return (BOOL):
//  
//  History:
//      05/18/93
//  
//--------------------------------------------------------------------------;

BOOL FNLOCAL TlbRecalcTabs
(
    PZYZTABBEDLISTBOX   ptlb
)
{
    static TCHAR szGonzoThing[] = TEXT("M");

    int         anTabsList[TLB_MAX_TAB_STOPS];
    HDC         hdc;
    HFONT       hfont;
    TEXTMETRIC  tm;
    int         nAveCharWidth;

    UINT        u;
    int         nWidth;
    int         nPrevTabTitle;
    int         nPrevTabList;
    SIZE        sSize;


    //
    //
    //
    hdc = GetDC(NULL);
    {
	//
	//  get the average char width and height of the current font so we
	//  can compute tabs correctly. note that GetTextMetrics is pretty
	//  bogus when it comes to the average char width--it normally gives
	//  you the width of the character 'x'. what it should be is the
	//  average width of all capitals and lower case letters..
	//
	hfont = GetWindowFont(ptlb->hlb);
	if (NULL == hfont)
	    hfont = GetStockFont(SYSTEM_FONT);

	hfont = SelectObject(hdc, hfont);

#if 0
	GetTextMetrics(hdc, &tm);
	nAveCharWidth = tm.tmAveCharWidth;
#else
	nAveCharWidth = GetRealTextMetrics(hdc, &tm);
#endif
	ptlb->nFontHeight = tm.tmHeight;


	//
	//
	//
	GetTextExtentPoint(hdc, szGonzoThing, 1, &sSize);


	//
	//
	//
	hfont = SelectObject(hdc, hfont);
    }
    ReleaseDC(NULL, hdc);


    //
    //  calculate the width of each column
    //
    nPrevTabTitle = 0;
    nPrevTabList  = 0;
    for (u = 0; u < ptlb->uTabStops; u++)
    {
//      nWidth = nAveCharWidth * ptlb->panTabs[u] + nAveCharWidth * 2;
	nWidth = sSize.cx * ptlb->panTabs[u] + (sSize.cx * 2);

	//
	//  set tabstop for title text--this is in client units
	//  for TabbedTextOut in TlbPaint
	//
	ptlb->panTitleTabs[u] = nPrevTabTitle + nWidth;
	nPrevTabTitle = ptlb->panTitleTabs[u];

	//
	//  set tabstop for listbox--this is in dialog units
	//
	anTabsList[u] = nPrevTabList + MulDiv(nWidth, 4, nAveCharWidth);
	nPrevTabList  = anTabsList[u];
    }


    //
    //  now setup the tabstops in the listbox
    //
    ListBox_SetTabStops(ptlb->hlb, ptlb->uTabStops, anTabsList);

    return (TRUE);
} // TlbRecalcTabs()


//--------------------------------------------------------------------------;
//  
//  HFONT TlbSetFont
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//      HFONT hfont:
//  
//      BOOL fRedraw:
//  
//  Return (HFONT):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

HFONT FNGLOBAL TlbSetFont
(
    PZYZTABBEDLISTBOX   ptlb,
    HFONT               hfont,
    BOOL                fRedraw
)
{
    HFONT       hfontOld;

    //
    //
    //
    hfontOld = GetWindowFont(ptlb->hlb);
    SetWindowFont(ptlb->hlb, hfont, FALSE);

    TlbRecalcTabs(ptlb);
    TlbMove(ptlb, &ptlb->rc, fRedraw);

    return (hfontOld);
} // TlbSetFont()


//--------------------------------------------------------------------------;
//  
//  BOOL TlbSetTitleAndTabs
//  
//  Description:
//      This function sets the title text and tab stops for a Tabbed List
//      Box (TLB). The pszTitleFormat specifies the title text for each
//      column along with the tabstop position for each column. The format
//      of this string is as follows:
//
//      <columnname1>\t<tab1>!<columnname2>
//
//      TCHAR   szTlbThings[] = TEXT("Index\t6!Code\t5!Name");
//
//
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//      PTSTR pszTitleFormat:
//
//      BOOL fRedraw:
//  
//  Return (BOOL):
//  
//  History:
//      05/18/93
//  
//--------------------------------------------------------------------------;

BOOL FNGLOBAL TlbSetTitleAndTabs
(
    PZYZTABBEDLISTBOX   ptlb,
    PTSTR               pszTitleFormat,
    BOOL                fRedraw
)
{
    TCHAR       szTitleText[TLB_MAX_TITLE_CHARS];
    int         anTabs[TLB_MAX_TAB_STOPS];
    PTSTR       pch;
    PTSTR       pchTitleText;
    UINT        uTabStops;
    UINT        cchTitleText;
    HWND        hwnd;

    //
    //  parse the title format counting tab stops and actual size of title
    //  text
    //
    uTabStops    = 0;
    pchTitleText = szTitleText;
    for (pch = pszTitleFormat; '\0' != *pch; )
    {
	TCHAR       ch;

	//
	//  scan to tab
	//
	while ('\0' != (ch = *pch))
	{
	    *pchTitleText++ = *pch++;

	    if ('\t' == ch)
		break;
	}

	if ('\0' == ch)
	    break;

	//
	//  grab the next tab stop value
	//
	anTabs[uTabStops] = atoi(pch);
	uTabStops++;

	//
	//  skip to start of next column name
	//
	while ('!' != *pch++)
	    ;
    }


    //
    //  terminate the converted title text
    //
    *pchTitleText = '\0';
    cchTitleText = lstrlen(szTitleText);

    //
    //  free the memory used for the previous tab stops and title text
    //
    if (NULL != ptlb->panTabs)
    {
	LocalFree((HLOCAL)ptlb->panTabs);

	ptlb->uTabStops    = 0;
	ptlb->panTabs      = NULL;
	ptlb->panTitleTabs = NULL;
    }

    if (NULL != ptlb->pszTitleText)
    {
	LocalFree((HLOCAL)ptlb->pszTitleText);

	ptlb->cchTitleText = 0;
	ptlb->pszTitleText = NULL;
    }


    //
    //  allocate new space for tab stops. there are two different tab
    //  arrays:
    //
    //      panTabs: original tab values as passed by caller. these are
    //      virtual tab locations represented as number of characters. we
    //      need to keep these values for recomputing the real tabs when
    //      the font changes.
    //
    //      panTitleTabs: these values are computed by TlbRecalcTabs and
    //      are actual tab positions in client coordinates for the title
    //      text (needed for TabbedTextOut in TlbPaint).
    //
    //  the tabs for the listbox are computed and set in TlbRecalcTabs
    //
    if (0 != uTabStops)
    {
	ptlb->panTabs = (PINT)LocalAlloc(LPTR, (uTabStops * sizeof(int)) * 2);
	if (NULL == ptlb->panTabs)
	    return (FALSE);

	ptlb->uTabStops    = uTabStops;
	ptlb->panTitleTabs = ptlb->panTabs + uTabStops;
	memcpy(ptlb->panTabs, anTabs, uTabStops * sizeof(int));
    }


    //
    //  allocate space for the converted title text (stripped of the tab
    //  spacing values). this string is passed directly to TabbedTextOut
    //  in TlbPaint.
    //
    if (0 != cchTitleText)
    {
	ptlb->pszTitleText = (PTSTR)LocalAlloc(LPTR, (cchTitleText + 1) * sizeof(TCHAR));
	if (NULL == ptlb->pszTitleText)
	    return (FALSE);

	ptlb->cchTitleText = cchTitleText;
	lstrcpy(ptlb->pszTitleText, szTitleText);
    }



    //
    //
    //
    TlbRecalcTabs(ptlb);


    //
    //  force a complete repaint of the title text and listbox--redraw
    //  immediately if we are supposed to
    //
    hwnd = GetParent(ptlb->hlb);
    InvalidateRect(hwnd, &ptlb->rc, TRUE);
    if (fRedraw)
    {
	UpdateWindow(hwnd);
    }

    return (TRUE);
} // TlbSetTitleAndTabs()


//--------------------------------------------------------------------------;
//  
//  PZYZTABBEDLISTBOX TlbDestroy
//  
//  Description:
//  
//  
//  Arguments:
//      PZYZTABBEDLISTBOX ptlb:
//  
//  Return (PZYZTABBEDLISTBOX):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

PZYZTABBEDLISTBOX FNGLOBAL TlbDestroy
(
    PZYZTABBEDLISTBOX   ptlb
)
{
    HWND        hwnd;
    int         nHeight;

    //
    //  get rid of the listbox
    //
    if (NULL != ptlb->hlb)
    {
	DestroyWindow(ptlb->hlb);

	//
	//  invalidate area where title text was so it will be clean
	//
	nHeight = min(ptlb->nFontHeight, ptlb->rc.bottom - ptlb->rc.top);
	ptlb->rc.bottom = ptlb->rc.top + nHeight;

	hwnd = GetParent(ptlb->hlb);
	InvalidateRect(hwnd, &ptlb->rc, TRUE);


	//
	//  free the memory used for tab stops and title text
	//
	if (NULL != ptlb->panTabs)
	    LocalFree((HLOCAL)ptlb->panTabs);

	if (NULL != ptlb->pszTitleText)
	    LocalFree((HLOCAL)ptlb->pszTitleText);
    }

    LocalFree((HLOCAL)ptlb);

    return (NULL);
} // TlbDestroy()


//--------------------------------------------------------------------------;
//  
//  PZYZTABBEDLISTBOX TlbCreate
//  
//  Description:
//  
//  
//  Arguments:
//      HWND hwnd:
//  
//      int nId:
//  
//      PRECT prc:
//  
//  Return (PZYZTABBEDLISTBOX):
//  
//  History:
//      05/16/93
//  
//--------------------------------------------------------------------------;

PZYZTABBEDLISTBOX FNGLOBAL TlbCreate
(
    HWND                hwnd,
    int                 nId,
    PRECT               prc
)
{
    #define TLB_DEF_STYLE   (WS_VISIBLE|WS_CHILD|WS_VSCROLL|WS_BORDER|  \
			     LBS_NOTIFY|LBS_NOINTEGRALHEIGHT|LBS_USETABSTOPS)

    static TCHAR    szNull[]    = TEXT("");
    static TCHAR    szListBox[] = TEXT("ListBox");

    PZYZTABBEDLISTBOX   ptlb;
    HINSTANCE           hinst;


    //
    //  create a new instance data structure..
    //
    ptlb = (PZYZTABBEDLISTBOX)LocalAlloc(LPTR, sizeof(*ptlb));
    if (NULL == ptlb)
	return (NULL);


    //
    //  create the listbox
    //
    hinst = GetWindowInstance(hwnd);

    ptlb->hlb = CreateWindow(szListBox, szNull, TLB_DEF_STYLE,
			     0, 0, 0, 0, hwnd, (HMENU)nId, hinst, NULL);
    if (NULL == ptlb->hlb)
    {
	TlbDestroy(ptlb);
	return (NULL);
    }

    TlbRecalcTabs(ptlb);

    if (NULL != prc)
    {
	ptlb->rc = *prc;
	TlbMove(ptlb, prc, FALSE);
    }

    return (ptlb);
} // TlbCreate()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\mmcapsex\zyztlb.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
//  A PARTICULAR PURPOSE.
//
//  Copyright (C) 1993 - 1995 Microsoft Corporation. All Rights Reserved.
//
//--------------------------------------------------------------------------;
//==========================================================================;
//
//  zyztlb.h
//
//  Description:
//
//
//  History:
//       5/18/93
//
//==========================================================================;


//
//
//
//
typedef struct tZYZTABBEDLISTBOX
{
    HWND            hlb;

    int             nFontHeight;
    RECT            rc;

    UINT            uTabStops;
    PINT            panTabs;
    PINT            panTitleTabs;

    UINT            cchTitleText;
    PTSTR           pszTitleText;

} ZYZTABBEDLISTBOX, *PZYZTABBEDLISTBOX;


#define TLB_MAX_TAB_STOPS           20      // max number of columns
#define TLB_MAX_TITLE_CHARS         512


//
//
//
//
//
BOOL FNGLOBAL TlbPaint
(
    PZYZTABBEDLISTBOX   ptlb,
    HWND                hwnd,
    HDC                 hdc
);

BOOL FNGLOBAL TlbMove
(
    PZYZTABBEDLISTBOX   ptlb,
    PRECT               prc,
    BOOL                fRedraw
);

HFONT FNGLOBAL TlbSetFont
(
    PZYZTABBEDLISTBOX   ptlb,
    HFONT               hfont,
    BOOL                fRedraw
);

BOOL FNGLOBAL TlbSetTitleAndTabs
(
    PZYZTABBEDLISTBOX   ptlb,
    PTSTR               pszTitleFormat,
    BOOL                fRedraw
);

PZYZTABBEDLISTBOX FNGLOBAL TlbDestroy
(
    PZYZTABBEDLISTBOX   ptlb
);

PZYZTABBEDLISTBOX FNGLOBAL TlbCreate
(
    HWND                hwnd,
    int                 nId,
    PRECT               prc
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\reverse\reverse.h ===
/* reverse.h - Header file for REVERSE sample application.
 */


/*
 *  Constants
 */

// Child window identifiers
#define IDE_NAME        200
#define IDB_PLAY        201
#define IDB_QUIT        202

// Window Position and size definitions
#define WMAIN_DX        207
#define WMAIN_DY        120
#define NAME_DX         180
#define NAME_DY         30
#define NAME_X          10
#define NAME_Y          10
#define PLAY_DX         85
#define PLAY_DY         35
#define PLAY_X          10
#define PLAY_Y          50
#define QUIT_DX         85
#define QUIT_DY         35
#define QUIT_X          105
#define QUIT_Y          50

#define IDM_ABOUT           0x101

/*
 * Data Types
 */
typedef struct waveInst {
    HANDLE hWaveInst;
    HANDLE hWaveHdr;
    HANDLE hWaveData;
} WAVEINST;

typedef WAVEINST FAR *LPWAVEINST;

/*
 *  Function prototypes
 */
BOOL FAR PASCAL AppAbout(HWND, unsigned, UINT, LONG);
LONG FAR PASCAL WndProc(HWND, unsigned ,UINT, LONG);
void Interchange(HPSTR, HPSTR, unsigned);
void ReversePlay(void);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\setup\makefile.inc ===
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF


!IF "$(TARGET_DIRECTORY)"=="i386"  || "$(TARGET_DIRECTORY)"=="I386"
PLATFORM_SWITCH=i
!ELSEIF "$(TARGET_DIRECTORY)"=="amd64"  || "$(TARGET_DIRECTORY)"=="AMD64"
PLATFORM_SWITCH=a
!ELSEIF "$(TARGET_DIRECTORY)"=="ia64"  || "$(TARGET_DIRECTORY)"=="IA64"
PLATFORM_SWITCH=m
!ELSE
! ERROR Invalid Platform Switch for infs
!ENDIF


_LNG=$(LANGUAGE)
_INX=.
_INF=obj\$(TARGET_DIRECTORY)
STAMP=stampinf -f $@

make_infs:$(_INF)\wave.inf      \
          $(_INF)\wdmaudio.inf  \
          $(_INF)\wdma10k1.inf  \
          $(_INF)\wdma_ali.inf  \
          $(_INF)\wdma_aur.inf  \
          $(_INF)\wdma_azt.inf  \
          $(_INF)\wdma_csc.inf  \
          $(_INF)\wdma_csf.inf  \
          $(_INF)\wdma_ctl.inf  \
          $(_INF)\wdma_cwr.inf  \
          $(_INF)\wdma_ens.inf  \
          $(_INF)\wdma_ess.inf  \
          $(_INF)\wdma_es2.inf  \
          $(_INF)\wdma_es3.inf  \
          $(_INF)\wdma_int.inf  \
          $(_INF)\wdma_m2e.inf  \
          $(_INF)\wdma_neo.inf  \
          $(_INF)\wdma_ne2.inf  \
          $(_INF)\wdma_rip.inf  \
          $(_INF)\wdma_sis.inf  \
          $(_INF)\wdma_usb.inf  \
          $(_INF)\wdma_via.inf  \
          $(_INF)\wdma_avc.inf  \
          $(_INF)\wdma_ymh.inf  \
          $(_INF)\wdma_ym2.inf  \
          $(_INF)\adm_mult.inf  \
          $(_INF)\adm_port.inf  \
          $(_INF)\mssb16.inf


#
# Explicit dependencies. We do it this way instead of trying to use rules
# because !#@&^$#% nmake doesn't allow multiple 'source' extensions
# when defining a rule, and we need to express a dependency between
# .txt OR .inx to the final .inf.
#


$(_INF)\wave.inf: $(_INX)\wave.inx $(_LNG)\wave.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdmaudio.inf: $(_INX)\wdmaudio.inx $(_LNG)\wdmaudio.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp2 >$@
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma10k1.inf: $(_INX)\wdma10k1.inx $(_LNG)\wdma10k1.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)


$(_INF)\wdma_ali.inf: $(_INX)\wdma_ali.inx $(_LNG)\wdma_ali.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_aur.inf: $(_INX)\wdma_aur.inx $(_LNG)\wdma_aur.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_azt.inf: $(_INX)\wdma_azt.inx $(_LNG)\wdma_azt.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_csc.inf: $(_INX)\wdma_csc.inx $(_LNG)\wdma_csc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_csf.inf: $(_INX)\wdma_csf.inx $(_LNG)\wdma_csf.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_ctl.inf: $(_INX)\wdma_ctl.inx $(_LNG)\wdma_ctl.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_cwr.inf: $(_INX)\wdma_cwr.inx $(_LNG)\wdma_cwr.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp2 >$@
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(BINPLACE_CMD)


$(_INF)\wdma_ens.inf: $(_INX)\wdma_ens.inx $(_LNG)\wdma_ens.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)
    
$(_INF)\wdma_ess.inf: $(_INX)\wdma_ess.inx $(_LNG)\wdma_ess.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_es2.inf: $(_INX)\wdma_es2.inx $(_LNG)\wdma_es2.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_es3.inf: $(_INX)\wdma_es3.inx $(_LNG)\wdma_es3.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_int.inf: $(_INX)\wdma_int.inx $(_LNG)\wdma_int.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)


$(_INF)\wdma_m2e.inf: $(_INX)\wdma_m2e.inx $(_LNG)\wdma_m2e.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_neo.inf: $(_INX)\wdma_neo.inx $(_LNG)\wdma_neo.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_ne2.inf: $(_INX)\wdma_ne2.inx $(_LNG)\wdma_ne2.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_rip.inf: $(_INX)\wdma_rip.inx $(_LNG)\wdma_rip.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_sis.inf: $(_INX)\wdma_sis.inx $(_LNG)\wdma_sis.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_usb.inf: $(_INX)\wdma_usb.inx $(_LNG)\wdma_usb.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_via.inf: $(_INX)\wdma_via.inx $(_LNG)\wdma_via.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_avc.inf: $(_INX)\wdma_avc.inx $(_LNG)\wdma_avc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_ymh.inf: $(_INX)\wdma_ymh.inx $(_LNG)\wdma_ymh.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\wdma_ym2.inf: $(_INX)\wdma_ym2.inx $(_LNG)\wdma_ym2.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\adm_mult.inf: $(_INX)\adm_mult.inx $(_LNG)\adm_mult.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\adm_port.inf: $(_INX)\adm_port.inx $(_LNG)\adm_port.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)

$(_INF)\mssb16.inf: $(_INX)\mssb16.inx $(_LNG)\mssb16.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(@B).tmp1 >$@
    @del $(@B).tmp1
    $(STAMP)
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\samples\reverse\reverse.c ===
/* reverse.c - WinMain() and WndProc() for REVERSE, along with
 *      initialization and support code.
 *
 * REVERSE is a Windows with Multimedia sample application that
 *  illustrates how to use the low-level waveform playback services.
 *  It also shows how to use the multimedia file I/O services to read
 *  data from a WAVE file.
 *
 *  REVERSE plays a WAVE waveform audio file backwards.
 *
 *    (C) Copyright Microsoft Corp. 1991, 1992.  All rights reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 *
 */

#include <windows.h>
#include <mmsystem.h>
#include "reverse.h"

#define MAX_FILENAME_SIZE   128

/* Global variables.
 */
char        szAppName[] = "Reverse";    // application name
HANDLE      hInstApp    = NULL;         // instance handle
HWND        hwndApp     = NULL;         // main window handle
HWND        hwndName    = NULL;         // filename window handle
HWND        hwndPlay    = NULL;         // "Play" button window handle
HWND        hwndQuit    = NULL;         // "Exit" button window handle
HWAVEOUT    hWaveOut    = NULL;
LPWAVEHDR   lpWaveHdr   = NULL;
VOID        cleanup(LPWAVEINST lpWaveInst);


/* WinMain - Entry point for Reverse.
 */
int PASCAL WinMain(HANDLE hInst, HANDLE hPrev, LPSTR szCmdLine, int cmdShow)
{
    MSG         msg;
    WNDCLASS    wc;

    hInstApp =  hInst;

    /* Define and register a window class for the main window.
     */
    if (!hPrev)
    {
        wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon          = LoadIcon(hInst, szAppName);
        wc.lpszMenuName   = szAppName;
        wc.lpszClassName  = szAppName;
        wc.hbrBackground  = GetStockObject(LTGRAY_BRUSH);
        wc.hInstance      = hInst;
        wc.style          = 0;
        wc.lpfnWndProc    = WndProc;
        wc.cbWndExtra     = 0;
        wc.cbClsExtra     = 0;

        if (!RegisterClass(&wc))
        return FALSE;
    }

    /* Create and show the main window.
     */
    hwndApp = CreateWindow (szAppName,              // class name
                            szAppName,              // caption
                            WS_OVERLAPPEDWINDOW,    // style bits
                            CW_USEDEFAULT,          // x position
                            CW_USEDEFAULT,          // y position
                            WMAIN_DX,               // x size
                            WMAIN_DY,               // y size
                            (HWND)NULL,             // parent window
                            (HMENU)NULL,            // use class menu
                            (HANDLE)hInst,          // instance handle
                            (LPSTR)NULL             // no params to pass on
                           );
    /* Create child windows for the "Play" and "Exit" buttons
     * and for an edit field to enter filenames.
     */
    hwndPlay = CreateWindow( "BUTTON", "Play",
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            PLAY_X, PLAY_Y,
            PLAY_DX, PLAY_DY,
            hwndApp, (HMENU)IDB_PLAY, hInstApp, NULL );
    if( !hwndPlay )
        return( FALSE );

    hwndQuit = CreateWindow( "BUTTON", "Exit",
            WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON,
            QUIT_X, QUIT_Y,
            QUIT_DX, QUIT_DY,
            hwndApp, (HMENU)IDB_QUIT, hInstApp, NULL );
    if( !hwndQuit )
        return( FALSE );

    hwndName = CreateWindow("EDIT","",
            WS_CHILD|WS_VISIBLE|WS_BORDER|ES_AUTOHSCROLL,
            NAME_X, NAME_Y,
            NAME_DX, NAME_DY,
            hwndApp, (HMENU)IDE_NAME, hInstApp, NULL);
    if( !hwndName )
        return( FALSE );
    SendMessage(hwndName, EM_LIMITTEXT, MAX_FILENAME_SIZE - 1, 0);

    ShowWindow(hwndApp,cmdShow);

    /* Add about dialog to system menu.
     */
    AppendMenu(GetSystemMenu(hwndApp, 0),
        MF_STRING | MF_ENABLED, IDM_ABOUT, "About Reverse...");


  /* The main message processing loop. Nothing special here.
   */
  while (GetMessage(&msg,NULL,0,0))
  {
      TranslateMessage(&msg);
      DispatchMessage(&msg);
  }

  return msg.wParam;
}


/* WndProc - Main window procedure function.
 */
LONG FAR PASCAL WndProc(HWND hWnd, unsigned msg, UINT wParam, LONG lParam)
{
    FARPROC fpfn;
    LPWAVEINST lpWaveInst;

    switch (msg)
    {
    case WM_DESTROY:
        if (hWaveOut)
	{
  	   waveOutReset(hWaveOut);	
           waveOutUnprepareHeader(hWaveOut, lpWaveHdr, sizeof(WAVEHDR) );
           lpWaveInst = (LPWAVEINST) lpWaveHdr->dwUser;
	   cleanup(lpWaveInst);
           waveOutClose(hWaveOut);	
        }
        PostQuitMessage(0);
        break;

    case WM_SYSCOMMAND:
        switch (LOWORD(wParam))
        {
        case IDM_ABOUT:
            /* Show ABOUTBOX dialog box.
             */
            fpfn = MakeProcInstance((FARPROC)AppAbout, hInstApp);  // no op in 32 bit
            DialogBox(hInstApp, "ABOUTBOX", hWnd, (DLGPROC)fpfn);
            FreeProcInstance(fpfn);
            break;
        }
        break;

    /* Process messages sent by the child window controls.
     */
    case WM_SETFOCUS:
        SetFocus(hwndName);
        return 0;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDE_NAME:              // filename edit control
            return( 0L );

        case IDB_PLAY:              // "Play" button
            if (HIWORD(wParam) == BN_CLICKED)
                ReversePlay();
            break;

        case IDB_QUIT:              // "Exit" button
            if (HIWORD(wParam) == BN_CLICKED)
                PostQuitMessage(0);
            break;
        }
        return( 0L );

    case MM_WOM_DONE:
        /* This message indicates a waveform data block has
         * been played and can be freed. Clean up the preparation
         * done previously on the header.
         */
        waveOutUnprepareHeader( (HWAVEOUT) wParam,
                                (LPWAVEHDR) lParam, sizeof(WAVEHDR) );

        /* Get a pointer to the instance data, then unlock and free
         * all memory associated with the data block, including the
         * memory for the instance data itself.
         */
        lpWaveInst = (LPWAVEINST) ((LPWAVEHDR)lParam)->dwUser;
	cleanup(lpWaveInst);
        /* Close the waveform output device.
         */
        waveOutClose( (HWAVEOUT) wParam );

        /* Reenable both button controls.
         */
        EnableWindow( hwndPlay, TRUE );
        EnableWindow( hwndQuit, TRUE );
        SetFocus(hwndName);

        break;
    }

    return DefWindowProc(hWnd,msg,wParam,lParam);
}


/* AppAbout -- Dialog procedure for ABOUTBOX  dialog box.
 */
BOOL FAR PASCAL AppAbout(HWND hDlg, unsigned msg, unsigned wParam, LONG lParam)
{
    switch (msg)
    {
    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK)
            EndDialog(hDlg,TRUE);
        break;

    case WM_INITDIALOG:
        return TRUE;
    }
    return FALSE;
}

/* ReversePlay - Gets a filename from the edit control, then uses
 *  the multimedia file I/O services to read data from the requested
 *  WAVE file. If the file is a proper WAVE file, ReversePlay() calls
 *  the Interchange() function to reverse the order of the waveform
 *  samples in the file. It then plays the reversed waveform data.
 *
 *  Note that ReversePlay() only handles a single waveform data block.
 *  If the requested WAVE file will not fit in a single data block, it
 *  will not be played. The size of a single data block depends on the
 *  amount of available system memory.
 *
 * Params:  void
 *
 * Return:  void
 */
void ReversePlay()
{
    HANDLE          hWaveHdr;
    LPWAVEINST      lpWaveInst;
    HMMIO           hmmio;
    MMCKINFO        mmckinfoParent;
    MMCKINFO        mmckinfoSubchunk;
    DWORD           dwFmtSize;
    char            szFileName[ MAX_FILENAME_SIZE ];
    HANDLE          hFormat;
    WAVEFORMAT      *pFormat;
    DWORD           dwDataSize;
    HPSTR           hpch1, hpch2;
    WORD            wBlockSize;
    HANDLE          hWaveInst;
    HANDLE          hData       = NULL;
    HPSTR           lpData      = NULL;

    /* Get the filename from the edit control.
     */
    if (!GetWindowText( hwndName, (LPSTR)szFileName, MAX_FILENAME_SIZE))
    {
        MessageBox(hwndApp, "Failed to Get Filename",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    /* Open the given file for reading using buffered I/O.
     */
    if(!(hmmio = mmioOpen(szFileName, NULL, MMIO_READ | MMIO_ALLOCBUF)))
    {
        MessageBox(hwndApp, "Failed to open file.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    /* Locate a 'RIFF' chunk with a 'WAVE' form type
     * to make sure it's a WAVE file.
     */
    mmckinfoParent.fccType = mmioFOURCC('W', 'A', 'V', 'E');
    if (mmioDescend(hmmio, (LPMMCKINFO) &mmckinfoParent, NULL, MMIO_FINDRIFF))
    {
        MessageBox(hwndApp, "This is not a WAVE file.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        mmioClose(hmmio, 0);
        return;
    }

    /* Now, find the format chunk (form type 'fmt '). It should be
     * a subchunk of the 'RIFF' parent chunk.
     */
    mmckinfoSubchunk.ckid = mmioFOURCC('f', 'm', 't', ' ');
    if (mmioDescend(hmmio, &mmckinfoSubchunk, &mmckinfoParent,
        MMIO_FINDCHUNK))
    {
        MessageBox(hwndApp, "WAVE file is corrupted.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        mmioClose(hmmio, 0);
        return;
    }

    /* Get the size of the format chunk, allocate and lock memory for it.
     */
    dwFmtSize = mmckinfoSubchunk.cksize;
    hFormat = LocalAlloc(LMEM_MOVEABLE, LOWORD(dwFmtSize));
    if (!hFormat)
    {
        MessageBox(hwndApp, "Out of memory.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        mmioClose(hmmio, 0);
        return;
    }
    pFormat = (WAVEFORMAT *) LocalLock(hFormat);
    if (!pFormat)
    {
        MessageBox(hwndApp, "Failed to lock memory for format chunk.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        LocalFree( hFormat );
        mmioClose(hmmio, 0);
        return;
    }

    /* Read the format chunk.
     */
    if (mmioRead(hmmio, (HPSTR) pFormat, dwFmtSize) != (LONG) dwFmtSize)
    {
        MessageBox(hwndApp, "Failed to read format chunk.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        LocalUnlock( hFormat );
        LocalFree( hFormat );
        mmioClose(hmmio, 0);
        return;
    }

    /* Make sure it's a PCM file.
     */
    if (pFormat->wFormatTag != WAVE_FORMAT_PCM)
    {
        LocalUnlock( hFormat );
        LocalFree( hFormat );
        mmioClose(hmmio, 0);
        MessageBox(hwndApp, "The file is not a PCM file.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    /* Make sure a waveform output device supports this format.
     */
    if (waveOutOpen(&hWaveOut, WAVE_MAPPER, (LPWAVEFORMAT)pFormat, 0L, 0L,
                    WAVE_FORMAT_QUERY))
    {
        LocalUnlock( hFormat );
        LocalFree( hFormat );
        mmioClose(hmmio, 0);
        MessageBox(hwndApp, "The waveform device can't play this format.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    /* Ascend out of the format subchunk.
     */
    mmioAscend(hmmio, &mmckinfoSubchunk, 0);

    /* Find the data subchunk.
     */
    mmckinfoSubchunk.ckid = mmioFOURCC('d', 'a', 't', 'a');
    if (mmioDescend(hmmio, &mmckinfoSubchunk, &mmckinfoParent,
        MMIO_FINDCHUNK))
    {
        MessageBox(hwndApp, "WAVE file has no data chunk.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        LocalUnlock( hFormat );
        LocalFree( hFormat );
        mmioClose(hmmio, 0);
        return;
    }

    /* Get the size of the data subchunk.
     */
    dwDataSize = mmckinfoSubchunk.cksize;
    if (dwDataSize == 0L)
    {
        MessageBox(hwndApp, "The data chunk has no data.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        LocalUnlock( hFormat );
        LocalFree( hFormat );
        mmioClose(hmmio, 0);
        return;
    }

    /* Open a waveform output device.
     */
    if (waveOutOpen((LPHWAVEOUT)&hWaveOut, WAVE_MAPPER,
                  (LPWAVEFORMAT)pFormat, (UINT)hwndApp, 0L, CALLBACK_WINDOW))
    {
        MessageBox(hwndApp, "Failed to open waveform output device.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        LocalUnlock( hFormat );
        LocalFree( hFormat );
        mmioClose(hmmio, 0);
        return;
    }

    /* Save block alignment info for later use.
     */
    wBlockSize = pFormat->nBlockAlign;

    /* We're done with the format header, free it.
     */
    LocalUnlock( hFormat );
    LocalFree( hFormat );

    /* Allocate and lock memory for the waveform data.
     */
    hData = GlobalAlloc(GMEM_MOVEABLE , dwDataSize );
                       /* GMEM_SHARE is not needed on 32 bits */
    if (!hData)
    {
        MessageBox(hwndApp, "Out of memory.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        mmioClose(hmmio, 0);
        return;
    }
    lpData = GlobalLock(hData);
    if (!lpData)
    {
        MessageBox(hwndApp, "Failed to lock memory for data chunk.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        GlobalFree( hData );
        mmioClose(hmmio, 0);
        return;
    }

    /* Read the waveform data subchunk.
     */
    if(mmioRead(hmmio, (HPSTR) lpData, dwDataSize) != (LONG) dwDataSize)
    {
        MessageBox(hwndApp, "Failed to read data chunk.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        GlobalUnlock( hData );
        GlobalFree( hData );
        mmioClose(hmmio, 0);
        return;
    }

    /* We're done with the file, close it.
     */
    mmioClose(hmmio, 0);

    /* Reverse the sound for playing.
     */
    hpch1 = lpData;
    hpch2 = lpData + dwDataSize - 1;
    while (hpch1 < hpch2)
    {
        Interchange( hpch1, hpch2, wBlockSize );
        hpch1 += wBlockSize;
        hpch2 -= wBlockSize;
    }

    /* Allocate a waveform data header. The WAVEHDR must be
     * globally allocated and locked.
     */
    hWaveHdr = GlobalAlloc(GMEM_MOVEABLE, (DWORD) sizeof(WAVEHDR));
    if (!hWaveHdr)
    {
        GlobalUnlock( hData );
        GlobalFree( hData );
        MessageBox(hwndApp, "Not enough memory for header.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        return;
    }
    lpWaveHdr = (LPWAVEHDR) GlobalLock(hWaveHdr);
    if (!lpWaveHdr)
    {
        GlobalUnlock( hData );
        GlobalFree( hData );
        GlobalFree( hWaveHdr );
        MessageBox(hwndApp, "Failed to lock memory for header.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    /* Allocate and set up instance data for waveform data block.
     * This information is needed by the routine that frees the
     * data block after it has been played.
     */
    hWaveInst = GlobalAlloc(GMEM_MOVEABLE, (DWORD) sizeof(WAVEHDR));
    if (!hWaveInst)
    {
        GlobalUnlock( hData );
        GlobalFree( hData );
        GlobalUnlock( hWaveHdr );
        GlobalFree( hWaveHdr );
        MessageBox(hwndApp, "Not enough memory for instance data.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        return;
    }
    lpWaveInst = (LPWAVEINST) GlobalLock(hWaveInst);
    if (!lpWaveInst)
    {
        GlobalUnlock( hData );
        GlobalFree( hData );
        GlobalUnlock( hWaveHdr );
        GlobalFree( hWaveHdr );
        GlobalFree( hWaveInst );
        MessageBox(hwndApp, "Failed to lock memory for instance data.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);
        return;
    }
    lpWaveInst->hWaveInst = hWaveInst;
    lpWaveInst->hWaveHdr = hWaveHdr;
    lpWaveInst->hWaveData = hData;

    /* Set up WAVEHDR structure and prepare it to be written to wave device.
     */
    lpWaveHdr->lpData = lpData;
    lpWaveHdr->dwBufferLength = dwDataSize;
    lpWaveHdr->dwFlags = 0L;
    lpWaveHdr->dwLoops = 0L;
    lpWaveHdr->dwUser = (DWORD) lpWaveInst;
    if(waveOutPrepareHeader(hWaveOut, lpWaveHdr, sizeof(WAVEHDR)))
    {
        GlobalUnlock( hData );
        GlobalFree( hData );
        GlobalUnlock( hWaveHdr );
        GlobalFree( hWaveHdr );
        GlobalUnlock( hWaveInst );
        GlobalFree( hWaveInst );
        MessageBox(hwndApp, "Unable to prepare wave header.",
                   NULL, MB_OK | MB_ICONEXCLAMATION);

        return;
    }

    /* Then the data block can be sent to the output device.
     */
    {   MMRESULT        mmResult;
        mmResult = waveOutWrite(hWaveOut, lpWaveHdr, sizeof(WAVEHDR));
        if (mmResult != 0)
        {
            waveOutUnprepareHeader( hWaveOut, lpWaveHdr, sizeof(WAVEHDR));
            GlobalUnlock( hData );
            GlobalFree( hData );
            MessageBox(hwndApp, "Failed to write block to device",
                       NULL, MB_OK | MB_ICONEXCLAMATION);
            return;
        }
    }

    /* Disable input to the button controls.
     */
    EnableWindow(hwndPlay, FALSE);
    EnableWindow(hwndQuit, FALSE);
}

/* Interchange - Interchanges two samples at the given positions.
 *
 * Params:  hpchPos1 - Points to one sample.
 *          hpchPos2 - Points to the other sample.
 *          wLength  - The length of a sample in bytes.
 *
 * Return:  void
 */
void Interchange(HPSTR hpchPos1, HPSTR hpchPos2, unsigned uLength)
{
    unsigned    uPlace;
    BYTE    bTemp;

    for (uPlace = 0; uPlace < uLength; uPlace++)
    {
        bTemp = hpchPos1[uPlace];
        hpchPos1[uPlace] = hpchPos2[uPlace];
        hpchPos2[uPlace] = bTemp;
    }
}

VOID cleanup(LPWAVEINST lpWaveInst)
{
    GlobalUnlock( lpWaveInst->hWaveData );
    GlobalFree( lpWaveInst->hWaveData );
    GlobalUnlock( lpWaveInst->hWaveHdr );
    GlobalFree( lpWaveInst->hWaveHdr );
    GlobalUnlock( lpWaveInst->hWaveInst );
    GlobalFree( lpWaveInst->hWaveInst );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\clsdesc.cxx ===
//+---------------------------------------------------------------------
//
//   File:       clsdesc.cxx
//
//   Contents:   ClassDescriptor implementation
//
//------------------------------------------------------------------------

//[ classdescriptor_overview
/*
                        ClassDescriptor Overview

A ClassDescriptor is a structure the contains global, static information
about an OLE Compound Document class.  Having a ClassDescriptor allows
the base classes to do a lot of work on behalf of the derived class because
it can get information it needs from the ClassDescriptor instead of resorting
to virtual method calls.  A single ClassDescriptor is shared by all object
instances of that Compound Document class.

A ClassDescriptor has three conceptual parts.  The first part is a collection
of information loaded from resources.  This includes strings, menus, accelerators,
and an icon.  The second part is a pair of verb tables that are used to implement
IOleObject::DoVerb.  The third part is two pairs of format tables that are
used to implement many of the Get/Set/Query methods on IDataObject.
Each of these parts has its own initialization method to prepare that part of
the class descriptor.

The ClassDescriptor is usually associated with the ClassFactory.

*/
//]

#include "headers.hxx"
#pragma hdrstop

#define MAX_USERTYPE_LEN 64

//+---------------------------------------------------------------
//
//  Member:     ClassDescriptor::ClassDescriptor
//
//  Synopsis:   Constructor for ClassDescriptor structure
//
//  Notes:      A DLL (in-process) server should allocate the class
//              descriptor at library initialization time and allocate
//              it in shared memory (GMEM_SHARE flag with GlobalAlloc, or
//              the OLE shared allocator, MEMCTX_SHARED).
//
//              The constructor ensures all members of the structure
//              are initialized to NULL
//
//----------------------------------------------------------------

ClassDescriptor::ClassDescriptor(void)
{
    // initialize everything to NULL
    // ZeroMemory(this, sizeof(ClassDescriptor));
    memset(this, 0, sizeof(ClassDescriptor));
}

//+---------------------------------------------------------------
//
//  Member:     ClassDescriptor::Init
//
//  Synopsis:   Initializes a class descriptor structure from resources
//
//  Arguments:  [hinst] -- instance handle of module with resources used
//                      to initialize the class descriptor
//
//  Returns:    TRUE iff the class descriptor was successfully initialized
//
//  Notes:      This method only fills in the part of the class descriptor
//              that can be initialized from resources.  The other part
//              that requires initialization are the verb and format tables.
//
//              Objects that are concerned about resource load times could
//              not use this initialization method and fill in fields of the
//              class descriptor directly.
//
//----------------------------------------------------------------

BOOL ClassDescriptor::Init(HINSTANCE hinst, WORD wBaseID)
{
    //REVIEW:  Currently, information loaded from resources is duplicated
    //REVIEW:  in the registration database.  We could
    //REVIEW:   (1) load this stuff from the reg db instead (except CLSID), or
    //REVIEW:   (2) do an autoregistration feature where the reg db is filled
    //REVIEW:       in from the class descriptor information loaded from resources

    //REVIEW:  We could also support loading the verb and format tables
    //REVIEW:  from resources/regdb as well.

    _hinst = hinst;
    _wBaseResID = wBaseID;

    // load our class id string and convert it into our real class id
    TCHAR szClsId[40];
    ZeroMemory (szClsId, sizeof (szClsId));

    LoadString(hinst, wBaseID+IDOFF_CLASSID, szClsId, ARRAY_SIZE(szClsId));
    
#if !defined(UNICODE) && !defined(OLE2ANSI)
    LPOLESTR lpostr = ConvertMBToOLESTR(szClsId,-1);
    BOOL fRet = OK(CLSIDFromString(lpostr, &_clsid));
    TaskFreeMem(lpostr);
#else
    BOOL fRet = OK(CLSIDFromString(szClsId, &_clsid));
#endif
    
    // load our in-place menus and accelerators
    _hicon = LoadIcon(hinst, MAKEINTRESOURCE(wBaseID+IDOFF_ICON));

    _haccel = (HACCEL)LoadAccelerators(hinst,
            MAKEINTRESOURCE(wBaseID+IDOFF_ACCELS));

    LoadResourceData(hinst,
                           MAKEINTRESOURCE(wBaseID+IDOFF_MGW),
                           &_mgw,
                           sizeof(_mgw));
    
    LoadResourceData(hinst,
                     MAKEINTRESOURCE(wBaseID+IDOFF_MISCSTATUS),
                     &_dwMiscStatus,
                     sizeof(_dwMiscStatus));

#if !defined(UNICODE) && !defined(OLE2ANSI)
    
    CHAR szUserClassType[MAX_USERTYPE_LEN];
    
#define SetWideClassType(y,x) \
    MultiByteToWideChar(CP_ACP                      \
                        , 0                         \
                        , (y)                       \
                        , -1                        \
                        , _szUserClassType[(x)]     \
                        , ARRAY_SIZE(_szUserClassType[(x)]))
    LoadString(hinst
               , wBaseID+IDOFF_USERTYPEFULL
               , szUserClassType
               , MAX_USERTYPE_LEN);
    
    SetWideClassType(szUserClassType,USERCLASSTYPE_FULL);

    LoadString(hinst
               , wBaseID+IDOFF_USERTYPESHORT
               , szUserClassType
               , MAX_USERTYPE_LEN);
    
    SetWideClassType(szUserClassType,USERCLASSTYPE_SHORT);
    
    LoadString(hinst
               , wBaseID+IDOFF_USERTYPEAPP
               , szUserClassType
               , MAX_USERTYPE_LEN);
    
    SetWideClassType(szUserClassType,USERCLASSTYPE_APPNAME);
    
    LoadString(hinst
               , wBaseID+IDOFF_DOCFEXT
               , szUserClassType
               , MAX_USERTYPE_LEN);

    MultiByteToWideChar(CP_ACP
                        , 0
                        , szUserClassType
                        , -1
                        , _szDocfileExt
                        , ARRAY_SIZE(_szDocfileExt));
#else    
    LoadString(hinst
               , wBaseID+IDOFF_USERTYPEFULL
               , _szUserClassType[USERCLASSTYPE_FULL]
               , ARRAY_SIZE(_szUserClassType[USERCLASSTYPE_FULL]));
    LoadString(hinst
               , wBaseID+IDOFF_USERTYPESHORT
               , _szUserClassType[USERCLASSTYPE_SHORT]
               , ARRAY_SIZE(_szUserClassType[USERCLASSTYPE_SHORT]));
    LoadString(hinst
               , wBaseID+IDOFF_USERTYPEAPP
               , _szUserClassType[USERCLASSTYPE_APPNAME]
               , ARRAY_SIZE(_szUserClassType[USERCLASSTYPE_APPNAME]));
    LoadString(hinst
               , wBaseID+IDOFF_DOCFEXT
               , _szDocfileExt
               , ARRAY_SIZE(_szDocfileExt));

#endif
    
    return fRet;
}

//+---------------------------------------------------------------
//
//  Member:     ClassDescriptor::LoadMenu, public
//
//  Synopsis:   Loads a copy of the menus for the server
//
//  Notes:      A single copy of the menu cannot be shared by all
//              instances of the class, like an accelerator table can.
//              This is because the menu is not a read-only resource
//              (e.g. you can "check" a menu item and merge in verb
//              menu items).  Therefore each class instance must load
//              its own copy of the menu.  This LoadMenu call is used
//              for that purpose.
//
//---------------------------------------------------------------

HMENU
ClassDescriptor::LoadMenu(void)
{
    return ::LoadMenu(_hinst, MAKEINTRESOURCE(_wBaseResID+IDOFF_MENU));
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\border.cxx ===
//+---------------------------------------------------------------------
//
//   File:       border.cxx
//
//   Contents:   Border Object Class
//
//   Classes:    OLEBorder
//
//------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


    BOOL OLEBorder::fInit = FALSE;
    HCURSOR OLEBorder::ahc[5] = { NULL, NULL, NULL, NULL, NULL };
    int OLEBorder::iPartMap[14] = {
        ICURS_STD,  // 0 NOWHERE
        ICURS_STD,  // 1 TOP
        ICURS_STD,  // 2 RIGHT
        ICURS_STD,  // 3 BOTTOM
        ICURS_STD,  // 4 LEFT
        ICURS_NESW, // 5 TOPRIGHT
        ICURS_NWSE, // 6 BOTTOMRIGHT
        ICURS_NESW, // 7 BOTTOMLEFT
        ICURS_NWSE, // 8 TOPLEFT
        ICURS_NS,   // 9 TOPHAND
        ICURS_WE,   //10 RIGHTHAND
        ICURS_NS,   //11 BOTTOMHAND
        ICURS_WE,   //12 LEFTHAND
        ICURS_STD   //13 INSIDE
    };

HCURSOR
OLEBorder::MapPartToCursor(USHORT usPart)
{
    if (usPart > MAX_OBPART)
        usPart = 0;
    return ahc[iPartMap[usPart]];
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::InitClass
//
//---------------------------------------------------------------
void
OLEBorder::InitClass( void )
{
    _fErased = TRUE;
    _state = 0;
    _sThickness = FBORDER_THICKNESS;
    _sMinHeight = FBORDER_MINHEIGHT;
    _sMinWidth = FBORDER_MINWIDTH;
    if(fInit)
        return;

    ahc[ICURS_NWSE] = LoadCursor( NULL, IDC_SIZENWSE );
    ahc[ICURS_NESW] = LoadCursor( NULL, IDC_SIZENESW );
    ahc[ICURS_NS] = LoadCursor( NULL, IDC_SIZENS );
    ahc[ICURS_WE] = LoadCursor( NULL, IDC_SIZEWE );
    ahc[ICURS_STD] = LoadCursor( NULL, IDC_SIZEALL );
    fInit = TRUE;
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::OLEBorder
//
//---------------------------------------------------------------
OLEBorder::OLEBorder( void )
{
    rect.top = 0;
    rect.left = 0;
    rect.bottom = 0;
    rect.right = 0;
    InitClass();
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::OLEBorder
//
//---------------------------------------------------------------
OLEBorder::OLEBorder( RECT& r )
{
    rect = r;
    InitClass();
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::~OLEBorder
//
//---------------------------------------------------------------
OLEBorder::~OLEBorder( void )
{
}


//+---------------------------------------------------------------
//
//  Member: OLEBorder::SetState
//
//---------------------------------------------------------------
USHORT
OLEBorder::SetState( HDC hdc, HWND hwnd, USHORT usBorderState )
{
    if (_state ^ usBorderState)
    {
        if (hdc != NULL)
        {
            _state |= OBSTYLE_RESERVED;
            Draw(hdc,hwnd);
        }
    }
    _state = usBorderState & (~OBSTYLE_RESERVED);
    if (hdc != NULL)
        Draw(hdc,hwnd);

    return _state;
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::Erase
//
//---------------------------------------------------------------
void
OLEBorder::Erase(HWND hwnd)
{
    RECT r;
    if (hwnd != NULL && !_fErased)
    {
        _fErased = TRUE;
        if(_state & OBSTYLE_DIAGONAL_FILL)
        {
            GetBorderRect(r,BP_INSIDE);
            InvalidateRect(hwnd,&r,TRUE);
        }
        else
        {
            for(int i = BP_TOP; i <= BP_LEFT; i++)
            {
                GetBorderRect(r,i);
                InvalidateRect(hwnd,&r,TRUE);
            }
        }
    }
    _state = _state & OBSTYLE_INSIDE;
}

void
OLEBorder::GetInsideBorder( RECT& rDest, int iEdge )
{
    int sHalf = _sThickness >> 1;
    int sMid;

    switch(iEdge)
    {
    case BP_TOP:
    case BP_BOTTOM:
        rDest.left = rect.left;
        rDest.right = rect.right;
        if (iEdge == BP_TOP)
        {
            rDest.top = rect.top;
            rDest.bottom = rect.top + _sThickness;
        }
        else
        {
            rDest.top = rect.bottom - _sThickness;
            rDest.bottom = rect.bottom;
        }
        break;

    case BP_RIGHT:
    case BP_LEFT:
        rDest.top = rect.top;
        rDest.bottom = rect.bottom;
        if (iEdge == BP_RIGHT)
        {
            rDest.left = rect.right - _sThickness;
            rDest.right = rect.right;
        }
        else
        {
            rDest.left = rect.left;
            rDest.right = rect.left + _sThickness;
        }
        break;

    case BP_TOPRIGHT:
    case BP_BOTTOMRIGHT:
        rDest.left = rect.right - _sThickness;
        rDest.right = rect.right;
        if (iEdge == BP_TOPRIGHT)
        {
            rDest.top = rect.top;
            rDest.bottom = rect.top + _sThickness;
        }
        else
        {
            rDest.top = rect.bottom - _sThickness;
            rDest.bottom = rect.bottom;
        }
        break;

    case BP_BOTTOMLEFT:
    case BP_TOPLEFT:
        rDest.left = rect.left;
        rDest.right = rect.left + _sThickness;
        if (iEdge == BP_BOTTOMLEFT)
        {
            rDest.top = rect.bottom - _sThickness;
            rDest.bottom = rect.bottom;
        }
        else
        {
            rDest.top = rect.top;
            rDest.bottom = rect.top + _sThickness;
        }
        break;

    case BP_TOPHAND:
    case BP_BOTTOMHAND:
        sMid = rect.left + ((rect.right - rect.left) >> 1);
        rDest.left = sMid - sHalf;
        rDest.right = sMid + sHalf;
        if (iEdge == BP_TOPHAND)
        {
            rDest.top = rect.top;
            rDest.bottom = rect.top + _sThickness;
        }
        else
        {
            rDest.top = rect.bottom - _sThickness;
            rDest.bottom = rect.bottom;
        }
        break;

    case BP_RIGHTHAND:
    case BP_LEFTHAND:
        sMid = rect.top + ((rect.bottom - rect.top) >> 1);
        rDest.top = sMid - sHalf;
        rDest.bottom = sMid + sHalf;
        if (iEdge == BP_LEFTHAND)
        {
            rDest.left = rect.left;
            rDest.right = rect.left + _sThickness;
        }
        else
        {
            rDest.left = rect.right - _sThickness;
            rDest.right = rect.right;
        }
        break;

    case BP_INSIDE:
    default:
        rDest = rect;
        break;
    }
}

void
OLEBorder::GetOutsideBorder( RECT& rDest, int iEdge )
{
    int sHalf = _sThickness >> 1;
    int sMid;

    switch(iEdge)
    {
    case BP_TOP:
    case BP_BOTTOM:
        rDest.left = rect.left - _sThickness;
        rDest.right = rect.right + _sThickness;
        if (iEdge == BP_TOP)
        {
            rDest.top = rect.top - _sThickness;
            rDest.bottom = rect.top + 1;
        }
        else
        {
            rDest.top = rect.bottom;
            rDest.bottom = rect.bottom + _sThickness;
        }
        break;

    case BP_RIGHT:
    case BP_LEFT:
        rDest.top = rect.top - _sThickness;
        rDest.bottom = rect.bottom + _sThickness;
        if (iEdge == BP_RIGHT)
        {
            rDest.left = rect.right;
            rDest.right = rect.right + _sThickness;
        }
        else
        {
            rDest.left = rect.left - _sThickness;
            rDest.right = rect.left + 1;
        }
        break;

    case BP_TOPRIGHT:
    case BP_BOTTOMRIGHT:
        rDest.left = rect.right;
        rDest.right = rect.right + _sThickness;
        if (iEdge == BP_TOPRIGHT)
        {
            rDest.top = rect.top - _sThickness;
            rDest.bottom = rect.top + 1;
        }
        else
        {
            rDest.top = rect.bottom;
            rDest.bottom = rect.bottom + _sThickness;
        }
        break;

    case BP_BOTTOMLEFT:
    case BP_TOPLEFT:
        rDest.left = rect.left - _sThickness;
        rDest.right = rect.left + 1;
        if (iEdge == BP_BOTTOMLEFT)
        {
            rDest.top = rect.bottom;
            rDest.bottom = rect.bottom + _sThickness;
        }
        else
        {
            rDest.top = rect.top - _sThickness;
            rDest.bottom = rect.top + 1;
        }
        break;

    case BP_TOPHAND:
    case BP_BOTTOMHAND:
        sMid = rect.left + ((rect.right - rect.left) >> 1);
        rDest.left = sMid - sHalf;
        rDest.right = sMid + sHalf;
        if (iEdge == BP_TOPHAND)
        {
            rDest.top = rect.top - _sThickness;
            rDest.bottom = rect.top + 1;
        }
        else
        {
            rDest.top = rect.bottom;
            rDest.bottom = rect.bottom + _sThickness;
        }
        break;

    case BP_RIGHTHAND:
    case BP_LEFTHAND:
        sMid = rect.top + ((rect.bottom - rect.top) >> 1);
        rDest.top = sMid - sHalf;
        rDest.bottom = sMid + sHalf;
        if (iEdge == BP_LEFTHAND)
        {
            rDest.left = rect.left - _sThickness;
            rDest.right = rect.left + 1;
        }
        else
        {
            rDest.left = rect.right;
            rDest.right = rect.right + _sThickness;
        }
        break;

    case BP_INSIDE:
    default: //inactive border
        rDest.left = rect.left - 1;
        rDest.right = rect.right + 1;
        rDest.top = rect.top - 1;
        rDest.bottom = rect.bottom + 1;
        break;
    }
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::GetBorderRect
//
//---------------------------------------------------------------
void
OLEBorder::GetBorderRect( RECT& rDest, int iEdge )
{
    if(_state & OBSTYLE_INSIDE)
        GetInsideBorder(rDest,iEdge);
    else
        GetOutsideBorder(rDest,iEdge);
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::SwitchCoords
//
//---------------------------------------------------------------
void
OLEBorder::SwitchCoords( HWND hwndFrom, HWND hwndTo )
{
    MapWindowPoints(hwndFrom, hwndTo, (LPPOINT)&rect, 2);
    MapWindowPoints(hwndFrom, hwndTo, &_pt, 1);
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::Draw
//
//---------------------------------------------------------------
void
OLEBorder::Draw( HDC hdc, HWND hwnd )
{
    if(hdc == NULL || (_state & ~OBSTYLE_INSIDE) == 0)
    {
        return;     //nothing to do!
    }

    RECT r;
    //
    //       the following should be rewritten so any border style
    //       can be drawn in XOR mode...
    //
    if (_state & OBSTYLE_XOR)
    {
        if (_state & OBSTYLE_THICK)
        {
            PatBlt(hdc, rect.left - 1, rect.top - 1,
                rect.right - rect.left + 2, 3, PATINVERT);

            PatBlt(hdc, rect.left - 1, rect.bottom - 2,
                rect.right - rect.left + 2, 3, PATINVERT);

            PatBlt(hdc, rect.left - 1, rect.top + 2,
                3, rect.bottom - rect.top - 4, PATINVERT);

            PatBlt(hdc, rect.right - 2, rect.top + 2,
                3, rect.bottom - rect.top - 4, PATINVERT);
        }
        else
            DrawFocusRect(hdc,&rect);
        return;
    }

    HBRUSH hbrBlack = (HBRUSH)GetStockObject(BLACK_BRUSH);
    HBRUSH hbr;
    COLORREF clrref;
    int i;

    if (_state & OBSTYLE_RESERVED)
    {
        Erase(hwnd);
        return;
    }

    if (_state & OBSTYLE_ACTIVE)
    {
        clrref = GetSysColor(COLOR_ACTIVECAPTION);
    }
    else
    {
        clrref = GetSysColor(COLOR_WINDOWFRAME);
    }

    if ((_state & OBSTYLE_TYPEMASK) == OBSTYLE_DIAGONAL_FILL)
    {
        hbr = CreateHatchBrush(HS_DIAGCROSS,clrref);
        GetBorderRect(r,BP_INSIDE);
        FillRect(hdc,&r,hbr);
        DeleteObject(hbr);
    }
    else if ((_state & OBSTYLE_TYPEMASK) == OBSTYLE_SOLID_PEN)
    {
        GetBorderRect(r,BP_INSIDE);
        FrameRect(hdc,&r,hbrBlack);
    }

    if (_state & OBSTYLE_THICK)
    {
        if (_state & OBSTYLE_INSIDE)
            InflateRect(&r,-1,-1);
        else
            InflateRect(&r,1,1);
        FrameRect(hdc,&rect,hbrBlack);
    }

    if (_state & OBSTYLE_HANDLED)
    {
        for (i = BP_TOPRIGHT; i <= BP_TOPLEFT; i++)
        {
            GetBorderRect(r,i);
            FillRect(hdc,&r,hbrBlack);
        }
        for (i = BP_TOPHAND; i <= BP_LEFTHAND; i++)
        {
            GetBorderRect(r,i);
            FillRect(hdc,&r,hbrBlack);
        }
    }
    _fErased = FALSE;
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::QueryHit
//
//---------------------------------------------------------------
USHORT
OLEBorder::QueryHit( POINT point )
{
    RECT r = rect;
    USHORT usWhere = BP_NOWHERE;

    if ((_state & OBSTYLE_INSIDE) == 0)
        InflateRect(&r,_sThickness,_sThickness);
    if (PtInRect(&r,point))
    {
        usWhere = BP_INSIDE;
        //
        //test against the real inside to optimize this case...
        //
        InflateRect(&r,-_sThickness,-_sThickness);

        //
        // PtInRect counts the top and left borders as being inside, so
        // we must account for this.
        //
        r.left++;
        r.top++;
        if (!PtInRect(&r,point))
        {
            //
            //Search for the "handle" that was hit...
            //
            USHORT i;
            for (i = BP_LEFTHAND; i >= BP_TOP; i--)
            {
                GetBorderRect(r,i);
                if (PtInRect(&r,point))
                {
                    usWhere = i;
                    break;
                }
            }
        }
    }
    return(usWhere);
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::QueryMoveCursor
//
//---------------------------------------------------------------
HCURSOR
OLEBorder::QueryMoveCursor( POINT ptCurrent, BOOL fMustMove )
{
    //
    //Stash part-hit info so we can do the right thing durring
    //upcomming move/size operation
    //
    if (fMustMove)
    {
        _usPart = BP_INSIDE;
    }
    else
    {
        _usPart = QueryHit(ptCurrent);
    }
    return MapPartToCursor(_usPart);
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::BeginMove
//
//---------------------------------------------------------------
HCURSOR
OLEBorder::BeginMove( HDC hdc, HWND hwnd, POINT ptStart,
        BOOL fMustMove )
{
    if(_state == 0 )
        _state = OBSTYLE_SOLID_PEN;
    SetState( hdc, hwnd, _state | OBSTYLE_XOR | OBSTYLE_THICK);
    _pt = ptStart;
    return QueryMoveCursor(ptStart,fMustMove);
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::UpdateMove
//
//---------------------------------------------------------------
RECT&
OLEBorder::UpdateMove( HDC hdc, HWND hwnd, POINT ptCurrent, BOOL fNewRegion )
{
    if ((ptCurrent.x == _pt.x) && (ptCurrent.y == _pt.y))
        return rect;

    RECT rTemp = rect;
    Draw(hdc,hwnd);
    if (fNewRegion)
    {
        rTemp.left = min(_pt.x,ptCurrent.x);
        rTemp.top = min(_pt.y,ptCurrent.y);
        rTemp.right = max(_pt.x,ptCurrent.x);
        rTemp.bottom = max(_pt.y,ptCurrent.y);
    }
    else
    {
        int xDelta = ptCurrent.x - _pt.x;
        int yDelta = ptCurrent.y - _pt.y;
        switch (_usPart)
        {
        case BP_INSIDE:
        case BP_TOP:
        case BP_BOTTOM:
        case BP_RIGHT:
        case BP_LEFT:
        default:
            OffsetRect(&rTemp,xDelta,yDelta);
            break;

        case BP_TOPRIGHT:
            rTemp.right += xDelta;
            rTemp.top += yDelta;
            break;

        case BP_BOTTOMRIGHT:
            rTemp.right += xDelta;
            rTemp.bottom += yDelta;
            break;

        case BP_BOTTOMLEFT:
            rTemp.bottom += yDelta;
            rTemp.left += xDelta;
            break;

        case BP_TOPLEFT:
            rTemp.top += yDelta;
            rTemp.left += xDelta;
            break;

        case BP_TOPHAND:
            rTemp.top += yDelta;
            break;

        case BP_BOTTOMHAND:
            rTemp.bottom += yDelta;
            break;

        case BP_RIGHTHAND:
            rTemp.right += xDelta;
            break;

        case BP_LEFTHAND:
            rTemp.left += xDelta;
            break;
        }
    }
    //
    //clip resize to repect minimum height & width specification
    //
    if((rTemp.right - rTemp.left >= _sMinWidth) &&
        (rTemp.bottom - rTemp.top >= _sMinHeight))
    {
        rect = rTemp;
        if (!fNewRegion)
        {
            _pt = ptCurrent;
        }
    }

    Draw(hdc,hwnd);

    return rect;
}

//+---------------------------------------------------------------
//
//  Member: OLEBorder::EndMove
//
//---------------------------------------------------------------
RECT&
OLEBorder::EndMove( HDC hdc, HWND hwnd, POINT ptCurrent, USHORT usBorderState )
{
    SetState( hdc, hwnd, usBorderState );
    return rect;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\ipborder.cxx ===
//+---------------------------------------------------------------------
//
//   File:       ipborder.cxx
//
//   Classes:    InPlaceBorder
//
//   Notes:      Use of this class limits windows to the use
//               of the non-client region for UIAtive borders
//               only: Standard (non-control window) scroll bars
//               are specifically NOT supported.
//
//   History:    14-May-93   CliffG        Created.
//
//------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define IPB_GRABFACTOR  3

#define SetWF(hwnd,wf)  SetWindowLongPtr(hwnd, GWL_STYLE, \
            GetWindowLongPtr(hwnd,GWL_STYLE) | (wf))
#define ClrWF(hwnd,wf)  SetWindowLongPtr(hwnd, GWL_STYLE, \
            GetWindowLongPtr(hwnd,GWL_STYLE) &~(wf))
#define TestWF(hwnd,wf) (GetWindowLongPtr(hwnd,GWL_STYLE) & (wf))


    WORD InPlaceBorder::_cUsage = 0;
    HBRUSH InPlaceBorder::_hbrActiveCaption;
    HBRUSH InPlaceBorder::_hbrInActiveCaption;


//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::DrawFrame
//
//---------------------------------------------------------------
void
InPlaceBorder::DrawFrame(HWND hwnd)
{
    if(!_fUIActive)
        return;

    HDC hdc = GetWindowDC(hwnd);
    if (!hdc)
        return;

    HBRUSH hbr;
    if(_fParentActive)
        hbr = _hbrActiveCaption;
    else
        hbr = _hbrInActiveCaption;

    if (hbr)
    {
        RECT rcWhole;
        GetWindowRect(hwnd, &rcWhole);
        OffsetRect(&rcWhole, -rcWhole.left, -rcWhole.top);
        RECT rc;
        //Top
        rc = rcWhole;
        rc.bottom = rc.top + _cyFrame;
        FillRect(hdc, &rc, hbr);
        //Left
        rc = rcWhole;
        rc.right = rc.left + _cxFrame;
        FillRect(hdc, &rc, hbr);
        //Bottom
        rc = rcWhole;
        rc.top = rc.bottom - _cyFrame;
        FillRect(hdc, &rc, hbr);
        //Right
        rc = rcWhole;
        rc.left = rc.right - _cxFrame;
        FillRect(hdc, &rc, hbr);

        if(TestWF(hwnd, WS_THICKFRAME)) //Resizable window?
        {
            //
            //Draw grab handles at 4 corners of the border...
            //
            hbr = (HBRUSH)GetStockObject( BLACK_BRUSH );
            //TopLeft
            rc = rcWhole;
            rc.right = rc.left + _cxFrame;
            rc.bottom = rc.top + _cyFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            rc.bottom = rc.top + _cyFrame;
            rc.right = rc.left + _cxFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            //TopRight
            rc.right = rcWhole.right;
            rc.left = rc.right - _cxFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            rc.left = rc.right - _cxFrame;
            rc.bottom = rc.top + _cyFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            //BottomLeft
            rc = rcWhole;
            rc.top = rc.bottom - _cyFrame * IPB_GRABFACTOR;
            rc.right = rc.left + _cxFrame;
            FillRect(hdc, &rc, hbr);
            rc.top = rc.bottom - _cyFrame;
            rc.right = rc.left + _cxFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            //BottomRight
            rc.right = rcWhole.right;
            rc.left = rc.right - _cxFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
            rc.right = rcWhole.right;
            rc.left = rc.right - _cxFrame;
            rc.top = rc.bottom - _cyFrame * IPB_GRABFACTOR;
            FillRect(hdc, &rc, hbr);
        }
    }

    ReleaseDC(hwnd, hdc);
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::HitTest
//
//---------------------------------------------------------------
LONG
InPlaceBorder::HitTest(HWND hwnd, int x, int y)
{
    POINT pt = { x, y };
    RECT rcClient;

    GetWindowRect(hwnd, &rcClient);
    CalcClientRect(hwnd, &rcClient);
    if (PtInRect(&rcClient, pt))
        return HTCLIENT;

    // We're somewhere on the window frame.
    if (y >= rcClient.bottom)
    {
        if (x <= rcClient.left + _cxFrame * IPB_GRABFACTOR)
            return HTBOTTOMLEFT;
        if (x >= rcClient.right - _cxFrame * IPB_GRABFACTOR)
            return HTBOTTOMRIGHT;
        return HTBOTTOM;
    }
    else if (y <= rcClient.top)
    {
        if (x <= rcClient.left + _cxFrame * IPB_GRABFACTOR)
            return(HTTOPLEFT);
        if (x >= rcClient.right - _cxFrame * IPB_GRABFACTOR)
            return(HTTOPRIGHT);
        return HTTOP;
    }
    else if (x <= rcClient.left)
    {
        if (y <= rcClient.top + _cyFrame * IPB_GRABFACTOR)
            return HTTOPLEFT;
        if (y >= rcClient.bottom - _cyFrame * IPB_GRABFACTOR)
            return HTBOTTOMLEFT;
        return HTLEFT;
    }
    else
    {
        if (y <= rcClient.top + _cyFrame * IPB_GRABFACTOR)
            return HTTOPRIGHT;
        if (y >= rcClient.bottom - _cyFrame * IPB_GRABFACTOR)
            return HTBOTTOMRIGHT;
        return HTRIGHT;
    }

    return HTNOWHERE;
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::DefWindowProc
//
//---------------------------------------------------------------
LRESULT
InPlaceBorder::DefWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0L;
    //REVIEW code assumes an SDI app...
    if(_hwnd == NULL)
        return ::DefWindowProc(hwnd,msg,wParam,lParam);

    switch (msg)
    {
    case WM_WINDOWPOSCHANGED:
        if(_pSite != NULL && _cResizing == 0 && _fUIActive)
        {
            ++_cResizing;
            RECT rc;
            GetChildWindowRect(hwnd, &rc);
            InflateRect(&rc,-_cxFrame,-_cyFrame);
            _pSite->OnPosRectChange(&rc);
            _cResizing--;
        }
        break;
    case WM_NCCALCSIZE:     // lParam == LPRECT of window rect
        //
        //Turn off the WS_THICKFRAME style bit during
        //default processing so we keep ownership of visualization...
        //
        if (TestWF(hwnd, WS_THICKFRAME))
        {
            ClrWF(hwnd, WS_THICKFRAME);
            lRet = ::DefWindowProc(hwnd, msg, wParam,lParam);
            SetWF(hwnd, WS_THICKFRAME);
        }
        CalcClientRect(hwnd, (LPRECT)lParam);
        return lRet;

    case WM_NCHITTEST:      // lParam is POINT in screen cords
        return HitTest(hwnd, LOWORD(lParam), HIWORD(lParam));

    case WM_NCPAINT:
        DrawFrame(hwnd);
        return 0L;

    case WM_NCLBUTTONDOWN:
    case WM_NCMOUSEMOVE:
    case WM_NCLBUTTONUP:
    case WM_NCLBUTTONDBLCLK:
    case WM_NCRBUTTONDOWN:
    case WM_NCRBUTTONUP:
    case WM_NCRBUTTONDBLCLK:
    case WM_NCMBUTTONDOWN:
    case WM_NCMBUTTONUP:
    case WM_NCMBUTTONDBLCLK:
    case WM_NCACTIVATE:     // wParam == active state
    case WM_NCCREATE:       // Sent before WM_CREATE
    case WM_NCDESTROY:      // Sent before WM_DESTROY
        break;
    }

    return ::DefWindowProc(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::InPlaceBorder
//
//---------------------------------------------------------------
InPlaceBorder::InPlaceBorder(void)
{
    _fParentActive = TRUE;
    _fUIActive = FALSE;
    _hwnd = NULL;
    _pSite = NULL;
    _cResizing = 0;
    _cxFrame = _cyFrame = IPBORDER_THICKNESS;
    if(_cUsage++ == 0)
    {
        // the following could fail and we would be hosed...
        _hbrActiveCaption = CreateHatchBrush(HS_BDIAGONAL,
            GetSysColor(COLOR_ACTIVECAPTION));
        _hbrInActiveCaption = CreateHatchBrush(HS_BDIAGONAL,
            GetSysColor(COLOR_WINDOWFRAME));
    }
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::~InPlaceBorder
//
//---------------------------------------------------------------
InPlaceBorder::~InPlaceBorder(void)
{
    if(--_cUsage == 0)
    {
        DeleteObject(_hbrActiveCaption);
        _hbrActiveCaption = NULL;
        DeleteObject(_hbrInActiveCaption);
        _hbrInActiveCaption = NULL;
    }
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::SetState
//
//Change the border state: reflected in the nonclient window border
//---------------------------------------------------------------
void
InPlaceBorder::SetUIActive(BOOL fUIActive)
{
    if(_hwnd == NULL)
        return;

    if(_fUIActive != fUIActive)
    {
        RECT rcClient;
        GetChildWindowRect(_hwnd, &rcClient);
        int cx = rcClient.right - rcClient.left;
        int cy = rcClient.bottom - rcClient.top;
        int x = rcClient.left;
        int y = rcClient.top;
        BOOL fResize = FALSE;
        if (fUIActive)
        {
            fResize = TRUE;
            cx += _cxFrame * 2;
            cy += _cyFrame * 2;
            x -= _cxFrame;
            y -= _cyFrame;
        }
        else if (_fUIActive)
        {
            fResize = TRUE;
            cx -= _cxFrame * 2;
            cy -= _cyFrame * 2;
            x += _cxFrame;
            y += _cyFrame;
        }
        if (fResize)
        {
            //
            //Set our state member up so CalcClientRect generates correct values,
            //then move the window (keeping client area same size and position)
            //
            _fUIActive = fUIActive;
            ++_cResizing;
            SetWindowPos( _hwnd, NULL, x, y, cx, cy, SWP_FRAMECHANGED |
                SWP_NOACTIVATE | SWP_NOZORDER);
            RedrawFrame();
            _cResizing--;
        }
        else
        {
            InvalidateFrame();
        }
    }
    _fUIActive = fUIActive;
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::SetSize
//
//---------------------------------------------------------------
void
InPlaceBorder::SetSize(HWND hwnd, RECT& rc)
{
    int cx = rc.right - rc.left;
    int cy = rc.bottom - rc.top;
    int x = rc.left;
    int y = rc.top;
    if(_fUIActive)
    {
        cx += _cxFrame * 2;
        cy += _cyFrame * 2;
        x -= _cxFrame;
        y -= _cyFrame;
    }
    ++_cResizing;
    MoveWindow(hwnd, x, y, cx, cy, TRUE);
    _cResizing--;
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::Erase
//
// Force border state to non-UIActive, managing the coresponding
// change in border appearance
//
//---------------------------------------------------------------
void
InPlaceBorder::Erase(void)
{
    if(_hwnd == NULL)
        return;
    SetUIActive(FALSE);
    _fParentActive = TRUE;
    InvalidateFrame();
    RedrawFrame();
}


//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::SetBorderSize
//
//---------------------------------------------------------------
void
InPlaceBorder::SetBorderSize( int cx, int cy )
{
    if(cx < 0)
        cx = 0;
    if(cy < 0)
        cy = 0;
    _cxFrame = cx;
    _cyFrame = cy;
    InvalidateFrame();
    RedrawFrame();
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::GetBorderSize
//
//---------------------------------------------------------------
void
InPlaceBorder::GetBorderSize( LPINT pcx, LPINT pcy )
{
    *pcx = _cxFrame;
    *pcy = _cyFrame;
}

//+---------------------------------------------------------------
//
//  Member: InPlaceBorder::Attach
//
//---------------------------------------------------------------
void
InPlaceBorder::Attach(HWND hwnd, BOOL fUIActive)
{
    if((_hwnd = hwnd) != NULL)
    {
        SetUIActive(fUIActive);
        InvalidateFrame();  //force first-time NCCALC
    }
}

void
InPlaceBorder::Bind(LPOLEINPLACESITE pSite, HWND hwnd, BOOL fUIActive)
{
    _pSite = NULL;
    if((_hwnd = hwnd) != NULL && (_pSite = pSite) != NULL)
    {
        SetUIActive(fUIActive);
        InvalidateFrame();  //force first-time NCCALC
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\iputils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       iputils.hxx
//
//  Contents:   Helper functions for in-place activation
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define MAXLABELLEN 32

//+---------------------------------------------------------------
//
//  Function:   InsertServerMenus
//
//  Synopsis:   Inserts the objects menus into a shared menu after
//              the top-level application has inserted its menus
//
//  Arguments:  [hmenuShared] -- the shared menu to recieve the objects menus
//              [hmenuObject] -- all of the objects menus
//              [lpmgw] -- menu group widths indicating where the menus
//                          should be inserted
//
//  Returns:    Success if the menus were merged successfully
//
//  Notes:      The function does most of the shared menu work
//              by the object between the IOleInPlaceFrame::InsertMenus and
//              IOleInPlaceFrame::SetMenu method calls.
//              c.f. RemoveServerMenus
//
//----------------------------------------------------------------

HRESULT
InsertServerMenus(HMENU hmenuShared,
        HMENU hmenuObject,
        LPOLEMENUGROUPWIDTHS lpmgw)
{
    int i, j;
    HMENU hmenuXfer;
    TCHAR szLabel[MAXLABELLEN];
    UINT iServer = 0;
    UINT iShared = 0;

    // for each of the Edit, Object, and Help menu groups
    for (j = 1; j <= 5; j += 2)
    {
        // advance over container menus
        iShared += (UINT)lpmgw->width[j-1];

        // pull out the popup menus from servers menu
        for (i = 0; i < lpmgw->width[j]; i++)
        {
            GetMenuString(hmenuObject,
                        iServer,
                        szLabel,
                        MAXLABELLEN,
                        MF_BYPOSITION);
            hmenuXfer = GetSubMenu(hmenuObject, iServer++);
            if (!InsertMenu(hmenuShared,
                        iShared++,
                        MF_BYPOSITION|MF_POPUP,
                        (UINT_PTR)hmenuXfer,
                        szLabel))
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Function:   RemoveServerMenus
//
//  Synopsis:   Removes the objects menus from a shared menu
//
//  Arguments:  [hmenuShared] -- the menu contain both the application's
//                              and the object's menus
//              [lpmgw] -- menu group widths indicating which menus should
//                          be removed
//
//  Notes:      c.f. InsertServerMenus
//
//----------------------------------------------------------------

void
RemoveServerMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpmgw)
{
    int i, j;
    UINT iShared = 0;

    // for each of the Edit, Object, and Help menu groups
    for (j = 1; j <= 5; j += 2)
    {
        // advance over container menus
        iShared += (UINT)lpmgw->width[j-1];

        // pull out the popup menus from shared menu
        for (i = 0; i < lpmgw->width[j]; i++)
        {
            RemoveMenu(hmenuShared, iShared, MF_BYPOSITION);
        }
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//#include <rpcferr.h>


#if !defined(UNICODE) && !defined(OLE2ANSI)
LPOLESTR ConvertMBToOLESTR(LPCSTR lpStr, int cchStr)
{
        OLECHAR *lpwConverted;
        int cchW;
        
        //
        // UNICODE note: assuming we get an LPSTR here, find out how
        // many *bytes* are required and multiply by sizeof(TCHAR)
        //
        cchW = MultiByteToWideChar(CP_ACP, 0, lpStr, cchStr, NULL, 0);

        TaskAllocMem(sizeof(OLECHAR)*cchW, (LPVOID FAR *)&lpwConverted);

        if (lpwConverted == NULL)
                return NULL;
        
        MultiByteToWideChar(CP_ACP
                            , 0
                            , lpStr
                            , cchStr
                            , lpwConverted
                            , cchW);
        
        return lpwConverted;
}

LPTSTR ConvertOLESTRToMB(LPCOLESTR lpStr, int cchStr)
{
        LPTSTR lpConverted;
        int    cch;
        
        //
        // UNICODE note: assuming we get an LPSTR here, find out how
        // many *bytes* are required and multiply by sizeof(TCHAR)
        //
        cch = WideCharToMultiByte(CP_ACP, 0, lpStr, cchStr, NULL, 0, NULL, NULL);

        TaskAllocMem(sizeof(TCHAR)*cch, (LPVOID FAR *)&lpConverted);

        if (lpConverted == NULL)
                return NULL;
        
        WideCharToMultiByte(CP_ACP
                            , 0
                            , lpStr
                            , cchStr
                            , lpConverted
                            , cch
                            , NULL
                            , NULL);
        
        return lpConverted;
}
#endif

//+---------------------------------------------------------------
//
//  Function:   IsCompatibleOleVersion
//
//  Synopsis:   Checks if the installed version of OLE is compatible with
//              the version of OLE for which the software was written.
//
//  Arguments:  [wMaj] -- the major version number
//              [wMin] -- the minor version number
//
//  Returns:    TRUE if the installed version of OLE is compatible
//
//  Notes:      This function combines a call to OleBuildVersion
//              with the proper checking of version numbers.
//              The major and minor values passed in should be
//              the major and minor values returned from
//              OleBuildVersion for the version of OLE current
//              when the software was written.
//
//----------------------------------------------------------------

BOOL
IsCompatibleOleVersion(WORD wMaj, WORD wMin)
{
    // Check our compatibility with the OLE runtime.
    // We are compatible with any later major version,
    // or the same major version with equal or greater minor version.
    DWORD ov = OleBuildVersion();
    return HIWORD(ov) > wMaj || (HIWORD(ov) == wMaj && LOWORD(ov) >= wMin);
}

#if DBG

//+---------------------------------------------------------------
//
//  Function:   AssertSFL
//
//  Synopsis:   Displays "Assertion Failed" message and puts up
//              a message box allowing the user to (1) exit the program,
//              (2) break into the debugger, or (3) ignore
//
//  Arguments:
//              [lpszClause]   -- The assertion clause
//              [lpszFileName] -- File where assertion failed
//              [nLine}        -- Line in file where assertion failed
//
//----------------------------------------------------------------

extern "C" void FAR PASCAL AssertSFL(LPSTR lpszClause,
        LPSTR lpszFileName, int nLine)
{
    static TCHAR achMessage[] = TEXT("File %hs\n Line %d");
    TCHAR achTitle[256];
    TCHAR achFormatBuffer[256];

    wsprintf(achTitle,TEXT("%hs"), lpszClause);
    wsprintf(achFormatBuffer, achMessage, lpszFileName, nLine);
    
    OutputDebugString(achFormatBuffer);
    OutputDebugString(TEXT(", "));
    OutputDebugString(achTitle);
    OutputDebugString(TEXT("\n\r"));
        
retry:
    int nCode = ::MessageBox(NULL, achFormatBuffer, achTitle,
                        MB_SYSTEMMODAL | MB_ICONHAND | MB_ABORTRETRYIGNORE);
    if (nCode == IDIGNORE)
        return;     // ignore
    else if (nCode == IDRETRY)
    {
        // break into the debugger (or Dr Watson log)
        DebugBreak();   
        goto retry;
    }                            
    
    // else fall through and exit
    FatalExit(2);
}

#endif // DBG

#if DBG == 1

//+---------------------------------------------------------------
//
//  Function:   TraceIID
//
//  Synopsis:   Outputs the name of the interface to the debugging device
//
//  Arguments:  [riid] -- the interface
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

void
TraceIID(REFIID riid)
{
    LPTSTR lpstr = TEXT("UNKNOWN INTERFACE");

#define CASE_IID(iid)  \
        if (IsEqualIID(IID_##iid, riid)) lpstr = (LPTSTR)TEXT(#iid);

    CASE_IID(IUnknown)
    CASE_IID(IOleLink)
    CASE_IID(IOleCache)
    CASE_IID(IOleManager)
    CASE_IID(IOlePresObj)
    CASE_IID(IDebug)
    CASE_IID(IDebugStream)
    CASE_IID(IAdviseSink2)
    CASE_IID(IDataObject)
    CASE_IID(IViewObject)
    CASE_IID(IOleObject)
    CASE_IID(IOleInPlaceObject)
    CASE_IID(IParseDisplayName)
    CASE_IID(IOleContainer)
    CASE_IID(IOleItemContainer)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IPersist)
    CASE_IID(IPersistStorage)
    CASE_IID(IPersistFile)
    CASE_IID(IPersistStream)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IAdviseSink)
    CASE_IID(IDataAdviseHolder)
    CASE_IID(IOleAdviseHolder)
    CASE_IID(IClassFactory)
    CASE_IID(IOleWindow)
    CASE_IID(IOleInPlaceActiveObject)
    CASE_IID(IOleInPlaceUIWindow)
    CASE_IID(IOleInPlaceFrame)
    CASE_IID(IDropSource)
    CASE_IID(IDropTarget)
    CASE_IID(IBindCtx)
    CASE_IID(IEnumUnknown)
    CASE_IID(IEnumString)
    CASE_IID(IEnumFORMATETC)
    CASE_IID(IEnumSTATDATA)
    CASE_IID(IEnumOLEVERB)
    CASE_IID(IEnumMoniker)
    CASE_IID(IEnumGeneric)
    CASE_IID(IEnumHolder)
    CASE_IID(IEnumCallback)
    CASE_IID(ILockBytes)
    CASE_IID(IStorage)
    CASE_IID(IStream)
    //CASE_IID(IDispatch)
    //CASE_IID(IEnumVARIANT)
    //CASE_IID(ITypeInfo)
    //CASE_IID(ITypeLib)
    //CASE_IID(ITypeComp)
    //CASE_IID(ICreateTypeInfo)
    //CASE_IID(ICreateTypeLib)

#undef CASE_IID

    TCHAR achTemp[256];
#ifdef UNICODE    
    wsprintf(achTemp, TEXT("%ws"), lpstr);
#else
    wsprintf(achTemp, TEXT("%s"), lpstr);    
#endif        
    OutputDebugString( achTemp );
}


//+---------------------------------------------------------------
//
//  Function:   TraceHRESULT
//
//  Synopsis:   Outputs the name of the SCODE to the debugging device
//
//  Arguments:  [scode] -- the status code to report
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

HRESULT
TraceHRESULT(HRESULT r)
{
    LPTSTR lpstr;
#ifdef UNICODE
#define CASE_SCODE(sc)  \
        case sc: lpstr = (LPWSTR)L#sc; break;
#else
#define CASE_SCODE(sc)  \
        case sc: lpstr = (LPSTR)#sc; break;
#endif    
    switch (r) {
        /* SCODE's defined in SCODE.H */
        CASE_SCODE(S_OK)
 // same value as S_OK      CASE_SCODE(S_TRUE)
        CASE_SCODE(S_FALSE)
        CASE_SCODE(E_UNEXPECTED)
        CASE_SCODE(E_NOTIMPL)
        CASE_SCODE(E_OUTOFMEMORY)
        CASE_SCODE(E_INVALIDARG)
        CASE_SCODE(E_NOINTERFACE)
        CASE_SCODE(E_POINTER)
        CASE_SCODE(E_HANDLE)
        CASE_SCODE(E_ABORT)
        CASE_SCODE(E_FAIL)
        CASE_SCODE(E_ACCESSDENIED)

        /* SCODE's defined in DVOBJ.H */
        CASE_SCODE(DATA_E_FORMATETC)
// same as DATA_E_FORMATETC     CASE_SCODE(DV_E_FORMATETC)
        CASE_SCODE(DATA_S_SAMEFORMATETC)
        CASE_SCODE(VIEW_E_DRAW)
//  same as VIEW_E_DRAW         CASE_SCODE(E_DRAW)
        CASE_SCODE(VIEW_S_ALREADY_FROZEN)
        CASE_SCODE(CACHE_E_NOCACHE_UPDATED)
        CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
        CASE_SCODE(CACHE_S_SAMECACHE)
        CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)

        /* SCODE's defined in OLE2.H */
        CASE_SCODE(OLE_E_OLEVERB)
        CASE_SCODE(OLE_E_ADVF)
        CASE_SCODE(OLE_E_ENUM_NOMORE)
        CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
        CASE_SCODE(OLE_E_NOCONNECTION)
        CASE_SCODE(OLE_E_NOTRUNNING)
        CASE_SCODE(OLE_E_NOCACHE)
        CASE_SCODE(OLE_E_BLANK)
        CASE_SCODE(OLE_E_CLASSDIFF)
        CASE_SCODE(OLE_E_CANT_GETMONIKER)
        CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
        CASE_SCODE(OLE_E_STATIC)
        CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
        CASE_SCODE(OLE_E_INVALIDRECT)
        CASE_SCODE(OLE_E_WRONGCOMPOBJ)
        CASE_SCODE(OLE_E_INVALIDHWND)
        CASE_SCODE(DV_E_DVTARGETDEVICE)
        CASE_SCODE(DV_E_STGMEDIUM)
        CASE_SCODE(DV_E_STATDATA)
        CASE_SCODE(DV_E_LINDEX)
        CASE_SCODE(DV_E_TYMED)
        CASE_SCODE(DV_E_CLIPFORMAT)
        CASE_SCODE(DV_E_DVASPECT)
        CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
        CASE_SCODE(DV_E_NOIVIEWOBJECT)
        CASE_SCODE(OLE_S_USEREG)
        CASE_SCODE(OLE_S_STATIC)
        CASE_SCODE(OLE_S_MAC_CLIPFORMAT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
        CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
        CASE_SCODE(CONVERT10_E_STG_FMT)
        CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
        CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
        CASE_SCODE(CONVERT10_S_NO_PRESENTATION)
        CASE_SCODE(CLIPBRD_E_CANT_OPEN)
        CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
        CASE_SCODE(CLIPBRD_E_CANT_SET)
        CASE_SCODE(CLIPBRD_E_BAD_DATA)
        CASE_SCODE(CLIPBRD_E_CANT_CLOSE)
        CASE_SCODE(DRAGDROP_E_NOTREGISTERED)
        CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)
        CASE_SCODE(DRAGDROP_E_INVALIDHWND)
        CASE_SCODE(DRAGDROP_S_DROP)
        CASE_SCODE(DRAGDROP_S_CANCEL)
        CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)
        CASE_SCODE(OLEOBJ_E_NOVERBS)
        CASE_SCODE(OLEOBJ_S_INVALIDVERB)
        CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
        CASE_SCODE(OLEOBJ_S_INVALIDHWND)
        CASE_SCODE(INPLACE_E_NOTUNDOABLE)
        CASE_SCODE(INPLACE_E_NOTOOLSPACE)
        CASE_SCODE(INPLACE_S_TRUNCATED)

        /* SCODE's defined in STORAGE.H */
        CASE_SCODE(STG_E_INVALIDFUNCTION)
        CASE_SCODE(STG_E_FILENOTFOUND)
        CASE_SCODE(STG_E_PATHNOTFOUND)
        CASE_SCODE(STG_E_TOOMANYOPENFILES)
        CASE_SCODE(STG_E_ACCESSDENIED)
        CASE_SCODE(STG_E_INVALIDHANDLE)
        CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
        CASE_SCODE(STG_E_INVALIDPOINTER)
        CASE_SCODE(STG_E_NOMOREFILES)
        CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
        CASE_SCODE(STG_E_SEEKERROR)
        CASE_SCODE(STG_E_WRITEFAULT)
        CASE_SCODE(STG_E_READFAULT)
        CASE_SCODE(STG_E_LOCKVIOLATION)
        CASE_SCODE(STG_E_FILEALREADYEXISTS)
        CASE_SCODE(STG_E_INVALIDPARAMETER)
        CASE_SCODE(STG_E_MEDIUMFULL)
        CASE_SCODE(STG_E_ABNORMALAPIEXIT)
        CASE_SCODE(STG_E_INVALIDHEADER)
        CASE_SCODE(STG_E_INVALIDNAME)
        CASE_SCODE(STG_E_UNKNOWN)
        CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
        CASE_SCODE(STG_E_INVALIDFLAG)
        CASE_SCODE(STG_E_INUSE)
        CASE_SCODE(STG_E_NOTCURRENT)
        CASE_SCODE(STG_E_REVERTED)
        CASE_SCODE(STG_E_CANTSAVE)
        CASE_SCODE(STG_E_OLDFORMAT)
        CASE_SCODE(STG_E_OLDDLL)
        CASE_SCODE(STG_E_SHAREREQUIRED)
        CASE_SCODE(STG_S_CONVERTED)
        //CASE_SCODE(STG_S_BUFFEROVERFLOW)
        //CASE_SCODE(STG_S_TRYOVERWRITE)

        /* SCODE's defined in COMPOBJ.H */
        CASE_SCODE(CO_E_NOTINITIALIZED)
        CASE_SCODE(CO_E_ALREADYINITIALIZED)
        CASE_SCODE(CO_E_CANTDETERMINECLASS)
        CASE_SCODE(CO_E_CLASSSTRING)
        CASE_SCODE(CO_E_IIDSTRING)
        CASE_SCODE(CO_E_APPNOTFOUND)
        CASE_SCODE(CO_E_APPSINGLEUSE)
        CASE_SCODE(CO_E_ERRORINAPP)
        CASE_SCODE(CO_E_DLLNOTFOUND)
        CASE_SCODE(CO_E_ERRORINDLL)
        CASE_SCODE(CO_E_WRONGOSFORAPP)
        CASE_SCODE(CO_E_OBJNOTREG)
        CASE_SCODE(CO_E_OBJISREG)
        CASE_SCODE(CO_E_OBJNOTCONNECTED)
        CASE_SCODE(CO_E_APPDIDNTREG)
        CASE_SCODE(CLASS_E_NOAGGREGATION)
        CASE_SCODE(REGDB_E_READREGDB)
        CASE_SCODE(REGDB_E_WRITEREGDB)
        CASE_SCODE(REGDB_E_KEYMISSING)
        CASE_SCODE(REGDB_E_INVALIDVALUE)
        CASE_SCODE(REGDB_E_CLASSNOTREG)
        CASE_SCODE(REGDB_E_IIDNOTREG)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(RPC_E_SERVER_DIED)
        CASE_SCODE(RPC_E_CALL_REJECTED)
        CASE_SCODE(RPC_E_CALL_CANCELED)
        CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
        CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
        CASE_SCODE(RPC_E_CLIENT_DIED)
        CASE_SCODE(RPC_E_INVALID_DATAPACKET)
        CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
        CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_INVALID_DATA)
        CASE_SCODE(RPC_E_INVALID_PARAMETER)
        CASE_SCODE(RPC_E_UNEXPECTED)
#endif // NO_NTOLEBUGS

        /* SCODE's defined in MONIKER.H */
        CASE_SCODE(MK_E_CONNECTMANUALLY)
        CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
        CASE_SCODE(MK_E_NEEDGENERIC)
        CASE_SCODE(MK_E_UNAVAILABLE)
        CASE_SCODE(MK_E_SYNTAX)
        CASE_SCODE(MK_E_NOOBJECT)
        CASE_SCODE(MK_E_INVALIDEXTENSION)
        CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
        CASE_SCODE(MK_E_NOTBINDABLE)
        CASE_SCODE(MK_E_NOTBOUND)
        CASE_SCODE(MK_E_CANTOPENFILE)
        CASE_SCODE(MK_E_MUSTBOTHERUSER)
        CASE_SCODE(MK_E_NOINVERSE)
        CASE_SCODE(MK_E_NOSTORAGE)
        CASE_SCODE(MK_S_REDUCED_TO_SELF)
        CASE_SCODE(MK_S_ME)
        CASE_SCODE(MK_S_HIM)
        CASE_SCODE(MK_S_US)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
#endif //NO_NTOLEBUGS

    default:
        lpstr = TEXT(" <UNKNOWN SCODE  0x%lx>\n");
        break;
    }

#undef CASE_SCODE

    TCHAR achTemp[256];
#ifdef UNICODE    
    wsprintf(achTemp, TEXT("%ws"), lpstr);
#else
    wsprintf(achTemp, TEXT("%s"), lpstr);
#endif        
    OutputDebugString( achTemp );
    return r;
}

#endif  // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\memutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       memutils.cxx
//
//  Contents:   IMalloc-related helpers
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

HRESULT
OleAllocMem(MEMCTX ctx, ULONG cb, LPVOID FAR* ppv)
{
    HRESULT r;
    LPMALLOC pMalloc;
    if (OK(r = CoGetMalloc(ctx, &pMalloc)))
    {
        *ppv = pMalloc->Alloc(cb);
        if (*ppv == NULL)
        {
            DOUT(TEXT("o2base/memutils/OleAllocMem failed\r\n"));
            r = E_OUTOFMEMORY;
        }

        pMalloc->Release();
    }
    return r;
}

void
OleFreeMem(MEMCTX ctx, LPVOID pv)
{
    LPMALLOC pMalloc;
    if (OK(CoGetMalloc(ctx, &pMalloc)))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

HRESULT
OleAllocString(MEMCTX ctx, LPCOLESTR lpstrSrc, LPOLESTR FAR* ppstr)
{
    HRESULT r;
    if (lpstrSrc == NULL)
    {
        *ppstr = NULL;
        r = NOERROR;
    }
    else
    {
        r = OleAllocMem(ctx,
                (ostrlen(lpstrSrc)+1) * sizeof(OLECHAR),
                (LPVOID FAR*)ppstr);
        if (*ppstr != NULL)
        {
            ostrcpy((LPOLESTR)*ppstr, lpstrSrc);
        }
    }
    return r;
}

void
OleFreeString(MEMCTX ctx, LPOLESTR lpstr)
{
    OleFreeMem(ctx, lpstr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\dvutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       dvutils.cxx
//
//  Contents:   Helper functions for implementing IDataObject and IViewObject
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//
//  Globals
//

UINT OleClipFormat[OCF_LAST+1];         // array of OLE standard clipboard formats

// these are the names of the standard OLE clipboard formats that need to
// be registered.
LPTSTR OleClipNames[OCF_LAST+1] =
{
    TEXT("ObjectLink"),
    TEXT("OwnerLink"),
    TEXT("Native"),
    TEXT("FileName"),
    TEXT("NetworkName"),
    TEXT("DataObject"),
    TEXT("Embedded Object"),
    TEXT("Embed Source"),
    TEXT("Link Source"),
    TEXT("Link Source Descriptor"),
    TEXT("Object Descriptor"),
    TEXT("OleDraw")
};


//+---------------------------------------------------------------
//
//  Function:   RegisterOleClipFormats
//
//  Synopsis:   Initializes the OleClipFormat table of standard
//              OLE clipboard formats.
//
//  Notes:      The OleClipFormat table is a table of registered,
//              standard, OLE-related clipboard formats.  The table
//              is indexed by the OLECLIPFORMAT enumeration.
//              Before this table can be used it must be initialized
//              via this function.
//              This function is usually called in the WinMain or
//              LibMain of the module using the OleClipFormat table.
//
//----------------------------------------------------------------

void
RegisterOleClipFormats(void)
{
    for (int i = 0; i<= OCF_LAST; i++)
        OleClipFormat[i] = RegisterClipboardFormat(OleClipNames[i]);
}

//+---------------------------------------------------------------
//
//  Function:   IsCompatibleDevice, public
//
//  Synopsis:   Compares two DEVICETARGET structures and returns
//              TRUE if they are compatible.
//
//  Arguments:  [ptdLeft] -- A pointer to a device target
//              [ptdRight] -- Another pointer to a device target
//
//  Notes:      The target devices are compatible if they are both
//              NULL or if they are identical.  Otherwise they are
//              incompatible.
//
//----------------------------------------------------------------

BOOL
IsCompatibleDevice(DVTARGETDEVICE FAR* ptdLeft, DVTARGETDEVICE FAR* ptdRight)
{
    // same address of td; must be same (handles NULL case)
    if (ptdLeft == ptdRight)
        return TRUE;

#if 1
    
//fix for NTbug 20692 - reason: see bad assumption below
    if ((ptdRight == DVTARGETIGNORE) || (ptdLeft == DVTARGETIGNORE))
        return TRUE;
    
#endif    

//        The following is a wrong assumption for device independant formats
//        like CF_DIB and CF_METAFILE
    
    // if ones NULL, and the others not then they are incompatible
    if ((ptdRight == NULL) || (ptdLeft == NULL))
        return FALSE;

    // different sizes, not equal
    if (ptdLeft->tdSize != ptdRight->tdSize)
        return FALSE;

    return _fmemcmp(ptdLeft, ptdRight, (size_t)ptdLeft->tdSize) == 0;
}

//+---------------------------------------------------------------
//
//  Function:   IsCompatibleFormat, public
//
//  Synopsis:   Compares two FORMATETC structures and returns
//              TRUE if they are compatible.
//
//  Arguments:  [f1] -- A FORMATETC structure
//              [f2] -- Another FORMATETC structure
//
//  Notes:      This function ignores the lindex member of the
//              FORMATETCs.
//
//----------------------------------------------------------------

BOOL
IsCompatibleFormat(FORMATETC& f1, FORMATETC& f2)
{
    return f1.cfFormat == f2.cfFormat
            && IsCompatibleDevice(f1.ptd, f2.ptd)
            && (f1.dwAspect & f2.dwAspect) != 0L
            && (f1.tymed & f2.tymed) != 0;
}

//+---------------------------------------------------------------
//
//  Function:   FindCompatibleFormat
//
//  Synopsis:   Searches a table of FORMATETC structures and
//              returns the index of the first entry that is
//              compatible with a specified FORMATETC.
//
//  Arguments:  [FmtTable] -- the table of FORMATETCs
//              [iSize] -- the number of entries in the format table
//              [formatetc] -- the FORMATETC we are comparing for compatibility
//
//  Returns:    The index into the table of the compatible format, or
//              -1 if no compatible format was found.
//
//  Notes:      This function is typically used in conjunction with
//              IDataObject methods that need to check if a requested format
//              is available.
//
//----------------------------------------------------------------

int
FindCompatibleFormat(FORMATETC FmtTable[], int iSize, FORMATETC& formatetc)
{
    // look through the table for a compatible format
    for (int i = 0; i < iSize; i++)
    {
        if (IsCompatibleFormat(formatetc, FmtTable[i]))
            return i;
    }
    return -1;
}


//+---------------------------------------------------------------
//
//  Function:   GetObjectDescriptor
//
//  Synopsis:   Extracts an OBJECTDESCRIPTOR from an IDataObject,
//              if available.
//
//  Arguments:  [pDataObj] -- data object from which to extract an object descriptor
//              [pDescOut] -- object descriptor structure to fill in
//
//  Returns:    Success iff the object descriptor could be extracted.
//              This does not copy out the dwFullUserTypeName or
//              dwSrcOfCopy strings.
//
//----------------------------------------------------------------

HRESULT
GetObjectDescriptor(LPDATAOBJECT pDataObj, LPOBJECTDESCRIPTOR pDescOut)
{
    HRESULT r;
    HGLOBAL hglobal = GlobalAlloc(GMEM_SHARE, sizeof(OBJECTDESCRIPTOR)+256);
    LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hglobal);
    if (pObjDesc == NULL)
    {
        DOUT(TEXT("o2base/dvutils/GetObjectDescriptor failed\r\n"));
        r = E_OUTOFMEMORY;
    }
    else
    {
        FORMATETC formatetc =
            { (WORD)OleClipFormat[OCF_OBJECTDESCRIPTOR],
                NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

        STGMEDIUM stgmedium;
        stgmedium.tymed = TYMED_HGLOBAL;
        stgmedium.hGlobal = hglobal;
        stgmedium.pUnkForRelease = NULL;

        if (OK(r = pDataObj->GetDataHere(&formatetc, &stgmedium)))
        {
            if (pDescOut != NULL)
            {
                // note: in the future we may wish to copy out the strings
                // into two out parameters.  This would be used in
                // implementing the Paste Special dialog box.
                *pDescOut = *pObjDesc;
                pDescOut->dwFullUserTypeName = 0;
                pDescOut->dwSrcOfCopy = 0;
            }
        }
        GlobalUnlock(hglobal);
        GlobalFree(hglobal);
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   UpdateObjectDescriptor
//
//  Synopsis:   Updates the pointl and dwDrawAspects of an OBJECTDESCRIPTOR
//              on a data object
//
//  Arguments:  [pDataObj] -- the data object to update
//              [ptl] -- the pointl to update in the object descriptor
//              [dwAspect] -- the draw aspect to update in the object descriptor
//
//  Returns:    Success iff the object descriptor could be updated
//
//  Notes:      This method is for IDataObjects used in drag-drop.
//              The object being dragged supplies the object descriptor but only
//              the container knows where the point that the mouse button went
//              down relative to the corner of the object, and what aspect
//              of the object the container is displaying.
//              The container uses this method to fill in that missing information.
//              This performs a GetDataHere on the object to get a filled-in
//              object descriptor.  It then updates the pointl and dwDrawAspect
//              fields and uses SetData to update the object.
//
//----------------------------------------------------------------

HRESULT
UpdateObjectDescriptor(LPDATAOBJECT pDataObj, POINTL& ptl, DWORD dwAspect)
{
    HRESULT r;
    HGLOBAL hglobal = GlobalAlloc(GMEM_SHARE, sizeof(OBJECTDESCRIPTOR)+256);
    LPOBJECTDESCRIPTOR pObjDesc = (LPOBJECTDESCRIPTOR)GlobalLock(hglobal);
    if (pObjDesc == NULL)
    {
        DOUT(TEXT("o2base/dvutils/UpdateObjectDescriptor failed\r\n"));
        r = E_OUTOFMEMORY;
    }
    else
    {
        FORMATETC formatetc =
            { (WORD)OleClipFormat[OCF_OBJECTDESCRIPTOR],
                NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

        STGMEDIUM stgmedium;
        stgmedium.tymed = TYMED_HGLOBAL;
        stgmedium.hGlobal = hglobal;
        stgmedium.pUnkForRelease = NULL;

        if (OK(r = pDataObj->GetDataHere(&formatetc, &stgmedium)))
        {
            pObjDesc->pointl = ptl;
            pObjDesc->dwDrawAspect = dwAspect;
            r = pDataObj->SetData(&formatetc, &stgmedium, FALSE);
        }
        GlobalUnlock(hglobal);
        GlobalFree(hglobal);
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   DrawMetafile
//
//  Synopsis:   Creates a metafile from an IViewObject using the Draw method
//
//  Arguments:  [pVwObj] -- the view object
//              [rc] -- rectangle on the view object to draw
//              [dwAspect] -- aspect of the view object to draw, typically
//                           content or icon
//              [pHMF] -- place where handle to the metafile is drawn
//
//  Returns:    Success iff the metafile was drawn successfully.
//
//----------------------------------------------------------------

HRESULT
DrawMetafile(LPVIEWOBJECT pVwObj,
        RECT& rc,
        DWORD dwAspect,
        HMETAFILE FAR* pHMF)
{
    HRESULT hr;
    HMETAFILE hmf = NULL;
    HDC hdc;

    if ((hdc = CreateMetaFile(NULL)) == NULL)
    {
        DOUT(TEXT("o2base/dvutils/DrawMetafile failed to create metafile\r\n"));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        SetMapMode(hdc, MM_ANISOTROPIC);
        SetWindowOrgEx(hdc, 0, 0, NULL);
        SetWindowExtEx(hdc, rc.right, rc.bottom, NULL);

        hr = OleDraw(pVwObj, dwAspect, hdc, &rc);

        hmf = CloseMetaFile(hdc);

        if (!OK(hr))
        {
            DeleteMetaFile(hmf);
            hmf = NULL;
        }

        if (hmf == NULL)
        {
            DOUT(TEXT("o2base/dvutils/DrawMetafile failed\r\n"));
            hr = E_OUTOFMEMORY;
        }
    }
    *pHMF = hmf;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\himetric.cxx ===
//+---------------------------------------------------------------------
//
//  File:       himetric.cxx
//
//  Contents:   Routines to convert Pixels to Himetric and vice versa
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define HIMETRIC_PER_INCH 2540L

//+---------------------------------------------------------------
//
//  Function:   HimetricFromHPix
//
//  Synopsis:   Converts horizontal pixel units to himetric units.
//
//----------------------------------------------------------------

long
HimetricFromHPix(int iPix)
{
   HDC hdc = GetDC(NULL);
   if (!hdc) 
       return 0;
   int iPPLI = GetDeviceCaps(hdc, LOGPIXELSX);
   ReleaseDC(NULL, hdc);

   return (HIMETRIC_PER_INCH * (long)iPix)/(long)iPPLI;
}

//+---------------------------------------------------------------
//
//  Function:   HimetricFromVPix
//
//  Synopsis:   Converts vertical pixel units to himetric units.
//
//----------------------------------------------------------------

long
HimetricFromVPix(int iPix)
{
   HDC hdc = GetDC(NULL);
   if (!hdc) 
       return 0;
   int iPPLI = GetDeviceCaps(hdc, LOGPIXELSY);
   ReleaseDC(NULL, hdc);
   return (HIMETRIC_PER_INCH * (long)iPix)/(long)iPPLI;
}

//+---------------------------------------------------------------
//
//  Function:   HPixFromHimetric
//
//  Synopsis:   Converts himetric units to horizontal pixel units.
//
//----------------------------------------------------------------

int
HPixFromHimetric(long lHi)
{
   HDC hdc = GetDC(NULL);
   if (!hdc) 
       return 0;
   int iPPLI = GetDeviceCaps(hdc, LOGPIXELSX);
   ReleaseDC(NULL, hdc);
   return (int)(( (iPPLI * lHi) + (HIMETRIC_PER_INCH / 2) )/HIMETRIC_PER_INCH);
}

//+---------------------------------------------------------------
//
//  Function:   VPixFromHimetric
//
//  Synopsis:   Converts himetric units to vertical pixel units.
//
//----------------------------------------------------------------

int
VPixFromHimetric(long lHi)
{
   HDC hdc = GetDC(NULL);
   if (!hdc) 
       return 0;
   int iPPLI = GetDeviceCaps(hdc, LOGPIXELSY);
   ReleaseDC(NULL, hdc);
   return (int)(( (iPPLI * lHi) + (HIMETRIC_PER_INCH / 2) )/HIMETRIC_PER_INCH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\rotutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       rotutils.cxx
//
//  Contents:   Running Object Table helper functions
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------
//
//  Function:   RegisterAsRunning
//
//  Synopsis:   Registers the object in the Running Object Table
//
//  Arguments:  [lpUnk] -- the object being registered
//              [lpmkFull] -- the full moniker to the object
//              [lpdwRegister] -- where the registration value will be
//                                  returned.
//
//  Notes:      c.f. RevokeAsRunning
//
//----------------------------------------------------------------

void
RegisterAsRunning(LPUNKNOWN lpUnk,
        LPMONIKER lpmkFull,
        DWORD FAR* lpdwRegister)
{
    LPRUNNINGOBJECTTABLE pROT;
    HRESULT r;

    if (OK(r = GetRunningObjectTable(0,(LPRUNNINGOBJECTTABLE FAR*)&pROT)))
    {
        // if already registered, revoke
        if (*lpdwRegister != NULL)
        {
            pROT->Revoke(*lpdwRegister);
            *lpdwRegister = NULL;
        }

        // register as running if a valid moniker is passed
        if (lpmkFull)
        {
            pROT->Register(NULL, lpUnk, lpmkFull, lpdwRegister);
        }

        pROT->Release();
    }
}


//+---------------------------------------------------------------
//
//  Function:   RevokeAsRunning
//
//  Synopsis:   Revokes an objects registration in the Running Object Table
//
//  Arguments:  [lpdwRegister] -- points to where the registration value is
//                                  for the object.  Will be set to NULL.
//
//  Notes:      c.f. RegisterAsRunning
//
//----------------------------------------------------------------

void
RevokeAsRunning(DWORD FAR* lpdwRegister)
{
    LPRUNNINGOBJECTTABLE pROT;
    HRESULT r;

    // if still registered, then revoke
    if (*lpdwRegister != NULL)
    {
        if (OK(r = GetRunningObjectTable(0,(LPRUNNINGOBJECTTABLE FAR*)&pROT)))
        {
            pROT->Revoke(*lpdwRegister);
            *lpdwRegister = NULL;
            pROT->Release();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\sctrl.cxx ===
//+---------------------------------------------------------------------
//
//   File:       sctrl.cxx
//
//------------------------------------------------------------------------

//[ srvr_overview
/*
                        Srvr Library Overview

The Srvr library is a set of C++ base classes intended to greatly simplify
the process of implementing an OLE Compound Document object DLL in C++.
This library requires the O2UTIL library and and understanding of elements
in that library is prerequisite to a complete understanding of these base
classes.  Consult documentation for the O2UTIL library.

The library consists of three C++ base classes: SrvrCtrl, SrvrDV, and
SrvrInPlace.  An OLE Compound Document object implemented using the Srvr
library is an aggregate of three subobjects -- the control, data/view
and in-place subobjects.  The implementations of these subobjects are C++
classes that inherit from SrvrCtrl, SrvrDV, and SrvrInPlace respectively.
Behaviour specific to the C.D. object type is implemented
by overriding virtual methods on the base classes.  The base classes are
designed so that a simple but functional server can be implemented by overriding
only a small number of virtual methods.  Progressively more advanced servers
can be implemented by deriving more virtual methods and adding support for
new interfaces in the derived classes.

In the following discussion, the unqualified term "object" refers to an OLE
Compound Document (C.D.) object.  The term "subobject" refers to a C++ object
whose class inherits from one of the Srvr base classes.

The data/view subobject encapsulates the persistent data of an object and the
rendering of that data.  This subobject supports the IDataObject, IViewObject,
and the IPersist family of interfaces.  These subobjects can also function
independently as a data transfer object for clipboard and drag-drop operations.

The control subobject manages the dynamic control of the object.  This subobject
supports the IOleObject interface and directs all state transitions of the object.

The in-place subobject is responsible for the child window and user interface
of an object while it is in-place active.  The subobject supports the
IOleInPlaceObject and IOleInPlaceActiveObject interfaces.  This subobject is
not required for objects that don't support in-place editing.

The control subobject controls the aggregate and holds pointers to the data/view
and inplace subobjects.  It maintains the reference count for the object as a
whole and delegates QueryInterfaces to the other subobjects for interfaces
that it does not handle.  The data/view and in-place subobjects each hold a
pointer to the control subobject.  They each forward their IUnknown methods
to the control.  When a data/view subobject is being used independently as
a data-transfer object then its control pointer is NULL.

For more information consult the overview sections for each of the base
classes and the documentation for the base class methods.

*/
//]

//[ srvrctrl_overview
/*
                        SrvrCtrl Overview

The SrvrCtrl base class implements the control aspects common to most
OLE Compound Document objects.  It records the state of the object and
directs the state transitions.  It implements the IOleObject interface.

An object is in one of five possible states: passive, loaded, in-place,
U.I. active, or opened.  An object is passive when it is holding no
resources.  This is true for objects that are newly created or have
been released.  An object becomes loaded when it gets
an IPersistXXX::Load or IPersistStorage::InitNew call and has loaded
or initialized the necessary part of its persistent state.  An object in
the in-place state has a child window in its containers window and
can receive window messages.  The object (nor any of its embeddings)
does not have its U.I. visible (e.g. shared menu or toolbars).
A U.I. active object does have its (or one of its embeddings) U.I. visible.
An open object is one that is being open-edited in a separate, top-level
window.

Part of implementing the control subobject of an OLE Compound Document object
is implementing verbs.  There are a number of standard, OLE-defined verbs
and an object can add its own.  Since the set of verbs is very object
dependent SrvrCtrl requires a derived class to supply tables indicating
the verbs that are supported.  One is table of OLEVERB structures giving
standard information about the verb including the verb number and name.
A parallel table contains a pointer for each verb pointing to a function
that implements that verb.  SrvrCtrl has a set of static methods that
implement the standard OLE verbs.  The derived class can include these methods
in its verb table.  SrvrCtrl implements all the IOleObject verb-related
methods using these two verb tables.  The verb tables must be in order
of verb number and must be contiguous (i.e. no missing verb numbers).

*/
//]

#include "headers.hxx"
#pragma hdrstop


//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SrvrCtrl, protected
//
//  Synopsis:   Constructor for SrvrCtrl object
//
//  Notes:      To create a properly initialized object you must
//              call the Init method immediately after construction.
//
//---------------------------------------------------------------

SrvrCtrl::SrvrCtrl(void)
{
    DOUT(TEXT("SrvrCtrl: Constructing\r\n"));

    _pDV        = NULL;
    _pInPlace   = NULL;
    _pPrivUnkDV = NULL;
    _pPrivUnkIP = NULL;

     // site-related information
    _pClientSite = NULL;
    _pOleAdviseHolder = NULL;
    _pClass = NULL;

    _dwRegROT = 0;

    _lpstrCntrApp = NULL;
    _lpstrCntrObj = NULL;
    
#if !defined(UNICODE) && !defined(OLE2ANSI)
    _lpstrCntrAppA = NULL;
    _lpstrCntrObjA = NULL;
#endif
    
    _state = OS_PASSIVE;

    EnableIPB(TRUE);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::Init, protected
//
//  Synopsis:   Fully initializes a SrvrCtrl object
//
//  Arguments:  [pClass] -- The initialized class descriptor for the server
//              [pUnkOuter] -- The controlling unknown if this server is being
//                          created as part of an aggregate; NULL otherwise
//
//  Returns:    NOERROR if successful
//
//  Notes:      The class descriptor pointer is saved in the protected _pClass
//              member variable where it is accessible during the lifetime
//              of the object.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::Init(LPCLASSDESCRIPTOR pClass)
{
    _pClass = pClass;
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::~SrvrCtrl, protected
//
//  Synopsis:   Destructor for the SrvrCtrl object
//
//  Notes:      The destructor is called as a result of the servers
//              reference count going to 0.  It ensure the object
//              is in a passive state and releases the data/view and inplace
//              subobjects objects.
//
//---------------------------------------------------------------

SrvrCtrl::~SrvrCtrl(void)
{
    DOUT(TEXT("~~~~~SrvrCtrl::~OPCtrl\r\n"));
    // note: we don't have to release _pDV and _pInPlace because
    // we should have released them right away (standard aggregation policy)
    // We must release the private unknowns of those two subobjects, though.

    if (_pPrivUnkIP)
        _pPrivUnkIP->Release();
    if (_pPrivUnkDV)
        _pPrivUnkDV->Release();

    // free our advise holder
    if(_pOleAdviseHolder != NULL)
        _pOleAdviseHolder->Release();

    // release our client site
    TaskFreeString(_lpstrCntrApp);
    TaskFreeString(_lpstrCntrObj);
    
#if !defined(UNICODE) && !defined(OLE2ANSI)
    TaskFreeMem(_lpstrCntrAppA);
    TaskFreeMem(_lpstrCntrObjA);
#endif
    
    if (_pClientSite != NULL)
        _pClientSite->Release();
    DOUT(TEXT("SrvrCtrl: Destructed\r\n"));
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::TransitionTo, public
//
//  Synopsis:   Drives the transition of the object from one state to another
//
//  Arguments:  [state] -- the desired resulting state of the object
//
//  Returns:    Success iff the transition completed successfully.  On failure
//              the object will be in the original or some intermediate,
//              but consistent, state.
//
//  Notes:      There are eight direct state transitions.  These are:
//              between the passive and loaded states, between the
//              loaded and inplace states, between the inplace and U.I. active
//              states, and between the loaded and opened states.
//              Each of these direct transitions has an overridable method
//              that effects it.  The TransitionTo function implements
//              transitions between any two arbitrary states by calling
//              these direct transition methods in the proper order.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::TransitionTo(OLE_SERVER_STATE state)
{
#if DBG
    TCHAR achTemp[256];
    wsprintf(achTemp,TEXT("[%d] --> [%d] SrvrCtrl::TransitionTo\n\r"),(int)_state,(int)state);
    DOUT(achTemp);
#endif //DBG

    Assert(state >= OS_PASSIVE && state <= OS_OPEN);
    Assert(_state >= OS_PASSIVE && _state <= OS_OPEN);

    //
    // at each iteration we transition one state closer to
    // our destination state...
    //
    HRESULT hr = NOERROR;
    while (state != _state && OK(hr))
    {
        switch(_state)
        {
        case OS_PASSIVE:
            // from passive we can only go to loaded!
            if (OK(hr = PassiveToLoaded()))
                _state = OS_LOADED;

            break;

        case OS_LOADED:
            switch(state)
            {
            default:
                if (OK(hr = LoadedToRunning()))
                    _state = OS_RUNNING;
                break;

            case OS_PASSIVE:
                if (OK(hr = LoadedToPassive()))
                    _state = OS_PASSIVE;
                break;
            }
            break;

        case OS_RUNNING:
            switch(state)
            {
            default:
            case OS_LOADED:
                if (OK(hr = RunningToLoaded()))
                    _state = OS_LOADED;
                break;
            case OS_INPLACE:
            case OS_UIACTIVE:
                if (OK(hr = RunningToInPlace()))
                    _state = OS_INPLACE;
                break;
            case OS_OPEN:
                if (OK(hr = RunningToOpened()))
                    _state = OS_OPEN;
                break;
            }
            break;

        case OS_INPLACE:
            switch(state)
            {
            default:
                if (OK(hr = InPlaceToRunning()))
                {
                    //
                    // The following handles re-entrancy cases in which
                    // processing of this state transition caused us to
                    // reach a state below our current target state...
                    if(_state < OS_RUNNING)
                        goto LExit;

                    _state = OS_RUNNING;
                }
                
                break;
            case OS_UIACTIVE:
                if (OK(hr = InPlaceToUIActive()))
                    _state = OS_UIACTIVE;
                break;
            }
            break;

        case OS_UIACTIVE:
            // from UIActive we can only go to inplace
            if (OK(hr = UIActiveToInPlace()))
            {
                //
                // In the course of notifying the container that we
                // are no longer UIActive, it is possible that we
                // got InPlace deactivated (or worse, Closed).
                // If this happened we abort our currently targeted
                // transition...
                if(_state < OS_INPLACE)
                    goto LExit;

                _state = OS_INPLACE;
            }
            break;

        case OS_OPEN:
            // from Open we can only go to running
            if (OK(hr = OpenedToRunning()))
                _state = OS_RUNNING;
            break;
        }
    }

LExit:
#if DBG
    wsprintf(achTemp,TEXT("SrvrCtrl::TransitionTo [%d] hr = %lx\n\r"),(int)_state, hr);
    DOUT(achTemp);
#endif //DBG
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::PassiveToLoaded, protected
//
//  Synopsis:   Effects the direct passive to loaded state transition
//
//  Returns:    Success iff the object is in the loaded state.  On failure
//              the object will be in a consistent passive state.
//
//  Notes:      The base class does not do any processing on this transition.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::PassiveToLoaded(void)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::LoadedToRunning, protected
//
//  Synopsis:   Effects the direct loaded to running state transition
//
//  Returns:    Success if the object is running.
//
//  Notes:      This transition occurs as a result of an
//              IRunnableObject::Run call (TBD) and is implicit in any
//              DoVerb call.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::LoadedToRunning(void)
{
    DOUT(TEXT("SrvrCtrl::LoadedToRunning\r\n"));
    //
    // enter ourself in the Running Object Table
    //
    LPMONIKER pmk;
    if (OK(_pDV->GetMoniker(OLEGETMONIKER_ONLYIFTHERE, &pmk)))
    {
        RegisterAsRunning((LPUNKNOWN)this, pmk, &_dwRegROT);
        pmk->Release();
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::LoadedToPassive, protected
//
//  Synopsis:   Effects the direct loaded to passive state transition
//
//  Returns:    Success if the object is loaded.
//
//  Notes:      This transition occurs as a result of an IOleObject::Close()
//              call.
//              This method sends an OnClose notification to all of our
//              advises.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::LoadedToPassive(void)
{
    DOUT(TEXT("SrvrCtrl::LoadedToPassive\r\n"));

    // notify our data advise holders of 'stop'
    _pDV->OnDataChange(ADVF_DATAONSTOP);
    
    // notify our advise holders that we have closed
    if (_pOleAdviseHolder != NULL)
    {
        DOUT(TEXT("SrvrCtrl::LoadedToPassive calling _pOleAdviseHolder->SendOnClose()\r\n"));
        _pOleAdviseHolder->SendOnClose();
    }

    // forcibly cut off remoting clients???
    //CoDisconnectObject((LPUNKNOWN)this, 0);

    //
    // revoke our entry in the running object table
    //
    if (_dwRegROT != 0)
    {
        DOUT(TEXT(".-.-.SrvrCtrl::RunningToLoaded calling RevokeAsRunning\r\n"));
        RevokeAsRunning(&_dwRegROT);
        _dwRegROT = 0;
    }

    DOUT(TEXT("SrvrCtrl::LoadedToPassive (returning)\r\n"));
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::RunningToLoaded, protected
//
//  Synopsis:   Effects the direct running to loaded state transition
//
//  Returns:    Success if the object is loaded.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::RunningToLoaded(void)
{
    DOUT(TEXT("SrvrCtrl::RunningToLoaded\r\n"));
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::RunningToOpened, protected
//
//  Synopsis:   Effects the direct running to opened state transition
//
//  Returns:    Success if the object is open-edited.
//
//  Notes:      Open-editing is not yet supported.  This returns E_FAIL.
//
//              The derived class MUST completely override this
//              transition to implement an open-ediing server!
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::RunningToOpened(void)
{
    DOUT(TEXT("SrvrCtrl::RunningToOpened E_FAIL\r\n"));
    return E_FAIL;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::OpenedToRunning, protected
//
//  Synopsis:   Effects the direct opened to running state transition
//
//  Returns:    Success if the open-editing session was shut down
//
//  Notes:      This occurs as the result of a DoVerb(HIDE...)
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::OpenedToRunning(void)
{
    // notify our container so it can un-hatch
    if (_pClientSite != NULL)
        _pClientSite->OnShowWindow(FALSE);

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::RunningToInPlace, protected
//
//  Synopsis:   Effects the direct Running to inplace state transition
//
//  Returns:    Success iff the object is in the inplace state.  On failure
//              the object will be in a consistent Running state.
//
//  Notes:      This transition invokes the ActivateInPlace method on the
//              inplace subobject of the server, if there is one.  Containers
//              will typically override this method in order to additionally
//              inplace activate any inside-out embeddings that are visible.
//              If the server does not support in-place
//              activation then this method will return E_UNEXPECTED.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::RunningToInPlace(void)
{
    if (_pInPlace == NULL)
    {
        DOUT(TEXT("SrvrCtrl::RunningToInPlace E_FAIL\r\n"));
        return E_FAIL;
    }

    return _pInPlace->ActivateInPlace(_pClientSite);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::InPlaceToRunning, protected
//
//  Synopsis:   Effects the direct inplace to Running state transition
//
//  Returns:    Success under all but catastrophic circumstances.
//
//  Notes:      This transition invokes the DeactivateInPlace method on the
//              inplace subobject of the server, if there is one.  Containers
//              will typically override this method in order to additionally
//              inplace deactivate any inplace-active embeddings.
//              If the server does not support in-place activation then
//              this method will never be called.
//              This method is called as the result of a DoVerb(HIDE...)
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::InPlaceToRunning(void)
{
    Assert(_pInPlace != NULL);
    return _pInPlace->DeactivateInPlace();
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::InPlaceToUIActive, protected
//
//  Synopsis:   Effects the direct inplace to U.I. active state transition
//
//  Returns:    Success iff the object is in the U.I. active state.  On failure
//              the object will be in a consistent inplace state.
//
//  Notes:      This transition invokes the ActivateUI methods on the inplace
//              subobject of the server.
//              If the server does not support in-place activation then
//              this method will never be called.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::InPlaceToUIActive(void)
{
    Assert(_pInPlace != NULL);
    return _pInPlace->ActivateUI();
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::UIActiveToInPlace, protected
//
//  Synopsis:   Effects the direct U.I. Active to inplace state transition
//
//  Returns:    Success under all but catastrophic circumstances.
//
//  Notes:      This transition invokes the DeactivateUI methods
//              on the inplace subobject of the server.  Containers
//              will typically override this method in order to possibly
//              U.I. deactivate a U.I. active embedding.
//              If the server does not support in-place activation then
//              this method will never be called.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::UIActiveToInPlace(void)
{
    Assert(_pInPlace != NULL);
    return _pInPlace->DeactivateUI();
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::OnSave, public
//
//  Synopsis:   Raises the OnSave advise to any registered advises
//
//  Notes:      This method is called by the data/view subobject upon
//              successful completion of a save operation.
//
//---------------------------------------------------------------

void
SrvrCtrl::OnSave(void)
{
    if (_pOleAdviseHolder != NULL)
        _pOleAdviseHolder->SendOnSave();
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::DoShow, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_SHOW
//
//  Arguments:  [pv] -- pointer to a SrvrCntrl object.
//              All other parameters are the same as the IOleObject::DoVerb
//              method.
//
//  Returns:    Success if the verb was successfully executed
//
//  Notes:      This and the other static Do functions are provided for
//              use in the server's verb table.  This verb results in
//              a ShowObject call on our container and a transition
//              to the U.I. active state
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::DoShow(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    HRESULT hr = NOERROR;

#if DBG    
    TCHAR achTemp[256];
    wsprintf(achTemp,TEXT("SrvrCtrl::DoShow [%d]\n\r"),(int)pCtrl->State());
    DOUT(achTemp);
#endif    

    if (pCtrl->_pClientSite != NULL)
    {
        pCtrl->_pClientSite->ShowObject();
        if(pCtrl->State() == OS_OPEN)
        {
            HWND hwnd = NULL;
            if(pCtrl->_pInPlace)
                pCtrl->_pInPlace->GetWindow(&hwnd);
            if(hwnd != NULL)
                SetForegroundWindow(hwnd);
        }
        else
        {
            hr = pCtrl->TransitionTo(OS_UIACTIVE);
        }
    }
    
    if (!OK(hr))
    {
        // the default action is OPEN...
        hr = pCtrl->TransitionTo(OS_OPEN);
    }

    // if the verb was unknown then return Unknown Verb error.
    if (OK(hr) && iVerb != OLEIVERB_PRIMARY && iVerb != OLEIVERB_SHOW)
    {
        DOUT(TEXT("SrvrCtrl::DoShow returning OLEOBJ_S_INVALIDVERB\r\n"));
        hr = OLEOBJ_S_INVALIDVERB;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::DoOpen, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_OPEN.
//              This verb results in a transition to the open state.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::DoOpen(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    DOUT(TEXT("SrvrCtrl::DoOpen\r\n"));

    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    if(pCtrl->State() == OS_OPEN)
    {
        HWND hwnd = NULL;
        if(pCtrl->_pInPlace)
            pCtrl->_pInPlace->GetWindow(&hwnd);
        if(hwnd != NULL)
            SetForegroundWindow(hwnd);
    }
    return pCtrl->TransitionTo(OS_OPEN);
}

//+---------------------------------------------------------------
//
//  Member: SrvrCtrl::DoHide, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_HIDE
//              This verb results in a transition to the Running state.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::DoHide(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    DOUT(TEXT("SrvrCtrl::DoHide\r\n"));

    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    if(pCtrl != NULL)
    {
//jyg: ntbug 17327        
//        if(pCtrl->_state == OS_LOADED || pCtrl->_state == OS_PASSIVE)
//            return pCtrl->TransitionTo(OS_PASSIVE);
//        else
            return pCtrl->TransitionTo(OS_RUNNING);
    }
    else
    {
        DOUT(TEXT("SrvrCtrl::DoHide E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::DoUIActivate, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_UIACTIVATE
//              This verb results in a transition to the U.I. active state.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::DoUIActivate(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    HRESULT hr = pCtrl->TransitionTo(OS_UIACTIVE);
    if(OK(hr) && (lpmsg != NULL))
    {
        PostMessage(pCtrl->_pInPlace->WindowHandle(),
                lpmsg->message,
                lpmsg->wParam,
                lpmsg->lParam);
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::DoInPlaceActivate, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_INPLACEACTIVATE
//              This verb results in a transition to the inplace state.
//
//---------------------------------------------------------------

HRESULT
SrvrCtrl::DoInPlaceActivate(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    HRESULT hr = pCtrl->TransitionTo(OS_INPLACE);
    if(OK(hr) && (lpmsg != NULL))
    {
        PostMessage(pCtrl->_pInPlace->WindowHandle(),
                lpmsg->message,
                lpmsg->wParam,
                lpmsg->lParam);
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SetClientSite, public
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method saves the client site pointer in the
//              _pClientSite member variable.
//
//              We never fail!
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    //
    // if we already have a client site then release it
    //
    if (_pClientSite != NULL)
        _pClientSite->Release();

    //
    // if there is a new client site then hold on to it
    //
    _pClientSite = pClientSite;
    if (_pClientSite != NULL)
        _pClientSite->AddRef();

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetClientSite
//
//  Synopsis:   Method of IOleObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetClientSite(LPOLECLIENTSITE FAR* ppClientSite)
{
    if (ppClientSite == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetClientSite E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *ppClientSite = NULL;   // set out params to NULL

    //
    // if we have a client site then return it, but addref it first.
    //
    if (_pClientSite != NULL)
        (*ppClientSite = _pClientSite)->AddRef();

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SetHostNames
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method saves copies of the container-related strings
//              in the _lpstrCntrApp and _lpstrCntrObj member variables.
//
//              We never fail!
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::SetHostNames(LPCOLESTR lpstrCntrApp, LPCOLESTR lpstrCntrObj)
{
    // free any strings we are holding on to
    if (_lpstrCntrApp != NULL)
    {
        TaskFreeString(_lpstrCntrApp);
        _lpstrCntrApp = NULL;
        
#if !defined(UNICODE) && !defined(OLE2ANSI)        
        TaskFreeMem(_lpstrCntrAppA);
        _lpstrCntrAppA = NULL;
#endif
        
    }
    if (_lpstrCntrObj != NULL)
    {
        TaskFreeString(_lpstrCntrObj);
        _lpstrCntrObj = NULL;
        
#if !defined(UNICODE) && !defined(OLE2ANSI)                
        TaskFreeMem(_lpstrCntrObjA);
        _lpstrCntrObjA = NULL;
#endif
                
    }

    // make copies of the new strings and hold on
    TaskAllocString(lpstrCntrApp, &_lpstrCntrApp);
    TaskAllocString(lpstrCntrObj, &_lpstrCntrObj);

#if !defined(UNICODE) && !defined(OLE2ANSI)
    _lpstrCntrAppA = ConvertOLESTRToMB(_lpstrCntrApp, -1);
    _lpstrCntrObjA = ConvertOLESTRToMB(_lpstrCntrObj, -1);    
#endif

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::Close
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method ensures the object is in the loaded
//              (not passive!) state.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::Close(DWORD dwSaveOption)
{
    HRESULT hr = NOERROR;

    // if our object is dirty then we should save it, depending on the
    // save options
    if (_pClientSite != NULL && NOERROR == _pDV->IsDirty())
    {
        BOOL fSave;
        switch(dwSaveOption)
        {
        case OLECLOSE_SAVEIFDIRTY:
            fSave = TRUE;
            break;

        case OLECLOSE_NOSAVE:
            fSave = FALSE;
            break;

        case OLECLOSE_PROMPTSAVE:
            {
                // put up a message box asking the user if they want to update
                // the container
                LPOLESTR lpstrObj =
                    _pDV->GetMonikerDisplayName(OLEGETMONIKER_ONLYIFTHERE);
                if (lpstrObj == NULL)
                {
                    lpstrObj = _pClass->_szUserClassType[USERCLASSTYPE_FULL];
                }
                int i = IDYES;
#if 0                
#pragma message("Localizable string here!")
                int i = MessageBox(NULL,
                            TEXT("Object has changed.  Update?"),
                            lpstrObj,
                            MB_YESNOCANCEL | MB_ICONQUESTION);
#endif                

                if (IDCANCEL == i)
                {
                    return OLE_E_PROMPTSAVECANCELLED;
                }

                fSave = (IDYES == i);
            }
            break;

        default:
            DOUT(TEXT("SrvrCtrl::Close E_INVALIDARG\r\n"));
            return E_INVALIDARG;
        }

        if (fSave)
            hr = _pClientSite->SaveObject();
    }

    // Ensure that we do not loose any SaveObject() failure. 
    if (SUCCEEDED (hr))
        hr = TransitionTo(OS_PASSIVE);
    else
        (void) TransitionTo(OS_PASSIVE);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method notifies our data/view subobject of our new
//              moniker.  It also registers us in the running object
//              table and sends an OnRename notification to all registered
//              advises.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    // our moniker has changed so revoke our entry in the running object table
    if (_dwRegROT != 0)
    {
        RevokeAsRunning(&_dwRegROT);
    }

    //
    // insure that we have a full moniker to register in the ROT
    // if we have a full moniker, then go with it
    // otherwise ask our client site for a full moniker
    //
    HRESULT hr = NOERROR;
    LPMONIKER pmkFull = NULL;
    if (dwWhichMoniker == OLEWHICHMK_OBJFULL)
    {
        if((pmkFull = pmk) != NULL)
            pmkFull->AddRef();
    }
    else
    {
        if (_pClientSite == NULL)
        {
            DOUT(TEXT("SrvrCtrl::SetMoniker E_FAIL\r\n"));
            hr = E_FAIL;
        }
        else
        {
            hr = _pClientSite->GetMoniker(OLEGETMONIKER_ONLYIFTHERE,
                    OLEWHICHMK_OBJFULL,
                    &pmkFull);
        }
    }

    if (OK(hr))
    {
        // stow the moniker away in our data object
        _pDV->SetMoniker(pmkFull);

        if(pmkFull != NULL)
        {
            // register ourself in the running object table
            // NOTE: if we had native data items that weren't embeddings
            // but could be pseudo-objects then we would also register a
            // wildcard moniker
            //
            RegisterAsRunning((LPUNKNOWN)this, pmkFull, &_dwRegROT);

            // notify our advise holders that we have been renamed!
            if (_pOleAdviseHolder != NULL)
            {
                _pOleAdviseHolder->SendOnRename(pmkFull);
            }

            pmkFull->Release();
        }
        else
        {
            RevokeAsRunning(&_dwRegROT);
        }
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method forwards the request to our client site
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    if (ppmk == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetMoniker E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *ppmk = NULL;   // set out parameters to NULL

    // get the requested moniker from our client site
    HRESULT hr;
    if (_pClientSite == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetMoniker MK_E_UNAVAILABLE\r\n"));
        hr = MK_E_UNAVAILABLE;
    }
    else
        hr = _pClientSite->GetMoniker(dwAssign, dwWhichMoniker, ppmk);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::InitFromData
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns S_FALSE indicating InitFromData
//              is not supported.  Servers that wish to support initialization
//              from a selection should override this function.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::InitFromData(LPDATAOBJECT pDataObject,
        BOOL fCreation,
        DWORD dwReserved)
{
    return S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetClipboardData
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method uses the GetClipboardCopy method on our
//              data/view subobject to obtain a data transfer object
//              representing a snapshot of our compound document object.
//
//              This is considered an exotic, and OPTIONAL method to
//              implement. It was intended for programatic access
//              (bypassing the clipboard), and will probably never
//              be used...
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetClipboardData(DWORD dwReserved, LPDATAOBJECT FAR* ppDataObject)
{
    if (ppDataObject == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetClipboardData E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *ppDataObject = NULL;               // set out params to NULL

    // create a new data object initialized from our own data object
    LPSRVRDV pDV = NULL;
    HRESULT hr;
    if (OK(hr = _pDV->GetClipboardCopy(&pDV)))
    {
        *ppDataObject = (LPDATAOBJECT)pDV;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::DoVerb
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method locates the requested verb in the servers
//              verb table and calls the associated verb function.
//              If the verb is not found then the first (at index 0) verb in
//              the verb table is called.  This should be the primary verb
//              with verb number 0.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::DoVerb(LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    //
    // All DoVerbs make an implicit transition to the running state if
    // the object is not already running...
    //
    HRESULT hr = NOERROR;
    if (_state < OS_RUNNING)
        hr = TransitionTo(OS_RUNNING);

    if (OK(hr))
    {
        //
        // find the verb in the verb table.  if it is not there then default
        // to the 0th entry in the table (should be primary verb)
        //
        for (int i = 0; i < _pClass->_cVerbTable; i++)
        {
            if (iVerb == _pClass->_pVerbTable[i].lVerb)
            {
                break;
            }
        }
        if (i >= _pClass->_cVerbTable)
        {
            i = 0;
        }

        // dispatch the verb
        hr = (*_pVerbFuncs[i])(this,
                iVerb,
                lpmsg,
                pActiveSite,
                lindex,
                hwndParent,
                lprcPosRect);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::EnumVerbs
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method produces an enumerator over the server's
//              verb table.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::EnumVerbs(LPENUMOLEVERB FAR* ppenum)
{
    if (ppenum == NULL)
    {
        DOUT(TEXT("SrvrCtrl::EnumVerbs E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *ppenum = NULL;
    
    //return OLE_S_USEREG;
    return CreateOLEVERBEnum(_pClass->_pVerbTable, _pClass->_cVerbTable, ppenum);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::Update
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns NOERROR indicating that the update was
//              successful.  Containers will wish to override this function
//              in order to recursively pass the function on to all embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::Update(void)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::IsUpToDate
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method returns NOERROR indicating that the object is
//              up to date.  Containers will wish to override this function
//              in order to recursively pass the function on to all embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::IsUpToDate(void)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetUserClassID
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the class id from the server's
//              CLASSDESCRIPTOR structure
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetUserClassID(CLSID FAR* pClsid)
{
    if (pClsid == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetUserClassID E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *pClsid = _pClass->_clsid;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetUserType
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the user type string from the server's
//              CLASSDESCRIPTOR structure
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetUserType(DWORD dwFormOfType, LPOLESTR FAR* plpstr)
{
    if (plpstr == NULL || dwFormOfType < 1 || dwFormOfType > 3)
    {
        DOUT(TEXT("SrvrCtrl::GetUserType E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    return TaskAllocString(_pClass->_szUserClassType[dwFormOfType], plpstr);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SetExtent
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is forwarded to the SetExtent method on
//              the data/view subobject.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    if (lpsizel == NULL)
    {
        DOUT(TEXT("SrvrCtrl::SetExtent E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    return _pDV->SetExtent(dwDrawAspect, *lpsizel);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetExtent
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is forwarded to the SetExtent method on
//              the data/view subobject.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    if (lpsizel == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetExtent E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    return _pDV->GetExtent(dwDrawAspect, lpsizel);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::Advise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::Advise(IAdviseSink FAR* pAdvSink, DWORD FAR* pdwConnection)
{
    if (pdwConnection == NULL)
    {
        DOUT(TEXT("SrvrCtrl::Advise E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *pdwConnection = NULL;              // set out params to NULL

    HRESULT hr = NOERROR;
    if (_pOleAdviseHolder == NULL)
        hr = CreateOleAdviseHolder(&_pOleAdviseHolder);

    if (OK(hr))
        hr = _pOleAdviseHolder->Advise(pAdvSink, pdwConnection);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::Unadvise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::Unadvise(DWORD dwConnection)
{
    if (_pOleAdviseHolder == NULL)
        return NOERROR;

    return _pOleAdviseHolder->Unadvise(dwConnection);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::EnumAdvise
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method is implemented using the standard
//              OLE advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    if (ppenumAdvise == NULL)
    {
        DOUT(TEXT("SrvrCtrl::EnumAdvise E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    HRESULT hr;
    if (_pOleAdviseHolder == NULL)
    {
        *ppenumAdvise = NULL;
        hr = NOERROR;
    }
    else
    {
        hr = _pOleAdviseHolder->EnumAdvise(ppenumAdvise);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::GetMiscStatus
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      This method supplies the misc status flags from the server's
//              CLASSDESCRIPTOR structure
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::GetMiscStatus(DWORD dwAspect, DWORD FAR* pdwStatus)
{
    if (pdwStatus == NULL)
    {
        DOUT(TEXT("SrvrCtrl::GetMiscStatus E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *pdwStatus = _pClass->_dwMiscStatus;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrCtrl::SetColorScheme
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      Servers should override this method if they are
//              interested in the palette.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrCtrl::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    DOUT(TEXT("SrvrCtrl::SetColorScheme E_NOTIMPL\r\n"));
    return E_NOTIMPL;   //will we ever?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\vwadvhld.cxx ===
//+---------------------------------------------------------------------
//
//   File:       vwadvhld.cxx
//
//   Contents:   Miscellaneous OLE helper routines
//
//------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::ViewAdviseHolder, protected
//
//  Synopsis:   Constructor for ViewAdviseHolder class
//
//----------------------------------------------------------------

ViewAdviseHolder::ViewAdviseHolder()
{
    _refs = 1;
    _pAdvSink = NULL;
    _dwAdviseAspects = 0;
    _dwAdviseFlags = 0;

}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::~ViewAdviseHolder, protected
//
//  Synopsis:   Destructor for ViewAdviseHolder class
//
//----------------------------------------------------------------

ViewAdviseHolder::~ViewAdviseHolder()
{
    if (_pAdvSink != NULL)
        _pAdvSink->Release();
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
ViewAdviseHolder::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid,IID_IUnknown))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    DOUT(TEXT("ViewAdviseHolder::QueryInterface E_NOINTERFACE\r\n"));
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder:AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
ViewAdviseHolder::AddRef(void)
{
    return _refs++;
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
ViewAdviseHolder::Release(void)
{
    if (--_refs == 0)
        delete this;
    return (_refs);
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::SetAdvise, public
//
//  Synopsis:   Places an advise in the advise holder
//
//  Arguments:  The arguments are the same as to IViewObject::SetAdvise
//
//  Notes:      IViewObject objects using this advise holder delegate
//              their IViewObject::SetAdvise methods to this method.
//
//----------------------------------------------------------------

STDMETHODIMP
ViewAdviseHolder::SetAdvise(DWORD aspects, DWORD advf, LPADVISESINK pAdvSink)
{
    if (_pAdvSink != NULL)
        _pAdvSink->Release();

    _pAdvSink = pAdvSink;

    if (_pAdvSink != NULL)
        _pAdvSink->AddRef();

    _dwAdviseAspects = aspects;
    _dwAdviseFlags = advf;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::GetAdvise, public
//
//  Synopsis:   Reports on an advise in the advise holder
//
//  Arguments:  The arguments are the same as to IViewObject::GetAdvise
//
//  Notes:      IViewObject objects using this advise holder delegate
//              their IViewObject::GetAdvise methods to this method.
//
//----------------------------------------------------------------

STDMETHODIMP
ViewAdviseHolder::GetAdvise(DWORD FAR* pAspects,
        DWORD FAR* pAdvf,
        LPADVISESINK FAR* ppAdvSink)
{
    *ppAdvSink = _pAdvSink;
    *pAspects = _dwAdviseAspects;
    *pAdvf = _dwAdviseFlags;
    return NOERROR;
    // review: is this the right return code if no advise has been set?
}

//+---------------------------------------------------------------
//
//  Member:     ViewAdviseHolder::SendOnViewChange, public
//
//  Synopsis:   Sends an OnViewChange notification to the registered advise.
//
//  Arguments:  [dwAspect] -- the display aspect that has changed
//
//  Notes:      The client IViewObject should call this method whenever
//              its view has changed.
//
//----------------------------------------------------------------

void ViewAdviseHolder::SendOnViewChange(DWORD dwAspect)
{
    if (_pAdvSink != NULL && (dwAspect&_dwAdviseAspects) != 0)
        _pAdvSink->OnViewChange(dwAspect, -1);
}

//+---------------------------------------------------------------
//
//  Function:   CreateViewAdviseHolder
//
//  Synopsis:   Creates a ViewAdviseHolder object
//
//  Arguments:  [ppViewHolder] -- place where the view holder is returned
//
//  Returns:    Success if the advise holder was created
//
//  Notes:      This function is directly analogous to the OLE provided
//              CreateDataAdviseHolder
//
//----------------------------------------------------------------

HRESULT
CreateViewAdviseHolder(LPVIEWADVISEHOLDER FAR* ppViewHolder)
{
    //LPVIEWADVISEHOLDER pViewAdvHolder = new (NullOnFail) ViewAdviseHolder;
    LPVIEWADVISEHOLDER pViewAdvHolder = new ViewAdviseHolder;
    *ppViewHolder = pViewAdvHolder;

    if (pViewAdvHolder == NULL)
    {
        DOUT(TEXT("o2base/vwadvhld/CreateViewAdviseHolder failed\r\n"));
        return E_OUTOFMEMORY;
    }
    else
        return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\sdv.cxx ===
//+---------------------------------------------------------------------
//
//   File:       sdv.cxx
//
//------------------------------------------------------------------------

//[ srvrdv_overview
/*
                        SrvrDV Overview

The SrvrDV base class implements the persistent data and view aspects common
to most OLE Compound Document objects.  It implements the IDataObject,
IViewObject, and IPersist family of interfaces.

The set of formats supported in IDataObject::GetData and SetData methods is
very object dependent.  SrvrDV uses a table approach to allow each derived
class to specify precisely exactly the set of formats supported.  For each
of GetData and SetData there is a pair of tables.  One is a table of FORMATETC
structures that specify information about the format supported.  A parallel
table contains a pointer to a function that implements each format supported.
SrvrDV has a set of static methods that implement the standard OLE clipboard
formats.  The derived class can include these methods in its Get/Set tables.

*/
//]

#include "headers.hxx"
#pragma hdrstop

OLECHAR szContents[] = OLETEXT("contents");

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SrvrDV, protected
//
//  Synopsis:   Constructor for SrvrCtrl object
//
//  Notes:      To create a properly initialized object you must
//              call the Init method immediately after construction.
//
//---------------------------------------------------------------

SrvrDV::SrvrDV(void)
{
    DOUT(TEXT("SrvrDV: Constructing\r\n"));

    _pmk = NULL;
    _lpstrDisplayName = NULL;
    _sizel.cx = 0; _sizel.cy = 0;
    _pDataAdviseHolder = NULL;

    _fFrozen = FALSE;
    _pViewAdviseHolder = NULL;

    _fDirty = FALSE;
    _fNoScribble = FALSE;
    _pStg = NULL;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Init, protected
//
//  Synopsis:   Fully initializes a SrvrCtrl object as part of a compound
//              document server aggregate
//
//  Arguments:  [pClass] -- The initialized class descriptor for the server
//              [pCtrl] -- The control subobject of the server we are a part of.
//
//  Returns:    NOERROR if successful
//
//  Notes:      The Init method of the control subobject creates the data/view and
//              inplace subobjects of the object and calls the respective Init methods
//              on each, including this one.
//              The class descriptor pointer is saved in the protected _pClass
//              member variable where it is accessible during the lifetime
//              of the object.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::Init(LPCLASSDESCRIPTOR pClass, LPSRVRCTRL pCtrl)
{
    _pClass = pClass;
    _pCtrl = pCtrl;

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Init, protected
//
//  Synopsis:   Fully initializes a SrvrCtrl object from an existing object
//              to be used as a data transfer object
//
//  Arguments:  [pClass] -- The initialized class descriptor for the server
//              [pDV] -- The data/view subobject of the object that is the source
//                       of this transfer data object
//
//  Returns:    NOERROR if successful
//
//  Notes:      This method is used in the process of the GetClipboardCopy method
//              for obtaining a transfer data object from an existing object.
//              The class descriptor pointer is saved in the protected _pClass
//              member variable where it is accessible during the lifetime
//              of the object.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::Init(LPCLASSDESCRIPTOR pClass, LPSRVRDV pDV)
{
    _pClass = pClass;           // stash the class descriptor pointer
    _pCtrl = NULL;              // we are a free-floating transfer data object

    // copy over member variables as appropriate
    _pmk = pDV->_pmk;
    if (_pmk != NULL)
       _pmk->AddRef();

    TaskAllocString(pDV->_lpstrDisplayName, &_lpstrDisplayName);
    _sizel = pDV->_sizel;

    // we create a temporary IStorage and take a snapshot of the storage.
    // The temporary IStorage will be automatically deleted when this
    // data object is released
    // What happens when we run out of memory?
    // Should re-try with disk-based docfile?
    //
    HRESULT hr;
    LPSTORAGE pStg;
    if (OK(hr = CreateStorageOnHGlobal(NULL, &pStg)))
    {
        // do a "Save Copy As" into our storage instance.
        if (OK(hr = OleSave((LPPERSISTSTORAGE)pDV, pStg, FALSE)))
        {
            if (OK(hr = pStg->Commit(STGC_DEFAULT)))
            {
                if (OK(hr = ((LPPERSISTSTORAGE)pDV)->SaveCompleted(NULL)))
                    (_pStg = pStg)->AddRef();
            }
        }
        pStg->Release();
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::~SrvrDV, protected
//
//  Synopsis:   Destructor for the SrvrDV object
//
//  Notes:      The destructor is called as a result of the servers
//              reference count going to 0.  It releases any held resources
//              including advise holders and storages.
//
//---------------------------------------------------------------

SrvrDV::~SrvrDV(void)
{
    if (_pmk != NULL)
        _pmk->Release();

    if (_lpstrDisplayName != NULL)
        TaskFreeString(_lpstrDisplayName);

    if (_pDataAdviseHolder != NULL)
        _pDataAdviseHolder->Release();

    if (_pViewAdviseHolder != NULL)
        _pViewAdviseHolder->Release();

    if (_pStg != NULL)
        _pStg->Release();

    DOUT(TEXT("SrvrDV: Destructed\r\n"));
}

#ifdef DOCGEN  // documentation for pure virtual function
//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetClipboardCopy, public
//
//  Synopsis:   Produces a data-transfer object representing a snapshot
//              of this data/view object
//
//  Arguments:  [ppDV] -- The place where the data-transfer object is returned
//
//  Returns:    Success if the data-transfer object was created.
//
//  Notes:      This method is called
//              as a result of an IOleObject::GetClipboardData call on the
//              control subobject.  The overridden method should create a new
//              instance of itself and call the appropriate Init method on
//              the new instance passing the `this' pointer.  This way the
//              new instance can initialize itself as a snapshot of this object.
//              All servers must override this pure virtual method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetClipboardCopy(LPSRVRDV FAR* ppDV)
{}
#endif  // DOCGEN

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SetExtent, public
//
//  Synopsis:   Informs the object that it has a new expected size
//
//  Notes:      IOleObject::SetExtent and GetExtent methods are passed
//              directly from the control subobject to the data/view subobject
//              via these methods.   See OLE documentation for the
//              arguments and return values.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::SetExtent(DWORD dwAspect, SIZEL& sizel)
{
    HRESULT hr = NOERROR;
    switch(dwAspect)
    {
    case DVASPECT_CONTENT:
    case DVASPECT_DOCPRINT:
#if 1
        // NTBug #20692: Fail Metafile setextent, because
        //    Powerpoint tries to resize things in weird ways.
        hr = E_FAIL;            // icon aspect is fixed size        
#else
        _sizel = sizel;
#endif        
        break;
    case DVASPECT_THUMBNAIL:    //REVIEW: what size is a thumbnail?
    case DVASPECT_ICON:
        DOUT(TEXT("SrvrDV::SetExtent E_FAIL\r\n"));
        hr = E_FAIL; // icon aspect is fixed size
        break;
    default:
        DOUT(TEXT("SrvrDV::SetExtent E_INVALIDARG\r\n"));
        hr = E_INVALIDARG;
        break;
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetExtent, public
//
//  Synopsis:   Requests the current size for some draw aspect of the object
//
//  Notes:      IOleObject::SetExtent and GetExtent methods are passed
//              directly from the control subobject to the data/view subobject
//              via these methods.   See OLE documentation for the
//              arguments and return values.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetExtent(DWORD dwAspect, LPSIZEL lpsizel)
{
#if DBG
    TCHAR achTemp[256];
    wsprintf(achTemp,TEXT("SrvrDV::GetExtent (dwApsect = %ld, cx = %ld, cy = %ld)\r\n"),
            dwAspect, _sizel.cx, _sizel.cy);
    DOUT(achTemp);
#endif
    
    HRESULT hr = NOERROR;
    switch(dwAspect) {
    default:
        DOUT(TEXT("SrvrDV::GetExtent INVALIDARG\r\n"));
    case DVASPECT_CONTENT:
    case DVASPECT_DOCPRINT:
        *lpsizel = _sizel;
        break;

    case DVASPECT_THUMBNAIL:
    case DVASPECT_ICON:
        // The iconic view is actually a metafile of the
        // icon with a text-string underneath.
        // This isn't the right calculation...
        lpsizel->cx = HimetricFromHPix(32);
        lpsizel->cy = HimetricFromVPix(32);
        break;

    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::OnDataChange, public
//
//  Synopsis:   Sets the dirty flag and raises data and view changed
//              to all registered advises
//
//  Arguments:  [dwAdvf] -- from the ADVF Data Advise flags.
//                          Usually this is 0.  ADVF_DATAONSTOP is used
//                          when the object is closing down.
//  Notes:      This function should be called whenever the native
//              data of the object is modified.
//
//---------------------------------------------------------------

void
SrvrDV::OnDataChange(DWORD dwAdvf)
{
    _fDirty = TRUE;
    if (_pViewAdviseHolder != NULL)
        _pViewAdviseHolder->SendOnViewChange(DVASPECT_CONTENT);
    if (_pDataAdviseHolder != NULL)
        _pDataAdviseHolder->SendOnDataChange((LPDATAOBJECT)this, 0, dwAdvf);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SetMoniker, public
//
//  Synopsis:   Informs the object of its new, full moniker
//
//  Arguments:  [pmk] -- full moniker to the object
//
//  Notes:      The data/view subobject records the full moniker to the
//              object so it can properly dispense the standard OLE
//              Object Descriptor and Link Source clipboard formats.
//              This method is called whenever the IOleObject::SetMoniker
//              method is called on the control subobject.
//
//---------------------------------------------------------------

void
SrvrDV::SetMoniker(LPMONIKER pmk)
{
    if (_pmk != NULL)
    {
        _pmk->Release();

        if (_lpstrDisplayName != NULL)        // flush our cached display name
        {
            TaskFreeString(_lpstrDisplayName);
            _lpstrDisplayName = NULL;
        }
    }

    _pmk = pmk;

    if (_pmk != NULL)
    {
        _pmk->AddRef();
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetMoniker, public
//
//  Synopsis:   Returns the full moniker to the object
//
//  Arguments:  [dwAssign] -- See IOleObject::GetMoniker
//              [ppmk] -- The place where the moniker is returned
//
//  Returns:    Success if the moniker is available.
//
//  Notes:      This returns the moniker that this data/view subobject has
//              previously recorded.  If no moniker is yet assigned
//              then the moniker is requested from the client site
//              via the IOleObject::GetMoniker method on the control subobject.
//              This method is used by the GetOBJECTDESCRIPTOR and GetLINKSOURCE
//              methods.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetMoniker(DWORD dwAssign, LPMONIKER FAR* ppmk)
{
    *ppmk = NULL;   // set out params to NULL

    HRESULT hr = NOERROR;
    if (_pmk == NULL)
    {
        if (_pCtrl == NULL)
        {
            DOUT(TEXT("SrvrDV::GetMoniker E_INVALIDARG\r\n"));
            hr = MK_E_UNAVAILABLE;
        }
        else
        {
            hr = _pCtrl->GetMoniker(dwAssign, OLEWHICHMK_OBJFULL, &_pmk);
        }
    }

    if (OK(hr))
        (*ppmk = _pmk)->AddRef();

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetMonikerDisplayName, public
//
//  Synopsis:   Returns the display name from the object's moniker
//
//  Notes:      The display name of the object is used in for
//              dispensing the Object Descriptor clipboard format.
//              The caller must not free the string returned.
//
//---------------------------------------------------------------

LPOLESTR
SrvrDV::GetMonikerDisplayName(DWORD dwAssign)
{
    //
    // NOTE: default dwAssign is OLEGETMONIKER_ONLYIFTHERE
    //
    // we maintain a moniker display name cache in the form of member
    // variable _lpstrDisplayName.
    //
    // If we don't have a display name cached then take our moniker and
    // squeeze a display name out of it
    //
    if (!_lpstrDisplayName)
    {
        LPMONIKER pmk;
        if (OK(GetMoniker(dwAssign, &pmk)))
        {
            ::GetMonikerDisplayName(pmk, &_lpstrDisplayName);
            pmk->Release();
        }
    }
    return _lpstrDisplayName;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetEMBEDDEDOBJECT, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Embedded Object clipboard format
//
//  Arguments:  [pv] -- pointer to a SrvrDV object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetEMBEDDEDOBJECT( LPSRVRDV pDV,
                        LPFORMATETC pformatetc,
                        LPSTGMEDIUM pmedium,
                        BOOL fHere)
{
    LPPERSISTSTORAGE pPStg = (LPPERSISTSTORAGE)(LPSRVRDV)pDV;
    HRESULT hr = NOERROR;
    if (!fHere && pmedium)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_ISTORAGE;
        hr = StgCreateDocfile(NULL,
                            STGM_DFRALL | STGM_CREATE | STGM_DELETEONRELEASE,
                            0L,
                            &pmedium->pstg);
        pmedium->pUnkForRelease = NULL;
    }

    if (OK(hr) && pmedium && pPStg)
    {
        if (OK(hr = OleSave(pPStg, pmedium->pstg, FALSE)))
            hr = pPStg->SaveCompleted(NULL);

        // if we failed somehow and yet created a docfile, then we will
        // release the docfile to delete it
        //
        if (!OK(hr) && !fHere)
            pmedium->pstg->Release();
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetMETAFILEPICT, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Metafilepict clipboard format
//
//  Arguments:  [pv] -- pointer to a SrvrDV object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This member function uses IViewObject::Draw to construct
//              the metafile pict.
//              This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetMETAFILEPICT( LPSRVRDV pDV,
                        LPFORMATETC pformatetc,
                        LPSTGMEDIUM pmedium,
                        BOOL fHere)
{
    DOUT(TEXT("o2base/SrvrDV::GetMETAFILEPICT\r\n"));

    LPVIEWOBJECT pView = (LPVIEWOBJECT)pDV;
    SIZEL sizel;
    pDV->GetExtent(pformatetc->dwAspect, &sizel);

    RECT rc = { 0, 0, sizel.cx, sizel.cy };
    HRESULT hr = NOERROR;
    if (!fHere)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_MFPICT;
        pmedium->hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(METAFILEPICT));
        if (pmedium->hGlobal == NULL)
        {
            DOUT(TEXT("o2base/SrvrDV::GetMETAFILEPICT failed\r\n"));
            hr = E_OUTOFMEMORY;
        }
        pmedium->pUnkForRelease = NULL;
    }

    if (OK(hr))
    {
        HMETAFILE hmf;
        if (OK(hr = DrawMetafile(pView, rc, pformatetc->dwAspect, &hmf)))
        {
            LPMETAFILEPICT pPict = (LPMETAFILEPICT)GlobalLock(pmedium->hGlobal);
            if (pPict == NULL)
            {
                DOUT(TEXT("SrvrDV::GetMETAFILEPICT E_INVALIDARG\r\n"));

                DeleteMetaFile(hmf);
                hr = E_INVALIDARG;
            }
            else
            {
                // fill in the object descriptor
                pPict->mm   =  MM_ANISOTROPIC;
                pPict->hMF  =  hmf;
                pPict->xExt =  rc.right;
                pPict->yExt =  rc.bottom;

                GlobalUnlock(pmedium->hGlobal);
            }
        }

        // if we failed somehow and yet allocated memory,
        // then we will release it here...
        //
        if (!OK(hr) && !fHere)
        {
            GlobalFree(pmedium->hGlobal);
            pmedium->hGlobal = NULL;
        }
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetOBJECTDESCRIPTOR, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Object Descriptor clipboard format
//
//  Arguments:  [pv] -- pointer to a SrvrDV object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------
         
HRESULT
SrvrDV::GetOBJECTDESCRIPTOR( LPSRVRDV pDV,
                            LPFORMATETC pformatetc,
                            LPSTGMEDIUM pmedium,
                            BOOL fHere)
{
    HRESULT hr = NOERROR;
    LPCLASSDESCRIPTOR pClass = pDV->_pClass;

    //
    //REVIEW: what's the best display name for the OBJECTDESCRIPTOR?
    //

    OLECHAR achDisplay[256];
    
    ostrcpy(achDisplay, OLETEXT("Microsoft "));
    ostrcat(achDisplay, pClass->_szUserClassType[USERCLASSTYPE_FULL]);
    
    LPOLESTR    lpstrDisplay = achDisplay;
    DWORD       dwDisplay = lpstrDisplay ?
                            (ostrlen(lpstrDisplay) + 1) * sizeof(OLECHAR) : 0;
    LPOLESTR    lpstrUserTypeFull = pClass->_szUserClassType[USERCLASSTYPE_FULL];
    DWORD       dwUserTypeFull = lpstrUserTypeFull ?
                            (ostrlen(lpstrUserTypeFull) + 1) * sizeof(OLECHAR) : 0;

    DWORD dwSize = sizeof(OBJECTDESCRIPTOR) + dwUserTypeFull + dwDisplay;

    if (!fHere)
    {
        // compute the amount of memory required

        // fill in the pmedium structure
        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->hGlobal = GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, dwSize);
        if (pmedium->hGlobal == NULL)
        {
            DOUT(TEXT("o2base/SrvrDV::GetOBJECTDESCRIPTOR failed (pmedium)\r\n"));
            hr = E_OUTOFMEMORY;
        }

        pmedium->pUnkForRelease = NULL;
    }

    if (OK(hr) && (GlobalSize(pmedium->hGlobal) >= dwSize))
    {
        LPOBJECTDESCRIPTOR pObjDesc =
                (LPOBJECTDESCRIPTOR)GlobalLock(pmedium->hGlobal);
        if (pObjDesc == NULL)
        {
            DOUT(TEXT("o2base/SrvrDV::GetOBJECTDESCRIPTOR failed\r\n"));
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //
            // fill in the object descriptor
            //
            pObjDesc->cbSize        = dwSize;
            pObjDesc->clsid         = pClass->_clsid;
            pObjDesc->dwDrawAspect  = DVASPECT_CONTENT;
            pObjDesc->sizel         = pDV->_sizel;
            pObjDesc->pointl.y      = pObjDesc->pointl.x = 0;
            pObjDesc->dwStatus      = pClass->_dwMiscStatus;

            LPOLESTR lpstrDest = (LPOLESTR)(pObjDesc + 1);
            if(lpstrUserTypeFull)
            {
                ostrcpy(lpstrDest, lpstrUserTypeFull);
#if DBG
#if !defined(UNICODE) && !defined(OLE2ANSI)
                LPSTR lp = ConvertOLESTRToMB(lpstrDest, -1);
                OutputDebugStringA(lp);
                OutputDebugStringA("\r\n");
                TaskFreeMem(lp);
#endif                
#endif                
                pObjDesc->dwFullUserTypeName = sizeof(OBJECTDESCRIPTOR);
                lpstrDest += ostrlen(lpstrUserTypeFull) + 1;
                
            }
            else
                pObjDesc->dwFullUserTypeName = 0;

            if (lpstrDisplay)
            {
                pObjDesc->dwSrcOfCopy = pObjDesc->dwFullUserTypeName + dwUserTypeFull;
                ostrcpy(lpstrDest, lpstrDisplay);
#if DBG
#if !defined(UNICODE) && !defined(OLE2ANSI)
                LPSTR lp = ConvertOLESTRToMB(lpstrDest, -1);
                OutputDebugStringA(lp);
                OutputDebugStringA("\r\n");
                TaskFreeMem(lp);
#endif                
#endif                
            }
            else
                pObjDesc->dwSrcOfCopy = 0;

            GlobalUnlock(pmedium->hGlobal);
            hr = NOERROR;
        }

        // if we failed somehow and yet allocated memory,
        // then we will release it here...
        if (!OK(hr) && !fHere)
        {
            GlobalFree(pmedium->hGlobal);
            pmedium->hGlobal = NULL;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetLINKSOURCE, public
//
//  Synopsis:   Implementation of IDataObject::GetData and GetDataHere
//              for the standard Link Source clipboard format
//
//  Arguments:  [pv] -- pointer to a SrvrDV object
//              [pformatetc] -- as in IDataObject::GetData, GetDataHere
//              [pmedium] -- as in IDataObject::GetData, GetDataHere
//              [fHere] -- TRUE for GetDataHere, FALSE for GetData
//
//  Returns:    Success if the clipboard format could be dispensed
//
//  Notes:      This method uses the moniker cached by the data/view
//              object.
//              This and the other static GetXXX methods are for use
//              in the server's Get format tables.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::GetLINKSOURCE( LPSRVRDV pDV,
                    LPFORMATETC pformatetc,
                    LPSTGMEDIUM pmedium,
                    BOOL fHere)
{
    LPMONIKER pmk;
    HRESULT hr;

    if (OK(hr = pDV->GetMoniker(OLEGETMONIKER_FORCEASSIGN, &pmk)))
    {
        if (!fHere)
        {
            pmedium->tymed = TYMED_ISTREAM;
            HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pmedium->pstm);
            pmedium->pUnkForRelease = NULL;
        }

        if (OK(hr))
        {
            CLSID clsid;
            if (OK(hr = pmk->GetClassID(&clsid)))
            {
                if (OK(hr = WriteClassStm(pmedium->pstm, clsid)))
                    hr = pmk->Save(pmedium->pstm, FALSE);
                
                pDV->GetClassID(&clsid);
                WriteClassStm(pmedium->pstm, clsid);
            }
        }

        pmk->Release();
    }

    return hr;
}


//+--------------------------------------------------------------
//
//  Member:     SrvrDV::GetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  If one is found it calls
//              the corresponding Get function.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetData(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    DOUT(TEXT("SrvrDV:GetData\r\n"));

    if (pformatetc == NULL || pmedium == NULL)
    {
        DOUT(TEXT("SrvrDV::GetData E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    HRESULT hr;
    
    int i = FindCompatibleFormat(_pClass->_pGetFmtTable,
            _pClass->_cGetFmtTable,
            *pformatetc);
    
    if (i < 0)
    {
        DOUT(TEXT("SrvrDV::GetData DV_E_FORMATETC\r\n"));
        hr = DV_E_FORMATETC;
    }
    else
    {
        hr = (*_pGetFuncs[i]) (this, pformatetc, pmedium, FALSE);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetDataHere, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  If one is found it calls
//              the corresponding Get function.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    DOUT(TEXT("SrvrDV:GetDataHere\r\n"));

    HRESULT hr;
    int i = FindCompatibleFormat(_pClass->_pGetFmtTable,
            _pClass->_cGetFmtTable,
            *pformatetc);
    if (i < 0)
    {
        DOUT(TEXT("SrvrDV::GetDataHere DV_E_FORMATETC\r\n"));
        hr = DV_E_FORMATETC;
    }
    else
    {
        hr = (*_pGetFuncs[i]) (this, pformatetc, pmedium, TRUE);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::QueryGetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Get format table
//              for a compatible format.  The return value indicates
//              whether or not a compatible format was found.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::QueryGetData(LPFORMATETC pformatetc)
{
    return FindCompatibleFormat(_pClass->_pGetFmtTable,
            _pClass->_cGetFmtTable,
            *pformatetc) >=0 ? NOERROR : DV_E_FORMATETC;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetCanonicalFormatEtc, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method returns DATA_S_SAMEFORMATETC assuming
//              that each format the server dispenses is its own
//              canonical format.  If this is not the case then this
//              method should be overridden.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetCanonicalFormatEtc(LPFORMATETC pformatetc,
    LPFORMATETC pformatetcOut)
{
    return DATA_S_SAMEFORMATETC;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SetData, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method searches the server's Set format table
//              for a compatible format.  If one is found it calls
//              the corresponding Set function.
//
//---------------------------------------------------------------
STDMETHODIMP
SrvrDV::SetData(LPFORMATETC pformatetc, STGMEDIUM FAR *pmedium, BOOL fRelease)
{
    DOUT(TEXT("SrvrDV:SetData\r\n"));

    HRESULT hr;
    int i = FindCompatibleFormat(_pClass->_pSetFmtTable,
            _pClass->_cSetFmtTable,
            *pformatetc);
    if (i < 0)
    {
        DOUT(TEXT("SrvrDV::SetData DV_E_FORMATETC\r\n"));
        hr = DV_E_FORMATETC;
    }
    else
    {
        hr = (*_pSetFuncs[i]) (this, pformatetc, pmedium);
    }

    if (fRelease)
    {
        ReleaseStgMedium(pmedium);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::EnumFormatEtc, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method creates an enumerator over the Get or
//              Set format tables depending on the value of the
//              dwDirection argument.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    if (ppenumFormatEtc == NULL)
    {
        DOUT(TEXT("SrvrDV::EnumFormatEtc E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }
    *ppenumFormatEtc = NULL;            // set out params to NULL

    // create an enumerator over our static format table.
    HRESULT hr = E_INVALIDARG;
    switch (dwDirection)
    {
    case DATADIR_GET:
        hr = CreateFORMATETCEnum(_pClass->_pGetFmtTable,
                _pClass->_cGetFmtTable,
                ppenumFormatEtc);
        break;
    case DATADIR_SET:
        hr = CreateFORMATETCEnum(_pClass->_pSetFmtTable,
                _pClass->_cSetFmtTable,
                ppenumFormatEtc);
        break;
    default:
        DOUT(TEXT("SrvrDV::EnumFormatEtc E_INVALIDARG (2)\r\n"));
        break;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::DAdvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::DAdvise(FORMATETC FAR* pFormatetc,
                DWORD advf,
                LPADVISESINK pAdvSink,
                DWORD FAR* pdwConnection)
{
    if (pdwConnection == NULL)
    {
        DOUT(TEXT("SrvrDV::DAdvise E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *pdwConnection = NULL;              // set out params to NULL

    HRESULT hr = NOERROR;
    if (_pDataAdviseHolder == NULL)
        hr = CreateDataAdviseHolder(&_pDataAdviseHolder);

    if (OK(hr))
    {
        hr = _pDataAdviseHolder->Advise((LPDATAOBJECT)this,
                pFormatetc,
                advf,
                pAdvSink,
                pdwConnection);
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::DUnadvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::DUnadvise(DWORD dwConnection)
{
    if (_pDataAdviseHolder == NULL)
        return NOERROR;

    return _pDataAdviseHolder->Unadvise(dwConnection);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::EnumDAdvise, public
//
//  Synopsis:   Method of IDataObject interface
//
//  Notes:      This method uses the standard OLE data advise holder.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::EnumDAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    if (ppenumAdvise == NULL)
    {
        DOUT(TEXT("SrvrDV::EnumDAdvise E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *ppenumAdvise = NULL;               // set out params to NULL

    HRESULT hr;
    if (_pDataAdviseHolder == NULL)
        hr = NOERROR;
    else
        hr = _pDataAdviseHolder->EnumAdvise(ppenumAdvise);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::RenderContent, public
//
//  Synopsis:   Used to draw the content aspect of the object
//
//  Notes:      This method is used by the implementation of IViewObject::Draw
//              when the content aspect is requested.  The parameters are
//              identical to those of IViewObject::Draw.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::RenderContent(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::RenderPrint, public
//
//  Synopsis:   Used to draw the print aspect of the object
//
//  Notes:      This method is used by the implementation of IViewObject::Draw
//              when the docprint aspect is requested.  The parameters are
//              identical to those of IViewObject::Draw.
//              By default this method calls RenderContent.  If the
//              server has special processing for the print case then
//              this method should be overridden.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::RenderPrint(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    return RenderContent(dwDrawAspect,
            lindex,
            pvAspect,
            ptd,
            hicTargetDev,
            hdcDraw,
            lprectl,
            lprcWBounds,
            pfnContinue,
            dwContinue);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::RenderThumbnail, public
//
//  Synopsis:   Used to draw the thumbnail aspect of the object
//
//  Notes:      This method is used by the implementation of IViewObject::Draw
//              when the thumbnail aspect is requested.  The parameters are
//              identical to those of IViewObject::Draw.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::RenderThumbnail(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Draw, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method calls RenderContent/Print/Thumbnail for
//              those respective aspects.  It handles the icon aspect
//              automatically using the icon found in the class descriptor
//              indicated by the _pClass member.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Draw(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK * pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    HRESULT hr;
    switch(dwDrawAspect) {
    case DVASPECT_CONTENT:
        hr = RenderContent(dwDrawAspect,
                lindex,
                pvAspect,
                ptd,
                hicTargetDev,
                hdcDraw,
                lprectl,
                lprcWBounds,
                pfnContinue,
                dwContinue);
        break;

    case DVASPECT_DOCPRINT:
        hr = RenderPrint(dwDrawAspect,
                lindex,
                pvAspect,
                ptd,
                hicTargetDev,
                hdcDraw,
                lprectl,
                lprcWBounds,
                pfnContinue,
                dwContinue);
        break;

    case DVASPECT_THUMBNAIL:
        hr = RenderThumbnail(dwDrawAspect,
                lindex,
                pvAspect,
                ptd,
                hicTargetDev,
                hdcDraw,
                lprectl,
                lprcWBounds,
                pfnContinue,
                dwContinue);
        break;

    case DVASPECT_ICON:
        {
            // This is not the right way to do iconic aspect rendering!
            RECT rc;
            RECTL rcTemp = *lprectl;
            RECTLtoRECT(rcTemp, &rc);
            DrawIcon(hdcDraw, rc.left, rc.top, _pClass->_hicon);
            hr = NOERROR;
        }
        break;

    default:
        DOUT(TEXT("SrvrDV::Draw E_INVALIDARG\r\n"));
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetColorSet, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method returns S_FALSE indicating the server
//              does not support this functionality.  Server's that
//              wish to support it should override this method.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetColorSet(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        LPLOGPALETTE FAR* ppColorSet)
{
    if (ppColorSet == NULL)
    {
        DOUT(TEXT("SrvrDV::GetColorSet E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *ppColorSet = NULL; //set out params to NULL

    return S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Freeze, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method sets the frozen flag, _fFrozen.
//              The derived class must pay attention to this flag
//              and not allow any modifications that would change
//              the current rendering.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Freeze(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DWORD FAR* pdwFreeze)
{
    if (pdwFreeze == NULL)
    {
        DOUT(TEXT("SrvrDV::Freeze E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *pdwFreeze = 0; //set out params to NULL

    _fFrozen = TRUE;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Unfreeze, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method clears the frozen flag, _fFrozen.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Unfreeze(DWORD dwFreeze)
{
    _fFrozen = FALSE;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SetAdvise, public
//
//  Synopsis:   Method of IViewObject interface
//
//  Notes:      This method implements an advise holder for the view
//              advise.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::SetAdvise(DWORD aspects, DWORD advf, LPADVISESINK pAdvSink)
{
    HRESULT hr = NOERROR;
    if (_pViewAdviseHolder == NULL)
        hr = CreateViewAdviseHolder(&_pViewAdviseHolder);

    if (OK(hr))
        hr = _pViewAdviseHolder->SetAdvise(aspects, advf, pAdvSink);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetAdvise, public
//
//  Synopsis:   Method of IViewObject interface
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetAdvise(DWORD FAR* pAspects,
        DWORD FAR* pAdvf,
        LPADVISESINK FAR* ppAdvSink)
{
    if (ppAdvSink == NULL)
    {
        DOUT(TEXT("SrvrDV::GetAdvise E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *ppAdvSink = NULL;                  // set out params to NULL

    HRESULT hr;
    if (_pViewAdviseHolder==NULL)
        hr = NOERROR;
    else
        hr = _pViewAdviseHolder->GetAdvise(pAspects, pAdvf, ppAdvSink);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::LoadFromStream, protected
//
//  Synopsis:   Loads the object's persistent state from a stream
//
//  Arguments:  [pStrm] -- stream to load from
//
//  Returns:    Success iff persistent state was read
//
//  Notes:      This function is used in the implementation of
//              IPersistStream::Load and IPersistFile::Load when
//              the file is not a docfile.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::LoadFromStream(LPSTREAM pStrm)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SaveToStream, protected
//
//  Synopsis:   Saves the object's persistent state to a stream
//
//  Arguments:  [pStrm] -- stream to save to
//
//  Returns:    Success iff persistent state was written
//
//  Notes:      This function is used in the implementation of
//              IPersistStream::Save and IPersistFile::Save when
//              the file is not a docfile.
//              All objects should override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::SaveToStream(LPSTREAM pStrm)
{
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetStreamSizeMax, protected
//
//  Synopsis:   Returns the number of bytes required to serialize object
//
//  Notes:      This function is used in the implementation of
//              IPersistStream::GetSizeMax.
//              All objects should override this method.
//
//---------------------------------------------------------------
DWORD
SrvrDV::GetStreamSizeMax(void)
{
    return 0;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetClassID, public
//
//  Synopsis:   Method of IPersist interface
//
//  Notes:      This method uses the class id in the class descriptor.
//
//---------------------------------------------------------------
STDMETHODIMP
SrvrDV::GetClassID(LPCLSID lpClassID)
{
    if (lpClassID == NULL)
    {
        DOUT(TEXT("SrvrDV::GetClassID E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *lpClassID = _pClass->_clsid;
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     SrvrDV::IsDirty, public
//
//  Synopsis:   Method of IPersistStream/Storage/File interface
//
//  Notes:      This method uses the dirty flag, _fDirty.
//              Objects should not set the _fDirty flag directly
//              but instead call the OnDataChange method to set the
//              flag.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::IsDirty(void)
{
    return (_fDirty ? NOERROR : S_FALSE);
}


//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Load, public
//
//  Synopsis:   Method of IPersistStream interface
//
//  Notes:      This function uses the LoadFromStream method and
//              transitions the object to the loaded state if the
//              load was successful.
//
//---------------------------------------------------------------
STDMETHODIMP
SrvrDV::Load(LPSTREAM pStrm)
{
    // object can be loaded only once!
    if (_pCtrl->State() != OS_PASSIVE)
    {
        DOUT(TEXT("SrvrDV::Load E_FAIL\r\n"));
        return E_FAIL;
    }

    HRESULT hr;
    if (OK(hr = LoadFromStream(pStrm)))
        hr = _pCtrl->TransitionTo(OS_LOADED);

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Save, public
//
//  Synopsis:   Method of IPersistStream interface
//
//  Notes:      This method uses the SaveToStream method and
//              clears the _fDirty flag as appropriate.
//              Containers that have nonserializeable embeddings can
//              override this method and return STG_E_CANTSAVE
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Save(LPSTREAM pStrm, BOOL fClearDirty)
{
    HRESULT hr;
    if (OK(hr = SaveToStream(pStrm)))
    {
        if (fClearDirty)
        {
            _fDirty = FALSE;
        }
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetSizeMax
//
//  Synopsis:   Method of IPersistStream interface
//
//  Notes:
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetSizeMax(ULARGE_INTEGER FAR * pcbSize)
{
    if (pcbSize == NULL)
    {
        DOUT(TEXT("SrvrDV::GetSizeMax E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    ULISet32(*pcbSize, GetStreamSizeMax());

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::LoadFromStorage, protected
//
//  Synopsis:   Loads the object's persistent state from a storage
//
//  Arguments:  [pSg] -- storage to load from
//
//  Returns:    Success iff persistent state was read
//
//  Notes:      This function is used in the implementation of
//              IPersistStorage::Load and IPersistFile::Load when
//              the file is a docfile.
//              This method opens a stream, "CONTENTS", and uses
//              method LoadFromStream to complete the load.
//              Servers that do more sophisticated loading will want
//              to override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::LoadFromStorage(LPSTORAGE pStg)
{
    LPSTREAM pStrm;
    HRESULT hr;
    if (OK(hr = pStg->OpenStream(szContents, NULL, STGM_SRO, 0, &pStrm)))
    {
        hr = LoadFromStream(pStrm);
        pStrm->Release();
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member: SrvrDV::SaveToStorage
//
//  Synopsis:   Saves the object's persistent state to a storage
//
//  Arguments:  [pSg] -- storage to save to
//
//  Returns:    Success iff persistent state was written
//
//  Notes:      This function is used in the implementation of
//              IPersistStorage::Save and IPersistFile::Save when
//              the file is a docfile.
//              This method opens a stream, "CONTENTS", and uses
//              method SaveToStream to complete the save.
//              Servers that do more sophisticated saving will want
//              to override this method.
//
//---------------------------------------------------------------

HRESULT
SrvrDV::SaveToStorage(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    // write our native data stream
    HRESULT hr;
    LPSTREAM pStrm;
    hr = pStg->CreateStream(szContents, STGM_SALL|STGM_CREATE, 0L, 0L, &pStrm);
    if (OK(hr))
    {
        hr = SaveToStream(pStrm);
        pStrm->Release();
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::InitNew
//
//  Synopsis:   IPersistStorage Method
//
//  Notes:      This method transitions the object to loaded.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::InitNew(LPSTORAGE pStg)
{
    //
    //REVIEW: what happens if we attempt to load the same ctrl more than once?
    //
    if (pStg == NULL)
    {
        DOUT(TEXT("SrvrDV::InitNew E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    HRESULT hr;
    if (OK(hr = _pCtrl->TransitionTo(OS_LOADED)))
        (_pStg = pStg)->AddRef();   // hold on to the storage

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Load
//
//  Synopsis:   IPersistStorage Method
//
//  Notes:      This method loads the object using LoadFromStorage and
//              then transitions the object to loaded.
//              A pointer to our storage is maintained in member variable
//              _pStg.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Load(LPSTORAGE pStg)
{
    // object can be loaded only once!
    if (_pCtrl->State() != OS_PASSIVE)
    {
        DOUT(TEXT("SrvrDV::Load E_FAIL\r\n"));
        return E_FAIL;
    }

    if (pStg == NULL)
    {
        DOUT(TEXT("SrvrDV::Load E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    // do the load and move to the loaded state
    HRESULT hr;
    if (OK(hr = LoadFromStorage(pStg)))
    {
        if (OK(hr = _pCtrl->TransitionTo(OS_LOADED)))
        {
            (_pStg = pStg)->AddRef();
        }
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Save
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method uses SaveToStorage to write the persistent
//              state.  It also writes the full user type string to the
//              storage as is required.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Save(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    if (pStg == NULL)
    {
        DOUT(TEXT("SrvrDV::Save E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    // write our native data stream
    HRESULT hr;
    if (OK(hr = SaveToStorage(pStg, fSameAsLoad)))
    {
        // Write the UserType string. We don't let this fail the operation.
        WriteFmtUserTypeStg(pStg,
                0,
                _pClass->_szUserClassType[USERCLASSTYPE_FULL]);

        _fNoScribble = TRUE;
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SaveCompleted
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method clears the dirty flag and updates our
//              storage pointer, _pStg, if required.
//              Servers that are also containers will want to override
//              this method to pass the call recursively to all loaded
//              embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::SaveCompleted(LPSTORAGE pStg)
{
    // if pStg is non-null then we are coming out of HANDS-OFF mode,
    // otherwise we are coming out of NO-SCRIBBLE mode.
    if (pStg != NULL)
    {
        // We should be in HANDS-OFF mode and hence able to Assert that
        // _pStg is NULL here by virtue of the HandsOffStorage call.
        // However, the official OLE sample container app "Outline"
        // fail to make the HandsOffStorage call.
        // In order to be robust we release our _pStg handle if it is
        // "illegally" NON-NULL
        //
        if (_pStg != NULL)
        {
            DOUT(TEXT("SrvrDV: WARNING! SaveCompleted: "));
            DOUT(TEXT("SrvrDV: Container failed to make required HandsOffStorage call.\n"));
            _pStg->Release();
        }

        (_pStg = pStg)->AddRef();   // hold on to the new storage
    }

    _fDirty = FALSE;                // clear our dirty flag
    _fNoScribble = FALSE;           // we are out of NO-SCRIBBLE mode

    //REVIEW: should we advise in the case we are not fRemembering?
    if (_pCtrl != NULL)
        _pCtrl->OnSave();           // and notify any advises that we have saved

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::HandsOffStorage
//
//  Synopsis:   Method of IPersistStorage interface
//
//  Notes:      This method releases the storage we are holding on to.
//              Servers that are also containers will want to override
//              this method to pass the call recursively to all loaded
//              embeddings.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::HandsOffStorage(void)
{
    if (_pStg != NULL)
        _pStg->Release();
    _pStg = NULL;

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Load, public
//
//  Synopsis:   Method of IPersistFile interface
//
//  Notes:      This opens the file as a docfile and uses IPersistStorage::Load
//              to complete the operation.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Load(LPCOLESTR lpstrFile, DWORD grfMode)
{

    // use the default storage modes if no flags were specified
    if (grfMode == 0)
        grfMode = STGM_DFRALL;

    // if they didn't specify a share mode then use deny-write
    if ( (grfMode & STGM_SHARE) == 0)
        grfMode |= STGM_SHARE_DENY_WRITE;

    // of course, we use transacted mode
    grfMode |= STGM_TRANSACTED;

    HRESULT hr;
    if (lpstrFile == NULL)
    {
        // lpstrFile NULL is a special-case indicating that we should
        // create a temporary docfile for the new file case
        //
        grfMode |= STGM_CREATE | STGM_DELETEONRELEASE;

        LPSTORAGE pStg;
        if (OK(hr = StgCreateDocfile(NULL, grfMode, 0L, &pStg)))
        {
            hr = InitNew(pStg);

            // IPersistStorage::InitNew will hold on to the pStg
            pStg->Release();
        }
        return hr;
    }

    LPSTORAGE pStg;
    if (OK(hr = StgOpenStorage(lpstrFile, NULL, grfMode, NULL, 0L, &pStg)))
    {
        hr = Load(pStg);

        // IPersistStorage::Load will hold on to the pStg
        pStg->Release();
    }
    //REVIEW:  Is the first SetMoniker happening correctly?
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::Save, public
//
//  Synopsis:   Method of IPersistFile interface
//
//  Notes:      If a file is specified then this creates a docfile and
//              uses IPersistStorage::Save to complete the operation.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::Save(LPCOLESTR lpstrFile, BOOL fRemember)
{
    // if lpstrFile is NULL that means that we should save from where we
    // loaded.  Otherwise create a docfile with the specified name
    HRESULT hr = NOERROR;
    LPSTORAGE pStg;

    if (lpstrFile == NULL)
        (pStg = _pStg)->AddRef();
    else
        hr = StgCreateDocfile(lpstrFile, STGM_DFRALL|STGM_CREATE, 0L, &pStg);

    if (OK(hr))
    {
        hr = OleSave((LPPERSISTSTORAGE)this, pStg, pStg == _pStg);

        if (OK(hr))
        {
            // if we are to remember this storage then release our old
            // storage and hold on to the new.
            // Otherwise, wrap up a storage save by the usual SaveCompleted.
            if (lpstrFile != NULL && fRemember)
            {
                // release our previous storage or stream
                // and hold on to our new
                HandsOffStorage();
                ((LPPERSISTSTORAGE)this)->SaveCompleted(pStg);
            }
            else
            {
                // If we did a storage save and we are not switching to a new
                // storage then we complete the transaction with a SaveCompleted.
                ((LPPERSISTSTORAGE)this)->SaveCompleted(NULL);
            }
        }

        // Release the storage.  If we are supposed to hold on
        // to it then we have already add-ref'd it.
        pStg->Release();
    }

    // if we have renamed then
    if (lpstrFile != NULL)
    {
        // TBD: Send On_Renamed advise?
        //
        // inform our object of its new moniker
        //
        LPMONIKER pmk;
        if (OK(CreateFileMoniker(lpstrFile, &pmk)))
        {
            _pCtrl->SetMoniker(OLEWHICHMK_OBJFULL, pmk);
            pmk->Release();
        }
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::SaveCompleted, public
//
//  Synopsis:   Method of IPersistFile interface
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::SaveCompleted(LPCOLESTR lpstrFile)
{
    //REVIEW: should we launch advise in the case we are not fRemembering?
    if (_pCtrl != NULL)
        _pCtrl->OnSave();   // and notify any advises that we have saved

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrDV::GetCurFile, public
//
//  Synopsis:   Method of IPersistFile interface
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrDV::GetCurFile(LPOLESTR FAR * ppstrFile)
{
    if (ppstrFile == NULL)
    {
        DOUT(TEXT("SrvrDV::GetCurFile E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *ppstrFile = 0; //set out params to NULL

    HRESULT hr;

    // if we don't currently have a file then return the default filename
    if (_pStg == NULL)
    {
        // the default filename is *.ext where ext is our docfile extension
        OLECHAR szDefault[6];
#if defined(OLE2ANSI)        
        wsprintf(szDefault, TEXT("*%s"), _pClass->_szDocfileExt);
#else
        wsprintfW(szDefault, OLETEXT("*%ws"), _pClass->_szDocfileExt);        
#endif                
        hr = TaskAllocString(szDefault, ppstrFile);
    }
    else
    {
        // the caller will free the task-allocated file name
        STATSTG statstg;
        if (OK(hr = _pStg->Stat(&statstg, STATFLAG_DEFAULT)))
            *ppstrFile = statstg.pwcsName;
    }

    return hr;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\stdenum.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdenum.cxx
//
//  Contents:   Standard implementations of common enumerators
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop
#include <limits.h>         // for UINT_MAX below

//
//  forward declarations
//

class StdEnumOLEVERB;
typedef StdEnumOLEVERB FAR* LPSTDENUMOLEVERB;

class StdEnumFORMATETC;
typedef StdEnumFORMATETC FAR* LPSTDENUMFORMATETC;

#if 1
class StdStaticEnum;
typedef StdStaticEnum FAR* LPSTDSTATICENUM;
#endif  // 0


//+---------------------------------------------------------------
//
//  Class:      StdEnumOLEVERB
//
//  Purpose:    Standard enumerator of OLEVERB tables
//
//---------------------------------------------------------------

class StdEnumOLEVERB: public IEnumOLEVERB
{
    friend HRESULT CreateOLEVERBEnum(LPOLEVERB, ULONG, LPENUMOLEVERB FAR*);

public:
    DECLARE_STANDARD_IUNKNOWN(StdEnumOLEVERB);

    // *** IEnumOLEVERB methods ***
    STDMETHOD(Next) (ULONG celt, LPOLEVERB rgelt, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (IEnumOLEVERB FAR* FAR* ppenm);

private:
    StdEnumOLEVERB(LPOLEVERB pStart, ULONG cCount);
    ~StdEnumOLEVERB(void);

    LPOLEVERB _pStart;
    ULONG _cCount;
    ULONG _cCurrent;
};

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::StdEnumOLEVERB, private
//
//  Synopsis:   Constructor for StdEnumOLEVERB objects
//
//  Arguments:  [pStart] -- pointer to the beginning of the OLEVERB array
//              [cCount] -- the number of elements in the array
//
//  Notes:      OLEVERB enumerators should be constructed using the
//              CreateOLEVERBEnum function.
//
//----------------------------------------------------------------

StdEnumOLEVERB::StdEnumOLEVERB(LPOLEVERB pStart, ULONG cCount)
{
    _ulRefs = 1;
    _pStart = pStart;
    _cCount = cCount;
    _cCurrent = 0;
    DOUT(TEXT("StdEnumOLEVERB constructed.\r\n"));
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::~StdEnumOLEVERB, private
//
//  Synopsis:   Destructor for StdEnumOLEVERB objects
//
//  Notes:      Static enumerators should never be `deleted' but
//              instead IUnknown::Release'd.
//
//----------------------------------------------------------------

StdEnumOLEVERB::~StdEnumOLEVERB(void)
{
    DOUT(TEXT("StdEnumOLEVERB destructed.\r\n"));
}

IMPLEMENT_STANDARD_IUNKNOWN(StdEnumOLEVERB)

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumOLEVERB::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,IID_IEnumOLEVERB))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    DOUT(TEXT("StdEnumOLEVERB::QueryInterface E_NOINTERFACE\r\n"));
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumOLEVERB::Next(ULONG celt,
        LPOLEVERB pArrayObjs,
        ULONG FAR* pceltFetched)
{
    /* skip ahead to primary verb */
    for (;_cCurrent <= _cCount; _cCurrent++)
    {
        LPOLEVERB pVerb = &_pStart[_cCurrent];
        if (pVerb->lVerb >= OLEIVERB_PRIMARY)
            break;
    }

    ULONG celtFetched = min(celt, _cCount-_cCurrent);
    for (ULONG i = 0; i < celtFetched; i++, _cCurrent++)
    {
        LPOLEVERB pVerb = &_pStart[_cCurrent];

        pArrayObjs[i] = *pVerb;
        if (pVerb->lpszVerbName!=NULL)
        {
            HRESULT r;
            r = TaskAllocString(pVerb->lpszVerbName,
                    &pArrayObjs[i].lpszVerbName);
            if (!OK(r))
                return r;
        }
    }

    if (pceltFetched != NULL)
    {
        *pceltFetched = celtFetched;
    }

    return ((celtFetched == celt) ? NOERROR : S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumOLEVERB::Skip(ULONG celt)
{
    _cCurrent += celt;
    if (_cCurrent >= _cCount)
    {
        _cCurrent = _cCount;
        return S_FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumOLEVERB::Reset(void)
{
    _cCurrent = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumOLEVERB::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumOLEVERB::Clone(LPENUMOLEVERB FAR* ppenm)
{
    HRESULT r = E_OUTOFMEMORY;
    //LPSTDENUMOLEVERB penum = new (NullOnFail) StdEnumOLEVERB(_pStart, _cCount);
    LPSTDENUMOLEVERB penum = new StdEnumOLEVERB(_pStart, _cCount);
    if (penum != NULL)
    {
        r = NOERROR;
        penum->_cCurrent = _cCurrent;
        *ppenm = penum;
    }
    else
    {
        DOUT(TEXT("o2base/StdEnumOLEVERB::Clone failed\r\n"));
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateOLEVERBEnum, public
//
//  Synopsis:   Creates a standard enumerator over OLEVERB arrays
//
//  Arguments:  [pVerbs] -- pointer to the beginning of the OLEVERB array
//              [cVerbs] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IOleObject::EnumVerbs
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateOLEVERBEnum(LPOLEVERB pVerbs, ULONG cVerbs, LPENUMOLEVERB FAR* ppenum)
{
    HRESULT r = E_OUTOFMEMORY;
    //LPSTDENUMOLEVERB penum = new (NullOnFail) StdEnumOLEVERB(pVerbs, cVerbs);
    LPSTDENUMOLEVERB penum = new StdEnumOLEVERB(pVerbs, cVerbs);
    if (penum != NULL)
    {
        r = NOERROR;
        *ppenum = penum;
    }
    else
    {
        DOUT(TEXT("o2base/stdenum/CreateOLEVERBEnum failed\r\n"));
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Class:      StdEnumFORMATETC
//
//  Purpose:    Standard enumerator of FORMATETC tables
//
//---------------------------------------------------------------

class StdEnumFORMATETC: public IEnumFORMATETC
{
    friend HRESULT CreateFORMATETCEnum(LPFORMATETC, ULONG, LPENUMFORMATETC FAR*);
public:
    DECLARE_STANDARD_IUNKNOWN(StdEnumFORMATETC);

    // *** IEnumFORMATETC methods ***
    STDMETHOD(Next) (ULONG celt, LPFORMATETC rgelt, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (IEnumFORMATETC FAR* FAR* ppenm);

private:
    StdEnumFORMATETC(LPFORMATETC pStart, ULONG cCount);
    ~StdEnumFORMATETC(void);

    LPFORMATETC _pStart;
    ULONG _cCount;
    ULONG _cCurrent;
};

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::StdEnumFORMATETC, private
//
//  Synopsis:   Constructor for StdEnumFORMATETC objects
//
//  Arguments:  [pStart] -- pointer to the beginning of the FORMATETC array
//              [cCount] -- the number of elements in the array
//
//  Notes:      Static enumerators should be constructed using the
//              CreateFORMATETCEnum function.
//
//----------------------------------------------------------------

StdEnumFORMATETC::StdEnumFORMATETC(LPFORMATETC pStart, ULONG cCount)
{
    _ulRefs = 1;
    _pStart = pStart;
    _cCount = cCount;
    _cCurrent = 0;
    DOUT(TEXT("StdEnumFORMATETC constructed.\r\n"));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::~StdStaticEnum, private
//
//  Synopsis:   Destructor for StdStaticEnum objects
//
//  Notes:      Static enumerators should never be `deleted' but
//              instead IUnknown::Release'd.
//
//----------------------------------------------------------------

StdEnumFORMATETC::~StdEnumFORMATETC(void)
{
    DOUT(TEXT("StdEnumFORMATETC destructed.\r\n"));
}

IMPLEMENT_STANDARD_IUNKNOWN(StdEnumFORMATETC)

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumFORMATETC::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
#ifdef VERBOSE_DBG
    TCHAR achBuffer[256];
    wsprintf(achBuffer,
            TEXT("StdEnumFORMATETC::QueryInterface (%lx)\r\n"),
            riid.Data1);
    DOUT(achBuffer);
#endif //VERBOSE_DBG

    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,IID_IEnumFORMATETC))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }

#if VERBOSE_DBG
    wsprintf(achBuffer,
            TEXT("StdEnumFORMATETC::QueryInterface returning E_NOINTERFACE for %lx\r\n"),
            riid.Data1);
    DOUT(achBuffer);
#endif //VERBOSE_DBG
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumFORMATETC::Next(ULONG celt,
                        LPFORMATETC pArrayObjs,
                        ULONG FAR* pceltFetched)
{
    ULONG celtFetched = 0;

    if (_pStart == NULL)
        return S_FALSE;

    if (pceltFetched != NULL)
        *pceltFetched = 0L;

    if (pArrayObjs == NULL || _cCurrent >= _cCount)
        return S_FALSE;
    
    while ( _cCurrent < _cCount && celt > 0 )
    {
        LPFORMATETC pFormat = &_pStart[_cCurrent];

        // deep copy the FORMATETC structure
        
        *pArrayObjs = *pFormat;
        if (pFormat->ptd == DVTARGETIGNORE )
            pArrayObjs->ptd = NULL;
        
        if (pArrayObjs->ptd != NULL)
        {
            HRESULT r = TaskAllocMem(sizeof(DVTARGETDEVICE),
                (LPVOID FAR*)&pArrayObjs->ptd);
            if (OK(r))
            {
                *(pArrayObjs->ptd) = *(pFormat->ptd);
            }
        }
        pArrayObjs++;
        _cCurrent++;
        celtFetched++;
        celt--;
    }

    if (pceltFetched != NULL)
    {
        *pceltFetched = celtFetched - celt;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumFORMATETC::Skip(ULONG celt)
{
    _cCurrent += celt;
    if (_cCurrent >= _cCount)
    {
        _cCurrent = _cCount;
        return S_FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumFORMATETC::Reset(void)
{
    _cCurrent = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdEnumFORMATETC::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdEnumFORMATETC::Clone(LPENUMFORMATETC FAR* ppenm)
{
    HRESULT r = E_OUTOFMEMORY;;
    LPSTDENUMFORMATETC penum = new StdEnumFORMATETC(_pStart, _cCount);
    if (penum != NULL)
    {
        r = NOERROR;
        penum->_cCurrent = _cCurrent;
        *ppenm = penum;
    }
    else
    {
        DOUT(TEXT("o2base/StdEnumFORMATETC::Clone failed\r\n"));
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateFORMATETCEnum, public
//
//  Synopsis:   Creates a standard enumerator over FORMATETC arrays
//
//  Arguments:  [pFormats] -- pointer to the beginning of the FORMATETC array
//              [cFormats] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//  Notes:      This function is typically used in the IDataObject::EnumFormatetc
//              method implementation.
//
//----------------------------------------------------------------

HRESULT
CreateFORMATETCEnum(LPFORMATETC pFormats,
                    ULONG cFormats,
                    LPENUMFORMATETC FAR* ppenum)
{
    HRESULT r;
    LPSTDENUMFORMATETC penum = new StdEnumFORMATETC(pFormats, cFormats);
    if (penum == NULL)
    {
        DOUT(TEXT("o2base/stdenum/CreateFORMATETCEnum E_OUTOFMEMORY\r\n"));
        r = E_OUTOFMEMORY;
    }
    else
    {
        *ppenum = penum;
        r = NOERROR;
    }
    return r;
}

#if 1   // this maybe useful later but is not currently used.

//+---------------------------------------------------------------
//
//  Class:      StdStaticEnum
//
//  Purpose:    Enumerates over a static array
//
//  Notes:      This may not be used to enumerate over structures
//              that are "deep".  For instance, it cannot be used
//              to enumerate over an array of FORMATETCs because such
//              an enumerator needs to deep copy the ptd field
//              and the enumerator client frees these allocated ptd.
//              Similarly for the OLEVERB structure where the verb
//              name string must be deep copied.
//
//---------------------------------------------------------------

class StdStaticEnum: public IUnknown
{
    friend HRESULT CreateStaticEnum(REFIID, LPVOID, ULONG, ULONG, LPVOID FAR*);

public:
    DECLARE_STANDARD_IUNKNOWN(StdStaticEnum);

    //*** IEnumerator methods ***
    STDMETHOD(Next) (ULONG celt, LPVOID pArrayObjs, ULONG FAR* pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (LPSTDSTATICENUM FAR* ppenm);

private:
    // constructor/destructor
    StdStaticEnum(REFIID riid, LPVOID pStart, ULONG cSize, ULONG cCount);
    ~StdStaticEnum(void);

    IID _iid;
    LPVOID _pStart;
    ULONG _cSize;
    ULONG _cCount;
    ULONG _cCurrent;
};

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::StdStaticEnum, private
//
//  Synopsis:   Constructor for StdStaticEnum objects
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//
//  Notes:      Static enumerators should be constructed using the
//              CreateStaticEnum function.
//
//----------------------------------------------------------------

StdStaticEnum::StdStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount)
{
    _ulRefs = 1;
    _iid = riid;
    _pStart = pStart;
    _cSize = cSize;
    _cCount = cCount;
    _cCurrent = 0;
    DOUT(TEXT("StdStaticEnum constructed.\r\n"));
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::~StdStaticEnum, private
//
//  Synopsis:   Destructor for StdStaticEnum objects
//
//  Notes:      Static enumerators should never be `deleted' but
//              instead IUnknown::Release'd.
//
//----------------------------------------------------------------

StdStaticEnum::~StdStaticEnum(void)
{
    DOUT(TEXT("StdStaticEnum destructed.\r\n"));
}

IMPLEMENT_STANDARD_IUNKNOWN(StdStaticEnum);

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid,IID_IUnknown) || IsEqualIID(riid,_iid))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    DOUT(TEXT("StdStaticEnum::QueryInterface E_NOINTERFACE\r\n"));
    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Next
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Next(ULONG celt,
        LPVOID pArrayObjs,
        ULONG FAR* pceltFetched)
{
    ULONG celtFetched = min(celt, _cCount-_cCurrent);

    // calculate the number of bytes to copy
    if (celtFetched != 0 && _cSize > (UINT_MAX/celtFetched))
    {
        DOUT(TEXT("StdStaticEnum::Next E_FAIL\r\n"));
        return E_FAIL;         // overflow!
    }

    UINT count = (UINT) (celtFetched*_cSize);
    _fmemcpy(pArrayObjs, (LPBYTE)_pStart+_cCurrent*_cSize, count);
    _cCurrent += celtFetched;
    if (pceltFetched != NULL)
    {
        *pceltFetched = celtFetched;
    }
    return ((celtFetched == celt) ? NOERROR : S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Skip
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Skip(ULONG celt)
{
    _cCurrent += celt;
    if (_cCurrent >= _cCount)
    {
        _cCurrent = _cCount;
        return S_FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Reset
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Reset(void)
{
    _cCurrent = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     StdStaticEnum::Clone
//
//  Synopsis:   Member of IEnumXXX interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdStaticEnum::Clone(LPSTDSTATICENUM FAR* ppenm)
{
    HRESULT r;
    //LPSTDSTATICENUM penum = new (NullOnFail) StdStaticEnum(
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    _iid,
                                                    _pStart,
                                                    _cSize,
                                                    _cCount);
    if (penum == NULL)
    {
        DOUT(TEXT("o2base/StdStaticEnum::Clone failed\r\n"));
        r = E_OUTOFMEMORY;
    }
    else
    {
        penum->_cCurrent = _cCurrent;
        *ppenm = penum;
        r = NOERROR;
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateStaticEnum, public
//
//  Synopsis:   Creates a standard enumerator over static arrays
//
//  Arguments:  [riid] -- the enumerator interface that this class is
//                          "pretending" to be.
//              [pStart] -- pointer to the beginning of the static array
//              [cSize] -- the size of the elements of the array
//              [cCount] -- the number of elements in the array
//              [ppenum] -- where the enumerator is returned
//
//  Returns:    Success if the enumerator could be successfully created
//
//----------------------------------------------------------------

HRESULT
CreateStaticEnum(REFIID riid,
        LPVOID pStart,
        ULONG cSize,
        ULONG cCount,
        LPVOID FAR* ppenum)
{
    HRESULT r;
    //LPSTDSTATICENUM penum = new (NullOnFail) StdStaticEnum(
    LPSTDSTATICENUM penum = new StdStaticEnum(
                                                    riid,
                                                    pStart,
                                                    cSize,
                                                    cCount);
    if (penum == NULL)
    {
        DOUT(TEXT("o2base/stdenum/CreateStaticEnum failed\r\n"));
        r = E_OUTOFMEMORY;
    }
    else
    {
        *ppenum = penum;
        r = NOERROR;
    }
    return r;
}

#endif // 0

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\stgutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stgutils.hxx
//
//  Contents:   IStorage and IStream Helper functions
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------
//
//  Function:   GetMonikerDisplayName
//
//  Synopsis:   Retrieves the display name of a moniker
//
//  Arguments:  [pmk] -- the moniker for which the display name is requested
//              [ppstr] -- the place where the display name is returned
//
//  Returns:    Success iff the display name could be retrieved
//
//  Notes:      The display name string is allocated using the task allocator
//              and should be freed by the same.
//
//----------------------------------------------------------------

HRESULT
GetMonikerDisplayName(LPMONIKER pmk, LPOLESTR FAR* ppstr)
{
    HRESULT r;
    LPBC pbc;
    if (OK(r = CreateBindCtx(0, &pbc)))
    {
        r = pmk->GetDisplayName(pbc, NULL, ppstr);
        pbc->Release();
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   CreateStorageOnHGlobal
//
//  Synopsis:   Creates an IStorage on a global memory handle
//
//  Arguments:  [hgbl] -- memory handle to create storage on
//              [ppStg] -- where the storage is returned
//
//  Returns:    Success iff the storage could be successfully created
//              on the memory handle.
//
//  Notes:      This helper function combines CreateILockBytesOnHGlobal
//              and StgCreateDocfileOnILockBytes.  hgbl may be NULL in
//              which case a global memory handle will be automatically
//              allocated.
//
//----------------------------------------------------------------

HRESULT
CreateStorageOnHGlobal(HGLOBAL hgbl, LPSTORAGE FAR* ppStg)
{
    HRESULT r;
    LPLOCKBYTES pLockBytes;
    if (OK(r = CreateILockBytesOnHGlobal(hgbl, TRUE, &pLockBytes)))
    {
        //REVIEW:  should be use STGM_DELETEONRELEASE when hgbl == NULL?
        r = StgCreateDocfileOnILockBytes(pLockBytes,
                STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE, 0, ppStg);
        pLockBytes->Release();
    }
    return r;
}

//+---------------------------------------------------------------
//
//  Function:   ConvertToMemoryStream
//
//  Synopsis:   Takes a stream and produces an equivalent stream
//              stored in memory for faster individual reads
//
//  Arguments:  [pStrmFrom] -- the stream to convert
//
//  Returns:    An equivalent stream
//
//  Notes:      Any failure in creating the memory stream will result in
//              the original stream, pStrmFrom, being returned.
//              Hence the caller should assume the stream passed in has
//              been released and should release the stream returned
//              after it has finished using it.
//
//----------------------------------------------------------------

LPSTREAM
ConvertToMemoryStream(LPSTREAM pStrmFrom)
{
    //REVIEW:  perhaps we should use the IStream::CopyTo function
    // instead of doing the read manually!
    HRESULT r;
    LPSTREAM pStrm = NULL;
    STATSTG statstg;

    if (OK(r = pStrmFrom->Stat(&statstg, STATFLAG_NONAME)))
    {
        if (statstg.cbSize.HighPart != 0)
        {
            DOUT(TEXT("o2base/stdils/ConvertToMemoryStream E_FAIL\r\n"));
            r = E_FAIL;
        }
        else
        {
            HGLOBAL hgbl = GlobalAlloc(GMEM_SHARE, statstg.cbSize.LowPart);
            if (hgbl == NULL)
            {
               DOUT(TEXT("o2base/stgutils/ConvertToMemoryStream failed\r\n"));
               r = E_OUTOFMEMORY;
            }
            else
            {
                LPVOID pv = GlobalLock(hgbl);
                if (pv == NULL)
                {
                    DOUT(TEXT("o2base/stdils/ConvertToMemoryStream E_FAIL(2)\r\n"));
                    r = E_FAIL;
                }
                else
                {
                    r = pStrmFrom->Read(pv, statstg.cbSize.LowPart, NULL);
                    GlobalUnlock(hgbl);
                    if (OK(r))
                    {
                        if (OK(r = CreateStreamOnHGlobal(hgbl, TRUE, &pStrm)))
                        {
                            pStrm->SetSize(statstg.cbSize);
                            pStrmFrom->Release();
                        }
                        else
                        {
                            DOUT(TEXT("o2base/stdils/ConvertToMemoryStream CreateStreamOnHGlobal Failed!\r\n"));
                        }
                    }
                }
                if (!OK(r))
                {
                    GlobalFree(hgbl);
                }
            }
        }
    }

    if (!OK(r))
    {
        pStrm = pStrmFrom;
    }

    return pStrm;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\sinpl.cxx ===
//+---------------------------------------------------------------------
//
//   File:      sinpl.cxx
//
//   Contents:  Implementation of the SrvrInPlace class
//
//------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::SrvrInPlace, public
//
//  Synopsis:   Constructor for SrvrInPlace object
//
//  Notes:      To create a properly initialized object you must
//              call the Init method immediately after construction.
//
//---------------------------------------------------------------

SrvrInPlace::SrvrInPlace(void)
{
    DOUT(TEXT("SrvrInPlace: Constructing\r\n"));

    _hwnd = NULL;

    _pInPlaceSite = NULL;
    _frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    _pFrame = NULL;
    _pDoc = NULL;

    _hmenu = NULL;
    _hOleMenu = NULL;
    _hmenuShared = NULL;

    _fCSHelpMode = FALSE;
    _fChildActivating = FALSE;
    _fDeactivating = FALSE;
    _rcFrame.top = 0; _rcFrame.left = 0;
    _rcFrame.bottom = 0; _rcFrame.right = 0;

    _fClientResize = FALSE;
    _fUIDown = TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::Init, public
//
//  Synopsis:   Fully initializes a SrvrInPlace object
//
//  Arguments:  [pClass] -- The initialized class descriptor for the server
//              [pCtrl] -- The control subobject of the server we are a part of.
//
//  Returns:    NOERROR if successful
//
//  Notes:      The class descriptor pointer is saved in the protected _pClass
//              member variable where it is accessible during the lifetime
//              of the object.
//
//---------------------------------------------------------------

HRESULT
SrvrInPlace::Init(LPCLASSDESCRIPTOR pClass, LPSRVRCTRL pCtrl)
{
    _pClass = pClass;
    _pCtrl = pCtrl;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::~SrvrInPlace, protected
//
//  Synopsis:   Destructor for the SrvrCtrl object
//
//  Notes:      The destructor is called as a result of the servers
//              reference count going to 0.  It releases all held
//              resources.
//
//---------------------------------------------------------------

SrvrInPlace::~SrvrInPlace(void)
{
    DOUT(TEXT("SrvrInPlace: Destructed\r\n"));
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ActivateInPlace, public
//
//  Synopsis:   In-place activates the object
//
//  Arguments:  [pClientSite] -- The site on our container
//
//  Returns:    Success if we in-place activated properly
//
//  Notes:      This method implements the standard in-place activation
//              protocol and creates the in-place window.  It creates
//              all U.I. elements using CreateUI but does not
//              activate the U.I., for that is reserved for
//              the ActivateUI and InstallUI methods.
//
//---------------------------------------------------------------

HRESULT
SrvrInPlace::ActivateInPlace(LPOLECLIENTSITE pClientSite)
{
    DOUT(TEXT("SrvrInPlace::ActivateInPlace\r\n"));

    if (pClientSite == NULL)
    {
        DOUT(TEXT("SrvrInPlace::ActivateInPlace E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    HWND hwndSite;
    RECT rect, rectVis;
    HRESULT hr;

    //
    // see if the client site supports in-place, and is willing to do so...
    //
    if (OK(hr = pClientSite->QueryInterface(IID_IOleInPlaceSite,
                (LPVOID FAR *)&_pInPlaceSite)))
    {
        if (OK(hr = _pInPlaceSite->CanInPlaceActivate()))
        {
            if (OK(hr = _pInPlaceSite->GetWindow(&hwndSite))
                    &&  OK(hr = _pInPlaceSite->GetWindowContext(&_pFrame,
                                &_pDoc,
                                &rect,
                                &rectVis,
                                &_frameInfo)))
            {
                if ((_hwnd = AttachWin(hwndSite)) == NULL)
                {
                    DOUT(TEXT("SrvrInPlace::ActivateInPlace failed at AttachWin\r\n"));
                    hr = E_UNEXPECTED;
                }
                else
                {
                    if (OK(hr = _pInPlaceSite->OnInPlaceActivate()))
                    {
                        if(_pCtrl->IsIPBEnabled())
                        {
                            _IPB.Bind(_pInPlaceSite, _hwnd, FALSE);
                        }

                        // create any U.I. elements
                        CreateUI();

                        // position and show the window
                        SetObjectRects(&rect, &rectVis);
                        ShowWindow(_hwnd, SW_SHOW);

                        return NOERROR;

                        //
                        //The rest of this code cleans up after errors...
                        //
                    }
                    DetachWin();
                }
                if (_pFrame != NULL)
                    _pFrame->Release();
                if (_pDoc != NULL)
                    _pDoc->Release();
            }
        }
        _pInPlaceSite->Release();
    }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::DeactivateInPlace, public
//
//  Synopsis:   In-place deactivates the object
//
//  Returns:    Success except for catastophic circumstances
//
//  Notes:      This method "undoes" everything done in ActivateInPlace
//              including destroying U.I. elements via DestroyUI, and
//              destroying the inplace active window.
//
//---------------------------------------------------------------

HRESULT
SrvrInPlace::DeactivateInPlace(void)
{
    DOUT(TEXT("SrvrInPlace::DeactivateInPlace\r\n"));

    //
    // The following prevents some nasty recursion cases, in which the call
    // bellow to OnInPlaceDeactivate get's us back in to the same transition we
    // are in now...
    //
    _pCtrl->SetState(OS_RUNNING);
        
    // undo everything we did in InPlaceActivate
    if(_pCtrl->IsIPBEnabled())
    {
        _IPB.Detach();
    }

    DestroyUI();
    DetachWin();

    _pInPlaceSite->OnInPlaceDeactivate();

    if (_pFrame != NULL)
        _pFrame->Release();
    if (_pDoc != NULL)
        _pDoc->Release();

    // release the in-place site we were holding on to.
    _pInPlaceSite->Release();
    _pInPlaceSite = NULL;

    return NOERROR; // we never fail this function
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ActivateUI, public
//
//  Synopsis:   Notifies container of U.I. activation and installs our
//              U.I. elements.
//
//  Returns:    Success if our container granted permission to U.I. activate.
//
//  Notes:      Installing our U.I. (border toolbars, floating palettes,
//              adornments) is accomplished via a virtual call to InstallUI.
//
//---------------------------------------------------------------

HRESULT
SrvrInPlace::ActivateUI(void)
{
    DOUT(TEXT("SrvrInPlace::ActivateUI\r\n"));

    HRESULT hr;
    if (OK(hr = _pInPlaceSite->OnUIActivate()))
    {
        InstallUI();

        if(!GetChildActivating() && !IsDeactivating())
            ReflectState(TRUE);
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::DeactivateUI, public
//
//  Synopsis:   Removes any U.I. we have installed and notifies our container
//              that we are no longer U.I. active
//
//  Returns:    Success except for catastrophic circumstances
//
//  Notes:      This method "undoes" everything done in ActivateUI.
//              U.I. elements are removed via a virtual call to RemoveUI
//
//---------------------------------------------------------------

HRESULT
SrvrInPlace::DeactivateUI(void)
{
    DOUT(TEXT("SrvrInPlace::DeactivateUI\r\n"));

    //
    // The following prevents some nasty recursion cases, in which the call
    // bellow to OnUIDeactivate get's us back in to the same transition we
    // are in now...
    //
    _pCtrl->SetState(OS_INPLACE);
        
    // remove any UI that is up and notify our container that we have deactivated
    RemoveUI();
    _pInPlaceSite->OnUIDeactivate(FALSE);
    ReflectState(FALSE);

    //REVIEW: we should return TRUE if we add Undo capability.
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::InstallUI, public
//
//  Synopsis:   Installs previously created U.I. so it is displayed to
//              the user.
//
//  Notes:      This method will call the InstallFrameUI and InstallDocUI
//              methods to install those U.I. elements, respectively.
//
//---------------------------------------------------------------

void
SrvrInPlace::InstallUI(void)
{
    DOUT(TEXT("SrvrInPlace::InstallUI\r\n"));
    
    if(!_fChildActivating && !_fDeactivating)
    {
        _pFrame->SetActiveObject((LPOLEINPLACEACTIVEOBJECT)this,
                            _pClass->_szUserClassType[USERCLASSTYPE_SHORT]);
        InstallFrameUI();
        InstallDocUI();
        _fUIDown = FALSE;
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::RemoveUI, public
//
//  Synopsis:   Removes previously installed U.I. so it is hidden from the
//              the user.
//
//  Notes:      This method "undoes" everything done in InstallUI.  It calls
//              the RemoveFrameUI and RemoveDocUI methods.
//
//---------------------------------------------------------------

void
SrvrInPlace::RemoveUI(void)
{
    DOUT(TEXT("SrvrInPlace::RemoveUI\r\n"));

    if(!_fUIDown)
    {
        _fUIDown = TRUE;

        ClearSelection();
        RemoveDocUI();
        RemoveFrameUI();
        _pFrame->SetActiveObject(NULL, NULL);
    }
}


#ifdef DOCGEN  // documentation for pure virtual function
//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::AttachWin, public
//
//  Synopsis:   Attaches the child in-place window
//              to the given parent.
//
//  Arguments:  [hwndParent] -- parent window for child
//
//  Returns:    HWND of attached window
//
//  Notes:      All servers must override this method.
//
//---------------------------------------------------------------

HWND SrvrInPlace::AttachWin(HWND hwndParent) {}
#endif //DOCGEN

//+--------------------------------------------------------------
//
//  Member:     SrvrInPlace::DetachWin, public
//
//  Synopsis:   Detaches the child's in-place
//              window from the current parent.
//
//  Arguments:  [hwndParent] -- parent window for child
//
//  Notes:      This destroys the _hwnd of the server.
//              If the derived class does anything
//              other than create a Window on AttachWin,
//              it must over-ride this function.
//              If the derived class destroys the window
//              on detach, it must set _hwnd = NULL
//
//---------------------------------------------------------------
void
SrvrInPlace::DetachWin()
{
    DOUT(TEXT("SrvrInPlace::DetachWin\r\n"));

    Assert(_hwnd != NULL && IsWindow(_hwnd));
    DestroyWindow(_hwnd);
    _hwnd = NULL;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::CreateUI, protected
//
//  Synopsis:   Creates all U.I. elements
//
//  Notes:      This method uses information in the class descriptor
//              to create a merged menu and OLE menu descriptor.
//              Servers that have additional U.I. should override
//              this method, but can call the base class to do the
//              standard menu processing.
//
// IMPORTANT:   The derived class is responsible for having
//              settup the _hmenu member prior to calling
//              this code.
//
//---------------------------------------------------------------

void
SrvrInPlace::CreateUI(void)
{
    DOUT(TEXT("SrvrInPlace::CreateUI\r\n"));

    Assert(_hmenuShared == NULL);

    _fUIDown = TRUE;

    if (_hmenu != NULL)
    {
        // create an empty menu and ask application to insert its menus
        if ((_hmenuShared = CreateMenu()) != NULL)
        {
            // get a copy of our menu-group widths and perform the merge
            _mgw = _pClass->_mgw;
            if (OK(_pFrame->InsertMenus(_hmenuShared, &_mgw)))
            {
                // insert our own menus and create a descriptor for
                // the whole mess
                if (OK(InsertServerMenus(_hmenuShared, _hmenu, &_mgw)))
                    _hOleMenu = OleCreateMenuDescriptor(_hmenuShared, &_mgw);
            }
        }
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::DestroyUI, protected
//
//  Synopsis:   Destroys U.I. elements
//
//  Notes:      This method "undoes" everything that was done in
//              CreateUI -- destroys the shared menu and OLE menu
//              descriptor.  If a server overrides CreateUI then it
//              should also override this method.
//
//---------------------------------------------------------------

void
SrvrInPlace::DestroyUI(void)
{
    DOUT(TEXT("SrvrInPlace::DestroyUI\r\n"));

    if (_hmenuShared != NULL)
    {
        OleDestroyMenuDescriptor(_hOleMenu);
        RemoveServerMenus(_hmenuShared, &_mgw);
        _pFrame->RemoveMenus(_hmenuShared);
        DestroyMenu(_hmenuShared);
        _hmenuShared = NULL;
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::InstallFrameUI, protected
//
//  Synopsis:   Installs the U.I. elements on the frame window
//
//  Notes:      This method uses IOleInPlaceFrame::SetMenu to install
//              the shared menu constructed in CreateUI.  It also notifies
//              the frame that we are the active object.
//              Servers that have additional frame adornments should
//              override this method.
//              This method is called by the InstallUI method and
//              on document window activation for when we are in a MDI
//              an application.
//
//---------------------------------------------------------------

void
SrvrInPlace::InstallFrameUI(void)
{
    DOUT(TEXT("SrvrInPlace::InstallFrameUI\r\n"));

    _pFrame->SetMenu(_hmenuShared, _hOleMenu, _hwnd);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::RemoveFrameUI, protected
//
//  Synopsis:   Removes the U.I. elements on the frame window
//
//  Notes:      This method "undoes" everything that was done in
//              InstallFrameUI -- it removes the shared menu from
//              the frame.
//              Servers that override the InstallFrameUI method will
//              also want to override this method.
//              This method is call by the RemoveUI method and on
//              document window deactivation for MDI-application purposes.
//
//---------------------------------------------------------------

void
SrvrInPlace::RemoveFrameUI(void)
{
    DOUT(TEXT("SrvrInPlace::RemoveFrameUI\r\n"));

    _pFrame->SetMenu(NULL, NULL, _hwnd);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::InstallDocUI, protected
//
//  Synopsis:   Installs the U.I. elements on the document window
//
//  Notes:      This method notifies the document window that we are
//              the active object.  Otherwise, there are no standard U.I. elements
//              installed on the document window.
//              Servers that have document window tools should override this
//              method.
//
//---------------------------------------------------------------

void
SrvrInPlace::InstallDocUI(void)
{
    DOUT(TEXT("SrvrInPlace::InstallDocUI\r\n"));

    if (_pDoc != NULL)
    {
        DOUT(TEXT("SrvrInPlace::InstallDocUI (_pDoc != NULL)\r\n"));
        _pDoc->SetActiveObject((LPOLEINPLACEACTIVEOBJECT)this,
                                _pClass->_szUserClassType[USERCLASSTYPE_SHORT]);
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::RemoveDocUI, protected
//
//  Synopsis:   Removes the U.I. elements from the document window.
//
//  Notes:      This method "undoes" everything done in the InstallDocUI
//              method.
//              Servers that override the InstallDocUI method should
//              also override this method.
//
//---------------------------------------------------------------

void
SrvrInPlace::RemoveDocUI(void)
{
    DOUT(TEXT("SrvrInPlace::RemoveDocUI\r\n"));

    if (_pDoc != NULL)
    {
        _pDoc->SetActiveObject(NULL, NULL);
    }
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ClearSelection
//
//  Synopsis:   Removes any selection because we have lost ownership of the U.I.
//
//  Notes:      When our container or an embedding steals the right to put
//              up the U.I. then we should remove any selection to avoid
//              confusing the user.
//
//---------------------------------------------------------------

void
SrvrInPlace::ClearSelection(void)
{
    DOUT(TEXT("SrvrInPlace::ClearSelection\r\n"));
}


//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::SetFocus, public
//
//  Synopsis:   Overide in derived if focus-window != _hwnd
//
//---------------------------------------------------------------

void
SrvrInPlace::SetFocus(HWND hwnd)
{
    ::SetFocus(hwnd);
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::GetWindow, public
//
//  Synopsis:   Method of IOleWindow interface
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::GetWindow(HWND FAR* lphwnd)
{
    if (lphwnd == NULL)
    {
        DOUT(TEXT("SrvrInPlace::GetWindow E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    *lphwnd = _hwnd;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ContextSensitiveHelp, public
//
//  Synopsis:   Method of IOleWindow interface
//
//  Notes:      This method sets or clears the _fCSHelpMode
//              member flag.  The window procedure needs to pay
//              attention to the value of this flag in implementing
//              context-sensitive help.
//
//              We never fail!
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::ContextSensitiveHelp(BOOL fEnterMode)
{
    DOUT(TEXT("SrvrInPlace::ContextSensitiveHelp\r\n"));

    _fCSHelpMode = fEnterMode;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::InPlaceDeactivate, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method transitions the object to the loaded state
//              if the object is in the InPlace or U.I. active state.
//
//              We never fail!
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::InPlaceDeactivate(void)
{
    DOUT(TEXT("SrvrInPlace::InPlaceDeactivate\r\n"));

    if (_pCtrl->State() == OS_INPLACE || _pCtrl->State() == OS_UIACTIVE)
    {
        _pCtrl->TransitionTo(OS_LOADED);
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::UIDeactivate, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      The method transitions the object to the in-place state
//              if the object is in U.I. active state.
//
//              We never fail!
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::UIDeactivate(void)
{
    DOUT(TEXT("SrvrInPlace::UIDeactivate\r\n"));

    if (_pCtrl->State() == OS_UIACTIVE)
    {
        _fDeactivating = TRUE;
        _pCtrl->TransitionTo(OS_INPLACE);
        _fDeactivating = FALSE;
    }
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::SetObjectRects, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method does a Move window on the child
//              window to put it in its new position.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::SetObjectRects(LPCRECT lprcPos, LPCRECT lprcVisRect)
{
    DOUT(TEXT("SrvrInPlace::SetObjectRects\r\n"));

    if (lprcPos == NULL || lprcVisRect == NULL)
    {
        DOUT(TEXT("SrvrInPlace::SetObjectRects E_INVALIDARG\r\n"));
        return E_INVALIDARG;
    }

    _fClientResize = TRUE;  //indicate that we are being resized by client

    //
    // calculate and do the new child window positioning
    //
    RECT rc = *lprcPos;
    if(_pCtrl->IsIPBEnabled())
    {
        _IPB.SetSize(_hwnd, rc);
    }
    else
    {
        SetWindowPos( _hwnd, NULL, rc.left, rc.top,
            rc.right - rc.left, rc.bottom - rc.top,
            SWP_NOZORDER);
    }

    //
    // update our border rect (child window coordinates)
    //
    _rcFrame.right = rc.right - rc.left;
    _rcFrame.bottom = rc.bottom - rc.top;

    //
    // update our "native" extent
    //
    SIZEL sizel = { HimetricFromHPix(_rcFrame.right - _rcFrame.left),
            HimetricFromVPix(_rcFrame.bottom - _rcFrame.top) };

    _pCtrl->SetExtent(DVASPECT_CONTENT, &sizel);

    _fClientResize = FALSE; // indicate that client resize is over

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ReactivateAndUndo, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method returns E_FAIL.  If the server wishes
//              to support undo it should override this method.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::ReactivateAndUndo(void)
{
    DOUT(TEXT("SrvrInPlace::ReactivateAndUndo E_NOTIMPL\r\n"));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::TranslateAccelerator, public
//
//  Synopsis:   Method of IOleInPlaceActiveObject interface
//
//  Notes:      This method translates the message according
//              to the accelerator table in the class descriptor
//              structure.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::TranslateAccelerator(LPMSG lpmsg)
{
    //
    // translate the message via the SrvrInPlace accelerator table
    //
    if (_pClass->_haccel  &&
            ::TranslateAccelerator(_hwnd, _pClass->_haccel, lpmsg))
    {
        return NOERROR;
    }

    return S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::OnFrameWindowActivate, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method changes the color of our border shading
//              depending on whether our frame window is activating
//              or deactivating.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::OnFrameWindowActivate(BOOL fActivate)
{
    DOUT(TEXT("SrvrInPlace::OnFrameWindowActivate\r\n"));

    if(_pCtrl->IsIPBEnabled())
        _IPB.SetParentActive(fActivate);

    if(fActivate && _hwnd && (_pCtrl->State() != OS_OPEN))
        SetFocus(_hwnd);

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::OnDocWindowActivate, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      This method will install or remove the frame
//              U.I. elements using the InstallFrameUI or RemoveFrameUI
//              methods.  This is to properly handle the MDI application
//              case.  It also updates our shading color.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::OnDocWindowActivate(BOOL fActivate)
{
    DOUT(TEXT("SrvrInPlace::OnDocWindowActivate\r\n"));

    if (fActivate)
    {
        InstallFrameUI();
        SetFocus(_hwnd);
    }
    else if (!fActivate)
        RemoveFrameUI();

    if(_pCtrl->IsIPBEnabled())
        _IPB.SetParentActive(fActivate);

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::ResizeBorder, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      There are no standard border adornments so we do
//              nothing in this method.  Servers that have additional
//              U.I. elements that are installed on the frame or
//              document windows should override this method.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::ResizeBorder(LPCRECT lprc,
                        LPOLEINPLACEUIWINDOW pUIWindow,
                        BOOL fFrameWindow)
{
    DOUT(TEXT("SrvrInPlace::ResizeBorder\r\n"));

    // we do not install any tools on our frame or document windows.
    //REVIEW:  This must be implemented if we do implement a frame or document
    //REVIEW:  toolbar.

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SrvrInPlace::EnableModeless, public
//
//  Synopsis:   Method of IOleInPlaceObject interface
//
//  Notes:      If we are a DLL and hence don't have a separate
//              message pump we can ignore this call and simply
//              return NOERROR.
//
//---------------------------------------------------------------

STDMETHODIMP
SrvrInPlace::EnableModeless(BOOL fEnable)
{
    DOUT(TEXT("SrvrInPlace::EnableModeless\r\n"));

    return NOERROR;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\stdfact.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdfact.cxx
//
//  Contents:   Standard IClassFactory implementation
//
//  Classes:    StdClassFactory
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::StdClassFactory, public
//
//  Synopsis:   Constructor for StdUnknown class
//
//----------------------------------------------------------------

StdClassFactory::StdClassFactory(void)
{
    _ulRefs = 0;
    _ulLocks = 0;
}

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::AddRef(void)
{
    return ++_ulRefs;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::Release(void)
{
    Assert(_ulRefs > 0);
    --_ulRefs;

#if DBG
    if(_ulRefs == 0)
        DOUT(TEXT("StdClassFactory::Release _ulRefs == 0\r\n"));
#endif

    return _ulRefs;
}

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
#if DBG
    TCHAR achBuffer[256];
    wsprintf(achBuffer,
            TEXT("StdClassFactory::QueryInterface (%lx)\r\n"),
            riid.Data1);
    DOUT(achBuffer);
#endif

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        AddRef();
        *ppv = (LPCLASSFACTORY)this;
        return NOERROR;
    }
    *ppv = NULL;
    DOUT(TEXT("StdClassFactory::QueryInterface returning E_NOINTERFACE\r\n"));
    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
    {
        _ulLocks++;
    }
    else
    {
        Assert(_ulLocks > 0);
        _ulLocks--;
    }
    return NOERROR;
}

#ifdef DOCGEN
//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::CreateInstance, public
//
//  Synopsis:   Manufactures an instance of the class
//
//  Notes:      This pure virtual function must be overridden by the inheriting
//              class because the base class does not know what class to
//              instantiate.
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
        REFIID iid,
        LPVOID FAR* ppv) {};

//REVIEW: how to enforce ref counting of Class factory in object
// constructor/destructor?  Can we do this in a conjunction of StdUnknown
// with StdClassFactory.
#endif  // DOCGEN

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::CanUnload, public
//
//  Synopsis:   Returns TRUE iff there are no extant instances of
//              this class, outstanding references on the class factory,
//              or locks on the class factory.
//
//  Notes:      This function is for use in the standard DllCanUnloadNow
//              function.
//
//----------------------------------------------------------------

BOOL
StdClassFactory::CanUnload(void)
{
    return _ulRefs == 0 && _ulLocks == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\o2base\wutils.cxx ===
//+---------------------------------------------------------------------
//
//  File:       wutils.cxx
//
//  Contents:   Windows helper functions
//
//----------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------
//
//  Function:   LoadResourceData
//
//  Synopsis:   Loads a resource RCDATA block into a buffer
//
//  Arguments:  [hinst] -- instance of the module with the resource
//              [lpstrId] -- the identifier of the RCDATA resource
//              [lpvBuf] -- the buffer where the resource is to be loaded
//              [cbBuf] -- the number of bytes of resource data to load
//
//  Returns:    lpvBuf if the resource was successfully loaded, NULL otherwise
//
//  Notes:      This function combines Windows' FindResource, LoadResource,
//              LockResource, and a memory copy.
//
//----------------------------------------------------------------

LPVOID
LoadResourceData(HINSTANCE hinst,
        LPCTSTR lpstrId,
        LPVOID lpvBuf,
        int cbBuf)
{
    LPVOID lpvRet = NULL;
    HRSRC hrsrc = FindResource(hinst, lpstrId, RT_RCDATA);
    if (hrsrc != NULL)
    {
        HGLOBAL hgbl = LoadResource(hinst, hrsrc);
        if (hgbl != NULL)
        {
            LPVOID lpvSrc = LockResource(hgbl);
            if (lpvSrc != NULL)
            {
                lpvRet = _fmemcpy(lpvBuf, lpvSrc, cbBuf);
                UnlockResource(hgbl);
            }
            FreeResource(hgbl);
        }
    }
    return lpvRet;
}

//+---------------------------------------------------------------
//
//  Function:   GetChildWindowRect
//
//  Synopsis:   Gets the rectangle of the child window in
//              its parent window coordinates
//
//  Arguments:  [hwndChild] -- the child window
//              [lprect]  -- the rectangle to fill with childs coordinates
//
//  Notes:      This function gets the screen coordinates of the child
//              then maps them into the client coordinates of its parent.
//
//----------------------------------------------------------------

void
GetChildWindowRect(HWND hwndChild, LPRECT lprect)
{
    HWND hwndParent;
    POINT ptUpperLeft;
    POINT ptLowerRight;

    // get the screen coordinates of the child window
    GetWindowRect(hwndChild, lprect);

    // get the parent window of the child
    if ((hwndParent = GetParent(hwndChild)) != NULL)
    {
        // map the screen coordinates to client coordinates
        ptUpperLeft.x   = lprect->left;
        ptUpperLeft.y   = lprect->top;
        ptLowerRight.x  = lprect->right;
        ptLowerRight.y  = lprect->bottom;

        ScreenToClient(hwndParent, &ptUpperLeft);
        ScreenToClient(hwndParent, &ptLowerRight);

        SetRect(lprect,
                ptUpperLeft.x,
                ptUpperLeft.y,
                ptLowerRight.x,
                ptLowerRight.y);
    }
}

//+---------------------------------------------------------------
//
//  Function:   SizeClientRect
//
//  Synopsis:   Resizes the window so its client size is a specified
//              area.  Can also move the window so its client region
//              covers a specified rectangle.
//
//  Arguments:  [hwnd] -- the window to resize/move
//              [rc] -- rectangle indicating size and possibly position of
//                      client area
//              [fMove] -- flag indicating resize-only or move
//
//  Notes:      This function uses SetWindowPos which does not handle
//              accurately the case where the menu wraps to more than one line
//              as a result of the resize.
//
//----------------------------------------------------------------

void
SizeClientRect(HWND hwnd, RECT& rc, BOOL fMove)
{
    AdjustWindowRect(&rc,
            GetWindowLong(hwnd, GWL_STYLE),
            GetMenu(hwnd) != NULL);
    SetWindowPos(hwnd,
            NULL,
            rc.left,
            rc.top,
            rc.right-rc.left,
            rc.bottom-rc.top,
            SWP_NOZORDER|SWP_NOACTIVATE | (fMove ? 0 : SWP_NOMOVE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\file.h ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
/* file.h
 *
 * File I/O and related functions.
 */

#include <mmsystem.h>

/* make this a global def.*/

typedef struct tCKNODE {
   MMCKINFO ck;
   HPBYTE hpData;
   struct tCKNODE * psNext;
} CKNODE, *PCKNODE, FAR * LPCKNODE;

/* Fact Chunk, should be defined elsewhere. */
typedef struct tFACT {
   long lSamples;
} FACT, *PFACT, FAR * LPFACT;

/* export these.*/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\errorbox.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/*******************************************************************
 *
 *  ERRORBOX.C
 *
 *  Routines for dealing with Resource-string based message
 *  boxes.
 *
 *******************************************************************/
/* Revision History.
 *   4/2/91 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 *  22/Feb/94 LaurieGr Merged Motown and Daytona versions
 */

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include "soundrec.h"
#include <stdarg.h>
#include <stdio.h>


/*
 * @doc INTERNAL
 *
 * @func short | ErrorResBox | This function displays a message box using
 * program resource error strings.
 *
 * @parm    HWND | hwnd | Specifies the message box parent window.
 *
 * @parm    HANDLE | hInst | Specifies the instance handle of the module
 * that contains the resource strings specified by <p idAppName> and
 * <p idErrorStr>.  If this value is NULL, the instance handle is
 * obtained from <p hwnd> (in which case <p hwnd> may not be NULL).
 *
 * @parm    UINT | flags | Specifies message box types controlling the
 * message box appearance.  All message box types valid for <f MessageBox> are
 * valid.
 *
 * @parm    UINT | idAppName | Specifies the resource ID of a string that
 * is to be used as the message box caption.
 *
 * @parm    UINT | idErrorStr | Specifies the resource ID of a error
 * message format string.  This string is of the style passed to
 * <f wsprintf>, containing the standard C argument formatting
 * characters.  Any procedure parameters following <p idErrorStr> will
 * be taken as arguments for this format string.
 *
 * @parm    arguments | [ arguments, ... ] | Specifies additional
 * arguments corresponding to the format specification given by
 * <p idErrorStr>.  All string arguments must be FAR pointers.
 *
 * @rdesc   Returns the result of the call to <f MessageBox>.  If an
 * error occurs, returns zero.
 *
 * @comm    This is a variable arguments function, the parameters after
 * <p idErrorStr> being taken for arguments to the <f printf> format
 * string specified by <p idErrorStr>.  The string resources specified
 * by <p idAppName> and <p idErrorStr> must be loadable using the
 * instance handle <p hInst>.  If the strings cannot be
 * loaded, or <p hwnd> is not valid, the function will fail and return
 * zero.
 *
 */
#define STRING_SIZE 1024

short FAR _cdecl
ErrorResBox (
    HWND        hwnd,
    HANDLE      hInst,
    UINT        flags,
    UINT        idAppName,
    UINT        idErrorStr,
    ... )
{
    PTSTR    sz = NULL;
    PTSTR    szFmt = NULL;
    UINT    w;
    va_list va;         // got to do this for DEC Alpha platform
                        // where parameter lists are different.

    if (hInst == NULL) {
        if (hwnd == NULL) {
            MessageBeep(0);
            return FALSE;
        }
        hInst = (HANDLE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE);
    }

    w = 0;

    sz = (PTSTR) GlobalAllocPtr(GHND, STRING_SIZE*sizeof(TCHAR));
    szFmt = (PTSTR) GlobalAllocPtr(GHND, STRING_SIZE*sizeof(TCHAR));
    if (!sz || !szFmt)
        goto ExitError; // no mem, get out

    if (!LoadString(hInst, idErrorStr, szFmt, STRING_SIZE))
        goto ExitError;

    va_start(va, idErrorStr);
    wvsprintf(sz, szFmt, va);
    va_end(va);

    if (!LoadString(hInst, idAppName, szFmt, STRING_SIZE))
        goto ExitError;

    if (gfErrorBox) {
#if DBG
        TCHAR szTxt[256];
        wsprintf(szTxt, TEXT("!ERROR '%s'\r\n"), sz);
        OutputDebugString(szTxt);
#endif
        return 0;
    }
    else {
        gfErrorBox++;
        w = MessageBox(hwnd, sz, szFmt, flags);
        gfErrorBox--;
    }

ExitError:
    if (sz) GlobalFreePtr(sz);
    if (szFmt) GlobalFreePtr(szFmt);
    return (short)w;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\buttons.h ===
/******************************Module*Header*******************************\
* Module Name: chicago.h
*
* CD Playing application - support for Chicago
*
*
* Created: 19-04-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

/* -------------------------------------------------------------------------
** Button helper functions
** -------------------------------------------------------------------------
*/
void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    );

void
CheckSysColors(
    void
    );


extern DWORD        rgbFace;
extern DWORD        rgbShadow;
extern DWORD        rgbHilight;
extern DWORD        rgbFrame;
extern int          nSysColorChanges;


#if WINVER >= 0x0400
#ifndef NOBITMAPBTN

/* -------------------------------------------------------------------------
** Bitmap button styles
** -------------------------------------------------------------------------
*/

/*
** If you want little tool tips to popup next to your toolbar buttons
** use the style below.
*/
#define BBS_TOOLTIPS    0x00000100L   /* make/use a tooltips control */



/* -------------------------------------------------------------------------
** Bitmap button states
** -------------------------------------------------------------------------
*/
#define BTNSTATE_PRESSED     ODS_SELECTED
#define BTNSTATE_DISABLED    ODS_DISABLED
#define BTNSTATE_HAS_FOCUS   ODS_FOCUS




/* -------------------------------------------------------------------------
** Bitmap button structures
** -------------------------------------------------------------------------
*/
typedef struct {
    int     iBitmap;    /* Index into mondo bitmap of this button's picture */
    UINT    uId;        /* Button ID */
    UINT    fsState;    /* Button's state, see BTNSTATE_XXXX above */
} BITMAPBTN, NEAR *PBITMAPBTN, FAR *LPBITMAPBTN;




/* -------------------------------------------------------------------------
** Bitmap buttons public interfaces
** -------------------------------------------------------------------------
*/

BOOL WINAPI
BtnCreateBitmapButtons(
    HWND hwndOwner,
    HINSTANCE hBMInst,
    UINT wBMID,
    UINT uStyle,
    LPBITMAPBTN lpButtons,
    int nButtons,
    int dxBitmap,
    int dyBitmap
    );

void WINAPI
BtnDestroyBitmapButtons(
    HWND hwndOwner
    );

void WINAPI
BtnDrawButton(
    HWND hwndOwner,
    HDC hdc,
    int dxButton,
    int dyButton,
    LPBITMAPBTN lpButton
    );

void WINAPI
BtnDrawFocusRect(
    HDC hdc,
    const RECT *lpRect,
    UINT fsState
    );

void WINAPI
BtnUpdateColors(
    HWND hwndOwner
    );
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\buttons.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/******************************Module*Header*******************************\
* Module Name: buttons.c
*
* Bitmap button support.  On Daytona bitmap buttons are provided by
* mmcntrls.  On Chicago there is no mmcntrls, so we use the functions
* in this file.
*
*
* Created: 19-04-94
* Author:  Stephen Estrop [StephenE]
*
\**************************************************************************/
//#pragma warning( once : 4201 4214 )

#define NOOLE
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>

#include "buttons.h"


/* -------------------------------------------------------------------------
** Color globals
** -------------------------------------------------------------------------
*/
int         nSysColorChanges = 0;
DWORD       rgbFace;
DWORD       rgbShadow;
DWORD       rgbHilight;
DWORD       rgbFrame;


extern void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    );

#if 0
// also defined in sframe.c!

/*****************************Private*Routine******************************\
* PatB
*
* Fast way to fill an rectangle with a solid colour.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    )
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

#endif



/*****************************Private*Routine******************************\
* CheckSysColors
*
* Checks the system colors and updates the cached global variables if
* they have changed.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CheckSysColors(
    void
    )
{
   static COLORREF rgbSaveFace    = 0xffffffffL,
                   rgbSaveShadow  = 0xffffffffL,
                   rgbSaveHilight = 0xffffffffL,
                   rgbSaveFrame   = 0xffffffffL;

   rgbFace    = GetSysColor(COLOR_BTNFACE);
   rgbShadow  = GetSysColor(COLOR_BTNSHADOW);
   rgbHilight = GetSysColor(COLOR_BTNHIGHLIGHT);
   rgbFrame   = GetSysColor(COLOR_WINDOWFRAME);

   if (rgbSaveFace!=rgbFace || rgbSaveShadow!=rgbShadow
      || rgbSaveHilight!=rgbHilight || rgbSaveFrame!=rgbFrame)
   {
      ++nSysColorChanges;

      rgbSaveFace    = rgbFace;
      rgbSaveShadow  = rgbShadow;
      rgbSaveHilight = rgbHilight;
      rgbSaveFrame   = rgbFrame;

   }
}


#if WINVER >= 0x0400
/* -------------------------------------------------------------------------
** Button globals  -- some of these should be constants
** -------------------------------------------------------------------------
*/
const TCHAR   szBbmProp[]     = TEXT("ButtonBitmapProp");
const TCHAR   szButtonProp[]  = TEXT("ButtonProp");

typedef struct tagBTNSTATE {      /* instance data for toolbar window */
    WNDPROC     lpfnDefProc;
    HWND        hwndToolTips;
    HINSTANCE   hInst;
    UINT        wID;
    UINT        uStyle;
    HBITMAP     hbm;
    HDC         hdcGlyphs;
    HDC         hdcMono;
    HBITMAP     hbmMono;
    HBITMAP     hbmDefault;
    int         dxBitmap;
    int         dyBitmap;
    int         nButtons;
    int         nSysColorChanges;
    BITMAPBTN   Buttons[1];
} BTNSTATE, NEAR *PBTNSTATE, FAR *LPBTNSTATE;

typedef struct {
    WNDPROC     lpfnDefProc;
    HWND        hwndParent;
    HWND        hwndToolTips;
} BTN_INFO, *LPBTN_INFO;


LRESULT CALLBACK
ButtonSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
ParentSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

void FAR PASCAL
RelayToToolTips(
    HWND hwndToolTips,
    HWND hWnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
InitObjects(
    LPBTNSTATE pTBState
    );

BOOL
FreeObjects(
    LPBTNSTATE pTBState
    );

void
CreateButtonMask(
    LPBTNSTATE pTBState,
    PBITMAPBTN pTBButton
    );


/*****************************Private*Routine******************************\
* InitObjects
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
InitObjects(
    LPBTNSTATE pTBState
    )
{
    pTBState->hdcGlyphs = CreateCompatibleDC(NULL);
    if (pTBState->hdcGlyphs == NULL ) {
        return FALSE;
    }

    pTBState->hdcMono = CreateCompatibleDC(NULL);
    if (pTBState->hdcMono == NULL ) {
        DeleteObject( pTBState->hdcGlyphs );
        return FALSE;
    }

    pTBState->hbmMono = CreateBitmap( pTBState->dxBitmap,
                                      pTBState->dyBitmap, 1, 1, NULL);
    if ( pTBState->hbmMono == NULL ) {
        DeleteObject( pTBState->hdcGlyphs );
        DeleteObject( pTBState->hdcMono );
        return FALSE;
    }

    pTBState->hbmDefault = SelectObject(pTBState->hdcMono, pTBState->hbmMono);

    return TRUE;
}


/*****************************Private*Routine******************************\
* FreeObjects
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
FreeObjects(
    LPBTNSTATE pTBState
    )
{
    if (pTBState->hdcMono) {
        SelectObject(pTBState->hdcMono, pTBState->hbmDefault);
        DeleteDC(pTBState->hdcMono);              /* toast the DCs */
    }

    if (pTBState->hdcGlyphs) {
        DeleteDC(pTBState->hdcGlyphs);
    }

    if (pTBState->hbmMono) {
        DeleteObject(pTBState->hbmMono);
    }

    return TRUE;
}



/*****************************Private*Routine******************************\
* CreateButtonMask
*
* create a mono bitmap mask:
*   1's where color == COLOR_BTNFACE || COLOR_HILIGHT
*   0's everywhere else
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
CreateButtonMask(
    LPBTNSTATE pTBState,
    PBITMAPBTN pTBButton
    )
{
    /* initalize whole area with 0's */
    PatBlt( pTBState->hdcMono, 0, 0, pTBState->dxBitmap,
            pTBState->dyBitmap, WHITENESS);

    /* create mask based on color bitmap
    ** convert this to 1's
    */
    SetBkColor(pTBState->hdcGlyphs, rgbFace);
    BitBlt( pTBState->hdcMono, 0, 0, pTBState->dxBitmap, pTBState->dyBitmap,
            pTBState->hdcGlyphs, pTBButton->iBitmap * pTBState->dxBitmap, 0,
            SRCCOPY );

    /* convert this to 1's */
    SetBkColor(pTBState->hdcGlyphs, rgbHilight);

    /* OR in the new 1's */
    BitBlt( pTBState->hdcMono, 0, 0, pTBState->dxBitmap, pTBState->dyBitmap,
            pTBState->hdcGlyphs, pTBButton->iBitmap * pTBState->dxBitmap, 0,
            SRCPAINT );
}



#define PSDPxax     0x00B8074A


/*****************************Private*Routine******************************\
* BtnDrawButton
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnDrawButton(
    HWND hwnd,
    HDC hdc,
    int dx,
    int dy,
    LPBITMAPBTN ptButton
    )
{
    int         glyph_offset;
    HBRUSH      hbrOld, hbr;
    BOOL        bMaskCreated = FALSE;
    RECT        rcFocus;
    PBTNSTATE   pTBState;
    int         x = 0, y = 0;


    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);

    CheckSysColors();
    if (pTBState->nSysColorChanges != nSysColorChanges) {

        DeleteObject( pTBState->hbm );
        pTBState->hbm = CreateMappedBitmap( pTBState->hInst,
                                            pTBState->wID, TRUE, NULL, 0);
        pTBState->nSysColorChanges = nSysColorChanges;
    }

    /*
    ** erase with face color
    */

    PatB(hdc, x, y, dx, dy, rgbFace);

    SetRect( &rcFocus, x, y, x + dx, y + dy );

    if (ptButton->fsState & BTNSTATE_PRESSED) {
        DrawEdge( hdc, &rcFocus, EDGE_SUNKEN, BF_RECT );
        glyph_offset = 1;
    }
    else {
        DrawEdge( hdc, &rcFocus, EDGE_RAISED, BF_RECT );
        glyph_offset = 0;
    }


    /*
    ** make the coordinates the interior of the button
    */
    x++;
    y++;
    dx -= 2;
    dy -= 2;

    SelectObject( pTBState->hdcGlyphs, pTBState->hbm );

    /* now put on the face */

    /*
    ** We need to centre the Bitmap here within the button
    */
    x += ((dx - pTBState->dxBitmap ) / 2) - 1;
    y +=  (dy - pTBState->dyBitmap ) / 2;

    if (!(ptButton->fsState & BTNSTATE_DISABLED)) {

        /* regular version */
        BitBlt( hdc, x + glyph_offset, y + glyph_offset,
                pTBState->dxBitmap, pTBState->dyBitmap,
                pTBState->hdcGlyphs,
                ptButton->iBitmap * pTBState->dxBitmap, 0, SRCCOPY);
    }
    else {

        /* disabled version */
        bMaskCreated = TRUE;
        CreateButtonMask(pTBState, ptButton );

        SetTextColor(hdc, 0L);          /* 0's in mono -> 0 (for ROP) */
        SetBkColor(hdc, 0x00FFFFFF);    /* 1's in mono -> 1 */

        hbr = CreateSolidBrush(rgbHilight);
        if (hbr) {
            hbrOld = SelectObject(hdc, hbr);
            if (hbrOld) {
                /* draw hilight color where we have 0's in the mask */
                BitBlt( hdc, x + 1, y + 1,
                        pTBState->dxBitmap, pTBState->dyBitmap,
                        pTBState->hdcMono, 0, 0, PSDPxax);
                SelectObject(hdc, hbrOld);
            }
            DeleteObject(hbr);
        }

        hbr = CreateSolidBrush(rgbShadow);
        if (hbr) {
            hbrOld = SelectObject(hdc, hbr);
            if (hbrOld) {
                /* draw the shadow color where we have 0's in the mask */
                BitBlt(hdc, x, y, pTBState->dxBitmap, pTBState->dyBitmap,
                       pTBState->hdcMono, 0, 0, PSDPxax);
                SelectObject(hdc, hbrOld);
            }
            DeleteObject(hbr);
        }
    }

    if (ptButton->fsState & ODS_FOCUS) {

        BtnDrawFocusRect(hdc, &rcFocus, ptButton->fsState);
    }
}



/*****************************Private*Routine******************************\
* BtnCreateBitmapButtons
*
* Returns TRUE if successful, otherwise FALSE;
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL WINAPI
BtnCreateBitmapButtons(
    HWND hWnd,
    HINSTANCE hInst,
    UINT wID,
    UINT uStyle,
    LPBITMAPBTN lpButtons,
    int nButtons,
    int dxBitmap,
    int dyBitmap
    )
{
    PBTNSTATE pTBState;


    /*
    ** If we have already created Bitmap Buttons for this
    ** window just return.
    */
    if (GetProp(hWnd, szBbmProp)) {
        return TRUE;
    }

    // InitGlobalMetrics();
    // InitToolTipsClass( hInst );

    CheckSysColors();

    /*
    ** Allocate the required storage and save the pointer in the window
    ** property list.
    */
    pTBState = (PBTNSTATE)GlobalAllocPtr( GHND,
                                      (sizeof(BTNSTATE) - sizeof(BITMAPBTN)) +
                                      (nButtons * sizeof(BITMAPBTN)) );
    if (pTBState == NULL ) {
        return FALSE;
    }
    SetProp(hWnd, szBbmProp, (HANDLE)pTBState);


    pTBState->hInst       = hInst;
    pTBState->wID         = wID;
    pTBState->uStyle      = uStyle;
    pTBState->nButtons    = nButtons;
    pTBState->hbm         = CreateMappedBitmap( hInst, wID, TRUE, NULL, 0);
    pTBState->dxBitmap    = dxBitmap;
    pTBState->dyBitmap    = dyBitmap;

    InitObjects( pTBState );

    CopyMemory( pTBState->Buttons, lpButtons, nButtons * sizeof(BITMAPBTN) );

    /*
    ** Does the caller want tool tips ?
    */
    if (pTBState->uStyle & BBS_TOOLTIPS) {
        extern BOOL gfIsRTL;   
        pTBState->hwndToolTips = CreateWindowEx(
                                              gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0,
                                              TOOLTIPS_CLASS, TEXT(""),
                                              WS_POPUP,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              hWnd, NULL, hInst, NULL);


        if (pTBState->hwndToolTips != (HWND)NULL ) {

            int         i;
            TOOLINFO    ti;

            pTBState->lpfnDefProc = SubclassWindow( hWnd, ParentSubclassProc );

            ti.uFlags = 0;
            ti.cbSize = sizeof(ti);
            ti.lpszText = LPSTR_TEXTCALLBACK;

            for ( i = 0; i < nButtons; i++ ) {

                LPBTN_INFO  lpBtnInfo;
                HWND        hwndBtn;

                hwndBtn = GetDlgItem(hWnd, pTBState->Buttons[i].uId);
                if ( hwndBtn == (HWND)NULL ) {
                    break;
                }

                lpBtnInfo = (LPBTN_INFO)GlobalAllocPtr(GHND, sizeof(BTN_INFO));
                if (lpBtnInfo == NULL ) {
                    break;
                }

                SetProp(hwndBtn, szButtonProp, (HANDLE)lpBtnInfo);
                lpBtnInfo->hwndToolTips = pTBState->hwndToolTips;
                lpBtnInfo->hwndParent   = hWnd;
                lpBtnInfo->lpfnDefProc = SubclassWindow( hwndBtn,
                                                         ButtonSubclassProc );

                ti.hwnd = hwndBtn;
                ti.uId = pTBState->Buttons[i].uId;

                GetClientRect( hwndBtn, &ti.rect );
                SendMessage( lpBtnInfo->hwndToolTips, TTM_ADDTOOL,
                             (WPARAM)0, (LPARAM)&ti );


                /*
                ** Add the same rectange in parent co-ordinates so that
                ** the tooltip still gets displayed even though the button
                ** is disbaled.
                */
                MapWindowRect( hwndBtn, hWnd, &ti.rect );
                ti.hwnd = hWnd;
                SendMessage( lpBtnInfo->hwndToolTips, TTM_ADDTOOL,
                             (WPARAM)0, (LPARAM)&ti );
            }

        }
        else {

            /*
            ** No tips available, just remove the BBS_TOOLTIPS style
            */
            pTBState->uStyle &= ~BBS_TOOLTIPS;
        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* BtnDestroyBitmapButtons
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnDestroyBitmapButtons(
    HWND hwnd
    )
{
    PBTNSTATE pTBState;

    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);
    if ( pTBState != NULL ) {
        if (pTBState->hbm)
            DeleteObject( pTBState->hbm );
        FreeObjects( pTBState );
        GlobalFreePtr( pTBState );
    }
    RemoveProp(hwnd, szBbmProp);
}


/******************************Public*Routine******************************\
* BtnDrawFocusRect
*
* Use this function to draw focus rectangle around a bitmap button.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnDrawFocusRect(
    HDC hdc,
    const RECT *lpRect,
    UINT fsState
    )
{
    int     iFaceOffset;
    RECT    rc;

    CopyRect( &rc, lpRect );

    rc.top = rc.left = 3;

    if (fsState & ODS_SELECTED) {
        iFaceOffset = 2;
    }
    else {
        iFaceOffset = 4;
    }

    rc.right  -= iFaceOffset;
    rc.bottom -= iFaceOffset;

    SetBkColor( hdc, rgbFace );
    DrawFocusRect( hdc, &rc );
}


/******************************Public*Routine******************************\
* BtnUpdateColors
*
* After a WM_SYSCOLORCHANGE message is received this function should be
* called to update the colors of the button bitmaps.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void WINAPI
BtnUpdateColors(
    HWND hwnd
    )
{
    PBTNSTATE   pTBState;

    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);
    if (pTBState->nSysColorChanges != nSysColorChanges)
    {
        DeleteObject( pTBState->hbm );
        pTBState->hbm = CreateMappedBitmap( pTBState->hInst,
                                            pTBState->wID, TRUE, NULL, 0);

        pTBState->nSysColorChanges = nSysColorChanges;
    }
}


/******************************Public*Routine******************************\
* ButtonSubclassProc
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
ButtonSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPBTN_INFO  lpBtnInfo;
    WNDPROC     lpfnDefProc;


    lpBtnInfo = (LPBTN_INFO)GetProp( hwnd, szButtonProp );

    /*
    ** Save this in case anything happens to lpBtnInfo before we return.
    */
    lpfnDefProc = lpBtnInfo->lpfnDefProc;

    switch ( uMsg ) {

    case WM_DESTROY:
        SubclassWindow( hwnd, lpfnDefProc );
        if (lpBtnInfo) {
            GlobalFreePtr(lpBtnInfo);
            RemoveProp(hwnd, szButtonProp);
        }
        break;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MOUSEMOVE:
        RelayToToolTips( lpBtnInfo->hwndToolTips, hwnd, uMsg, wParam, lParam );
        break;

#if WINVER < 0x0400
    case WM_WININICHANGE:
        InitGlobalMetrics();
        break;
#endif

    case WM_MOVE:
        {
            TOOLINFO    ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = 0;
            ti.hwnd = hwnd;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.uId = GetDlgCtrlID( hwnd );

            GetClientRect( hwnd, &ti.rect );

            SendMessage( lpBtnInfo->hwndToolTips, TTM_NEWTOOLRECT, 0,
                         (LPARAM)&ti );

            /*
            ** Add the same rectange in parent co-ordinates so that
            ** the tooltip still gets displayed even though the button
            ** is disbaled.
            */
            MapWindowRect( hwnd, lpBtnInfo->hwndParent, &ti.rect );
            ti.hwnd = lpBtnInfo->hwndParent;
            SendMessage( lpBtnInfo->hwndToolTips, TTM_NEWTOOLRECT,
                         (WPARAM)0, (LPARAM)&ti );
        }
        break;

    case WM_NOTIFY:
        SendMessage(lpBtnInfo->hwndParent, WM_NOTIFY, wParam, lParam);
        break;

    }

    return CallWindowProc(lpfnDefProc, hwnd, uMsg, wParam, lParam);
}


/******************************Public*Routine******************************\
* ParentSubclassProc
*
* Why do I need to subclass the buttons parent window ?  Well,
* if a button is disable it will not receive mouse messages, the
* messages go to the window underneath the button (ie. the parent).
* Therefore we detect this and relay the mouse message to the tool tips
* window as above.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
ParentSubclassProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    WNDPROC     lpfnDefProc;
    PBTNSTATE   pTBState;


    pTBState = (PBTNSTATE)GetProp(hwnd, szBbmProp);

    /*
    ** Save this in case anything happens to lpBtnInfo before we return.
    */
    lpfnDefProc = pTBState->lpfnDefProc;

    switch ( uMsg ) {

#if WINVER < 0x0400
    case TB_ACTIVATE_TOOLTIPS:
        SendMessage( pTBState->hwndToolTips, TTM_ACTIVATE, wParam, 0L );
        break;
#endif

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MOUSEMOVE:
        RelayToToolTips( pTBState->hwndToolTips, hwnd, uMsg, wParam, lParam );
        break;

    case WM_DESTROY :
    {
        SubclassWindow( hwnd, lpfnDefProc );
        BtnDestroyBitmapButtons(hwnd);
    }
    break;

    }

    return CallWindowProc(lpfnDefProc, hwnd, uMsg, wParam, lParam);
}

/******************************Public*Routine******************************\
* RelayToToolTips
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void FAR PASCAL
RelayToToolTips(
    HWND hwndToolTips,
    HWND hWnd,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if(hwndToolTips) {
        MSG msg;
        msg.lParam = lParam;
        msg.wParam = wParam;
        msg.message = wMsg;
        msg.hwnd = hWnd;
        SendMessage(hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\convert.h ===
LPTSTR SoundRec_GetFormatName(LPWAVEFORMATEX pwfx);

MMRESULT FAR PASCAL
ChooseDestinationFormat(
    HINSTANCE       hInst,
    HWND            hwndParent,
    PWAVEFORMATEX   pwfxIn,
    PWAVEFORMATEX   *ppwfxOut,
    DWORD           fdwEnum);

typedef struct tPROGRESS {
    HWND            hPrg;           // window to post progress messages
    DWORD           dwTotal;        // percent of full process this requires
    DWORD           dwComplete;     // fixed percent completed
} PROGRESS, *PPROGRESS, FAR * LPPROGRESS;

UINT_PTR CALLBACK SaveAsHookProc(
    HWND    hdlg,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam);

MMRESULT
ConvertFormat(
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg);          // progress update

MMRESULT
ConvertMultipleFormats(
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg);          // progress update

MMRESULT
ConvertFormatDialog(
    HWND            hParent,
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg);          // progress update


typedef struct t_SGLOBALS {
    PWAVEFORMATEX   *ppwfx;
    DWORD           *pcbwfx;
    DWORD           *pcbdata;
    LPBYTE          *ppbdata;
    LONG            *plSamples;     // number of samples 
    LONG            *plSamplesValid;// number of valid samples
    LONG            *plWavePosition;// current sample position
} SGLOBALS, *PSGLOBALS, FAR * LPSGLOBALS;

/* extend use of this throughout soundrec */
typedef struct t_WAVEDOC
{
    PWAVEFORMATEX   pwfx;       // format
    LPBYTE          pbdata;     // sample data
    DWORD           cbdata;     // sizeof data buffer
    LPTSTR          pszFileName;    // document file name
    LPTSTR          pszCopyright; // copyright info
    HICON           hIcon;      // document icon
    BOOL            fChanged;   // changed in viewing
    LPVOID          lpv;        // extra
} WAVEDOC, *PWAVEDOC, FAR *LPWAVEDOC;

BOOL SoundRec_Properties(HWND hwnd, HINSTANCE hinst, PWAVEDOC pwd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\convert.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* convert.c
 *
 * conversion utilites.
 */
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <commctrl.h>
#if WINVER >= 0x0400
# include "..\..\msacm\msacm\msacm.h"
#else
# include <msacm.h>
#endif
#include <commdlg.h>
#include <dlgs.h>
#include <convert.h>
#include <msacmdlg.h>

#include "soundrec.h"
#ifdef CHICAGO
#include "helpids.h"
#endif

BOOL gfBreakOfDeath;
/*
 **/
LPTSTR SoundRec_GetFormatName(
    LPWAVEFORMATEX pwfx)
{
    ACMFORMATTAGDETAILS aftd;
    ACMFORMATDETAILS    afd;
    const TCHAR         szFormat[] = TEXT("%s %s");
    LPTSTR              lpstr;
    UINT                cbstr;

    ZeroMemory(&aftd, sizeof(ACMFORMATTAGDETAILS));    
    aftd.cbStruct = sizeof(ACMFORMATTAGDETAILS);
    aftd.dwFormatTag = pwfx->wFormatTag;

    if (MMSYSERR_NOERROR != acmFormatTagDetails( NULL
                                                 , &aftd
                                                 , ACM_FORMATTAGDETAILSF_FORMATTAG))
    {
        aftd.szFormatTag[0] = 0;
    }

    ZeroMemory(&afd, sizeof(ACMFORMATDETAILS));
    afd.cbStruct = sizeof(ACMFORMATDETAILS);
    afd.pwfx = pwfx;
    afd.dwFormatTag = pwfx->wFormatTag;

    afd.cbwfx = sizeof(WAVEFORMATEX);
    if (pwfx->wFormatTag != WAVE_FORMAT_PCM)
        afd.cbwfx += pwfx->cbSize;

    if (MMSYSERR_NOERROR != acmFormatDetails( NULL
                                              , &afd
                                              , ACM_FORMATDETAILSF_FORMAT))
    {
        afd.szFormat[0] = 0;
    }

    cbstr = sizeof(LPTSTR) * ( lstrlen(aftd.szFormatTag) + lstrlen(afd.szFormat) + lstrlen(szFormat));
    lpstr = (LPTSTR) GlobalAllocPtr(GHND, cbstr);
    if (lpstr)
        wsprintf(lpstr, szFormat, aftd.szFormatTag, afd.szFormat);
    return lpstr;
}

/* 
 * SaveAsHookProc
 *
 * This is a hook proc for the Save As common dialog to support conversion
 * upon save.
 **/
UINT_PTR CALLBACK SaveAsHookProc(
    HWND    hdlg,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
#ifdef CHICAGO
    int DlgItem;
    static const DWORD aHelpIds[] = {
        IDC_TXT_FORMAT,         IDH_SOUNDREC_CHANGE,
        IDC_CONVERTTO,          IDH_SOUNDREC_CHANGE,
        IDC_CONVERT_TO,         IDH_SOUNDREC_CHANGE,
        0,                      0
    };
    extern DWORD aChooserHelpIds[];
    extern UINT  guChooserContextMenu;
    extern UINT  guChooserContextHelp;
    
    //
    //  Handle context-sensitive help messages from acm dialog
    //
    if( msg == guChooserContextMenu )
    {
        WinHelp( (HWND)wParam, NULL, HELP_CONTEXTMENU, 
            (UINT_PTR)(LPSTR)aChooserHelpIds );
        return TRUE;
    }
    else if( msg == guChooserContextHelp )
    {
        WinHelp( ((LPHELPINFO)lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (UINT_PTR)(LPSTR)aChooserHelpIds );
        return TRUE;
    }
    
#endif    
    
    switch (msg)
    {
#ifdef CHICAGO
        case WM_CONTEXTMENU:
            DlgItem = GetDlgCtrlID((HWND)wParam);
            
            //
            // Only process the id's we are responsible for
            //
            if (DlgItem != IDC_CONVERTTO && DlgItem != IDC_CONVERT_TO && DlgItem != IDC_TXT_FORMAT)
                break;

            WinHelp((HWND)wParam, gachHelpFile, HELP_CONTEXTMENU, 
                (UINT_PTR)(LPSTR)aHelpIds);

            return TRUE;

        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lParam;

            //
            // Only process the id's we are responsible for
            //
            DlgItem = GetDlgCtrlID(lphi->hItemHandle);
            if (DlgItem != IDC_CONVERTTO && DlgItem != IDC_CONVERT_TO && DlgItem != IDC_TXT_FORMAT)
                break;
            WinHelp (lphi->hItemHandle, gachHelpFile, HELP_WM_HELP,
                    (UINT_PTR) (LPSTR) aHelpIds);
            return TRUE;
        }
#endif

        case WM_INITDIALOG:
        {
            LPTSTR          lpszFormat;
            PWAVEFORMATEX * ppwfx;
                        
            // passed in through lCustData
            ppwfx = (PWAVEFORMATEX *)((OPENFILENAME *)(LPVOID)lParam)->lCustData;

            SetProp(hdlg,  TEXT("DATA"), (HANDLE)ppwfx);

            lpszFormat = SoundRec_GetFormatName(gpWaveFormat);
            if (lpszFormat)
            {
                SetDlgItemText(hdlg, IDC_CONVERT_TO, lpszFormat);
                SetDlgItemText(hdlg, IDC_CONVERT_FROM, lpszFormat);
                GlobalFreePtr(lpszFormat);
            }
            return FALSE;
        }
            
        case WM_COMMAND:
        {
            PWAVEFORMATEX *ppwfx = (PWAVEFORMATEX *)GetProp(hdlg, TEXT("DATA"));
            int id = GET_WM_COMMAND_ID(wParam, lParam);
            switch (id)
            {
                case IDC_CONVERTTO:
                {
                    PWAVEFORMATEX pwfxNew = NULL;
                    if (ChooseDestinationFormat(ghInst
                                                ,hdlg
                                                ,NULL
                                                ,&pwfxNew
                                                ,0L) == MMSYSERR_NOERROR)
                    {
                        LPTSTR lpszFormat;
                        if (*ppwfx)
                            GlobalFreePtr(*ppwfx);

                        //
                        // set string name
                        //
                        lpszFormat = SoundRec_GetFormatName(pwfxNew);
                        if (lpszFormat)
                        {
                            SetDlgItemText(hdlg, IDC_CONVERT_TO, lpszFormat);
                            GlobalFreePtr(lpszFormat);
                        }
                        //
                        // do something
                        // 
                        *ppwfx = pwfxNew;
                    }
                    return TRUE;
                }
                default:
                    break;
            }
            break;
        }

        case WM_DESTROY:
            RemoveProp(hdlg, TEXT("DATA"));
            break;

        default:
            break;
    }
    return FALSE;
}

/*
 * Launches the chooser dialog for changing the destination format.
 */
MMRESULT FAR PASCAL
ChooseDestinationFormat(
    HINSTANCE       hInst,
    HWND            hwndParent,
    PWAVEFORMATEX   pwfxIn,
    PWAVEFORMATEX   *ppwfxOut,
    DWORD           fdwEnum)
{
    ACMFORMATCHOOSE     cwf;
    MMRESULT            mmr;
    LPWAVEFORMATEX      pwfx;
    DWORD               dwMaxFormatSize;
    
    mmr = acmMetrics(NULL
                     , ACM_METRIC_MAX_SIZE_FORMAT
                     , (LPVOID)&dwMaxFormatSize);

    if (mmr != MMSYSERR_NOERROR)
        return mmr;
    
    pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)dwMaxFormatSize);
    if (pwfx == NULL)
        return MMSYSERR_NOMEM;
    
    memset(&cwf, 0, sizeof(cwf));
    
    cwf.cbStruct    = sizeof(cwf);
    cwf.hwndOwner   = hwndParent;
    cwf.fdwStyle    = 0L;

    cwf.fdwEnum     = 0L;           // all formats!
    cwf.pwfxEnum    = NULL;         // all formats!
    
    if (fdwEnum)
    {
        cwf.fdwEnum     = fdwEnum;
        cwf.pwfxEnum    = pwfxIn;
    }
    
    cwf.pwfx        = (LPWAVEFORMATEX)pwfx;
    cwf.cbwfx       = dwMaxFormatSize;

#ifdef CHICAGO
    cwf.fdwStyle    |= ACMFORMATCHOOSE_STYLEF_CONTEXTHELP;
#endif

    mmr = acmFormatChoose(&cwf);
    
    if (mmr == MMSYSERR_NOERROR)
        *ppwfxOut = pwfx;
    else
    {
        *ppwfxOut = NULL;
        GlobalFreePtr(pwfx);
    }
    return mmr;
    
}
#ifndef WM_APP
#define WM_APP                          0x8000
#endif

#define MYWM_CANCEL      (WM_APP+0)
#define MYWM_PROGRESS    (WM_APP+1)

/* Update a progress dialog
 */
BOOL
ProgressUpdate (
    PPROGRESS       pPrg,
    DWORD           dwCompleted)
{
    DWORD dwDone;
    BOOL  fCancel;

    if (pPrg == NULL)
        return TRUE;

    dwDone = (dwCompleted * pPrg->dwTotal) / 100L + pPrg->dwComplete;

    if (!IsWindow(pPrg->hPrg))
        return FALSE;
        
    SendMessage( pPrg->hPrg, MYWM_CANCEL, (WPARAM)&fCancel, 0L);
    if (fCancel)
    {
        return FALSE;
    }

    PostMessage( pPrg->hPrg, MYWM_PROGRESS, (WPARAM)dwDone, 0L);
    return TRUE;
}


//
// should support a file handle as well.
//

typedef struct tConvertParam {
    PWAVEFORMATEX   pwfxSrc;        // pwfx specifying source format
    DWORD           cbSrc;          // size of the source buffer
    LPBYTE          pbSrc;          // source buffer
    PWAVEFORMATEX   pwfxDst;        // pwfx specifying dest format
    DWORD *         pcbDst;         // return size of the dest buffer
    LPBYTE *        ppbDst;         // dest buffer
    DWORD           cBlks;          // number of blocks
    PROGRESS        Prg;            // progress update
    MMRESULT        mmr;            // MMSYSERR result
    HANDLE          hThread;        // private
} ConvertParam, *PConvertParam;

/*
 * */
DWORD ConvertThreadProc(LPVOID lpv)
{
    PConvertParam pcp = (PConvertParam)lpv;
    MMRESULT mmr;

    mmr = ConvertMultipleFormats(pcp->pwfxSrc
                                 , pcp->cbSrc
                                 , pcp->pbSrc
                                 , pcp->pwfxDst
                                 , pcp->pcbDst
                                 , pcp->ppbDst
                                 , pcp->cBlks
                                 , &pcp->Prg);

    pcp->mmr = mmr;
    PostMessage(pcp->Prg.hPrg, WM_CLOSE, 0, 0);
    
    return 0;   // end of thread! 
}

static BOOL gfCancel = FALSE;

/*
 * Progress_OnCommand
 * */
void Progress_OnCommand(
    HWND    hdlg,
    int     id,
    HWND    hctl,
    UINT    unotify)
{
    switch (id)
    {
        case IDCANCEL:
            gfCancel = TRUE;
            EndDialog(hdlg, FALSE);
            break;
            
        default:
            break;
    }
}

/*
 * Progress_Proc
 * */
INT_PTR CALLBACK
Progress_Proc(
    HWND        hdlg,
    UINT        umsg,
    WPARAM      wparam,
    LPARAM      lparam)
{
    switch (umsg)
    {
        case WM_INITDIALOG:
        {
            HANDLE          hThread;
            PConvertParam   pcp = (PConvertParam)(LPVOID)lparam;
            HWND            hprg;
            DWORD           thid;
            LPTSTR          lpsz;
            
            hprg = GetDlgItem(hdlg, IDC_PROGRESSBAR);
            
            SendMessage(hprg, PBM_SETRANGE, 0, MAKELONG(0, 100));
            SendMessage(hprg, PBM_SETPOS, 0, 0);

            SetProp(hdlg,  TEXT("DATA"), (HANDLE)pcp);
            pcp->Prg.hPrg    = hdlg;
            pcp->Prg.dwTotal = 100;
            gfCancel         = FALSE;
            
            lpsz = SoundRec_GetFormatName(pcp->pwfxSrc);
            if (lpsz)
            {
                SetDlgItemText(hdlg, IDC_CONVERT_FROM, lpsz);
                GlobalFreePtr(lpsz);
            }
            
            lpsz = SoundRec_GetFormatName(pcp->pwfxDst);
            if (lpsz)
            {
                SetDlgItemText(hdlg, IDC_CONVERT_TO, lpsz);
                GlobalFreePtr(lpsz);
            }
            
            hThread = CreateThread( NULL        // no special security 
                                    , 0           // default stack size 
                                    , (LPTHREAD_START_ROUTINE)ConvertThreadProc
                                    , (LPVOID)pcp
                                    , 0           // start running at once 
                                    , &thid );
    
            pcp->hThread = hThread;
            break;
        }
        
        case WM_COMMAND:
            HANDLE_WM_COMMAND(hdlg, wparam, lparam, Progress_OnCommand);
            break;
            
        case MYWM_CANCEL:
        {
            BOOL *pf = (BOOL *)wparam;
            if (pf)
                *pf = gfCancel;
            break;
        }

        case MYWM_PROGRESS:
        {
            HWND hprg = GetDlgItem(hdlg, IDC_PROGRESSBAR);
            SendMessage(hprg, PBM_SETPOS, wparam, 0);
            break;
        }

        case WM_DESTROY:
        {
            PConvertParam pcp = (ConvertParam *)GetProp(hdlg, TEXT("DATA"));
            if (pcp)
            {
                //
                // Make sure the thread exits
                //
                if (pcp->hThread)
                {
                    WaitForSingleObject(pcp->hThread, 1000);
                    CloseHandle(pcp->hThread);
                    pcp->hThread = NULL;
                }
                RemoveProp(hdlg, TEXT("DATA"));
            }
            break;
        }
            
        default:
            break;
    }
    return FALSE;
}

/* Generic single step conversion.
 */
MMRESULT
ConvertFormatDialog(
    HWND            hParent,
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg)           // progress update
{
    ConvertParam    cp;

    *pcbDst     = 0;
    *ppbDst     = NULL;
    
    if (cbSrc == 0)
        return MMSYSERR_NOERROR;
        
    cp.pwfxSrc  = pwfxSrc;
    cp.cbSrc    = cbSrc;
    cp.pbSrc    = pbSrc;
    cp.pwfxDst  = pwfxDst;
    cp.pcbDst   = pcbDst;
    cp.ppbDst   = ppbDst;
    cp.cBlks    = cBlks;
    cp.mmr      = MMSYSERR_ERROR;    // fail on abnormal thread termination!
    cp.hThread  = NULL;

    DialogBoxParam(ghInst
                 , MAKEINTRESOURCE(IDD_CONVERTING)
                 , hParent
                 , Progress_Proc
                 , (LPARAM)(LPVOID)&cp);
    return cp.mmr;
}

#if DBG
void DumpASH(
             MMRESULT mmr,
             ACMSTREAMHEADER *pash)
{
    TCHAR sz[256];

    wsprintf(sz,TEXT("mmr = %lx\r\n"), mmr);
    OutputDebugString(sz);

    wsprintf(sz,TEXT("pash is %s\r\n"),IsBadWritePtr(pash, pash->cbStruct)?TEXT("bad"):TEXT("good"));
    OutputDebugString(sz);

    OutputDebugString(TEXT("ACMSTREAMHEADER {\r\n"));
    wsprintf(sz,TEXT("ash.cbStruct       = %lx\r\n"),pash->cbStruct);
    OutputDebugString(sz);

    wsprintf(sz,TEXT("ash.fdwStatus      = %lx\r\n"),pash->fdwStatus);
    OutputDebugString(sz);

    wsprintf(sz,TEXT("ash.pbSrc          = %lx\r\n"),pash->pbSrc);
    OutputDebugString(sz);

    wsprintf(sz,TEXT("ash.cbSrcLength    = %lx\r\n"),pash->cbSrcLength);
    OutputDebugString(sz);
    
    wsprintf(sz,TEXT("pbSrc is %s\r\n"),IsBadWritePtr(pash->pbSrc, pash->cbSrcLength)?TEXT("bad"):TEXT("good"));
    OutputDebugString(sz);
    
    wsprintf(sz,TEXT("ash.cbSrcLengthUsed= %lx\r\n"),pash->cbSrcLengthUsed);
    OutputDebugString(sz);

    wsprintf(sz,TEXT("ash.pbDst          = %lx\r\n"),pash->pbDst);
    OutputDebugString(sz);
    
    wsprintf(sz,TEXT("ash.cbDstLength    = %lx\r\n"),pash->cbDstLength);
    OutputDebugString(sz);
    
    wsprintf(sz,TEXT("pbDst is %s\r\n"),IsBadWritePtr(pash->pbDst, pash->cbDstLength)?TEXT("bad"):TEXT("good"));
    OutputDebugString(sz);
    
    wsprintf(sz,TEXT("ash.cbDstLengthUsed= %lx\r\n"),pash->cbDstLengthUsed);
    OutputDebugString(sz);
    
    OutputDebugString(TEXT("} ACMSTREAMHEADER\r\n"));
    
    if (mmr != MMSYSERR_NOERROR)
        DebugBreak();
}

void DumpWFX(
             LPTSTR         psz,
             LPWAVEFORMATEX pwfx,
             LPBYTE         pbSamples,
             DWORD          cbSamples)
{
    TCHAR sz[256];
    
    if (psz)
    {
        OutputDebugString(psz);
        OutputDebugString(TEXT("\r\n"));
    }
    OutputDebugString(TEXT("WAVEFORMATEX {\r\n"));
    
    wsprintf(sz , TEXT("wfx.wFormatTag        = %x\r\n")
                , pwfx->wFormatTag);
    OutputDebugString(sz);

    wsprintf(sz , TEXT("wfx.nChannels         = %x\r\n")
                , pwfx->nChannels);
    OutputDebugString(sz);

    wsprintf(sz , TEXT("wfx.nSamplesPerSec    = %lx\r\n")
                , pwfx->nSamplesPerSec);
    OutputDebugString(sz);
    
    wsprintf(sz , TEXT("wfx.nAvgBytesPerSec   = %lx\r\n")
                , pwfx->nAvgBytesPerSec);
    OutputDebugString(sz);
    
    wsprintf(sz , TEXT("wfx.nBlockAlign       = %x\r\n")
                , pwfx->nBlockAlign);
    OutputDebugString(sz);

    wsprintf(sz , TEXT("wfx.wBitsPerSample    = %x\r\n")
                , pwfx->wBitsPerSample);
    OutputDebugString(sz);

    wsprintf(sz , TEXT("wfx.cbSize            = %x\r\n")
                , pwfx->cbSize);
    OutputDebugString(sz);
    OutputDebugString(TEXT("} WAVEFORMATEX\r\n"));

    wsprintf(sz , TEXT("cbSamples = %d, that's %d ms\r\n")
                , cbSamples
                , wfSamplesToTime(pwfx, wfBytesToSamples(pwfx, cbSamples)));
    OutputDebugString(sz);    
    if (IsBadReadPtr(pbSamples, cbSamples))
    {
        OutputDebugString(TEXT("Bad Data (READ)!!!!!\r\n"));
        DebugBreak();
    }
    if (IsBadWritePtr(pbSamples, cbSamples))
    {
        OutputDebugString(TEXT("Bad Data (WRITE)!!!!!\r\n"));
        DebugBreak();
    }

}
#else
#define DumpASH(x,y)
#define DumpWFX(x,y,z,a)
#endif

MMRESULT
ConvertMultipleFormats(
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg)           // progress update
{

    MMRESULT        mmr;
    WAVEFORMATEX    wfxPCM1, wfxPCM2;
    LPBYTE          pbPCM1, pbPCM2;
    DWORD           cbPCM1, cbPCM2;

    if (cbSrc == 0 || pbSrc == NULL)
    {
        pPrg->dwTotal       = 100;
        pPrg->dwComplete    = 100;
        
        ProgressUpdate(pPrg, 100);
        
        *pcbDst = 0;
        *ppbDst = NULL;
        
        return MMSYSERR_NOERROR;
    }
    
    //
    // Ask ACM to suggest a PCM format to convert to.
    //
    wfxPCM1.wFormatTag      = WAVE_FORMAT_PCM;
    mmr = acmFormatSuggest(NULL, pwfxSrc, &wfxPCM1, sizeof(WAVEFORMATEX),
                           ACM_FORMATSUGGESTF_WFORMATTAG);

    if (mmr != MMSYSERR_NOERROR)
        return mmr;

    //
    // Ask ACM to suggest a PCM format to convert from.
    // 
    wfxPCM2.wFormatTag      = WAVE_FORMAT_PCM;

    mmr = acmFormatSuggest(NULL, pwfxDst, &wfxPCM2, sizeof(WAVEFORMATEX),
                           ACM_FORMATSUGGESTF_WFORMATTAG);

    if (mmr != MMSYSERR_NOERROR)
        return mmr;

    //
    // if either of the above suggestions failed, we cannot complete the
    // conversion.
    //
    // now, we have the following steps to execute:
    //
    // *pwfxSrc -> wfxPCM1
    // wfxPCM1  -> wfxPCM2
    // wfxPCM2  -> *pwfxDst
    //
    // if either *pwfxSrc or *pwfxDst are PCM, we only need a two or one step
    // conversion.
    //
    
    if (pwfxSrc->wFormatTag == WAVE_FORMAT_PCM
        || pwfxDst->wFormatTag == WAVE_FORMAT_PCM)
    {

        LPWAVEFORMATEX pwfx;
        DWORD *        pcb;
        LPBYTE *       ppb;
        //
        // single step conversion
        //
        if ((pwfxSrc->wFormatTag == WAVE_FORMAT_PCM
             && pwfxDst->wFormatTag == WAVE_FORMAT_PCM)
            || (pwfxSrc->wFormatTag == WAVE_FORMAT_PCM
                && memcmp(pwfxSrc, &wfxPCM2, sizeof(PCMWAVEFORMAT)) == 0)
            || (pwfxDst->wFormatTag == WAVE_FORMAT_PCM
                && memcmp(pwfxDst, &wfxPCM1, sizeof(PCMWAVEFORMAT)) == 0))
        {
            pPrg->dwTotal       = 100;
            pPrg->dwComplete    = 0;
            mmr = ConvertFormat(pwfxSrc
                                , cbSrc
                                , pbSrc
                                , pwfxDst
                                , pcbDst
                                , ppbDst
                                , cBlks
                                , pPrg);
            return mmr;
        }
        
        //
        // two step conversion required
        //
        if (pwfxSrc->wFormatTag == WAVE_FORMAT_PCM)
        {
            pwfx = &wfxPCM2;
            pcb  = &cbPCM2;
            ppb  = &pbPCM2;
        }
        else
        {
            pwfx = &wfxPCM1;
            pcb  = &cbPCM1;
            ppb  = &pbPCM1;
        }
        pPrg->dwTotal       = 50;
        pPrg->dwComplete    = 0;

        mmr = ConvertFormat(pwfxSrc
                            , cbSrc
                            , pbSrc
                            , pwfx
                            , pcb
                            , ppb
                            , cBlks
                            , pPrg);

        if (mmr != MMSYSERR_NOERROR)
            return mmr;

        pPrg->dwTotal       = 50;
        pPrg->dwComplete    = 50;

        mmr = ConvertFormat(pwfx
                            , *pcb
                            , *ppb
                            , pwfxDst
                            , pcbDst
                            , ppbDst
                            , cBlks
                            , pPrg);

        GlobalFreePtr(*ppb);
        return mmr;
    }
    else
    {
        //
        // three step conversion required
        //
        pPrg->dwTotal       = 33;
        pPrg->dwComplete    = 1;

        //
        // Convert from Src to PCM1
        //
        mmr = ConvertFormat(pwfxSrc
                            , cbSrc
                            , pbSrc
                            , &wfxPCM1
                            , &cbPCM1
                            , &pbPCM1
                            , cBlks
                            , pPrg);
        if (mmr != MMSYSERR_NOERROR)
            return mmr;

        pPrg->dwTotal       = 33;
        pPrg->dwComplete    = 34;

        //
        // Convert from PCM1 to PCM2
        //
        mmr = ConvertFormat (&wfxPCM1
                             , cbPCM1
                             , pbPCM1
                             , &wfxPCM2
                             , &cbPCM2
                             , &pbPCM2
                             , cBlks
                             , pPrg);

        GlobalFreePtr(pbPCM1);

        if (mmr != MMSYSERR_NOERROR)
            return mmr;

        pPrg->dwTotal       = 33;
        pPrg->dwComplete    = 67;

        //
        // Convert from PCM2 to DST
        //
        mmr = ConvertFormat (&wfxPCM2
                             , cbPCM2
                             , pbPCM2
                             , pwfxDst
                             , pcbDst
                             , ppbDst
                             , cBlks
                             , pPrg);

        GlobalFreePtr(pbPCM2);
    }
    return mmr;
}

//
// add spilage to/from file i/o
//

/* Generic single step conversion.
 */
MMRESULT
ConvertFormat(
    PWAVEFORMATEX   pwfxSrc,        // pwfx specifying source format
    DWORD           cbSrc,          // size of the source buffer
    LPBYTE          pbSrc,          // source buffer
    PWAVEFORMATEX   pwfxDst,        // pwfx specifying dest format
    DWORD *         pcbDst,         // return size of the dest buffer
    LPBYTE *        ppbDst,         // dest buffer
    DWORD           cBlks,          // number of blocks
    PPROGRESS       pPrg)           // progress update
{
    HACMSTREAM      hasStream   = NULL;
    MMRESULT        mmr         = MMSYSERR_NOERROR;

    //
    // temporary copy buffers
    //
    DWORD           cbSrcBuf    = 0L;
    LPBYTE          pbSrcBuf    = NULL;

    DWORD           cbDstBuf    = 0L;
    LPBYTE          pbDstBuf    = NULL;

    //
    // full destination buffers
    //
    DWORD           cbDst       = 0L;
    LPBYTE          pbDst       = NULL;

    DWORD           cbSrcUsed   = 0L;
    DWORD           cbDstUsed   = 0L;

    DWORD           cbCopySrc   = 0L;
    DWORD           cbCopyDst   = 0L;    

    DWORD           cbRem;
    
    ACMSTREAMHEADER ash;
    WORD            nBlockAlign;
    
    gfBreakOfDeath = FALSE;
    
    DumpWFX(TEXT("ConvertFormat Input"), pwfxSrc, pbSrc, cbSrc);

    if (cbSrc == 0 || pbSrc == NULL)
    {
        pPrg->dwTotal       = 100;
        pPrg->dwComplete    = 100;
        
        ProgressUpdate(pPrg, 100);
        
        *pcbDst = 0;
        *ppbDst = NULL;
        
        return MMSYSERR_NOERROR;
    }
    
    //
    // synchronous conversion 
    //
    mmr = acmStreamOpen(&hasStream
                        , NULL
                        , pwfxSrc
                        , pwfxDst
                        , NULL        // no filter. maybe later
                        , 0L
                        , 0L
                        , ACM_STREAMOPENF_NONREALTIME );

    if (MMSYSERR_NOERROR != mmr)
    {
        return mmr;
    }

    //
    // How big of a destination buffer do we need?
    //
    // WARNING: acmStreamSize only gives us an estimation. if, in the event
    // it *underestimates* the destination buffer size we currently ignore
    // it, causing a clipping of the end buffer
    //
    mmr = acmStreamSize(hasStream
                        , cbSrc
                        , &cbDst
                        , ACM_STREAMSIZEF_SOURCE);
    
    if (MMSYSERR_NOERROR != mmr)
    {
        goto ExitCloseStream;
    }
    
    //
    // allocate the destination buffer 
    //
    pbDst = (LPBYTE)GlobalAllocPtr(GHND | GMEM_SHARE,cbDst);
    
    if (pbDst == NULL)
    {
        mmr = MMSYSERR_NOMEM;
        goto ExitCloseStream;
    }
    
    *ppbDst = pbDst;
    *pcbDst = cbDst;

    //
    // chop up the data into 10 bitesize pieces
    //
    nBlockAlign = pwfxSrc->nBlockAlign;
                 
    cbSrcBuf = cbSrc / 10;
    cbSrcBuf = cbSrcBuf - (cbSrcBuf % nBlockAlign);
    cbSrcBuf = ( 0L == cbSrcBuf ) ? nBlockAlign : cbSrcBuf;

    mmr = acmStreamSize(hasStream
                        , cbSrcBuf
                        , &cbDstBuf
                        , ACM_STREAMSIZEF_SOURCE);
    
    if (MMSYSERR_NOERROR != mmr)
        goto ExitFreeDestData;
    
    //
    // allocate source copy buffer 
    //
    pbSrcBuf = (LPBYTE)GlobalAllocPtr(GHND | GMEM_SHARE,cbSrcBuf);
    if (pbSrcBuf == NULL)
    {
        mmr = MMSYSERR_NOMEM;        
        goto ExitFreeDestData;
    }

    //
    // allocate destination copy buffer
    //
    pbDstBuf = (LPBYTE)GlobalAllocPtr(GHND | GMEM_SHARE,cbDstBuf);
    if (pbDstBuf == NULL)
    {
        mmr = MMSYSERR_NOMEM;
        GlobalFreePtr(pbSrcBuf);
        pbSrcBuf = NULL;
        goto ExitFreeDestData;
    }

    //
    // initialize the ash 
    //    
    ash.cbStruct        = sizeof(ash);
    ash.fdwStatus       = 0L;
    ash.pbSrc           = pbSrcBuf;
    ash.cbSrcLength     = cbSrcBuf;
    ash.cbSrcLengthUsed = 0L;
    ash.pbDst           = pbDstBuf;
    ash.cbDstLength     = cbDstBuf;
    ash.cbDstLengthUsed = 0L;

    //
    // we will only need to prepare once, since the buffers are
    // never moved.
    //
    mmr = acmStreamPrepareHeader(hasStream, &ash, 0L);
    if (MMSYSERR_NOERROR != mmr)
        goto ExitFreeTempBuffers;

    //
    // main blockalign conversion loop
    //
    while (cbSrcUsed < cbSrc)
    {
        cbCopySrc = min(cbSrcBuf, cbSrc - cbSrcUsed);
        if (cbCopySrc > 0L)
            memmove(pbSrcBuf, pbSrc, cbCopySrc);
        
#ifdef ACMBUG
//
// ACM has a bug wherein the destination buffer is validated for too
// much.  If we exactly calculate the cbCopyDst here, ACM is sure to
// puke on the conversion before the last.
//
        cbCopyDst = min(cbDstBuf, cbDst - cbDstUsed);
#else        
        cbCopyDst = cbDstBuf;
#endif
        if (cbCopyDst == 0L || cbCopyDst == 0L)
            break;
        
        ash.cbSrcLength     = cbCopySrc;
        ash.cbSrcLengthUsed = 0L;        
        ash.cbDstLength     = cbCopyDst;
        ash.cbDstLengthUsed = 0L;

        mmr = acmStreamConvert(hasStream
                               , &ash
                               , ACM_STREAMCONVERTF_BLOCKALIGN );
        
        if (MMSYSERR_NOERROR != mmr)
        {
            DumpASH(mmr, &ash);
            goto ExitUnprepareHeader;
        }

        //
        // Update the user and test for cancel
        //
        if (!ProgressUpdate(pPrg, (cbSrcUsed * 100)/cbSrc))
        {
            mmr = MMSYSERR_ERROR;
            goto ExitUnprepareHeader;
        }
        
        while (0 == (ACMSTREAMHEADER_STATUSF_DONE & ash.fdwStatus))
        {
            //
            // I don't trust an infinite loop.
            //
            if (gfBreakOfDeath)
            {
                mmr = MMSYSERR_HANDLEBUSY;  // Bad bad bad condition
                goto ExitUnprepareHeader;
            }
        }

        //
        // always increment.  we will have to carry over whatever the
        // last conversion gives us back since this determined by.
        //
        cbSrcUsed   += ash.cbSrcLengthUsed;
        pbSrc       += ash.cbSrcLengthUsed;

        //
        // loop terminating condition.  if the conversion yields no
        // destination data without error, we can only flush end data.
        //
        if (0L == ash.cbDstLengthUsed || cbDstUsed >= cbDst)
            break;

#ifdef ACMBUG            
        memmove(pbDst, pbDstBuf, ash.cbDstLengthUsed );
        cbDstUsed   += ash.cbDstLengthUsed;
        pbDst       += ash.cbDstLengthUsed;
#else
        cbRem = min(ash.cbDstLengthUsed, cbDst - cbDstUsed);
        memmove(pbDst, pbDstBuf, cbRem);
            
        cbDstUsed   += cbRem;
        pbDst       += cbRem;
#endif        
    }

    //
    // Flush remaining block-aligned end data to the destination stream.
    // Example: A few bytes of source data were left unconverted because
    // for some reason, the last 
    //
 
    for (;cbDst - cbDstUsed > 0; )
    {
        cbCopySrc = min(cbSrcBuf, cbSrc - cbSrcUsed);
        if (cbCopySrc > 0L)
            memmove(pbSrcBuf, pbSrc, cbCopySrc);

#ifdef ACMBUG
        cbCopyDst = min(cbDstBuf, cbDst - cbDstUsed);
#else        
        cbCopyDst = cbDstBuf;
#endif        
        
        ash.cbSrcLength     = cbCopySrc;
        ash.cbSrcLengthUsed = 0L;
        ash.cbDstLength     = cbCopyDst;
        ash.cbDstLengthUsed = 0L;
        
        mmr = acmStreamConvert(hasStream
                               , &ash
                               , ACM_STREAMCONVERTF_BLOCKALIGN |
                                 ACM_STREAMCONVERTF_END );
        
        if (MMSYSERR_NOERROR != mmr)
        {
            DumpASH(mmr, &ash);
            goto ExitUnprepareHeader;
        }

        //
        // Update the user and test for cancel
        //
        if (!ProgressUpdate(pPrg, (cbSrcUsed * 100)/cbSrc))
        {
            mmr = MMSYSERR_ERROR;
            goto ExitUnprepareHeader;
        }
        
        while (0 == (ACMSTREAMHEADER_STATUSF_DONE & ash.fdwStatus))
        {
            //
            // I don't trust an infinite loop.
            //
            if (gfBreakOfDeath)
            {
                mmr = MMSYSERR_HANDLEBUSY;  // Bad bad bad condition
                goto ExitUnprepareHeader;
            }
        }
        cbSrcUsed   += ash.cbSrcLengthUsed;
        pbSrc       += ash.cbSrcLengthUsed;

        if (0L != ash.cbDstLengthUsed && cbDstUsed < cbDst)
        {
#ifdef ACMBUG            
            memmove(pbDst, pbDstBuf, ash.cbDstLengthUsed);
        
            cbDstUsed   += ash.cbDstLengthUsed;
            pbDst       += ash.cbDstLengthUsed;
#else            
            cbRem = min(ash.cbDstLengthUsed, cbDst - cbDstUsed);
            memmove(pbDst, pbDstBuf, cbRem);
            cbDstUsed   += cbRem;
            pbDst       += cbRem;
#endif            
        }

        //
        // Last pass non-blockaligned end data 
        //
        cbCopySrc = min(cbSrcBuf, cbSrc - cbSrcUsed);
        if (cbCopySrc > 0L)
            memmove(pbSrcBuf, pbSrc, cbCopySrc);

#ifdef ACMBUG
        cbCopyDst = min(cbDstBuf, cbDst - cbDstUsed);
        if (0L == cbCopyDst)
            break;
#else        
        cbCopyDst = cbDstBuf;
#endif        

        ash.cbSrcLength     = cbCopySrc;
        ash.cbSrcLengthUsed = 0L;
        ash.cbDstLength     = cbCopyDst;        
        ash.cbDstLengthUsed = 0L;
        
        mmr = acmStreamConvert(hasStream
                               , &ash
                               , ACM_STREAMCONVERTF_END );

        if (MMSYSERR_NOERROR != mmr)
        {
            DumpASH(mmr, &ash);
            goto ExitUnprepareHeader;
        }

        //
        // Update the user and test for cancel 
        //
        if (!ProgressUpdate(pPrg, (cbSrcUsed * 100)/cbSrc))
        {
            mmr = MMSYSERR_ERROR;
            goto ExitUnprepareHeader;
        }
        
        while (0 == (ACMSTREAMHEADER_STATUSF_DONE & ash.fdwStatus))
        {
            //
            // I don't trust an infinite loop.
            //
            if (gfBreakOfDeath)
            {
                mmr = MMSYSERR_HANDLEBUSY;  // Bad bad bad condition
                goto ExitUnprepareHeader;
            }
        }

        cbSrcUsed   += ash.cbSrcLengthUsed;
        pbSrc       += ash.cbSrcLengthUsed;

        if (0L != ash.cbDstLengthUsed && cbDstUsed < cbDst)
        {
#ifdef ACMBUG
            memmove(pbDst, pbDstBuf, ash.cbDstLengthUsed);
        
            cbDstUsed   += ash.cbDstLengthUsed;
            pbDst       += ash.cbDstLengthUsed;
#else            
            cbRem = min(ash.cbDstLengthUsed, cbDst - cbDstUsed);
            memmove(pbDst, pbDstBuf, cbRem);
            cbDstUsed   += cbRem;
            pbDst       += cbRem;
#endif            
        }
        else // nothing's going to work 
            break;
    }
    
    *pcbDst = cbDstUsed;
    DumpWFX(TEXT("ConvertFormat Output"), pwfxDst, *ppbDst, cbDstUsed);
            
ExitUnprepareHeader:    
    acmStreamUnprepareHeader(hasStream, &ash, 0L);

ExitFreeTempBuffers:
    GlobalFreePtr(pbDstBuf);
    GlobalFreePtr(pbSrcBuf);    
    
    if (MMSYSERR_NOERROR == mmr)
        goto ExitCloseStream;

ExitFreeDestData:
    GlobalFreePtr(*ppbDst);
    *ppbDst = NULL;
    *pcbDst = 0L;

ExitCloseStream:
    acmStreamClose(hasStream,0L);
    
    return mmr;
}

/*      -       -       -       -       -       -       -       -       -   */
void Properties_InitDocVars(
    HWND        hwnd,
    PWAVEDOC    pwd)
{
    if (pwd->pwfx)
    {
        LPTSTR  lpstr;
        TCHAR   sz[128];
        TCHAR   szFmt[128];        
        LONG    lTime;
        HINSTANCE hinst;
        
        lpstr = SoundRec_GetFormatName(pwd->pwfx);
        if (lpstr)
        {
            SetDlgItemText(hwnd, IDC_AUDIOFORMAT, lpstr);
            GlobalFreePtr(lpstr);
        }
        lTime = wfSamplesToTime(pwd->pwfx,wfBytesToSamples(pwd->pwfx,pwd->cbdata));
        if (gfLZero || ((int)(lTime/1000) != 0))
            wsprintf(sz, aszPositionFormat, (int)(lTime/1000), chDecimal,
                     (int)((lTime/10)%100));
        else
            wsprintf(sz, aszNoZeroPositionFormat, chDecimal,
                     (int)((lTime/10)%100));
        SetDlgItemText(hwnd, IDC_FILELEN, sz);

        hinst = GetWindowInstance(hwnd);
        if (hinst && LoadString(hinst, IDS_DATASIZE, szFmt, SIZEOF(szFmt)))
        {
            wsprintf(sz, szFmt, pwd->cbdata);
            SetDlgItemText(hwnd, IDC_DATASIZE, sz);
        }
    }
}
/*
 * */
BOOL Properties_OnInitDialog(
    HWND        hwnd,
    HWND        hwndFocus,
    LPARAM      lParam)
{
    HINSTANCE   hinst;
    HWND        hChoice;
    TCHAR       sz[256];
    int         i;
    
    //
    // commence initialization
    //
    PWAVEDOC pwd = (PWAVEDOC)((LPPROPSHEETPAGE)lParam)->lParam;
    if (pwd == NULL)
    {
        EndDialog(hwnd, FALSE);
        return FALSE;
    }
    
    SetProp(hwnd,  TEXT("DATA"), (HANDLE)pwd);
    hinst = GetWindowInstance(hwnd);
    
    //
    // Set "static" property information
    //
    if (pwd->pszFileName)
        SetDlgItemText(hwnd, IDC_FILENAME, pwd->pszFileName);
    if (pwd->pszCopyright)
        SetDlgItemText(hwnd, IDC_COPYRIGHT, pwd->pszCopyright);
    else if (LoadString(hinst, IDS_NOCOPYRIGHT, sz, SIZEOF(sz)))
    {
        SetDlgItemText(hwnd, IDC_COPYRIGHT, sz);
    }
    if (pwd->hIcon)
        Static_SetIcon(GetDlgItem(hwnd, IDC_DISPICON), pwd->hIcon);

    //
    // Set "volatile" property information
    //
    Properties_InitDocVars(hwnd, pwd);

    //
    // Initialize the enumeration choice combobox
    //
    hChoice = GetDlgItem(hwnd, IDC_CONVERTCHOOSEFROM);
    if (waveOutGetNumDevs())
    {
        if (LoadString(hinst, IDS_SHOWPLAYABLE, sz, SIZEOF(sz)))
        {
            i = ComboBox_AddString(hChoice, sz);
            ComboBox_SetItemData(hChoice, i, ACM_FORMATENUMF_OUTPUT);
        }
    }
    if (waveInGetNumDevs())
    {
        if (LoadString(hinst, IDS_SHOWRECORDABLE, sz, SIZEOF(sz)))
        {
            i = ComboBox_AddString(hChoice, sz);
            ComboBox_SetItemData(hChoice, i, ACM_FORMATENUMF_INPUT);
        }
    }
    if (LoadString(hinst, IDS_SHOWALL, sz, SIZEOF(sz)))
    {
        i = ComboBox_AddString(hChoice, sz);
        ComboBox_SetItemData(hChoice, i, 0L);
    }
    ComboBox_SetCurSel(hChoice, i);
    
    return FALSE;
}

/*
 * */
void Properties_OnDestroy(
    HWND        hwnd)
{
    //
    // commence cleanup
    //
    PWAVEDOC pwd = (PWAVEDOC)GetProp(hwnd, TEXT("DATA"));
    if (pwd)
    {
        RemoveProp(hwnd, TEXT("DATA"));
    }
}


/*
 * */
BOOL PASCAL Properties_OnCommand(
    HWND        hwnd,
    int         id,
    HWND        hwndCtl,
    UINT        codeNotify)
{
    switch (id)
    {
        case ID_APPLY:
            return TRUE;
            
        case IDOK:
            break;

        case IDCANCEL:
            break;

        case ID_INIT:		
            break;

        case IDC_CONVERTTO:
        {
            PWAVEDOC pwd = (PWAVEDOC)GetProp(hwnd, TEXT("DATA"));
            PWAVEFORMATEX pwfxNew = NULL;
            DWORD fdwEnum = 0L;
            int i;
            HWND hChoice;

            hChoice = GetDlgItem(hwnd, IDC_CONVERTCHOOSEFROM);
            i = ComboBox_GetCurSel(hChoice);
            fdwEnum = (DWORD)ComboBox_GetItemData(hChoice, i);
            
            if (ChooseDestinationFormat(ghInst
                                        ,hwnd
                                        ,NULL
                                        ,&pwfxNew
                                        ,fdwEnum) == MMSYSERR_NOERROR)
            {
                DWORD   cbNew;
                LPBYTE  pbNew;
                DWORD   cbSize = (pwfxNew->wFormatTag == WAVE_FORMAT_PCM)?
                                 sizeof(PCMWAVEFORMAT):
                                 sizeof(WAVEFORMATEX)+pwfxNew->cbSize;
                
                if (memcmp(pwfxNew, pwd->pwfx, cbSize) == 0)
                    break;
                StopWave();
                BeginWaveEdit();
                if (ConvertFormatDialog(hwnd
                                        , pwd->pwfx
                                        , pwd->cbdata
                                        , pwd->pbdata
                                        , pwfxNew
                                        , &cbNew
                                        , &pbNew
                                        , 0
                                        , NULL) == MMSYSERR_NOERROR)
                {
                    GlobalFreePtr(pwd->pwfx);
                    if (pwd->pbdata)
                        GlobalFreePtr(pwd->pbdata);
                    
                    pwd->pwfx   = pwfxNew;
                    pwd->cbdata = cbNew;
                    pwd->pbdata = pbNew;
                    pwd->fChanged = TRUE;

                    if (pwd->lpv)
                    {
                        PSGLOBALS psg = (PSGLOBALS)pwd->lpv;
                        *psg->ppwfx     = pwfxNew;
                        *psg->pcbwfx    = sizeof(WAVEFORMATEX);
                        if (pwfxNew->wFormatTag != WAVE_FORMAT_PCM)
                            *psg->pcbwfx += pwfxNew->cbSize;

                        *psg->pcbdata   = cbNew;
                        *psg->ppbdata    = pwd->pbdata;
                        *psg->plSamples = wfBytesToSamples(pwfxNew, cbNew);
                        *psg->plSamplesValid    = *psg->plSamples;
                        *psg->plWavePosition = 0;
                        UpdateDisplay(TRUE);
                        Properties_InitDocVars(hwnd, pwd);
                    }
                    EndWaveEdit(TRUE);
                }
                else
                    EndWaveEdit(FALSE);
                
            }
            return TRUE;
        }
    }
    return FALSE;
}


/*
 * Properties_Proc
 */
INT_PTR CALLBACK
Properties_Proc(
    HWND        hdlg,
    UINT        umsg,
    WPARAM      wparam,
    LPARAM      lparam)
{
#ifdef CHICAGO
    static const DWORD aHelpIds[] = {
        IDC_DISPICON,           IDH_SOUNDREC_ICON,
        IDC_FILENAME,           IDH_SOUNDREC_SNDTITLE,
        IDC_TXT_COPYRIGHT,      IDH_SOUNDREC_COPYRIGHT,    
        IDC_COPYRIGHT,          IDH_SOUNDREC_COPYRIGHT,
        IDC_TXT_FILELEN,        IDH_SOUNDREC_LENGTH,
        IDC_FILELEN,            IDH_SOUNDREC_LENGTH,
        IDC_TXT_DATASIZE,       IDH_SOUNDREC_SIZE,
        IDC_DATASIZE,           IDH_SOUNDREC_SIZE,
        IDC_TXT_AUDIOFORMAT,    IDH_SOUNDREC_AUDIO,
        IDC_AUDIOFORMAT,        IDH_SOUNDREC_AUDIO,
        IDC_CONVGROUP,          IDH_SOUNDREC_COMM_GROUPBOX,
        IDC_CONVERTCHOOSEFROM,  IDH_SOUNDREC_CONVERT,
        IDC_CONVERTTO,          IDH_SOUNDREC_FORMAT,
        0,                      0
    };
#endif

    switch (umsg)
    {
        
#ifdef CHICAGO
        case WM_CONTEXTMENU:        
            WinHelp((HWND)wparam, gachHelpFile, HELP_CONTEXTMENU, 
                (UINT_PTR)(LPSTR)aHelpIds);
            return TRUE;
        
        case WM_HELP:
        {
            LPHELPINFO lphi = (LPVOID) lparam;
            WinHelp (lphi->hItemHandle, gachHelpFile, HELP_WM_HELP,
                    (UINT_PTR) (LPSTR) aHelpIds);
            return TRUE;
        }
#endif            
        case WM_INITDIALOG:
            return HANDLE_WM_INITDIALOG(hdlg, wparam, lparam, Properties_OnInitDialog);
            
        case WM_DESTROY:
            HANDLE_WM_DESTROY(hdlg, wparam, lparam, Properties_OnDestroy);
            break;
            
        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR FAR *)lparam;
            switch(lpnm->code)
            {
                case PSN_KILLACTIVE:
                    FORWARD_WM_COMMAND(hdlg, IDOK, 0, 0, SendMessage);
                    break;
                    
                case PSN_APPLY:
                    FORWARD_WM_COMMAND(hdlg, ID_APPLY, 0, 0, SendMessage);	
                    break;              					

                case PSN_SETACTIVE:
                    FORWARD_WM_COMMAND(hdlg, ID_INIT, 0, 0, SendMessage);
                    break;

                case PSN_RESET:
                    FORWARD_WM_COMMAND(hdlg, IDCANCEL, 0, 0, SendMessage);
                    break;
            }
            break;
        }
        case WM_COMMAND:
            return HANDLE_WM_COMMAND(hdlg, wparam, lparam, Properties_OnCommand);
        default:
        {
#ifdef CHICAGO            
            extern DWORD aChooserHelpIds[];
            extern UINT  guChooserContextMenu;
            extern UINT  guChooserContextHelp;            
            //
            //  Handle context-sensitive help messages from acm dialog
            //
            if( umsg == guChooserContextMenu )
            {
                WinHelp( (HWND)wparam, NULL, HELP_CONTEXTMENU, 
                           (UINT_PTR)(LPSTR)aChooserHelpIds );
            }
            else if( umsg == guChooserContextHelp )
            {
                WinHelp( ((LPHELPINFO)lparam)->hItemHandle, NULL,
                        HELP_WM_HELP, (UINT_PTR)(LPSTR)aChooserHelpIds );
            }
#endif            
            break;            
        }

    }
    return FALSE;
}



/*
 * Wave document property sheet.
 * */
BOOL
SoundRec_Properties(
    HWND            hwnd,
    HINSTANCE       hinst,
    PWAVEDOC        pwd)
{
    PROPSHEETPAGE   psp;
    PROPSHEETHEADER psh;
    TCHAR szCaption[256], szCapFmt[64];
    
    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_DEFAULT;// | PSP_USETITLE;
    psp.hInstance   = hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPERTIES);
    psp.pszIcon     = NULL;
    psp.pszTitle    = NULL; 
    psp.pfnDlgProc  = Properties_Proc;
    psp.lParam      = (LPARAM)(LPVOID)pwd;
    psp.pfnCallback = NULL;
    psp.pcRefParent = NULL;

    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_NOAPPLYNOW|PSH_PROPSHEETPAGE ;
    psh.hwndParent  = hwnd;
    psh.hInstance   = hinst;
    psh.pszIcon     = NULL;

    if (LoadString(hinst, IDS_PROPERTIES, szCapFmt, SIZEOF(szCapFmt)))
    {
        wsprintf(szCaption, szCapFmt, pwd->pszFileName);
        psh.pszCaption = szCaption;
    }
    else
        psh.pszCaption = NULL;
    
    psh.nPages      = 1;
    psh.nStartPage  = 0;
    psh.ppsp        = &psp;
    psh.pfnCallback = NULL;

    PropertySheet(&psh);
    
    return FALSE;   // nothing changed?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\file.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* file.c
 *
 * File I/O and related functions.
 *
 * Revision history:
 *  4/2/91      LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 *  5/27/92     -jyg- Added more RIFF support to BOMBAY version
 *  22/Feb/94   LaurieGr merged Motown and Daytona version
 */

#include "nocrap.h"
#include <windows.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <windowsx.h>

#define INCLUDE_OLESTUBS
#include "SoundRec.h"
#include "srecids.h"

#ifdef CHICAGO
# if WINVER >= 0x0400
#  include <shellapi.h>
# else
#  include <shell2.h>
# endif
#endif

#include "file.h"
#include "convert.h"
#include "reg.h"

/* globals */
PCKNODE gpcknHead = NULL;   // ??? eugh. more globals!
PCKNODE gpcknTail = NULL;

static PFACT spFact = NULL;
static long scbFact = 0;

static void FreeAllChunks(PCKNODE *ppcknHead, PCKNODE *ppcknTail);
static BOOL AddChunk(LPMMCKINFO lpCk, HPBYTE hb, PCKNODE * ppcknHead,
    PCKNODE * ppcknTail);
static PCKNODE FreeHeadChunk(PCKNODE *ppcknHead);


/*
 * Is the current document untitled?
 */
BOOL IsDocUntitled()
{
    return (lstrcmp(gachFileName, aszUntitled) == 0);
}

/*
 * Rename the current document.
 */
void RenameDoc(LPTSTR aszNewFile)
{
    lstrcpy(gachFileName, aszNewFile);
    lstrcpy(gachLinkFilename, gachFileName);
    if (gfLinked)
        AdviseRename(gachLinkFilename);
}
    
/* MarkWaveDirty: Mark the wave as dirty. */
void FAR PASCAL
EndWaveEdit(BOOL fDirty)
{
    if (fDirty)
    {
        gfDirty = TRUE;
        AdviseDataChange();
        
        DoOleSave();
        AdviseSaved();
    }
}

void FAR PASCAL
BeginWaveEdit(void)
{
    FlushOleClipboard();
}

/* fOK = PromptToSave()
 *
 * If the file is dirty (modified), ask the user "Save before closing?".
 * Return TRUE if it's okay to continue, FALSE if the caller should cancel
 * whatever it's doing.
 */
PROMPTRESULT FAR PASCAL
PromptToSave(
    BOOL        fMustClose,
    BOOL        fSetForground)
{
    WORD        wID;
    DWORD       dwMB = MB_ICONEXCLAMATION | MB_YESNOCANCEL;

    if (fSetForground)
        dwMB |= MB_SETFOREGROUND;

    /* stop playing/recording */
    StopWave();


    if (gfDirty && gfStandalone && gfDirty != -1) {   // changed and possible to save
        wID = ErrorResBox( ghwndApp
                         , ghInst
                         , dwMB
                         , IDS_APPTITLE
                         , IDS_SAVECHANGES
                         , (LPTSTR) gachFileName
                         );
        if (wID == IDCANCEL)
        {
            return enumCancel;
        }
        else if (wID == IDYES)
        {
            if (!FileSave(FALSE))
                return enumCancel;
        }
        else
            return enumRevert;
        
    }

#if 0
// is this necessary?
    
// This is bad.  It notifies the container before we actually
// DoOleClose.  This will cause some containers (Excel 5.0c) to
// get confused and nuke client sites on non-dirty objects.
                
    else if (fMustClose)
    {
        DebugBreak();
        AdviseClosed();
    }
#endif
    return enumSaved;
} /* PromptToSave */


/* fOK = CheckIfFileExists(szFileName)
 *
 * The user specified <szFileName> as a file to write over -- check if
 * this file exists.  Return TRUE if it's okay to continue (i.e. the
 * file doesn't exist, or the user OK'd overwriting it),
 * FALSE if the caller should cancel whatever it's doing.
 */
static BOOL NEAR PASCAL
CheckIfFileExists( LPTSTR       szFileName)     // file name to check
{
    HANDLE hFile;
    hFile = CreateFile(szFileName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
    if (hFile == INVALID_HANDLE_VALUE)
            return TRUE;        // doesn't exist
    CloseHandle(hFile);
            
    /* prompt user for permission to overwrite the file */
    return ErrorResBox(ghwndApp, ghInst, MB_ICONQUESTION | MB_OKCANCEL,
             IDS_APPTITLE, IDS_FILEEXISTS, szFileName) == IDOK;
}

#define SLASH(c)     ((c) == TEXT('/') || (c) == TEXT('\\'))


/* return a pointer to the filename part of the path
   i.e. scan back from end to \: or start
   e.g. "C:\FOO\BAR.XYZ"  -> return pointer to "BAR.XYZ"
*/
LPCTSTR FAR PASCAL
FileName(LPCTSTR szPath)
{
    LPCTSTR   sz;
    if (!szPath)
        return NULL;
    for (sz=szPath; *sz; sz = CharNext(sz))
        ;
    for (; !SLASH(*sz) && *sz!=TEXT(':'); sz = CharPrev(szPath,sz))
        if (sz == szPath)
            return sz;
    
    return CharNext(sz);
}



/* UpdateCaption()
 *
 * Set the caption of the app window.
 */
void FAR PASCAL
UpdateCaption(void)
{
    TCHAR    ach[_MAX_PATH + _MAX_FNAME + _MAX_EXT - 2];
    static SZCODE aszTitleFormat[] = TEXT("%s - %s");
#ifdef CHICAGO
    SHFILEINFO shfi;
        
    if (!IsDocUntitled() && SHGetFileInfo(gachFileName, 0, &shfi, sizeof(shfi), SHGFI_ICON|SHGFI_DISPLAYNAME ))
    {
        wsprintf(ach, aszTitleFormat, shfi.szDisplayName, (LPTSTR)gachAppTitle);
        SetWindowText(ghwndApp, ach);
        SetClassLongPtr(ghwndApp, GCLP_HICON, (DWORD_PTR)shfi.hIcon);
        return;
    }
    else
    {
        //
        // reset icon to app icon
        //
        extern HICON ghiconApp;
        SetClassLongPtr(ghwndApp, GCLP_HICON, (LONG_PTR)ghiconApp);
    }
#endif
    wsprintf(ach, aszTitleFormat, FileName(gachFileName), (LPTSTR)gachAppTitle);
    SetWindowText(ghwndApp, ach);

} /* UpdateCaption */

//REVIEW:  The functionality in FileOpen and FileNew should be more
//         safe for OLE.  This means, we want to open a file, but
//         have no reason to revoke the server.


/* FileNew(fmt, fUpdateDisplay, fNewDlg)
 *
 * Make a blank document.
 *
 * If <fUpdateDisplay> is TRUE, then update the display after creating a new file.
 */
BOOL FAR PASCAL FileNew(
    WORD    fmt,
    BOOL    fUpdateDisplay,
    BOOL    fNewDlg)
{
    //
    // avoid reentrancy when called through OLE
    //

    // ??? Need to double check on this.  Is this thread safe?
    // ??? Does it need to be thread safe?  Or are we actually
    // ??? just trying to avoid recursion rather than reentrancy?

    if (gfInFileNew)
        return FALSE;

    //
    // stop playing/recording
    //
    StopWave();

    //
    // Commit all pending objects.
    //
    FlushOleClipboard();

    //
    //  some client's (ie Excel 3.00 and PowerPoint 1.0) don't
    //  handle saved notifications, they expect to get a
    //  OLE_CLOSED message.
    //
    //  if the user has chosen to update the object, but the client did
    //  not then send a OLE_CLOSED message.
    //
    if (gfEmbeddedObject && gfDirty == -1)
        AdviseClosed();

    //  
    // FileNew can be called either from FileOpen or from a menu
    // or from the server, etc...  We should behave as FileOpen from the
    // server (i.e. the dialog can be canceled without toasting the buffer)
    //
    if (!NewWave(fmt,fNewDlg))
        return FALSE;

    //        
    // update state variables
    //
    lstrcpy(gachFileName, aszUntitled);
    BuildUniqueLinkName();
    
    gfDirty = FALSE;                        // file was modified and not saved?

    if (fUpdateDisplay) {
        UpdateCaption();
        UpdateDisplay(TRUE);
    }

    FreeAllChunks(&gpcknHead, &gpcknTail);    // free all old info

    return TRUE;
} /* FileNew */


/* REVIEW:  The functionality in FileOpen and FileNew should be more
 *          safe for OLE.  This means, we want to open a file, but
 *          have no reason to revoke the server.
 * */

BOOL FileLoad(
    LPCTSTR     szFileName)
{
    TCHAR       aszFile[_MAX_PATH];
    HCURSOR     hcurPrev = NULL; // cursor before hourglass
    HMMIO       hmmio;
    BOOL        fOk = TRUE;
    
    StopWave();

    // qualify 
    GetFullPathName(szFileName,SIZEOF(aszFile),aszFile,NULL);
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    // read the WAVE file
    hmmio = mmioOpen(aszFile, NULL, MMIO_READ | MMIO_ALLOCBUF);
    
    if (hmmio != NULL)
    {
        MMRESULT        mmr;
        LPWAVEFORMATEX  pwfx;
        DWORD           cbwfx;
        DWORD           cbdata;
        LPBYTE          pdata;

        PCKNODE         pcknHead = gpcknHead;
        PCKNODE         pcknTail = gpcknTail;
        PFACT           pfct = spFact;
        LONG            cbfact = scbFact;
                
        gpcknHead       = NULL;
        gpcknTail       = NULL;
        spFact          = NULL;
        scbFact         = 0L;
                
        mmr = ReadWaveFile(hmmio
                           , &pwfx
                           , &cbwfx
                           , &pdata
                           , &cbdata
                           , aszFile
                           , TRUE);
        
        mmioClose(hmmio, 0);

        if (mmr != MMSYSERR_NOERROR || pwfx == NULL)
        {
            //
            // restore the cache globals
            //
            gpcknHead = pcknHead;
            gpcknTail = pcknTail;
            spFact = pfct;
            scbFact = cbfact;
            
            if (pwfx == NULL)
            {
                if (pdata)
                    GlobalFreePtr(pdata);
            }
            goto RETURN_ERROR;
        }
        
        DestroyWave();
        
        gpWaveFormat = pwfx;  
        gcbWaveFormat = cbwfx;
        gpWaveSamples = pdata;
        glWaveSamples = cbdata;

        //
        // destroy the cache temps
        //
        FreeAllChunks(&pcknHead, &pcknTail);
        if (pfct)
            GlobalFreePtr((LPVOID)pfct);
        
    }
    else
    {
        ErrorResBox(ghwndApp
                    , ghInst
                    , MB_ICONEXCLAMATION | MB_OK
                    , IDS_APPTITLE
                    , IDS_ERROROPEN
                    , (LPTSTR) aszFile);
        
        goto RETURN_ERROR;
    }

    //
    // update state variables
    //
    RenameDoc(aszFile);
    
    glWaveSamplesValid = glWaveSamples;
    glWavePosition = 0L;
    
    goto RETURN_SUCCESS;
    
RETURN_ERROR:
    fOk = FALSE;
#if 0    
    FreeAllChunks(&gpcknHead, &gpcknTail);     /* free all old info */
#endif
    
RETURN_SUCCESS:

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* Only mark clean on success */
    if (fOk)
        gfDirty = FALSE;

    /* update the display */
    UpdateCaption();
    UpdateDisplay(TRUE);

    return fOk;
}

/* FileOpen(szFileName)
 *
 * If <szFileName> is NULL, do a File/Open command.  Otherwise, open
 * <szFileName>.  Return TRUE on success, FALSE otherwise.
 */
BOOL FAR PASCAL
FileOpen(
    LPCTSTR     szFileName) // file to open (or NULL)
{
    TCHAR       ach[80];    // buffer for string loading
    TCHAR       aszFile[_MAX_PATH];
    HCURSOR     hcurPrev = NULL; // cursor before hourglass
    HMMIO       hmmio;
    BOOL        fOk = TRUE;

    //
    // stop playing/recording
    //
    StopWave();

    //
    // Commit all pending objects.
    //
    FlushOleClipboard();

    if (!PromptToSave(FALSE, FALSE))
        goto RETURN_ERRORNONEW;

    //
    // get the new file name into <ofs.szPathName>
    //
    if (szFileName == NULL)
    {
        OPENFILENAME    ofn;
        BOOL f;

        //
        // prompt user for file to open
        //
        LoadString(ghInst, IDS_OPEN, ach, SIZEOF(ach));
        aszFile[0] = 0;
        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = ghwndApp;
        ofn.hInstance       = NULL;
        ofn.lpstrFilter     = aszFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter  = 0;
        ofn.nFilterIndex    = 1;
        ofn.lpstrFile       = aszFile;
        ofn.nMaxFile        = SIZEOF(aszFile);
        ofn.lpstrFileTitle  = NULL;
        ofn.nMaxFileTitle   = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle      = ach;
        ofn.Flags           =   OFN_FILEMUSTEXIST
                              | OFN_PATHMUSTEXIST
#ifdef CHICAGO
                              | OFN_EXPLORER
#endif                                
                              | OFN_HIDEREADONLY;
        ofn.lpfnHook        = NULL;
        ofn.nFileOffset     = 0;
        ofn.nFileExtension  = 0;
        ofn.lpstrDefExt     = gachDefFileExt;
        ofn.lCustData       = 0;
        ofn.lpTemplateName  = NULL;
        f = GetOpenFileName(&ofn);

        if (!f)
            goto RETURN_ERRORNONEW;
    }
    else
    {

        GetFullPathName(szFileName,SIZEOF(aszFile),aszFile,NULL);
    }

    UpdateWindow(ghwndApp);

    //
    // show hourglass cursor
    //
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    // read the WAVE file
    //
    hmmio = mmioOpen(aszFile, NULL, MMIO_READ | MMIO_ALLOCBUF);
    if (hmmio != NULL)
    {
        MMRESULT        mmr;
        LPWAVEFORMATEX  pwfx;
        DWORD           cbwfx;
        DWORD           cbdata;
        LPBYTE          pdata;

        PCKNODE         pcknHead = gpcknHead;
        PCKNODE         pcknTail = gpcknTail;
        PFACT           pfct = spFact;
        LONG            cbfact = scbFact;
                
        gpcknHead       = NULL;
        gpcknTail       = NULL;
        spFact          = NULL;
        scbFact         = 0L;
        
        mmr = ReadWaveFile(hmmio
                           , &pwfx
                           , &cbwfx
                           , &pdata
                           , &cbdata
                           , aszFile
                           , TRUE);
        
        mmioClose(hmmio, 0);

        if (mmr != MMSYSERR_NOERROR || pwfx == NULL)
        {
            //
            // restore the cache globals
            //
            gpcknHead = pcknHead;
            gpcknTail = pcknTail;
            spFact = pfct;
            scbFact = cbfact;
            
            if (pwfx == NULL)
            {
                if (pdata)
                    GlobalFreePtr(pdata);
            }
            goto RETURN_ERRORNONEW;
        }

        DestroyWave();
        
        gpWaveFormat = pwfx;  
        gcbWaveFormat = cbwfx;
        gpWaveSamples = pdata;
        glWaveSamples = cbdata;

        //
        // destroy the cache temps
        //
        FreeAllChunks(&pcknHead, &pcknTail);
        if (pfct)
            GlobalFreePtr((LPVOID)pfct);
    }
    else
    {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
            IDS_APPTITLE, IDS_ERROROPEN, (LPTSTR) aszFile);
        goto RETURN_ERRORNONEW;
    }

    //
    // update state variables
    //
    RenameDoc(aszFile);
    glWaveSamplesValid = glWaveSamples;
    glWavePosition = 0L;

    goto RETURN_SUCCESS;

#if 0    
RETURN_ERROR:               // do error exit without error message

    FileNew(FMT_DEFAULT, FALSE, FALSE);// revert to "(Untitled)" state

    /* fall through */
#endif
RETURN_ERRORNONEW:          // same as above, but don't do "new"

    fOk = FALSE;
    /* fall through */

RETURN_SUCCESS:             // normal exit

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* Only mark clean on success */
    if (fOk)
        gfDirty = FALSE;

    /* update the display */
    UpdateCaption();
    UpdateDisplay(TRUE);

    return fOk;
} /* FileOpen */



/* fOK = FileSave(fSaveAs)
 *
 * Do a File/Save operation (if <fSaveAs> is FALSE) or a File/SaveAs
 * operation (if <fSaveAs> is TRUE).  Return TRUE unless the user cancelled
 * or an error occurred.
 */
BOOL FAR PASCAL FileSave(
    BOOL  fSaveAs)        // do a "Save As" instead of "Save"?
{
    BOOL        fOK = TRUE; // function succeeded?
    TCHAR       ach[80];    // buffer for string loading
    TCHAR       aszFile[_MAX_PATH];
    BOOL        fUntitled;  // file is untitled?
    HCURSOR     hcurPrev = NULL; // cursor before hourglass
    HMMIO       hmmio;
    
    // temp arguments to WriteWaveFile if a conversion is requested
    PWAVEFORMATEX pwfxSaveAsFormat = NULL;
    
    /* stop playing/recording */
    StopWave();

    fUntitled = IsDocUntitled();

    if (fSaveAs || fUntitled)
    {
        OPENFILENAME  ofn;
        BOOL          f;

        // prompt user for file to save 
        LoadString(ghInst, IDS_SAVE, ach, SIZEOF(ach));
        
        if (!gfEmbeddedObject && !fUntitled)
            lstrcpy(aszFile, gachFileName);
        else
            aszFile[0] = 0;

        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = ghwndApp;
        ofn.hInstance       = ghInst;
        ofn.lpstrFilter     = aszFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter  = 0;
        ofn.nFilterIndex    = 1;
        ofn.lpstrFile       = aszFile;
        ofn.nMaxFile        = SIZEOF(aszFile);
        ofn.lpstrFileTitle  = NULL;
        ofn.nMaxFileTitle   = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle      = ach;
        ofn.Flags           =   OFN_PATHMUSTEXIST
                              | OFN_HIDEREADONLY
#ifdef CHICAGO
                              | OFN_EXPLORER
#endif                              
                              | OFN_NOREADONLYRETURN;
        ofn.nFileOffset     = 0;
        ofn.nFileExtension  = 0;
        ofn.lpstrDefExt     = gachDefFileExt;
        
        //
        // We need to present a new Save As dialog template to add a convert
        // button.  Adding a convert button requires us to also hook and
        // handle the button message ourselves.
        //
        if (fSaveAs)
        {
            // pwfxSaveAsFormat will point to a new format if the user
            // requested it
            ofn.lCustData       = (LPARAM)(LPVOID)&pwfxSaveAsFormat;
            ofn.Flags           |= OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
            ofn.lpTemplateName  = MAKEINTRESOURCE(IDD_SAVEAS);
            ofn.lpfnHook        = SaveAsHookProc;
        }
        else
        {
            ofn.lpfnHook        = NULL;
            ofn.lpTemplateName  = NULL;
        }
        f = GetSaveFileName(&ofn);

        if (!f)
            goto RETURN_CANCEL;
        
        {
            //
            // Add extension if none given
            //
            LPTSTR lp;
            for (lp = (LPTSTR)&aszFile[lstrlen(aszFile)] ; *lp != TEXT('.')  ;)
            {
                if (SLASH(*lp) || *lp == TEXT(':') || lp == (LPTSTR)aszFile)
                {
                    extern TCHAR FAR aszClassKey[];
                    lstrcat(aszFile, aszClassKey);
                    break;
                }
                lp = CharPrev(aszFile, lp);                
            }
        }

        // prompt for permission to overwrite the file 
        if (!CheckIfFileExists(aszFile))
            return FALSE;           // user cancelled

        if (gfEmbeddedObject && gfDirty)
        {
            int id;
            
            // see if user wants to update first 
            id = ErrorResBox( ghwndApp
                              , ghInst
                              , MB_ICONQUESTION | MB_YESNOCANCEL
                              , IDS_APPTITLE
                              , IDS_UPDATEBEFORESAVE);
            
            if (id == IDCANCEL)
                return FALSE;
            
            else if (id == IDYES)
            {
                DoOleSave();
                AdviseSaved();
                gfDirty = FALSE;
            }
        }
    }
    else
    {
        // Copy the current name to our temporary variable
        // We really should save to a different temporary file
        lstrcpy(aszFile, gachFileName);
    }

    // show hourglass cursor
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // write the WAVE file 
    // open the file -- if it already exists, truncate it to zero bytes
    
    hmmio = mmioOpen(aszFile
                     , NULL
                     , MMIO_CREATE | MMIO_WRITE | MMIO_ALLOCBUF);
    
    if (hmmio == NULL) {
        ErrorResBox(ghwndApp
                    , ghInst
                    , MB_ICONEXCLAMATION | MB_OK
                    , IDS_APPTITLE
                    , IDS_ERROROPEN
                    , (LPTSTR) aszFile);

        goto RETURN_ERROR;
    }

    if (pwfxSaveAsFormat)
    {
        DWORD cbNew;
        DWORD cbOld;
        LPBYTE pbNew;

        cbOld = wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid);
        if (ConvertFormatDialog(ghwndApp
                                , gpWaveFormat
                                , cbOld
                                , gpWaveSamples
                                , pwfxSaveAsFormat
                                , &cbNew
                                , &pbNew
                                , 0
                                , NULL) == MMSYSERR_NOERROR )
        {
            GlobalFreePtr(gpWaveFormat);
            GlobalFreePtr(gpWaveSamples);
            
            gpWaveFormat = pwfxSaveAsFormat;
            
            gcbWaveFormat = sizeof(WAVEFORMATEX);            
            if (pwfxSaveAsFormat->wFormatTag != WAVE_FORMAT_PCM)
                gcbWaveFormat += pwfxSaveAsFormat->cbSize;
            
            gpWaveSamples = pbNew;
            glWaveSamples = wfBytesToSamples(gpWaveFormat, cbNew);
            glWaveSamplesValid = wfBytesToSamples(gpWaveFormat, cbNew);
        }
        else
        {
            ErrorResBox(ghwndApp
                        , ghInst
                        , MB_ICONEXCLAMATION | MB_OK
                        , IDS_APPTITLE, IDS_ERR_CANTCONVERT);
            
            goto RETURN_ERROR;
        }
    }
    
    if (!WriteWaveFile(hmmio
                       , gpWaveFormat
                       , gcbWaveFormat
                       , gpWaveSamples
                       , glWaveSamplesValid))
    {
        mmioClose(hmmio,0);
        ErrorResBox(ghwndApp
                    , ghInst
                    , MB_ICONEXCLAMATION | MB_OK
                    , IDS_APPTITLE, IDS_ERRORWRITE
                    , (LPTSTR) aszFile );
        goto RETURN_ERROR;
    }

    mmioClose(hmmio,0);

    //
    // Only change file name if we succeed
    //
    RenameDoc(aszFile);

    UpdateCaption();
    
    if (fSaveAs || fUntitled)
    {
        AdviseRename(gachFileName);
    }
    else 
    {
        DoOleSave();
        gfDirty = FALSE;
    }
    
    goto RETURN_SUCCESS;

RETURN_ERROR:               // do error exit without error message
    DeleteFile(aszFile);

RETURN_CANCEL:

    fOK = FALSE;

    //
    // Clean up conversion selection
    //
    if (pwfxSaveAsFormat)
        GlobalFreePtr(pwfxSaveAsFormat);

RETURN_SUCCESS:             // normal exit

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    if (fOK)
        gfDirty = FALSE;

    //
    // update the display
    //
    UpdateDisplay(TRUE);

    return fOK;
} /* FileSave*/




/* fOK = FileRevert()
 *
 * Do a File/Revert operation, i.e. let user revert to last-saved version.
 */
BOOL FAR PASCAL
     FileRevert(void)
{
    int     id;
    TCHAR       achFileName[_MAX_PATH];
    BOOL        fOk;
    BOOL        fDirtyOrig;

    /* "Revert..." menu is grayed unless file is dirty and file name
     * is not "(Untitled)" and this is not an embedded object
     */

    /* prompt user for permission to discard changes */
    id = ErrorResBox(ghwndApp, ghInst, MB_ICONQUESTION | MB_YESNO,
        IDS_APPTITLE, IDS_CONFIRMREVERT);
    if (id == IDNO)
        return FALSE;

    /* discard changes and re-open file */
    lstrcpy(achFileName, gachFileName); // FileNew nukes <gachFileName>

    /* Make file clean temporarily, so FileOpen() won't warn user */
    fDirtyOrig = gfDirty;
    gfDirty = FALSE;

    fOk = FileOpen(achFileName);
    if (!fOk)
        gfDirty = fDirtyOrig;

    return fOk;
} /* FileRevert */




/* ReadWaveFile
 *
 * Read a WAVE file from <hmmio>.  Fill in <*pWaveFormat> with
 * the WAVE file format and <*plWaveSamples> with the number of samples in
 * the file.  Return a pointer to the samples (stored in a GlobalAlloc'd
 * memory block) or NULL on error.
 *
 * <szFileName> is the name of the file that <hmmio> refers to.
 * <szFileName> is used only for displaying error messages.
 *
 * On failure, an error message is displayed.
 */
MMRESULT ReadWaveFile(
    HMMIO           hmmio,          // handle to open file
    LPWAVEFORMATEX* ppWaveFormat,   // fill in with the WAVE format
    DWORD *         pcbWaveFormat,  // fill in with WAVE format size
    LPBYTE *        ppWaveSamples,
    DWORD *         plWaveSamples,  // number of samples
    LPTSTR          szFileName,     // file name (or NULL) for error msg.
    BOOL            fCacheRIFF)     // cache RIFF?
{
    MMCKINFO      ckRIFF;              // chunk info. for RIFF chunk
    MMCKINFO      ck;                  // info. for a chunk file
    HPBYTE        pWaveSamples = NULL; // waveform samples
    UINT          cbWaveFormat;
    WAVEFORMATEX* pWaveFormat = NULL;
    BOOL          fHandled;
    DWORD         dwBlkAlignSize = 0; // initialisation only to eliminate spurious warning
    MMRESULT      mmr = MMSYSERR_NOERROR;
    
    //
    // added for robust RIFF checking
    //
    BOOL          fFMT=FALSE, fDATA=FALSE, fFACT=FALSE;
    DWORD         dwCkEnd,dwRiffEnd;
    
    if (ppWaveFormat == NULL
        || pcbWaveFormat == NULL
        || ppWaveSamples == NULL
        || plWaveSamples == NULL )
       return MMSYSERR_ERROR;

    *ppWaveFormat   = NULL;
    *pcbWaveFormat  = 0L;
    *ppWaveSamples  = NULL;
    *plWaveSamples  = 0L;

    //
    // descend the file into the RIFF chunk
    //
    if (mmioDescend(hmmio, &ckRIFF, NULL, 0) != 0)
    {
        //
        // Zero length files are OK.
        //
        if (mmioSeek(hmmio, 0L, SEEK_END) == 0L)
        {
            DWORD           cbwfx;
            LPWAVEFORMATEX  pwfx;

            //
            // Synthesize a wave header
            //
            if (!SoundRec_GetDefaultFormat(&pwfx, &cbwfx))
            {
                cbwfx = sizeof(WAVEFORMATEX);
                pwfx  = (WAVEFORMATEX *)GlobalAllocPtr(GHND, sizeof(WAVEFORMATEX));

                if (pwfx == NULL)
                    return MMSYSERR_NOMEM;

                CreateWaveFormat(pwfx,FMT_DEFAULT,(UINT)WAVE_MAPPER);
            }
            *ppWaveFormat   = pwfx;
            *pcbWaveFormat  = cbwfx;
            *plWaveSamples  = 0L;
            *ppWaveSamples  = NULL;

            return MMSYSERR_NOERROR;
        }
        else
            goto ERROR_NOTAWAVEFILE;
    }

    /* make sure the file is a WAVE file */
    if ((ckRIFF.ckid != FOURCC_RIFF) ||
        (ckRIFF.fccType != mmioFOURCC('W', 'A', 'V', 'E')))
        goto ERROR_NOTAWAVEFILE;

    /* We can preserve the order of chunks in memory
     * by parsing the entire file as we read it in.
     */

    /* Use AddChunk(&ck,NULL) to add a placeholder node
     * for a chunk being edited.
     * Else AddChunk(&ck,hpstrData)
     */
    dwRiffEnd = ckRIFF.cksize;
    dwRiffEnd += (dwRiffEnd % 2);   /* must be even */

    while ( mmioDescend( hmmio, &ck, &ckRIFF, 0) == 0)
    {
        fHandled = FALSE;

        dwCkEnd = ck.cksize + (ck.dwDataOffset - ckRIFF.dwDataOffset);
        dwCkEnd += (dwCkEnd % 2);   /* must be even */

        if (dwCkEnd > dwRiffEnd)
        {
            DPF(TEXT("Chunk End %lu> Riff End %lu\n"),dwCkEnd,dwRiffEnd);

            /* CORRUPTED RIFF, when we ascend we'll be past the
             * end of the RIFF
             */

            if (fFMT && fDATA)
            {
                /* We might have enough information to deal
                 * with clipboard mixing/inserts, etc...
                 * This is for the bug with BOOKSHELF '92
                 * where they give us RIFF with a
                 * RIFF.dwSize > sum(childchunks).
                 * They *PROMISE* not to do this again.
                 */
                mmioAscend( hmmio, &ck, 0 );
                goto RETURN_FINISH;

            }
            goto ERROR_READING;
        }

        switch ( ck.ckid )
        {
            case mmioFOURCC('f','m','t',' '):
                if (fFMT)
                    break; /* we've been here before */

                /* expect the 'fmt' chunk to be at least as
                 * large as <sizeof(WAVEFORMAT)>;
                 * if there are extra parameters at the end,
                 * we'll ignore them
                 */
                // 'fmt' chunk too small?
                if (ck.cksize < sizeof(WAVEFORMAT))
                    goto ERROR_NOTAWAVEFILE;

                /*
                 *  always force allocation to be AT LEAST
                 *  the size of WFX. this is required so all
                 *  code does not have to special case the
                 *  cbSize field. note that we alloc with zero
                 *  init so cbSize will be zero for plain
                 *  jane PCM
                 */
                cbWaveFormat = max((WORD)ck.cksize,
                                    sizeof(WAVEFORMATEX));
                pWaveFormat = (WAVEFORMATEX*)GlobalAllocPtr(GHND, cbWaveFormat);

                if (pWaveFormat == NULL)
                    goto ERROR_FILETOOLARGE;
                /*
                 *  set the size back to the actual size
                 */
                cbWaveFormat = (WORD)ck.cksize;

                *ppWaveFormat  = pWaveFormat;
                *pcbWaveFormat = cbWaveFormat;

                /* read the file format into <*pWaveFormat> */
                if (mmioRead(hmmio, (HPSTR)pWaveFormat, ck.cksize) != (long)ck.cksize)
                    goto ERROR_READING; // truncated file, probably

                if (fCacheRIFF && !AddChunk(&ck,NULL,&gpcknHead,&gpcknTail))
                {
                    goto ERROR_FILETOOLARGE;
                }

//Sanity check for PCM Formats:
                if (pWaveFormat->wFormatTag == WAVE_FORMAT_PCM)
                {
                    pWaveFormat->nBlockAlign = pWaveFormat->nChannels *
                                                ((pWaveFormat->wBitsPerSample + 7)/8);
                    pWaveFormat->nAvgBytesPerSec = pWaveFormat->nBlockAlign *
                                                    pWaveFormat->nSamplesPerSec;
                }

                fFMT = TRUE;
                fHandled = TRUE;
                break;

            case mmioFOURCC('d','a','t','a'):
                /* deal with the 'data' chunk */

                if (fDATA)
                    break; /* we've been here before */

                if (!pWaveFormat)
                    goto ERROR_READING;

//***           is dwBlkAlignSize?  Don't you want to use nBlkAlign
//***           to determine this value?
#if 0
                dwBlkAlignSize = ck.cksize;
                dwBlkAlignSize += (ck.cksize%pWaveFormat.nBlkAlign);
                *pcbWaveSamples = ck.cksize;

#else
                dwBlkAlignSize = wfBytesToBytes(pWaveFormat, ck.cksize);
#endif

                if ((pWaveSamples = GlobalAllocPtr(GHND | GMEM_SHARE
                                                   , dwBlkAlignSize+4)) == NULL)

                    goto ERROR_FILETOOLARGE;

                /* read the samples into the memory buffer */
                if (mmioRead(hmmio, (HPSTR)pWaveSamples, dwBlkAlignSize) !=
                           (LONG)dwBlkAlignSize)
                    goto ERROR_READING;     // truncated file, probably

                if (fCacheRIFF && !AddChunk(&ck,NULL,&gpcknHead,&gpcknTail))
                {
                    goto ERROR_FILETOOLARGE;
                }

                fDATA = TRUE;
                fHandled = TRUE;
                break;

            case mmioFOURCC('f','a','c','t'):

                /* deal with the 'fact' chunk */
                if (fFACT)
                    break; /* we've been here before */
                
#if 0
//
//         There are some wave editors that are writing 'fact' chunks
//         after the data chunk, so we no longer make this assumption
//                                
                if (fDATA)
                    break; /* we describe some another 'data' chunk */
#endif

                if (mmioRead(hmmio,(HPSTR)plWaveSamples, sizeof(DWORD))
                        != sizeof(DWORD))
                    goto ERROR_READING;

                if (fCacheRIFF && ck.cksize > sizeof(DWORD) &&
                        ck.cksize < 0xffff)
                {
                    spFact = (PFACT)GlobalAllocPtr(GHND,(UINT)(ck.cksize - sizeof(DWORD)));
                    if (spFact == NULL)
                        goto ERROR_FILETOOLARGE;
                    scbFact = ck.cksize - sizeof(DWORD);
                    if (mmioRead(hmmio,(HPSTR)spFact,scbFact) != scbFact)
                        goto ERROR_READING;
                }

                /* we don't AddChunk() the 'fact' because we
                 * write it out before we write our edit 'data'
                 */
                fFACT = TRUE;
                fHandled = TRUE;
                break;

#ifdef DISP
            case mmioFOURCC('d','i','s','p'):
                /* deal with the 'disp' chunk for clipboard transfer */
                
                // TODO:
                //  DISP's are CF_DIB or CF_TEXT.  Put 'em somewhere
                //  global and pass them through as text or a BMP when
                //  we copy to clipboard.
                //
                break;
                
#endif /* DISP */
                
            case mmioFOURCC('L','I','S','T'):
                if (fCacheRIFF)
                {
                    /* seek back over the type field */
                    if (mmioSeek(hmmio,-4,SEEK_CUR) == -1)
                        goto ERROR_READING;
                }
                break;

            default:
                break;
        }

        /* the "default" case. */
        if (fCacheRIFF && !fHandled)
        {
            HPBYTE hpData;

            hpData = GlobalAllocPtr(GMEM_MOVEABLE, ck.cksize+4);
            if (hpData == NULL)
            {
                goto ERROR_FILETOOLARGE;
            }
            /* read the data into the cache buffer */
            if (mmioRead(hmmio, (HPSTR)hpData, ck.cksize) != (LONG) ck.cksize)
            {
                GlobalFreePtr(hpData);
                goto ERROR_READING;// truncated file, probably
            }
            //
            // Special case the copyright info.  I'd rather do this than
            // rewrite this whole app.
            //
            if (ck.ckid == mmioFOURCC('I','C','O','P'))
            {
                LPTSTR lpstr = GlobalAllocPtr(GHND, ck.cksize+4);
                if (lpstr)
                {
                    memcpy(lpstr, hpData, ck.cksize+4);
                    gpszInfo = lpstr;
                }
            }
            
            if (!AddChunk(&ck,hpData,&gpcknHead, &gpcknTail))
            {
                goto ERROR_FILETOOLARGE;
            }
        }
        mmioAscend( hmmio, &ck, 0 );
    }

RETURN_FINISH:

    if (fFMT && fDATA)
    {
        *plWaveSamples = wfBytesToSamples(pWaveFormat, dwBlkAlignSize);
        *ppWaveSamples = pWaveSamples;
        goto RETURN_SUCCESS;
    }

    /* goto ERROR_NOTAWAVEFILE; */

ERROR_NOTAWAVEFILE:             // file is not a WAVE file

    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                IDS_APPTITLE, IDS_NOTAWAVEFILE, (LPTSTR) szFileName);
    goto RETURN_ERROR;

ERROR_READING:                  // error reading from file

    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                IDS_APPTITLE, IDS_ERRORREAD, (LPTSTR) szFileName);
    goto RETURN_ERROR;

ERROR_FILETOOLARGE:             // out of memory

    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                IDS_APPTITLE, IDS_FILETOOLARGE, (LPTSTR) szFileName);
    goto RETURN_ERROR;

RETURN_ERROR:

    if (pWaveSamples != NULL)
        GlobalFreePtr(pWaveSamples), pWaveSamples = NULL;

    if (fCacheRIFF)
        FreeAllChunks(&gpcknHead, &gpcknTail);
    
    mmr = MMSYSERR_ERROR;
    
RETURN_SUCCESS:
    return mmr;
    
} /* ReadWaveFile */


/* fSuccess = AddChunk(lpCk, hpData)
 *
 * Adds to our linked list of chunk information.
 *
 * LPMMCKINFO lpCk | far pointer to the MMCKINFO describing the chunk.
 * HPBYTE hpData | huge pointer to the data portion of the chunk, NULL if
 *      handled elsewhere.
 *
 * RETURNS: TRUE if added, FALSE if out of local heap.
 */

static BOOL AddChunk(
    LPMMCKINFO      lpCk,
    HPBYTE          hpData,
    PCKNODE *       ppcknHead,
    PCKNODE *       ppcknTail)
{
    PCKNODE         pckn;

    //
    // create a node
    //
    pckn = (PCKNODE)GlobalAllocPtr(GHND,sizeof(CKNODE));
    if (pckn == NULL)
    {
        DPF(TEXT("No Local Heap for Cache"));
        return FALSE;
    }

    if (*ppcknHead == NULL)
    {
        *ppcknHead = pckn;
    }

    if (*ppcknTail != NULL)
    {
        (*ppcknTail)->psNext = pckn;
    }
    *ppcknTail = pckn;

    pckn->ck.ckid           = lpCk->ckid;
    pckn->ck.fccType        = lpCk->fccType;
    pckn->ck.cksize         = lpCk->cksize;
    pckn->ck.dwDataOffset   = lpCk->dwDataOffset;

    pckn->hpData = hpData;

    return TRUE;

} /* AddChunk() */


/* pckn = PCKNODE FreeHeadChunk(void)
 *
 * Frees up the Head chunk and return a pointer to the new Head.
 * Uses global gpcknHead
 *
 * RETURNS: PCKNODE pointer to the Head chunk.  NULL if no chunks in the list.
 */

static PCKNODE FreeHeadChunk(
    PCKNODE *       ppcknHead)
{
    PCKNODE         pckn, pcknNext;

    if (*ppcknHead == NULL)
    {
        goto SUCCESS;
    }

    pckn = *ppcknHead;
    pcknNext = (*ppcknHead)->psNext;

    if (pckn->hpData != NULL)
    {
        GlobalFreePtr(pckn->hpData);
    }

    GlobalFreePtr(pckn);
    *ppcknHead = pcknNext;

SUCCESS:;
    return *ppcknHead;

} /* FreeHeadChunk() */


/* void FreeAllChunks(void)
 *
 * Frees up the link list of chunk data.
 *
 * RETURNS: Nothing
 */
static void FreeAllChunks(
    PCKNODE *       ppcknHead,
    PCKNODE *       ppcknTail)
{
    PCKNODE         pckn = *ppcknHead;
    PCKNODE         pcknNext = (*ppcknHead ? (*ppcknHead)->psNext : NULL);

    DPF1(TEXT("Freeing All Chunks\n"));

    while (FreeHeadChunk(ppcknHead));
            
    if (scbFact > 0)
    {
        GlobalFreePtr(spFact);
        scbFact = 0;
    }
    *ppcknHead = NULL;
    *ppcknTail = NULL;

} /* FreeAllChunks() */


/* fSuccess = WriteWaveFile(hmmio, pWaveFormat, lWaveSamples)
 *
 * Write a WAVE file into <hmmio>.  <*pWaveFormat> should be
 * the WAVE file format and <lWaveSamples> should be the number of samples in
 * the file.  Return TRUE on success, FALSE on failure.
 *
 */
BOOL FAR PASCAL
     WriteWaveFile(
                    HMMIO       hmmio,          // handle to open file
                    WAVEFORMATEX* pWaveFormat,  // WAVE format
                    UINT        cbWaveFormat,   // size of WAVEFORMAT
                    HPBYTE      pWaveSamples,   // waveform samples
                    LONG        lWaveSamples)   // number of samples
{
    MMCKINFO    ckRIFF;     // chunk info. for RIFF chunk
    MMCKINFO    ck;     // info. for a chunk file
    PCKNODE     pckn = gpcknHead;
    LONG        cbWaveSamples;
    MMRESULT    mmr;
    
    /* create the RIFF chunk of form type 'WAVE' */
    ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E');
    ckRIFF.cksize = 0L;         // let MMIO figure out ck. size
    
    mmr = mmioCreateChunk(hmmio, &ckRIFF, MMIO_CREATERIFF);
    if (mmr != MMSYSERR_NOERROR)
        goto wwferror;

    if (pckn != NULL)
    {
        /* ForEach node in the linked list of chunks,
         * Write out the corresponding data chunk OR
         * the global edit data.
         */

        do {
            ck.cksize   = 0L;
            ck.ckid     = pckn->ck.ckid;
            ck.fccType  = pckn->ck.fccType;

            if (pckn->hpData == NULL)
            {
                /* This must be a data-type we have in edit
                 * buffers. We should preserve the original
                 * order.
                 */

                switch (pckn->ck.ckid)
                {
                    case mmioFOURCC('f','m','t',' '):

                        mmr = mmioCreateChunk(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;

                        if (mmioWrite(hmmio, (LPSTR) pWaveFormat, cbWaveFormat)
                            != (long)cbWaveFormat)
                            goto wwfwriteerror;

                        mmr = mmioAscend(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;
                        
                        break;

                    case mmioFOURCC('d','a','t','a'):
                        /* Insert a 'fact' chunk here */
                        /* 'fact' should always preceed the 'data' it
                         * describes.
                         */

                        ck.ckid = mmioFOURCC('f', 'a', 'c', 't');

                        mmr = mmioCreateChunk(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;

                        if (mmioWrite(hmmio, (LPSTR) &lWaveSamples,
                            sizeof(lWaveSamples)) != sizeof(lWaveSamples))
                            goto wwfwriteerror;

                        if (scbFact > 4)
                        {
                            if ( mmioWrite(hmmio, (LPSTR)spFact, scbFact)
                                    != scbFact )
                                goto wwfwriteerror;
                        }

                        mmr = mmioAscend(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;

                        ck.cksize = 0L;

                        ck.ckid = mmioFOURCC('d', 'a', 't', 'a');

                        mmr = mmioCreateChunk(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;

                        cbWaveSamples = wfSamplesToBytes(pWaveFormat,
                                                         lWaveSamples);
                        if (cbWaveSamples)
                        {
                            /* write the waveform samples */
                            if (mmioWrite(hmmio, (LPSTR)pWaveSamples
                                          , cbWaveSamples)
                                != cbWaveSamples)
                                return FALSE;
                        }
                        
                        mmr = mmioAscend(hmmio, &ck, 0);
                        if (mmr != MMSYSERR_NOERROR)
                            goto wwferror;
                            
                        break;

#ifdef DISP
                    case mmioFOURCC('d','i','s','p'):
                        /* deal with writing the 'disp' chunk */
                        break;
#endif /* DISP */

                    case mmioFOURCC('f','a','c','t'):
                        /* deal with the 'fact' chunk */
                        /* skip it.  We always write it before the 'data' */
                        break;

                    default:
                        /* This should never happen.*/
                        return FALSE;
                }
            }
            else
            {
                /* generic case */

                mmr = mmioCreateChunk(hmmio,&ck,0);
                if (mmr != MMSYSERR_NOERROR)
                    goto wwferror;


                if (mmioWrite(hmmio,(LPSTR)pckn->hpData,pckn->ck.cksize)
                    != (long) pckn->ck.cksize)
                    goto wwfwriteerror;

                mmr = mmioAscend(hmmio, &ck, 0);
                if (mmr != MMSYSERR_NOERROR)
                    goto wwferror;

            }

        } while (pckn = pckn->psNext);

    }
    else
    {
        /* <hmmio> is now descended into the 'RIFF' chunk -- create the
         * 'fmt' chunk and write <*pWaveFormat> into it
         */ 
        ck.ckid = mmioFOURCC('f', 'm', 't', ' ');
        ck.cksize = cbWaveFormat;
        
        mmr = mmioCreateChunk(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;

        if (mmioWrite(hmmio, (LPSTR) pWaveFormat, cbWaveFormat) !=
                (long)cbWaveFormat)
            goto wwfwriteerror;

        /* ascend out of the 'fmt' chunk, back into 'RIFF' chunk */
        mmr = mmioAscend(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;
        
        /* write out the number of samples in the 'FACT' chunk */
        ck.ckid = mmioFOURCC('f', 'a', 'c', 't');

        mmr = mmioCreateChunk(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;                        
        
        if (mmioWrite(hmmio, (LPSTR)&lWaveSamples,  sizeof(lWaveSamples))
                != sizeof(lWaveSamples))
            return FALSE;

        /* ascend out of the 'fact' chunk, back into 'RIFF' chunk */
        mmr = mmioAscend(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;
        
        /* create the 'data' chunk that holds the waveform samples */
        ck.ckid = mmioFOURCC('d', 'a', 't', 'a');
        ck.cksize = 0L;             // let MMIO figure out ck. size

        mmr = mmioCreateChunk(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;            

        cbWaveSamples = wfSamplesToBytes(pWaveFormat,lWaveSamples);

        /* write the waveform samples */
        if (cbWaveSamples)
        {
            if (mmioWrite(hmmio, (LPSTR)pWaveSamples, cbWaveSamples)
                != cbWaveSamples)
                goto wwfwriteerror;
        }

        /* ascend the file out of the 'data' chunk, back into
         * the 'RIFF' chunk -- this will cause the chunk size of the 'data'
         * chunk to be written
         */
        mmr = mmioAscend(hmmio, &ck, 0);
        if (mmr != MMSYSERR_NOERROR)
            goto wwferror;
    }

    /* ascend the file out of the 'RIFF' chunk */
    mmr = mmioAscend(hmmio, &ckRIFF, 0);
    if (mmr != MMSYSERR_NOERROR)
        goto wwferror;

    /* done */
    return TRUE;

wwferror:
#if DBG    
    {
        TCHAR sz[256];
        wsprintf(sz, TEXT("WriteWaveFile: Error %lx\r\n"), mmr);
        OutputDebugString(sz);
        DebugBreak();
    }
#endif            
    return FALSE;

wwfwriteerror:
#if DBG    
    {
        TCHAR sz[256];
        wsprintf(sz,TEXT("Write Error! ckid = %04x\r\n"), (DWORD)ck.ckid);
        OutputDebugString(sz);
        DebugBreak();
    }
#endif    
    return FALSE;
} /* WriteWaveFile */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\edit.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* edit.c
 *
 * Editing operations and special effects.
 */

/* Revision History.
 *   4/ Feb/91 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 *  14/Feb/94 LaurieGr merged Motown and Daytona versions
 */

#include "nocrap.h"
#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <string.h>

#define INCLUDE_OLESTUBS
#include "SoundRec.h"
#include "srecids.h"

/* constants */
#define CHVOL_INCDELTAVOLUME    25  // ChangeVolume: % to inc volume by
#define CHVOL_DECDELTAVOLUME    20  // ChangeVolume: % to dec volume by

#define ECHO_VOLUME             25      // AddEcho: % to multiply echo samples
#define ECHO_DELAY              150     // AddEcho: millisec delay for echo
#define WAVEBUFSIZE             400     // IncreasePitch, DecreasePitch
#define FINDWAVE_PICKYNESS      5       // how picky is FindWave?

extern char aszInitFile[];          // soundrec.c

static  SZCODE aszSamplesFormat[] = TEXT("%d%c%02d");
static  SZCODE aszSamplesNoZeroFormat[] = TEXT("%c%02d");

/* InsertFile(void)
 *
 * Prompt for the name of a WAVE file to insert at the current position.
 */
void FAR PASCAL
InsertFile(BOOL fPaste)
{
    TCHAR           achFileName[_MAX_PATH]; // name of file to insert
    WAVEFORMATEX*   pwfInsert=NULL; // WAVE file format of given file
    DWORD           cb;             // size of WAVEFORMATEX
    HPBYTE          pInsertSamples = NULL;  // samples from file to insert
    long            lInsertSamples; // number of samples in given file
    long            lSamplesToInsert;// no. samp. at samp. rate of cur. file
    TCHAR           ach[80];        // buffer for string loading
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    HPBYTE          pchSrc;         // pointer into source wave buffer
    short  *    piSrc;          // 16-bit pointer
    HPBYTE          pchDst;         // pointer into destination wave buffer
    short  *    piDst;          // 16-bit pointer
    long            lSamplesDst;    // bytes to copy into destination buffer
    long            lDDA;           // used to implement DDA algorithm
    HMMIO           hmmio;          // Handle to open file to read from

    BOOL            fDirty = TRUE;  // Is the buffer Dirty?

    BOOL            fStereoIn;
    BOOL            fStereoOut;
    BOOL            fEightIn;
    BOOL            fEightOut;
    BOOL            fEditWave = FALSE;
    int             iTemp;
    int             iTemp2;
    OPENFILENAME    ofn;

#ifdef DOWECARE    
    /* HACK from "server.c" to read objects without CF_WAVE */
    extern WORD cfNative;
#endif
    
    if (glWaveSamplesValid > 0 && !IsWaveFormatPCM(gpWaveFormat))
        return;

    if (fPaste) {
        MMIOINFO        mmioinfo;
        HANDLE          h;
        
        BeginWaveEdit();
        
        if (!OpenClipboard(ghwndApp))
            return;

        LoadString(ghInst, IDS_CLIPBOARD, achFileName, SIZEOF(achFileName));

        h = GetClipboardData(CF_WAVE);
#ifdef DOWECARE        
        if (!h) h = GetClipboardData(cfNative);
#endif
        if (h)
        {
            mmioinfo.fccIOProc = FOURCC_MEM;
            mmioinfo.pIOProc = NULL;
            mmioinfo.pchBuffer = GlobalLock(h);
            mmioinfo.cchBuffer = (long)GlobalSize(h); // initial size
            mmioinfo.adwInfo[0] = 0;            // grow by this much
            hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READ);
        }
        else
        {
            hmmio = NULL;
        }
    }
    else
    {
        BOOL f;

        achFileName[0] = 0;

        /* prompt user for file to open */
        LoadString(ghInst, IDS_INSERTFILE, ach, SIZEOF(ach));
        ofn.lStructSize = sizeof(OPENFILENAME);
        ofn.hwndOwner = ghwndApp;
        ofn.hInstance = NULL;
        ofn.lpstrFilter = aszFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter = 0;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = achFileName;
        ofn.nMaxFile = SIZEOF(achFileName);
        ofn.lpstrFileTitle = NULL;
        ofn.nMaxFileTitle = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle = ach;
        ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
        ofn.nFileOffset = 0;
        ofn.nFileExtension = 0;
        ofn.lpstrDefExt = NULL;
        ofn.lCustData = 0;
        ofn.lpfnHook = NULL;
        ofn.lpTemplateName = NULL;
        f = GetOpenFileName(&ofn);  // get the filename

        // did we succeed or not?
        if (!f)
            goto RETURN_ERROR;

        /* read the WAVE file */
        hmmio = mmioOpen(achFileName, NULL, MMIO_READ | MMIO_ALLOCBUF);
    }

    if (hmmio != NULL)
    {
        MMRESULT    mmr;
        
        //
        // show hourglass cursor
        //
        hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

        //
        // read the WAVE file
        //
        mmr = ReadWaveFile( hmmio
                            , &pwfInsert
                            , &cb
                            , &pInsertSamples
                            , &lInsertSamples
                            , achFileName
                            , FALSE );
        
        mmioClose(hmmio, 0);

        if (mmr != MMSYSERR_NOERROR)
            goto RETURN_ERROR;
        
        if (lInsertSamples == 0)
            goto RETURN_SUCCESS;

        if (pInsertSamples == NULL)
            goto RETURN_ERROR;

        if (glWaveSamplesValid > 0 && !IsWaveFormatPCM(pwfInsert))
        {

            ErrorResBox( ghwndApp
                       , ghInst
                       , MB_ICONEXCLAMATION | MB_OK
                       , IDS_APPTITLE
                       , fPaste ? IDS_CANTPASTE : IDS_NOTASUPPORTEDFILE
                       , (LPTSTR) achFileName
                       );
            goto RETURN_ERROR;
        }
    } else {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                            IDS_APPTITLE, IDS_ERROROPEN, (LPTSTR) achFileName);
        goto RETURN_ERROR;
    }
    
//jyg:moved
//        BeginWaveEdit();
    fEditWave = TRUE;

    //
    // if the current file is empty, treat the insert like a open
    //
    if (glWaveSamplesValid == 0)
    {
        DestroyWave();

        gpWaveSamples = pInsertSamples;
        glWaveSamples = lInsertSamples;
        glWaveSamplesValid = lInsertSamples;
        gpWaveFormat  = pwfInsert;
        gcbWaveFormat = cb;

        pInsertSamples = NULL;
        pwfInsert      = NULL;

        goto RETURN_SUCCESS;
    }

    fStereoIn  = pwfInsert->nChannels != 1;
    fStereoOut = gpWaveFormat->nChannels != 1;

    fEightIn  = ((LPWAVEFORMATEX)pwfInsert)->wBitsPerSample == 8;
    fEightOut = ((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8;

    /* figure out how many bytes need to be inserted */
    lSamplesToInsert = MulDiv(lInsertSamples, gpWaveFormat->nSamplesPerSec,
                                      pwfInsert->nSamplesPerSec);
#ifdef DEBUG
    DPF(TEXT("insert %ld samples, converting from %ld Hz to %ld Hz\n"),
            lInsertSamples, pwfInsert->nSamplesPerSec,
            gpWaveFormat->nSamplesPerSec);
    DPF(TEXT("so %ld samples need to be inserted at position %ld\n"),
            lSamplesToInsert, glWavePosition);
#endif

    /* reallocate the WAVE buffer to be big enough */
    if (!AllocWaveBuffer(glWaveSamplesValid + lSamplesToInsert, TRUE, TRUE))
        goto RETURN_ERROR;
    glWaveSamplesValid += lSamplesToInsert;

    /* create a "gap" in the WAVE buffer to go from this:
     *     |---glWavePosition---|-rest-of-buffer-|
     * to this:
     *     |---glWavePosition---|----lSamplesToInsert----|-rest-of-buffer-|
     * where <glWaveSamplesValid> is the size of the buffer
     * *after* reallocation
     */
    memmove( gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWavePosition + lSamplesToInsert)
           , gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWavePosition)
           , wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - (glWavePosition + lSamplesToInsert))
           );

    /* copy the read-in WAVE file into the "gap" */
    pchDst = gpWaveSamples + wfSamplesToBytes(gpWaveFormat,glWavePosition);
    piDst = (short  *) pchDst;

    lSamplesDst = lSamplesToInsert;
    pchSrc = pInsertSamples;
    piSrc = (short  *) pchSrc;

    lDDA = -((LONG)gpWaveFormat->nSamplesPerSec);
    while (lSamplesDst > 0)
    {
        /* get a sample, convert to right format */
        if (fEightIn) {
            iTemp = *((BYTE  *) pchSrc);
            if (fStereoIn) {
                iTemp2 = (unsigned char) *(pchSrc+1);
                if (!fStereoOut) {
                    iTemp = (iTemp + iTemp2) / 2;
                }
            }
            else
                iTemp2 = iTemp;

            if (!fEightOut) {
                iTemp = (iTemp - 128) << 8;
                iTemp2 = (iTemp2 - 128) << 8;
            }
        } else {
            iTemp = *piSrc;
            if (fStereoIn) {
                iTemp2 = *(piSrc+1);
                if (!fStereoOut) {
                    iTemp = (int) (  ( ((long)iTemp) + ((long) iTemp2)
                                     ) / 2);
                }
            }
            else
                iTemp2 = iTemp;

            if (fEightOut) {
                iTemp = (iTemp >> 8) + 128;
                iTemp2 = (iTemp2 >> 8) + 128;
            }
        }

        /* Output a sample */
        if (fEightOut)
        {   // Cast on lvalue eliminated -- LKG
            *(BYTE  *) pchDst = (BYTE) iTemp;
            pchDst = (BYTE  *)pchDst + 1;
        }
        else
            *piDst++ = (short)iTemp;
        if (fStereoOut) {
            if (fEightOut)
            {   // Cast on lvalue eliminated -- LKG
                *(BYTE  *) pchDst = (BYTE) iTemp2;
                pchDst = (BYTE  *)pchDst + 1;
            }
            else
                *piDst++ = (short)iTemp2;
        }
        lSamplesDst--;

        /* increment <pchSrc> at the correct rate so that the
         * sampling rate of the input file is converted to match
         * the sampling rate of the current file
         */
        lDDA += pwfInsert->nSamplesPerSec;
        while (lDDA >= 0) {
            lDDA -= gpWaveFormat->nSamplesPerSec;
            if (fEightIn)
                pchSrc++;
            else
                piSrc++;
            if (fStereoIn) {
                if (fEightIn)
                    pchSrc++;
                else
                    piSrc++;
            }
        }
    }
#ifdef DEBUG
    if (!fEightIn)
        pchSrc = (HPBYTE) piSrc;
    DPF(TEXT("copied %ld bytes from insertion buffer\n"), (long) (pchSrc - pInsertSamples));
#endif

    goto RETURN_SUCCESS;

RETURN_ERROR:                           // do error exit without error message
    fDirty = FALSE;

RETURN_SUCCESS:                         // normal exit

    if (fPaste)
        CloseClipboard();

    if (pInsertSamples != NULL)
        GlobalFreePtr(pInsertSamples);

    if (pwfInsert != NULL)
        GlobalFreePtr(pwfInsert);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    if (fEditWave == TRUE)
        EndWaveEdit(fDirty);

    /* update the display */
    UpdateDisplay(TRUE);
}


/* MixWithFile(void)
 *
 * Prompt for the name of a WAVE file to mix with the audio starting at
 * the current location.
 */
void FAR PASCAL
MixWithFile(BOOL fPaste)
{
    TCHAR           achFileName[_MAX_PATH]; // name of file to mix with
    WAVEFORMATEX*     pwfMix=NULL;    // WAVE file format of given file
    UINT            cb;
    HPBYTE          pMixSamples = NULL;     // samples from file to mix with
    long            lMixSamples;    // number of samples in given file
    long            lSamplesToMix;  // no. Samples at samp. rate. of cur. file
    long            lSamplesToAdd;  // no. Samples to add in
    TCHAR           ach[80];        // buffer for string loading
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    HPBYTE          pchSrc;         // pointer into source wave buffer
    HPBYTE          pchDst;         // pointer into destination wave buffer
    short  *    piSrc;          // pointer into source wave buffer
    short  *    piDst;          // pointer into destination wave buffer
    long            lSamplesDst;    // Samples to copy into destination buffer
    long            lDDA;           // used to implement DDA algorithm
    int             iSample;        // value of a waveform sample
    long            lSample;        // value of a waveform sample
    HMMIO           hmmio;

    BOOL            fDirty = TRUE;

    BOOL            fStereoIn;
    BOOL            fStereoOut;
    BOOL            fEightIn;
    BOOL            fEightOut;
    BOOL            fEditWave = FALSE;
    int             iTemp;
    int             iTemp2;
    OPENFILENAME    ofn;

#ifdef DOWECARE    
    /* HACK from "server.c" to read objects without CF_WAVE */
    extern WORD cfNative;
#endif
    
    if (glWaveSamplesValid > 0 && !IsWaveFormatPCM(gpWaveFormat))
        return;

    if (fPaste) {
        MMIOINFO        mmioinfo;
        HANDLE          h;

        BeginWaveEdit();        
        if (!OpenClipboard(ghwndApp))
            return;

        LoadString(ghInst, IDS_CLIPBOARD, achFileName, SIZEOF(achFileName));

        h = GetClipboardData(CF_WAVE);
#ifdef DOWECARE        
        if (!h) h = GetClipboardData(cfNative);
#endif        
        if (h) {
            mmioinfo.fccIOProc = FOURCC_MEM;
            mmioinfo.pIOProc = NULL;
            mmioinfo.pchBuffer = GlobalLock(h);
            mmioinfo.cchBuffer = (long)GlobalSize(h); // initial size
            mmioinfo.adwInfo[0] = 0;            // grow by this much
            hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READ);
        }
        else {
            hmmio = NULL;
        }
    }
    else {
        BOOL f;

        achFileName[0] = 0;

        /* prompt user for file to open */
        LoadString(ghInst, IDS_MIXWITHFILE, ach, SIZEOF(ach));
        ofn.lStructSize = sizeof(OPENFILENAME);
        ofn.hwndOwner = ghwndApp;
        ofn.hInstance = NULL;
        ofn.lpstrFilter = aszFilter;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter = 0;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = achFileName;
        ofn.nMaxFile = SIZEOF(achFileName);
        ofn.lpstrFileTitle = NULL;
        ofn.nMaxFileTitle = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle = ach;
        ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
        ofn.nFileOffset = 0;
        ofn.nFileExtension = 0;
        ofn.lpstrDefExt = NULL;
        ofn.lCustData = 0;
        ofn.lpfnHook = NULL;
        ofn.lpTemplateName = NULL;
        f = GetOpenFileName(&ofn);  // get the filename for mixing

        // see if we continue
        if (!f)
            goto RETURN_ERROR;

        /* read the WAVE file */
        hmmio = mmioOpen(achFileName, NULL, MMIO_READ | MMIO_ALLOCBUF);
    }

    if (hmmio != NULL)
    {
        MMRESULT mmr;
        
        //
        // show hourglass cursor
        //
        hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

        //
        // read the WAVE file
        //
        mmr = ReadWaveFile( hmmio
                            , &pwfMix       // wave format
                            , &cb           // wave format size
                            , &pMixSamples  // samples
                            , &lMixSamples  // number of samples
                            , achFileName   // file name for error
                            , FALSE );      // cache riff?
                                 
        mmioClose(hmmio, 0);


        if (mmr != MMSYSERR_NOERROR)
            goto RETURN_ERROR;
        
        if (lMixSamples == 0)
            goto RETURN_SUCCESS;
        
        if (pMixSamples == NULL)
            goto RETURN_ERROR;

        if (glWaveSamplesValid > 0 && !IsWaveFormatPCM(pwfMix)) {
            ErrorResBox( ghwndApp
                       , ghInst
                       , MB_ICONEXCLAMATION | MB_OK
                       , IDS_APPTITLE
                       , fPaste ? IDS_CANTPASTE : IDS_NOTASUPPORTEDFILE
                       , (LPTSTR) achFileName
                       );
            goto RETURN_ERROR;
        }
    }
    else
    {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                    IDS_APPTITLE, IDS_ERROROPEN, (LPTSTR) achFileName);
        goto RETURN_ERROR;
    }

//jyg: moved
//        BeginWaveEdit();
    fEditWave = TRUE;

    //
    // if the current file is empty, treat the insert like a open
    //
    if (glWaveSamplesValid == 0)
    {
        DestroyWave();

        gpWaveSamples = pMixSamples;
        glWaveSamples = lMixSamples;
        glWaveSamplesValid = lMixSamples;
        gpWaveFormat  = pwfMix;
        gcbWaveFormat = cb;

        pMixSamples = NULL;
        pwfMix      = NULL;

        goto RETURN_SUCCESS;
    }

    fStereoIn  = pwfMix->nChannels != 1;
    fStereoOut = gpWaveFormat->nChannels != 1;

    fEightIn  = ((LPWAVEFORMATEX)pwfMix)->wBitsPerSample == 8;
    fEightOut = ((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8;

    /* figure out how many Samples need to be mixed in */
    lSamplesToMix = MulDiv(lMixSamples, gpWaveFormat->nSamplesPerSec,
                                  pwfMix->nSamplesPerSec);
    lSamplesToAdd = lSamplesToMix - (glWaveSamplesValid - glWavePosition);
    if (lSamplesToAdd < 0)
        lSamplesToAdd = 0;
#ifdef DEBUG
    DPF(TEXT("mix in %ld samples, converting from %ld Hz to %ld Hz\n"),
                lMixSamples, pwfMix->nSamplesPerSec,
                gpWaveFormat->nSamplesPerSec);
    DPF(TEXT("so %ld Samples need to be mixed in at position %ld (add %ld)\n"),
                lSamplesToMix, glWavePosition, lSamplesToAdd);
#endif

    if (lSamplesToAdd > 0) {

        /* mixing the specified file at the current location will
         * require the current file's wave buffer to be expanded
         * by <lSamplesToAdd>
         */

        /* reallocate the WAVE buffer to be big enough */
        if (!AllocWaveBuffer(glWaveSamplesValid + lSamplesToAdd,TRUE, TRUE))
            goto RETURN_ERROR;

        /* fill in the new part of the buffer with silence
         */
        lSamplesDst = lSamplesToAdd;

        /* If stereo, just twice as many samples
         */
        if (fStereoOut)
            lSamplesDst *= 2;

        pchDst = gpWaveSamples + wfSamplesToBytes(gpWaveFormat,glWaveSamplesValid);

        if (fEightOut) {
            while (lSamplesDst-- > 0) {
                // cast on lvalue eliminated
                *((BYTE  *) pchDst) = 128;
                pchDst = (BYTE  *)pchDst + 1;
            }
        }
        else {
            piDst = (short  *) pchDst;
            while (lSamplesDst-- > 0) {
                *((short  *) piDst) = 0;
                piDst = (short  *)piDst + 1;
            }
        }
        glWaveSamplesValid += lSamplesToAdd;
    }

    /* mix the read-in WAVE file with the current file starting at the
     * current position
     */
    pchDst = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWavePosition);
    piDst = (short  *) pchDst;

    lSamplesDst = lSamplesToMix;
    pchSrc = pMixSamples;
    piSrc = (short  *) pchSrc;

    lDDA = -((LONG)gpWaveFormat->nSamplesPerSec);
    while (lSamplesDst > 0)
    {
        /* get a sample, convert to right format */
        if (fEightIn) {
            iTemp = (int) (unsigned char) *pchSrc;
            if (fStereoIn) {
                iTemp2 = (int) (unsigned char) *(pchSrc+1);
                if (!fStereoOut) {
                    iTemp = (iTemp + iTemp2) / 2;
                }
            } else
                iTemp2 = iTemp;

            if (!fEightOut) {
                iTemp = (iTemp - 128) << 8;
                iTemp2 = (iTemp2 - 128) << 8;
            }
        } else {
            iTemp = *piSrc;
            if (fStereoIn) {
                iTemp2 = *(piSrc+1);
                if (!fStereoOut) {
                    iTemp = (int) ((((long) iTemp)
                              + ((long) iTemp2)) / 2);
                }
            } else
                iTemp2 = iTemp;

            if (fEightOut) {
                iTemp = (iTemp >> 8) + 128;
                iTemp2 = (iTemp2 >> 8) + 128;
            }
        }

        /* Output a sample */
        if (fEightOut)
        {
            iSample = (int) *((BYTE  *) pchDst)
                                            + iTemp - 128;
            *((BYTE  *) pchDst++) = (BYTE)
                         (iSample < 0 ? 0 :
                                 (iSample > 255 ? 255 : iSample));
        }
        else
        {
            lSample = (long) *((short  *) piDst)
                                            + (long) iTemp;
            *((short  *) piDst++) = (int)
                            (lSample < -32768L
                                    ? -32768 : (lSample > 32767L
                                            ? 32767 : (short) lSample));
        }
        if (fStereoOut) {
            if (fEightOut)
            {
                iSample = (int) *((BYTE  *) pchDst)
                                                    + iTemp2 - 128;
                *((BYTE  *) pchDst++) = (BYTE)
                                    (iSample < 0
                                            ? 0 : (iSample > 255
                                                    ? 255 : iSample));
            }
            else
            {
                lSample = (long) *((short  *) piDst)
                                                    + (long) iTemp2;
                *((short  *) piDst++) = (short)
                                    (lSample < -32768L
                                        ? -32768 : (lSample > 32767L
                                            ? 32767 : (short) lSample));
            }
        }
        lSamplesDst--;

        /* increment <pchSrc> at the correct rate so that the
         * sampling rate of the input file is converted to match
         * the sampling rate of the current file
         */
        lDDA += pwfMix->nSamplesPerSec;
        while (lDDA >= 0)
        {
            lDDA -= gpWaveFormat->nSamplesPerSec;
            if (fEightIn)
                pchSrc++;
            else
                piSrc++;
            if (fStereoIn) {
                if (fEightIn)
                    pchSrc++;
                else
                    piSrc++;
            }
        }
    }
#ifdef DEBUG
    if (!fEightIn)
        pchSrc = (HPBYTE) piSrc;
    DPF(TEXT("copied %ld bytes from mix buffer\n"),
        (long) (pchSrc - pMixSamples));
#endif

    goto RETURN_SUCCESS;

RETURN_ERROR:                           // do error exit without error message
    fDirty = FALSE;

RETURN_SUCCESS:                         // normal exit

    if (fPaste)
        CloseClipboard();

    if (pMixSamples != NULL)
        GlobalFreePtr(pMixSamples);

    if (pwfMix != NULL)
        GlobalFreePtr(pwfMix);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    if (fEditWave == TRUE)
        EndWaveEdit(fDirty);

    /* update the display */
    UpdateDisplay(TRUE);
}


/* DeleteBefore()
 *
 * Delete samples before <glWavePosition>.
 */
void FAR PASCAL
     DeleteBefore(void)
{
    TCHAR           ach[40];
    long            lTime;
    int             id;

    if (glWavePosition == 0)                // nothing to do?
            return;                         // don't set dirty flag

    BeginWaveEdit();

    /* jyg - made this conditional because of rounding errors at
     * the end of buffer case
     */
    if (glWavePosition != glWaveSamplesValid)
        glWavePosition = wfSamplesToSamples(gpWaveFormat, glWavePosition);

    /* get the current wave position */
    lTime = wfSamplesToTime(gpWaveFormat, glWavePosition);
    if (gfLZero || ((int)(lTime/1000) != 0))               // ??? what are these casts ???
        wsprintf(ach, aszSamplesFormat, (int)(lTime/1000), chDecimal, (int)((lTime/10)%100));
    else
    wsprintf(ach, aszSamplesNoZeroFormat, chDecimal, (int)((lTime/10)%100));


    /* prompt user for permission */

    id = ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OKCANCEL,
        IDS_APPTITLE, IDS_DELBEFOREWARN, (LPTSTR) ach);

    if (id != IDOK)
        return;

    /* copy the samples after <glWavePosition> to the beginning of
     * the buffer
     */
    memmove(gpWaveSamples,
            gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWavePosition),
            wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - glWavePosition));

    /* reallocate the buffer to be <glWavePosition> samples smaller */
    AllocWaveBuffer(glWaveSamplesValid - glWavePosition, TRUE, TRUE);
    glWavePosition = 0L;

    EndWaveEdit(TRUE);

    /* update the display */
    UpdateDisplay(TRUE);
} /* DeleteBefore */


/* DeleteAfter()
 *
 * Delete samples after <glWavePosition>.
 */
void FAR PASCAL
     DeleteAfter(void)
{
    TCHAR           ach[40];
    long            lTime;
    int             id;

    if (glWavePosition == glWaveSamplesValid)       // nothing to do?
            return;                         // don't set dirty flag

    glWavePosition = wfSamplesToSamples(gpWaveFormat, glWavePosition);

    BeginWaveEdit();

    /* get the current wave position */
    lTime = wfSamplesToTime(gpWaveFormat, glWavePosition);
    if (gfLZero || ((int)(lTime/1000) != 0))             // ??? casts ???
        wsprintf(ach, aszSamplesFormat, (int)(lTime/1000), chDecimal, (int)((lTime/10)%100));
    else
        wsprintf(ach, aszSamplesNoZeroFormat, chDecimal, (int)((lTime/10)%100));

    /* prompt user for permission */

    id = ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OKCANCEL,
            IDS_APPTITLE, IDS_DELAFTERWARN, (LPTSTR) ach);

    if (id != IDOK)
        return;

    /* reallocate the buffer to be <glWavePosition> samples in size */
    AllocWaveBuffer(glWavePosition, TRUE, TRUE);

    EndWaveEdit(TRUE);

    /* update the display */
    UpdateDisplay(TRUE);
} /* DeleteAfter */


/* ChangeVolume(fIncrease)
 *
 * Increase the volume (if <fIncrease> is TRUE) or decrease the volume
 * (if <fIncrease> is FALSE) of samples in the wave buffer by CHVOL_DELTAVOLUME
 * percent.
 */
void FAR PASCAL
ChangeVolume(BOOL fIncrease)
{
    HPBYTE          pch = gpWaveSamples; // ptr. into waveform buffer
    long            lSamples;       // samples to modify
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    int             iFactor;        // amount to multiply amplitude by
    short  *    pi = (short  *) gpWaveSamples;

    if (glWaveSamplesValid == 0L)           // nothing to do?
        return;                             // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    BeginWaveEdit();

    /* for stereo, just twice as many samples */
    lSamples = glWaveSamplesValid * gpWaveFormat->nChannels;

    iFactor = 100 + (fIncrease ? CHVOL_INCDELTAVOLUME : -CHVOL_DECDELTAVOLUME);
    if (((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8) {
        /* 8-bit: samples 0-255 */
        int     iTemp;
        while (lSamples-- > 0)
        {
            iTemp = ( ((short) *((BYTE  *) pch) - 128)
                    * iFactor
                    )
                    / 100 + 128;
            *((BYTE  *) pch++) = (BYTE)
                            (iTemp < 0 ? 0 : (iTemp > 255 ? 255 : iTemp));
        }
    } else {
        /* 16-bit: samples -32768 - 32767 */
        long            lTemp;
        while (lSamples-- > 0)
        {
            lTemp =  (((long) *pi) * iFactor) / 100;
            *(pi++) = (short) (lTemp < -32768L ? -32768 :
                                    (lTemp > 32767L ?
                                            32767 : (short) lTemp));
        }
    }

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}


/* MakeFaster()
 *
 * Make the sound play twice as fast.
 */
void FAR PASCAL
MakeFaster(void)
{
    HPBYTE          pchSrc;         // pointer into source part of buffer
    HPBYTE          pchDst;         // pointer into destination part
    short  *    piSrc;
    short  *    piDst;
    long            lSamplesDst;    // samples to copy into destination buffer
    HCURSOR         hcurPrev = NULL; // cursor before hourglass

    if (glWaveSamplesValid == 0L)           // nothing to do?
        return;                             // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    BeginWaveEdit();

    /* move the current position so it will correspond to the same point
     * in the audio before and after the change-pitch operation
     */
    glWavePosition /= 2L;

    /* delete every other sample */
    lSamplesDst = glWaveSamplesValid / 2L;
    if (((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8) {
        pchSrc = pchDst = gpWaveSamples;
        if (gpWaveFormat->nChannels == 1) {
            while (lSamplesDst-- > 0)
            {
                *pchDst++ = *pchSrc++;
                pchSrc++;
            }
        } else {
            while (lSamplesDst-- > 0)
            {
                *pchDst++ = *pchSrc++;
                *pchDst++ = *pchSrc++;
                pchSrc++;
                pchSrc++;
            }
        }
    } else {
        piSrc = piDst = (short  *) gpWaveSamples;
        if (gpWaveFormat->nChannels == 1) {
            while (lSamplesDst-- > 0)
            {
                *piDst++ = *piSrc++;
                piSrc++;
            }
        } else {
            while (lSamplesDst-- > 0)
            {
                *piDst++ = *piSrc++;
                *piDst++ = *piSrc++;
                piSrc++;
                piSrc++;
            }
        }
    }

    /* reallocate the WAVE buffer to be half as big enough */
//!!WinEval(AllocWaveBuffer(glWaveSamplesValid / 2L));
    AllocWaveBuffer(glWaveSamplesValid / 2L, TRUE, TRUE);

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
            SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}


/* MakeSlower()
 *
 * Make the sound play twice as slow.
 */
void FAR PASCAL
MakeSlower(void)
{
    HPBYTE          pchSrc;         // pointer into source part of buffer
    HPBYTE          pchDst;         // pointer into destination part
    short  *    piSrc;
    short  *    piDst;

    long            lSamplesSrc;    // samples to copy from source buffer
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    long            lPrevPosition;  // previous "current position"

    int             iSample;        // current source sample
    int             iPrevSample;    // previous sample (for interpolation)
    int             iSample2;
    int             iPrevSample2;

    long            lSample;
    long            lPrevSample;
    long            lSample2;
    long            lPrevSample2;

    if (glWaveSamplesValid == 0L)           // nothing to do?
        return;                             // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    BeginWaveEdit();

    /* reallocate the WAVE buffer to be twice as big */
    lPrevPosition = glWavePosition;
    if (!AllocWaveBuffer(glWaveSamplesValid * 2L, TRUE, TRUE))
        goto RETURN;

    /* each source sample generates two destination samples;
     * use interpolation to generate new samples; must go backwards
     * through the buffer to avoid destroying data
     */
    pchSrc = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid);
    pchDst = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid * 2L);
    lSamplesSrc = glWaveSamplesValid;

    if (((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8)
    {
        if (gpWaveFormat->nChannels == 1)
        {
            iPrevSample = *((BYTE  *) (pchSrc - 1));
            while (lSamplesSrc-- > 0)
            {
                pchSrc =  ((BYTE  *) pchSrc) - 1;
                iSample = *((BYTE  *) pchSrc);

                *--pchDst = (BYTE)((iSample + iPrevSample)/2);
                *--pchDst = (BYTE) iSample;
                iPrevSample = iSample;
            }
        }
        else
        {
            iPrevSample = *((BYTE  *) (pchSrc - 2));
            iPrevSample2 = *((BYTE  *) (pchSrc - 1));
            while (lSamplesSrc-- > 0)
            {
                pchSrc = ((BYTE  *) pchSrc)-1;
                iSample2 = *((BYTE  *) pchSrc);

                pchSrc = ((BYTE  *) pchSrc)-1;
                iSample = *((BYTE  *) pchSrc);

                *--pchDst = (BYTE)((iSample2 + iPrevSample2)
                                                        / 2);
                *--pchDst = (BYTE)((iSample + iPrevSample)
                                                        / 2);
                *--pchDst = (BYTE) iSample2;
                *--pchDst = (BYTE) iSample;
                iPrevSample = iSample;
                iPrevSample2 = iSample2;
            }
        }
    }
    else
    {
        piDst = (short  *) pchDst;
        piSrc = (short  *) pchSrc;

        if (gpWaveFormat->nChannels == 1)
        {
            lPrevSample = *(piSrc - 1);
            while (lSamplesSrc-- > 0)
            {
                lSample = *--piSrc;
                *--piDst = (short)((lSample + lPrevSample)/2);
                *--piDst = (short) lSample;
                lPrevSample = lSample;
            }
        }
        else
        {
            lPrevSample = *(piSrc - 2);
            lPrevSample2 = *(piSrc - 1);
            while (lSamplesSrc-- > 0)
            {
                lSample2 = *--piSrc;
                lSample = *--piSrc;
                *--piDst = (short)((lSample2 + lPrevSample2)/2);
                *--piDst = (short)((lSample + lPrevSample) / 2);
                *--piDst = (short) lSample2;
                *--piDst = (short) lSample;
                lPrevSample = lSample;
                lPrevSample2 = lSample2;
            }
        }
    }

    /* the entire buffer now contains valid samples */
    glWaveSamplesValid *= 2L;

    /* move the current position so it will correspond to the same point
     * in the audio before and after the change-pitch operation
     */
    glWavePosition = lPrevPosition * 2L;
//!!WinAssert(glWavePosition <= glWaveSamplesValid);

RETURN:
    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}


#if 0

/* pchNew = FindWave(pch, pchEnd, ppchWaveBuf)
 *
 * Assuming <pch> points within the wave buffer and <pchEnd> points past the
 * end of the buffer, find the beginning of the next "wave", i.e. the point
 * where the waveform starts rising (after it has fallen).
 *
 * <ppchWaveBuf> points to a pointer that points to a buffer that is filled
 * in with a copy of the wave.  The pointer <*ppchWaveBuf> is modified and
 * upon return will point past the end of the wave.
 */
HPBYTE NEAR PASCAL
FindWave(HPBYTE pch, HPBYTE pchEnd, NPBYTE *ppchWaveBuf)
{
    BYTE    bLowest = 255;
    BYTE    bHighest = 0;
    BYTE    bLowPoint;
    BYTE    bHighPoint;
    BYTE    bDelta;
    HPBYTE  pchWalk;
    BYTE    b;
#ifdef VERBOSEDEBUG
    NPBYTE  pchWaveBufInit = *ppchWaveBuf;
#endif

    if (pch == pchEnd)
            return pch;

    for (pchWalk = pch; pchWalk != pchEnd; pchWalk++)
    {
            b = *pchWalk;
            b = *((BYTE  *) pchWalk);
            if (bLowest > b)
                    bLowest = b;
            if (bHighest < b)
                    bHighest = b;
    }

    bDelta = (bHighest - bLowest) / FINDWAVE_PICKYNESS;
    bLowPoint = bLowest + bDelta;
    bHighPoint = bHighest - bDelta;
//!!WinAssert(bLowPoint >= bLowest);
//!!WinAssert(bHighPoint <= bHighest);
#ifdef VERBOSEDEBUG
    DPF(TEXT("0x%08lX: %3d to %3d"), (DWORD) pch,
            (int) bLowPoint, (int) bHighPoint);
#endif

    if (bLowPoint == bHighPoint)
    {
        /* avoid infinite loop */
        *(*ppchWaveBuf)++ = *((BYTE  *) pch++);
#ifdef VERBOSEDEBUG
        DPF(TEXT(" (equal)\n"));
#endif
        return pch;
    }

    /* find a "peak" */
    while ((pch != pchEnd) && (*((BYTE  *) pch) < bHighPoint))
        *(*ppchWaveBuf)++ = *((BYTE  *) pch++);

    /* find a "valley" */
    while ((pch != pchEnd) && (*((BYTE  *) pch) > bLowPoint))
        *(*ppchWaveBuf)++ = *((BYTE  *) pch++);

#ifdef VERBOSEDEBUG
    DPF(TEXT(" (copied %d)\n"), *ppchWaveBuf - pchWaveBufInit);
#endif

    return pch;
}

#endif


#if 0

/* IncreasePitch()
 *
 * Increase the pitch of samples in the wave buffer by one octave.
 */
void FAR PASCAL
IncreasePitch(void)
{
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    HPBYTE          pchEndFile;     // end of file's buffer
    HPBYTE          pchStartWave;   // start of one wave
    HPBYTE          pchMaxWave;     // last place where wave may end
    HPBYTE          pchEndWave;     // end an actual wave
    char            achWaveBuf[WAVEBUFSIZE];
    NPBYTE          pchWaveBuf;
    NPBYTE          pchSrc;
    HPBYTE          pchDst;

    if (glWaveSamplesValid == 0L)           // nothing to do?
        return;                             // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    BeginWaveEdit();

    /* find each wave in the wave buffer and double it */
    pchEndFile = gpWaveSamples + glWaveSamplesValid;
    pchStartWave = gpWaveSamples;
    while (TRUE)
    {
        pchMaxWave = pchStartWave + WAVEBUFSIZE;
        if (pchMaxWave > pchEndFile)
            pchMaxWave = pchEndFile;
        pchWaveBuf = achWaveBuf;
        pchEndWave = FindWave(pchStartWave, pchMaxWave, &pchWaveBuf);
        pchSrc = achWaveBuf;
        pchDst = pchStartWave;
        if (pchSrc == pchWaveBuf)
            break;                  // no samples copied

        while (pchDst != pchEndWave)
        {
            *pchDst++ = *pchSrc++;
            pchSrc++;
            if (pchSrc >= pchWaveBuf)
            {
                if (pchSrc == pchWaveBuf)
                    pchSrc = achWaveBuf;
                else
                    pchSrc = achWaveBuf + 1;
            }
        }

        pchStartWave = pchEndWave;
    }

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}

#endif


#if 0

/* DecreasePitch()
 *
 * Decrease the pitch of samples in the wave buffer by one octave.
 */
void FAR PASCAL
DecreasePitch(void)
{
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    HPBYTE          pchEndFile;     // end of file's buffer
    HPBYTE          pchStartWave;   // start of one wave
    HPBYTE          pchMaxWave;     // last place where wave may end
    HPBYTE          pchEndWave;     // end an actual wave
    char            achWaveBuf[WAVEBUFSIZE];
    NPBYTE          pchWaveBuf;     // end of first wave in <achWaveBuf>
    NPBYTE          pchSrc;         // place to read samples from
    NPBYTE          pchSrcEnd;      // end of place to read samples from
    int             iSample;        // current source sample
    int             iPrevSample;    // previous sample (for interpolation)
    HPBYTE          pchDst;         // where result gets put in buffer
    long            lNewFileSize;   // file size after pitch change

    if (glWaveSamplesValid == 0L)           // nothing to do?
        return;                             // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    BeginWaveEdit();

    /* find each pair of waves in the wave buffer, discard the longer
     * of the two waves, and expand the shorter of the two waves to
     * twice its size
     */
    pchEndFile = gpWaveSamples + glWaveSamplesValid;
    pchStartWave = gpWaveSamples;           // read waves from here
    pchDst = gpWaveSamples;                 // write waves to here
    while (TRUE)
    {
        pchMaxWave = pchStartWave + WAVEBUFSIZE;
        if (pchMaxWave > pchEndFile)
            pchMaxWave = pchEndFile;

        /* read one wave -- make <pchWaveBuf> point to the end
         * of the wave that's copied into <achWaveBuf>
         */
        pchWaveBuf = achWaveBuf;
        pchEndWave = FindWave(pchStartWave, pchMaxWave, &pchWaveBuf);
        if (pchWaveBuf == achWaveBuf)
            break;

        /* read another wave -- make <pchWaveBuf> now point to the end
         * of that wave that's copied into <achWaveBuf>
         */
        pchEndWave = FindWave(pchEndWave, pchMaxWave, &pchWaveBuf);

        pchSrc = achWaveBuf;
        pchSrcEnd = achWaveBuf + ((pchWaveBuf - achWaveBuf) / 2);
        iPrevSample = *((BYTE *) pchSrc);
        while (pchSrc != pchSrcEnd)
        {
            iSample = *((BYTE *) pchSrc)++;
            *pchDst++ = (BYTE) ((iSample + iPrevSample) / 2);
            *pchDst++ = iSample;
            iPrevSample = iSample;
        }

        pchStartWave = pchEndWave;
    }

    /* file may have shrunk */
    lNewFileSize = pchDst - gpWaveSamples;
//!!WinAssert(lNewFileSize <= glWaveSamplesValid);
#ifdef DEBUG
    DPF(TEXT("old file size is %ld, new size is %ld\n"),
                    glWaveSamplesValid, lNewFileSize);
#endif
    AllocWaveBuffer(lNewFileSize, TRUE, TRUE);

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}

#endif


/* AddEcho()
 *
 * Add echo to samples in the wave buffer.
 */
void FAR PASCAL
AddEcho(void)
{
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    long            lDeltaSamples;  // no. samples for echo delay
    long            lSamples;       // no. samples to modify
    int             iAmpSrc;        // current source sample amplitude
    int             iAmpDst;        // current destination sample amplitude

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    BeginWaveEdit();

    /* figure out how many samples need to be modified */
    lDeltaSamples = MulDiv((long) ECHO_DELAY,
                             gpWaveFormat->nSamplesPerSec, 1000L);

    /* Set lSamples to be number of samples * number of channels */
    lSamples = (glWaveSamplesValid - lDeltaSamples)
                            * gpWaveFormat->nChannels;

    if (lSamples <= 0L)             // nothing to do?
        return;                     // don't set dirty flag

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /* copy ECHO_VOLUME percent of each source sample (starting at
     * ECHO_DELAY milliseconds from the end of the the buffer)
     * to the each destination sample (starting at the end of the
     * buffer)
     */
    if (((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8)
    {
        HPBYTE  pchSrc;         // pointer into source part of buffer
        HPBYTE  pchDst;         // pointer into destination part
        int     iSample;        // destination sample

        pchSrc = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - lDeltaSamples);
        pchDst = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid);

        while (lSamples-- > 0)
        {
            pchSrc = ((BYTE  *) pchSrc) - 1;
            iAmpSrc = (int) *((BYTE  *) pchSrc) - 128;

            pchDst = ((BYTE  *) pchDst) - 1;
            iAmpDst = (int) *((BYTE  *) pchDst) - 128;

            iSample = iAmpDst + (iAmpSrc * ECHO_VOLUME) / 100
                                                            + 128;
            *((BYTE  *) pchDst) = (BYTE)
                    (iSample < 0 ? 0 : (iSample > 255
                                            ? 255 : iSample));
        }
    }
    else
    {
        short  *  piSrc;  // pointer into source part of buffer
        short  *  piDst;  // pointer into destination part
        long            lSample;// destination sample

        piSrc = (short  *) (gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - lDeltaSamples));
        piDst = (short  *) (gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid));

        while (lSamples-- > 0)
        {
            iAmpSrc = *--piSrc;
            iAmpDst = *--piDst;
            lSample = ((long) iAmpSrc * ECHO_VOLUME) / 100 + (long) iAmpDst;

            *piDst = (short) (lSample < -32768L
                            ? -32768 : (lSample > 32767L
                                    ? 32767 : (short) lSample));
        }
    }

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}


/* Reverse()
 *
 * Reverse samples in the wave buffer.
 */
void FAR PASCAL
Reverse(void)
{
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    HPBYTE          pchA, pchB;     // pointers into buffer
    short  *      piA;
    short  *      piB;
    long            lSamples;       // no. Samples to modify
    char            chTmp;          // for swapping
    int             iTmp;

    if (glWaveSamplesValid == 0L)   // nothing to do?
        return;                     // don't set dirty flag

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    BeginWaveEdit();

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    lSamples = glWaveSamplesValid / 2;

    if (((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8)
    {
        pchA = gpWaveSamples;
        if (gpWaveFormat->nChannels == 1)
        {
            pchB = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid);

            while (lSamples-- > 0)
            {
                chTmp = *pchA;
                *pchA++ = *--pchB;
                *pchB = chTmp;
            }
        }
        else
        {
            pchB = gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - 1);

            while (lSamples-- > 0)
            {
                chTmp = *pchA;
                *pchA = *pchB;
                *pchB = chTmp;
                chTmp = pchA[1];
                pchA[1] = pchB[1];
                pchB[1] = chTmp;
                pchA += 2;
                pchB -= 2;
            }
        }
    }
    else
    {
        piA = (short  *) gpWaveSamples;
        if (gpWaveFormat->nChannels == 1)
        {
            piB = (short  *) (gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid));

            while (lSamples-- > 0)
            {
                iTmp = *piA;
                *piA++ = *--piB;
                *piB = (short)iTmp;
            }
        }
        else
        {
            piB = (short  *) (gpWaveSamples + wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid - 1));

            while (lSamples-- > 0)
            {
                iTmp = *piA;
                *piA = *piB;
                *piB = (short)iTmp;
                iTmp = piA[1];
                piA[1] = piB[1];
                piB[1] = (short)iTmp;
                piA += 2;
                piB -= 2;
            }
        }
    }

    /* move the current position so it corresponds to the same point
     * in the audio as it did before the reverse operation
     */
    glWavePosition = glWaveSamplesValid - glWavePosition;

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
}

#if defined(REVERB)

/* AddReverb()
 *
 * Add reverberation to samples in the wave buffer.
 * Very similar to add echo, but instead of adding a single
 * shot we
 * 1. have multiple echoes
 * 2. Have feedback so that each echo also generates an echo
 *    Danger: Because some of the echo times are short, there
 *            is likely to be high correlation between the wave
 *            at the source and destination points.  In this case
 *            we don't get an echo at all, we get a resonance.
 *            The effect of a large hall DOES give resonances,
 *            but we should scatter them about to avoid making
 *            any sharp resonance.
 *            The first echo is also chosen to be long enough that
 *            its primary resonance will be below any normal speaking
 *            voice.  20mSec is 50Hz and an octave below bass range.
 *            Low levels of sound suffer badly from quantisation noise
 *            which can get quite bad.  For this reason it's probably
 *            better to have the multipliers as powers of 2.
 *
 *    Cheat:  The reverb does NOT extend the total time (no realloc (yet).
 *
 *    This takes a lot of compute - and is not really very much different
 *    in sound to AddEcho.  Conclusion -- NOT IN PRODUCT.
 *
 */
void FAR PASCAL
AddReverb(void)
{
    HCURSOR         hcurPrev = NULL; // cursor before hourglass
    long            lSamples;       // no. samples to modify
    int             iAmpSrc;        // current source sample amplitude
    int             iAmpDst;        // current destination sample amplitude
    int i;

    typedef struct
    {  long Offset;   // delay in samples
       long Delay;    // delay in mSec
       int  Vol;      // volume multiplier in units of 1/256
    }  ECHO;

#define CREVERB  3

    ECHO Reverb[CREVERB] = { 0,  18, 64
                           , 0,  64, 64
                           };

    if (!IsWaveFormatPCM(gpWaveFormat))
        return;

    BeginWaveEdit();

    /* Convert millisec figures into samples */
    for (i=0; i<CREVERB; ++i)
    {  Reverb[i].Offset = MulDiv( Reverb[i].Delay
                                  , gpWaveFormat->nSamplesPerSec
                                  , 1000L
                                  );

       // I think this could have the effect of putting the reverb
       // from one stereo channel onto the other one sometimes.
       // It's a feature!  (Fix is to make Offset always even)
    }

    if (lSamples <= 0L)             // nothing to do?
        return;                     // don't set dirty flag

    /* show hourglass cursor */
    hcurPrev = SetCursor(LoadCursor(NULL, IDC_WAIT));

    lSamples = glWaveSamplesValid * gpWaveFormat->nChannels;

    /* Work through the buffer left to right adding in the reverbs */
    if (((LPPCMWAVEFORMAT)gpWaveFormat)->wBitsPerSample == 8)
    {
        BYTE *  pbSrc;         // pointer into source part of buffer
        BYTE *  pbDst;         // pointer into destination part
        int     iSample;       // destination sample


        for (i=0; i<CREVERB; ++i)
        {   long cSamp; // loop counter
            int  Vol = Reverb[i].Vol;
            pbSrc = gpWaveSamples;
            pbDst = gpWaveSamples+Reverb[i].Offset; // but elsewhere if realloc
            cSamp = lSamples-Reverb[i].Offset;
            while (cSamp-- > 0)
            {
                iAmpSrc = (*pbSrc) - 128;
                iSample = *pbDst + MulDiv(iAmpSrc, Vol, 256);
                *pbDst = (iSample < 0 ? 0 : (iSample > 255 ? 255 : iSample));

                ++pbSrc;
                ++pbDst;
            }
        }
    }
    else
    {
        int short *     piSrc;  // pointer into source part of buffer
        int short *     piDst;  // pointer into destination part
        long            lSample;// destination sample

        piSrc = gpWaveSamples;
        piDst = gpWaveSamples;

        while (lSamples-- > 0)
        {
            iAmpSrc = *piSrc;
            for (i=0; i<CREVERB; ++i)
            {   int short * piD = piDst + Reverb[i].Offset;   // !!not win16
                lSample = *piD + MulDiv(iAmpSrc, Reverb[i].Vol, 256);
                *piDst = (short) ( lSample < -32768L
                                 ? -32768
                                 : (lSample > 32767L ? 32767 : (short) lSample)
                                 );
            }

            ++piSrc;
            ++piDst;
        }
    }

    EndWaveEdit(TRUE);

    if (hcurPrev != NULL)
        SetCursor(hcurPrev);

    /* update the display */
    UpdateDisplay(TRUE);
} /* AddReverb */
#endif //REVERB

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\fixreg.h ===
/*-----------------------------------------------------------------------------+
| FIXREG.H                                                                     |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    10-Aug-1994 Lauriegr Created.                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

/* Call this with the hwnd that you want a WM_BADREG message posted to
   It will check the registry.  No news is good news.
   It does the work on a separate thread, so this should return quickly.
*/
void BackgroundRegCheck(HWND hwnd);

/* Insert the good values into the registry
   Call this if you get a WM_BADREG back from BackgroundRegCheck.
*/
BOOL SetRegValues(void);

/*
 * Test if the app should ignore registry changes.
 */
BOOL IgnoreRegCheck(void);

/*
 * Fixup registry values to our known defaults.
 */
void FixReg(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\helpids.h ===
/* context sensitive help */
#define IDH_SOUNDREC_ICON       4303
#define IDH_SOUNDREC_SNDTITLE   4304
#define IDH_SOUNDREC_COPYRIGHT  4305
#define IDH_SOUNDREC_LENGTH     4306
#define IDH_SOUNDREC_SIZE       4307
#define IDH_SOUNDREC_AUDIO      4308
#define IDH_SOUNDREC_COMM_GROUPBOX  4309
#define IDH_SOUNDREC_FORMAT     4310
#define IDH_SOUNDREC_CONVERT    4311
#define IDH_SOUNDREC_SAVEFMT    4312
#define IDH_SOUNDREC_CHANGE     4313
                                      
/* menu help */
#define IDH_SOUNDREC_SNDRC_CS_FILE_NEW					4314
#define IDH_SOUNDREC_SNDRC_CS_FILE_OPEN					4315
#define IDH_SOUNDREC_SNDRC_CS_FILE_SAVE					4316
#define IDH_SOUNDREC_SNDRC_CS_FILE_SAVE_AS				4317
#define IDH_SOUNDREC_SNDRC_CS_FILE_REVERT				4318
#define IDH_SOUNDREC_SNDRC_CS_FILE_PROPERTIES				4319
#define IDH_SOUNDREC_SNDRC_CS_FILE_EXIT					4320
#define IDH_SOUNDREC_SNDRC_CS_EDIT_COPY					4321
#define IDH_SOUNDREC_SNDRC_CS_EDIT_PASTE_INSERT				4322
#define IDH_SOUNDREC_SNDRC_CS_EDIT_PASTE_MIX				4323
#define IDH_SOUNDREC_SNDRC_CS_EDIT_INSERT_FILE				4324
#define IDH_SOUNDREC_SNDRC_CS_EDIT_MIX_WITH_FILE			4325
#define IDH_SOUNDREC_SNDRC_CS_EDIT_DELETE_BEFORE_CURRENT_POSITION	4326
#define IDH_SOUNDREC_SNDRC_CS_EDIT_DELETE_AFTER_CURRENT_POSITION	4327
#define IDH_SOUNDREC_SNDRC_CS_EDIT_AUDIO_PROPERTIES			4328
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_INCREASE_VOLUME			4329
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_DECREASE_VOLUME			4330
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_INCREASE_SPEED			4331
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_DECREASE_SPEED			4332
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_ADD_ECHO				4333
#define IDH_SOUNDREC_SNDRC_CS_EFFECTS_REVERSE				4334
#define IDH_SOUNDREC_SNDRC_CS_HELP_HELP_TOPICS				4335
#define IDH_SOUNDREC_SNDRC_CS_HELP_ABOUT				4336
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\nftext.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* Revision History.
   4/2/91 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
*/
/* nftext.c
 *
 * Implements the no-flicker static text control ("td_nftext").
 *
 * This is NOT a general-purpose control (see the globals below).
 *
 * Note: most NoFlickerText controls use ANSI_VAR_FONT, but the status
 * control (ID_STATUSTXT) uses the font defined in the dialog box
 * template (e.g. Helv8).  Also, the foreground color of most NoFlickerText
 * controls is RGB_FGNFTEXT, but the foreground color of the status control
 * is whatever the current value of <grgbStatusColor> is.
 *
 * Borrowed from ToddLa (with many, many modifications).
 */

#include "nocrap.h"
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>
#include "soundrec.h"



/* statics */
HFONT       ghfontDialog = NULL;        // font of dialog box

void NEAR PASCAL
NFTextPaint(HWND hwnd, HDC hdc)
{
    RECT        rc;
    TCHAR      ach[128];
    int     iLen;
    long        lStyle;
    int     xOrigin;

    GetClientRect(hwnd, &rc);
    iLen = GetWindowText(hwnd, ach, SIZEOF(ach));

    SetTextColor(hdc, grgbStatusColor);
    SelectObject(hdc, ghfontDialog);

    SetBkColor(hdc, RGB_BGNFTEXT);

    lStyle = GetWindowLong(hwnd, GWL_STYLE);
    {
        SIZE size;
        if (lStyle & SS_RIGHT)
        {   GetTextExtentPoint(hdc, ach, iLen, &size);
            xOrigin = rc.right - size.cx;
        }
        else
        if (lStyle & SS_CENTER)
        {   GetTextExtentPoint(hdc, ach, iLen, &size);
            xOrigin = (rc.right - size.cx) / 2;
        }
        else
            xOrigin = 0;
    }


    ExtTextOut(hdc, xOrigin, 0, ETO_OPAQUE,
           &rc, ach, iLen, NULL);
}

INT_PTR CALLBACK
NFTextWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC     hdc;

    switch (wMsg)
    {

    case WM_SETTEXT:

        DefWindowProc(hwnd, wMsg, wParam, lParam);
        hdc = GetDC(hwnd);
        if (hdc)
        {
            NFTextPaint(hwnd, hdc);
            ReleaseDC(hwnd, hdc);
        }
        return 0L;

    case WM_SETFONT:

        ghfontDialog = (HFONT)wParam;
        return 0L;

    case WM_ERASEBKGND:

        return 0L;

    case WM_PAINT:

        BeginPaint(hwnd, &ps);
        NFTextPaint(hwnd, ps.hdc);
        EndPaint(hwnd, &ps);
        return 0L;
    }

    return DefWindowProc(hwnd, wMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\nocrap.h ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
// #define NOVIRTUALKEYCODES    // VK_*
#define NOICONS         // IDI_*
#define NOKEYSTATES     // MK_*
// #define NOSYSCOMMANDS    // SC_*
#define OEMRESOURCE     // OEM Resource values
// #define NOATOM       // Atom Manager routines
// #define NOCLIPBOARD      // Clipboard routines
// #define NOCTLMGR     // Control and Dialog routines
#define NODRAWTEXT      // DrawText() and DT_*
#define NOMETAFILE      // typedef METAFILEPICT
// #define NOMSG        // typedef MSG and associated routines
#define NOSOUND         // Sound driver routines
#define NOWH            // SetWindowsHook and WH_*
#define NOCOMM          // COMM driver routines
#define NOKANJI         // Kanji support stuff.
// #define NOHELP       // Help engine interface.
#define NOPROFILER      // Profiler interface.
#define NODEFERWINDOWPOS    // DeferWindowPos routines
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\oleglue.h ===
//
// FILE:    oleglue.h
//
// NOTES:   All OLE-related outbound references from SoundRecorder
//
#include <ole2.h>


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#if DBG
#define DOUT(t)    OutputDebugString(t)
#define DOUTR(t)   OutputDebugString(t TEXT("\n"))
#else // !DBG
#define DOUT(t)
#define DOUTR(t)
#endif
    
extern DWORD dwOleBuildVersion;
extern BOOL gfOleInitialized;

extern BOOL gfStandalone;
extern BOOL gfEmbedded;
extern BOOL gfLinked;

extern BOOL gfTerminating;

extern BOOL gfUserClose;
extern HWND ghwndApp;
extern HICON ghiconApp;

extern BOOL gfClosing;

extern BOOL gfHideAfterPlaying;
extern BOOL gfShowWhilePlaying;
extern BOOL gfDirty;

extern int giExtWidth;
extern int giExtHeight;

#define CTC_RENDER_EVERYTHING       0   // render all data
#define CTC_RENDER_ONDEMAND         1   // render cfNative and CF_WAVE as NULL
#define CTC_RENDER_LINK             2   // render all data, except cfNative

extern TCHAR gachLinkFilename[_MAX_PATH];

/*
 * from srfact.cxx
 */
extern HRESULT ReleaseSRClassFactory(void);
extern BOOL CreateSRClassFactory(HINSTANCE hinst,BOOL fEmbedded);

extern BOOL InitializeSRS(HINSTANCE hInst);
extern void FlagEmbeddedObject(BOOL flag);

extern void DoOleClose(BOOL fSave);
extern void DoOleSave(void);
extern void TerminateServer(void);
extern void FlushOleClipboard(void);
extern void AdviseDataChange(void);
extern void AdviseRename(LPTSTR lpname);
extern void AdviseSaved(void);
extern void AdviseClosed(void);

extern HANDLE GetNativeData(void);
extern LPBYTE PutNativeData(LPBYTE lpbData, DWORD dwSize);

extern BOOL FileLoad(LPCTSTR lpFileName);
extern void BuildUniqueLinkName(void);

/* in srfact.cxx */
extern BOOL CreateStandaloneObject(void);

/* new clipboard stuff */
extern BOOL gfXBagOnClipboard;
extern void TransferToClipboard(void);

/* access to current server state data */
extern HANDLE GetPicture(void);
extern HBITMAP GetBitmap(void);
extern HANDLE GetDIB(HANDLE);

/* link helpers */
extern BOOL IsDocUntitled(void);

/* menu fixup */
extern void FixMenus(void);

/* Play sound */
extern void AppPlay(BOOL fClose);

/* Get Host names */
extern void OleObjGetHostNames(LPTSTR *ppCntr, LPTSTR *ppObj);

/* Ole initialization */
extern BOOL InitializeOle(HINSTANCE hInst);

extern void WriteObjectIfEmpty(void);

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\init.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* init.c
 *
 * init (discardable) utility functions.
 */
/* Revision History.
 *  4/2/91    LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 * 22/Feb/94  LaurieGr merged Motown and Daytona versions
 */

#include <windows.h>
#include <mmsystem.h>
#include <shellapi.h>
#include <mmreg.h>
#include <winnls.h>
#include <tchar.h>

#define INCLUDE_OLESTUBS
#include "soundrec.h"
#include "srecids.h"
#include "reg.h"

#define NOMENUHELP
#define NODRAGLIST
#ifdef USE_MMCNTRLS
#include "mmcntrls.h"
#else
#include <commctrl.h>
#include "buttons.h"
#endif

/* globals */
TCHAR    gachAppName[12];    // 8-character name
TCHAR    gachAppTitle[30];   // full name
TCHAR    gachHelpFile[20];   // name of help file
TCHAR    gachHtmlHelpFile[20];   // name of help file
TCHAR    gachDefFileExt[10]; // default file extension

HBRUSH   ghbrPanel = NULL;   // color of main window
HANDLE   ghAccel;
TCHAR    aszNull[2];
TCHAR    aszUntitled[32];    // Untitled string resource
TCHAR    aszFilter[64];      // Common Dialog file list filter
#ifdef FAKEITEMNAMEFORLINK
TCHAR    aszFakeItemName[16];    // Wave
#endif
TCHAR    aszPositionFormat[32];
TCHAR    aszNoZeroPositionFormat[32];

extern UINT     guWaveHdrs ;            // 1/2 second of buffering?
extern DWORD    gdwBufferDeltaMSecs ;   // # msecs added to end on record
extern UINT     gwMSecsPerBuffer;       // 1/8 second. initialised in this file

extern BITMAPBTN tbPlaybar[];

static  SZCODE aszDecimal[] = TEXT("sDecimal");
static  SZCODE aszLZero[] = TEXT("iLzero");
static  SZCODE aszWaveClass[] = TEXT("wavedisplay");
static  SZCODE aszNoFlickerClass[] = TEXT("noflickertext");
static  SZCODE aszShadowClass[] = TEXT("shadowframe");

static  SZCODE aszBufferDeltaSeconds[]  = TEXT("BufferDeltaSeconds");
static  SZCODE aszNumAsyncWaveHeaders[] = TEXT("NumAsyncWaveHeaders");
static  SZCODE aszMSecsPerAsyncBuffer[] = TEXT("MSecsPerAsyncBuffer");


/* FixupNulls(chNull, p)
 *
 * To facilitate localization, we take a localized string with non-NULL
 * NULL substitutes and replacement with a real NULL.
 */
 
void NEAR PASCAL FixupNulls(
    TCHAR chNull,
    LPTSTR p)
{
    while (*p) {
        if (*p == chNull)
            *p++ = 0;
        else
            p = CharNext(p);
    }
} /* FixupNulls */

/* AppInit(hInst, hPrev)
 *
 * This is called when the application is first loaded into memory.
 * It performs all initialization that doesn't need to be done once
 * per instance.
 */
BOOL PASCAL AppInit(
    HINSTANCE      hInst,      // instance handle of current instance
    HINSTANCE      hPrev)      // instance handle of previous instance
{
#ifdef OLE1_REGRESS        
    TCHAR       aszClipFormat[32];
#endif    
    WNDCLASS    cls;
    UINT            i;

    /* load strings */
    LoadString(hInst, IDS_APPNAME, gachAppName, SIZEOF(gachAppName));
    LoadString(hInst, IDS_APPTITLE, gachAppTitle, SIZEOF(gachAppTitle));
    LoadString(hInst, IDS_HELPFILE, gachHelpFile, SIZEOF(gachHelpFile));
    LoadString(hInst, IDS_HTMLHELPFILE, gachHtmlHelpFile, SIZEOF(gachHtmlHelpFile));
    LoadString(hInst, IDS_UNTITLED, aszUntitled, SIZEOF(aszUntitled));
    LoadString(hInst, IDS_FILTER, aszFilter, SIZEOF(aszFilter));
    LoadString(hInst, IDS_FILTERNULL, aszNull, SIZEOF(aszNull));
    LoadString(hInst, IDS_DEFFILEEXT, gachDefFileExt, SIZEOF(gachDefFileExt));
    FixupNulls(*aszNull, aszFilter);

#ifdef FAKEITEMNAMEFORLINK
    LoadString(hInst, IDS_FAKEITEMNAME, aszFakeItemName, SIZEOF(aszFakeItemName));
#endif
    LoadString(hInst, IDS_POSITIONFORMAT, aszPositionFormat, SIZEOF(aszPositionFormat));
    LoadString(hInst, IDS_NOZEROPOSITIONFORMAT, aszNoZeroPositionFormat, SIZEOF(aszNoZeroPositionFormat));

    ghiconApp = LoadIcon(hInst, MAKEINTRESOURCE(IDI_APP));


#ifdef OLE1_REGRESS
    /* Initialize OLE server stuff */
    InitVTbls();
    
//    IDS_OBJECTLINK          "ObjectLink"
//    IDS_OWNERLINK           "OwnerLink"
//    IDS_NATIVE              "Native"
    LoadString(hInst, IDS_OBJECTLINK, aszClipFormat, SIZEOF(aszClipFormat));
    cfLink      = (OLECLIPFORMAT)RegisterClipboardFormat(aszClipFormat);
    LoadString(hInst, IDS_OWNERLINK, aszClipFormat, SIZEOF(aszClipFormat));
    cfOwnerLink = (OLECLIPFORMAT)RegisterClipboardFormat(aszClipFormat);
    LoadString(hInst, IDS_NATIVE, aszClipFormat, SIZEOF(aszClipFormat));
    cfNative    = (OLECLIPFORMAT)RegisterClipboardFormat(aszClipFormat);
#if 0
    cfLink      = (OLECLIPFORMAT)RegisterClipboardFormatA("ObjectLink");
    cfOwnerLink = (OLECLIPFORMAT)RegisterClipboardFormatA("OwnerLink");
    cfNative    = (OLECLIPFORMAT)RegisterClipboardFormatA("Native");
#endif
            
#endif
    
#ifdef DEBUG
    
    ReadRegistryData(NULL
                     , TEXT("Debug")
                     , NULL
                     , (LPBYTE)&__iDebugLevel
                     , (DWORD)sizeof(__iDebugLevel));
    
    DPF(TEXT("Debug level = %d\n"),__iDebugLevel);
    
#endif

    ghbrPanel = CreateSolidBrush(RGB_PANEL);

    if (hPrev == NULL)
    {
        /* register the "wavedisplay" window class */
        cls.lpszClassName  = aszWaveClass;
        cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = WaveDisplayWndProc;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = 0;
        if (!RegisterClass(&cls))
            return FALSE;

        /* register the "noflickertext" window class */
        cls.lpszClassName  = aszNoFlickerClass;
        cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = NFTextWndProc;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = 0;
        if (!RegisterClass(&cls))
            return FALSE;

        /* register the "shadowframe" window class */
        cls.lpszClassName  = aszShadowClass;
        cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
        cls.hIcon          = NULL;
        cls.lpszMenuName   = NULL;
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = SFrameWndProc;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = 0;
        if (!RegisterClass(&cls))
            return FALSE;

        /* register the dialog's window class */
        cls.lpszClassName  = gachAppName;
        cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
        cls.hIcon          = ghiconApp;
        cls.lpszMenuName   = NULL;
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_HREDRAW | CS_VREDRAW;
        cls.lpfnWndProc    = DefDlgProc;
        cls.cbClsExtra     = 0;
        cls.cbWndExtra     = DLGWINDOWEXTRA;
        if (!RegisterClass(&cls))
            return FALSE;

    }

#ifdef USE_MMCNTRLS
    if (!InitTrackBar(hPrev))
        return FALSE;
#else
    InitCommonControls();
#endif    

    if (!(ghAccel = LoadAccelerators(hInst, gachAppName)))
        return FALSE;


    i = DEF_BUFFERDELTASECONDS;
    ReadRegistryData(NULL
                     , (LPTSTR)aszBufferDeltaSeconds
                     , NULL
                     , (LPBYTE)&i
                     , (DWORD)sizeof(i));
    
    if (i > MAX_DELTASECONDS)
        i = MAX_DELTASECONDS;
    else if (i < MIN_DELTASECONDS)
        i = MIN_DELTASECONDS;
    gdwBufferDeltaMSecs = i * 1000L;
    DPF(TEXT("gdwBufferDeltaMSecs=%lu\n"), gdwBufferDeltaMSecs);

    //
    //  because it really doesn't help in standard mode to stream with
    //  multiple wave headers (we sorta assume we having a paging device
    //  to make things work...), we just revert to one big buffer in
    //  standard mode...  might want to check if paging is enabled??
    //
    //  in any case, this helps a LOT when running KRNL286-->the thing
    //  is buggy and GP faults when lots of discarding, etc
    //  is going on... like when dealing with large sound objects, eh?
    //
    i = DEF_NUMASYNCWAVEHEADERS;
    ReadRegistryData(NULL
                     , (LPTSTR)aszNumAsyncWaveHeaders
                     , NULL
                     , (LPBYTE)&i
                     , (DWORD)sizeof(i));
    
    if (i > MAX_WAVEHDRS)
        i = MAX_WAVEHDRS;
    else if (i < MIN_WAVEHDRS)
        i = 1;
    guWaveHdrs = i;
                 
    DPF(TEXT("         guWaveHdrs=%u\n"), guWaveHdrs);
    
    i = DEF_MSECSPERASYNCBUFFER;
    ReadRegistryData(NULL
                     , (LPTSTR)aszMSecsPerAsyncBuffer
                     , NULL
                     , (LPBYTE)&i
                     , (DWORD)sizeof(i));
    
    if (i > MAX_MSECSPERBUFFER)
        i = MAX_MSECSPERBUFFER;
    else if (i < MIN_MSECSPERBUFFER)
        i = MIN_MSECSPERBUFFER;
    gwMSecsPerBuffer = i;
    
    DPF(TEXT("   gwMSecsPerBuffer=%u\n"), gwMSecsPerBuffer);

    return TRUE;
} /* AppInit */



/*
 * */
void DoOpenFile(void)
{

    LPTSTR lpCmdLine = GetCommandLine();
    
    /* increment pointer past the argv[0] */
    while ( *lpCmdLine && *lpCmdLine != TEXT(' '))
            lpCmdLine = CharNext(lpCmdLine);
    
    if( gfLinked )
    {
         FileOpen(gachLinkFilename);
    }
    else if (!gfEmbedded)
    {
         // skip blanks
         while (*lpCmdLine == TEXT(' '))
         {
             lpCmdLine++;
             continue;
         }
         if(*lpCmdLine)
         {
             ResolveIfLink(lpCmdLine);
             FileOpen(lpCmdLine);             
         }
    }
}


/*
 * Dialog box initialization
 * */
BOOL PASCAL SoundDialogInit(
    HWND        hwnd,
    int         iCmdShow)
{
    /* make the window handle global */
    ghwndApp = hwnd;

    DragAcceptFiles(ghwndApp, TRUE); /* Process dragged and dropped file */

    GetIntlSpecs();

    /* Hide the window unless we want to display it later */
    ShowWindow(ghwndApp,SW_HIDE);

    /* remember the window handles of the important controls */
    ghwndWaveDisplay = GetDlgItem(hwnd, ID_WAVEDISPLAY);
    ghwndScroll = GetDlgItem(hwnd, ID_CURPOSSCRL);
    ghwndPlay = GetDlgItem(hwnd, ID_PLAYBTN);
    ghwndStop = GetDlgItem(hwnd, ID_STOPBTN);
    ghwndRecord = GetDlgItem(hwnd, ID_RECORDBTN);
    ghwndForward = GetDlgItem(hwnd, ID_FORWARDBTN);
    ghwndRewind = GetDlgItem(hwnd, ID_REWINDBTN);

#ifdef THRESHOLD
    ghwndSkipStart = GetDlgItem(hwnd, ID_SKIPSTARTBTN);
    ghwndSkipEnd = GetDlgItem(hwnd, ID_SKIPENDBTN);
#endif //THRESHOLD

    /* set up scroll bar */
    // SetScrollRange(ghwndScroll, SB_CTL, 0, SCROLL_RANGE, TRUE);
    SendMessage(ghwndScroll,TBM_SETRANGEMIN, 0, 0);
    SendMessage(ghwndScroll,TBM_SETRANGEMAX, 0, SCROLL_RANGE);
    SendMessage(ghwndScroll,TBM_SETPOS, TRUE, 0);

    /* Set up the bitmap buttons */
    BtnCreateBitmapButtons( hwnd,
                            (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE),
                            IDR_PLAYBAR,
                            BBS_TOOLTIPS,
                            tbPlaybar,
                            NUM_OF_BUTTONS,
                            25,
                            17);
    //
    // OLE2 and command line initialization...
    //
    InitializeSRS(ghInst);
    gfRunWithEmbeddingFlag = gfEmbedded;

    //
    // Try and init ACM
    //
    LoadACM();      
    
    //
    // build the File.New menu 
    //

    //
    // create a blank document
    //
    if (!FileNew(FMT_DEFAULT, TRUE, FALSE))
    {
        PostMessage(hwnd, WM_CLOSE, 0, 0);
        return TRUE;        
    }

    //
    // Note, FileNew/FileOpen has the side effect of releasing the
    // server when called by the user.  For now, do it here.  In the future
    // Wrapping these calls would suffice.
    //
    FlagEmbeddedObject(gfEmbedded);

    //
    // open a file if requested on command line
    //

    //
    // Execute command line verbs here.
    //
    
// Would be nicer just to execute methods that are likewise exportable
// through an OLE interface.
    
    if (gStartParams.fNew)
    {
        //
        // Behavior: If there is a filename specified, create it and
        // commit it so we have a named, empty document.  Otherwise, we
        // start in a normal new state.
        //
        
//TODO: Implement checkbox to set-as default format and not bring up
//TODO: the format selection dialog box.
                
        FileNew(FMT_DEFAULT,TRUE,TRUE);
        if (gStartParams.achOpenFilename[0] != 0)
        {
            lstrcpy(gachFileName, gStartParams.achOpenFilename);
            FileSave(FALSE);
        }
        //
        // Behaviour: If -close was specified, all we do is exit.
        //
        if (gStartParams.fClose)
            PostMessage(hwnd,WM_CLOSE,0,0);
    }
    else if (gStartParams.fPlay)
    {
        /* Behavior: If there is a file, just open it.  If not, ask for the
         * filename.  Then queue up a play request.
         * If -close was specified, then when the play is done the application
         * will exit. (see wave.c:YieldStop())
         */
        if (gStartParams.achOpenFilename[0] != 0)
            FileOpen(gStartParams.achOpenFilename);
        else
            FileOpen(NULL);
        AppPlay(gStartParams.fPlay && gStartParams.fClose);
    }
    else 
    {
        /* case: Both linked and standalone "open" cases are handled
         * here.  The only unusual case is if -open was specified without
         * a filename, meaning the user should be asked for a filename
         * first upon app start.
         *
         * Behaviour: -open and -close has no meaning, unless as a
         * verification (i.e. is this a valid wave file).  So this
         * isn't implemented.
         */
        if (gStartParams.achOpenFilename[0] != 0)
            FileOpen(gStartParams.achOpenFilename);
        else if (gStartParams.fOpen)
            FileOpen(NULL);
    }
    
    if (!gfRunWithEmbeddingFlag) {
        ShowWindow(ghwndApp,iCmdShow);

        /* set focus to "Record" if the file is empty, "Play" if not */
        if (glWaveSamplesValid == 0 && IsWindowEnabled(ghwndRecord))
            SetDlgFocus(ghwndRecord);
        else if (glWaveSamplesValid > 0 && IsWindowEnabled(ghwndPlay))
            SetDlgFocus(ghwndPlay);
        else
            SetDlgFocus(ghwndScroll);

        if (!waveInGetNumDevs() && !waveOutGetNumDevs()) {
            /* No recording or playback devices */
            ErrorResBox(hwnd, ghInst, MB_ICONHAND | MB_OK,
                            IDS_APPTITLE, IDS_NOWAVEFORMS);
        }

        return FALSE;   // FALSE because we set the focus above
    }
    //
    //  return FALSE, so the dialog manager will not activate us, it is
    //  ok because we are hidden anyway
    //
    return FALSE;
    
} /* SoundDialogInit */


/*
 * localisation stuff - decimal point delimiter etc
 * */
BOOL FAR PASCAL
GetIntlSpecs()
{
    TCHAR szTmp[5];

    // find decimal seperator
    szTmp[0] = chDecimal;
    szTmp[1] = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT
                  , LOCALE_SDECIMAL
                  , szTmp
                  , SIZEOF(szTmp));
    chDecimal = szTmp[0];

    // leading zeros
    szTmp[0] = TEXT('1');
    szTmp[1] = 0;
    GetLocaleInfo(LOCALE_USER_DEFAULT
                  , LOCALE_ILZERO
                  , szTmp
                  , SIZEOF(szTmp));
    gfLZero = _ttoi(szTmp);

    szTmp[0] = TEXT('0');
    LoadString(ghInst, IDS_RTLENABLED, szTmp, SIZEOF(szTmp));
    gfIsRTL = (szTmp[0] != TEXT('0'));

    return TRUE;
} /* GetIntlSpecs */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\fixreg.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/*-----------------------------------------------------------------------------+
| FIXREG.C                                                                     |
|                                                                              |
| Publisher and Video For Windows make evil changes to the registry            |
| when they are installed.  Look for these changes.  If they are spotted       |
| then put up a message box to warn the user and offer the user the chance to  |
| correct them (i.e. stuff our version back in)                                |
|                                                                              |
| (C) Copyright Microsoft Corporation 1994.  All rights reserved.              |
|                                                                              |
| Revision History                                                             |
|    10-Aug-1994 Lauriegr Created.                                             |
|                                                                              |
+-----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <soundrec.h>
#include <reg.h>
#include <fixreg.h>
#include <string.h>
#include <tchar.h>

#define RC_INVOKED
#include <o2base.hxx>
#include <srs.hxx>
#undef RC_INVOKED


/* The idea is to call CheckRegValues(hinst) on a separate thread
   (sort of backgroundy thing) and have it just die
   quietly if there's no problem.  If on the other hand there is a problem
   then we need to get the message box up - and it's a VERY BAD IDEA to
   try to put a message box up on anything other than the thread that's doing
   all the UI (otherwise ScottLu will get you with a weasle word - guaranteed).

   So the background thread should PostMessage (Post, don't Send - more weasles)
   to the main thread a message to say "WM_BADREG".  The main thread should then
   wack up the dialog box by calling FixRegValues.

   Suggested coding in main thread:

       BackgroundRegCheck(hwndmain);

   in window proc for hwndmain:
       case WM_HEYUP:
           FixReg(hwndmain, title);
*/


/* These are the things we check up.

   First define them as static strings, since the compiler's not smart enough
   to spot common strings.

   NOTE - these values are NOT LOCALISED
*/
/* These are for Sound Recorder - Let's try to fix it all while we're here. */
TCHAR szSoundRec[]               = TEXT("SoundRec");
TCHAR szSoundRec_CLSID[]         = TEXT("SoundRec\\CLSID");
TCHAR szSROLE2GUID[]             = TEXT("{00020C01-0000-0000-C000-000000000046}");
TCHAR szSROLE1GUID[]             = TEXT("{0003000D-0000-0000-C000-000000000046}");
TCHAR szSRCLSID_OLE2GUID[]       = TEXT("CLSID\\{00020C01-0000-0000-C000-000000000046}");
TCHAR szSRStdExecute_Server[]    = TEXT("SoundRec\\protocol\\StdExecute\\server");
TCHAR szSR32[]                   = TEXT("sndrec32.exe");
TCHAR szSRStdFileEdit_Server[]   = TEXT("SoundRec\\protocol\\StdFileEditing\\server");
TCHAR szSRShell_Open_Command[]   = TEXT("SoundRec\\shell\\open\\command");
TCHAR szSR32Cmd[]                = TEXT("sndrec32.exe %1");
TCHAR szSRStdFileEdit_verb_0[]   = TEXT("SoundRec\\protocol\\StdFileEditing\\verb\\0");
TCHAR szSRStdFileEdit_verb_1[]   = TEXT("SoundRec\\protocol\\StdFileEditing\\verb\\1");
TCHAR szSRStdFileEdit_verb_2[]   = TEXT("SoundRec\\protocol\\StdFileEditing\\verb\\2");
TCHAR sz_Open[]                  = TEXT("&Open");

/* Array of registry value-data pairs to check:
 */
#define RES_STR_LEN 40  /* Should be enough as a maximum resource string. */
TCHAR szSound[RES_STR_LEN];      // IDS_CLASSROOT in resources
TCHAR sz_Play[RES_STR_LEN];      // IDS_PLAYVERB in resources
TCHAR sz_Edit[RES_STR_LEN];      // IDS_EDITVERB in resources

/*
 * Check for explicit equivalence.
 * These are absolutely necessary.
 */
LPTSTR RegValuesExplicit[] =
{
    szSoundRec,               szSound,          // Primary name for object
    szSoundRec_CLSID,         szSROLE2GUID,     // CLSID, very important
    szSRStdFileEdit_verb_0,   sz_Play,          // verb, very important
    szSRStdFileEdit_verb_1,   sz_Edit           // verb, very important
//    szSRCLSID_OLE2GUID,       szSound,        // not too important 
};

/*
 * Check for valid substring
 * These are OK if the substring exists, i.e:
 *
 * "ntsd.exe sndrec32.exe"
 *  or "sndrec32.exe /play" are OK.
 *
 * "qrecord.exe" is NOT ok.
 */
LPTSTR RegValuesSubstring[] =
{
    szSRStdExecute_Server,    szSR32,   szSR32,     
    szSRStdFileEdit_Server,   szSR32,   szSR32
//    szSRShell_Open_Command,   szSR32Cmd,szSR32    // user can change this
};

/*
 * Check that a REG_SZ value in the registry has the value that it should do
 * Return TRUE if it does, FALSE if it doesn't.
 */
BOOL CheckRegValue(HKEY RootKey, LPTSTR KeyName, LPTSTR ShouldBe, LPTSTR CouldBe)
{
    DWORD Type;
    TCHAR Data[100];
    DWORD cData = sizeof(Data);
    LONG lRet;
    HKEY hkey;


    if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                   , KeyName
                                   , 0  /* reserved */
                                   , KEY_QUERY_VALUE
                                   , &hkey
                                   )
       )
        return FALSE;  /* couldn't even open the key */


    lRet=RegQueryValueEx( hkey
                        , NULL /* ValueName */
                        , NULL  /* reserved */
                        , &Type
                        , (LPBYTE)Data
                        , &cData
                        );

    RegCloseKey(hkey);  /* no idea what to do if this fails */

    if (ERROR_SUCCESS!=lRet) return FALSE;  /* couldn't query it */

    /*  Data, cData and Type give the data, length and type */
    if (Type!=REG_SZ) return FALSE;
    //
    // if Data == ShouldBe, then lRet = 0
    //
    lRet = lstrcmp(Data, ShouldBe); /* capture lRet to make debug easier */
    if (lRet && CouldBe != NULL)
    {
        //
        // if Couldbe in Data, lRet = 0
        //
        lRet = (_tcsstr(Data, CouldBe) == NULL);
    }
    
    return 0==lRet;

} /* CheckRegValue */

#define ARRAY_SIZE(x)   (sizeof((x))/sizeof((x)[0]))

/* check the registry for anything evil.  Return TRUE if it's OK else FALSE */
BOOL CheckRegValues(void)
{
    HKEY HCL = HKEY_CLASSES_ROOT;  /* save typing! */
    DWORD i;
    
    if( !( LoadString( ghInst, IDS_USERTYPESHORT, szSound, SIZEOF(szSound) )
        && LoadString( ghInst, IDS_PLAYVERB, sz_Play, SIZEOF(sz_Play))
        && LoadString( ghInst, IDS_EDITVERB, sz_Edit, SIZEOF(sz_Edit) ) ) )
        /* If any of the strings fails to load, forget it:
         */
        return TRUE;

    for( i = 0; i < ARRAY_SIZE(RegValuesExplicit); i+=2 )
    {
        if( !CheckRegValue( HCL
                            , RegValuesExplicit[i]
                            , RegValuesExplicit[i+1]
                            , NULL ) )
            return FALSE;
    }
    for(i = 0; i < ARRAY_SIZE(RegValuesSubstring); i+=3)
    {
        if( !CheckRegValue( HCL
                            , RegValuesSubstring[i]
                            , RegValuesSubstring[i+1]
                            , RegValuesSubstring[i+2] ) )
            return FALSE;
    }

    return TRUE;

} /* CheckRegValues */


/* start this thread to get the registry checked out.
 * hwnd is typed as a LPVOID because that's what CreateThread wants.
 */
DWORD RegCheckThread(LPVOID hwnd)
{
   if (!CheckRegValues())
       PostMessage((HWND)hwnd, WM_BADREG, 0, 0);

   return 0;   /* end of thread! */
}


/* Call this with the hwnd that you want a WM_BADREG message posted to
 * It will check the registry.  No news is good news.
 * It does the work on a separate thread, so this should return quickly.
 */
void BackgroundRegCheck(HWND hwnd)
{
    HANDLE hThread;
    DWORD thid;
    hThread = CreateThread( NULL /* no special security */
                          , 0    /* default stack size */
                          , (LPTHREAD_START_ROUTINE)RegCheckThread
                          , (LPVOID)hwnd
                          , 0 /* start running at once */
                          , &thid
                          );
    if (hThread!=NULL) CloseHandle(hThread);  /* we don't need this any more */

    /* Else we're in some sort of trouble - dunno what to do.
       Can't think of an intelligible message to give to the user.
       Too bad.  Creep home quietly.
    */

} /* BackgroundRegCheck */


/* returns TRUE if it worked.  Dunno what to do if it didn't

*/
BOOL SetRegValue(HKEY RootKey, LPTSTR KeyName, LPTSTR ValueName, LPTSTR ShouldBe)
{
    HKEY hkey;

    if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                   , KeyName
                                   , 0  /* reserved */
                                   , KEY_SET_VALUE
                                   , &hkey
                                   )
       ) {
        /* Maybe the key has been DELETED - we've seen that */
        DWORD dwDisp;
        if (ERROR_SUCCESS!=RegCreateKeyEx( RootKey
                                         , KeyName
                                         , 0  /* reserved */
                                         , TEXT("") /* class */
                                         , REG_OPTION_NON_VOLATILE
                                         , KEY_SET_VALUE
                                         , NULL   /* SecurityAttributes */
                                         , &hkey
                                         , &dwDisp
                                       )
           ) /* well we're really in trouble */
           return FALSE;
        else /* So now it exists, but we now have to open it */
            if (ERROR_SUCCESS!=RegOpenKeyEx( RootKey
                                           , KeyName
                                           , 0  /* reserved */
                                           , KEY_SET_VALUE
                                           , &hkey
                                           )
               ) /* Give up */
                   return FALSE;

    }


    if (ERROR_SUCCESS!=RegSetValueEx( hkey
                                    , ValueName
                                    , 0  // reserved 
                                    , REG_SZ
                                    , (LPBYTE)ShouldBe
                                    , (lstrlen(ShouldBe)+1)*sizeof(TCHAR)  //BYTES
                                    )
       )
        return FALSE;    /* couldn't set it */

    if ( ERROR_SUCCESS!=RegCloseKey(hkey) )
        /* no idea what to do!*/   ;    // couldn't set it

    // I'm NOT calling RegFlushKey.  They'll get there eventually 

    return TRUE;

} /* SetRegValue */


/*
 * SetRegValues
 *  Update the registry with the correct values.  Return TRUE if everything
 *  succeeds
 * */
BOOL SetRegValues(void)
{
    HKEY HCL = HKEY_CLASSES_ROOT;  /* save typing! */
    DWORD i;

    for( i = 0; i < ARRAY_SIZE(RegValuesExplicit); i+=2 )
    {
        // Do another check to see whether this one needs changing,
        // to avoid gratuitous changes, and to avoid the slim chance
        // that an unnecessary SetRegValue might fail:
        //
        if( !CheckRegValue( HCL
                            , RegValuesExplicit[i]
                            , RegValuesExplicit[i+1]
                            , NULL ) )
        {
            if( !SetRegValue( HCL
                              , RegValuesExplicit[i]
                              , NULL
                              , RegValuesExplicit[i+1] ) )
                return FALSE;
        }
    }
    for( i = 0; i < ARRAY_SIZE(RegValuesSubstring); i+=3 )
    {
        // Do another check to see whether this one needs changing,
        // to avoid gratuitous changes, and to avoid the slim chance
        // that an unnecessary SetRegValue might fail:
        //
        if( !CheckRegValue( HCL
                            , RegValuesSubstring[i]
                            , RegValuesSubstring[i+1]
                            , RegValuesSubstring[i+2] ) )
        {
            if( !SetRegValue( HCL
                              , RegValuesSubstring[i]
                              , NULL
                              , RegValuesSubstring[i+1] ) )
                return FALSE;
        }
    }
    return TRUE;
} /* SetRegValues */

/*
 * FixReg
 * */
void FixReg(HWND hwnd)
{
    int r;

    // Error is confusing and can be caused simply by incomplete localization
    // (see bug # 34330). I removed the error so that we fix the registry
    // automatically and fixed this bug.
    r = IDYES;
//    r = ErrorResBox(hwnd
//                    , NULL
//                    , MB_ICONEXCLAMATION | MB_YESNO
//                    , IDS_APPTITLE
//                    , IDS_BADREG) ;
    switch (r)
    {
        case IDYES:
            if (!SetRegValues())
                ErrorResBox(ghwndApp
                            , ghInst
                            , MB_ICONEXCLAMATION | MB_OK
                            , IDS_APPTITLE
                            , IDS_FIXREGERROR
                            , FALSE );
            break;
        case IDNO:
        case IDCANCEL:
            /* else sneak away quietly */            
        default:
            break;
    }


}  /* FixReg */

const TCHAR aszOptionsSection[]  = TEXT("Options");
const TCHAR aszIgnoreRegistryCheck[]   = TEXT("Ignore Registry Check");
        
BOOL IgnoreRegCheck()
{
    DWORD fIgnore = 0L;
    
    ReadRegistryData((LPTSTR)aszOptionsSection
                     , (LPTSTR)aszIgnoreRegistryCheck
                     , NULL
                     , (LPBYTE)&fIgnore
                     , sizeof fIgnore);
    
    return (fIgnore != 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\oleglue.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
//
// FILE:    oleglue.c
//
// NOTES:   OLE-related outbound references from SoundRecorder
//

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <shellapi.h>
#include <objbase.h>

#define INCLUDE_OLESTUBS
#include "soundrec.h"
#include "srecids.h"

//
// GLOBALS
//

// should unify state variables and put globals into a single location

DWORD dwOleBuildVersion = 0;    // OLE library version number
BOOL gfOleInitialized = FALSE;  // did OleInitialize succeed?

BOOL gfStandalone = FALSE;      // status, are we a non-embedded object
BOOL gfEmbedded = FALSE;        // were we invoked with an -Embedding flag?
BOOL gfLinked = FALSE;          // are we a linked object?

BOOL gfTerminating = FALSE;     // has TerminateServer been called?

BOOL gfHideAfterPlaying = FALSE;
BOOL gfShowWhilePlaying = TRUE;
BOOL gfCloseAtEndOfPlay = FALSE;

TCHAR gachLinkFilename[_MAX_PATH];

BOOL gfClosing = FALSE;

int giExtWidth;                 // Metafile extent width
int giExtHeight;                // Metafile extent height

//
// Utility functions ported from old OLE1 code
//

/*
 *  DibFromBitmap()
 *
 *  Will create a global memory block in DIB format that represents the DDB
 *  passed in
 *
 */

#define WIDTHBYTES(i)     ((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

HANDLE FAR PASCAL DibFromBitmap(HBITMAP hbm, HPALETTE hpal, HANDLE hMem)
{
    BITMAP               bm;
    BITMAPINFOHEADER     bi;
    BITMAPINFOHEADER FAR *lpbi;
    DWORD                dw;
    HANDLE               hdib = NULL;
    HDC                  hdc;
    HPALETTE             hpalT;

    if (!hbm)
        return NULL;

    GetObject(hbm,sizeof(bm),&bm);

    bi.biSize               = sizeof(BITMAPINFOHEADER);
    bi.biWidth              = bm.bmWidth;
    bi.biHeight             = bm.bmHeight;
    bi.biPlanes             = 1;
    bi.biBitCount           = (bm.bmPlanes * bm.bmBitsPixel) > 8 ? 24 : 8;
    bi.biCompression        = BI_RGB;
    bi.biSizeImage          = (DWORD)WIDTHBYTES(bi.biWidth * bi.biBitCount) * bi.biHeight;
    bi.biXPelsPerMeter      = 0;
    bi.biYPelsPerMeter      = 0;
    bi.biClrUsed            = bi.biBitCount == 8 ? 256 : 0;
    bi.biClrImportant       = 0;

    dw  = bi.biSize + bi.biClrUsed * sizeof(RGBQUAD) + bi.biSizeImage;

    if (hMem && GlobalSize(hMem) != 0)
    {
        if (GlobalSize(hMem) < dw)
            return NULL;

        lpbi = GlobalLock(hMem);
    }
    else
        lpbi = GlobalAllocPtr(GHND | GMEM_DDESHARE, dw);

    if (!lpbi)
        return NULL;
        
    *lpbi = bi;

    hdc = CreateCompatibleDC(NULL);

    if (hdc)
    {
        if (hpal)
        {
            hpalT = SelectPalette(hdc,hpal,FALSE);
            RealizePalette(hdc);
        }

        GetDIBits(hdc, hbm, 0, (UINT)bi.biHeight,
            (LPBYTE)lpbi + (int)lpbi->biSize + (int)lpbi->biClrUsed * sizeof(RGBQUAD),
            (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

        if (hpal)
            SelectPalette(hdc,hpalT,FALSE);

        DeleteDC(hdc);
    }

    hdib = GlobalHandle(lpbi);
    GlobalUnlock(hdib);
    
    return hdib;
}

HANDLE GetDIB(HANDLE hMem)
{
    HPALETTE hpal = GetStockObject(DEFAULT_PALETTE);
    HBITMAP hbm = GetBitmap();
    HANDLE hDib = NULL;

    if (hbm && hpal)
    {
        hDib = DibFromBitmap(hbm,hpal,hMem);
        if (!hDib)
            DOUT(TEXT("DibFromBitmap failed!\r\n"));
    }
    
    if (hpal)
        DeleteObject(hpal);
    
    if (hbm)
        DeleteObject(hbm);
    
    return hDib;
}

HBITMAP
GetBitmap(void)
{
    HDC hdcmem = NULL;
    HDC hdc = NULL;
    HBITMAP hbitmap = NULL;
    HBITMAP holdbitmap = NULL;
    RECT rc;
    hdc = GetDC(ghwndApp);
    if (hdc)
    {
        SetRect(&rc, 0, 0,
                GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON));

        hdcmem = CreateCompatibleDC(hdc);
        if (hdcmem)
        {
            hbitmap = CreateCompatibleBitmap(hdc, rc.right, rc.bottom);
            holdbitmap = (HBITMAP)SelectObject(hdcmem, hbitmap);

            // paint directly into the bitmap
            PatBlt(hdcmem, 0, 0, rc.right, rc.bottom, WHITENESS);
            DrawIcon(hdcmem, 0, 0, ghiconApp);

            hbitmap = (HBITMAP)SelectObject(hdcmem, holdbitmap);
            DeleteDC(hdcmem);
        }
        ReleaseDC(ghwndApp, hdc);
    }
    return hbitmap;
}

#pragma message("this code should extract the picture from the file")

HANDLE
GetPicture(void)
{
    HANDLE hpict = NULL;
    HMETAFILE hMF = NULL;

    LPMETAFILEPICT lppict = NULL;
    HBITMAP hbmT = NULL;
    HDC hdcmem = NULL;
    HDC hdc = NULL;

    BITMAP bm;
    HBITMAP hbm;
    
    hbm = GetBitmap();
    
    if (hbm == NULL)
        return NULL;

    GetObject(hbm, sizeof(bm), (LPVOID)&bm);
    hdc = GetDC(ghwndApp);
    if (hdc)
    {
        hdcmem = CreateCompatibleDC(hdc);
        ReleaseDC(ghwndApp, hdc);
    }
    if (!hdcmem)
    {
        DeleteObject(hbm);
        return NULL;
    }
    hdc = CreateMetaFile(NULL);
    hbmT = (HBITMAP)SelectObject(hdcmem, hbm);

    SetWindowOrgEx(hdc, 0, 0, NULL);
    SetWindowExtEx(hdc, bm.bmWidth, bm.bmHeight, NULL);

    StretchBlt(hdc,    0, 0, bm.bmWidth, bm.bmHeight,
               hdcmem, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);

    hMF = CloseMetaFile(hdc);

    SelectObject(hdcmem, hbmT);
    DeleteObject(hbm);
    DeleteDC(hdcmem);

    lppict = (LPMETAFILEPICT)GlobalAllocPtr(GHND|GMEM_DDESHARE
                                            , sizeof(METAFILEPICT));
    if (!lppict)
    {
        if (hMF)
            DeleteMetaFile(hMF);
        return NULL;
    }
    
    hdc = GetDC(ghwndApp);
    lppict->mm   = MM_ANISOTROPIC;
    lppict->hMF  = hMF;
    lppict->xExt = MulDiv(bm.bmWidth,  2540, GetDeviceCaps(hdc, LOGPIXELSX));
    lppict->yExt = MulDiv(bm.bmHeight, 2540, GetDeviceCaps(hdc, LOGPIXELSX));
    
    giExtWidth = lppict->xExt;    
    giExtHeight = lppict->yExt;
    
    ReleaseDC(ghwndApp, hdc);

    hpict = GlobalHandle(lppict);
    GlobalUnlock(hpict);
    
    return hpict;
}

//
// Code ported from server.c (OLE1) for serialization...
//

HANDLE GetNativeData(void)
{
    LPBYTE      lplink = NULL;
    MMIOINFO    mmioinfo;
    HMMIO       hmmio;
    BOOL        fOk;

    lplink = (LPBYTE)GlobalAllocPtr(GHND | GMEM_SHARE, 4096L);

    if (lplink == NULL)
    {
#if DBG
        OutputDebugString(TEXT("GetNativeData: malloc failed\r\n"));
#endif        
        return NULL;
    }
    mmioinfo.fccIOProc  = FOURCC_MEM;
    mmioinfo.pIOProc    = NULL;
    mmioinfo.pchBuffer  = lplink;
    mmioinfo.cchBuffer  = 4096L;        // initial size
    mmioinfo.adwInfo[0] = 4096L;        // grow by this much
    hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READWRITE);

    if (hmmio == NULL)
    {
        GlobalFreePtr(lplink);
        return NULL;
    }

    fOk = WriteWaveFile(hmmio
                         , gpWaveFormat
                         , gcbWaveFormat
                         , gpWaveSamples
                         , glWaveSamplesValid);

    mmioGetInfo(hmmio, &mmioinfo, 0);
    mmioClose(hmmio,0);

    if (fOk)
    {
        //
        // Warning, the buffer we allocated may have been realloc'd
        //
        HANDLE hlink = GlobalHandle(mmioinfo.pchBuffer);
        GlobalUnlock(hlink);
        return hlink;
    }
    else
    {
        gfErrorBox++;
        ErrorResBox( ghwndApp
                   , ghInst
                   , MB_ICONEXCLAMATION | MB_OK
                   , IDS_APPTITLE
                   , IDS_ERROREMBED
                   );
#if DBG
        OutputDebugString(TEXT("Failed to WriteWaveFile\r\n"));
#endif
        gfErrorBox--;
        
        //
        // Warning, the buffer we allocated may have been realloc'd
        //
        if (mmioinfo.pchBuffer)
            GlobalFreePtr(mmioinfo.pchBuffer);
        
        return NULL;
    }
}

/*
 * Called from OLE storage code
 */
LPBYTE PutNativeData(LPBYTE lpbData, DWORD dwSize)
{
    MMIOINFO        mmioinfo;
    HMMIO           hmmio;

    MMRESULT        mmr;
    LPWAVEFORMATEX  pwfx;
    DWORD           cbwfx;
    DWORD           cbdata;
    LPBYTE          pdata;

    mmioinfo.fccIOProc = FOURCC_MEM;
    mmioinfo.pIOProc = NULL;
    mmioinfo.pchBuffer = lpbData;
    mmioinfo.cchBuffer = dwSize;    // initial size
    mmioinfo.adwInfo[0] = 0L;       // grow by this much

    hmmio = mmioOpen(NULL, &mmioinfo, MMIO_READ);
    if (hmmio)
    {
        mmr = ReadWaveFile(hmmio
                           , &pwfx
                           , &cbwfx
                           , &pdata
                           , &cbdata
                           , TEXT("NativeData")
                           , TRUE);
        
        mmioClose(hmmio,0);

        if (mmr != MMSYSERR_NOERROR)
            return NULL;
        
        if (pwfx == NULL)
            return NULL;
        
        DestroyWave();
        
        gpWaveFormat = pwfx;  
        gcbWaveFormat = cbwfx;
        gpWaveSamples = pdata;
        glWaveSamples = cbdata;
    }

    //
    // update state variables
    //
    glWaveSamplesValid = glWaveSamples;
    glWavePosition = 0L;
    gfDirty = FALSE;
    
    //
    // update the display
    //
    UpdateDisplay(TRUE);

    return (LPBYTE)gpWaveSamples;
}

/*
 * PERMANENT ENTRY POINTS
 */
BOOL ParseCommandLine(LPTSTR lpCommandLine);

/*
 * modifies gfEmbedded, initializes gStartParams
 */

BOOL InitializeSRS(HINSTANCE hInst)
{
    TCHAR * lptCmdLine = GetCommandLine();
    BOOL fOLE = FALSE, fServer;
    gfUserClose = FALSE;
    
    gachLinkFilename[0] = 0;

    fServer = ParseCommandLine(lptCmdLine);
    gfEmbedded = fServer;       // We are embedded or linked
    
    if (!fServer)
    {
        if (gStartParams.achOpenFilename[0] != 0)
        {
            lstrcpy(gachLinkFilename, gStartParams.achOpenFilename);
        }
    }

    //
    // Only if we are invoked as an embedded object do we initialize OLE.
    // Defer initialization for the standalone object until later.
    //
    if (gfEmbedded)
        fOLE = InitializeOle(hInst);
    
    return fOLE;
}

/* OLE initialization
 */
BOOL InitializeOle(HINSTANCE hInst)
{
    BOOL fOLE;

    DOUT(TEXT("SOUNDREC: Initializing OLE\r\n"));
    
    dwOleBuildVersion = OleBuildVersion();

    // Fix bug #33271
    // As stated in the docs:
    // Typically, the COM library is initialized on an apartment only once. 
    // Subsequent calls will succeed, as long as they do not attempt to change 
    // the concurrency model of the apartment, but will return S_FALSE. To close 
    // the COM library gracefully, each successful call to OleInitialize, 
    // including those that return S_FALSE, must be balanced by a corresponding 
    // call to OleUninitialize.
    // gfOleInitialized = (OleInitialize(NULL) == NOERROR) ? TRUE : FALSE;
    gfOleInitialized = SUCCEEDED(OleInitialize(NULL));

    if (gfOleInitialized)
        fOLE = CreateSRClassFactory(hInst, gfEmbedded);
    else
        fOLE = FALSE;   // signal a serious problem!
    
    return fOLE;
}

/*
 * Initialize the state of the application or
 * change state from Embedded to Standalone.
 */
void FlagEmbeddedObject(BOOL flag)
{
    // Set global state variables.  Note, gfEmbedding is untouched.    
    gfEmbeddedObject = flag;
    gfStandalone = !flag;

}


void SetOleCaption(
    LPTSTR      lpszObj)
{
    TCHAR       aszFormatString[256];
    LPTSTR      lpszTitle;
    
    //
    // Change title to "Sound Object in XXX"
    //
    LoadString(ghInst, IDS_OBJECTTITLE, aszFormatString,
        SIZEOF(aszFormatString));

    lpszTitle = (LPTSTR)GlobalAllocPtr(GHND, (lstrlen(lpszObj) + SIZEOF(aszFormatString))*sizeof(TCHAR));
    if (lpszTitle)
    {
        wsprintf(lpszTitle, aszFormatString, lpszObj);
        SetWindowText(ghwndApp, lpszTitle);
        GlobalFreePtr(lpszTitle);
    }
}

void SetOleMenu(
    HMENU       hMenu,
    LPTSTR      lpszObj)
{
    TCHAR       aszFormatString[256];
    LPTSTR      lpszMenu;
    
    //
    // Change menu to "Exit & Return to XXX"
    //
    LoadString(ghInst, IDS_EXITANDRETURN, aszFormatString,
        SIZEOF(aszFormatString));

    lpszMenu = (LPTSTR)GlobalAllocPtr(GHND, (lstrlen(lpszObj) + SIZEOF(aszFormatString))*sizeof(TCHAR));
    if (lpszMenu)
    {
        wsprintf(lpszMenu, aszFormatString, lpszObj);
        ModifyMenu(hMenu, IDM_EXIT, MF_BYCOMMAND, IDM_EXIT, lpszMenu);
        GlobalFreePtr(lpszMenu);
    }
}

/* Adjust menus according to system state.
 * */
void FixMenus(void)
{
    HMENU       hMenu;
     
    hMenu = GetMenu(ghwndApp);
    
    if (!gfLinked && gfEmbeddedObject)
    {
        // Remove these menu items as they are irrelevant.
        
        DeleteMenu(hMenu, IDM_NEW, MF_BYCOMMAND);
        DeleteMenu(hMenu, IDM_SAVE, MF_BYCOMMAND);
        DeleteMenu(hMenu, IDM_SAVEAS, MF_BYCOMMAND);
        DeleteMenu(hMenu, IDM_REVERT, MF_BYCOMMAND);
        DeleteMenu(hMenu, IDM_OPEN, MF_BYCOMMAND);
    }
    else
    {
        TCHAR       ach[40];
// Is this necessary?
        LoadString(ghInst, IDS_NONEMBEDDEDSAVE, ach, SIZEOF(ach));
        ModifyMenu(hMenu, IDM_SAVE, MF_BYCOMMAND, IDM_SAVE, ach);
    }

    //
    // Update the titlebar and exit menu too.
    //
    if (!gfLinked && gfEmbeddedObject)
    {
        LPTSTR lpszObj = NULL;
        LPTSTR lpszApp = NULL;
        
        OleObjGetHostNames(&lpszApp,&lpszObj);
        if (lpszObj)
            lpszObj = (LPTSTR)FileName((LPCTSTR)lpszObj);
        if (lpszObj)
        {
            SetOleCaption(lpszObj);
            SetOleMenu(hMenu, lpszObj);
        }
    }

    DrawMenuBar(ghwndApp);  /* Can't hurt... */
}

#define WM_USER_DESTROY         (WM_USER+10)

//
// Called from WM_CLOSE (from user) or SCtrl::~SCtrl (from container)
//
void TerminateServer(void)
{
    DOUT(TEXT("SoundRec: TerminateServer\r\n"));
    
    gfTerminating = TRUE;

    if (gfOleInitialized)
    {
        WriteObjectIfEmpty();
        
        ReleaseSRClassFactory();
        FlushOleClipboard();
        
        //
        // If, at this time, we haven't closed, we really should.
        //
        if (!gfClosing)
        {
            DoOleClose(TRUE);
            AdviseClosed();
        }
    }
    //
    // only if the user is terminating OR we're embedded
    //
    if (gfUserClose || !gfStandalone)
        PostMessage(ghwndApp, WM_USER_DESTROY, 0, 0);
}

/* start params!
 * the app will use these params to determine behaviour once started.
 */
StartParams gStartParams = { FALSE,FALSE,FALSE,FALSE,TEXT("") };

BOOL ParseCommandLine(LPTSTR lpCommandLine)
{
    
#define TEST_STRING_MAX 11      // sizeof szEmbedding
#define NUMOPTIONS      6

    static TCHAR szEmbedding[] = TEXT("embedding");
    static TCHAR szPlay[]      = TEXT("play");
    static TCHAR szOpen[]      = TEXT("open");
    static TCHAR szNew[]       = TEXT("new");
    static TCHAR szClose[]     = TEXT("close");
    
    static struct tagOption {
        LPTSTR name;
        LPTSTR filename;
        int    cchfilename;
        LPBOOL state;
    } options [] = {
        { NULL, gStartParams.achOpenFilename, _MAX_PATH, &gStartParams.fOpen },
        { szEmbedding, gStartParams.achOpenFilename, _MAX_PATH, &gfEmbedded },
        { szPlay, gStartParams.achOpenFilename, _MAX_PATH, &gStartParams.fPlay },
        { szOpen, gStartParams.achOpenFilename, _MAX_PATH, &gStartParams.fOpen },
        { szNew, gStartParams.achOpenFilename, _MAX_PATH, &gStartParams.fNew },
        { szClose, NULL, 0, &gStartParams.fClose }
    };

    LPTSTR pchNext;
    int iOption = 0,i,cNumOptions = sizeof(options)/sizeof(struct tagOption);
    TCHAR szSwitch[TEST_STRING_MAX];
    TCHAR ch;
    
    if (lpCommandLine == NULL)
        return FALSE;
    
    
    /* skip argv[0] */
    if (*lpCommandLine == TEXT('"'))
    {
        //
        // eat up everything to the next quote
        //
        lpCommandLine++;
        do {
            ch = *lpCommandLine++;
        }
        while (ch != TEXT('"'));
    }
    else
    {
        //
        // eat up everything to the next whitespace
        //
        ch = *lpCommandLine;
        while (ch != TEXT(' ') && ch != TEXT('\t') && ch != TEXT('\0'))
            ch = *++lpCommandLine;
    }
    
    pchNext = lpCommandLine;
    while ( *pchNext )
    {
        LPTSTR pchName = options[iOption].filename;
        int cchName = options[iOption].cchfilename;
        
        /* whitespace */
        switch (*pchNext)
        {
            case TEXT(' '):
            case TEXT('\t'):
                pchNext++;
                continue;

            case TEXT('-'):
            case TEXT('/'):
            {
                lstrcpyn(szSwitch,pchNext+1,TEST_STRING_MAX);
                szSwitch[TEST_STRING_MAX-1] = 0;

                /* scan to the NULL or ' ' and terminate string */
                
                for (i = 0; i < TEST_STRING_MAX && szSwitch[i] != 0; i++)
                    if (szSwitch[i] == TEXT(' '))
                    {
                        szSwitch[i] = 0;
                        break;
                    }
                
                /* now test each option switch for a hit */

                for (i = 0; i < cNumOptions; i++)
                {
                    if (options[i].name == NULL)
                        continue;
                    
                    if (!lstrcmpi(szSwitch,options[i].name))
                    {
                        *(options[i].state) = TRUE;
                        if (options[i].filename)
                        /* next non switch string applies to this option */
                            iOption = i;
                        break;
                    }
                }
                
                /* seek ahead */
                while (*pchNext && *pchNext != TEXT(' '))
                    pchNext++;
                
                continue;
            }
            case TEXT('\"'):
                /* filename */
                /* copy up to next quote */
                pchNext++;
                while (*pchNext && *pchNext != TEXT('\"'))
                {
                    if (cchName)
                    {
                        *pchName++ = *pchNext++;
                        cchName--;
                    }
                    else
                        break;
                }
                pchNext++;
                
                continue;
                    
            default:
                /* filename */
                /* copy up to the end */
                while (*pchNext && cchName)
                {
                        *pchName++ = *pchNext++;
                        cchName--;
                }
                break;
        }
    }
    /* special case.
     * we are linked if given a LinkFilename and an embedding flag.
     * Does this ever happen or only through IPersistFile?
     */
    if (gfEmbedded && gStartParams.achOpenFilename[0] != 0)
    {
        gfLinked = TRUE;
    }
    return gfEmbedded;
}

void
BuildUniqueLinkName(void)
{
    //
    //Ensure a unique filename in gachLinkFilename so we can create valid
    //FileMonikers...
    //
    if(gachLinkFilename[0] == 0)
    {
        TCHAR aszFile[_MAX_PATH];
        GetTempFileName(TEXT("."), TEXT("Tmp"), 0, gachLinkFilename);
        
        /* GetTempFileName creates an empty file, delete it.
         */
               
        GetFullPathName(gachLinkFilename,SIZEOF(aszFile),aszFile,NULL);
        DeleteFile(aszFile);
    }
    
}


void AppPlay(BOOL fClose)
{
    if (fClose)
    {
        //ugh.  don't show while playing.
        gfShowWhilePlaying = FALSE;
    }
    
    if (IsWindow(ghwndApp))
    {
        gfCloseAtEndOfPlay = fClose;
            
        PostMessage(ghwndApp,WM_COMMAND,ID_PLAYBTN, 0L);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\reg.h ===
DWORD ReadRegistryData( LPTSTR pEntryNode,
                        LPTSTR pEntryName,
                        PDWORD pType,
                        LPBYTE pData,
                        DWORD  DataSize );

DWORD WriteRegistryData( LPTSTR pEntryNode,
                         LPTSTR pEntryName,
                         DWORD  Type,
                         LPBYTE pData,
                         DWORD  Size );
DWORD QueryRegistryDataSize( LPTSTR  pEntryNode,
                            LPTSTR  pEntryName,
                            DWORD   *pDataSize );

enum { SGSRR_GET, SGSRR_SET };

BOOL SoundRec_GetSetRegistryRect(
    HWND	hwnd,
    int         Get);

BOOL SoundRec_GetDefaultFormat(
    LPWAVEFORMATEX  *ppwfx,
    DWORD           *pcbwfx);

BOOL SoundRec_SetDefaultFormat(
    LPTSTR lpFormat);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\reg.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <regstr.h>
#include "reg.h"

const TCHAR szRegPath[] = REGSTR_PATH_WINDOWSAPPLETS TEXT("\\Sound Recorder");

/* ReadRegistryData
 *
 * Reads information from the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under Media Player which should be opened
 *         for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be retrieved.
 *
 *     pType - Pointer to a buffer to receive type of data read.  May be NULL.
 *
 *     pData - Pointer to a buffer to receive the value data.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD ReadRegistryData( LPTSTR pEntryNode,
                        LPTSTR pEntryName,
                        PDWORD pType,
                        LPBYTE pData,
                        DWORD  DataSize )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;
    DWORD  Size;

    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ, &hkeyRegPath );

    if( Status == NO_ERROR )
    {
        /* Open the sub-node:
         */
        if( pEntryNode )
            Status = RegOpenKeyEx( hkeyRegPath, pEntryNode, 0,
                                   KEY_READ, &hkeyEntryNode );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            Size = DataSize;

            /* Read the entry from the registry:
             */
            Status = RegQueryValueEx( hkeyEntryNode,
                                      pEntryName,
                                      0,
                                      pType,
                                      pData,
                                      &Size );

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }
    return Status;
}


DWORD QueryRegistryDataSize(
    LPTSTR  pEntryNode,
    LPTSTR  pEntryName,
    DWORD   *pDataSize )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;
    DWORD  Size;

    /* Open the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Sound Recorder"
     */
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                           KEY_READ, &hkeyRegPath );

    if( Status == NO_ERROR )
    {
        /* Open the sub-node:
         */
        if( pEntryNode )
            Status = RegOpenKeyEx( hkeyRegPath, pEntryNode, 0,
                                   KEY_READ, &hkeyEntryNode );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            /* Read the entry from the registry:
             */
            Status = RegQueryValueEx( hkeyEntryNode,
                                      pEntryName,
                                      0,
                                      NULL,
                                      NULL,
                                      &Size );
            if (Status == NO_ERROR)
                *pDataSize = Size;

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }
    return Status;
}



/* WriteRegistryData
 *
 * Writes a bunch of information to the registry
 *
 * Parameters:
 *
 *     pEntryNode - The node under szRegPath which should be created
 *         or opened for this data.  If this is NULL, the value is
 *         written directly under szRegPath.
 *
 *     pEntryName - The name of the value under pEntryNode to be set.
 *
 *     Type - Type of data to read (e.g. REG_SZ).
 *
 *     pData - Pointer to the value data to be written.  If this is NULL,
 *         the value under pEntryNode is deleted.
 *
 *     Size - Size, in bytes, of the buffer pointed to by pData.
 *
 *
 * This routine is fairly generic, apart from the name of the top-level node.
 *
 * The data are stored in the following registry tree:
 *
 * HKEY_CURRENT_USER
 *  
 *   Software
 *      
 *       Microsoft
 *          
 *           Windows NT
 *              
 *               CurrentVersion
 *                  
 *                   Media Player
 *                      
 *                       AVIVideo
 *                      
 *                       DisplayPosition
 *                      
 *                       SysIni
 *
 *
 * Return:
 *
 *     Registry status return (NO_ERROR is good)
 *
 *
 * Andrew Bell (andrewbe) wrote it, 10 September 1992
 *
 */
DWORD WriteRegistryData( LPTSTR pEntryNode,
                         LPTSTR pEntryName,
                         DWORD  Type,
                         LPBYTE pData,
                         DWORD  Size )
{
    DWORD  Status;
    HKEY   hkeyRegPath;
    HKEY   hkeyEntryNode;

    /* Open or create the top-level node.  For Media Player this is:
     * "Software\\Microsoft\\Windows NT\\CurrentVersion\\Media Player"
     */
    Status = RegCreateKeyEx( HKEY_CURRENT_USER, szRegPath, 0,
                             NULL, 0, KEY_WRITE, NULL, &hkeyRegPath, NULL );

    if( Status == NO_ERROR )
    {
        /* Open or create the sub-node.
         */
        if( pEntryNode )
            Status = RegCreateKeyEx( hkeyRegPath, pEntryNode, 0,
                                     NULL, 0, KEY_WRITE, NULL, &hkeyEntryNode, NULL );
        else
            hkeyEntryNode = hkeyRegPath;

        if( Status == NO_ERROR )
        {
            if( pData )
            {
                Status = RegSetValueEx( hkeyEntryNode,
                                        pEntryName,
                                        0,
                                        Type,
                                        pData,
                                        Size );

            }
            else
            {
                Status = RegDeleteValue( hkeyEntryNode, pEntryName );
            }

            if( pEntryNode )
                RegCloseKey( hkeyEntryNode );
        }

        RegCloseKey( hkeyRegPath );
    }


    return Status;
}


/*
 * Save/Restore window position
 */
BOOL SoundRec_GetSetRegistryRect(
    HWND	hwnd,
    int         Get)
{
    const TCHAR aszXPos[]    = TEXT("X");
    const TCHAR aszYPos[]    = TEXT("Y");
    
    RECT  rcWnd,rc;
    
    if (!GetWindowRect(hwnd, &rcWnd))
        return FALSE;

    switch (Get)
    {
        case SGSRR_GET:
            if (ReadRegistryData((LPTSTR)NULL
                , (LPTSTR)aszXPos
                , NULL
                , (LPBYTE)&rc.left
                , sizeof(rc.left)) != NO_ERROR)
            {
                break;
            }
            if (ReadRegistryData((LPTSTR)NULL
                , (LPTSTR)aszYPos
                , NULL
                , (LPBYTE)&rc.top
                , sizeof(rc.top)) != NO_ERROR)
            {
                break;
            }
            
            //
            // Restore window position
            //
            MoveWindow(hwnd
                        , rc.left
                        , rc.top
                        , rcWnd.right - rcWnd.left
                        , rcWnd.bottom - rcWnd.top
                        , FALSE );
            
            return TRUE;
            
        case SGSRR_SET:
            //
            // don't save iconic or hidden window states
            //
            if (IsIconic(hwnd) || !IsWindowVisible(hwnd))
                break;

            if (WriteRegistryData((LPTSTR)NULL
                , (LPTSTR)aszXPos
                , REG_DWORD
                , (LPBYTE)&rcWnd.left
                , sizeof(rcWnd.left)) != NO_ERROR)
            {
                break;
            }
            if (WriteRegistryData((LPTSTR)NULL
                , (LPTSTR)aszYPos
                , REG_DWORD
                , (LPBYTE)&rcWnd.top
                , sizeof(rcWnd.top)) != NO_ERROR)
            {
                break;
            }
            
            return TRUE;
            
        default:
            break;
    }
    return FALSE;
}    

/*
 *
 * */
const TCHAR szAudioRegPath[]    = REGSTR_PATH_MULTIMEDIA_AUDIO;
const TCHAR szWaveFormats[]     = REGSTR_PATH_MULTIMEDIA_AUDIO TEXT("\\WaveFormats");
const TCHAR szDefaultFormat[]   = TEXT("DefaultFormat");

/*
 * BOOL SoundRec_SetDefaultFormat
 * 
 * Write the DefaultFormat friendly name into the registry.  Under DAYTONA
 * we don't have a UI to set DefaultFormat, so this is a way of setting
 * it from an application.
 * 
 * Under Chicago, the Audio page in MMCPL manages this information.
 * */
BOOL SoundRec_SetDefaultFormat(
    LPTSTR lpFormat)
{
    DWORD  cbFormat;
    DWORD  Status;
    HKEY   hkeyRegPath;

    cbFormat = (lstrlen(lpFormat) + 1) * sizeof(TCHAR);

    //
    // Don't store NULL.
    //
    if (cbFormat <= sizeof(TCHAR) )
        return FALSE;
    
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szAudioRegPath, 0,
                           KEY_WRITE, &hkeyRegPath );
    
    if (Status != NO_ERROR)
        return FALSE;

    //
    // Get the format tag string
    //
    Status = RegSetValueEx( hkeyRegPath,
                              szDefaultFormat,
                              0,
                              REG_SZ,
                              (CONST BYTE*)lpFormat,
                              cbFormat );
    
    return (Status == NO_ERROR);
}

/* IsValidWFX
 *
 * Validate the wfx in case it was corrupted.
 *
 * */
BOOL IsValidWFX(
    LPWAVEFORMATEX  lpwfx,
    DWORD           cbwfx)
{

    if (cbwfx < sizeof(WAVEFORMAT))
        return FALSE;
    
    if (lpwfx->nChannels == 0)
        return FALSE;

    if (lpwfx->nSamplesPerSec == 0)
        return FALSE;

    if (lpwfx->nAvgBytesPerSec == 0)
        return FALSE;
    
    if (lpwfx->nBlockAlign == 0)
        return FALSE;
        
    if (lpwfx->wFormatTag == WAVE_FORMAT_PCM)
        return TRUE;

    if (cbwfx < (sizeof(WAVEFORMATEX) + lpwfx->cbSize))
        return FALSE;

    return TRUE;
}

/*
 * BOOL SoundRec_GetDefaultFormat
 *
 * Default format is stored in a public area of the registry.
 *
 * */
BOOL SoundRec_GetDefaultFormat(
    LPWAVEFORMATEX  *ppwfx,
    DWORD           *pcbwfx)
{
    DWORD           Status;
    HKEY            hkeyRegPath;
    HKEY            hkeyFmtPath;
    
    LPTSTR          lpsz;
    DWORD           cbsz;
    
    DWORD           cbwfx = 0;
    LPWAVEFORMATEX  lpwfx = NULL;


    //
    // Null out params
    //
    *ppwfx          = NULL;
    *pcbwfx         = 0;
    
    Status = RegOpenKeyEx( HKEY_CURRENT_USER, szAudioRegPath, 0,
                           KEY_READ, &hkeyRegPath );
    if (Status != NO_ERROR)
        return FALSE;

    //
    // Get the format tag string
    //
    Status = RegQueryValueEx( hkeyRegPath, szDefaultFormat, 0, NULL, NULL,
                              &cbsz );

    if (Status != NO_ERROR)
        return FALSE;
    
    lpsz = (LPTSTR)GlobalAllocPtr(GHND, cbsz);
    if (!lpsz)
        return FALSE;
    
    Status = RegQueryValueEx( hkeyRegPath, szDefaultFormat, 0, NULL,
                              (LPBYTE)lpsz, &cbsz );
    
    if (Status == NO_ERROR)
    {
        //
        // Get the format
        //
        Status = RegOpenKeyEx( HKEY_CURRENT_USER, szWaveFormats, 0,
                               KEY_READ, &hkeyFmtPath );

        if (Status == NO_ERROR)
        {
            Status = RegQueryValueEx( hkeyFmtPath, lpsz, 0, NULL, NULL,
                                      &cbwfx );
            //
            // Make sure the structure is at minimum a WAVEFORMAT in size
            //
            if ((Status == NO_ERROR) && (cbwfx >= sizeof(WAVEFORMAT)))
            {
                lpwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfx);
                if (lpwfx)
                {
                    Status = RegQueryValueEx( hkeyFmtPath, lpsz, 0, NULL,
                                              (LPBYTE)lpwfx, &cbwfx );
                }
            }
            
            RegCloseKey(hkeyFmtPath);
        }
    }

    RegCloseKey(hkeyRegPath);
    
    GlobalFreePtr(lpsz);

    //
    // Sanity Check.
    //
    if (lpwfx)
    {
        if (Status == NO_ERROR && IsValidWFX(lpwfx, cbwfx))
        {
            cbwfx = sizeof(WAVEFORMATEX)
                    + ((lpwfx->wFormatTag == WAVE_FORMAT_PCM)?0:lpwfx->cbSize);
            *pcbwfx = cbwfx;
            *ppwfx = lpwfx;
            return TRUE;
        }
        else
        {
            GlobalFreePtr(lpwfx);
            return FALSE;
        }
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\srecids.h ===
/* RESERVED:
 * The scheme of the o2base library requires a set of 14 or so resources.
 * Every object has resources that are an offset from these 15 resources and
 * it's up to the initialization of the ClassDescriptor to get this right.
 * Currently, this offset is 0, set in srfact.cxx

#define IDOFF_CLASSID         0
#define IDOFF_USERTYPEFULL    1
#define IDOFF_USERTYPESHORT   2
#define IDOFF_USERTYPEAPP     3
#define IDOFF_DOCFEXT         5
#define IDOFF_ICON            10
#define IDOFF_ACCELS          11
#define IDOFF_MENU            12
#define IDOFF_MGW             13
#define IDOFF_MISCSTATUS      14

*/

/* Icons */
#define IDI_APP                 10  // same as IDOFF_ICON
#define IDI_DSOUND              15
#define IDI_CONVERT             16

/* Dialogs */
#ifndef IDC_STATIC
#define IDC_STATIC              -1
#endif

#define IDD_SOUNDRECBOX         100

#define ID_STATUSTXT            200
#define ID_CURPOSTXT            201
#define ID_FILELENTXT           202
#define ID_WAVEDISPLAY          203
#define ID_CURPOSSCRL           204

// These need to start at ID_BTN_BASE and be sequential in the
// order in which the bitmaps occur in sndrec32.bmp (use imagedit)

#define ID_REWINDBTN            205
#define ID_BTN_BASE             ID_REWINDBTN
#define ID_FORWARDBTN           206
#define ID_PLAYBTN              207
#define ID_STOPBTN              208
#define ID_RECORDBTN            209

#define NUM_OF_BUTTONS          (1 + ID_RECORDBTN - ID_BTN_BASE)

#define IDR_PLAYBAR             501

#if defined(THRESHOLD)
#define ID_SKIPSTARTBTN         213
#define ID_SKIPENDBTN           214
#endif //THRESHOLD

#define IDD_SAVEAS              101
#define IDC_CONVERTTO           1000
//#define IDC_CONVERT_FROM        1001
//#define IDC_CONVERT_TO          1002
#define IDC_TXT_FORMAT          1003
#define IDC_CONVERTPLAYABLE     1008
#define IDC_CONVERTRECORDABLE   1009
#define IDC_CONVERTALL          1010


#define IDD_CONVERTING          102
#define IDC_PROGRESSBAR         1000
#define IDC_CONVERT_FROM        1001
#define IDC_CONVERT_TO          1002

#define IDD_PROPERTIES          103
#define IDC_DISPFRAME           1000
#define IDC_DISPICON            1001
#define IDC_FILENAME            1002
#define IDC_COPYRIGHT           1003
#define IDC_FILELEN             1004
#define IDC_AUDIOFORMAT         1005

#define ID_APPLY                1006
#define ID_INIT                 1007

#define IDC_TXT_COPYRIGHT       1008
#define IDC_TXT_FILELEN         1009
#define IDC_TXT_AUDIOFORMAT     1010

#define IDC_CONVERTCHOOSEFROM   1011
#define IDC_DATASIZE            1012
#define IDC_CONVGROUP           1013
#define IDC_TXT_DATASIZE        1014

#define IDD_CONVERTCHOOSE       104     

#define IDC_SETPREFERRED        1000

/* Strings */
#define IDS_APPNAME             100     // SoundRec
#define IDS_APPTITLE            101     // Sound Recorder
#define IDS_HELPFILE            102     // SOUNDREC.HLP
#define IDS_SAVECHANGES         103     // Save changes to '<file>'?
#define IDS_OPEN                104     // Open WAVE File
#define IDS_SAVE                105     // Save WAVE File
#define IDS_ERROROPEN           106     // Error opening '<file>'
#define IDS_ERROREMBED          107     // Out of memory...
#define IDS_ERRORREAD           108     // Error reading '<file>'
#define IDS_ERRORWRITE          109     // Error writing '<file>'
#define IDS_OUTOFMEM            110     // Out of memory
#define IDS_FILEEXISTS          111     // File '<file>' exists -- overwrite it?
//#define IDS_BADFORMAT           112     // File format is incorrect/unsupported
#define IDS_CANTOPENWAVEOUT     113     // Cannot open waveform output device
#define IDS_CANTOPENWAVEIN      114     // Cannot open waveform input device
#define IDS_STATUSSTOPPED       115     // Stopped
#define IDS_STATUSPLAYING       116     // Playing
#define IDS_STATUSRECORDING     117     // Recording -- ...
#define IDS_CANTFINDFONT        118     // Cannot find file '<file>', so...
#define IDS_INSERTFILE          119     // Insert WAVE File
#define IDS_MIXWITHFILE         120     // Mix With WAVE File
#define IDS_CONFIRMREVERT       121     // Revert to last-saved copy... ?
#define IDS_INPUTNOTSUPPORT     122     // ...does not support recording
#define IDS_BADINPUTFORMAT      123     // ...cannot record into files like...
#define IDS_BADOUTPUTFORMAT     124     // ...cannot play files like...
#define IDS_UPDATEBEFORESAVE    125     // Update embedded before save as?
#define IDS_SAVEEMBEDDED        126     // Update embedded before closing?
//#define IDS_CANTSTARTOLE        127     // Can't register the server with OLE
#define IDS_NONEMBEDDEDSAVE     128     // 'Save'
#define IDS_EMBEDDEDSAVE        129     // 'Update'
//#define IDS_NONEMBEDDEDEXIT     130     // 'Exit'
#define IDS_EMBEDDEDEXIT        131     // 'Exit and Update'
//#define IDS_SAVELARGECLIP       132     // Save large clipboard?
//#define IDS_FILENOTFOUND        133     // The file %s does not exist
#define IDS_NOTAWAVEFILE        134     // The file %s is not a valid...
#define IDS_NOTASUPPORTEDFILE   135     // The file %s is not a supported...
#define IDS_FILETOOLARGE        136     // The file %s is too large...
#define IDS_DELBEFOREWARN       137     // Warning: Deleteing before
#define IDS_DELAFTERWARN        138     // Warning: Deleteing after
#define IDS_UNTITLED            139     // (Untitled)
#define IDS_FILTERNULL          140     // Null replacement char
#define IDS_FILTER              141     // Common Dialog file filter
#define IDS_OBJECTLINK          142     // Object link clipboard format
#define IDS_OWNERLINK           143     // Owner link clipboard format
#define IDS_NATIVE              144     // Native clipboard format
#ifdef FAKEITEMNAMEFORLINK
#define IDS_FAKEITEMNAME        145     // Wave
#endif
//#define IDS_CLASSROOT           146     // Root name
//#define IDS_EMBEDDING           147     // Embedding
#define IDS_POSITIONFORMAT      148     // Format of current position string
#define IDS_NOWAVEFORMS         149     // No recording or playback devices are present
#define IDS_PASTEINSERT         150
#define IDS_PASTEMIX            151
#define IDS_FILEINSERT          152
#define IDS_FILEMIX             153
//#define IDS_SOUNDOBJECT         154
#define IDS_CLIPBOARD           156
#define IDS_MONOFMT             157
#define IDS_STEREOFMT           158
#define IDS_CANTPASTE           159
//#define IDS_PLAYVERB            160
//#define IDS_EDITVERB            161

#define IDS_DEFFILEEXT          162
#define IDS_NOWAVEIN            163
#define IDS_SNEWMONOFMT         164
#define IDS_SNEWSTEREOFMT       165
#define IDS_NONE                166
#define IDS_NOACMNEW            167
#define IDS_NOZEROPOSITIONFORMAT 168
#define IDS_NOZEROMONOFMT       169
#define IDS_NOZEROSTEREOFMT     170

//#define IDS_LINKEDUPDATE        171
#define IDS_OBJECTTITLE         172
#define IDS_EXITANDRETURN       173

#define IDS_BADREG              174
#define IDS_FIXREGERROR         175
         

#define IDS_ERR_CANTCONVERT     177
#define IDS_PROPERTIES          178
#define IDS_SHOWPLAYABLE        179
#define IDS_SHOWRECORDABLE      180
#define IDS_SHOWALL             181
#define IDS_DATASIZE            182
#define IDS_NOCOPYRIGHT         183


#define IDS_PLAYVERB            184
#define IDS_EDITVERB            185
#define IDS_OPENVERB            186

#define IDS_MMSYSPROPTITLE      187
#define IDS_MMSYSPROPTAB        188

#define IDS_RTLENABLED          189

#define IDS_HTMLHELPFILE        190     // SOUNDREC.CHM

/*
 * menus
 */         
#define IDM_OPEN                12
#define IDM_SAVE                13
#define IDM_SAVEAS              14
#define IDM_REVERT              15
#define IDM_EXIT                16

#define IDM_COPY                20
#define IDM_DELETE              21
#define IDM_INSERTFILE          22
#define IDM_MIXWITHFILE         23
#define IDM_PASTE_INSERT        24
#define IDM_PASTE_MIX           25

#if defined(THRESHOLD)
   #define IDM_SKIPTOSTART      26
   #define IDM_SKIPTOEND        27
   #define IDM_INCREASETHRESH   28
   #define IDM_DECREASETHRESH   29
#endif //threshold

#define IDM_DELETEBEFORE        31
#define IDM_DELETEAFTER         32
#define IDM_INCREASEVOLUME      33
#define IDM_DECREASEVOLUME      34
#define IDM_MAKEFASTER          35
#define IDM_MAKESLOWER          36
#define IDM_ADDECHO             37
#define IDM_REVERSE             38
#define IDM_ADDREVERB           39

#define IDM_INDEX               91
#define IDM_KEYBOARD            92
#define IDM_COMMANDS            93
#define IDM_PROCEDURES          94
#define IDM_USINGHELP           95
#define IDM_ABOUT               96
#define IDM_SEARCH              97

#define IDM_HELPTOPICS          98

#define IDM_VOLUME              99
#define IDM_PROPERTIES          100
                         
#define IDM_NEW                 1000    // need room ...
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\srecnew.h ===
/* (C) Copyright Microsoft Corporation 1992.  All Rights Reserved */

/* strings */

#define IDS_DEFAULT     200
#define IDS_MSPCM       201
#define IDS_MSADPCM     202
#define IDS_RBLOW       203
#define IDS_RBMED       204
#define IDS_RBHIGH      205
#define IDS_CUSTOM      206
#define IDS_STANDARD    207

/* Dialog Controls */

#define IDA_NEWCONFIG   100
#define IDPB_HELP       101
#define IDPB_DEFAULT    102
#define IDRB_HIGH       103
#define IDRB_MEDIUM     104
#define IDRB_LOW        105
#define IDRB_MONO       106
#define IDRB_STEREO     107
#define IDCB_FORMATTYPE 108
#define IDLB_ATTRIB     109
#define IDRB_CUSTOM     110
#define IDF_BOGUS       112
#define IDPB_CUSTOM     113

#define ID_ACMVER       114


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\soundrec.h ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
/* SoundRec.h
 */
/* Revision History.
   LaurieGr  7/Jan/91  Ported to WIN32 / WIN16 common code
   LaurieGr  16/Feb/94 Merged Daytona and Motown versions
*/

/* Set NT type debug flags */

#if DBG
# ifndef DEBUG
# define DEBUG
# endif
#endif

/* Enable Win95 UI code for Windows NT with the new shell */
#if WINVER >= 0x0400
#define CHICAGO
#endif

#include <stdlib.h>

#ifndef RC_INVOKED
#ifndef OLE1_REGRESS
#ifdef INCLUDE_OLESTUBS
#include "oleglue.h"
#endif
#else
#pragma message("OLE1 alert")
#include "server.h"
#endif
#endif

#define SIZEOF(x)       (sizeof(x)/sizeof(TCHAR))

typedef BYTE * HPBYTE;     /* note a BYTE is NOT the same as a CHAR */
typedef BYTE * NPBYTE;     /* A CHAR can be TWO BYTES (UNICODE!!)   */


#define FMT_DEFAULT     0x0000
#define FMT_STEREO      0x0010
#define FMT_MONO        0x0000
#define FMT_16BIT       0x0008
#define FMT_8BIT        0x0000
#define FMT_RATE        0x0007      /* 1, 2, 4 */
#define FMT_11k         0x0001
#define FMT_22k         0x0002
#define FMT_44k         0x0004

//
// convertsion routines in wave.c
//
LONG PASCAL wfSamplesToBytes(WAVEFORMATEX* pwf, LONG lSamples);
LONG PASCAL wfBytesToSamples(WAVEFORMATEX* pwf, LONG lBytes);
LONG PASCAL wfSamplesToTime (WAVEFORMATEX* pwf, LONG lSamples);
LONG PASCAL wfTimeToSamples (WAVEFORMATEX* pwf, LONG lTime);

#define wfTimeToBytes(pwf, lTime)   wfSamplesToBytes(pwf, wfTimeToSamples(pwf, lTime))
#define wfBytesToTime(pwf, lBytes)  wfSamplesToTime(pwf, wfBytesToSamples(pwf, lBytes))

#define wfSamplesToSamples(pwf, lSamples)  wfBytesToSamples(pwf, wfSamplesToBytes(pwf, lSamples))
#define wfBytesToBytes(pwf, lBytes)        wfSamplesToBytes(pwf, wfBytesToSamples(pwf, lBytes))

//
// function to determine if a WAVEFORMATEX is a valid PCM format we support for
// editing and such.
//
BOOL PASCAL IsWaveFormatPCM(WAVEFORMATEX* pwf);

void PASCAL WaveFormatToString(LPWAVEFORMATEX lpwf, LPTSTR sz);
BOOL PASCAL CreateWaveFormat(LPWAVEFORMATEX lpwf, WORD fmt, UINT uiDeviceID);
BOOL PASCAL CreateDefaultWaveFormat(LPWAVEFORMATEX lpwf, UINT uDeviceID);

//
// used to set focus to a dialog control
//
#define SetDlgFocus(hwnd)   SendMessage(ghwndApp, WM_NEXTDLGCTL, (WPARAM)(hwnd), 1L)

#define FAKEITEMNAMEFORLINK

#define SZCODE const TCHAR

/* constants */
#define TIMER_MSEC              50              // msec. for display update
#define SCROLL_RANGE            10000           // scrollbar range
#define SCROLL_LINE_MSEC        100             // scrollbar arrow left/right
#define SCROLL_PAGE_MSEC        1000            // scrollbar page left/right

#define WM_USER_DESTROY         (WM_USER+10)
#define WM_USER_KILLSERVER      (WM_USER+11)
#define WM_USER_WAITPLAYEND (WM_USER+12)
#define WM_BADREG           (WM_USER+125)

#define MAX_WAVEHDRS            10
#define MAX_DELTASECONDS        350
#define MAX_MSECSPERBUFFER      10000

#define MIN_WAVEHDRS            2
#define MIN_DELTASECONDS        5
#define MIN_MSECSPERBUFFER      62

#define DEF_BUFFERDELTASECONDS      60
#define DEF_NUMASYNCWAVEHEADERS     10
#define DEF_MSECSPERASYNCBUFFER     250


/* colors */

#define RGB_PANEL           GetSysColor(COLOR_BTNFACE)   // main window background

#define RGB_STOP            GetSysColor(COLOR_BTNTEXT) // color of "Stop" status text
#define RGB_PLAY            GetSysColor(COLOR_BTNTEXT) // color of "Play" status text
#define RGB_RECORD          GetSysColor(COLOR_BTNTEXT) // color of "Record" status text

#define RGB_FGNFTEXT        GetSysColor(COLOR_BTNTEXT) // NoFlickerText foreground
#define RGB_BGNFTEXT        GetSysColor(COLOR_BTNFACE) // NoFlickerText background

#define RGB_FGWAVEDISP      RGB(  0, 255,   0)  // WaveDisplay foreground
#define RGB_BGWAVEDISP      RGB(  0,   0,   0)  // WaveDisplay background

#define RGB_DARKSHADOW      GetSysColor(COLOR_BTNSHADOW)     // dark 3-D shadow
#define RGB_LIGHTSHADOW     GetSysColor(COLOR_BTNHIGHLIGHT)  // light 3-D shadow

/* a window proc */
typedef LONG (FAR PASCAL * LPWNDPROC) (void);

/* globals from "SoundRec.c" */
extern TCHAR            chDecimal;
extern TCHAR            gachAppName[];  // 8-character name
extern TCHAR            gachAppTitle[]; // full name
extern TCHAR            gachHelpFile[]; // name of help file
extern TCHAR            gachHtmlHelpFile[]; // name of help file
extern TCHAR            gachDefFileExt[]; // 3-character file extension
extern HWND             ghwndApp;       // main application window
extern HMENU            ghmenuApp;      // main application menu
extern HANDLE           ghAccel;        // accelerators
extern HINSTANCE        ghInst;         // program instance handle
extern TCHAR            gachFileName[]; // cur. file name (or UNTITLED)
extern BOOL             gfLZero;        // leading zeros?
extern BOOL             gfIsRTL;        // no compile BIDI support
extern BOOL             gfDirty;        // file was modified and not saved?
                                        // -1 seems to mean "cannot save"
                                        // Damned funny value for a BOOL!!!!
extern BOOL             gfClipboard;    // current doc is in clipboard
extern HWND             ghwndWaveDisplay; // waveform display window handle
extern HWND             ghwndScroll;    // scroll bar control window handle
extern HWND             ghwndPlay;      // Play button window handle
extern HWND             ghwndStop;      // Stop button window handle
extern HWND             ghwndRecord;    // Record button window handle
extern HWND             ghwndForward;   // [>>] button
extern HWND             ghwndRewind;    // [<<] button

extern UINT         guiACMHlpMsg;   // ACM Help's message value

/* hack fix for the multiple sound card problem */
#define NEWPAUSE
#ifdef NEWPAUSE
extern BOOL         gfPaused;
extern BOOL         gfPausing;
extern HWAVE            ghPausedWave;
extern BOOL             gfWasPlaying;
extern BOOL             gfWasRecording;
#endif
#ifdef THRESHOLD
extern HWND             ghwndSkipStart; // [>N] button
extern HWND             ghwndSkipEnd;   // [>-] button
#endif // THRESHOLD

extern int              gidDefaultButton;// which button should have focus
extern HICON            ghiconApp;      // Application's icon
extern TCHAR             aszUntitled[];  // Untitled string resource
extern TCHAR             aszFilter[];    // File name filter
#ifdef FAKEITEMNAMEFORLINK
extern  TCHAR            aszFakeItemName[];      // Wave
#endif
extern TCHAR             aszPositionFormat[];
extern TCHAR         aszNoZeroPositionFormat[];

/* globals from "wave.c" */
extern DWORD            gcbWaveFormat;  // size of WAVEFORMAT
extern WAVEFORMATEX *   gpWaveFormat;   // format of WAVE file
extern LPTSTR           gpszInfo;
extern HPBYTE            gpWaveSamples;  // pointer to waveoform samples
extern LONG             glWaveSamples;  // number of samples total in buffer
extern LONG             glWaveSamplesValid; // number of samples that are valid
extern LONG             glWavePosition; // current wave position in samples
                                        // from start of buffer
extern LONG             glStartPlayRecPos; // pos. when play or record started
extern HWAVEOUT         ghWaveOut;      // wave-out device (if playing)
extern HWAVEIN          ghWaveIn;       // wave-out device (if recording)
extern DWORD            grgbStatusColor; // color of status text
extern HBRUSH           ghbrPanel;      // color of main window

extern BOOL             gfEmbeddedObject; // TRUE if editing embedded OLE object
extern BOOL             gfRunWithEmbeddingFlag; // TRUE if we are run with "-Embedding"

extern int              gfErrorBox;      // TRUE iff we do not want to display an
                                         // error box (e.g. because one is active)

//OLE2 stuff:
extern BOOL gfStandalone;               // CG
extern BOOL gfEmbedded;                 // CG
extern BOOL gfLinked;                   // CG
extern BOOL gfCloseAtEndOfPlay;         // jyg need I say more?

/* SRECNEW.C */
extern BOOL         gfInFileNew;    // are we doing a File.New op?

void FAR PASCAL LoadACM(void);
void FreeACM(void);

#include "srecids.h"

typedef enum {
        enumCancel,
        enumSaved,
        enumRevert
}       PROMPTRESULT;


/* prototypes from "SoundRec.c" */
INT_PTR CALLBACK SoundRecDlgProc(HWND hDlg, UINT wMsg,
        WPARAM wParam, LPARAM lParam);
BOOL ResolveIfLink(PTCHAR szFileName);

/* prototypes from "file.c" */
void FAR PASCAL BeginWaveEdit(void);
void FAR PASCAL EndWaveEdit(BOOL fDirty);
PROMPTRESULT FAR PASCAL PromptToSave(BOOL fMustClose, BOOL fSetForground);
void FAR PASCAL UpdateCaption(void);
BOOL FAR PASCAL FileNew(WORD fmt, BOOL fUpdateDisplay, BOOL fNewDlg);
BOOL FAR PASCAL FileOpen(LPCTSTR szFileName);
BOOL FAR PASCAL FileSave(BOOL fSaveAs);
BOOL FAR PASCAL FileRevert(void);
LPCTSTR FAR PASCAL FileName(LPCTSTR szPath);
MMRESULT ReadWaveFile(HMMIO hmmio, LPWAVEFORMATEX* ppWaveFormat,
    DWORD *pcbWaveFormat, LPBYTE * ppWaveSamples, DWORD *plWaveSamples,
    LPTSTR szFileName, BOOL fCacheRIFF);
BOOL FAR PASCAL WriteWaveFile(HMMIO hmmio, WAVEFORMATEX* pWaveFormat,
        UINT cbWaveFormat, HPBYTE pWaveSamples, LONG lWaveSamples);

/* prototypes from "errorbox.c" */
short FAR cdecl ErrorResBox(HWND hwnd, HANDLE hInst, UINT flags,
        UINT idAppName, UINT idErrorStr, ...);

/* prototypes from "edit.c" */
void FAR PASCAL InsertFile(BOOL fPaste);
void FAR PASCAL MixWithFile(BOOL fPaste);
void FAR PASCAL DeleteBefore(void);
void FAR PASCAL DeleteAfter(void);
void FAR PASCAL ChangeVolume(BOOL fIncrease);
void FAR PASCAL MakeFaster(void);
void FAR PASCAL MakeSlower(void);
void FAR PASCAL IncreasePitch(void);
void FAR PASCAL DecreasePitch(void);
void FAR PASCAL AddEcho(void);
#if defined(REVERB)
void FAR PASCAL AddReverb(void);
#endif //REVERB
void FAR PASCAL Reverse(void);

/* prototypes from "wave.c" */
BOOL FAR PASCAL AllocWaveBuffer(long lBytes, BOOL fErrorBox, BOOL fExact);
BOOL FAR PASCAL NewWave(WORD fmt,BOOL fNewDlg);
BOOL FAR PASCAL DestroyWave(void);
BOOL FAR PASCAL PlayWave(void);
BOOL FAR PASCAL RecordWave(void);
void FAR PASCAL WaveOutDone(HWAVEOUT hWaveOut, LPWAVEHDR pWaveHdr);
void FAR PASCAL WaveInData(HWAVEIN hWaveIn, LPWAVEHDR pWaveHdr);
void FAR PASCAL StopWave(void);
void FAR PASCAL SnapBack(void);
void FAR PASCAL UpdateDisplay(BOOL fStatusChanged);
void FAR PASCAL FinishPlay(void);
void FAR PASCAL SkipToStart(void);
void FAR PASCAL SkipToEnd(void);
void FAR PASCAL IncreaseThresh(void);
void FAR PASCAL DecreaseThresh(void);

/* prototypes from "init.c" */
BOOL PASCAL AppInit( HINSTANCE hInst, HINSTANCE hPrev);
BOOL PASCAL SoundDialogInit(HWND hwnd, int iCmdShow);
BOOL PASCAL GetIntlSpecs(void);

/* prototype from "wavedisp.c" */
INT_PTR CALLBACK WaveDisplayWndProc(HWND hwnd, UINT wMsg,
        WPARAM wParam, LPARAM lParam);

/* prototype from "nftext.c" */
INT_PTR CALLBACK NFTextWndProc(HWND hwnd, UINT wMsg,
        WPARAM wParam, LPARAM lParam);

/* prototype from "sframe.c" */
void FAR PASCAL DrawShadowFrame(HDC hdc, LPRECT prc);
INT_PTR CALLBACK SFrameWndProc(HWND hwnd, UINT wMsg,
        WPARAM wParam, LPARAM lParam);

/* prototype from "server.c" */
BOOL FAR PASCAL IsClipboardNative(void);

/* prototypes from "srecnew.c" */
BOOL FAR PASCAL NewSndDialog(HINSTANCE hInst, HWND hwndParent,
    PWAVEFORMATEX pwfxPrev, UINT cbPrev,
    PWAVEFORMATEX *ppWaveFormat, PUINT pcbWaveFormat);

/* start parameters (set in oleglue.c) */

typedef struct tStartParams {
    BOOL    fOpen;
    BOOL    fPlay;
    BOOL    fNew;
    BOOL    fClose;
    TCHAR   achOpenFilename[_MAX_PATH];
} StartParams;

extern StartParams gStartParams;

#ifdef DEBUG
    int __iDebugLevel;

    extern void FAR cdecl dprintfA(LPSTR, ...);
    extern void FAR cdecl dprintfW(LPWSTR, ...);
    
#ifdef UNICODE
    #define dprintf dprintfW
#else
    #define dprintf dprintfA
#endif

#if 0    
    #define DPF  if (__iDebugLevel >  0) dprintf
    #define DPF1 if (__iDebugLevel >= 1) dprintf
    #define DPF2 if (__iDebugLevel >= 2) dprintf
    #define DPF3 if (__iDebugLevel >= 3) dprintf
    #define DPF4 if (__iDebugLevel >= 4) dprintf
    #define CPF
#endif

#ifdef PPC    
    //
    // The below line crashes the PPC compiler for NT 3.51
    //
    #define DPF(a)    
#else
    #define DPF  if (0) ((int (*)(TCHAR *, ...)) 0)
#endif        
    #define DPF1 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF2 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF3 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF4 if (0) ((int (*)(TCHAR *, ...)) 0)

    #define CPF  if (0) ((int (*)(TCHAR *, ...)) 0)
#else
    
#ifdef PPC
    //
    // The below line crashes the PPC compiler for NT 3.51
    //
    #define DPF(a)
#else
    #define DPF  if (0) ((int (*)(TCHAR *, ...)) 0)
#endif    
    #define DPF1 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF2 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF3 if (0) ((int (*)(TCHAR *, ...)) 0)
    #define DPF4 if (0) ((int (*)(TCHAR *, ...)) 0)

    #define CPF  if (0) ((int (*)(TCHAR *, ...)) 0)
#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\sframe.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* sframe.c
 *
 * Implements the shadow-frame static text control ("sb_sframe").
 *
 * This is NOT a general-purpose control (see the globals below).
 *
 * Borrowed from KeithH (with many, many modifications).
 */
/* Revision History.
   4/2/91 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
*/

#include "nocrap.h"
#include <windows.h>
#include <mmsystem.h>
#include "SoundRec.h"


/* PatB(hdc, x, y, dx, dy, rgb)
 *
 * Fast solid color PatBlt() using ExtTextOut().
 */
void
PatB(HDC hdc, int x, int y, int dx, int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc, rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
}


/* DrawShadowFrame(hdc, prc)
 *
 * Draw a shadow frame inside <prc> in <hdc>.
 */
void FAR PASCAL
DrawShadowFrame(HDC hdc, LPRECT prc)
{
    int     dx, dy;

    dx = prc->right  - prc->left;
    dy = prc->bottom - prc->top;
    PatB(hdc, prc->left, prc->top, 1, dy, RGB_DARKSHADOW);
    PatB(hdc, prc->left, prc->top, dx, 1, RGB_DARKSHADOW);
    PatB(hdc, prc->right-1, prc->top+1, 1, dy-1, RGB_LIGHTSHADOW);
    PatB(hdc, prc->left+1, prc->bottom-1, dx-1, 1, RGB_LIGHTSHADOW);
}


/* SFrameWndProc(hwnd, wMsg, wParam, lParam)
 *
 * Window procedure for "tb_sframe" window class.
 */
INT_PTR CALLBACK
SFrameWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC     hdc;
    RECT        rc;

    switch (wMsg)
    {

    case WM_ERASEBKGND:

        return 0L;

    case WM_PAINT:

        hdc = BeginPaint(hwnd, &ps);
        GetClientRect(hwnd, &rc);
        DrawShadowFrame(hdc, &rc);
                InflateRect(&rc, -1, -1);
//              DrawShadowFrame(hdc, &rc);
//              InflateRect(&rc, -1, -1);
//              FillRect(hdc, &rc, GetStockObject(SOBJ_BGSFRAME));
                PatB(hdc, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, RGB_BGNFTEXT);
        EndPaint(hwnd, &ps);

        return 0L;
    }

    return DefWindowProc(hwnd, wMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\srecnew.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* snddlg.c
 *
 * Routines for New & Custom Sound dialogs
 *
 */

#include "nocrap.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include <mmreg.h>
#if WINVER >= 0x0400
# include "..\..\msacm\msacm\msacm.h"
#else
# include <msacm.h>
#endif
#include <msacmdlg.h>
#include "SoundRec.h"
#include "srecnew.h"
#include "srecids.h"
#include "reg.h"

/******************************************************************************
 * DECLARATIONS
 */

/* Global variables
 */
BOOL            gfInFileNew     = FALSE;    // Are we in the file.new dialog?
DWORD           gdwMaxFormatSize= 0L;       // Max format size for ACM

/* Internal function declarations
 */
void FAR PASCAL LoadACM(void);

#ifndef CHICAGO
//
// Removed from the Win95 app due to Properties dialog
//

/*****************************************************************************
 * PUBLIC FUNCTIONS
 */
#if 0
#ifndef CHICAGO

BOOL NewDlg_OnCommand(
    HWND    hdlg,
    int     id,
    HWND    hctl,
    UINT    unotify)
{
    switch(id)
    {
        case IDD_ACMFORMATCHOOSE_CMB_CUSTOM:
            switch (unotify)
            {
                case CBN_SELCHANGE:
                {
                    HWND hSet;
                    int i = ComboBox_GetCurSel(hctl);
                    hSet = GetDlgItem(hdlg, IDC_SETPREFERRED);
                    if (!hSet)
                        break;
                    if (i == 0)
                    {
                        EnableWindow(hSet, FALSE);
                        Button_SetCheck(hSet, 0);
                    }
                    else
                        EnableWindow(hSet, TRUE);
                    break;
                }
            }
            break;
        case IDC_SETPREFERRED:
            if (Button_GetCheck(hctl) != 0)
            {
                TCHAR sz[256];
                HWND hName;
                hName = GetDlgItem(hdlg, IDD_ACMFORMATCHOOSE_CMB_CUSTOM);
                if (!hName)
                    break;
                ComboBox_GetText(hName, sz, SIZEOF(sz));
                SoundRec_SetDefaultFormat(sz);
            }
            break;
            
        default:
            break;
    }
    return FALSE;
}

UINT CALLBACK SoundRec_NewDlgHook(
     HWND       hwnd,
     UINT       uMsg,
     WPARAM     wParam,
     LPARAM     lParam)
{
     switch(uMsg)
     {
         case WM_COMMAND:
             HANDLE_WM_COMMAND(hwnd, wParam, lParam, NewDlg_OnCommand);
             break;
         default:
             break;
     }
     return FALSE;
}
#endif                    
#endif
/* NewSndDialog()
 *
 * NewSndDialog - put up the new sound dialog box
 *
 *---------------------------------------------------------------------
 * 6/15/93      TimHa
 * Change to only work with ACM 2.0 chooser dialog or just default
 * to a 'best' format for the machine.
 *---------------------------------------------------------------------
 *
 */
BOOL FAR PASCAL
NewSndDialog(
    HINSTANCE       hInst,
    HWND            hwndParent,
    PWAVEFORMATEX   pwfxPrev,
    UINT            cbPrev,
    PWAVEFORMATEX   *ppWaveFormat,
    PUINT           pcbWaveFormat)
{
    ACMFORMATCHOOSE     cwf;
    MMRESULT            mmr;
    PWAVEFORMATEX       pwfx;
    DWORD               cbwfx;

    DPF(TEXT("NewSndDialog called\n"));
    
    *ppWaveFormat   = NULL;
    *pcbWaveFormat  = 0;
    
    gfInFileNew     = TRUE;

    mmr = acmMetrics(NULL
                     , ACM_METRIC_MAX_SIZE_FORMAT
                     , (LPVOID)&gdwMaxFormatSize);

    if (mmr != MMSYSERR_NOERROR || gdwMaxFormatSize == 0L)
        goto NewSndDefault;

    //
    // allocate a buffer at least as large as the previous
    // choice or the maximum format
    //
    cbwfx = max(cbPrev, gdwMaxFormatSize);
    pwfx  = (PWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)cbwfx);
    if (NULL == pwfx)
        goto NewSndDefault;

    ZeroMemory(&cwf,sizeof(cwf));

    cwf.cbStruct    = sizeof(cwf);
    cwf.hwndOwner   = hwndParent;

    //
    // Give them an input format when they can record.
    //
    if (waveInGetNumDevs())
        cwf.fdwEnum     = ACM_FORMATENUMF_INPUT;
    else
        cwf.fdwEnum     = 0L;

    if (pwfxPrev)
    {
        CopyMemory(pwfx, pwfxPrev, cbPrev);
        cwf.fdwStyle = ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT;
    }

    cwf.pwfx        = (LPWAVEFORMATEX)pwfx;
    cwf.cbwfx       = cbwfx;

    cwf.hInstance   = ghInst;
#ifdef CHICAGO
    cwf.fdwStyle    |= ACMFORMATCHOOSE_STYLEF_CONTEXTHELP;    
#endif
    
    mmr = acmFormatChoose(&cwf);
    if (mmr == MMSYSERR_NOERROR)
    {
        *ppWaveFormat   = pwfx;
        *pcbWaveFormat  = (UINT)cwf.cbwfx;
    }
    else
    {
        GlobalFreePtr(pwfx);
    }
    
    gfInFileNew = FALSE;        // outta here
    
    return (mmr == MMSYSERR_NOERROR);                // return our result
    
NewSndDefault:
    
    if (SoundRec_GetDefaultFormat(&pwfx, &cbwfx))
    {
        if (waveInOpen(NULL
                       , (UINT)WAVE_MAPPER
                       , (LPWAVEFORMATEX)pwfx
                       , 0L
                       , 0L
                       , WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC) == MMSYSERR_NOERROR)
        {
            *ppWaveFormat   = pwfx;
            *pcbWaveFormat  = cbwfx;

            gfInFileNew = FALSE;        // outta here
            
            return TRUE;
        }
        else
            GlobalFreePtr(pwfx);
    }
    
    cbwfx = sizeof(WAVEFORMATEX);
    pwfx  = (WAVEFORMATEX *)GlobalAllocPtr(GHND, sizeof(WAVEFORMATEX));

    if (pwfx == NULL)
        return FALSE;

    CreateWaveFormat(pwfx,FMT_DEFAULT,(UINT)WAVE_MAPPER);
    
    *ppWaveFormat   = pwfx;
    *pcbWaveFormat  = cbwfx;
    
    gfInFileNew = FALSE;        // outta here
    
    return TRUE;

} /* NewSndDialog() */

#endif

/* These functions previously expected to dynaload ACM.  From
 * now on, we implicitly load ACM.
 */

/* LoadACM()
 */
void FAR PASCAL
LoadACM()
{
#ifdef CHICAGO        
    extern UINT guChooserContextMenu;
    extern UINT guChooserContextHelp;
#endif
    
    guiACMHlpMsg = RegisterWindowMessage(ACMHELPMSGSTRING);
    
#ifdef CHICAGO    
    guChooserContextMenu = RegisterWindowMessage( ACMHELPMSGCONTEXTMENU );
    guChooserContextHelp = RegisterWindowMessage( ACMHELPMSGCONTEXTHELP );
#endif
    
} /* LoadACM() */

/* Free the MSACM[32] DLL.  Inverse of LoadACM.
 */
void FreeACM(void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\soundrec.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* SoundRec.c
 *
 * SoundRec main loop etc.
 * Revision History.
 * 4/2/91  LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 * 21/2/94 LaurieGr Merged Daytona and Motown versions
 *         LaurieGr Merged common button and trackbar code from StephenE
 */

#undef NOWH                     // Allow SetWindowsHook and WH_*
#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <htmlhelp.h>

#ifdef USE_MMCNTRLS
#include "mmcntrls.h"
#else
#include <commctrl.h>
#include "buttons.h"
#endif

#include <mmreg.h>

#define INCLUDE_OLESTUBS
#include "soundrec.h"
#include "srecids.h"
#include "fixreg.h"
#include "reg.h"
#include "convert.h"
#include "helpids.h"

#include <stdarg.h>
#include <stdio.h>

/* globals */

BOOL            gfUserClose;            // user-driven shutdown
HWND            ghwndApp;               // main application window
HINSTANCE       ghInst;                 // program instance handle
TCHAR           gachFileName[_MAX_PATH];// current file name (or UNTITLED)
BOOL            gfDirty;                // file was modified and not saved?
BOOL            gfClipboard;            // we have data in clipboard
int             gfErrorBox;             // TRUE if we have a message box active
HICON           ghiconApp;              // app's icon
HWND            ghwndWaveDisplay;       // waveform display window handle
HWND            ghwndScroll;            // scroll bar control window handle
HWND            ghwndPlay;              // Play button window handle
HWND            ghwndStop;              // Stop button window handle
HWND            ghwndRecord;            // Record button window handle
#ifdef THRESHOLD
HWND            ghwndSkipStart;         // Needed to enable/disable...
HWND            ghwndSkipEnd;           // ...the skip butons
#endif //THRESHOLD
HWND            ghwndForward;           // [>>] button
HWND            ghwndRewind;            // [<<] button
BOOL            gfWasPlaying;           // was playing before scroll, fwd, etc.
BOOL            gfWasRecording;         // was recording before scroll etc.
BOOL            gfPaused;               // are we paused now?
BOOL            gfPausing;              // are we stopping into a paused state?
HWAVE           ghPausedWave;           // holder for the paused wave handle

int             gidDefaultButton;       // which button should have input focus
BOOL            gfEmbeddedObject;       // Are we editing an embedded object?
BOOL            gfRunWithEmbeddingFlag; // TRUE if we are run with "-Embedding"
BOOL            gfHideAfterPlaying;
BOOL            gfShowWhilePlaying;
BOOL            gfInUserDestroy = FALSE;
TCHAR           chDecimal = TEXT('.');
BOOL            gfLZero = 1;            // do we use leading zeros?
BOOL            gfIsRTL = 0;       // no compile BIDI
UINT            guiACMHlpMsg = 0;       // help message from ACM, none == 0

//Data used for supporting context menu help
BOOL   bF1InMenu=FALSE;					//If true F1 was pressed on a menu item.
UINT   currMenuItem=0;					//The current selected menu item if any.


BITMAPBTN       tbPlaybar[] = {
    { ID_REWINDBTN   - ID_BTN_BASE, ID_REWINDBTN, 0 },       /* index 0 */
    { ID_FORWARDBTN  - ID_BTN_BASE, ID_FORWARDBTN,0 },       /* index 1 */
    { ID_PLAYBTN     - ID_BTN_BASE, ID_PLAYBTN,   0 },       /* index 2 */
    { ID_STOPBTN     - ID_BTN_BASE, ID_STOPBTN,   0 },       /* index 3 */
    { ID_RECORDBTN   - ID_BTN_BASE, ID_RECORDBTN, 0 }        /* index 4 */
};

#include <msacmdlg.h>

#ifdef CHICAGO

/* these id's are part of the main windows help file */
#define IDH_AUDIO_CUST_ATTRIB   2403
#define IDH_AUDIO_CUST_FORMAT   2404
#define IDH_AUDIO_CUST_NAME 2405
#define IDH_AUDIO_CUST_REMOVE   2406
#define IDH_AUDIO_CUST_SAVEAS   2407

const DWORD aChooserHelpIds[] = {
    IDD_ACMFORMATCHOOSE_CMB_FORMAT,     IDH_AUDIO_CUST_ATTRIB,
    IDD_ACMFORMATCHOOSE_CMB_FORMATTAG,  IDH_AUDIO_CUST_FORMAT,
    IDD_ACMFORMATCHOOSE_CMB_CUSTOM,     IDH_AUDIO_CUST_NAME,
    IDD_ACMFORMATCHOOSE_BTN_DELNAME,    IDH_AUDIO_CUST_REMOVE,
    IDD_ACMFORMATCHOOSE_BTN_SETNAME,    IDH_AUDIO_CUST_SAVEAS,
    0, 0
};

UINT guChooserContextMenu = 0;
UINT guChooserContextHelp = 0;
#endif

/*
 * constants
 */
SZCODE          aszNULL[]       = TEXT("");
SZCODE          aszClassKey[]   = TEXT(".wav");
SZCODE          aszIntl[]       = TEXT("Intl");

/*
 * statics
 */
static HHOOK    hMsgHook;

/*
 * functions
 */
BOOL SoundRec_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);
BOOL SoundRec_OnDrawItem(HWND hwnd, const DRAWITEMSTRUCT *lpdis);
void SoundRec_ControlPanel(HINSTANCE hinst, HWND hwnd);
BOOL NEAR PASCAL FreeWaveHeaders(void);

/*
 * HelpMsgFilter - filter for F1 key in dialogs
 */
LRESULT CALLBACK
HelpMsgFilter(
    int         nCode,
    WPARAM      wParam,
    LPARAM      lParam)
{
    LPMSG       msg;
	    
    if (nCode >= 0){
	msg = (LPMSG)lParam;
	if ((msg->message == WM_KEYDOWN) && (LOWORD(msg->wParam) == VK_F1))
	{
		// testing for <0 tests MSB whether int is 16 or 32 bits
	    // MSB set means key is down

	    if (( GetAsyncKeyState(VK_SHIFT)
		| GetAsyncKeyState(VK_CONTROL)
		| GetAsyncKeyState(VK_MENU)) < 0 )
		    //
		    // do nothing
		    //
		    ;
	    else
	    {
			if(nCode == MSGF_MENU)
            {
				bF1InMenu = TRUE;
			    SendMessage(ghwndApp, WM_COMMAND, IDM_HELPTOPICS, 0L);
            }
	    }
	}
    }
    return CallNextHookEx(hMsgHook, nCode, wParam, lParam);
}

/* WinMain(hInst, hPrev, lpszCmdLine, cmdShow)
 *
 * The main procedure for the App.  After initializing, it just goes
 * into a message-processing loop until it gets a WM_QUIT message
 * (meaning the app was closed).
 */
int WINAPI                      // returns exit code specified in WM_QUIT
WinMain(
    HINSTANCE hInst,            // instance handle of current instance
    HINSTANCE hPrev,            // instance handle of previous instance
    LPSTR lpszCmdLine,          // null-terminated command line
    int iCmdShow)               // how window should be initially displayed
{
    HWND            hDlg;
    MSG             rMsg;

    //
    // save instance handle for dialog boxes
    //
    ghInst = hInst;

    DPF(TEXT("AppInit ...\n"));
    //
    // call initialization procedure
    //
    if (!AppInit(hInst, hPrev))
    {
	DPF(TEXT("AppInit failed\n"));
	return FALSE;
    }

    //
    // setup the message filter to handle grabbing F1 for this task
    //
    hMsgHook = SetWindowsHookEx(WH_MSGFILTER, HelpMsgFilter, ghInst, GetCurrentThreadId());

    //
    // display "SoundRec" dialog box
    //
    hDlg = CreateDialogParam( ghInst
			    , MAKEINTRESOURCE(IDD_SOUNDRECBOX)
			    , NULL
			    , SoundRecDlgProc
			    , iCmdShow );
    if (hDlg)
    {
	//
	// Polling messages from event queue
	//
	while (GetMessage(&rMsg, NULL, 0, 0))
	{
	    if (ghwndApp) {
		if (TranslateAccelerator(ghwndApp, ghAccel, &rMsg))
		    continue;

		if (IsDialogMessage(ghwndApp,&rMsg))
		    continue;
	    }

	    TranslateMessage(&rMsg);
	    DispatchMessage(&rMsg);
	}
    }

    //
    // free the current document
    //
    DestroyWave();

    //
    // if the message hook was installed, remove it and free
    // up our proc instance for it.
    //
    if (hMsgHook)
    {
	UnhookWindowsHookEx(hMsgHook);
    }

    //
    // random cleanup
    //
    DeleteObject(ghbrPanel);

    if(gfOleInitialized)
    {
	FlushOleClipboard();
	OleUninitialize();
	gfOleInitialized = FALSE;
    }


    return TRUE;
}

/*
 * Process file drop/drag options.
 */
void SoundRec_OnDropFiles(
    HWND        hwnd,
    HDROP       hdrop)
{
    TCHAR    szPath[_MAX_PATH];

    if (DragQueryFile(hdrop, (UINT)(-1), NULL, 0) > 0)
    {
	//
	// If user dragged/dropped a file regardless of keys pressed
	// at the time, open the first selected file from file
	// manager.
	//
	DragQueryFile(hdrop,0,szPath,SIZEOF(szPath));
	SetActiveWindow(hwnd);

	ResolveIfLink(szPath);

	if (FileOpen(szPath))
	{
	    gfHideAfterPlaying = FALSE;
	    //
	    // This is a bit hacked.  The Ole caption should just never change.
	    //
	    if (gfEmbeddedObject && !gfLinked)
	    {
		LPTSTR      lpszObj, lpszApp;
		extern void SetOleCaption(LPTSTR lpsz);

		DoOleSave();
		AdviseSaved();

		OleObjGetHostNames(&lpszApp,&lpszObj);
		lpszObj = (LPTSTR)FileName((LPCTSTR)lpszObj);
		SetOleCaption(lpszObj);
	    }
	    PostMessage(ghwndApp, WM_COMMAND, ID_PLAYBTN, 0L);
	}
    }
    DragFinish(hdrop);     // Delete structure alocated
}

/* Pause(BOOL fBeginPause)
 *
 * If <fBeginPause>, then if user is playing or recording do a StopWave().
 * The next call to Pause() should have <fBeginPause> be FALSE -- this will
 * cause the playing or recording to be resumed (possibly at a new position
 * if <glWavePosition> changed.
 */
void
Pause(BOOL fBeginPause)
{
    if (fBeginPause) {
	if (ghWaveOut != NULL) {
#ifdef NEWPAUSE
	    gfPausing = TRUE;
	    gfPaused = FALSE;
	    ghPausedWave = (HWAVE)ghWaveOut;
#endif
	    gfWasPlaying = TRUE;

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	}
	else if (ghWaveIn != NULL) {
#ifdef NEWPAUSE
	    gfPausing = TRUE;
	    gfPaused = FALSE;
	    ghPausedWave = (HWAVE)ghWaveIn;
#endif
	    gfWasRecording = TRUE;

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	}
    }
    else {
	if (gfWasPlaying) {
	    gfWasPlaying = FALSE;
	    PlayWave();
#ifdef NEWPAUSE
	    gfPausing = FALSE;
	    gfPaused = FALSE;
#endif
	}
	else if (gfWasRecording) {
	    gfWasRecording = FALSE;
	    RecordWave();
#ifdef NEWPAUSE
	    gfPausing = FALSE;
	    gfPaused = FALSE;
#endif
	}
    }
}

void DoHtmlHelp()
{
	//note, using ANSI version of function because UNICODE is foobar in NT5 builds
    char chDst[MAX_PATH];
    WideCharToMultiByte(CP_ACP, 0, gachHtmlHelpFile, 
									    -1, chDst, MAX_PATH, NULL, NULL); 
	HtmlHelpA(GetDesktopWindow(), chDst, HH_DISPLAY_TOPIC, 0L);
}
	 

void ProcessHelp(HWND hwnd)
{
	static TCHAR HelpFile[] = TEXT("SOUNDREC.HLP");
	
	//Handle context menu help
	if(bF1InMenu) 
	{
		switch(currMenuItem)
		{
		case IDM_NEW:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_NEW);
		break;
		case IDM_OPEN:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_OPEN);
		break;
		case IDM_SAVE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_SAVE);
		break;
		case IDM_SAVEAS:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_SAVE_AS);
		break;
		case IDM_REVERT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_REVERT);
		break;
		case IDM_PROPERTIES:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_PROPERTIES);
		break;
		case IDM_EXIT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_FILE_EXIT);
		break;
		case IDM_COPY:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_COPY);
		break;
		case IDM_PASTE_INSERT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_PASTE_INSERT);
		break;
		case IDM_PASTE_MIX:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_PASTE_MIX);
		break;
		case IDM_INSERTFILE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_INSERT_FILE);
		break;
		case IDM_MIXWITHFILE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_MIX_WITH_FILE);
		break;
		case IDM_DELETEBEFORE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_DELETE_BEFORE_CURRENT_POSITION);
		break;
		case IDM_DELETEAFTER:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_DELETE_AFTER_CURRENT_POSITION);
		break;
		case IDM_VOLUME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EDIT_AUDIO_PROPERTIES);
		break;
		case IDM_INCREASEVOLUME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_INCREASE_VOLUME);
		break;
		case IDM_DECREASEVOLUME:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_DECREASE_VOLUME);
		break;
		case IDM_MAKEFASTER:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_INCREASE_SPEED);
		break;
		case IDM_MAKESLOWER:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_DECREASE_SPEED);
		break;
		case IDM_ADDECHO:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_ADD_ECHO);
		break;
		case IDM_REVERSE:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_EFFECTS_REVERSE);
		break;
		case IDM_HELPTOPICS:
		case IDM_INDEX:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_HELP_HELP_TOPICS);
		break;
		case IDM_ABOUT:
			WinHelp(hwnd, HelpFile, HELP_CONTEXTPOPUP, IDH_SOUNDREC_SNDRC_CS_HELP_ABOUT);
		break;
		default://In the default case just display the HTML Help.
			DoHtmlHelp();
		}
		bF1InMenu = FALSE; //This flag will be set again if F1 is pressed in a menu.
	}
	else
		DoHtmlHelp();
}

/*
 * SoundRec_OnCommand
 */
BOOL
SoundRec_OnCommand(
    HWND            hwnd,
    int             id,
    HWND            hwndCtl,
    UINT            codeNotify)
{

    if (gfHideAfterPlaying && id != ID_PLAYBTN)
    {
	DPF(TEXT("Resetting HideAfterPlaying\n"));
	gfHideAfterPlaying = FALSE;
    }

    switch (id)
    {
	case IDM_NEW:

	    if (PromptToSave(FALSE, FALSE) == enumCancel)
		return FALSE;
#ifdef CHICAGO
	    if (FileNew(FMT_DEFAULT,TRUE,FALSE))
#else
	    if (FileNew(FMT_DEFAULT,TRUE,TRUE))
#endif
	    {
		/* return to being a standalone */
		gfHideAfterPlaying = FALSE;
	    }

	    break;

	case IDM_OPEN:

	    if (FileOpen(NULL)) {
		/* return to being a standalone */
		gfHideAfterPlaying = FALSE;
	    }

	    if (IsWindowEnabled(ghwndPlay))
	    {
		SetDlgFocus(ghwndPlay);
	    }
	    break;

	case IDM_SAVE:      // also OLE UPDATE
	    if (!gfEmbeddedObject || gfLinked)
	    {
		if (!FileSave(FALSE))
		    break;
	    }
	    else
	    {
		DoOleSave();
		gfDirty = FALSE;
	    }
	    break;

	case IDM_SAVEAS:
	    if (FileSave(TRUE))
	    {
		/* return to being a standalone */
		gfHideAfterPlaying = FALSE;
	    }
	    break;

	case IDM_REVERT:
	    UpdateWindow(hwnd);

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	    SnapBack();

	    if (FileRevert())
	    {
		/* return to being a standalone */
		gfHideAfterPlaying = FALSE;
	    }
	    break;

	case IDM_EXIT:
	    PostMessage(hwnd, WM_CLOSE, 0, 0L);
	    return TRUE;

	case IDCANCEL:

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	    SnapBack();
	    break;

	case IDM_COPY:
	    if (!gfOleInitialized)
	    {
		InitializeOle(ghInst);
		if (gfStandalone && gfOleInitialized)
		    CreateStandaloneObject();
	    }
	    TransferToClipboard();
	    gfClipboard = TRUE;
	    break;

	case IDM_PASTE_INSERT:
	case IDM_INSERTFILE:
	    UpdateWindow(hwnd);

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	    SnapBack();
	    InsertFile(id == IDM_PASTE_INSERT);
	    break;

	case IDM_PASTE_MIX:
	case IDM_MIXWITHFILE:
	    UpdateWindow(hwnd);

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	    SnapBack();
	    MixWithFile(id == IDM_PASTE_MIX);
	    break;

	case IDM_DELETEBEFORE:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    DeleteBefore();
	    Pause(FALSE);
	    break;

	case IDM_DELETE:
	    if (glWaveSamplesValid == 0L)
		return 0L;

	    glWavePosition = 0L;

	    // fall through to delete after.

	case IDM_DELETEAFTER:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    DeleteAfter();
	    Pause(FALSE);
	    break;

#ifdef THRESHOLD
// Threshold was an experiment to allow facilities to skip to the start
// of the sound or to the end of the sound.  The trouble was that it
// required the ability to detect silence and different sound cards in
// different machines with different background noises gave quite different
// ideas of what counted as silence.  Manual control over the threshold level
// did sort-of work but was just too complicated.  It really wanted to be
// intuitive or intelligent (or both).
	case IDM_SKIPTOSTART:
	case ID_SKIPSTARTBTN:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    SkipToStart();
	    Pause(FALSE);
	    break;

	case ID_SKIPENDBTN:
	case IDM_SKIPTOEND:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    SkipToEnd();
	    Pause(FALSE);
	    break;

	case IDM_INCREASETHRESH:
	    IncreaseThresh();
	    break;

	case IDM_DECREASETHRESH:
	    DecreaseThresh();
	    break;
#endif //THRESHOLD

	case IDM_INCREASEVOLUME:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    ChangeVolume(TRUE);
	    Pause(FALSE);
	    break;

	case IDM_DECREASEVOLUME:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    ChangeVolume(FALSE);
	    Pause(FALSE);
	    break;

	case IDM_MAKEFASTER:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    MakeFaster();
	    Pause(FALSE);
	    break;

	case IDM_MAKESLOWER:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    MakeSlower();
	    Pause(FALSE);
	    break;

	case IDM_ADDECHO:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    AddEcho();
	    Pause(FALSE);
	    break;

#if defined(REVERB)
	case IDM_ADDREVERB:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    AddReverb();
	    Pause(FALSE);
	    break;
#endif //REVERB

	case IDM_REVERSE:
	    UpdateWindow(hwnd);
	    Pause(TRUE);
	    Reverse();
	    Pause(FALSE);
	    break;

	case IDM_VOLUME:
	    SoundRec_ControlPanel(ghInst, hwnd);
	    break;

	case IDM_PROPERTIES:
	{
	    WAVEDOC wd;
	    SGLOBALS sg;
	    DWORD dw;

	    wd.pwfx     = gpWaveFormat;
	    wd.pbdata   = gpWaveSamples;
	    wd.cbdata   = wfSamplesToBytes(gpWaveFormat, glWaveSamplesValid);
	    wd.fChanged = FALSE;
	    wd.pszFileName  = (LPTSTR)FileName(gachFileName);
	    // 
	    // Need to extract these from the file
	    //
	    wd.hIcon    = NULL;
	    wd.pszCopyright = gpszInfo;
	    wd.lpv      = &sg;

	    //
	    // modify globals w/o returning from prop dialog
	    //
	    sg.ppwfx    = &gpWaveFormat;
	    sg.pcbwfx   = &gcbWaveFormat;
	    sg.pcbdata  = &dw;
	    sg.ppbdata  = &gpWaveSamples;
	    sg.plSamplesValid = &glWaveSamplesValid;
	    sg.plSamples = &glWaveSamples;
	    sg.plWavePosition = &dw;

	    SoundRec_Properties(hwnd, ghInst, &wd);
	    break;
	}

#ifndef CHICAGO
	case IDM_INDEX:
	    WinHelp(hwnd, gachHelpFile, HELP_INDEX, 0L);
	    break;

	case IDM_SEARCH:
	    WinHelp(hwnd, gachHelpFile, HELP_PARTIALKEY,
		    (DWORD)(LPTSTR)aszNULL);
	    break;
#else
	case IDM_HELPTOPICS:
		ProcessHelp(hwnd);
       break;
#endif

	case IDM_USINGHELP:
	    WinHelp(hwnd, (LPTSTR)NULL, HELP_HELPONHELP, 0L);
	    break;



	case IDM_ABOUT:
	{
	    LPTSTR lpAbout = NULL;
	    lpAbout = SoundRec_GetFormatName(gpWaveFormat);
	    ShellAbout(hwnd,
		       gachAppTitle,
		       lpAbout,
		       (HICON)SendMessage(hwnd, WM_QUERYDRAGICON, 0, 0L));
	    //                , ghiconApp
	    if (lpAbout)
		GlobalFreePtr(lpAbout);
	    break;
	}

	case ID_REWINDBTN:
#if 1
	    //Related to BombayBug 1609
	    Pause(TRUE);
	    glWavePosition = 0L;
	    Pause(FALSE);
	    UpdateDisplay(FALSE);
#else
	    //Behave as if the user pressed the 'Home' key
	    //Call the handler directly
	    SoundRec_OnHScroll(hwnd,ghwndScroll,SB_TOP,0);
#endif
	    break;

	case ID_PLAYBTN:
	    // checks for empty file moved to PlayWave in wave.c
	    // if at end of file, go back to beginning.
	    if (glWavePosition == glWaveSamplesValid)
		glWavePosition = 0;

	    PlayWave();
	    break;

	case ID_STOPBTN:
	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();

//       I added this update because StopWave doesn't call it and
//       if you hit stop too quickly, the buttons aren't updated
//       Should StopWave() be calling UpdateDisplay()?

	    UpdateDisplay(TRUE);
	    SnapBack();
	    break;

	case ID_RECORDBTN:
	    /* Never let us be forced to quit after recording. */
	    gfHideAfterPlaying = FALSE;
	    RecordWave();
	    break;

	case ID_FORWARDBTN:
#if 1
	    //Bombay bug 1610
	    //Behave as if the user pressed the 'End' key
	    Pause(TRUE);
	    glWavePosition = glWaveSamplesValid;
	    Pause(FALSE);
	    UpdateDisplay(FALSE);
#else
	    //Call the handler directly
	    SoundRec_OnHScroll(hwnd,ghwndScroll,SB_BOTTOM,0);
#endif
	    break;

	default:
	    return FALSE;
    }
    return TRUE;
} /* SoundRec_OnCommand */


/*
 * handle WM_INIT from SoundRecDlgProc
 */
void
SoundRec_OnInitMenu(HWND hwnd, HMENU hMenu)
{
    BOOL    fUntitled;      // file is untitled?
    UINT    mf;

    //
    // see if we can insert/mix into this file.
    //
    mf = (glWaveSamplesValid == 0 || IsWaveFormatPCM(gpWaveFormat))
	 ? MF_ENABLED : MF_GRAYED;

    EnableMenuItem(hMenu, IDM_INSERTFILE  , mf);
    EnableMenuItem(hMenu, IDM_MIXWITHFILE , mf);

    //
    // see if any CF_WAVE data is in the clipboard
    //
    mf = ( (mf == MF_ENABLED)
	 && IsClipboardFormatAvailable(CF_WAVE) //DOWECARE (|| IsClipboardNative())
	 ) ? MF_ENABLED : MF_GRAYED;

    EnableMenuItem(hMenu, IDM_PASTE_INSERT, mf);
    EnableMenuItem(hMenu, IDM_PASTE_MIX   , mf);

    //
    //  see if we can delete before or after the current position.
    //
    EnableMenuItem(hMenu, IDM_DELETEBEFORE, glWavePosition > 0 ? MF_ENABLED : MF_GRAYED);
    EnableMenuItem(hMenu, IDM_DELETEAFTER,  (glWaveSamplesValid-glWavePosition) > 0 ? MF_ENABLED : MF_GRAYED);

    //
    // see if we can do editing operations on the file.
    //
    mf = IsWaveFormatPCM(gpWaveFormat) ? MF_ENABLED : MF_GRAYED;

    EnableMenuItem(hMenu, IDM_INCREASEVOLUME , mf);
    EnableMenuItem(hMenu, IDM_DECREASEVOLUME , mf);
    EnableMenuItem(hMenu, IDM_MAKEFASTER     , mf);
    EnableMenuItem(hMenu, IDM_MAKESLOWER     , mf);
    EnableMenuItem(hMenu, IDM_ADDECHO        , mf);
    EnableMenuItem(hMenu, IDM_REVERSE        , mf);

    /* enable "Revert..." if the file was opened or saved
     * (not created using "New") and is currently dirty
     * and we're not using an embedded object
    */
    fUntitled = (lstrcmp(gachFileName, aszUntitled) == 0);
    EnableMenuItem( hMenu,
		    IDM_REVERT,
		    (!fUntitled && gfDirty && !gfEmbeddedObject)
			    ? MF_ENABLED : MF_GRAYED);

    if (gfHideAfterPlaying) {
	DPF(TEXT("Resetting HideAfterPlaying"));
	gfHideAfterPlaying = FALSE;
    }

} /* SoundRec_OnInitMenu() */

/*
 * Handle WM_HSCROLL from SoundRecDlgProc
 * */
BOOL
SoundRec_OnHScroll(
    HWND        hwnd,
    HWND        hwndCtl,
    UINT        code,
    int         pos)
{
    BOOL    fFineControl;
    long    lNewPosition;   // new position in wave buffer
    LONG    l;

    LONG    lBlockInc;
    LONG    lInc;

    fFineControl = (0 > GetKeyState(VK_SHIFT));

    if (gfHideAfterPlaying) {
	DPF(TEXT("Resetting HideAfterPlaying"));
	gfHideAfterPlaying = FALSE;
    }

    lBlockInc = wfBytesToSamples(gpWaveFormat,gpWaveFormat->nBlockAlign);

    switch (code)
    {
	case SB_LINEUP:         // left-arrow
	    // This is a mess.  NT implemented SHIFT and Motown implemented CTRL
	    // To do about the same thing!!
	    if (fFineControl)
		lNewPosition = glWavePosition - 1;
	    else {
		l = (GetKeyState(VK_CONTROL) < 0) ?
			(SCROLL_LINE_MSEC/10) : SCROLL_LINE_MSEC;

		lNewPosition = glWavePosition -
		    MulDiv(l, (long) gpWaveFormat->nSamplesPerSec, 1000L);
	    }
	    break;

	case SB_PAGEUP:         // left-page
	    // NEEDS SOMETHING SENSIBLE !!! ???
	    if (fFineControl)
		lNewPosition = glWavePosition - 10;
	    else
		lNewPosition = glWavePosition -
		    MulDiv((long) SCROLL_PAGE_MSEC,
		      (long) gpWaveFormat->nSamplesPerSec, 1000L);
	    break;

	case SB_LINEDOWN:       // right-arrow
	    if (fFineControl)
		lNewPosition = glWavePosition + 1;
	    else {
		l = (GetKeyState(VK_CONTROL) & 0x8000) ?
			(SCROLL_LINE_MSEC/10) : SCROLL_LINE_MSEC;
		lInc = MulDiv(l, (long) gpWaveFormat->nSamplesPerSec, 1000L);
		lInc = (lInc < lBlockInc)?lBlockInc:lInc;
		lNewPosition = glWavePosition + lInc;
	    }
	    break;

	case SB_PAGEDOWN:       // right-page
	    if (fFineControl)
		lNewPosition = glWavePosition + 10;
	    else {
		lInc = MulDiv((long) SCROLL_PAGE_MSEC,
			  (long) gpWaveFormat->nSamplesPerSec, 1000L);
		lInc = (lInc < lBlockInc)?lBlockInc:lInc;
		lNewPosition = glWavePosition + lInc;
	    }
	    break;

	case SB_THUMBTRACK:     // thumb has been positioned
	case SB_THUMBPOSITION:  // thumb has been positioned
	    lNewPosition = MulDiv(glWaveSamplesValid, pos, SCROLL_RANGE);
	    break;

	case SB_TOP:            // Home
	    lNewPosition = 0L;
	    break;

	case SB_BOTTOM:         // End
	    lNewPosition = glWaveSamplesValid;
	    break;

	case SB_ENDSCROLL:      // user released mouse button
	    /* resume playing, if necessary */
	    Pause(FALSE);
	    return TRUE;

	default:
	    return TRUE;

    }

    //
    // snap position to nBlockAlign
    //
    if (lNewPosition != glWaveSamplesValid)
	lNewPosition = wfSamplesToSamples(gpWaveFormat,lNewPosition);

    if (lNewPosition < 0)
	lNewPosition = 0;
    if (lNewPosition > glWaveSamplesValid)
	lNewPosition = glWaveSamplesValid;

    /* if user is playing or recording, pause until scrolling
     * is complete
     */
    Pause(TRUE);

    glWavePosition = lNewPosition;
    UpdateDisplay(FALSE);
    return TRUE;
} /* SoundRec_OnHScroll() */


/*
 * WM_SYSCOLORCHANGE needs to be send to all child windows (esp. trackbars)
 */
void SoundRec_PropagateMessage(
    HWND        hwnd,
    UINT        uMessage,
    WPARAM      wParam,
    LPARAM      lParam)
{
    HWND hwndChild;

    for (hwndChild = GetWindow(hwnd, GW_CHILD); hwndChild != NULL;
    hwndChild = GetWindow(hwndChild, GW_HWNDNEXT))
    {
	SendMessage(hwndChild, uMessage, wParam, lParam);
    }
}


/* SoundRecDlgProc(hwnd, wMsg, wParam, lParam)
 *
 * This function handles messages belonging to the main window dialog box.
 */
INT_PTR CALLBACK
SoundRecDlgProc(
    HWND            hwnd,
    UINT            wMsg,
    WPARAM          wParam,
    LPARAM          lParam)
{

    switch (wMsg)
    {

	case WM_BADREG:
	    //
	    // Bad registry entries detected.  Clean it up.
	    //
	    FixReg(hwnd);
	    return TRUE;

	case WM_COMMAND:
	    return HANDLE_WM_COMMAND( hwnd, wParam, lParam
				      , SoundRec_OnCommand );

	case WM_INITDIALOG:
	    //
	    // Start async registry check.
	    //
	    if (!IgnoreRegCheck())
		BackgroundRegCheck(hwnd);
	    //
	    // restore window position
	    //
	    SoundRec_GetSetRegistryRect(hwnd, SGSRR_GET);
	    return SoundDialogInit(hwnd, (int)lParam);

	case WM_SIZE:
	    return FALSE;   // let dialog manager do whatever else it wants

	case WM_WININICHANGE:
	    if (!lParam || !lstrcmpi((LPTSTR)lParam, aszIntl))
		if (GetIntlSpecs())
		    UpdateDisplay(TRUE);

	    return (TRUE);

	case WM_INITMENU:
	    HANDLE_WM_INITMENU(hwnd, wParam, lParam, SoundRec_OnInitMenu);
	    return (TRUE);

	case WM_PASTE:
	    UpdateWindow(hwnd);

	    // User intentionally stopped us.  Don't go away.
	    if (gfCloseAtEndOfPlay && IsWindowVisible(ghwndApp))
		gfCloseAtEndOfPlay = FALSE;

	    StopWave();
	    SnapBack();
	    InsertFile(TRUE);
	    break;

	case WM_DRAWITEM:
	    return HANDLE_WM_DRAWITEM( hwnd, wParam, lParam, SoundRec_OnDrawItem );

	case WM_NOTIFY:
	{
	    LPNMHDR         pnmhdr;
	    pnmhdr = (LPNMHDR)lParam;

	    //
	    // tooltips notifications
	    //
	    switch (pnmhdr->code)
	    {
		case TTN_NEEDTEXT:
		{
		    LPTOOLTIPTEXT       lpTt;
		    lpTt = (LPTOOLTIPTEXT)lParam;

		    LoadString( ghInst, (UINT)lpTt->hdr.idFrom, lpTt->szText
				, SIZEOF(lpTt->szText) );
		    break;
		}
		default:
		    break;
	    }
	    break;
	}

	case WM_HSCROLL:
	    HANDLE_WM_HSCROLL(hwnd, wParam, lParam, SoundRec_OnHScroll);
	    return (TRUE);

	case WM_SYSCOMMAND:
	    if (gfHideAfterPlaying)
	    {
		DPF(TEXT("Resetting HideAfterPlaying"));
		gfHideAfterPlaying = FALSE;
	    }

	    switch (wParam & 0xFFF0)
	    {
		case SC_CLOSE:
		    PostMessage(hwnd, WM_CLOSE, 0, 0L);
		    return TRUE;
	    }
	    break;

	case WM_QUERYENDSESSION:
	    if (PromptToSave(FALSE, TRUE) == enumCancel)
		return TRUE;

	    SoundRec_GetSetRegistryRect(hwnd, SGSRR_SET);
	   #if 0 // this is bogus if someone else cancels the shutdown!
	    ShowWindow(hwnd, SW_HIDE);
	   #endif
	    return FALSE;


	case WM_SYSCOLORCHANGE:
	    if (ghbrPanel)
		DeleteObject(ghbrPanel);

	    ghbrPanel = CreateSolidBrush(RGB_PANEL);
	    SoundRec_PropagateMessage(hwnd, wMsg, wParam, lParam);
	    break;

	case WM_ERASEBKGND:
	{
	    RECT            rcClient;       // client rectangle
	    GetClientRect(hwnd, &rcClient);
	    FillRect((HDC)wParam, &rcClient, ghbrPanel);
	    return TRUE;
	}

	case MM_WOM_DONE:
	    WaveOutDone((HWAVEOUT)wParam, (LPWAVEHDR) lParam);
	    return TRUE;

	case MM_WIM_DATA:
	    WaveInData((HWAVEIN)wParam, (LPWAVEHDR) lParam);
	    return TRUE;

	case WM_TIMER:
	    //
	    //  timer message is only used for SYNCRONOUS drivers
	    //
	    UpdateDisplay(FALSE);
	    return TRUE;

	case WM_MENUSELECT:
		//Keep track of which menu bar item is currently popped up.
		//This will be used for displaying the appropriate help from the mplayer.hlp file
		//when the user presses the F1 key.
		currMenuItem = (UINT)LOWORD(wParam);
		return TRUE;

	case MM_WIM_CLOSE:
	    return TRUE;

	case WM_CTLCOLORBTN:
	case WM_CTLCOLORSTATIC:
	{
	    POINT           pt;
	    pt.x = pt.y = 0;
	    ClientToScreen((HWND)lParam, &pt);
	    ScreenToClient(hwnd, &pt);
	    SetBrushOrgEx((HDC) wParam, -pt.x, -pt.y, NULL);
	    return (INT_PTR)ghbrPanel;
	}

	case WM_CLOSE:
	    if (gfInUserDestroy)
	    {
		DestroyWindow(hwnd);
		return TRUE;
	    }

	    DPF(TEXT("WM_CLOSE received\n"));
	    gfUserClose = TRUE;
	    if (gfHideAfterPlaying)
	    {
		DPF(TEXT("Resetting HideAfterPlaying\n"));
		gfHideAfterPlaying = FALSE;
	    }
	    if (gfErrorBox) {
		//  DPF("we have a error box up, ignoring WM_CLOSE.\n");
		return TRUE;
	    }
	    if (PromptToSave(TRUE, FALSE) == enumCancel)
		return TRUE;

	    //
	    // Don't free our data before terminating.  When the clipboard
	    // is flushed, we need to commit the data.
	    //
	    TerminateServer();
	    FileNew(FMT_DEFAULT, FALSE, FALSE);
	    FreeACM();
        FreeWaveHeaders();

	    //
	    //  NOTE: TerminateServer() will destroy the window!
	    //
	    SoundRec_GetSetRegistryRect(hwnd, SGSRR_SET);
	    return TRUE; //!!!

	case WM_USER_DESTROY:
	    DPF(TEXT("WM_USER_DESTROY\n"));

	    if (ghWaveOut || ghWaveIn) {
		DPF(TEXT("Ignoring, we have a device open.\n"));
		//
		// Close later, when the play finishes.
		//
		return TRUE;
	    }
	    gfInUserDestroy = TRUE;
	    PostMessage(hwnd, WM_CLOSE, 0, 0);
	    return TRUE;

	case WM_DESTROY:
	    DPF(TEXT("WM_DESTROY\n"));

	    WinHelp(hwnd, gachHelpFile, HELP_QUIT, 0L);
	    ghwndApp = NULL;

	    //
	    //  Tell my app to die
	    //
	    PostQuitMessage(0);
	    return TRUE;

	case WM_DROPFILES:
	    HANDLE_WM_DROPFILES(hwnd, wParam, lParam, SoundRec_OnDropFiles);
	    break;

	default:
#ifdef CHICAGO
	    //
	    // if we have an ACM help message registered see if this
	    // message is it.
	    //
	    if (guiACMHlpMsg && wMsg == guiACMHlpMsg)
	    {
		//
		// message was sent from ACM because the user
		// clicked on the HELP button on the chooser dialog.
		// report help for that dialog.
		//
		WinHelp(hwnd, gachHelpFile, HELP_CONTEXT, IDM_NEW);
		return TRUE;
	    }

	    //
	    //  Handle context-sensitive help messages from acm dialog
	    //
	    if( wMsg == guChooserContextMenu )
	    {
		WinHelp( (HWND)wParam, NULL, HELP_CONTEXTMENU,
			   (UINT_PTR)(LPSTR)aChooserHelpIds );
	    }
	    else if( wMsg == guChooserContextHelp )
	    {
		WinHelp( ((LPHELPINFO)lParam)->hItemHandle, NULL,
			HELP_WM_HELP, (UINT_PTR)(LPSTR)aChooserHelpIds );
	    }
#endif
	    break;
    }
    return FALSE;

} /* SoundRecDlgProc */

/*
 * Bitmap Buttons
 * */
BOOL SoundRec_OnDrawItem (
    HWND        hwnd,
    const DRAWITEMSTRUCT *lpdis )
{
    int         i;

    i = lpdis->CtlID - ID_BTN_BASE;

    if (lpdis->CtlType == ODT_BUTTON ) {

	/*
	** Now draw the button according to the buttons state information.
	*/

	tbPlaybar[i].fsState = LOBYTE(lpdis->itemState);

	if (lpdis->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {

	    BtnDrawButton( hwnd, lpdis->hDC, (int)lpdis->rcItem.right,
			   (int)lpdis->rcItem.bottom,
			   &tbPlaybar[i] );
	    return(TRUE);
	}
	else if (lpdis->itemAction & ODA_FOCUS) {

	    BtnDrawFocusRect(lpdis->hDC, &lpdis->rcItem, lpdis->itemState);
	    return(TRUE);
	}
    }
    return(FALSE);
}



/*
 * void SoundRec_ControlPanel
 *
 * Launch "Audio" control panel/property sheet upon request.
 *
 * */
void SoundRec_ControlPanel(
    HINSTANCE   hInst,
    HWND        hParent)
{
    const TCHAR gszOpen[]     = TEXT("open");
    const TCHAR gszRunDLL[]   = TEXT("RUNDLL32.EXE");
    const TCHAR gszMMSYSCPL[] = TEXT("MMSYS.CPL,ShowAudioPropertySheet");
    ShellExecute (NULL, gszOpen, gszRunDLL, gszMMSYSCPL, NULL, SW_SHOWNORMAL);
}


/* ResolveLink
 *
 * This routine is called when the user drags and drops a shortcut
 * onto Media Player.  If it succeeds, it returns the full path
 * of the actual file in szResolved.
 */
BOOL ResolveLink(LPTSTR szPath, LPTSTR szResolved, LONG cbSize)
{
    IShellLink *psl = NULL;
    HRESULT hres;

    if (!gfOleInitialized)
    {
	if (!InitializeOle(ghInst))
	    return FALSE;
    }

    hres = CoCreateInstance(&CLSID_ShellLink, NULL, CLSCTX_INPROC,
			    &IID_IShellLink, &psl);

    if (SUCCEEDED(hres) && (psl != NULL))
    {
	IPersistFile *ppf;

	psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);

	if (ppf)
	{
	    WCHAR wszPath[MAX_PATH];
#ifdef UNICODE
	    lstrcpy (wszPath, szPath);
#else
	    AnsiToUnicodeString(szPath, wszPath, UNKNOWN_LENGTH);
#endif
	    hres = ppf->lpVtbl->Load(ppf, wszPath, 0);
	    ppf->lpVtbl->Release(ppf);

	    if (FAILED(hres))
	    {
		psl->lpVtbl->Release(psl);
		psl = NULL;
	    }
	}
	else
	{
	    psl->lpVtbl->Release(psl);
	    psl = NULL;
	}
    }   

    if (psl)
    {
	psl->lpVtbl->Resolve(psl, NULL, SLR_NO_UI);
	psl->lpVtbl->GetPath(psl, szResolved, cbSize, NULL, 0);
	psl->lpVtbl->Release(psl);
    }

    return SUCCEEDED(hres);
}


/* ResolveIfLink
 *
 * Called to check whether a given file name is a shortcut
 * on Windows 95.
 *
 * Copies the resolved file name into the buffer provided,
 * overwriting the original name.
 *
 * Returns TRUE if the function succeeded, whether or not the
 * file name was changed.  FALSE indicates that an error occurred.
 *
 * Andrew Bell, 16 February 1995
 */
BOOL ResolveIfLink(PTCHAR szFileName)
{
    SHFILEINFO sfi;
    BOOL       rc = TRUE;

    if ((SHGetFileInfo(szFileName, 0, &sfi, sizeof sfi, SHGFI_ATTRIBUTES) == 1)
	&& ((sfi.dwAttributes & SFGAO_LINK) == SFGAO_LINK))
    {
	TCHAR szResolvedLink[MAX_PATH];

	if (ResolveLink(szFileName, szResolvedLink, SIZEOF(szResolvedLink)))
	    lstrcpy(szFileName, szResolvedLink);
	else
	    rc = FALSE;
    }

    return rc;
}



#if DBG
void FAR cdecl dprintfA(LPSTR szFormat, ...)
{
    char ach[128];
    int  s,d;
    va_list va;

    va_start(va, szFormat);
    s = vsprintf (ach,szFormat, va);
    va_end(va);

    for (d=sizeof(ach)-1; s>=0; s--)
    {
	if ((ach[d--] = ach[s]) == '\n')
	    ach[d--] = '\r';
    }

    OutputDebugStringA("SNDREC32: ");
    OutputDebugStringA(ach+d+1);
}
#ifdef UNICODE
void FAR cdecl dprintfW(LPWSTR szFormat, ...)
{
    WCHAR ach[128];
    int  s,d;
    va_list va;

    va_start(va, szFormat);
    s = vswprintf (ach,szFormat, va);
    va_end(va);

    for (d=(sizeof(ach)/sizeof(WCHAR))-1; s>=0; s--)
    {
	if ((ach[d--] = ach[s]) == TEXT('\n'))
	    ach[d--] = TEXT('\r');
    }

    OutputDebugStringW(TEXT("SNDREC32: "));
    OutputDebugStringW(ach+d+1);
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\srs.cxx ===
//+---------------------------------------------------------------------
//
//   File:       srs.cxx
//
//   Contents:   OLE2 Server Class code
//
//   Classes:
//               SRCtrl
//               SRInPlace
//               SRDV
//
//------------------------------------------------------------------------

#include <stdlib.h>

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>      // common dialog boxes

#include <ole2.h>
#include <o2base.hxx>     // the base classes and utilities

#include "srecids.h"      // for resources
#include "srs.hxx"

// Our class factory
extern SRFactory *gpSRFactory;
extern "C" HINSTANCE ghInst;

DWORD       gdwRegROT           = 0L;   // Registered on the running object table?
LPMONIKER   gpFileMoniker       = NULL; // Application wide file moniker for linking
LPXBAG      gpXBagOnClipboard   = NULL;
BOOL        gfXBagOnClipboard   = FALSE;
LPSRCTRL    gpCtrlThis          = NULL;


// Glue functions for the C code
//===============================
//
void
FlushOleClipboard(void)
{
    if (!gfOleInitialized)
        return;
    
    if(gfXBagOnClipboard)
    {
        if(OleIsCurrentClipboard(gpXBagOnClipboard) == NOERROR)
        {
            DOUT(TEXT("\\\\Soundrec: OleFlushClipboard()\r\n"));
            //
            // Keep the data object on the clipboard for object pasting
            //
            OleFlushClipboard();
            
            gpXBagOnClipboard->Detach();
            gpXBagOnClipboard = NULL;
        }
        gfXBagOnClipboard = FALSE;
    }
}

               
// copied from pbrush
void
TransferToClipboard(void)
{
    DOUT(TEXT("TransferToClipboard\r\n"));

    if(gpCtrlThis != NULL)
    {
        LPXBAG pXBag;
        HRESULT hr = CXBag::Create(&pXBag, gpCtrlThis, NULL);
        if(hr == NOERROR)
        {
            if(gfXBagOnClipboard)
                OleSetClipboard(NULL);
            hr = OleSetClipboard(pXBag);
            gfXBagOnClipboard = (hr == NOERROR) ? TRUE : FALSE;
            if(hr == NOERROR)
            {
                gpXBagOnClipboard = pXBag;
            }
            else
            {
                DOUT(TEXT("TransferToClipboard FAILED!\r\n"));
            }
        }
    }
    else
    {
        DOUT(TEXT("TransferToClipboard called with a NULL gpCtrlThis!\r\n"));
    }

}
void AdviseDataChange(void)
{
    if(gpCtrlThis)
    {
        gpCtrlThis->_pDV->OnDataChange();
        gpCtrlThis->MarkAsLoaded();
    }
}

void AdviseRename(LPTSTR lpname)
{
    if(gpCtrlThis)
    {
        if (gpCtrlThis->_pOleAdviseHolder != NULL)
        {
            LPMONIKER pmk = NULL;
#if !defined(UNICODE) && !defined(OLE2ANSI)            
            LPOLESTR lpstr = ConvertMBToOLESTR(lpname,-1);
            if(NOERROR == CreateFileMoniker(lpstr, &pmk))
#else
            if(NOERROR == CreateFileMoniker(lpname, &pmk))                
#endif                
                
            {
                gpCtrlThis->_pOleAdviseHolder->SendOnRename(pmk);
                pmk->Release();
            }
#if !defined(UNICODE) && !defined(OLE2ANSI)                        
            TaskFreeMem(lpstr);
#endif            
        }
    }
}

void AdviseSaved(void)
{
    if(gpCtrlThis)
    {
        if (gpCtrlThis->_pOleAdviseHolder != NULL)
        {
            gpCtrlThis->_pOleAdviseHolder->SendOnSave();
        }
    }
}

void AdviseClosed(void)
{
    if(gpCtrlThis)
    {
        if (gpCtrlThis->_pOleAdviseHolder != NULL)
        {
            gpCtrlThis->_pOleAdviseHolder->SendOnClose();
        }
    }
}

void DoOleSave(void)
{
    if(!gfStandalone && gpCtrlThis && gpCtrlThis->_pClientSite)
    {
        gpCtrlThis->_pClientSite->SaveObject();
    }
}

void DoOleClose(BOOL fSave)
{
    if(gpCtrlThis)
    {
        DOUT(TEXT("SoundRec: DoOleClose\r\n"));
        if (gfStandalone)
        {
            RevokeAsRunning(&gdwRegROT);
            if(gpFileMoniker != NULL)
            {
                gpFileMoniker->Release();
                gpFileMoniker = NULL;
            }
            gfClosing = TRUE;
            gpCtrlThis->UnLock();

//        This release will cause a fatal recursion in SRCtrl::~SRCtrl on
//        objects that were created due to link conversations.
                        
            if (gfEmbedded)
                gpCtrlThis->Release();
        }
        else
            gpCtrlThis->Close(fSave ? OLECLOSE_SAVEIFDIRTY: OLECLOSE_NOSAVE);
    }
}

void WriteObjectIfEmpty()
{
    if (gpCtrlThis)
    {
        if (!gpCtrlThis->IsLoaded())
        {
            AdviseDataChange();
        }
    }
}

void OleObjGetHostNames(
    LPTSTR *ppCntr,
    LPTSTR *ppObj)
{
    if (gpCtrlThis)
    {
#if !defined(UNICODE) && !defined(OLE2ANSI)
        *ppCntr = gpCtrlThis->_lpstrCntrAppA;
        *ppObj  = gpCtrlThis->_lpstrCntrObjA;
#else
        *ppCntr = gpCtrlThis->_lpstrCntrApp;
        *ppObj  = gpCtrlThis->_lpstrCntrObj;
#endif        
    }
}

//
// Data Transfer Object
//========================
//

//
// List of formats offered by our data transfer object via EnumFormatEtc
// NOTE: OleClipFormat is a global array of stock formats defined in
//       o2base\dvutils.cxx and initialized via RegisterOleClipFormats()
//       in our class factory.
//
static FORMATETC g_aGetFmtEtcs[] = {
    //
    //Other formats go here..
    //{ CF_WHATEVER, NULL, DVASPECT_ALL, -1L, TYMED_HGLOBAL }

    //
    // put the embed source first so containers recognize this is an object
    //
    { (unsigned short)-OCF_EMBEDSOURCE, NULL, DVASPECT_CONTENT, -1L, TYMED_ISTORAGE },

    //
    // everything else
    //
    { (unsigned short)-OCF_OBJECTDESCRIPTOR, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
    { CF_WAVE, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
    { CF_METAFILEPICT, NULL, DVASPECT_CONTENT, -1L, TYMED_MFPICT },
    { CF_DIB, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },

    //    
    // I am reserving the *LAST TWO* for the links.  We can prevent a
    // link from being offered
    //    
    { (unsigned short)-OCF_LINKSOURCE, NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM | TYMED_HGLOBAL },
    { (unsigned short)-OCF_LINKSRCDESCRIPTOR, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL }

};


//+---------------------------------------------------------------
//
//  Member:     CXBag::Create, static
//
//  Synopsis:   Create a new, initialized transfer object
//
//---------------------------------------------------------------
HRESULT
CXBag::Create(LPXBAG *ppXBag, LPSRCTRL pHost, LPPOINT pptSelected)
{
//    Assert(ppXBag != NULL && pHost != NULL && pptSelected != NULL);

    LPXBAG pXBag = new CXBag(pHost);
    if((*ppXBag = pXBag) == NULL)
        return E_OUTOFMEMORY;

    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     CXBag::CXBag
//
//  Synopsis:   constructor
//
//---------------------------------------------------------------
CXBag::CXBag(LPSRCTRL pHost)
{
    _pHost = pHost;
    _ulRefs = 1;
    _pStgBag = NULL;
}

//+---------------------------------------------------------------
//
//  Member:     CXBag::~CXBag
//
//  Synopsis:   destructor
//
//---------------------------------------------------------------
CXBag::~CXBag()
{
    _pHost = NULL;
    if(_pStgBag != NULL)
        _pStgBag->Release();
}


//+---------------------------------------------------------------
//
//  Member:     CXBag::SnapShotAndDetach
//
//  Synopsis:   Save a snapshot then detach from Host
//
//---------------------------------------------------------------
HRESULT
CXBag::SnapShotAndDetach(void)
{
    STGMEDIUM medium;
    medium.pUnkForRelease = NULL;    // transfer ownership to caller
    medium.hGlobal = NULL;
    medium.tymed = TYMED_ISTORAGE;
    HRESULT hr = BagItInStorage(&medium, FALSE);

    _pHost = NULL;
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CXBag::BagItInStorage, private
//
//  Synopsis:   Save or copy a snapshot into specified stg
//
//---------------------------------------------------------------
HRESULT
CXBag::BagItInStorage(LPSTGMEDIUM pmedium, BOOL fStgProvided)
{
    HRESULT hr = NOERROR;
    LPPERSISTSTORAGE pPStg = NULL;

    LPSTORAGE pStg = fStgProvided ? pmedium->pstg: NULL;
    if(!fStgProvided)
    {
        //
        // allocate a temp docfile that will delete on last release
        //
        hr = StgCreateDocfile(
            NULL,
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE,
            0,
            &pStg);
        pmedium->tymed = TYMED_ISTORAGE;
        pmedium->pstg = pStg;
    }

    if(pStg == NULL)
        goto LExit;

    if(_pStgBag == NULL)
    {
        if(_pHost == NULL)
        {
            hr = E_UNEXPECTED;  // We got prematurely detached!
            goto LExit;
        }
        _pHost->QueryInterface(IID_IPersistStorage, (LPVOID FAR*)&pPStg);
        Assert(pPStg != NULL);
        hr = OleSave(pPStg, pStg, FALSE /* fSameAsLoad */);
        pPStg->SaveCompleted(NULL);
    }
    else
    {
        _pStgBag->CopyTo(NULL, NULL, NULL, pStg);
    }

LExit:
    if(pPStg != NULL)
        pPStg->Release();
    return hr;
}

IMPLEMENT_STANDARD_IUNKNOWN(CXBag)

//+---------------------------------------------------------------
//
//  Member:     CXBag::QueryInterface, public
//
//  Synopsis:   Expose our IFaces
//
//---------------------------------------------------------------
STDMETHODIMP
CXBag::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid,IID_IUnknown))
    {
        *ppv = (LPVOID)this;
    }
    else if (IsEqualIID(riid,IID_IDataObject))
    {
        *ppv = (LPVOID)(LPDATAOBJECT)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     CXBag::QueryGetData
//
//     OLE:     IDataObject
//
//  Synopsis:   Answer whether a request for this format might suceed
//
//---------------------------------------------------------------
STDMETHODIMP
CXBag::QueryGetData(LPFORMATETC pformatetc)
{
    HRESULT hr = DV_E_FORMATETC;
    //
    // Pick out the formats we are willing to offer on IStorage
    //
    if ( (pformatetc->cfFormat == OleClipFormat[OCF_EMBEDSOURCE]) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_ISTORAGE) )
    {
        hr = NOERROR;
    }
    //
    // Pick out the formats we are willing to offer on TYMED_ISTREAM
    //
    else if (pformatetc->tymed == TYMED_ISTREAM)
    {
        DOUT(TEXT("CXBag::QueryGetData[ISTREAM]\r\n"));
        //
        // Do not offer a static link if we don't have a filename
        //
        if (pformatetc->cfFormat == OleClipFormat[OCF_LINKSOURCE] )
        {
            hr = NOERROR;
        }
    }
    //
    // Pick out the formats we are willing to offer on HGLOBAL
    //
    else if (pformatetc->tymed == TYMED_HGLOBAL)
    {
        DOUT(TEXT("CXBag::QueryGetData[HGLOBAL]"));        
        if (pformatetc->cfFormat == OleClipFormat[OCF_OBJECTDESCRIPTOR])
        {
            hr = NOERROR;
        }
        else if (pformatetc->cfFormat == OleClipFormat[OCF_LINKSRCDESCRIPTOR])
        {
            hr = NOERROR;
        }
        else if (pformatetc->cfFormat == CF_DIB)
        {
            DOUT(TEXT("CXBag::QueryGetData[DIB]"));
            hr = NOERROR;
        }
        
    }
    else if ( (pformatetc->tymed == TYMED_MFPICT) &&
              ( pformatetc->cfFormat == CF_METAFILEPICT) )
    {
        DOUT(TEXT("CXBag::QueryGetData[MFPICT]"));
        hr = NOERROR;
    }

    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CXBag::EnumFormatEtc
//
//     OLE:     IDataObject
//
//  Synopsis:   Answer an enumerator over supported formats
//
//---------------------------------------------------------------
STDMETHODIMP
CXBag::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    HRESULT hr = E_NOTIMPL;
    *ppenumFormatEtc = NULL;
    if (dwDirection == DATADIR_GET)
    {
        BOOL fNoLink = IsDocUntitled();
        ULONG cFormats = ARRAY_SIZE(g_aGetFmtEtcs);

        /* Don't enumerate the link support */
        if (fNoLink)
            cFormats -= 2;  

        hr = CreateFORMATETCEnum(g_aGetFmtEtcs, cFormats,
                ppenumFormatEtc);
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CXBag::GetData
//
//     OLE:     IDataObject
//
//  Synopsis:   Deliver data in requested format
//
//---------------------------------------------------------------
STDMETHODIMP
CXBag::GetData(LPFORMATETC pformatetcIn, LPSTGMEDIUM pmedium)
{
    pmedium->pUnkForRelease = NULL;    // transfer ownership to caller
    pmedium->hGlobal = NULL;
    
    HRESULT hr = DV_E_FORMATETC;
    if ( (pformatetcIn->cfFormat == OleClipFormat[OCF_EMBEDSOURCE]) &&
         (pformatetcIn->dwAspect == DVASPECT_CONTENT) &&
         (pformatetcIn->tymed == TYMED_ISTORAGE) )
    {
        DOUT(TEXT("CXBag::GetData:OCF_EMBEDSOURCE\r\n"));        
        hr = BagItInStorage(pmedium,FALSE);
    }
    else if(pformatetcIn->tymed & TYMED_ISTREAM)
    {
        if ( pformatetcIn->cfFormat == OleClipFormat[OCF_LINKSOURCE] )
        {
            DOUT(TEXT("CXBag::GetData OCF_LINKSOURCE on STREAM\r\n"));
            if(_pHost != NULL)
            {
                hr = _pHost->_pDV->GetLINKSOURCE( (LPSRVRDV)(_pHost->_pDV),
                                                    pformatetcIn,
                                                    pmedium,
                                                    FALSE /* fHere */ );
            }
        }
    }
    else if((pformatetcIn->tymed & TYMED_HGLOBAL) && (_pHost != NULL))
    {
        pmedium->tymed = TYMED_HGLOBAL;
        if ( pformatetcIn->cfFormat == OleClipFormat[OCF_OBJECTDESCRIPTOR] )
        {
            DOUT(TEXT("CXBag::GetData OCF_OBJECTDESCRIPTOR on HGLOBAL\r\n"));
            hr = _pHost->_pDV->GetOBJECTDESCRIPTOR( (LPSRVRDV)(_pHost->_pDV),
                                                    pformatetcIn,
                                                    pmedium,
                                                    FALSE /* fHere */ );
        }
        else if (pformatetcIn->cfFormat == OleClipFormat[OCF_LINKSRCDESCRIPTOR])
        {
            DOUT(TEXT("CXBag::GetData OCF_LINKSRCDESCRIPTOR on HGLOBAL\r\n"));
            hr = _pHost->_pDV->GetOBJECTDESCRIPTOR( (LPSRVRDV)(_pHost->_pDV),
                                                    pformatetcIn,
                                                    pmedium,
                                                    FALSE /* fHere */ );
        }
        else if ( pformatetcIn->cfFormat == CF_WAVE )
        {
            DOUT(TEXT("CXBag::GetData CF_WAVE on HGLOBAL\r\n"));
            if ((pmedium->hGlobal = GetNativeData()) != NULL)
                hr = NOERROR;
        }
        else if ( pformatetcIn->cfFormat == CF_DIB )
        {
            DOUT(TEXT("CXBag::GetData CF_DIB on HGLOBAL\r\n"));            
            if ((pmedium->hGlobal = ::GetDIB(NULL)) != NULL)
                hr = NOERROR;
        }
                
    }
    else if (pformatetcIn->tymed & TYMED_MFPICT)
    {
        pmedium->tymed = TYMED_MFPICT;
        if (pformatetcIn->cfFormat == CF_METAFILEPICT)
        {
            DOUT(TEXT("CXBag::GetData CF_METAFILEPICT\r\n"));
            if (_pHost != NULL)
            {
                if ((pmedium->hGlobal = GetPicture())!= NULL)
                    hr = NOERROR;
            }
        }
    }
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CXBag::GetDataHere
//
//     OLE:     IDataObject
//
//  Synopsis:   Deliver requested format in specified medium
//
//---------------------------------------------------------------
STDMETHODIMP
CXBag::GetDataHere(LPFORMATETC pformatetc, LPSTGMEDIUM pmedium)
{
    HRESULT hr = DV_E_FORMATETC;
            
    if ( (pformatetc->cfFormat == OleClipFormat[OCF_EMBEDSOURCE]) &&
         (pformatetc->dwAspect == DVASPECT_CONTENT) &&
         (pformatetc->tymed == TYMED_ISTORAGE) )
    {
        DOUT(TEXT("CXBag::GetDataHere:OCF_EMBEDSOURCE\r\n"));
        hr = BagItInStorage(pmedium,TRUE);
    }
    else if(pformatetc->tymed & TYMED_ISTREAM)
    {
        if (pformatetc->cfFormat = (WORD)OleClipFormat[OCF_LINKSOURCE])
        {
            DOUT(TEXT("CXBag::GetDataHere:OCF_LINKSOURCE\r\n"));
            
            if (_pHost != NULL)
            {
                hr = _pHost->_pDV->GetLINKSOURCE((LPSRVRDV)(_pHost->_pDV)
                                                 ,pformatetc
                                                 ,pmedium
                                                 ,TRUE);
            }
        }
    }                                        
    else if ((pformatetc->tymed & TYMED_HGLOBAL) && (_pHost != NULL))
    {
        if ( pformatetc->cfFormat == OleClipFormat[OCF_OBJECTDESCRIPTOR] )
        {
            DOUT(TEXT("CXBag::GetDataHere:OCF_OBJECTDESCRIPTOR\r\n"));
            
            hr = _pHost->_pDV->GetOBJECTDESCRIPTOR( _pHost->_pDV,
                    pformatetc,
                    pmedium,
                    TRUE /* fHere */ );
        }
        else if ( pformatetc->cfFormat == OleClipFormat[OCF_LINKSRCDESCRIPTOR])
        {
            DOUT(TEXT("CXBag::GetDataHere:OCF_LINKSRCDESCRIPTOR\r\n"));
            
            hr = _pHost->_pDV->GetOBJECTDESCRIPTOR( _pHost->_pDV,
                    pformatetc,
                    pmedium,
                    TRUE /* fHere */ );
        }
        else if ( pformatetc->cfFormat == CF_WAVE )
        {
            DOUT(TEXT("CXBag::GetDataHere CF_WAVE on HGLOBAL\r\n"));
            if ((pmedium->hGlobal = GetNativeData()) != NULL)
                hr = NOERROR;
        }
        else if ( pformatetc->cfFormat == CF_DIB )
        {
            DOUT(TEXT("CXBag::GetDataHere CF_DIB on HGLOBAL\r\n"));

            if ((pmedium->hGlobal = ::GetDIB(pmedium->hGlobal)) != NULL)
                hr = NOERROR;
        }
        
    }
    else if (pformatetc->tymed & TYMED_MFPICT)
    {
        pmedium->tymed = TYMED_MFPICT;
        if (pformatetc->cfFormat == CF_METAFILEPICT)
        {
            DOUT(TEXT("CXBag::GetData CF_METAFILEPICT\r\n"));
            if (_pHost != NULL)
            {
                if ((pmedium->hGlobal = GetPicture()) != NULL)
                    hr = NOERROR;
            }
        }
    }

#if 0
        //
        // Replace with appropriate format handlers...
        //
        else if ( pformatetc->cfFormat == g_cfSourceList )
        {
            hr = _pBaggedList->Copy(pmedium->hGlobal);
        }
#endif
    return hr;
}


//
// (Open-Editing) Server Object for SoundRec
//==========================================
//

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::ClassInit, public
//
//  Synopsis:   Initializes the SRCtrl class
//
//  Arguments:  [pClass] -- our class descriptor
//
//  Returns:    TRUE iff the class could be initialized successfully
//
//  Notes:      This method initializes the verb tables in the
//              class descriptor.
//
//---------------------------------------------------------------

static OLECHAR lpszPlay[64];
static OLECHAR lpszEdit[64];
static OLECHAR lpszOpen[64];

BOOL
SRCtrl::ClassInit(LPCLASSDESCRIPTOR pClass)
{
    // These are our verb tables.  They are used by the base class
    // in implementing methods of the IOleObject interface.
    // NOTE: the verb table must be in ascending, consecutive order
    static OLEVERB OleVerbs[] =
    {
    //  { lVerb, lpszVerbName, fuFlags, grfAttribs },
        { OLEIVERB_INPLACEACTIVATE, NULL, 0, 0 },
        { OLEIVERB_UIACTIVATE, NULL, 0, 0 },
        { OLEIVERB_HIDE, NULL, 0, 0 },
        { OLEIVERB_OPEN, NULL, 0, 0 },
        { OLEIVERB_SHOW, NULL, 0, 0 },
        { OLEIVERB_PRIMARY, lpszPlay, MF_ENABLED, OLEVERBATTRIB_ONCONTAINERMENU },
        { 1, lpszEdit, MF_ENABLED, OLEVERBATTRIB_ONCONTAINERMENU },
        { 2, lpszOpen, MF_ENABLED, OLEVERBATTRIB_ONCONTAINERMENU }
    };
#if !defined(UNICODE) && !defined(OLE2ANSI)
    TCHAR sz[64];
    LoadString(ghInst, IDS_PLAYVERB, sz, ARRAY_SIZE(sz));
    MultiByteToWideChar(CP_ACP, 0, sz, -1, lpszPlay, ARRAY_SIZE(lpszPlay));
    
    LoadString(ghInst, IDS_EDITVERB, sz, ARRAY_SIZE(sz));
    MultiByteToWideChar(CP_ACP, 0, sz, -1, lpszEdit, ARRAY_SIZE(lpszEdit));
    
    LoadString(ghInst, IDS_OPENVERB, sz, ARRAY_SIZE(sz));
    MultiByteToWideChar(CP_ACP, 0, sz, -1, lpszOpen, ARRAY_SIZE(lpszOpen));
    
#else
    LoadString(ghInst, IDS_PLAYVERB, lpszPlay, ARRAY_SIZE(lpszPlay));
    LoadString(ghInst, IDS_EDITVERB, lpszEdit, ARRAY_SIZE(lpszEdit));
    LoadString(ghInst, IDS_OPENVERB, lpszOpen, ARRAY_SIZE(lpszOpen));
#endif
    
    pClass->_pVerbTable = OleVerbs;
    pClass->_cVerbTable = ARRAY_SIZE(OleVerbs);

    return TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::Create, public
//
//  Synopsis:   Creates and initializes an SRCtrl object
//
//  Arguments:  [pUnkOuter] -- A controlling unknown.  NULL if we are not
//                             being created as part of an aggregation
//              [pClass]    -- The OlePad class descriptor
//              [ppUnkCtrl] -- Where we return our controlling unknown
//              [ppObj]     -- Pointer to the SRCtrl object created
//
//  Returns:    Success if the object could be successfully created and
//              initialized.
//
//---------------------------------------------------------------

HRESULT
SRCtrl::Create( LPUNKNOWN pUnkOuter,
        LPCLASSDESCRIPTOR pClass,
        LPUNKNOWN FAR* ppUnkCtrl,
        LPSRCTRL FAR* ppObj)
{
    // set out parameters to NULL
    *ppUnkCtrl = NULL;
    *ppObj = NULL;

    if(gpCtrlThis)
    {
        DOUT(TEXT("SRCtrl::Create non-NULL gpCtrlThis!"));
        return E_FAIL;
    }

    // create an object
    HRESULT hr = E_OUTOFMEMORY;
    LPSRCTRL pObj = new SRCtrl(pUnkOuter);
    if (pObj != NULL)
    {
        // initialize it
        if (OK(hr = pObj->Init(pClass)))
        {
            // return the object and its controlling unknown
            *ppUnkCtrl = &pObj->_PrivUnk;
            *ppObj = gpCtrlThis = pObj;
        }
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::SRCtrl, protected
//
//  Synopsis:   Constructor for the SRCtrl class
//
//  Arguments:  [pUnkOuter] -- the controlling unknown or NULL if we are
//                              not being created as part of an aggregate
//
//  Notes:      This is the first part of a two-stage construction process.
//              The second part is in the Init method.  Use the static
//              Create method to properly instantiate an SRCtrl object
//
//---------------------------------------------------------------

#pragma warning(disable:4355)   // `this' argument to base-member init. list.
SRCtrl::SRCtrl(LPUNKNOWN pUnkOuter):
        _PrivUnk(this)  // the controlling unknown holds a pointer to the object
{
    static SrvrCtrl::LPFNDOVERB VerbFuncs[] =
    {
        &SrvrCtrl::DoInPlaceActivate, // OLEIVERB_INPLACEACTIVATE
        &SrvrCtrl::DoUIActivate,      // OLEIVERB_UIACTIVATE
        &SrvrCtrl::DoHide,            // OLEIVERB_HIDE
        &SRCtrl::DoOpen,              // OLEIVERB_OPEN
        &SRCtrl::DoShow,              // OLEIVERB_SHOW
        &SRCtrl::DoPlay,              // Play, OLEIVERB_PRIMARY
        &SRCtrl::DoOpen,              // Edit 
        &SRCtrl::DoOpen               // Open
    };

    _pUnkOuter = (pUnkOuter != NULL) ? pUnkOuter : (LPUNKNOWN)&_PrivUnk;

    _pDVCtrlUnk = NULL;
    _pIPCtrlUnk = NULL;

    _pVerbFuncs = VerbFuncs;
    _cLock = 0;
    _fLoaded = FALSE;
}
#pragma warning(default:4355)

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::DoPlay, public, static
//
//  Synopsis:   Implementation of the play verb.
//              This verb results in a transition to the open state.
//
//---------------------------------------------------------------

HRESULT
SRCtrl::DoPlay(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    DOUT(TEXT("SrvrCtrl::DoPlay\r\n"));
    LPSRCTRL pCtrl = (LPSRCTRL)pv;

    BOOL fClose = FALSE;
    
    /* if we are already open, just play it.
     * if we aren't, play it and close.
     */
    if (!gfStandalone)
    {
        fClose = pCtrl->State() != OS_OPEN;
        
        /* We've never been loaded.  This means someone (Project 4.0) is
         * calling our primary verb incorrectly on Insert->Object.  They
         * really want us to DoOpen.
         */
        if (!pCtrl->IsLoaded())
            return (pCtrl->DoOpen(pv, iVerb, lpmsg, pActiveSite, lindex,
                hwndParent,lprcPosRect));
    }

    if (IsWindowVisible(ghwndApp))
        SetForegroundWindow(ghwndApp);
    
    AppPlay(fClose);
    
    return pCtrl->TransitionTo(OS_OPEN);
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::DoShow, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_SHOW.
//              This verb results in a transition to the open state.
//
//---------------------------------------------------------------

HRESULT
SRCtrl::DoShow(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    DOUT(TEXT("SrvrCtrl::DoShow\r\n"));

    LPSRCTRL pCtrl = (LPSRCTRL)pv;
    if(pCtrl->State() == OS_OPEN)
    {
        HWND hwnd = NULL;
        if(pCtrl->_pInPlace)
            pCtrl->_pInPlace->GetWindow(&hwnd);
        if(hwnd != NULL)
            SetForegroundWindow(hwnd);
    }
    WriteObjectIfEmpty();
    return pCtrl->TransitionTo(OS_OPEN);
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::DoOpen, public
//
//  Synopsis:   Implementation of the standard verb OLEIVERB_OPEN.
//              This verb results in a transition to the open state.
//
//---------------------------------------------------------------
HRESULT
SRCtrl::DoOpen(LPVOID pv,
        LONG iVerb,
        LPMSG lpmsg,
        LPOLECLIENTSITE pActiveSite,
        LONG lindex,
        HWND hwndParent,
        LPCRECT lprcPosRect)
{
    DOUT(TEXT("SRCtrl::DoOpen\r\n"));

    LPSRVRCTRL pCtrl = (LPSRVRCTRL)pv;
    if(pCtrl->State() == OS_OPEN)
    {
        HWND hwnd = NULL;
        if(pCtrl->_pInPlace)
            pCtrl->_pInPlace->GetWindow(&hwnd);
        if(hwnd != NULL)
            SetForegroundWindow(hwnd);
        if (IsWindowVisible(ghwndApp))
            SetForegroundWindow(ghwndApp);

    }
    return pCtrl->TransitionTo(OS_OPEN);
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::Init, protected
//
//  Synopsis:   Initializes an SRCtrl object
//
//  Arguments:  [pClass] -- the class descriptor
//
//  Returns:    SUCCESS iff the class could be initialized
//
//  Notes:      This is the second part of a two-stage construction
//              process.  Use the static Create method to properly
//              instantiate an SRCtrl object.
//
//---------------------------------------------------------------

HRESULT
SRCtrl::Init(LPCLASSDESCRIPTOR pClass)
{
    HRESULT hr = NOERROR;

    if (OK(hr = SrvrCtrl::Init(pClass)))
    {
        LPSRDV pSRDV;
        LPUNKNOWN pDVCtrlUnk;
        if (OK(hr = SRDV::Create(this, pClass, &pDVCtrlUnk, &pSRDV)))
        {
            LPSRINPLACE pSRInPlace;
            LPUNKNOWN pIPCtrlUnk;
            if (OK(hr = SRInPlace::Create(this,
                    pClass,
                    &pIPCtrlUnk,
                    &pSRInPlace)))
            {
                _pDVCtrlUnk = pDVCtrlUnk;
                _pDV = pSRDV;
                _pIPCtrlUnk = pIPCtrlUnk;
                _pInPlace = pSRInPlace;

                pDVCtrlUnk->AddRef();
//        This was in paintbrush.  I expect it's because standalone objects don't
//        do state transitions correctly
//                Lock();
            }
            pDVCtrlUnk->Release();  // on failure this will free DV subobject
        }
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::~SRCtrl
//
//  Synopsis:   Destructor for the SRCtrl class
//
//---------------------------------------------------------------

SRCtrl::~SRCtrl(void)
{
    DOUT(TEXT("SRCtrl::~SRCtrl\r\n"));
    if(_state > OS_PASSIVE)
    {
        // make sure we are back to the loaded state
        TransitionTo(OS_LOADED);
    }
    
    //
    // If we are not being shut down by the user (via FILE:EXIT etc.,)
    // then we must cause app shutdown here...
    //

// This AddRef is necessary to prevent a reentrancy within
// TerminateServer because it does a QI and Release to get a storage
// if an uncommitted object is on the clipboard at exit time. 
    AddRef();
    
    if (!gfUserClose && !gfTerminating)
        TerminateServer();

    if (gpFileMoniker != NULL)
        gpFileMoniker->Release();

    //
    // release the controlling unknowns of our subobjects, which should
    // free them...
    //
    DOUT(TEXT("~SRCtrl: DV->Release\r\n"));
    if (_pDVCtrlUnk != NULL)
    {
        _pDVCtrlUnk->Release();
    }
    
    DOUT(TEXT("~SRCtrl: IP->Release\r\n"));
    if (_pIPCtrlUnk != NULL)
    {
        _pIPCtrlUnk->Release();
    }
    
    gpCtrlThis = NULL;
}


// the standard IUnknown methods all delegate to the controlling unknown.
IMPLEMENT_DELEGATING_IUNKNOWN(SRCtrl)

IMPLEMENT_PRIVATE_IUNKNOWN(SRCtrl)

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::PrivateUnknown::QueryInterface
//
//  Synopsis:   QueryInterface on our controlling unknown
//
//---------------------------------------------------------------

STDMETHODIMP
SRCtrl::PrivateUnknown::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
#if DBG
    TCHAR achBuffer[256];
    wsprintf(achBuffer,
            TEXT("SRCtrl::PrivateUnknown::QueryInterface (%lx)\r\n"),
            riid.Data1);
    DOUT(achBuffer);
#endif
    
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (void FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IOleObject))
    {
        *ppv = (void FAR *) (LPOLEOBJECT)_pSRCtrl;
    }
    else    // try each of our delegate subobjects until one succeeds
    {
        HRESULT hr;
        if (!OK(hr = _pSRCtrl->_pDVCtrlUnk->QueryInterface(riid, ppv)))
            hr = _pSRCtrl->_pIPCtrlUnk->QueryInterface(riid, ppv);
        return hr;
    }

    //
    // Important:  we must addref on the pointer that we are returning,
    // because that pointer is what will be released!
    //
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::GetMoniker
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      Our overide creates a file moniker for the Standalone case
//
//---------------------------------------------------------------

STDMETHODIMP
SRCtrl::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    DOUT(TEXT("SRCtrl::GetMoniker\r\n"));

    HRESULT hr = E_INVALIDARG;

    if (ppmk == NULL)
    {
        DOUT(TEXT("SRCtrl::GetMoniker E_INVALIDARG\r\n"));
        return hr;
    }
    *ppmk = NULL;   // set out parameters to NULL

    if(gfStandalone || gfLinked)    // set by FlagEmbededObject()
    {
        if(gpFileMoniker != NULL)
        {
            *ppmk = gpFileMoniker;
            gpFileMoniker->AddRef();
            hr = NOERROR;
        }
        else
        {
#if !defined(UNICODE) && !defined(OLE2ANSI)            
            LPOLESTR lpLinkFilename = ConvertMBToOLESTR(gachLinkFilename, -1);
            if((hr = CreateFileMoniker(lpLinkFilename, &gpFileMoniker)) == NOERROR)
            {
                gpFileMoniker->AddRef(); //because we are keeping this pointer
                *ppmk = gpFileMoniker;
                RegisterAsRunning((LPUNKNOWN)this, *ppmk, &gdwRegROT);
            }
            else
            {
                DOUT(TEXT("SRCtrl::GetMoniker CreateFileMoniker FAILED!\r\n"));
            }
            TaskFreeMem(lpLinkFilename);
#else
            if((hr = CreateFileMoniker(gachLinkFilename, &gpFileMoniker)) == NOERROR)
            {
                gpFileMoniker->AddRef(); //because we are keeping this pointer
                *ppmk = gpFileMoniker;
                RegisterAsRunning((LPUNKNOWN)this, *ppmk, &gdwRegROT);
            }
            else
            {
                DOUT(TEXT("SRCtrl::GetMoniker CreateFileMoniker FAILED!\r\n"));
            }
#endif                        
        }
    }
    else
    {
        return SrvrCtrl::GetMoniker(dwAssign, dwWhichMoniker, ppmk);
    }
    return hr;
}
//+---------------------------------------------------------------
//
//  Member:     SRCtrl::IsUpToDate
//
//  Synopsis:   Method of IOleObject interface
//
//  Notes:      Return S_FALSE if we are dirty (not up-to-date)
//
//---------------------------------------------------------------

STDMETHODIMP
SRCtrl::IsUpToDate(void)
{
    DOUT(TEXT("SRCtrl::IsUpToDate\r\n"));

    return gfDirty ? S_FALSE : S_OK;
}
#if 0
//+---------------------------------------------------------------
//
//  Member:     SRCtrl::GetHostNames, public
//
//  Synopsis:   Returns any host names set by the container
//
//  Arguments:  [plpstrCntrApp] -- location for string indicating the top-level
//                                  container application.
//              [plpstrCntrObj] -- location for string indicating the top-level
//                                  document.
//
//  Notes:      The method makes available the strings originally set by the
//              container using IOleObject::SetHostNames.  These strings are
//              used in the title bar of an open-edited object.  It is useful
//              to containers that need to forward this information to their
//              embeddings.  The returned strings are allocated using the
//              standard task allocator and should be freed appropriately by
//              the caller.
//
//---------------------------------------------------------------

void
SRCtrl::GetHostNames(LPTSTR FAR* plpstrCntrApp, LPTSTR FAR* plpstrCntrObj)
{
    if (_lpstrCntrApp != NULL)
    {
        TaskAllocString(_lpstrCntrApp, plpstrCntrApp);
    }
    else
    {
        *plpstrCntrApp = NULL;
    }

    if (_lpstrCntrObj != NULL)
    {
        TaskAllocString(_lpstrCntrObj, plpstrCntrObj);
    }
    else
    {
        *plpstrCntrObj = NULL;
    }
}
#endif
void
SRCtrl::Lock(void)
{
    ++_cLock;
#if DBG
    TCHAR achBuffer[256];
    wsprintf(achBuffer, TEXT("\\\\SRCtrl::Lock (%d)\r\n"), _cLock);
    DOUT(achBuffer);
#endif
    CoLockObjectExternal((LPUNKNOWN)&_PrivUnk, TRUE, TRUE);
}

void
SRCtrl::UnLock(void)
{
    --_cLock;
#if DBG
    TCHAR achBuffer[256];
    wsprintf(achBuffer, TEXT("\\\\SRCtrl::UnLock (%d)\r\n"), _cLock);
    DOUT(achBuffer);
#endif
    Assert(_cLock >= 0);
    CoLockObjectExternal((LPUNKNOWN)&_PrivUnk, FALSE, TRUE);
}

BOOL
SRCtrl::IsLoaded(void)
{
    return _fLoaded;
}

void
SRCtrl::MarkAsLoaded(void)
{
    _fLoaded = TRUE;
}

HRESULT
SRCtrl::PassiveToLoaded()
{
    DOUT(TEXT("=== SRCtrl::PassiveToLoaded\r\n"));
    Lock();    
    return SrvrCtrl::PassiveToLoaded();
}

HRESULT
SRCtrl::LoadedToPassive()
{
    DOUT(TEXT("=== SRCtrl::LoadedToPassive\r\n"));
    HRESULT hr = SrvrCtrl::LoadedToPassive();
    UnLock();
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     SRCtrl::RunningToOpened
//
//  Synopsis:   Effects the running to open state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//---------------------------------------------------------------

HRESULT
SRCtrl::RunningToOpened()
{
    DOUT(TEXT("SRCtrl::RunningToOpened\r\n"));

    // ...  show open editing window
    if (!gfStandalone)
    {
        FixMenus();
    
        if (gfShowWhilePlaying)
            ShowWindow(ghwndApp, SW_SHOW | SW_SHOWNORMAL);
        if (IsWindowVisible(ghwndApp))
            SetForegroundWindow(ghwndApp);
    }
    OleNoteObjectVisible((LPUNKNOWN)&_PrivUnk, TRUE);

    //
    // notify our container so it can hatch-shade our object 
    // indicating that it is open-edited...
    //
    
    if (_pClientSite != NULL)
        _pClientSite->OnShowWindow(TRUE);

    SetFocus(ghwndApp);

    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::OpenedToRunning
//
//  Synopsis:   Effects the open to running state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//---------------------------------------------------------------

HRESULT
SRCtrl::OpenedToRunning()
{
    DOUT(TEXT("SRCtrl::OpenedToRunning\r\n"));
    
    //
    // If we are transitioning to a standalone app, we don't want the app
    // to disappear.
    //
    ShowWindow(ghwndApp,SW_HIDE);
    
    HRESULT hr = SrvrCtrl::OpenedToRunning();
    
    OleNoteObjectVisible((LPUNKNOWN)&_PrivUnk, FALSE);
    
    return hr;
}


const OLECHAR szContentsStrm[] = OLETEXT("contents");
const OLECHAR szOLE1Strm[] = OLETEXT("\1Ole10Native");

//---------------------------------------------------------------
//
//  The Format Tables
//
//---------------------------------------------------------------

//
// GetData format information
// note: the LINKSRCDESCRIPTOR and OBJECTDESCRIPTOR are identical structures
//       so we use the OBJECTDESCRIPTOR get/set fns for both.
//

    static FORMATETC SRGetFormatEtc[] =
    {// { cfFormat, ptd, dwAspect, lindex, tymed },
#if 0
// NTBUG # 11225: CorelDraw 5.0 does not like our implementation of
//                CF_EMBEDDEDOBJECT and cannot save our data in the
//                Insert->Object->CreateFromFile scenerio        
        
        { (unsigned short)-OCF_EMBEDDEDOBJECT, NULL, DVASPECT_CONTENT, -1L, TYMED_ISTORAGE },
#else
        { (unsigned short)-OCF_EMBEDSOURCE, NULL, DVASPECT_CONTENT, -1L, TYMED_ISTORAGE },
#endif
        { CF_METAFILEPICT, DVTARGETIGNORE, DVASPECT_CONTENT, -1L, TYMED_MFPICT },
        { CF_DIB, DVTARGETIGNORE, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },            
        { (unsigned short)-OCF_OBJECTDESCRIPTOR, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
        { (unsigned short)-OCF_LINKSRCDESCRIPTOR, NULL, DVASPECT_CONTENT, -1L, TYMED_HGLOBAL },
        { (unsigned short)-OCF_LINKSOURCE, NULL, DVASPECT_CONTENT, -1L, TYMED_ISTREAM }
    };
    
    static SrvrDV::LPFNGETDATA SRGetFormatFuncs[] =
    {   &SRDV::GetEMBEDDEDOBJECT,
        &SRDV::GetMETAFILEPICT,
        &SRDV::GetDIB,
        &SRDV::GetOBJECTDESCRIPTOR,
        &SRDV::GetOBJECTDESCRIPTOR,
        &SRDV::GetLINKSOURCE
    };

//+---------------------------------------------------------------
//
//  Member:     SRDV::ClassInit (static)
//
//  Synopsis:   Initializes the SRDV class
//
//  Arguments:  [pClass] -- our class descriptor
//
//  Returns:    TRUE iff the class could be initialized successfully
//
//  Notes:      This method initializes the format tables in the
//              class descriptor.
//
//---------------------------------------------------------------

BOOL
SRDV::ClassInit(LPCLASSDESCRIPTOR pClass)
{
    // fill in the class descriptor structure with the format tables
    pClass->_pGetFmtTable = SRGetFormatEtc;
    pClass->_cGetFmtTable = ARRAY_SIZE(SRGetFormatEtc);

    pClass->_pSetFmtTable = NULL;
    pClass->_cSetFmtTable = 0;

    //
    // walk our format tables and complete the cfFormat field from
    // the array of standard OLE clipboard formats.
    //
    LPFORMATETC pfe = SRGetFormatEtc;
    int c = ARRAY_SIZE(SRGetFormatEtc);

    for (int i = 0; i < c; i++, pfe++)
    {
        // if the clipformat is negative, then it really is an index into
        // our table of standard OLECLIPFORMATS
        int j = - (short)pfe->cfFormat;
        if (j >= 0 && j <= OCF_LAST)
            pfe->cfFormat = (WORD)OleClipFormat[j];
    }

    pfe = g_aGetFmtEtcs;
    c = ARRAY_SIZE(g_aGetFmtEtcs);

    for (i = 0; i < c; i++, pfe++)
    {
        // if the clipformat is negative, then it really is an index into
        // our table of standard OLECLIPFORMATS
        
        int j = - (short)pfe->cfFormat;
        if (j >= 0 && j <= OCF_LAST)
        {
            pfe->cfFormat = (WORD)OleClipFormat[j];
        }
    }
    
    return TRUE;
}

HRESULT
SRDV::GetDIB( LPSRVRDV pDV,
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium,
        BOOL fHere)
{
    HRESULT hr = NOERROR;
    LPVIEWOBJECT pView = (LPVIEWOBJECT)pDV;
    HANDLE hDIB;
            
    if (!fHere)
    {
        // fill in the pmedium structure
        pmedium->tymed = TYMED_HGLOBAL;
    }

    hDIB = ::GetDIB(pmedium->hGlobal);
    if (hDIB)
        pmedium->hGlobal = hDIB;
    else
        hr = E_OUTOFMEMORY;
    
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     SRDV::Create, public
//
//  Synopsis:   Creates and initializes an SRDV object
//
//  Arguments:  [pCtrl]     -- our control subobject
//              [pClass]    -- The class descriptor
//              [ppUnkCtrl] -- Where we return our controlling unknown
//              [ppObj]     -- where the created object is returned
//
//  Returns:    Success if the object could be successfully created and
//              initialized.
//
//---------------------------------------------------------------

HRESULT
SRDV::Create(LPSRCTRL pCtrl,
        LPCLASSDESCRIPTOR pClass,
        LPUNKNOWN FAR* ppUnkCtrl,
        LPSRDV FAR* ppObj)
{
    // set out parameters to NULL
    *ppUnkCtrl = NULL;
    *ppObj = NULL;

    // create an object
    HRESULT hr;
    LPSRDV pObj;
    pObj = new SRDV((LPUNKNOWN)(LPOLEOBJECT)pCtrl);
    if (pObj == NULL)
    {
        hr =  E_OUTOFMEMORY;
    }
    else
    {
        // initialize it
        if (OK(hr = pObj->Init(pCtrl, pClass)))
        {
            // return the object and its controlling unknown
            *ppUnkCtrl = &pObj->_PrivUnk;
            *ppObj = pObj;
        }
        else
        {
            pObj->_PrivUnk.Release();   //hari-kari
        }
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SRDV::SRDV, protected
//
//  Synopsis:   Constructor for the SRDV class
//
//  Arguments:  [pUnkOuter] -- the controlling unknown.  This is either
//                             a SRCtrl subobject or NULL we are being
//                             created as a transfer object.
//
//  Notes:      This is the first part of a two-stage construction process.
//              The second part is in the Init method.  Use the static
//              Create method to properly instantiate an SRDV object
//
//---------------------------------------------------------------

#pragma warning(disable:4355)   // `this' argument to base-member init. list.
SRDV::SRDV(LPUNKNOWN pUnkOuter):
    _PrivUnk(this)  // the controlling unknown holds a pointer to the object
{
    _pUnkOuter = (pUnkOuter != NULL) ? pUnkOuter : (LPUNKNOWN)&_PrivUnk;

    _pGetFuncs = SRGetFormatFuncs;
    _pSetFuncs = NULL;

    _sizel = _header._sizel;
}
#pragma warning(default:4355)

//+---------------------------------------------------------------
//
//  Member:     SRDV::Init, protected
//
//  Synopsis:   Initializes an SRDV object
//
//  Arguments:  [pCtrl]  -- our controlling SRCtrl subobject
//              [pClass] -- the class descriptor
//
//  Returns:    SUCCESS iff the class could be initialized
//
//  Notes:      This is the second part of a two-stage construction
//              process.  Use the static Create method to properly
//              instantiate an SRDV object.
//
//---------------------------------------------------------------

HRESULT
SRDV::Init(LPSRCTRL pCtrl, LPCLASSDESCRIPTOR pClass)
{
    HRESULT hr = SrvrDV::Init(pClass, pCtrl);
    //
    //do our own xtra init here...
    //
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SRDV::~SRDV
//
//  Synopsis:   Destructor for the SRDV class
//
//---------------------------------------------------------------

SRDV::~SRDV(void)
{
    //
    // TODO: check on anything we may have to clean up here...
    //
}

// the standard IUnknown methods all delegate to a controlling unknown.
IMPLEMENT_DELEGATING_IUNKNOWN(SRDV)

IMPLEMENT_PRIVATE_IUNKNOWN(SRDV)

//+---------------------------------------------------------------
//
//  Member:     SRDV::PrivateUnknown::QueryInterface
//
//  Synopsis:   QueryInterface on our controlling unknown
//
//---------------------------------------------------------------

STDMETHODIMP
SRDV::PrivateUnknown::QueryInterface (REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid,IID_IUnknown))
    {
        *ppv = (LPVOID)this;
    }
    else if (IsEqualIID(riid,IID_IDataObject))
    {
        *ppv = (LPVOID)(LPDATAOBJECT)_pSRDV;
    }
    else if (IsEqualIID(riid,IID_IViewObject))
    {
        *ppv = (LPVOID)(LPVIEWOBJECT)_pSRDV;
    }
    else if (IsEqualIID(riid,IID_IPersist))
    {
        //
        // The standard handler wants this
        //
        *ppv = (LPVOID)(LPPERSIST)(LPPERSISTSTORAGE)_pSRDV;
    }
    else if (IsEqualIID(riid,IID_IPersistStorage))
    {
        *ppv = (LPVOID)(LPPERSISTSTORAGE)_pSRDV;
    }
    else if (IsEqualIID(riid,IID_IPersistFile))
    {
        *ppv = (LPVOID)(LPPERSISTFILE)_pSRDV;
    }
    else   
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    
    //
    // Important:  we must addref on the pointer that we are returning,
    // because that pointer is what will be released!
    //
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SRDV::RenderContent, public
//
//  Synopsis:   Draws our contents into a display context
//
//  Arguments:  The arguments are the same as to the IViewObject::Draw method
//
//  Returns:    SUCCESS if the content was rendered
//
//  Notes:      This virtual method of the base class is called to implement
//              IViewObject::Draw for the DVASPECT_CONTENT aspect.
//
//----------------------------------------------------------------

HRESULT
SRDV::RenderContent(DWORD dwDrawAspect,
        LONG lindex,
        void FAR* pvAspect,
        DVTARGETDEVICE FAR * ptd,
        HDC hicTargetDev,
        HDC hdcDraw,
        LPCRECTL lprectl,
        LPCRECTL lprcWBounds,
        BOOL (CALLBACK *pfnContinue) (ULONG_PTR),
        ULONG_PTR dwContinue)
{
    DOUT(TEXT("SoundRec: RenderContent\r\n"));
    
    int x = GetSystemMetrics(SM_CXICON);
    int y = GetSystemMetrics(SM_CYICON);
    HDC hdc = GetDC(ghwndApp);
    HDC hdcMem = CreateCompatibleDC(hdc);
    HBITMAP hbm = CreateCompatibleBitmap(hdc, x, y);
    HBITMAP hbmOld = (HBITMAP)SelectObject(hdcMem, hbm);
    
    PatBlt(hdcMem, 0, 0, x, y, WHITENESS); 
    DrawIcon(hdcMem, 0, 0, ghiconApp);    
    
    StretchBlt(hdcDraw, lprectl->left, lprectl->top,
                lprectl->right - lprectl->left, lprectl->bottom - lprectl->top,
                hdcMem, 0, 0, x, y, SRCCOPY);
    
    hbm = (HBITMAP)SelectObject(hdcMem, hbmOld);
    
    if (hdcMem)
        DeleteDC(hdcMem);
    if (hbm)
        DeleteObject(hbm);
    if (hdc)
        ReleaseDC(ghwndApp, hdc);
    
    return NOERROR;
}


/*
 * SRDV::Load
 * Implements IPersistFile::Load
 *
 * Side effects: gfLinked - we know we are linked.
 */

STDMETHODIMP
SRDV::Load (LPCOLESTR lpstrFile, DWORD grfMode)
{
    DOUT(TEXT("SoundRec:SRDV::Load\r\n"));
    
#if !defined(UNICODE) && !defined(OLE2ANSI)
    LPTSTR lpszFileName = ConvertOLESTRToMB(lpstrFile,-1);
    FileLoad(lpszFileName);
    TaskFreeMem(lpszFileName);
#else
    TCHAR szFileName[256];
    
    lstrcpy(szFileName,lpstrFile);
    FileLoad(szFileName);
#endif
    gfLinked = TRUE;
    if (gpCtrlThis)
        gpCtrlThis->MarkAsLoaded();
    
    return ResultFromScode( S_OK );
}
    


//+---------------------------------------------------------------
//
//  Member:     LoadFromStorage
//
//  Synopsis:   Loads our data from a storage
//
//  Arguments:  [pStg] -- storage to load from
//
//  Returns:    SUCCESS if our native data was loaded
//
//  Notes:      This is a virtual method in our base class that is called
//              on an IPersistStorage::Load and an IPersistFile::Load when
//              the file is a docfile.  We override this method to
//              do our server-specific loading.
//
//----------------------------------------------------------------

HRESULT
SRDV::LoadFromStorage(LPSTORAGE pStg)
{
    DOUT(TEXT("SoundRec: LoadFromStorage\r\n"));
    LPSTREAM pStrm;

    // Open the OLE 1 Stream. 
    HRESULT hr = pStg->OpenStream(szOLE1Strm, NULL, STGM_SALL,0, &pStrm);
    
    if (OK(hr))
    {
        DWORD cbSize = 0L;

        pStrm->Read(&cbSize, sizeof(DWORD), NULL);
        
        if (cbSize > 0L)
        {
            LPBYTE lpbData = NULL;
            HANDLE hData = GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT, cbSize);
        
            if(hData != NULL)
            {
                if ((lpbData = (LPBYTE)GlobalLock(hData)) != NULL)
                {
                    pStrm->Read(lpbData, cbSize - sizeof(DWORD), NULL);
                    PutNativeData(lpbData, cbSize);
                    
                    GlobalUnlock(hData);
                    GlobalFree(hData);
                    if (gpCtrlThis)
                        gpCtrlThis->MarkAsLoaded();
                }
                else
                {
                    DOUT(TEXT("!Cannot Allocate Memory\r\n"));
                }
            }
        }
        pStrm->Release();
    }
    else
    {
//  There might be, in the future this ole2 stream, also, beta
//  ole objects will break without this.
        
        hr = pStg->OpenStream(szContentsStrm, NULL, STGM_SALL,0, &pStrm);
        if (OK(hr))
        {
            // Read the whole contents stream into memory and use that as a stream
            // to do our bits and pieces reads.
            pStrm = ConvertToMemoryStream(pStrm);

            hr = _header.Read(pStrm);
            if (OK(hr))
            {
                _sizel = _header._sizel;
                if(_header._dwNative > 0)
                {
                    //
                    //TODO: this code needs to be optimized. It is bad to create
                    //      three redundant copies of the wave data! At a minimum,
                    //      the ReadWaveFile (file.c) function should get a
                    //      companion MMIOProc capable of reading directly from
                    //      the stream...
                    //
                    LPBYTE lpbData = NULL;
                    HANDLE hData = GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT, _header._dwNative);
                    if(hData != NULL)
                    {
                        if ((lpbData = (LPBYTE)GlobalLock(hData)) != NULL)
                        {
                            pStrm->Read(lpbData, _header._dwNative, NULL);
                            PutNativeData(lpbData, _header._dwNative);
                            GlobalUnlock(hData);
                            GlobalFree(hData);
                            if (gpCtrlThis)
                                gpCtrlThis->MarkAsLoaded();
                        }
                    }
                    else
                    {
                        DOUT(TEXT("!Cannot Allocate Memory\r\n"));
                    }
                }
            }
            pStrm->Release();
        }
        else
        {
            DOUT(TEXT("!Cannot Open Stream\r\n"));
        }
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SaveToStorage
//
//  Synopsis:   Saves our data to a storage
//
//  Arguments:  [pStg]        -- storage to save to
//              [fSameAsLoad] -- flag indicating whether this is the same
//                               storage that we originally loaded from
//
//  Returns:    SUCCESS if our native data was saved
//
//  Notes:      This is a virtual method in our base class that is called
//              on an IPersistStorage::Save and IPersistFile::Save when the
//              file is a docfile.  We override this method to
//              do our server-specific saving.
//
//----------------------------------------------------------------

HRESULT
SRDV::SaveToStorage(LPSTORAGE pStg, BOOL fSameAsLoad)
{
    DOUT(TEXT("SoundRec: SaveToStorage\r\n"));

    HRESULT hr;

    // Mark our storage as OLE1
    if (!OK(hr = WriteClassStg(pStg, CLSID_OLE1SOUNDREC)))
        return hr;
    
    // open or create the native data stream and write our native data
    LPSTREAM pStrm;

    hr = pStg->CreateStream(szOLE1Strm,
            STGM_SALL | STGM_CREATE,
            0L,
            0L,
            &pStrm);

    if (!OK(hr))
        return hr;
    
    if (OK(hr))
    {
        HANDLE hNative = GetNativeData();
        DWORD cbSize;
        
        if (hNative != NULL && (cbSize = (DWORD)GlobalSize(hNative)) > 0)
        {
            hr = pStrm->Write(&cbSize, sizeof(cbSize), NULL);
            if (OK(hr))
            {
                LPBYTE pNative = (LPBYTE)GlobalLock(hNative);
                if(pNative != NULL)
                {
                    hr = pStrm->Write(pNative, cbSize, NULL);
                    GlobalUnlock(hNative);
                }
            }
        }
        if (hNative)
            GlobalFree(hNative);
    }
    
    pStrm->Release();
    
#ifdef OLE2ONLY
    hr = pStg->CreateStream(szContentsStrm,
            STGM_SALL | STGM_CREATE,
            0L,
            0L,
            &pStrm);

    if (OK(hr))
    {
        // update the members that may have changed
        _header._sizel = _sizel;

        HANDLE hNative = GetNativeData();
        _header._dwNative = GlobalSize(hNative);
        hr = _header.Write(pStrm);
        if (OK(hr))
        {
            if(_header._dwNative > 0)
            {
                LPBYTE pNative = (LPBYTE)GlobalLock(hNative);
                if(pNative != NULL)
                {
                    hr = pStrm->Write(pNative, _header._dwNative, NULL);
                    GlobalUnlock(hNative);
                }
            }
        }
        GlobalFree(hNative);
        pStrm->Release();
    }
#endif    
    return hr;
}


#ifdef WE_SUPPORT_INPLACE

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::RunningToInPlace
//
//  Synopsis:   Effects the running to inplace-active state transition
//
//  Returns:    SUCCESS if the object results in the in-place state
//
//---------------------------------------------------------------

HRESULT
SRCtrl::RunningToInPlace(void)
{
    return SrvrCtrl::RunningToInPlace();
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::InPlaceToRunning
//
//  Synopsis:   Effects the inplace-active to running state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//---------------------------------------------------------------

HRESULT
SRCtrl::InPlaceToRunning(void)
{
    return SrvrCtrl::InPlaceToRunning();
}

//+---------------------------------------------------------------
//
//  Member:     SRCtrl::UIActiveToInPlace
//
//  Synopsis:   Effects the U.I. active to inplace-active state transition
//
//  Returns:    SUCCESS in all but catastrophic circumstances
//
//---------------------------------------------------------------

HRESULT
SRCtrl::UIActiveToInPlace(void)
{
    return SrvrCtrl::UIActiveToInPlace();
}

#endif // WE_SUPPORT_INPLACE


//+---------------------------------------------------------------
//
//  Member:     SRInPlace::ClassInit (static)
//
//  Synopsis:   Load any static resources
//
//  Arguments:  [pClass] -- an initialized ClassDescriptor
//
//  Returns:    TRUE iff window class sucesfully registered
//
//---------------------------------------------------------------

BOOL
SRInPlace::ClassInit(LPCLASSDESCRIPTOR pClass)
{
    HINSTANCE hinst = pClass->_hinst;

    return TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     SRInPlace::Create (static)
//
//  Synopsis:   Create a new, fully initialize sub-object
//
//  Arguments:  [pSRCtrl] --  pointer to control we are a part of
//              [pClass] -- pointer to initialized class descriptor
//              [ppUnkCtrl] -- (out parameter) pObj's controlling unknown
//              [ppObj] -- (out parameter) the new sub-object
//
//  Returns:    NOERROR iff sucessful
//
//---------------------------------------------------------------

HRESULT
SRInPlace::Create( LPSRCTRL pSRCtrl,
        LPCLASSDESCRIPTOR pClass,
        LPUNKNOWN FAR* ppUnkCtrl,
        LPSRINPLACE FAR* ppObj)
{
    // set out parameters to NULL
    *ppUnkCtrl = NULL;
    *ppObj = NULL;

    // create an object
    HRESULT hr;
    LPSRINPLACE pObj;
    pObj = new SRInPlace((LPUNKNOWN)(LPOLEOBJECT)pSRCtrl);
    if (pObj == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // initialize it
        if (OK(hr = pObj->Init(pSRCtrl, pClass)))
        {
            // return the object and its controlling unknown
            *ppUnkCtrl = &pObj->_PrivUnk;
            *ppObj = pObj;
        }
        else
        {
            pObj->_PrivUnk.Release();    //hari-kari
        }
    }
    if(OK(hr))
    {
        hr = NOERROR;
    }
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     SRInPlace::SRInPlace
//
//  Synopsis:   Construct a new IP sub-object
//
//  Arguments:  [pUnkOuter] -- Unknown to aggregate with
//
//---------------------------------------------------------------

#pragma warning(disable:4355)   // `this' argument to base-member init. list.
SRInPlace::SRInPlace(LPUNKNOWN pUnkOuter):
        _PrivUnk(this)  // controlling unknown holds a pointer to us
{
    _pUnkOuter = (pUnkOuter != NULL) ? pUnkOuter : (LPUNKNOWN)&_PrivUnk;
}
#pragma warning(default:4355)


//+---------------------------------------------------------------
//
//  Member:     SRInPlace::~SRInPlace
//
//  Synopsis:   Destroy this sub-object
//
//---------------------------------------------------------------

SRInPlace::~SRInPlace(void)
{
}

//+---------------------------------------------------------------
//
//  Member:     SRInPlace::Init
//
//  Synopsis:   Initialize sub-object
//
//  Arguments:  [pSRCtrl] --  pointer to control we are a part of
//              [pClass]  -- pointer to an initialized class descriptor
//
//  Returns:    NOERROR if sucessful
//
//---------------------------------------------------------------

HRESULT
SRInPlace::Init(LPSRCTRL pSRCtrl, LPCLASSDESCRIPTOR pClass)
{
    HRESULT hr = SrvrInPlace::Init(pClass, pSRCtrl);
    return hr;
}

IMPLEMENT_DELEGATING_IUNKNOWN(SRInPlace)

IMPLEMENT_PRIVATE_IUNKNOWN(SRInPlace)

//+---------------------------------------------------------------
//
//  Member:     SRInPlace::QueryInterface, public
//
//     OLE:     IUnkown
//
//---------------------------------------------------------------
STDMETHODIMP
SRInPlace::PrivateUnknown::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (IsEqualIID(riid,IID_IUnknown))
    {
        *ppv = (LPVOID)this;
    }
    else if (IsEqualIID(riid,IID_IOleInPlaceObject)
          || IsEqualIID(riid,IID_IOleWindow))
    {
        *ppv = (LPVOID)(LPOLEINPLACEOBJECT)_pSRInPlace;
    }
    else if (IsEqualIID(riid,IID_IOleInPlaceActiveObject))
    {
        *ppv = (LPVOID)(LPOLEINPLACEACTIVEOBJECT)_pSRInPlace;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    //
    // Important:  we must addref on the pointer that we are returning,
    // because that pointer is what will be released!
    //
    ((IUnknown FAR*) *ppv)->AddRef();
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:    SRInPlace::AttachWin
//
//  Synopsis:  Create our InPlace window
//
//  Arguments: [hwndParent] -- our container's hwnd
//
//  Returns:   hwnd of InPlace window, or NULL
//
//---------------------------------------------------------------
HWND
SRInPlace::AttachWin(HWND hwndParent)
{
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\srfact.cxx ===
//+---------------------------------------------------------------------
//
//   File:       srfact.cxx
//
//   Contents:   Class Factory
//
//   Classes:    SRFactory
//
//------------------------------------------------------------------------

//#pragma warning(disable:4103)
#include <stdlib.h>

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>      // common dialog boxes

#include <ole2.h>
#include <o2base.hxx>     // the base classes and utilities

#include <initguid.h>
#include "srs.hxx"

SRFactory * gpSRFactory = NULL;
DWORD gdwRegisterClass = 0;

extern "C" BOOL
CreateSRClassFactory(HINSTANCE hinst,BOOL fEmbedded)
{
    BOOL fRet = FALSE;
    if(SRFactory::Create(hinst))
    {
        gpSRFactory->AddRef();
        if(fEmbedded)
        {
            DOUT(TEXT("SoundRec: Registering SRFactory\r\n"));

            HRESULT hr = CoRegisterClassObject(CLSID_SOUNDREC,
                    (LPUNKNOWN)(LPCLASSFACTORY)gpSRFactory,
                    CLSCTX_LOCAL_SERVER,
                    //REGCLS_MULTI_SEPARATE,
                    REGCLS_SINGLEUSE,
                    &gdwRegisterClass);
            if(OK(hr))
            {
                CoLockObjectExternal((LPUNKNOWN)(LPCLASSFACTORY)gpSRFactory,
                    TRUE, TRUE);
                fRet = TRUE;
            }
#if DBG
            else
            {
                TCHAR achBuffer[256];
                wsprintf(achBuffer,
                        TEXT("SoundRec: CoRegisterClassObject (%lx)\r\n"),
                        (long)hr);
                OutputDebugString(achBuffer);
            }
#endif
        }
        else
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

extern "C" HRESULT
ReleaseSRClassFactory(void)
{
    HRESULT hr = NOERROR;
    if(gdwRegisterClass)
    {
#if DBG            
        OutputDebugString(TEXT("SoundRec: Revoking SRFactory\r\n"));
#endif
        CoLockObjectExternal((LPUNKNOWN)(LPCLASSFACTORY)gpSRFactory,
             FALSE, TRUE);
        hr = CoRevokeClassObject(gdwRegisterClass);
        gdwRegisterClass = 0;

        gpSRFactory->Release();
        gpSRFactory = NULL;
    }
    return hr;
}


BOOL
SRFactory::Create(HINSTANCE hinst)
{
    gpSRFactory = new SRFactory;
    //
    // initialize our classes
    //
    if (gpSRFactory == NULL
             || !gpSRFactory->Init(hinst)
             || !SRCtrl::ClassInit(gpSRFactory->_pClass)
             || !SRDV::ClassInit(gpSRFactory->_pClass)
             || !SRInPlace::ClassInit(gpSRFactory->_pClass))
    {
        return FALSE;
    }
    return TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     SRFactory:::Init
//
//  Synopsis:   Initializes the class factory
//
//  Arguments:  [hinst] -- instance handle of the module with
//                         class descriptor resources
//
//  Returns:    TRUE iff the factory was successfully initialized
//
//----------------------------------------------------------------

BOOL
SRFactory::Init(HINSTANCE hinst)
{
    //
    // Register the standard OLE clipboard formats.
    // These are available in the OleClipFormat array.
    //
    RegisterOleClipFormats();
    
    if((_pClass = new ClassDescriptor) == NULL)
        return FALSE;
    
    BOOL fRet = _pClass->Init(hinst, 0); //IDS_CLASSID);

    //
    // Patch _pClass->_haccel with a resource reload
    // (for InPlace) due to mismatch between the base class
    // resource scheme and legacy code...
    //
    if(fRet)
    {
        if((_pClass->_haccel = LoadAccelerators(hinst, TEXT("SOUNDREC"))) == NULL)
            fRet = FALSE;
    }
    return fRet;
    
}

STDMETHODIMP
SRFactory::LockServer(BOOL fLock)
{
    return CoLockObjectExternal((LPUNKNOWN)gpSRFactory, fLock, TRUE);
}

//+---------------------------------------------------------------
//
//  Member:     SRFactory:::CreateInstance
//
//  Synopsis:   Member of IClassFactory interface
//
//----------------------------------------------------------------

STDMETHODIMP
SRFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID iid, LPVOID FAR* ppv)
{
#if DBG        
    OutputDebugString(TEXT("SRFactory::CreateInstance\r\n"));
#endif    

    *ppv = NULL;    //NULL output param
    //
    // create an object, then query for the appropriate interface
    //
    LPUNKNOWN pUnk;
    LPSRCTRL pTemp;
    HRESULT hr;
    if (OK(hr = SRCtrl::Create(pUnkOuter, _pClass, &pUnk, &pTemp)))
    {
        hr = pUnk->QueryInterface(iid, ppv);
        pUnk->Release();    // on failure this will release obj, otherwise
                            // it will ensure an object ref count of 1
    }
    return hr;
}


/*
 * for the creation of a moniker
 */
BOOL
CreateStandaloneObject(void)
{
    DOUT(TEXT("Soundrec CreateStandaloneObject\r\n"));

    //
    //Ensure a unique filename in gachLinkFilename so we can create valid
    //FileMonikers...
    //
    if(gachLinkFilename[0] == 0)
        BuildUniqueLinkName();

    BOOL fSuccess = FALSE;
    LPVOID pvUnk;
    HRESULT hr = gpSRFactory->CreateInstance(NULL, IID_IUnknown, (LPVOID FAR*)&pvUnk);
    if(hr == NOERROR)
    {
        //CoLockObjectExternal((LPUNKNOWN)(LPOLEOBJECT)gpCtrlThis, TRUE, TRUE);
        extern LPSRCTRL gpCtrlThis;
        gpCtrlThis->Lock();
        fSuccess = TRUE;
    }
    else
    {
        DOUT(TEXT("Soundrec CreateStandaloneObject FAILED!\r\n"));
        fSuccess = FALSE;
    }
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\wavedisp.c ===
/* (C) Copyright Microsoft Corporation 1991.  All Rights Reserved */
/* wavedisp.c
 *
 * Implements waveform display control ("td_wavedisplay").
 *
 * This is NOT a general-purpose control (see the globals below).
 *
 * The waveform is represented as a string of characters in a font that
 * consists of vertical lines that correspond to different amplitudes.
 * Actually there is no font, it's just done with patBlts
 *
 * WARNING: this control cheats: it stores information in globals, so you
 * couldn't put it in a DLL (or use two of them in the same app)
 * without changing it.
 */
/* Revision History.
 *  4/2/92 LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 *  25/6/92LaurieGr enhanced, Also had to reformat to 80 cols because
 *                  NT has only crappy fonts again.
 *  21/Feb/94 LaurieGr merged Daytona and Motown versions
 */

#include "nocrap.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <math.h>
#include "SoundRec.h"

/* constants */
#define MAX_TRIGGER_SEARCH  200     // limit search for trigger pt.
#define MIN_TRIGGER_SAMPLE  (128 - 8)   // look for silent part
#define MAX_TRIGGER_SAMPLE  (128 + 8)   // look for silent part

#define MIN_TRIG16_SAMPLE   (-1024)     // look for silent part
#define MAX_TRIG16_SAMPLE   (1024)      // look for silent part


/* globals */
static NPBYTE   gpbWaveDisplay;         // text string in WaveLine font
                                        // initially has samples in it
                                        // enough room for 4 bytes/sample
static RECT     grcWaveDisplay;         // wave display rectangle
static HBITMAP  ghbmWaveDisplay;        // mono bitmap.
static HDC      ghdcWaveDisplay;        // memory DC for bitmap.
// static iXScale = 1;                     // samples per pel across screen

/* UpdateWaveDisplayString()
 *
 * Copy samples from just before the current position in the sample buffer
 * to the wave display string.  The code tries to find a good "trigger point"
 * in the waveform so that the waveform will be aligned at the beginning of
 * a wave.
 *
 * The current position is in gpWaveSamples at glWavePosition which is
 * measured in samples (not bytes).
 *
 * The wave display string will contain numbers in the range -16..15
 *
 *  for 8  bit:   x' = abs(x-128)/8
 *  for 16 bit:   x' = abs(x)/2048
 *
 * When the display is "in motion" (i.e. actually playing or recording
 * we try to keep the display somewhat static by looking for a trigger
 * point (like an oscilloscope would) and display that part of the wave
 * that has just either played or been recorded.
 *
 */
static void NEAR PASCAL
UpdateWaveDisplayString(void)
{

    // piSrc and pbSrc are init NULL to kill a compiler diagnostic.
    // The compiler cannot follow the logic and thinks that they may be
    // used before being set.  (It's wrong. Hint: look at cbSrc and cbTrigger)

    BYTE *  pbSrc = NULL;   // pointer into <gpWaveSamples> to 8 bits
    short * piSrc = NULL;   // pointer into <gpWaveSamples> to 16 bits
                            // (use one or other according to wave format)

    int     cbSrc;          // number of samples that can be copied
    BYTE *  pbDst;          // pointer into <gpbWaveDisplay>
    int     cbDst;          // size of <gpWaveDisplay>
    int     cbTrigger;      // limit the search for a "trigger"
    BYTE    b;
    int     i;
    int     cnt;

    WORD    nSkipChannels;
    BOOL    fStereoIn;
    BOOL    fEightIn;

    cbDst = grcWaveDisplay.right - grcWaveDisplay.left; // rectangle size
    pbDst = gpbWaveDisplay;

    // Note: IsWaveFormatPCM() is called before this function is ever called, therefore
    //       we can always rely on the fact that gpWaveFormat->wwFormatTag == WAVE_FORMAT_PCM.
    //       This also implies, as mentioned in the docs on WAVEFORMATEX, that the
    //       gpWaveFormat->wBitsPerSample should be equal to 8 or 16.

    // Note: We average the first two channels if they exist, any additional channels are 
    //       ignored.
    
    fStereoIn = gpWaveFormat->nChannels != 1;
    fEightIn  = ((LPWAVEFORMATEX)gpWaveFormat)->wBitsPerSample == 8;
    nSkipChannels = max (0, gpWaveFormat->nChannels - 2);
    
    /* search for a "trigger point" if we are recording or playing */
    if ((ghWaveOut != NULL) || (ghWaveIn != NULL))
    {   // we are in motion - align the *right* hand side of the window.
        cbTrigger = MAX_TRIGGER_SEARCH;

        if (gpWaveSamples == NULL)
        {
            /* no document at all is open */
            cbSrc = 0;
        }
        else
        {
            long    lStartOffsetSrc, lEndOffsetSrc;

            /* align the *right* side of wave display to the current
             * position in the wave buffer, so that during recording
             * we see only samples that have just been recorded
             */
            lStartOffsetSrc = glWavePosition - (cbDst + cbTrigger);
            lEndOffsetSrc = glWavePosition;
            if (lStartOffsetSrc < 0)
                lEndOffsetSrc -= lStartOffsetSrc, lStartOffsetSrc = 0L;
            if (lEndOffsetSrc > glWaveSamplesValid)
                lEndOffsetSrc = glWaveSamplesValid;

            // Bombay Bug 1360: lStartOffsetSrc > lEndOffsetSrc causes GP Fault
            // if glWaveSamplesValid < lStartOffsetSrc we have a problem.

            if (lStartOffsetSrc > lEndOffsetSrc)
            {
                lStartOffsetSrc = lEndOffsetSrc - (cbDst + cbTrigger);
                if (lStartOffsetSrc < 0)
                    lStartOffsetSrc = 0L;
            }

            cbSrc = (int)wfSamplesToBytes(gpWaveFormat, lEndOffsetSrc - lStartOffsetSrc);

            /* copy samples from buffer into local one */
            memmove( gpbWaveDisplay
                   , gpWaveSamples + wfSamplesToBytes(gpWaveFormat, lStartOffsetSrc)
                   , cbSrc
                   );

            pbSrc = (BYTE *) gpbWaveDisplay;
            piSrc = (short *) gpbWaveDisplay;
        }

        if (cbTrigger > 0) {
            cbTrigger = min(cbSrc, cbTrigger);   // don't look beyond buffer end

            /* search for a silent part in waveform */
            if (fEightIn)
            {
                while (cbTrigger > 0)
                {
                    b = *pbSrc;
                    if ((b > MIN_TRIGGER_SAMPLE) && (b < MAX_TRIGGER_SAMPLE))
                        break;
                    cbSrc--, pbSrc++, cbTrigger--;
                    if (fStereoIn)
                        pbSrc+=(nSkipChannels+1);
                }
            }
            else
            {   // not EightIn
                while (cbTrigger > 0)
                {
                    i = *piSrc;
                    if ((i > MIN_TRIG16_SAMPLE) && (i < MAX_TRIG16_SAMPLE))
                        break;
                    cbSrc--, piSrc++, cbTrigger--;
                    if (fStereoIn)
                        piSrc+=(nSkipChannels+1);
                }
            }

            /* search for a non-silent part in waveform (this is the "trigger") */
            if (fEightIn)
            {
                while (cbTrigger > 0)
                {
                    b = *pbSrc;
                    if ((b <= MIN_TRIGGER_SAMPLE) || (b >= MAX_TRIGGER_SAMPLE))
                        break;
                    cbSrc--, pbSrc++, cbTrigger--;
                    if (fStereoIn)
                        pbSrc+=(nSkipChannels+1);
                }
            }
            else
            {   // not EightIn
                while (cbTrigger > 0)
                {
                    i = *piSrc;
                    if ((i <= MIN_TRIG16_SAMPLE) || (i >= MAX_TRIG16_SAMPLE))
                        break;
                    cbSrc--, piSrc++, cbTrigger--;
                    if (fStereoIn)
                        piSrc+=(nSkipChannels+1);
                }
            }
        }
    }
    else  // it's not playing or recording - static display
    {
        long    lStartOffsetSrc, lEndOffsetSrc;

        /* align the *left* side of wave display to the current
         * position in the wave buffer
         */
        lStartOffsetSrc = glWavePosition;
        lEndOffsetSrc = glWavePosition + cbDst;
        if (lEndOffsetSrc > glWaveSamplesValid)
            lEndOffsetSrc = glWaveSamplesValid;

        cbSrc = (int)wfSamplesToBytes( gpWaveFormat
                                     , lEndOffsetSrc - lStartOffsetSrc
                                     );

        //
        // copy samples from buffer into local one
        //
        memmove( gpbWaveDisplay
               , gpWaveSamples
                 + wfSamplesToBytes(gpWaveFormat, lStartOffsetSrc)
               , cbSrc
               );

        pbSrc = (BYTE *) gpbWaveDisplay;
        piSrc = (short *) gpbWaveDisplay;
    }

    cnt = min(cbSrc, cbDst);
    cbDst -= cnt;

    /* map cnt number of samples from pbSrc to string characters at pbDst
    ** fEightIn => 8 byte samples, else 16
    ** fStereoIn => Average left and right channels
    **
    ** pbSrc and pbDst both point into the same buffer addressed by
    ** gpbWaveDisplay, pbSrc >= pbDst.  We process left to right, so OK.
    */

    if (fEightIn)
    {
        BYTE *pbDC = pbDst;
        int dccnt = cnt;
        DWORD dwSum = 0L;
        
        while (cnt-- > 0)
        {
            b = *pbSrc++;
            if (fStereoIn)
            {
                // Average left and right channels.
                b /= 2;
                b += (*pbSrc++ / 2);
                // Skip channels past Stereo
                pbSrc+=nSkipChannels;
            }
            dwSum += *pbDst++ = (BYTE)(b/8 + 112);   // 128 + (b-128)/8            
        }

        /* Eliminate DC offsets by subtracting the average offset
         * over all samples.
         */
        if (dwSum)
        {
            dwSum /= (DWORD)dccnt;
            dwSum -= 128;
            while (dwSum && dccnt-- > 0)
                *pbDC++ -= (BYTE)dwSum;
        }
        
    }
    else
    {
        BYTE *pbDC = pbDst;
        int dccnt = cnt;
        LONG lSum = 0L;
        
        while (cnt-- > 0)
        {
            i = *piSrc++;
            if (fStereoIn)
            {
                // Average left and right channels.
                i /= 2;
                i += (*piSrc++ / 2);
                // Skip channels past Stereo
                piSrc+=nSkipChannels;
            }
            lSum += *pbDst++ = (BYTE)(i/2048 + 128);
        }
        
        /* Eliminate DC offsets by subtracting the average offset
         * over all samples.
         */
        if (lSum)
        {
            lSum /= dccnt;
            lSum -= 128;
            while (lSum && dccnt-- > 0)
                *pbDC++ -= (BYTE)lSum;
        }
        
    }
    /* if necessary, pad the strings with whatever character represents
     * the "silence level".  This is 128, the midpoint level.
     */
    while (cbDst-- > 0)
        *pbDst++ = 128;
}

/* WaveDisplayWndProc()
 *
 * This is the window procedure for the "WaveDisplay" control.
 */
INT_PTR CALLBACK
WaveDisplayWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PAINTSTRUCT ps;
    RECT        rc;
    int         i;
    int         n;
    int         dx;
    int         dy;

    switch (wMsg)
    {
    case WM_CREATE:
        /* make the window a bit bigger so that it lines up with
         * the frames of the shadow-frames beside it
         */

        /* allocate <gpbWaveDisplay> */
        GetClientRect(hwnd, &grcWaveDisplay);
        InflateRect(&grcWaveDisplay, -1, -1); // account for border

        gpbWaveDisplay = (NPBYTE)GlobalAllocPtr(GHND,
                         (grcWaveDisplay.right+MAX_TRIGGER_SEARCH) * 4);
                         // 4 is the maximum bytes per sample allowed

        if (gpbWaveDisplay == NULL)
                return -1;                   // out of memory

        ghdcWaveDisplay = CreateCompatibleDC(NULL);

        if (ghdcWaveDisplay == NULL)
                return -1;                   // out of memory

        ghbmWaveDisplay = CreateBitmap(
                grcWaveDisplay.right-grcWaveDisplay.left,
                grcWaveDisplay.bottom-grcWaveDisplay.top,
                1,1,NULL);

        if (ghbmWaveDisplay == NULL)
                return -1;                   // out of memory

        SelectObject(ghdcWaveDisplay, ghbmWaveDisplay);
        break;

    case WM_DESTROY:
        /* free <gpbWaveDisplay> */
        if (gpbWaveDisplay != NULL)
        {
                GlobalFreePtr(gpbWaveDisplay);
                gpbWaveDisplay = NULL;
        }

        if (ghbmWaveDisplay != NULL)
        {
                DeleteDC(ghdcWaveDisplay);
                DeleteObject(ghbmWaveDisplay);
                ghdcWaveDisplay = NULL;
                ghbmWaveDisplay = NULL;
        }

        break;

    case WM_ERASEBKGND:
        /* draw the border and fill */
        GetClientRect(hwnd, &rc);
        DrawShadowFrame((HDC)wParam, &rc);
        return 0L;

    case WM_PAINT:
        BeginPaint(hwnd, &ps);

        if (!IsWaveFormatPCM(gpWaveFormat))
        {
                FillRect(ps.hdc, &grcWaveDisplay, ghbrPanel);
        }
        else if (gpbWaveDisplay != NULL)
        {
            /* update <gpbWaveDisplay> */
            UpdateWaveDisplayString();

            dx = grcWaveDisplay.right-grcWaveDisplay.left;
            dy = grcWaveDisplay.bottom-grcWaveDisplay.top;

            //
            // update the bitmap.
            //
            PatBlt(ghdcWaveDisplay,0,0,dx,dy,BLACKNESS);
            PatBlt(ghdcWaveDisplay,0,dy/2,dx,1,WHITENESS);

            for (i=0; i<dx; i++)
            {
                n = (BYTE)gpbWaveDisplay[i];  // n.b. must get it UNSIGNED
                n = n-128;                    // -16..15

                if (n > 0)
                    PatBlt(ghdcWaveDisplay,
                           i, dy/2-n,
                           1, n*2+1,         WHITENESS);
                
                if (n < -1)
                {
                    n++;                      // neg peak == pos peak
                    PatBlt(ghdcWaveDisplay,
                        i, dy/2+n,
                        1, -(n*2)+1,      WHITENESS);
                }
            }

            /* draw the waveform */
            SetTextColor(ps.hdc, RGB_BGWAVEDISP);
            SetBkColor(ps.hdc, RGB_FGWAVEDISP);

            BitBlt(ps.hdc, grcWaveDisplay.left, grcWaveDisplay.top,
                dx,dy, ghdcWaveDisplay, 0, 0, SRCCOPY);
        }

        EndPaint(hwnd, &ps);
        return 0L;
    }

    return DefWindowProc(hwnd, wMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mci\mci.c ===
/*
    mci.c

    A console app to test the mciSendString API

    Created by NigelT in a moment of frustration with the GUI world.

*/

#include "mci.h"
#include "mcicda.h"

extern VOID winmmSetDebugLevel(int level);
// extern VOID mcicdaSetDebugLevel(int level);

char cmd[256];
char ResultString[256];
char ErrorString[256];

void SendCommand(char *command);
void Usage(void);
BOOL Parse(char *command);

int main(int argc, char *argv[])
{
    FILE *fp;

    if (argc > 1) {

        // do the command line thing and exit
        fp = fopen(argv[1], "r");
        if (fp == NULL) {
            strcpy(cmd, argv[1]);
            strcat(cmd, ".mci");
            fp = fopen(cmd, "r");
            if (fp == NULL) {
                printf("\nCould not open %s or %s", argv[1], cmd);
                exit(1);
            }
        }

        do {
            if (fgets(cmd, sizeof(cmd), fp) == NULL) break;
            // strip the newline char from the end
            cmd[strlen(cmd)-1] = '\0';
            printf("\nCommand: %s", cmd);
            if (!Parse(cmd)) break;
        } while(1);

    } else {

        // do the keyboard thing until we get bored

        do {
            printf("\nCommand: ");
            gets(cmd);
            if (!Parse(cmd)) break;
        } while(1);
    }

    return 0;
}

BOOL Parse(char *command)
{
    if (strcmpi(command, "q") == 0) {
        return FALSE;
    } else if (strcmpi(command, "?") == 0) {
        Usage();
    } else if (strnicmp(command, "dmm", 3) == 0) {
        winmmSetDebugLevel(atoi(command+3));
//  } else if (strnicmp(command, "dcd", 3) == 0) {
//      mcicdaSetDebugLevel(atoi(command+3));
    } else {
        SendCommand(command);
    }
    return TRUE;
}

void SendCommand(char *command)
{
    DWORD Result;

    Result = mciSendString(command, ResultString, sizeof(ResultString), 0);
    printf("\nResult : %08XH  %s", Result, ResultString);
    if (Result != 0) {
        mciGetErrorString(Result, ErrorString, sizeof(ErrorString));
        printf("\nError  : %s", ErrorString);
    }
}

void Usage()
{
    printf("\nUsage:");
    printf("\nMCI <filename>    Play an MCI script");
    printf("\nMCI               Enter command mode");
    printf("\n\nCommands:");
    printf("\nq            \t\tQuit");
    printf("\ndmm <n>      \t\tSet WINMM debug level to <n>");
//  printf("\ndcd <n>      \t\tSet MCICDA debug level to <n>");
    printf("\n?            \t\tThis helpful little missive");
    printf("\n<mci command>\t\tSome MCI command string");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndrec32\soundrec\wave.c ===
/* (C) Copyright Microsoft Corporation 1991-1994.  All Rights Reserved */
/* wave.c
 *
 * Waveform input and output.
 */

/** Revision History.
 *  4/2/91    LaurieGr (AKA LKG) Ported to WIN32 / WIN16 common code
 *  17/Feb/94 LaurieGr Merged Daytona and Motown versions.

 *  READ ME

 *  The new soundrec was changed to use multiple headers for the following
 *  reason.  The Win3.1 version of soundrec did one waveOutWrite (with one
 *  WAVEHDR) for the entire buffer, this worked okay for relatively small
 *  files, but the moment we started using large files (>
 *  3meg) it was becoming cumbersome since it needed all of that
 *  data page-locked.  It occasionally paged for > 1 min.
 *  Note: The o-scope display for soundrec is also updated on
 *  the WOM_DONE message, it no longer looks at the buffer given on the
 *  waveOutWrite before the WOM_DONE message for the buffer
 *  is received.  This is why input mapping was not implemented
 *  in ACM on product one, there were drawing artifacts in the
 *  o-scope window.

 *  The pausing algorithm was changed for the following reason.
 *  If you launch two instances of soundrec (with two wave devices)
 *  and do the following...  Play a .wav file on instance #1
 *  (allocates first device); play a .wav file on instance #2
 *  (allocates second device); press stop on instance #1
 *  (frees first device); press rewind on instance #2
 *  (frees second device, allocates first device).
 *  Essentially, you press rewind in soundrec and you
 *  switch devices.  Since there is no explicit stop,
 *  the device should not be closed.
 */

#include "nocrap.h"
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <mmreg.h>

#ifdef USE_MMCNTRLS
#define NOTOOLBAR
#define NOMENUHELP
#define NODRAGLIST
#define NOBITMAPBTN
#define NOMENUHELP
#define NODRAGLIST
#include "mmcntrls.h"
#else
#include <commctrl.h>
#include "buttons.h"
#endif

#define INCLUDE_OLESTUBS
#include "SoundRec.h"
#include "srecnew.h"
#include "reg.h"

#ifndef LPHWAVE
typedef HWAVE FAR *LPHWAVE;
#endif

/* globals that maintain the state of the current waveform */
BOOL            gfSyncDriver;           // true if open device is sync
PWAVEFORMATEX   gpWaveFormat;           // format of WAVE file
DWORD           gcbWaveFormat;          // size of WAVEFORMAT
LPTSTR          gpszInfo = NULL;        // file info
HPBYTE          gpWaveSamples = NULL;   // pointer to waveoform samples
LONG            glWaveSamples = 0;  // number of samples total in buffer
LONG            glWaveSamplesValid = 0; // number of samples that are valid
LONG            glWavePosition = 0; // current wave position in samples from start
LONG            glStartPlayRecPos;  // position when play or record started
LONG            glSnapBackTo = 0;
HWAVEOUT        ghWaveOut = NULL;   // wave-out device (if playing)
HWAVEIN         ghWaveIn = NULL;    // wave-out device (if recording)
BOOL            gfStoppingHard = FALSE; // StopWave() was called?
                                        // true during the call to FinishPlay()
static BOOL     fStopping = FALSE;  // StopWave() was called?
DWORD           grgbStatusColor;    // color of status text

DWORD           gdwCurrentBufferPos;    // Current playback/record pos (bytes)
DWORD           gdwBytesPerBuffer;      // Bytes in each buffer we give drvr
DWORD           gdwTotalLengthBytes;    // Length of entire buffer in bytes
DWORD           gdwBufferDeltaMSecs;    // # msecs added to end on record
BOOL            gfTimerStarted;

WAVEHDR    FAR *gapWaveHdr[MAX_WAVEHDRS];
UINT            guWaveHdrs;             // 1/2 second of buffering?
UINT            guWaveHdrsInUse;        // # we actually could write
UINT            gwMSecsPerBuffer;       // 1/8 second

#ifdef THRESHOLD
int iNoiseLevel = 15;      // 15% of full volume is defined to be quiet
int iQuietLength = 1000;  // 1000 samples in a row quiet means quiet
#endif // THRESHOLD

BOOL        fFineControl = FALSE; // fine scroll control (SHIFT key down)

/*------------------------------------------------------------------
|  fFineControl:
|  This turns on place-saving to help find your way
|  a wave file.  It's controlled by the SHIFT key being down.
|  If the key is down when you scroll (see soundrec.c) then it scrolls
|  fine amounts - 1 sample or 10 samples rather than about 100 or 1000.
|  In addition, if the SHIFT key is down when a sound is started
|  playing or recording, the position will be remembered and it will
|  snap back to that position.  fFineControl says whether we are
|  remembering such a position to snap back to.  SnapBack does the
|  position reset and then turns the flag off.  There is no such flag
|  or mode for scrolling, the SHIFT key state is examined on every
|  scroll command (again - see Soundrec.c)
 --------------------------------------------------------------------*/



/* dbgShowMemUse: display memory usage figures on debugger */
void dbgShowMemUse()
{
    MEMORYSTATUS ms;

    GlobalMemoryStatus(&ms);
//    dprintf( "load %d\n    PHYS tot %d avail %d\n    PAGE tot %d avail %d\n    VIRT tot %d avail %d\n"
//           , ms.dwMemoryLoad
//           , ms.dwTotalPhys, ms.dwAvailPhys
//           , ms.dwTotalPageFile, ms.dwAvailPageFile
//           , ms.dwTotalVirtual, ms.dwAvailVirtual
//           );

} // dbgShowMemUse

/* PLAYBACK and PAGING on NT
|
|  In order to try to get decent performance at the highest data rates we
|  need to try very hard to get all the data into storage.  The paging rate
|  on several x86 systems is only just about or even a little less than the
|  maximum data rate.  We therefore do the following:
|  a. Pre-touch the first 1MB of data when we are asked to start playing.
|     If it is already in storage, this is almost instantaneous.
|     If it needs to be faulted in, there will be a delay, but it will be well
|     worth having this delay at the start rather than clicks and pops later.
|     (At 44KHz 16 bit stereo it could be about 7 secs, 11KHz 8 bit mono it
|     would only be about 1/2 sec anyway).
|  b. Kick off a separate thread to run through the data touching 1 byte per
|     page.  This thread is Created when we start playing, periscopes the global
|     static flag fStopping and exits when it reaches the end of the buffer or when
|     that flag is set.  The global thread handle is kept in ghPreTouch and this is
|     initially invalid.  We WAIT on this handle (if valid) to clear the thread out
|     before creating a new one (so there will be at most one).  We do NOT do any
|     of this for record.  The paging does not have to happen in real time for
|     record.  It can get quite a way behind and still manage.
|
|  This whole thing is really a bit of a hack and sits uncomfortably on NT.
|  The memory management works by paging out the least recently used (LRU)
|  pages.  By stepping right though a 10Meg buffer, we will cause a lot of
|  code to get paged out.  It would be better to have a file and read it
|  in section by section into a much smaller buffer (like MPlayer does).

   Note that the use of multiple headers doesn't really affect anything.
   The headers merely point at different sections of the wave buffer.
   It merely makes the addressing of the starting point slightly different.
*/
HANDLE ghPreTouch = NULL;

typedef struct {
        LPBYTE Addr;  // start of buffer to pre-touch
        DWORD  Len;   // length of buffer to pre-touch
} PRETOUCHTHREADPARM;

/* PreToucher
**
** Asynchronous pre-toucher thread.  The thread parameter dw
** is realy a poionter to a PRETOUCHTHREADPARAM
*/
DWORD PreToucher(DWORD_PTR dw)
{
    PRETOUCHTHREADPARM * pttp;

    long iSize;
    BYTE * pb;

    pttp = (PRETOUCHTHREADPARM *) dw;
    if (!pttp) return 0;

    iSize = pttp->Len;
    pb = pttp->Addr;

    GlobalFreePtr(pttp);
    if (!pb) return 0;

    while (iSize>0 && !fStopping) {
        volatile BYTE b;
        b = *pb;
        pb += 4096;    // move to next page.  Are they ALWAYS 4096?
        iSize -= 4096; // and count it off
    }
//  dprintf(("All pretouched!"));
    return 0;
} // PreToucher


/* StartPreTouchThread
**
** Start a thread running which will run through the wave buffer
** pre-touching one byte every page to ensure that the stuff is
** faulted into memory before we actually need it.
** This was needed to make 44KHz 16 bit stereo work on a
** 25MHx 386 with 16MB memory running Windows NT.
*/
void StartPreTouchThread(LPBYTE lpb, LONG cb)
{
    /* before we start the thing running, pretouch the first bit of memory
       to give the paging a head start.  THEN start the thread running.
    */
    {    long bl = cb;
         BYTE * pb = lpb;
         if (bl>1000000) bl = 1000000;   /* 1 Meg, arbitrarily */
         pb += bl;
         while (bl>0){
             volatile BYTE b;
             b = *pb;
             pb-=4096;
             bl -= 4096;
         }
    }


    {
         PRETOUCHTHREADPARM * pttp;
         DWORD dwThread;

         if (ghPreTouch!=NULL) {
             fStopping = TRUE;
             WaitForSingleObject(ghPreTouch, INFINITE);
             CloseHandle(ghPreTouch);
             ghPreTouch = NULL;
         }
         fStopping = FALSE;
         pttp = (PRETOUCHTHREADPARM *)GlobalAllocPtr(GHND, sizeof(PRETOUCHTHREADPARM));
                /* freed by the invoked thread */

         if (pttp!=NULL) {
             pttp->Addr = lpb;
             pttp->Len = cb;
             ghPreTouch = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PreToucher, pttp, 0, &dwThread);
             // If the CreateThread fails there will be a memory leak.  It's very small,
             // unlikely and not frequent.  Not worth fixing.
         }
    }
} // StartPreTouchThread



/* wfBytesToSamples(pwf, lBytes)
 *
 * convert a byte offset into a sample offset.
 *
 * lSamples = (lBytes/nAveBytesPerSec) * nSamplesPerSec
 *
 */
LONG PASCAL wfBytesToSamples(WAVEFORMATEX* pwf, LONG lBytes)
{
    return MulDiv(lBytes,pwf->nSamplesPerSec,pwf->nAvgBytesPerSec);
}

/* wfSamplesToBytes(pwf, lSample)
 *
 * convert a sample offset into a byte offset, with correct alignment
 * to nBlockAlign.
 *
 * lBytes = (lSamples/nSamplesPerSec) * nBytesPerSec
 *
 */
LONG PASCAL wfSamplesToBytes(WAVEFORMATEX* pwf, LONG lSamples)
{
    LONG lBytes;

    lBytes = MulDiv(lSamples,pwf->nAvgBytesPerSec,pwf->nSamplesPerSec);

    // now align the byte offset to nBlockAlign
#ifdef ROUND_UP
    lBytes = ((lBytes + pwf->nBlockAlign-1) / pwf->nBlockAlign) * pwf->nBlockAlign;
#else
    lBytes = (lBytes / pwf->nBlockAlign) * pwf->nBlockAlign;
#endif

    return lBytes;
}

/* wfSamplesToTime(pwf, lSample)
 *
 * convert a sample offset into a time offset in miliseconds.
 *
 * lTime = (lSamples/nSamplesPerSec) * 1000
 *
 */
LONG PASCAL wfSamplesToTime(WAVEFORMATEX* pwf, LONG lSamples)
{
    return MulDiv(lSamples,1000,pwf->nSamplesPerSec);
}

/* wfTimeToSamples(pwf, lTime)
 *
 * convert a time index into a sample offset.
 *
 * lSamples = (lTime/1000) * nSamplesPerSec
 *
 */
LONG PASCAL wfTimeToSamples(
    WAVEFORMATEX*   pwf,
    LONG            lTime)
{
    return MulDiv(lTime,pwf->nSamplesPerSec,1000);
}

/*
 * function to determine if a WAVEFORMAT is a valid PCM format we support for
 * editing and such.
 *
 * we only handle the following formats...
 *
 *  Mono 8bit
 *  Mono 16bit
 *  Stereo 8bit
 *  Stereo 16bit
 * */
BOOL PASCAL IsWaveFormatPCM(WAVEFORMATEX* pwf)
{
    if (!pwf)
        return FALSE;

    if (pwf->wFormatTag != WAVE_FORMAT_PCM)
        return FALSE;

    if (pwf->nChannels < 1 || pwf->nChannels > 2)
        return FALSE;

    if ((pwf->wBitsPerSample != 8) && (pwf->wBitsPerSample != 16))
        return FALSE;

    return TRUE;
} // IsWaveFormatPCM

void PASCAL WaveFormatToString(LPWAVEFORMATEX lpwf, LPTSTR sz)
{
    TCHAR achFormat[80];

    //
    //  this is what we expect the resource strings to be...
    //
    // IDS_MONOFMT      "Mono %d%c%03dkHz, %d-bit"
    // IDS_STEREOFMT    "Stereo %d%c%03dkHz, %d-bit"
    //
    if (gfLZero || ((WORD)(lpwf->nSamplesPerSec / 1000) != 0)){
    LoadString(ghInst,lpwf->nChannels == 1 ? IDS_MONOFMT:IDS_STEREOFMT,
                   achFormat, SIZEOF(achFormat));

    wsprintf(sz, achFormat,
                 (UINT)  (lpwf->nSamplesPerSec / 1000), chDecimal,
                 (UINT)  (lpwf->nSamplesPerSec % 1000),
                 (UINT)  (lpwf->nAvgBytesPerSec * 8 / lpwf->nSamplesPerSec / lpwf->nChannels));
    } else {
        LoadString(ghInst,lpwf->nChannels == 1 ? IDS_NOZEROMONOFMT:
                   IDS_NOZEROSTEREOFMT, achFormat, SIZEOF(achFormat));

        wsprintf(sz, achFormat,
                 chDecimal,
                 (WORD)  (lpwf->nSamplesPerSec % 1000),
                 (WORD)  (lpwf->nAvgBytesPerSec * 8 / lpwf->nSamplesPerSec / lpwf->nChannels));
    }
} // WaveFormatToString

#ifdef THRESHOLD

/*
 * SkipToStart()
 *
 * move forward through sound file to the start of a noise.
 * What is defined as a noise is rather arbitrary.  See NoiseLevel
 */
void FAR PASCAL SkipToStart(void)
{  BYTE * pb;   // pointer to 8 bit sample
   int  * pi;   // pointer to 16 bit sample
   BOOL f8;     // 8 bit samples
   BOOL fStereo; // 2 channels
   int  iLo;    // minimum quiet value
   int  iHi;    // maximum quiet value

   fStereo = (gpWaveFormat->nChannels != 1);
   f8 = (pWaveFormat->wBitsPerSample == 8);

   if (f8)
   {  int iDelta = MulDiv(128, iNoiseLevel, 100);
      iLo = 128 - iDelta;
      iHi = 128 + iDelta;
   }
   else
   {  int iDelta = MulDiv(32767, iNoiseLevel, 100);
      iLo = 0 - iDelta;
      iHi = 0 + iDelta;
   }

   pb = (BYTE *) gpWaveSamples
                           + wfSamplesToBytes(gpWaveFormat, glWavePosition);
   pi = (int *)pb;

   while (glWavePosition < glWaveSamplesValid)
   {   if (f8)
       {   if ( ((int)(*pb) > iHi) || ((int)(*pb) < iLo) )
              break;
           ++pb;
           if (fStereo)
           {   if ( ((int)(*pb) > iHi) || ((int)(*pb) < iLo) )
               break;
               ++pb;
           }
       }
       else
       {   if ( (*pi > iHi) || (*pi < iLo) )
              break;
           ++pi;
           if (fStereo)
           {  if ( (*pi > iHi) || (*pi < iLo) )
                 break;
              ++pi;
           }
       }
       ++glWavePosition;
   }
   UpdateDisplay(FALSE);
} /* SkipToStart */


/*
 * SkipToEnd()
 *
 * move forward through sound file to a quiet place.
 * What is defined as quiet is rather arbitrary.
 * (Currently less than 20% of full volume for 1000 samples)
 */
void FAR PASCAL SkipToEnd(void)
{  BYTE * pb;   // pointer to 8 bit sample
   int  * pi;   // pointer to 16 bit sample
   BOOL f8;     // 8 bit samples
   BOOL fStereo; // 2 channels
   int  cQuiet;  // number of successive quiet samples so far
   LONG lQuietPos; // Start of quiet period
   LONG lPos;      // Search counter

   int  iLo;    // minimum quiet value
   int  iHi;    // maximum quiet value

   fStereo = (gpWaveFormat->nChannels != 1);
   f8 = (gpWaveFormat->wBitsPerSample == 8);

   if (f8)
   {  int iDelta = MulDiv(128, iNoiseLevel, 100);
      iLo = 128 - iDelta;
      iHi = 128 + iDelta;
   }
   else
   {  int iDelta = MulDiv(32767, iNoiseLevel, 100);
      iLo = 0 - iDelta;
      iHi = 0 + iDelta;
   }

   pb = (BYTE *) gpWaveSamples
                           + wfSamplesToBytes(gpWaveFormat, glWavePosition);
   pi = (int *)pb;

   cQuiet = 0;
   lQuietPos = glWavePosition;
   lPos = glWavePosition;

   while (lPos < glWaveSamplesValid)
   {   BOOL fQuiet = TRUE;
       if (f8)
       {   if ( ((int)(*pb) > iHi) || ((int)(*pb) < iLo) ) fQuiet = FALSE;
           if (fStereo)
           {   ++pb;
               if ( ((int)(*pb) > iHi) || ((int)(*pb) < iLo) ) fQuiet = FALSE;
           }
           ++pb;
       }
       else
       {   if ( (*pi > iHi) || (*pi < iLo) ) fQuiet = FALSE;
           if (fStereo)
           {   ++pi;
               if ( (*pi > iHi) || (*pi < iLo) ) fQuiet = FALSE;
           }
           ++pi;
       }
       if (!fQuiet) cQuiet = 0;
       else if (cQuiet == 0)
       {    lQuietPos = lPos;
            ++cQuiet;
       }
       else
       {  ++cQuiet;
          if (cQuiet>=iQuietLength) break;
       }

       ++lPos;
   }
   glWavePosition = lQuietPos;
   UpdateDisplay(FALSE);
} /* SkipToEnd */


/*
 * IncreaseThresh()
 *
 * Increase the threshold of what counts as quiet by about 25%
 * Ensure it changes by at least 1 unless on the stop already
 *
 */
void FAR PASCAL IncreaseThresh(void)
{   iNoiseLevel = MulDiv(iNoiseLevel+1, 5, 4);
    if (iNoiseLevel>100) iNoiseLevel = 100;
} // IncreaseThreshold


/*
 * DecreaseThresh()
 *
 * Decrease the threshold of what counts as quiet by about 25%
 * Ensure it changes by at least 1 unless on the stop already
 * It's a divisor, so we INcrease the divisor, but never to 0
 *
 */
void FAR PASCAL DecreaseThresh(void)
{   iNoiseLevel = MulDiv(iNoiseLevel, 4, 5)-1;
    if (iNoiseLevel <=0) iNoiseLevel = 0;
} // DecreaseThreshold

#endif //THRESHOLD


/* fOK = AllocWaveBuffer(lSamples, fErrorBox, fExact)
 *
 * If <gpWaveSamples> is NULL, allocate a buffer <lSamples> in size and
 * point <gpWaveSamples> to it.
 *
 * If <gpWaveSamples> already exists, then just reallocate it to be
 * <lSamples> in size.
 *
 * if fExact is FALSE, then when memory is tight, allocate less than
 * the amount asked for - so as to give reasonable performance,
 * if fExact is TRUE then when memory is short, FAIL.
 * NOTE: On NT on a 16MB machine it WILL GIVE you 20MB, i.e. it does
 * NOT FAIL - but may (unacceptably) take SEVERAL MINUTES to do so.
 * So better to monitor the situation ourselves and ask for less.
 *
 * On success, return TRUE.  On failure, return FALSE but if and only
 * if fErrorBox is TRUE then display a MessageBox first.
 */
BOOL FAR PASCAL AllocWaveBuffer(
        LONG    lSamples,       // samples to allocate
        BOOL    fErrorBox,      // TRUE if you want an error displayed
        BOOL    fExact)         // TRUE means allocate the full amount requested or FAIL
{
    LONG_PTR    lAllocSamples;  // may be bigger than lSamples
    LONG_PTR    lBytes;     // bytes to allocate
    LONG_PTR    lBytesReasonable;  // bytes reasonable to use (phys mem avail).

    MEMORYSTATUS ms;

    lAllocSamples = lSamples;

    lBytes = wfSamplesToBytes(gpWaveFormat, lSamples);

    /* Add extra space to compensate for code generation bug which
        causes reference past end */
    /* don't allocate anything to be zero bytes long */
    lBytes += sizeof(DWORD_PTR);

    if (gpWaveSamples == NULL || glWaveSamplesValid == 0L)
    {
        if (gpWaveSamples != NULL)
        {   DPF(TEXT("Freeing %x\n"),gpWaveSamples);
            GlobalFreePtr(gpWaveSamples);
        }
        GlobalMemoryStatus(&ms);
        lBytesReasonable = ms.dwAvailPhys;  // could multiply by a fudge factor
        if (lBytesReasonable<1024*1024)
             lBytesReasonable = 1024*1024;

        if (lBytes>lBytesReasonable)
        {
        if (fExact) goto ERROR_OUTOFMEM; // Laurie's first goto in 10 years.

            // dprintf("Reducing buffer from %d to %d\n", lBytes, lBytesReasonable);
            lAllocSamples = wfBytesToSamples(gpWaveFormat,(long)lBytesReasonable);
            lBytes = lBytesReasonable+sizeof(DWORD_PTR);
        }

        /* allocate <lBytes> of memory */

        gpWaveSamples = GlobalAllocPtr(GHND|GMEM_SHARE, lBytes);

        if (gpWaveSamples == NULL)
        {
            DPF(TEXT("wave.c Alloc failed, point A.  Wanted %d\n"), lBytes);
            glWaveSamples = glWaveSamplesValid = 0L;
            glWavePosition = 0L;
            goto ERROR_OUTOFMEM;
        }
        else {
            DPF(TEXT("wave.c Allocated  %d bytes at %x\n"), lBytes, (DWORD_PTR)gpWaveSamples );
        }

        glWaveSamples = (long)lAllocSamples;
    }
    else
    {
        HPBYTE  pch;

        GlobalMemoryStatus(&ms);
        lBytesReasonable = ms.dwAvailPhys;
        
        if (lBytesReasonable<1024*1024) lBytesReasonable = 1024*1024;

        if (lBytes > lBytesReasonable+wfSamplesToBytes(gpWaveFormat,glWaveSamplesValid))
        {
        if (fExact) goto ERROR_OUTOFMEM; // Laurie's second goto in 10 years.

            lBytesReasonable += wfSamplesToBytes(gpWaveFormat,glWaveSamplesValid);
            lAllocSamples = wfBytesToSamples(gpWaveFormat,(long)lBytesReasonable);
            lBytes = lBytesReasonable+4;
        }

        DPF(TEXT("wave.c ReAllocating  %d bytes at %x\n"), lBytes, (DWORD_PTR)gpWaveSamples );

        pch = GlobalReAllocPtr(gpWaveSamples, lBytes, GHND|GMEM_SHARE);

        if (pch == NULL)
        {
            DPF(TEXT("wave.c Realloc failed.  Wanted %d\n"), lBytes);
            goto ERROR_OUTOFMEM;
        }
        else{ DPF(TEXT("wave.c Reallocated %d at %x\n"), lBytes,(DWORD_PTR)pch);
        }
        
        gpWaveSamples = pch;
        glWaveSamples = (long)lAllocSamples;
    }

    /* make sure <glWaveSamplesValid> and <glWavePosition> don't point
     * to places they shouldn't
     */
    if (glWaveSamplesValid > glWaveSamples)
        glWaveSamplesValid = glWaveSamples;
    if (glWavePosition > glWaveSamplesValid)
        glWavePosition = glWaveSamplesValid;

    dbgShowMemUse();

    return TRUE;

ERROR_OUTOFMEM:
    if (fErrorBox) {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
            IDS_APPTITLE, IDS_OUTOFMEM);
    }
    dbgShowMemUse();
    return FALSE;
} // AllocWaveBuffer


/* CreateDefaultWaveFormat(lpWaveFormat)
 *
 * Fill in <*lpWaveFormat> with the "best" format that can be used
 * for recording.  If recording does not seem to be available, return
 * FALSE and set to a default "least common denominator"
 * wave audio format.
 *
 */
WORD wFormats[] =
    {
        FMT_16BIT | FMT_22k | FMT_MONO,  /* Best: 16-bit 22KHz */
        FMT_16BIT | FMT_11k | FMT_MONO,  /* Best: 16-bit 11KHz */
        FMT_8BIT  | FMT_22k | FMT_MONO,  /* Next: 8-bit 22KHz  */
        FMT_8BIT  | FMT_11k | FMT_MONO   /* Last: 8-bit 11KHz  */
    };
#define NUM_FORMATS (sizeof(wFormats)/sizeof(wFormats[0]))

/*
 * This relies on the behaviour of WAVE_MAPPER to supply a correct
 * header.
 *
 *---------------------------------------------------------------
 * 6/16/93          TimHa
 * Change back to getting a 'best' default format from the
 * above array of formats.  This is only used if ACM 2.0 isn't
 * available to do a format for us.
 *---------------------------------------------------------------
 *
 * */
BOOL PASCAL
CreateDefaultWaveFormat(LPWAVEFORMATEX lpwf, UINT uDeviceID)
{
    int i;

    lpwf->wFormatTag = WAVE_FORMAT_PCM;

    for (i = 0; i < NUM_FORMATS; i++) {
        if (CreateWaveFormat(lpwf, wFormats[i], (UINT)WAVE_MAPPER)){
            return TRUE;
        }

    }
    //
    // Couldn't find anything: leave worst format and return.
    //
    return FALSE;
} /* CreateDefaultWaveFormat */

/* BOOL PASCAL CreateWaveFormat(LPWAVEFORMATEX lpwf, WORD fmt, UINT uDeviceID)
 *
 * */
BOOL PASCAL
CreateWaveFormat(LPWAVEFORMATEX lpwf, WORD fmt, UINT uDeviceID)
{
    if (fmt == FMT_DEFAULT)
        return CreateDefaultWaveFormat(lpwf, uDeviceID);

    lpwf->wFormatTag      = WAVE_FORMAT_PCM;
    lpwf->nSamplesPerSec  = (fmt & FMT_RATE) * 11025;
    lpwf->nChannels       = (WORD)(fmt & FMT_STEREO) ? 2 : 1;
    lpwf->wBitsPerSample  = (WORD)(fmt & FMT_16BIT) ? 16 : 8;
    lpwf->nBlockAlign     = (WORD)lpwf->nChannels * ((lpwf->wBitsPerSample + 7) / 8);
    lpwf->nAvgBytesPerSec = lpwf->nSamplesPerSec * lpwf->nBlockAlign;

    return waveInOpen(NULL
                      , uDeviceID
                      , (LPWAVEFORMATEX)lpwf
                      , 0L
                      , 0L
                      , WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC) == 0;
    
} /* CreateWaveFormat */


/*
 * */
BOOL NEAR PASCAL FreeWaveHeaders(void)
{
    UINT    i;

    DPF(TEXT("FreeWaveHeaders!\n"));

    // #pragma message("----FreeWaveHeaders: should probably call on exit!")

    //
    //  free any previously allocated wave headers..
    //
    for (i = 0; i < MAX_WAVEHDRS; i++)
    {
        if (gapWaveHdr[i])
        {
            GlobalFreePtr(gapWaveHdr[i]);
            gapWaveHdr[i] = NULL;
        }
    }

    return (TRUE);
} /* FreeWaveHeaders() */


/*
 * */
BOOL NEAR PASCAL
AllocWaveHeaders(
    WAVEFORMATEX *  pwfx,
    UINT            uWaveHdrs)
{
    UINT        i;
    LPWAVEHDR   pwh;

    FreeWaveHeaders();

    //
    //  allocate all of the wave headers/buffers for streaming
    //
    for (i = 0; i < uWaveHdrs; i++)
    {
        pwh = GlobalAllocPtr(GMEM_MOVEABLE, sizeof(WAVEHDR));
        
        if (pwh == NULL)
            goto AWH_ERROR_NOMEM;

        pwh->lpData         = NULL;
        pwh->dwBufferLength = 0L;
        pwh->dwFlags        = 0L;
        pwh->dwLoops        = 0L;

        gapWaveHdr[i] = pwh;
    }

    return (TRUE);

AWH_ERROR_NOMEM:
    FreeWaveHeaders();
    return (FALSE);
} /* AllocWaveHeaders() */


/* WriteWaveHeader

   Writes wave header - also actually starts the wave I/O
   by WaveOutWrite or WaveInAddBuffer.
*/
UINT NEAR PASCAL WriteWaveHeader(LPWAVEHDR pwh,BOOL fJustUnprepare)
{
    UINT        uErr;
    BOOL        fInput;
    DWORD       dwLengthToWrite;
#if 1
    //see next "mmsystem workaround"
    BOOL        fFudge;
#endif
    fInput = (ghWaveIn != NULL);

    if (pwh->dwFlags & WHDR_PREPARED)
    {
        if (fInput)
            uErr = waveInUnprepareHeader(ghWaveIn, pwh, sizeof(WAVEHDR));
        else
            uErr = waveOutUnprepareHeader(ghWaveOut, pwh, sizeof(WAVEHDR));

        //
        //  because Creative Labs thinks they know what they are doing when
        //  they don't, we cannot rely on the unprepare succeeding like it
        //  should after they have posted the header back to us... they fail
        //  the waveInUnprepareHeader with WAVERR_STILLPLAYING (21h) even
        //  though the header has been posted back with the WHDR_DONE bit
        //  set!!
        //
        //  absolutely smurphingly brilliant! and i thought Media Vision was
        //  the leader in this type of 'Creativity'!! they have competition!
        //
#if 0
        if (uErr)
        {
            if (fInput && (uErr == WAVERR_STILLPLAYING) && (pwh->dwFlags & WHDR_DONE))
            {
                DPF(TEXT("----PERFORMING STUPID HACK FOR CREATIVE LABS' SBPRO----\n"));
                pwh->dwFlags &= ~WHDR_PREPARED;
            }
            else
            {
                DPF(TEXT("----waveXXUnprepareHeader FAILED! [%.04Xh]\n"), uErr);
                return (uErr);
            }
        }
#else
        if (uErr)
        {
            DPF(TEXT("----waveXXUnprepareHeader FAILED! [%.04Xh]\n"), uErr);
            return (uErr);
        }
#endif
    }

    if (fJustUnprepare)
        return (0);

    dwLengthToWrite = gdwTotalLengthBytes - gdwCurrentBufferPos;

    if (gdwBytesPerBuffer < dwLengthToWrite)
        dwLengthToWrite = gdwBytesPerBuffer;

    //
    //  if there is nothing to write (either no more data for output or no
    //  more room for input), then return -1 which signifies this case...
    //
    if (dwLengthToWrite == 0L)
    {
        DPF(TEXT("WriteWaveHeader: no more data!\n"));
        return (UINT)-1;
    }

#if 1
//"mmsystem workaround"  Apparently waveXXXPrepareHeader can't pagelock 1 byte, so make us 2
    fFudge = (dwLengthToWrite==1);
    pwh->dwBufferLength = dwLengthToWrite + ((fFudge)?1L:0L);
#else
    pwh->dwBufferLength = dwLengthToWrite;
#endif

    pwh->lpData         = (LPSTR)&gpWaveSamples[gdwCurrentBufferPos];
    pwh->dwBytesRecorded= 0L;
    pwh->dwFlags        = 0L;
    pwh->dwLoops        = 0L;
    pwh->lpNext         = NULL;
    pwh->reserved       = 0L;

    if (fInput)
        uErr = waveInPrepareHeader(ghWaveIn, pwh, sizeof(WAVEHDR));
    else
        uErr = waveOutPrepareHeader(ghWaveOut, pwh, sizeof(WAVEHDR));

    if (uErr)
    {
        DPF(TEXT("waveXXPrepareHeader FAILED! [%.04Xh]\n"), uErr);
        return uErr;
    }

#if 1
//"mmsystem workaround". Unfudge
    if (fFudge)
        pwh->dwBufferLength -= 1;
#endif

    if (fInput)
        uErr = waveInAddBuffer(ghWaveIn, pwh, sizeof(WAVEHDR));
    else
        uErr = waveOutWrite(ghWaveOut, pwh, sizeof(WAVEHDR));

    if (uErr)
    {
        DPF(TEXT("waveXXAddBuffer FAILED! [%.04Xh]\n"), uErr);

        if (fInput)
            waveInUnprepareHeader(ghWaveIn, pwh, sizeof(WAVEHDR));
        else
            waveOutUnprepareHeader(ghWaveOut, pwh, sizeof(WAVEHDR));

        return uErr;
    }

    gdwCurrentBufferPos += dwLengthToWrite;

    return 0;
} /* WriteWaveHeader() */


/* if fFineControl is set then reset the position and clear the flag */
void FAR PASCAL SnapBack(void)
{
    if (fFineControl)
    {
        glWavePosition = glSnapBackTo;
        UpdateDisplay(TRUE);
        fFineControl = FALSE;
    }
} /* SnapBack */


/* fOK = NewWave()
 *
 * Destroy the current waveform, and create a new empty one.
 *
 * On success, return TRUE.  On failure, display an error message
 * and return FALSE.
 */
BOOL FAR PASCAL
NewWave(WORD fmt, BOOL fNewDlg)
{
    BOOL    fOK = TRUE;
    
    DPF(TEXT("NewWave called: %s\n"),(gfEmbeddedObject?TEXT("Embedded"):TEXT("App")));
#ifndef CHICAGO
    //
    // bring up the dialog to get a new waveformat IFF this was
    // selected from the File menu
    //
    if (fNewDlg)
    {
        PWAVEFORMATEX pWaveFormat;
        UINT cbWaveFormat;

        if (NewSndDialog(ghInst, ghwndApp, gpWaveFormat, gcbWaveFormat, &pWaveFormat, &cbWaveFormat))
        {
            /* User made a selection */
            /* destroy the current document */
            DestroyWave();
            gpWaveFormat = pWaveFormat;
            gcbWaveFormat = cbWaveFormat;
            gidDefaultButton = ID_RECORDBTN;
        }
        else
        {
            /* user cancelled or out of mem */
            /* should probably handle outofmem differently */
            goto RETURN_ERROR;
        }
    }
    else
#endif        
    {

        DWORD           cbwfx;
        LPWAVEFORMATEX  pwfx;


        if (!SoundRec_GetDefaultFormat(&pwfx, &cbwfx))
        {
            cbwfx = sizeof(WAVEFORMATEX);
            pwfx  = (WAVEFORMATEX *)GlobalAllocPtr(GHND, sizeof(WAVEFORMATEX));

            if (pwfx == NULL)
                goto ERROR_OUTOFMEM;

            CreateWaveFormat(pwfx,fmt,(UINT)WAVE_MAPPER);
        }
        
        // destroy the current document
        DestroyWave();

        gcbWaveFormat = cbwfx;
        gpWaveFormat = pwfx;
    }

    if (gpWaveFormat == NULL)
        goto ERROR_OUTOFMEM;

    /* allocate an empty wave buffer */

    if (!AllocWaveBuffer(0L, TRUE, FALSE))
    {
        GlobalFreePtr(gpWaveFormat);
        gpWaveFormat = NULL;
        gcbWaveFormat = 0;
        goto RETURN_ERROR;
    }

    if (!AllocWaveHeaders(gpWaveFormat, guWaveHdrs))
        goto ERROR_OUTOFMEM;

    UpdateDisplay(TRUE);

    goto RETURN_SUCCESS;

ERROR_OUTOFMEM:
    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                IDS_APPTITLE, IDS_OUTOFMEM);
    goto RETURN_ERROR;

RETURN_ERROR:
    fOK = FALSE;

RETURN_SUCCESS:

#if 1
//bombay bug #1609  HackFix We're not getting focus on the right guy!
//                  UpdateDisplay should have done this

    if (IsWindowVisible(ghwndApp))
    {
        if (IsWindowEnabled(ghwndRecord))
            SetDlgFocus(ghwndRecord);
        else if (IsWindowEnabled(ghwndPlay))
            SetDlgFocus(ghwndPlay);
        else if (IsWindowEnabled(ghwndScroll))
            SetDlgFocus(ghwndScroll);
    }
#endif

    return fOK;
} // NewWave



/* fOK = DestroyWave()
 *
 * Destroy the current wave.  Do not access <gpWaveSamples> after this.
 *
 * On success, return TRUE.  On failure, display an error message
 * and return FALSE.
 */
BOOL FAR PASCAL
DestroyWave(void)
{
    DPF(TEXT("DestroyWave called\n"));

    if ((ghWaveIn != NULL) || (ghWaveOut != NULL))
        StopWave();
    if (gpWaveSamples != NULL)
    {
        DPF(TEXT("Freeing %x\n"),gpWaveSamples);
        GlobalFreePtr(gpWaveSamples);
    }
    if (gpWaveFormat != NULL)
        GlobalFreePtr(gpWaveFormat);

    if (gpszInfo != NULL)
        GlobalFreePtr(gpszInfo);

    //
    //      DON'T free wave headers!
    //
    ////////FreeWaveHeaders();

    glWaveSamples = 0L;
    glWaveSamplesValid = 0L;
    glWavePosition = 0L;
    gcbWaveFormat = 0; 

    gpWaveFormat = NULL;
    gpWaveSamples = NULL;
    gpszInfo = NULL;

#ifdef NEWPAUSE

    //***extra cautionary cleanup
    if (ghPausedWave && gfPaused)
    {
        if (gfWasPlaying)
            waveOutClose((HWAVEOUT)ghPausedWave);
        else
        if (gfWasRecording)
            waveInClose((HWAVEIN)ghPausedWave);
    }
    gfPaused = FALSE;
    ghPausedWave = NULL;

#endif

    return TRUE;
} /* DestroyWave */



UINT NEAR PASCAL SRecWaveOpen(LPHWAVE lphwave, LPWAVEFORMATEX lpwfx, BOOL fInput)
{
    UINT    uErr;

    if (!lphwave || !lpwfx)
        return (1);

#ifdef NEWPAUSE
    if (gfPaused && ghPausedWave)
    {
        /* we are in a paused state.  Restore the handle. */
        *lphwave = ghPausedWave;
        gfPaused = FALSE;
        ghPausedWave = NULL;
        return MMSYSERR_NOERROR;
    }
#endif

    *lphwave = NULL;

    //
    //  first open the wave device DISALLOWING sync drivers (sync drivers
    //  do not work with a streaming buffer scheme; which is our preferred
    //  mode of operation)
    //
    //  if we cannot open a non-sync driver, then we will attempt for
    //  a sync driver and disable the streaming buffer scheme..
    //

#if 0
    gfSyncDriver = FALSE;
#else
    //
    //  if the control key is down, then FORCE use of non-streaming scheme.
    //  all that this requires is that we set the gfSyncDriver flag
    //
    if (guWaveHdrs < 2)
        gfSyncDriver = TRUE;
    else
    {
#if 0

//********* Curtis, I don't know gfSyncDriver is always getting set now!
//********* please find out!  It probably has something to do with the
//********* hook for f1 help

        if (GetAsyncKeyState(VK_CONTROL) & 0x8000)
            gfSyncDriver = TRUE;
        else
            gfSyncDriver = FALSE;
#else
        gfSyncDriver = FALSE;
#endif

    }
#endif

    if (fInput)
    {
        uErr = waveInOpen((LPHWAVEIN)lphwave
                        , (UINT)WAVE_MAPPER
                        , (LPWAVEFORMATEX)lpwfx
                        , (DWORD_PTR)ghwndApp
                        , 0L
                        , CALLBACK_WINDOW);
        if (uErr)
        {

/**** bug #967.  SPEAKER.DRV does not correctly return WAVERR_SYNC, but it
 ****            does return in error */
//            if (uErr == WAVERR_SYNC)
//            {

            uErr = waveInOpen((LPHWAVEIN)lphwave
                              , (UINT)WAVE_MAPPER
                              , (LPWAVEFORMATEX)lpwfx
                              , (DWORD_PTR)ghwndApp
                              , 0L
                              , CALLBACK_WINDOW|WAVE_ALLOWSYNC);
            if (uErr == MMSYSERR_NOERROR)
            {
                gfSyncDriver = TRUE;
            }

//            }

        }
    }
    else
    {
        uErr = waveOutOpen((LPHWAVEOUT)lphwave
                           , (UINT)WAVE_MAPPER
                           , (LPWAVEFORMATEX)lpwfx
                           , (DWORD_PTR)ghwndApp
                           , 0L
                           , CALLBACK_WINDOW);
        if (uErr)
        {

/**** bug #967.  SPEAKER.DRV does not correctly return WAVERR_SYNC, but it
 ****            does return in error */
////////////if (uErr == WAVERR_SYNC)
////////////{

                uErr = waveOutOpen((LPHWAVEOUT)lphwave
                                   , (UINT)WAVE_MAPPER
                                   , (LPWAVEFORMATEX)lpwfx
                                   , (DWORD_PTR)ghwndApp
                                   , 0L
                                   , CALLBACK_WINDOW|WAVE_ALLOWSYNC);
                if (uErr == MMSYSERR_NOERROR)
                {
                    gfSyncDriver = TRUE;
                }

////////////}

        }
    }
    return (uErr);
} /* SRecWaveOpen() */


/* SRecPlayBegin
**
** Sets
**     gdwCurrentBufferPos
**     gdwBytesPerBuffer
**     gfTimerStarted
**     fStopping
**     gfStoppingHard
**     grgbStatusColor
**     fCanPlay
**     glWavePosition
**     * gapWaveHdr[0]
** Calls
**     StopWave
**     UpdateDisplay
**     WriteWaveHeader
*/
BOOL NEAR PASCAL SRecPlayBegin(BOOL fSyncDriver)
{
    BOOL    fOK = TRUE;
    WORD    wIndex;
    UINT    uErr;

    //
    //
    //
    //
    gdwCurrentBufferPos = wfSamplesToBytes(gpWaveFormat, glWavePosition);

    if (fSyncDriver)
    {
        gdwBytesPerBuffer = gdwTotalLengthBytes - gdwCurrentBufferPos;

        uErr = WriteWaveHeader(gapWaveHdr[0],FALSE);

        if (uErr)
        {
            if (uErr == MMSYSERR_NOMEM)
            {
                // Prepare failed
                goto PB_ERROR_OUTOFMEM;
            }

            goto PB_ERROR_WAVEOUTWRITE;
        }
    }
    else
    {
        gdwBytesPerBuffer = wfTimeToSamples(gpWaveFormat, gwMSecsPerBuffer);
        gdwBytesPerBuffer = wfSamplesToBytes(gpWaveFormat, gdwBytesPerBuffer);

#if defined(_WIN32)
        StartPreTouchThread( &(gpWaveSamples[gdwCurrentBufferPos])
                           , gdwTotalLengthBytes - gdwCurrentBufferPos
                           );
#endif //_WIN32

        //
        // First wave header to be played is zero
        //
        fStopping = FALSE;

        waveOutPause(ghWaveOut);

        for (wIndex=0; wIndex < guWaveHdrs; wIndex++)
        {
            uErr = WriteWaveHeader(gapWaveHdr[wIndex],FALSE);
            if (uErr)
            {
                //
                // WriteWaveHeader will return -1 if there is no
                // more data to write. This is not an error!
                //
                // It indicates that the previous block was the
                // last one queued. Flag that we are doing cleanup
                // (just waiting for headers to complete) and save
                // which header is the last one to wait for.
                //
                if (uErr == (UINT)-1)
                {
                    if (wIndex == 0)
                    {
                        StopWave();
                        goto PB_RETURN_SUCCESS;
                    }

                    break;
                }

                //
                // If we run out of memory, but have already written
                // at least 2 wave headers, we can still keep going.
                // If we've written 0 or 1, we can't stream and will
                // stop.
                //
                if (uErr == MMSYSERR_NOMEM)
                {
                    if (wIndex > 1)
                        break;

                    // Prepare failed
                    StopWave();
                    goto PB_ERROR_OUTOFMEM;
                }

                StopWave();
                goto PB_ERROR_WAVEOUTWRITE;
            }
        }

        waveOutRestart(ghWaveOut);
    }

    /* update the display, including the status string */
    UpdateDisplay(TRUE);

    if (fSyncDriver)
    {
        /* do display updates */
        gfTimerStarted = (BOOL)SetTimer(ghwndApp, 1, TIMER_MSEC, NULL);
    }

    /* if user stops, focus will go back to "Play" button */
    gidDefaultButton = ID_PLAYBTN;

    fStopping = FALSE;
    goto PB_RETURN_SUCCESS;


PB_ERROR_WAVEOUTWRITE:

    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
            IDS_APPTITLE, IDS_CANTOPENWAVEOUT);
    goto PB_RETURN_ERROR;

PB_ERROR_OUTOFMEM :
    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
            IDS_APPTITLE, IDS_OUTOFMEM);
////goto PB_RETURN_ERROR;

PB_RETURN_ERROR:

    fOK = FALSE;

PB_RETURN_SUCCESS:

    return fOK;
} /* SRecPlayBegin() */



/* fOK = PlayWave()
 *
 * Start playing from the current position.
 *
 * On success, return TRUE.  On failure, display an error message
 * and return FALSE.
 */
BOOL FAR PASCAL
PlayWave(void)
{
    BOOL            fOK = TRUE;             // does this function succeed?
    UINT            uErr;

    DPF(TEXT("PlayWave called\n"));


    /* we are currently playing....*/
    if (ghWaveOut != NULL)
        return TRUE;

#if 1

//       Still trying to get this right with some bogus estimations
//       We shouldn't have to do this correction, but our conversions
//       are never 1:1

    // try to align us.
    glWavePosition = wfSamplesToSamples(gpWaveFormat,glWavePosition);
    {
        long lBlockInSamples;

        // if the distance between the glWaveSamplesValid and glWavePosition
        // is less than a "block"

        lBlockInSamples = wfBytesToSamples(gpWaveFormat,
                                           gpWaveFormat->nBlockAlign);

        if (glWaveSamplesValid - glWavePosition < lBlockInSamples)
            glWavePosition -= lBlockInSamples;
        if (glWavePosition < 0L)
            glWavePosition = 0L;
    }
#endif

    //
    //  refuse to play a zero length wave file.
    //
    if (glWaveSamplesValid == glWavePosition)
        goto RETURN_ERROR;

    /* stop playing or recording */
    StopWave();

    gdwTotalLengthBytes = wfSamplesToBytes(gpWaveFormat, glWaveSamples);

    /* open the wave output device */
    uErr = SRecWaveOpen((LPHWAVE)&ghWaveOut, gpWaveFormat, FALSE);
    if (uErr)
    {
        ghWaveOut = NULL;

        /* cannot open the waveform output device -- if the problem
        ** is that <gWaveFormat> is not supported, tell the user that
        ** 
        ** If the wave format is bad, then the play button is liable
        ** to be grayed, and the user is not going to be able to ask
        ** it to try to play, so we don't get here, so he doesn't get
        ** a decent diagnostic!!!
        */
        if (uErr == WAVERR_BADFORMAT)
        {
            ErrorResBox(ghwndApp, ghInst,
                        MB_ICONEXCLAMATION | MB_OK, IDS_APPTITLE,
                        IDS_BADOUTPUTFORMAT);
            goto RETURN_ERROR;
        }
        else
        {
            /* unknown error */
            goto ERROR_WAVEOUTOPEN;
        }
    }

    if (ghWaveOut == NULL)
        goto ERROR_WAVEOUTOPEN;

    /* start waveform output */

    // if fFineControl is still set then this is a pause as it has never
    // been properly stopped.  This means that we should keep remembering
    // the old position and stay in fine control mode, (else set new position)
    if (!fFineControl) {
        glSnapBackTo = glWavePosition;
        fFineControl = (0 > GetKeyState(VK_SHIFT));
    }

    glStartPlayRecPos = glWavePosition;

    //
    //  now kickstart the output...
    //

    if (SRecPlayBegin(gfSyncDriver) == FALSE)
    {
        waveOutClose(ghWaveOut);
        ghWaveOut = NULL;
        ghPausedWave = NULL;
        gfPaused = FALSE;
        goto RETURN_ERROR;
    }
    goto RETURN_SUCCESS;

ERROR_WAVEOUTOPEN:
    if (!waveInGetNumDevs() && !waveOutGetNumDevs()) {
        /* No recording or playback devices */
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                    IDS_APPTITLE, IDS_NOWAVEFORMS);
    } else {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                    IDS_APPTITLE, IDS_CANTOPENWAVEOUT);
    }
    //goto RETURN_ERROR;

RETURN_ERROR:
    UpdateDisplay(TRUE);

    /* fix bug 4454 (WinWorks won't close) --EricLe */
    if (!IsWindowVisible(ghwndApp))
        PostMessage(ghwndApp, WM_CLOSE, 0, 0L);

    fOK = FALSE;

RETURN_SUCCESS:

    return fOK;
} // PlayWave



BOOL NEAR PASCAL SRecRecordBegin(BOOL fSyncDriver)
{
    UINT            uErr;
    long            lSamples;
    long            lOneSec;
    HCURSOR         hcurSave;
    DWORD           dwBytesAvailable;
    WORD            w;

    /* ok we go the wave device now allocate some memory to record into.
     * try to get at most 60sec from the current position.
     */

    lSamples = glWavePosition + wfTimeToSamples(gpWaveFormat, gdwBufferDeltaMSecs);
    lOneSec  = wfTimeToSamples(gpWaveFormat, 1000);

    hcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT));

    //
    //  set the current buffer position (in BYTES) to the current position
    //  of the thumb (in SAMPLES)...
    //
    gdwCurrentBufferPos = wfSamplesToBytes(gpWaveFormat, glWavePosition);

    //
    //  compute the the size of each buffer for the async case only
    //
    if (!fSyncDriver)
    {
        gdwBytesPerBuffer = wfTimeToSamples(gpWaveFormat, gwMSecsPerBuffer);
        gdwBytesPerBuffer = wfSamplesToBytes(gpWaveFormat, gdwBytesPerBuffer);
    }

    for (;;)
    {
        DPF(TEXT("RecordWave trying %ld samples %ld.%03ldsec\n"), lSamples,  wfSamplesToTime(gpWaveFormat, lSamples)/1000, wfSamplesToTime(gpWaveFormat, lSamples) % 1000);

        if (lSamples < glWaveSamplesValid)
            lSamples = glWaveSamplesValid;

        if (AllocWaveBuffer(lSamples, FALSE, FALSE))
        {
            dwBytesAvailable    = wfSamplesToBytes(gpWaveFormat, glWaveSamples - glWavePosition);
            gdwTotalLengthBytes = dwBytesAvailable + gdwCurrentBufferPos;

            if (fSyncDriver)
            {
                //
                //  for the sync driver case, there is only one buffer--so
                //  set the size of our 'buffer' to be the total size...
                //
                gdwBytesPerBuffer = dwBytesAvailable;

                //
                //  try to prepare and add the complete buffer--if this fails,
                //  then we will try a smaller buffer..
                //
                uErr = WriteWaveHeader(gapWaveHdr[0], FALSE);
                if (uErr == 0)
                    break;
            }
            else
            {
                //
                //  Make sure we can prepare enough wave headers to stream
                //  even if realloc succeeded
                //
                for (w = 0; w < guWaveHdrs; w++)
                {
                    uErr = WriteWaveHeader(gapWaveHdr[w], FALSE);
                    if (uErr)
                    {
                        //
                        //  WriteWaveHeader will return -1 if there is no
                        //  more data to write. This is not an error!
                        //
                        //  It indicates that the previous block was the
                        //  last one queued. Flag that we are doing cleanup
                        //  (just waiting for headers to complete) and save
                        //  which header is the last one to wait for.
                        //
                        if (uErr == (UINT)-1)
                        {
                            if (w == 0)
                            {
                                StopWave();
                                return (TRUE);
                            }

                            break;
                        }

                        //
                        //  If we run out of memory, but have already written
                        //  at least 2 wave headers, we can still keep going.
                        //  If we've written 0 or 1, we can't stream and will
                        //  stop.
                        //
                        if (uErr == MMSYSERR_NOMEM)
                        {
                            if (w > 1)
                                break;

                            StopWave();
                            goto BEGINREC_ERROR_OUTOFMEM;
                        }

                        goto BEGINREC_ERROR_WAVEINSTART;
                    }
                }

                //
                //  we wrote enough (we think), so break out of the realloc
                //  loop
                //
                break;
            }
        }

        //
        // we can't get the memory we want, so try 25% less.
        //
        if (lSamples <= glWaveSamplesValid ||
            lSamples < glWavePosition + lOneSec)
        {
            SetCursor(hcurSave);
            goto BEGINREC_ERROR_OUTOFMEM;
        }

        lSamples = glWavePosition + ((lSamples-glWavePosition)*75)/100;
    }

    SetCursor(hcurSave);

    glStartPlayRecPos = glWavePosition;

    BeginWaveEdit();

    if (waveInStart(ghWaveIn) != 0)
        goto BEGINREC_ERROR_WAVEINSTART;

    /* update the display, including the status string */
    UpdateDisplay(TRUE);

    //
    //  only start timer in the sync driver case--async case we use the
    //  buffers being posted back as our display update timer...
    //
    if (fSyncDriver)
    {
        /* do display updates */
        gfTimerStarted = (BOOL)SetTimer(ghwndApp, 1, TIMER_MSEC, NULL);
    }

    /* if user stops, focus will go back to "Record" button */
    gidDefaultButton = ID_RECORDBTN;

    fStopping = FALSE;

    return TRUE;

BEGINREC_ERROR_OUTOFMEM:
    ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
            IDS_APPTITLE, IDS_OUTOFMEM);
    goto BEGINREC_ERROR;


BEGINREC_ERROR_WAVEINSTART:
    /* This is necessary to un-add the buffer */
    waveInReset(ghWaveIn);

    EndWaveEdit(FALSE);

    /* The wave device will get closed in WaveInData() */
//    goto BEGINREC_ERROR;

BEGINREC_ERROR:

    return FALSE;

} /* SRecRecordBegin() */




/* fOK = RecordWave()
 *
 * Start recording at the current position.
 *
 * On success, return TRUE.  On failure, display an error message
 * and return FALSE.
 */
BOOL FAR PASCAL
RecordWave(void)
{
    UINT uErr;

    /* stop playing or recording */
    StopWave();

    glWavePosition = wfSamplesToSamples(gpWaveFormat, glWavePosition);

    /* open the wave input device */
    uErr = SRecWaveOpen((LPHWAVE)&ghWaveIn, gpWaveFormat, TRUE);
    if (uErr)
    {

        /* cannot open the waveform input device -- if the problem
         * is that <gWaveFormat> is not supported, advise the user to
         * do File/New to record; if the problem is that recording is
         * not supported even at 11KHz, tell the user
         */
        if (uErr == WAVERR_BADFORMAT)
        {
            WAVEFORMATEX    wf;

            /* is 11KHz mono recording supported? */
            if (!CreateWaveFormat(&wf, FMT_11k|FMT_MONO|FMT_8BIT,
                                  (UINT)WAVE_MAPPER))
            {
                /* even 11KHz mono recording is not supported */
                ErrorResBox(ghwndApp, ghInst,
                            MB_ICONEXCLAMATION | MB_OK, IDS_APPTITLE,
                            IDS_INPUTNOTSUPPORT);
                goto RETURN_ERROR;
            }
            else
            {
                /* 11KHz mono is supported, but the format
                 * of the current file is not supported
                 */
                ErrorResBox(ghwndApp, ghInst,
                            MB_ICONEXCLAMATION | MB_OK, IDS_APPTITLE,
                            IDS_BADINPUTFORMAT);
                goto RETURN_ERROR;
            }
        }
        else
        {
            /* unknown error */
            goto ERROR_WAVEINOPEN;
        }
    }

    if (ghWaveIn == NULL)
        goto ERROR_WAVEINOPEN;

    if (!SRecRecordBegin(gfSyncDriver))
        goto RETURN_ERROR;

    goto RETURN_SUCCESS;

ERROR_WAVEINOPEN:
    if (!waveInGetNumDevs() && !waveOutGetNumDevs()) {
        /* No recording or playback devices */
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                    IDS_APPTITLE, IDS_NOWAVEFORMS);
    } else {
        ErrorResBox(ghwndApp, ghInst, MB_ICONEXCLAMATION | MB_OK,
                    IDS_APPTITLE, IDS_CANTOPENWAVEIN);
    }

    // goto RETURN_ERROR;

RETURN_ERROR:
    if (ghWaveIn)
        waveInClose(ghWaveIn);
    ghWaveIn = NULL;
    ghPausedWave = NULL;

    if (glWaveSamples > glWaveSamplesValid)
    {
        /* reallocate the wave buffer to be small */
        AllocWaveBuffer(glWaveSamplesValid, TRUE, TRUE);
    }

    UpdateDisplay(TRUE);

RETURN_SUCCESS:
    return TRUE;
} /* RecordWave */





/* YieldStop(void)
 *
 *      Yeild for mouse and keyboard messages so that the stop can be
 *      processed.
 */

BOOL NEAR PASCAL YieldStop(void)
{
    BOOL    f;
    MSG         msg;

    f = FALSE;

    // Perhaps someone might deign to write a line or two
    // to explain why this loop is here twice and what it's actually doing?

    while (PeekMessage(&msg, ghwndStop, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE | PM_NOYIELD))
    {
        f = TRUE;
    TranslateMessage(&msg);
    DispatchMessage(&msg);
    }

    while (PeekMessage(&msg, ghwndStop, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE | PM_NOYIELD))
    {
        f = TRUE;
    TranslateMessage(&msg);
    DispatchMessage(&msg);
    }

    return (f);
} /* YieldStop() */


BOOL NEAR PASCAL IsAsyncStop(void)
{
    //
    //  we need to check for the esc key being pressed--BUT, we don't want
    //  to stop unless ONLY the esc key is pressed. so if someone tries to
    //  bring up task man with xxx-esc, it will not stop the playing wave..
    //
    if (GetAsyncKeyState(VK_ESCAPE) & 0x8000)
    {
        if ((GetAsyncKeyState(VK_CONTROL) & 0x8000) ||
            (GetAsyncKeyState(VK_MENU)    & 0x8000) ||
            (GetAsyncKeyState(VK_SHIFT)   & 0x8000))
        {
            return (FALSE);
        }

        //
        //  looks like only the esc key..
        //
        return (TRUE);
    }

    return (FALSE);
} /* IsAsyncStop() */




/* WaveOutDone(hWaveOut, pWaveHdr)
 *
 * Called when wave block with header <pWaveHdr> is finished playing.
 * This function causes playing to end.
 */
void FAR PASCAL
WaveOutDone(
HWAVEOUT        hWaveOut,                       // wave out device
LPWAVEHDR       pWaveHdr)               // wave header
{
    BOOL        f;
    MSG         msg;
    WORD        w;
    BOOL        fStillMoreToGo;
    UINT        u;

////DPF(TEXT("WaveOutDone()\n"));

    //
    //  check for plunger message--if we get this message, then we are done
    //  and need to close the wave device if it is still open...
    //
    if (pWaveHdr == NULL) {

#ifdef NEWPAUSE
        if (!gfPausing) {
            if (ghWaveOut) {
                waveOutClose(ghWaveOut);
                ghWaveOut = NULL;
                ghPausedWave = NULL;
            }
        }
        else
        {
            gfPaused = TRUE;
            ghWaveOut = NULL;
        }
#else
        if (ghWaveOut) {
            waveOutClose(ghWaveOut);
            ghWaveOut = NULL;
        }
#endif
    } else /* pWaveHdr!=NULL */
    if (gfSyncDriver) {
        WriteWaveHeader(pWaveHdr, TRUE);

        //
        //  !! must do this for sync drivers !!
        //
        if (!gfStoppingHard)
            /* I really don't understand the details of this yet.
            ** What you might call the random stab method of programming!
            ** Laurie
            */
            glWavePosition = glWaveSamplesValid;

#ifdef NEWPAUSE
        if (!gfPausing) {
            waveOutClose(ghWaveOut);
            ghWaveOut = NULL;
            ghPausedWave = NULL;
        } else {
            ghWaveOut = NULL;
            gfPaused = TRUE;
        }
#else
        waveOutClose(ghWaveOut);
        ghWaveOut = NULL;
#endif
    } else { /* pWaveHdr!=NULL & !gfSyncDriver */
        if (!fStopping) {
            while (1) {
                glWavePosition += wfBytesToSamples(gpWaveFormat, pWaveHdr->dwBufferLength);

                //
                // Go into cleanup mode (stop writing new data) on any error
                //
                u = WriteWaveHeader(pWaveHdr, FALSE);
                if (u) {
                    if (u == (UINT)-1) {
                        /* pWaveHdr!=NULL & !gfSyncDriver
                           & WriteWaveHeader() returned -1
                        */
                        fStopping = TRUE;

                        //
                        //  we cannot assume that the wave position is going
                        //  to end up exactly at the end with compressed data
                        //  because of this, we cannot do this postion compare
                        //  to see if we are 'completely' done (all headers
                        //  posted back, etc
                        //
                        //  so we jump to a piece of code that searches for
                        //  any buffers that are still outstanding...
                        //
#if 0
                        if (glWavePosition >= glWaveSamplesValid)
                        {
                            waveOutClose(ghWaveOut);
                            ghWaveOut = NULL;
                        }
                        break;
#else
                        fStillMoreToGo = FALSE;
                        goto KLUDGE_FOR_NOELS_BUG;
#endif
                    }

                    DPF(TEXT("WaveOutDone: CRITICAL ERROR ON WRITING BUFFER [%.04Xh]\n"), u);
                    StopWave();
                } else {
                    if (IsAsyncStop()) {
                        StopWave();
                        return;
                    }
                    if (YieldStop()) {
                        return;
                    }
                }

                f = PeekMessage(&msg, ghwndApp, MM_WOM_DONE, MM_WOM_DONE,
                                    PM_REMOVE | PM_NOYIELD);
                if (!f)
                    break;

                //
                //  don't let plunger msg mess us up!
                //
                if (msg.lParam == 0L)
                    break;

                pWaveHdr = (LPWAVEHDR)msg.lParam;
            }
        } else {
            fStillMoreToGo = FALSE;

            if (gfStoppingHard) {
                while (1) {
                    DPF(TEXT("HARDSTOP PLAY: another one bites the dust!\n"));

                    WriteWaveHeader(pWaveHdr, TRUE);

                    f = PeekMessage(&msg, ghwndApp, MM_WOM_DONE, MM_WOM_DONE,
                                        PM_REMOVE | PM_NOYIELD);

                    if (!f)
                        break;

                    //
                    //  don't let plunger msg mess us up!
                    //
                    if (msg.lParam == 0L)
                        break;

                    pWaveHdr = (LPWAVEHDR)msg.lParam;
                }
            } else {
                glWavePosition += wfBytesToSamples(gpWaveFormat, pWaveHdr->dwBufferLength);

                WriteWaveHeader(pWaveHdr, TRUE);

KLUDGE_FOR_NOELS_BUG:
                for (w = 0; w < guWaveHdrs; w++) {
                    if (gapWaveHdr[w]->dwFlags & WHDR_PREPARED) {
                        DPF(TEXT("PLAY: still more headers outstanding...\n"));
                        fStillMoreToGo = TRUE;
                        break;
                    }
                }
            }

            if (!fStillMoreToGo) {
                //
                //  if the user did not push stop (ie we played through
                //  normally) put the position at the end of the wave.
                //
                //  note we need to do this for sync drivers and compressed
                //  wave's
                //
                if (!gfStoppingHard)
                    glWavePosition = glWaveSamplesValid;
#ifdef NEWPAUSE
                if (!gfPausing) {
                    waveOutClose(ghWaveOut);
                    ghWaveOut = NULL;
                    ghPausedWave = NULL;
                } else {
                    ghWaveOut = NULL;
                    gfPaused = TRUE;
                }
#else
                waveOutClose(ghWaveOut);
                ghWaveOut = NULL;
#endif
                {
                    if (gfCloseAtEndOfPlay)
                        PostMessage(ghwndApp, WM_CLOSE, 0, 0L);
                }
            }
        }
    }

    UpdateDisplay(TRUE);

    //
    //
    //
    //
    if (ghWaveOut == NULL) {
        if (gfTimerStarted) {
            KillTimer(ghwndApp, 1);
            gfTimerStarted = FALSE;
        }
        SnapBack();
    }

    /* If we were showing the window temporarily while playing,
        hide it now. */

    if (ghWaveOut == NULL && gfHideAfterPlaying) {
        DPF(TEXT("Done playing, so hide window.\n"));
        ShowWindow(ghwndApp, SW_HIDE);
    }

    if (ghWaveOut == NULL && !IsWindowVisible(ghwndApp))
        PostMessage(ghwndApp, WM_CLOSE, 0, 0L);

} /* WaveOutDone */



/* WaveInData(hWaveIn, pWaveHdr)
 *
 * Called when wave block with header <pWaveHdr> is finished being
 * recorded.  This function causes recording to end.
 */
void FAR PASCAL
WaveInData(
HWAVEIN         hWaveIn,                // wave in device
LPWAVEHDR       pWaveHdr)               // wave header
{
    BOOL        f;
    MSG         msg;
    WORD        w;
    BOOL        fStillMoreToGo;
    UINT        u;

    //
    //  check for plunger message--if we get this message, then we are done
    //  and need to close the wave device if it is still open...
    //
    if (pWaveHdr == NULL)
    {

//*** BOMBAY:1370 how do we pause without closing the handle?

#ifdef NEWPAUSE

        if (!gfPausing)
        {
            if (ghWaveIn)
            {
                waveInClose(ghWaveIn);
                ghWaveIn = NULL;
                ghPausedWave = NULL;
            }
        }
        else
        {
            gfPaused = TRUE;
            ghWaveIn = NULL;
        }

#else

        if (ghWaveIn)
        {
            waveInClose(ghWaveIn);
            ghWaveIn = NULL;
        }

#endif

    }
    else if (gfSyncDriver)
    {
        glWavePosition = glStartPlayRecPos + wfBytesToSamples(gpWaveFormat,
                                                pWaveHdr->dwBytesRecorded);
        if (glWaveSamplesValid < glWavePosition)
            glWaveSamplesValid = glWavePosition;

        WriteWaveHeader(pWaveHdr, TRUE);

//*** BOMBAY:1370 How do we pause without closing the handle?

#ifdef NEWPAUSE

        if (!gfPausing)
        {
            waveInClose(ghWaveIn);
            ghWaveIn = NULL;
            ghPausedWave = NULL;
        }
        else
        {
            ghWaveIn = NULL;
            gfPaused = TRUE;
        }

#else

        waveInClose(ghWaveIn);
        ghWaveIn = NULL;

#endif

    }
    else
    {
        if (!fStopping)
        {
            while (1)
            {
                glWavePosition += wfBytesToSamples(gpWaveFormat, pWaveHdr->dwBytesRecorded);

                //
                //  go into cleanup mode (stop writing new data) on any error
                //
                u = WriteWaveHeader(pWaveHdr, FALSE);
                if (u)
                {
                    //
                    //  if the return value is '-1' then we are out of data
                    //  space--but probably have headers outstanding so we
                    //  need to wait for all headers to come in before
                    //  shutting down.
                    //
                    if (u == (UINT)-1)
                    {
                        DPF(TEXT("WaveInData: stopping cuz out of data space\n"));
                        fStopping = TRUE;
                        break;
                    }

                    DPF(TEXT("WaveInData: CRITICAL ERROR ON ADDING BUFFER [%.04Xh]\n"), u);
                    StopWave();
                }
                else
                {
                    if (IsAsyncStop())
                    {
                        StopWave();
                        return;
                    }

                    if (YieldStop())
                        return;
                }

                f = PeekMessage(&msg, ghwndApp, MM_WIM_DATA, MM_WIM_DATA,
                                    PM_REMOVE | PM_NOYIELD);
                if (!f)
                    break;

                //
                //  don't let plunger msg mess us up!
                //
                if (msg.lParam == 0L)
                    break;

                pWaveHdr = (LPWAVEHDR)msg.lParam;
            }
        }
        else
        {
            fStillMoreToGo = FALSE;

            if (gfStoppingHard)
            {
                while (1)
                {
                    DPF(TEXT("HARDSTOP RECORD: another one bites the dust!\n"));

                    //
                    //  NOTE! update the position cuz info could have been
                    //  recorded and we have not received its callback yet..
                    //  length will be zero if not used--so this works great
                    //
                    glWavePosition += wfBytesToSamples(gpWaveFormat, pWaveHdr->dwBytesRecorded);
                    WriteWaveHeader(pWaveHdr, TRUE);

                    f = PeekMessage(&msg, ghwndApp, MM_WIM_DATA, MM_WIM_DATA,
                                        PM_REMOVE | PM_NOYIELD);

                    if (!f)
                        break;

                    //
                    //  don't let plunger msg mess us up!
                    //
                    if (msg.lParam == 0L)
                        break;

                    pWaveHdr = (LPWAVEHDR)msg.lParam;
                }
            }
            else
            {
                glWavePosition += wfBytesToSamples(gpWaveFormat, pWaveHdr->dwBytesRecorded);

                //
                //  we're stopping, so get this header unprepared and proceed
                //  to shut this puppy down!
                //
                WriteWaveHeader(pWaveHdr, TRUE);

                for (w = 0; w < guWaveHdrs; w++)
                {
                    if (gapWaveHdr[w]->dwFlags & WHDR_PREPARED)
                    {
                        DPF(TEXT("RECORD: still more headers outstanding...\n"));
                        fStillMoreToGo = TRUE;
                        break;
                    }
                }
            }

            if (!fStillMoreToGo)
            {
//*** BOMBAY:1370 How do we pause without closing the handle?

#ifdef NEWPAUSE
                if (!gfPausing)
                {
                    waveInClose(ghWaveIn);
                    ghWaveIn = NULL;
                    ghPausedWave = NULL;
                }
                else
                {
                    ghWaveIn = NULL;
                    gfPaused = TRUE;
                }
#else
                waveInClose(ghWaveIn);
                ghWaveIn = NULL;
#endif
            }
        }
    }

    //
    //  update <glWaveSamplesValid>
    //
    UpdateDisplay(TRUE);

    //
    //  if we closed the wave device, then we are completely done so do what
    //  we do when we are completely done...
    //
    //  NOTE! we must have already called UpdateDisplay(TRUE) before doing
    //  the following!
    //
    if (ghWaveIn == NULL)
    {
        if (gfTimerStarted)
        {
            KillTimer(ghwndApp, 1);
            gfTimerStarted = FALSE;
        }

        if (glWaveSamples > glWaveSamplesValid)
        {
            /* reallocate the wave buffer to be small */
            AllocWaveBuffer(glWaveSamplesValid, TRUE, TRUE);
        }

        if (pWaveHdr)
        {
            /* ask user to save file if they close it */
            EndWaveEdit(TRUE);
        }
        SnapBack();
    }
} /* WaveInData */

/*
 *  @doc INTERNAL SOUNDREC
 *
 *  @api void FAR PASCAL | FinishPlay | Processes messages until a stop
 *      has flushed all WOM_DONE/WIM_DONE messages out of the message queue.
 *
 *  @rdesc  None.
 */
void FAR PASCAL FinishPlay(
        void)
{
        MSG             msg;
        while (GetMessage(&msg, NULL, 0, 0))
        {
                if (!TranslateAccelerator(ghwndApp, ghAccel, &msg))
                {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                }

#ifdef NEWPAUSE
//        Why is this commented out?
                
//        if (gfPausing && gfPaused)
//            break;
#endif
                if ((ghWaveOut == NULL) && (ghWaveIn == NULL))
                        break;
        }
} /* FinishPlay() */



/* StopWave()
 *
 * Request waveform recording or playback to stop.
 */
void FAR PASCAL
     StopWave(void)
{
    DPF(TEXT("------------StopWave() called!\n"));

    if (ghWaveOut != NULL)
    {
        waveOutReset(ghWaveOut);

        //
        //  post a 'plunger' message that will guarantee that at least one
        //  message goes through so we stop even in bizarre cases...
        //
        if (!gfSyncDriver)
        {
            DPF(TEXT("Post Plunger (WOM)\n"));
            PostMessage(ghwndApp, MM_WOM_DONE, 0, 0L);
        }
        fStopping      = TRUE;  // the pre-touch thread periscopes this flag
        if (ghPreTouch!=NULL){
            WaitForSingleObject(ghPreTouch, INFINITE);
            CloseHandle(ghPreTouch);
            ghPreTouch = NULL;
        }
    }
    else if (ghWaveIn != NULL)
    {
        waveInReset(ghWaveIn);
        //
        //  post a 'plunger' message that will guarantee that at least one
        //  message goes through so we stop even in bizarre cases...
        //
        if (!gfSyncDriver)
        {
            DPF(TEXT("Post Plunger (WIM)\n"));
            PostMessage(ghwndApp, MM_WIM_DATA, 0, 0L);
        }
    }
    else
        return;

    fStopping      = TRUE;
    gfStoppingHard = TRUE;

    /* get messages from event queue and dispatch them,
     * until the MM_WOM_DONE or MM_WIM_DATA message is
     * processed
     */
    FinishPlay();
    gfStoppingHard = FALSE;

// Should StopWave() be calling UpdateDisplay()?
}


#if 0 // this is obsolete
/* EnableButtonRedraw(fAllowRedraw)
 *
 * Allow/disallow the buttons to redraw, depending on <fAllowRedraw>.
 * This is designed to reduce button flicker.
 */
void NEAR PASCAL
     EnableButtonRedraw(BOOL fAllowRedraw)
{
    SendMessage(ghwndPlay, WM_SETREDRAW, fAllowRedraw, 0);
    SendMessage(ghwndStop, WM_SETREDRAW, fAllowRedraw, 0);
    SendMessage(ghwndRecord, WM_SETREDRAW, fAllowRedraw, 0);

    if (fAllowRedraw)
    {
        InvalidateRect(ghwndPlay, NULL, FALSE);
        InvalidateRect(ghwndStop, NULL, FALSE);
        InvalidateRect(ghwndRecord, NULL, FALSE);
    }
}
#endif //0  - obsolete function


/* UpdateDisplay(fStatusChanged)
 *
 * Update the current position and file length on the display.
 * If <fStatusChanged> is TRUE, also update the status line and button
 * enable/disable state.
 *
 * As a side effect, update <glWaveSamplesValid> if <glWavePosition>
 * is greater than <glWaveSamplesValid>.
 */
void FAR PASCAL
     UpdateDisplay(
                    BOOL fStatusChanged)         // update status line
{
   MMTIME          mmtime;
   UINT            uErr;
   int             id;
   TCHAR           ach[120];
   long            lTime;
   long            lLen;
   int             iPos;
   HWND            hwndFocus;
   BOOL            fCanPlay;
   BOOL            fCanRecord;

   hwndFocus = GetFocus();

   if (fStatusChanged)
   {

      // EnableButtonRedraw(FALSE);

      /* update the buttons and the status line */
      if (ghWaveOut != NULL)
      {
         /* we are now playing */
         id = IDS_STATUSPLAYING;
         grgbStatusColor = RGB_PLAY;

         SendMessage(ghwndPlay,BM_SETCHECK,TRUE,0L);

         EnableWindow(ghwndPlay, FALSE);
         EnableWindow(ghwndStop, TRUE);
         EnableWindow(ghwndRecord, FALSE);

         if ((hwndFocus == ghwndPlay) ||  (hwndFocus == ghwndRecord))
            if (IsWindowVisible(ghwndApp))
               SetDlgFocus(ghwndStop);
      }
      else
      if (ghWaveIn != NULL)
      {
         /* we are now recording */
         id = IDS_STATUSRECORDING;
         grgbStatusColor = RGB_RECORD;

         SendMessage(ghwndRecord,BM_SETCHECK,TRUE,0L);
         EnableWindow(ghwndPlay, FALSE);
         EnableWindow(ghwndStop, TRUE);
         EnableWindow(ghwndRecord, FALSE);

         if ((hwndFocus == ghwndPlay) ||  (hwndFocus == ghwndRecord))
            if (IsWindowVisible(ghwndApp))
               SetDlgFocus(ghwndStop);

      }
      else
      {
         fCanPlay = (0 == waveOutOpen(NULL
                                      , (UINT)WAVE_MAPPER
                                      , (LPWAVEFORMATEX)gpWaveFormat
                                      , 0L
                                      , 0L
                                      , WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC));

         fCanRecord = (0 == waveInOpen(NULL
                                       , (UINT)WAVE_MAPPER
                                       , (LPWAVEFORMATEX)gpWaveFormat
                                       , 0L
                                       , 0L
                                       , WAVE_FORMAT_QUERY|WAVE_ALLOWSYNC));

         /* we are now stopped */
         id = IDS_STATUSSTOPPED;
         grgbStatusColor = RGB_STOP;

         //
         //  'un-stick' the buttons if they are currently
         //  stuck
         //
         SendMessage(ghwndPlay,BM_SETCHECK,FALSE,0L);
         SendMessage(ghwndRecord,BM_SETCHECK,FALSE,0L);

         EnableWindow(ghwndPlay, fCanPlay && glWaveSamplesValid > 0);
         EnableWindow(ghwndStop, FALSE);
         EnableWindow(ghwndRecord, fCanRecord);

         if (hwndFocus && !IsWindowEnabled(hwndFocus) &&
            GetActiveWindow() == ghwndApp && IsWindowVisible(ghwndApp))
         {
            if (gidDefaultButton == ID_RECORDBTN && fCanRecord)
               SetDlgFocus(ghwndRecord);
            else if (fCanPlay && glWaveSamplesValid > 0)
               SetDlgFocus(ghwndPlay);
            else
               SetDlgFocus(ghwndScroll);
         }
      }

   }
   // EnableButtonRedraw(TRUE);
   if (ghWaveOut != NULL || ghWaveIn != NULL)
   {
      if (gfTimerStarted)
      {
         glWavePosition = 0L;
         mmtime.wType = TIME_SAMPLES;

         if (ghWaveOut != NULL)
            uErr = waveOutGetPosition(ghWaveOut, &mmtime, sizeof(mmtime));
         else
            uErr = waveInGetPosition(ghWaveIn, &mmtime, sizeof(mmtime));

         if (uErr == MMSYSERR_NOERROR)
         {
            switch (mmtime.wType)
            {
         case TIME_SAMPLES:
            glWavePosition = glStartPlayRecPos + mmtime.u.sample;
            break;

         case TIME_BYTES:
            glWavePosition = glStartPlayRecPos + wfBytesToSamples(gpWaveFormat, mmtime.u.cb);
            break;
            }
         }
      }
   }

   /* SEMI-HACK: Guard against bad values */
   if (glWavePosition < 0L) {
      DPF(TEXT("Position before zero!\n"));
      glWavePosition = 0L;
   }

   if (glWavePosition > glWaveSamples) {
      DPF(TEXT("Position past end!\n"));
      glWavePosition = glWaveSamples;
   }

   /* side effect: update <glWaveSamplesValid> */
   if (glWaveSamplesValid < glWavePosition)
      glWaveSamplesValid = glWavePosition;

   /* display the current wave position */
   lTime = wfSamplesToTime(gpWaveFormat, glWavePosition);
   if (gfLZero || ((int)(lTime/1000) != 0))
      wsprintf(ach, aszPositionFormat, (int)(lTime/1000), chDecimal, (int)((lTime/10)%100));
   else
      wsprintf(ach, aszNoZeroPositionFormat, chDecimal, (int)((lTime/10)%100));

   SetDlgItemText(ghwndApp, ID_CURPOSTXT, ach);

   /* display the current wave length */

   //
   //  changes whether the right-hand status box displays max length or current
   //  position while recording... the status box used to display the max
   //  length... if the status box gets added back for some reason, then we
   //  MAY want to change this back to the old way..
   //
#if 1
   lLen = ghWaveIn ? glWaveSamples : glWaveSamplesValid;
#else
   lLen = glWaveSamplesValid;
#endif
   lTime = wfSamplesToTime(gpWaveFormat, lLen);

   if (gfLZero || ((int)(lTime/1000) != 0))
      wsprintf(ach, aszPositionFormat, (int)(lTime/1000), chDecimal, (int)((lTime/10)%100));
   else
      wsprintf(ach, aszNoZeroPositionFormat, chDecimal, (int)((lTime/10)%100));

   SetDlgItemText(ghwndApp, ID_FILELENTXT, ach);

   /* update the wave display */
   InvalidateRect(ghwndWaveDisplay, NULL, fStatusChanged);
   UpdateWindow(ghwndWaveDisplay);

   /* update the scroll bar position */
   if (glWaveSamplesValid > 0)
      iPos = (int)MulDiv((DWORD) SCROLL_RANGE, glWavePosition, lLen);
   else
      iPos = 0;

   //
   // windows will re-draw the scrollbar even
   // if the position does not change.
   //
#if 0
   if (iPos != GetScrollPos(ghwndScroll, SB_CTL))
      SetScrollPos(ghwndScroll, SB_CTL, iPos, TRUE);
   //        if (iPos != GetScrollPos(ghwndScroll, SB_CTL))
   //       SendMessage(ghwndScroll, TBM_SETPOS, TRUE, (LPARAM)(WORD)iPos);
#endif

   // Now we're using a much nicer trackbar
   // SetScrollPos(ghwndScroll, SB_CTL, iPos, TRUE);
   SendMessage(ghwndScroll,TBM_SETPOS, TRUE, (LPARAM)(WORD)iPos);  // WORD worries me. LKG. ???
   SendMessage(ghwndScroll,TBM_SETRANGEMAX, 0, (glWaveSamplesValid > 0)?SCROLL_RANGE:0);

   EnableWindow(ghwndForward, glWavePosition < glWaveSamplesValid);
   EnableWindow(ghwndRewind,  glWavePosition > 0);

   if (hwndFocus == ghwndForward && glWavePosition >= glWaveSamplesValid)
      SetDlgFocus(ghwndRewind);

   if (hwndFocus == ghwndRewind && glWavePosition == 0)
      SetDlgFocus(ghwndForward);

#ifdef DEBUG
   if ( ((ghWaveIn != NULL) || (ghWaveOut != NULL)) &&
      (gapWaveHdr[0]->dwFlags & WHDR_DONE) )
      //!!            DPF2(TEXT("DONE BIT SET!\n"));
      ;
#endif
} /* UpdateDisplay */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mci\mci.h ===
/*
    mci.h
*/


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <mmsystem.h>
#include <string.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\sndvol\newvol.c ===
/* (C) Copyright Microsoft Corporation 1993.  All Rights Reserved */

#include <windows.h>
#include <mmsystem.h>
#include <string.h>
#include "newvol.h"
#include "volume.h"     // for ini file string identifiers
#include "sndcntrl.h"

#ifdef TESTMIX
#include "mixstub.h"
#endif
//
// Globals
//
#define SHOWMUX
int NumberOfDevices = 0;
PVOLUME_CONTROL    Vol = NULL;

UINT               FirstMasterIndex;

/*
 * Profile file, section and key names
 */
TCHAR gszVolumeSection[64];
TCHAR gszProfileFile[MAX_PATH];

DWORD AdjustMaster(WORD v)
{
    DWORD dwResult;

    if (bMuted) {
        return 1;
    }

    dwResult = (v >> 8) + 1;

    return dwResult;
}

//
// Add a control to our list
//
// Note that the G..Ptr macros in windowsx.h are inadequate and incorrect -
// especially for multithreaded systems where stuff can move while it is
// temporarily unlocked.
//

PVOLUME_CONTROL AddNewControl(VOID)
{
    HGLOBAL         hMem;
    PVOLUME_CONTROL pVol;

    if (Vol == NULL) {
        hMem = GlobalAlloc(GHND, sizeof(VOLUME_CONTROL));
        if (hMem == NULL) {
            return NULL;
        } else {
            Vol = GlobalLock(hMem);
            NumberOfDevices = 1;
        }
    } else {
        HGLOBAL hMemOld;

        hMemOld = GlobalHandle((LPVOID)Vol);
        GlobalUnlock(hMemOld);
        hMem = GlobalReAlloc(hMemOld,
                             sizeof(VOLUME_CONTROL) * (NumberOfDevices + 1),
                             GHND);
        if (hMem == NULL) {
            Vol = GlobalLock(hMemOld);
            return NULL;
        }

        Vol = GlobalLock(hMem);
        NumberOfDevices++;
    }
    pVol = Vol + (NumberOfDevices - 1);

    /*
    **  Finish initialization
    */

    pVol->Index          = NumberOfDevices - 1;

    pVol->MixerId        = (HMIXEROBJ)-1;
    pVol->ControlId      = (DWORD)-1;
    pVol->MuxControlId   = (DWORD)-1;
    pVol->MuteControlId  = (DWORD)-1;
    pVol->MuxSelectIndex = (DWORD)-1;

    return pVol;
}

WORD CombineVolume(WORD Master, WORD Slave)
{
   DWORD Result;

   //
   // treat both numbers as 8-bit volumes, and multiply them
   //

   Result = AdjustMaster(Master) * (DWORD)(Slave >> 8);

   return LOWORD(Result);
}

/*
**  Set the device volume.
**
**  The master volume (and mute setting) are simulated here by
**  scaling the individual device volumes if there is no mixer
**  or the mixer doesn't support the settings
*/
BOOL SetDeviceVolume(PVOLUME_CONTROL pVol, DWORD Volume)
{
    DWORD dwMaster;

    /*
    **  Mixer volumes get set when we get the notification
    */

    if (pVol->VolumeType != VolumeTypeMixerControl) {
        pVol->LRVolume = Volume;
    }

   /*
    *  If it's not the master volume we're setting then
    *  combine the setting with the master volume setting
    */

    if (pVol->Type != MasterVolume) {

        /*
        **  Only simulate controls which don't have real master controls
        */

        if (!pVol->NoMasterSimulation) {
            /*
             * if mute is selected, scale the volume by 1 (not 0)
             * as the master volume. This will still result in an
             * inaudible volume, but will allow us to recover the volume setting
             * from the device when this app restarts.
             */
            dwMaster = MasterDevice(FALSE)->LRVolume;

            Volume = CombineVolume(LOWORD(dwMaster),
                                   LOWORD(Volume)) +
                    (CombineVolume(HIWORD(dwMaster),
                                   HIWORD(Volume)) << 16);
        }
    }

    switch (pVol->Type) {
    case MasterVolume:
        {
           int i;
           for (i = 0; i < NumberOfDevices; i++) {
               if (!Vol[i].NoMasterSimulation && Vol[i].Type != MasterVolume) {
                   SetDeviceVolume(&Vol[i], Vol[i].LRVolume);
               }
           }
        }
        if (pVol->VolumeType == VolumeTypeMixerControl) {
            SetMixerVolume(pVol->MixerId,
                           pVol->ControlId,
                           pVol->Stereo,
                           Volume);
        }
        break;

    case AuxVolume:
        auxSetVolume(pVol->id, Volume);
        break;

    case MidiOutVolume:
#if (WINVER >= 0x0400)
        midiOutSetVolume((HMIDIOUT)pVol->id, Volume);
#else
        midiOutSetVolume(pVol->id, Volume);
#endif
        break;

    case WaveOutVolume:
#if (WINVER >= 0x0400)
        waveOutSetVolume((HWAVEOUT)pVol->id, Volume);
#else
        waveOutSetVolume(pVol->id, Volume);
#endif
        break;

    case MixerControlVolume:
        SetMixerVolume(pVol->MixerId,
                       pVol->ControlId,
                       pVol->Stereo,
                       Volume);
        break;

    }

    if (pVol->VolumeType != VolumeTypeMixerControl) {
        /*
        **  Update the slider(s)
        */

        UpdateVolume(pVol);
    }

    return TRUE;
}

/*
 *  Get the volume associated with a mixer device
 */

VOID GetMixerVolume(HMIXEROBJ MixerId, DWORD dwControlId, BOOL Stereo, LPDWORD pVolume)
{
    MIXERCONTROLDETAILS mxd;
    DWORD               Volume[2];

    Volume[0] = 0;
    Volume[1] = 0;

    mxd.cbStruct        = sizeof(mxd);
    mxd.dwControlID     = dwControlId;
    mxd.cChannels       = Stereo ? 2 : 1;
    mxd.cMultipleItems  = 0;
    mxd.cbDetails       = sizeof(DWORD);
    mxd.paDetails       = (LPVOID)Volume;

    mixerGetControlDetails(MixerId, &mxd, MIXER_GETCONTROLDETAILSF_VALUE);

    if (Stereo) {
        *pVolume = (DWORD)MAKELONG(Volume[0], Volume[1]);
    } else {
        *pVolume = (DWORD)MAKELONG(Volume[0], Volume[0]);
    }
}

/*
 *  Set the volume associated with a mixer device
 */

VOID SetMixerVolume(HMIXEROBJ MixerId, DWORD dwControlId, BOOL Stereo, DWORD NewVolume)
{
    MIXERCONTROLDETAILS mxd;
    DWORD               Volume[2];

    Volume[0] = LOWORD(NewVolume);
    Volume[1] = HIWORD(NewVolume);

    mxd.cbStruct        = sizeof(mxd);
    mxd.dwControlID     = dwControlId;
    mxd.cChannels       = Stereo ? 2 : 1;
    mxd.cMultipleItems  = 0;
    mxd.cbDetails       = sizeof(DWORD);
    mxd.paDetails       = (LPVOID)Volume;

    mixerSetControlDetails(MixerId, &mxd, MIXER_SETCONTROLDETAILSF_VALUE);
}


/*
 *  Get the volume for a given device.  Returns the volume
 *  setting packed in a DWORD
 */

DWORD GetDeviceVolume(PVOLUME_CONTROL pVol)
{
    DWORD Volume;
    DWORD Left;
    DWORD Right;
    DWORD dwMaster;
    PVOLUME_CONTROL pMaster;

    //
    // Default if calls fail
    //

    Volume = pVol->LRVolume;

    switch (pVol->Type) {

    case AuxVolume:
        auxGetVolume(pVol->id, &Volume);
        break;

    case MidiOutVolume:
#if (WINVER >= 0x0400)
        midiOutGetVolume((HMIDIOUT)pVol->id, &Volume);
#else
        midiOutGetVolume(pVol->id, &Volume);
#endif
        break;

    case WaveOutVolume:
#if (WINVER >= 0x0400)
        waveOutGetVolume((HWAVEOUT)pVol->id, &Volume);
#else
        waveOutGetVolume(pVol->id, &Volume);
#endif
        break;

    case MixerControlVolume:
    case MasterVolume:

        /*
        ** don't scale by master vol in this case
        */

        if (pVol->VolumeType != VolumeTypeMixerControl) {
            return Volume;
        }

        GetMixerVolume(pVol->MixerId,
                       pVol->ControlId,
                       pVol->Stereo,
                       &Volume);

        if (pVol->NoMasterSimulation || pVol->Type == MasterVolume) {
            return Volume;
        }
        break;
    }

    /*
    **  Translate it back through the master volume
    **  Use 1 as the master volume if mute is set (see SetDeviceVolume)
    */

    pMaster = MasterDevice(pVol->RecordControl);

    if (!pVol->NoMasterSimulation && pMaster != NULL) {
        dwMaster = pMaster->LRVolume;

        Left = ((DWORD)LOWORD(Volume)) / AdjustMaster(LOWORD(dwMaster));
        Left <<= 8;
        if (Left > 65535) {
            Left = 65535;
        }

        Right = ((DWORD)HIWORD(Volume)) / AdjustMaster(HIWORD(dwMaster));
        Right <<= 8;
        if (Right > 65535) {
            Right = 65535;
        }
    } else {
        if (bMuted &&
            (pMaster == NULL ||
             pMaster->MuteControlId == (DWORD)-1)) {

            Left = LOWORD(Volume) >> 8;
            Right = HIWORD(Volume) >> 8;
        } else {
            Left = LOWORD(Volume);
            Right = HIWORD(Volume);
        }
    }

    pVol->LRVolume = (DWORD)MAKELONG(Left, Right);

    return pVol->LRVolume;
}

/*
**  Update the displayed 'selected' state for a line
*/

VOID UpdateSelected(PVOLUME_CONTROL pVol)
{
    if (pVol->hCheckBox != NULL) {
        BOOL bSelected = ControlSelected(pVol);
        if (pVol->Type == MasterVolume) {
            SetWindowText(pVol->hCheckBox,
                          _string(bSelected ? IDS_MUTE : IDS_UNMUTE));
        } else {
            SendMessage(pVol->hCheckBox,
                        BM_SETCHECK,
                        (WPARAM)bSelected,
                        0L);
        }
    }
}

/*
**  Update the displayed volume for a slider by getting the actual level from
**  the device and then updating the local values and informing the window
**  control(s)
*/

VOID UpdateVolume(PVOLUME_CONTROL pVol)
{
    UINT    oldVolume, oldBalance;
    DWORD   dwVolumes;
    UINT    max, min, left, right, temp;

    oldVolume = pVol->Volume;
    oldBalance = pVol->Balance;

    dwVolumes = GetDeviceVolume(pVol);

    /* figure out pan information */
    right = HIWORD(dwVolumes);
    left = LOWORD(dwVolumes);
    max = (right > left) ? right : left;
    min = (right > left) ? left : right;

    if (max == 0) {
        /* special case since then there's no panning. Therefore
            we dont know what the panning level is, therefore
            dont change the slider balance */
        pVol->Volume = 0;
        pVol->Balance = oldBalance;       /* centered */
    } else {
        pVol->Volume = max >> 8;
        temp = (UINT) (((DWORD) (max - min) << 7) / max);
        if (temp > 0x7f) temp = 0x7f;

        if (right > left)
            pVol->Balance = 0x80 + temp;
        else
            pVol->Balance = 0x7f - temp;
    }

    /* change the slider if necessary */
    if (oldVolume != pVol->Volume && pVol->hChildWnd && IsWindow(pVol->hChildWnd)) {
        SendMessage(pVol->hChildWnd,SL_PM_SETKNOBPOS,
            pVol->Volume, 0);
    }
    if (oldBalance != pVol->Balance && IsWindow(pVol->hMeterWnd)) {
        SendMessage(pVol->hMeterWnd,MB_PM_SETKNOBPOS,
            pVol->Balance, 0);
    }
}

/*
 *  Extract pertinent information for a given device type
 *  If there is an equivalent mixer device don't bother.
 */
BOOL ExtractInfo(UINT id,
                 VOLUME_DEVICE_TYPE Type,
                 LPBOOL VolSupport,
                 LPBOOL StereoSupport,
                 LPTSTR lpName,
                 PUINT Technology)
{
    UINT MixerId;

    switch (Type) {
    case MasterVolume:
        break;
    case AuxVolume:
        if (mixerGetID((HMIXEROBJ)id, &MixerId, MIXER_OBJECTF_AUX) == MMSYSERR_NOERROR) {
            return FALSE;
        }  else {
           AUXCAPS ac;
           if (auxGetDevCaps(id, &ac, sizeof(ac)) != MMSYSERR_NOERROR) {
              return FALSE;
           }
           *VolSupport = (ac.dwSupport & AUXCAPS_VOLUME) != 0;
           *StereoSupport = (ac.dwSupport & AUXCAPS_LRVOLUME) != 0;
           lstrcpyn(lpName, ac.szPname, MAXPNAMELEN);
           *Technology =
               ac.wTechnology == AUXCAPS_CDAUDIO ? VolumeTypeCD :
               ac.wTechnology == AUXCAPS_AUXIN ? VolumeTypeLineIn :
                  VolumeTypeAux;
        }
        break;
    case MidiOutVolume:
       if (mixerGetID((HMIXEROBJ)id, &MixerId, MIXER_OBJECTF_MIDIOUT) == MMSYSERR_NOERROR) {
           return FALSE;
       }  else {
          MIDIOUTCAPS mc;
          if (midiOutGetDevCaps(id, &mc, sizeof(mc)) != MMSYSERR_NOERROR) {
             return FALSE;
          }
          *VolSupport = (mc.dwSupport & MIDICAPS_VOLUME) != 0;
          *StereoSupport = (mc.dwSupport & MIDICAPS_LRVOLUME) != 0;
          lstrcpyn(lpName, mc.szPname, MAXPNAMELEN);
          *Technology =
              mc.wTechnology == MOD_SYNTH || mc.wTechnology == MOD_SQSYNTH ||
              mc.wTechnology == MOD_FMSYNTH ? VolumeTypeSynth :
              VolumeTypeMidi;
       }
       break;
    case WaveOutVolume:
        if (mixerGetID((HMIXEROBJ)id, &MixerId, MIXER_OBJECTF_WAVEOUT) == MMSYSERR_NOERROR) {
            return FALSE;
        }  else {
           WAVEOUTCAPS wc;
           if (waveOutGetDevCaps(id, &wc, sizeof(wc)) != MMSYSERR_NOERROR) {
              return FALSE;
           }
           *VolSupport = (wc.dwSupport & WAVECAPS_VOLUME) != 0;
           *StereoSupport = (wc.dwSupport & WAVECAPS_LRVOLUME) != 0;
           lstrcpyn(lpName, wc.szPname, MAXPNAMELEN);
           *Technology = VolumeTypeWave;
        }
        break;
    }

    return TRUE;
}

/*
**  NonMixerDevices
**
**  Search to see if there is a non-mixer device which is not
**  duplicated by a mixer device
**
**  If there is one return TRUE, otherwise FALSE
*/

BOOL NonMixerDevices()
{
    VOLUME_DEVICE_TYPE DeviceType;

    for (DeviceType = WaveOutVolume;
         DeviceType < NumberOfDeviceTypes;
         DeviceType++) {
        UINT DeviceId;
        UINT N;

        N = DeviceType == AuxVolume          ? auxGetNumDevs() :
            DeviceType == MidiOutVolume      ? midiOutGetNumDevs() :
                                               waveOutGetNumDevs();

        for (DeviceId = 0; DeviceId < N; DeviceId++) {
            BOOL VolumeSupport;
            BOOL StereoSupport;
            TCHAR Pname[MAXPNAMELEN];
            UINT Technology;

            if (ExtractInfo(DeviceId,
                            DeviceType,
                            &VolumeSupport,
                            &StereoSupport,
                            Pname,
                            &Technology) &&
                VolumeSupport) {
                return TRUE;
            }
        }
    }

    return FALSE;
}

/*
**  Returns an allocated array of the controls for a given line
**  Caller must LocalFree it.
*/

PMIXERCONTROL GetMixerLineControls(HMIXEROBJ MixerId,
                                   DWORD dwLineID,
                                   DWORD cControls)
{
    MIXERLINECONTROLS MixerLineControls;

    MixerLineControls.cbStruct = sizeof(MixerLineControls);
    MixerLineControls.cControls = cControls;
    MixerLineControls.dwLineID  = dwLineID;
    MixerLineControls.cbmxctrl  = sizeof(MIXERCONTROL);

    MixerLineControls.pamxctrl =
        (LPMIXERCONTROL)LocalAlloc(LPTR, cControls * sizeof(MIXERCONTROL));

    if (MixerLineControls.pamxctrl == NULL) {
        //
        // Ulp!
        //

        return NULL;
    }

    if (mixerGetLineControls(MixerId,
                             &MixerLineControls,
                             MIXER_GETLINECONTROLSF_ALL) != MMSYSERR_NOERROR) {
        LocalFree((HLOCAL)MixerLineControls.pamxctrl);
        return NULL;
    }

    return MixerLineControls.pamxctrl;
}

BOOL GetControlByType(
    HMIXEROBJ MixerId,
    DWORD dwLineId,
    DWORD dwControlType,
    PMIXERCONTROL MixerControl
)
{
    MIXERLINECONTROLS MixerLineControls;

    MixerLineControls.cbStruct      = sizeof(MixerLineControls);
    MixerLineControls.cControls     = 1;
    MixerLineControls.dwLineID      = dwLineId;
    MixerLineControls.dwControlType = dwControlType;
    MixerLineControls.cbmxctrl      = sizeof(MIXERCONTROL);

    MixerLineControls.pamxctrl = MixerControl;

    if (mixerGetLineControls(MixerId,
                             &MixerLineControls,
                             MIXER_GETLINECONTROLSF_ONEBYTYPE) != MMSYSERR_NOERROR) {
        return FALSE;
    }

    return TRUE;
}

/*
**  See if a given volume control is selected through its mux/mixer
**  Note that this state can change every time the relevant mux/mixer
**  control changes
*/
BOOL ControlSelected(
    PVOLUME_CONTROL pVol
)
{
    MIXERCONTROLDETAILS mxd;
    BOOL                bResult;

    if (pVol->Type != MixerControlVolume ||
        pVol->MuxSelectIndex == (DWORD)-1) {
        bResult = TRUE;
    } else {

        mxd.cbStruct        = sizeof(mxd);
        mxd.dwControlID     = pVol->MuxControlId;
        mxd.cChannels       = 1;
        mxd.cMultipleItems  = pVol->MuxItems;
        mxd.cbDetails       = sizeof(DWORD);
        mxd.paDetails       =
            (LPVOID)LocalAlloc(LPTR, mxd.cbDetails * mxd.cMultipleItems);

        if (mxd.paDetails == NULL) {
            return FALSE;
        }

        mixerGetControlDetails(pVol->MixerId, &mxd, MIXER_GETCONTROLDETAILSF_VALUE);
        bResult = ((LPDWORD)mxd.paDetails)[pVol->MuxSelectIndex] != 0;
        LocalFree((HLOCAL)mxd.paDetails);
    }


    if (pVol->MuteControlId != (DWORD)-1) {
        bResult = bResult && !GetMixerMute(pVol);
    }

    return bResult;
}

/*
**  The user wants this device to do its thing
*/

VOID SelectControl(
    PVOLUME_CONTROL pVol,
    BOOL            Select
)
{
    MIXERCONTROLDETAILS mxd;

    if (pVol->Type != MixerControlVolume ||
        pVol->MuxSelectIndex == (DWORD)-1 &&
        pVol->MuteControlId == (DWORD)-1) {
        return;
    }

    if (pVol->MuxSelectIndex == (DWORD)-1) {
        SetMixerMute(pVol, !Select);
    } else {
        mxd.cbStruct        = sizeof(mxd);
        mxd.dwControlID     = pVol->MuxControlId;
        mxd.cChannels       = 1;
        mxd.cMultipleItems  = pVol->MuxItems;
        mxd.cbDetails       = sizeof(DWORD);
        mxd.paDetails       =
            (LPVOID)LocalAlloc(LPTR, mxd.cbDetails * mxd.cMultipleItems);

        if (mxd.paDetails == NULL) {
            return;
        }

        if (pVol->MuxOrMixer) {
            /*
            **  Mux
            */

            ZeroMemory(mxd.paDetails, sizeof(DWORD) * mxd.cMultipleItems);
        } else {
            /*
            **  Mixer
            */

            mixerGetControlDetails(pVol->MixerId, &mxd, MIXER_GETCONTROLDETAILSF_VALUE);
        }

        ((LPDWORD)mxd.paDetails)[pVol->MuxSelectIndex] = (DWORD)Select;
        mixerSetControlDetails(pVol->MixerId, &mxd, MIXER_SETCONTROLDETAILSF_VALUE);

        /*
        **  If we have both mute and mux then turn off the mute if we
        **  activate this device
        */

        if (Select && pVol->MuteControlId != (DWORD)-1) {
            SetMixerMute(pVol, FALSE);
        }

        LocalFree((HLOCAL)mxd.paDetails);
    }
}

BOOL GetMixerMute(PVOLUME_CONTROL pVol)
{
    MIXERCONTROLDETAILS mxd;
    DWORD               dwMute;

    if (pVol->MuteControlId == (DWORD)-1) {
        return FALSE;
    }

    mxd.cbStruct        = sizeof(mxd);
    mxd.dwControlID     = pVol->MuteControlId;
    mxd.cChannels       = 1;
    mxd.cMultipleItems  = 0;
    mxd.cbDetails       = sizeof(DWORD);
    mxd.paDetails       = (LPDWORD)&dwMute;

    mixerGetControlDetails(pVol->MixerId, &mxd, MIXER_GETCONTROLDETAILSF_VALUE);

    if (pVol->Type == MasterVolume) {
        bMuted = (BOOL)dwMute;
    }
    return (BOOL)dwMute;
}
VOID SetMixerMute(PVOLUME_CONTROL pVol, BOOL Set)
{
    MIXERCONTROLDETAILS mxd;

    if (pVol->MuteControlId == (DWORD)-1) {
        return;
    }

    mxd.cbStruct        = sizeof(mxd);
    mxd.dwControlID     = pVol->MuteControlId;
    mxd.cChannels       = 1;
    mxd.cMultipleItems  = 0;
    mxd.cbDetails       = sizeof(DWORD);
    mxd.paDetails       = (LPDWORD)&Set;

    mixerSetControlDetails(pVol->MixerId, &mxd, MIXER_SETCONTROLDETAILSF_VALUE);
}

/*
**  Add a master control
**
**  Paramters
**      MixerId   - The mixer id
**      dwMaster  - The control id for volume setting
**      dwMute    - The control id for muting
**      Record    - whether it's a record or play master
*/

VOID
AddMasterControl(
    HMIXEROBJ      MixerId,
    LPMIXERLINE    LineInfo,
    LPMIXERCONTROL ControlInfo,
    DWORD          dwMute,
    BOOL           Record
)
{
    PVOLUME_CONTROL pVol;

    pVol = AddNewControl();

    if (pVol == NULL) {
        return;
    }

    pVol->Type             = MasterVolume;
    pVol->MixerId          = MixerId;
    pVol->VolumeType       = VolumeTypeMixerControl;
    pVol->Stereo           = LineInfo->cChannels > 1;
    pVol->ControlId        = ControlInfo->dwControlID;
    pVol->RecordControl    = Record;
    pVol->MuteControlId    = dwMute;
    pVol->DestLineId       = LineInfo->dwLineID;
    lstrcpy(pVol->Name, LineInfo->szShortName);

    if (FirstMasterIndex == (DWORD)-1) {
        FirstMasterIndex = pVol->Index;
    }

    if (pVol->MuteControlId != (DWORD)-1) {
        bMuted = GetMixerMute(pVol);
    }
}

VOID
AddVolumeControl(
    HMIXEROBJ      MixerId,
    BOOL           NoMasterSimulation,
    LPMIXERLINE    LineInfo,
    LPMIXERCONTROL ControlInfo,
    BOOL           Record,
    LPMIXERCONTROL MuxControl,
    DWORD          MuxSelectIndex,
    BOOL           MuxOrMixer,
    DWORD          MuteControlId,
    DWORD          DestLineId
)
{
    PVOLUME_CONTROL pVol;

    pVol = AddNewControl();

    if (pVol == NULL) {
        return;
    }

    pVol->Type             = MixerControlVolume;
    pVol->MixerId          = MixerId;
    pVol->VolumeType       = VolumeTypeMixerControl;
    pVol->Stereo           = LineInfo->cChannels > 1;
#ifndef SHOWMUX
    pVol->ControlId        = ControlInfo->dwControlID;
#else
    if (ControlInfo != NULL)
        pVol->ControlId    = ControlInfo->dwControlID;
    else
        pVol->ControlId    = (DWORD)-1;
#endif
    pVol->RecordControl    = Record;
    pVol->DestLineId       = DestLineId;

    if (Record) {
        bRecordControllable = TRUE;
    }

    pVol->NoMasterSimulation = NoMasterSimulation;
    pVol->MuxSelectIndex   = MuxSelectIndex;
    pVol->MuteControlId    = MuteControlId;
    if (MuxSelectIndex != (DWORD)-1) {
        pVol->MuxControlId     = MuxControl->dwControlID;
        pVol->MuxOrMixer       = MuxControl->dwControlType ==
                                             MIXERCONTROL_CONTROLTYPE_MUX;

        pVol->MuxItems         = MuxControl->cMultipleItems;
    }

    lstrcpy(pVol->Name, LineInfo->szShortName);
}

//
// Get the mixer stuff we're interested in
//

VOID GetMixerControls(HMIXEROBJ MixerId)
{

    MIXERCAPS       MixerCaps;
    DWORD           DestLineIndex;

    //
    //  Find the number of dest lines
    //

    if (mixerGetDevCaps((UINT)MixerId, &MixerCaps, sizeof(MixerCaps)) !=
        MMSYSERR_NOERROR) {
        return;
    }

    /*
    **  For each destination :
    **     If it's an output
    **        Find the master and mute controls if there are any
    **        Scan the source lines for suitable devices
    **
    **  NB should this just be for speakers?
    */

    for (DestLineIndex = 0;
         DestLineIndex < MixerCaps.cDestinations;
         DestLineIndex++) {

         MIXERLINE    DestLineInfo;
         MIXERCONTROL MasterVolumeControl, MasterMuteControl;
         MIXERCONTROL MuxControl;
         DWORD        dwMute;
         DWORD        dwMaster;
         BOOL         MasterFound;
         BOOL         IncludeLine;
         BOOL         RecordDestination;
         BOOL         MuxValid;
         DWORD        SourceIndex;

         MasterFound = FALSE;
         dwMute = (DWORD)-1;
         dwMaster = (DWORD)-1;

         DestLineInfo.cbStruct = sizeof(DestLineInfo);
         DestLineInfo.dwDestination = DestLineIndex;

         if (mixerGetLineInfo(MixerId,
                              &DestLineInfo,
                              MIXER_GETLINEINFOF_DESTINATION) !=
             MMSYSERR_NOERROR) {
             return;              // Bad mixer or something
         }

         if (DestLineInfo.fdwLine & MIXERLINE_LINEF_DISCONNECTED) {
             continue;
         }

         switch (DestLineInfo.dwComponentType) {

             case MIXERLINE_COMPONENTTYPE_DST_SPEAKERS:
             case MIXERLINE_COMPONENTTYPE_DST_HEADPHONES:
                 RecordDestination = FALSE;
                 IncludeLine = TRUE;
                 break;

             case MIXERLINE_COMPONENTTYPE_DST_WAVEIN:
                 RecordDestination = TRUE;
                 IncludeLine = TRUE;
                 break;

             default:
                 IncludeLine = FALSE;
                 break;
         }

         if (!IncludeLine) {
             continue;
         }

         if (GetControlByType(MixerId,
                              DestLineInfo.dwLineID,
                              MIXERCONTROL_CONTROLTYPE_MUX,
                              &MuxControl) ||
             GetControlByType(MixerId,
                              DestLineInfo.dwLineID,
                              MIXERCONTROL_CONTROLTYPE_MIXER,
                              &MuxControl)) {
             /*
             **  Found a mux for this destination.
             */

             MuxValid = TRUE;
         } else {

             /*
             **  No Mux
             */

             MuxValid = FALSE;
         }

         /*
         **  Master and mute for all dest types
         */

         if (GetControlByType(MixerId,
                              DestLineInfo.dwLineID,
                              MIXERCONTROL_CONTROLTYPE_VOLUME,
                              &MasterVolumeControl)) {

             MasterFound = TRUE;
             dwMaster    = MasterVolumeControl.dwControlID;

             if (GetControlByType(MixerId,
                                  DestLineInfo.dwLineID,
                                  MIXERCONTROL_CONTROLTYPE_MUTE,
                                  &MasterMuteControl)) {
                 dwMute = MasterMuteControl.dwControlID;
             }

             /*
             **  Add master information
             */

             AddMasterControl(MixerId,
                              &DestLineInfo,
                              &MasterVolumeControl,
                              dwMute,
                              RecordDestination);

         }

         /*
         **  Now find each individual source control we want to
         **  control
         */

         for (SourceIndex = 0;
              SourceIndex < DestLineInfo.cConnections;
              SourceIndex++) {
             MIXERLINE         SourceLineInfo;
             MIXERCONTROL      SourceLineVolumeControl;
             LPMIXERCONTROL    lpSLVC = &SourceLineVolumeControl;

             BOOL              IncludeLine;
             DWORD             MuxSelectIndex;
             DWORD             MuteControlId;

             MuxSelectIndex = (DWORD)-1;

             SourceLineInfo.cbStruct      = sizeof(SourceLineInfo);
             SourceLineInfo.dwDestination = DestLineIndex;
             SourceLineInfo.dwSource      = SourceIndex;

             if (mixerGetLineInfo(MixerId,
                                  &SourceLineInfo,
                                  MIXER_GETLINEINFOF_SOURCE) !=
                 MMSYSERR_NOERROR) {
                 return;
             }

             if (SourceLineInfo.fdwLine & MIXERLINE_LINEF_DISCONNECTED) {
                 continue;
             }


             switch (SourceLineInfo.dwComponentType) {

                 /*
                 **  Only allow things we understand (and remove things
                 **  like pc speaker to keep the number of sliders down).
                 */

                 case MIXERLINE_COMPONENTTYPE_SRC_LINE:
                 case MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE:
                 case MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER:
                 case MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC:
                 case MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT:
                 case MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY:
                 case MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE:
                 case MIXERLINE_COMPONENTTYPE_SRC_DIGITAL:
                     IncludeLine = TRUE;
                     break;

                 default:
                     IncludeLine = TRUE;
                     break;
             }

             if (!IncludeLine) {
                 continue;
             }

             /*
             **  Try to get the relevant volume control
             */

             if (!GetControlByType(MixerId,
                                   SourceLineInfo.dwLineID,
                                   MIXERCONTROL_CONTROLTYPE_VOLUME,
                                   &SourceLineVolumeControl)) {
#ifdef SHOWMUX
                 lpSLVC = NULL;
#else
                 continue;
#endif
             }

             /*
             **  See if there's a mute
             */
             {
                 MIXERCONTROL MuteControl;

                 if (GetControlByType(MixerId,
                                      SourceLineInfo.dwLineID,
                                      MIXERCONTROL_CONTROLTYPE_MUTE,
                                      &MuteControl)) {
                     MuteControlId = MuteControl.dwControlID;
                 } else {
                     MuteControlId = (DWORD)-1;
                 }
             }

             /*
             ** See if we need an id to switch the recording on or
             ** off
             */

             if (MuxValid) {
                 LPMIXERCONTROLDETAILS_LISTTEXT ListText;

                 ListText = (LPMIXERCONTROLDETAILS_LISTTEXT)
                            LocalAlloc(LPTR,
                                       sizeof(*ListText) *
                                           MuxControl.cMultipleItems);

                 if (ListText != NULL) {
                     MIXERCONTROLDETAILS mxd;

                     mxd.cbStruct       = sizeof(mxd);
                     mxd.dwControlID    = MuxControl.dwControlID;
                     mxd.cChannels      = 1;   // Why the ???
                     mxd.cMultipleItems = MuxControl.cMultipleItems;
                     mxd.cbDetails      = sizeof(*ListText);
                     mxd.paDetails      = (LPVOID)ListText;

                     if (mixerGetControlDetails(
                             MixerId,
                             &mxd,
                             MIXER_GETCONTROLDETAILSF_LISTTEXT) ==
                         MMSYSERR_NOERROR) {
                         UINT i;

                         /*
                         **  Look for our line
                         */

                         for (i = 0; i < MuxControl.cMultipleItems; i++) {
                             if (ListText[i].dwParam1 ==
                                 SourceLineInfo.dwLineID) {
                                 MuxSelectIndex = i;
                             }
                         }
                     }

                     LocalFree((HLOCAL)ListText);
                 }
             }

             /*
             **  Add this volume control to the list
             */

             AddVolumeControl(MixerId,
                              MasterFound || RecordDestination,
                              &SourceLineInfo,
//                              &SourceLineVolumeControl,
                              lpSLVC,
                              RecordDestination,
                              MuxValid ? &MuxControl : NULL,
                              MuxSelectIndex,
                              MuxValid ? FALSE :
                                         MuxControl.dwControlType ==
                                         MIXERCONTROL_CONTROLTYPE_MUX,
                              MuteControlId,
                              DestLineInfo.dwLineID);
         }
    }
}

//
// Scan through all relevant devices.
// If pVol is 0 just count them, otherwise save away info
// about them as well
//

VOID FindDevices(VOLUME_DEVICE_TYPE Type)
{
   UINT N;
   UINT id;

   N = Type == MasterVolume       ? 0 :
       Type == AuxVolume          ? auxGetNumDevs() :
       Type == MidiOutVolume      ? midiOutGetNumDevs() :
       Type == WaveOutVolume      ? waveOutGetNumDevs() :
       Type == MixerControlVolume ? mixerGetNumDevs() :
       0;


   for (id = 0; id < N; id++) {
      if (Type == MixerControlVolume) {
          //
          //  Find out how many suitable volume controls this mixer
          //  supports.
          //
          //  This is incredibly laborious because we can't just enumerate
          //  the controls (!).
          //
          //  This next call has the side effect of generating the mixer
          //  master stuff too and a set of mixer handles.
          //

          GetMixerControls(MixerId);
          return;
      } else {
          BOOL Volume;
          BOOL Stereo;
          TCHAR Name[MAXPNAMELEN];
          UINT Technology;

          if (ExtractInfo(id, Type, &Volume, &Stereo, Name, &Technology)) {
              if (Volume) {
                 PVOLUME_CONTROL pVol;

                 /*
                 **  Supports volume setting
                 */

                 pVol = AddNewControl();

                 if (pVol) {
                     pVol->id = id;
                     pVol->Type = Type;
                     pVol->VolumeType = Technology;
                     pVol->Stereo = Stereo;
                     pVol++;
                 }
              }
          } else {
             continue; // Don't use this one
          }
      }
   }
}

/*
 *  Create and initialize our volume array
 *
 *  On exit
 *    NumberOfDevices is set to the number of devices we want
 *    Vol is an array of size NumberOfDevices (may be 0)
 */

BOOL VolInit(VOID)
{
    int i;
    WORD wLeft, wRight, wMax, wMin, wTemp;

    /*
    **  Free any volume stuff currently present
    */

    if (Vol) {
        HGLOBAL hVol;
        int     i;

        /*
        **  Free all the windows
        */
        for (i = 0; i < NumberOfDevices; i++) {
            DestroyOurWindow(&Vol[i].hChildWnd);
            DestroyOurWindow(&Vol[i].hMeterWnd);
            DestroyOurWindow(&Vol[i].hStatic);
            DestroyOurWindow(&Vol[i].hCheckBox);
        }

        /*
        **  Free the memory
        */

        hVol = GlobalHandle(Vol);
        GlobalUnlock(hVol);
        GlobalFree(hVol);
        Vol = NULL;

        /*
        **  Initialize globals
        */

        bRecordControllable = FALSE;
    }

    /*
    **  No master volume controls found yet
    */

    FirstMasterIndex = (DWORD)-1;

    /*
     *  Scan all the device types we're interested in :
     *     wave out
     *     midi out
     *     aux
     */

     if ((DWORD)MixerId != (DWORD)-1) {
         FindDevices(MixerControlVolume);
     } else {
         for (i = WaveOutVolume; i < NumberOfDeviceTypes; i++) {
             FindDevices(i);
         }
     }

     if (NumberOfDevices == 0) {
         return FALSE;
     }

     if (FirstMasterIndex == (DWORD)-1) {
         PVOLUME_CONTROL pMaster;
         BOOL            bStereo;

         /*
         **  Find if any devices are stereo
         */

         bStereo = FALSE;

         for (i = 0; i < NumberOfDevices; i++) {
             if (Vol[i].Stereo) {
                 bStereo = TRUE;
                 break;
             }
         }

         /*
         **  Create a default volume control
         */

         pMaster = AddNewControl();
         if (pMaster == NULL) {
             return FALSE;
         }

         pMaster->Type       = MasterVolume;
         pMaster->VolumeType = -1;

         pMaster->Stereo     = bStereo;

         FirstMasterIndex = pMaster->Index;

         wLeft = (WORD)MasterLeft;
         wRight = (WORD)MasterRight;

         pMaster->LRVolume = MAKELONG(wLeft, wRight);

         if (wRight > wLeft) {
             wMax = wRight;
             wMin = wLeft;
         } else {
             wMax = wLeft;
             wMin = wRight;
         }

         if (wMax == 0) {

            pMaster->Volume = 0;
            pMaster->Balance = 0x80;       /* centered */

         } else {

            pMaster->Volume = wMax >> 8;

            wTemp = (UINT) (((DWORD) (wMax - wMin) << 7) / wMax);
            if (wTemp > 0x7f) wTemp = 0x7f;

            if (wRight > wLeft)
                pMaster->Balance = 0x80 + wTemp;
            else
                pMaster->Balance = 0x7f - wTemp;
         }

     }

     return TRUE;
}

/*
**  Called when a mixer calls us back with a control change
*/

VOID ControlChange(HMIXER hMixer, DWORD ControlId)
{
    UINT        i;
    HMIXEROBJ   MixerId;
    MMRESULT    mmr;

    mmr = mixerGetID((HMIXEROBJ)hMixer, (PUINT)&MixerId, MIXER_OBJECTF_HMIXER);

    if (mmr != MMSYSERR_NOERROR) {
        return;
    }
    for (i = 0; i < (UINT)NumberOfDevices; i++) {

        if (Vol[i].MixerId == MixerId) {
            if (Vol[i].VolumeType == VolumeTypeMixerControl) {
                if (ControlId == Vol[i].ControlId) {
                    UpdateVolume(&Vol[i]);

                    /*
                    **  Volume controls only affect one control
                    **  (unlike muxes)
                    */

                    break;
                } else {
                    if (ControlId == Vol[i].MuxControlId ||
                        ControlId == Vol[i].MuteControlId) {

                        UpdateSelected(&Vol[i]);
                    }
                }
            }
        } /* MixerId == Vol[i].MixerId */
    }
}

PVOLUME_CONTROL FirstDevice(BOOL bRecord)
{
    UINT i;
    for (i = 0; i < (UINT)NumberOfDevices; i++) {
        if (Vol[i].Type          != MasterVolume &&
            Vol[i].RecordControl == bRecord) {
            return &Vol[i];
        }
    }

    return NULL;
}
PVOLUME_CONTROL LastDevice(BOOL bRecord)
{
    UINT i;
    for (i = NumberOfDevices; i > 0; i--) {
        if (Vol[i - 1].Type          != MasterVolume &&
            Vol[i - 1].RecordControl == bRecord) {
            return &Vol[i - 1];
        }
    }

    return NULL;
}

PVOLUME_CONTROL NextDevice(PVOLUME_CONTROL pVol)
{
    UINT            i;

    for (i = pVol->Index == (UINT)NumberOfDevices - 1 ? 0 : pVol->Index + 1 ;
         i != pVol->Index;
         i = i == (UINT)NumberOfDevices - 1 ? 0 : i + 1) {

        if (Vol[i].Type != MasterVolume &&
            Vol[i].RecordControl == pVol->RecordControl) {
           break;
        }
    }

    return &Vol[i];
}

PVOLUME_CONTROL NextDeviceNoWrap(PVOLUME_CONTROL pVol)
{
    UINT            i;

    for (i = pVol->Index + 1 ;
         i < (UINT)NumberOfDevices;
         i = i + 1) {

        if (Vol[i].Type != MasterVolume &&
            Vol[i].RecordControl == pVol->RecordControl) {
           return &Vol[i];
        }
    }

    return NULL;
}
PVOLUME_CONTROL PrevDevice(PVOLUME_CONTROL pVol)
{
    UINT            i;

    for (i = pVol->Index == 0 ? NumberOfDevices - 1 : pVol->Index - 1;
         i != pVol->Index;
         i = i == 0 ? NumberOfDevices - 1 : i - 1) {

        if (Vol[i].Type != MasterVolume &&
            Vol[i].RecordControl == pVol->RecordControl) {
           return &Vol[i];
        }
    }

    return &Vol[i];
}

PVOLUME_CONTROL PrevDeviceNoWrap(PVOLUME_CONTROL pVol)
{
    UINT            i;

    for (i = pVol->Index;
         i != 0;
         i = i - 1) {

        if (Vol[i - 1].Type != MasterVolume &&
            Vol[i - 1].RecordControl == pVol->RecordControl) {
           return &Vol[i - 1];
        }
    }

    return NULL;
}

PVOLUME_CONTROL MasterDevice(BOOL bRecord)
{
    UINT i;

    for (i = 0 ; i < (UINT)NumberOfDevices; i++) {
        if (Vol[i].Type == MasterVolume &&
            Vol[i].RecordControl == bRecord) {
            return &Vol[i];
        }
    }

    return NULL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mcitest\debug.c ===
/*
 *  debug.c
 *
 *  debugging menu support
 *
 *  Debug level info is in WIN.INI in the [debug] section:
 *
 *      [debug]
 *      App=0               level for App
 *
 */

#include <stdio.h>
#include <windows.h>
#include "mcitest.h"
#include <stdarg.h>

#if DBG

#define DEFAULTDEBUGLEVEL 1
int   __iDebugLevel = DEFAULTDEBUGLEVEL;

void dDbgSetDebugMenuLevel(int i)
{
    HMENU hMenu;
    UINT m;

    if ((i < 0) || (i > 4)) i = 4;
    hMenu = GetMenu(hwndMainDlg);
    for (m=IDM_DEBUG0; m<=IDM_DEBUG4; m++) {
        CheckMenuItem(hMenu, m, MF_UNCHECKED);
    }
    CheckMenuItem(hMenu, (UINT)(i + IDM_DEBUG0), MF_CHECKED);
    __iDebugLevel = i;
    dprintf3((TEXT("Debug level set to %d"), i));
}

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/

void dDbgOut(LPTSTR lpszFormat, ...)
{
    int i;
    TCHAR buf[256];
    va_list va;

    i = wsprintf(buf, TEXT("%s: "), aszAppName);

    va_start(va, lpszFormat);
    i += wvsprintf(buf+i, lpszFormat, va);
    va_end(va);

    buf[i++] = TEXT('\n');
    buf[i] = 0;

    OutputDebugString(buf);
}

/***************************************************************************

    @doc INTERNAL

    @api int | dDbgGetLevel | This function gets the current debug level
        for a module.

    @parm LPSTR | lpszModule | The name of the module.

    @rdesc The return value is the current debug level.

    @comm The information is kept in the [debug] section of WIN.INI

****************************************************************************/

int dDbgGetLevel(LPTSTR lpszAppName)
{
    return GetProfileInt(TEXT("mmdebug"), lpszAppName, DEFAULTDEBUGLEVEL);
}

/***************************************************************************

    @doc INTERNAL

    @api int | dDbgSaveLevel | This function saves the current debug level
        for a module.

    @parm LPSTR | lpszModule | The name of the module.
    @parm int | iLevel | The value to save.

    @rdesc There is no return value.

    @comm The information is kept in the [debug] section of WIN.INI

****************************************************************************/

void dDbgSaveLevel(LPTSTR lpszAppName, int iLevel)
{
    TCHAR buf[80];

    wsprintf(buf, TEXT("%d"), iLevel);
    WriteProfileString(TEXT("debug"), lpszAppName, buf);
}

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgAssert | This function shows an assert message box.

    @parm LPSTR | exp | Pointer to the expression string.
    @parm LPSTR | file | Pointer to the file name.
    @parm int | line | The line number.

    @rdesc There is no return value.

    @comm We try to use the current active window as the parent. If
        this fails we use the desktop window.  The box is system
        modal to avoid any trouble.

****************************************************************************/

void dDbgAssert(LPTSTR exp, LPTSTR file, int line)
{
    TCHAR bufTmp[256];
    int iResponse;
    HWND hWnd;

    wsprintf(bufTmp,
        TEXT("Expression: %s\nFile: %s, Line: %d\n\nAbort:  Exit Process\nRetry:  Enter Debugger\nIgnore: Continue"),
        exp, file, line);

    // try to use the active window, but NULL is ok if there
    // isn't one.

    hWnd = GetActiveWindow();

    iResponse = MessageBox(hWnd,
                           bufTmp,
                           TEXT("Assertion Failure"),
                           MB_TASKMODAL
                            | MB_ICONEXCLAMATION
                            | MB_DEFBUTTON3
                            | MB_ABORTRETRYIGNORE);

    switch (iResponse) {
        case 0:
            dprintf1((TEXT("Assert message box failed")));
            dprintf2((TEXT("  Expression: %s"), exp));
            dprintf2((TEXT("  File: %s,  Line: %d"), file, line));
            break;
        case IDABORT:
            ExitProcess(1);
            break;
        case IDRETRY:
            DebugBreak();
            break;
        case IDIGNORE:
            break;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mcitest\edit.c ===
/*----------------------------------------------------------------------------*\
|   edit.c - routines for dealing with multi-line edit controls                |
|                                                                              |
|                                                                              |
|   History:                                                                   |
|       01/01/88 toddla     Created                                            |
|       11/04/90 w-dougb    Commented & formatted the code to look pretty      |
|                                                                              |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
|                                                                              |
|   i n c l u d e   f i l e s                                                  |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include <windows.h>
#include "gmem.h"
#include "edit.h"
#include "mcitest.h"

/*----------------------------------------------------------------------------*\
|                                                                              |
|   c o n s t a n t   a n d   m a c r o   d e f i n i t i o n s                |
|                                                                              |
\*----------------------------------------------------------------------------*/

#define ISSPACE(c) ((c) == ' ' || (c) == '\t')
#define ISEOL(c)   ((c) == '\n'|| (c) == '\r')
#define ISWHITE(c) (ISSPACE(c) || ISEOL(c))


/*----------------------------------------------------------------------------*\
|   EditOpenFile(hwndEdit, lszFile)                                            |
|                                                                              |
|   Description:                                                               |
|       This function opens the file <lszFile>, copies the contents of the     |
|       file into the edit control with the handle <hwndEdit>, and then closes |
|       the file.                                                              |
|                                                                              |
|   Arguments:                                                                 |
|       hwndEdit        window handle of the edit box control                  |
|       lszFile         filename of the file to be opened                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if the operation was successful, else FALSE                       |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL               EditOpenFile(
    HWND    hwndEdit,
    LPTSTR  lszFile)
{
#ifdef UNICODE
    HANDLE      fh;                 /* DOS file handle returned by OpenFile   */
#else
    HFILE       fh;                 /* DOS file handle returned by OpenFile   */
    OFSTRUCT    of;                 /* structure used by the OpenFile routine */
#endif
    LPTSTR      lszText;            /* pointer to the opened file's text      */
    UINT        nFileLen;           /* length, in bytes, of the opened file   */
    HCURSOR     hcur;               /* handle to the pre-hourglass cursor     */

    /* If a valid window handle or a filename was not specified, then exit.
     */
    if (!hwndEdit || !lszFile) {
        dprintf1((TEXT("EditOpenFile: Invalid window or filename")));
        return FALSE;
    }

    /* Open the file for reading */

#ifdef UNICODE
    fh = CreateFile(lszFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0);
    if (fh == INVALID_HANDLE_VALUE) {
        dprintf1((TEXT("Failed to open: %s"), lszFile));
        return FALSE;
    }
#else
    fh = OpenFile(lszFile, &of, OF_READ);
    if (fh == HFILE_ERROR) {
        dprintf1((TEXT("Failed to open: %s"), lszFile));
        return FALSE;
    }
#endif

	nFileLen = (UINT)GetFileSize((HANDLE)fh, NULL);
	if (HFILE_ERROR == nFileLen) {
        dprintf1((TEXT("Failed to find file size: %s"), lszFile));
        return FALSE;
	}

    /*
     * Create a pointer to a region of memory large enough to hold the entire
     * contents of the file. If this was successful, then read the file into
     * this region, and use this region as the text for the edit control.
     * Finally, free up the region and its pointer, and close the file.
     *
     */

    lszText = (LPTSTR)GAllocPtr(nFileLen+1);   // Note: no *sizeof(TCHAR)
    if (NULL != lszText) {

		BOOL fReturn;
        /* This could take a while - show the hourglass cursor */

        hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

        /* Read the file and copy the contents into the edit control */

        dprintf3((TEXT("reading file...")));

#ifdef UNICODE
        {
        DWORD bytesRead;

        if (ReadFile(fh, lszText, nFileLen, &bytesRead, NULL)) {
			lszText[bytesRead]=0;
			dprintf2((TEXT("File loaded ok")));
			SetWindowTextA(hwndEdit, (LPSTR)lszText); // Until we have UNICODE files
			fReturn = TRUE;
		} else {
			dprintf2((TEXT("Error loading file")));
			fReturn = FALSE;
		}

        }
        /* Free up the memory, close the file, and restore the cursor */

        GFreePtr(lszText);
        CloseHandle(fh);
#else
        if ((_lread((HFILE)fh, lszText, nFileLen)) == nFileLen) {
			lszText[nFileLen/sizeof(TCHAR)]=0;
			dprintf2((TEXT("File loaded ok")));
			SetWindowText(hwndEdit, lszText);
			fReturn = TRUE;
		} else {
			dprintf2((TEXT("Error loading file")));
			fReturn = FALSE;
		}

        /* Free up the memory, close the file, and restore the cursor */

        GFreePtr(lszText);
        _lclose((HFILE)fh);
#endif
        SetCursor(hcur);

        return fReturn;
    }

    /*
     * We couldn't allocate the required memory, so close the file and
     * return FALSE.
     *
     */

    dprintf1((TEXT("Failed memory allocation for file")));
#ifdef UNICODE
    CloseHandle(fh);
#else
    _lclose((HFILE)fh);
#endif
    return FALSE;
}


/*----------------------------------------------------------------------------*\
|   EditSaveFile(hwndEdit, lszFile)                                            |
|                                                                              |
|   Description:                                                               |
|       This function saves the contents of the edit control with the handle   |
|       <hwndEdit> into the file  <lszFile>, creating the file if required.    |
|                                                                              |
|   Arguments:                                                                 |
|       hwndEdit        window handle of the edit box control                  |
|       lszFile         filename of the file to be saved                       |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if the operation was successful, else FALSE                       |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL               EditSaveFile(
    HWND    hwndEdit,
    LPTSTR  lszFile)
{
#ifdef UNICODE
    HANDLE      fh;                 /* DOS file handle returned by OpenFile   */
    DWORD       dwBytesWritten;
#else
    OFSTRUCT    of;                 /* structure used by the OpenFile routine */
    HFILE       fh;                 /* DOS file handle returned by OpenFile   */
#endif
    LPTSTR      lszText;            /* pointer to the saved file's text       */
    int         nFileLen;           /* length, in bytes, of the saved file    */
    HCURSOR     hcur;               /* handle to the pre-hourglass cursor     */

    /* If a valid window handle or a filename was not specified, then exit */
    dprintf2((TEXT("EditSaveFile:  Saving %s"), lszFile));

    if (!hwndEdit || !lszFile) {
        dprintf1((TEXT("EditSaveFile: Invalid window or filename")));
        return FALSE;
    }

    /* Create (or overwrite) the save file */

#ifdef UNICODE
    fh = CreateFile(lszFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, 0);
    if (fh == INVALID_HANDLE_VALUE) {
        dprintf1((TEXT("EditSaveFile: Error opening file")));
        return FALSE;
    }
#else
    fh = OpenFile(lszFile, &of, OF_CREATE);
    if (fh == HFILE_ERROR) {
        dprintf1((TEXT("EditSaveFile: Error opening file")));
        return FALSE;
    }
#endif

    /* Find out how big the contents of the edit box are */

    nFileLen = GetWindowTextLength(hwndEdit);
	// nFileLen = nFileLen*sizeof(TCHAR);  We write ASCII

    /*
     * Create a pointer to a region of memory large enough to hold the entire
     * contents of the edit box. If this was successful, then read the contents
     * of the edit box into this region, and write the contents of this region
     * into the save file. Finally, free up the region and its pointer, and
     * close the file.
     *
     */

    lszText = (LPTSTR)GAllocPtr(nFileLen);
    if (NULL != lszText) {

        /* This could take a while - show the hourglass cursor */

        hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

        /* Read the contents of the edit box, and write it to the save file */

        GetWindowTextA(hwndEdit, (LPSTR)lszText, nFileLen);  // Save ASCII file

#ifdef UNICODE
		WriteFile(fh, lszText, nFileLen, &dwBytesWritten, NULL);
#else
        _lwrite(fh, lszText, nFileLen);
#endif


        /* Free up the memory, close the file, and restore the cursor */

        GFreePtr(lszText);
#ifdef UNICODE
		CloseHandle(fh);
#else
        _lclose(fh);
#endif
        SetCursor(hcur);

        return TRUE;
    }

    /*
     * We couldn't allocate the required memory, so close the file and
     * return FALSE.
     */

    _lclose((HFILE)fh);
    return FALSE;
}


/*----------------------------------------------------------------------------*\
|   EditGetLineCount(hwndEdit)                                                    |
|                                                                              |
|   Description:                                                               |
|       This function finds out how many lines of text are in the edit box and |
|       returns this value.                                                    |
|                                                                              |
|   Arguments:                                                                 |
|       hwndEdit           window handle of the edit box control                  |
|                                                                              |
|   Returns:                                                                   |
|       The number of lines of text in the edit control.                       |
|                                                                              |
\*----------------------------------------------------------------------------*/

DWORD EditGetLineCount(
    HWND   hwndEdit)
{
    return SendMessage(hwndEdit, EM_GETLINECOUNT, 0, 0L);
}


/*----------------------------------------------------------------------------*\
|   EditGetLine(hwndEdit, iLine, lszLineBuffer, cch)                           |
|                                                                              |
|   Description:                                                               |
|       This function retrieves the contents of line # <iLine> from the edit   |
|       box control with handle <hwndEdit>.  If <iLine> is out of range (that  |
|       number line does not exist in the multi line edit field) then FALSE is |
|       returned.  Otherwise the line is copied into the buffer pointed to by  |
|       <lszLineBuffer> with white space removed.                              |
|       The string is also null terminated even if it means truncation.        |
|                                                                              |
|   Arguments:                                                                 |
|       hwndEdit        window handle of the edit box control                  |
|       iLine           line # to get the contents of                          |
|       lszLineBuffer   pointer to the buffer to copy the line to              |
|       cch             max # of characters to copy (MIN value on entry==2)    |
|                                                                              |
|   Returns:                                                                   |
|       TRUE.                                                                  |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL EditGetLine(
    HWND    hwndEdit,
    int     iLine,
    LPTSTR  lszLineBuffer,
    int     cch)
{
    int     nLines;             /* total number of lines in the edit box */

    /*
     * Find out how many lines are in the edit control. If the requested line
     * is out of range, then return.
     */

    nLines = (int)EditGetLineCount(hwndEdit);
    if (iLine < 0 || iLine >= nLines) {
        if (iLine!= nLines) {  // Probably because the user pressed Enter
                               // and the line number is beyond the end
		    dprintf1((TEXT("Requested line count %d is out of range (%d)"), iLine, nLines));
        }
        return *lszLineBuffer = 0;
		/* This sets the buffer to null and returns FALSE */
	}

    /* Read the requested line into the string pointed to by <lszLineBuffer> */
	/* NOTE:  This routine is always called with cch at least TWO */

    *((LPWORD)lszLineBuffer) = (WORD)cch;
    cch = (int)SendMessage(hwndEdit, EM_GETLINE, iLine, (LONG)(LPTSTR)lszLineBuffer);
	/* The returned string is NOT null terminated */

    /* Strip trailing white spaces from the string, and null-terminate it */
    while(cch > 0 && ISWHITE(lszLineBuffer[cch-1])) {
        cch--;
	}
    lszLineBuffer[cch] = 0;

    return TRUE;
}


/*----------------------------------------------------------------------------*\
|   EditGetCurLine(hwndEdit)                                                      |
|                                                                              |
|   Description:                                                               |
|       This function retrieves the line number of the current line in the     |
|       edit box control with handle <hwndEdit>. It returns this line number.     |
|                                                                              |
|   Arguments:                                                                 |
|       hwndEdit           window handle of the edit box control                  |
|                                                                              |
|   Returns:                                                                   |
|       The line number of the current line.                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/

int EditGetCurLine(
    HWND    hwndEdit)
{
    int iLine;                  /* Line number of the currently active line   */

    iLine = (int)SendMessage(hwndEdit, EM_LINEFROMCHAR, (WPARAM)-1, 0L);

    if (iLine < 0) {
        iLine = 0;
	}

    return iLine;
}


/*----------------------------------------------------------------------------*\
|   EditSetCurLine(hwndEdit, iLine)                                               |
|                                                                              |
|   Description:                                                               |
|       This function sets the current line in the edit box control with       |
|       handle <hwndEdit> to the number given in <iLine>.                         |
|                                                                              |
|   Arguments:                                                                 |
|       hwndEdit           window handle of the edit box control                  |
|       iLine           the line number to be made the current line            |
|                                                                              |
|   Returns:                                                                   |
|       void                                                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/

void EditSetCurLine(
    HWND    hwndEdit,
    int     iLine)
{
    int off;

    off = (int)SendMessage(hwndEdit, EM_LINEINDEX, iLine, 0L);
    SendMessage(hwndEdit, EM_SETSEL, off, off);

}

/*----------------------------------------------------------------------------*\
|   EditSelectLine(hwndEdit, iLine)                                               |
|                                                                              |
|   Description:                                                               |
|       This function selects line # <iLine> in the edit box control with      |
|       handle <hwndEdit>.                                                        |
|                                                                              |
|   Arguments:                                                                 |
|       hwndEdit           window handle of the edit box control                  |
|       iLine           the line number to be selected                         |
|                                                                              |
|   Returns:                                                                   |
|       void                                                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/

void EditSelectLine(
    HWND    hwndEdit,
    int     iLine)
{
    int offS;
    int offE;

    offS = (int)SendMessage(hwndEdit, EM_LINEINDEX, iLine, 0L);
    offE = (int)SendMessage(hwndEdit, EM_LINEINDEX, iLine+1, 0L);


    if (offE < offS) {	  /* Select to the end */
        offE = -1;
	}

    SendMessage(hwndEdit, EM_SETSEL, offS, offE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mcitest\mcimain.h ===
/*----------------------------------------------------------------------------*\
|   mcitest.h - constant definitions for MCI test                              |
|                                                                              |
|                                                                              |
|   History:                                                                   |
|       01/01/88 toddla     Created                                            |
|       11/04/90 w-dougb    Commented & formatted the code to look pretty      |
|                                                                              |
\*----------------------------------------------------------------------------*/

        // Name of the main dialog box.  Used in MCITEST.C and MCIMAIN.DLG
#define MCITESTER   MciTester

/*----------------------------------------------------------------------------*\
|                                                                              |
|   c o n s t a n t   d e f i n i t i o n s                                    |
|                                                                              |
\*----------------------------------------------------------------------------*/

#define ID_INPUT           0x101
#define ID_OUTPUT          0x102
#define ID_ERRORCODE       0x103
#define ID_NOT_SUCCESS     0x104
#define ID_NOT_SUPER       0x105
#define ID_NOT_ABORT       0x106
#define ID_NOT_FAIL        0x107
#define ID_DEVICE_LIST     0x108
#define ID_END_DEVICE_LIST 0x109
#define ID_GO              0x200
#define ID_STEP            0x201
#define ID_EXIT            0x202


#define ID_RUNCOUNT        0x205
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mcitest\fileopen.c ===
/*
    This is a very simple file open dbox.
*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include "mcitest.h"
#include "commdlg.h"


// global stuff

static TCHAR szSearchSpec[_MAX_PATH];

// routine to invoke the standard file open dialog box

int DlgOpen(HANDLE hModule, HWND hParent, LPTSTR lpName, int count, UINT flags)
{
	OPENFILENAME ofn;
    strcpy(szSearchSpec, lpName);
    if (strlen(szSearchSpec) == 0) strcpy(szSearchSpec, TEXT("*.*"));
    dprintf3((TEXT("Search spec: %s"), szSearchSpec));

    *lpName = 0;

    ofn.lStructSize         = sizeof(ofn);
    ofn.hwndOwner           = hParent;
    ofn.hInstance           = hModule;
    ofn.lpstrFilter         = TEXT("MCI Files\0*.mci\0All Files\0*.*\0");
    ofn.lpstrCustomFilter   = NULL;
    ofn.nMaxCustFilter      = 0;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = lpName;
    ofn.nMaxFile            = count;
    ofn.lpstrFileTitle      = NULL;
    ofn.nMaxFileTitle       = 0;
    ofn.lpstrInitialDir     = TEXT(".mci");
    ofn.Flags               = flags;
    ofn.nFileOffset         = 0;
    ofn.nFileExtension      = 0;
    ofn.lpstrDefExt         = szSearchSpec;
    ofn.lCustData           = 0;
    ofn.lpfnHook            = NULL;
    ofn.lpTemplateName      = NULL;


    if (flags & OFN_FILEMUSTEXIST) {
        ofn.lpstrTitle          = TEXT("File Open");
        dprintf3((TEXT("Calling GetOpenFileName")));
        return GetOpenFileName(&ofn);
    } else {
        ofn.lpstrTitle          = TEXT("File Save");
        dprintf3((TEXT("Calling GetSaveFileName")));
        return GetSaveFileName(&ofn);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mcitest\mcitest.h ===
/*----------------------------------------------------------------------------*\
|   mcitest.h - menu definitions, etc. for MCI test                            |
|                                                                              |
|                                                                              |
|   History:                                                                   |
|       01/01/88 toddla     Created                                            |
|       11/04/90 w-dougb    Commented & formatted the code to look pretty      |
|       05/29/91 NigelT     Ported to Win32
|                                                                              |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
|                                                                              |
|   c o n s t a n t   d e f i n i t i o n s                                    |
|                                                                              |
\*----------------------------------------------------------------------------*/

#ifdef UNICODE
	#define strcpy lstrcpy
	#define strlen lstrlen
#endif
#include <mmsystem.h>

#ifndef RC_INVOKED  /* These are defined to RC */
#define STATICDT static
#define STATICFN static
#define STATIC   static

#if DBG
    #undef STATICDT
    #undef STATICFN
    #undef STATIC
    #define STATICDT
    #define STATICFN
    #define STATIC
#endif  /* DBG */

#endif  /* RC_INVOKED */

/* Resource IDs of the About box, main test box, and error box */

#define IDD_ABOUTBOX      1	// Descriptive box
#define IDD_MCITEST       2	// Main dialog
#define IDD_ERRORDLG      3	// Error box dialog
#define IDD_DEVICES       4	// Device list dialog
						
#define IDI_MCITEST       5	// Icon
#define IDM_MCITEST		  6	// Menu
#define IDA_MCITEST       7	// Accelerator table

/* Controls for main dialog
 */
#include "mcimain.h"

/* Menu IDs of the various menu options */

#define MENU_ABOUT              20
#define MENU_EXIT               21
#define MENU_START_TEST         22

#define MENU_OPEN               10
#define MENU_SAVE               11
#define MENU_SAVEAS             12

#define MENU_DEVICES            30

#if DBG
#define IDM_DEBUG0         1000
#define IDM_DEBUG1         1001
#define IDM_DEBUG2         1002
#define IDM_DEBUG3         1003
#define IDM_DEBUG4         1004
#endif

typedef UINT MMMESSAGE;

/* mcitest.c */

extern TCHAR aszAppName[];
extern HWND hwndMainDlg;

/* fileopen.c */
extern int DlgOpen(HANDLE hModule, HWND hParent, LPTSTR lpName, int count, UINT flags);

/***************************************************************************

    DEBUGGING SUPPORT

***************************************************************************/

#if DBG

    extern void dDbgSetDebugMenuLevel(int i);
    extern void dDbgOut(LPTSTR lpszFormat, ...);
    extern int  dDbgGetLevel(LPTSTR lpszModule);
    extern void dDbgSaveLevel(LPTSTR lpszModule, int level);
    extern void dDbgAssert(LPTSTR exp, LPTSTR file, int line);

    extern int __iDebugLevel;
    DWORD __dwEval;

    #define dGetDebugLevel(lpszModule) (__iDebugLevel = dDbgGetLevel(lpszModule))
    #define dSaveDebugLevel(lpszModule) (dDbgSaveLevel(lpszModule, __iDebugLevel))

    #define dprintf( _x_ )                          dDbgOut _x_
    #define dprintf1( _x_ ) if (__iDebugLevel >= 1) dDbgOut _x_
    #define dprintf2( _x_ ) if (__iDebugLevel >= 2) dDbgOut _x_
    #define dprintf3( _x_ ) if (__iDebugLevel >= 3) dDbgOut _x_
    #define dprintf4( _x_ ) if (__iDebugLevel >= 4) dDbgOut _x_

    #define WinAssert(exp) \
        ((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))

    #define WinEval(exp) \
        ((__dwEval=(DWORD)(exp)),  \
		  __dwEval ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

#else

    #define dGetDebugLevel(lpszModule) 0
    #define dSaveDebugLevel(lpszModule) 0

    #define dprintf( _x_ )
    #define dprintf1( _x_ )
    #define dprintf2( _x_ )
    #define dprintf3( _x_ )
    #define dprintf4( _x_ )

    #define WinAssert(exp) 0
    #define WinEval(exp) (exp)

#endif


//  stuff which is a bit bogus

#ifndef GWW_HMODULE
#define GWW_HMODULE GWW_HINSTANCE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mcitest\edit.h ===
/*----------------------------------------------------------------------------*\
|   edit.h - routines for dealing with multi-line edit controls                |
|                                                                              |
|                                                                              |
|   History:                                                                   |
|       01/01/88 toddla     Created                                            |
|       11/04/90 w-dougb    Commented & formatted the code to look pretty      |
|                                                                              |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
|                                                                              |
|   f u n c t i o n   p r o t o t y p e s                                      |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL EditOpenFile(HWND hwndEdit, LPTSTR lszFile);
BOOL EditSaveFile(HWND hwndEdit, LPTSTR lszFile);
DWORD EditGetLineCount(HWND hwndEdit);
BOOL EditGetLine(HWND hwndEdit, int iLine, LPTSTR pch, int cch);
int  EditGetCurLine(HWND hwndEdit);
void EditSetCurLine(HWND hwndEdit, int iLine);
void EditSelectLine(HWND hwndEdit, int iLine);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mcitest\mcitest.c ===
/* mcitest.c - WinMain(), main dialog box and support code for MCITest.
 *
 * MCITest is a Windows with Multimedia sample application illustrating
 * the use of the Media Control Interface (MCI). MCITest puts up a dialog
 * box allowing you to enter and execute MCI string commands.
 *
 *    (C) Copyright Microsoft Corp. 1991 - 1995.  All rights reserved.
 *
 *    You have a royalty-free right to use, modify, reproduce and
 *    distribute the Sample Files (and/or any modified version) in
 *    any way you find useful, provided that you agree that
 *    Microsoft has no warranty obligations or liability for any
 *    Sample Application Files which are modified.
 */

/*----------------------------------------------------------------------------*\
|   mcitest.c - A testbed for MCI                                              |
|                                                                              |
|                                                                              |
|   History:                                                                   |
|       01/01/88 toddla     Created                                            |
|       03/01/90 davidle    Modified quick app into MCI testbed                |
|       09/17/90 t-mikemc   Added Notification box with 3 notification types   |
|       11/02/90 w-dougb    Commented & formatted the code to look pretty      |
|       05/29/91 NigelT     ported to Win32
|       02/05/92 SteveDav   Merged latest Win 3.1 stuff
|                                                                              |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
|                                                                              |
|   i n c l u d e   f i l e s                                                  |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include "mcitest.h"
#include "mcimain.h"
#include "edit.h"
#include "commdlg.h"


/*----------------------------------------------------------------------------*\
|                                                                              |
|   c o n s t a n t   a n d   m a c r o   d e f i n i t i o n s                |
|                                                                              |
\*----------------------------------------------------------------------------*/

#define BUFFER_LENGTH 256
#define SLASH(c)      ((c) == '/' || (c) == '\\')


/*----------------------------------------------------------------------------*\
|                                                                              |
|   g l o b a l   v a r i a b l e s                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/
#ifndef STATICDT
  #if DBG
        #define STATICDT
  #else
        #define STATICDT static
  #endif
#endif

STATICDT int         nLastNumberOfDevices = 0;
STATICDT HANDLE      hAccTable;
STATICDT HANDLE      hInstApp;
         HWND        hwndMainDlg = 0;
STATICDT HWND        hwndEdit = 0;
STATICDT HWND        hwndDevices = 0;
STATICDT TCHAR       aszMciFile[BUFFER_LENGTH] = TEXT("");
STATICDT TCHAR       aszBuffer[BUFFER_LENGTH];
STATICDT TCHAR       aszExt[] = TEXT("*.mci");
         TCHAR       aszAppName[] = TEXT("MCITest");
STATICDT TCHAR       aszMainTextFormat[] = TEXT("%s - %s");
STATICDT TCHAR       aszDeviceTextFormat[] = TEXT("Open MCI Devices(count=%d)");
STATICDT TCHAR       aszNULL[] = TEXT("");
STATICDT TCHAR       aszTRUE[] = TEXT("TRUE");
STATICDT TCHAR       aszFALSE[] = TEXT("FALSE");
STATICDT TCHAR       aszEOL[] = TEXT("\r\n");
STATICDT TCHAR       aszOpenFileTitle[] = TEXT("Open MCITest File");
STATICDT TCHAR       aszSaveFileTitle[] = TEXT("Save MCITest File");
STATICDT TCHAR       aszSaveFileControl[] = TEXT("Save File &Name");
STATICDT TCHAR       aszProfileSection[] = TEXT("extensions");
STATICDT TCHAR       aszProfileKey[] = TEXT("mcs");
STATICDT TCHAR       aszProfileSetting[] = TEXT("mcitest.exe ^.mcs");
STATICDT TCHAR       aszMciTester[] = TEXT("MciTester");

/*----------------------------------------------------------------------------*\
|                                                                              |
|   f u n c t i o n   d e f i n i t i o n s                                    |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL mcitester(HWND hwnd, UINT Msg, LONG wParam, LONG lParam);
PTSTR FileName(PTSTR szPath);
STATICFN void update_device_list(void);
DWORD sendstring(HWND hwndDlg, PTSTR strBuffer);
void execute( HWND hwndDlg, BOOL fStep);
void OpenMciFile( HWND hwndDlg, LPTSTR szFile);
BOOL AppInit(int argc, char *argv[]);
BOOL ErrDlgFunc( HWND hwndDlg, UINT Msg, LONG w, LONG l );
void create_device_list(void);
STATICFN BOOL devices(HWND hwndDlg, UINT Msg, LONG wParam, LONG lParam);
STATICFN void ProcessInternalCommand(HWND hDlg, LPTSTR aszBuffer);

/*----------------------------------------------------------------------------*\
|   AboutDlgProc( hwndDlg, Message, wParam, lParam )                           |
|                                                                              |
|   Description:                                                               |
|       This function handles messages belonging to the "About" dialog box.    |
|       The only message that it looks for is WM_COMMAND, indicating the user  |
|       has pressed the "OK" button.  When this happens, it takes down         |
|       the dialog box.                                                        |
|                                                                              |
|   Arguments:                                                                 |
|       hwndDlg         window handle of the about dialog window               |
|       Message         message number                                         |
|       wParam          message-dependent parameter                            |
|       lParam          message-dependent parameter                            |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if the message has been processed, else FALSE                     |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL AboutDlgProc(
    HWND    hwndDlg,
    UINT    Msg,
    LONG    wParam,
    LONG    lParam)
{
        dprintf4((TEXT("AboutDlgProc")));
    switch (Msg) {
    case WM_COMMAND:

        if (LOWORD(wParam) == IDOK) {
            EndDialog(hwndDlg,TRUE);
        }
        break;

    case WM_INITDIALOG:
        return TRUE;

    }

    return FALSE;
}

/*----------------------------------------------------------------------------*\
|   FileName(szPath)                                                           |
|                                                                              |
|   Description:                                                               |
|       This function takes the full path\filename string specified in <szPath>|
|       and returns a pointer to the first character of the filename in the    |
|       same string.                                                           |
|                                                                              |
|   Arguments:                                                                 |
|       szPath          pointer to the full path\filename string               |
|                                                                              |
|   Returns:                                                                   |
|       a pointer to the first character of the filename in the same string    |
|                                                                              |
\*----------------------------------------------------------------------------*/

PTSTR FileName(
    PTSTR   szPath)
{
    PTSTR   szCurrent;               /* temporary pointer to the string        */

    /* Scan to the end of the string */

    for (szCurrent = szPath; *szCurrent; szCurrent++)
    {} ;

    /*
     * Now start scanning back towards the beginning of the string until
     * a slash (\) character, colon, or start of the string is encountered.
     */

    for (; szCurrent >= szPath
               && !SLASH(*szCurrent)
                   && *szCurrent != ':'
                 ; szCurrent--)
    {} ;

        /* This should be done by calling a Win 32 function, e.g. GetFullPathName
         */

    /* Now pointing to the char before the first char in the filename.
     */
    return ++szCurrent;
}

/*----------------------------------------------------------------------------*\
|   OpenMciFile( hwndDlg, szFile )                                                |
|                                                                              |
|   Description:                                                               |
|       This function opens the MCI file specified by <szFile> and updates the |
|       main window caption to display this file name along with the app name. |
|                                                                              |
|   Arguments:                                                                 |
|       hwndDlg            window handle of the main dialog window                |
|       szFile          pointer to the string containing the filename to be    |
|                        opened                                                |
|   Returns:                                                                   |
|       void                                                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/

void OpenMciFile(
    HWND    hwndDlg,
    LPTSTR   lszFile)
{
    dprintf2((TEXT("OpenMciFile: %s"), lszFile));

    if (EditOpenFile(hwndEdit, lszFile)) {

        strcpy(aszMciFile, lszFile);
        wsprintf(aszBuffer, aszMainTextFormat, (LPTSTR)aszAppName,
           (LPTSTR)FileName(aszMciFile));
        dprintf3((TEXT("Set caption: %s"), aszBuffer));
        SetWindowText(hwndDlg, aszBuffer);
    }
}

/*----------------------------------------------------------------------------*\
|   get_number_of_devices()                                                    |
|                                                                              |
|   Description:                                                               |
|       This function sends a command to MCI querying it as to how many        |
|       are currently open in the system. It returns the value provided by MCI.|
|                                                                              |
|   Arguments:                                                                 |
|       none                                                                   |
|                                                                              |
|   Returns:                                                                   |
|       The number of MCI devices currently open, or 0 if an error occurred.   |
|                                                                              |
\*----------------------------------------------------------------------------*/

int get_number_of_devices(
    void)
{
    MCI_SYSINFO_PARMS sysinfo;      /* Parameter structure used for getting
                                        information about the MCI devices in
                                        the system                            */
    DWORD dwDevices;                /* count of open devices                  */

    /*
     * Set things up so that MCI puts the number of open devices directly
     * into <dwDevices>.
     */

    sysinfo.lpstrReturn = (LPTSTR)(LPDWORD)&dwDevices;
    sysinfo.dwRetSize = sizeof(dwDevices);

    /*
     * Send MCI a command querying all devices in the system to see if they
     * are open. If the command was successful, return the number provided by
     * MCI. Otherwise, return 0.
     *
     */

    if (mciSendCommand (MCI_ALL_DEVICE_ID,
                        MCI_SYSINFO,
                        (MCI_SYSINFO_OPEN | MCI_SYSINFO_QUANTITY),
                        (DWORD)(LPMCI_SYSINFO_PARMS)&sysinfo) != 0)
        return 0;
    else
        return (int)dwDevices;
}


/*----------------------------------------------------------------------------*\
|   update_device_list()                                                       |
|                                                                              |
|   Description:                                                               |
|       This function updates the list of devices displayed in the Devices     |
|       dialog.                                                                |
|                                                                              |
|   Arguments:                                                                 |
|       none                                                                   |
|                                                                              |
|   Returns:                                                                   |
|       void                                                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/

STATICFN void update_device_list(
    void)
{
        TCHAR aszBuf[BUFFER_LENGTH];     /* string used for several things       */
    MCI_SYSINFO_PARMS sysinfo;      /* Parameter structure used for getting
                                          information about the devices in the
                                          system                              */
    HWND              hwndList;     /* handle to the Devices listbox window   */
    int               nDevices;
    int               nCurrentDevice;

    /* If the Devices dialog is not present, then return */

    if (hwndDevices == 0) {
        return;
    }

    /* Find out how many devices are currently open in the system */

    nDevices = get_number_of_devices();

    /* Update the dialog caption appropriately */

        wsprintf(aszBuf, aszDeviceTextFormat, nDevices);
        SetWindowText(hwndDevices, aszBuf);

    /* Get a handle to the dialog's listbox, and prepare it for updating */

    hwndList = GetDlgItem (hwndDevices, ID_DEVICE_LIST);
    SendMessage (hwndList, LB_RESETCONTENT, 0, 0L);

        if (nDevices) {
                SendMessage (hwndList, WM_SETREDRAW, FALSE, 0L);
        }

    /*
     * Get the name of each open device in the system, one device at a time.
     * Add each device's name to the listbox.
     */

    for (nCurrentDevice = 1; nCurrentDevice <= nDevices; ++nCurrentDevice) {

        sysinfo.dwNumber = nCurrentDevice;
        sysinfo.lpstrReturn = (LPTSTR)&aszBuf;
        sysinfo.dwRetSize = sizeof(aszBuf);

        /* If an error is encountered, skip to the next device.
         */
        if (mciSendCommand(MCI_ALL_DEVICE_ID, MCI_SYSINFO,
                            MCI_SYSINFO_OPEN | MCI_SYSINFO_NAME,
                            (DWORD)(LPMCI_SYSINFO_PARMS)&sysinfo) != 0) {
            continue;
                }

        /* Redraw the list when all device names have been added.
         */
        if (nCurrentDevice == nDevices) {
                        /* About to add the last device - allow redrawing */
            SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);
                }

        /* Add the device name to the listbox.
         */
        SendMessage(hwndList, LB_ADDSTRING, 0, (LONG)(LPTSTR)aszBuf);
    }

    /* Remember the number of open devices we found this time */

    nLastNumberOfDevices = nDevices;
}

/*----------------------------------------------------------------------------*\
|   sendstring( hwndDlg, strBuffer )                                           |
|                                                                              |
|   Description:                                                               |
|       This function sends the string command specified in <strBuffer> to MCI |
|       via the MCI string interface. Any message returned by MCI is displayed |
|       in the 'MCI output' box. Any error which may have occurred is displayed|
|       in the 'Error' box'.                                                   |
|                                                                              |
|   Arguments:                                                                 |
|       hwndDlg            window handle of the main dialog window                |
|       strBuffer       pointer to the string containing the string command to |
|                        be executed                                           |
|   Returns:                                                                   |
|       void                                                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/

DWORD sendstring(
    HWND    hwndDlg,
    PTSTR    strBuffer)
{
    TCHAR   aszReturn[BUFFER_LENGTH];       /* string containing the message
                                                returned by MCI               */
    DWORD   dwErr;                          /* variable containing the return
                                                code from the MCI command     */
    dprintf2((TEXT("sendstring: %s"), strBuffer));

    /* Uncheck the notification buttons */

    CheckDlgButton (hwndDlg, ID_NOT_SUCCESS, FALSE);
    CheckDlgButton (hwndDlg, ID_NOT_SUPER, FALSE);
    CheckDlgButton (hwndDlg, ID_NOT_ABORT, FALSE);
    CheckDlgButton (hwndDlg, ID_NOT_FAIL, FALSE);

    /* Send the string command to MCI */

    dwErr = mciSendString(strBuffer, aszReturn, sizeof(aszReturn), hwndDlg);

    /* Put the text message returned by MCI into the 'MCI Output' box */

    SetDlgItemText (hwndDlg, ID_OUTPUT, aszReturn);

    /*
     * Decode the error # returned by MCI, and display the string in the
     * 'Error' box.
     */

    mciGetErrorString(dwErr, strBuffer, BUFFER_LENGTH);
    SetDlgItemText(hwndDlg, ID_ERRORCODE, strBuffer);

    /* Update the internal list of currently open devices */

    update_device_list();
    return dwErr;
}


/*----------------------------------------------------------------------------*\
|   ErrDlgFunc( hwndDlg, Msg, wParam, lParam )                                    |
|                                                                              |
|   Description:                                                               |
|       This function is the callback function for the dialog box which           |
|       occurs during the execution of a error in a loop of MCITEST commands   |
|       It displays Abort, Continue and Ignore buttons                         |
|                                                                              |
|   Arguments:                                                                 |
|       hwndDlg            window handle of the error message dialog window       |
|       Msg             message number                                         |
|       wParam          message-dependent parameter                            |
|       lParam          message-dependent parameter                            |
|                                                                              |
|   Returns:                                                                   |
|       normal message passing return values                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/


BOOL ErrDlgFunc(
    HWND    hwndDlg,
    UINT    Msg,
    LONG    wParam,
    LONG    lParam)
{
    dprintf4((TEXT("ErrDlgFunc")));
    switch( Msg ) {
        case WM_INITDIALOG:
            return TRUE;


        case WM_COMMAND:
            switch( LOWORD(wParam) ) {              // button pushed
                case IDABORT:
                case IDOK:
                case IDIGNORE:
                        EndDialog( hwndDlg, LOWORD(wParam) ); // return button ID
                        break;
                }
            break;
    }
    return( FALSE );
}

/*----------------------------------------------------------------------------*\
|   execute( hwndDlg, fStep )                                                  |
|                                                                              |
|   Description:                                                               |
|       This function executes the MCI command which is currently selected in  |
|       the edit box. If <fStep> is true, then only this one line will be      |
|       executed. Otherwise, every line from the currently selected line to    |
|       the last line in the edit box will be executed sequentially.           |
|                                                                              |
|   Arguments:                                                                 |
|       hwndDlg         window handle of the main dialog window                |
|       fSingleStep     flag indicating whether or not to work in 'single step'|
|                        mode                                                  |
|   Returns:                                                                   |
|       void                                                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/

void execute(
    HWND    hwndDlg,
    BOOL    fSingleStep)
{
    int  iLine;             /* line # of the command currently being executed
                                in the edit box                               */
    int  n=0;               /* counter variable                               */
    int  runcount = 1;
    int  count;
    int  iLineStart;
    BOOL fIgnoreErrors = FALSE;

    runcount = GetDlgItemInt(hwndDlg, ID_RUNCOUNT, NULL, TRUE);

    /*
     * Go through this loop for every line in the edit box from the currently
     * selected line to the last line, or a single line if in single step mode
     */

    iLineStart = EditGetCurLine(hwndEdit);
        dprintf2((TEXT("Called to execute %d lines from line %d"), runcount, iLineStart));

    for (count = runcount; count-- > 0; )
    {
        for (iLine = iLineStart;
            EditGetLine(hwndEdit, iLine, aszBuffer, sizeof(aszBuffer));
            iLine++ ) {

            /* If we hit a comment line or a blank line, skip to the next line */

            if (*aszBuffer == ';' || *aszBuffer == 0) {
                continue;
                        }

            if (*aszBuffer == '!' ) {  // Internal command
                ProcessInternalCommand(hwndDlg, aszBuffer+1);
                continue;
                        }

            /* Select the line that is about to be processed */

            EditSelectLine(hwndEdit,iLine);

            /*
             * If we're in 'single step' mode and we've already processed one
             * line, then break out of the loop (and exit the routine).
             */

            if (fSingleStep && ++n == 2) {
                break;
            }

            /*
            * Send the command on the current line to MCI via the string
            * interface.
            */

            if (sendstring(hwndDlg, aszBuffer) != 0
              && !fIgnoreErrors
              && runcount > 1
              && !fSingleStep) {

                int nRet;

                nRet = DialogBox(hInstApp, MAKEINTRESOURCE(IDD_ERRORDLG),
                                 hwndDlg, (DLGPROC)ErrDlgFunc);

                if (nRet == IDABORT)  { goto exit_fn; }
                if (nRet == IDIGNORE) { fIgnoreErrors = TRUE; }

            }
        }
        SetDlgItemInt (hwndDlg, ID_RUNCOUNT, count, TRUE);
        if (fSingleStep) { break; }
    }
exit_fn:;
    SetDlgItemInt (hwndDlg, ID_RUNCOUNT, runcount, TRUE);
}


/*----------------------------------------------------------------------------*\
|   devices( hwndDlg, uMessage, wParam, lParam )                                  |
|                                                                              |
|   Description:                                                               |
|       This function handles messages belonging to the "List of open devices" |
|       dialog box. The only message that it looks for is WM_COMMAND,          |
|       indicating the user has pressed the "OK" button.  When this happens,   |
|       it takes down the dialog box.                                          |
|                                                                              |
|   Arguments:                                                                 |
|       hwndDlg            window handle of the Devices dialog window             |
|       uMessage        message number                                         |
|       wParam          message-dependent parameter                            |
|       lParam          message-dependent parameter                            |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if the message has been processed, else FALSE                     |
|                                                                              |
\*----------------------------------------------------------------------------*/

STATICFN BOOL devices(
    HWND    hwndDlg,
    UINT    Msg,
    LONG    wParam,
    LONG    lParam)
{
    switch (Msg) {

    case WM_COMMAND:

                dprintf4((TEXT("Devices -- WM_COMMAND")));
        switch (LOWORD(wParam)) {

        case ID_END_DEVICE_LIST:

            hwndDevices = 0;
            EndDialog(hwndDlg,TRUE);

            break;
        }

        break;
    }

    return FALSE;
}



/*----------------------------------------------------------------------------*\
|   create_device_list()                                                       |
|                                                                              |
|   Description:                                                               |
|       This function creates the Devices dialog box and updates the list of   |
|       open devices displayed in it.                                          |
|                                                                              |
|   Arguments:                                                                 |
|       none                                                                   |
|                                                                              |
|   Returns:                                                                   |
|       void                                                                   |
|                                                                              |
\*----------------------------------------------------------------------------*/

void create_device_list(
    void)
{
    /* Create the Devices dialog box */

    hwndDevices = CreateDialog(hInstApp, MAKEINTRESOURCE(IDD_DEVICES),
                               hwndMainDlg, (DLGPROC)devices);

    if (hwndDevices == NULL) {
                dprintf1((TEXT("NULL hwndDevices")));
        return;
    }

    /* Update the information displayed in the listbox */

    update_device_list();
}


/*----------------------------------------------------------------------------*\
|   mcitester( hwndDlg, Msg, wParam, lParam )                                  |
|                                                                              |
|   Description:                                                               |
|       This function is the main message handler for MCI test. It handles     |
|       messages from the pushbuttons, radio buttons, edit controls, menu      |
|       system, etc. When it receives a WM_EXIT message, this routine tears    |
|       everything down and exits.                                             |
|                                                                              |
|   Arguments:                                                                 |
|       hwndDlg         window handle of the main dialog window                |
|       Msg             message number                                         |
|       wParam          message-dependent parameter                            |
|       lParam          message-dependent parameter                            |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if the message has been processed, else FALSE                     |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL mcitester(
    HWND    hwndDlg,
    UINT    Msg,
    LONG    wParam,
    LONG    lParam)
{
    DWORD dw;                       /* return value from various messages     */
    UINT  EnableOrNot;              /* is something currently selected?       */
    UINT  wID;                      /* the type of notification required      */
    int   i;

#if DBG
    if (Msg != WM_MOUSEMOVE  && Msg != WM_NCHITTEST && Msg != WM_NCMOUSEMOVE
            && (Msg < WM_CTLCOLORMSGBOX || Msg > WM_CTLCOLORSTATIC)
                && Msg != WM_SETCURSOR) {
        dprintf4((TEXT("hWnd: %08XH, Msg: %08XH, wParam: %08XH, lParam: %08XH"), hwndDlg, Msg, wParam, lParam ));
    }
#endif
    switch (Msg) {

    case WM_CLOSE:
        DestroyWindow( hwndDlg );
        break;

    case WM_COMMAND:

        dprintf3((TEXT("WM_COMMAND, wParam: %08XH, lParam: %08XH"), wParam, lParam));
        switch (LOWORD(wParam)) {

        case IDOK:

            /*
             * When the OK button gets pressed, insert a CR LF into
             * the edit control. and execute the current line.
             *
             */

            SetFocus(hwndEdit);
                        i = EditGetCurLine(hwndEdit);

            execute(hwndDlg, TRUE);

            EditSetCurLine(hwndEdit, i);

            SendMessage(hwndEdit, WM_KEYDOWN, VK_END, 0L);
            SendMessage(hwndEdit, WM_KEYUP, VK_END, 0L);
            SendMessage(hwndEdit, EM_REPLACESEL, 0,(LONG)(LPTSTR)aszEOL);

            break;

        case ID_GO:

            /*
             * When the GO! button gets pressed, execute every line
             * in the edit box starting with the first one.
             *
             */

            EditSetCurLine(hwndEdit, 0);
            execute(hwndDlg, FALSE);

            break;

        case ID_STEP:

            /*
             * When the STEP button gets pressed, execute the currently
             * selected line in the edit box.
             */

            execute(hwndDlg, TRUE);

            break;

        case MENU_EXIT:
        case ID_EXIT:

            /*
             * If the user indicates that he/she wishes to exit the
             * application, then end the main dialog and post a WM_QUIT
             * message.
             *
             */
            DestroyWindow( hwndDlg );
            break;

        case IDCANCEL:
            /* Ctrl+break will result in
               1. If there is an MCI command running, then breaking it (good)
               2. If there is NOT an MCI command running then the dialog manager will send
                  someone an IDCANCEL, and if we have the focus, we don't want to exit
                  by surprise.  This means that to actually exit you'll have to do
                  Alt+F4 or else File manu and Exit to send (WM_COMMAND, ID_EXIT)
            */
            break;

        case MENU_ABOUT:

            /* Show the 'About...' box */

            DialogBox(hInstApp, MAKEINTRESOURCE(IDD_ABOUTBOX), hwndDlg, (DLGPROC)AboutDlgProc);
            break;

        case WM_CLEAR:
        case WM_CUT:
        case WM_COPY:
        case WM_PASTE:
        case WM_UNDO:

            /* Pass whatever edit message we receive to the edit box */
            dprintf3((TEXT("sending edit Msg to edit control")));
            SendMessage(hwndEdit, LOWORD(wParam), 0, 0);

            break;

        case MENU_OPEN:

            /* Open a 'File Open' dialog */
#ifdef WIN16

            f = OpenFileDialog(hwndDlg, aszOpenFileTitle, aszExt,
                     DLGOPEN_MUSTEXIST | OF_EXIST | OF_READ, NULL,
                     aszBuffer, sizeof(aszBuffer));

            /* If the user selected a valid file, then open it */

            if ((int)f >= 0)
                                OpenMciFile(hwndDlg, aszBuffer);
#else

            strcpy(aszBuffer, aszExt);
            i = DlgOpen(hInstApp, hwndDlg, aszBuffer, sizeof(aszBuffer),
                    OFN_FILEMUSTEXIST);

            /* If the user selected a valid file, then open it */

            if (i == 1)
                OpenMciFile(hwndDlg, aszBuffer);
#endif

            break;

        case MENU_SAVE:

            /*
             * If a filename exists, then save the contents of the edit
             * box under that filename.
             *
             */

            if (*aszMciFile) {

                EditSaveFile(hwndEdit, aszMciFile);
                break;
            }

            break;

        case MENU_SAVEAS:

            /*
             */

#ifdef WIN16
            *aszBuffer = (char)0;
            f = OpenFileDialog(hwndDlg, aszSaveFileTitle, aszExt,
                DLGOPEN_SAVE | OF_EXIST, aszSaveFileControl, aszBuffer,
                sizeof(aszBuffer));

            /* If the user didn't hit Cancel, then he must have set a
             * filename, so save the contents of the edit box under
             * that filename.
             */
            if (f != DLGOPEN_CANCEL) {

                EditSaveFile(hwndEdit, aszBuffer);
            }

#else
            strcpy(aszBuffer, aszExt);
            i = DlgOpen(hInstApp, hwndDlg, aszBuffer, sizeof(aszBuffer) ,
                        OFN_PATHMUSTEXIST | OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT);

            /*
             * If the user didn't hit Cancel, then he must have set a
             * filename, so save the contents of the edit box under
             * that filename.
             *
             */

            if (i == 1) {

                EditSaveFile(hwndEdit, aszBuffer);
            }
#endif
            break;

        case MENU_DEVICES:

            /*
             * If the Devices dialog box doesn't already exist, then
             * create and display it.
             *
             */

            if (hwndDevices == 0) {
                create_device_list();
            }

            break;

#if DBG
        case IDM_DEBUG0:
        case IDM_DEBUG1:
        case IDM_DEBUG2:
        case IDM_DEBUG3:
        case IDM_DEBUG4:
            dDbgSetDebugMenuLevel(wParam - IDM_DEBUG0);
            break;
#endif
        default: /* no-op */
            break;
        }
        break; // end of WM_COMMAND case

    case WM_INITDIALOG:

        /* Do general initialization stuff */

        hwndEdit = GetDlgItem(hwndDlg,ID_INPUT);

                dprintf3((TEXT("WM_INITDIALOG:  hwndEdit = %08xH"), hwndEdit));

        SetMenu(hwndDlg, LoadMenu(hInstApp, MAKEINTRESOURCE(IDM_MCITEST)));

        SetClassLong (hwndDlg, GCL_HICON,
                      (DWORD)LoadIcon (hInstApp, MAKEINTRESOURCE(IDI_MCITEST)));

        CheckDlgButton (hwndDlg, ID_NOT_SUCCESS, FALSE);
        CheckDlgButton (hwndDlg, ID_NOT_SUPER, FALSE);
        CheckDlgButton (hwndDlg, ID_NOT_ABORT, FALSE);
        CheckDlgButton (hwndDlg, ID_NOT_FAIL, FALSE);
        SetDlgItemInt (hwndDlg, ID_RUNCOUNT, 1, TRUE);

#if DBG
        // Check the initial debug level
        {
            HANDLE hMenu;
            hMenu = GetMenu(hwndDlg);
            CheckMenuItem(hMenu, (UINT)(__iDebugLevel + IDM_DEBUG0), MF_CHECKED);
        }
#endif

        hAccTable = LoadAccelerators(hInstApp, MAKEINTRESOURCE(IDA_MCITEST));
        dprintf4((TEXT("INIT_DIALOG: hwndEdit = %08XH, Haccel = %08XH"), hwndEdit, hAccTable));
        return TRUE;

    case WM_DESTROY:

        /* End the dialog and send a WM_QUIT message */

        dprintf2((TEXT("dialog ending")));
        dSaveDebugLevel(aszAppName);
        PostQuitMessage (0);
        hwndMainDlg = 0;
        break;

    case MM_MCINOTIFY:

        /*
         * Check the radio button corresponding to the notification
         * received.
         *
         */

        dprintf3((TEXT("MM_MCINOTIFY, wParam: %08XH"), wParam));
        wID = 0;
        switch (wParam) {
        case MCI_NOTIFY_SUCCESSFUL:

            wID = ID_NOT_SUCCESS;
            break;

        case MCI_NOTIFY_SUPERSEDED:

            wID = ID_NOT_SUPER;
            break;

        case MCI_NOTIFY_ABORTED:

            wID = ID_NOT_ABORT;
            break;

        case MCI_NOTIFY_FAILURE:

            wID = ID_NOT_FAIL;
            break;

        default:
            break;
        }

        if (wID) {

            CheckDlgButton (hwndDlg, wID, TRUE);
            SetFocus (GetDlgItem(hwndDlg, ID_INPUT));
        }

        break;

    case WM_INITMENUPOPUP:                   /* wParam is menu handle */

        dprintf3((TEXT("WM_INITMENUPOPUP")));

        /* Enable the 'Save' option if a valid filename exists */

        EnableMenuItem((HMENU)wParam, (UINT)MENU_SAVE,
            (UINT)(*aszMciFile ? MF_ENABLED : MF_GRAYED));

        /* Find out if something is currently selected in the edit box */

        dw = SendMessage(hwndEdit,EM_GETSEL,0,0L);
        EnableOrNot = (UINT)((HIWORD(dw) != LOWORD(dw) ? MF_ENABLED : MF_GRAYED));

        /* Enable / disable the Edit menu options appropriately */

        EnableMenuItem ((HMENU)wParam, (UINT)WM_UNDO ,
            (UINT)(SendMessage(hwndEdit,EM_CANUNDO,0,0L) ? MF_ENABLED : MF_GRAYED));
        EnableMenuItem ((HMENU)wParam, WM_CUT  , EnableOrNot);
        EnableMenuItem ((HMENU)wParam, WM_COPY , EnableOrNot);
        EnableMenuItem ((HMENU)wParam, WM_PASTE,
            (UINT)(IsClipboardFormatAvailable(CF_TEXT) ? MF_ENABLED : MF_GRAYED));
        EnableMenuItem ((HMENU)wParam, WM_CLEAR, EnableOrNot);

        return 0L;
    }

    return 0;
}


/*----------------------------------------------------------------------------*\
|   AppInit( hInst, hPrev, sw, szCmdLine)                                      |
|                                                                              |
|   Description:                                                               |
|       This is called when the application is first loaded into memory. It    |
|       performs all initialization that doesn't need to be done once per      |
|       instance.                                                              |
|                                                                              |
|   Arguments:                                                                 |
|       hInstance       instance handle of current instance                    |
|       hPrev           instance handle of previous instance                   |
|       sw              not really used at all                                 |
|       szCmdLine       string containing the command line arguments           |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if successful, FALSE if not                                       |
|                                                                              |
\*----------------------------------------------------------------------------*/

BOOL AppInit(
    int    argc,
    char   *argv[])
{
    /* Put up the main dialog box */

    hInstApp = GetModuleHandle(NULL);
    dprintf1((TEXT("MCITEST starting... module handle is %xH"), hInstApp));

    if (NULL ==
       (hwndMainDlg = CreateDialog (hInstApp,
                                   MAKEINTRESOURCE(IDD_MCITEST),
                                   NULL, (DLGPROC)mcitester)
       )) {

        DWORD n;

        n = GetLastError();
        dprintf1((TEXT("NULL hwndMainDLG, last error is %d"), n));
        DebugBreak();

        return(FALSE);
    }

    /* Fix up WIN.INI if this is the first time we are run... */

    if (!GetProfileString(aszProfileSection, aszProfileKey, aszNULL, aszBuffer, sizeof(aszBuffer)))
        WriteProfileString(aszProfileSection, aszProfileKey, aszProfileSetting);

    /*
     * If a command line argument was specified, assume it to be a filename
     * and open that file.
     *
     */

    if (argc > 1 && *argv[1]) {
#ifdef UNICODE
        LPTSTR lpCommandLine = GetCommandLine();

        // Skip over the command name to get to the argument string
        while (*lpCommandLine && *lpCommandLine++ != TEXT(' ')) {
        }

        OpenMciFile(hwndMainDlg, lpCommandLine);
#else
        OpenMciFile(hwndMainDlg, argv[1]);
#endif
    }

    return TRUE;
}


/*----------------------------------------------------------------------------*\
|   WinMain( hInst, hPrev, lpszCmdLine, sw )                                   |
|                                                                              |
|   Description:                                                               |
|       The main procedure for the app. After initializing, it just goes       |
|       into a message-processing loop until it gets a WM_QUIT message         |
|       (meaning the app was closed).                                          |
|                                                                              |
|   Arguments:                                                                 |
|       hInst           instance handle of this instance of the app            |
|       hPrev           instance handle of previous instance, NULL if first    |
|       szCmdLine       null-terminated command line string                    |
|       sw              specifies how the window is to be initially displayed  |
|                                                                              |
|   Returns:                                                                   |
|       The exit code as specified in the WM_QUIT message.                     |
|                                                                              |
\*----------------------------------------------------------------------------*/

int __cdecl main(
    int argc,
    char *argv[],
    char *envp[])
{
    MSG     Msg;                    /* Windows message structure */

    // If we are in DEBUG mode, get debug level for this module
    dGetDebugLevel(aszAppName);
#if DBG
    dprintf1((TEXT("started (debug level %d)"), __iDebugLevel));
#endif

    /* Call the initialization procedure */

    if (!AppInit(argc, argv)) {
        return FALSE;
    }


    /* Poll the event queue for messages */

    while (GetMessage(&Msg, NULL, 0, 0))  {

        /*
         * If the Devices dialog is showing and the number of open devices has
         * changed since we last checked, then update the list of open devices.
         */

        if (hwndDevices != 0 && get_number_of_devices() != nLastNumberOfDevices) {
            update_device_list();
        }

        /* Main message processing */

        if (!hwndMainDlg || !IsDialogMessage(hwndMainDlg, &Msg)) {
            TranslateMessage(&Msg);
            DispatchMessage(&Msg);

            // IsDialogMessage may enter with hwndMainDlg != NULL and exit with
            // hwndMainDlg == NULL after processing the message
        }
        else if (hwndMainDlg) {
            TranslateAccelerator (hwndMainDlg, hAccTable, &Msg);
        }
    }

    return Msg.wParam;
}


STATICDT TCHAR ms[] = TEXT("milliseconds");
STATICDT TCHAR sc[] = TEXT("seconds");
STATICDT TCHAR hr[] = TEXT("hours");
STATICDT TCHAR mn[] = TEXT("minutes");

STATICFN void ProcessInternalCommand(HWND hDlg, LPTSTR aszBuffer)
{
    LPTSTR pch = aszBuffer;
    TCHAR msg[80];

    if( (0 == (strnicmp(aszBuffer, TEXT("SLEEP"),5)))
       || (0 == (strnicmp(aszBuffer, TEXT("PAUSE"),5)))) {

        UINT factor = 1;
        UINT number;
        LPTSTR delay;
        LPTSTR pch1;
        pch += 5; // length SLEEP/PAUSE
        while (*pch && *pch == TEXT(' ') ) {
            pch++;
        }

        if (!*pch) {
            SetDlgItemText (hDlg, ID_OUTPUT, TEXT("No parameter provided for Sleep command"));
            return;
        }

#ifdef UNICODE
        wsprintf(msg "%hs", pch);  // Convert string to ascii
        number = atoi( msg );
#else
        number = atoi( pch );
#endif

        if (0 == number) {
            SetDlgItemText (hDlg, ID_OUTPUT, TEXT("Parameter is not a number"));
            return;
        }


        // pch addresses the number
        // Now see if there are any other parameters
        // First, skip to the end of the number

        pch1 = pch+1;
        while (*pch1 && *pch1 != TEXT(' ') ) {
            pch1++;
        }

        if (*pch1) {
            *pch1++ = TEXT('\0');

            // There is another parameter.  Accept s/S for seconds,
            //                                     h/M for hours
            //                                     m/M for minutes
            //                              Default is milliseconds
            while (*pch1 && *pch1 == TEXT(' ') ) {
                pch1++;
            }
        }

        switch (*pch1) {
            case TEXT('s'):
            case TEXT('S'):
                delay = sc;
                factor = 1000;
                break;
            case TEXT('m'):
            case TEXT('M'):
                delay = mn;
                factor = 1000*60;
                break;
            case TEXT('h'):
            case TEXT('H'):
                delay = hr;
                factor = 1000*60*60;
                break;
           case TEXT('\0'):
           default:
                delay = ms;
                factor = 1;
                break;
        }

        wsprintf(msg, TEXT("Sleeping for %d %s"), number, delay);
        SetDlgItemText (hDlg, ID_OUTPUT, msg);
        Sleep(number*factor);

    } else if (0 == (strnicmp(aszBuffer, TEXT("CD"),2))) {
        BOOL fResult;
        pch += 2; // length CD
        while (*pch && *pch == TEXT(' ') ) {
            pch++;
        }
        fResult = SetCurrentDirectory(pch);
        if (!fResult) {
            UINT errorcode;
            errorcode = GetLastError();
            wsprintf(msg,
                TEXT("Set current directory to >%s< failed, error code==%d"),
                pch, errorcode);
        } else
            wsprintf(msg,
                TEXT("Set current directory to >%s<"), pch);
            SetDlgItemText (hDlg, ID_OUTPUT, msg);

    } else {
        SetDlgItemText (hDlg, ID_OUTPUT, TEXT("Unrecognised internal command"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mmiotest\mmiot32.h ===
/*
    mmiot32.h

    Port stuff to convert to win 32

*/

#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <mmsystem.h>

#include "MMIOTest.h"
#include "gmem.h"

#ifdef HUGE
#undef HUGE
#endif
#define HUGE

#ifdef huge
#undef huge
#endif
#define huge

#define HPSTR LPSTR



#define READ OF_READ // (Win32)

/*
    macros to replace the wincom stuff

*/

#define dprintf printf

#define lstrncmp(s,d,n) strncmp((s),(d),(n))

extern void dDbgAssert(LPSTR exp, LPSTR file, int line);

DWORD __dwEval;

#define WinAssert(exp) \
    ((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))


/* Evaluate exp.  If it's non-zero return it, else ASSERT */

#define WinEval(exp)                                   \
    ( __dwEval=(DWORD)(exp),                           \
      __dwEval                                         \
    ? (void)0                                          \
    : dDbgAssert(#exp, __FILE__, __LINE__)             \
    , __dwEval                                         \
    )

/*
    stuff not in Win32

*/

#define AccessResource(hInst, hResInfo) -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mmiotest\main.c ===
/*
    main.c

    A simple startup module so I can just call the win16 code
    with the least porting effort

    Revision history
    Sept 92 Lauriegr Remove try except - it just makes debugging harder.

*/

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

//
// globals in mmiotest.c
//

extern HANDLE ghInst;

//
// functions in mmiotest.c
//

extern void Test1(HWND hWnd);
extern void Test2(HWND hWnd);
extern void Test3(HWND hWnd);


int __cdecl main(int argc, char *argv[], char *envp[])
{
    FILE *fp;

    /* save instance handle for dialog boxes */
    ghInst = GetModuleHandle(NULL);

    // create the local test file

    printf("\nCreating hello.txt");
    fp = fopen("hello.txt", "wb");
    if (!fp) {
        printf("\nUnable to create hello.txt");
        exit(1);
    }
    fprintf(fp, "hello world\r\n");
    fclose(fp);

//  try {

        // execute all the tests

        printf("\n--------------- Test1 ---------------\n");
        Test1(NULL);
        printf("Done Test1.\n");

        printf("\n--------------- Test2 ---------------\n");
        Test2(NULL);
        printf("Done Test2.\n");

        printf("\n--------------- Test3 ---------------\n");
        Test3(NULL);
        printf("Done Test3.\n");

        printf("Done All Tests.\n");

//  } except (1) {
//      printf("\nException");
//  }

    return 0;
}

void dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    printf("\nAssertion failure:");
    printf("\n  Exp: %s", exp);
    printf("\n  File: %s, line %d\n", file, line);
    DebugBreak();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mmiotest\mmiotest.h ===
/* MMIOTest.h
 */

/* dialog boxes */
#define ABOUTBOX		1

/* menu items */
#define IDM_ABOUT		11
#define IDM_EXIT		12
#define IDM_ALLTESTS		21
#define IDM_TEST1		31
#define IDM_TEST2		41
#define IDM_TEST3		51
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\playsnd\about.c ===
/*
    about.c

    show the apps about box

*/

#include <windows.h>
#include "PlaySnd.h"

void About(
  HWND hWnd)
{
    /* show the about box */

    DialogBox(ghModule, MAKEINTRESOURCE(IDD_ABOUT) //"About"
				, hWnd , (DLGPROC)AboutDlgProc);
}


LONG AboutDlgProc(HWND hDlg, UINT msg, DWORD wParam, LONG lParam)
{
    UNREFERENCED_PARAMETER(lParam);

    switch (msg) {
    case WM_INITDIALOG:
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            EndDialog(hDlg, TRUE);
            break;
        default:
            break;
        }
        break;

    default:
        return FALSE; // say we didn't handle it
        break;
    }

    return TRUE; // say we handled it
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\mmiotest\mmiotest.c ===
/* MMIOTest.c
 *
 * Test the MMIO library.
 */

#include "mmiot32.h"                        // (Win32)


/* constants */
#define MMIOM_ANSWER    (MMIOM_USER + 1)    // get answer to the universe


/* globals */
char        gszAppName[] = "MMIOTest";      // for title bar etc.
HANDLE      ghInst;                         // program instance handle


/* prototypes */
void PASCAL AppPaint(HWND hwnd, HDC hdc);
BOOL FAR PASCAL AppAbout(HWND hDlg, UINT uMessage,
    DWORD dwParam, LONG lParam);
BOOL PASCAL AppInit(HANDLE hInst, HANDLE hPrev);
LONG FAR PASCAL AppWndProc(HWND hwnd, UINT uMessage,
    DWORD dwParam, LONG lParam);
int WINAPI WinMain(HANDLE hInst, HANDLE hPrev, LPSTR lpszCmdLine, int iCmdShow);

void NEAR PASCAL Test1(HWND hwnd);
void NEAR PASCAL TestHelloWorld(HMMIO hmmio, LONG lBufSize);
MMIOPROC RCDIOProc;
void NEAR PASCAL Test2(HWND hwnd);
void NEAR PASCAL Test2Helper(BOOL fMemFile);
void NEAR PASCAL FillBufferedFile(HMMIO hmmio, LONG lLongs);
void NEAR PASCAL Test3(HWND hwnd);
void NEAR PASCAL TestRIFF(HMMIO hmmio, BOOL fReadable);
LPSTR NEAR PASCAL lstrrchr(LPSTR szSrc, char ch);
#ifdef OMIT
void NEAR PASCAL lmemset(void far *pDst, BYTE bSrc, long cDst);
#endif //OMIT


/* AppPaint(hwnd, hdc)
 *
 * This function is called whenever the application windows needs to be
 * redrawn.
 */
void PASCAL
AppPaint(
    HWND    hwnd,           // window painting into
    HDC     hdc)            // display context to paint to
{
}


/* AppAbout(hDlg, uMessage, dwParam, lParam)
 *
 * This function handles messages belonging to the "About" dialog box.
 * The only message that it looks for is WM_COMMAND, indicating the use
 * has pressed the "OK" button.  When this happens, it takes down
 * the dialog box.
 */
BOOL FAR PASCAL             // TRUE iff message has been processed
AppAbout(
  HWND      hDlg,           // window handle of "about" dialog box
  UINT      uMessage,       // message number
  DWORD     dwParam,        // message-dependent parameter
  LONG      lParam)         // message-dependent parameter
{
    switch (uMessage)
    {
    case WM_COMMAND:
        if (dwParam == IDOK)
            EndDialog(hDlg, TRUE);
        break;
    case WM_INITDIALOG:
        return TRUE;
    }
    return FALSE;
}


/* AppInit(hInst, hPrev)
 *
 * This is called when the application is first loaded into memory.
 * It performs all initialization that doesn't need to be done once
 * per instance.
 */
BOOL PASCAL             // returns TRUE iff successful
AppInit(
    HANDLE  hInst,      // instance handle of current instance
    HANDLE  hPrev)      // instance handle of previous instance
{
    WNDCLASS    wndclass;

#if DBG
#if BOGUS  //Laurie
    wpfGetDebugLevel(gszAppName);
#endif
#endif

    if (!hPrev)
    {
        /* Register a class for the main application window */
        wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
        wndclass.hIcon = LoadIcon(hInst, "AppIcon");
        wndclass.lpszMenuName = "AppMenu";
        wndclass.lpszClassName = gszAppName;
        /* wndclass.hbrBackground = (HBRUSH) COLOR_WINDOW + 1; */
        wndclass.hbrBackground = GetStockObject(BLACK_BRUSH);
        wndclass.hInstance = hInst; // (Win32)
        wndclass.style = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW;
        wndclass.lpfnWndProc = (WNDPROC)AppWndProc;
        wndclass.cbWndExtra = 0;
        wndclass.cbClsExtra = 0;

        if (!RegisterClass(&wndclass))
            return FALSE;
    }

    return TRUE;
}


/* WinMain(hInst, hPrev, lpszCmdLine, cmdShow)
 *
 * The main procedure for the App.  After initializing, it just goes
 * into a message-processing loop until it gets a WM_QUIT message
 * (meaning the app was closed).
 */
int WINAPI                  // returns exit code specified in WM_QUIT
WinMain(
    HANDLE  hInst,          // instance handle of current instance
    HANDLE  hPrev,          // instance handle of previous instance
    LPSTR   lpszCmdLine,    // null-terminated command line
    int     iCmdShow)       // how window should be initially displayed
{
    MSG     msg;            // message from queue
    HWND        hwnd;       // handle to app's window

    /* save instance handle for dialog boxes */
    ghInst = hInst;

    /* call initialization procedure */
    if (!AppInit(hInst, hPrev))
        return FALSE;

    /* create the application's window */
    hwnd = CreateWindow
    (
        gszAppName,             // window class
        gszAppName,             // window caption
        WS_OVERLAPPEDWINDOW,    // window style
        CW_USEDEFAULT, 0,       // initial position
        CW_USEDEFAULT, 0,       // initial size
        NULL,                   // parent window handle
        NULL,                   // window menu handle
        hInst,                  // program instance handle
        NULL                    // create parameters
    );
    ShowWindow(hwnd, iCmdShow);

    /* get messages from event queue and dispatch them */
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;  /* Note: wParam is a DWORD in NT */
}


/* AppWndProc(hwnd, uMessage, dwParam, lParam)
 *
 * The window proc for the app's main window.  This processes all
 * of the parent window's messages.
 */
LONG FAR PASCAL                 // returns 0 iff processed message
AppWndProc(
    HWND        hwnd,           // window's handle
    UINT        uMessage,       // message number
    DWORD       dwParam,        // message-dependent parameter
    LONG        lParam)         // message-dependent parameter
{
#ifdef WIN16
    FARPROC     fpfn;
#endif
    PAINTSTRUCT ps;
    BOOL        fAllTests = FALSE;

    switch (uMessage)
    {

    case WM_COMMAND:

        switch (dwParam)
        {

        case IDM_ABOUT:

            /* request to display "About" dialog box */
#ifdef WIN16
            fpfn = MakeProcInstance((FARPROC) AppAbout, ghInst);
            DialogBox(ghInst, MAKEINTRESOURCE(ABOUTBOX),
                  hwnd, fpfn);
            FreeProcInstance(fpfn);
#else
            DialogBox(ghInst, MAKEINTRESOURCE(ABOUTBOX),
                  hwnd, (DLGPROC)AppAbout);
#endif
            break;

        case IDM_EXIT:

            /* request to exit this program */
            PostMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
            break;

        case IDM_ALLTESTS:

            fAllTests = TRUE;
            /* fall through */

        case IDM_TEST1:

            dprintf("\n--------------- Test1 ---------------\n");
            Test1(hwnd);
            dprintf("Done Test1.\n");
            if (!fAllTests)
                break;

        case IDM_TEST2:

            dprintf("\n--------------- Test2 ---------------\n");
            Test2(hwnd);
            dprintf("Done Test2.\n");
            if (!fAllTests)
                break;

        case IDM_TEST3:

            dprintf("\n--------------- Test3 ---------------\n");
            Test3(hwnd);
            dprintf("Done Test3.\n");
            if (!fAllTests)
                break;

            dprintf("Done All Tests.\n");
            break;
        }
        return 0L;

    case WM_DESTROY:

        /* exit this program */
        PostQuitMessage(0);
        break;

    case WM_PAINT:

        /* set up a paint structure, and call AppPaint() */
        BeginPaint(hwnd, &ps);
        AppPaint(hwnd, ps.hdc);
        EndPaint(hwnd, &ps);
        return 0;
    }

    return (LONG)DefWindowProc(hwnd, uMessage, dwParam, lParam);
}


void NEAR PASCAL
Test1(HWND hwnd)
{
    HMMIO       hmmio;
    char        achMemFile[100];
    MMIOINFO    mmioinfo;
    HMMIO       hmmioMF;        // memory file handle
    long        lBufSize;
    int         fh;
    FARPROC     farproc;       // Added to make it compile.  LKG


    dprintf("HelloWorld tests...\n");

    /* open "hello.txt" unbuffered -- assume it contains
     * "hello world\r\n" (13 bytes) -- and run the TestHelloWorld test
     */
    WinEval((hmmio = mmioOpen("hello.txt", NULL, 0)) != NULL);
    dprintf("TestHelloWorld() with no buffer\n");
    TestHelloWorld(hmmio, 0);

    for (lBufSize = 1; lBufSize <= 15; lBufSize++)
    {
        /* re-run test for various buffer sizes */
        WinEval(mmioSetBuffer(hmmio, NULL, lBufSize, 0) == 0);
        WinEval(mmioSeek(hmmio, 0L, SEEK_SET) == 0L);
        dprintf("TestHelloWorld() with %ld-byte buffer\n",
            lBufSize);
        TestHelloWorld(hmmio, lBufSize);
    }

    /* copy file into a memory block, set up memory block
     * as a memory file, and re-run the test
     */
    WinEval(mmioSeek(hmmio, 0L, SEEK_SET) == 0L);
    WinEval(mmioRead(hmmio, achMemFile, 13L) == 13L);
    memset(&mmioinfo, 0, sizeof(mmioinfo));
    mmioinfo.fccIOProc = FOURCC_MEM;
    mmioinfo.pchBuffer = achMemFile;
    mmioinfo.cchBuffer = 13L;
    WinEval((hmmioMF = mmioOpen(NULL, &mmioinfo, 0)) != NULL);
    dprintf("TestHelloWorld() with memory file\n");
    TestHelloWorld(hmmioMF, 13L);

    /* close the open files */
    WinEval(mmioClose(hmmio, 0) == 0);
    WinEval(mmioClose(hmmioMF, 0) == 0);

    /* open file and pass file handle to mmioOpen() */
    WinEval((fh = _lopen("hello.txt", READ)) >= 0);
    memset(&mmioinfo, 0, sizeof(mmioinfo));
    mmioinfo.adwInfo[0] = fh;
    WinEval((hmmio = mmioOpen((LPSTR) NULL, &mmioinfo, MMIO_ALLOCBUF))
            != NULL);
    dprintf("TestHelloWorld() with file handle passed to mmioOpen()\n");
    TestHelloWorld(hmmio, 0);
    WinEval(mmioClose(hmmio, 0) == 0);

    /* "hello.txt" is stored as an RCDATA resource named "Hello" --
     * use this to try out the custom I/O procedure stuff
     */
    dprintf("register Win3 RCDATA custom I/O procedure\n");
    #define FOURCC_RCD  mmioFOURCC('R', 'C', 'D', ' ')
    WinEval( (farproc = (FARPROC) RCDIOProc)  != NULL );

    /* installing it twice should just mean it has to be removed twice */
    WinEval(mmioInstallIOProc(FOURCC_RCD, NULL,
        MMIO_FINDPROC) == NULL);
    WinEval(mmioInstallIOProc(FOURCC_RCD, (LPMMIOPROC) farproc,
        MMIO_INSTALLPROC) == (LPMMIOPROC) farproc);
    WinEval(mmioInstallIOProc(FOURCC_RCD, NULL,
        MMIO_FINDPROC) == (LPMMIOPROC) farproc);
    WinEval(mmioInstallIOProc(FOURCC_RCD, (LPMMIOPROC) farproc,
        MMIO_INSTALLPROC) == (LPMMIOPROC) farproc);
    WinEval(mmioInstallIOProc(FOURCC_RCD, NULL,
        MMIO_FINDPROC) == (LPMMIOPROC) farproc);

    /* run the test without an I/O buffer */
    dprintf("TestHelloWorld() unbuffered, with custom I/O procedure\n");
    WinEval((hmmio = mmioOpen("mmiotest.rcd+Hello", NULL, 0)) != NULL);  // changed ! to + LKG
    TestHelloWorld(hmmio, 0);
    WinEval(mmioClose(hmmio, 0) == 0);

    /* run the test with a standard-size I/O buffer */
    dprintf("TestHelloWorld() buffered, with custom I/O procedure\n");
    WinEval((hmmio = mmioOpen("mmiotest.rcd+Hello", NULL, MMIO_ALLOCBUF))
            != NULL);
    TestHelloWorld(hmmio, MMIO_DEFAULTBUFFER);
    WinEval(mmioClose(hmmio, 0) == 0);

    /* remove the custom I/O procedure (it was installed twice above) */
    WinEval(mmioInstallIOProc(FOURCC_RCD, NULL,
        MMIO_FINDPROC) == (LPMMIOPROC) farproc);
    WinEval(mmioInstallIOProc(FOURCC_RCD, NULL,
        MMIO_REMOVEPROC) == (LPMMIOPROC) farproc);
    WinEval(mmioInstallIOProc(FOURCC_RCD, NULL,
        MMIO_FINDPROC) == (LPMMIOPROC) farproc);
    WinEval(mmioInstallIOProc(FOURCC_RCD, NULL,
        MMIO_REMOVEPROC) == (LPMMIOPROC) farproc);
    WinEval(mmioInstallIOProc(FOURCC_RCD, NULL,
        MMIO_FINDPROC) == NULL);
    WinEval(mmioInstallIOProc(FOURCC_RCD, NULL,
        MMIO_REMOVEPROC) == NULL);

    /* make sure the I/O procedure got removed */
    WinEval(mmioOpen("mmiotest.rcd+Hello", NULL, 0) == NULL);
}


void NEAR PASCAL
TestHelloWorld(HMMIO hmmio, LONG lBufSize)
{
    MMIOINFO    mmioinfo;
    char        ach[100];
    long        lOffset;
    static NPSTR    szHello = "hello world\r\n";    // contents of file
    long        lAnswer;

    strcpy(ach, "Recognisable garbage!");

    /* send the I/O procedure a custom message */
    lAnswer = mmioSendMessage(hmmio, MMIOM_ANSWER, 20L, 22L);
    dprintf("answer %ld, ", lAnswer);

    /* expect to be at offset 0 now */
    WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 0L);

    if (lBufSize > 0)
    {
        /* access buffer directly starting at "hello" */
        WinEval(mmioGetInfo(hmmio, &mmioinfo, 0) == 0);
        WinEval(mmioAdvance(hmmio, &mmioinfo, MMIO_READ) == 0);
        WinEval(lstrncmp(mmioinfo.pchNext, szHello,
            min((int) lBufSize, 13)) == 0);
        if (lBufSize >= 2)
        {
            WinAssert((mmioinfo.pchEndWrite - mmioinfo.pchNext)
                      >= 2);
            mmioinfo.pchNext += 2;
        }
        WinEval(mmioSetInfo(hmmio, &mmioinfo, 0) == 0);

        /* expect to be at offset 2 now */
        if (lBufSize >= 2)
            WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 2L);

        /* access buffer directly starting at "world" */
        WinEval(mmioSeek(hmmio, 6L, SEEK_SET) == 6L);
        WinEval(mmioGetInfo(hmmio, &mmioinfo, 0) == 0);
        WinEval(mmioAdvance(hmmio, &mmioinfo, MMIO_READ) == 0);
        WinEval(lstrncmp(mmioinfo.pchNext, szHello + 6,
            min((int) lBufSize, 13 - 6)) == 0);
        WinEval(mmioSetInfo(hmmio, &mmioinfo, 0) == 0);

        /* expect to still be at offset 6 */
        WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 6L);
    }

    /* go to offset 2 */
    WinEval(mmioSeek(hmmio, 2L, SEEK_SET) == 2L);

    /* read "llo" */
    strcpy(ach, "Recognisable garbage!");
    WinEval(mmioRead(hmmio, ach, 3) == 3);
    WinEval(lstrncmp(ach, "llo", 3) == 0);

    /* read " wor" */
    WinEval(mmioRead(hmmio, ach, 4) == 4);

    if (lstrncmp(ach, " wor", 4) != 0)
    {  printf("ach = <%s>, expected < wor>", ach);
    }

    WinEval(lstrncmp(ach, " wor", 4) == 0);

    /* expect to be at offset 9 now */
    WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 9L);

    /* read "ld\r\n" -- ask for 7 bytes, but only expect 4 */
    WinEval(mmioRead(hmmio, ach, 7) == 4);
    WinEval(lstrncmp(ach, "ld\r\n", 4) == 0);

    /* expect to be at end of file now */
    WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 13L);

    /* test seeking and reading for each offset in the file */
    dprintf("reading from offset");
    for (lOffset = 0; lOffset <= 11; lOffset++)
    {
        dprintf(" %ld", lOffset);
        WinEval(mmioSeek(hmmio, lOffset, SEEK_SET) == lOffset);
        WinEval(mmioRead(hmmio, ach, 2) == 2);
        WinEval(lstrncmp(ach, "hello world\r\n" + lOffset, 2) == 0);
    }
    dprintf(".\n");

    /* check more seeking */
    OutputDebugString("SEEK_SET\n");
    WinEval(mmioSeek(hmmio, 0L, SEEK_SET) == 0L);
    WinEval(mmioSeek(hmmio, 13L, SEEK_SET) == 13L);
    OutputDebugString("SEEK_CUR\n");
    WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 13L);
    WinEval(mmioSeek(hmmio, -2L, SEEK_CUR) == 11L);
    WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 11L);
    WinEval(mmioSeek(hmmio, -11L, SEEK_CUR) == 0L);
    WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 0L);
    OutputDebugString("SEEK_END\n");
    WinEval(mmioSeek(hmmio, 11L, SEEK_END) == 2L);
    OutputDebugString("SEEK_CUR\n");
    WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 2L);

    /* measure the length of the file */
    OutputDebugString("SEEK_END\n");
    WinEval(mmioSeek(hmmio, 0L, SEEK_END) == 13L);
} /* TestHelloWorld */


/* 'RCD' I/O Procedure
 *
 * I/O procedure that will open e.g. "foo.rcd+bar" but it's a con.
 * It will chech that what's between the . and + is rcd, it will
 * check that bar is in fact "hello" and that foo is "mmiotest"
 * It then has a spoof "file" containing "hello world\r\n"
 */

typedef struct _MMIORCDINFO     // How RCD IOProc uses MMIO.adwInfo[]
{
    int         fh;             // DOS file handle
    long        lOffset;        // offset of start of resource
    long        lSize;          // size of resource (bytes)
} MMIORCDINFO;

LONG FAR PASCAL
RCDIOProc(
  LPSTR     lpmmioStr,          // I/O status block (cast to LPSTR)
  UINT      uMsg,               // message number
  LONG      lParam1,
  LONG          lParam2)        // message-specific parameters
{
    LPMMIOINFO  pmmio = (LPMMIOINFO) lpmmioStr;
    MMIORCDINFO FAR *pInfo = (MMIORCDINFO FAR *) pmmio->adwInfo;
    LPSTR       szFileName = (LPSTR) lParam1;
    HANDLE      hModule;        // handle to module
    HANDLE      hResInfo;       // handle to resource information
    LONG        lBytesLeft;     // bytes left in res. after current pos.
    WORD        wBytesAsk;      // bytes asked to read
    WORD        wBytes;         // bytes actually read
    LONG        lBytesTotal;    // accum. bytes actually read
    LPSTR       pchPlus;        // pointer to '+'
    LPSTR       pchDot;         // pointer to '.rcd'
    LONG        lNewOffset;

    static LPSTR lpData = "hello world\r\n"; // actual data

    switch (uMsg)
    {

    case MMIOM_OPEN:

        if (0 != stricmp(szFileName,"mmiotest.rcd+hello"))
            return MMIOERR_CANNOTOPEN;

        pInfo->lSize = strlen(lpData);

        pInfo->lOffset = 0;

        pmmio->lDiskOffset = 0L;

        return 0L;

    case MMIOM_CLOSE:

        return 0L;

    case MMIOM_READ:

        /* lParam2 = number of bytes to read */
        /* lParam1 = address to deliver them to */
        lBytesLeft = pInfo->lSize - pmmio->lDiskOffset;
        if (lParam2 > lBytesLeft)
            lParam2 = lBytesLeft;

        // memcpy((LPSTR)lParam1, lpData[pmmio->lDiskOffset], lParam2);  but it trapped!
        {  int i;
           for (i=0; i<lParam2; ++i) {
               ((LPSTR)lParam1)[i] = lpData[pmmio->lDiskOffset++];
           }
        }

        return lParam2;

    case MMIOM_WRITE:

        /* Windows resources are read-only */
        return -1;

    case MMIOM_SEEK:

        /* calculate <lNewOffset>, the new offset (relative to the
         * beginning of the resource)
         */
        switch ((int) lParam2)
        {

        case SEEK_SET:

            lNewOffset = lParam1;
            break;

        case SEEK_CUR:

            lNewOffset = pmmio->lDiskOffset + lParam1;
            break;

        case SEEK_END:

            lNewOffset = pInfo->lSize - lParam1;
            break;
        }

        if (lNewOffset<0)
        {  dprintf("Seek to before start of rcd");
           return -1;
        }
        if (lNewOffset>pInfo->lSize)
        {  dprintf("Seek to after end of rcd");
           return -1;
        }


        pmmio->lDiskOffset = lNewOffset;
        return lNewOffset;

    case MMIOM_ANSWER:

        /* this I/O procedure knows the answer to the universe */
        return lParam1 + lParam2;

    }

    return 0L;
}


void NEAR PASCAL
Test2(
    HWND hwnd)
{
    dprintf("Test2 using a DOS file...\n");
    Test2Helper(FALSE);
    dprintf("Test2 using a memory file...\n");
    Test2Helper(TRUE);
}


void NEAR PASCAL
Test2Helper(
    BOOL fMemFile)
{
    HMMIO       hmmio;
    HPSTR       pchCallerData = NULL;
    long        lBytesToRead;
    long        lOffset;
    long        lBufSize;
    long        lMemFileBufSize;
    BOOL        fBuffered;
    MMIOINFO    mmioinfo;

    dprintf("creating 540000-byte file\n");
    if (fMemFile)
    {
        /* create a memory file */
        memset(&mmioinfo, 0, sizeof(mmioinfo));
        mmioinfo.fccIOProc = FOURCC_MEM;
        mmioinfo.pchBuffer = NULL;
        mmioinfo.cchBuffer = 12344L;        // initial size
        mmioinfo.adwInfo[0] = 76543L;       // grow by this much
        WinEval((hmmio = mmioOpen(NULL, &mmioinfo,
            MMIO_CREATE | MMIO_READWRITE)) != NULL);
    }
    else
    {
        /* open "test2.tmp" for reading and writing */
        WinEval((hmmio = mmioOpen("test2.tmp", NULL,
            MMIO_CREATE | MMIO_READWRITE | MMIO_ALLOCBUF)) != NULL);
    }

    /* create a file that's big enough so we do the following reads:
     *   40000, 60000, 80000, 100000, 120000, 140000  (sum 540000)
     */
    FillBufferedFile(hmmio, 540000L / 4L);

    WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 540000L);

    dprintf("create huge a buffer that's not segment boundary aligned\n");
    /* we'll read stuff into the buffer at offset 12345, to try out
     * reading into the buffer across segment offsets
     */
    if ((pchCallerData = GAllocPtr(140000L + 12345L)) == NULL)
    {
        dprintf("test program problem: can't allocate caller buffer\n");
        WinAssert(FALSE);
    }

    lMemFileBufSize = 540000L;
    for (fBuffered = fMemFile; fBuffered <= TRUE; fBuffered++)
    {
        /* seek back */
        dprintf("seek back, do 40000-140000 byte %s reads,"
            " and check file contents\n",
            (LPSTR) (fBuffered ? "buffered" : "unbuffered"));
        WinEval(mmioSeek(hmmio, 0L, SEEK_SET) == 0L);

        /* read the file in varying large and huge reads, and at the
         * same time verify that the file was written to correctly
         */
        for (lOffset = 0L, lBytesToRead = 40000L, lBufSize = 100000L;
             lBytesToRead <= 140000L;
             lOffset += lBytesToRead, lBytesToRead += 20000L,
                 lBufSize -= 10000L)
        {
            long        lLongs;
            long huge * pl;
            long        lOffsetCheck;
            MMIOINFO    mmioinfo;

            if (fMemFile)
            {
                /* juggle the memory file buffer around, but
                 * don't truncate the data
                 */
                if (lMemFileBufSize == 540000L)
                    lMemFileBufSize = 678901L;
                else
                    lMemFileBufSize = 540000L;
                WinEval(mmioSetBuffer(hmmio, NULL,
                        lMemFileBufSize, 0) == 0);
            }
            else
            if (fBuffered)
            {
                /* just to be nasty, let's play around with the
                 * buffer size while all this is going on
                 */
                WinEval(mmioSetBuffer(hmmio, NULL, lBufSize, 0)
                        == 0);
                WinEval(mmioGetInfo(hmmio, &mmioinfo, 0) == 0);
                WinEval(mmioAdvance(hmmio, &mmioinfo, MMIO_READ)
                        == 0);
                WinEval(mmioSetInfo(hmmio, &mmioinfo, 0) == 0);
            }
            else
            {
                /* no buffer */
                WinEval(mmioSetBuffer(hmmio, NULL, 0, 0)
                        == 0);
            }

            /* read the next <lBytesToRead> */
            WinEval(mmioRead(hmmio, pchCallerData + 12345L,
                         lBytesToRead) == lBytesToRead);

            lLongs = lBytesToRead / 4L, pl =
                (long huge *) (pchCallerData + 12345L);
            lOffsetCheck = lOffset;
            while (lLongs-- > 0)
            {
                WinEval(*pl++ == lOffsetCheck);
                lOffsetCheck += 4;
            }
        }

        WinAssert(mmioSeek(hmmio, 0L, SEEK_CUR) == 540000L);
        WinAssert(mmioSeek(hmmio, 0L, SEEK_END) == 540000L);
        WinEval(mmioRead(hmmio, pchCallerData + 12345L, 17L) == 0L);
    }

    if (pchCallerData != NULL)
        GFreePtr(pchCallerData);

    /* close "test2.tmp" */
    WinEval(mmioClose(hmmio, 0) == 0);

    if (!fMemFile)
    {
        dprintf("delete the test file using MMIO_DELETE\n");
        WinEval(mmioOpen("test2.tmp", NULL, MMIO_DELETE)
                == (HANDLE) TRUE);
    }
}


void NEAR PASCAL
FillBufferedFile(
    HMMIO hmmio,
    LONG lLongs)
{
    MMIOINFO    mmioinfo;
    long        lOffset = 0;

    /* fill buffered file <hmmio> with <lLongs> binary long integers,
     * where offset X (such that X % 4 == 0) contains long integer X
     */

    /* begin direct access of the I/O buffer */
    WinEval(mmioGetInfo(hmmio, &mmioinfo, 0) == 0);

    for( ; ; )
    {
        long    lAvail;             // bytes available in buffer

        lAvail = mmioinfo.pchEndWrite - mmioinfo.pchNext;
        for( ; ; )
        {
            if ((lAvail -= sizeof(lOffset)) < 0)
                break;
            if (lLongs-- <= 0)
                goto EXIT_FUNCTION;
            *((long *) mmioinfo.pchNext) = lOffset;
            mmioinfo.pchNext = (long)mmioinfo.pchNext + sizeof(long);  // bypass compiler bug
            lOffset += sizeof(lOffset);
        }

        /* flush the I/O buffer */
        mmioinfo.dwFlags |= MMIO_DIRTY;
        WinEval(mmioAdvance(hmmio, &mmioinfo, MMIO_WRITE) == 0);
        WinAssert((mmioinfo.pchNext + sizeof(lOffset))
            <= mmioinfo.pchEndWrite);
    }

EXIT_FUNCTION:

    /* end direct access of the I/O buffer */
    mmioinfo.dwFlags |= MMIO_DIRTY;
    WinEval(mmioSetInfo(hmmio, &mmioinfo, 0) == 0);

    /* make sure we're where we think we should be */
    WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == lOffset);
}


void NEAR PASCAL
Test3(
    HWND hwnd)
{
    HMMIO       hmmio;
    DWORD       dwFlags;
    MMIOINFO    mmioinfo;

    for (dwFlags = 0; dwFlags <= MMIO_ALLOCBUF; dwFlags += MMIO_ALLOCBUF)
    {
        WinEval((hmmio = mmioOpen("test3.tmp", NULL,
            dwFlags | MMIO_CREATE | MMIO_WRITE)) != NULL);
        dprintf("TestRIFF(), %s, MMIO_WRITE: ",
            (LPSTR) (dwFlags == 0 ? "unbuffered" : "buffered"));
        TestRIFF(hmmio, FALSE);
        WinEval(mmioClose(hmmio, 0) == 0);

        WinEval((hmmio = mmioOpen("test3.tmp", NULL,
            dwFlags | MMIO_CREATE | MMIO_READWRITE)) != NULL);
        dprintf("TestRIFF(), %s, MMIO_READWRITE: ",
            (LPSTR) (dwFlags == 0 ? "unbuffered" : "buffered"));
        TestRIFF(hmmio, TRUE);
        WinEval(mmioClose(hmmio, 0) == 0);
    }

    /* create a memory file */
    memset(&mmioinfo, 0, sizeof(mmioinfo));
    mmioinfo.fccIOProc = FOURCC_MEM;
    mmioinfo.pchBuffer = NULL;
    mmioinfo.cchBuffer = 1L;    // initial size
    mmioinfo.adwInfo[0] = 1L;   // grow by this much
    WinEval((hmmio = mmioOpen(NULL, &mmioinfo,
        MMIO_CREATE | MMIO_READWRITE)) != NULL);
    dprintf("TestRIFF() with memory file: ");
    TestRIFF(hmmio, TRUE);
    WinEval(mmioClose(hmmio, 0) == 0);

    dprintf("delete the test file using MMIO_DELETE\n");
    WinEval(mmioOpen("test3.tmp", NULL, MMIO_DELETE) == (HANDLE) TRUE);
}


/* Output from TestRIFF():
 *
 * 00000000 RIFF (0001E32A) 'foo '
 * 0000000C     abc1 (00000001)
 * 00000016     abc2 (00000002)
 * 00000020     abc3 (00000003)
 * 0000002C     abc4 (00000004)
 * 00000038     abc5 (00000005)
 * 00000046     abc6 (00000006)
 * 00000054     abc7 (00000007)
 * 00000064     LIST (0000007E) 'data'
 * 00000070         num1 (00000001)
 * 0000007A         num2 (00000002)
 * 00000084         num3 (00000003)
 * 00000090         num4 (00000004)
 * 0000009C         num5 (00000005)
 * 000000AA         num6 (00000006)
 * 000000B8         num7 (00000007)
 * 000000C8         num8 (00000008)
 * 000000D8         num9 (00000009)
 * 000000EA     xyz  (0001E240)
 * 0001E332
 */

void NEAR PASCAL
TestRIFF(
    HMMIO hmmio,
    BOOL fReadable)
{
    MMCKINFO    ckRIFF;
    MMCKINFO    ckLIST;
    MMCKINFO    ck;
    HPSTR       pchBuf, pchStart;
    int huge *  pi;
    int     i;

    #define FOURCC_FOO  mmioFOURCC('f', 'o', 'o', ' ')
    #define FOURCC_ABC  mmioFOURCC('a', 'b', 'c', ' ')
    #define FOURCC_DATA mmioFOURCC('d', 'a', 't', 'a')
    #define FOURCC_NUM  mmioFOURCC('n', 'u', 'm', ' ')
    #define FOURCC_XYZ  mmioFOURCC('x', 'y', 'z', ' ')

    dprintf("write file");

    /* create 'RIFF' chunk, formtype ' */
    ckRIFF.cksize = 0L;
    ckRIFF.fccType = FOURCC_FOO;
    WinEval(mmioCreateChunk(hmmio, &ckRIFF, MMIO_CREATERIFF) == 0);

    /* create chunks 'abc1' ... 'abc7' -- the data for the i-th chunk
     * is the first i uppercase letters of the alphabet
     */
    for (i = 1; i <= 7; i++)
    {
        MMCKINFO    ck;

        ck.ckid = FOURCC_ABC;
        ((NPSTR) (&ck.ckid))[3] = (CHAR)'0' + (CHAR)i;
        ck.cksize = 8 + i;
        WinEval(mmioCreateChunk(hmmio, &ck, 0) == 0);
        WinEval(mmioWrite(hmmio, "ABCDEFG", (LONG) i) == (LONG) i);
        WinEval(mmioAscend(hmmio, &ck, 0) == 0);
    }

    /* create a LIST chunk with list type 'data' */
    ckLIST.cksize = 0L;
    ckLIST.fccType = FOURCC_DATA;
    WinEval(mmioCreateChunk(hmmio, &ckLIST, MMIO_CREATELIST) == 0);

    /* create chunks 'num1' ... 'num9' -- the data for the i-th chunk
     * is the first i positive numbers
     */
    for (i = 1; i <= 9; i++)
    {
        ck.ckid = FOURCC_NUM;
        ((NPSTR) (&ck.ckid))[3] = (CHAR)'0' + (CHAR)i;
        ck.cksize = 77; // make medAscend() work for a living
        WinEval(mmioCreateChunk(hmmio, &ck, 0) == 0);
        WinEval(mmioWrite(hmmio, "123456789", (LONG) i) == (LONG) i);
        WinEval(mmioAscend(hmmio, &ck, 0) == 0);
    }

    /* ascend from the LIST chunk */
    WinEval(mmioAscend(hmmio, &ckLIST, 0) == 0);

    /* write 'xyz' chunk to contain 123456 bytes that are filled with
     * short integers 0 to 123456/2 - 1; make the buffer misaligned
     * by 32768 bytes
     */

    if ((pchBuf = GAllocPtr(123456L + 32768L)) == NULL)
    {
        dprintf("test program problem: out of memory\n");
        WinAssert(FALSE);
    }
    pchStart = pchBuf + 32768L;

    for (pi = (int huge *) pchStart, i = 0; i < (int) (123456L / sizeof(int)); // (Win32)
         pi++, i++)
        *pi = i;

    ck.ckid = FOURCC_XYZ;
    WinEval(mmioCreateChunk(hmmio, &ck, 0) == 0);
    WinEval(mmioWrite(hmmio, pchStart, 123456L) == 123456L);
    WinEval(mmioAscend(hmmio, &ck, 0) == 0);

    /* ascend from the RIFF chunk */
    WinEval(mmioAscend(hmmio, &ckRIFF, 0) == 0);
    WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 0x0001E332L);

    /* destroy data in <pchStart>, <ck>, etc. to ensure a
     * valid test
     */
#ifdef OMIT
    lmemset(pchStart, 12, 123456L);
#else
    memset(pchStart, 12, 123456L);
#endif //OMIT
    memset(&ckRIFF, 34, sizeof(ckRIFF));
    memset(&ckLIST, 56, sizeof(ckLIST));
    memset(&ck, 78, sizeof(ck));

    if (fReadable)
    {
        dprintf(", read file");

        /* seek back */
        WinEval(mmioSeek(hmmio, 0L, SEEK_SET) == 0L);

        /* descend into RIFF chunk */
        WinEval(mmioDescend(hmmio, &ckRIFF, NULL, 0) == 0);
        WinAssert(ckRIFF.ckid == FOURCC_RIFF);
        WinAssert(ckRIFF.cksize == 0x0001E32AL);
        WinAssert(ckRIFF.fccType == FOURCC_FOO);
        WinAssert(ckRIFF.dwDataOffset == 0x00000000L + 8L);
        WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 0x0000000CL);

        /* find all the 'abc' chunks */
        for (i = 1; i <= 7; i++)
        {
            MMCKINFO    ck;
            char        ach[10];

            /* seek back to start of RIFF chunk data */
            WinEval(mmioSeek(hmmio, 12L, SEEK_SET) == 12L);
            ck.ckid = FOURCC_ABC;
            ((NPSTR) (&ck.ckid))[3] = (CHAR)'0' + (CHAR)i;
            WinEval(mmioDescend(hmmio, &ck, &ckRIFF,
                                MMIO_FINDCHUNK) == 0);
            WinAssert(ck.cksize == (UINT)i);
            WinAssert(ck.fccType == 0);
            WinEval(mmioRead(hmmio, ach, (LONG) i) == (LONG) i);
            WinEval(lstrncmp(ach, "ABCDEFG", i) == 0);
            if (i != 7)
                WinEval(mmioAscend(hmmio, &ck, 0) == 0);
        }

        /* we're down two levels -- ascend to end of RIFF chunk */
        WinEval(mmioAscend(hmmio, &ckRIFF, 0) == 0);
        WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 0x0001E332L);

        /* seek back to start of RIFF chunk data */
        WinEval(mmioSeek(hmmio, 12L, SEEK_SET) == 12L);

        /* make sure we cannot find 'num1' chunk */
        ck.ckid = mmioFOURCC('n', 'u', 'm', '1');
        WinEval(mmioDescend(hmmio, &ck, &ckRIFF, MMIO_FINDCHUNK)
            == MMIOERR_CHUNKNOTFOUND);

        /* seek back to start of RIFF chunk data */
        WinEval(mmioSeek(hmmio, 12L, SEEK_SET) == 12L);

        /* make sure we can find 'data' list */
        ckLIST.fccType = FOURCC_DATA;
        WinEval(mmioDescend(hmmio, &ckLIST, &ckRIFF, MMIO_FINDLIST)
                == 0);
        WinAssert(ckLIST.ckid == FOURCC_LIST);
        WinAssert(ckLIST.fccType == FOURCC_DATA);
        WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 0x00000064L + 12L);

        /* descend into each of the 'num' chunks */
        for (i = 1; i <= 9; i++)
        {
            FOURCC      fcc;
            MMCKINFO    ck;
            char        ach[10];

            fcc = FOURCC_ABC;
            ((NPSTR) (&fcc))[3] = (CHAR)'0' + (CHAR)i;
            WinEval(mmioDescend(hmmio, &ck, &ckLIST, 0) == 0);
            WinAssert(ck.cksize == (UINT)i);
            WinAssert(ck.fccType == 0);
            WinEval(mmioRead(hmmio, ach, (LONG) i) == (LONG) i);
            WinEval(lstrncmp(ach, "123456789", i) == 0);
            WinEval(mmioAscend(hmmio, &ck, 0) == 0);
        }

        /* make sure we cannot go any further */
        WinEval(mmioDescend(hmmio, &ck, &ckLIST, 0)
                == MMIOERR_CHUNKNOTFOUND);

        /* seek back to start of RIFF chunk data */
        WinEval(mmioSeek(hmmio, 12L, SEEK_SET) == 12L);

        /* seek to the 'xyz' chunk */
        ck.ckid = FOURCC_XYZ;
        WinEval(mmioDescend(hmmio, &ck, &ckRIFF, MMIO_FINDCHUNK) == 0);
        WinAssert(ck.ckid == FOURCC_XYZ);
        WinAssert(ck.fccType == 0);
        WinEval(mmioRead(hmmio, pchStart, 123456L) == 123456L);
        WinEval(mmioAscend(hmmio, &ck, 0) == 0);

        /* ascend from the RIFF chunk */
        WinEval(mmioAscend(hmmio, &ckRIFF, 0) == 0);
        WinEval(mmioSeek(hmmio, 0L, SEEK_CUR) == 0x0001E332L);

        /* check the contents of the 'xyz' chunk */
        for (pi = (int huge *) pchStart, i = 0; i < (int) (123456L / sizeof(int)); // (Win32)
             pi++, i++)
        {
            WinAssert(*pi == i);
        }
    }

    GFreePtr(pchBuf);

    dprintf(", done.\n");
}


/* sz = lstrrchr(szSrc, ch)
 *
 * Find the last occurence <sz> (NULL if not found) of <p ch> in <p szSrc>.
 */
LPSTR NEAR PASCAL
lstrrchr(
    LPSTR szSrc,
    char ch)
{
    LPSTR   szLast = NULL;

    do
    {
        if (*szSrc == ch)
            szLast = szSrc;
    } while (*szSrc++ != 0);

    return szLast;
}

#ifdef OMIT
/* lmemset(pDst, bSrc, cDst)
 *
 * Set all <cDest> bytes in memory block <pDst> to a byte value <bSrc>.
 */
void NEAR PASCAL
lmemset(
    void far *pDst,
    BYTE bSrc,
    long cDst)
{
    while (cDst-- > 0)
        *((BYTE huge *) pDst)++ = bSrc;
}
#endif //OMIT

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\playsnd\help.c ===
/*
    help.c

    Support for the HELP menu item

*/

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include "PlaySnd.h"

void Help(HWND hWnd, DWORD wParam)
{
    char szHelpFileName[_MAX_PATH];

    strcpy(szHelpFileName, szAppName);
    strcat(szHelpFileName, ".HLP");

    switch (wParam) {
    case IDM_HELP_INDEX:
        WinHelp(hWnd, szHelpFileName, HELP_INDEX, (DWORD)0);
        break;

    case IDM_HELP_KEYBOARD:
        WinHelp(hWnd, szHelpFileName, HELP_KEY, (DWORD)(LPSTR)"keys");
        break;

    case IDM_HELP_HELP:
		WinHelp(hWnd, "WINHELP.HLP", HELP_INDEX, 0L);
        break;

    default:
        break;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\playsnd\debug.c ===
/*
    debug.c

    debugging menu support

    Debug level info is in WIN.INI in the [debug] section:

        [debug]
        App=0               level for App

*/

#include <stdio.h>
#include <windows.h>
#include "PlaySnd.h"
#include <stdarg.h>

#ifdef MEDIA_DEBUG

extern void winmmSetDebugLevel(int level);

void dDbgSetDebugMenuLevel(int i)
{
    HMENU hMenu;
    UINT m;

    if ((i < 0) || (i > 4)) i = 4;
    hMenu = GetMenu(ghwndMain);

    for (m=IDM_DEBUG0; m<=IDM_DEBUG4; m++) {
        CheckMenuItem(hMenu, m, MF_UNCHECKED);
    }

    CheckMenuItem(hMenu, (i + IDM_DEBUG0), MF_CHECKED);
    __iDebugLevel = i;
    dprintf3(("Debug level set to %d", i));

    //
    // set the winmm dll debug level to be the same
    //

    winmmSetDebugLevel(i);
}

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/

void dDbgOut(LPSTR lpszFormat, ...)
{
    int i;
    char buf[256];
    va_list va;

    sprintf(buf, "%s: ", szAppName);
    OutputDebugString(buf);

    va_start(va, lpszFormat);
    i = vsprintf(buf, lpszFormat, va);
    va_end(va);

    OutputDebugString(buf);

    OutputDebugString("\n");
}

/***************************************************************************

    @doc INTERNAL

    @api int | dDbgGetLevel | This function gets the current debug level
        for a module.

    @parm LPSTR | lpszModule | The name of the module.

    @rdesc The return value is the current debug level.

    @comm The information is kept in the [debug] section of WIN.INI

****************************************************************************/

int dDbgGetLevel(LPSTR lpszAppName)
{
#ifdef MEDIA_DEBUG
    return GetProfileInt("MMDEBUG", lpszAppName, 4);
#else
    return GetProfileInt("MMDEBUG", lpszAppName, 1);
#endif
}

/***************************************************************************

    @doc INTERNAL

    @api int | dDbgSaveLevel | This function saves the current debug level
        for a module.

    @parm LPSTR | lpszModule | The name of the module.
    @parm int | iLevel | The value to save.

    @rdesc There is no return value.

    @comm The information is kept in the [debug] section of WIN.INI

****************************************************************************/

void dDbgSaveLevel(LPSTR lpszAppName, int iLevel)
{
    char buf[80];

    sprintf(buf, "%d", iLevel);
    WriteProfileString("MMDEBUG", lpszAppName, buf);
}

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgAssert | This function shows an assert message box.

    @parm LPSTR | exp | Pointer to the expression string.
    @parm LPSTR | file | Pointer to the file name.
    @parm int | line | The line number.

    @rdesc There is no return value.

    @comm We try to use the current active window as the parent. If
        this fails we use the desktop window.  The box is system
        modal to avoid any trouble.

****************************************************************************/

void dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    char bufTmp[256];
    int iResponse;
    HWND hWnd;

    sprintf(bufTmp,
        "Expression: %s\nFile: %s, Line: %d\n\nAbort:  Exit Process\nRetry:  Enter Debugger\nIgnore: Continue",
        exp, file, line);

    // try to use the active window, but NULL is ok if there
    // isn't one.

    hWnd = GetActiveWindow();

    iResponse = MessageBox(hWnd,
                           bufTmp,
                           "Assertion Failure - continue?",
                           MB_TASKMODAL
                            | MB_ICONEXCLAMATION
                            | MB_DEFBUTTON3
                            | MB_OKCANCEL);

    switch (iResponse) {
        case 0:
            dprintf1(("Assert message box failed"));
            dprintf2(("  Expression: %s", exp));
            dprintf2(("  File: %s,  Line: %d", file, line));
            break;
        case IDCANCEL:
            ExitProcess(1);
            break;
        case IDOK:
            break;
        default:
            dprintf1(("Assert message box failed"));
            dprintf2(("  Expression: %s", exp));
            dprintf2(("  File: %s,  Line: %d", file, line));
            break;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\playsnd\file.c ===
/*

    file.c

    File i/o module

*/

#include <stdlib.h>
#include <windows.h>
#include <string.h>
#include <commdlg.h>
#include "PlaySnd.h"



OPENFILENAME ofn;		        // passed to the File Open/save APIs

void PlayFile()
{
    char szFileName[_MAX_PATH];
    DWORD dwFlags;

    szFileName[0] = 0;
    ofn.lStructSize         = sizeof(ofn);
    ofn.hwndOwner           = ghwndMain;
    ofn.hInstance           = ghModule;
    ofn.lpstrFilter         = "Wave Files\0*.wav\0All Files\0*.*\0\0";
    ofn.lpstrCustomFilter   = NULL;
    ofn.nMaxCustFilter      = 0;
    ofn.nFilterIndex        = 1;
    ofn.lpstrFile           = szFileName;
    ofn.nMaxFile            = sizeof(szFileName);
    ofn.lpstrFileTitle      = NULL;
    ofn.nMaxFileTitle       = 0;
    ofn.lpstrInitialDir     = ".";
    ofn.lpstrTitle          = "File Open";
    ofn.Flags               = 0;
    ofn.nFileOffset         = 0;
    ofn.nFileExtension      = 0;
    ofn.lpstrDefExt         = NULL;
    ofn.lCustData           = 0;
    ofn.lpfnHook            = NULL;
    ofn.lpTemplateName      = NULL;


    dprintf3(("Calling GetOpenFileName"));
    if (GetOpenFileName(&ofn)) {

        dwFlags = SND_FILENAME;

        if (bSync) {
			WinAssert(!SND_SYNC);
		} else {
			dwFlags |= SND_ASYNC;
		}

        if (bNoWait) dwFlags |= SND_NOWAIT;

        if (!PlaySound(szFileName, NULL, dwFlags | bNoDefault)) {
            Error("Failed to play file: %s", szFileName);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\playsnd\init.c ===
/*
    init.c

    initialisation, termination and error handling code

*/

#include <stdio.h>
#include <windows.h>
#include "PlaySnd.h"
#include <stdarg.h>


/***************************************************************************

    @doc INTERNAL

    @api BOOL | InitApp | Initialise the application.

    @rdesc The return value is TRUE if the application is successfully
        initialised, otherwise it is FALSE.

***************************************************************************/

BOOL InitApp()
{
    WNDCLASS wc;

    // set up our module handle for resource loading etc.

    ghModule = GetModuleHandle(NULL);

    // get the name of our app
    WinEval(LoadString(ghModule, IDS_APPNAME, szAppName, sizeof(szAppName)));

    // load the profile info
    bSync = GetProfileInt(szAppName, "bSync", 0);
    bNoWait = GetProfileInt(szAppName, "bNoWait", 0);
    bResourceID = GetProfileInt(szAppName, "bResourceID", 0);

#ifdef MEDIA_DEBUG
    // If we are in DEBUG mode, get debug level for this module
    dGetDebugLevel(szAppName);
    dprintf(("started (debug level %d)", __iDebugLevel));
#endif

    // define the class of the main window

    wc.lpszClassName    = szAppName;
    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon            = LoadIcon(ghModule, MAKEINTRESOURCE(IDI_ICON));
    wc.lpszMenuName     = MAKEINTRESOURCE(IDM_MENU); // "Menu";
    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE+1);
    wc.hInstance        = ghModule;
    wc.lpfnWndProc      = (WNDPROC)MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;

    WinEval(RegisterClass(&wc));

    // create a window for the application

    ghwndMain = CreateWindow(szAppName,
                        szAppName,
                        WS_OVERLAPPEDWINDOW,
                        GetSystemMetrics(SM_CXSCREEN) / 8,
                        GetSystemMetrics(SM_CYSCREEN) / 4,
                        GetSystemMetrics(SM_CXSCREEN) * 4 / 5,
                        GetSystemMetrics(SM_CYSCREEN) / 3,
                        (HWND)NULL,
                        (HMENU)NULL,
                        ghModule,
                        (LPSTR)NULL
                        );

    WinAssert(ghwndMain);

#ifdef MEDIA_DEBUG
    dDbgSetDebugMenuLevel(__iDebugLevel);   // set debug menu state
#endif

    ShowWindow(ghwndMain, SW_SHOWNORMAL);
    UpdateWindow(ghwndMain); // paint it


    return TRUE;
}

/***************************************************************************

    @doc INTERNAL

    @api void | CreateApp | Initialise the application when WM_CREATE
        message is received.

    @parm HWND | hWnd | Handle to the parent window.

    @rdesc There is no return value.

***************************************************************************/

void CreateApp(HWND hWnd)
{
    hWnd;
}

/***************************************************************************

    @doc INTERNAL

    @api void | TerminateApp | Terminate the application.

    @parm LPSTR | lpszFormat | A printf style format string
    @parm ... | ... | Printf style args

    @rdesc There is no return value.

***************************************************************************/

void TerminateApp()
{
    char buf[20];

    // save profile info
    sprintf(buf, "%d", bSync);
    WriteProfileString(szAppName, "bSync", buf);
    sprintf(buf, "%d", bNoWait);
    WriteProfileString(szAppName, "bNoWait", buf);
    sprintf(buf, "%d", bResourceID);
    WriteProfileString(szAppName, "bResourceID", buf);


    dprintf(("ending", szAppName));
    dSaveDebugLevel(szAppName);
}

/***************************************************************************

    @doc INTERNAL

    @api void | Error | Show an error message box.

    @rdesc There is no return value.

***************************************************************************/

void Error(LPSTR lpszFormat, ...)
{
    int i;
    char buf[256];
    va_list va;

    va_start(va, lpszFormat);
    i = vsprintf(buf, lpszFormat, va);
    va_end(va);

    MessageBeep(MB_ICONEXCLAMATION);
    MessageBox(ghwndMain, buf, szAppName, MB_OK | MB_ICONEXCLAMATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\playsnd\playsnd.c ===
/*
    PlaySnd.c

    This is a PlaySnd Win32 app

*/

#include <windows.h>
#include "PlaySnd.h"

/* useful global things */

HANDLE ghModule;                // global module handle
char szAppName[SIZEOFAPPNAME];  // app name
HWND ghwndMain;                 // handle of main window
BOOL bNoWait;
BOOL bNoDefault = SND_NODEFAULT;
BOOL bSync;
BOOL bResourceID;

//
// local fns
//

void MyBeep(DWORD wParam);

/***************** Main entry point routine *************************/

int __cdecl main(int argc, char *argv[], char *envp[])
{
    MSG msg;
    HANDLE hAccTable;           /* handle to keyboard accelerator table */

    UNREFERENCED_PARAMETER(envp);

    if (argc > 1) {

        // assume that the first arg is a filename
		dprintf1(("Calling PLAYSOUND to play %s", argv[1]));

		WinAssert(SND_ASYNC);

        PlaySound(argv[1], NULL, SND_SYNC | SND_FILENAME | bNoDefault);
        return 0;
    }

    // try to init the main part of the app
    if (! InitApp()) {
		dprintf(("Failed to initialise correctly"));
        return 1;
    }

    /* load the keyboard accelerator table */

    hAccTable = LoadAccelerators(ghModule, MAKEINTRESOURCE(IDA_ACCTABLE)/*"AccTable" */);
    WinAssert(hAccTable);

    /* check for messages from Windows and process them */

    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator(ghwndMain, hAccTable, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return 0;
}

/************* main window message handler ******************************/

int APIENTRY MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    HMENU hMenu;
    PAINTSTRUCT ps;             /* paint structure */

    /* process any messages we want */

    switch(message) {
    case WM_CREATE:
        break;

    case WM_SIZE:
        break;

    case WM_INITMENUPOPUP:
        // show the option flag states
		dprintf2(("WM_INITMENUPOPUP %8x %8x %8x",hWnd, wParam, lParam));
        hMenu = GetMenu(hWnd);
        CheckMenuItem(hMenu, IDM_SYNC, bSync ? MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_NOWAIT, bNoWait ? MF_CHECKED : MF_UNCHECKED);

        // Note: we are slightly naughty here.  bNoDefault is not a true
        // boolean value.  It will contain SND_NODEFAULT or NULL
        CheckMenuItem(hMenu, IDM_NODEFAULT, bNoDefault ? MF_CHECKED : MF_UNCHECKED);

        CheckMenuItem(hMenu, IDM_RESOURCEID, bResourceID ? MF_CHECKED : MF_UNCHECKED);

	ModifyMenu(hMenu, IDM_HELP_KEYBOARD, MF_GRAYED | MF_STRING, IDM_HELP_KEYBOARD, "&Keyboard"); 

#ifdef MEDIA_DEBUG
		CheckMenuItem(hMenu, (__iDebugLevel + IDM_DEBUG0), MF_CHECKED);
#endif
        break;

    case WM_COMMAND:
        /* process menu messages */
        CommandMsg(hWnd, wParam);
        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        EndPaint(hWnd, &ps);
        break;

    case WM_DESTROY:
        TerminateApp();
        PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }
    return 0;
}

void CommandMsg(HWND hWnd, DWORD wParam)
{
    /* process any WM_COMMAND messages we want */

    switch (wParam) {
    case IDM_PLAYFILE:
        PlayFile();
        break;

    case IDM_SOUNDS:
        Sounds(hWnd);
        break;

    case IDM_DING:
    case IDM_SIREN:
    case IDM_LASER:
        Resource(wParam);
        break;

    case IDM_ICONHAND:
    case IDM_ICONQUESTION:
    case IDM_ICONEXCLAMATION:
    case IDM_ICONASTERISK:
    case IDM_SYNC_ICONHAND:
    case IDM_SYNC_ICONQUESTION:
    case IDM_SYNC_ICONEXCLAMATION:
    case IDM_SYNC_ICONASTERISK:
        MyBeep(wParam);
        break;

    case IDM_RESOURCEID:
        bResourceID = !bResourceID;
        break;

    case IDM_SYNC:
        bSync = !bSync;
        break;

    case IDM_NOWAIT:
        bNoWait = !bNoWait;
        break;

    case IDM_NODEFAULT:
        if (bNoDefault) {
            bNoDefault = 0;
        } else {
            bNoDefault = SND_NODEFAULT;
        }
        break;

    case IDM_ABOUT:
        About(hWnd);
        break;

    case IDM_HELP_INDEX:
    case IDM_HELP_KEYBOARD:
    case IDM_HELP_HELP:
        Help(hWnd, wParam);
        break;

#ifdef MEDIA_DEBUG
    case IDM_DEBUG0:
    case IDM_DEBUG1:
    case IDM_DEBUG2:
    case IDM_DEBUG3:
    case IDM_DEBUG4:
        dDbgSetDebugMenuLevel((int)(wParam - IDM_DEBUG0));
        break;
#endif

    case IDM_EXIT:
        PostMessage(hWnd, WM_CLOSE, 0, 0l);
        break;

    default:
        break;
    }
}

void MyBeep(DWORD wParam)
{
    DWORD dwFlags = MB_OK;
	LPSTR lpstr = NULL;

    switch (wParam) {
    case IDM_SYNC_ICONHAND:
    case IDM_SYNC_ICONQUESTION:
    case IDM_SYNC_ICONEXCLAMATION:
    case IDM_SYNC_ICONASTERISK:
        dwFlags |= MB_TASKMODAL;
        break;
    }

    switch (wParam) {
    case IDM_ICONHAND:
    case IDM_SYNC_ICONHAND:
        dwFlags |= MB_ICONHAND;
        lpstr =  "MB_ICONHAND";
        break;

    case IDM_ICONQUESTION:
    case IDM_SYNC_ICONQUESTION:
        dwFlags |= MB_ICONQUESTION;
        lpstr =  "MB_ICONQUESTION";
        break;

    case IDM_ICONEXCLAMATION:
    case IDM_SYNC_ICONEXCLAMATION:
        dwFlags |= MB_ICONEXCLAMATION;
        lpstr = "MB_ICONEXCLAMATION";
        break;

    case IDM_ICONASTERISK:
    case IDM_SYNC_ICONASTERISK:
        dwFlags |= MB_ICONASTERISK;
        lpstr = "MB_ICONASTERISK";
        break;

    default:
        break;

    }
	if (lpstr) {
		dprintf2(("Calling Message beep with flags %8x  Type %s", dwFlags, lpstr));
        MessageBeep((UINT)dwFlags);
		dprintf2(("Now calling MessageBox"));
        MessageBox(ghwndMain, lpstr, szAppName, (UINT)dwFlags);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\playsnd\sounddlg.h ===
#define IDSND_SOUNDNAME 103
#define IDSND_LIST   102
#define IDSND_PLAY   101
#define IDSND_IDPLAY 100
#define IDSND_SYNC   99
#define IDSND_WAIT   98
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\playsnd\sound.c ===
/*
    sound.c

    Sound menu stuff

    Puts up a list of all the sounds in the [sounds]
    section of win.ini and plays the selected one


*/

#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <commdlg.h>
#include "PlaySnd.h"

#define KEYBUFSIZE 2048

LONG SoundDlgProc(HWND hDlg, UINT msg, DWORD wParam, LONG lParam);

typedef struct SoundNameAlias {
	LPSTR pName;
	UINT  alias;
} SOUNDNAMEALIAS;

static SOUNDNAMEALIAS sss[] = {"System"};

static SOUNDNAMEALIAS SNA[] = {
      "SystemAsterisk",     sndAlias('S', '*')   ,
      "SystemQuestion",     sndAlias('S', '?')   ,
      "SystemHand",         sndAlias('S', 'H')   ,
      "SystemExit",         sndAlias('S', 'E')   ,
      "SystemStartup",      sndAlias('S', 'S')   ,
	  "SystemWelcome",      sndAlias('S', 'W')   ,
      "SystemExclamation",  sndAlias('S', '!')	 ,
      "SystemDefault",      sndAlias('S', 'D')   };
											
#define NUMSYSTEMSOUNDS (sizeof(SNA)/sizeof(SOUNDNAMEALIAS))

UINT TranslateNameToAlias(LPSTR name)
{
	UINT n;

	for (n=0; n<NUMSYSTEMSOUNDS; ++n) {

		if (!lstrcmpi(name, SNA[n].pName)) {
			return(SNA[n].alias);
		}
	}

	return(0);
}

void Sounds(HWND hWnd)
{
    WinEval(DialogBox(ghModule, MAKEINTRESOURCE(IDD_SOUNDDLG) // "SoundDlg"
			, hWnd, (DLGPROC)SoundDlgProc) != -1);
}

void PlaySelection(HWND hDlg)
{
    DWORD dwSel;
    DWORD dwFlags = SND_ASYNC | bNoDefault | SND_NOSTOP;
    char name[40];
	UINT alias;
	LPSTR pName = name;
	BOOL fSync;
	BOOL fWait;

    dwSel = SendDlgItemMessage(hDlg, IDSND_LIST, LB_GETCURSEL, 0, 0);
    if (dwSel != LB_ERR) {
        SendDlgItemMessage(hDlg, IDSND_LIST,
                    LB_GETTEXT,
                    (WPARAM)dwSel,
                    (LPARAM)name);

        dwFlags = SND_ALIAS;

		fSync = (BOOL)SendDlgItemMessage(hDlg, IDSND_SYNC, BM_GETCHECK, 0, 0);

        if (fSync) {
			// Turn off ASYNC
			dwFlags &= ~SND_ASYNC;
		} else {
			dwFlags |= SND_ASYNC;
		}

		fWait = (BOOL)SendDlgItemMessage(hDlg, IDSND_WAIT, BM_GETCHECK, 0, 0);
        if (!fWait) dwFlags |= SND_NOWAIT;

		if (1 == SendDlgItemMessage(hDlg, IDSND_IDPLAY, BM_GETCHECK, 0, 0)) {
			if (0 != (alias = TranslateNameToAlias(name))) {
				dwFlags |= SND_ALIAS_ID;
				pName = (LPSTR)alias;
			}
		}

        if (!PlaySound(pName, NULL, dwFlags | bNoDefault)) {
            Error("Failed to play alias: %s", name);
        }
    }

}

VOID SetSoundName(HWND hDlg)
{
    DWORD dwSel;
    char name[40];
	char filename[MAX_PATH];
	UINT n;

    dwSel = SendDlgItemMessage(hDlg, IDSND_LIST, LB_GETCURSEL, 0, 0);
    if (dwSel != LB_ERR
        && SendDlgItemMessage(hDlg, IDSND_LIST,
                    LB_GETTEXT,
                    (WPARAM)dwSel,
                    (LPARAM)name)
		&& (n=GetProfileString("SOUNDS", name, NULL, filename, sizeof(filename)))
       ) {
		do {
		   n--;
		   if (filename[n] == ',') {
			   filename[n]=0;
		   }
		}  while (filename[n]);
		GetFileTitle(filename, name, sizeof(name));
		SendDlgItemMessage(hDlg, IDSND_SOUNDNAME, WM_SETTEXT, 0, (LPARAM)name);
	} else {
		SendDlgItemMessage(hDlg, IDSND_SOUNDNAME, WM_SETTEXT, 0, (LPARAM)"<no selection>");
	}
}

LONG SoundDlgProc(HWND hDlg, UINT msg, DWORD wParam, LONG lParam)
{
    LPSTR lpBuf, lpKey;
    DWORD dwChars;

//  dprintf4(("SoundDlgProc: %8.8XH, %8.8XH, %8.8XH", msg, wParam, lParam));

    switch (msg) {
    case WM_INITDIALOG:
        // fill the listbox with the keys in the [sounds]
        // section of win.ini

        // allocate a buffer to put the keys in
        WinEval(lpBuf = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, KEYBUFSIZE));

        // get the key list
        dwChars = GetProfileString("sounds", NULL, "", lpBuf, KEYBUFSIZE);
        dprintf4(("%lu chars read from [sounds] section", dwChars));

        if (dwChars > 0) {
            // add each entry to the list box
            lpKey = lpBuf;
            while (*lpKey) {
				// TEMPORARY SECTION
				if (lstrcmpi((LPCTSTR)lpKey, "enable"))  // if not ENABLE
				// END OF TEMPORARY SECTION
                SendMessage(GetDlgItem(hDlg, IDSND_LIST),
                            LB_ADDSTRING,
                            0,
                            (LONG)lpKey);
                lpKey += strlen(lpKey) + 1;
            }
        } else {
            // show there aren't any
            SendMessage(GetDlgItem(hDlg, IDSND_LIST),
                        LB_ADDSTRING,
                        0,
                        (LONG)(LPSTR)"[none]");
        }
		SendDlgItemMessage(hDlg, IDSND_SOUNDNAME, WM_SETTEXT, 0, (LPARAM)"");

		if (bSync) {
			// Set the initial state of the Sync checkbox from global flag
			SendDlgItemMessage(hDlg, IDSND_SYNC, BM_SETCHECK, 1, 0);
		}

		if (!bNoWait) {
			// Set the initial state of the Wait checkbox from global flag
			SendDlgItemMessage(hDlg, IDSND_WAIT, BM_SETCHECK, 1, 0);
		}

        GlobalFree((HANDLE)lpBuf);

        // disable the play button till we get a selection
        EnableWindow(GetDlgItem(hDlg, IDSND_PLAY), FALSE);

        break;

    case WM_COMMAND:
        dprintf4(("WM_COMMAND: %08lXH, %08lX", wParam, lParam));
        switch (LOWORD(wParam)) {
        case IDOK:
            EndDialog(hDlg, TRUE);
            break;

        case IDSND_PLAY:
            // get the current selection and try to play it
            PlaySelection(hDlg);
            break;

        case IDSND_LIST:
            switch (HIWORD(wParam)){
            case LBN_SELCHANGE:
                // enable the play button
                EnableWindow(GetDlgItem(hDlg, IDSND_PLAY), TRUE);
                dprintf3(("Play button enabled"));
				// Set the current sound name
				SetSoundName(hDlg);
                break;

            case LBN_DBLCLK:
                PlaySelection(hDlg);
                break;

            default:
                break;
            }
            break;

        default:
            break;
        }
        break;

    default:
        return FALSE; // say we didn't handle it
        break;
    }

    return TRUE; // say we handled it
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\playsnd\res.c ===
/*
    res.c

    Resource menu stuff

*/

#include <stdlib.h>
#include <windows.h>
#include "PlaySnd.h"


void Resource(DWORD wParam)
{
    char *name;
    DWORD dwFlags;

    switch (wParam) {
    case IDM_DING:
        name = "ding";
        break;

    case IDM_SIREN:
        name = "siren";
        break;

    case IDM_LASER:
        name = "laser";
        break;

    default:
        name = NULL;
        Error("Don't know how to play that");
        break;
    }
	if (bResourceID) {
		name = (LPSTR)wParam;
	}

    if (name) {
        dwFlags = SND_RESOURCE;

        if (bSync) {
			WinAssert(!SND_SYNC);
		} else {
			dwFlags |= SND_ASYNC;
		}

        if (bNoWait) dwFlags |= SND_NOWAIT;
        if (!PlaySound(name, ghModule, dwFlags | bNoDefault)) {
			if (HIWORD(name)) {
				Error("Failed to play resource: %s  (by name)", name);
			} else {
				Error("Failed to play resource: %x  (by ID)", name);
			}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\callback.c ===
/****************************************************************************
 *
 *  callback.c
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include "sbtest.h"

#pragma alloc_text(SBTESTCBFIX, SBMidiInCallback)

//  NOTE this function is entered at interrupt time
//  NOTE don't touch the DATA segment, it is not setup!!!!!!

void FAR PASCAL SBMidiInCallback(HMIDIIN hMidiIn, UINT wMsg, DWORD dwInstance,
					     DWORD dwParam1, DWORD dwParam2)
{
    if (dwInstance) {
        if ((wMsg == MM_MIM_DATA) && ((dwParam1 & 0x000000F0) != 0x000000F0))
            // don't allow system messages (e.g. active sensing!)
            midiOutShortMsg((HMIDIOUT)dwInstance, dwParam1);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\init.c ===
/****************************************************************************
 *
 *  init.c
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include "sbtest.h"

/****************************************************************************
 *
 *  public data
 *
 ***************************************************************************/

HANDLE hAccTable;           // handle to keyboard accelerator table
HWND   hMainWnd;            // main window
int    gInstBase;

BOOL InitFirstInstance(HANDLE hInstance)
{
WNDCLASS wc;

    // define the class of window we want to register

    wc.lpszClassName    = szAppName;
    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon            = LoadIcon(hInstance, "Icon");
    wc.lpszMenuName     = "Menu";
    wc.hbrBackground    = GetStockObject(WHITE_BRUSH);
    wc.hInstance        = hInstance;
    wc.lpfnWndProc      = MainWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;

    if (!RegisterClass(&wc))
        return FALSE;

    // define a class for our keyboard

    wc.lpszClassName    = "SYNTHKEYS";
    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.hCursor          = LoadCursor(NULL, IDC_UPARROW);
    wc.hIcon            = NULL;
    wc.lpszMenuName     = NULL;
    wc.hbrBackground    = GetStockObject(WHITE_BRUSH);
    wc.hInstance        = hInstance;
    wc.lpfnWndProc      = KeyWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;

    if (!RegisterClass(&wc))
        return FALSE;

    // define a class for our position display

    wc.lpszClassName    = "POSITION";
    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.hCursor          = LoadCursor(NULL, IDC_UPARROW);
    wc.hIcon            = NULL;
    wc.lpszMenuName     = NULL;
    wc.hbrBackground    = GetStockObject(WHITE_BRUSH);
    wc.hInstance        = hInstance;
    wc.lpfnWndProc      = PosWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;

    if (!RegisterClass(&wc))
        return FALSE;

    // define a class for our selector

    wc.lpszClassName    = "SELECTOR";
    wc.style            = CS_HREDRAW | CS_VREDRAW;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon            = NULL;
    wc.lpszMenuName     = NULL;
    wc.hbrBackground    = GetStockObject(WHITE_BRUSH);
    wc.hInstance        = hInstance;
    wc.lpfnWndProc      = InstWndProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;

    if (!RegisterClass(&wc))
        return FALSE;

    fDebug = 0;

    return TRUE;
}

BOOL InitEveryInstance(HANDLE hInstance, int cmdShow)
{
    // create a window for the application

    hMainWnd = CreateWindow(szAppName,          // class name
                        szAppName,              // caption text
                        WS_OVERLAPPEDWINDOW,    // window style
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        (HWND)NULL,         // handle of parent window
                        (HMENU)NULL,        // menu handle (default class)
                        hInstance,          // handle to window instance
                        (LPSTR)NULL);       // no params to pass on

    if (!hMainWnd)
        return FALSE;

    ShowWindow(hMainWnd, cmdShow); // display window as open or icon
    UpdateWindow(hMainWnd);     // paint it

    // load the keyboard accelerator table

    hAccTable = LoadAccelerators(hInstance, "AccTable");
    if (!hAccTable)
        return FALSE;

    gInstBase = GetProfileInt(szAppName, "InstrumentBase", 0);

    return TRUE;

}

void InitMenus(HWND hWnd)
{
UINT n;
UINT wDevice;
UINT wRet;
HMENU hMenu;
MIDIOUTCAPS moc;
MIDIINCAPS  mic;

    hMenu = GetMenu(hWnd);

    // no output device is the default
    ModifyMenu(hMenu, IDM_D0, MF_BYCOMMAND | MF_ENABLED | MF_STRING,
                      IDM_D0, "None");
    CheckMenuItem(hMenu, IDM_D0, MF_CHECKED);

    n = midiOutGetNumDevs();
    for (wDevice = 1; wDevice <= n; wDevice++) {
        wRet = midiOutGetDevCaps(wDevice - 1, &moc, sizeof(moc));
        if (wRet == 0) {
            ModifyMenu(hMenu, wDevice + IDM_D0,
                       MF_BYCOMMAND | MF_ENABLED | MF_STRING,
                       wDevice + IDM_D0, moc.szPname);
        }
        else {
            ModifyMenu(hMenu, wDevice + IDM_D0,
                       MF_BYCOMMAND | MF_ENABLED | MF_STRING,
                       wDevice + IDM_D0, "ERROR");
        }
    }
    for (wDevice = n + 1; wDevice < LASTPORT; wDevice++)
        DeleteMenu(hMenu, wDevice + IDM_D0, MF_BYCOMMAND);

    ModifyMenu(hMenu, LASTPORT + IDM_D0, MF_BYCOMMAND | MF_ENABLED | MF_STRING,
               LASTPORT + IDM_D0, "MIDI MAPPER");


    // no input device is the default
    ModifyMenu(hMenu, IDM_I0, MF_BYCOMMAND | MF_ENABLED | MF_STRING,
                      IDM_I0, "None");
    CheckMenuItem(hMenu, IDM_I0, MF_CHECKED);

    n = midiInGetNumDevs();
    for (wDevice = 1; wDevice <= n; wDevice++) {
        wRet = midiInGetDevCaps(wDevice - 1, &mic, sizeof(mic));
        if (wRet == 0) {
            ModifyMenu(hMenu, wDevice + IDM_I0,
                       MF_BYCOMMAND | MF_ENABLED | MF_STRING,
                       wDevice + IDM_I0, mic.szPname);
        }
        else {
            ModifyMenu(hMenu, wDevice + IDM_I0,
                       MF_BYCOMMAND | MF_ENABLED | MF_STRING,
                       wDevice + IDM_I0, "ERROR");
        }
    }
    for (wDevice = n + 1; wDevice <= LASTPORT; wDevice++)
        DeleteMenu(hMenu, wDevice + IDM_I0, MF_BYCOMMAND);

    EnableMenuItem(hMenu, IDM_STARTMIDIIN, MF_GRAYED);
    EnableMenuItem(hMenu, IDM_STOPMIDIIN, MF_GRAYED);

    EnableMenuItem(hMenu, IDM_PROFSTART, MF_ENABLED);
    EnableMenuItem(hMenu, IDM_PROFSTOP, MF_GRAYED);
}

int sbtestError(LPSTR msg)
{
    MessageBeep(0);
    return MessageBox(hMainWnd, msg, szAppName, MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\about.c ===
/****************************************************************************
 *
 *  about.c
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include "sbtest.h"

void About(HWND hWnd)
{
FARPROC fpDlg;

    // show the about box

    fpDlg = MakeProcInstance(AboutDlgProc, ghInst);
    DialogBox(ghInst, "About", hWnd, fpDlg);
    FreeProcInstance(fpDlg);
}

int FAR PASCAL AboutDlgProc(HWND hDlg, unsigned msg, UINT wParam, LONG lParam)
{

    switch (msg) {

    case WM_INITDIALOG:
        break;

    case WM_COMMAND:
        EndDialog(hDlg, TRUE);
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\playsnd\playsnd.h ===
/*
    PlaySnd.h
*/
#if DBG
	#define MEDIA_DEBUG
#endif

#include <mmsystem.h>
#include "sounddlg.h"

// menu ids

#define IDD_ABOUT           96
#define IDD_SOUNDDLG        97

#define IDM_ABOUT           100

#define IDM_EXIT            101
#define IDM_PLAYFILE        102

#define IDM_SOUNDS          201

#define IDI_ICON			202
#define IDM_MENU			203
#define IDA_ACCTABLE		204

#define IDM_DING            301
#define IDM_SIREN           302
#define IDM_LASER           303

#define IDM_SYNC            401
#define IDM_NOWAIT          402
#define IDM_NODEFAULT       403

#define IDM_RESOURCEID		408

#define IDM_ICONHAND        501
#define IDM_ICONQUESTION    502
#define IDM_ICONEXCLAMATION 503
#define IDM_ICONASTERISK    504
#define IDM_SYNC_ICONHAND        505
#define IDM_SYNC_ICONQUESTION    506
#define IDM_SYNC_ICONEXCLAMATION 507
#define IDM_SYNC_ICONASTERISK    508

#define IDM_HELP_INDEX      901
#define IDM_HELP_KEYBOARD   902
#define IDM_HELP_HELP       903

#ifdef MEDIA_DEBUG
#define IDM_DEBUG0         1000
#define IDM_DEBUG1         1001
#define IDM_DEBUG2         1002
#define IDM_DEBUG3         1003
#define IDM_DEBUG4         1004
#endif

// string resource ids

#define IDS_APPNAME     1       /* application (and class) name */

// child window ids

/* macros */


/* extern declarations for various modules */

/* main module */

#define SIZEOFAPPNAME 20
extern HANDLE ghModule;
extern char szAppName[SIZEOFAPPNAME];
extern HWND ghwndMain;
extern BOOL bSync;
extern BOOL bNoWait;
extern BOOL bNoDefault;
extern BOOL bResourceID;

int APIENTRY MainWndProc(HWND, UINT, WPARAM ,LPARAM);
void CommandMsg(HWND hWnd, DWORD wParam);

// init.c

extern BOOL InitApp(void);
extern void CreateApp(HWND hWnd);
extern void TerminateApp(void);
extern void Error(LPSTR format, ...);

/* about.c */

extern void About(HWND hWnd);
extern LONG AboutDlgProc(HWND, UINT, DWORD ,LONG);

/* debug.c */

#ifdef MEDIA_DEBUG
extern void SetDebugMenuLevel(int i);
#endif

/* help.c */

extern void Help(HWND hWnd, DWORD wParam);

/* file.c */

extern void PlayFile(void);

/* sound.c */

extern void Sounds(HWND hWnd);

/* res.c */

extern void Resource(DWORD wParam);

/***************************************************************************

    DEBUGGING SUPPORT

***************************************************************************/


#ifdef MEDIA_DEBUG

    extern void dDbgSetDebugMenuLevel(int i);
    extern void dDbgOut(LPSTR lpszFormat, ...);
    extern int  dDbgGetLevel(LPSTR lpszModule);
    extern void dDbgSaveLevel(LPSTR lpszModule, int level);
    extern void dDbgAssert(LPSTR exp, LPSTR file, int line);

    int __iDebugLevel;
    DWORD __dwEval;

    #define dGetDebugLevel(lpszModule) (__iDebugLevel = dDbgGetLevel(lpszModule))
    #define dSaveDebugLevel(lpszModule) (dDbgSaveLevel(lpszModule, __iDebugLevel))

    #define dprintf( _x_ )                         dDbgOut _x_
    #define dprintf1( _x_ ) if (__iDebugLevel >= 1) dDbgOut _x_
    #define dprintf2( _x_ ) if (__iDebugLevel >= 2) dDbgOut _x_
    #define dprintf3( _x_ ) if (__iDebugLevel >= 3) dDbgOut _x_
    #define dprintf4( _x_ ) if (__iDebugLevel >= 4) dDbgOut _x_

    #define WinAssert(exp) \
        ((exp) ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__))
    #define WinEval(exp) \
        ((__dwEval=(DWORD)(exp)),  \
		  __dwEval ? (void)0 : dDbgAssert(#exp, __FILE__, __LINE__), __dwEval)

#else

    #define dGetDebugLevel(lpszModule) 0
    #define dSaveDebugLevel(lpszModule) 0

    #define dprintf(x)
    #define dprintf1(x)
    #define dprintf2(x)
    #define dprintf3(x)
    #define dprintf4(x)

    #define WinAssert(exp) 0
    #define WinEval(exp) (exp)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\options.h ===
#define IDO_WAVPATH    100
#define IDO_PROFPATH   101
#define IDD_ZERO       200
#define IDD_ONE        201
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\options.c ===
/****************************************************************************
 *
 *  options.c
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include "wincom.h"
#include "sbtest.h"


void WaveOptions(HWND hWnd)
{
FARPROC fpDlg;

    // show the wave options dialog box

    fpDlg = MakeProcInstance(WaveOptionsDlgProc, ghInst);
    DialogBox(ghInst, "Options", hWnd, fpDlg);
    FreeProcInstance(fpDlg);
}


int FAR PASCAL WaveOptionsDlgProc(HWND hDlg, unsigned msg, UINT wParam, LONG lParam)
{
char szPath[_MAX_PATH];

    switch (msg) {

    case WM_INITDIALOG:
        GetProfileString(szAppName, "wavpath", "", szPath, sizeof(szPath));
        SetDlgItemText(hDlg, IDO_WAVPATH, szPath);
        GetProfileString(szAppName, "profpath", "", szPath, sizeof(szPath));
        SetDlgItemText(hDlg, IDO_PROFPATH, szPath);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            GetDlgItemText(hDlg, IDO_WAVPATH, szPath, sizeof(szPath));
            WriteProfileString(szAppName, "wavpath", szPath);
            GetDlgItemText(hDlg, IDO_PROFPATH, szPath, sizeof(szPath));
            WriteProfileString(szAppName, "profpath", szPath);
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        default:
            break;
        }
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;
}

void MidiOptions(HWND hWnd)
{
FARPROC fpDlg;

    // show the midi options dialog box */

    fpDlg = MakeProcInstance(MidiOptionsDlgProc, ghInst);
    DialogBox(ghInst, "Optionsm", hWnd, fpDlg);
    FreeProcInstance(fpDlg);
}

int FAR PASCAL MidiOptionsDlgProc(HWND hDlg, unsigned msg, UINT wParam, LONG lParam)
{
static int iInstBase;
char       szNum[2];

    switch (msg) {

    case WM_INITDIALOG:
        CheckRadioButton(hDlg, IDD_ZERO, IDD_ONE, gInstBase?IDD_ONE:IDD_ZERO);
	iInstBase = gInstBase;
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDD_ZERO:
            CheckRadioButton(hDlg, IDD_ZERO, IDD_ONE, IDD_ZERO);
	    iInstBase = 0;
	    break;

        case IDD_ONE:
            CheckRadioButton(hDlg, IDD_ZERO, IDD_ONE, IDD_ONE);
	    iInstBase = 1;
	    break;

        case IDOK:
	    if (gInstBase != iInstBase) {
               szNum[0] = '0' + (char)iInstBase;
               szNum[1] = 0;
               WriteProfileString(szAppName, "InstrumentBase", szNum);
	       InvalidateRect(hInstWnd, NULL, TRUE);
	       gInstBase = iInstBase;
	    }
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        default:
            break;
        }
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\pos.c ===
/****************************************************************************
 *
 *  pos.c
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include "sbtest.h"

/****************************************************************************
 *
 *  public data
 *
 ***************************************************************************/

HWND hPosWnd;             // position window

/****************************************************************************
 *
 *  internal function prototypes
 *
 ***************************************************************************/

static void Paint(HWND hWnd, HDC hDC);


void CreatePosition(HWND hParent)
{
UINT x, y, dx, dy;

    x = GetSystemMetrics(SM_CXSCREEN) / 8;
    dx = GetSystemMetrics(SM_CXSCREEN) / 4;
    y = GetSystemMetrics(SM_CYSCREEN) / 3;
    dy = GetSystemMetrics(SM_CYCAPTION) * 5 / 2;

    hPosWnd = CreateWindow("POSITION",
                        "Wave Position",
                        WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE | WS_THICKFRAME,
                        x, y, dx, dy,
                        hParent,
                        NULL,
                        ghInst,
                        (LPSTR)NULL);
}

static void Paint(HWND hWnd, HDC hDC)
{
MMTIME mt;
char buf[20];

    if (hWaveOut) {
	mt.wType = TIME_SAMPLES;
	waveOutGetPosition(hWaveOut, &mt, sizeof(mt));
	wsprintf(buf, "%lu              ", mt.u.sample);
    }
    else
	wsprintf(buf, "Not Playing");
	
    TextOut(hDC, 0, 0, buf, lstrlen(buf));
}

long FAR PASCAL PosWndProc(HWND hWnd, unsigned message, UINT wParam, LONG lParam)
{
PAINTSTRUCT ps;             // paint structure
HMENU hMenu;

    // process any messages we want

    switch (message) {

    case WM_CREATE:
        hMenu = GetMenu(hMainWnd);
        CheckMenuItem(hMenu, IDM_KEYBOARD, MF_CHECKED);
        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        Paint(hWnd, ps.hdc);
        EndPaint(hWnd, &ps);
        break;

    case WM_DESTROY:
        hMenu = GetMenu(hMainWnd);
        CheckMenuItem(hMenu, IDM_KEYBOARD, MF_UNCHECKED);
        hPosWnd = NULL;
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }
    return NULL;
}

void ShowPos(void)
{
HDC hDC;

    if (!hPosWnd)
        return;

    hDC = GetDC(hPosWnd);
    Paint(hPosWnd, hDC);
    ReleaseDC(hPosWnd, hDC);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\record.c ===
/****************************************************************************
 *
 *  record.c
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include "wincom.h"
#include "sbtest.h"

/****************************************************************************
 *
 *  public data
 *
 ***************************************************************************/

HWAVEIN hWaveIn = NULL;

/****************************************************************************
 *
 *  local data
 *
 ***************************************************************************/

static LPWAVEFORMAT lpFormat;
       LPSTR        lpRecordBuf;
static LPWAVEHDR    lpWaveHdr;
       DWORD        dwDataSize;
       DWORD        dwBlockSize;
       DWORD        dwRecorded;

void Record(HWND hWnd)
{
FARPROC fpDlg;

    // show the record dialog box

    fpDlg = MakeProcInstance(RecordDlgProc, ghInst);
    DialogBox(ghInst, "Record", hWnd, fpDlg);
    FreeProcInstance(fpDlg);
}


int FAR PASCAL RecordDlgProc(HWND hDlg, unsigned msg, UINT wParam, LONG lParam)
{
UINT  wRet;
char  acherr[80];

    switch (msg) {
    case WM_INITDIALOG:

        lpFormat = LocalAlloc(LPTR, sizeof(PCMWAVEFORMAT));
        if (!lpFormat) {
            sprintf(ach, "\nNot enough memory for format block");
            dbgOut;
            return FALSE;
        }

        lpFormat->wFormatTag = WAVE_FORMAT_PCM;
        lpFormat->nChannels = 1;
        lpFormat->nSamplesPerSec = 11025;
        lpFormat->nAvgBytesPerSec = 11025;
        lpFormat->nBlockAlign = 1;
        ((LPPCMWAVEFORMAT)lpFormat)->wBitsPerSample = 8;

        lpWaveHdr = LocalAlloc(LPTR, sizeof(WAVEHDR));
        if (!lpWaveHdr) {
            sprintf(ach, "\nNot enough memory for header block");
            dbgOut;
            return FALSE;
        }

        dwDataSize = 0x80000;
        dwBlockSize = 0x8000;
        lpRecordBuf = GlobalAlloc(GPTR, dwDataSize);
        if (!lpRecordBuf) {
            sprintf(ach, "\nNot enough memory for recording block");
            dbgOut;
            return FALSE;
        }

        lpWaveHdr->dwFlags = NULL;

        return TRUE;

    case WM_COMMAND:
        switch (wParam) {
        case IDR_START:
            lpWaveHdr->lpData = lpRecordBuf;
            lpWaveHdr->dwBufferLength = dwBlockSize;
            dwRecorded = 0;
            wRet = waveInOpen(&hWaveIn, 0, lpFormat,
                              (DWORD)hMainWnd, 0L, CALLBACK_WINDOW);
            if (wRet) {
                waveInGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveInOpen: %s", (LPSTR) acherr);
                dbgOut;
            }
            wRet = waveInPrepareHeader(hWaveIn, lpWaveHdr, sizeof(WAVEHDR));
            if (wRet) {
                waveInGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveInPrepareHeader: %s", (LPSTR) acherr);
                dbgOut;
            }
            wRet = waveInAddBuffer(hWaveIn, lpWaveHdr, sizeof(WAVEHDR));
            if (wRet) {
                waveInGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveInAddBuffer: %s", (LPSTR) acherr);
                dbgOut;
            }
            wRet = waveInStart(hWaveIn);
            if (wRet) {
                waveInGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveInStart: %s", (LPSTR) acherr);
                dbgOut;
            }
            break;

        case IDR_STOP:
            wRet = waveInStop(hWaveIn);
            if (wRet) {
                waveInGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveInStop: %s, %d", (LPSTR) acherr, wRet);
                dbgOut;
            }
            wRet = waveInUnprepareHeader(hWaveIn, lpWaveHdr, sizeof(WAVEHDR));
            if (wRet) {
                waveInGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveInUnprepareHeader: %s", (LPSTR) acherr);
                dbgOut;
            }
            wRet = waveInClose(hWaveIn);
            if (wRet) {
                waveInGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveInClose: %s", (LPSTR) acherr);
                dbgOut;
            }
            break;

        case IDR_PLAY:
            wRet = waveOutOpen(&hWaveOut, 0, lpFormat, 0L, 0L, 0L);
            if (wRet) {
                waveOutGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveOutOpen: %s", (LPSTR) acherr);
                dbgOut;
            }
            lpWaveHdr->dwBufferLength = dwRecorded;
            lpWaveHdr->lpData = lpRecordBuf;
            wRet = waveOutPrepareHeader(hWaveOut, lpWaveHdr, sizeof(WAVEHDR));
            if (wRet) {
                waveOutGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveOutPrepareHeader: %s", (LPSTR) acherr);
                dbgOut;
            }
            wRet = waveOutWrite(hWaveOut, lpWaveHdr, sizeof(WAVEHDR));
            if (wRet) {
                waveOutGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveOutWrite: %s", (LPSTR) acherr);
                dbgOut;
            }
            break;

        case IDR_ENDPLAY:
            wRet = waveOutReset(hWaveOut);
            if (wRet) {
                waveOutGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveOutReset: %s", (LPSTR) acherr);
                dbgOut;
            }
            wRet = waveOutUnprepareHeader(hWaveOut, lpWaveHdr, sizeof(WAVEHDR));
            if (wRet) {
                waveOutGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveOutUnprepareHeader: %s", (LPSTR) acherr);
                dbgOut;
            }
            wRet = waveOutClose(hWaveOut);
            if (wRet) {
                waveOutGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveOutClose: %s", (LPSTR) acherr);
                dbgOut;
            }
            hWaveOut = 0;
            break;

        case IDR_OK:
            LocalFree(lpFormat);
            LocalFree(lpWaveHdr);
            GlobalFree(lpRecordBuf);
            EndDialog(hDlg, TRUE);
            break;

        default:
            break;
        }
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\inst.c ===
/****************************************************************************
 *
 *  inst.c
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include "wincom.h"
#include "sbtest.h"

/****************************************************************************
 *
 *  public data
 *
 ***************************************************************************/

HWND hInstWnd;
BYTE bInstrument = 0;

/****************************************************************************
 *
 *  local data
 *
 ***************************************************************************/

static int  width;
static int  height;
static TEXTMETRIC tm;

/****************************************************************************
 *
 *  internal function prototypes
 *
 ***************************************************************************/

static void Paint(HWND hWnd, HDC hDC);

void CreateInstrument(HWND hWnd)
{
HDC hDC;
POINT pt;
int w, h;

    hDC = GetDC(hWnd);
    GetTextMetrics(hDC, &tm);
    ReleaseDC(hWnd, hDC);

    w = tm.tmMaxCharWidth * 3;
    h = tm.tmHeight + tm.tmExternalLeading;
    width = w * 8;
    height = h * 16;
    GetCursorPos(&pt);

    hInstWnd = CreateWindow("SELECTOR",
                            "Instrument",
                            WS_POPUP | WS_CAPTION | WS_VISIBLE | WS_SYSMENU,
                            pt.x, pt.y,
                            width,
                            height + GetSystemMetrics(SM_CYCAPTION),
                            hWnd,
                            NULL,
                            ghInst,
                            NULL);

}

static void Paint(HWND hWnd, HDC hDC)
{
int x, y;
char szVal[20];
RECT rect;

    for (y = 0; y < 16; y++) {
        for (x = 0; x < 8; x++) {
            wsprintf(szVal, "%d", y * 8 + x + gInstBase);
            TextOut(hDC,
                    width * x / 8 + tm.tmMaxCharWidth / 2,
                    height * y / 16,
                    szVal,
                    lstrlen(szVal));

        }
    }
    for (y = 0; y < 16; y++) {
        MoveToEx(hDC, 0, height * y / 16, NULL);
        LineTo(hDC, width, height * y / 16);
    }
    for (x = 0; x < 8; x++) {
        MoveToEx(hDC, width * x / 8, 0, NULL);
        LineTo(hDC, width * x / 8, height);
    }

    rect.left = ((bInstrument % 8) * (width / 8)) + 1;
    rect.right = rect.left + (width / 8) - 1;
    rect.top = ((bInstrument / 8) * (height / 16)) + 1;
    rect.bottom = rect.top + (height / 16) - 1;
    InvertRect(hDC, &rect);
}

long FAR PASCAL InstWndProc(HWND hWnd, unsigned message, UINT wParam, LONG lParam)
{
PAINTSTRUCT ps;             // paint structure
int x, y;
SHORTMSG sm;
HMENU hMenu;
RECT  rect;

    // process any messages we want

    switch (message) {

    case WM_CREATE:
        hMenu = GetMenu(hMainWnd);
        CheckMenuItem(hMenu, IDM_INSTRUMENT, MF_CHECKED);
        break;

    case WM_LBUTTONDOWN:
	// revert old patch
	rect.left = ((bInstrument % 8) * (width / 8)) + 1;
	rect.right = rect.left + (width / 8) - 1;
	rect.top = ((bInstrument / 8) * (height / 16)) + 1;
	rect.bottom = rect.top + (height / 16) - 1;
	InvalidateRect(hWnd, &rect, TRUE);

        // calculate new patch
        x = LOWORD(lParam) * 8 / width;
        y = HIWORD(lParam) * 16 / height;
        bInstrument = (BYTE) y * 8 + x;
        sm.b[0] = (BYTE) 0xC0 + bChannel;
        sm.b[1] = bInstrument;

        // invert new patch
	rect.left = ((bInstrument % 8) * (width / 8)) + 1;
	rect.right = rect.left + (width / 8) - 1;
	rect.top = ((bInstrument / 8) * (height / 16)) + 1;
	rect.bottom = rect.top + (height / 16) - 1;
	InvalidateRect(hWnd, &rect, TRUE);

	// send patch change message
        if (hMidiOut) {
            midiOutShortMsg(hMidiOut, sm.dw);
	    if (ISBITSET(fDebug, DEBUG_PATCH))
	        sprintf(ach, "\nPatch Change to %d on Channel %d",
                          bInstrument, bChannel);
            dbgOut;
        }

        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        Paint(hWnd, ps.hdc);
        EndPaint(hWnd, &ps);
        break;

    case WM_DESTROY:
        hMenu = GetMenu(hMainWnd);
        CheckMenuItem(hMenu, IDM_INSTRUMENT, MF_UNCHECKED);
        hInstWnd = NULL;
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\keyb.c ===
/****************************************************************************
 *
 *  keyb.c
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include "wincom.h"
#include "sbtest.h"

// make these multiples of 12
#define NUMKEYS 36
#define FIRSTKEY 48             // 60 is middle C (includes semi-tones)

/****************************************************************************
 *
 *  public data
 *
 ***************************************************************************/

HWND     hKeyWnd;             // keyboard window

/****************************************************************************
 *
 *  local data
 *
 ***************************************************************************/

typedef struct _key {
    RECT rc;             // the key's area
    BYTE midinote;       // which midi key number
    BYTE note;           // which (alphabetical) note
    BYTE noteon;         // is the note on?
} KEY, *PKEY;

static UINT wWidth;            // client area width
static UINT wHeight;           // client area height
static int  iWhiteKeys;        // number of white keys
static BYTE bLastNote;
static char keyadd = 0;
static KEY  keys[128];
static TEXTMETRIC tm;

/****************************************************************************
 *
 *  internal function prototypes
 *
 ***************************************************************************/

static char WhiteKey(int key);
static void MidiNoteOn(BYTE note);
static void MidiNoteOff(BYTE note);
static BYTE GetNote(LONG pos);
static void noteChanged(HWND hWnd, BYTE note);
static void Paint(HWND hWnd, HDC hDC);
static void Size(HWND hWnd);


static char WhiteKey(int key)
{
    switch (key % 12) {
    case 0:
        return 'C';
    case 2:
        return 'D';
    case 4:
        return 'E';
    case 5:
        return 'F';
    case 7:
        return 'G';
    case 9:
        return 'A';
    case 11:
        return 'B';
    default:
        return 0;
    }
}

void CreateKeyboard(HWND hParent)
{
UINT x, y, dx, dy;
int  i;
RECT rc;

    // initialize key array
    for (i = 0; i < 128; i++) {
	keys[i].noteon = FALSE;
	keys[i].note = WhiteKey(i);
	keys[i].midinote = (BYTE)i;
    }
	
    // initial size and location of keyboard
    dx = 600;
    dy = 150;
    x = 20;
    GetWindowRect(hParent, &rc);
    y = rc.bottom - GetSystemMetrics(SM_CYFRAME) - dy;

    hKeyWnd = CreateWindow("SYNTHKEYS",
                        "",
                        WS_POPUP | WS_CAPTION | WS_SYSMENU | WS_VISIBLE | WS_THICKFRAME,
                        x, y, dx, dy,
                        hParent,
                        NULL,
                        ghInst,
                        (LPSTR)NULL);
}

static void MidiNoteOn(BYTE note)
{
SHORTMSG sm;

    if (hMidiOut) {
        sm.b[0] = (BYTE) 0x90 + bChannel;
        sm.b[1] = note;
        sm.b[2] = NOTEVELOCITY;

        midiOutShortMsg(hMidiOut, sm.dw);
        bLastNote = note;

        keys[note].noteon = TRUE;

        if (ISBITSET(fDebug, DEBUG_NOTE))
    	sprintf(ach, "\nNote On %d Channel %d", note, bChannel);
        dbgOut;
    }
}

static void MidiNoteOff(BYTE note)
{
SHORTMSG sm;

    if (hMidiOut) {
        sm.b[0] = (BYTE) 0x80 + bChannel;
        sm.b[1] = note;
        sm.b[2] = 0;

        midiOutShortMsg(hMidiOut, sm.dw);

        keys[note].noteon = FALSE;

        if (ISBITSET(fDebug, DEBUG_NOTE))
    	sprintf(ach, "\nNote Off %d Channel %d", note, bChannel);
        dbgOut;
    }
}

static BYTE GetNote(LONG pos)
{
POINT pt;
BYTE i;

    pt.x = LOWORD(pos);
    pt.y = HIWORD(pos);

    for (i = FIRSTKEY; i < FIRSTKEY + NUMKEYS; i++) {
	if (!keys[i].note) {	// black notes are 'over' white ones
	    if (PtInRect(&(keys[i].rc), pt))
		return (i + keyadd);
	}
    }

    for (i = FIRSTKEY; i < FIRSTKEY + NUMKEYS; i++) {
	if (keys[i].note) {	// look at white notes
	    if (PtInRect(&(keys[i].rc), pt))
		return (i + keyadd);
	}
    }

    // shouldn't get here...
    return 0;
}

static void noteChanged(HWND hWnd, BYTE note)
{
RECT onRC;

    CopyRect(&onRC, &(keys[note].rc));
    onRC.top = onRC.bottom - tm.tmHeight * 2;

    // set top of ON rect to not overlap black keys
    if (WhiteKey(note))
	onRC.top = max(onRC.top, wHeight * 2/3);

    InflateRect(&onRC, -2, -2);

    InvalidateRect(hWnd, &onRC, WhiteKey(note));
}

static void Paint(HWND hWnd, HDC hDC)
{
int    i;
RECT   onRC;
HBRUSH hBlackBrush, hOldBrush;
char   buf[4];

    GetTextMetrics(hDC, &tm);
    hBlackBrush = GetStockObject(BLACK_BRUSH);

    for (i = FIRSTKEY; i < (FIRSTKEY + NUMKEYS); i++) {
	CopyRect(&onRC, &(keys[i].rc));
	onRC.top = onRC.bottom - 2 * tm.tmHeight;
        if (keys[i].note) {                     // paint white keys
            MoveToEx(hDC, keys[i].rc.right, keys[i].rc.top, NULL);
            LineTo(hDC, keys[i].rc.right, keys[i].rc.bottom);
	    wsprintf(buf, "%u", i + keyadd);
            TextOut(hDC,
                keys[i].rc.left + (keys[i].rc.right -
		  keys[i].rc.left - tm.tmAveCharWidth*lstrlen(buf)) / 2,
                wHeight - 2 * tm.tmHeight,
                (LPSTR)buf,
                lstrlen(buf));
            TextOut(hDC,
                keys[i].rc.right - (keys[i].rc.right -
		  keys[i].rc.left) / 2 - tm.tmAveCharWidth / 2,
                wHeight - tm.tmHeight,
                (LPSTR)&(keys[i].note),
                1);

	    // set top of ON rect to not overlap black keys
	    onRC.top = max(onRC.top, wHeight * 2/3);
        }
	else {                              // paint black keys
            hOldBrush = SelectObject(hDC, hBlackBrush);
            Rectangle(hDC,
                    keys[i].rc.left,
                    keys[i].rc.top,
                    keys[i].rc.right,
		    keys[i].rc.bottom);
            SelectObject(hDC, hOldBrush);
        }
	if (keys[i+keyadd].noteon) {
	    InflateRect(&onRC, -2, -2);
	    InvertRect(hDC, &onRC);
	}
    }
}

static void Size(HWND hWnd)
{
int i, x, dx;

    // count the number of white keys visible
    iWhiteKeys = 0;
    for (i = FIRSTKEY; i < FIRSTKEY + NUMKEYS; i++) {
        if (WhiteKey(i))
            iWhiteKeys++;
    }

    // x is the right side of the white, dx is the width of a white key.
    x = dx = wWidth / iWhiteKeys;

    for (i = FIRSTKEY; i < FIRSTKEY + NUMKEYS; i++) {
        if (keys[i].note) {                // it's a white key
	    SetRect(&(keys[i-NUMKEYS].rc), x - dx, 0, x, wHeight);
	    SetRect(&(keys[i].rc), x - dx, 0, x, wHeight);
	    SetRect(&(keys[i+NUMKEYS].rc), x - dx, 0, x, wHeight);
	    x += dx;
        }
	else {                            // it's a black key
	   SetRect(&(keys[i-NUMKEYS].rc), x-dx/3-dx, 0, x+dx/3-dx, wHeight*2/3);
	   SetRect(&(keys[i].rc), x-dx/3-dx, 0, x+dx/3-dx, wHeight*2/3);
	   SetRect(&(keys[i+NUMKEYS].rc), x-dx/3-dx, 0, x+dx/3-dx, wHeight*2/3);
        }
    }
}

long FAR PASCAL KeyWndProc(HWND hWnd, unsigned message, UINT wParam, LONG lParam)
{
PAINTSTRUCT ps;             // paint structure
HMENU hMenu;
BYTE note;
RECT rc;

    // process any messages we want

    switch(message) {
    case WM_CREATE:
        hMenu = GetMenu(hMainWnd);
        CheckMenuItem(hMenu, IDM_KEYBOARD, MF_CHECKED);
        break;

    case WM_SIZE:
        wWidth = LOWORD(lParam);
        wHeight = HIWORD(lParam);
	Size(hWnd);
        break;

    case WM_LBUTTONDOWN:
	note = GetNote(lParam);
	if (note) {
	    MidiNoteOn(note);
	    noteChanged(hWnd, note);
	}
        break;

    case WM_LBUTTONUP:
	note = GetNote(lParam);
	if (note) {
	    MidiNoteOff(note);
	    noteChanged(hWnd, note);
	}
        break;

    case WM_KEYDOWN:
        GetWindowRect(hWnd, &rc);
	rc.right = rc.right - rc.left;
	rc.left = 0;
	rc.top = wHeight - 2 * tm.tmHeight;
	rc.bottom = wHeight - tm.tmHeight;
	if (wParam == VK_CONTROL) {
	   keyadd = -NUMKEYS;
	   if (!(lParam & 0x40000000))
	       InvalidateRect(hWnd, &rc, TRUE);
	}
	else if (wParam == VK_SHIFT) {
	   keyadd = NUMKEYS;
	   if (!(lParam & 0x40000000))
	       InvalidateRect(hWnd, &rc, TRUE);
	}
	break;

    case WM_KEYUP:
        GetWindowRect(hWnd, &rc);
	rc.right = rc.right - rc.left;
	rc.left = 0;
	rc.top = wHeight - 2 * tm.tmHeight;
	rc.bottom = wHeight - tm.tmHeight;
	keyadd = 0;
	InvalidateRect(hWnd, &rc, TRUE);
	break;

    case WM_MOUSEMOVE:
        if (wParam & MK_LBUTTON) {
            note = GetNote(lParam);
            if (note && (note != bLastNote)) {
                MidiNoteOff(bLastNote);
		noteChanged(hWnd, bLastNote);
                MidiNoteOn(note);
		noteChanged(hWnd, note);
            }
        }
        break;


    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        Paint(hWnd, ps.hdc);
        EndPaint(hWnd, &ps);
        break;

    case WM_DESTROY:
        hMenu = GetMenu(hMainWnd);
        CheckMenuItem(hMenu, IDM_KEYBOARD, MF_UNCHECKED);
        hKeyWnd = NULL;
        break;

    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
        break;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\playfile.c ===
/****************************************************************************
 *
 *  playfile.c
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include "wincom.h"
#include "sbtest.h"

#define CHUNKSIZE 0x4000        // size of chunk we send to the driver

/****************************************************************************
 *
 *  public data
 *
 ***************************************************************************/

HWAVEOUT hWaveOut = 0;            // handle to open wave device
int      iWaveOut = 0;            // count of blocks writen to the wave device

#if 0
/****************************************************************************
 *
 *  internal function prototypes
 *
 ***************************************************************************/


static void ShowResError(void);

static void ShowResError(void)
{
DWORD dwErr;
char buf[80];

    dwErr = medGetError();
    if (!dwErr)
        return;

    medGetErrorText(dwErr, buf, sizeof(buf));
    sprintf(ach, "\nMediaman error: %s", (LPSTR) buf);
    dbgOut;
}
#endif

void PlayFile(LPSTR fname)
{
// MEDID       medid;
int         hMed;
// FOURCC      ckid;
DWORD       dwFmtSize;
char        szFileName[80];
UINT        wResult;
WAVEFORMAT  *pFormat;
DWORD       dwDataSize;
HANDLE      hData;
LPSTR       lpData;
LPWAVEHDR   lpWaveHdr;
PVOID       pData;

// Get a handle to our file

hMed = _lopen(fname, OF_READ);

#if 0
    lstrcpy(szFileName, fname);


    medid = medLocate(  szFileName,
                        medMEDTYPE('W','A','V','E'),
                        MEDF_LOCATE,
                        NULL);
    if (medid == 0) {
        sprintf(ach, "\nFailed to locate resource: %s", (LPSTR)szFileName);
        dbgOut;
//      ShowResError();
        return;
    }


    // open the resource and validate it

    hMed = medOpen(medid, MOP_READ, 64);
#endif

    if (!hMed) {
        sprintf(ach, "\nFailed to open resource");
//      ShowResError();
        return;
    }


    hData = CreateFileMapping(hMed, NULL, PAGE_READONLY, 0, 0, NULL);
    pData = MapViewOfFile(hData, FILE_MAP_READ, 0, 0, 0);
    if (!pData) {
        sprintf(ach, "\nCould not map file");
        dbgOut;
        return;
    }

    // descend into the murky depths of the RIFF chunk

#if 0
    ckid = medDescend(hMed);
    if (ckid != medFOURCC('R','I','F','F')) {
        sprintf(ach, "\nResource is not Ricky's Interchange File Format");
        dbgOut;
//      ShowResError();
        return;
    }

    // first four chars should be WAVE

    if ((medGetFOURCC(hMed) != mmioFOURCC('W','A','V','E'))
#endif

    if (!IsRiffWaveFormat(pData)) {
        sprintf(ach, "\nRIFF file not a WAVE file");
        dbgOut;
//        ShowResError();
        return;
    }

    // get all excited and look for a fmt chunk

#if 0
    if (!medFindChunk(hMed, medFOURCC('f','m','t',' '))) {
        sprintf(ach, "\nRIFF/WAVE file has no fmt chunk");
        dbgOut;
//        ShowResError();
        return;
    }

    // allocate some memory we can read the format chunk into

    dwFmtSize = medGetChunkSize(hMed);
    pFormat = (WAVEFORMAT*)LocalAlloc(LPTR, (UINT)dwFmtSize);
#endif

    pFormat = FindRiffChunk(&dwFmtSize, pData, mmioFOURCC('f','m','t',' '));


    if (!pFormat) {
        sprintf(ach, "\nFailed to alloc memory for WAVEFORMAT");
        dbgOut;
        return;
    }

    // read the header


#if 0
    if (medRead(hMed, (LPSTR) pFormat, dwFmtSize) != dwFmtSize) {
        sprintf(ach, "\nFailed to read header");
        dbgOut;
        ShowResError();
        return;
    }
#endif


    // try to open the first wave device with this format
    // (we should enum them later)

    if (!hWaveOut) {
        if (waveOutOpen(&hWaveOut,
                        0,
                        pFormat,
                        (DWORD)hMainWnd,
                        0L,
                        CALLBACK_WINDOW)) {
            sprintf(ach, "\nFailed to open wave device");
            dbgOut;
            return;
        }
    }

    // LocalFree((HANDLE)pFormat);

    // find the data chunk and get it's size


#if 0
    if (!medAscend(hMed)) {
        sprintf(ach, "\nFailed to ascend from the depths");
        dbgOut;
        ShowResError();
        return;
    }

    if (!medFindChunk(hMed, medFOURCC('d','a','t','a'))) {
        sprintf(ach, "\nRIFF/WAVE file has no data chunk");
        dbgOut;
        ShowResError();
        return;
    }

    dwDataSize = medGetChunkSize(hMed);


    // read the data chunk

    hData = GlobalAlloc(GMEM_MOVEABLE, dwDataSize + sizeof(WAVEHDR));


    if (!hData) {
        sprintf(ach, "\nNot enough memory for data block");
        dbgOut;
        return;
    }

    //  fill the buffer from the file

    lpData = GlobalLock(hData);
#endif

    lpData = FindRiffChunk(&dwDataSize, pData, mmioFOURCC('d','a','t','a'));
    if (!lpData) {
        sprintf(ach, "\nFailed to lock data memory");
        dbgOut;
        CloseHandle(hData);
//      GlobalFree(hData);
        return;
    }

#if 0
    if (medRead(hMed, lpData + sizeof(WAVEHDR), dwDataSize) != dwDataSize) {
        sprintf(ach, "\nFailed to read data block");
        dbgOut;
        GlobalUnlock(hData);
        GlobalFree(hData);
        return;
    }
#endif

    // create a header to send to the device

    lpWaveHdr = LocalAlloc(LPTR, sizeof(WAVEHDR));

    lpWaveHdr->lpData   = lpData;
    lpWaveHdr->dwBufferLength = dwDataSize;
    lpWaveHdr->dwUser   = 0;
    lpWaveHdr->dwFlags  = 0;
    lpWaveHdr->dwLoops  = 0;

    // Add looping flags if required

    if (wLoops != IDM_LOOPOFF) {
        lpWaveHdr->dwFlags |= (WHDR_BEGINLOOP | WHDR_ENDLOOP);
        if (wLoops == IDM_LOOP2)
            lpWaveHdr->dwLoops = 2;
        else
            lpWaveHdr->dwLoops = 100;
    }

    // let the driver prepare the header and data block
    waveOutPrepareHeader(hWaveOut, lpWaveHdr, sizeof(WAVEHDR));

    // send it to the driver
    wResult = waveOutWrite(hWaveOut, lpWaveHdr, sizeof(WAVEHDR));

    if (wResult != 0) {
        sprintf(ach, "\nFailed to write block to device : code %d", wResult);
        dbgOut;
        waveOutUnprepareHeader(hWaveOut, lpWaveHdr, sizeof(WAVEHDR));
//      GlobalUnlock(hData);
//      GlobalFree(hData);
        return;
    }

    _lclose(hMed);

    iWaveOut++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\record.h ===
#define IDR_START   101
#define IDR_STOP    102
#define IDR_PLAY    103
#define IDR_ENDPLAY 104
#define IDR_OK      105
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\riff.h ===
/*
    riff.h

    Definitions for dealing with RIFF files

*/


#define ckidRIFF        mmioFOURCC( 'R', 'I', 'F', 'F' )

// local stuff

#define ckidWAVE mmioFOURCC('W','A','V','E')

typedef struct _RIFFHDR {
    FOURCC rifftag;
    ULONG  Size;
    FOURCC wavetag;
    } RIFFHDR, *PRIFFHDR;

typedef struct _RIFFCHUNKHDR {
    FOURCC rifftag;
    ULONG  Size;
    } RIFFCHUNKHDR, *PRIFFCHUNKHDR;

//
// in riff.c
//

BOOL IsRiffWaveFormat(PUCHAR pView);
PUCHAR FindRiffChunk(PULONG pChunkSize, PUCHAR pView, FOURCC Tag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\sbtest.c ===
/****************************************************************************
 *
 *  sbtest.c
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include <windows.h>
#include <mmsystem.h>
#include "wincom.h"
#include "sbtest.h"
#include <commdlg.h>

/****************************************************************************
 *
 *  public data
 *
 ***************************************************************************/

HANDLE          ghInst;              // global instance handle
char            szAppName[10];       // app name
HWND            hPrintfWnd;          // printf child window
HWND            hwndVolumeDlg;
int             fDebug;
BYTE            bChannel = 0;
UINT            wLoops = IDM_LOOPOFF;
HMIDIOUT        hMidiOut = NULL;
char            ach[256];
OPENFILENAME    ofn;
char            szFname[MAXFILENAME];
BOOL            AuxNotSupported;
BOOL            SetAux;

/****************************************************************************
 *
 *  local data
 *
 ***************************************************************************/

static HMIDIIN hMidiIn = NULL;
static int     iProfiler;
int FAR PASCAL VolumeDlgProc(HWND, unsigned, UINT, LONG);

/****************************************************************************
 *
 *  internal function prototypes
 *
 ***************************************************************************/

static void GetInfo(void);
static void CommandMsg(HWND hWnd, UINT wParam, LONG lParam);

/***************************************************************************

    get and show device info

***************************************************************************/

static void GetInfo(void)
{
WAVEOUTCAPS wc;
WAVEINCAPS  wic;
MIDIOUTCAPS mc;
MIDIINCAPS  mic;
AUXCAPS     ac;
UINT        wDevs, wDevice;
char        acherr[80];
UINT        wErr;

    wDevs = waveInGetNumDevs();
    if (wDevs > 32)
        wDevs = 0;

    sprintf(ach, "\n%u Wave Input Devices\n", wDevs);
    dbgOut;

    for (wDevice = 0; wDevice < wDevs; wDevice++) {
        sprintf(ach, "Wave input device %u: ", wDevice);
        dbgOut;
        wErr = waveInGetDevCaps(wDevice, &wic, sizeof(wic));
        if (!wErr) {
            sprintf(ach, "Mid:%u, Pid:%u, %s", wic.wMid, wic.wPid, (LPSTR) wic.szPname);
            dbgOut;
            sprintf(ach, "\nFormats:%8.8lXH", wic.dwFormats);
            dbgOut;
            sprintf(ach, ", channels:%4.4XH\n", wic.wChannels);
            dbgOut;
        }
        else {
            sprintf(ach, " Error Getting Wave Input Capabilities\n");
            dbgOut;
            waveInGetErrorText(wErr, acherr, sizeof(acherr));
            sprintf(ach, " Error: %s\n", (LPSTR) acherr);
            dbgOut;
        }
    }

    wDevs = waveOutGetNumDevs();
    if (wDevs > 32)
        wDevs = 0;

    sprintf(ach, "\n%u Wave Output Devices\n", wDevs);

    for (wDevice = 0; wDevice < wDevs; wDevice++) {
        sprintf(ach, "Wave output device %u: ", wDevice);
        wErr = waveOutGetDevCaps(wDevice, &wc, sizeof(wc));
        if (!wErr) {
            sprintf(ach, "Mid:%u, Pid:%u, %s", wc.wMid, wc.wPid, (LPSTR) wc.szPname);
            dbgOut;
            sprintf(ach, "\nFormats:%8.8lXH\n", wc.dwFormats);
            dbgOut;
        }
        else {
            sprintf(ach, " Error Getting Wave Output Capabilities\n");
            dbgOut;
            waveOutGetErrorText(wErr, acherr, sizeof(acherr));
            sprintf(ach, " Error: %s\n", (LPSTR) acherr);
            dbgOut;
        }
    }

    wDevs = midiInGetNumDevs();
    if (wDevs > 32)
        wDevs = 0;

    sprintf(ach, "\n%u MIDI Input Devices\n", wDevs);

    for (wDevice = 0; wDevice < wDevs; wDevice++) {
        sprintf(ach, "MIDI input device %u: ", wDevice);
        wErr = midiInGetDevCaps(wDevice, &mic, sizeof(mic));
        if (!wErr) {
            sprintf(ach, "Mid:%u, Pid:%u, %s\n", mic.wMid, mic.wPid, (LPSTR) mic.szPname);
            dbgOut;
        }
        else {
            sprintf(ach, " Error Getting MIDI Input Capabilities\n");
            dbgOut;
            midiInGetErrorText(wErr, acherr, sizeof(acherr));
            sprintf(ach, " Error: %s\n", (LPSTR) acherr);
            dbgOut;

        }
    }

    wDevs = midiOutGetNumDevs();
    if (wDevs > 32)
        wDevs = 0;

    sprintf(ach, "\n%u MIDI Output Devices\n", wDevs);
    dbgOut;

    for (wDevice = 0; wDevice < wDevs; wDevice++) {
        sprintf(ach, "MIDI output device %u: ", wDevice);
        wErr = midiOutGetDevCaps(wDevice, &mc, sizeof(mc));
        if (!wErr) {
            sprintf(ach, "Mid:%u, Pid:%u, %s", mc.wMid, mc.wPid, (LPSTR) mc.szPname);
            dbgOut;
            sprintf(ach, "\nTechnology:%4.4XH", mc.wTechnology);
            dbgOut;
            sprintf(ach, ", voices:%4.4XH", mc.wVoices);
            dbgOut;
            sprintf(ach, ", notes:%4.4XH\n", mc.wNotes);
            dbgOut;
        }
        else {
            sprintf(ach, " Error Getting MIDI Output Capabilities\n");
            dbgOut;
            midiOutGetErrorText(wErr, acherr, sizeof(acherr));
            sprintf(ach, " Error: %s\n", (LPSTR) acherr);
            dbgOut;
        }
    }
    sprintf(ach, "MIDI output device %u: ", MIDIMAPPER);
    wErr = midiOutGetDevCaps(MIDIMAPPER, &mc, sizeof(mc));
    if (!wErr) {
        sprintf(ach, "Mid:%u, Pid:%u, %s", mc.wMid, mc.wPid, (LPSTR) mc.szPname);
        dbgOut;
        sprintf(ach, "\nTechnology:%4.4XH", mc.wTechnology);
        dbgOut;
        sprintf(ach, ", voices:%4.4XH", mc.wVoices);
        dbgOut;
        sprintf(ach, ", notes:%4.4XH\n", mc.wNotes);
        dbgOut;
    }
    else {
        sprintf(ach, " Error Getting MIDI Output Capabilities\n");
        dbgOut;
        midiOutGetErrorText(wErr, acherr, sizeof(acherr));
        sprintf(ach, " Error: %s\n", (LPSTR) acherr);
        dbgOut;
    }

    wDevs = auxGetNumDevs();
    if (wDevs > 32)
        wDevs = 0;

    sprintf(ach, "\n%u Auxiliary Output Devices\n", wDevs);
    dbgOut;

    for (wDevice = 0; wDevice < wDevs; wDevice++) {
        sprintf(ach, "Auxiliary output device %u: ", wDevice);
        dbgOut;
        wErr = auxGetDevCaps(wDevice, &ac, sizeof(ac));
        if (!wErr) {
            sprintf(ach, "Mid:%u, Pid:%u, %s", ac.wMid, ac.wPid, (LPSTR) ac.szPname);
            dbgOut;
            sprintf(ach, "\nTechnology:%4.4XH", ac.wTechnology);
            dbgOut;
            sprintf(ach, ", Support:%4.4XH", ac.dwSupport);
            dbgOut;
        }
        else {
            sprintf(ach, " Error Getting Auxiliary Output Capabilities\n");
            dbgOut;
        }
    }
}

/***************** Main entry point routine *************************/

int __cdecl main(int argc, char **argv)
{
MSG msg;

    /* fill in non-variant fields of OPENFILENAME struct. */
    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner	  = hMainWnd;
    ofn.lpstrFilter	  = NULL;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter	  = 0;
    ofn.nFilterIndex	  = 1;
    ofn.lpstrFile         = szFname;
    ofn.nMaxFile	  = MAXFILENAME;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrTitle        = NULL;
    ofn.lpstrDefExt       = "WAV";
    ofn.Flags             = 0;

    ghInst = GetModuleHandle(NULL);          // save our instance handle

    // medClientInit();

    LoadString(ghInst, IDS_APPNAME, szAppName, sizeof(szAppName));
    if (! InitFirstInstance(ghInst)) {
        return 1;
    }

    if (!InitEveryInstance(ghInst, SW_SHOWDEFAULT))
        return 1;


    // check for messages from Windows and process them
    // if no messages, perform some idle function

    do {
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            // got a message to process
            if (msg.message == WM_QUIT) break;
            if (!TranslateAccelerator(hMainWnd, hAccTable, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else {

            if (hPosWnd)
                ShowPos();
            else
                WaitMessage();
        }
    } while (1);

    // medClientExit();

    return (msg.wParam);
}

/************* main window message handler ******************************/

long FAR PASCAL MainWndProc(HWND hWnd, unsigned message, UINT wParam, LONG lParam)
{
PAINTSTRUCT ps;             // paint structure
WAVEOUTCAPS wc;
AUXCAPS     ac;

    // process any messages we want

    switch (message) {

    case WM_CREATE:
        InitMenus(hWnd);
        hPrintfWnd = wpfCreateWindow(hWnd,
                                     ghInst,
                                     "",
                                     WS_CHILD | WS_VISIBLE | WS_VSCROLL,
                                     0, 0, 0, 0,
                                     100,
                                     0);
        sprintf(ach, "Wave and MIDI device driver test app.\n");
        dbgOut;

        waveOutGetDevCaps( 0, &wc, sizeof(wc) );
        EnableMenuItem( GetMenu( hWnd ),
                        IDM_VOLUME,
                        wc.dwSupport & WAVECAPS_VOLUME
                        ? MF_ENABLED : MF_GRAYED );

        if ( !(wc.dwSupport & WAVECAPS_VOLUME) ) {
            hwndVolumeDlg = (HWND)1;
        }

        memset(&ac, 0, sizeof(ac));
        auxGetDevCaps( 0, &ac, sizeof(ac) );
        EnableMenuItem( GetMenu( hWnd ),
                        IDM_AUX_VOLUME,
                        ac.dwSupport & AUXCAPS_VOLUME
                        ? MF_ENABLED : MF_GRAYED );

        if ( !(wc.dwSupport & WAVECAPS_VOLUME) ) {
            AuxNotSupported = 1;
        }



#if 0
		{
HMENU       hMenu;
        iProfiler = ProfInsChk();

        switch (iProfiler) {
        case 1:
            sprintf(ach, "Profiler installed for real/286p modes\n");
            dbgOut;
            break;
        case 2:
            sprintf(ach, "Profiler installed for real/286p/386p modes\n");
            dbgOut;
            break;
        default:
            sprintf(ach, "Profiler not installed\n");
            dbgOut;
            iProfiler = 0;
            hMenu = GetMenu(hWnd);
            EnableMenuItem(hMenu, IDM_PROFSTART, MF_GRAYED);
            break;
        }
		}
#endif
        break;

    case WM_SIZE:
        MoveWindow(hPrintfWnd, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
        break;

    case WM_COMMAND:
        // process menu messages
        CommandMsg(hWnd, wParam, lParam);
        break;

    case WM_PAINT:
        BeginPaint(hWnd, &ps);
        EndPaint(hWnd, &ps);
        break;

    case WM_DESTROY:
        if (hMidiOut)
            midiOutClose(hMidiOut);
        if (hMidiIn)
            midiInClose(hMidiIn);
        if (hWaveOut) {
            waveOutReset(hWaveOut);
            waveOutClose(hWaveOut);
        }
        if (hWaveIn) {
            waveInReset(hWaveIn);
            waveInClose(hWaveIn);
        }
        PostQuitMessage(0);
        break;

    case MM_WIM_CLOSE:
        sprintf(ach, " MM_WIM_CLOSE:     %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_WIM_DATA:
        sprintf(ach, " MM_WIM_DATA:      %04X %08lX\n",wParam,lParam);
        dbgOut;
        //
        // Get more data if possible
        //

        dwRecorded += ((LPWAVEHDR)lParam)->dwBytesRecorded;
        if (hWaveIn &&
            (dwDataSize  - (lpRecordBuf - (LPSTR)((LPWAVEHDR)lParam)->lpData))
            >= dwBlockSize) {
           UINT wRet;
           char acherr[80];

           ((LPWAVEHDR)lParam)->lpData += dwBlockSize;
           wRet = waveInAddBuffer(hWaveIn, (LPWAVEHDR)lParam, sizeof(WAVEHDR));
           if (wRet) {
                waveInGetErrorText(wRet, acherr, sizeof(acherr));
                sprintf(ach, "\nwaveInAddBuffer: %s", (LPSTR) acherr);
                dbgOut;
            }
        }
        break;

    case MM_WIM_OPEN:
        sprintf(ach, " MM_WIM_OPEN:      %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_WOM_OPEN:
        sprintf(ach, " MM_WOM_OPEN:      %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_WOM_CLOSE:
        sprintf(ach, " MM_WOM_CLOSE:     %04X %08lX\n",wParam,lParam);
        dbgOut;

        if (hWaveOut != (HWAVEOUT)wParam) {
            sprintf(ach, " MM_WOM_CLOSE: ACK! wParam doesn't match hWaveOut!!!!\n");
            return 0L;
        }

        iWaveOut = 0;
        hWaveOut = NULL;

        break;

    case MM_WOM_DONE:
        sprintf(ach, " MM_WOM_DONE:      %04X %08lX\n",wParam,lParam);
        dbgOut;

        if (hWaveOut != (HWAVEOUT)wParam) {
            sprintf(ach, " MM_WOM_DONE: ACK! wParam doesn't match hWaveOut!!!!\n");
            return 0L;
        }

        //
        // the wave block is done playing, we need to let the driver unprepare
        // it and free the memory it used.
        //
        //      wParam = hWaveOut
        //      lParam = lpWaveHdr
        //
        waveOutUnprepareHeader((HWAVEOUT)wParam, (LPWAVEHDR)lParam, sizeof(WAVEHDR));
//        GlobalUnlock(lParam);
//      LocalFree(lParam);
        GlobalFree( (HANDLE)lParam );

        //
        // if we have no more outstanding blocks free the wave device.
        //
        if (--iWaveOut == 0) {
            sprintf(ach, " MM_WOM_DONE:  Releasing the wave device\n");
            waveOutClose(hWaveOut);
        }
        break;

    case MM_MIM_OPEN:
        sprintf(ach, " MM_MIM_OPEN:      %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_MIM_CLOSE:
        sprintf(ach, " MM_MIM_CLOSE:     %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_MIM_DATA:
        sprintf(ach, " MM_MIM_DATA:      %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_MIM_LONGDATA:
        sprintf(ach, " MM_MIM_LONGDATA:  %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_MIM_ERROR:
        sprintf(ach, " MM_MIM_ERROR:     %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_MIM_LONGERROR:
        sprintf(ach, " MM_MIM_LONGERROR: %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_MOM_OPEN:
        sprintf(ach, " MM_MOM_OPEN:      %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_MOM_CLOSE:
        sprintf(ach, " MM_MOM_CLOSE:     %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case MM_MOM_DONE:
        sprintf(ach, " MM_MOM_DONE:      %04X %08lX\n",wParam,lParam);
        dbgOut;
        break;

    case WM_INITMENU:
        EnableMenuItem((HWND)wParam, IDM_LOOPBREAK , hWaveOut ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem((HWND)wParam, IDM_RESET     , hWaveOut ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem((HWND)wParam, IDM_PAUSE     , hWaveOut ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem((HWND)wParam, IDM_RESUME    , hWaveOut ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem((HWND)wParam, IDM_VOLUME, hwndVolumeDlg ? MF_GRAYED : MF_ENABLED);
        EnableMenuItem((HWND)wParam, IDM_AUX_VOLUME, AuxNotSupported ? MF_GRAYED : MF_ENABLED);
        break;
    }
    return DefWindowProc(hWnd, message, wParam, lParam);
}

static void CommandMsg(HWND hWnd, UINT wParam, LONG lParam)
{
int         i;
HMENU       hMenu;
BYTE        acherr[80];
UINT        wErr;
UINT        wPortNum;
SHORTMSG    sm;

    switch (wParam) {

    case IDM_SNDPLAYSOUND:
    case IDM_PLAYWAVE:

//        GetProfileString(szAppName, "wavpath", "", szPath, sizeof(szPath));
//        if (lstrlen(szPath)) {
//            DosChangeDir(szPath);
//        }
//        i = OpenFileDialog(hMainWnd,
//                          "Open file",
//                          "*.WAV",
//                          DLGOPEN_MUSTEXIST | DLGOPEN_OPEN,
//                          szFname,
//                          sizeof(szFname));
//        if (i == DLG_MISSINGFILE) {
//            sbtestError"Illegal filename");
//        }
//	else if (i == DLG_CANCEL) {
//            // user pressed cancel
//        }
//	else {
//        }


        if (GetOpenFileName(&ofn)) {
            // valid file name
            if (wParam == IDM_SNDPLAYSOUND) {
                if (wLoops == IDM_LOOPOFF)
                    sndPlaySound(ofn.lpstrFile, SND_ASYNC);
                else
                    sndPlaySound(ofn.lpstrFile, SND_ASYNC|SND_LOOP);
            }
            else {
                PlayFile(ofn.lpstrFile);
            }
        }
        break;

    case IDM_LOOPOFF:
    case IDM_LOOP2:
    case IDM_LOOP100:
        wLoops = wParam;
        hMenu = GetMenu(hWnd);
        CheckMenuItem(hMenu, IDM_LOOPOFF, MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_LOOP2,   MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_LOOP100, MF_UNCHECKED);
        CheckMenuItem(hMenu, wParam,      MF_CHECKED);
        if (wParam != IDM_LOOP100) {
            if (hWaveOut) {
                waveOutBreakLoop(hWaveOut);
            }
        }
        break;

    case IDM_LOOPBREAK:
        if (hWaveOut) {
            waveOutBreakLoop(hWaveOut);
        }
        break;

    case IDM_POSITION:
        if (hPosWnd == NULL) {
            CreatePosition(hWnd);
        }
        else {
            DestroyWindow(hPosWnd);
            hPosWnd = NULL;
        }
        break;

    case IDM_RESET:
        if (hWaveOut)
            waveOutReset(hWaveOut);
        break;

    case IDM_PAUSE:
        if (hWaveOut)
            waveOutPause(hWaveOut);
        break;

    case IDM_RESUME:
        if (hWaveOut)
            waveOutRestart(hWaveOut);
        break;

    case IDM_RECORD:
        Record(hWnd);
        break;

    case IDM_AUX_VOLUME:
        SetAux = TRUE;
        hwndVolumeDlg = CreateDialog(ghInst, "Volume", hWnd, (DLGPROC)VolumeDlgProc);
        SetWindowPos( hwndVolumeDlg, (HWND)-1, 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE |
                      SWP_NOZORDER | SWP_SHOWWINDOW );
        break;

    case IDM_VOLUME:
        SetAux = FALSE;
        hwndVolumeDlg = CreateDialog(ghInst, "Volume", hWnd, (DLGPROC)VolumeDlgProc);
        SetWindowPos( hwndVolumeDlg, (HWND)-1, 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE |
                      SWP_NOZORDER | SWP_SHOWWINDOW );
        break;

    case IDM_I0:
    case IDM_I1:
    case IDM_I2:
    case IDM_I3:
    case IDM_I4:
    case IDM_I5:
    case IDM_I6:
    case IDM_I7:
    case IDM_I8:
    case IDM_I9:
    case IDM_I10:
    case IDM_I11:
    case IDM_I12:
    case IDM_I13:
    case IDM_I14:
    case IDM_I15:
        hMenu = GetMenu(hWnd);
        for (i = IDM_I0; i <= IDM_I15; i++) {
            CheckMenuItem(hMenu, i, MF_UNCHECKED);
        }
        CheckMenuItem(hMenu, wParam, MF_CHECKED);
        EnableMenuItem(hMenu, IDM_STARTMIDIIN, MF_GRAYED);
        EnableMenuItem(hMenu, IDM_STOPMIDIIN, MF_GRAYED);

        if (hMidiIn) {
            midiInClose(hMidiIn);
            hMidiIn = NULL;
        }

        wPortNum = wParam - IDM_I0;

        if (wPortNum != 0) {
            //  NOTE!!! we must PAGE-LOCK our CODE and DATA segment!!!!
            //  The FIXED segment attribute is ignored for applications
            //
            //  Callbacks *must* be in FIXED code segments of DLLs *not* APPS
            //
            //  *********** THIS APP IS TOTALY WRONG! *************
            //  ******************* DONT COPY THIS CODE! **********************

//            #define GetDS() HIWORD((DWORD)((LPSTR)&hMidiIn))
//            GlobalPageLock(GetDS());


            wErr = midiInOpen(&hMidiIn, wPortNum - 1, (DWORD)SBMidiInCallback,
                          (DWORD)hMidiOut, CALLBACK_FUNCTION);
            if (wErr) {
                sprintf(ach, " Error opening MIDI Input\n");
                dbgOut;
                midiInGetErrorText(wErr, acherr, sizeof(acherr));
                sprintf(ach, " Error: %s\n", (LPSTR) acherr);
                dbgOut;
                hMidiIn = NULL;
                CheckMenuItem(hMenu, wParam, MF_UNCHECKED);
                CheckMenuItem(hMenu, IDM_I0, MF_CHECKED);
            }
            else
                EnableMenuItem(hMenu, IDM_STARTMIDIIN, MF_ENABLED);
        }
        break;

    case IDM_STARTMIDIIN:
        if (hMidiIn) {
            hMenu = GetMenu(hWnd);
            EnableMenuItem(hMenu, IDM_STARTMIDIIN, MF_GRAYED);
            EnableMenuItem(hMenu, IDM_STOPMIDIIN, MF_ENABLED);
            midiInStart(hMidiIn);
        }
        break;

    case IDM_STOPMIDIIN:
        if (hMidiIn) {
            hMenu = GetMenu(hWnd);
            EnableMenuItem(hMenu, IDM_STOPMIDIIN, MF_GRAYED);
            EnableMenuItem(hMenu, IDM_STARTMIDIIN, MF_ENABLED);
            midiInStop(hMidiIn);
        }
        break;

    case IDM_D0:
    case IDM_D1:
    case IDM_D2:
    case IDM_D3:
    case IDM_D4:
    case IDM_D5:
    case IDM_D6:
    case IDM_D7:
    case IDM_D8:
    case IDM_D9:
    case IDM_D10:
    case IDM_D11:
    case IDM_D12:
    case IDM_D13:
    case IDM_D14:
    case IDM_D15:
        hMenu = GetMenu(hWnd);
        for (i = IDM_D0; i <= IDM_D15; i++) {
            CheckMenuItem(hMenu, i, MF_UNCHECKED);
        }
        CheckMenuItem(hMenu, wParam, MF_CHECKED);

        if (hMidiOut) {
            midiOutClose(hMidiOut);
            hMidiOut = NULL;
        }

        if (wParam == IDM_D0 + LASTPORT)
            wPortNum = MIDIMAPPER;    // open mapper if chose last item
        else
            wPortNum = wParam - IDM_D0 - 1;

        if (wParam != IDM_D0) {
            wErr = midiOutOpen(&hMidiOut, wPortNum, (DWORD)hWnd, 0L, 0L);
            if (wErr) {
                sprintf(ach, " Error opening MIDI Output\n");
                dbgOut;
                midiOutGetErrorText(wErr, acherr, sizeof(acherr));
                sprintf(ach, " Error: %s\n", (LPSTR) acherr);
                dbgOut;
                hMidiOut = NULL;
            }
            else {               // send patch change
                sm.b[0] = (BYTE) 0xC0 + bChannel;
                sm.b[1] = bInstrument;
                midiOutShortMsg(hMidiOut, sm.dw);
            }
        }
        break;

    case IDM_C0:
    case IDM_C1:
    case IDM_C2:
    case IDM_C3:
    case IDM_C4:
    case IDM_C5:
    case IDM_C6:
    case IDM_C7:
    case IDM_C8:
    case IDM_C9:
    case IDM_C10:
    case IDM_C11:
    case IDM_C12:
    case IDM_C13:
    case IDM_C14:
    case IDM_C15:
        hMenu = GetMenu(hWnd);
        for (i = IDM_C0; i <= IDM_C15; i++) {
            CheckMenuItem(hMenu, i, MF_UNCHECKED);
        }
        CheckMenuItem(hMenu, wParam, MF_CHECKED);
        bChannel = (BYTE)(wParam - IDM_C0);
        break;

    case IDM_KEYBOARD:
        if (hKeyWnd == NULL) {
            CreateKeyboard(hWnd);
        }
        else {
            DestroyWindow(hKeyWnd);
            hKeyWnd = NULL;
        }
        break;

    case IDM_INSTRUMENT:
        if (hInstWnd == NULL) {
            CreateInstrument(hWnd);
        }
        else {
            DestroyWindow(hInstWnd);
            hInstWnd = NULL;
        }
        break;

    case IDM_DUMPPATCH:
        hMenu = GetMenu(hWnd);
        if (ISBITSET(fDebug, DEBUG_PATCH))

            RESETBIT(fDebug, DEBUG_PATCH);
        else
            SETBIT(fDebug, DEBUG_PATCH);

        CheckMenuItem(hMenu, wParam,
                ISBITSET(fDebug, DEBUG_PATCH) ? MF_CHECKED : MF_UNCHECKED);
        break;

    case IDM_DUMPNOTES:
        hMenu = GetMenu(hWnd);
        if (ISBITSET(fDebug, DEBUG_NOTE))

            RESETBIT(fDebug, DEBUG_NOTE);
        else
            SETBIT(fDebug, DEBUG_NOTE);

        CheckMenuItem(hMenu, wParam,
                ISBITSET(fDebug, DEBUG_NOTE) ? MF_CHECKED : MF_UNCHECKED);
        break;

    case IDM_RIP:
        //
        //  send total stuff to mmsystem APIs
        //
        waveOutPrepareHeader((HWAVEOUT)1, NULL, sizeof(WAVEHDR));
        waveOutClose(NULL);
        midiInPrepareHeader(0, (LPMIDIHDR)-1l, 4);
        midiOutClose((HMIDIOUT)(-1));
        break;

    case IDM_GETINFO:
        GetInfo();
        break;

    case IDM_WAVEOPTIONS:
        WaveOptions(hWnd);
        break;

    case IDM_MIDIOPTIONS:
        MidiOptions(hWnd);
        break;

    case IDM_ABOUT:
        About(hWnd);
        break;

    case IDM_EXIT:
        PostMessage(hWnd, WM_CLOSE, 0, 0l);
        break;

#if 0
    case IDM_PROFSTART:

        if (iProfiler) {
            GetProfileString(szAppName, "profpath", "", szPath, sizeof(szPath));
            if (lstrlen(szPath)) {
                DosChangeDir(szPath);
            }
            ProfStart();
            sprintf(ach, "\nProfiler started. Files in %s", (LPSTR) szPath);
            dbgOut;
            EnableMenuItem(hMenu, IDM_PROFSTART, MF_GRAYED);
            EnableMenuItem(hMenu, IDM_PROFSTOP, MF_ENABLED);
        }
        break;

    case IDM_PROFSTOP:
        if (iProfiler) {
            ProfStop();
            ProfFlush();
            sprintf(ach, "\nProfiler stopped");
            dbgOut;
            EnableMenuItem(hMenu, IDM_PROFSTART, MF_ENABLED);
            EnableMenuItem(hMenu, IDM_PROFSTOP, MF_GRAYED);
        }
        break;

#endif
    default:
        break;
    }
}


int FAR PASCAL VolumeDlgProc(HWND hwnd, unsigned msg, UINT wParam, LONG lParam )
{
    static HWND     hwndScrollbar;
    static int      iScrollPos;

    DWORD           dwVolumeLevel;
    DWORD           dwNewVolumeLevel;
    WORD            wVolumeLeft;
    WORD            wVolumeRight;
    WORD            ret;

    switch (msg) {

    case WM_INITDIALOG:

        /*
         * What is the current volume setting ?
         */
        (SetAux ? auxGetVolume : waveOutGetVolume)( 0, &dwVolumeLevel );

        /*
         * Take the average of the left and right volume settings
         */
        wVolumeLeft  = LOWORD( dwVolumeLevel );
        wVolumeRight = HIWORD( dwVolumeLevel );
        iScrollPos = ( wVolumeLeft + wVolumeRight ) >> 9;

        /*
         * Set the scroll bar and level indicator
         */
        hwndScrollbar   = GetDlgItem( hwnd, 105 ); /* 105 is the scroll bar */
        SetScrollRange( hwndScrollbar, SB_CTL, 0, 255, FALSE );
        SetScrollPos( hwndScrollbar, SB_CTL, iScrollPos, TRUE );
        SetDlgItemInt( hwnd, 104, iScrollPos << 8, FALSE );
        break;

    case WM_HSCROLL:
        switch ( LOWORD( wParam ) ) {

            case SB_BOTTOM:
                iScrollPos = 0;
                break;

            case SB_TOP:
                iScrollPos = 255;
                break;

            case SB_LINEUP:
                iScrollPos--;
                break;

            case SB_LINEDOWN:
                iScrollPos++;
                break;

            case  SB_PAGEDOWN:
                iScrollPos += 16;
                break;

            case SB_PAGEUP:
                iScrollPos -= 16;
                break;

            case SB_THUMBPOSITION:
            case SB_THUMBTRACK:
                iScrollPos = HIWORD( wParam );
                break;

        }

        /*
         * Make sure that the new setting is within the correct volume
         * range
         */
        if ( iScrollPos > 255 ) {
            iScrollPos = 255;
        }

        if ( iScrollPos < 0 ) {
            iScrollPos = 0;
        }

        /*
         * Update the scrollbar position and value indicator
         */
        SetScrollPos( hwndScrollbar, SB_CTL, iScrollPos, TRUE );
        SetDlgItemInt( hwnd, 104, iScrollPos << 8, FALSE );

        /*
         * Set the volume on the device and make sure that the
         * volume has been set correctly.
         */
        dwVolumeLevel = MAKELONG( iScrollPos << 8, iScrollPos << 8 );
        if ( 0 != (ret =
                   (SetAux ? auxSetVolume : waveOutSetVolume)( 0, dwVolumeLevel ) ) ) {
            sprintf( ach, "\n waveOutSetVolume %8X ret = %d ",
                     dwVolumeLevel, ret );
            dbgOut;
        }
        else {
            (SetAux ? auxGetVolume : waveOutGetVolume)( 0, &dwNewVolumeLevel );

            if ( dwNewVolumeLevel != dwVolumeLevel) {
                sprintf( ach, "\n New volume not set correctly" );
                dbgOut;
            }
        }
        break;

    case WM_COMMAND:
        DestroyWindow( hwnd );
        hwndVolumeDlg = (HWND)NULL;
        break;

    default:
        return FALSE;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\sbtest.h ===
/****************************************************************************
 *
 *  sbtest.h
 *
 *  Copyright (c) 1991 Microsoft Corporation.  All Rights Reserved.
 *
 ***************************************************************************/

#include "options.h"
#include "record.h"
#include "riff.h"
#include "stdio.h"

#define dbgOut wpfOut(hPrintfWnd, ach)
extern char ach[256];
/****************************************************************************
 *
 *  defines
 *
 ***************************************************************************/

#define MAXFILENAME 256

// string resource ids

#define IDS_APPNAME           1

// menu ids

#define IDM_ABOUT           101
#define IDM_EXIT            102

#define IDM_PLAYWAVE        201
#define IDM_SNDPLAYSOUND    202

#define IDM_LOOPOFF         211
#define IDM_LOOP2           212
#define IDM_LOOP100         213
#define IDM_LOOPBREAK       214

#define IDM_RESET           221
#define IDM_POSITION        222
#define IDM_PAUSE           223
#define IDM_RESUME          224
#define IDM_VOLUME          225
#define IDM_AUX_VOLUME      226

#define IDM_RECORD          231

#define IDM_D0              301
#define IDM_D1              302
#define IDM_D2              303
#define IDM_D3              304
#define IDM_D4              305
#define IDM_D5              306
#define IDM_D6              307
#define IDM_D7              308
#define IDM_D8              309
#define IDM_D9              310
#define IDM_D10             311
#define IDM_D11             312
#define IDM_D12             313
#define IDM_D13             314
#define IDM_D14             315
#define IDM_D15             316
#define LASTPORT	    15

#define IDM_D0              301
#define IDM_D1              302
#define IDM_D2              303
#define IDM_D3              304
#define IDM_D4              305
#define IDM_D5              306
#define IDM_D6              307
#define IDM_D7              308
#define IDM_D8              309
#define IDM_D9              310
#define IDM_D10             311
#define IDM_D11             312
#define IDM_D12             313
#define IDM_D13             314
#define IDM_D14             315
#define IDM_D15             316
#define LASTPORT	    15

#define IDM_C0              321
#define IDM_C1              322
#define IDM_C2              323
#define IDM_C3              324
#define IDM_C4              325
#define IDM_C5              326
#define IDM_C6              327
#define IDM_C7              328
#define IDM_C8              329
#define IDM_C9              330
#define IDM_C10             331
#define IDM_C11             332
#define IDM_C12             333
#define IDM_C13             334
#define IDM_C14             335
#define IDM_C15             336

#define IDM_INSTRUMENT      341
#define IDM_KEYBOARD        342

#define IDM_I0              401
#define IDM_I1              402
#define IDM_I2              403
#define IDM_I3              404
#define IDM_I4              405
#define IDM_I5              406
#define IDM_I6              407
#define IDM_I7              408
#define IDM_I8              409
#define IDM_I9              410
#define IDM_I10             411
#define IDM_I11             412
#define IDM_I12             413
#define IDM_I13             414
#define IDM_I14             415
#define IDM_I15             416
#define IDM_STARTMIDIIN	    417
#define IDM_STOPMIDIIN	    418

#define IDM_GETINFO         501

#define IDM_DUMPNOTES	    601
#define IDM_DUMPPATCH	    602
#define IDM_RIP             603

#define IDM_WAVEOPTIONS     701
#define IDM_MIDIOPTIONS     702

#define IDM_PROFSTART       801
#define IDM_PROFSTOP        802

// miscellaneous defines

#define MAXPLAYERS          100
#define NOTEVELOCITY         80

#define DEBUG_PATCH	1
#define DEBUG_NOTE	2

#define ISBITSET(f,b)	((f) & (b))
#define SETBIT(f,b)	((f)|=(b))
#define RESETBIT(f,b)	((f)&=(~b))

/****************************************************************************
 *
 *  typedefs
 *
 ***************************************************************************/

typedef union shortmsg_tag {
    BYTE  b[4];
    DWORD dw;
} SHORTMSG;

typedef struct playitem_tag {
    LPWAVEHDR lpHdr;
    LPSTR     lpData;
    HANDLE    hMem;
    HANDLE    hData;
    BOOL      bResource;
} PLAYITEM;

/****************************************************************************
 *
 *  extern declarations
 *
 ***************************************************************************/

// about.c
extern void About(HWND hWnd);
extern int FAR PASCAL AboutDlgProc(HWND, unsigned, UINT, LONG);

// callback.c
extern void FAR PASCAL SBMidiInCallback(HMIDIIN hMidiIn, UINT wMsg,
                            DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);

// init.c
extern HANDLE hAccTable;
extern int    gInstBase;
extern HWND   hMainWnd;
extern BOOL InitFirstInstance(HANDLE hInstance);
extern BOOL InitEveryInstance(HANDLE hInstance, int cmdShow);
extern void InitMenus(HWND hWnd);
extern int  sbtestError(LPSTR msg);

// inst.c
extern HWND hInstWnd;
extern BYTE bInstrument;
extern void CreateInstrument(HWND hWnd);
extern long FAR PASCAL InstWndProc(HWND, unsigned, UINT, LONG);

// keyb.c
extern HWND hKeyWnd;
extern void CreateKeyboard(HWND hParent);
extern long FAR PASCAL KeyWndProc(HWND, unsigned, UINT, LONG);

// options.c
extern void WaveOptions(HWND hWnd);
extern int FAR PASCAL WaveOptionsDlgProc(HWND, unsigned, UINT, LONG);
extern void MidiOptions(HWND hWnd);
extern int FAR PASCAL MidiOptionsDlgProc(HWND, unsigned, UINT, LONG);

// playfile.c
extern HWAVEOUT hWaveOut;
extern int iWaveOut;
extern void PlayFile(LPSTR fname);

// pos.c
extern HWND hPosWnd;
extern void CreatePosition(HWND hParent);
extern long FAR PASCAL PosWndProc(HWND, unsigned, UINT, LONG);
extern void ShowPos(void);

// record.c
extern HWAVEIN hWaveIn;
extern void Record(HWND hWnd);
extern int FAR PASCAL RecordDlgProc(HWND, unsigned, UINT, LONG);

// sbtest.c
extern HMIDIOUT hMidiOut;
extern HANDLE   ghInst;
extern char     szAppName[];
extern HWND     hPrintfWnd;
extern int      fDebug;
extern BYTE     bChannel;
extern UINT     wLoops;
extern void GetInfo(void);
extern int PASCAL WinMain(HANDLE, HANDLE, LPSTR, int);
extern long FAR PASCAL MainWndProc(HWND, unsigned, UINT, LONG);
extern LPSTR    lpRecordBuf;
extern DWORD    dwBlockSize;
extern DWORD    dwRecorded;
extern DWORD    dwDataSize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\wincom.h ===
/****************************************************************************
 *
 *	WINCOM.H
 *
 *	Exported definitions for MM/Windows common code library.
 *
 ****************************************************************************/

#ifndef _WINCOM_H_
#define _WINCOM_H_


/*************************************
 *
 *	OPEN FILE DIALOG BOX
 *
 *************************************/

int FAR PASCAL OpenFileDialog(HWND hwndParent, LPSTR lpszTitle,
				LPSTR lpszExtension, WORD wFlags,
				LPSTR lpszFileBuf, WORD wFileLen );

/*  Flags for OpenFileDialog  */
#define DLGOPEN_MUSTEXIST	0x0001
#define DLGOPEN_NOSHOWSPEC	0x0002
#define DLGOPEN_SAVE		0x0004
#define DLGOPEN_OPEN		0x0008
#define DLGOPEN_SHOWDEFAULT	0x0020
#define DLGOPEN_NOBEEPS		0x0040
#define DLGOPEN_SEARCHPATH	0x0080

/*  Return codes  */
#define DLG_CANCEL	0
#define DLG_MISSINGFILE	-1
#define DLG_OKFILE	1


/**************************************************
 *
 *  DEFAULT FILE OPEN DIALOG PROCEDURE STUFF
 *
 **************************************************/

BOOL FAR PASCAL DefDlgOpenProc(HWND hwnd, unsigned msg,
				WORD wParam, LONG lParam);

typedef struct _DlgOpenCreate {
	LPSTR	lpszTitle;	// NULL if use default dialog caption
	LPSTR	lpszExt;	// NULL defaults to *.*
	LPSTR	lpszBuf;	// final filename buffer
	WORD	wBufLen;	// length of this buffer
	WORD	wFlags;		// DLGOPEN_xxx flags
	DWORD	dwExtra;	// for use by the owner of the dialog
} DlgOpenCreate;
typedef DlgOpenCreate FAR *FPDlgOpenCreate;

#define SetDialogReturn(hwnd, val) SetWindowLong(hwnd, 0, val)

/*  These messages are sent to/from DefDlgOpenProc to make the
 *  Dialog box work.  They may be answered by the "owner" of the dialog
 *  box.
 */
#define DLGOPEN_OKTOCLOSE	(WM_USER + 1)	// ask whether ok to close box
#define DLGOPEN_CLOSEBOX	(WM_USER + 2)	// tell dlgOpen to close box
#define DLGOPEN_SETEXTEN	(WM_USER + 3)	// sets default extensions
// #define DLGOPEN_SETEDITTEXT	(WM_USER + 4)	// sets editbox contents
// #define DLGOPEN_REFRESH		(WM_USER + 5)	// refresh the box?
#define DLGOPEN_CHANGED		(WM_USER + 6)	// edit box has been changed
#define DLGOPEN_RESETDIR	(WM_USER + 7)	// directory change

BOOL FAR PASCAL IconDirBox(HWND hwnd, WORD wId, unsigned msg,
				WORD wParam, LONG lParam);
BOOL FAR PASCAL IconDirBoxFixup(HWND hwndDirbox);


/*
 *  HUGE READ/WRITE functions
 *
 */

LONG FAR PASCAL _hread( int hFile, HPSTR hpBuffer, DWORD dwBytes );
LONG FAR PASCAL _hwrite( int hFile, HPSTR hpBuffer, DWORD dwBytes );


/*
 *  FAR STRING FUNCTIONS
 */
LPSTR FAR PASCAL lstrncpy(LPSTR dest, LPSTR source, WORD count);
LPSTR FAR PASCAL lstrncat(LPSTR dest, LPSTR source, WORD count);
int   FAR PASCAL lstrncmp(LPSTR d, LPSTR s, WORD n);

/*
 *  FAR MEMORY FUNCTIONS
 */
void FAR * FAR PASCAL lmemcpy(LPSTR dest, LPSTR source, WORD count);
void FAR * FAR PASCAL hmemcpy(HPSTR dest, HPSTR source, LONG count);
HANDLE FAR PASCAL CopyHandle(WORD wFlags, HANDLE h);

void FAR PASCAL fmemfill (LPSTR lpMem, DWORD count, BYTE bFill);

/*
 *  BYTE SWAPPING FUNCTIONS
 */
WORD FAR PASCAL ByteSwapWORD( WORD w );
DWORD FAR PASCAL ByteSwapDWORD( DWORD dw );


/*
 * atol for far strings
 */
LONG FAR PASCAL StringToLong( LPSTR lpstr );


/*
 *  PATH PARSING FUNCTIONS
 */
BOOL FAR PASCAL AddExtension(LPSTR lpszPath, LPSTR lpszExt, WORD wBufLen);
WORD FAR PASCAL SplitPath(LPSTR path, LPSTR drive, LPSTR dir,
			LPSTR fname, LPSTR ext);
void FAR PASCAL MakePath(LPSTR lpPath, LPSTR lpDrive, LPSTR lpDir,
			LPSTR lpFname, LPSTR lpExt);
LPSTR FAR PASCAL QualifyPathname(LPSTR lpszFile);


/* return codes from SplitPath */
#define PATH_OK		0	/* path is fine */
#define PATH_TOOLONG	1	/* filename too long   */
#define PATH_ILLEGAL	2	/* filename is illegal */

		
/* Definitions stolen from <stdlib.h> */
#ifndef _MAX_PATH

#define _MAX_PATH      144      /* max. length of full pathname */
#define _MAX_DRIVE   3      /* max. length of drive component */
#define _MAX_DIR       130      /* max. length of path component */
#define _MAX_FNAME   9      /* max. length of file name component */
#define _MAX_EXT     5      /* max. length of extension component */

#endif

/*
 *  DOS FAR UTILITY FUNCTIONS
 */
typedef struct _FindFileStruct {
	char	chReserved[21];
	BYTE	bAttribute;
	WORD	wTime;
	WORD	wDate;
	DWORD	dwSize;
	char	chFilename[13];
} FindFileStruct;
typedef FindFileStruct	FAR *FPFindFileStruct;
typedef FindFileStruct	NEAR *NPFindFileStruct;

#define	DOS_READONLY	0x0001
#define	DOS_HIDDEN	0x0002
#define DOS_SYSTEM	0x0004
#define DOS_VOLUME	0x0008
#define DOS_DIRECTORY	0x0010
#define DOS_ARCHIVE	0x0020
#define DOS_FILES	(DOS_READONLY | DOS_SYSTEM)
#define DOS_ALL		(DOS_FILES | DOS_DIRECTORY | DOS_HIDDEN)

/*  Return codes from DosFindFirst and DosFindNext  */
#define	DOSFF_OK		0
#define DOSFF_FILENOTFOUND	2
#define DOSFF_PATHINVALID	3
#define DOSFF_NOMATCH		0x12

WORD FAR PASCAL DosFindFirst(FPFindFileStruct lpFindStruct,
				LPSTR lpszFileSpec, WORD wAttrib);
WORD FAR PASCAL DosFindNext(FPFindFileStruct lpFindStruct);

int FAR PASCAL DosChangeDir(LPSTR lpszPath);
WORD FAR PASCAL DosGetCurrentDrive();
BOOL FAR PASCAL DosSetCurrentDrive(WORD wDrive);
WORD FAR PASCAL DosGetCurrentDir(WORD wCurdrive, LPSTR lpszBuf);
BOOL FAR PASCAL DosGetCurrentPath(LPSTR lpszBuf, WORD wLen);
WORD FAR PASCAL DosDeleteFile(LPSTR lpszFile);
BOOL FAR PASCAL DosGetVolume(BYTE chDrive, LPSTR lpszBuf);

WORD FAR PASCAL DosQueryNet(WORD wIndex, LPSTR lpszLocal, LPSTR lspzRemote);
WORD FAR PASCAL mscdGetDrives(LPSTR lpszDriveBuf);

/*  Return codes from DosQueryNet()  */
#define NET_ERROR	(-1)
#define	NET_INVALID	(0x0100)
#define	NET_TYPEMASK	(0x00ff)
#define NET_PRINTER	(0x0003)
#define NET_DRIVE	(0x0004)



/*
 *  ERROR MESSAGE REPORTING BOX
 */
short FAR cdecl ErrorResBox(	HWND	hwnd,
				HANDLE	hInst,
				WORD	flags,
				WORD	idAppName,
				WORD	idErrorStr, ...);

/*
 *  PROGRESS BAR GRAPH CONTROL - class "ProgBar"
 */
#define BAR_SETRANGE	(WM_USER + 0)
#define BAR_SETPOS	(WM_USER + 2)
#define BAR_DELTAPOS	(WM_USER + 4)
#define CTLCOLOR_PROGBAR	(CTLCOLOR_MAX + 2)


/*
 *  STATUS TEXT CONTROL - class "MPStatusText".
 *
 *  See wincom project file status.c for more information on control.
 */
#define ST_GETSTATUSHEIGHT	(WM_USER + 0)
#define ST_SETRIGHTSIDE		(WM_USER + 1)
#define ST_GETRIGHTSIDE		(WM_USER + 2)
#define CTLCOLOR_STATUSTEXT	(CTLCOLOR_MAX + 1)


/*
 *  ARROW CONTROL - class "ComArrow".
 */
LONG FAR PASCAL ArrowEditChange( HWND hwndEdit, WORD wParam,
			LONG lMin, LONG lMax );

/*
 *  CHOOSER CONTROL - class "CHOOSER".
 */
/* Chooser Window control messages */
#define CM_SETITEMRECTSIZE	(WM_USER + 1)
#define CM_CALCSIZE		(WM_USER + 2)
#define CM_ADDITEM		(WM_USER + 3)
#define CM_INSERTITEM		(WM_USER + 4)
#define CM_DELETEITEM		(WM_USER + 5)
#define CM_GETCOUNT		(WM_USER + 6)
#define CM_GETITEMDATA		(WM_USER + 7)
#define CM_GETCURSEL		(WM_USER + 8)
#define CM_SETCURSEL		(WM_USER + 9)
#define CM_FINDITEM		(WM_USER + 10)
#define CM_ERR			LB_ERR

/* Chooser Window notification messages */
#define CN_SELECTED		100
#define CN_DESELECTED		101


/*
 *  Mac-like small Non-client window message handler
 */
LONG FAR PASCAL ncMsgFilter(HWND hwnd,unsigned msg, WORD wParam, LONG lParam);

/*  Window styles used by ncMsgFilter  */
#define WF_SIZEFRAME	WS_THICKFRAME
#define WF_SYSMENU	WS_SYSMENU
#define WF_MINIMIZED	WS_MINIMIZE
#define WF_SIZEBOX	0x0002


/*  Obscure stuff to deal with DLL loading/unloading  */
typedef HANDLE	HLIBLIST;
typedef WORD	DYNALIBID;

typedef struct _DynaLib {
	HANDLE	hModule;
	WORD	wRefcount;
	char	achLibname[_MAX_PATH];
} DynaLib;
typedef DynaLib FAR *FPDynaLib;

HLIBLIST FAR PASCAL dllMakeList(WORD wSize, LPSTR lpszLoadPoint,
			LPSTR lpszFreePoint);
BOOL FAR PASCAL	dllUnloadLib(HLIBLIST hlist, DYNALIBID id, BOOL fDestroy);
BOOL FAR PASCAL	dllDestroyList(HLIBLIST hlist);
BOOL FAR PASCAL dllForceUnload(HLIBLIST hlist);
HANDLE FAR PASCAL dllLoadLib(HLIBLIST hlist, DYNALIBID libid);
BOOL FAR PASCAL	dllGetInfo(HLIBLIST hlist, DYNALIBID libid, FPDynaLib fpLib);
BOOL FAR PASCAL dllIsLoaded(HLIBLIST hlist, DYNALIBID libid);
DYNALIBID FAR PASCAL dllAddLib(HLIBLIST hlist, LPSTR lpszName);
DYNALIBID FAR PASCAL dllIterAll(HLIBLIST hlist, DYNALIBID idLast);
DYNALIBID FAR PASCAL dllFindHandle(HLIBLIST hlist, HANDLE hModHandle);
DYNALIBID FAR PASCAL dllFindName(HLIBLIST hlist, LPSTR lpszName);
DYNALIBID FAR PASCAL dllAddLoadedLib(HLIBLIST hlist,HANDLE hModule,BOOL fLoad);



/**********************************
 *
 *	FOR DOS FILE FUNCTIONS (SWITCH PSP)
 *
 **********************************/


/* flags for DosSeek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

/* DOS attributes */
#define ATTR_READONLY   0x0001
#define ATTR_HIDDEN     0x0002
#define ATTR_SYSTEM     0x0004
#define ATTR_VOLUME     0x0008
#define ATTR_DIR        0x0010
#define ATTR_ARCHIVE    0x0020
#define ATTR_FILES      (ATTR_READONLY+ATTR_SYSTEM)
#define ATTR_ALL_FILES  (ATTR_READONLY+ATTR_SYSTEM+ATTR_HIDDEN)
#define ATTR_ALL        (ATTR_READONLY+ATTR_DIR+ATTR_HIDDEN+ATTR_SYSTEM)

typedef struct {
    char        Reserved[21];
    BYTE        Attr;
    WORD        Time;
    WORD        Date;
    DWORD       Length;
    char        szName[13];
}   FCB;

typedef FCB     * PFCB;
typedef FCB FAR * LPFCB;

/* functions from dos.asm */

extern int   FAR PASCAL DosError(void);

extern int   FAR PASCAL DosOpen(LPSTR szFile,WORD acc);
extern int   FAR PASCAL DosCreate(LPSTR szFile,WORD acc);
extern int   FAR PASCAL DosDup(int fh);
extern void  FAR PASCAL DosClose(int fh);

extern DWORD FAR PASCAL DosSeek(int fh,DWORD ulPos,WORD org);
extern DWORD FAR PASCAL DosRead(int fh,LPSTR pBuf,DWORD ulSize);
extern DWORD FAR PASCAL DosWrite(int fh,LPSTR pBuf,DWORD ulSize);

/* DOS ERROR CODES */

#define ERROR_OK            0x00
#define ERROR_FILENOTFOUND  0x02    /* File not found */
#define ERROR_PATHNOTFOUND  0x03    /* Path not found */
#define ERROR_NOFILEHANDLES 0x04    /* Too many open files */
#define ERROR_ACCESSDENIED  0x05    /* Access denied */
#define ERROR_INVALIDHANDLE 0x06    /* Handle invalid */
#define ERROR_FCBNUKED      0x07    /* Memory control blocks destroyed */
#define ERROR_NOMEMORY      0x08    /* Insufficient memory */
#define ERROR_FCBINVALID    0x09    /* Memory block address invalid */
#define ERROR_ENVINVALID    0x0A    /* Environment invalid */
#define ERROR_FORMATBAD     0x0B    /* Format invalid */
#define ERROR_ACCESSCODEBAD 0x0C    /* Access code invalid */
#define ERROR_DATAINVALID   0x0D    /* Data invalid */
#define ERROR_UNKNOWNUNIT   0x0E    /* Unknown unit */
#define ERROR_DISKINVALID   0x0F    /* Disk drive invalid */
#define ERROR_RMCHDIR       0x10    /* Attempted to remove current directory */
#define ERROR_NOSAMEDEV     0x11    /* Not same device */
#define ERROR_NOFILES       0x12    /* No more files */
#define ERROR_13            0x13    /* Write-protected disk */
#define ERROR_14            0x14    /* Unknown unit */
#define ERROR_15            0x15    /* Drive not ready */
#define ERROR_16            0x16    /* Unknown command */
#define ERROR_17            0x17    /* Data error (CRC) */
#define ERROR_18            0x18    /* Bad request-structure length */
#define ERROR_19            0x19    /* Seek error */
#define ERROR_1A            0x1A    /* Unknown media type */
#define ERROR_1B            0x1B    /* Sector not found */
#define ERROR_WRITE         0x1D    /* Write fault */
#define ERROR_1C            0x1C    /* Printer out of paper */
#define ERROR_READ          0x1E    /* Read fault */
#define ERROR_1F            0x1F    /* General failure */
#define ERROR_SHARE         0x20    /* Sharing violation */
#define ERROR_21            0x21    /* File-lock violation */
#define ERROR_22            0x22    /* Disk change invalid */
#define ERROR_23            0x23    /* FCB unavailable */
#define ERROR_24            0x24    /* Sharing buffer exceeded */
#define ERROR_32            0x32    /* Unsupported network request */
#define ERROR_33            0x33    /* Remote machine not listening */
#define ERROR_34            0x34    /* Duplicate name on network */
#define ERROR_35            0x35    /* Network name not found */
#define ERROR_36            0x36    /* Network busy */
#define ERROR_37            0x37    /* Device no longer exists on network */
#define ERROR_38            0x38    /* NetBIOS command limit exceeded */
#define ERROR_39            0x39    /* Error in network adapter hardware */
#define ERROR_3A            0x3A    /* Incorrect response from network */
#define ERROR_3B            0x3B    /* Unexpected network error */
#define ERROR_3C            0x3C    /* Remote adapter incompatible */
#define ERROR_3D            0x3D    /* Print queue full */
#define ERROR_3E            0x3E    /* Not enough room for print file */
#define ERROR_3F            0x3F    /* Print file was deleted */
#define ERROR_40            0x40    /* Network name deleted */
#define ERROR_41            0x41    /* Network access denied */
#define ERROR_42            0x42    /* Incorrect network device type */
#define ERROR_43            0x43    /* Network name not found */
#define ERROR_44            0x44    /* Network name limit exceeded */
#define ERROR_45            0x45    /* NetBIOS session limit exceeded */
#define ERROR_46            0x46    /* Temporary pause */
#define ERROR_47            0x47    /* Network request not accepted */
#define ERROR_48            0x48    /* Print or disk redirection paused */
#define ERROR_50            0x50    /* File already exists */
#define ERROR_51            0x51    /* Reserved */
#define ERROR_52            0x52    /* Cannot make directory */
#define ERROR_53            0x53    /* Fail on Int 24H (critical error) */
#define ERROR_54            0x54    /* Too many redirections */
#define ERROR_55            0x55    /* Duplicate redirection */
#define ERROR_56            0x56    /* Invalid password */
#define ERROR_57            0x57    /* Invalid parameter */
#define ERROR_58            0x58    /* Net write fault */

/*
 *  DIB and BITMAP UTILITIES
 */
HANDLE FAR PASCAL dibCreate(DWORD dwWidth, DWORD dwHeight, WORD wBitCount,
			    WORD wPalSize, WORD wGmemFlags, WORD wDibFlags);
#define DBC_PALINDEX	0x0001

#define dibWIDTHBYTES(i)	(((i) + 31) / 32 * 4)



/*
 *  WPF OUTPUT WINDOW
 */
#define WPF_CHARINPUT	0x00000001L

void	FAR PASCAL wpfOut(HWND hwnd, LPSTR lpsz);

HWND FAR PASCAL wpfCreateWindow(HWND hwndParent, HANDLE hInst,LPSTR lpszTitle,
				DWORD dwStyle, WORD x, WORD y,
				WORD dx, WORD dy, int iMaxLines, WORD wID);

/*  Control messages sent to WPF window  */
//#define WPF_SETNLINES	(WM_USER + 1)
#define WPF_GETNLINES	(WM_USER + 2)
#define WPF_SETTABSTOPS	(WM_USER + 4)
#define WPF_GETTABSTOPS	(WM_USER + 5)
#define WPF_GETNUMTABS	(WM_USER + 6)
#define WPF_SETOUTPUT	(WM_USER + 7)
#define WPF_GETOUTPUT	(WM_USER + 8)
#define WPF_CLEARWINDOW (WM_USER + 9)

/*  Flags for WPF_SET/GETOUTPUT  */
#define	WPFOUT_WINDOW		1
#define WPFOUT_COM1		2
#define WPFOUT_NEWFILE		3
#define WPFOUT_APPENDFILE	4
#define WPFOUT_DISABLED		5

/*  Messages sent to owner of window  */
#define WPF_NTEXT	(0xbff0)
#define WPF_NCHAR	(0xbff1)


/**********************************
 *
 *	DEBUGGING SUPPORT
 *
 **********************************/

BOOL	FAR PASCAL	wpfDbgSetLocation(WORD wLoc, LPSTR lpszFile);
int	FAR cdecl	wpfDbgOut(LPSTR lpszFormat, ...);
BOOL	FAR PASCAL	wpfSetDbgWindow(HWND hwnd, BOOL fDestroyOld);

#define	WinPrintf	wpfDbgOut

#ifdef DEBUG
	BOOL	__fEval;
	BOOL	__iDebugLevel;

	int FAR PASCAL __WinAssert(LPSTR lpszFile, int iLine);

	#define WinAssert(exp)		\
		((exp) ? 0 : __WinAssert((LPSTR) __FILE__, __LINE__))
	#define WinEval(exp) (__fEval=(exp), WinAssert(__fEval), __fEval)

	#define wpfGetDebugLevel(lpszModule)	\
		(__iDebugLevel = GetProfileInt("MMDebug", (lpszModule), 0))

        #define wpfSetDebugLevel(i)    \
                (__iDebugLevel = (i))

        #define wpfDebugLevel()    (__iDebugLevel)

	#define dprintf if (__iDebugLevel) wpfDbgOut
	#define dprintf1 if (__iDebugLevel >= 1) wpfDbgOut
	#define dprintf2 if (__iDebugLevel >= 2) wpfDbgOut
	#define dprintf3 if (__iDebugLevel >= 3) wpfDbgOut
	#define dprintf4 if (__iDebugLevel >= 4) wpfDbgOut
#else
	#define WinAssert(exp) 0
	#define WinEval(exp) (exp)

        #define wpfGetDebugLevel(lpszModule) 0
        #define wpfSetDebugLevel(i)          0
        #define wpfDebugLevel()              0

	#define dprintf if (0) ((int (*)(char *, ...)) 0)
	#define dprintf1 if (0) ((int (*)(char *, ...)) 0)
	#define dprintf2 if (0) ((int (*)(char *, ...)) 0)
	#define dprintf3 if (0) ((int (*)(char *, ...)) 0)
	#define dprintf4 if (0) ((int (*)(char *, ...)) 0)
#endif


/**  THIS MUST BE LAST LINE OF FILE  **/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\riff.c ===
/*
    riff.c

    This module contains functions which deal with RIFF files

*/

#include <windows.h>
#include <mmsystem.h>
#include "sbtest.h"

BOOL IsRiffWaveFormat(PUCHAR pView)
{
    PRIFFHDR pHdr;

    pHdr = (PRIFFHDR) pView;

    // validate it's a wave file

    if ((pHdr->rifftag != ckidRIFF)
    ||  (pHdr->wavetag != ckidWAVE)) {
        return FALSE;
    }
    return TRUE;
}


PUCHAR FindRiffChunk(PULONG pChunkSize, PUCHAR pView, FOURCC Tag)
{
    PRIFFHDR pHdr;
    PRIFFCHUNKHDR pChHdr;
    FOURCC ChTag;
    ULONG Size;

    pHdr = (PRIFFHDR) pView;
    Size = pHdr->Size;
    pView += sizeof(RIFFHDR); // point to the first chunk
    while (Size) {
        pChHdr = (PRIFFCHUNKHDR) pView;
        ChTag = pChHdr->rifftag;
        if (ChTag == Tag) {
            *pChunkSize = pChHdr->Size;
            return pView + sizeof(RIFFCHUNKHDR);
        }
        pView += pChHdr->Size + sizeof(RIFFCHUNKHDR);
        Size -= (pChHdr->Size + sizeof(RIFFCHUNKHDR));
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\sbtest\wpf.c ===
/*
 * WPF.C
 *
 * WPF line output/input windows.  Taken from the wpf.dll library,
 * originally written by ToddLa.
 *
 * History:
 *  10/02/86    Todd Laney  Created
 *  04/14/87    toddla  Added new function CreateDebugWin
 *  07/08/87    brianc  added iMaxLines parm to CreateDebugWin[dow]
 *  2/90        russellw    moved into Wincom and cleaned up.
 *      10/1/92         robinsp         moved to NT
 *
 * NT conversion
 *      remove the tricks on dereferencing and passing a pointer to
 *      the stack in wvsprintf.  This means we can't do the printf
 *      thing so have to use a macro, sprintf etc which means wpfprintf
 *      must be coded :
 *          wpfprintf(hwnd, lpszFormat, (args))
 *
 */

#include <windows.h>
#include <mmsystem.h>
#include "wincom.h"
#include "sbtest.h"
#include <stdarg.h>

/*
 * This code appears to make use of the fact that a local handle can be
 * double de-referenced to get the actual pointer that the local handle
 * refers to.  This is a somewhat shady practice.. maybe eliminate it?
 *
 */


/*--------------------------------------------------------------------------*\
|                                                                            |
|   g e n e r a l   c o n s t a n t s                                        |
|                                                                            |
\*--------------------------------------------------------------------------*/

#define MAXBUFLEN 200         /* Maximum string length for wprintf */

/*  Macros to manipulate the printf window array of lines.  This array
 *  wraps around, thus the need for the modulo arithmetic
 */
#define FIRST(pTxt) ((pTxt)->iFirst)
#define TOP(pTxt)   (((pTxt)->iFirst + (pTxt)->iTop) % (pTxt)->iMaxLines)
#define LAST(pTxt)  (((pTxt)->iFirst + (pTxt)->iCount-1) % (pTxt)->iMaxLines)
#define INC(pTxt,x) ((x) = ++(x) % (pTxt)->iMaxLines)
#define DEC(pTxt,x) ((x) = --(x) % (pTxt)->iMaxLines)

#define HWinInfo(hwnd)       ((HTXT)GetWindowLong((hwnd),0))
#define LockWinInfo(hwnd)    ((PTXT)LocalLock((HANDLE)HWinInfo(hwnd)))
#define UnlockWinInfo(hwnd)  ((PTXT)LocalUnlock((HANDLE)HWinInfo(hwnd)))

#define VK(vk)  ((vk) | 0x0100)

/*  The pad values used between the edge of the window and the text.
 *  x = 1/2 ave char width, y = 1 pixel
 */
#define OFFSETX (pTxt->Tdx/2)
#define OFFSETY 1
#define VARSIZE 1


#define BOUND(x,min,max) ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))



#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

/*--------------------------------------------------------------------------*\
|                                                                            |
|   g l o b a l   v a r i a b l e s                                          |
|                                        |
\*--------------------------------------------------------------------------*/
#define QUESIZE   128

/*
 *   QUEUE STRUCTURE:   Support queuing of input characters.
 *
 */
typedef struct {
    int     iLen;
    char    ach[QUESIZE];
}   QUE;
typedef QUE        *PQUE; /* pointer to a char que */
typedef PQUE           *HQUE; /* handle (**) to a char que */


/*
 *  WPF WINDOW INSTANCE DATA STRUCTURE
 *
 */
typedef struct {
    int     iLen;
    char    **hText;
}   LINE;

struct TEXT_STRUCT {
    HWND    hwnd;       // Window displaying the text
    WORD    wID;        // window ID code, for WM_COMMAND messages
    BOOL    fScrollSemaphore;
    WORD    wOutputLocation;
    int iFile;
    int iFirst;     // First line in que
    int iCount;     // Number of lines in que
    int iTop;       // Line at top of window
    int iLeft;      // X offset of the window
    int MaxLen;     // length of longest string currently stored.
    int iMaxLines;  // max number of LINEs
    int iRangeH;
    int iRangeV;
    HFONT   hFont;      // Font to draw with
    int Tdx,Tdy;    // Font Size
    HQUE    hQue;
    int nTabs;
    PINT    pTabs;
    LINE    arLines[VARSIZE];   // array of iMaxLines LINEs
};
typedef struct TEXT_STRUCT *PTXT; /* pointer to a text struct */
typedef PTXT           *HTXT; /* Handle (**) to a text struct */

static int  iSem=0;
static BOOL gbRedraw=TRUE;

static HWND   hwndLast = NULL;

/*  External buffer for scratch space  */
char   bufTmp[MAXBUFLEN];        /* intermediate buffer */

static char     szClass[] = "WPFWIN";
static BOOL     fInit = FALSE;

/*--------------------------------------------------------------------------*\
|                                                                            |
|   f u n c t i o n   d e f i n i t i o n s                                  |
|                                                                            |
\*--------------------------------------------------------------------------*/

LONG FAR PASCAL PrintfWndProc(HWND, unsigned, UINT, LONG);

void NEAR PASCAL WpfSetFont(HWND hWnd, HFONT hFont);
void NEAR PASCAL WpfClear(HWND hWnd);
void NEAR PASCAL WpfSetTabs(HWND hwnd, int nTabs, LPINT pTabs);
BOOL NEAR PASCAL WpfGetTabs(HWND hwnd, LPINT pTabs);
void NEAR PASCAL WpfPaint(HWND hwnd, HDC hdc);

void NEAR PASCAL WpfVScroll(HWND hWnd, PTXT pTxt, int n);
void NEAR PASCAL WpfHScroll(HWND hWnd, PTXT pTxt, int n);
int  NEAR PASCAL LinesInWpfWindow(HWND hWnd);
int  NEAR PASCAL CharsInWpfWindow(HWND hWnd);
void NEAR PASCAL WpfMaxLen(PTXT pTxt);
void NEAR PASCAL WpfSetScrollRange(HWND hWnd, BOOL bRedraw);

void NEAR PASCAL NewLine(PTXT pTxt);
int  NEAR PASCAL ChangeLine(PTXT pTxt, int iLine, LPSTR lpch);
int  NEAR PASCAL InsertString(PTXT pTxt,  LPSTR lpstr);

BOOL NEAR PASCAL EnQueChar(HTXT hTxt, WORD vk);
void NEAR PASCAL UpdateCursorPos(PTXT pTxt);

WORD NEAR PASCAL SetOutput(HWND hwnd, UINT wParam, LONG lParam);
WORD NEAR PASCAL GetOutput(HWND hwnd);

BOOL NEAR PASCAL wpfWrtTTY(HWND hWnd, LPSTR sz);

// BOOL FAR PASCAL DbgDestroy(HWND hwnd);

void wpfWrtFile(int fh, LPSTR sz);

/*
 * fSuccess = WpfInit(hInst)
 *
 * Register the WinPrintf window class.
 *
 */
BOOL FAR PASCAL WpfInit(HANDLE hInstance);

#pragma alloc_text(init, WpfInit)

BOOL FAR PASCAL WpfInit(HANDLE hInstance)
{
    WNDCLASS rClass;

    if (!fInit) {
        rClass.hCursor        = LoadCursor(NULL,IDC_ARROW);
        rClass.hIcon          = (HICON)NULL;
        rClass.lpszMenuName   = (LPSTR)NULL;
        rClass.lpszClassName  = szClass;
        rClass.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        rClass.hInstance      = hInstance;
        rClass.style          = CS_GLOBALCLASS;
        rClass.lpfnWndProc    = PrintfWndProc;
        rClass.cbWndExtra     = sizeof (HTXT);
        rClass.cbClsExtra     = 0;

    if (!RegisterClass(&rClass))
        return FALSE;

        fInit++;
    }

    return TRUE;
}





/*
 * @doc EXTERNAL WINCOM WPFWINDOW
 *
 * @api HWND | wpfCreateWindow | This function creates a
 * text output window.  WPF windows allow <f printf> style output
 * and line oriented input.  WPF windows also remember a fixed number of
 * lines of previous output for scrolling back.
 *
 * @parm    HWND | hwndParent | Specifies the parent window.
 *
 * @parm    HANDLE | hInst | Specifies the module instance handle of the
 * DLL owner.  If the parameter is NULL, the module instance handle of
 * the WINCOM DLL is used.
 *
 * @parm    LPSTR | lpszTitle | Points to the window title.  This
 * information is ignored when the style specified by <p dwStyle> does
 * not create a title bar for the window.
 *
 * @parm    DWORD | dwStyle | Specifies the window style flags.  All
 * standard window style flags are valid.  The WPF window class also defines
 * the following additional flags:
 *
 * @flag    WPF_CHARINPUT | The WPF window allows the user to input
 * characters and sends its parent <m WPF_NCHAR> and <m WPF_NTEXT> messages.
 *
 * @parm    WORD | x | Specifies the x position of the window.
 * @parm    WORD | y | Specifies the y position of the window.
 * @parm    WORD | dx | Specifies the width of the window.
 * @parm    WORD | dy | Specifies the height of the window.
 *
 * @parm    int | iMaxLines | Specifies the maximum number of lines that
 * the WPF window remembers for scrolling purposes.  If this
 * parameter is zero, a default value of 100 is supplied.
 *
 * @parm    WORD | wID | Specifies the window ID of the WPF window.  This
 * code is used in WM_COMMAND message to notify the owner of the WPF
 * window when key events have occurred.
 *
 * @rdesc   Returns the window handle of the new WPF window, or NULL if
 * an error occurs.  The returned window handle may be used with the
 * normal Windows window-management APIs.
 *
 * @comm    A WPF window behaves like a partial Windows control.  The
 * owner may change the parameters of a WPF window by sending control
 * messages (including WM_SETFONT, WM_GETFONT, and the WPF messages
 * documented with the WINCOM DLL).  The WPF window notifies its owner
 * of state changes by sending the owner WM_COMMAND messages with a
 * control ID of <p wID>.  WPF windows are not full controls, however,
 * as they cannot be used in dialog boxes.  WPF windows also do not
 * respond to WM_GETTEXT and WM_SETTEXT messages.
 *
 */
HWND FAR PASCAL wpfCreateWindow(HWND hwndParent, HANDLE hInst,LPSTR lpszTitle,
                DWORD dwStyle, WORD x, WORD y,
                WORD dx, WORD dy, int iMaxLines, WORD wID)
{
  HWND   hWnd;

  if (!fInit)
    if (!WpfInit(ghInst))
    /*  Return NULL if the class could not be registered  */
    return NULL;

  if (iMaxLines == 0)
      iMaxLines = 100;

  if (hInst == NULL)
      hInst = ghInst;

  hWnd = CreateWindow((LPSTR)szClass,
            (LPSTR)lpszTitle,
                        dwStyle,
                        x,y,
                        dx,dy,
                        (HWND) hwndParent,
                        (HMENU) NULL,
                        (HANDLE) hInst,
            (LPSTR) MAKELONG(iMaxLines, wID)
                       );

  return hWnd;
}


/*****************************************************
 *
 *      UTILITY PROCEDURES
 *
 *****************************************************/

/*
 * WpfSetFont(hwnd, hfont)
 *
 * Changes the font of a winprintf window to be the specified handle.
 * Rebuilds the internal character size measurements, and causes the
 * window to repaint.
 *
 * Is there a problem with scroll ranges changing here?
 *
 */
void NEAR PASCAL WpfSetFont(HWND hWnd, HFONT hFont)
{
    PTXT       pTxt;
    HDC        hDC;
    TEXTMETRIC tm;

    pTxt = LockWinInfo(hWnd);

    pTxt->hFont = hFont;

    /* Find out the size of a Char in the font */
    hDC = GetDC(hWnd);
    SelectObject(hDC, hFont);
    GetTextMetrics(hDC, (LPTEXTMETRIC) &tm);
    pTxt->Tdy = tm.tmHeight;
    pTxt->Tdx = tm.tmAveCharWidth;
    ReleaseDC (hWnd, hDC);
    InvalidateRect(hWnd, NULL, TRUE);
    UnlockWinInfo(hWnd);
}


/*
 * WpfClear(hwnd)
 *
 * Clears all text from the window.  Frees all allocated memory.  The
 * current queue is not modified?
 *
 */
void NEAR PASCAL WpfClear(HWND hWnd)
{
    int   i,iQue;
    PTXT  pTxt;

    pTxt = LockWinInfo(hWnd);

    iQue = FIRST(pTxt);
    for (i=0; i < pTxt->iCount; i++, INC(pTxt,iQue))
      if (pTxt->arLines[iQue].hText != NULL)
         LocalFree((HANDLE) pTxt->arLines[iQue].hText);

    pTxt->iFirst            = 0;    /* Set the que up to have 1 NULL line */
    pTxt->iCount            = 1;
    pTxt->iTop              = 0;
    pTxt->iLeft             = 0;
    pTxt->MaxLen            = 0;
    pTxt->arLines[0].hText  = NULL;
    pTxt->arLines[0].iLen   = 0;

    UnlockWinInfo(hWnd);

    InvalidateRect(hWnd,NULL,TRUE);
    WpfSetScrollRange(hWnd,TRUE);
    UpdateWindow(hWnd);
}

/*
 * WpfSetTabs(hwnd, nTabs, pTabs)
 *
 * Sets up hwnd to use the tabs stops specified by pTabs.  Copies these
 * tabs into a local-alloc'ed buffer.  Any pre-existing tab stops are
 * deallocated.
 *
 */
void NEAR PASCAL WpfSetTabs(HWND hwnd, int nTabs, LPINT pTabs)
{
    PTXT  pTxt;
    int   i;

    pTxt = LockWinInfo(hwnd);

    /*  Discard old tabs, allocate space for new tab settings  */
    if (pTxt->pTabs)
        LocalFree((HANDLE)pTxt->pTabs);

    if (pTabs == NULL || nTabs == 0) {
    pTxt->pTabs = NULL;
    pTxt->nTabs = 0;
    }
    else {
        pTxt->pTabs = (PINT)LocalAlloc(LPTR, nTabs * sizeof(int));
        pTxt->nTabs = nTabs;

        /*  Copy caller's tab settings into the current tab table  */
        if (pTxt->pTabs) {
            for (i=0; i < nTabs; i++)
                pTxt->pTabs[i] = *pTabs++;
        }
    }

    InvalidateRect(hwnd,NULL,TRUE);
    UnlockWinInfo(hwnd);
}

/*
 * fIsTabs = WpfGetTabs(hwnd, pTabs)
 *
 * Responds to a WPF_GETTABSTOPS message by filling in the supplied
 * buffer with the current tab settings.  Returns TRUE if there are tabs
 * stops, or FALSE if there aren't any tab stops in use.
 *
 */
BOOL NEAR PASCAL WpfGetTabs(HWND hwnd, LPINT pTabs)
{
    PTXT  pTxt;
    int   i;

    pTxt = LockWinInfo(hwnd);

    /*  If there are no current tabs, return FALSE  */
    if (pTxt->nTabs == 0 || pTxt->pTabs == NULL) {
            UnlockWinInfo(hwnd);
        return FALSE;
    }

    /*  Otherwise, copy my tabs into the caller's buffer.  Assume
     *  that the caller's buffer is large enough.
     */
    for (i=0; i < pTxt->nTabs; i++) {
            *pTabs++ = pTxt->pTabs[i];
    }

    UnlockWinInfo(hwnd);
    return TRUE;
}

/***********************************
 *
 *  WINDOW PROCEDURE
 *
 ***********************************/

/*--------------------------------------------------------------------------*\
|   WpfPaint(hWnd, hDC )                                                     |
|                                                                            |
|   Description:                                                             |
|       The paint function.                                                  |
|                                                                            |
|   Arguments:                                                               |
|       hWnd            Window to paint to.                                  |
|       hDC             handle to update region's display context            |
|                                                                            |
|   Returns:                                                                 |
|       nothing                                                              |
|                                                                            |
\*--------------------------------------------------------------------------*/
void NEAR PASCAL WpfPaint(HWND hwnd, HDC hdc)
{
    PTXT   pTxt;
    int    i;
    int    iQue;
    int    xco;
    int    yco;
    int    iLast;
    RECT   rc;
    RECT   rcClip;
    HFONT   hfontOld;

    //LockData(0);    /* need from spy DS not locked! */

    pTxt = LockWinInfo(hwnd);

    GetClientRect(hwnd, &rc);
    rc.left += OFFSETX;
    rc.top  += OFFSETY;
    IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));

    /*  If a font (other than the system font) has been specified, use it  */
    if (pTxt->hFont)
      hfontOld = SelectObject(hdc, pTxt->hFont);

    /*  Setup counters as appropriate.  Get indexes of first and last
     *  lines visible within the window.
     */
    iLast = LAST(pTxt);
    iQue  = TOP(pTxt);
    /*  The x and y initial points for the text line.
     *  xco is shifted left to account for any horizonal scrolling
     *  that may be going on
     */
    xco   = OFFSETX - pTxt->iLeft * pTxt->Tdx;  // shifted for h-scrolling
    yco   = OFFSETY;        // starting y pix value

    /*  RC is the bounding rect for the current line.
     *
     *  Calc initial line bounding rect.. top = top of window (padded),
     *  bottom = top + height of one line.
     */
    rc.left   = xco;
    rc.top    = yco;
    rc.bottom = yco + pTxt->Tdy;

    /*  Get the clipping rectangle  */
    GetClipBox(hdc, &rcClip);

    /*  Iter over all lines that are visible - if the bounding rect
     *  for the current line intersects the clip rect, draw the line.
     */
    for (;;) {
        if (rc.bottom >= rcClip.top) {
        /*  If we're using tabs, then tab out the text.
         */
            char *pStr;
            pStr = LocalLock(pTxt->arLines[iQue].hText);
            if (pTxt->nTabs > 0) {
        /*  Erase the background  */
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

        /*  Using *pTxt->arLines[iQue].hText returns the local
         *  string that is refered to by local handle hText.
         */
                TabbedTextOut(hdc, xco, yco,
                        (LPSTR)pStr,
            pTxt->arLines[iQue].iLen,
            pTxt->nTabs, pTxt->pTabs, xco);
            }
            else {
        /*  Otherwise, blow it out using ExtTextOut  */
                ExtTextOut(hdc, xco, yco, ETO_OPAQUE, &rc,
                   (LPSTR)pStr,
                   pTxt->arLines[iQue].iLen, NULL);
            }
            LocalUnlock(pTxt->arLines[iQue].hText);
    }

    /*  Bail out when finished printing window contents  */
    if (iQue == iLast)
        break;

    INC(pTxt, iQue);
    /*  Advance the boundry rect & char positions down one line  */
    yco = rc.top = rc.bottom;
    rc.bottom += pTxt->Tdy;

    if (yco > rcClip.bottom)
         break;
    }

    /*  Restore the old font  */
    if (hfontOld)
        SelectObject(hdc, hfontOld);

    // UnlockData(0);
}




LONG FAR PASCAL PrintfWndProc(HWND hWnd, unsigned uiMessage,
                UINT wParam, LONG lParam)
{
    PAINTSTRUCT rPS;
    PTXT    pTxt;
    HTXT    hTxt;
    int     i;
    int     iQue;
    DWORD   rc = 0L;

    hTxt  = (HTXT)GetWindowLong(hWnd,0);
    if (hTxt) pTxt  = LocalLock(hTxt);

    #define lpCreate ((LPCREATESTRUCT)lParam)

    switch (uiMessage) {
    case WM_CREATE:
            i = LOWORD((DWORD)lpCreate->lpCreateParams);

        /*  Allocate and initialize the window instance structure
         *  The storage for the current lines is placed at the end
         *  end of the instance data structure. allocate room for it.
         */
        hTxt = (HTXT) LocalAlloc(LHND, sizeof(struct TEXT_STRUCT) +
                    (i - VARSIZE) * sizeof(LINE));

        if (!hTxt)
        return -1L;

            pTxt = (PTXT)LocalLock((HANDLE)hTxt);

        pTxt->hwnd          = hWnd;
        pTxt->wID       = HIWORD(lpCreate->lpCreateParams);
        pTxt->iFile     = -1;
        pTxt->wOutputLocation = WPFOUT_WINDOW;
        pTxt->iFirst        = 0;    // initially 1 null line
        pTxt->iCount        = 1;
        pTxt->iTop          = 0;
        pTxt->iLeft         = 0;    // no initial hscroll offset
        pTxt->MaxLen        = 0;
        pTxt->iMaxLines     = i;
        pTxt->nTabs         = 0;
        /*  If user specified character input, allocate a buffer  */
        if (lpCreate->style & WPF_CHARINPUT)
        pTxt->hQue      = (HQUE) LocalAlloc(LHND | LMEM_ZEROINIT,
                            sizeof(QUE));
        else
        pTxt->hQue      = NULL;

        /*  Null initial first line  */
        pTxt->arLines[0].hText  = NULL;
        pTxt->arLines[0].iLen   = 0;

        /*  Store the structure pointer onto the window  */
        SetWindowLong(hWnd, 0, (LONG) hTxt);

        /*  Setup to use the system font by default  */
            WpfSetFont(hWnd, GetStockObject(SYSTEM_FONT));

        LocalUnlock((HANDLE) hTxt);
        return 0L;

        case WM_DESTROY:
            // DbgDestroy(hWnd);

        /*  Flush any files in use by the window  */
        SetOutput(hWnd, WPFOUT_DISABLED, 0L);

        /*  Blow away all lines held by the window  */
        iQue = FIRST(pTxt);
        for (i=0; i < pTxt->iCount; i++, INC(pTxt,iQue))
          if (pTxt->arLines[iQue].hText != NULL)
         LocalFree((HANDLE) pTxt->arLines[iQue].hText);

        /*  And kill char input and tab stop storage  */
        if (pTxt->hQue)
        LocalFree ((HANDLE) pTxt->hQue);
            if (pTxt->pTabs)
                LocalFree ((HANDLE) pTxt->pTabs);

        LocalUnlock(hTxt);
        LocalFree((HANDLE)hTxt);
        hTxt = NULL;
            break;

//  case WPF_SETNLINES:
//      return 0L;

        case WPF_GETNLINES:
            rc = pTxt->iMaxLines;
            break;

        case WM_GETFONT:
            rc = pTxt->hFont;
            break;

        case WM_SETFONT:
            WpfSetFont(hWnd, wParam);
            break;

    /*  Tab stop stuff  */
        case WPF_SETTABSTOPS:
            WpfSetTabs(hWnd, wParam, (LPINT) lParam);
            break;

    case WPF_GETNUMTABS:
            rc = pTxt->pTabs ? pTxt->nTabs : 0;
            break;

    case WPF_GETTABSTOPS:
        rc = (LONG) WpfGetTabs(hWnd, (LPINT) lParam);
                break;

    case WPF_SETOUTPUT:
        rc = (LONG) SetOutput(hWnd, wParam, lParam);
                break;

    case WPF_GETOUTPUT:
        rc = (LONG) GetOutput(hWnd);
                break;

    case WPF_CLEARWINDOW:
        WpfClear(hWnd);
                break;

    case WM_SIZE:
        /*  It is possible to get WM_SIZEs as a result of
         *  dicking with scrollbars..  Avoid race conditions
         */
        if (!pTxt->fScrollSemaphore) {
           pTxt->fScrollSemaphore++;
               WpfSetScrollRange(hWnd, TRUE);
           UpdateCursorPos(pTxt);
           pTxt->fScrollSemaphore--;
        }
        break;

        case WM_VSCROLL:
            switch (wParam) {
               case SB_LINEDOWN:
                  WpfVScroll (hWnd,pTxt,1);
                  break;
               case SB_LINEUP:
                  WpfVScroll (hWnd,pTxt,-1);
                  break;
               case SB_PAGEUP:
                  WpfVScroll (hWnd,pTxt,-LinesInWpfWindow(hWnd));
                  break;
               case SB_PAGEDOWN:
                  WpfVScroll (hWnd,pTxt,LinesInWpfWindow(hWnd));
                  break;
               case SB_THUMBTRACK:
                  WpfVScroll (hWnd,pTxt,LOWORD(lParam)-pTxt->iTop);
                  break;

               case SB_THUMBPOSITION:
                  WpfVScroll (hWnd,pTxt,LOWORD(lParam)-pTxt->iTop);
          /*  Fall through  */

               case SB_ENDSCROLL:
                  WpfSetScrollRange(hWnd,TRUE);
                  UpdateCursorPos(pTxt);
                  break;
            }
            break;

        case WM_HSCROLL:
            switch (wParam) {
               case SB_LINEDOWN:
                  WpfHScroll (hWnd, pTxt, 1);
                  break;
               case SB_LINEUP:
                  WpfHScroll (hWnd, pTxt, -1);
                  break;
               case SB_PAGEUP:
                  WpfHScroll (hWnd, pTxt, -CharsInWpfWindow(hWnd));
                  break;
               case SB_PAGEDOWN:
                  WpfHScroll (hWnd, pTxt, CharsInWpfWindow(hWnd));
                  break;
               case SB_THUMBTRACK:
                  WpfHScroll (hWnd, pTxt, LOWORD(lParam) - pTxt->iLeft);
                  break;

               case SB_THUMBPOSITION:
                  WpfHScroll (hWnd, pTxt, LOWORD(lParam) - pTxt->iLeft);
          /*  Fall through  */

               case SB_ENDSCROLL:
                  WpfSetScrollRange(hWnd,TRUE);
                  UpdateCursorPos(pTxt);
                  break;
            }
            break;

    case WM_PAINT:
        BeginPaint(hWnd,&rPS);
            WpfPaint (hWnd,rPS.hdc);
        EndPaint(hWnd,&rPS);
        break;

    /*  Allow keyboard scrolling  */
    case WM_KEYDOWN:
        switch (wParam) {
           case VK_UP:
               PostMessage (hWnd,WM_VSCROLL,SB_LINEUP,0L);   break;
           case VK_DOWN:
               PostMessage (hWnd,WM_VSCROLL,SB_LINEDOWN,0L); break;
           case VK_PRIOR:
               PostMessage (hWnd,WM_VSCROLL,SB_PAGEUP,0L);   break;
           case VK_NEXT:
               PostMessage (hWnd,WM_VSCROLL,SB_PAGEDOWN,0L); break;

           case VK_HOME:
               PostMessage (hWnd,WM_HSCROLL,SB_PAGEUP,0L);   break;
           case VK_END:
               PostMessage (hWnd,WM_HSCROLL,SB_PAGEDOWN,0L); break;
           case VK_LEFT:
               PostMessage (hWnd,WM_HSCROLL,SB_LINEUP,0L);   break;
           case VK_RIGHT:
               PostMessage (hWnd,WM_HSCROLL,SB_LINEDOWN,0L); break;
        }
        break;

    /*  Handle focus messages to hide and show the caret
     *  if the WPF window allows for character input.
     */
    case WM_SETFOCUS:
        if (pTxt->hQue) {
        CreateCaret(hWnd,0,1,pTxt->Tdy);
        UpdateCursorPos(pTxt);
        ShowCaret(hWnd);
        }
        break;

    case WM_KILLFOCUS:
        if (pTxt->hQue)
        DestroyCaret();
        break;

    case WM_CHAR:
            EnQueChar(hTxt,wParam);
        break;

    case WM_KEYUP:
        switch (wParam) {
           case VK_F3:
                  EnQueChar(hTxt,VK(wParam));
          break;

        /*  Send endscroll when the key goes up - allows for
         *  type-a-matic action.
         */
           case VK_UP:
           case VK_DOWN:
           case VK_PRIOR:
           case VK_NEXT:
          PostMessage (hWnd,WM_VSCROLL,SB_ENDSCROLL,0L);
          break;

           case VK_HOME:
           case VK_END:
           case VK_LEFT:
           case VK_RIGHT:
          PostMessage (hWnd,WM_HSCROLL,SB_ENDSCROLL,0L);
          break;
        }
        break;

    default:
           return DefWindowProc(hWnd,uiMessage,wParam,lParam);
    }

    if (hTxt) LocalUnlock(hTxt);
    return rc;
}


/***********************************************
 *
 *      SCROLLING STUFF
 *
 ***********************************************/

/*
 * WpfVScroll(hwnd, pTxt, n)
 *
 * Vertical scroll the window by n number of lines.
 *
 */
void NEAR PASCAL WpfVScroll(HWND hWnd, PTXT pTxt, int n)
{
    RECT rect;
    int  iRange;

    /* GetScrollRange (hWnd,SB_VERT,&iMinPos,&iMaxPos); */
    iRange = pTxt->iRangeV;     // where did this come from?
    GetClientRect(hWnd, &rect);
    rect.left += OFFSETX;       // adjust for pad boundry
    rect.top  += OFFSETY;

    n = BOUND(pTxt->iTop + n, 0, iRange) - pTxt->iTop;
    pTxt->iTop += n;
    ScrollWindow(hWnd, 0, -n * pTxt->Tdy, &rect, &rect);
    SetScrollPos(hWnd, SB_VERT, pTxt->iTop, gbRedraw);
    UpdateWindow(hWnd);
}


/*
 * WpfHScroll(hwnd, ptxt, n)
 *
 * Horizontally scrolls the window by n number of character widths.
 *
 */
void NEAR PASCAL WpfHScroll(HWND hWnd, PTXT pTxt, int n)
{
    RECT rect;
    int  iRange;

    /* GetScrollRange (hWnd,SB_HORZ,&iMinPos,&iMaxPos); */
    iRange = pTxt->iRangeH;
    GetClientRect (hWnd,&rect);
    rect.left += OFFSETX;
    rect.top  += OFFSETY;

    n = BOUND(pTxt->iLeft + n, 0, iRange) - pTxt->iLeft;
    pTxt->iLeft += n;
    ScrollWindow(hWnd, -n * pTxt->Tdx, 0, &rect, &rect);
    SetScrollPos(hWnd, SB_HORZ, pTxt->iLeft, gbRedraw);
    UpdateWindow(hWnd);
}


/*
 * nLines = LinesInWpfWindow(hwnd)
 *
 * Returns the height in lines of the window.
 *
 */
int NEAR PASCAL LinesInWpfWindow(HWND hWnd)
{
    RECT rRect;
    PTXT pTxt;
    int  iLines;

    pTxt = *(HTXT) GetWindowLong(hWnd, 0);
    GetClientRect(hWnd, &rRect);
    iLines = 0;
    if (pTxt) {
       iLines = (rRect.bottom - rRect.top - OFFSETY) / pTxt->Tdy;
       iLines = min(iLines, pTxt->iMaxLines);
    }
    return iLines;
}


/*
 * nChars = CharsInWpfWindow(hwnd)
 *
 * Returns the width in characters of the window.
 *
 */
int NEAR PASCAL CharsInWpfWindow(HWND hWnd)
{
    RECT rRect;
    PTXT pTxt;

    pTxt = *(HTXT)GetWindowLong (hWnd,0);
    GetClientRect(hWnd,&rRect);
    return pTxt ? (rRect.right - rRect.left - OFFSETX) / pTxt->Tdx : 0;
}




/*
 * WpfMaxLen(pTxt)
 *
 * This function sets the pTxt->MaxLen field to be the length in
 * characters of the longest string currently being stored by the WPF
 * window.
 *
 */
void NEAR PASCAL WpfMaxLen(PTXT pTxt)
{
    int    iQue;
    int    iLast;
    int    iLen;
    SIZE   size;
//    DWORD  dwLen;
//    HDC    hdc;

#if 0
    hdc = GetDC(NULL);

    if (pTxt->hFont)
    SelectObject(hdc, pTxt->hFont);
#endif

    iLast = LAST(pTxt);
    iQue  = TOP(pTxt);
    pTxt->MaxLen = 0;
    for (;;) {
    iLen = pTxt->arLines[iQue].iLen;

#if 0
        if (pTxt->nTabs)
      dwLen = GetTabbedTextExtent(hdc, (LPSTR) *pTxt->arLines[iQue].hText,
                  iLen, pTxt->nTabs, (LPINT)pTxt->pTabs);
        else
      GetTextExtent(hdc, (LPSTR) *pTxt->arLines[iQue].hText,iLen,&size);

    iLen = size.cx // pTxt->Tdx + 1;
#endif

    if (iLen > pTxt->MaxLen)
        pTxt->MaxLen = iLen;
    if (iQue == iLast) break;
    INC(pTxt,iQue);
    }

//    ReleaseDC(NULL,hdc);

}



/*
 * WpfSetScrollRange(hwnd, bRedraw)
 *
 * This function sets the scrollbar ranges according to the current
 * character/line contents of the window.  Both the horizontal and
 * vertical scrollbars are adjusted.
 *
 * This function then calls WpfVScroll/WpfHScroll to adjust the
 * scrollbar position accordingly.
 *
 */
void NEAR PASCAL WpfSetScrollRange(HWND hWnd, BOOL bRedraw)
{
    PTXT pTxt;
    int  iRange;

    if (pTxt = *(HTXT) GetWindowLong(hWnd, 0)) {
    gbRedraw = bRedraw;
    /* Update the scroll bars */

        iRange = pTxt->iCount - LinesInWpfWindow(hWnd) + 1;

    /*  Adjust for blank last line?  */
    if (pTxt->arLines[LAST(pTxt)].iLen == 0);
        iRange -= 1;

    if (iRange < 0) iRange = 0;

    /*  Set the scrollbar range to that calculated  */
    pTxt->iRangeV = iRange;
    SetScrollRange(hWnd, SB_VERT, 0, iRange, FALSE);
        WpfVScroll(hWnd, pTxt, 0);

    /*  Setup the horizontal scrollbar range  */
    WpfMaxLen(pTxt);
        iRange = pTxt->MaxLen - CharsInWpfWindow(hWnd) + 1;
    if (iRange < 0) iRange = 0;
    pTxt->iRangeH = iRange;
    SetScrollRange(hWnd, SB_HORZ, 0, iRange, FALSE);
        WpfHScroll(hWnd, pTxt, 0);

    gbRedraw = TRUE;
    }
}



/***********************************************************
 *
 *      STUFF TO ADD NEW TEXT LINES
 *
 ***********************************************************/

/*
 * NewLine(pTxt)
 *
 * Adjusts a WPF window when adding a line to the circular array.
 * iCount is the count of valid lines in the array.  If we
 * haven't yet filled up the array, the count is merely increased.
 * Otherwise, if the array is full and we're about to wrap around, fixup
 * the wrap-around.
 *
 */
void NEAR PASCAL NewLine(PTXT pTxt)
{
    int iLast = LAST(pTxt);
    int iLine,cLine;
    RECT rect;

    if (pTxt->iCount == pTxt->iMaxLines) {
    /*  If the array is full, check for wrap-around  */
       LocalFree ((HANDLE)pTxt->arLines[pTxt->iFirst].hText);
       pTxt->arLines[pTxt->iFirst].hText = NULL;

       INC(pTxt, pTxt->iFirst);

       if (pTxt->iTop > 0)
      pTxt->iTop--;
       else {
      GetClientRect (pTxt->hwnd,&rect);
      rect.left += OFFSETX;
      rect.top  += OFFSETY;
      ScrollWindow (pTxt->hwnd, 0, -pTxt->Tdy, &rect, &rect);
       }
    }
    else {
       pTxt->iCount++;
    }
    iLast = LAST(pTxt);
    pTxt->arLines[iLast].hText = NULL;
    pTxt->arLines[iLast].iLen  = 0;
}



/*
 * fSuccess = ChangeLine(pTxt, iLine, lpsz)
 *
 * Changes line number <iLine> to be the string pointed to by lpsz.
 * Frees any line currently occupying index <iLine>, and then alloc and
 * stores text lpsz.
 *
 */
int NEAR PASCAL ChangeLine(PTXT pTxt, int iLine, LPSTR lpch)
{
    int iLen;
    LPSTR pData;

    if (pTxt->arLines[iLine].hText != NULL)
       LocalFree((HANDLE)pTxt->arLines[iLine].hText);

    iLen = lstrlen(lpch);
    if ((pTxt->arLines[iLine].hText = (char**)LocalAlloc(LHND,iLen+1))== NULL)
        return FALSE;

    pTxt->arLines[iLine].iLen = iLen;
    pData = LocalLock(pTxt->arLines[iLine].hText);
    lstrcpy(pData, lpch);
    LocalUnlock(pTxt->arLines[iLine].hText);
    return TRUE;
}


/*



 */
int NEAR PASCAL InsertString(PTXT pTxt, LPSTR lpstr)
{
    int    iBuf;
    int    iLast = LAST(pTxt);
    int    cLine = 0;
    char   buf[MAXBUFLEN];
    buf[0] = '\0';

    /*
     *  copy the string already there
     */
    {
        PSTR pch;
        HANDLE hText;

        hText = pTxt->arLines[iLast].hText;
        if (hText) {
            pch  = LocalLock(hText);  // (LocalLock eqiv)
            iBuf = lstrlen(pch);
            lstrcpy(buf, pch);      // why?
            LocalUnlock(pTxt->arLines[iLast].hText);
        } else {
            iBuf = 0;
        }
    }

    while (*lpstr != '\0') {
    while (*lpstr != '\n' && *lpstr != '\0' && iBuf < MAXBUFLEN-2)
        switch (*lpstr) {

        case '\b':
        /*  Backspace, blow away one character  */
        iBuf--;
        lpstr++;
        break;

        case '\r':
        /*  Carriage return, go back to beginning of line  */
        iBuf = 0;
        lpstr++;
        break;

        default:
        /*  Otherwise, add this char to line  */
                buf[iBuf++] = *lpstr++;
        break;
        }
        buf[iBuf++] = 0;

    /*  Presto chango add the line  */
        ChangeLine(pTxt, iLast, buf);  /* buf must be a asciiz string */

    if (*lpstr == '\n') {   /* Now do the next string after the \n */
        lpstr++;
        iBuf = 0;
        cLine++;
        NewLine(pTxt);
        INC(pTxt, iLast);
    }
    }
    return cLine;   /* the number of new lines added to list */
}


/**********************************************************
 *
 *      CHARACTER INPUT STUFF
 *
 **********************************************************/


BOOL NEAR PASCAL EnQueChar(HTXT hTxt, WORD vk)
{
    PTXT pTxt;
    PQUE pQue;
    int  i;
    HWND hwndP;

    pTxt = (PTXT)LocalLock((HANDLE)hTxt);

    if (!pTxt->hQue)
        goto noque;

    pQue = (PQUE)LocalLock((HANDLE)pTxt->hQue);

    i = pQue->iLen;

    switch (vk)
    {
    case '\b':
    if (i > 0)
    {
           --i;
       wpfOut(pTxt->hwnd, "\b");
    }
        break;

    case VK(VK_F3):
        wpfOut(pTxt->hwnd, pQue->ach + i);
        i += lstrlen(pQue->ach + i);
        break;

    case '\r':
    case '\n':
    if (GetKeyState(VK_CONTROL) < 0)
    {
        wpfOut(pTxt->hwnd,"\\\n");
    }
    else
    {
            wpfOut(pTxt->hwnd, "\n");
            pQue->ach[i] = '\0';
        if (hwndP = GetParent(pTxt->hwnd))
           SendMessage(hwndP, WPF_NTEXT, pTxt->wID,
                   (LONG)(LPSTR)pQue->ach);
        i = 0;
    }
    break;

    default:
    if (i < QUESIZE)
    {
        pQue->ach[i]   = (char)vk;
        sprintf(ach, ("%c", vk));
        wpfOut(pTxt->hwnd, ach);
        if (hwndP = GetParent(pTxt->hwnd))
        SendMessage(hwndP, WPF_NCHAR, pTxt->wID, (LONG) vk);
        i++;
    }
    else
    {
            /*  Input que is full, beep to notify  */
        MessageBeep(0);
    }
    break;
    }

    pQue->iLen = i;
    LocalUnlock((HANDLE)pTxt->hQue);

noque:
    LocalUnlock((HANDLE)hTxt);
    return TRUE;
}



void NEAR PASCAL UpdateCursorPos(PTXT pTxt)
{
    int    iLine;
    int    y,x;
    int    iLen;
    DWORD  dw;
    HDC    hdc;
    SIZE   size;
    char   **h;
    char   *ptxt;

    /*  If I don't do char input, or don't have the focus, forget it  */
    if (!pTxt->hQue || GetFocus() != pTxt->hwnd)
    return;

    hdc   = GetDC(NULL);
    SelectObject(hdc, pTxt->hFont);
    iLen  = pTxt->arLines[LAST(pTxt)].iLen - pTxt->iLeft;
    h     = pTxt->arLines[LAST(pTxt)].hText;

    //  HACK HACK Need to account for tabs?
    ptxt = LocalLock(h);
    dw    = GetTextExtentPoint(hdc, (LPSTR) ptxt + pTxt->iLeft, iLen, &size);
    LocalUnlock(h);
    iLine = pTxt->iCount - pTxt->iTop;
    ReleaseDC(NULL,hdc);

    y = OFFSETY + (iLine - 1) * pTxt->Tdy;
    x = OFFSETX + size.cx;
    SetCaretPos(x,y);
}


/*************************************************
 *
 *      OUTPUT APIS
 *
 *************************************************/



/*
 * fSuccess = SetOutput(hwnd, wCommand, lpszFile)
 *
 * Changes the output location of the window to be the location
 * designated by wParam, one of the WPFOUT_ codes.  If this specifies a
 * file, lParam points to the filename.
 *
 * If the new output location cannot be opened/used, the previous output
 * location is not altered and FALSE is returned.  Otherwise, the
 * previous output location is closed (for files) and TRUE is returned.
 *
 */
WORD NEAR PASCAL SetOutput(HWND hwnd, UINT wParam, LONG lParam)
{
  PTXT  pTxt;
  int   i;
  HANDLE    h;
  int   fhOld = -1;

  #define COM1_FH   (3)     // stdaux

  /*  Check for invalid command code  */
  if (!(wParam == WPFOUT_WINDOW || wParam == WPFOUT_COM1 ||
    wParam == WPFOUT_NEWFILE || wParam == WPFOUT_APPENDFILE ||
    wParam == WPFOUT_DISABLED)) {
      return FALSE;
  }

  h = GetWindowLong(hwnd, 0);
  pTxt = (PTXT)LocalLock(h);

  /*  Save the old file handle  */
  fhOld = pTxt->iFile;

  /*  If I'm using a file output type, setup the file handle  */
  switch (wParam) {
    case WPFOUT_COM1:
    pTxt->iFile = COM1_FH;
    break;

    case WPFOUT_APPENDFILE:
    /*  Open file to see if it is there, then seek to end  */
    i = _lopen((LPSTR) lParam, OF_READWRITE);
    if (i == -1) {
        /*  File didn't exist, just create it  */
        i = _lcreat((LPSTR) lParam, 0);
        if (i == -1) {
            /*  Couldn't open, just return FALSE  */
            LocalUnlock(h);
            return FALSE;
        }
    }
    else {
        /*  Seek to the end of existing file  */
        _llseek(i, 0L, 2);
    }

    pTxt->iFile = i;
    break;

    case WPFOUT_NEWFILE:
    i = _lcreat((LPSTR) lParam, 0);
    if (i == -1) {
        LocalUnlock(h);
        return FALSE;
    }
    pTxt->iFile = i;
    break;

    case WPFOUT_DISABLED:
    case WPFOUT_WINDOW:
    pTxt->iFile = -1;
    break;

  }

  /*  Clear any existing open file handle by closing it  */
  if (fhOld != -1 && fhOld != COM1_FH) {
    /*  Close the file  */
    _lclose(fhOld);
  }

  pTxt->wOutputLocation = wParam;
  LocalUnlock(h);
  return TRUE;

}



/*
 * wOutput = GetOutput(hwnd)
 *
 * Returns the output location for window hwnd (one of the WPFOUT_ codes)
 *
 */
WORD NEAR PASCAL GetOutput(HWND hwnd)
{
  PTXT  pTxt;
  WORD  w;
  HANDLE    h;

  h = GetWindowLong(hwnd, 0);
  pTxt = (PTXT) LocalLock(h);

  w = pTxt->wOutputLocation;

  LocalUnlock(h);
  return w;
}

/*
 * @doc EXTERNAL WINCOM WPFWINDOW
 *
 * @api int | wpfPrintf | This function prints a string to a WPF window
 * (or redirected output device) using <f printf> style formatting
 * codes.  The output is placed at the end of the specified WPF window,
 * which is scrolled as required.  This function does not yield.
 *
 * @parm    HWND | hwnd | Specifies the WPF window.  Output to the window
 * may be redirected to a file or COM1 by sending a WPF_SETOUTPUT window
 * message to <p hwnd>.  If output has been redirected, this parameter
 * is still required as the current output location is stored in the WPF
 * window instance data.
 *
 * @parm    LPSTR | lpszFormat | Points to the output string format
 * specification.  This string uses the same formatting codes as the
 * Windows <f wsprintf> function.
 *
 * @parm    argument | [ arguments, ...] | Extra parameters
 * as required by the
 * formatting string.  Note that these parameters are in the form
 * required by <p wsprintf>, so that all string arguments must be far
 * pointers (LPSTR) or be cast to be far pointers.
 *
 * @rdesc   Returns the number of characters output.  If output to
 * the WPF window is disabled, zero is returned.  The returned count of
 * characters output does not include the translation of newline
 * characters into carriage return newline sequences.
 *
 * @xref    wpfVprintf
 *
 */
//int FAR cdecl wpfPrintf(HWND hwnd, LPSTR lpszFormat, ...)
//{
//  return wpfVprintf(hwnd, lpszFormat, (LPSTR)(&lpszFormat + 1));
//}


/* wpfWrtTTY(hWnd, sz)
 *
 * Print <sz> to wprintf window <hWnd>.
 *
 */
BOOL NEAR PASCAL wpfWrtTTY(HWND hWnd, LPSTR sz)
{
    RECT  rect;
    int   iFree;
    int   iLine;
    PTXT  pTxt;
    HTXT  hTxt;
    MSG   rMsg;
    POINT rPoint;

    if (!hWnd) hWnd = hwndLast;

    if (!hWnd || !IsWindow(hWnd))
    return FALSE;  /* fail if bad window handle */

    hwndLast = hWnd;

    hTxt = (HTXT)GetWindowLong (hWnd,0);
    pTxt = (PTXT)LocalLock((HANDLE)hTxt);

    iLine   = pTxt->iCount - pTxt->iTop;
    /*
     *  invalidate the last line to the bottom of window so
     *  new text will be painted.
     */
    GetClientRect(hWnd,&rect);
    rect.top += (iLine-1) * pTxt->Tdy;
    InvalidateRect (hWnd,&rect,FALSE);

    InsertString (pTxt, sz);  /* Insert text in the que */
    iLine = (pTxt->iCount - pTxt->iTop) - iLine;

    if (iLine > 0) {
        WpfSetScrollRange (hWnd,FALSE);
        WpfVScroll (hWnd,pTxt,pTxt->iCount);/* scroll all the way to bottom */
    }
#if 0
    else {
        WpfSetScrollRange (hWnd,TRUE);
    }
#endif
    UpdateCursorPos(pTxt);
    LocalUnlock((HANDLE)hTxt);
    UpdateWindow (hWnd);

    return TRUE;
}


/*
 * @doc EXTERNAL WINCOM WPFWINDOW
 *
 * @api int | wpfVprintf | This function prints a string to a WPF window
 * (or redirected output device) using <f printf> style formatting
 * codes.  This function is the same as the <f wpfOut> function, except
 * that arguments to the format string are placed in an array of WORDs
 * or DWORDs.
 *
 * @parm    HWND | hwnd | Specifies the WPF window.  Output to the window
 * may be redirected to a file or COM1 by sending a WPF_SETOUTPUT window
 * message to <p hwnd>.  If output has been redirected, this parameter
 * is still required as the current output location is stored in the WPF
 * window instance data.
 *
 * @parm    LPSTR | lpszFormat | Points to the output string format
 * specification.  This string uses the same formatting codes as the
 * Windows <f wsprintf> function.
 *
 * @parm    LPSTR | pargs | Points to an array of words, each of which
 * specifies an argument for the format string <p lspzFormat>.  The
 * number, type, and interpretation of the arguments depend on the
 * corresponding format control sequences in <p lpszFormat>.
 *
 * @rdesc   Returns the number of characters output.  If output to the
 * WPF window is disabled, zero is returned.  The returned count of
 * characters output does not include the translation of newline
 * characters into carriage return newline sequences.
 *
 * @xref    wpfPrintf
 *
 */
//int FAR cdecl wpfVprintf(HWND hwnd, LPSTR lpszFormat, LPSTR pargs)
//{
//  int   i;
//
//
//  i = wvsprintf(bufTmp, lpszFormat, pargs);
//  wpfOut(hwnd, bufTmp);
//
//  return i;
//}

/*
 * @doc WINCOM EXTERNAL WPFWINDOW
 *
 * @api void | wpfOut | This function prints a string to a WPF window
 * or redirected output device.  No formatting is carried out upon the
 * string, it is printed verbatim.
 *
 * @parm    HWND | hwnd | Specifies the WPF window.  Output to the window
 * may be redirected to a file or COM1 by sending a WPF_SETOUTPUT window
 * message to <p hwnd>.  If output has been redirected, this parameter
 * is still required as the current output location is stored in the WPF
 * window instance data.
 *
 * @parm    LPSTR | lpsz | Points to the string to be output.
 *
 * @rdesc   None.
 *
 * @xref    wpfPrintf
 *
 */
void FAR PASCAL wpfOut(HWND hwnd, LPSTR lpsz)
{
  PTXT  pTxt;
  HTXT  hTxt;

  if (!IsWindow(hwnd))
    return;

  hTxt = (HTXT) GetWindowLong(hwnd, 0);
  pTxt = (PTXT) LocalLock((HANDLE) hTxt);

  if (pTxt->wOutputLocation != WPFOUT_DISABLED) {
    if (pTxt->wOutputLocation == WPFOUT_WINDOW) {
          wpfWrtTTY(hwnd, lpsz);
    }
    else {
          wpfWrtFile(pTxt->iFile, lpsz);
    }
  }

  LocalUnlock((HANDLE) hTxt);
}


void wpfWrtFile(int fh, LPSTR sz)
{
    LPSTR p, q;
    char save;

    if (fh == -1)
        return;

    /* output to <fh>, but must convert \n's to \n\r's;
     * code below is designed to minimize calls to write()
     */
    for (p = q = sz; *p != 0; p++) {
            /* e.g. bufTmp="hello\nabc", q->'h', p->'\n' */
            if (*p == '\n') {
                    /* hack: temporarily replace next char by \r */
                    /* won't work if string is READ-ONLY!!! */
                    save = *++p;            /* remember it */
                    p[0] = '\n';              /* replace by \r */
                    p[-1]= '\r';              /* replace by \r */
                    _lwrite(fh, q, p - q + 1);
                    q = p;                  /* for next write() */
                    *p-- = save;            /* un-hack */
                    *p   = '\n';
            }
    }
    if (p > q)              /* any part of <bufTmp> left to write */
            _lwrite(fh, q, p - q);

    //
    // flush the file, by closing a copy of the file
    //
    FlushFileBuffers(fh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\timetest\about.c ===
/*----------------------------------------------------------------------------*\
|                                                                              |
|   about.c - About Dialog Proc Handler for Timer Device Driver Test App       |
|                                                                              |
|                                                                              |
|   History:                                                                   |
|	Created     Glenn Steffler (w-GlennS) 29-Jan-1990		       |
|                                                                              |
\*----------------------------------------------------------)-----------------*/

/*----------------------------------------------------------------------------*\
|                                                                              |
|   i n c l u d e   f i l e s                                                  |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <port1632.h>
#include <stdio.h>
#include <string.h>
#include "ta.h"

/*----------------------------------------------------------------------------*\
|                                                                              |
|   g l o b a l   v a r i a b l e s                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/


/*----------------------------------------------------------------------------*\
|   fnAboutDlg( hDlg, uiMessage, wParam, lParam )			       |
|									       |
|   Description:							       |
|	This function handles messages belonging to the "About" dialog box.    |
|	The only message that it looks for is WM_COMMAND, indicating the use   |
|	has pressed the "OK" button.  When this happens, it takes down	       |
|	the dialog box. 						       |
|									       |
|   Arguments:								       |
|	hDlg		window handle of about dialog window		       |
|	uiMessage	message number					       |
|	wParam		message-dependent				       |
|	lParam		message-dependent				       |
|									       |
|   Returns:								       |
|	TRUE if message has been processed, else FALSE			       |
|									       |
\*----------------------------------------------------------------------------*/
BOOL FAR PASCAL
fnAboutDlg( HWND hDlg, unsigned uiMessage, UINT wParam, LONG lParam )
{
    #define ptCurrent	    ((POINT)lParam)
    RECT    rcDlg,rcButton,rcNew;
    HWND    hwndButton;

    switch( uiMessage ) {
    case WM_COMMAND:
	if( wParam == IDOK )
	    EndDialog(hDlg,TRUE);
	break;

#ifdef THISCOULDNEVERBEDEFINED
    case WM_MOUSEMOVE:
	if( wParam & MK_CONTROL == 0 ) {
	    GetClientRect( hDlg, &rc );
	    hwndButton = GetDlgItem(hDlg,ID_BUTTON);
	    GetWindowRect( hwndButton, &rcButton);
	    rcNew.top = min( 0,
	    GetWindowPos(



	}
	break;

    case WM_NCHIT

    case WM_DESTROY:
	return TRUE;
#endif

    case WM_INITDIALOG:
	return TRUE;
    }
    return FALSE;

    #undef ptCurrent
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\timetest\dialog.h ===
#define ID_ADD		101
#define ID_REMOVE	102

#define ID_PERIODIC	103
#define LB_DELAY	104

#define ID_STARTEDIT	105
#define ID_DELAYEDIT	106
#define ID_RESOLEDIT	107

#define ID_AUTOLOAD	108
#define CB_SESSION	109
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\timetest\ta.h ===
#include "dialog.h"

/* dialog box resource id's */
#define ABOUTDLG    1
#define DELAYDLG    2
#define FILEDLG     3

#define ID_APP      1000

/* Menu Items */
#define MENU_SAVE	1
#define MENU_LOAD	2
#define MENU_ABOUT	3
#define MENU_EXIT	4
#define MENU_DELAY	5
#define MENU_TIME       6

#define MENU_PERIODIC   100
#define MENU_ONESHOT    200

// fake ID for fake message to update the list box if a one-shot event is done
#define ID_UPDATEDISPLAY    WM_USER + 5000

#define MM_TIMEEVENT    WM_USER + 20
/*------------------------------------------------------------)-----------)---*\
|                                                                              |
|   f u n c t i o n   d e f i n i t i o n s                                    |
|                                                                              |
\*----------------------------------------------------------------------------*/

extern void PASCAL DelayDlgCmd( HWND hDlg, UINT wParam, LONG lParam );
extern TIMECALLBACK TimeCallback;
extern void PASCAL ErrMsg(char *sz);
extern void PASCAL KillAllEvents(void);
extern void PASCAL Idle(void);

#define     MAXEVENTS	20

typedef struct timerevent_tag {
    WORD                wDelay;         // delay required
    WORD                wResolution;    // resolution required
    LPTIMECALLBACK      lpFunction;     // ptr to callback function
    DWORD               dwUser;         // user DWORD
    WORD                wFlags;         // defines how to program event
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

typedef struct My_Event_Struct_tag {
    BOOL	bActive;
    BOOL	bPeriodic;
    BOOL	bHit;
    WORD	nID;
    TIMEREVENT teEvent;
    DWORD	dwCount;
    DWORD       dwError;
    WORD	wStart;
    LONG        time;
    LONG        dtime;
    LONG        dtimeMin;
    LONG        dtimeMax;
} EVENTLIST;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\timetest\tefti.h ===
/*
    tefti.h

    TEFTI DLL information and API definitions

*/

/* * * * * TEFTI TIMER BOARD * * * * *
;
;  Base port address is variable depending on jumper settings of
;  card. Port address will default to 220h, but can also be set
;  for DLL to read from system.ini during initialization. This is
;  particularly necessary for Multimedia Windows becuase the default
;  port address for the SoundBlaster audio card is 220h.
;
;  Jumper Definition
;
;	--------------
;    20|
;      | A7 A6 A5 A4
;    19|
;	--------------
;
;  Jumper defines the BASE address per the following table:
;
;    A7 A6 A5 A4	      system.ini port= entry
;
;     0  0  0  0  200h	      200
;     0  0  0  1  210h	      210
;     0  0  1  0  220h	      220
;     0  0  1  1  230h	      230
;     0  1  0  0  240h	      240
;     0  1  0  1  250h	      250
;     0  1  1  0  260h	      260
;     0  1  1  1  270h	      270
;     1  0  0  0  280h	      280
;     1  0  0  1  290h	      290
;     1  0  1  0  2A0h	      300
;     1  0  1  1  2B0h	      310
;     1  1  0  0  2C0h	      320
;     1  1  0  1  2D0h	      330
;     1  1  1  0  2E0h	      340
;     1  1  1  1  2F0h	      350
;
;
;  Jumper in place corresponds to '0' in that particular position.
;
;  Frequency for counter 1 is variable depending on system.ini section
;  or zero for default. counter 3 is chained to counter 1 to hold all
;  overflow, producing a 32 bit counter value.
;
;  Frequency setting are per the following table:
;
;  Value  Frequency	  Resolution	   Approx. Time to rollover (32 bit)
;
;    0	  1Mhz		    1 microsec	   1hr. 11min. 57sec.
;    1	  250Khz	    4 microsec	   4hr. 47min. 48sec.
;    2	  62.5Khz	   16 microsec	  15hr. 11min. 12sec.
;    3	  15.625Khz	   64 microsec	  60hr. 44min. 48sec.
;    4	  7.8125Khz	  256 microsec	 242hr. 15min. 12sec.
;    5	  976.5625Hz	1.024 millisec		  .
;    6	  122.0703Hz	8.196 millisec	  a LONG  .  TIME!
;    7	  30.5175Hz    32.784 millisec		  .
;
;* * * * * * * * * * * * * * * * * * */

void far pascal StartTimer(void);
void far pascal StopTimer(void);
void  far pascal ResetTimer(void);

unsigned long far pascal GetTimer(void);
unsigned long far pascal SnapTimer(void);

WORD  far pascal InitTimer(void);
short far pascal IT(void);
void  far pascal EndTimer(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\timetest\dialog.c ===
/*----------------------------------------------------------------------------*\
|                                                                              |
|   dialog.c - Dialog functions for Timer Device Driver Test Application       |
|                                                                              |
|                                                                              |
|   History:                                                                   |
|       Created     Glenn Steffler (w-GlennS) 29-Jan-1990                      |
|                                                                              |
\*----------------------------------------------------------)-----------------*/

/*----------------------------------------------------------------------------*\
|                                                                              |
|   i n c l u d e   f i l e s                                                  |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <port1632.h>
#include <stdio.h>
#include <string.h>
#include "ta.h"

#define abs(x)      ( (x) < 0 ? -(x) : (x) )

/*----------------------------------------------------------------------------*\
|                                                                              |
|   g l o b a l   v a r i a b l e s                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/

extern LPTIMECALLBACK lpTimeCallback; // call back function entry point
extern BOOL     bHandlerHit;
extern WORD     wHandlerError;
extern HWND     hwndApp;

static char     *szPerOne[] = { "One","Per" };

HWND        hdlgModeless = NULL;
HWND        hdlgDelay = NULL;
int         nEvents = 0;
EVENTLIST   EventList[MAXEVENTS];

/*----------------------------------------------------------------------------*\
|   ErrMsg - Opens a Message box with a error message in it.  The user can     |
|            select the OK button to continue                                  |
\*----------------------------------------------------------------------------*/
void PASCAL ErrMsg(char *sz)
{
    MessageBox(NULL,sz,NULL,MB_YESNO|MB_ICONEXCLAMATION|MB_DEFBUTTON2|MB_SYSTEMMODAL);
}

/*----------------------------------------------------------------------------*\
|   fnFileDlg (hDlg, uiMessage, wParam, lParam)                                |
|                                                                              |
|   Description:                                                               |
|                                                                              |
|   This function handles the messages for the delay dialog box.  When         |
|   the ADD, or REMOVE options are chosen, a timer event is either added       |
|   or removed from the system respectively.                                   |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of dialog window                         |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL FAR PASCAL
fnFileDlg( HWND hDlg, unsigned uiMessage, UINT wParam, LONG lParam )
{
    switch (uiMessage) {
    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            EndDialog(hDlg,TRUE);
            break;

        case IDCANCEL:
            EndDialog(hDlg,FALSE);
            break;
        }
        break;

    case WM_INITDIALOG:
        // SetDlgItemText(hDlg,IDOK,szText);
        return TRUE;
    }
    return FALSE;
}

/*----------------------------------------------------------------------------*\
|   fnDelayDlg (hDlg, uiMessage, wParam, lParam)                               |
|                                                                              |
|   Description:                                                               |
|                                                                              |
|   This function handles the messages for the delay dialog box.  When         |
|   the ADD, or REMOVE options are chosen, a timer event is either added       |
|   or removed from the system respectively.                                   |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of dialog window                         |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if message has been processed, else FALSE                         |
|                                                                              |
\*----------------------------------------------------------------------------*/


BOOL FAR PASCAL
fnDelayDlg( HWND hDlg, unsigned uiMessage, UINT wParam, LONG lParam )
{
    static int  piTabs[5] = { 0, 5*4, 10*4, 15*4, 20*4 };

    HWND    hWnd;
    int     nID,i,i1;
    char    szTemp[100];
    EVENTLIST *pEventList;
    TIMEREVENT  *pEvent;
    WORD        error;

    switch (uiMessage) {
    case MM_TIMEEVENT:
        if( EventList[LOWORD(lParam)].bPeriodic ) {
            bHandlerHit = TRUE;
            EventList[LOWORD(lParam)].dwCount++;
            EventList[LOWORD(lParam)].bHit = TRUE;
        }
        else {
            i = (int)EventList[LOWORD(lParam)].teEvent.wDelay;

            error = (int)EventList[LOWORD(lParam)].dtime - i;

            if (error < 0)
                wsprintf(szTemp,"%dms OneShot was %dms early",-i,error);
            else if (error > 0)
                wsprintf(szTemp,"%dms OneShot was %dms late",i,error);
            else
                wsprintf(szTemp,"%dms OneShot was on time",i);

            MessageBox(NULL,szTemp,NULL,MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL);

            hWnd = GetDlgItem(hDlg,LB_DELAY);
            /* events in listbox */
            i1 = (int)SendMessage(hWnd,LB_GETCOUNT,0,0l);
            for( i=1; i < i1; i++ ) {
                SendMessage(hWnd,LB_GETTEXT,i,(LONG)(LPSTR)szTemp);
                sscanf( szTemp+strlen(szTemp)-4, "%x", &nID );
                if( nID == wParam ) {   // compare ID's - kill if same
                    nEvents--;
                    bHandlerHit = TRUE;
                    EventList[LOWORD(lParam)].bActive = FALSE;
                    SendMessage(hWnd,LB_DELETESTRING,i,0l);
                    break;
                }
            }
        }
        return TRUE;

    case WM_COMMAND:
        DelayDlgCmd( hDlg, wParam, lParam );
        break;

    case WM_CLOSE:
        DestroyWindow( hDlg );
        hdlgModeless = NULL;
        hdlgDelay = NULL;
        return TRUE;

    case WM_INITDIALOG:
        hdlgDelay = hDlg;
        hWnd = GetDlgItem(hDlg,LB_DELAY);
        SendMessage(hWnd,LB_SETTABSTOPS,
                    sizeof(piTabs)/sizeof(int),(LONG)(LPSTR)piTabs);

        SendMessage(hWnd,LB_RESETCONTENT,0,0l);
        SendMessage(hWnd,LB_ADDSTRING,0,(LONG)(LPSTR)"[none]");
        for( pEventList=EventList,i=0; i < MAXEVENTS ; i++,pEventList++) {
            if( pEventList->bActive ) {
                pEvent = &( pEventList->teEvent );
                wsprintf(szTemp,"%d\t%d\t%d\t %s : %4x",
                    pEventList->wStart,
                    pEvent->wDelay,
                    pEvent->wResolution,
                    (LPSTR)szPerOne[pEventList->bPeriodic],
                    pEventList->nID);

                SendMessage(hWnd,LB_ADDSTRING,0,(LONG)(LPSTR)szTemp);
            }
        }
        SendMessage(hWnd,LB_SETCURSEL,0,0l);
        return TRUE;
    }
    return FALSE;
}


/*----------------------------------------------------------------------------*\
|   DelayDlgCmd( hDlg, wParam, lParam )                                        |
|                                                                              |
|   Description:                                                               |
|                                                                              |
|   Process the WM_COMMAND messages for the fnDelayDlg DIALOG.                 |
|                                                                              |
|   Arguments:                                                                 |
|       hDlg            window handle of dialog window                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       abso-poso-litilly-nothin                                               |
|                                                                              |
\*----------------------------------------------------------------------------*/
void PASCAL DelayDlgCmd( HWND hDlg, UINT wParam, LONG lParam )
{
    HWND    hWnd;
    int     nStartEdit,nDelayEdit,nResolEdit,nID,i;
    BOOL    b1,b2,b3,bPeriodic;
    char    szTemp[100],szTemp2[100];
    TIMEREVENT  *pEvent;

    switch (wParam) {
    case ID_REMOVE:
        hWnd = GetDlgItem(hDlg,LB_DELAY);
        if( (i = (int)SendMessage(hWnd,LB_GETCURSEL,0,0l)) > 0 ) {
            SendMessage(hWnd,LB_GETTEXT,i,(LONG)(LPSTR)szTemp);
            sscanf( szTemp+strlen(szTemp)-4, "%x", &nID );
            if( nID != 0 ) {
                SendMessage(hWnd,LB_DELETESTRING,i,0l);
                for( i=0; i < MAXEVENTS; i++ ) {
                    if( EventList[i].nID == nID ) {
                        if( EventList[i].bActive ) {
                            EventList[i].bActive = FALSE;
                            timeKillEvent(nID);
                            nEvents--;
                            break;
                        }
                        else {
                            ErrMsg( "Isn't registered in Queue!" );
                            break;
                        }
                    }
                }
                SendMessage(hWnd,LB_SETCURSEL,0,0l);
                PostMessage(hDlg,WM_COMMAND,LB_DELAY,
                            MAKELONG(hWnd,LBN_SELCHANGE));
                break;
            }
        }
        MessageBeep( NULL );
        break;

    case IDOK:
    case ID_ADD:
        hWnd = GetDlgItem(hDlg,LB_DELAY);
        nStartEdit = GetDlgItemInt( hDlg, ID_STARTEDIT, &b1, FALSE );
        nDelayEdit = GetDlgItemInt( hDlg, ID_DELAYEDIT, &b2, FALSE );
        nResolEdit = GetDlgItemInt( hDlg, ID_RESOLEDIT, &b3, FALSE );
        bPeriodic = (int)SendDlgItemMessage(hDlg,ID_PERIODIC,BM_GETCHECK,0,0l);

        if( nID = (b1 && b2 && b3) ) {
            for( i=0; i < MAXEVENTS; i++ ) {
                if( !EventList[i].bActive )
                    break;
            }
            if( i >= MAXEVENTS ) {
                nID = 0;
                break;
            }
            pEvent = &( EventList[i].teEvent );
            pEvent->wDelay = nDelayEdit;
            pEvent->wResolution = nResolEdit;
            pEvent->dwUser = i;

            pEvent->wFlags = ((bPeriodic)?(TIME_PERIODIC):(TIME_ONESHOT));

            pEvent->lpFunction = lpTimeCallback;

            EventList[i].bActive = TRUE;
            EventList[i].bPeriodic = bPeriodic;
            EventList[i].bHit = FALSE;
            EventList[i].dwCount = 0l;
            EventList[i].dwError = 0l;
            EventList[i].wStart = nStartEdit;

            EventList[i].dtimeMin = 0x7FFFFFFF;
            EventList[i].dtimeMax = 0;
            EventList[i].dtime    = 0;
            EventList[i].time     = timeGetTime();

            if( (nID = timeSetEvent(pEvent->wDelay, pEvent->wResolution,
                pEvent->lpFunction, pEvent->dwUser, pEvent->wFlags)) == NULL )
            {
                EventList[i].bActive = FALSE;
                break;
            }
            // SetTimer call must return non-NULL ID to signify a valid event

            nEvents++;
            EventList[i].nID = nID;

            wsprintf(szTemp,"%d\t%d\t%d\t %s : %4x",
                    nStartEdit,nDelayEdit,nResolEdit,(LPSTR)szPerOne[bPeriodic],nID);

            SendMessage(hWnd,LB_ADDSTRING,0,(LONG)(LPSTR)szTemp);

            SendMessage(hWnd,LB_SETCURSEL,0,0l);
            PostMessage(hDlg,WM_COMMAND,LB_DELAY,MAKELONG(hWnd,LBN_SELCHANGE));
        }
        if( wParam == IDOK ) {
            PostMessage( hDlg, WM_CLOSE, 0, 0l );
            break;
        }
        if( !nID ) {
            MessageBeep( NULL );
        }
        break;

    case LB_DELAY:
        switch( HIWORD(lParam) ) {
        case LBN_SELCHANGE:
            i = (int)SendMessage(LOWORD(lParam),LB_GETCURSEL,0,0l);
            if( i == 0 ) {
                SetDlgItemText(hDlg,ID_STARTEDIT,"");
                SetDlgItemText(hDlg,ID_DELAYEDIT,"");
                SetDlgItemText(hDlg,ID_RESOLEDIT,"");
                SendDlgItemMessage(hDlg,ID_PERIODIC,BM_SETCHECK,FALSE,0l);
            }
            else if( i != LB_ERR ) {
                SendMessage(LOWORD(lParam),LB_GETTEXT,i,(LONG)(LPSTR)szTemp);
                sscanf( szTemp, "%d %d %d %s : %x",
                    &nStartEdit,&nDelayEdit,&nResolEdit,szTemp2,&nID);
                bPeriodic = (lstrcmp( szTemp2, szPerOne[1] ) == 0);
                SetDlgItemInt(hDlg,ID_STARTEDIT,nStartEdit,FALSE);
                SetDlgItemInt(hDlg,ID_DELAYEDIT,nDelayEdit,FALSE);
                SetDlgItemInt(hDlg,ID_RESOLEDIT,nResolEdit,FALSE);
                SendDlgItemMessage(hDlg,ID_PERIODIC,BM_SETCHECK,bPeriodic,0l);
            }
            else
                break;

            break;
        }
        break;

    case IDCANCEL:
        PostMessage( hDlg, WM_CLOSE, 0, 0l );
        break;

    }
    return;
}

/*----------------------------------------------------------------------------*\
|   KillAllEvents(void )                                                       |
|                                                                              |
|   Description:                                                               |
|       Kills all outstanding events when windows exits                        |
|                                                                              |
|   Arguments:                                                                 |
|                                                                              |
|   Returns:                                                                   |
|       Absolutely nothing                                                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
void PASCAL KillAllEvents( void )
{
    int i;

    for( i=0; i < MAXEVENTS; i++ ) {
        if( EventList[i].bActive ) {
            timeKillEvent( (UINT)EventList[i].nID );
        }
    }
}

/*----------------------------------------------------------------------------*\
|   TimeCallback( wID, dwUser )                                                |
|                                                                              |
|   Description:                                                               |
|       The routine which processes the timer interrupt call backs.            |
|       Simply adds one to the long int corresponding to lParam in the         |
|       table of call back function counts.  This essentionally means the      |
|       number of times this routine is called for the certain interrupts      |
|       is recorded.                                                           |
|                                                                              |
|   Arguments:                                                                 |
|       wID             ID returned from timeSetTimerEvent  call               |
|       dwUser          value passed in event structure to said function.      |
|                                                                              |
|   Returns:                                                                   |
|       Absolutely nothing                                                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
void FAR PASCAL TimeCallback( UINT wID, UINT msg, DWORD dwUser, DWORD dwTime, DWORD dw2)
{
    #define i (LOWORD(dwUser))

    DWORD   time;

    time = timeGetTime();

    EventList[i].dtime    = time - EventList[i].time;
    EventList[i].dtimeMin = min(EventList[i].dtime,EventList[i].dtimeMin);
    EventList[i].dtimeMax = max(EventList[i].dtime,EventList[i].dtimeMax);
    EventList[i].time     = time;

    if( !EventList[i].bActive ) {
        wHandlerError++;
    }
    else if( EventList[i].bPeriodic ) {
        bHandlerHit = TRUE;
        EventList[i].dwCount++;

        if (abs((int)EventList[i].dtime-(int)EventList[i].teEvent.wDelay) > (int)EventList[i].teEvent.wResolution)
            EventList[i].dwError++;

        EventList[i].bHit = TRUE;
    }
    else if( hdlgDelay != NULL ) {
        PostMessage(hdlgDelay,MM_TIMEEVENT,wID,dwUser);
    }
    else {
        nEvents--;
        bHandlerHit = TRUE;
        EventList[i].bActive = FALSE;
    }
    #undef i
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\docfmt.c ===
/*	
	docfmt.c - Take the output from extract program and format it.

Copyright (c) 1989, Microsoft.	All Rights Reserved.

...
10-06-89 Matt Saettler
...
10-15-89 Matt Saettler - Autodoc'ed added functions

3-26-91  Ported for use with Win32 (NigelT)

*/



#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <assert.h>
#include <search.h>
#include <io.h>
#include <direct.h>
#include <ctype.h>
#ifdef MMWIN
#include <mmsysver.h>
#endif
#include "version.h"
#include "types.h"
#include "text.h"
#include "docfmt.h"
#include "readext.h"
#include "ventura.h"
#include "process.h"
#include "misc.h"
#include "rtf.h"
#include "errstr.h"

void addexternal(char *pch);
int levelOK(aBlock *pBlock);
void parseargfile(char *filename);

/* globals */
char	*progName = "docfmt";	// name of our program.

char	*dirPath = NULL;	// path for creation of temporary files
char	*outputFile = NULL;	// the final output file name

int	noOutput = OFF; 	// if ON then no output is generated.
int	outputType;		// type of output to be generated
int	fprocessFiles;		// flag: should files be processed?
int	fCleanFiles;		// flag: should temporary files be cleaned up?

int	fMMUserEd=FALSE;	// flag: generating for User Ed?

logentry *head_log=NULL;	// head of list of log files
aLine *headExternal=NULL;	// head of list of external names to process

int fprocessOverride=FALSE;	// has fprocessFiles been set by user?
int fCleanOverride=FALSE;	// has fCleanFiles been set by user?


char achtmpbuf[128];		// a global temporary buffer

int verbose=FALSE;

// Definitions for Error Strings
//
int warninglevel=2;		// warning level
int prlineno=TRUE;		// print line numbers
int prinfo=TRUE;		// print INFO messages ?
long haderror=0;		// count of number of errors
int therewaserror=FALSE;	// flag: TRUE if there was an error
int dumplevels=FALSE;		// flag: TRUE if want to dump doc levels
int fSortMessage=TRUE;		// flag: TRUE if want to sort messages
				//        seperately from APIs

/*
 *	@doc INTERNAL
 *
 *	@func int | docfmt | Formats the input from the given file and
 *	prints it to 'stdout'.  If the given filename is NULL, input is 
 *	taken from 'stdin'.
 *
 *	@parm char * | fileName | Specifies the name of the 
 *	file to be processed.
 *
 *	@rdesc A return value of zero indicates success; a non-zero return value
 *	indicates an error.
 */
int docfmt(fileName, pcur_log)
char *fileName;
logentry *pcur_log;
{
    int     nStatus;
    int     wtag;
    aBlock  *pcurBlock;
    EXTFile *pExt;
    char    ach[120];


    pExt=(EXTFile *)clear_alloc(sizeof (struct _EXTFile));
    if(!pExt)
    {
	error(ERROR3);
	exit(7);
    }
    /* file from standard input? */
    if( fileName == NULL )
    {
	    pExt->EXTFilename=cp_alloc("<stdin>");
	    pExt->fp = stdin;
    }
    else
    {
	pExt->EXTFilename=cp_alloc(fileName);
	pExt->fp = fopen( pExt->EXTFilename, "r");
	if(pExt->fp == NULL )
	{
	    /* or from user-supplied filename? */
	    strcpy( achtmpbuf, dirPath );
	    strcat( achtmpbuf, fileName );
	    my_free(pExt->EXTFilename);
	    pExt->EXTFilename=cp_alloc(achtmpbuf);

	    pExt->fp = fopen( achtmpbuf, "r");


	    /* can file be opened? */
	    if(pExt->fp == NULL)
	    {
		    error( ERROR1, achtmpbuf);
		    exit(1);
	    }
	}
    }

#if 0
// get header information
    getLine(pExt);
    wtag=HIWORD(getTag(pExt));

    while(wtag == T2_HEADER)
    {
	wtag=(int)getTag(pExt);
	switch( wtag)
	{
	    case TG_BEGINHEAD:
		getLine(pExt);
		break;

	    case TG_EXTRACTID:
		nStatus = processText( pExt, &((pcur_log->pExt)->extractid) );
		if( nStatus)
		    return( nStatus );
		getLine(pExt);
		break;

	    case TG_EXTRACTVER:
		nStatus = processText( pExt, &((pcur_log->pExt)->extractver) );
		if( nStatus)
		    return( nStatus );
		getLine(pExt);
		break;
	    case TG_EXTRACTDATE:
		nStatus = processText( pExt, &((pcur_log->pExt)->extractdate) );
		if( nStatus)
		    return( nStatus );
		getLine(pExt);
		break;
	    case TG_ENDHEAD:
		break;

	}

	wtag=HIWORD(getTag(pExt));
    }

#endif

    if( getLine(pExt) )
    {
	pcurBlock=(aBlock *)1;			// a do.. while loop
	while( pcurBlock )
	{
	    if(verbose>1)
		fprintf(errfp,"  Reading: ");
	    pcurBlock = getBlock(pExt);
	    if(pcurBlock && levelOK(pcurBlock) )
	    {
		if(verbose>1)
		    fprintf(errfp," Writing.\n");
		putblock(pcurBlock, pcur_log);
	    }
	    else if(verbose>1)
		if(pcurBlock)
		    fprintf(errfp," Skipping\n");
		else
		    fprintf(errfp," End of File.\n");
		    
	    if(pcurBlock)
		destroyblock(pcurBlock);
	}
    }
    else
    {
	nStatus = ST_EOF;
    }

    /* close the file */
    fclose(pExt->fp);
    pExt->fp=NULL;

    if( nStatus == ST_EOF )
	return( 0 );
    else
	return( nStatus );
}

/*
 *	@doc INTERNAL
 *
 *	@func int | levelOK | Returns TRUE if the specified Block is
 *	OK to output.
 *
 *	@parm aBlock * | pBlock | Specifies the Block to check.
 *
 *	@rdesc A return value of TRUE indicates the specified Block is
 *	valid to output.  If not valid to print, the return value is FALSE.
 */
int
levelOK(aBlock *pBlock)
{
    aLine *pextern;
    aLine *pLevel;

    pextern=headExternal;
    while(pextern)
    {
	if(!strcmp(pextern->text,"*"))		// '*' means everything
	    return TRUE;
	    
	pLevel=pBlock->doclevel;
	while(pLevel)
	{
	    if(!stricmp(pLevel->text,pextern->text))
		return(TRUE);	/* we found a match */
	    pLevel=pLevel->next;
	}
	pextern=pextern->next;

    }

    /* no matches. */
    return FALSE;
}

/*
 *	@doc INTERNAL
 *
 *	@func void | Usage | Prints usage information to 'stderr'.
 *
 *	@comm This function does not exit.
 */
void Usage()
{
	fprintf(stdout, "usage: \n%s [-x[ ]name] [-r[dh]] [-c[01] [-p[01] \n", progName);
	fprintf(stdout, "\t[-o[ ]filename] [-d[ ]dirpath] [-l[ ]logfile] [-Zs] [-V[level]] [files]\n");
	fprintf(stdout, "\t[@argfile]\n\n");
	fprintf(stdout, "[-x[ ]name\tDefines <name> to be generated from the extracted file.\n");
	fprintf(stdout, "\t\t\t\t(Default is external.)\n");
	fprintf(stdout, "[-X\t\tProcesses all names from extract file.\n");
	fprintf(stdout, "[-Zs]\t\t\tNo output, error check only.\n");
	fprintf(stdout, "[-Ze]\t\t\tEnables extensions: dump doc level in API.\n");
	fprintf(stdout, "[-rd]\t\t\tGenerate RTF output for printing.\n");
	fprintf(stdout, "[-rh]\t\t\tGenerate RTF output for WinHelp.\n");
	fprintf(stdout, "\t\t\t\t(Default is generate for Ventura.)\n");
	fprintf(stdout, "\t\t\t\t(Default RTF is for printing.)\n");
	fprintf(stdout, "[-p[01]] \t\tProcess output files.\n");
	fprintf(stdout, "\t\t\t\t(0 means don't process)\n");
	fprintf(stdout, "[-c[01]] \t\tClean up intermediate files.\n");
	fprintf(stdout, "\t\t\t\t(0 means don't clean)\n");
	fprintf(stdout, "[-m[01]] \t\tSort Messages seperately from APIs.\n");
	fprintf(stdout, "\t\t\t\t(0 means don't sort seperate)\n");
	fprintf(stdout, "[-d dirpath] \t\tSpecify the directory for temporary files.\n");
	fprintf(stdout, "\t\t\t\t(only one tmp path should be specified)\n");
	fprintf(stdout, "[-l logfile] \t\tSpecify the logfile.\n");
	fprintf(stdout, "\t\t\t\t(many logfiles may be specified)\n");
	fprintf(stdout, "\t\t\t\t(the logfile maps functions to files)\n"); 
	fprintf(stdout, "[-o outputfile] \tSpecify the output file.\n");
	fprintf(stdout, "[-v[level]] \t\tSets the Verbosity level.\n");
	fprintf(stdout, "[-M]] \t\t\tSets processing for MM User Ed.\n");
	fprintf(stdout, "[files] \t\tList of files to be processed.\n");
	fprintf(stdout, "[@argfile]\t\tName of file to get list of arguments from.\n");
	fprintf(stdout, "\nOptions may be placed in any order.\n");
	fprintf(stdout, "example: %s /xinternal /rd dspmgr.ext\n",progName);
	fprintf(stdout, "example: %s dspmgr.ext\n",progName);
	fprintf(stdout, "example: %s /d \\tmp /rh dspmgr.ext\n",progName);
	fprintf(stdout, "example: %s -x internal -x dspmgr -d\\tmp /rh dspmgr.ext /c0 /p0\n",progName);
	fprintf(stdout, "example: %s /rd @args /c0\n",progName);
}

/*
 *	@doc INTERNAL
 *
 *	@func int | main | This function formats documentation information 
 *	from the given input file and sends it to the standard output.  
 *	Information is not sorted or formatted.
 *
 *	@parm int | argc | Specified the number of arguments.
 *
 *	@parm char * | argv[] | Specifies an arrayof points to the arguments.
 *
 *	@rdesc The return value is zero if there are no errors, otherwise the
 *	return value is a non-zero error code.
 */
int main(argc, argv)
int argc;	/* Specifies the number of arguments. */
char *argv[];	/* Specifies an array of pointers to the arguments */
{
    int nFiles = 0;	    /* # of files processed */
    int nStatus;
    int done;
    int temp;

    if(initerror())
    {
	fprintf(stderr, "%s: Internal Error 01\n",progName);
	exit(765);
    }

    errfp=stderr;	// set error logging file to stderr

    /* announce our existance */




    initreadext();

    noOutput = FALSE;
    done = FALSE;

    outputType=VENTURA;
    fprocessFiles=TRUE;

    parsearg(argc,argv, FALSE);

#if MMWIN
    sprintf(achtmpbuf," Version %d.%02d.%02d  %s %s   - %s  %s\n",
	   rmj, rmm, rup, __DATE__, __TIME__, szVerUser, MMSYSVERSIONSTR);

    error(LOGON,achtmpbuf);
#endif
    
    if(!head_log)
    {
	Usage();
	exit(1);
    }

    if(!outputFile)
    {
	if(fprocessFiles)
	{
	    if(head_log->inheadFile)
	    {
		temp=findlshortname(head_log->inheadFile->filename);
		strncpy(achtmpbuf,head_log->inheadFile->filename,temp);
	    }
	    else
	    {
		temp=findlshortname(head_log->pchlogname);
		strncpy(achtmpbuf,head_log->pchlogname,temp);
	    }
	    achtmpbuf[temp]='\0';
	    switch(outputType)
	    {
		case VENTURA:
		    strcat(achtmpbuf,".txt");
		    break;
		case RTFDOC:
		case RTFHELP:
		    strcat(achtmpbuf,".rtf");
		    break;
	    }
	    outputFile=cp_alloc(achtmpbuf);
	    error(INFO_OUTFILEDEFAULT, achtmpbuf);
	    if(!fCleanOverride)
		fCleanFiles=TRUE;
	}

    }
    if(!dirPath)
    {
	getcwd(achtmpbuf,128);
	if (achtmpbuf[strlen(achtmpbuf) - 1] != '\\')
		strcat(achtmpbuf,"\\");
	dirPath=cp_alloc(achtmpbuf);

    }
    if(!headExternal)
    {
if(verbose>1) 
 fprintf(errfp,"Document Level list DEFAULTS to %s\n","external");
	addexternal("external");
    }

if(verbose) fprintf(errfp,"Reading input files...\n");
    formatFiles();


    if(fprocessFiles)
    {
if(verbose) fprintf(errfp,"Creating %s...\n",outputFile);
       processLog();

    }

    return(FALSE);	/* we exit ok */
}


/*
 *	@doc INTERNAL
 *
 *	@func void | formatFiles | This function formats the entire list
 *	   files and sends them to the specified output type.
 *
 *  @comm The log files are filled in on exit.
 */
void
formatFiles()
{
    fileentry *cur_file;
    FILE * fp;
    logentry *cur_log=head_log;

    while(cur_log)
    {
	fp=fopen(cur_log->pchlogname,"w");
	if(!fp)
	{
fprintf(errfp,"Can't open %s\n",cur_log->pchlogname);
	    error(ERROR3);
	    exit(1);
	}

	/* output per-log header data */
	cur_log->outputType=outputType;
	fprintf(fp,"%d\n",cur_log->outputType);

	/* close log header */
	fclose(fp);
if(verbose>1) fprintf(errfp,"Processing log file %s\n",cur_log->pchlogname);
	cur_file=cur_log->inheadFile;
	while(cur_file)
	{
	    cur_file->logfile=cur_log;

if(verbose>1) fprintf(errfp," Reading file %s\n",cur_file->filename);
	    docfmt(cur_file->filename, cur_log);
	    cur_file=cur_file->next;
	}
	cur_log=cur_log->next;
    }
}


/*
 *	@doc INTERNAL
 *
 *	@func void | parsearg | This function parses and process the
 *	  arguments that it is passed.
 *
 *	@parm int | argc | Specified the number of arguments.
 *
 *	@parm char * | argv[] | Specifies an arrayof points to the arguments.
 *
 *	@parm int | flag | Specifies where the arguments came from.
 *
 *	@flag	TRUE  | Arguments came from a file.
 *
 *	@flag	FALSE | Arguments came from the command line.
 *
 *	@rdesc The return value is zero if there are no errors, otherwise the
 *	return value is a non-zero error code.
 */
void
parsearg(argc,argv, flag)
unsigned argc;
char **argv;
int flag;
{
    unsigned  i,j;
    char copt;
    int fsamearg;

    i = 1;
    while( i < argc )
    {
	switch (*argv[i])
	{
	    case '@':
		++argv[i];
		if(*argv[i]==':')
		    ++argv[i];
		if(strlen(argv[i])==0) /* we have @<space><file> */
		    i++;

		if(*argv[i])
		    parseargfile(argv[i]);
		else
		{
		    error(ERR_FILE_OPTION, '@');
		    Usage();
		    exit(1);
		}

		break;
#ifdef MSDOS
	    case '/' :
#endif
	    case '-' :
		++argv[i];
		fsamearg=TRUE;
		while(*argv[i] && fsamearg)
		{
		    copt=*argv[i];
		    switch( *argv[i] )
		    {

			case 'V':
			case 'v':
			    ++argv[i];
			    fsamearg=FALSE;
			    if(*argv[i])
				verbose=atoi( argv[i]);
			    else
				verbose=1;
			    if(verbose>0)
				prinfo=TRUE;
			    else
				prinfo=FALSE;
			    break;

			case 'o':
			case 'O':
			    ++argv[i];
			    fsamearg=FALSE;
			    if(*argv[i]==':')
				++argv[i];
			    if(strlen(argv[i])==0) /* we have /o<space><file> */
				i++;

			    if(*argv[i])
				setoutputfile(argv[i]);
			    else
			    {
				if(flag)
				{
				    fprintf(errfp,"%s. Line %d\n",argv[0],i);
				}
				error(ERR_FILE_OPTION, copt);
				Usage();
				exit(1);
			    }

			    break;
			case 'd':
			case 'D':
			    ++argv[i];
			    fsamearg=FALSE;
			    if(*argv[i]==':')
				++argv[i];
			    if(strlen(argv[i])==0) /* we have /d<space><file> */
				i++;

			    if(*argv[i])
				settmppath(argv[i]);
			    else
			    {
				if(flag)
				{
				    fprintf(errfp,"%s. Line %d\n",argv[0],i);
				}
				error(ERR_FILE_OPTION, copt);
				Usage();
				exit(1);
			    }

			    break;

			case 'X':
			    ++argv[i];
			    addexternal("*");
			    break;
			    
			case 'x':
			    ++argv[i];
			    fsamearg=FALSE;
			    if(*argv[i]==':')
				++argv[i];

			    if(strlen(argv[i])==0) /* we have /l<space><name> */
				i++;

			    if(*argv[i])
				addexternal(argv[i]);
			    else
			    {
				if(flag)
				{
				    fprintf(errfp,"%s. Line %d\n",argv[0],i);
				}
				error(ERR_NAME_OPTION, copt);
				Usage();
				exit(1);
			    }

			    break;
			case 'l':
			case 'L':
			    ++argv[i];
			    fsamearg=FALSE;
			    if(*argv[i]==':')
				++argv[i];

			    if(strlen(argv[i])==0) /* we have /l<space><file> */
				i++;

			    fprocessFiles=TRUE;

			    if(*argv[i])
				add_logtoprocess(argv[i]);
			    else
			    {
				if(flag)
				{
				    fprintf(errfp,"%s. Line %d\n",argv[0],i);
				}
				error(ERR_FILE_OPTION, copt);
				Usage();
				exit(1);
			    }

			    break;

			case 'c':
			case 'C':
			    ++argv[i];
			    fsamearg=FALSE;
			    if(*argv[i]==':')
				++argv[i];
			    fCleanFiles=atoi( argv[i]);
			    fCleanOverride=TRUE;
			    break;
			    
			case 'm':
			    ++argv[i];
			    fsamearg=FALSE;
			    if(*argv[i]==':')
				++argv[i];
			    fSortMessage=atoi( argv[i]);
			    break;

			case 'p':
			case 'P':
			    ++argv[i];
			    fsamearg=FALSE;
			    if(*argv[i]==':')
				++argv[i];
			    fprocessFiles=atoi( argv[i]);
			    fprocessOverride=TRUE;
			    break;


			case 'r':
			case 'R':
			    ++argv[i];

			    if(!argv[i][0]) /* if no parms, default to RTFDOC */
			    {
				outputType=RTFDOC;
				break;
			    }

			    switch(argv[i][0])
			    {
				case 'h':
				case 'H':
				    outputType=RTFHELP;
				    break;
				case 'd':
				case 'D':
				    outputType=RTFDOC;
				    break;

				default:
				    if(flag)
				    {
					fprintf(errfp,"%s. Line %d\n",argv[0],i);
				    }
				    error(ERR_XOPTION, copt, argv[i][0]);
				    break;
			    }
			    ++argv[i];
			    break;
			    
			case 'M':
			    ++argv[i];
			    fsamearg=TRUE;
			    fMMUserEd=1;
			    break;

			case 'Z':
			    ++argv[i];
			    while(argv[i][0])
			    {
				switch(argv[i][0])
				{
				    case 'e':	// enable extensions
					dumplevels= TRUE;
					break;
				    case 's':	// syntax check only
					noOutput = YES;
					break;
				    default:
					if(flag)
					{
					    fprintf(errfp,"%s. Line %d\n",argv[0],i);
					}
					error(ERR_XOPTION,copt, argv[i][0]);
					break;
				}
				++argv[i];
			    }
			    break;

			default:
			    error(ERR_OPTION, copt);
			    Usage();
			    exit(1);
		    }
		}
		break;
	    default:
		/* let's look to see what kind of file it is */
		j=findlshortname(argv[i]);
		if(j==strlen(argv[i]))
		{
		    /* it has no extension */
		    if(flag)
		    {
			fprintf(errfp,"%s. Line %d\n",argv[0],i);
		    }
		    error(ERR_UNKNOWN_FILE, argv[i]);
		    Usage();
		    exit(1);

		}
		else
		{
#if 0
		    if(!stricmp(argv[i]+j,".sav"))
		    {
                        add_infile(argv[i]);
		    }
		    else if(!stricmp(argv[i]+j,".ind"))
		    { /* it's an input file */
                        add_infile(argv[i]);
		    }
		    else if(!stricmp(argv[i]+j,".db"))
		    { /* it's an input file */
                        add_infile(argv[i]);
		    }
		    else if(!stricmp(argv[i]+j,".xrf"))
                    {
                        add_xrffile(argv[i]);
		    }
		    else
#endif
		    {
			/* default  file type */
			/* add it */

			if(!head_log)
			{
			    j=findlshortname(argv[i]);
			    strncpy(achtmpbuf,argv[i],j);
			    achtmpbuf[j]='\0';
			    strcat(achtmpbuf,".log");
			    add_logtoprocess(achtmpbuf);
			    error(INFO_LOGFILEDEFAULT, achtmpbuf);
			    if(!fprocessOverride)
				fprocessFiles=TRUE;
			}

			add_filetoprocess(argv[i], head_log);
#if 0
			if(!baseFile)
			{
			    argv[i][j]='\0';
			    while(j>=0 && (argv[i][j]!='\\' || argv[i][j]!='/') )
				j--;
			    j++;

			    baseFile=cp_alloc(argv[i]+j);
			}
#endif
		    }


		}
		break;
	} /* switch */
	i++;
    } /*while */

}

/*
 * @doc INTERNAL
 *
 * @func void | parseargfile | This function processes a file as arguments.
 *
 * @parm char * | filename | specifies the filename to process.
 *
 */
void
parseargfile(char *filename)
{
static reenter=0;

    FILE *fp;
    int lineno,i;
    char * * ppch;
    char *pch;
    aLine *pLine=NULL;
    aLine *pHLine=NULL;

    assert(!reenter);
    reenter++;
    fp=fopen(filename,"r");
    if(!fp)
    {
 fprintf(errfp,"Cannot open argument file %s\n",filename);
	exit(1);
    }

    lineno=0;
    while(fgets(achtmpbuf,128,fp))
    {
	    // comment is # or ; on first significant character

	pch=achtmpbuf;
	while(*pch && isspace(*pch))
	    pch++;

	if(*pch=='#' || *pch==';')
	    continue;

	pLine=lineMake(pch);
	if(pHLine)
	    pLine->next=pHLine;
	pHLine=pLine;
	lineno++;
    }
    fclose(fp);

    if(lineno>0 && pHLine )
    {
	lineno++; // leave room for arg 0
	ppch=(char * *)clear_alloc( (sizeof (char *)) * (lineno+1));
	assert(ppch);

	pLine=pHLine;
	sprintf(achtmpbuf,"Arg file: %s",filename);
	ppch[0]=cp_alloc(achtmpbuf);
	for(i=1;i<lineno;i++)
	{
	    assert(pLine);
	    ppch[i]=pLine->text;
	    pLine=pLine->next;
	}
	parsearg(lineno,ppch, TRUE);  /* do the dirty work */

	lineDestroy(pHLine);
	my_free(*ppch);
	my_free(ppch);
    }

    reenter--;

}

/*
 * @doc INTERNAL
 *
 * @func void | addexternal | This function adds the specified string
 *  to the list of defined externals to extract.
 *
 * @parm char * | pch | Specifies the string to add.
 *
 */
void
addexternal(char *pch)
{
    aLine   *pLine;

    pLine=lineMake(pch);
    assert(pLine);
    assert(pch);

    if(headExternal)	    /* insert at head */
	pLine->next=headExternal;

    headExternal=pLine;
}

/*
 * @doc INTERNAL
 *
 * @func void | setoutputfile | This sets the output file name.
 *
 * @parm char * | pch | Specifies the filename.
 *
 */
void
setoutputfile(char * pch)
{
    assert(pch);
    assert(!outputFile);

    outputFile=cp_alloc(pch);
    return;
}

/*
 * @doc INTERNAL
 *
 * @func void | settmppath | This sets the path for temporary files.
 *
 * @parm char * | pch | Specifies the path name.
 *
 */
void
settmppath(char *pch)
{
    int temp;
    char ach[80];

    assert(pch);
    assert(!dirPath);

    strcpy( ach, pch );
    temp = strlen( ach );
    if( (temp != 0) && (ach[temp-1] != '\\') )
    {
	ach[temp++] = '\\';
	ach[temp] = '\0';
    }
    dirPath=cp_alloc(ach);
    return;
}

/*
 * @doc INTERNAL
 *
 * @func files | add_outfile | This function adds the specified file to
 *  the list of output files for the specified log file.
 *
 * @parm char * | pchfile | Specifies the filename.
 *
 * @parm logentry * | pcur_log | Specifies the log file.
 *
 * @rdesc The return value is the outfile of the specified file.
 *
 */
files
add_outfile(char *pchfile, logentry *pcur_log)
{
    files   pfile;
    files   pcurfile;

    assert(pcur_log);

    pfile=(files)clear_alloc(sizeof (struct strfile));
    if(!pfile)
	return(NULL);

    pfile->filename=cp_alloc(pchfile);
    pfile->logfile=pcur_log;
    if(pcur_log->outheadFile)
    {
	pcurfile=pcur_log->outheadFile;
	while(pcurfile->next)
	{
	    pcurfile=pcurfile->next;
	}
	pcurfile->next=pfile;

    }
    else
	pcur_log->outheadFile=pfile;

    return(pfile);
}


/**********************************************************/

/*
 * @doc INTERNAL
 *
 * @func int | putblock | This function outputs a specifed block.
 *
 * @parm aBlock * |pBlock | Specifies the block to output.
 *
 * @parm logentry * | pcur_log | Specifies the log to add the output file.
 *
 * @rdesc The return value is TRUE if no error has occured.
 *
 */
int
putblock( aBlock *pBlock, logentry *pcur_log)
{
    char    achFile[128];
    FILE    *tFile;
    files   pfile;

    assert(pBlock);
    assert(pcur_log);

    /* output function documentation */
    if( !noOutput )
    {

        mymktemp(dirPath,achFile);

	pfile=add_outfile(achFile, pcur_log);

	assert(pfile);

	/* open the file */
	tFile = fopen( pfile->filename, "w" );
	if( !tFile )
	{
	    error(ERROR10, pfile->filename);
	    return(FALSE);
	}

        /* output information */
        switch(outputType)
        {
            case VENTURA:
		VenturaBlockOut(pBlock, tFile);
		break;

            case RTFDOC:
            case RTFHELP:

		RTFBlockOut( pBlock, tFile );
                break;

            default:
  fprintf(errfp, "\nInternal Error: Unknown Output Type. Block name:%s\n",pBlock->name->text);
                break;
	}

	fclose(tFile);


        /* add to the logfile */
	tFile = fopen(pcur_log->pchlogname, "a");
	if( !tFile )
        {
	    error(ERROR9, pcur_log->pchlogname );
        }
        else
	{
	    fprintf(tFile, "%d ", pBlock->blockType);	// output type
	    VentextOut( tFile, pBlock->name, FALSE );		// block name
	    fprintf( tFile, "  \t%s\n", pfile->filename );	// filename
	    fclose( tFile );
        }

    }
    return(TRUE);

}

/*
 * @doc INTERNAL
 *
 * @func void |destroyblock | This functions deletes all the data structures
 *  associated withe a block.
 *
 * @parm aBlock *| pcurblock | Specifies the Block to be destroyed.
 *
 */
void
destroyblock(aBlock *pcurblock)
{
    aBlock *pcbBlock;

    if(!pcurblock)
	return;

    destroyBlockchain(pcurblock->cb);
    pcurblock->cb=NULL;

    /* free all elements of the aBlock structure */
	my_free( pcurblock->srcfile );
	pcurblock->srcfile=NULL;
	
    lineDestroy( pcurblock->doclevel );
    pcurblock->doclevel=NULL;

    lineDestroy( pcurblock->name );
    pcurblock->name=NULL;

    lineDestroy( pcurblock->type );
    pcurblock->type=NULL;

    lineDestroy( pcurblock->desc );
    pcurblock->desc=NULL;

    parmDestroy( pcurblock->parm );
    pcurblock->parm=NULL;

    regDestroy( pcurblock->reg );
    pcurblock->reg=NULL;

    fieldDestroy( pcurblock->field);
    pcurblock->field=NULL;
    
    otherDestroy( pcurblock->other);
    pcurblock->other=NULL;
    
    lineDestroy( pcurblock->tagname);
    pcurblock->tagname=NULL;
    
    lineDestroy( pcurblock->rtndesc );
    pcurblock->rtndesc=NULL;

    flagDestroy( pcurblock->rtnflag );
    pcurblock->rtnflag=NULL;

    lineDestroy( pcurblock->comment );
    pcurblock->comment=NULL;

    lineDestroy( pcurblock->xref );
    pcurblock->xref=NULL;
	
	/* now, free the aBlock structure itself */
	my_free( pcurblock );
}

/*
 * @doc INTERNAL
 *
 * @func void |destroyBlockchain | This function deletes a list of Blocks.
 *
 * @parm aBlock * |pcurblock | Specifies the head of the list of Blocks.
 *
 * @comm This function is recursive.
 */
void
destroyBlockchain(aBlock *pcurblock)
{
    if(!pcurblock)
	return;

    if(pcurblock->next)
	destroyBlockchain(pcurblock->next);

    destroyblock(pcurblock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\test\timetest\ta.c ===
/*----------------------------------------------------------------------------*\
|                                                                              |
|   ta.c - Timer Device Driver Test Application                                |
|                                                                              |
|                                                                              |
|   History:                                                                   |
|                                                                              |
|       Created     Glenn Steffler (w-GlennS) 24-Jan-1990                      |
|                                                                              |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
|                                                                              |
|   i n c l u d e   f i l e s                                                  |
|                                                                              |
\*----------------------------------------------------------------------------*/

#include <windows.h>
#include <mmsystem.h>
#include <port1632.h>
#include <stdio.h>
#include <string.h>
#include "ta.h"

/*----------------------------------------------------------------------------*\
|                                                                              |
|   g l o b a l   v a r i a b l e s                                            |
|                                                                              |
\*----------------------------------------------------------------------------*/
extern HWND hdlgDelay;

static  char    szAppName[]="Timer Device Test Application";

HANDLE  hInstApp;
HWND    hwndApp;

WORD    wHandlerError = 0;
BOOL    bHandlerHit = FALSE;      // was timer event handler hit since last
int     dyFont;
int     dxFont;
HFONT   hfontApp;
HBRUSH  hbrWindow;
extern  int         nEvents;
extern  EVENTLIST   EventList[];
extern  HWND        hdlgModeless;

LPTIMECALLBACK lpTimeCallback;    // timer callback function

FARPROC lpfnDelayDlg = NULL;      // modeless Delay dialog function pointer
BOOL fSystemTime = TRUE;
BOOL fRealTime = TRUE;
BOOL fFirstTime = TRUE;

/*----------------------------------------------------------------------------*\
|                                                                              |
|   f u n c t i o n   d e f i n i t i o n s                                    |
|                                                                              |
\*----------------------------------------------------------------------------*/

LONG FAR PASCAL AppWndProc (HWND hwnd, unsigned uiMessage, UINT wParam, LONG lParam);
BOOL fDialog(int id,HWND hwnd,FARPROC lpfn);

LONG  NEAR PASCAL AppCommand(HWND hwnd, unsigned msg, UINT wParam, LONG lParam);

extern BOOL FAR PASCAL fnAboutDlg(
        HWND hDlg, unsigned uiMessage, UINT wParam, LONG lParam );
extern BOOL FAR PASCAL fnDelayDlg(
        HWND hDlg, unsigned uiMessage, UINT wParam, LONG lParam );
extern BOOL FAR PASCAL fnFileDlg(
        HWND hDlg, unsigned uiMessage, UINT wParam, LONG lParam );

/*----------------------------------------------------------------------------*\
|   AppInit( hInst, hPrev)                                                     |
|                                                                              |
|   Description:                                                               |
|       This is called when the application is first loaded into               |
|       memory.  It performs all initialization that doesn't need to be done   |
|       once per instance.                                                     |
|                                                                              |
|   Arguments:                                                                 |
|       hInstance       instance handle of current instance                    |
|       hPrev           instance handle of previous instance                   |
|                                                                              |
|   Returns:                                                                   |
|       TRUE if successful, FALSE if not                                       |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL AppInit(HANDLE hInst,HANDLE hPrev,UINT sw,LPSTR szCmdLine)
{
    WNDCLASS cls;
    int      dx,dy;
    char     ach[80];
    HMENU    hmenu;
    TEXTMETRIC tm;
    HDC        hdc;

    /* Save instance handle for DialogBoxs */
    hInstApp = hInst;

    if (!hPrev) {
        /*
         *  Register a class for the main application window
         */
        cls.hCursor        = LoadCursor(NULL,IDC_ARROW);
        cls.hIcon          = LoadIcon(hInst,MAKEINTATOM(ID_APP));
        cls.lpszMenuName   = MAKEINTATOM(ID_APP);
        cls.lpszClassName  = MAKEINTATOM(ID_APP);
        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
        cls.hInstance      = hInst;
        cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
        cls.lpfnWndProc    = AppWndProc;
        cls.cbWndExtra     = 0;
        cls.cbClsExtra     = 0;

        if (!RegisterClass(&cls))
            return FALSE;
    }

    dx = GetSystemMetrics (SM_CXSCREEN);
    dy = GetSystemMetrics (SM_CYSCREEN);

////hfontApp = GetStockObject(ANSI_VAR_FONT);
    hfontApp = GetStockObject(ANSI_FIXED_FONT);

    hdc = GetDC(NULL);
    SelectObject(hdc, hfontApp);
    GetTextMetrics(hdc, &tm);
    dxFont = tm.tmAveCharWidth;
    dyFont = tm.tmHeight;
    ReleaseDC(NULL,hdc);

    hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW));

    hwndApp = CreateWindow (MAKEINTATOM(ID_APP),    // Class name
                            szAppName,              // Caption
                            WS_OVERLAPPEDWINDOW,    // Style bits
                            CW_USEDEFAULT, 0,       // Position
                            ((2*dx)/3),dy/2,        // Size
                            (HWND)NULL,             // Parent window (no parent)
                            (HMENU)NULL,            // use class menu
                            (HANDLE)hInst,          // handle to window instance
                            (LPSTR)NULL             // no params to pass on
                           );
    ShowWindow(hwndApp,sw);

    lpTimeCallback = (LPTIMECALLBACK)MakeProcInstance(TimeCallback,hInst);

    return TRUE;
}

/*----------------------------------------------------------------------------*\
|   WinMain( hInst, hPrev, lpszCmdLine, cmdShow )                              |
|                                                                              |
|   Description:                                                               |
|       The main procedure for the App.  After initializing, it just goes      |
|       into a message-processing loop qntil it gets a WM_QUIT message         |
|       (meaning the app was closed).                                          |
|                                                                              |
|   Arguments:                                                                 |
|       hInst           instance handle of this instance of the app            |
|       hPrev           instance handle of previous instance, NULL if first    |
|       szCmdLine       ->null-terminated command line                         |
|       cmdShow         specifies how the window is initially displayed        |
|                                                                              |
|   Returns:                                                                   |
|       The exit code as specified in the WM_QUIT message.                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
MMain(hInst, hPrev, szCmdLine, sw)
{
    MSG     msg;

    /* Call initialization procedure */

    if (!AppInit(hInst,hPrev,sw,szCmdLine))
        return FALSE;

    /* check for messages from Windows and process them */
    /* if no messages, perform some idle function */

    while(1) {
        if( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) ) {
            if( hdlgModeless == 0 || !IsDialogMessage( hdlgModeless, &msg ) ) {
                /* got a message to process */
                if( msg.message == WM_QUIT ) break;
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else {
            Idle();
        }
    }

    DeleteObject(hbrWindow);
    return (msg.wParam);
}
}


static  LONG lError2=0l;
static  LONG lDelta=0l;
static  LONG lTDelta=0l;

static  LONG lErrorMax=0l;
static  LONG lErrorMin=0l;

/*----------------------------------------------------------------------------*\
|   AppPaint(hwnd)                                                             |
|                                                                              |
|   Description:                                                               |
|       The paint function.  Right now this does nothing.                      |
|                                                                              |
|   Arguments:                                                                 |
|       hwnd             window painting into                                  |
|                                                                              |
|   Returns:                                                                   |
|       nothing                                                                |
|                                                                              |
\*----------------------------------------------------------------------------*/
void PASCAL AppPaint(HWND hwnd, HDC hdc)
{
    typedef struct tag_booga {
        int     *pnValue;
        char    *szDescription;
    } BOOGA;

    static  BOOGA   bgTell[] ={ { &wHandlerError,   "Handler Error" },
                                { &nEvents,         "Number Of Events" }};
    RECT    rc;
    char    szText[100];
    int     i;
    MMTIME  mmt;
    DWORD   ms;
    DWORD   dw,dwRTC;
    LONG    lError,lTError;
    BOOL    fGetDC;
    int     len;
    int hrs, min, sec;
    SYSTEMTIME Time;

    if (fGetDC = (hdc == NULL))
        hdc = GetDC(hwnd);

    SelectObject(hdc, hfontApp);

    GetClientRect(hwnd,&rc);

    SetTextColor(hdc,GetSysColor(COLOR_WINDOWTEXT));
    SetBkColor(hdc,GetSysColor(COLOR_WINDOW));

    rc.top    = dxFont;
    rc.left   = dxFont;
    rc.bottom = rc.top+dyFont;

    GetSystemTime(&Time);
    if (fSystemTime)
        {
        timeGetSystemTime(&mmt, sizeof(mmt));


        dwRTC = (Time.wSecond * 1000l) +
                (Time.wMinute * 1000l * 60l) +
                (Time.wHour * 1000l * 60l * 60l);

        if (fRealTime)
            {
            len = wsprintf(szText, "RealTime = [%08ld ms] %02d hrs %02d min %02d.000 sec",
                    dwRTC,
                    Time.wHour,
                    Time.wMinute,
                    Time.wSecond);

            ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, szText, len, NULL);
            rc.top     = rc.bottom;
            rc.bottom += dyFont;

            dw = dwRTC;
            }

        mmt.u.ms += lDelta;

        lError = (long)dwRTC - (long)mmt.u.ms;

        if (lDelta == 0l)
            {
            lDelta = lError;
            mmt.u.ms += lDelta;
            }

        hrs = (WORD)(mmt.u.ms / (1000l*60l*60l));
        min = (WORD)(mmt.u.ms / (1000*60l)) % 60;
        sec = (WORD)(mmt.u.ms / 1000l) % 60;

        len = wsprintf( szText, "SysTime  = [%08ld ms] %02d hrs %02d min %02d.%03d sec",
                  mmt.u.ms,
                  hrs,min,sec,
                  (int)(mmt.u.ms % 1000L) );

        ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, szText, len, NULL);
        rc.top     = rc.bottom;
        rc.bottom += dyFont;


        if (fFirstTime)
            {
            fFirstTime = FALSE;
            }
        else
            {
            lErrorMin = min(lErrorMin,lError);
            lErrorMax = max(lErrorMax,lError);
            }

        len = wsprintf( szText, "SysTime Error:%8ld ms Max:%8ld Min:%8ld delta: %8ld",
            -lError,
            -lErrorMin,
            -lErrorMax,
            lError-lError2);

        lError2 = lError;

        ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, szText, len, NULL);
        rc.top     = rc.bottom;
        rc.bottom += dyFont;
        }

    for( i=0; i < sizeof(bgTell)/sizeof(BOOGA); i++ ) {
        if( *(bgTell[i].pnValue) ) {
            len = wsprintf( szText, "%ls  = [%d] ",
                 (LPSTR)bgTell[i].szDescription, *(bgTell[i].pnValue) );

            ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, szText, len, NULL);
            rc.top     = rc.bottom;
            rc.bottom += dyFont;
        }
    }
    for( i=0; i < MAXEVENTS; i++ ) {
        if( EventList[i].bActive ) {
            len = wsprintf( szText, "Event %2.2x Count=[%ld]%c Errors=%ld (%d%%) dtime=%ld Min=%ld Max=%ld",
                (int)EventList[i].nID,
                EventList[i].dwCount,
                (char)(EventList[i].bHit ? '*' : '-'),
                EventList[i].dwError,
                EventList[i].dwCount ? (int)(EventList[i].dwError * 100 / EventList[i].dwCount) : 0,
                EventList[i].dtime,
                EventList[i].dtimeMin,
                EventList[i].dtimeMax );

            EventList[i].bHit = FALSE;

            ExtTextOut( hdc, rc.left, rc.top, ETO_OPAQUE, &rc, szText, len, NULL);
            rc.top     = rc.bottom;
            rc.bottom += dyFont;
        }
    }

    i = rc.top;
    GetClientRect(hwnd,&rc);
    rc.top = i;
    FillRect(hdc, &rc, hbrWindow);
////ExtTextOut( hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    if (fGetDC)
        ReleaseDC(hwnd,hdc);

    return;
    #undef  BOOGA
}

/*----------------------------------------------------------------------------*\
|   Idle( void )                                                               |
|                                                                              |
|   Description:                                                               |
|       Idle loop function...displays time values while windows idles          |
|                                                                              |
|   Arguments:                                                                 |
|       none                                                                   |
|                                                                              |
|   Returns:                                                                   |
|       nothing                                                                |
|                                                                              |
\*----------------------------------------------------------------------------*/
void PASCAL Idle( )
{
    if(hwndApp && bHandlerHit || fSystemTime) {
        AppPaint( hwndApp, NULL );
        bHandlerHit = FALSE;
    }
    else
        WaitMessage();

    return;
}


/*----------------------------------------------------------------------------*\
|                                                                              |
|   w i n d o w   p r o c s                                                    |
|                                                                              |
\*----------------------------------------------------------------------------*/

/*----------------------------------------------------------------------------*\
|   AppWndProc( hwnd, uiMessage, wParam, lParam )                              |
|                                                                              |
|   Description:                                                               |
|       The window proc for the app's main (tiled) window.  This processes all |
|       of the parent window's messages.                                       |
|                                                                              |
|   Arguments:                                                                 |
|       hwnd            window handle for the window                           |
|       uiMessage       message number                                         |
|       wParam          message-dependent                                      |
|       lParam          message-dependent                                      |
|                                                                              |
|   Returns:                                                                   |
|       0 if processed, nonzero if ignored                                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
LONG FAR PASCAL AppWndProc(hwnd, msg, wParam, lParam)
    HWND     hwnd;
    unsigned msg;
    UINT     wParam;
    long     lParam;
{
    BOOL        f;
    HDC         hdc;
    PAINTSTRUCT ps;

    switch (msg) {
        case WM_CREATE:
            break;

        case WM_COMMAND:
            return AppCommand(hwnd,msg,wParam,lParam);

        case WM_CLOSE:
            hwndApp = NULL;
            if (hdlgDelay) {
                PostMessage (hdlgDelay,WM_CLOSE,0,0l);
            }
            break;

        case WM_DESTROY:
            PostQuitMessage (0);

            // FALL THRU AND DESTROY ALL REMAINING OBJECTS / TIMER EVENTS

        case WM_ENDSESSION:
            KillAllEvents();
            if( lpTimeCallback ) {
                FreeProcInstance(lpTimeCallback);
                lpTimeCallback = NULL;
            }
            if( lpfnDelayDlg ) {
                FreeProcInstance(lpfnDelayDlg);
            }
            break;

        case WM_ERASEBKGND:
            break;

        case WM_PAINT:
            BeginPaint(hwnd, &ps);
            AppPaint( hwnd, ps.hdc );
            EndPaint(hwnd, &ps);
            return 0L;

        case MM_TIMEEVENT:
            if( hdlgDelay != NULL )
                SendMessage(hdlgDelay,msg,wParam,lParam);
            break;

    }
    return DefWindowProc(hwnd,msg,wParam,lParam);
}

LONG NEAR PASCAL AppCommand (hwnd, msg, wParam, lParam)
    HWND     hwnd;
    unsigned msg;
    UINT     wParam;
    long     lParam;
{
    HANDLE  hInst;

    switch(LOWORD(wParam))
    {
        case MENU_ABOUT:
            fDialog(ABOUTDLG,hwnd,fnAboutDlg);
            break;

        case MENU_DELAY:
            if( hdlgDelay ) {
                ShowWindow( hdlgDelay, SW_SHOWNORMAL );
                SetFocus( hdlgDelay );
            } else {
                hInst = GetWindowLong(hwnd,GWL_HINSTANCE);
                lpfnDelayDlg = MakeProcInstance(fnDelayDlg,hInst);
                hdlgModeless = CreateDialog(hInst,
                    MAKEINTRESOURCE(DELAYDLG),hwnd,lpfnDelayDlg);
            }
            break;

        case MENU_TIME:
            fSystemTime = !fSystemTime;
            if (!fSystemTime)
                {
                fFirstTime = TRUE;
                }
            lTDelta = 0l;
            lDelta = lErrorMin = lErrorMax = 0l;
            break;

        case MENU_LOAD:
        case MENU_SAVE:
            if( fDialog(FILEDLG,hwnd,fnFileDlg) )
                // call function to Save/Load session
                break;
            break;

        case MENU_EXIT:
            PostMessage(hwnd,WM_CLOSE,0,0L);
            break;

    }
    return 0L;
}

/*----------------------------------------------------------------------------*\
|   fDialog(id,hwnd,lpfn)                                                      |
|                                                                              |
|   Description:                                                               |
|       This function displays a dialog box and returns the exit code.         |
|       the function passed will have a proc instance made for it.             |
|                                                                              |
|   Arguments:                                                                 |
|       id              resource id of dialog to display                       |
|       hwnd            parent window of dialog                                |
|       lpfn            dialog message function                                |
|                                                                              |
|   Returns:                                                                   |
|       exit code of dialog (what was passed to EndDialog)                     |
|                                                                              |
\*----------------------------------------------------------------------------*/
BOOL fDialog(int id,HWND hwnd,FARPROC lpfn)
{
    BOOL        f;
    HANDLE      hInst;

    hInst = GetWindowLong(hwnd,GWL_HINSTANCE);
    lpfn  = MakeProcInstance(lpfn,hInst);
    f = DialogBox(hInst,MAKEINTRESOURCE(id),hwnd,lpfn);
    FreeProcInstance (lpfn);
    return f;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void FAR PASCAL PeriodicCallback( UINT wID, UINT msg, DWORD dwUser, DWORD dwTime, DWORD dw2)
{
    int i = LOWORD(dwUser);

    DWORD   time;

    bHandlerHit = TRUE;

    time = timeGetTime();

    EventList[i].dtime    = time - EventList[i].time;
    EventList[i].dtimeMin = min(EventList[i].dtime,EventList[i].dtimeMin);
    EventList[i].dtimeMax = max(EventList[i].dtime,EventList[i].dtimeMax);
    EventList[i].time     = time;
    EventList[i].dwCount++;
    EventList[i].bHit     = TRUE;

//  if (abs((int)EventList[i].dtime-(int)EventList[i].teEvent.wDelay) > (int)EventList[i].teEvent.wResolution)
//       EventList[i].dwError++;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void FAR PASCAL OneShotCallback( UINT wID, UINT msg, DWORD dwUser, DWORD dwTime, DWORD dw2)
{
    int i = LOWORD(dwUser);

    DWORD   time;

    bHandlerHit = TRUE;

    time = timeGetTime();

    EventList[i].dtime    = time - EventList[i].time;
    EventList[i].dtimeMin = min(EventList[i].dtime,EventList[i].dtimeMin);
    EventList[i].dtimeMax = max(EventList[i].dtime,EventList[i].dtimeMax);
    EventList[i].time     = time;
    EventList[i].dwCount++;
    EventList[i].bHit     = TRUE;

//  if (abs((int)EventList[i].dtime-(int)EventList[i].teEvent.wDelay) > (int)EventList[i].teEvent.wResolution)
//      EventList[i].dwError++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\docfmt.h ===
/*
	docfmt.h
*/


extern	int	fprocessFiles;
extern	int	fCleanFiles;

#if 0
extern	char	currentFile[];
extern	char	*baseFile;
extern	files	headFile;
extern	int	numFiles;

extern	fileentry *head_file;
#endif
extern	logentry *head_log;
extern	aLine	 *headExternal;

extern	char	*pchparm;
extern	char	*pchfunc;
extern	char	*pchdefault;
extern int noOutput;

extern	char * dirPath;
extern	char	*outputFile;

extern int verbose;
extern int dumplevels;
extern int fSortMessage;

extern int fMMUserEd;

extern  int docfmt(char *fileName,struct s_log *pcur_log);
extern  void Usage(void );
extern	int main(int argc,char * *argv);
extern  void formatFiles(void );
extern	void parsearg(int argc,char * *argv, int flags);
extern  void setoutputfile(char *pch);
extern  void settmppath(char *pch);
extern  int putblock(struct stBlock *pBlock,struct s_log *pcur_log);
extern  void destroyblock(struct stBlock *pcurblock);
extern  void destroyBlockchain(struct stBlock *pcurblock);

extern	files add_outfile(char *pchfile, logentry *pcur_log);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\errstr.h ===
#define ERROR1		  1
#define ERROR4		  2
#define ERROR7		  3
#define ERROR8		  4
#define ERROR9		  5
#define ERROR10 	  7
#define ERROR5		  8
#define ERROR6		  9
#define WARN1		  10
#define WARN2		  11


#define ERR_FILE_OPTION   12
#define ERR_XOPTION	      13
#define ERR_OPTION	      14
#define ERR_UNKNOWN_FILE      15
#define INFO_LOGFILEDEFAULT   16
#define INFO_OUTFILEDEFAULT   17


#define LOGON		      18
#define ERROR3		      19

#define ERR_NAME_OPTION   20

int  error(int,...);
int  initerror(void);
void dumperrorlist(FILE *);



extern FILE *errfp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\errstr.c ===
/* errstr.c - error codes
 *
 * Matt Saettler.  06-09-88 Created
 * Kevyn C-T	   88-07-25 Warnings 1,2,3 no longer cause non-zero ret. code
 *
 * Matt Saettler   89-10-09 Placed into Autodoc Sources and modified for DOCFMT
 * Matt Saettler   89-10-15 Create Autodoc style comment blocks.
 */

#include <stdio.h>
#include <stdarg.h>

#include "types.h"
#include "docfmt.h"

#define FATAL	   -1
#define INTERNAL   -2
#define INFO	   -3
#define SYSTEM	   -4
#define COMMAND    -5
#define EOFILE	   -6

#define WARNING0	0
#define WARNING1	1
#define WARNING2	2
#define WARNING3	3



#if 0
#include "tools.h"
#endif

#include "errstr.h"

extern int warninglevel;
extern int prlineno;
extern int prinfo;
extern long haderror;
extern int	therewaserror;

FILE *errfp;				/* where the error messages are sent */

struct errormsg {
	int   errno;
	int   errlevel;
	char *errtxt;
	int   errcnt;
};





struct errormsg errorlist[]=
{
/* error messages */
ERROR1,     FATAL,     "Unable to open file.\n", 0,
ERROR3,     FATAL,     "Memory Allocation Failure.\n", 0,
ERROR4,     FATAL,     "Unexpected End of File.\n", 0,
ERROR7,     FATAL,     "Unknown Error.\n", 0,
ERROR8,     FATAL,     "Out of Memory.\n", 0,
ERROR9,     FATAL,     "Could not open file %s.\n", 0,
ERROR10,    FATAL,     "Could not create file %s\n.", 0,

ERR_FILE_OPTION,  FATAL, "No file specified for -%c option.\n", 0,
ERR_NAME_OPTION,  FATAL, "No name specified for -%c option.\n", 0,
ERR_XOPTION,	  FATAL, "Unrecognized %c option: %c.\n", 0,
ERR_OPTION,	  FATAL, "Illegal option flag '-%c'\n", 0,
ERR_UNKNOWN_FILE, FATAL, "Unknown file type: %s\n", 0,

ERROR5,     WARNING0,  "Improper tag or tag sequence.\n", 0,
ERROR6,     WARNING0,  "Missing @ENDBLOCK.\n", 0,

WARN1,	    WARNING1,  "FLAGS are not currently allowed on Return Values.\n", 0,
WARN2,	    WARNING1,  "Improper tag or tag sequence.\nFile %s. Line %d\n", 0,

LOGON,	    INFO,      "Source Code Documentation Formatting Tool\n %s\n", 0,

INFO_LOGFILEDEFAULT, INFO, "Log file defaults to: %s\n", 0,
INFO_OUTFILEDEFAULT, INFO, "Output file defaults to: %s\n", 0,


		0,		   0,  "\n\n***DUMMY ERROR****\n\n", 0
};

#if 0
extern long curlineno;
extern long curoffset;
#endif

#ifdef TEST

long curlineno=0L;
long curoffset=0L;


main()
 {
   int line = 1;
   int no=0;
	 char *filename = "EXAMPLE";

	while(errorlist[no].errno!=0)
	{
		error(no);
		no++;

	}
}


#endif

/*
 * @doc INTERNAL ERRSTR
 *
 * @func int | initerror | This function initializes the error handling
 *  system.  It must be called before any calls to <f error>.
 *
 * @rdesc The return value is zero if no errors have occured during
 *  initialization, non-zero otherwise.
 */
int
initerror()
{
	int errno;

	for(errno=0;errorlist[errno].errno!=0; errno++)
		errorlist[errno].errcnt=0;

	return(0); /* success */
}

/*
 * @doc INTERNAL ERRSTR
 *
 * @func void | dumperrorlist | This function prints the error
 *  list logs to the specified file.
 *
 * @parm FILE * | fpout | Specifies the output file.
 *
 */
void
dumperrorlist(fpout)
FILE *fpout;
{
	int errno;

	for(errno=0;errorlist[errno].errno!=0; errno++)
	{
		if(errorlist[errno].errcnt!=0)
		{
			switch(errorlist[errno].errlevel)
			{
			  case FATAL	 :
			  case EOFILE	 :
			  case INTERNAL  :
			  case INFO 	 :
			  case SYSTEM	 :
			  case COMMAND	 :
					break;	/* these errors are not counted */
			  case WARNING0  : /* is actually an error */
				fprintf(errfp,"Error %d: ",errorlist[errno].errno);
				fprintf(errfp,"Occured %d times.\n",errorlist[errno].errcnt);
				break;
			  case WARNING1  :
			  case WARNING2  :
			  case WARNING3  :
				fprintf(errfp,"Warning %d: ",errorlist[errno].errno);
				fprintf(errfp,"Occured %d times.\n",errorlist[errno].errcnt);
				break;
			  default:
					fprintf(errfp," -----> UHOH:\n\n");
					break;
			}


		}
	}

}

/*
 * @doc INTERNAL ERRSTR
 *
 * @func int | error | Prints the specified error on the file errfp.
 *
 * @parm int | errno | Specifies the error number.
 *
 * @comm This is a variable argument function like printf.
 *
 */

int
error(int no, ...)
{
	int errno,no,thelevel,ret;
	va_list arg_ptr;

  /* initiliaze "arg_ptr" */
	va_start(arg_ptr,no);

	no=va_arg(arg_ptr,int);
	for(errno=0;errorlist[errno].errno!=0; errno++)
		if(errorlist[errno].errno==no)
			break;

	thelevel=errorlist[errno].errlevel;

	if(errorlist[errno].errno==0)
	{
		fprintf(stderr,"Bad errno to error()!\n");
		exit(1);
	}

	ret=TRUE; /* we printed the error */

	switch(thelevel)
	{
	  case FATAL	 :
#if 0
			fprintf(errfp,"Offset %ld",curoffset + (oldcurpos - curline));
			if(prlineno)
				fprintf(errfp,", Line %ld",curlineno);
#endif
			fprintf(errfp,": FATAL Error %d: ",errorlist[errno].errno);
			vfprintf(errfp,errorlist[errno].errtxt, arg_ptr);
			haderror++;
			therewaserror = TRUE;
			break;
	  case EOFILE	 :
			fprintf(errfp,"General File Error %d: ",errorlist[errno].errno);
			vfprintf(errfp,errorlist[errno].errtxt, arg_ptr);
			therewaserror = TRUE;
			haderror++;
			break;
	  case INTERNAL  :
#if 0
			fprintf(errfp,"Offset %ld",curoffset + (oldcurpos - curline));
			if(prlineno)
				fprintf(errfp,", Line %ld",curlineno);
#endif
			fprintf(errfp,": Internal FATAL Error %d: ",errorlist[errno].errno);
			therewaserror = TRUE;
			vfprintf(errfp,errorlist[errno].errtxt, arg_ptr);
			break;
	  case INFO 	 :
			if(prinfo)
			{
				vfprintf(errfp,errorlist[errno].errtxt, arg_ptr);
			}
			else
				ret=FALSE;

			break;
	  case SYSTEM	 :
#if 0
			fprintf(errfp,"Offset %ld",curoffset + (oldcurpos - curline));
			if(prlineno)
				fprintf(errfp,", Line %ld",curlineno);
#endif
			fprintf(errfp,": SYSTEM Error %d: ",errorlist[errno].errno);
			vfprintf(errfp,errorlist[errno].errtxt, arg_ptr);
			therewaserror = TRUE;
			break;
	  case COMMAND	 :
#if 0
			fprintf(errfp,"Offset %ld",curoffset + (oldcurpos - curline));
			if(prlineno)
				fprintf(errfp,", Line %ld",curlineno);
#endif
			fprintf(errfp,": Command Line Error %d: ",errorlist[errno].errno);
			vfprintf(errfp,errorlist[errno].errtxt, arg_ptr);

			therewaserror = TRUE;

			break;

	  case WARNING0  : /* is actually an error */
#if 0
			fprintf(errfp,"Offset %ld",curoffset + (oldcurpos - curline));
			if(prlineno)
				fprintf(errfp,", Line %ld",curlineno);
#endif
			fprintf(errfp,": Error %d: ",errorlist[errno].errno);
			vfprintf(errfp,errorlist[errno].errtxt, arg_ptr);

			errorlist[errno].errcnt++;

			haderror++;
			therewaserror = TRUE;
			break;
	  case WARNING1  :
		if(warninglevel>=thelevel)
		{
#if 0
			fprintf(errfp,"Offset %ld",curoffset + (oldcurpos - curline));
			if(prlineno)
				fprintf(errfp,", Line %ld",curlineno);
#endif
			fprintf(errfp,": Warning %d: ",errorlist[errno].errno);
			vfprintf(errfp,errorlist[errno].errtxt, arg_ptr);
			errorlist[errno].errcnt++;

		}
		else
			ret=FALSE;
		break;
	  case WARNING2  :
		if(warninglevel>=thelevel)
		{
#if 0
			fprintf(errfp,"Offset %ld",curoffset + (oldcurpos - curline));
			if(prlineno)
				fprintf(errfp,", Line %ld",curlineno);
#endif
			fprintf(errfp,": Warning %d: ",errorlist[errno].errno);
			vfprintf(errfp,errorlist[errno].errtxt, arg_ptr);
			errorlist[errno].errcnt++;

		}
		else
			ret=FALSE;
		break;
	  case WARNING3  :
		if(warninglevel>=thelevel)
		{
#if 0
			fprintf(errfp,"Offset %ld",curoffset + (oldcurpos - curline));
			if(prlineno)
				fprintf(errfp,", Line %ld",curlineno);
#endif
			fprintf(errfp,": Warning %d: ",errorlist[errno].errno);
			vfprintf(errfp,errorlist[errno].errtxt, arg_ptr);
			errorlist[errno].errcnt++;

		}
		else
			ret=FALSE;
		break;
	  default:
#if 0
			fprintf(errfp,"Offset %ld",curoffset + (oldcurpos - curline));
#endif
			fprintf(errfp," -----> UHOH:\n\n");
			ret=TRUE;
			therewaserror = TRUE;

			break;
	}
#ifdef TEST
	fprintf(errfp,"%s",errorlist[errno].errtxt);
#endif

	va_end(arg_ptr);


	return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\process.c ===
/*	
  process.c - Process the log files.

Copyright (c) 1989, Microsoft.	All Rights Reserved.

10-07-89 Matt Saettler
10-10-89 Update for log,aBlock,EXTFile,files structures
*/

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <assert.h>
#include <search.h>

#include "types.h"
#include "docfmt.h"
#include "ventura.h"
#include "rtf.h"
#include "process.h"
#include "misc.h"
#include "errstr.h"

void dumptable(int numfiles, files * ptable);

/*
 * @doc INTERNAL
 *
 * @func void | processLog | This function processes all the Log files.
 *
 * @xref readLog, initLogs, processLogs, doneLogs
 */
void
processLog(void)
{
    logentry *cur_log;
    FILE *fpout;

    if(!head_log)
	return;

    cur_log=head_log;
    while(cur_log)
    {
	readLog(cur_log);
	cur_log=cur_log->next;
    }

    fpout=fopen(outputFile,"w");
    if(!fpout)
        return;

    cur_log=head_log;

    initLogs(fpout, &head_log);

    while(cur_log)
    {
if(verbose>1) fprintf(errfp," Processing Log file: %s\n",cur_log->pchlogname);
	processLogs(fpout, cur_log);
	cur_log=cur_log->next;
    }
    doneLogs(fpout, head_log);

    fclose(fpout);
if(verbose) fprintf(errfp,"%s is complete.\n",outputFile);

}

/*
 *
 * @doc INTERNAL
 *
 * @func void | processLogs | This functions processes all the files within
 *  the specified log file structure.
 *
 * @parm FILE * | fpout | This is the output file to process the files
 *  to.
 *
 * @parm logentry * | cur_log | This is the current log file to process.
 *
 * @xref initFiles, processFiles, doneFiles
 */
void
processLogs(FILE *fpout, logentry * cur_log)
{
    initFiles(fpout, cur_log);

    if(cur_log->outheadMFile)
	processFiles(fpout, cur_log->outheadMFile);
	
    processFiles(fpout, cur_log->outheadFile);

    if(cur_log->outheadSUFile)
	processFiles(fpout, cur_log->outheadSUFile);
	
    doneFiles(fpout, cur_log->outheadFile);

}

/*
 * @doc INTERNAL
 *
 * @func void | cleanLogs | This function removes the log files structure
 *  from memory and removes any files if the fCleanFiles flag is TRUE.
 *
 * @parm logentry * | cur_log | This specifies the log file structure to remove.
 *
 * @xref cleanFile, cleanLogs
 */
void
cleanLogs(logentry *cur_log)
{
    if(!cur_log)
	return;

    cleanFile(cur_log->outheadFile);
    cleanFile(cur_log->outheadMFile);
    cleanFile(cur_log->outheadSUFile);
    
// structs go here...    

    cleanLogs(cur_log->next);	   /* recursive !! */

    if(fCleanFiles)
	unlink(cur_log->pchlogname);

    my_free(cur_log->pchlogname);

    my_free(cur_log);
    return;
}

/*
 * @doc INTERNAL PROCESS
 *
 * @func void | readLog | This function reads the logfile and creates
 *  the logfile structure.
 *
 * @parm logentry * | cur_log | This specifies the logfile structure to
 *   fill.  The filename has been filled in.
 *
 * @xref parseFile
 */
void
readLog(logentry *cur_log)
{
    FILE * tFile;
    files curFile;
    files curMFile;
    files curSUFile;
    files curTFile;

    tFile = fopen(cur_log->pchlogname, "r");
    if(tFile == NULL)
    {
	error(ERROR9, "xxx", cur_log->pchlogname );
	Usage();
	return;
    }

    cur_log->outheadFile=NULL;
    cur_log->outheadMFile=NULL;
    cur_log->outheadSUFile=NULL;
    
    fscanf(tFile, "%d\n",&cur_log->outputType);

    curTFile=(files)clear_alloc(sizeof (struct strfile) );
    
    curMFile=NULL;
    curSUFile=NULL;
    curFile=NULL;
    curFile=cur_log->outheadFile;
    while(parseFile(tFile, curTFile))
    {
	if(curTFile->blockType==MESSAGE && fSortMessage)
	{
	    if(curMFile==NULL)
	    {
		cur_log->outheadMFile=curTFile;
	    }
	    else
	    {
		curMFile->next=curTFile;
	    }
	    curMFile=curTFile;
	}
	else if( (curTFile->blockType==STRUCTBLOCK) ||
		(curTFile->blockType==STRUCTBLOCK))
	{
	    if(curSUFile==NULL)
	    {
		cur_log->outheadSUFile=curTFile;
	    }
	    else
	    {
		curSUFile->next=curTFile;
	    }
	    curSUFile=curTFile;
	}
	else
	{
	    if(curFile==NULL)
	    {
		cur_log->outheadFile=curTFile;
	    }
	    else
	    {
		curFile->next=curTFile;
	    }
	    curFile=curTFile;
	}
	curTFile=(files)clear_alloc(sizeof (struct strfile) );
    }
    my_free(curTFile);
    curFile->next=NULL;

#ifdef MMWIN // This causes GP fault
    curMFile->next=NULL;	// just to be sure.
    curSUFile->next=NULL;	// just to be sure.
#endif

    fclose( tFile );

}

/*
 * @doc INTERNAL PROCESS
 *
 * @func int | initLogs | This function is called at the beginning of
 *  processing the list of logs.
 *
 * @parm FILE * | phoutfile | This functions specifies the output file handle.
 *
 * @parm logentry **| phead_log | This specifies the pointer to the list of
 *  log files to be processed.	The head value may be modified due to sorting,
 *  etc., by the output LogInit routine <f VenLogInit> or <f RTFLogInit>.
 *
 * @rdesc  The return value is TRUE if the operation succeds.
 *
 * @xref VenLogInit, RTFLogInit
 *
 */
int
initLogs(FILE *phoutfile, logentry **phead_log)
{
    switch(head_log->outputType)
    {
	case VENTURA:
	    VenLogInit(phoutfile, phead_log);
	    break;
	case RTFDOC:
	case RTFHELP:
	    RTFLogInit(phoutfile, phead_log);
	    break;

	default:
	    fprintf(stderr, "Unknown Output Type");
	    break;

    }
    return(TRUE);
}

/*
 * @doc INTERNAL PROCESS
 *
 * @func int |initFiles| This function is called before processing each
 *  log file.
 *
 * @parm FILE *|phoutfile| This parmameter specifies the output file.
 *
 * @parm logentry * | curlog | This is the log file containing the files
 *  to be processed.
 *
 * @rdesc The return value is TRUE if the initialization was successful.
 *
 * @comm The files are sorted by function name
 *
 * @xref VenFileInit, RTFFileInit
 *
 */
int
initFiles(FILE *phoutfile, logentry *curlog)
{
    files   curFile;
    int     i;
    files   *ptable;
    int     numFiles;

    numFiles=0;
    curFile=curlog->outheadFile;
    if(!curFile)
	goto nofiles;
	
    while(curFile)
    {
	numFiles++;
	curFile=curFile->next;
    }
    /* sort the list */


    ptable=(files *)clear_alloc( sizeof (struct s_log) * (numFiles + 1)  );

    curFile=curlog->outheadFile;
    for(i=0;i<numFiles; i++)
    {
	ptable[i]=curFile;
	curFile=curFile->next;
    }

/*   dumptable(numFiles, ptable); */

    qsort( ptable, numFiles, sizeof (files *), filecmp);

/*   dumptable(numFiles, ptable); */

    curlog->outheadFile=ptable[0];
    
    curFile=curlog->outheadFile;


    for(i=0;i<numFiles; i++)
    {
	curFile->next=ptable[i];
	curFile=curFile->next;
    }
    curFile->next=NULL;

    my_free(ptable);

nofiles:

    ////////////////////////////////////////////////////////////////
    // sort messages

    numFiles=0;
    curFile=curlog->outheadMFile;
    if(!curFile)
	goto nomessages;
	
    while(curFile)
    {
	numFiles++;
	curFile=curFile->next;
    }
    /* sort the list */


    ptable=(files *)clear_alloc( sizeof (struct s_log) * (numFiles + 1)  );

    curFile=curlog->outheadMFile;
    for(i=0;i<numFiles; i++)
    {
	ptable[i]=curFile;
	curFile=curFile->next;
    }

/*   dumptable(numFiles, ptable); */

    qsort( ptable, numFiles, sizeof (files *), filecmp);

/*   dumptable(numFiles, ptable); */

    curlog->outheadMFile=ptable[0];
    
    curFile=curlog->outheadMFile;


    for(i=0;i<numFiles; i++)
    {
	curFile->next=ptable[i];
	curFile=curFile->next;
    }
    curFile->next=NULL;

    my_free(ptable);

nomessages:



    ////////////////////////////////////////////////////////////////
    // sort structs/unions

    numFiles=0;
    curFile=curlog->outheadSUFile;
    if(!curFile)
	goto nosu;
	
    while(curFile)
    {
	numFiles++;
	curFile=curFile->next;
    }
    /* sort the list */


    ptable=(files *)clear_alloc( sizeof (struct s_log) * (numFiles + 1)  );

    curFile=curlog->outheadSUFile;
    for(i=0;i<numFiles; i++)
    {
	ptable[i]=curFile;
	curFile=curFile->next;
    }

/*   dumptable(numFiles, ptable); */

    qsort( ptable, numFiles, sizeof (files *), filecmp);

/*   dumptable(numFiles, ptable); */

    curlog->outheadSUFile=ptable[0];
    
    curFile=curlog->outheadSUFile;


    for(i=0;i<numFiles; i++)
    {
	curFile->next=ptable[i];
	curFile=curFile->next;
    }
    curFile->next=NULL;

    my_free(ptable);

nosu:



    //////////////////////////////////////////////////////////////
    // Init file/section output
    
// this is a little out of design because we now have multiple
// files (text and messages and soon structs...

    switch(outputType)
    {
	case VENTURA:
	    VenFileInit(phoutfile, curlog);
	    break;
	case RTFDOC:
	case RTFHELP:
	    RTFFileInit(phoutfile, curlog);
	    break;

	default:
	    fprintf(stderr, "Unknown Output Type");
	    break;

    }
    return(TRUE);
}

/*
 * @doc INTERNAL PROCESS
 *
 * @func void|dumptable| This is a debug function to dump the list of
 *  files.
 *
 * @parm int| numfiles | Specifies the nmber of entries in the table.
 *
 * @parm files * | ptable | Specifies the table to dump.
 *
 * @xref initFiles
 *
 */
void
dumptable(int numfiles, files * ptable)
{
    int i;
    for(i=0;i<numfiles;i++)
	fprintf(stderr, "%s\t\t%s\n",ptable[i]->name,ptable[i]->filename);
}

/*
 * @doc INTERNAL PROCESS
 *
 * @func int | filecmp | This routine is used in the qsort.  It does a
 *  case insensitive compare of the names.
 *
 * @parm files * | f1 | This is the first file to compare.
 *
 * @parm files * | f2 | This is the second file to compare.
 *
 * @rdesc The return is the same as <f strcmp>.  See <f qsort>.
 *
 * @xref qsort, strcmp, initFiles
 */
int
filecmp(files  * f1, files * f2)
{
    int order;

    order=stricmp((*f1)->name,(*f2)->name);

    return(order);

}

/*
 * @doc INTERNAL PROCESS
 *
 * @func int | processFiles | This routine processes all the files in
 *  a log file structure by calling the appropriate file output routine.
 *
 * @parm FILE * | phoutfile | This is the output file handle.
 *
 * @parm files |headFile| This is the head of the list of files to process.
 *
 * @xref VenFileProcess, RTFFileProcess
 */
int
processFiles(FILE * phoutfile, files headFile)
{

    files   curFile;

    curFile=headFile;
    while(curFile && curFile->name)
    {
if(verbose>1) fprintf(errfp,"  Copying Block %s\n",curFile->name);

	switch(outputType)
	{
	    case VENTURA:
		VenFileProcess(phoutfile, curFile);
		break;
	    case RTFDOC:
	    case RTFHELP:
		RTFFileProcess(phoutfile, curFile);
		break;

	    default:
  fprintf(stderr, "Unknown Output Type");
		break;

	}
	curFile=curFile->next;
    }

    return TRUE;
}



/*
 * @doc INTERNAL PROCESS
 *
 * @func int | parseFile | This routine parses a file structure from a log file.
 *
 * @parm FILE * | pfh | The input file handle of the log file.
 *
 * @parm files | curFile| The file structure to place the data from the file.
 *
 */
int
parseFile(FILE * pfh, files curFile)
{
    char    achbuf[80];

    if(fscanf(pfh,"%d ",&(curFile->blockType)) == EOF)
		return(FALSE);

    if(fscanf(pfh, "%s",achbuf) == EOF)
		return(FALSE);

    curFile->name=cp_alloc(achbuf);

    if(fscanf(pfh, " %s\n",achbuf) == EOF)
		return(FALSE);

    curFile->filename=cp_alloc(achbuf);

    return(TRUE);
}

/*
 * @doc INTERNAL PROCESS
 *
 * @func void | doneLogs | This function is called after all the logs
 *  in the list have been processed.
 *
 * @parm FILE *|phoutfile| Specifies the output file.
 *
 * @parm logentry * | headLog | Specifies the head of the list of log structure.
 *
 * @xref VenLogDone, RTFLogDone, cleanLogs
 *
 * @comm If the fCleanFiles flag is set, then the log files are cleaned.
 *
 */
void
doneLogs(FILE *phoutfile, logentry *headLog)
{
    switch(outputType)
    {
	case VENTURA:
	    VenLogDone(phoutfile, headLog);
	    break;
	case RTFDOC:
	case RTFHELP:
	    RTFLogDone(phoutfile, headLog);
	    break;

	default:
	    fprintf(stderr, "Unknown Output Type");
	    break;

    }

    if(fCleanFiles)
	cleanLogs(headLog);

    return;
}

/*
 * @doc INTERNAL PROCESS
 *
 * @func void | doneFiles | This function is called when all the files
 *  in the current log have been processed.
 *
 * @parm FILE *|phoutfile| Specifies the output file.
 *
 * @parm files | headFile| Specifies the list of files that have been processed.
 *
 * @xref VenFileDone, RTFFileDone
 */
void
doneFiles(FILE *phoutfile, files headFile)
{
    switch(outputType)
    {
	case VENTURA:
	    VenFileDone(phoutfile, headFile);
	    break;
	case RTFDOC:
	case RTFHELP:
	    RTFFileDone(phoutfile, headFile);
	    break;

	default:
  fprintf(stderr, "Unknown Output Type");
	    break;

    }

    return;
}

/*
 * @doc INTERNAL PROCESS
 *
 * @func int | cleanFile | This function removes all the memory and
 *  DOS files associated with the files data structure.
 *
 * @parm files | headFile| Specifies the list of files to be cleaned.
 *
 */
int
cleanFile(files headFile)
{
    files   curFile;
    files   tcurFile;

    curFile=headFile;

    while(curFile && curFile->name)
    {
	unlink(curFile->filename);
	my_free(curFile->filename);
	my_free(curFile->name);

	tcurFile=curFile->next;
	my_free(curFile);

	curFile=tcurFile;
    }

    return TRUE;

}



/*
 * @doc INTERNAL PROCESS
 *
 * @func void | copyfile | This function appends the specified file name
 *  to the specified output file.
 *
 * @parm FILE *|phoutfile| Specifies the output file.
 *
 * @parm char *| pchfilename| Specifies the input file.
 *
 */
void
copyfile(FILE *phoutfile, char *pchfilename)
{
    FILE *fpin;
    int i;
    char *pch;

    pch=findfile(pchfilename);
    if(!pch)
	return;
    fpin=fopen(pch,"r");
    if(!fpin)
	return;

    while((i=fgetc(fpin))!=EOF)
	fputc(i,phoutfile);

    fclose(fpin);

    return;


}


/*
 * @doc INTERNAL PROCESS
 *
 * @func char * | findfile | This function tries to find the specified
 *  file.  It searches directories in this order: current, PATH, INIT
 * and finally INCLUDE.
 *
 * @parm char * |pch| Specifies the filename to find.
 *
 * @rdesc This function returns a pointer to the complete file/path
 *  of the specified file.  Just the file name is returned if it is
 *  found in the current directory.  NULL is returned if the file cannot
 *  be found.
 *
 */
char *
findfile(char * pch)
{
    FILE		*fp;
    static char ach[128];
	static char *pchmode="r";

    strcpy(ach,pch);
    fp=fopen(ach, pchmode);
    if(fp)
    {
	fclose(fp);
	return(ach);
    }

    _searchenv(pch,"PATH",ach);
    fp=fopen(ach, pchmode);
    if(fp)
    {
	fclose(fp);
	return(ach);
    }

    _searchenv(pch,"INIT",ach);
    fp=fopen(ach, pchmode);
    if(fp)
    {
	fclose(fp);
	return(ach);
    }

    _searchenv(pch,"INCLUDE",ach);
    fp=fopen(ach, pchmode);
    if(fp)
    {
	fclose(fp);
	return(ach);
    }

    return(NULL);
}




/*
 * @doc INTERNAL PROCESS
 *
 * @func logentry * | add_logtoprocess | This function adds the specified
 *  log file name to the list of logs to be processed.
 *
 * @parm char * | pch| Specifies log file name to bo added.
 *
 * @rdesc The return value specifies the logentry that was created
 *  for the specified log file.
 *
 * @xref newlog
 */
logentry *
add_logtoprocess(char *pch)
{
    logentry *cur_log;
    cur_log=newlog(&head_log);
    cur_log->pchlogname=cp_alloc(pch);
    return(cur_log);

}

/*
 * @doc INTERNAL PROCESS
 *
 * @func logentry * | newlog | This function creates a new log entry
 *  in the specified list of logs.
 *
 * @parm logentry ** | start_log| Specifies the head of head of the list
 *  of logs.
 *
 * @rdesc The return value specifies the logentry that was added.
 *
 * @comm The new log structure is added at the head of the list.
 *
 */
logentry *
newlog(logentry **start_log)
{
    logentry * cur_log;
    logentry * tmp_log;

    cur_log=(logentry *)clear_alloc(sizeof(struct s_log));

    if(!*start_log)
    {
	*start_log=cur_log;
    }
    else
    {
	tmp_log=*start_log;
	while(tmp_log->next)
	    tmp_log=tmp_log->next;

	tmp_log->next=cur_log;
    }
    return(cur_log);

}

/*
 * @doc INTERNAL PROCESS
 *
 * @func fileentry * | add_filetoprocess |  This function adds an input
 *  file to process to a log structure.
 *
 * @parm char * |pch| Specifies the filename to be added.
 *
 * @parm logentry *|curlog| Specifies the log structure.
 *
 * @rdesc The return value is the new file structure that is created
 *  to hold the file entry in the log structure.
 *
 * @xref newfile
 */
fileentry *
add_filetoprocess(char *pch, logentry *curlog)
{
    fileentry *cur_file;
    cur_file=newfile(&(curlog->inheadFile));
    cur_file->filename=cp_alloc(pch);
    cur_file->logfile=curlog;
    return(cur_file);

}

/*
 * @doc INTERNAL PROCESS
 *
 * @func fileentry * | newfile | This function creates a new file entry
 *  in a list of files.  It is similar to <f newlog>.
 *
 * @parm fileentry **|start_file| Specifies the head of the list of files.
 *
 * @rdesc The return value specifies the new file structure that was created
 *  to hold the new file entry.
 *
 * @comm This routine inserts at the head of the list.
 *
 */
fileentry *
newfile(fileentry **start_file)
{
    fileentry * cur_file;
    fileentry * tmp_file;

    cur_file=(fileentry *)clear_alloc(sizeof(struct strfile));

    if(!*start_file)
    {
        *start_file=cur_file;
    }
    else
    {
	tmp_file=*start_file;
	while(tmp_file->next)
	    tmp_file=tmp_file->next;

	tmp_file->next=cur_file;
    }
    return(cur_file);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\misc.c ===
/* misc.c -  miscellanous routines
 *
 * 06/16/88 MattS	Created
 *
 * 10/15/89 MattS	Added AutoDoc comment blocks
*/

#include <stdio.h>
#include <ctype.h>
#ifdef MSDOS
#include <io.h>
#include <stdlib.h>
#endif
#include <fcntl.h>
#include <malloc.h>
#include <string.h>

#include "misc.h"

#define FALSE 0
#define TRUE 1

/*
** Compare a string with a hi-bit terminates string
*/

#ifdef NOT_NEEDED
/*
 * @doc MISC INTERNAL
 *
 * @func int | hb_strcmp | This function compares a string with a
 *  hi-bit terminated string. (instead of zero terminated)
 *
 * @parm unsigned char * | str | Zero terminated string.
 *
 * @parm unsigned char * | hb_str | High-bit terminated string.
 *
 * @rdesc The return is the same as strcmp.
 *
 */
hb_strcmp(str, hb_str)
	register unsigned char *str, *hb_str;
{
	unsigned char hbc;

	for (;;) {
		hbc = *hb_str & (unsigned char)0x7f;
		if (hbc == *str) {
			if (*++str == 0)
				return (*hb_str & 0x80) ? 0 : -1;
			else if (*hb_str++ & 0x80)
				return 1;
		} else
			return *str - hbc;
	}
}



/*
 * @doc MISC
 *
 * @func int | hex_nyb | This function converts the hex character into
 *  binary.
 *
 * @parm int | chr | The character to convert.
 *
 * @rdesc The return is the binary hex value of <p chr>.
 *
 */
int hex_nyb(chr)
	register int chr;
{
	if (chr >= '0' && chr <= '9')
		return chr - '0';
	else
		if (chr >= 'A' && chr <= 'Z')
			return chr - 'A' + 0xA;
		else
			return chr - 'a' + 0xA;
}

/*
 * @doc INTERNAL MISC
 *
 * @func int | hex_bytes | This function converts a hex string to binary.
 *
 * @parm char * | str | Specifies string to convert.
 *
 * @parm int | nbytes | Specifies length of string.
 *
 * @rdesc Returns binary value of hex string.
 *
 * @xref hex_nyb
 *
 */
int hex_bytes(str, nbytes)
	register char *str;
	register int nbytes;
{
	register int ret = 0;

	while (nbytes--) {
		ret <<= 4;
		ret += hex_nyb(*str++);
	}
	return ret;
}


/*
 * @doc INTERNAL MISC
 *
 * @func long | htoi | This function converts a hex string to a long.
 *
 * @parm char * | str | Specifies string to convert.
 *
 * @xref hex_bytes
 *
 */

/*
 * Interpret an ASCII string as a hex number, convert to long int.
 */
long htoi(str)
	char *str;
{
	register long ret = 0;
	register unsigned char ch;

	while (ch = *str++)
		if (ch >= '0' && ch <= '9')
			ret = (ret << 4) + ch - '0';
		else if (ch >= 'A' && ch <= 'Z')
			ret = (ret << 4) + ch - 'A' + 10;
		else if (ch >= 'a' && ch <= 'z')
			ret = (ret << 4) + ch - 'a' + 10;
		else return ret;
	return ret;
}

/* nindex --
 *
 */

/*
 *
 * @doc INTERNAL MISC
 *
 * @func int | nindex | looks for pattern p in string s starting at position start.
 *
 * @parm char * | p | Specifies pattern.
 *
 * @parm char * | s | Specifies string.
 *
 * @parm int | start | Specifies starting offset in string.
 *
 * @rdesc It returns an index to the position AFTER p if it succeeds; else -1.
 */
int
nindex(p,s,start)
    char p[];
    char s[];
    int start;
{
    register int j = start;
    register int i;
    int match = -1;
    int nLineLen = strlen(s);
    int nPattLen = strlen(p);

    while ( j < nLineLen )
    {
        /*find first letter of pattern
        */
        while (j < nLineLen)
        {
            if (p[0] == s[j++])
            {                       /* found 1st char of pattern */
                match = 1;          /* toggle flag */
                break;              /* go on to next step */
            }
        }

        if (match == 1)
        {
            /* look for rest of pattern
            */
            for (i = 1; (i < nPattLen) && (j < nLineLen) ; i++,j++)
            {
                if (p[i] != s[j])
                {
                    match = -1;     /* pattern doesn't match: toggle flag */
                    break;          /* stop looking */
                }
            }

            if (j >= nLineLen)      /* if we're at end, it doesn't matter */
            {
                match = -1;
                break;              /* break main loop with flag = fail */
            }
            else
            {
                if (match == 1)     /* found the pattern */
                {
                    match = j;      /* match points to char after pattern */
                    break;          /* break main loop with flag = success */
                }
            }
        }
    }

    return(match);
}



/*
 *
 * @doc INTERNAL MISC
 *
 * @func int | parse | Split of the line, point <p fl> array to each record, records are seperated by
 *  <p sep> charactor.
 *
 * @parm char * | cp | Specifies line.
 *
 * @parm char ** | fl | Specifies array of argument pointers.
 *
 * @parm char | sep | Specifies argument seperator character.
 *
 * @rdesc This function returns the number of fields it found.
 */
int
parse(cp, fl, sep)
	register char *cp, **fl, sep;
{
	register int nfields = 1;

	*fl++ = cp;
	while (1) {
		if (*cp == sep) {
			nfields++;
			*fl++ = cp + 1;
			*cp = 0;
		} else if (*cp == '\n' || *cp == '\0') {
			*cp = 0;
			return nfields;
		}
		cp++;
	}
}

/*
 *
 * Progress routines
 *
 *
 */

long pinc, ploc, loc;

/*
 *
 * @doc INTERNAL MISC
 *
 * @func void | init_progress | This function initializes the progress
 *  indicator.
 *
 * @parm long | size | Specifies the total size.
 *
 * @xref show_progress
 *
 */
void
init_progress(size)
	long size;
{
	ploc = pinc = size / 80;
	loc = 0;
}

/*
 *
 * @doc INTERNAL MISC
 *
 * @func void | show_progress | This function displays the progress
 *  according to the initialized value in <f init_progress>.
 *
 * @parm int | amount | Specifies the delta processed since last call
 *
 */
void
show_progress(int amt)
{
   if( (loc + amt) >ploc)
	{
		while( (loc + pinc) <= ploc+ amt) {
			loc+=pinc;
			fputc('.', stdout);
			fflush(stdout);
		}
		ploc += amt;
	}
}

/*
** mem_to_long and long_to_mem are used to convert back and forth between
 * the byte-order independant representation of integers and the
 * the internal C format
*/

/*
 *
 * @doc INTERNAL MISC
 *
 * @func long | mem_to_long | Used to convert back and forth between
 *  the byte-order independant representation of integers and the
 *  the internal C format.
 *
 * @parm unsigned char * |cp| Specifies the memory to convert.
 *
 * @parm short |nbytes | Specifies the number of bytes to convert.
 *
 * @rdesc This function returns the Local version of the value contained
 *  in the memory location.
 *
 * @comm This function was meant to provide byte-order independence capability
 *  in C code and was used in Microsoft Bookshelf and the Microsoft Library
 *  products.
 *
 * @xref long_to_mem
 *
 */
long
mem_to_long(cp, nbytes)
	register unsigned char *cp;
	register short nbytes;
{
	register int i;
	register long ret = 0;

	for (i = nbytes; i > 0;) {
		ret <<= 8;
		ret += cp[--i];
	}
	return ret;
}

/*
 *
 * @doc INTERNAL MISC
 *
 * @func void | long_to_mem | This function is used to convert back and forth between
 *  the byte-order independant representation of integers and the
 *  the internal C format.
 *
 * @parm long | value | Specifies the value to save into the memory.
 *
 * @parm unsigned char * |cp| Specifies the memory buffer.
 *
 * @parm short |nbytes | Specifies the number of bytes to convert.
 *
 * @comm This function was meant to provide byte-order independence capability
 *  in C code and was used in Microsoft Bookshelf and the Microsoft Library
 *  products.
 *
 * @xref mem_to_long
 *
 */
void
long_to_mem(val, cp, nbytes)
	register long val;
	register unsigned char *cp;
	register int nbytes;
{
	register int i;

	for (i = 0; i < nbytes; i++) {
		*cp++ = (unsigned char)val & (unsigned char)0xff;
		val >>= 8;
	}
}

/*
** This function is available under Sun 3.2 UNIX but not on MS-DOS so I
** had to write it in order to use the index building tools under MS-DOS
**
** getopt(argc, argv, template)
**	argc, argv are the arguments to main
**	template is a string of legal arguemnt characters.
**	if a character in the template is followed by a ':', this means
**	that the option takes an additional argument which will either be the
**	remainder of the argument string if this argument strings ended,
**	the next argument.
**
** RETURNS:
**		'?'	on error, print usage and exit
**		EOF	when end of options is hit, use "optind" to get non option args
**		chr means that option "chr" was specified and if it takes an
**			additional argument, that would be in the string "optarg"
**
** Here is an example program which just echos back how it parsed the command
** line, using getopt.  This template says the program has flags 'a' and 'b'
** and options 'c' and 'd'.  Legal commmand lines would be:
**		D>prog hello there folks
**		D>prog -a hello folks
**		D>prog -ab -chello -d there folks
**		D>prog -abc hello -dthere folks
**
**	extern char *optarg;
**	extern int optind;
**	char *my_template = "abc:d:";
**	
**	main(argc, argv)
**		char **argv;
**	{
**		int arg;
**	
**		while (arg = getopt(argv, argv, my_template))
**			if (optarg)
**				printf("-%c %s\n", arg, optarg);
**			else if (arg == '?') {
**				printf("Argument error\n");
**				break;
**			} else
**				printf("-%c\n", arg);
**		for (arg = optind; arg < argc - 1; arg++)
**			printf("### %s\n", argv[arg]);
**	}
*/


static int argNum;
static char *optparse;
int optind = 1;
char *optarg;

getopt(argc, argv, template)
	int		argc;
	char	**argv,
			*template;
{
	register char *arg, *tp;

	optarg = NULL;
	if (!optparse)
		if (++argNum < argc) {
			arg = argv[argNum];
			if (*arg != '-') {
				optind = argNum;
				return EOF;
			}
			optparse = arg + 1;
		} else
			return EOF;
	for (tp = template; *tp; tp++)
		if (*tp == *optparse) {
			if (tp[1] == ':') {
				if (optparse[1]) {
					optarg = optparse + 1;
					optparse = 0;
				} else
				if (++argNum == argc)
					return '?';
				else
					optarg = argv[argNum];
			}
			if (optparse && *++optparse == 0)
				optparse = NULL;
			return *tp;
		}
	return '?';
}

#endif

/*

/*
 *
 * @doc INTERNAL MISC
 *
 * @func int | findlshortname | This function returns the offset of the
 *  end of the complete path and file name not counting the file extension.
 *
 * @parm char * | fullname | Specifies the name to search.
 *
 * @rdesc The return value is the offset of the end of the complete path
 *  and file name not counting the file extension.
 *
 */
int
findlshortname(fullname) /* find the length of the short name */
		    /* full path/file name not counting extension */
char *fullname;
{
    char *ch;
    int cnt;

    if(!fullname || !*fullname)
	    return(0);

    cnt=strlen(fullname);
    ch=fullname+cnt;

    while(*ch!='.' && *ch!='\\' && *ch!='/' && cnt)
    {
	ch--;
	cnt--;
    }

    if(!cnt)
	return(strlen(fullname));

    return(ch - fullname);
}


/* getblong - get the next number from a buffer.  Returns a long positive
 * value if successful, otherwise returns -1.  Scans-off leading BS.
 * Parameters: takes a pointer to a char and a pointer to an int which
 * will become a pointer the character following the number.
 */
/*
 *
 * @doc INTERNAL MISC
 *
 * @func long | getblong | ATOL for buffer.
 *
 * @parm char * | line | Specifies buffer.
 *
 * @parm int * | i | Specifies current offset into buffer.  This value is
 *  updated as the buffer is scanned.
 *
 * @rdesc This function returns the Long value of the ASCII value contained
 *  in the buffer at the specified offset.
 *
 * The offset is updated to the next character after the last ASCII character.
 *
 */
long
getblong(line, i)
char *line;
int *i;
{
    int pos = *i;
    long result = 0;
    int nLineLen = strlen(line);

/*     while (!isdigit(line[pos]) && pos < nLineLen) */
/*	   ++pos; */

    if (pos == nLineLen)
        return ((long)-1);

    while (isdigit(line[pos]) && pos < nLineLen)
        result = 10 * result + line[pos++] - '0';

    *i = pos;

    return (result);
}

#ifdef NOT_NEEDED
/*
 *
 * @doc INTERNAL MISC
 *
 * @func char * | parse_sec_name | This function parses the section
 *  name from a complete name.
 *
 *  It was written for use in for Compound File indexing tools for
 *  Microsoft Library.
 *
 * @parm char ** | ppch | Specifies the name to parse.
 *
 * @rdesc Ack.
 *
 */
char *
parse_sec_name(char **ppch)
{
    char *pch;
    char *p2ch;
    int j;

    if(!ppch || !*ppch)
	return(NULL);

    pch=*ppch;

    while(*pch && *pch!='!')
	pch++;


    if(!*pch)		    /* default section name is file name */
	return(*ppch);

    *pch='\0';

    pch++;

    p2ch=*ppch;
    *ppch=pch;

    return(p2ch);
}

#endif


/*							*
 *							*
 * Memory Management routines				*
 *							*
 *							*
 *							*/

char _achmemout[]= "Oh my, we seem to be out of %smemory. %ld Allocated\n" ;

/* Generic memory management */

/*
 *
 * @doc INTERNAL MISC
 *
 * @func char * | cp_alloc | Allocates memory for the string and copies
 *  it into the buffer and returns it.
 *
 * @parm char * | pch| Specifies string to copy.
 *
 * @comm The buffer should be freed with <f my_free>.
 *
 */
char *
cp_alloc(pch)
char *pch;
{
    char *pch2;

    if(!pch)
	return(NULL);

    pch2=my_malloc(strlen(pch)+1);
    strcpy(pch2,pch);
    return pch2;
}

/*
 *
 * @doc INTERNAL MISC
 *
 * @func void | memfil | Fills the memory with zero.
 *
 * @parm int * | mem | Specifies the memory block to fill.
 *
 * @parm unsigned int | size | Specifies the size of the memory block.
 *
 * @comm The size of the memory block does not have to be a multiple of 2.
 *
 */
void
memfil(mem,size)
register int *mem;
register unsigned int size;
{
    char flag=FALSE;
    char *pch;

    if(size&1) /* it's odd so int fill won't work all the way */
    {
	flag=TRUE;
	size--;
    }

    size=size/2;
    while(size--)
	*mem++=0;

    if(flag)
    {
	pch=(char *)mem;
	*pch='\0';
    }

}

/*
 *
 * @doc INTERNAL MISC
 *
 * @func char * | clear_alloc | This function allocates memory and
 *  initialized it to zeros.
 *
 * @parm unsigned int | size | Specifies the size of the memory to allocate.
 *
 * @comm The allocated memory should be freed with <f my_free>.
 *
 */
char *
clear_alloc(size)
unsigned int size;
{
    char *pmem;

    pmem=my_malloc(size);
    memfil((int *)pmem,size);

    return pmem;
}

static long ivemalloc=0;

/*
 *
 * @doc INTERNAL MISC
 *
 * @func char * | my_malloc | Allocates memory and checks for errors.
 *
 * @parm unsigned int | size | Specifies the size of the memory to allocate.
 *
 * @comm The allocated memory should be freed with <f my_free>.
 *
 */
char *
my_malloc(size)
unsigned int size;
{
    char *pmem;
    int hck;

    if(size>32767)
    {
	fprintf(stderr,"Size >32K\n");
	exit(666);
    }
    hck=_heapchk();
    if(hck == _HEAPBADNODE)
    {
	fprintf(stderr,"Bad node in Heap.  Ack!\n");
	exit(666);
    }
    if(hck == _HEAPBADBEGIN)
    {
	fprintf(stderr,"Bad begin in Heap.  Ack!\n");
	exit(666);
    }
    pmem=(char *)malloc(size);
    if(pmem==NULL)
    {
	fprintf(stderr,_achmemout,"",ivemalloc);
	   exit(777);
    }
    ivemalloc+=size;
    return(pmem);
}


/*
 *
 * @doc INTERNAL MISC
 *
 * @func void | my_free | Frees the specified buffer.
 *
 * @parm void * | buffer | Specifies the buffe to free.
 *
 */
void
my_free(void * buffer)
{
    if(!buffer)
	return;

    ivemalloc-=_msize(buffer);
    free(buffer);
    return;

}


/* used by old indexing tools */

char *cpalloc(str)
	char *str;
{
	return(cp_alloc(str));
}



/*
 *
 * @doc INTERNAL MISC
 *
 * @func void | setmem | Sets the memory to the specified value.
 *
 * @parm char * | mem | Specifies the memory.
 *
 * @parm int | size | Specifies the size of the memory block.
 *
 * @parm char | val | Specifies the value to set the memory to.
 *
 * @comm Filling with zero is much faster with <f mem_fil>.
 *
 */
void
setmem(src, size, val)
	register char *src;
	register int size;
	register char val;
{
	while (size-- > 0)
		*src++ = val;
}

/*
 *
 * @doc INTERNAL MISC
 *
 * @func void | movmem | This function moves the specified memory.
 *  Overlap is not checked.
 *
 * @parm char * | src | Source of copy.
 *
 * @parm char * | dst | Destination of copy.
 *
 * @parm int | len |  Specifies number of bytes to copy.
 *
 */
void
movmem(src,dst,len)
	register char *src, *dst;
	register int len;
{
	while (len-- > 0)
		*dst++ = *src++;
}


#ifdef NOT_NEEDED

/* explicit NEAR memory management calls */

char near *
ncp_alloc(pch)
char near *pch;
{
    char near *pch2;

    if(!pch)
	return(NULL);

    pch2=nmy_malloc(strlen(pch)+1);
    strcpy(pch2,pch);
    return pch2;
}

void
nmemfil(mem,size)
register int near *mem;
register unsigned int size;
{
    char flag=FALSE;
    char near *pch;

    if(size&1) /* it's odd so int fill won't work all the way */
    {
	flag=TRUE;
	size--;
    }

    size=size/2;
    while(size--)
	*mem++=0;

    if(flag)
    {
	pch=(char near *)mem;
	*pch='\0';
    }

}

char near *
nclear_alloc(size)
unsigned int size;
{
    char near *pmem;

    pmem=nmy_malloc(size);
    memfil((int near*)pmem,size);

    return pmem;
}

static long ivenmalloc=0;

char near *
nmy_malloc(size)
unsigned int size;
{
    char near *pmem;

    pmem=(char near *)_nmalloc(size);
    if(pmem==NULL)
    {
	fprintf(stderr,_achmemout,"NEAR ",ivenmalloc);
	 exit(777);
    }
    ivenmalloc+=size;
    return(pmem);
}




/* used by old indexing tools */

char near *
ncpalloc(str)
char near *str;
{
	return(ncp_alloc(str));
}



void
nsetmem(src, size, val)
	register char near *src;
	register int size;
	register char val;
{
	while (size-- > 0)
		*src++ = val;
}

void
nmovmem(src,dst,len)
	register char near *src;
	register char near *dst;
	register int len;
{
	while (len-- > 0)
		*dst++ = *src++;
}






/* explicit FAR memory management calls */

char far *
fcp_alloc(pch)
char far *pch;
{
    char far *pch2;

    if(!pch)
	return(NULL);

    pch2=fmy_malloc(strlen(pch)+1);
    strcpy(pch2,pch);
    return pch2;
}

void
fmemfil(mem,size)
register int far *mem;
register unsigned int size;
{
    char flag=FALSE;
    char far *pch;

    if(size&1) /* it's odd so int fill won't work all the way */
    {
	flag=TRUE;
	size--;
    }

    size=size/2;
    while(size--)
	*mem++=0;

    if(flag)
    {
	pch=(char far *)mem;
	*pch='\0';
    }

}

char far *
fclear_alloc(size)
unsigned int size;
{
    char far *pmem;

    pmem=fmy_malloc(size);
    fmemfil((int far*)pmem,size);

    return pmem;
}

static long ivefmalloc=0;

char far *
fmy_malloc(size)
unsigned int size;
{
    char far *pmem;

    pmem=(char far *)_fmalloc(size);
    if(pmem==NULL)
    {
	fprintf(stderr,_achmemout,"FAR ",ivefmalloc);
	 exit(777);
    }
    ivefmalloc+=size;
    return(pmem);
}




/* used by old indexing tools */

char far *
fcpalloc(str)
char far *str;
{
	return(fcp_alloc(str));
}



void
fsetmem(src, size, val)
	register char far *src;
	register int size;
	register char val;
{
	while (size-- > 0)
		*src++ = val;
}

void
fmovmem(src,dst,len)
	register char far *src;
	register char far *dst;
	register int len;
{
	while (len-- > 0)
		*dst++ = *src++;
}



#endif

/*
 *
 * @doc INTERNAL MISC
 *
 * @func void | mymktemp | Make a temporary file.  The returned file name is
 *  guranteed to be unique and not already exist.
 *
 * @parm char * | lpszpath | Specifies the path to create the file.
 *
 * @parm char * | lpszbuffer | Specifies the buffer to receive the
 *  full path/file name.
 *
 *
 */
void
mymktemp(char * lpszpath, char * lpszbuffer)
{
    static int i=0;
    FILE *fp;

    sprintf(lpszbuffer,"%sdoc%05X.xxx",lpszpath,i++);
    fp=fopen(lpszbuffer,"r");
    if(!fp)
	return;

    fclose(fp);
    while(fp)
    {

	if(i>30000)
	{
 fprintf(stderr,"ERROR: Cannot create temporary files on %s.\n",lpszpath);
	    exit(1);
	}
	sprintf(lpszbuffer,"%sdoc%05X.xxx",lpszpath,i++);
	fp=fopen(lpszbuffer,"r");

	if(fp)
	    fclose(fp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\misc.h ===
extern  int hb_strcmp(unsigned char *str,unsigned char *hb_str);
extern  int hex_nyb(int chr);
extern  int hex_bytes(char *str,int nbytes);
extern  long htoi(char *str);
extern  int nindex(char *p,char *s,int start);
extern	int parse(char *cp,char * *fl,char sep);

extern  void init_progress(long size);
extern	void show_progress(int amt);

extern  long mem_to_long(unsigned char *cp,short nbytes);
extern	void long_to_mem(long val,unsigned char *cp,int nbytes);

extern  int getopt(int argc,char * *argv,char *template);
extern  int findlshortname(char *fullname);
extern  long getblong(char *line,int *i);
extern	char *parse_sec_name(char * *ppch);

extern  char *cp_alloc(char *pch);
extern  void memfil(int *mem,unsigned int size);
extern  char *clear_alloc(unsigned int size);
extern  char *my_malloc(unsigned int size);
extern	void my_free(void * buffer);
extern	char *cpalloc(char *str);
extern  void setmem(char *src,int size,char val);
extern	void movmem(char *src,char *dst,int len);

extern  char near *ncp_alloc(char near *pch);
extern  void nmemfil(int near *mem,unsigned int size);
extern  char near *nclear_alloc(unsigned int size);
extern  char near *nmy_malloc(unsigned int size);
extern  char near *ncpalloc(char near *str);
extern  void nsetmem(char near *src,int size,char val);
extern	void nmovmem(char near *src,char near *dst,int len);

extern  char far *fcp_alloc(char far *pch);
extern  void fmemfil(int far *mem,unsigned int size);
extern  char far *fclear_alloc(unsigned int size);
extern  char far *fmy_malloc(unsigned int size);
extern  char far *fcpalloc(char far *str);
extern  void fsetmem(char far *src,int size,char val);
extern  void fmovmem(char far *src,char far *dst,int len);

extern	void mymktemp(char * lpszpath, char * lpszbuffer);

#ifdef MSDOS
extern	void far crypt(char far *, int);
#else
extern	crypt(char *, int);
#endif




#define IS_BIT(f,b) ((f) & (b))

#define BIT_SET(f,b) f|=(b)

#define BIT_CLEAR(f,b) f&=~(b)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\process.h ===
/*
  Process.h
 *
 */
extern  void processLog(void );
extern  void processLogs(struct _iobuf *fpout,struct s_log *cur_log);
extern  void cleanLogs(struct s_log *cur_log);
extern  void readLog(struct s_log *cur_log);
extern  int initLogs(struct _iobuf *phoutfile,struct s_log * *phead_log);
extern  int initFiles(struct _iobuf *phoutfile,struct s_log *curlog);
extern  void dumptable(int numfiles,struct strfile * *ptable);
extern  int filecmp(struct strfile * *f1,struct strfile * *f2);
extern  int processFiles(struct _iobuf *phoutfile,struct strfile *headFile);
extern  int parseFile(struct _iobuf *pfh,struct strfile *curFile);
extern  void doneLogs(struct _iobuf *phoutfile,struct s_log *headLog);
extern  void doneFiles(struct _iobuf *phoutfile,struct strfile *headFile);
extern  int cleanFile(struct strfile *headFile);
extern  void copyfile(struct _iobuf *phoutfile,char *pchfilename);
extern  char *findfile(char *pch);
extern  struct s_log *add_logtoprocess(char *pch);
extern  struct s_log *newlog(struct s_log * *start_log);
extern  struct strfile *newfile(struct strfile * *start_file);


extern fileentry * add_filetoprocess(char *pch, logentry *curlog);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\readext.h ===
/*
    readext.h	    Read Extract database file
 */

#define T2_TYPEMASK	    0x0E0

#define T2_TYPEBLOCK	    0x000
#define T2_TYPEFUNC	    0x0E0
#define T2_TYPECB	    0x0C0
#define T2_TYPEMSG	    0x0A0
#define T2_TYPEINT	    0x080
#define T2_TYPEASM	    0x060
#define T2_TYPEASMCB	    0x040
#define T2_TYPETYPE	    0x020

// WARNING: no more bits are available for types

#define T2_HEADER	    T2_TYPEBLOCK + 0x00

#define T2_BEGINHEAD	    T2_HEADER
#define T2_EXTRACTID	    T2_HEADER
#define T2_EXTRACTVER	    T2_HEADER
#define T2_EXTRACTDATE	    T2_HEADER
#define T2_ENDHEAD	    T2_HEADER


#define T2_BEGINBLOCK	    T2_TYPEBLOCK + 0x01
#define T2_ENDBLOCK	    T2_TYPEBLOCK + 0x02
#define T2_ENDCALLBACK	    T2_TYPEBLOCK + 0x05
#define T2_DOCLEVEL	    T2_TYPEBLOCK + 0x03
#define T2_SRCLINE	    T2_TYPEBLOCK + 0x04
#define T2_BEGINHEADER	    T2_TYPEBLOCK + 0x05
#define T2_ENDHEADER	    T2_TYPEBLOCK + 0x06


#define T2_FUNCTYPE	    T2_TYPEFUNC + 0x1
#define T2_FUNCNAME	    T2_TYPEFUNC + 0x2
#define T2_FUNCDESC	    T2_TYPEFUNC + 0x3
#define T2_PARMTYPE	    T2_TYPEFUNC + 0x4
#define T2_PARMNAME	    T2_TYPEFUNC + 0x5
#define T2_PARMDESC	    T2_TYPEFUNC + 0x6
#define T2_FLAGNAMEPARM     T2_TYPEFUNC + 0x7
#define T2_FLAGDESCPARM     T2_TYPEFUNC + 0x8
#define T2_FLAGNAMERTN	    T2_TYPEFUNC + 0x9
#define T2_FLAGDESCRTN	    T2_TYPEFUNC + 0xa
#define T2_RTNDESC	    T2_TYPEFUNC + 0xb
#define T2_COMMENT	    T2_TYPEFUNC + 0xc
#define T2_XREF 	    T2_TYPEFUNC + 0xd
#define T2_USES 	    T2_TYPEFUNC + 0x17

#ifdef WARPAINT
#define T2_INTTYPE	     T2_TYPEINT   + 0x2
#define T2_INTNAME	     T2_TYPEINT   + 0x3
#define T2_INTDESC	     T2_TYPEINT   + 0x4
#define T2_INTPARMTYPE	     T2_TYPEINT   + 0x5
#define T2_INTPARMNAME	     T2_TYPEINT   + 0x6
#define T2_INTPARMDESC	     T2_TYPEINT   + 0x7
#define T2_INTFLAGNAMEPARM   T2_TYPEINT   + 0xa
#define T2_INTFLAGDESCPARM   T2_TYPEINT   + 0xb
#define T2_INTRTNDESC	     T2_TYPEINT   + 0xc
#define T2_INTFLAGNAMERTN    T2_TYPEINT   + 0x8
#define T2_INTFLAGDESCRTN    T2_TYPEINT   + 0x9
#define T2_INTCOMMENT	     T2_TYPEINT   + 0xd
#define T2_INTXREF	     T2_TYPEINT   + 0xe
#define T2_INTUSES	     T2_TYPEINT   + 0x17

#define T2_INTREGNAME	     T2_TYPEINT   + 0xf
#define T2_INTREGDESC	     T2_TYPEINT   + 0x10
#define T2_INTFLAGNAMEREGRTN T2_TYPEINT   + 0x11
#define T2_INTFLAGDESCREGRTN T2_TYPEINT   + 0x12
#define T2_INTFLAGNAMEREG    T2_TYPEINT   + 0x13
#define T2_INTFLAGDESCREG    T2_TYPEINT   + 0x14

#endif

#define T2_ASMTYPE	     T2_TYPEASM   + 0x2
#define T2_ASMNAME	     T2_TYPEASM   + 0x3
#define T2_ASMDESC	     T2_TYPEASM   + 0x4
#define T2_ASMPARMTYPE	     T2_TYPEASM   + 0x5
#define T2_ASMPARMNAME	     T2_TYPEASM   + 0x6
#define T2_ASMPARMDESC	     T2_TYPEASM   + 0x7
#define T2_ASMFLAGNAMEPARM   T2_TYPEASM   + 0xa
#define T2_ASMFLAGDESCPARM   T2_TYPEASM   + 0xb
#define T2_ASMRTNDESC	     T2_TYPEASM   + 0xc
#define T2_ASMFLAGNAMERTN    T2_TYPEASM   + 0x8
#define T2_ASMFLAGDESCRTN    T2_TYPEASM   + 0x9
#define T2_ASMCOMMENT	     T2_TYPEASM   + 0xd
#define T2_ASMXREF	     T2_TYPEASM   + 0xe
#define T2_ASMUSES	     T2_TYPEASM   + 0x17

#define T2_ASMREGNAME	     T2_TYPEASM   + 0xf
#define T2_ASMREGDESC	     T2_TYPEASM   + 0x10
#define T2_ASMFLAGNAMEREG    T2_TYPEASM   + 0x13
#define T2_ASMFLAGDESCREG    T2_TYPEASM   + 0x14

#define T2_ASMREGNAMERTN     T2_TYPEASM	+ 0x15
#define T2_ASMREGDESCRTN     T2_TYPEASM + 0x16
#define T2_ASMFLAGNAMEREGRTN T2_TYPEASM   + 0x11
#define T2_ASMFLAGDESCREGRTN T2_TYPEASM   + 0x12
#define T2_ASMCOND	     T2_TYPEASM   + 0x18


#define T2_ASMCBTYPE	     T2_TYPEASMCB + 0x2
#define T2_ASMCBNAME	     T2_TYPEASMCB + 0x3
#define T2_ASMCBDESC	     T2_TYPEASMCB + 0x4
#define T2_ASMCBPARMTYPE     T2_TYPEASMCB + 0x5
#define T2_ASMCBPARMNAME     T2_TYPEASMCB + 0x6
#define T2_ASMCBPARMDESC     T2_TYPEASMCB + 0x7
#define T2_ASMCBFLAGNAMEPARM T2_TYPEASMCB + 0xa
#define T2_ASMCBFLAGDESCPARM T2_TYPEASMCB + 0xb
#define T2_ASMCBRTNDESC	     T2_TYPEASMCB + 0xc
#define T2_ASMCBFLAGNAMERTN  T2_TYPEASMCB + 0x8
#define T2_ASMCBFLAGDESCRTN  T2_TYPEASMCB + 0x9
#define T2_ASMCBCOMMENT	     T2_TYPEASMCB + 0xd
#define T2_ASMCBXREF	     T2_TYPEASMCB + 0xe
#define T2_ASMCBUSES	     T2_TYPEASMCB + 0x17

#define T2_ASMCBREGNAME	     T2_TYPEASMCB + 0xf
#define T2_ASMCBREGDESC	     T2_TYPEASMCB + 0x10
#define T2_ASMCBFLAGNAMEREG  T2_TYPEASMCB + 0x13
#define T2_ASMCBFLAGDESCREG  T2_TYPEASMCB + 0x14

#define T2_ASMCBREGNAMERTN     T2_TYPEASMCB + 0x15
#define T2_ASMCBREGDESCRTN     T2_TYPEASMCB + 0x16
#define T2_ASMCBFLAGNAMEREGRTN T2_TYPEASMCB + 0x11
#define T2_ASMCBFLAGDESCREGRTN T2_TYPEASMCB + 0x12
#define T2_ASMCBCOND	       T2_TYPEASMCB + 0x18


#define T2_CBTYPE	    T2_TYPECB	+ 0x2
#define T2_CBNAME	    T2_TYPECB	+ 0x3
#define T2_CBDESC	    T2_TYPECB	+ 0x4
#define T2_CBPARMTYPE	    T2_TYPECB	+ 0x5
#define T2_CBPARMNAME	    T2_TYPECB	+ 0x6
#define T2_CBPARMDESC	    T2_TYPECB	+ 0x7
#define T2_CBFLAGNAMEPARM   T2_TYPECB	+ 0xa
#define T2_CBFLAGDESCPARM   T2_TYPECB	+ 0xb
#define T2_CBRTNDESC	    T2_TYPECB	+ 0xc
#define T2_CBFLAGNAMERTN    T2_TYPECB	+ 0x8
#define T2_CBFLAGDESCRTN    T2_TYPECB	+ 0x9
#define T2_CBCOMMENT	    T2_TYPECB	+ 0xd
#define T2_CBXREF	    T2_TYPECB	+ 0xe
#define T2_CBUSES	    T2_TYPECB	+ 0x17

#define T2_CBREGNAME	    T2_TYPECB	+ 0xf
#define T2_CBREGDESC	    T2_TYPECB	+ 0x10
#define T2_CBFLAGNAMEREG    T2_TYPECB	+ 0x11
#define T2_CBFLAGDESCREG    T2_TYPECB	+ 0x12


#define T2_MSGTYPE	    T2_TYPEMSG	+ 0x2
#define T2_MSGNAME	    T2_TYPEMSG	+ 0x3
#define T2_MSGDESC	    T2_TYPEMSG	+ 0x4
#define T2_MSGPARMTYPE	    T2_TYPEMSG	+ 0x5
#define T2_MSGPARMNAME	    T2_TYPEMSG	+ 0x6
#define T2_MSGPARMDESC	    T2_TYPEMSG	+ 0x7
#define T2_MSGFLAGNAMEPARM  T2_TYPEMSG	+ 0xa
#define T2_MSGFLAGDESCPARM  T2_TYPEMSG	+ 0xb
#define T2_MSGRTNDESC	    T2_TYPEMSG	+ 0xc
#define T2_MSGFLAGNAMERTN   T2_TYPEMSG	+ 0xa
#define T2_MSGFLAGDESCRTN   T2_TYPEMSG	+ 0x9
#define T2_MSGCOMMENT	    T2_TYPEMSG	+ 0xd
#define T2_MSGXREF	    T2_TYPEMSG	+ 0xe
#define T2_MSGUSES	    T2_TYPEMSG	+ 0x17

#define T2_MSGREGNAME	    T2_TYPEMSG	+ 0xf
#define T2_MSGREGDESC	    T2_TYPEMSG	+ 0x10
#define T2_MSGFLAGNAMEREG   T2_TYPEMSG	+ 0x11
#define T2_MSGFLAGDESCREG   T2_TYPEMSG	+ 0x12


// Struct Type definition
#define T2_STRUCTNAME		T2_TYPETYPE + 0x01
#define T2_STRUCTDESC		T2_TYPETYPE + 0x02
#define T2_STRUCTFIELDTYPE	T2_TYPETYPE + 0x03
#define T2_STRUCTFIELDNAME	T2_TYPETYPE + 0x04
#define T2_STRUCTFIELDDESC	T2_TYPETYPE + 0x05
#define T2_STRUCTFLAGNAME	T2_TYPETYPE + 0x06
#define T2_STRUCTFLAGDESC	T2_TYPETYPE + 0x07

#define T2_STRUCTSTRUCTNAME	T2_TYPETYPE + 0x08
#define T2_STRUCTSTRUCTDESC	T2_TYPETYPE + 0x09
#define T2_STRUCTSTRUCTEND	T2_TYPETYPE + 0x0a


#define T2_STRUCTUNIONNAME	T2_TYPETYPE + 0x0b
#define T2_STRUCTUNIONDESC	T2_TYPETYPE + 0x0c
#define T2_STRUCTUNIONEND	T2_TYPETYPE + 0x0d

#define T2_STRUCTOTHERTYPE	T2_TYPETYPE + 0x0e
#define T2_STRUCTOTHERNAME	T2_TYPETYPE + 0x0f
#define T2_STRUCTOTHERDESC	T2_TYPETYPE + 0x13

#define T2_STRUCTTAGNAME	T2_TYPETYPE + 0x10

#define T2_STRUCTCOMMENT	T2_TYPETYPE + 0x11
#define T2_STRUCTXREF		T2_TYPETYPE + 0x12



// Union Type definition
#define T2_UNIONNAME		T2_TYPETYPE + 0x13
#define T2_UNIONDESC		T2_TYPETYPE + 0x14
#define T2_UNIONSTRUCTEND	T2_TYPETYPE + 0x15
#define T2_UNIONUNIONEND	T2_TYPETYPE + 0x16

#define T2_UNIONFIELDTYPE	T2_STRUCTFIELDTYPE
#define T2_UNIONFIELDNAME	T2_STRUCTFIELDNAME
#define T2_UNIONFIELDDESC	T2_STRUCTFIELDDESC
#define T2_UNIONFLAGNAME	T2_STRUCTFLAGNAME
#define T2_UNIONFLAGDESC	T2_STRUCTFLAGDESC

#define T2_UNIONSTRUCTNAME	T2_STRUCTSTRUCTNAME
#define T2_UNIONSTRUCTDESC	T2_STRUCTSTRUCTDESC


#define T2_UNIONUNIONNAME	T2_STRUCTUNIONNAME
#define T2_UNIONUNIONDESC	T2_STRUCTUNIONDESC

#define T2_UNIONOTHERTYPE	T2_STRUCTOTHERTYPE
#define T2_UNIONOTHERNAME	T2_STRUCTOTHERNAME
#define T2_UNIONOTHERDESC	T2_STRUCTOTHERDESC

#define T2_UNIONTAGNAME		T2_STRUCTTAGNAME

#define T2_UNIONCOMMENT		T2_STRUCTCOMMENT
#define T2_UNIONXREF		T2_STRUCTXREF


/* general classifications */

#define TG_BEGINBLOCK	    0x61
#define TG_ENDBLOCK	    0x62
#define TG_DOCLEVEL	    0x63
#define TG_SRCLINE	    0x64
#define TG_BEGINHEADER	    0x65
#define TG_ENDHEADER	    0x66

#define TG_TYPE 	    0x71
#define TG_NAME 	    0x72
#define TG_DESC 	    0x73
#define TG_PARMTYPE	    0x74
#define TG_PARMNAME	    0x75
#define TG_PARMDESC	    0x76
#define TG_FLAGNAME	    0x77
#define TG_FLAGDESC	    0x78
#define TG_RTNDESC	    0x7b
#define TG_COMMENT	    0x7c
#define TG_XREF 	    0x7d
#define TG_REGNAME	    0x7e
#define TG_REGDESC	    0x7f
#define TG_USES 	    0x80
#define TG_COND		    0x81

#define TG_BEGINHEAD	    0x40
#define TG_EXTRACTID	    0x41
#define TG_EXTRACTVER	    0x42
#define TG_EXTRACTDATE	    0x43
#define TG_ENDHEAD	    0x44

#define TG_STRUCT	    0x50
#define TG_FIELDTYPE	    0x51
#define TG_FIELDNAME	    0x52
#define TG_FIELDDESC	    0x53
#define TG_UNION	    0x54
#define TG_OTHERTYPE	    0x55
#define TG_OTHERNAME	    0x55
#define TG_OTHERDESC	    0x57
#define TG_TAG		    0x5F



#define TYPE(l)   ((int)(HIWORD((unsigned long)l) & T2_TYPEMASK ))



extern  void nextText(struct _EXTFile *pExt);
extern  char *lineText(char *pch);
extern  void stripNewline(char *pch);
extern  int getLine(struct _EXTFile *pExt);
extern	DWORD getTag(struct _EXTFile *pExt);
extern	DWORD _getTag(struct _EXTFile *pExt);
extern  int initreadext(void );
extern  int processText(struct _EXTFile *pExt,struct stLine * *place);
extern  int getFlag(struct _EXTFile *pExt,struct stFlag * *flag);
extern  int getParm(struct _EXTFile *pExt,struct stParm * *parm);
extern  int getCallback(struct _EXTFile *pExt,struct stBlock *pcbBlock);
extern  int getFuncBlock(struct _EXTFile *pExt,struct stBlock *pBlock);
extern  struct stBlock *newBlock(void );
extern  int getMsgBlock(struct _EXTFile *pExt,struct stBlock *pBlock);
extern  struct stBlock *getBlock(struct _EXTFile *pExt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\readext.c ===
/*
    readext.c	    Read Extract file.


  Copyright (c) 1989, Microsoft.  All Rights Reserved.

10-09-89 Matt Saettler
10-11-89 Version 1.0
10-11-89 MHS New Extract codes
...
10-15-89 Completed Autodoc style comments.

*/

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <assert.h>
#include <search.h>
#include <io.h>
#include <direct.h>
#include <ctype.h>

#include "types.h"
#include "readext.h"
#include "text.h"
#include "docfmt.h"
#include "process.h"
#include "misc.h"
#include "rtf.h"
#include "errstr.h"

int curFieldLevel=0;

void getDocLevel(aBlock *pBlock, EXTFile *pExt);
void getSrcLine(aBlock *pBlock, EXTFile *pExt);

struct	codes_struct Codes[]=
{
// Heading level stuff

TG_BEGINBLOCK  ,   T2_BEGINBLOCK      ,    "BEGINBLOCK",       0,
TG_ENDBLOCK    ,   T2_ENDBLOCK	      ,    "ENDBLOCK",	       0,
TG_ENDBLOCK    ,   T2_ENDCALLBACK     ,    "ENDCALLBACK",      0,
TG_DOCLEVEL    ,   T2_DOCLEVEL	      ,    "DOCLEVEL",	       0,
TG_SRCLINE     ,   T2_SRCLINE	      ,    "SRCLINE",	       0,

TG_BEGINHEAD   ,   T2_BEGINHEAD       ,    "BeginHead",        0,
TG_EXTRACTID   ,   T2_EXTRACTID       ,  "ExtractID",	       0,
TG_EXTRACTVER  ,   T2_EXTRACTVER      ,  "ExtractVer",	       0,
TG_EXTRACTDATE ,   T2_EXTRACTDATE     ,  "ExtractDate",        0,
TG_ENDHEAD     ,   T2_ENDHEAD	      ,  "EndHead",	       0,

TG_BEGINHEADER ,   T2_BEGINHEADER     ,    "BeginHeader",      0,
TG_ENDHEADER   ,   T2_ENDHEADER       ,    "EndHeader",        0,

// API (function) block
TG_TYPE        ,   T2_FUNCTYPE	      ,    "ApiType",	      0,
TG_NAME        ,   T2_FUNCNAME	      ,    "ApiName",	      0,
TG_DESC        ,   T2_FUNCDESC	      ,    "ApiDesc",	      0,
TG_PARMTYPE    ,   T2_PARMTYPE	      ,    "ApiParmType",	  0,
TG_PARMNAME    ,   T2_PARMNAME	      ,    "ApiParmName",	  0,
TG_PARMDESC    ,   T2_PARMDESC	      ,    "ApiParmDesc",	  0,
TG_FLAGNAME    ,   T2_FLAGNAMEPARM    ,    "ApiFlagNameParm",	      0,
TG_FLAGDESC    ,   T2_FLAGDESCPARM    ,    "ApiFlagDescParm",	      0,

TG_FLAGNAME    ,   T2_FLAGNAMERTN     ,    "ApiFlagNameRtn",	     0,
TG_FLAGDESC    ,   T2_FLAGDESCRTN     ,    "APIFlagDescRtn",	     0,
TG_RTNDESC     ,   T2_RTNDESC	      ,    "ApiRtnDesc",	  0,
TG_COMMENT     ,   T2_COMMENT	      ,    "ApiComment",	  0,
TG_XREF        ,   T2_XREF	      ,    "ApiXref",	      0,
TG_USES        ,   T2_USES	      ,    "ApiUses",	      0,

// callback block
TG_TYPE        ,   T2_CBTYPE	      ,    "CBTYPE",	     0,
TG_NAME        ,   T2_CBNAME	      ,    "CBNAME",	     0,
TG_DESC        ,   T2_CBDESC	      ,    "CBDESC",	     0,
TG_PARMTYPE    ,   T2_CBPARMTYPE      ,    "CBPARMTYPE",	 0,
TG_PARMNAME    ,   T2_CBPARMNAME      ,    "CBPARMNAME",	 0,
TG_PARMDESC    ,   T2_CBPARMDESC      ,    "CBPARMDESC",	 0,
TG_FLAGNAME    ,   T2_CBFLAGNAMEPARM  ,    "CBFLAGNAMEPARM",	     0,
TG_FLAGDESC    ,   T2_CBFLAGDESCPARM  ,    "CBFLAGDESCPARM",	     0,
TG_RTNDESC     ,   T2_CBRTNDESC       ,    "CBRTNDESC", 	 0,
TG_FLAGNAME    ,   T2_CBFLAGNAMERTN   ,    "CBFLAGNAMERTN",	    0,
TG_FLAGDESC    ,   T2_CBFLAGDESCRTN   ,    "CBFLAGDESCRTN",	    0,
TG_COMMENT     ,   T2_CBCOMMENT       ,    "CBCOMMENT", 	 0,
TG_XREF        ,   T2_CBXREF	      ,    "CBXref",	     0,
TG_USES        ,   T2_CBUSES	      ,    "CBUses",	      0,

TG_REGNAME     ,   T2_CBREGNAME       ,    "CBRegNAME", 	0,
TG_REGDESC     ,   T2_CBREGDESC       ,    "CBRegDESC", 	0,
TG_REGNAME     ,   T2_CBFLAGNAMEREG   ,    "CBFLAGNAMEReg",	    0,
TG_REGDESC     ,   T2_CBFLAGDESCREG   ,    "CBFLAGDESCReg",	    0,

#ifdef WARPAINT
// Interrupt Block

TG_TYPE        ,   T2_INTTYPE	      ,    "INTTYPE",	      0,
TG_NAME        ,   T2_INTNAME	      ,    "INTNAME",	      0,
TG_DESC        ,   T2_INTDESC	      ,    "INTDESC",	      0,
//TG_PARMTYPE  ,   T2_INTPARMTYPE     ,    "INTPARMTYPE",	  0,
//TG_PARMNAME  ,   T2_INTPARMNAME     ,    "INTPARMNAME",	  0,
//TG_PARMDESC  ,   T2_INTPARMDESC     ,    "INTPARMDESC",	  0,
//TG_FLAGNAME  ,   T2_INTFLAGNAMEPARM ,    "INTFLAGNAMEPARM",	      0,
//TG_FLAGDESC  ,   T2_INTFLAGDESCPARM ,    "INTFLAGDESCPARM",	      0,
TG_RTNDESC     ,   T2_INTRTNDESC      ,    "INTRTNDESC",	  0,
TG_FLAGNAME    ,   T2_INTFLAGNAMERTN  ,    "INTFLAGNAMERTN",	     0,
TG_FLAGDESC    ,   T2_INTFLAGDESCRTN  ,    "INTFLAGDESCRTN",	     0,
TG_COMMENT     ,   T2_INTCOMMENT      ,    "INTCOMMENT",	  0,
TG_XREF        ,   T2_INTXREF	      ,    "INTXref",	      0,
TG_USES        ,   T2_INTUSES	      ,    "INTUses",	      0,

TG_REGNAME     ,   T2_INTREGNAME      ,    "INTRegNAME",	 0,
TG_REGDESC     ,   T2_INTREGDESC      ,    "INTRegDESC",	 0,
TG_FLAGNAME    ,   T2_INTFLAGNAMEREGRTN  ,    "INTFLAGNAMERegRtn",	   0,
TG_FLAGDESC    ,   T2_INTFLAGDESCREGRTN  ,    "IntFLAGDESCRegRtn",	   0,
TG_FLAGNAME    ,   T2_INTFLAGNAMEREG  ,    "INTFLAGNAMEReg",	     0,
TG_FLAGDESC    ,   T2_INTFLAGDESCREG  ,    "IntFLAGDESCReg",	     0,

#endif

// Asm Block
TG_TYPE        ,   T2_ASMTYPE	      ,    "ASMTYPE",	      0,
TG_NAME        ,   T2_ASMNAME	      ,    "ASMNAME",	      0,
TG_DESC        ,   T2_ASMDESC	      ,    "ASMDESC",	      0,
TG_PARMTYPE    ,   T2_ASMPARMTYPE     ,    "ASMPARMTYPE",	  0,
TG_PARMNAME    ,   T2_ASMPARMNAME     ,    "ASMPARMNAME",	  0,
TG_PARMDESC    ,   T2_ASMPARMDESC     ,    "ASMPARMDESC",	  0,
TG_FLAGNAME    ,   T2_ASMFLAGNAMEPARM ,    "ASMFLAGNAMEPARM",	      0,
TG_FLAGDESC    ,   T2_ASMFLAGDESCPARM ,    "ASMFLAGDESCPARM",	      0,
TG_RTNDESC     ,   T2_ASMRTNDESC      ,    "ASMRTNDESC",	  0,
TG_FLAGNAME    ,   T2_ASMFLAGNAMERTN  ,    "ASMFLAGNAMERTN",	     0,
TG_FLAGDESC    ,   T2_ASMFLAGDESCRTN  ,    "ASMFLAGDESCRTN",	     0,
TG_COMMENT     ,   T2_ASMCOMMENT      ,    "ASMCOMMENT",	  0,
TG_XREF        ,   T2_ASMXREF	      ,    "ASMXref",	      0,
TG_USES        ,   T2_ASMUSES	      ,    "ASMUses",	      0,

TG_REGNAME     ,   T2_ASMREGNAMERTN   ,    "ASMRegNAMERtn",	 0,
TG_REGDESC     ,   T2_ASMREGDESCRTN   ,    "ASMRegDESCRtn",	 0,
TG_REGNAME     ,   T2_ASMREGNAME      ,    "ASMRegNAME",	 0,
TG_REGDESC     ,   T2_ASMREGDESC      ,    "ASMRegDESC",	 0,
TG_FLAGNAME    ,   T2_ASMFLAGNAMEREGRTN  ,    "ASMFLAGNAMERegRtn",	   0,
TG_FLAGDESC    ,   T2_ASMFLAGDESCREGRTN  ,    "AsmFLAGDESCRegRtn",	   0,
TG_FLAGNAME    ,   T2_ASMFLAGNAMEREG  ,    "ASMFLAGNAMEReg",	     0,
TG_FLAGDESC    ,   T2_ASMFLAGDESCREG  ,    "AsmFLAGDESCReg",	     0,
TG_COND	       ,   T2_ASMCOND         ,    "AsmCond",		     0,

// Asm CallBack Block
TG_TYPE        ,   T2_ASMCBTYPE	        ,    "ASMCBTYPE",	      0,
TG_NAME        ,   T2_ASMCBNAME	        ,    "ASMCBNAME",	      0,
TG_DESC        ,   T2_ASMCBDESC	        ,    "ASMCBDESC",	      0,
TG_PARMTYPE    ,   T2_ASMPARMTYPE       ,    "ASMCBPARMTYPE",	      0,
TG_PARMNAME    ,   T2_ASMCBPARMNAME     ,    "ASMCBPARMNAME",	      0,
TG_PARMDESC    ,   T2_ASMCBPARMDESC     ,    "ASMCBPARMDESC",	      0,
TG_FLAGNAME    ,   T2_ASMCBFLAGNAMEPARM ,    "ASMCBFLAGNAMEPARM",     0,
TG_FLAGDESC    ,   T2_ASMCBFLAGDESCPARM ,    "ASMCBFLAGDESCPARM",     0,
TG_RTNDESC     ,   T2_ASMCBRTNDESC      ,    "ASMCBRTNDESC",	      0,
TG_FLAGNAME    ,   T2_ASMCBFLAGNAMERTN  ,    "ASMCBFLAGNAMERTN",      0,
TG_FLAGDESC    ,   T2_ASMCBFLAGDESCRTN  ,    "ASMCBFLAGDESCRTN",      0,
TG_COMMENT     ,   T2_ASMCBCOMMENT      ,    "ASMCBCOMMENT",	      0,
TG_XREF        ,   T2_ASMCBXREF	        ,    "ASMCBXref",	      0,
TG_USES        ,   T2_ASMCBUSES	        ,    "ASMCBUses",	      0,

TG_REGNAME     ,   T2_ASMCBREGNAMERTN   ,    "ASMCBRegNAMERtn",	      0,
TG_REGDESC     ,   T2_ASMCBREGDESCRTN   ,    "ASMCBRegDESCRtn",	      0,
TG_REGNAME     ,   T2_ASMCBREGNAME      ,    "ASMCBRegNAME",	      0,
TG_REGDESC     ,   T2_ASMCBREGDESC      ,    "ASMCBRegDESC",	      0,
TG_FLAGNAME    ,   T2_ASMCBFLAGNAMEREGRTN,   "ASMCBFLAGNAMERegRtn",   0,
TG_FLAGDESC    ,   T2_ASMCBFLAGDESCREGRTN,   "AsmCBFLAGDESCRegRtn",   0,
TG_FLAGNAME    ,   T2_ASMCBFLAGNAMEREG  ,    "ASMCBFLAGNAMEReg",      0,
TG_FLAGDESC    ,   T2_ASMCBFLAGDESCREG  ,    "AsmCBFLAGDESCReg",      0,
TG_COND	       ,   T2_ASMCBCOND         ,    "AsmCBCond", 	      0,

// Message Block
TG_TYPE        ,   T2_MSGTYPE	      ,    "MSGTYPE",	      0,
TG_NAME        ,   T2_MSGNAME	      ,    "MSGNAME",	      0,
TG_DESC        ,   T2_MSGDESC	      ,    "MSGDESC",	      0,
TG_PARMTYPE    ,   T2_MSGPARMTYPE     ,    "MSGPARMTYPE",	  0,
TG_PARMNAME    ,   T2_MSGPARMNAME     ,    "MSGPARMNAME",	  0,
TG_PARMDESC    ,   T2_MSGPARMDESC     ,    "MSGPARMDESC",	  0,
TG_FLAGNAME    ,   T2_MSGFLAGNAMEPARM ,    "MSGFLAGNAMEPARM",	      0,
TG_FLAGDESC    ,   T2_MSGFLAGDESCPARM ,    "MSGFLAGDESCPARM",	      0,
TG_RTNDESC     ,   T2_MSGRTNDESC      ,    "MSGRTNDESC",	  0,
TG_FLAGNAME    ,   T2_MSGFLAGNAMERTN  ,    "MSGFLAGNAMERTN",	     0,
TG_FLAGDESC    ,   T2_MSGFLAGDESCRTN  ,    "MSGFLAGDESCRTN",	     0,
TG_COMMENT     ,   T2_MSGCOMMENT      ,    "MSGCOMMENT",	  0,
TG_XREF        ,   T2_MSGXREF	      ,    "MsgXref",	      0,
TG_USES        ,   T2_MSGUSES	      ,    "MSGUses",	      0,

TG_REGNAME     ,   T2_MSGREGNAME      ,    "MsgRegNAME",	 0,
TG_REGDESC     ,   T2_MSGREGDESC      ,    "MsgRegDESC",	 0,
TG_FLAGNAME    ,   T2_MSGFLAGNAMEREG  ,    "MsgFLAGNAMEReg",	     0,
TG_FLAGDESC    ,   T2_MSGFLAGDESCREG  ,    "MsgFLAGDESCReg",	     0,

// Typedef struct Block
TG_NAME        ,   T2_STRUCTNAME      ,    "STRUCTNAME",	      0,
TG_DESC        ,   T2_STRUCTDESC      ,    "STRUCTDESC",	      0,
TG_FIELDTYPE   ,   T2_STRUCTFIELDTYPE    ,    "STRUCTFIELDTYPE",	  0,
TG_FIELDNAME   ,   T2_STRUCTFIELDNAME    ,    "STRUCTFIELDNAME",	  0,
TG_FIELDDESC   ,   T2_STRUCTFIELDDESC    ,    "STRUCTFIELDDESC",	  0,
TG_FLAGNAME    ,   T2_STRUCTFLAGNAME     ,    "STRUCTFLAGNAME",	      0,
TG_FLAGDESC    ,   T2_STRUCTFLAGDESC     ,    "STRUCTFLAGDESC",	      0,

TG_NAME		,  T2_STRUCTSTRUCTNAME	, "structstructName", 0,
TG_DESC		,  T2_STRUCTSTRUCTDESC	, "structstructDesc", 0,
TG_ENDBLOCK	,  T2_STRUCTSTRUCTEND	, "structstructEnd", 0,


TG_NAME		,  T2_STRUCTUNIONNAME	, "structunionName", 0,
TG_DESC		,  T2_STRUCTUNIONDESC	, "structunionDesc", 0,
TG_ENDBLOCK	,  T2_STRUCTUNIONEND	, "structunionEnd", 0,

TG_OTHERTYPE	,  T2_STRUCTOTHERTYPE	, "STRUCTOTHERTYPE", 0,
TG_OTHERNAME	,  T2_STRUCTOTHERNAME	, "STRUCTOTHERNAME", 0,
TG_OTHERDESC	,  T2_STRUCTOTHERDESC   , "structotherdesc", 0,

TG_TAG		,  T2_STRUCTTAGNAME	, "STRUCTTAGNAME", 0,

TG_COMMENT     ,   T2_STRUCTCOMMENT      ,    "STRUCTCOMMENT",	  0,
TG_XREF        ,   T2_STRUCTXREF         ,    "STRUCTXref",	      0,

// Typedef union Block
TG_NAME        ,   T2_UNIONNAME      ,    "UNIONNAME",	      0,
TG_DESC        ,   T2_UNIONDESC      ,    "UNIONDESC",	      0,
TG_FIELDTYPE   ,   T2_UNIONFIELDTYPE    ,    "UNIONFIELDTYPE",	  0,
TG_FIELDNAME   ,   T2_UNIONFIELDNAME    ,    "UNIONFIELDNAME",	  0,
TG_FIELDDESC   ,   T2_UNIONFIELDDESC    ,    "UNIONFIELDDESC",	  0,
TG_FLAGNAME    ,   T2_UNIONFLAGNAME     ,    "UNIONFLAGNAME",	      0,
TG_FLAGDESC    ,   T2_UNIONFLAGDESC     ,    "UNIONFLAGDESC",	      0,

TG_NAME		,  T2_UNIONSTRUCTNAME	, "UNIONstructName", 0,
TG_DESC 	,  T2_UNIONSTRUCTDESC	, "UNIONstructDesc", 0,
TG_ENDBLOCK	,  T2_UNIONSTRUCTEND	, "UNIONstructEnd", 0,


TG_NAME		,  T2_UNIONUNIONNAME	, "UNIONunionName", 0,
TG_DESC		,  T2_UNIONUNIONDESC	, "UNIONunionDesc", 0,
TG_ENDBLOCK	,  T2_UNIONUNIONEND	, "UNIONunionEnd", 0,

TG_OTHERTYPE	,  T2_UNIONOTHERTYPE	, "UNIONOTHERTYPE", 0,
TG_OTHERNAME	,  T2_UNIONOTHERNAME	, "UNIONOTHERNAME", 0,
TG_OTHERDESC	,  T2_UNIONOTHERDESC	, "UNIONOTHERDESC", 0,

TG_TAG		,  T2_UNIONTAGNAME	, "UNIONTAGNAME", 0,

TG_COMMENT     ,   T2_UNIONCOMMENT      ,    "UNIONCOMMENT",	  0,
TG_XREF        ,   T2_UNIONXREF         ,    "UNIONXref",	      0,

// end marker
 0		   ,	  0		  ,    0, 0
};



/*
 *	@doc INTERNAL  READEXT
 *
 *	@func char * | nextText | This updates the curlinepos for
 *   the specified Extracted file.
 *
 *	@parm EXTFile * | pExt | Specifies the Extracted structure.
 *
 */
void nextText( EXTFile *pExt )
{
    if( !pExt)
	return;

    while(  (pExt->lineBuffer[pExt->curlinepos] != '\n') &&
	    (pExt->lineBuffer[pExt->curlinepos] != '\0') &&
	     (pExt->lineBuffer[pExt->curlinepos] != '\t') &&
	      (pExt->lineBuffer[pExt->curlinepos] != ' ')   )
    {
	pExt->curlinepos++;
    }
    while(  (pExt->lineBuffer[pExt->curlinepos] != '\n') &&
	    (pExt->lineBuffer[pExt->curlinepos] != '\0') &&
	    ( (pExt->lineBuffer[pExt->curlinepos] == '\t') ||
	      (pExt->lineBuffer[pExt->curlinepos] == ' ') ) )
    {
	pExt->curlinepos++;
    }
}

/*
 *  @doc INTERNAL READEXT
 *
 *  @func DWORD | getTag | This function finds the possible tag in the
 * 	lineBuffer.
 *
 *  @rdesc The return value is the command of the tag in the line buffer.
 *	It is NULL if the tag is not found.
 *
 * @flag    loword | Uniquely identifies the tag.
 *
 * @flag    TYPE(loword) | Type of the tag.
 *
 * @flag    hiword | Group of the tag.
 *
 * @xref _getTag
 */
DWORD getTag( EXTFile *pExt )
{
    if(pExt->curtag)
	return(pExt->curtag);

    pExt->curlinepos=0;

    while( (pExt->lineBuffer[pExt->curlinepos] != '@') &&
	    (pExt->lineBuffer[pExt->curlinepos] != '\n') &&
	    (pExt->lineBuffer[pExt->curlinepos] != '\0') &&
	    ( (pExt->lineBuffer[pExt->curlinepos] == '\t') ||
	      (pExt->lineBuffer[pExt->curlinepos] == ' ') )  ) {
	pExt->curlinepos++;
    }

    if( pExt->lineBuffer[pExt->curlinepos] == '@' )
    {
	pExt->curlinepos++;
	pExt->curtag=_getTag(pExt);
	return(pExt->curtag);

    }
    else if( pExt->lineBuffer[pExt->curlinepos] == '\n' )
    {
	pExt->lineBuffer[pExt->curlinepos] = '\0';
	return( 0 );
    }
    else
	return( 0 );
}

/*
 *  @doc INTERNAL READEXT
 *
 *  @func DWORD | _getTag | This function returns the command value of the
 *   tag on the buffer.
 *
 *  @rdesc The return value is the command of the tag in the line buffer.
 *	It is NULL if the tag is not found.
 *
 * @flag    loword | Uniquely identifies the tag.
 *
 * @flag    TYPE(loword) | Type of the tag.
 *
 * @flag    hiword | Group of the tag.
 *
 */
DWORD
_getTag(EXTFile *pExt)
{
    int cur_command;

    for(cur_command=0;Codes[cur_command].pchcommand != NULL; cur_command++)
    { /* we are still comparing a valid command... */
	if(strnicmp(pExt->lineBuffer+ pExt->curlinepos,Codes[cur_command].pchcommand,Codes[cur_command].size)==0)
	{ /* we found a match */
	    pExt->curlinepos+=Codes[cur_command].size;

	    return( ( (DWORD)Codes[cur_command].icommand << 16L) +
		    ( (DWORD)Codes[cur_command].igeneral)	       );
	}
    }
    /* didn't match any known tag */
    return(0);


}

/*
 * @doc INTERNAL READEXT
 *
 * @func int | initreadext | This function is used to initialize the
 *  Read External functions.  It must be called before any of the readext
 *   functions are called.
 *
 * @rdesc This function returs TRUE if the initialization was successful.
 *
 */
int
initreadext()
{
    int cur_command;

    for(cur_command=0;Codes[cur_command].pchcommand != NULL; cur_command++)
    { /* we are still comparing a valid command... */
	Codes[cur_command].size=strlen(Codes[cur_command].pchcommand);
    }
    /* INIT OK */
    return(TRUE);
}

/*
 *	@doc INTERNAL  READEXT
 *
 *	@func int | processText | This function takes the text for the 
 *	already found tag. (starting at the given point) and puts it 
 *	into the specified place.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *	@parm aLine * | place | Specifies the place to store the text.
 *
 *	@rdesc The return value is non zero if there was an error 
 *	while processing the file.
 */
int processText( EXTFile *pExt, aLine **place )
{
    int ok;
    aLine * line;

    if( place == NULL )
    {
	return( ST_ERROR );
    }

    /* if we have more text on line left place into
       aLine
     */
    if( pExt->lineBuffer[pExt->curlinepos])
    {
	line = lineMake( pExt->lineBuffer + pExt->curlinepos );
	if( line == NULL )
	{
	    return( ST_MEMORY );
	}
	lineAdd( place, line );
    }

    /* get rest of text for this tag. */
    ok = getLine(pExt);
    while( ok && ( !getTag(pExt) ) )
    {
	line = lineMake( pExt->lineBuffer );
	if( line == NULL )
	{
	    return( ST_MEMORY );
	}
	lineAdd( place, line );
	ok = getLine( pExt );
    }
    if( !ok )
	return( ST_ERROR_EOF );
    else
	return( 0 );
}

/*
 *	@doc INTERNAL  READEXT
 *
 *	@func char * | getFlag | This function gets a list of Flag blocks
 *	from the file. The flag blocks are stored in the list.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *  @parm aFlag * * | flag | Specifies the head of the list to place
 *   the list of flags.
 *
 *	@rdesc The return value is non zero if there was an error 
 *	while processing the file.
 */
int getFlag( EXTFile *pExt, aFlag * * flag )
{
    int rtn;
    int ok, nStatus;
    char * text;
    char * tag;
    int itag;
    int startType;
    DWORD dTag;
    aFlag *curFlag;
    aFlag *tFlag;

    if( flag == NULL )
	    return( ST_ERROR );

    /* find begin of flag */
    itag=(int)getTag(pExt);
    startType=TYPE(itag);
    if( itag != TG_FLAGNAME  )
	return( ST_BADOBJ );

    curFlag=flagAlloc();
    if( curFlag == NULL )
	return( ST_MEMORY );

    if(!*flag)
	*flag =curFlag;
    else
    {
	tFlag=*flag;
	while(tFlag->next)
	{
	    tFlag=tFlag->next;
	}
	tFlag->next=curFlag;
    }

    nStatus = processText( pExt, &((curFlag)->name) );
    if( nStatus)
	    return( nStatus );

    /* find desc of flag */
    itag=(int)getTag(pExt);
    if( itag == TG_FLAGDESC )
    {
	nStatus = processText( pExt, &((curFlag)->desc) );
	if( nStatus)
	    return( nStatus );
    }

    return( 0 );
}

/*
 *	@doc INTERNAL  READEXT
 *
 *	@func char * | getField | This function gets a list of Field blocks
 *	from the file. The blocks are stored in the list.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *  @parm aField * * | field | Specifies the head of the list to place
 *   the list of fields.
 *
 *	@rdesc The return value is non zero if there was an error 
 *	while processing the file.
 */
int getSUType( EXTFile *pExt, aField * * field )
{
    int rtn;
    int ok, nStatus;
//    char * text;
//    char * tag;
    int itag;
//    int startType;
    DWORD dTag;
    aField *curfield;
    aField *tfield;
    aType *curtype;

    if( field == NULL )
	    return( ST_ERROR );

    /* find begin of flag */
    itag=(int)getTag(pExt);
//    startType=TYPE(itag);
    
    
    if( itag != TG_FIELDTYPE  )
	return( ST_BADOBJ );

    curfield=fieldAlloc();
    if( curfield == NULL )
	return( ST_MEMORY );

    
    if(!*field)
	*field =curfield;
    else
    {
	tfield=*field;
	while(tfield->next)
	{
	    tfield=tfield->next;
	}
	tfield->next=curfield;
    }

    curfield->wType=FIELD_TYPE;
    curtype=typeAlloc();
    if(curtype == NULL)
	return (ST_MEMORY);
	
    curtype->level=curFieldLevel;
    curfield->ptr=(void *)curtype;
    
    nStatus = processText( pExt, &((curtype)->type) );
    if( nStatus)
	    return( nStatus );
	    
    /* find name of field */
    itag=(int)getTag(pExt);
    if( itag == TG_FIELDNAME )
    {
	nStatus = processText( pExt, &((curtype)->name) );
	if( nStatus)
	    return( nStatus );
    }
    else
	return( ST_BADOBJ );

    /* find desc of field */
    itag=(int)getTag(pExt);
    if( itag == TG_FIELDDESC )
    {
	nStatus = processText( pExt, &((curtype)->desc) );
	if( nStatus)
	    return( nStatus );
    }
    else
	return( ST_BADOBJ );

    /* process flags and other info */
    nStatus = 0;
    itag=(int)getTag(pExt);
    while( (nStatus == 0) &&
	   ( itag == TG_FLAGNAME) )
    {
	nStatus = getFlag( pExt, &((curtype)->flag) );
	if( nStatus )
	    return( nStatus );

	itag=(int)getTag(pExt);
    }

    return(nStatus);


}


/*
 *	@doc INTERNAL READEXT
 *
 *	@func char * | getReg | This function gets a list of register blocks
 *	from the file.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *  @parm aReg ** | reg | Specifies the head of the list of reg blocks
 *   to save.
 *
 *	@rdesc The return value is non zero if there was an error
 *	while processing the file.
 */
int getReg( EXTFile *pExt, aReg * * reg )
{
    int nStatus;
    aFlag * flag;
    aReg * curreg;
    int itag;
    int startType;


    assert(reg);
    assert(pExt);

    /* find name of parameter */

    itag=(int)getTag(pExt);
    startType=TYPE((DWORD)itag);

    if( itag != TG_REGNAME )
    {
fprintf(errfp,"Error: Tag not regname at line %d in %s\n",
			    pExt->curlineno,
			    pExt->EXTFilename);
	return( ST_BADOBJ );
    }

    curreg = regAlloc();
    if( curreg == NULL )
	return( ST_MEMORY );

    regAdd(reg, curreg);

//    itag = (int)getTag(pExt);
    if( itag == TG_REGNAME)
    {
	nStatus = processText( pExt, &((curreg)->name) );
	if( nStatus )
	    return( nStatus );
    }
    else
	assert(TRUE);	    // what are we doing here?

    /* find desc of parameter */
    itag = (int)getTag(pExt);
    if(  itag == TG_REGDESC )
    {
	nStatus = processText( pExt, &((curreg)->desc) );
	if( nStatus )
	    return( nStatus );
    }
    else
 fprintf(errfp,"Warning: Register without Description at line %d in %s\n",
			    pExt->curlineno,
			    pExt->EXTFilename);

    /* process flags and other info */
    nStatus = 0;
    itag=(int)getTag(pExt);
    while( (nStatus == 0) &&
	   ( itag == TG_FLAGNAME) )
    {
	nStatus = getFlag( pExt, &((curreg)->flag) );
	if( nStatus )
	    return( nStatus );

	itag=(int)getTag(pExt);
    }

    return(nStatus);
	
}

/*
 *	@doc INTERNAL READEXT
 *
 *	@func char * | getCond | This function gets a Conditional block
 *	from the file.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *  @parm aCond ** | ppCond | Specifies the head of the list of Cond blocks
 *   to save.
 *
 *	@rdesc The return value is non zero if there was an error
 *	while processing the file.
 */
int getCond( EXTFile *pExt, aCond * * ppCond )
{
    int nStatus;
    aFlag * flag;
    aCond * curcond;
//    aReg * curreg;
    int itag;
    int startType;


    assert(ppCond);
    assert(pExt);

    /* find name of parameter */

    itag=(int)getTag(pExt);
    startType=TYPE((DWORD)itag);

    if( itag != TG_COND )
    {
fprintf(errfp,"Error: Tag not Cond at line %d in %s\n",
			    pExt->curlineno,
			    pExt->EXTFilename);
	return( ST_BADOBJ );
    }

    curcond= condAlloc();
    if( curcond == NULL )
	return( ST_MEMORY );

    condAdd(ppCond, curcond);

//    itag = (int)getTag(pExt);
    if( itag == TG_COND)
    {
	nextText( pExt );
	nStatus = processText( pExt, &((curcond)->desc) );
	if( nStatus )
	    return( nStatus );
    }
    else
	assert(TRUE);	    // what are we doing here?

    /* process regs and other info */
    nStatus = 0;
    itag=(int)getTag(pExt);
    while( (nStatus == 0) &&
	   ( itag == TG_REGNAME) )
    {
	nStatus = getReg( pExt, &((curcond)->regs) );
	if( nStatus )
	    return( nStatus );

	itag=(int)getTag(pExt);
    }

    return(nStatus);
	
}

/*
 *	@doc INTERNAL READEXT
 *
 *	@func char * | getParm | This function gets a list of parameter blocks
 *	from the file.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *  @parm aParm ** | parm | Specifies the head of the list.
 *
 *	@rdesc The return value is non zero if there was an error
 *	while processing the file.
 */
int getParm( EXTFile *pExt, aParm * * parm )
{
    int nStatus;
    aFlag * flag;
    aParm * curparm;
    int itag;
    int startType;

    assert(parm);
    assert(pExt);

    /* find name of parameter */

    itag=(int)getTag(pExt);
    startType=TYPE((DWORD)itag);

    if( itag != TG_PARMTYPE )
	return( ST_BADOBJ );

    curparm = parmAlloc();
    if( curparm == NULL )
	return( ST_MEMORY );

    parmAdd(parm, curparm);

    /* find type of parameter */
    if( itag == TG_PARMTYPE )
    {
	nStatus = processText( pExt, &((curparm)->type) );
	if( nStatus )
	    return( nStatus );
    }

    itag = (int)getTag(pExt);
    if( itag == TG_PARMNAME)
    {
	nStatus = processText( pExt, &((curparm)->name) );
	if( nStatus )
	    return( nStatus );
    }

    /* find desc of parameter */
    itag = (int)getTag(pExt);
    if(  itag == TG_PARMDESC )
    {
	nStatus = processText( pExt, &((curparm)->desc) );
	if( nStatus )
	    return( nStatus );
    }

    /* process flags and other info */
    nStatus = 0;
    itag=(int)getTag(pExt);
    while( (nStatus == 0) &&
	   ( itag == TG_FLAGNAME) )
    {
	nStatus = getFlag( pExt, &((curparm)->flag) );
	if( nStatus )
	    return( nStatus );

	itag=(int)getTag(pExt);
    }

    return(nStatus);
	
}


/*
 *	@doc INTERNAL READEXT
 *
 *	@func char * | getParm | This function gets a list of parameter blocks
 *	from the file.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *  @parm aParm ** | parm | Specifies the head of the list.
 *
 *	@rdesc The return value is non zero if there was an error
 *	while processing the file.
 */
int getOther( EXTFile *pExt, aOther * * other )
{
    int nStatus;
    aOther * curother;
    int itag;
    int startType;

    assert(other);
    assert(pExt);

    /* find name of parameter */

    itag=(int)getTag(pExt);
    startType=TYPE((DWORD)itag);

    if( itag != TG_OTHERTYPE )
	return( ST_BADOBJ );

    curother = otherAlloc();
    if( curother == NULL )
	return( ST_MEMORY );

    otherAdd(other, curother);

    /* find type of other */
	nStatus = processText( pExt, &((curother)->type) );
	if( nStatus )
	    return( nStatus );

    itag = (int)getTag(pExt);
	nStatus = processText( pExt, &((curother)->name) );
	if( nStatus )
	    return( nStatus );


    /* find [optional] desc of other */
    itag = (int)getTag(pExt);
    if(  itag == TG_OTHERDESC )
    {
	nStatus = processText( pExt, &((curother)->desc) );
	if( nStatus )
	    return( nStatus );
    }

    return(nStatus);
	
}


/*
 *	@doc INTERNAL READEXT
 *
 *	@func char * | getSU | This function gets a list of SU blocks
 *	from the file.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *  @parm aField * * | pField | Specifies the head of the list.
 *
 *	@rdesc The return value is non zero if there was an error
 *	while processing the file.
 */
int getSU(EXTFile *pExt, aField **field)
{
    int rtn;
    int ok, nStatus;
//    char * text;
//    char * tag;
    int itag;
//    int startType;
    DWORD dtag;
    aField *curfield;
    aField *tfield;
    aSU *curSU;
    int startType;

    if( field == NULL )
	    return( ST_ERROR );

    curfield=fieldAlloc();
    if( curfield == NULL )
	return( ST_MEMORY );

    if(!*field)
	*field =curfield;
    else
    {
	tfield=*field;
	while(tfield->next)
	{
	    tfield=tfield->next;
	}
	tfield->next=curfield;
    }

   /* find begin of SU block */
    dtag=getTag(pExt);

    // since struct and union prefixes are the same, we only need to
    // check for combo each ( ss, su, us, uu)
    if(HIWORD(dtag) == T2_UNIONUNIONNAME)
	curfield->wType=FIELD_UNION;
    else if(HIWORD(dtag) == T2_STRUCTSTRUCTNAME)
	curfield->wType=FIELD_STRUCT;
    else
    {
fprintf(errfp, "Unrecognized block type in getSU().\n");
fprintf(errfp,"Line %d. File %s\n",pExt->curlineno,pExt->EXTFilename);
    }

    curSU=SUAlloc();
    if(curSU == NULL)
	return (ST_MEMORY);
	
   
    curSU->level=curFieldLevel;
    curfield->ptr=(void *)curSU;
    
    nStatus = processText( pExt, &((curSU)->name) );
    if( nStatus)
	    return( nStatus );
	    

    /* find [optional] desc of SU */
    itag=(int)getTag(pExt);
    if( itag == TG_DESC )
    {
	nStatus = processText( pExt, &((curSU)->desc) );
	if( nStatus)
	    return( nStatus );
    }

    /* process parms and other info */
    nStatus = 0;
    while( (nStatus == 0) )
    {

	itag=(int)getTag(pExt);
	if(itag==TG_ENDBLOCK)
	{
	    // this is a nested thing, so eat ENDBLOCK
	    getLine(pExt);
	    break;
	}

	switch(itag)
	{
	    case TG_FIELDTYPE:
		{
		    nStatus = getSUType(pExt,  &(curSU->field) );
		    if( nStatus )
			return( nStatus );
		}
		break;

	    case TG_NAME:
		{
		    /* handles multiple parms */
		    curFieldLevel++;
		    nStatus = getSU(pExt,  &(curSU->field) );
		    curFieldLevel--;
		    if( nStatus )
			return( nStatus );
		}
		break;
	    default:
      fprintf(errfp,"Unrecognized Tag on line %d\n%s",
		     pExt->curlineno,
		     pExt->lineBuffer
		    );
                nStatus = ST_BADOBJ;
           }

    }

    return( nStatus );
   
}

/*
 *	@doc INTERNAL READEXT
 *
 *	@func char * | getSUBlock | This function gets a list of SU blocks
 *	from the file.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *  @parm aBlock * | pBlock | Specifies the head of the list.
 *
 *	@rdesc The return value is non zero if there was an error
 *	while processing the file.
 */
int getSUBlock(EXTFile *pExt, aBlock *pBlock)
{
    int ok, nStatus;
    int itag;
    DWORD dtag;
    int startType;
    int fendRtn;
    aBlock *pB2;

    /* find begin of function */
    dtag=getTag(pExt);
    startType=TYPE(dtag);

    if( HIWORD(dtag) == T2_STRUCTNAME )
    {
	pBlock->blockType=STRUCTBLOCK;
    }
    else if( HIWORD(dtag) == T2_UNIONNAME	)
    {
	pBlock->blockType=UNIONBLOCK;
    }
    else
    {
fprintf(errfp, "Unrecognized block type in getSUBlock().\n");
fprintf(errfp,"Line %d. File %s\n",pExt->curlineno,pExt->EXTFilename);
	return( ST_BADOBJ );
    }

    /* find name of function */
    itag=(int)getTag(pExt);
    if( itag == TG_NAME )
    {
	nStatus = processText( pExt, &( pBlock->name) );
	if( nStatus )
		return( nStatus );
	if(verbose>1)
	    fprintf(errfp, "%-30s",pBlock->name->text);
    }

    /* find description of function */
    itag=(int)getTag(pExt);
    if( itag == TG_DESC )
    {
	nStatus = processText( pExt, &( pBlock->desc) );
	if( nStatus )
	    return( nStatus );
    }

    /* process parms and other info */
    nStatus = 0;
    while( (nStatus == 0) )
    {

	itag=(int)getTag(pExt);
	if(itag==TG_ENDBLOCK)
	    break;

	switch(itag)
	{
	    case TG_FIELDTYPE:
		{
		    nStatus = getSUType(pExt,  &(pBlock->field) );
		    if( nStatus )
			return( nStatus );
		}
		break;

	    case TG_NAME:
		{
		    curFieldLevel++;
		    /* handles multiple parms */
		    nStatus = getSU(pExt,  &(pBlock->field) );
		    curFieldLevel--;
		    if( nStatus )
			return( nStatus );
		}
		break;

	    case TG_OTHERTYPE:
		{
		    /* handles multiple parms */
		    nStatus = getOther(pExt,  &(pBlock->other) );
		    if( nStatus )
			return( nStatus );
		}
		break;

	    case TG_TAG:
                {
                    nextText( pExt );
		    nStatus = processText( pExt, &(pBlock->tagname) );
                    if( nStatus )
                        return( nStatus );

                }
                break;
	    case TG_COMMENT:
                {
                    nextText( pExt );
		    nStatus = processText( pExt, &(pBlock->comment) );
                    if( nStatus )
                        return( nStatus );

                }
                break;
	    case TG_XREF:
                {
                    nextText( pExt );
		    nStatus = processText( pExt, &(pBlock->xref) );
                    if( nStatus )
                        return( nStatus );

                }
                break;
	    default:
      fprintf(errfp,"Unrecognized Tag on line %d\n%s",
		     pExt->curlineno,
		     pExt->lineBuffer
		    );
                nStatus = ST_BADOBJ;
           }

    }

    return( nStatus );
}

/*
 *	@doc INTERNAL READEXT
 *
 *	@func char * | getFuncBlock | This function gets a list of function blocks
 *	from the file.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *  @parm aBlock * | pBlock | Specifies the head of the list.
 *
 *	@rdesc The return value is non zero if there was an error
 *	while processing the file.
 */
int getFuncBlock(EXTFile *pExt, aBlock *pBlock)
{
    int ok, nStatus;
    int itag;
    DWORD dtag;
    int startType;
    int fendRtn;
    aBlock *pB2;

    /* find begin of function */
    dtag=getTag(pExt);
    startType=TYPE(dtag);

    if( HIWORD(dtag) == T2_FUNCTYPE )
    {
	pBlock->blockType=FUNCTION;
    }
    else if( HIWORD(dtag) == T2_CBTYPE	)
    {
	pBlock->blockType=CALLBACK;
    }
    else if( HIWORD(dtag) == T2_MSGNAME )
    {
	pBlock->blockType=MESSAGE;
    }
#ifdef WARPAINT
    else if( HIWORD(dtag) == T2_INTNAME )
    {
	pBlock->blockType=INTBLOCK;
    }
#endif
    else if( HIWORD(dtag) == T2_ASMNAME )
    {
	pBlock->blockType=MASMBLOCK;
    }
    else if( HIWORD(dtag) == T2_ASMCBNAME )
    {
	pBlock->blockType=MASMCBBLOCK;
    }
    else
    {
fprintf(errfp, "Unrecognized block type in getFuncBlock().\n");
fprintf(errfp,"Line %d. File %s\n",pExt->curlineno,pExt->EXTFilename);
	return( ST_BADOBJ );
    }

    /* find type of function */
    itag=(int)getTag(pExt);
    if( itag == TG_TYPE )
    {
	nStatus = processText( pExt, &( pBlock->type) );
	if( nStatus )
	    return( nStatus );
    }

    /* find name of function */
    itag=(int)getTag(pExt);
    if( itag == TG_NAME )
    {
	nStatus = processText( pExt, &( pBlock->name) );
	if( nStatus )
		return( nStatus );
	if(verbose>1)
	    fprintf(errfp, "%-30s",pBlock->name->text);
    }

    /* find description of function */
    itag=(int)getTag(pExt);
    if( itag == TG_DESC )
    {
	nStatus = processText( pExt, &( pBlock->desc) );
	if( nStatus )
	    return( nStatus );
    }

    /* process parms and other info */
    nStatus = 0;
    while( (nStatus == 0) )
    {
//	itag=TYPE(getTag(pExt));
//	if(itag != startType || itag == T2_TYPEBLOCK )
//	    break;

	itag=(int)getTag(pExt);
	if(itag==TG_ENDBLOCK)
	    break;

	switch(itag)
	{
	    case TG_REGNAME:
		{
		    assert(!pBlock->rtndesc);

		    /* handles multiple regss */
		    nStatus = getReg(pExt,  &(pBlock->reg) );
		    if( nStatus )
			return( nStatus );
		}
		break;

	    case TG_PARMTYPE:
		{
		    assert(!pBlock->rtndesc);

		    /* handles multiple parms */
		    nStatus = getParm(pExt,  &(pBlock->parm) );
		    if( nStatus )
			return( nStatus );
		}
		break;

	    case TG_RTNDESC:
		{
/* does'nt handle multiple return desc */

//		    assert(!pBlock->rtndesc);

		    nextText( pExt );
		    nStatus = processText( pExt, &( pBlock->rtndesc) );
		    if( nStatus )
			return( nStatus );

		    fendRtn=FALSE;
		    while(!fendRtn)
		    {
			itag=(int)getTag(pExt);
			switch(itag)
			{
			    case TG_FLAGNAME:
				/* handles multiple flags */
#if 0				
				if(pBlock->blockType==MASMBLOCK || 
				    pBlock->blockType == INTBLOCK
				    )
{
fprintf(errfp,"Warning: Return flags in return block.  Not allowed in this block type.\n");
fprintf(errfp,"Line %d. File %s\n",pExt->curlineno,pExt->EXTFilename);
}
#endif 
				nStatus = getFlag( pExt, &(pBlock->rtnflag) );
				if( nStatus )
				    return( nStatus );
				break;
			    case TG_REGNAME:
				/* handles multiple regss */
#if 0
				if(pBlock->blockType==MASMBLOCK || 
				    pBlock->blockType == INTBLOCK
				    )
{
fprintf(errfp,"Warning: Register in return block.  Not allowed in this block type.\n");
fprintf(errfp,"Line %d. File %s\n",pExt->curlineno,pExt->EXTFilename);
}
#endif
				nStatus = getReg(pExt,	&(pBlock->rtnreg) );
				if( nStatus )
				    return( nStatus );
				break;
			    default:
				fendRtn=TRUE;
				break;

			} // switch
		    } // while
		} // Return
		break;
	    case TG_COMMENT:
                {
                    nextText( pExt );
		    nStatus = processText( pExt, &(pBlock->comment) );
                    if( nStatus )
                        return( nStatus );

                }
                break;
	    case TG_COND:
                {
		    nStatus = getCond( pExt, &(pBlock->cond) );
                    if( nStatus )
                        return( nStatus );
                }
                break;
	    case TG_USES:
                {
                    nextText( pExt );
		    nStatus = processText( pExt, &(pBlock->uses) );
                    if( nStatus )
                        return( nStatus );
                }
                break;
	    case TG_XREF:
                {
                    nextText( pExt );
		    nStatus = processText( pExt, &(pBlock->xref) );
                    if( nStatus )
                        return( nStatus );

                }
                break;
	    case TG_NAME:
	    case TG_TYPE:
		{
	     /* check to make sure CB and not FUNC or MSG */
		    pB2=newBlock();
		    pB2->blockType=CALLBACK;

if(verbose>1) fprintf(errfp,"\nCallback: ");
		    nStatus = getFuncBlock( pExt , pB2);
		    if(!pBlock->cb)	/* head */
			pBlock->cb=pB2;
		    else
		    {	/* insert at head */
			pB2->next=pBlock->cb;
			pBlock->cb=pB2;
		    }
		    if(nStatus )
			return(nStatus);

		    /* eat end line */
		    getLine(pExt);

                }
                break;
	    default:
      fprintf(errfp,"Unrecognized Tag on line %d\n%s",
		     pExt->curlineno,
		     pExt->lineBuffer
		    );
                nStatus = ST_BADOBJ;
           }

    }

    return( nStatus );
}

/*
 * @doc INTERNAL READEXT
 *
 * @func aBlock * | newBlock | This function allocates a new Block
 *
 */
aBlock *
newBlock()
{
    aBlock *pBlock;
    pBlock=(aBlock *)clear_alloc(sizeof (aBlock));
    return(pBlock);

}

#if 0
/*
 * @doc INTERNAL READEXT
 *
 * @func aBlock * | newBlock | This function allocates a new Block
 *
 */
void
freeBlock(aBlock * pBlock)
{
    assert(pBlock);
    if(pBlock->srcfile)
	my_free(pBlock->srcfile);
	
    if(pBlock->doclevel)
	lineDestroy(pBlock->doclevel);
	
    if(pBlock->name)
	lineDestroy(pBlock->name);
	
    if(pBlock->type)
	lineDestroy(pBlock->type);
	
    if(pBlock->desc)
	lineDestroy(pBlock->desc);
	
    if(pBlock->parm)
	parmDestroy(pBlock->parm);
	
    if(pBlock->reg)
	regDestroy(pBlock->reg);
	
    if(pBlock->rtndesc)
	lineDestroy(pBlock->rtndesc);
	
    if(pBlock->rtnflag)
	flagDestroy(pBlock->rtnflag);
	
    if(pBlock->rtnreg)
	regDestroy(pBlock->rtnreg);
	
    if(pBlock->cond)
	condDestroy(pBlock->cond);
	
    if(pBlock->comment)
	lineDestroy(pBlock->comment);
	
    if(pBlock->cb)
	freeBlock(pBlock->cb);
	
    if(pBlock->xref)
	lineDestroy(pBlock->xref);
	
    if(pBlock->uses)
	lineDestroy(pBlock->uses);
	
    return;

}
#endif

/*
 *	@doc INTERNAL READEXT
 *
 *	@func aBlock * | getBlock | This function gets a block of documentation
 *	from the file.
 *
 *  @parm EXTFile * | pExt | Specifies the Extracted file to process.
 *
 *	@rdesc The return value is the block from the file or NULL if an error
 *	occured while processing the file.
 */
aBlock * getBlock(EXTFile * pExt)
{
    int ok, nStatus;
    int itag;
    aBlock *pcurBlock;

    /* find begin of block */
    ok = TRUE;
    while( ok && ((int)getTag(pExt) != TG_BEGINBLOCK ))
	    ok = getLine(pExt);

    if( !ok )
        return( NULL );

    pcurBlock=newBlock();

    /* get to next tag. */
    ok = getLine(pExt );
    while( ok && ( !getTag(pExt) ) )
        ok = getLine( pExt );

    if( !ok )
	return( NULL );


    itag=(int)getTag(pExt);

    if(itag == TG_DOCLEVEL)	     /* set doclevel */
    {
	getDocLevel(pcurBlock, pExt);
	itag=(int)getTag(pExt);
    }


    if(itag == TG_SRCLINE)	     /* set source file, line */
    {
	getSrcLine(pcurBlock, pExt);
	itag=(int)getTag(pExt);
    }

    itag=HIWORD(getTag(pExt));
    switch(itag)
    {
	case T2_STRUCTNAME:
	case T2_UNIONNAME:
            {
                nStatus = getSUBlock(pExt, pcurBlock );
            }
	    break;
	    
	case T2_FUNCTYPE:
        case T2_FUNCNAME:
            {
                pcurBlock->blockType = FUNCTION;
                nStatus = getFuncBlock(pExt, pcurBlock );
            }
	    break;

	case T2_MSGTYPE:
	case T2_MSGNAME:

            {
                pcurBlock->blockType = MESSAGE;
                nStatus = getFuncBlock(pExt, pcurBlock );
            }
	    break;
#ifdef WARPAINT	    
	case T2_INTTYPE:
	case T2_INTNAME:
	    {
		pcurBlock->blockType = INTBLOCK;
                nStatus = getFuncBlock(pExt, pcurBlock );
            }
	    break;
#endif	    
	case T2_ASMTYPE:
	case T2_ASMNAME:
	    {
		pcurBlock->blockType = MASMBLOCK;
                nStatus = getFuncBlock(pExt, pcurBlock );
            }
	    break;
	case T2_ASMCBTYPE:
	case T2_ASMCBNAME:
	    {
		pcurBlock->blockType = MASMCBBLOCK;
                nStatus = getFuncBlock(pExt, pcurBlock );
            }
	    break;
	default:

	    {
	fprintf(errfp,"Unrecognized Block Tag at line %d of %s\n",
			    pExt->curlineno,
			    pExt->EXTFilename);
		pcurBlock->blockType = 0;
                nStatus = ST_BADOBJ;
            }
            break;
    }
    /* eat text until end block */
    ok = TRUE;
    while( ok && ((int)getTag(pExt) != TG_ENDBLOCK ))
    {
  fprintf(errfp,"Warning: unexpected tags before end of block at line %d of %s\n",
			    pExt->curlineno,
			    pExt->EXTFilename);
	ok = getLine(pExt);
    }

    /* read past end block */
    ok = getLine(pExt);

    if( nStatus == 0 )
    {
        ok = TRUE;
    }
    else if( nStatus == ST_BADOBJ )
    {
	error(WARN2, pExt->EXTFilename, pExt->curlineno );
        nStatus = 0;
        ok = TRUE;
    }
    else
        return( NULL );

    return(pcurBlock);

}

/*
 * @doc INTERNAL READEXT
 *
 * @func void | getDocLevel | This function parses the DOCLEVEL extract tag
 *  and fills in the information in the block.
 *
 * @parm aBlock * | pBlock | Specifies the block.
 *
 * @parm EXTFile *| pExt | Specifies the Extracted file.
 *
 */

void getDocLevel(aBlock *pBlock, EXTFile *pExt)
{
    aLine *pLine;
    char *pch;
    char *spch;

    assert(pBlock);
    assert(pExt);

    pch=pExt->lineBuffer + pExt->curlinepos;
    while(*pch)
    {
	while(isspace(*pch))
	    ++pch;
	spch=pch;
	while(*pch && !isspace(*pch))
	    ++pch;
	if(*pch)
	{
	    *pch='\0';
	    pLine=lineMake(spch);
	    if(pBlock->doclevel)
		pLine->next=pBlock->doclevel;
	    pBlock->doclevel=pLine;
	    ++pch;
	}
    }
    getLine(pExt);
}

/*
 * @doc INTERNAL READEXT
 *
 * @func void | getSrcLine | This function parses the SRCLINE extract tag
 *  and fills in the information in the block.
 *
 * @parm aBlock * | pBlock | Specifies the block.
 *
 * @parm EXTFile *| pExt | Specifies the Extracted file.
 *
 */
void getSrcLine(aBlock *pBlock, EXTFile *pExt)
{
    char *pch;
    char *spch;

    assert(pBlock);
    assert(pExt);

    pch=pExt->lineBuffer + pExt->curlinepos;
    while(isspace(*pch))
	++pch;
    spch=pch;
    while(!isspace(*pch))
	++pch;
    *pch='\0';
    pBlock->srcfile=cp_alloc(spch);

    ++pch;
    while(isspace(*pch))
	++pch;
    pBlock->srcline=atoi(pch);

    getLine(pExt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\rtf.h ===
/*
	RTF.h  Output file to generate RTF for Windows 3.0 help system

    10-06-1989 Matt Saettler

 Copyright 1989, Microsoft.  All Rights Reserved.

*/


extern void RTFBlockOut(aBlock * func, FILE * file);

extern void RTFFileInit(FILE * phoutfile, logentry * curlog);
extern void RTFFileProcess(FILE * phoutfile, files curfile);
extern void RTFFileDone(FILE * phoutfile, files headfile);

extern void RTFLogInit(FILE * phoutfile, logentry * * pheadlog);
extern void RTFLogProcess(FILE * phoutfile, logentry * curlog);
extern void RTFLogDone(FILE * phoutfile, logentry * headlog);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\text.h ===
/*
	text.h - definitions for saving the documentation text
*/

/* function definitions */


extern  struct stLine *lineMake(char *string);
extern  void lineDestroy(struct stLine *line);
extern	void lineAdd(struct stLine * *place,struct stLine *line);

extern  struct stFlag *flagAlloc(void );
extern  void flagDestroy(struct stFlag *flag);
extern	void flagAdd(struct stFlag * *place,struct stFlag *flag);

extern  struct stParm *parmAlloc(void );
extern  void parmDestroy(struct stParm *parm);
extern  void parmAdd(struct stParm * *place,struct stParm *parm);

extern	aReg * regAlloc(void);
extern	void regDestroy(struct stReg *reg);
extern	void regAdd(struct stReg * *place,struct stReg *reg);

extern	aCond * condAlloc(void);
extern	void condDestroy(struct stCond *cond);
extern	void condAdd(struct stCond * *place,struct stCond *cond);

extern	aType * typeAlloc(void);
extern	void typeDestroy(struct stType *type);
extern	void typeAdd(struct stType * *place,struct stType *type);

extern	aField * fieldAlloc(void);
extern	void fieldDestroy(struct stField *field);
extern	void fieldAdd(struct stField * *place,struct stField *field);

extern	aSU * SUAlloc(void);
extern	void SUDestroy(struct stSU *SU);
extern	void SUAdd(struct stSU * *place,struct stSU *SU);

extern	aOther * otherAlloc(void);
extern	void otherDestroy(struct stOther *other);
extern	void otherAdd(struct stOther * *place,struct stOther *other);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\rtf.c ===
/*
	RTF.c  Output file to generate RTF for Windows 3.0 help system

    10-06-1989 Matt Saettler
     ...
    10-11-1989 MHS Block output instead of specific output
     ...
    10-15-1989 MHS Autodoc
    10-16-1989 MHS Added support for rtnregs
    01-24-1990 MHS Added support for masm Callbacks
    01-31-1990 MHS Added support for conditionals
    03-12-1990 MHS added support for Structs/Unions

 Copyright 1989, 1990 Microsoft Corp.  All Rights Reserved.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "types.h"
#include "docfmt.h"
#include "process.h"
#include "RTF.h"
#include "errstr.h"
#include "misc.h"

#include "head.h"
#include "tail.h"

#define FUNCHELP 1
#define MSGHELP  2
#define CBHELP	 3
#define FUNCDOC  4
#define MSGDOC	 5
#define CBDOC	 6
#define INTDOC	 7
#define INTHELP  8
#define MASMDOC  9
#define MASMHELP 10
#define MASMCBDOC  CBDOC		// HACK HACK
#define MASMCBHELP CBHELP		// PRETEND it is just another CB
#define STRUCTHELP 11
#define STRUCTDOC  12
#define UNIONHELP  13
#define UNIONDOC   14

void RTFLineOut(FILE * fpoutfile, char * pch);
void RTFGenIndex(FILE * file, files curfile);
void RTFParmOut(FILE *file, aParm *pparm, int hselect);
void copylines(FILE * phoutfile, char **lines);
void RTFRegOut(FILE *file, aReg *reg, int hselect);
void RTFFieldOut(FILE *file, aBlock *pBlock, int hselect);
void RTFOtherOut(FILE *file, aOther *other, int hselect);
void RTFCondOut(FILE *file, aCond *cond, int hselect);
void RTFSUOut1(FILE *file, aSU *SU, int hselect, int wType);
void RTFTypeOut1(FILE *file, aType *type, int hselect);
void RTFsubFieldOut1(FILE *file, aField *field , int hselect);
void RTFSUOut2(FILE *file, aSU *SU, int hselect, int wType);
void RTFTypeOut2(FILE *file, aType *type, int hselect);
void RTFsubFieldOut2(FILE *file, aField *field , int hselect);

void RTFDoneText( FILE *fpoutfile );

#define FLAGRTN   1
#define FLAGPARM  2
#define FLAGREG   3

void RTFFlagOut(FILE *file, aFlag *flag, int hselect, int flags);
void RTFDumpParms(FILE *file, aBlock *pBlock, int hselect);
void RTFDumpLevel(FILE *file, aLine *pLine, int hselect);
void RTFDumpX(FILE *file, char *ach);

int fSubBlock=0;

char	*pchparm="<p>"; 	    // 'old' style attributes
char	*pchfunc="<f>";
char	*pchdefault="<d>";

char	*pchrtfparm="{\\i ";	    // attributes for parameter
char	*pchrtffunc="{\\b ";	    // attributes for function
char	*pchrtftype="{\\b ";	    // attributes for type
char	*pchrtfmsg ="{ ";			// attributes for message
char	*pchrtfelem="{\\b ";	    // attributes for element
char	*pchrtfnone  ="{ ";			// attributes for unknown style
char	*pchrtfdefault="}";			// how to restore to default attributes


int blocksprocessed=0;

char *flagdoc ="\\par\n\\pard\\%s\\f26\\fs20\\li%d\\sa60\\sb60\\sl0\\fi%d\\tx5760\\tx6480\n";

char *sepsynhelp="\\tab\n";
char *sepsyndoc ="\\tab\n";

char *synhelp="\\pard\\plain\\f26\\fs20\\fi-1440\\sl0\\li1440\\tx1440\\tx3600\\tx5760\\tx6480\\par\n";
char *syndoc ="\\par\\pard\\plain\\f26\\fs20\\li0000\\sl0\\fi0000\\tx2160\\tx3240\\tx4320\\tx6480\n";

char *sephohelp="\\tab\n";
char *sephodoc ="\\par\n\\pard\\plain\\f26\\fs20\\li1080\\fi0000\\tx2160\\tx3240\\tx4320\\tx6480\n";

char *hcbhelp="\\pard\\plain\\f26\\fs20\\fi0000\\li0000\\tx1440\\tx6480\\par\n";
char *hcbdoc ="\\par\\pard\\plain\\f26\\fs20\\fi0000\\li0000\\tx1080\\tx4320\\tx6480\n";

char *ecbhelp="\\par\\pard\n";
char *ecbdoc ="\\par\\pard\n";

char *head0help="\\pard\\f26\\fs28\\fi0000\\li0000\\tx1440\\tx6480{\\b\n";
char *head0doc ="\\par\\pard\\brdrt\\brdrs\\f26\\fs28\\fi0000\\li0000\\tx1080\\tx4320\\tx6480\n\\v\\f26\\fs20 {\\tc \\plain{\\b \\f26\\fs20 ";

char *ehead0help="}";
char *ehead0doc ="}}\\plain\\f26\\fs20\\li0000\\sl0\\fi0000\n";

char *hohelp="\\par\\pard\\plain\\f26\\fs20\\fi-1440\\sl0\\li1440\\tx1440\\tx3600\\tx5760\\tx6480\n";
char *hodoc ="\\par\\pard\\plain\\f26\\fs20\\li0000\\sl0\\fi0000\\tx2160\\tx3240\\tx4320\\tx6480\n";

char *hparmhelp="\\par\\pard\\plain\\f26\\sl0\\sb60\\sa60\\fs20\\fi-2160\\li3600\\tx1440\\tx3600\\tx5760\\tx6480\n";
char *hparmdoc ="\\par\\pard\\sbys\\f26\\fs20\\ri3200\\li1080\\sl0\\fi0000\\tx2160\\tx3240\\tx4320\\tx6480\n";

char *sepreghelp="\\tab\n";
char *sepregdoc ="\\par\n\\pard\\sbys\\f26\\fs20\\li3240\\sl0\\fi0000\\tx2160\\tx3240\\tx4320\\tx6480\n";

char *hreghelp="\\par\\pard\\plain\\f26\\fs20\\fi-1440\\li3600\\tx1440\\tx3600\\tx5760\\tx6480\n";
char *hregdoc ="\\par\\pard\\sbys\\f26\\fs20\\ri3200\\li1080\\sl0\\fi0000\\tx2160\\tx3240\\tx4320\\tx6480\n";

char *hvalhelp="\\par\\pard\\plain\\f26\\sl0\\sb60\\sa60\\fs20\\fi-2160\\li5760\\tx5760\\tx6480\n";
char *sepvalhelp="\\tab\n";

char *hvaldoc="\\par\\pard\\plain\\f26\\sl0\\sb60\\sa60\\fs20\\fi-2160\\li5760\\tx5760\\tx6480\n";
char *sepvaldoc="\\tab\n";

char *sepparmhelp="\\tab\n";
char *sepparmdoc ="\\par\n\\pard\\sbys\\f26\\fs20\\li3240\\sl0\\fi0000\\tx2160\\tx3240\\tx4320\\tx6480\n";

char *hdeschelp="\\par\\pard\\plain\\f26\\fs20\\fi0000\\li1440\\tx1440\\tx3600\\tx5760\n";
char *hdescdoc ="\\par\\pard\\plain\\f26\\fs20\\fi0000\\li1080\\tx1080\\tx2160\\tx3240\\tx4320\n";

char *SUpar ="\\par\\pard\\plain\\f1\\fs20\\fi-3600\\li5760\\tx5760\n";

char *hSUelements="\\par\\pard\\plain\\f26\\fs20\\fi-3600\\li5760\\tx5760\\tx6480\n";


char *preg2a= "{\\b\\ulw Register}";

char *p2a= "{\\b\\ulw Type/Parameter}";
char *p2ahelp= "{\\b\\ulw Parameter}";
char *p2b= "{\\b\\ulw Description}\\par\n";
char *p2bhelp= "{\\b\\ulw Type/Description}\n";
char *p3a= "{\\b\\ulw Value}";
char *p3b= "{\\b\\ulw Meaning}\n";


///////////////////////////////////////////////////////////////////////////
char achindex[256];

struct _repl 
{
	char *from;
	char *to;
	int state;
	int size;
};

char ach2[100];

#define DEFAULT 1
#define TYPE	15
#define ELEMENT 16
#define FUNC 17
#define MSG 18
#define PARM	19

struct _repl reps[]= 
{
	"<t>", "", TYPE,			0,
	"<e>", "", ELEMENT,			0,
	"<f>", "", FUNC,			0,
	"<m>", "", MSG, 			0,
	"<p>", "", PARM,			0,
	"<d>", "", DEFAULT,			0,
	"<t", "", TYPE,				0,
	"<e", "", ELEMENT,			0,
	"<f", "", FUNC,				0,
	"<m", "", MSG,				0,
	"<p", "", PARM,				0,
	    
// fence	    
	    NULL, NULL, 0, 0
	    
};


static	int state=0;
static	int i=0;

void RTFtextOut( FILE * file,aLine * line);

/*
 *	@doc INTERNAL
 *
 *	@func void | RTFtextOut | This outputs the given text lines.
 *
 *	@parm aLine * | line | Specifies the text to output.
 */
void RTFtextOut( file, line )
FILE * file;
aLine * line;
{
    assert(!state);
    i=0;
    while( line != NULL ) 
    {
	if(!line->next && !line->text[0])
	    break;	// stop at trailing blank lines
	    
        RTFLineOut(file, line->text);
	//
	//  Should we put out a trailing space?
	//
	//  if the previous line ends in a word, or a <D> then splat on
	//  a space so words will not run together.
	//
	//
	if(line->next)
	{
	    int len;
	    char ch;

	    len = strlen(line->text);
	    ch	= line->text[len-1];

            if ( len>=2 && !state &&
		( isalpha(ch) || isdigit(ch) || ch == '.' ||
		  (ch == '>' && line->text[len-2] == 'D') 
		) 
	       )
		fprintf( file, " ");
        }
	fprintf(file,"\n");
	line = line->next;
    }
    RTFDoneText(file);
    state=0;
}


void RTFDoneText( FILE *fpoutfile )
{
//    IndexTag *pIndex;
    // close off any processing that was in progress.
    char *pch;
    
    if(state)
    {
	achindex[i]=0;
	
	// strip leading spaces.
	i=0;
	while(isspace(achindex[i]))
	    i++;
    
	if(outputType==RTFHELP && state != PARM)
	{
	    /* output crossreference if in HELP, but not for parameters */
	    if(state!=ELEMENT)
	    {

		if((state == FUNC) || (state == TYPE))
			fprintf( fpoutfile, "{\\b\\uldb\\f26\\fs20 ");
		else
			fprintf( fpoutfile, "{\\uldb\\f26\\fs20 ");
		fprintf( fpoutfile, "%s", achindex + i);
		fprintf( fpoutfile, "}{\\v\\f26\\fs20 ");
		fprintf( fpoutfile, "%s",achindex + i);
		fprintf( fpoutfile, "}\\plain\\f26\\fs20 ");
	    }
	    else
	    {
		pch=achindex+i;
		while(*pch)		// just leave element name
		{
		    if(*pch=='.')
		    {
			pch++;
			break;
		    }
		    pch++;
		}
		if(!*pch)
		    fprintf(errfp,"warning: bad element reference in %s\n",achindex);
		 
		fprintf( fpoutfile, "{\\uldb\\b\\f26\\fs20 ");
		fprintf( fpoutfile, "%s", pch);
		fprintf( fpoutfile, "}{\\v\\f26\\fs20 ");
	    
		pch=achindex+i;
		while(*pch)		// just leave struct name
		{
		    if(*pch=='.')
		    {
			*pch=0;
			break;
		    }
		    pch++;
		}
		fprintf( fpoutfile, "%s",achindex + i);
		fprintf( fpoutfile, "}\\plain\\f26\\fs20 ");
	    
	    }
	    
	}
	else
	{
		switch  (state)
		{
			case PARM:
				fprintf( fpoutfile, pchrtfparm );
				break;
			case FUNC:
				fprintf( fpoutfile, pchrtffunc );
				break;
			case MSG:
				fprintf( fpoutfile, pchrtfmsg );
				break;
			case TYPE:
				fprintf( fpoutfile, pchrtftype );
				break;
			case ELEMENT:
				fprintf( fpoutfile, pchrtfelem );
				break;
			default:
				fprintf( fpoutfile, pchrtfnone );
				break;
		}
		
	    fprintf( fpoutfile,achindex +i);
	    fprintf( fpoutfile,pchrtfdefault);
	}
	
        state=0;
	i=0;
    }
	
}
#define ERRORMARK(w)	for(j=0;j<w;j++) fprintf(errfp," "); fprintf(errfp,"^\n");

/*
 *	@doc INTERNAL
 *
 *	@func void | RTFLineOut | This outputs the given text line.
 *
 *	@parm char * | line | Specifies the text to output.
*/
void
RTFLineOut(FILE * fpoutfile, char * pch)
{
    int j;

    int k;
    int flag;
    char *pchs=pch;
    
    
    // first time init
    if(reps[0].size==0)
	for(j=0;reps[j].from; j++)
	    reps[j].size=strlen(reps[j].from);

/* check for and process blank lines */
    if(!*pch)
    {
	// need to set cur par sep formatting
	
	//  HACK.  Doing a 'tab' should get us to column indent.
	//            (assumes fi is set to -x and tx at indent)
	//
	// the tab puts in a blank line also
	
	if(fSubBlock)		// if in sub-block
	    fprintf(fpoutfile, "\\par\\tab");
	else
	    fprintf(fpoutfile, "\\par\\par\\tab");
    }

    while(*pch)
    {
	if(state)
	{
	    // Handles <x>yyy<d> and <x yyy>
	    
	    if(*pch!='>' && *pch!='<')
	    {
		if(*pch!='\n')
		    achindex[i++]=*pch;
		pch++;
	    }
	    else
	    {
		RTFDoneText(fpoutfile);
		if(*pch=='<')
		{	// it was a <
		    pch++;
		    if(*pch=='d' || *pch=='D')
		    {
			// it's OK, it's <d
			pch++;
			if(*pch!='>')
			{
			    fprintf(errfp, 
	"non-fatal error: Badly formed formatting code in text: %s\n",pchs);
			    ERRORMARK(pch-pchs);			    
			}
			pch++;
		    }
		    else
		    {
			// we don't know what it is.  Skip it.
			
			fprintf(errfp, 
	"non-fatal error: Unexpected formatting code in text: %s\n",pchs);
			ERRORMARK(pch-pchs);			    
			
			while(*pch && *pch!='>')
			    pch++;
			    
			if(*pch)
			    pch++;
		    }
		}
		else	// it's just >
		    pch++;
	    }
	    continue;	    
	}
    
	if(*pch == '\t')
	{
	    fprintf(fpoutfile," ");
	    pch++;
	    continue;
	}
	    
	if(*pch == '\\')
	{
	    pch++;
	    
	    if (*pch == '|' || *pch == '@')
		    fprintf(fpoutfile, "%c", *pch);
	    else
	    {
		pch--;
		fprintf(fpoutfile,"\\%c",*pch);	// output '\\'
	    }
	    pch++;
	    continue;
	}
    
	if(*pch == '{' || *pch == '}')
	{
	    fprintf(fpoutfile,"\\%c",*pch);
	    pch++;
	    continue;
	}
    
	if(*pch=='<' && pch[1]!='<')
	{
	    for(j=0; reps[j].from!=NULL; j++)
	    {
		if(!strnicmp(pch,reps[j].from,reps[j].size))
		{
		    if(reps[j].state==DEFAULT )
		    {
			if(!state)
			{

		    fprintf(errfp, "Ending without start. Ignored.\n");

			}
			else
			{
			    // reset state and take care of business
			    RTFDoneText(fpoutfile);
			}
			    
		    } 
		    state=reps[j].state;
		    pch+=reps[j].size;
		    break; // the for loop
		}
	    }

	    if(reps[j].from==NULL)  // we didn't find it in table
	    {
                fprintf(errfp, 
	"non-fatal error: Unknown formatting code in text: %s\n",pch);
		putc(*pch, fpoutfile);
		pch++;
	    }
	}
	else
	{
            putc(*pch, fpoutfile);
            pch++;
        }
    }

    RTFDoneText(fpoutfile);
}
///////////////////////////////////////////////////////////////////////////

/*
 *	@doc INTERNAL
 *
 *	@func void | RTFXrefOut | This outputs the given Xref lines.
 *	(lines are seperated by <new-line>)
 *
 *	@parm aLine * | line | Specifies the text to output.
 */
void RTFXrefOut(FILE * file,aLine * line);
void RTFXrefOut( file, line )
FILE * file;
aLine * line;
{
    char ach[80];
    int i;
    char *pch;

    while( line != NULL )
    {

	pch=line->text;

	while(isspace(*pch))
	    pch++;

	while(*pch)
	{
	    i=0;
	    while(*pch && !(*pch ==',' || isspace(*pch) ) )
		ach[i++]=*pch++;

	    if(i>0)
	    {
		ach[i]=0;
		RTFDumpX(file, ach);
	    }

	    while(*pch && (*pch == ',' || isspace(*pch)))
	    {
		pch++;
	    }
//	    if(*pch && outputType == RTFDOC )
	    // put commas between items
		fprintf(file, ", ");

	}

	fprintf( file, "\n" );
	line = line->next;
	if(line)
	    fprintf( file, " ");

    }
}

/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFDumpX | This function outputs a Crossreference.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm char * | pch | Specifies the name of the Crossreference.
 *
 */
void
RTFDumpX(FILE *file, char *pch)
{
    if(outputType==RTFHELP)
    {
	fprintf( file, "{\\uldb\\f26\\fs20 ");
	fprintf( file, "%s",pch);
	fprintf( file, "}{\\v\\f26\\fs20 ");
	fprintf( file, "%s",pch);
	fprintf( file, "}\n\\plain\\f26\\fs20 ");
    }
    else
	fprintf( file, "%s", pch);
}


/*
 *  @doc INTERNAL RTF
 *
 *  @func void | RTFtextOutLn | This outputs the given text lines.
 *  (lines are seperated by <new-line>)
 *
 *  @parm FILE * | file | Specifies the output file.
 *
 *  @parm aLine * | line | Specifies the text to output.
 */
void RTFtextOutLn( FILE * file,aLine * line);
void RTFtextOutLn( file, line )
FILE * file;
aLine * line;
{
    RTFtextOut(file,line);
}

/*
 *	@doc INTERNAL
 *
 *	@func void | RTFBlockOut | This outputs the block information in
 *			       RTF Format.
 *
 *	@parm aFuncBlock * | func | Specifies a pointer to the function
 *		information
 *
 *	@parm FILE * | file | File to send output to.
 */
void RTFBlockOut(aBlock * pBlock, FILE * file)
{
    aParm * parm;
    aFlag * flag;
    aBlock *pcurBlock;
    aCond *cond;
    int iblock ;
    
    int hselect;

    blocksprocessed++;
    
/* add to hselect the block type */
    if( !pBlock || !file )
    {
	fprintf(errfp,"XXX:RTFBlockOut: parameter error\n");
	return;
    }

    if( pBlock->blockType == FUNCTION)
	hselect= (outputType == RTFHELP) ? FUNCHELP : FUNCDOC;
    else if( pBlock->blockType == MESSAGE )
	hselect= (outputType == RTFHELP) ? MSGHELP : MSGDOC;
    else if( pBlock->blockType == CALLBACK )
	hselect= (outputType == RTFHELP) ? CBHELP : CBDOC;
    else if( pBlock->blockType == MASMBLOCK )
	hselect= (outputType == RTFHELP) ? MASMHELP : MASMDOC;
    else if( pBlock->blockType == MASMCBBLOCK )
	hselect= (outputType == RTFHELP) ? MASMCBHELP : MASMCBDOC;
    else if( pBlock->blockType == CALLBACK )
	hselect= (outputType == RTFHELP) ? INTHELP : INTDOC;
    else if( pBlock->blockType == STRUCTBLOCK )
	hselect= (outputType == RTFHELP) ? STRUCTHELP : STRUCTDOC;
    else if( pBlock->blockType == UNIONBLOCK )
	hselect= (outputType == RTFHELP) ? UNIONHELP : UNIONDOC;
    else
    {
	fprintf(errfp,"Unknown block type in RTFBlockOut\n");
	return;
    }

    switch(hselect)
    {
	case FUNCHELP:
	case MASMHELP:
	case INTHELP:
	case MSGHELP:
	case STRUCTHELP:
	case UNIONHELP:
	    fprintf( file, "\\par\\page K{\\footnote{\\up6 K} "); /* keyword */
	    RTFtextOut( file, pBlock->name );
	    fprintf( file, "} ${\\footnote{\\up6 $} "); /* section Title */
	    RTFtextOut( file, pBlock->name );
	    fprintf( file, "} +{\\footnote{\\up6 +} "); /* order */
	    fprintf( file, "T");
//	    RTFtextOut( file, pBlock->name );
	    fprintf( file, "} #{\\footnote{\\up6 #} "); /* make target */
	    RTFtextOut( file, pBlock->name );
	    fprintf( file, "}\n");
	    break;
    }

    /* process name */
    switch(hselect)
    {
	case MASMHELP:
	case INTHELP:
	case FUNCHELP:
	case MSGHELP:
	case STRUCTHELP:
	case UNIONHELP:
	    fprintf( file, head0help);
	    RTFtextOut( file, pBlock->name );
	    fprintf( file, ehead0help);

	    break;

	case CBHELP:
	case CBDOC:
	    /* nothing */
	    break;
	case FUNCDOC:
	case MSGDOC:
	case INTDOC:
	case MASMDOC:
	case STRUCTDOC:
	case UNIONDOC:
	    fprintf( file, head0doc);
	    RTFtextOut( file, pBlock->name );
	    fprintf( file, ehead0doc);

	    break;

    }

    if(pBlock->doclevel && dumplevels)
	RTFDumpLevel(file, pBlock->doclevel, hselect);

    if(outputType!= RTFHELP)
	fprintf(file, "\\par\\pard\n");	// blank line

    /* handle outputting syntax */
    switch(hselect)
    {
	case CBHELP:
	    fprintf( file, synhelp );
	    fprintf( file, "{\\b %s}\\tab \n","Callback");
		
	    fprintf( file, " {\\b ");
	    RTFtextOut( file, pBlock->type );
	    fprintf( file, "}");

	    fprintf( file, " {\\i ");
	    RTFtextOut( file, pBlock->name );
	    fprintf( file, "}");
	    fprintf( file, "\\par\n" );
	    
	    fprintf( file, sepsynhelp );

	    if( pBlock->parm )
	    {
		parm = pBlock->parm;
		while( parm )
		{
		    fprintf( file, "{\\b ");
		    RTFtextOut( file, parm->type );
		    fprintf( file, "} " ); // << note the trailing space
		    
		    fprintf( file, "{\\i ");
		    RTFtextOut( file, parm->name );
		    fprintf( file, ";}" ); // << note the ';'
		    parm = parm->next;
		    if( parm )
		    {
			fprintf( file, "\\par\\tab\n" );
		    }
		}
		parm=NULL;
	    }

	    fprintf( file, "\\par\n" );

	    break;
	case MASMHELP:
	case INTHELP:
	case FUNCHELP:
	    fprintf( file, synhelp );
	    fprintf( file, "{\\b %s}\n","Syntax" );
	    fprintf( file, sepsynhelp );

	    RTFDumpParms(file, pBlock, hselect);

	fprintf( file, "\\par\n" );

	    break;
	case UNIONHELP:
	case STRUCTHELP:
	case MSGHELP:
	    break;

	case INTDOC:
	case MASMDOC:
	case FUNCDOC:
	case CBDOC:
	    fprintf( file, syndoc );
	    fprintf( file, "{\\b %s}\n",
		     (hselect==CBDOC) ? "Callback" : "Syntax" );
	    fprintf( file, sepsyndoc );

	    RTFDumpParms(file, pBlock, hselect);

	    fprintf( file, "\\par\n" );
	    break;

	case UNIONDOC:
	case STRUCTDOC:
	case MSGDOC:
	    break;
    }

    /* description block */
    switch(hselect)
    {
	case MASMHELP:
	case INTHELP:
	case FUNCHELP:
	case CBHELP:
	case MSGHELP:
	case UNIONHELP:
	case STRUCTHELP:
	    fprintf( file, hdeschelp );
	    RTFtextOutLn( file, pBlock->desc );
	    fprintf( file, "\\par\n" );

	    break;

	case INTDOC:
	case MASMDOC:
	case FUNCDOC:
	case CBDOC:
	case MSGDOC:
	case UNIONDOC:
	case STRUCTDOC:
	    fprintf( file, hdescdoc );
	    RTFtextOutLn( file, pBlock->desc );
	    fprintf( file, "\\par\n" );
	    break;
    }

    if( pBlock->reg  )
    {
	RTFRegOut( file, pBlock->reg, hselect);
	if(pBlock->parm)
  fprintf(errfp,"Warning: Block contains BOTH Registers and API parms.\n");
    }

    if( pBlock->parm  )
    {
	RTFParmOut( file, pBlock->parm, hselect);
    }

    if( pBlock->field )
	RTFFieldOut( file, pBlock, hselect);
	
    if( pBlock->other)
	RTFOtherOut( file, pBlock->other, hselect);
	
    /* return description */
    if( pBlock->rtndesc  )
    {
	switch(hselect)
	{
	    case FUNCHELP:
	    case MASMHELP:
	    case INTHELP:
	    case CBHELP:
	    case MSGHELP:
		// leave extra blank line before return value
		fprintf(file,"\n\\par");
		fprintf( file, hohelp );

		fprintf( file, "{\\b Return Value}" );
		fprintf( file, sephohelp);

		break;

	    case INTDOC:
	    case MASMDOC:
	    case FUNCDOC:
	    case CBDOC:
	    case MSGDOC:
		fprintf( file, hodoc );

		fprintf( file, "{\\b Return Value}" );
		fprintf( file, sephodoc);

		break;

	}   // switch

	RTFtextOutLn( file, pBlock->rtndesc );

	if(pBlock->rtnflag)
	{
	    RTFFlagOut(file, pBlock->rtnflag, hselect, FLAGRTN);
	}
	if(pBlock->rtnreg)
	{
	    RTFRegOut(file, pBlock->rtnreg, hselect);
	}
	fprintf( file, "\\par\n" );
	
    }	// if rtndesc
    else
	if(pBlock->rtnflag)
	    fprintf(errfp,"XXX: Return flags without return desc\n");

    for( cond = pBlock->cond; cond; cond = cond->next )
    {
	switch(hselect)
	{
	case MASMHELP:
	case INTHELP:
	    case FUNCHELP:
	    case CBHELP:
	    case MSGHELP:
		fprintf( file, hohelp );

		fprintf( file, "{\\b Conditional}" );
		fprintf( file, sephohelp);

		break;

	    case INTDOC:
	    case MASMDOC:
	    case FUNCDOC:
	    case CBDOC:
	    case MSGDOC:
		fprintf( file, hodoc );

		fprintf( file, "{\\b Conditional}" );
		fprintf( file, sephodoc);

		break;
	}
	RTFCondOut(file, cond, hselect);

	fprintf( file, "\\par\n" );
    }

    if( pBlock->comment )
    {
	switch(hselect)
	{
	case MASMHELP:
	case INTHELP:
	    case FUNCHELP:
	    case CBHELP:
	    case MSGHELP:
		fprintf( file, hohelp );

		fprintf( file, "{\\b Comments}" );
		fprintf( file, sephohelp);

		break;

	    case INTDOC:
	    case MASMDOC:
	    case FUNCDOC:
	    case CBDOC:
	    case MSGDOC:
		fprintf( file, hodoc );

		fprintf( file, "{\\b Comments}" );
		fprintf( file, sephodoc);

		break;
	}
	RTFtextOutLn( file, pBlock->comment );
	fprintf( file, "\\par\n" );
    }

    if( pBlock->uses )
    {
	switch(hselect)
	{
	case MASMHELP:
	case INTHELP:
	    case FUNCHELP:
	    case CBHELP:
	    case MSGHELP:
		fprintf( file, hohelp );

		fprintf( file, "{\\b Uses}" );
		fprintf( file, sephohelp);

		break;

	    case INTDOC:
	    case MASMDOC:
	    case FUNCDOC:
	    case CBDOC:
	    case MSGDOC:
		fprintf( file, hodoc );

		fprintf( file, "{\\b Uses}" );
		fprintf( file, sephodoc);

		break;
	}
	RTFtextOutLn( file, pBlock->uses );
	fprintf( file, "\\par\n" );
    }

    if( pBlock->cb)
    {
	pcurBlock=pBlock->cb;
	while(pcurBlock)
	{
	    RTFBlockOut(pcurBlock, file );
	    pcurBlock=pcurBlock->next;
	}
    }

    if( pBlock->xref )
    {
	switch(hselect)
	{
	    case MASMHELP:
	    case INTHELP:
	    case FUNCHELP:
	    case CBHELP:
	    case MSGHELP:
		fprintf( file, hohelp );

		fprintf( file, "{\\b See Also}" );
		fprintf( file, sephohelp);

		break;

	    case INTDOC:
	    case MASMDOC:
	    case FUNCDOC:
	    case CBDOC:
	    case MSGDOC:
		fprintf( file, hodoc );

		fprintf( file, "{\\b Related Functions}" );
		fprintf( file, sephodoc);

		break;
	}

	RTFXrefOut( file, pBlock->xref );
	fprintf( file, "\\par\n" );
    }

}

/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFDumpLevel | This function outputs the DOC Level.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm aLine * | pLine | Specifies the list of Doc Levels.
 *
 * @parm int | hselect | Specifies the current mode of output.
 *
 * @flag FUNCHELP |  Specifies the current block is a Function,
 *  and the mode is RTFHELP.
 *
 * @flag MSGHELP  |  Specifies the current block is a Message,
 *  and the mode is RTFHELP.
 *
 * @flag CBHELP   |  Specifies the current block is a Call Back,
 *  and the mode is RTFHELP.
 *
 * @flag FUNCDOC  |  Specifies the current block is a Function,
 *  and the mode is RTFDOC.
 *
 * @flag MSGDOC   |  Specifies the current block is a Message,
 *  and the mode is RTFDOC.
 *
 * @flag CBDOC	  |  Specifies the current block is a Call Back,
 *  and the mode is RTFDOC.
 *
 * @flag INTDOC   |  Specifies the current block is an Interrupt,
 *  and the mode is RTFDOC.
 *
 * @flag INTHELP  |  Specifies the current block is an Interrupt,
 *  and the mode is RTFHELP.
 *
 * @flag MASMDOC  |  Specifies the current block is a MASM,
 *  and the mode is RTFDOC.
 *
 * @flag MASMHELP |  Specifies the current block is a MASM,
 *  and the mode is RTFHELP.
 *
 */
void
RTFDumpLevel(FILE *file, aLine *pLine, int hselect)
{
    fprintf(file, "\\tab ");

    while(pLine)
    {
	if(pLine->text)
	{
	    fprintf( file, "{\\scaps %s}", pLine->text);
	    pLine=pLine->next;
	    if(pLine)
		fprintf(file, ", ");
	}

    }

}


/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFDumpParms | This functions outputs the Parameters
 *  for a declaration in the specfied mode to the output file.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm aLine * | pLine | Specifies the list of Doc Levels.
 *
 * @parm int | hselect | Specifies the current mode of output.
 *
 * @flag FUNCHELP |  Specifies the current block is a Function,
 *  and the mode is RTFHELP.
 *
 * @flag MSGHELP  |  Specifies the current block is a Message,
 *  and the mode is RTFHELP.
 *
 * @flag CBHELP   |  Specifies the current block is a Call Back,
 *  and the mode is RTFHELP.
 *
 * @flag FUNCDOC  |  Specifies the current block is a Function,
 *  and the mode is RTFDOC.
 *
 * @flag MSGDOC   |  Specifies the current block is a Message,
 *  and the mode is RTFDOC.
 *
 * @flag CBDOC	  |  Specifies the current block is a Call Back,
 *  and the mode is RTFDOC.
 *
 * @flag INTDOC   |  Specifies the current block is an Interrupt,
 *  and the mode is RTFDOC.
 *
 * @flag INTHELP  |  Specifies the current block is an Interrupt,
 *  and the mode is RTFHELP.
 *
 * @flag MASMDOC  |  Specifies the current block is a MASM,
 *  and the mode is RTFDOC.
 *
 * @flag MASMHELP |  Specifies the current block is a MASM,
 *  and the mode is RTFHELP.
 *
 */
void
RTFDumpParms(FILE *file, aBlock *pBlock, int hselect)
{
    aParm *parm;

    assert(hselect!=CBHELP);
    
    fprintf( file, " {\\b ");
    RTFtextOut( file, pBlock->type );
    fprintf( file, "}");

    fprintf( file, " {\\b ");
    RTFtextOut( file, pBlock->name );
    fprintf( file, "}");

    switch(hselect)
    {
	case CBDOC:
	    if( pBlock->blockType == MASMCBBLOCK )
		break;
	case FUNCHELP:
	case FUNCDOC:
	    fprintf( file, "(" );
	    break;
	case CBHELP:
	    break;
    }
    if( pBlock->parm )
    {
	parm = pBlock->parm;
	while( parm )
	{
	    fprintf( file, "{\\i ");
	    RTFtextOut( file, parm->name );
	    fprintf( file, "}" );
	    parm = parm->next;
	    if( parm )
	    {
		    fprintf( file, ", " );
	    }
	}
    }

    switch(hselect)
    {
	case CBDOC:
	case CBHELP:
	    if( pBlock->blockType == MASMCBBLOCK )
		break;
	case FUNCHELP:
	case FUNCDOC:
	    fprintf( file, ")" );
	    break;
    }

    return;
}

/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFRegOut | This function outputs the specified Register
 *  structure in the specifed mode to the output file.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm aReg * | reg | Specifies the list of Registers.
 *
 * @parm int | hselect | Specifies the current mode of output.
 *
 * @flag FUNCHELP |  Specifies the current block is a Function,
 *  and the mode is RTFHELP.
 *
 * @flag MSGHELP  |  Specifies the current block is a Message,
 *  and the mode is RTFHELP.
 *
 * @flag CBHELP   |  Specifies the current block is a Call Back,
 *  and the mode is RTFHELP.
 *
 * @flag FUNCDOC  |  Specifies the current block is a Function,
 *  and the mode is RTFDOC.
 *
 * @flag MSGDOC   |  Specifies the current block is a Message,
 *  and the mode is RTFDOC.
 *
 * @flag CBDOC	  |  Specifies the current block is a Call Back,
 *  and the mode is RTFDOC.
 *
 * @flag INTDOC   |  Specifies the current block is an Interrupt,
 *  and the mode is RTFDOC.
 *
 * @flag INTHELP  |  Specifies the current block is an Interrupt,
 *  and the mode is RTFHELP.
 *
 * @flag MASMDOC  |  Specifies the current block is a MASM,
 *  and the mode is RTFDOC.
 *
 * @flag MASMHELP |  Specifies the current block is a MASM,
 *  and the mode is RTFHELP.
 *
 */
void
RTFRegOut(FILE *file, aReg *reg, int hselect)
{
    switch(hselect)
    {
	case MASMHELP:
	case INTHELP:
	case FUNCHELP:
	case CBHELP:
	case MSGHELP:
	    fprintf( file, hreghelp );
	    fprintf( file, preg2a );
	    fprintf( file, sepreghelp);
	    fprintf( file, p2b );

	    break;

	    case INTDOC:
	    case MASMDOC:
	case FUNCDOC:
	case CBDOC:
	case MSGDOC:
	    fprintf( file, hregdoc );
	    fprintf( file, preg2a );
	    fprintf( file, sepregdoc);
	    fprintf( file, p2b );
	    break;
    }

    while( reg )
    {
	switch(hselect)
	{
	    case MASMHELP:
	    case INTHELP:
	    case FUNCHELP:
	    case CBHELP:
	    case MSGHELP:
		fprintf( file, hreghelp );
		fprintf( file, "{\\i ");
		RTFtextOut( file, reg->name );
		fprintf( file, "} " );
		fprintf( file, sepreghelp);

		break;

	    case INTDOC:
	    case MASMDOC:
	    case FUNCDOC:
	    case CBDOC:
	    case MSGDOC:
		fprintf( file, hregdoc );
		fprintf( file, "{\\i ");
		RTFtextOut( file, reg->name );
		fprintf( file, "} " );
		fprintf( file, sepregdoc);
		break;
	}

	RTFtextOutLn( file, reg->desc );
	fprintf( file, "\n" );

	if(reg->flag)
	    RTFFlagOut(file, reg->flag, hselect, FLAGREG);


	fprintf( file, "\\par\n");
	reg = reg->next;
    }

}

void RTFFieldOut(FILE *file, aBlock *pBlock , int hselect)
{
    aLine *tag;
    aField *curfield;
    aField *field;
    
    field=pBlock->field;
    tag=pBlock->tagname;
    
    // recursively dump fields

    // output structure definition
    fprintf(file, "%stypedef struct %s \\{\n", SUpar, tag ? tag->text : "" );
    fprintf(file, "%s",SUpar);

    curfield=pBlock->field;
    while(curfield)
    {
	switch(curfield->wType)
	{
	    case FIELD_TYPE:
		RTFTypeOut1(file, (aType *)curfield->ptr, hselect);
		break;
	    case FIELD_STRUCT:
	    case FIELD_UNION:
		RTFSUOut1(file, (aSU *)curfield->ptr, 
			    hselect, curfield->wType);
		break;
	    default:
		assert(FALSE);
		break;
	}
	curfield=curfield->next;
    }
    fprintf(file,"\\} %s;\\par",pBlock->name->text);

    fprintf(file,"%s\\par The {\\b %s} structure contains the following fields:\\par\\par",
	    hdescdoc, pBlock->name->text);
	    
    fprintf(file,"%s{\\ul Field}\\tab{\\ul Description}\\par\n",hSUelements);
    // output element definitions.
    
    curfield=pBlock->field;
    while(curfield)
    {
	switch(curfield->wType)
	{
	    case FIELD_TYPE:
		RTFTypeOut2(file, (aType *)curfield->ptr, hselect);
		break;
	    case FIELD_STRUCT:
	    case FIELD_UNION:
		RTFSUOut2(file, (aSU *)curfield->ptr, hselect, curfield->wType);
		break;
	    default:
		assert(FALSE);
		break;
	}
	curfield=curfield->next;
    }
    
}

void RTFsubFieldOut1(FILE *file, aField *field , int hselect)
{
    aLine *tag;
    aField *curfield;
    
    // recursively dump fields

    curfield=field;
    while(curfield)
    {
	switch(curfield->wType)
	{
	    case FIELD_TYPE:
		RTFTypeOut1(file, (aType *)curfield->ptr, hselect);
		break;
	    case FIELD_STRUCT:
	    case FIELD_UNION:
		RTFSUOut1(file, (aSU *)curfield->ptr, 
				    hselect, curfield->wType);
		break;
	    default:
		assert(FALSE);
		break;
	}
	curfield=curfield->next;
    }
    
}

void RTFSUOut1(FILE *file, aSU *SU, int hselect, int wType)
{
    aSU *curSU;
    
    int level;
    
    
    for(level=SU->level ; level>0; level--)
	fprintf(file, "    "); // four spaces per indent.
	
    fprintf(file, "%s \\{\\par\n", wType == FIELD_STRUCT ? "struct" : "union");
    if(SU->field)
	RTFsubFieldOut1(file, SU->field, hselect);
    
    for(level=SU->level ; level>0; level--)
	fprintf(file, "    "); // four spaces per indent.
	
    fprintf(file, "\\} %s;\\par\n",SU->name->text);
    
}

void RTFTypeOut1(FILE *file, aType *type, int hselect)
{
    int level;
    
    for(level=type->level +1 ; level>0; level--)
	fprintf(file, "    "); // four spaces per indent.
	
    RTFtextOut(file, type->type);
    fprintf(file,"\\tab ");
    RTFtextOut(file, type->name);
    
    fprintf( file, ";\\par\n" );	// note the ; <<<<
    
    if(type->flag)
    {
	RTFFlagOut(file, type->flag, hselect, FLAGPARM);
	fprintf(file, "%s", SUpar);
    }
    
}

void RTFSUOut2(FILE *file, aSU *SU, int hselect, int wType)
{
    aSU *curSU;
    
    int level;
    
    if(SU->field)
	RTFsubFieldOut2(file, SU->field, hselect);
    
    fprintf( file, "\\par\n" );
    
}

void RTFTypeOut2(FILE *file, aType *type, int hselect)
{
    
    RTFtextOut(file, type->name);
    fprintf(file,"\\tab ");
    RTFtextOut(file, type->desc);
    
    fprintf( file, "\\par\n" );
    
}

void RTFsubFieldOut2(FILE *file, aField *field , int hselect)
{
    aLine *tag;
    aField *curfield;
    
    // recursively dump fields

    curfield=field;
    while(curfield)
    {
	switch(curfield->wType)
	{
	    case FIELD_TYPE:
		RTFTypeOut2(file, (aType *)curfield->ptr, hselect);
		break;
	    case FIELD_STRUCT:
	    case FIELD_UNION:
		RTFSUOut2(file, (aSU *)curfield->ptr, hselect, curfield->wType);
		break;
	    default:
		assert(FALSE);
		break;
	}
	curfield=curfield->next;
    }
    
}


void RTFOtherOut(FILE *file, aOther *other, int hselect)
{
    aOther *curo;
    
    switch(hselect)
    {
	case MASMHELP:
	case INTHELP:
	case FUNCHELP:
	case CBHELP:
	case MSGHELP:
	    // what are we doing here?
	    break;
	    
	case STRUCTHELP:
	case UNIONHELP:
	    fprintf( file, hohelp );

	    fprintf( file, "{\\b Synonyms}" );
	    fprintf( file, sephohelp);

	break;

	case INTDOC:
	case MASMDOC:
	case FUNCDOC:
	case CBDOC:
	case MSGDOC:
	    // what are we doing here?
	    break;
	    
	case STRUCTDOC:
	case UNIONDOC:
	    fprintf( file, hodoc );

	    fprintf( file, "{\\b Other names}" );
	    fprintf( file, sephodoc);

	break;
    }
    
    curo=other;
    while(curo)
    {
	if(hselect == STRUCTHELP || hselect == UNIONHELP)
	{
	    fprintf( file, "K{\\footnote{\\up6 K} "); /* make target */
	    RTFtextOut( file, curo->name);
	    fprintf( file, "}\n");
	    
	}
	RTFtextOut( file, curo->type );
	fprintf(file,"\\tab ");
	RTFtextOut( file, curo->name);
	if(curo->desc)
	    RTFtextOut( file, curo->desc);
	fprintf( file, "\\par\n" );
	curo=curo->next;
    }
    fprintf( file, "\\par\n" );
    
}


/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFCondOut | This function outputs the specified Conditional
 *  structure in the specifed mode to the output file.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm aCond * | pCond | Specifies the list of Conditionals.
 *
 * @parm int | hselect | Specifies the current mode of output.
 *
 * @flag FUNCHELP |  Specifies the current block is a Function,
 *  and the mode is RTFHELP.
 *
 * @flag MSGHELP  |  Specifies the current block is a Message,
 *  and the mode is RTFHELP.
 *
 * @flag CBHELP   |  Specifies the current block is a Call Back,
 *  and the mode is RTFHELP.
 *
 * @flag FUNCDOC  |  Specifies the current block is a Function,
 *  and the mode is RTFDOC.
 *
 * @flag MSGDOC   |  Specifies the current block is a Message,
 *  and the mode is RTFDOC.
 *
 * @flag CBDOC	  |  Specifies the current block is a Call Back,
 *  and the mode is RTFDOC.
 *
 * @flag INTDOC   |  Specifies the current block is an Interrupt,
 *  and the mode is RTFDOC.
 *
 * @flag INTHELP  |  Specifies the current block is an Interrupt,
 *  and the mode is RTFHELP.
 *
 * @flag MASMDOC  |  Specifies the current block is a MASM,
 *  and the mode is RTFDOC.
 *
 * @flag MASMHELP |  Specifies the current block is a MASM,
 *  and the mode is RTFHELP.
 *
 */
void
RTFCondOut(FILE *file, aCond *cond, int hselect)
{
	RTFtextOutLn( file, cond->desc );
	fprintf( file, "\\par\n" );

	RTFRegOut(file, cond->regs,hselect);
	    
	// fprintf( file, "\\par\n" );	    
}

/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFParmOut | This function outputs the Parameters in the
 *  mode to the output file.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm aParm * | parm | Specifies the list of Parameters.
 *
 * @parm int | hselect | Specifies the current mode of output.
 *
 * @flag FUNCHELP |  Specifies the current block is a Function,
 *  and the mode is RTFHELP.
 *
 * @flag MSGHELP  |  Specifies the current block is a Message,
 *  and the mode is RTFHELP.
 *
 * @flag CBHELP   |  Specifies the current block is a Call Back,
 *  and the mode is RTFHELP.
 *
 * @flag FUNCDOC  |  Specifies the current block is a Function,
 *  and the mode is RTFDOC.
 *
 * @flag MSGDOC   |  Specifies the current block is a Message,
 *  and the mode is RTFDOC.
 *
 * @flag CBDOC	  |  Specifies the current block is a Call Back,
 *  and the mode is RTFDOC.
 *
 * @flag INTDOC   |  Specifies the current block is an Interrupt,
 *  and the mode is RTFDOC.
 *
 * @flag INTHELP  |  Specifies the current block is an Interrupt,
 *  and the mode is RTFHELP.
 *
 * @flag MASMDOC  |  Specifies the current block is a MASM,
 *  and the mode is RTFDOC.
 *
 * @flag MASMHELP |  Specifies the current block is a MASM,
 *  and the mode is RTFHELP.
 *
 */
void
RTFParmOut(FILE *file, aParm *parm, int hselect)
{
    fSubBlock++;
    
    switch(hselect)
    {

	case CBHELP:	case MASMHELP:
	case INTHELP:	case FUNCHELP:
	case MSGHELP:
	    fprintf( file, hparmhelp );
	    fprintf( file, p2ahelp );
	    fprintf( file, sepparmhelp);
	    fprintf( file, p2bhelp );

	    break;

	case INTDOC:
	case MASMDOC:
	case FUNCDOC:
	case CBDOC:
	case MSGDOC:
	    fprintf( file, hparmdoc );
	    fprintf( file, p2a );
	    fprintf( file, sepparmdoc);
	    fprintf( file, p2b );
	    break;
    }

    while( parm )
    {
	switch(hselect)
	{
	    case MASMHELP:
	    case INTHELP:
	    case FUNCHELP:
	    case CBHELP:
	    case MSGHELP:
		fprintf( file, hparmhelp );
		fprintf( file, "{\\i ");
		RTFtextOut( file, parm->name );
		fprintf( file, "} " );
		fprintf( file, sepparmhelp);
		fprintf( file, "{\\b ");
		RTFtextOut( file, parm->type );
		fprintf( file, "} ");		// << note ' '

		break;

	    case INTDOC:
	    case MASMDOC:
	    case FUNCDOC:
	    case CBDOC:
	    case MSGDOC:
		fprintf( file, hparmdoc );
		fprintf( file, "{\\b ");
		RTFtextOut( file, parm->type );
		fprintf( file, "} {\\i ");
		RTFtextOut( file, parm->name );
		fprintf( file, "} " );
		fprintf( file, sepparmdoc);
		break;
	}

	fprintf( file, "\n" );
//	RTFtextOutLn( file, parm->desc );
	RTFtextOut( file, parm->desc );

	if(parm->flag)
	{
//	    fprintf(file, "\\par\n");	    // blank line before flags
	    RTFFlagOut(file, parm->flag, hselect, FLAGPARM);
	}

	if(outputType!=RTFHELP)
	    fprintf( file, "\\par\n");
	    
	parm = parm->next;
    }

    fSubBlock--;
}


/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFFlagOut | This function output a list of flags to
 *  the output file based on the current mode of output and where
 *  the flags are attached.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm aFlag * | flag | Specifies the list of flags.
 *
 * @parm int | hselect | Specifies the current mode of output.
 *
 * @flag FUNCHELP |  Specifies the current block is a Function,
 *  and the mode is RTFHELP.
 *
 * @flag MSGHELP  |  Specifies the current block is a Message,
 *  and the mode is RTFHELP.
 *
 * @flag CBHELP   |  Specifies the current block is a Call Back,
 *  and the mode is RTFHELP.
 *
 * @flag FUNCDOC  |  Specifies the current block is a Function,
 *  and the mode is RTFDOC.
 *
 * @flag MSGDOC   |  Specifies the current block is a Message,
 *  and the mode is RTFDOC.
 *
 * @flag CBDOC	  |  Specifies the current block is a Call Back,
 *  and the mode is RTFDOC.
 *
 * @flag INTDOC   |  Specifies the current block is an Interrupt,
 *  and the mode is RTFDOC.
 *
 * @flag INTHELP  |  Specifies the current block is an Interrupt,
 *  and the mode is RTFHELP.
 *
 * @flag MASMDOC  |  Specifies the current block is a MASM,
 *  and the mode is RTFDOC.
 *
 * @flag MASMHELP |  Specifies the current block is a MASM,
 *  and the mode is RTFHELP.
 *
 * @parm int | flags | Specifies where the flags are attached.
 *
 * @flag FLAGPARM | Flags are attached to Parameters.
 *
 * @flag FLAGRTN | Flags are attached to Return Description.
 *
 * @flag FLAGREG | Flags are attached to Register Description.
 *
 */
void
RTFFlagOut(FILE *file, aFlag *flag, int hselect, int flags)
{
    int lih,lisep,fih,fisep;
    char *parh,*parsep;
    
    fSubBlock++;

    assert(flag);

// everything should look more like this....

    switch(hselect)
    {


	case MASMHELP:
	case INTHELP:
	case CBHELP:

	case FUNCHELP:
	case MSGHELP:
	case UNIONHELP:
	case STRUCTHELP:
	    if(flags==FLAGRTN)
	    {
		fprintf( file, hparmhelp );
		fprintf( file, p3a);
		fprintf( file, sepparmhelp);
		fprintf( file, p3b);
	    }
	    else
	    {
		fprintf( file, hvalhelp );
		fprintf( file, p3a);
		fprintf( file, sepvalhelp);
		fprintf( file, p3b);
	    }
//	    lih=5760;
//	    lisep=5760;
//	    fih=-2160;
//	    fisep=0;
//	    parh="plain";
//	    parsep="plain";
    while( flag )
    {
#if 1	
	fprintf(file,"\\par ");
#else	
	if(flags==FLAGRTN)
	    fprintf( file, hparmhelp );
	else
	    fprintf( file, hvalhelp );
#endif

	RTFtextOut( file, flag->name );

	if(flags==FLAGRTN)
	    fprintf( file, sepparmhelp );
	else
	    fprintf( file, sepvalhelp);

	RTFtextOut( file, flag->desc );
	
//	if(flag)
//	    fprintf( file, "\\par " );

	flag = flag->next;
	}

	    break;


	case INTDOC:
	case MASMDOC:
	case CBDOC:

	case FUNCDOC:
	case MSGDOC:
	case STRUCTDOC:
	case UNIONDOC:
		fprintf( file, hvaldoc );
		fprintf( file, p3a);
		fprintf( file, sepvaldoc);
		fprintf( file, p3b);


//	    lih= (flags==FLAGRTN) ? 1080 : 2160;
//	    lisep=(flags==FLAGRTN) ? 3240 : 4320;
//	    fih=0;
//	    fisep=0;
//	    parh=(flags==FLAGRTN) ? "sbys\\ri3200" : "sbys\\ri4280";
//	    parsep="sbys";
    while( flag )
    {
	fprintf( file, hvaldoc );
	RTFtextOut( file, flag->name );

	fprintf( file, sepvaldoc);

	RTFtextOutLn( file, flag->desc );
	fprintf( file, "\\par " );

	flag = flag->next;
    }

	    break;
    }


    fSubBlock--;
}

/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFFileInit | This routine is called before a list of files
 *  in a log structure are processed.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm files | headfile | Specifies the list of files.
 *
 * @xref RTFGenIndex
 */
void
RTFFileInit(FILE * phoutfile, logentry *curlog)
{
    files curfile;
    files headfile;
    

    copylines(phoutfile,headrtf);

    if(outputType==RTFDOC)
    {
	fprintf(phoutfile,"{\\header \\pard \\qc\\ri-1800\\li-1800\\sl0 ");
	fprintf(phoutfile,"\\plain \\ul\\sl240 \\plain \\f26\\fs20 "
		    "Microsoft Confidential\\plain \\par}\n");
	fprintf(phoutfile,"{\\footer \\pard \\qc\\ri-1800\\li-1800\\sl0"
		     "\\plain \\f26\\fs20 Page \\chpgn \\par}\n");
    }
    else if(outputType==RTFHELP && !fMMUserEd)
    {

	fprintf(phoutfile,"\\plain\\f26\\fs20\n");
	fprintf(phoutfile,"#{\\footnote \\pard \\sl240 \\plain \\f26 #\\plain \\f26 ");
	fprintf(phoutfile,"%s_index}\n","");
	fprintf(phoutfile,"${\\footnote \\pard \\sl240 \\plain \\f26 $\\plain \\f26 ");
	fprintf(phoutfile,"%s Index}\n","");

	fprintf(phoutfile,"\\plain\\f26\\fs20\\par\\par\n");
	fprintf(phoutfile,"For information on how to use Help, press F1 or choose\n");
	fprintf(phoutfile," Using Help from the Help menu.\\par\n");


	headfile=curlog->outheadFile;
	if(headfile)
	{
    
	    fprintf(phoutfile,"\\plain\\f26\\fs24\\par\\par\n");
	    fprintf(phoutfile,"{\\b Functions Index}\n");

	    fprintf(phoutfile,"\\plain\\f26\\fs20\\par\\par\n");
	    curfile=headfile;
	    while(curfile)
	    {
		if(curfile->name)
		    RTFGenIndex(phoutfile, curfile);
		curfile=curfile->next;
	    }

	    fprintf(phoutfile,"\\plain\\f26\\fs20\\par\\par\n");
	}
	headfile=curlog->outheadMFile;
	if(headfile)
	{
    
	    fprintf(phoutfile,"\\plain\\f26\\fs24\\par\\par\n");
	    fprintf(phoutfile,"{\\b Messages Index}\n");

	    fprintf(phoutfile,"\\plain\\f26\\fs20\\par\\par\n");
	    curfile=headfile;
	    while(curfile)
	    {
		if(curfile->name)
		    RTFGenIndex(phoutfile, curfile);
		curfile=curfile->next;
	    }

	    fprintf(phoutfile,"\\plain\\f26\\fs20\\par\\par\n");
	}
	headfile=curlog->outheadSUFile;
	if(headfile)
	{
    
	    fprintf(phoutfile,"\\plain\\f26\\fs24\\par\\par\n");
	    fprintf(phoutfile,"{\\b Data Structures Index}\n");

	    fprintf(phoutfile,"\\plain\\f26\\fs20\\par\\par\n");
	    curfile=headfile;
	    while(curfile)
	    {
		if(curfile->name)
		    RTFGenIndex(phoutfile, curfile);
		curfile=curfile->next;
	    }

	    fprintf(phoutfile,"\\plain\\f26\\fs20\\par\\par\n");
	}
    
	fprintf(phoutfile,"\\par Entire contents Copyright 1990, "
	    "Microsoft Crop. All rights reserved.\\par\\par\n");
	 
    }

    return;
}

/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFGenIndex | This function outputs a reference to a block name.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm files | curfile | Specifies the file structure with the block name.
 *
 */
void
RTFGenIndex(FILE * file, files curfile)
{
    fprintf( file, "\\tab {\\uldb\\f26\\fs20 ");
    fprintf( file, "%s",curfile->name);
    fprintf( file, "}{\\v\\f26\\fs20 ");
    fprintf( file, "%s",curfile->name);
    fprintf( file, "}\\plain\\f26\\fs20\\par\n");

}

/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFFileProcess | This function is called for each file that
 *  is being processed.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm files | curfile | Specifies the file.
 *
 */
void
RTFFileProcess(FILE * phoutfile, files curfile)
{
    copyfile(phoutfile,curfile->filename);
    return;

}

	
/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFFileDone | This function is called when all files in a list
 *  of files have been processed.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm files | headfile | Specifies the file.
 *
 */
void
RTFFileDone(FILE * phoutfile, files headfile)
{
#if 0    
    if(blocksprocessed > 100 && outputType==RTFHELP)
    {
	fprintf( phoutfile, "\\par\\page K{\\footnote{\\up6 K} "); /* keyword */
	fprintf( phoutfile, "mmGetCredits" );
	fprintf( phoutfile, "} ${\\footnote{\\up6 $} "); /* section Title */
	fprintf( phoutfile, "Credits" );
	fprintf( phoutfile, "} +{\\footnote{\\up6 +} "); /* order */
	fprintf( phoutfile, "CREDITS");
	fprintf( phoutfile, "}\n");
	
	fprintf( phoutfile, head0help);
	fprintf( phoutfile,  "Credits");
	fprintf( phoutfile, ehead0help);
	fprintf( phoutfile,  "\\parAutomatic documentation Tool by\\par");
	fprintf( phoutfile,
,		" Russell Wiliams, Mark McCulley and Matt Saettler\\par\n");
	fprintf( phoutfile, "\\par Windows SDK and Multimedia MDK documentation and generation program by Matt Saettler\n");
	fprintf( phoutfile, "\\par Windows SDK layout and processing by Todd Laney and Matt Saettler\\par\n");
	
    }
#endif    
    copylines(phoutfile,tailrtf);
    return;
}


/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFLogInit | This function is called before a list of log
 *  files are to be processed.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm logentry ** | pheadlog | Specifies the head of the log list.
 *
 */
void
RTFLogInit(FILE * phoutfile, logentry * * pheadlog)
{
    FILE *fp;
    char achbuf[180];
    int j;
    
    if(outputType==RTFHELP)
    {
	j=findlshortname(outputFile);
	strncpy(achbuf,outputFile,j);
	achbuf[j]=0;
	strcat(achbuf,".hpj");
	fp=fopen(achbuf,"r");
	
	if(!fp)	// file doesn't exist
	{
	    fp=fopen(achbuf,"w");
	    assert(fp);
	    
	    fprintf(fp,"; HPJ file automagically generated by DOCFMT\n");
	    fprintf(fp,"[files]\n");
	    fprintf(fp," %s\n",outputFile);
	}
	fclose(fp);
    }
    return;
}

/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFLogProcess | This function is called for each log to be processed.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm logentry * | curlog | Specifies the current log.
 *
 */
void
RTFLogProcess(FILE * phoutfile, logentry * curlog)
{
    return;
}

/*
 * @doc INTERNAL RTF
 *
 * @func void | RTFLogDone | This function is called after a list of logs
 *  has been processed.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm logentry * | headlog | Specifies the head of the log list.
 *
 */
void
RTFLogDone(FILE * phoutfile, logentry * headlog)
{
    return;
}


/*
 * @doc INTERNAL RTF
 *
 * @func void | copylines |  This function appends the array of lines
 *  to the output file.
 *
 * @parm FILE * | file | Specifies the output file.
 *
 * @parm char ** | papch | Specifies the array of lines.
 *
 * @comm The list is terminated by a NULL pointer.
 *
 */
void
copylines(FILE * phoutfile, char **lines)
{
    assert(lines);
    while(*lines)
    {
	fprintf(phoutfile, "%s",*lines);
	lines++;
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\text.c ===
/*	
	text.c - Module to work with the text strings.
...
10-15-89 MHS	More Autodoc and more asserts.

*/

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "types.h"
#include "text.h"
#include "docfmt.h"
#include "errstr.h"
#include "misc.h"

/*
 *  @doc INTERNAL
 *
 *  @func void | stripNewline | This function strips trailing white space.
 *
 *  @parm char * | pch |  Specifies the line to strip.
 *   and trailing white space.
 *
 */
void
stripNewline(char *pch)
{
    int i;
    unsigned char *puch;

    assert(pch);

    i=strlen(pch);
    puch=(unsigned char *)pch;	    // so isspace always works

    while(i>=0) 		    // process whole string from end
    {
	if(!isspace(puch[i]))	    // if it is evil,
	    return;
	puch[i]='\0';		    // nuke it
	--i;

    }
}


/*
 *  @doc INTERNAL
 *
 *  @func BOOL | getLine | This function gets a line from the file
 *  specified by Input file structure and puts it into the line buffer.
 *
 *  @parm EXTFile * | pExt | Specifies the file.
 *
 *  @rdesc The return value is FALSE if there was an error
 *   reading the file.
 *
 *  @xref stripNewline
 */
BOOL getLine( EXTFile *pExt )
{
    if(!pExt->lineBuffer)	// if it doesn't already exist,
	pExt->lineBuffer=my_malloc(MAXLINESIZE + 1);	// make it

    if(!pExt->lineBuffer)
    {
	error(ERROR3);
	return (FALSE);
    }
    if( fgets(pExt->lineBuffer, MAXLINESIZE, pExt->fp) != NULL )
    {
	/* replace the newline with a NULL */
	stripNewline(pExt->lineBuffer);
	pExt->curlineno++;	// increment line count
	pExt->curtag=0; 	// new line. no current tag.
	pExt->curlinepos=0;	// start at beginning of line.
	return( TRUE );
    }
    else
    {
	return( FALSE );
    }
}

/*
 *	@doc INTERNAL
 *
 *	@func char * | lineText | This function tells if the line has any
 *	text on it.
 *
 *	@rdesc The return value is NULL if there is no text on the line.
 *	It is the location of the text otherwise.
 */
char * lineText(char *pch)
{

    while( (*pch) && *pch!='\n')
    {
	if( !isspace(*pch))
	{
	    return( pch );
	}
	pch++;
    }
    return( NULL );
}


/*
 *	@doc INTERNAL
 *
 *	@func char * | lineMake | This allocates the line structure, 
 *	 sets the text string and nulls out the next feild of the structure.
 *
 *	@parm char * | string | Specifies a pointer to the 
 *	 string to be set up as a line processed.
 *
 *	@rdesc The return value is a pointer to the line structure
 */
aLine * lineMake(string)
char *string;
{
    aLine *line;
    char *pch;
    int i;

    /* strip leading white space */
    while(isspace(*string))
	string++;

    i=0;
    pch=string;
    while(*pch)
    {
	i++;
	++pch;
    }

    --pch;		     // get before \0
    while(i>0 && isspace(*pch))
    {
	*pch='\0';	    // nuke white space at EOS
	--pch;
	--i;
    }

    /* make aLine structure */
    line = (aLine *)my_malloc( 1 + strlen(string) + sizeof( aLine ) );
    if( line == NULL )
    {
	error(ERROR3);
	return( NULL );
    }
    strcpy( line->text, string );
    line->next = NULL;
    return( line );
}

/*
 *	@doc INTERNAL
 *
 *	@func void | lineDestroy | This de-allocates the list of line structures.
 *
 *  @parm aLine * | line | Specifies the head of the list.
 */
void
lineDestroy( line )
aLine *line;
{
    aLine *next;

    while( line != NULL )
    {
	next = line->next;
	my_free( line );
	line = next;
    }
}

/*
 *  @doc INTERNAL
 *
 *  @func void | lineAdd | This adds the given line to the list of
 *   lines.
 *
 *  @parm aLine * * | place | Specifies a the head of the list lines.
 *
 *  @parm aLine * | line | Specifies the line to add.
 *
 *  @comm The line is added to the end of the list.
 */
void
lineAdd( place, line )
aLine * * place;
aLine * line;
{
    assert(place);

    while( *place != NULL )
    {
	place = (aLine **)(*place);
    }
    *place = line;
}
	
/*
 *	@doc INTERNAL
 *
 *	@func aFlag * | flagAlloc | This allocates and nulls out
 *	a flag structure;
 *
 *	@rdesc The return value is a pointer to the flag structure
 */
aFlag * flagAlloc()
{
    aFlag *flag;

    flag = (aFlag *)clear_alloc( sizeof( aFlag ) );
    if( !flag )
    {
	error(ERROR3);
	return( NULL );
    }
    return( flag );
}

/*
 *  @doc INTERNAL
 *
 *  @func void | flagDestroy | This de-allocates a list of flag structures.
 *
 *  @parm aFlag *|flag| Specifies the head of the list to destroy.
 *
 *  @xref lineDestroy
 */
void flagDestroy( flag )
aFlag *flag;
{
    aFlag * next;
	
    while( flag )
    {
	next = flag->next;
	lineDestroy( flag->name );
	lineDestroy( flag->desc );

	my_free( flag );
	flag = next;
    }
}

/*
 *	@doc INTERNAL
 *
 *	@func void | flagAdd | This adds the given flag to the list of
 *	 flags.
 *
 *	@parm aFlag * * | place | Specifies a pointer to the pointer
 *	 that is the list start
 *
 *	@parm aFlag * | flag | Specifies the flag to add.
 */
void flagAdd( place, flag )
aFlag * * place;
aFlag * flag;
{
	if( place == NULL ) {
		return;
	}
	while( *place != NULL ) {
		place = &((*place)->next);
	}
	*place = flag;
}
	
/*
 *	@doc INTERNAL
 *
 *	@func aReg* | regAlloc | This allocates and nulls out
 *	a reg structure;
 *
 *	@rdesc The return value is a pointer to the parm structure
 */
aReg * regAlloc()
{
    aReg *reg;

    reg = (aReg *)clear_alloc( sizeof( aReg ) );
    if(! reg )
    {
	error(ERROR3);
	return( NULL );
    }
    return( reg );
}

/*
 *  @doc INTERNAL
 *
 *  @func void | regAdd | This adds the given reg to the list of
 *	 reg.
 *
 *  @parm aReg * * | place | Specifies the head of the list of regs.
 *
 *  @parm aReg * | parm | Specifies the reg to add.
 *
 *  @comm The register is added to the end of the list.
 */
void
regAdd( aReg * * place, aReg * reg )
{
	if( place == NULL )
	{
	    return;
	}
	while( *place != NULL )
	{
	    place = &((*place)->next);
	}
	*place = reg;
}

/*
 *  @doc INTERNAL
 *
 *  @func void | regDestroy | This de-allocates a list of reg structures.
 *
 *  @parm aReg * | reg | Specifies the head of the reg structure to destroy.
 *
 *  @xref lineDestroy, flagDestroy
 *
 */
void regDestroy( aReg *reg  )
{
    aReg * next;

    while( reg != NULL )
    {
	next = reg->next;

	lineDestroy( reg->name );
//	       lineDestroy( reg->type );
	lineDestroy( reg->desc );

	flagDestroy( reg->flag );
	my_free( reg );
	reg = next;
    }
}

/*
 *	@doc INTERNAL
 *
 *	@func aCond* | condAlloc | This allocates and nulls out
 *	a cond structure;
 *
 *	@rdesc The return value is a pointer to the parm structure
 */
aCond * condAlloc()
{
    aCond *cond;

    cond = (aCond *)clear_alloc( sizeof( aCond ) );
    if(! cond )
    {
	error(ERROR3);
	return( NULL );
    }
    return( cond );
}

/*
 *  @doc INTERNAL
 *
 *  @func void | condAdd | This adds the given cond to the list of
 *	 conds.
 *
 *  @parm aCond * * | place | Specifies the head of the list of conds.
 *
 *  @parm aCond * | parm | Specifies the cond to add.
 *
 *  @comm The Condition is added to the end of the list.
 */
void
condAdd( aCond * * place, aCond * cond )
{
	if( place == NULL )
	{
	    return;
	}
	while( *place != NULL )
	{
	    place = &((*place)->next);
	}
	*place = cond;
}

/*
 *  @doc INTERNAL
 *
 *  @func void | condDestroy | This de-allocates a list of cond structures.
 *
 *  @parm aCond * | cond | Specifies the head of the cond structure to destroy.
 *
 *  @xref lineDestroy, regDestroy
 *
 */
void condDestroy( aCond *cond  )
{
    aCond * next;

    while( cond != NULL )
    {
	next = cond->next;

	lineDestroy( cond->desc );

	regDestroy( cond->regs );
	my_free( cond );
	cond = next;
    }
}


/*
 *	@doc INTERNAL
 *
 *	@func aParm * | parmAlloc | This allocates and nulls out
 *	a parm structure;
 *
 *	@rdesc The return value is a pointer to the parm structure
 */
aParm * parmAlloc()
{
    aParm *parm;

    parm = (aParm *)clear_alloc( sizeof( aParm ) );
    if(! parm )
    {
	error(ERROR3);
	return( NULL );
    }
    return( parm );
}

/*
 *	@doc INTERNAL
 *
 *	@func void | parmDestroy | This de-allocates a list of parm structures.
 *
 *  @parm aParm * |parm| Specifies the head of the parm structure to destroy.
 *
 *  @xref lineDestroy, flagDestroy
 *
 */
void parmDestroy( parm )
aParm *parm;
{
    aParm * next;

    while( parm != NULL )
    {
	next = parm->next;

	lineDestroy( parm->name );
	lineDestroy( parm->type );
	lineDestroy( parm->desc );

	flagDestroy( parm->flag );
	my_free( parm );
	parm = next;
    }
}

/*
 *  @doc INTERNAL
 *
 *  @func void | parmAdd | This adds the given parm to the list of
 *	 parms.
 *
 *  @parm aParm * * | place | Specifies the head of the list of parms.
 *
 *  @parm aParm * | parm | Specifies the parm to add.
 *
 *  @comm The paramater is added to the end of the list.
 */
void
parmAdd( place, parm )
aParm * * place;
aParm * parm;
{
	if( place == NULL )
	{
	    return;
	}
	while( *place != NULL )
	{
	    place = &((*place)->next);
	}
	*place = parm;
}


/*
 *	@doc INTERNAL
 *
 *	@func aField * | fieldAlloc | This allocates and nulls out
 *	a structure;
 *
 *	@rdesc The return value is a pointer to the structure
 */
aField * fieldAlloc()
{
    aField *field;

    field = (aField *)clear_alloc( sizeof( aField ) );
    if(! field )
    {
	error(ERROR3);
	return( NULL );
    }
    return( field );
}

/*
 *	@doc INTERNAL
 *
 *	@func void | FieldDestroy | This de-allocates a list of Field structures.
 *
 *  @Field aField * |Field| Specifies the head of the Field structure to destroy.
 *
 *  @xref lineDestroy, flagDestroy
 *
 */
void fieldDestroy( Field )
aField *Field;
{
    aField * next;

    while( Field )
    {
	next = Field->next;

	switch(Field->wType)
	{
	    case FIELD_TYPE:
		typeDestroy((aType *)Field->ptr);
		break;
	    case FIELD_STRUCT:
	    case FIELD_UNION:
		SUDestroy((aSU *)Field->ptr);
		break;
	    default:
  fprintf(stderr,"INTERNAL ERROR: unknown field type in destroy!\n");
		assert(FALSE);
		break;
	}
	my_free( Field );
	Field = next;
    }
}

/*
 *  @doc INTERNAL
 *
 *  @func void | FieldAdd | This adds the given Field to the list of
 *	 Fields.
 *
 *  @Field aField * * | place | Specifies the head of the list of Fields.
 *
 *  @Field aField * | Field | Specifies the Field to add.
 *
 *  @comm The paramater is added to the end of the list.
 */
void
FieldAdd( place, Field )
aField * * place;
aField * Field;
{
	if( place == NULL )
	{
	    return;
	}
	while( *place != NULL )
	{
	    place = &((*place)->next);
	}
	*place = Field;
}



/*
 *	@doc INTERNAL
 *
 *	@func aField * | fieldAlloc | This allocates and nulls out
 *	a structure;
 *
 *	@rdesc The return value is a pointer to the structure
 */
aType * typeAlloc()
{
    aType *type;

    type = (aType *)clear_alloc( sizeof( aType ) );
    if(! type )
    {
	error(ERROR3);
	return( NULL );
    }
    return( type );
}

/*
 *	@doc INTERNAL
 *
 *	@func void | FieldDestroy | This de-allocates a list of Field structures.
 *
 *  @Field aField * |Field| Specifies the head of the Field structure to destroy.
 *
 *  @xref lineDestroy, flagDestroy
 *
 */
void typeDestroy( type )
aType *type;
{
    while( type )
    {
	lineDestroy( type->name );
	lineDestroy( type->type );
	lineDestroy( type->desc );

	flagDestroy( type->flag );

	my_free( type );
	type=NULL;
    }
}




/*
 *	@doc INTERNAL
 *
 *	@func aField * | fieldAlloc | This allocates and nulls out
 *	a structure;
 *
 *	@rdesc The return value is a pointer to the structure
 */
aSU * SUAlloc()
{
    aSU *SU;

    SU = (aSU *)clear_alloc( sizeof( aSU ) );
    if(! SU )
    {
	error(ERROR3);
	return( NULL );
    }
    return( SU );
}

/*
 *	@doc INTERNAL
 *
 *	@func void | FieldDestroy | This de-allocates a list of Field structures.
 *
 *  @Field aField * |Field| Specifies the head of the Field structure to destroy.
 *
 *  @xref lineDestroy, flagDestroy
 *
 */
void SUDestroy( SU )
aSU *SU;
{

    while( SU )
    {


	lineDestroy( SU->name );
	lineDestroy( SU->desc );

	fieldDestroy( SU->field );

	my_free( SU );
	SU=NULL;
    }
}



/*
 *	@doc INTERNAL
 *
 *	@func aField * | fieldAlloc | This allocates and nulls out
 *	a structure;
 *
 *	@rdesc The return value is a pointer to the structure
 */
aOther * otherAlloc()
{
    aOther *other;

    other = (aOther *)clear_alloc( sizeof( aOther ) );
    if(! other )
    {
	error(ERROR3);
	return( NULL );
    }
    return( other );
}

/*
 *	@doc INTERNAL
 *
 *	@func void | FieldDestroy | This de-allocates a list of Field structures.
 *
 *  @Field aField * |Field| Specifies the head of the Field structure to destroy.
 *
 *  @xref lineDestroy, flagDestroy
 *
 */
void otherDestroy( other )
aOther *other;
{
    aOther * next;

    while( other )
    {
	next = other->next;

	lineDestroy( other->name );
	lineDestroy( other->desc );
	lineDestroy( other->type );

	my_free( other );
	other = next;
    }
}

/*
 *  @doc INTERNAL
 *
 *  @func void | FieldAdd | This adds the given Field to the list of
 *	 Fields.
 *
 *  @Field aField * * | place | Specifies the head of the list of Fields.
 *
 *  @Field aField * | Field | Specifies the Field to add.
 *
 *  @comm The paramater is added to the end of the list.
 */
void
otherAdd( place, other )
aOther * * place;
aOther * other;
{
	if( place == NULL )
	{
	    return;
	}
	while( *place != NULL )
	{
	    place = &((*place)->next);
	}
	*place = other;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\tail.h ===
char *tailrtf[]= 
{ 
"}\n",
 NULL  
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\types.h ===
/*
  types.h	defined types and constants.
 */

/* standard defines */
#define TRUE		1
#define FALSE		0
#define YES		1
#define NO		0
#define ON		1
#define OFF		0



/* useful typedefs */
typedef int	BOOL;
typedef unsigned long DWORD;
#define HIWORD(l)   ((int)((unsigned long)l >> 16L))
#define LOWORD(l)   ((int)((unsigned long)l ))

/* return codes */
#define ST_OK		0	
#define ST_EOF		1
#define ST_BADOBJ	2
#define ST_ERROR_EOF	3
#define ST_MEMORY	4
#define ST_ERROR	8


extern int outputType;

#define VENTURA 1
#define RTFHELP 2
#define RTFDOC 3

/* temp output file.  */
typedef struct strfile
{
struct strfile *next;
    char       *filename;	/* output file name */
    char       *name;		/* name for sorting */
    int		blockType;	// block type
struct s_log   *logfile;	/* logfile */

} *files, fileentry;

/* Log file */
typedef struct s_log
{
    struct s_log	*next;
    char		*pchlogname;	// logfile name
    struct stBlock	*pBlock;	// first regular Block
    struct stBlock	*pMBlock;	// first message Block
    struct _EXTFile	*pExt;		// input file
    files		inheadFile;	// list of files to read
    files		outheadFile;	// list of files in log
    files		outheadMFile;	// list of Message files in log
    files		outheadSUFile;	// list of struct/union files
    int 		outputType;	// type of data contained in log

} logentry;




#define MAXLINESIZE	512

/* multiple lines of text */
typedef struct stLine
{
    struct stLine   *next;
    char	    text[1];
} aLine;

/* a complete flag structure */
typedef struct stFlag
{
    struct stFlag   *next;
    aLine   *name;
    aLine   *desc;
} aFlag;

/* a complete parm structure */
typedef struct stParm
{
    struct stParm   *next;
    aLine   *name;
    aLine   *type;
    aLine   *desc;
    aFlag   *flag;
} aParm;

/* a complete reg structure */
typedef struct stReg
{
    struct stReg    *next;
    aLine   *name;
    aLine   *desc;
    aFlag   *flag;
    // no types on registers
} aReg;

/* a complete cond structure */
typedef struct stCond
{
    struct stCond    *next;
    aLine   *desc;		// text description of condition
    aReg    *regs;		// registers for condition
} aCond;

typedef struct stType
{
    int		level;
    aLine	*type;
    aLine	*name;
    aLine	*desc;
    aFlag	*flag;
    
} aType;

typedef struct stSU	// Struct or Union
{
    int		level;
    aLine	*name;
    aLine	*desc;
    struct stField *field;
    
} aSU;


typedef struct stOther
{
    struct stOther *next;
    aLine	*type;
    aLine	*name;
    aLine	*desc;
    
} aOther;

typedef struct stField
{
    struct stField *next;
    int		wType;	// type of field
#define FIELD_TYPE	1
#define FIELD_STRUCT	2
#define FIELD_UNION	3
//    int		level;	// level of current field (0 is beginning)
    void	*ptr;	// pointer to data for field of wType
    
} aField;


/* a complete block */
typedef struct stBlock
{
struct stBlock * next;
    fileentry  *poutfile;	    /* where we go */
 struct _EXTFile    *pExt;		 /* input file */

/* block type identifiers */
#define FUNCTION	0x10		// no special reason for numbering
#define MESSAGE		0x20
#define CALLBACK	0x30
#define MASMBLOCK	0x40
#define INTBLOCK	0x50
#define MASMCBBLOCK	0x60
#define STRUCTBLOCK	0x70		// TYPEBLOCK
#define UNIONBLOCK	0x80		// TYPEBLOCK

    int     blockType;

    int     srcline;		/* where we came from (before extract) */
    char    *srcfile;
    aLine   *doclevel;

    aLine   *name;	    // name
    aLine   *type;	    // type definitions
    aLine   *desc;	    // descrption
    aParm   *parm;	    // parameters
    aReg    *reg;	    // registers

    aField  *field;	    // fields for TYPEBLOCK
    aOther  *other;	    // other names for TYPEBLOCK
    aLine   *tagname;	    // other tag names for TYPEBLOCK

    
    aLine   *rtndesc;	    // return description
    aFlag   *rtnflag;	    // return flags
    aReg    *rtnreg;	    // Return registers only valid in ASM or INT Block
    aCond   *cond;	    // conditional return regs

    
    
    aLine   *comment;	    // comment block
    struct stBlock *cb;     // call-back block
    aLine   *xref;	    // cross-reference block
    aLine   *uses;	    // uses comment
    
} aBlock;

/* an input file */
typedef struct _EXTFile
{
    FILE *fp;		    /* the current FP */
    char *EXTFilename;	    /* file path/name */
    char *lineBuffer;	    /* line buffer */
    int   curlinepos;	    /* current location within the line buffer */
    int   curlineno;	    /* current line number within input file */
    DWORD curtag;	    // tag for current line.
    aLine *extractid;	     // id of extract tools
    aLine *extractdate;      // date of extract
    aLine *extractver;	     // version of extract

} EXTFile;


/* Extracted Database tag definitions */

struct codes_struct
{
    int igeneral;
    int icommand;
    char *pchcommand;
    int size;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\ventura.h ===
/*
	output.h - definitions for outputting the documentation text
*/

extern void VenturaBlockOut( aBlock *pBlock, FILE *ofile);

extern void VentextOut( FILE *, aLine *, BOOL );
extern void VentextOutLnCol(FILE *, aLine *, char *);

extern void VenfuncOut( aBlock *, FILE * );


/*  LogFile stuff  */
extern void VenFileInit(FILE * phoutfile, logentry *curlog);
extern void VenFileProcess(FILE * phoutfile, files curfile);
extern void VenFileDone(FILE * phoutfile, files headfile);
extern void VenLogInit(FILE * phoutfile, logentry * * pheadlog);
extern void VenLogProcess(FILE * phoutfile, logentry * curlog);
extern void VenLogDone(FILE * phoutfile, logentry * headlog);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\ventura.c ===
/*	
	ventura.c - Module to output the data.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>

#include "types.h"
#include "docfmt.h"
#include "text.h"
#include "ventura.h"
#include "process.h"
#include "errstr.h"


int VenLineOut(FILE * fpoutfile, char * pch, int wState);

/*  Formatting codes to output for ventura word formatting.
 */
char	*pchVenparm="<MI>";
char	*pchVenfunc="<B>";
char	*pchVenelem="<B>";
char	*pchVendefault="<D>";


#define NUMFLAGTYPES	8
#define REGISTERS	0
#define REGRETURN	1
#define REGCONDITION	2
#define PARAMETERS	3
#define PARAMRETURN	4
#define FIELD1		5
#define FIELD2		6
#define FIELD3		7


/*  "output" modes for the line out routines.  These
 *  signify what sort of formatting should be done.
 */
#define TEXT	0x0
#define PARM	0x1
#define FUNC	0x2
#define STRUCT	0x3
#define ELEMENT 0x4

#define OLDSTYLE	0x80
#define NEWSTYLE	0x40

/* 
 * @doc	VENTURA
 * @api	void | VenturaBlockOut | Central entry point for outputing a
 * Ventura format outerlevel block.
 * 
 * @parm	aBlock * | pBlock | Pointer to block structure.
 * @parm	FILE * | ofile | Output file pointer.
 * 
 * @comm	Call this to get something output in ventura.
 * 
 */
void VenturaBlockOut( aBlock *pBlock, FILE *ofile)
{
  VenfuncOut(pBlock, ofile);
}



/*************************************************************
 *
 *			LINE OUT STUFF
 *
 *************************************************************/

/* @doc	INTERNAL
 * 
 * @func	void | VentextOut | This outputs the given text lines.  Uses
 * <f VenLineOut> to expand formatting codes.
 * 
 * @parm	FILE * | file | Specifies the output file.
 * @parm	aLine * | line | Specifies the text to output.
 * 
 * @xref	VenLineOut
 * 
 */
void VentextOut( FILE *file, aLine *line, BOOL fLineSeps )
{
  int	wMode = TEXT;
  
  for (; line != NULL; line = line->next) {
	  wMode = VenLineOut( file, line->text, wMode );
	  if (fLineSeps)
		  fprintf(file, "\n");
  }
  
  if (wMode != TEXT) {
	  fprintf(errfp, "Warning: Runaway formatting code with no close.\n");
	  fprintf(file, "<D>");		// is this right?
  }
}



/* @doc	INTERNAL
 * 
 * @func	void | VentextOutLnCol | This outputs the given text lines,
 * with each line separated by a newline.  If a new paragraph occurs, it is
 * prefixed by the column prefix code <p pColHead>.
 * 
 * @parm	FILE * | file | Specifies the output file.
 * @parm	aLine * | line | Specifies the text lines to output.
 * @parm	char * | pColHead | Column header string to prefix new
 * paragraphs with.
 * 
 * @comm	Uses <f VenLineOut> to expand formatting codes.
 * 
 * @xref	VentextOut, VenLineOut
 * 
 */
void VentextOutLnCol( FILE *file, aLine *line, char *pColHead )
{
	
  int	wMode = TEXT;
	
  for (; line != NULL; line = line->next) {
	if (*(line->text) == '\0') {
		/*  Print warning if a formatting code is being
		 *  continued across a para boundry.
		 */
		if (wMode != TEXT) {
			fprintf(errfp, "Warning:  formatting code"
				"crosses paragraph boundry.\n");
		}

		/* blank line, need new paragraph header  */
		fprintf(file, "\n%s", pColHead);
	}
	else {
		/* Otherwise, normal line, print the line as usual */
		wMode = VenLineOut(file, line->text, wMode);
		fprintf(file, "\n");
	}
  }
  
  if (wMode != TEXT) {
	  fprintf(errfp, "Warning: Runaway formatting code with no"
		  "close before para end.\n");
	  fprintf(file, "<D>\n");		// is this right?
  }

}


/* 
 * @doc	INTERNAL
 * 
 * @func	int | VenLineOut | Output the given text line, expanding any
 * character/word formatting control codes to the appropriate ventura
 * control codes.
 * 
 * @parm	FILE * | fpoutfile | Output file pointer.
 * @parm	char * | line | Specifies the text to output.
 * @parm	int | wState | Specifies the current line output
 * state, either TEXT, FUNC, STRUCTURE, or PARM.  This value should initially
 * be TEXT.
 *
 * @rdesc	Returns the line output state at the end of the text line.
 * This value should be passed to <f VenLineOut> on the next iteration
 * in order to continue the formatting code across a line break.
 *
 * @comm	Reads and expands both old <p>foobar<d> style function
 * parameters and <p foobar> new-style parameters.
 * 
 * This functions sends out character strings.  Use <f VentextOut> and
 * <f VentextOut> for printing the aLine text storage data structures.
 * 
 */
int VenLineOut(FILE * fpoutfile, char * pch, int wState)
{

    /* 
     * <p> is parm
     * <f> is function
     * <t> is struct/union reference
     * <e> is structure element reference
     * <m> is message
     * <d> is return to default
     * <p foobar> is param
     * <f foobar> is function
     * <t foobar> is structure/union
     */

    BOOL	iStyle;
    char	chFormat;
	char	*pchTemp;
	
    /*  Loop over all chars on line  */
    while(*pch) {
	/*  Convert tabs into spaces.  */
	if(*pch == '\t')
	    *pch=' ';

        /*  Skip non-printing chars  */
	if (((*pch) & 0x80) || (*pch < ' ')) {
	    pch++;
	    continue;
	}

	
	/*  Check and see if this is a formatting prefix character.
	 */
	if (*pch == '<') {
		pch++;
		if (!*pch)
			/*  Warning!  Unexpected EOS  */
			continue;
		
		chFormat = *pch;
		
		/*  Move the character pointer to the characters following
		 *  the formatting, and determine the type of formatting code
		 *  in use, old or new style.
		 */
		pch++;	// skip the formatting character
		if (*pch == '>') {
			pch++;
			iStyle = OLDSTYLE;
		}
		else {
			/*  For a new style formatting code, there must be
			 *  either a EOL or whitespace following the code
			 *  character.  Make sure this is the case.  If not,
			 *  then this isn't a formatting code, so
			 *  just print the characters out.
			 */
			if (*pch && !isspace(*pch)) {
				fprintf(errfp,"Warning: New-style formatting "
		"code without whitespace.\nCode ignored but text printed.\n");
				/*  Write out the characters, but
				 *  don't enter a formatting state.
				 */
				putc('<', fpoutfile);
				putc(chFormat, fpoutfile);
				continue;	// the while (*pch)
			}

			/*  Otherwise, this a new style def.  Suck
			 *  up any whitespace present.
			 */
			iStyle = NEWSTYLE;
			/*  Chew up whitespace  */
			while (*pch && isspace(*pch))
				pch++;
		}
		
		/*  Now I'm pointing to the start of the string
		 *  that the formatting should be applied to.
		 *  Check that a formatting code is not already
		 *  in effect, cancel it if so.
		 */
		if (!(chFormat == 'd' || chFormat == 'D') && wState != TEXT) {
			fprintf(errfp, "Error:  Nested formatting codes.\n");
			fprintf(fpoutfile, "<D>");	// HACK HACK!
			wState = TEXT;
		}


		/*  Now setup the output state as appropriate, setting
		 *  the wState variable and outputting any leader chars
		 *  required.
		 */
		switch (chFormat) {
		  case 'P':
		  case 'p':
			  
			/*  Parameter formatting.  Output the
			 *  leader codes and setup wState.
			 */
			wState = iStyle | PARM;
			fprintf(fpoutfile, pchVenparm);
			break;
			
		  case 'E':
		  case 'e':
			  
			/*  Data structure element formatting.  Output the
			 *  leader codes and setup wState.
			 */
			wState = iStyle | ELEMENT;
			fprintf(fpoutfile, pchVenelem);

			/*  Skip over the structure notation (struct.element).
			 */
			pchTemp = pch;
			while (*pchTemp++ != '>') {
				if (*pchTemp == '.')
					pch = ++pchTemp;
			}
			break;
			
		  case 'F':
		  case 'f':
			/*  Function formatting.  Output & setup state */
			wState = iStyle | FUNC;
			fprintf(fpoutfile, pchVenfunc);
			break;

		  case 'D':
		  case 'd':
			if (iStyle == NEWSTYLE) {
				fprintf(errfp,"Error: <d foobar> encountered."
				     " <d> is the only valid use for <d>.\n");
				/*  Here, just print the <d_ anyway.  Then
				 *  set no mode, continue.
				 */
				fprintf(fpoutfile, "<d ");
			}
			else {
				/*  Oldstyle end of formatting encountered.
				 *  Cancel the current mode, output
				 *  a return-to-normal code (ventura is nice
				 *  for this one thing, being consistent in
				 *  what constitues return-to-normal!)
				 */
				wState = TEXT;	// reset mode
				fprintf(fpoutfile, "<D>");
			}
			break;
			
		  case 'T':
		  case 't':
			  
		  case 'M':
		  case 'm':
			  
			/*  Structure definition   */
			wState = iStyle | STRUCT;
			fprintf(fpoutfile, pchVenfunc);
			break;
			
		  default:
			/*  Unrecognized code.  Barf.
			 */
			fprintf(errfp, "Error: unrecognized"
				" formatting code.\n");
			
			/*  Simulate the output and set no mode  */
			if (iStyle == NEWSTYLE)
				fprintf(fpoutfile, "<%c ", chFormat);
			else
				fprintf(fpoutfile, "<%c>", chFormat);
			break;
		}	// switch for '<' formating codes
	}	// if *pch == '<'
	
	/*  If the character is a new-style close end formatting
	 *  indicator, clear the current mode to text and send out the
	 *  the ventura return-to-default code.
	 *
	 *  If there is no current mode, then just output the chracter?
	 */
		
	else if (*pch == '>') {
		if (wState != TEXT) {
			
			if (wState & OLDSTYLE) {
				fprintf(errfp, "Warning: new style close in "
		"oldstyle formatting.\nIgnoring close, writing char.\n");
				putc(*pch, fpoutfile);
			}
			else {
				/*  Cancel the current mode  */
				fprintf(fpoutfile, "<D>");
				wState = TEXT;
			}
		}
		else {
			fprintf(errfp, "Warning: Standalone '>' "
				"encountered.\n");
			putc(*pch, fpoutfile);
		}
		
		pch++;	// skip the '>'
		
	}
	else {
		/*  Just print the character  */
		putc(*pch, fpoutfile);
		pch++;
	}
	
    }	// while (*pch);
    
    /*  We're done!  Return the current output state  */
    return wState;

}



/****************************************************
 *
 *			XREFS
 *
 ****************************************************/

/* 
 * @doc	INTERNAL
 * @func	void | VenDoXrefs | Process and print the cross reference
 * list for a function or message block.
 * 
 * @parm	FILE * | file | Specifies the output file.
 * @parm	aLine * | line | The line of cross references to print.
 * 
 */
void VenDoXrefs( FILE *file, aLine *line)
{
  char	ach[80];
  int	i;
  char	*p;

  
  if (line == NULL) {
	  fprintf(errfp, "NULL line passed to VenDoXrefs\n");
	  return;
  }
  
  /*  Header line  */
  fprintf( file, "@HO = See Also\n\n" );  
  
  while (line != NULL) {
    /* skip whitespace */
    for (p = line->text; isspace(*p); p++);
    
    while (*p) {
	i = 0;
	while (*p && !(*p == ',' || isspace(*p)))
		ach[i++] = *p++;
	
	if (i > 0) {
		ach[i] = '\0';
		fprintf(file, "%s", ach);
	}

	while (*p && (*p == ',' || isspace(*p)))
		p++;
	if (*p)
		fprintf(file, ", ");
    }  /* while *p  */
    
    fprintf(file, "\n");
    line = line->next;
    if (line)
	    fprintf(file, " ");

  }	/* while line != NULL */
  
  fprintf(file, "\n");

}


/****************************************************
 *
 *			FLAGS
 *
 ****************************************************/

/* 
 * @doc	INTERNAL
 *
 * @func	void | VenDoFlagList | Print the flag list of a parameter,
 * register, or return description.
 * 
 * @parm	aFlag * | flag | Pointer to flag list to be printed.
 *
 * @parm	FILE * | file | Specifies the file to print to.
 *
 * @parm	WORD | wType | This parameter may be one of the following,
 * depending on the type of flag list being produced:
 *
 *   @flag	REGISTERS | This is a normal input register declaration, below
 *		a ASM or ASM callback function declaration.
 *   @flag	REGRETURN | This is a register return declaration beneath
 *		a return description.  This is not part of a conditional
 *		block.
 *   @flag	REGCONDITION | This is a register return declaration beneath
 *		a return conditional block.
 *   @flag	PARAMETERS | This is a normal parameter declaration beneath
 *		an API, or API Callback function or Message declaration.
 *   @flag	PARAMRETURN | This is a return flag list declaration beneath
 *		a return block in an API or API callback, or a Message return.
 */
void VenDoFlagList( aFlag *flag, FILE *file, int wType )
{
  static char *aszFlagNameOut[NUMFLAGTYPES] = {
	"@RFLAG = ",		// registers
	"@RFLAG = ",		// reg return
	"@RFLAG = ",		// reg condition return
	"@FLAG = ",		// param flag
	"@PARM = ",		// param return
	"@FLAG = ",		// level 1 field
	"@L2FLAG = ",		// level 2 field
	"@L3FLAG = ",		// level 3 field
  };

  static char *aszFlagDescOut[NUMFLAGTYPES] = {
	"@RFLDESC = ",		// registers
	"@RFLDESC = ",		// reg return
	"@RFLDESC = ",		// reg condition return
	"@FLDESC = ",		// param flag
	"@PDESC = ",		// param return
	"@FLDESC = ",		// level 1 field
	"@L2FLDESC = ",		// level 2 field
	"@L3FLDESC = ",		// level 3 field
  };

  if (!flag) {
	  fprintf(errfp, "Warning:  NULL Flag sent to VenDoFlaglist\n");
	  return;
  }

  assert(wType < NUMFLAGTYPES);
  
  /*  loop over the flag list  */
  for ( ; flag != NULL; flag = flag->next) {
	/*  Do flag name  */
	fprintf(file, aszFlagNameOut[wType]);
	VentextOut( file, flag->name, FALSE );
	fprintf( file, "\n\n" );

	/* Do the description */
	fprintf(file, aszFlagDescOut[wType]);
	VentextOutLnCol(file, flag->desc, aszFlagNameOut[wType]);

	fprintf( file, "\n" );
  }  // for flag list

}



/****************************************************
 *
 *			PARMS
 *
 ****************************************************/

/* 
 * @doc	INTERNAL
 * @func	void | VenDoParmList | Print the parameter list of a function
 * block.
 * 
 * @parm	aBlock * | pBlock | Specifies the enclosing block of the
 * parameter list.
 * @parm	aParm * | parm | The parameter list to print.
 * @parm	FILE * | file | Specifies the file to use for output.
 * 
 * @comm	Prints the given parameter list.  If parameters within the
 * list contain a flag list, the flag list is printed using
 * <f VenDoFlagList>.
 * 
 * @xref	VenDoFlagList
 * 
 */	
void VenDoParmList( aBlock *pBlock, aParm *parm, FILE *file )
{

  if (!parm) {
	  fprintf(file, "None\n\n");
  }
  else {
	  /*  Loop over the parameter list of the message  */
	  for (; parm != NULL; parm = parm->next) {
		  /*  Print first col, param type and name  */
		  fprintf( file, "@PARM = " );

		  VentextOut( file, parm->type, FALSE );

		  fprintf( file, "<_><MI>");
		  VentextOut( file, parm->name, FALSE );
		  fprintf( file, "<D>\n\n" );

		  /*  Do second column, the description  */
		  fprintf( file, "@PDESC = " );
		  VentextOutLnCol( file, parm->desc, "@PDESC = ");
		  // VentextOutLnCol( file, parm->desc, "@PDESC");
		  fprintf( file, "\n" );

		  /* Print the parameter's flags, if any */
		  if (parm->flag != NULL) {
			  VenDoFlagList(parm->flag, file, PARAMETERS);
		  }
	  }  // for parm list
  }
  
  /*  Close off the parameter list  */
  fprintf(file, "@LE = \n\n");
	  
}


/****************************************************
 *
 *		REGS AND CONDITIONALS
 *
 ****************************************************/


/* 
 * @doc	INTERNAL
 * @func	void | VenDoRegList | Print a register list.
 *
 * @parm	aBlock * | pBlock | Specifies the enclosing block of the
 * parameter list.
 * @parm	aReg * | reg | The register list to print.
 * @parm	FILE * | file | Specifies the file to use for output.
 *
 * @parm	WORD | wType | This parameter may be one of the following,
 * depending on the type of register list being produced:
 *
 *   @flag	REGISTERS | This is a normal input register declaration, below
 *		a ASM or ASM callback function declaration.
 *   @flag	REGRETURN | This is a register return declaration beneath
 *		a return description.  This is not part of a conditional
 *		block.
 *   @flag	REGCONDITION | This is a register return declaration beneath
 *		a return conditional block.
 *
 * @comm	Prints the given register list.  If registers within the
 * list contain a flag list, the flag list is printed using
 * <f VenDoFlagList>.
 * 
 * @xref	VenDoFlagList
 * 
 */	
void VenDoRegList( aBlock *pBlock, aReg *reg, FILE *file, int wType)
{
  static char *aszRegNameOut[] = {
	"@RNAME = ",		// registers
	"@RNAME = ",		// reg return
	"@RNAME = ",		// reg condition return
  };

  static char *aszRegDescOut[] = {
	"@RDESC = ",		// registers
	"@RDESC = ",		// reg return
	"@RDESC = ",		// reg condition return
  };
	
  assert(wType == REGISTERS || wType == REGRETURN || wType == REGCONDITION);
	
  if (reg == NULL) {
	  fprintf(file, "None\n\n");
  }
  else {
	  /*  Loop over the register list of the message  */
	  for (; reg != NULL; reg = reg->next) {
		  /*  Print first col, reg name  */
		  fprintf( file, aszRegNameOut[wType]);
		  
		  /*  Print the register name  */
		  fprintf( file, "<B>" );
		  VentextOut( file, reg->name, FALSE );
		  fprintf( file, "<D>\n\n" );

		  /*  Do second column, the description  */
		  fprintf( file, aszRegDescOut[wType] );
		  VentextOutLnCol( file, reg->desc, aszRegDescOut[wType] );
		  fprintf( file, "\n" );

		  /* Print the parameter's flags, if any */
		  if (reg->flag != NULL) {
			  VenDoFlagList(reg->flag, file, wType);
		  }
	  }  // for reg list
  }
  
  fprintf(file, "@LE = \n\n");

}



/* 
 * @doc	INTERNAL
 * 
 * @func	void | VenDoCondList | Print a conditional register list.
 * 
 * @parm	aBlock * | pBlock | Specifies the enclosing block of the
 * register list.
 * 
 * @parm	aCond * | cond | The conditional list to print.
 * 
 * @parm	FILE * | file | Specifies the file to use for output.
 * 
 * @comm	Prints the given conditional list.  For each conditional
 * block, the text is printed, followed by the the list of registers
 * (and their associated tags) for the conditional block.
 * 
 * @xref	VenDoRegList, VenDoFlagList
 * 
 */	
void VenDoCondList( aBlock *pBlock, aCond *cond, FILE *file)
{
	
  assert(cond != NULL);

  /*  Loop over the register list of the message  */
  for (; cond != NULL; cond = cond->next) {
	  
	  /*  Print out the conditional tag text..  */
	  fprintf( file, "@COND = ");
	  VentextOutLnCol(file, cond->desc, "@COND = ");
	  
	  fprintf( file, "\n");
	  
	  /*  Now print the conditional's registers (and subseqent flags) */
	  VenDoRegList(pBlock, cond->regs, file, REGCONDITION);
	  
  }  // for conditional list

  fprintf(file, "@LE = \n\n");

}


/*******************************************************
 *
 *			STRUCTS
 *
 *******************************************************/
	  
	  
/* 
 * VenPrintFieldText(aType *type, FILE *file)
 * 
 * Prints the text of a field for a structure courier dump.  This proc
 * only prints the name and type of structure fields at the appropriate
 * indent levels.
 * 
 */
void VenPrintFieldText(aType *type, FILE *file)
{
  int	i;
  
  for (i = type->level + 1; i > 0; i--)
	  fprintf(file, "    ");
  
  VentextOut(file, type->type, FALSE);
  fprintf(file, "  ");

  VentextOut(file, type->name, FALSE);

  fprintf(file, ";<R>\n");

  /*  Flags?  */
}


/* 
 * VenPrintSubstructText(aSU *su, file, wType)
 * 
 * Prints a courier dump of a sub-structure or sub-union at the
 * appropriate indent level.  Does not print any description text.
 * 
 * wType must indicate whether this is a union or structure, being
 * either FIELD_STRUCT or FIELD_UNION.
 * 
 */
void VenPrintSubstructText(aSU *su, FILE *file, int wType)
{
  int		i;
  aField	*field;
  
  
  /*  Do struct/union and brace of sub-structure  */
  for (i = su->level; i > 0; i--)
	  fprintf(file, "    ");
  
  fprintf(file, "%s {<R>\n", wType == FIELD_STRUCT ? "struct" : "union");
  
  field = su->field;
  if (field) {
    while (field) {
	switch (field->wType) {
		case FIELD_TYPE:
			VenPrintFieldText((aType *) field->ptr, file);
			break;
			
		case FIELD_STRUCT:
		case FIELD_UNION:
			VenPrintSubstructText((aSU *) field->ptr,
					file, field->wType);
			break;
	}
	field = field->next;
    }
  }

  /*  Do closing brace and title of sub-structure  */
  for (i = su->level; i > 0; i--)
	  fprintf(file, "    ");
  
  fprintf(file, "} %s;<R>\n", su->name->text);
  
}



/* 
 * VenPrintStructText(pBlock, file, wType)
 * 
 * Prints a courier dump of the text of a structure/union outerlevel
 * block.  Does not print any description fields or flags.
 * 
 * wType indicates whether the block is a structure or union, either
 * FIELD_STRUCT or FIELD_UNION.
 * 
 */
void VenPrintStructText(aBlock *pBlock, FILE *file)
{
  aField	*curf;
  aLine		*tag;

  curf = pBlock->field;
  tag = pBlock->tagname;
  
  fprintf(file, "@EX = typedef %s ", 
	  pBlock->blockType == STRUCTBLOCK ? "struct" : "union");
  if (tag)
	  fprintf(file, "%s ", tag->text);
  
  fprintf(file, "{<R>\n");
  
  while (curf) {
    switch (curf->wType) {
	case FIELD_TYPE:
		VenPrintFieldText((aType *) curf->ptr, file);
		break;
		
	case FIELD_STRUCT:
	case FIELD_UNION:
		VenPrintSubstructText((aSU *) curf->ptr, file, curf->wType);
		break;
		
	default:
		assert(FALSE);
		break;
    }
    curf = curf->next;
  }
  fprintf(file, "} %s;\n\n", pBlock->name->text);
  
  /*  Now print out the othernames?  */
}


/*********  DESCRIPTION DUMPS  ************/

#define NUMFIELDLEVELS 3

char *aachFieldNameTags[NUMFIELDLEVELS] = {
	"@PARM = ", "@L2PARM = ", "@L3PARM = "
};
char *aachFieldDescTags[NUMFIELDLEVELS] = {
	"@PDESC = ", "@L2PDESC = ", "@L3PDESC = "
};

int aiFlagTypes[NUMFIELDLEVELS] = { FIELD1, FIELD2, FIELD3 };


/* 
 * @doc	INTERNAL
 * 
 * @api	void | VenPrintFieldDesc | This function prints the
 * descriptions of a field entry in a structure.  The printout is done
 * using the standard @parm tags (and associated flag tags).
 * 
 * @parm	aType * | type | Points to a type structure which contains
 * the field information.
 * 
 * @parm	FILE * | file | Specifies the output file.
 * 
 * @comm	Use this function to output the names/descriptions of fields.
 * Use <f VenPrintFieldText> to output a similated text dump of the
 * structure definition.
 * 
 * Note that the use of this function requires an @LE tag be output when
 * the list of parameters has been ended.
 * 
 */
void VenPrintFieldDesc(aType *type, FILE *file)
{
  int level;

  level = type->level;
  if (level >= NUMFIELDLEVELS)
	  level = NUMFIELDLEVELS - 1;

  /*  Print the field type and name in the first column, formatted */
  fprintf(file, "%s<B>", aachFieldNameTags[level]);
  VentextOut(file, type->name, FALSE);
  fprintf(file, "<D>\n\n");
#if 0
  /*  Print parameter type above?  */
  fprintf(file, "<_><MI>");
  VentextOut(file, type->name, FALSE);
  fprintf(file, "\n\n");
#endif

  /*  Do the second column, description text  */
  fprintf(file, aachFieldDescTags[level]);
  VentextOutLnCol(file, type->desc, aachFieldDescTags[level]);
  putc('\n', file);

  /*  Do the flag list, if any  */
  if (type->flag != NULL) {
	  VenDoFlagList(type->flag, file, aiFlagTypes[level]);
  }
  
  /*  Now, somewhere, a @LE = needs to be output!  */
  
}




void VenPrintSubstructDesc(aSU *su, FILE *file, int wType)
{
  aField	*field;
  int level;
  int levelStruct;
  
  /*  Limit level to the number of nesting levels supported by Ventura  */
  level = min(NUMFIELDLEVELS - 1, su->level);

  levelStruct = level - 1;
  
  /*  For the sub-structure, print out a little blurb for
   *  the sub-structure/union itself, as well as the optional
   *  description text that may come with a sub-structure.
   */
  
  fprintf(file, aachFieldNameTags[levelStruct]);
  fprintf(file, "<B>%s<D>\n\n", su->name->text);

  if (su->desc) {
	  fprintf(file, aachFieldDescTags[levelStruct]);
	  VentextOutLnCol(file, su->desc, aachFieldDescTags[levelStruct]);
	  putc('\n', file);
  }

  /*  Now print the sub-fields  */
  fprintf(file, aachFieldDescTags[levelStruct]);
  fprintf(file, "The following sub-fields are contained in %s <B>%s<D>:\n\n",
	  wType == FIELD_STRUCT ? "structure" : "union",
	  su->name->text);

  /*  Now do each field of the sub-structure  */
  field = su->field;
  if (field) {
    while (field) {
	switch (field->wType) {
		case FIELD_TYPE:
			VenPrintFieldDesc((aType *) field->ptr, file);
			break;

		case FIELD_STRUCT:
		case FIELD_UNION:
			VenPrintSubstructDesc((aSU *) field->ptr,
					file, field->wType);
			break;
	}
	field = field->next;
    }
  }

  /*  Print a closing blurb  */
  fprintf(file, aachFieldNameTags[levelStruct]);
  fprintf(file, "End of sub-fields for %s %s.\n\n",
	  wType == FIELD_STRUCT ? "structure" : "union", su->name->text);

}



void VenDoStructDescriptions(aBlock *pBlock, FILE *file)
{
  aField	*cur;
  
  /*  Look through the field list, printing each field as it is
   *  encountered using @parm tags...
   */

  fprintf(file, "@HO = Fields\n\n");

  fprintf(file, "The <b>%s<d> %s has the following fields:\n\n",
		pBlock->name->text,
		pBlock->blockType == STRUCTBLOCK ? "structure" : "union");

  /*  Dump the structure  */
  cur = pBlock->field;
  if (cur == NULL) {
	fprintf(file, "None\n\n");
	return;
  }

  while (cur) {
    switch (cur->wType) {
	case FIELD_TYPE:
		VenPrintFieldDesc((aType *) cur->ptr, file);
		break;
		
	case FIELD_STRUCT:
	case FIELD_UNION:
		VenPrintSubstructDesc((aSU *) cur->ptr, file, cur->wType);
		break;
		
	default:
		assert(FALSE);
		break;
    }
    cur = cur->next;
  }

  /*  Close off the param list  */
  fprintf(file, "@LE = \n\n");

  /*  Print out othertypes?  */
  
}

	  


	  
/*********************************************************
 *
 *			DOC BLOCK
 *
 *********************************************************/

/* 
 * @doc	INTERNAL
 * @func	void | VenfuncOut | This outputs the function information.
 * 
 * @parm	aBlock * | func | Specifies a pointer to the function
 * information.  The type of the block is determined by looking at the
 * blocktype field.
 * 
 * @parm	FILE * | file | Specifies the output file.
 * 
 * @comm	This function may be called recursively to deal with callback
 * procedures.  It handles most anything.
 * 
 */
void VenfuncOut( aBlock *func, FILE *file )
{
  aParm		*parm;
  aBlock	*pCb;
  int		type;

  /*  Pointer to tag header type - depends on block type  */
  char		*pIntHeader;
  static char	achCbHeader[] = "@HU =";
  static char	achFuncHeader[] = "@HO =";

  if( func == NULL || file == NULL) {
	  fprintf(errfp, "Bogus params to VenFuncOut!\n");
	  return;
  }

  /* Get the blocktype for this block, do different things according to
   * type.
   */
  type = func->blockType;

  /*
   *  DO THE BLOCK HEADER
   */
  switch (type) {
    case FUNCTION:
	/*  use interior headers of normal level  */  
	pIntHeader = achFuncHeader;

	/* Block header */
	fprintf(file, "@HR = ");
	VentextOut(file, func->name, FALSE);
	fprintf(file, "\n\n");

	/*  Setup API description  */
	fprintf( file, "@HO = Syntax\n\n" );

	VentextOut( file, func->type, FALSE );
	fprintf( file, "<_><B>" );
	VentextOut( file, func->name, FALSE );
	fprintf( file, "<D>" );

DoFunctionBlockHeader:
	/*  Print the function header line, with parameters  */
	fprintf(file, "(");
	for (parm = func->parm; parm != NULL; ) {
		fprintf(file, "<MI>");
		VentextOut(file, parm->name, FALSE);
		fprintf(file, "<D>");
		/* Advance */
		parm = parm->next;
		if (parm != NULL) 
			fprintf(file, ", ");
	}
	fprintf(file, ")\n\n");
	// fprintf(file, "\n\n");

	break;
	
    case CALLBACK:
	/* Use callback interior header styles */
	pIntHeader = achCbHeader;

	/* Print function header setup */
	fprintf(file, "@HO = Callback\n\n");
	VentextOut(file, func->type, FALSE);
	fprintf(file, "<_><B>");
	VentextOut(file, func->name, FALSE);
	fprintf(file, "<D>");

	/* Get the parameter list done the same way as with a normal
	 * function.  Cheat by using a goto to the above code.
	 */
	goto DoFunctionBlockHeader;
	break;

    case MESSAGE:
	pIntHeader = achFuncHeader;
	
	/*  Print message header setup  */
	fprintf(file, "@HR = ");
	VentextOut(file, func->name, FALSE);
	fprintf(file, "\n\n");

//	fprintf(file, "@HO = Description\n\n");
	
	break;
	
    case MASMBLOCK:
	pIntHeader = achFuncHeader;
	
	/*  Print MASM block header setup  */
	fprintf(file, "@HR = ");
	VentextOut(file, func->name, FALSE);
	fprintf(file, "\n\n");
	
	break;

    case MASMCBBLOCK:
	pIntHeader = achCbHeader;
	
	/*  Print MASM block header setup  */
	fprintf(file, "@HO = Callback\n\n");
	
	/*  BOLD THE CALLBACK NAME?  */
	fprintf(file, "<B>");
	VentextOut(file, func->name, FALSE);
	fprintf(file, "<D>\n\n");

	break;

	
    case STRUCTBLOCK:
    case UNIONBLOCK:
	pIntHeader = achFuncHeader;
	
	/*  Print message header setup  */
	fprintf(file, "@HR = ");
	VentextOut(file, func->name, FALSE);
	fprintf(file, "\n\n");
	
//	fprintf(file, "@HO = Description\n\n");

	break;
	
	
//    case UNIONBLOCK:
//	break;
	
    default:
	fprintf(errfp, "Ventura:  Unknown block type\n");
	return;

  }  // switch type


	
  /*
   *  DO DESCRIPTION
   */
  if (func->desc != NULL) {
	  VentextOut( file, func->desc, TRUE );
	  fprintf( file, "\n" );
  }


  /*
   *  DO STRUCTURE/UNION FIELDS
   */
  if (func->field != NULL) {
	/*  Print structure dump in courier  */
	VenPrintStructText(func, file);
	
	/*  Print out the fields with descriptions & flags in table
	 *  format.
	 */
	VenDoStructDescriptions(func, file);
  }
  
  if (func->other) {
	/*  RTFOtherOut(file, func->other);
	 */
	  
  }
  
  /*
   *  DO PARAMETER OR REGISTER LISTS
   */
  switch (type) {
    case FUNCTION:
    case CALLBACK:
    case MESSAGE:
	fprintf(file, "%s Parameters\n\n", pIntHeader);
	VenDoParmList(func, func->parm, file);
	assert(func->reg == NULL);
	break;
	
    case MASMBLOCK:
    case MASMCBBLOCK:
	fprintf(file, "%s Registers\n\n", pIntHeader);
	/*  Print the register list in input register declaration format  */
	VenDoRegList(func, func->reg, file, REGISTERS);
	assert(func->parm == NULL);
	break;

  }
  

  /*
   *  DO RETURN DESCRIPTION
   */
  if( func->rtndesc != NULL ) {
	  fprintf( file, "%s Return Value\n\n", pIntHeader );

	  /*  Print the return description text  */
	  VentextOut(file, func->rtndesc, TRUE);
	  fprintf(file, "\n");

	  switch (type) {
	    case MESSAGE:
	    case FUNCTION:
	    case CALLBACK:
		if (func->rtnflag != NULL) {
			VenDoFlagList(func->rtnflag, file, PARAMRETURN);
			fprintf(file, "@LE = \n\n");
		}
		break;
	    case MASMBLOCK:
	    case MASMCBBLOCK:
		/*  Process any available register tags  */
		if (func->rtnreg != NULL) {
			VenDoRegList(func, func->rtnreg, file, REGRETURN);
		}
		
		/*  Now do the conditional list  */
		if (func->cond != NULL) {
			VenDoCondList(func, func->cond, file);
		}
		
		break;
	    default:
		assert(0);
		break;
		
	  }	// switch
  }

  /*
   *  DO USES TAG
   */
  if (func->uses != NULL) {
	  fprintf(file, "%s Uses\n\n", pIntHeader);
	  VentextOut(file, func->uses, TRUE);
	  fprintf(file, "\n@LE = \n\n");
  }
  
  /*
   *  DO COMMENT BLOCK
   */
  if( func->comment != NULL ) {
	fprintf( file, "%s Comments\n\n", pIntHeader );
	VentextOut( file, func->comment, TRUE );
	fprintf( file, "\n" );
  }
  
  
  /*
   *  DO ANY CALLBACKS
   */
  for (pCb = func->cb; pCb != NULL; pCb = pCb->next) {
	  VenfuncOut( pCb, file );
  }

  /*
   *  DO CROSS REFERENCES
   */
  if (func->xref != NULL) {
	  VenDoXrefs(file, func->xref);
  }

  /*  Done.  Whew!  */
}



/****************************************************
 *
 *	RANDOM STUFF TO SUPPORT RTF FILES
 *
 ****************************************************/


void
VenFileInit(FILE * phoutfile, logentry *curlog)
{

    return;
}

void
VenFileProcess(FILE * phoutfile, files curfile)
{
    copyfile(phoutfile,curfile->filename);
    return;

}

	
void
VenFileDone(FILE * phoutfile, files headfile)
{
    return;
}


void
VenLogInit(FILE * phoutfile, logentry * * pheadlog)
{
    return;
}

void
VenLogProcess(FILE * phoutfile, logentry * curlog)
{
    return;
}

void
VenLogDone(FILE * phoutfile, logentry * headlog)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\docfmt\version.h ===
#define rmj		2
#define rmm		3
#define rup		7
#define szVerName	""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\extract.h ===
/* 
 * EXTRACT.H
 * 
 * Common definitions for the EXTRACT program to process source code
 * comment blocks and remove tagged documentation.
 * 
 */

/*
 *  General type definitions, since I've been programming windows
 *  too long.
 */
#define NEAR	near
#define FAR	far
//#define	NULL	0
#define	True	1
#define TRUE	1
#define False	0
#define FALSE	0

typedef char NEAR	*PSTR;
typedef char FAR	*LPSTR;
typedef unsigned long	DWORD;
typedef long		LONG;
typedef unsigned short	WORD;
typedef int		BOOL;


/*
 *  Set version of stuff here
 */
#define VERSIONNAME	"Source Code Documentation Extraction Tool"

/*
 *  GENERAL GLOBAL STATUS VARIABLES
 */
extern	BOOL	fNoOutput;
extern	PSTR	szOutputFile;
extern	FILE	*fpOutput;

/* 
 *  Source code type definitions - used by input parser in FileEntry struct.
 */
#define SRC_UNKNOWN	0
#define	SRC_C		1
#define	SRC_MASM	2

/*
 *  File name parser stuff
 */
typedef struct _FileEntry {
    struct _FileEntry	*next;
    int			type;
    char		*filename;
} FileEntry;
/*  list of files to process, built by parser */
extern	FileEntry *FilesToProcess;
/*  Command line argument processor  */
void	ParseArgs(int argc, char **argv);
void	Usage(PSTR progName);


/*
 *  SOURCE FILE STRUCTURE - struct used during parsing of source file
 */
typedef struct _SourceFile {
	/* Direct file stuff */
	FileEntry	*fileEntry;	// fileentry struct pointer
	FILE		*fp;		// file pointer
	BOOL		fExitAfter;	// exit after processing file
	int		wLineNo;	// file line number currently at
	/*  Buffer holders */
	PSTR		lpbuf;		// global copy buffer
	PSTR		pt;		// buffer `point'
	PSTR		mark;		// buffer `mark'
	int		wLineBuf;	// line number start of buffer is
	/* Stuff for reading in comment block */
	BOOL		fTag;		// tag on this line, and status
	BOOL		fHasTags;	// tags appear in this buffer.
	/* Stuff used while processing block tags */
	PSTR		pDocLevel;	// @doc output for this block
	PSTR		pXref;		// @xref line for this block
	WORD		wFlags;		// flags indicating state?
} SourceFile;
typedef SourceFile NEAR *NPSourceFile;

/* Proc to process a filled buffer to the output file */
void TagProcessBuffer(NPSourceFile sf);


/*
 *  General Comment buffer parsing routines - bfuncs.c
 */
void OutputTag(NPSourceFile sf, WORD wBlock, WORD wTag);
void OutputTagText(NPSourceFile sf, PSTR szTag);
void OutputRegion(NPSourceFile sf, char chPost);
void OutputText(NPSourceFile sf, PSTR szText);
void OutputFileHeader(FILE *fpOut);
void CopyRegion(NPSourceFile sf, PSTR buf, WORD wLen);
BOOL FindNextTag(NPSourceFile sf);
WORD GetFirstBlock(NPSourceFile sf);
WORD GetNextBlock(NPSourceFile sf);
WORD FixLineCounts(NPSourceFile sf, PSTR pt);
void PrintError(NPSourceFile sf, PSTR szMessage, BOOL fExit);
WORD ProcessWordList(NPSourceFile sf, PSTR *bufPt, BOOL fCap);

/*  Flags for return from GetFirstBlock && GetNextBlock  */
#define RET_EMPTYBLOCK		1
#define RET_ENDCOMMENT		2
#define RET_ENDBLOCK		3
#define RET_ENDTAG		4


/*
 *  INNERLEVEL TAG PROCESSING ROUTINES - innertag.c
 */
BOOL DoDocTag(NPSourceFile sf);
BOOL DoFlagTag(NPSourceFile sf, WORD wBlock, WORD wNameFlag, WORD wDescFlag);
BOOL ProcessFlagList(NPSourceFile sf, WORD wBlock, 
			WORD wNameFlag, WORD wDescFlag);
BOOL DoParameterTag(NPSourceFile sf, WORD wBlock);
BOOL DoParameterizedReturnTag(NPSourceFile sf, WORD wBlock);
BOOL DoRegisterizedReturnTag(NPSourceFile sf, WORD wBlock);
BOOL DoCommentTag(NPSourceFile sf, WORD wBlock);
BOOL DoUsesTag(NPSourceFile sf, WORD wBlock);
BOOL DoPrintedCommentTag(NPSourceFile sf);
void ProcessXrefTag(NPSourceFile sf);
BOOL DoRegisterTag(NPSourceFile sf, WORD wBlock, BOOL fReturn);
BOOL DoRegisterDeclaration(NPSourceFile sf, WORD wBlock);
void DoBlockBegin(NPSourceFile sf);
void DoBlockEnd(NPSourceFile sf, WORD wBlock, BOOL fFlushXref);
BOOL DoFieldTag(NPSourceFile sf, WORD wBlock);
BOOL DoOthertypeTag(NPSourceFile sf, WORD wBlock);
BOOL DoStructTag(NPSourceFile sf, WORD wBlock, BOOL fStructure);
BOOL DoTagnameTag(NPSourceFile sf, WORD wBlock);


/*  Flags indicating status of comment block tag parsing  */
#define SFLAG_SMASK		0xF800
#define SFLAG_RDESC		0x8000
#define SFLAG_COMM		0x4000
#define SFLAG_PARMS		0x2000
#define SFLAG_REGS		0x1000
#define SFLAG_USES		0x0800


/*
 *  Memory manager stuff - misc.c
 */
extern WORD	wNearMemoryUsed;	/* counts of how much memory used */
extern DWORD	dwFarMemoryUsed;

PSTR	NearMalloc(WORD size, BOOL fZero);
PSTR	NearRealloc(PSTR pblock, WORD newsize);
void	NearFree(PSTR pblock);
WORD	NearSize(PSTR pblock);
PSTR	StringAlloc(PSTR string);
void	NearHeapCheck();

#if 0
LPSTR	FarMalloc(int size, BOOL fZero);
void	FarFree(LPSTR lpblock);
extern int far lmemzero(LPSTR lpBase, WORD wLength);
#endif


/*
 *  Debugging support
 */
#ifdef DEBUG
	BOOL fDebug;
	void cdecl COMprintf(PSTR format, ...);
	#define dprintf if (fDebug) COMprintf
#else
	#define dprintf if (0) ((int (*)(char *, ...)) 0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\extract.c ===
/* 
 * EXTRACT.C
 * 
 * Documentation extractor.  Extracts tagged comment blocks from source
 * code, interprets and reformats the tag definitions, and outputs an
 * intermediate level 2 tag file, suitable for processing by a final
 * formatting tool to coerce the level 2 tags into something appropriate
 * for the presentation medium (paper, WinHelp RTF, Ventura, etc).
 * 
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include "extract.h"
#include "tags.h"
#include "version.h"
#if MMWIN
#include <mmsysver.h>
#endif

/* Whether to do any output at all?  */
BOOL	fNoOutput	= False;
/*  The output file to use if not stdout */
PSTR	szOutputFile	= NULL;
/*  The actual output file pointer  */
FILE	*fpOutput;

/*
 *  File-private procedure templates
 */
void ProcessSourceFile( NPSourceFile sf );
void AppendLineToBuf(NPSourceFile sf, PSTR buf);
BOOL LookForCommentStart(NPSourceFile sf, PSTR buf, PSTR *nbuf);
BOOL IsTag(PSTR p);
BOOL PrepLine( NPSourceFile sf, PSTR buf, PSTR *nbuf );

/*
 *  User messages
 */
char msgStdin[] = "Using Standard Input for source text...\n";
char msgCurFile[] = "Processing file %s...\n";
char msgSyntaxCheck[] = "Syntax check only.\n";

char msgTypeMASM[] = "%s (%d): File is MASM source.\n";
char msgTypeC[] = "%s (%d): File is C source.\n";

char errOutputFile[] = "%s: Can not open output file\n";
char errInputFile[] = "%s: Can not open file.\n";
char errEOFinComment[] = "%s (%d): Premature end of file within comment block.\n";
char errRead[] = "%s (%d): Unable to read.\n";


/* 
 * @doc EXTRACT
 * 
 * @func int | main | This program extracts documentation information 
 * from the given input file and sends it to the standard output.  
 * Information is not sorted or formatted, but parsed from the
 * initial tag types to an intermediate tag output format that contains
 * full information as to tag placement within documentation/function
 * declarations.
 * 
 * @rdesc The return value is zero if there are no errors, otherwise the
 * return value is a non-zero error code.
 * 
 */
void main(argc, argv)
int argc;	/* Specifies the number of arguments. */
char *argv[];	/* Specifies an array of pointers to the arguments */
{
	SourceFile	sourceBuf;
	FileEntry	fileEntry;
	BOOL		fStdin = False;

	#define INITIAL_BUF	8192
	
#ifdef MMWIN
	/* announce our existance */
	fprintf(stderr, "%s\n", VERSIONNAME);
	fprintf(stderr, "Program Version %d.%d.%d\t%s\n", rmj, rmm, rup,
		MMSYSVERSIONSTR);
#ifdef DEBUG
	fprintf(stderr, "Compiled: %s %s by %s\n", __DATE__, __TIME__,
		szVerUser);
	fDebug = 1;
#endif
#endif

	ParseArgs(argc, argv);

	if (fNoOutput) {
	  fprintf(stderr, msgSyntaxCheck);
	  szOutputFile == NULL;
	}
	else {
	   /*  Open the output file, if one was specified.  If !szOutputFile,
	    *  then use stdout.
	    */
	   if (szOutputFile) {
	     fpOutput = fopen(szOutputFile, "w");
	     if (fpOutput == NULL) {
		fprintf(stderr, errOutputFile, szOutputFile);
		exit(1);
	     }
	   }
	   else {		/* Using stdout for output */
	     fpOutput = stdout;
	     szOutputFile = StringAlloc("stdout");
	   }
	   
	   OutputFileHeader(fpOutput);
	}

	/*  If no files were specified on command line, use stdin.
	 *  Fake a fileEntry structure for stdin.
	 */
	if (FilesToProcess == NULL) {
		/* No files specified, use stdin */
		fileEntry.filename = StringAlloc("stdin");
		fileEntry.next = NULL;
		fileEntry.type = SRC_UNKNOWN;
		FilesToProcess = &fileEntry;
		fStdin = True;
	}

	/*
	 *  Loop over all files specified on command line
	 */
	while (FilesToProcess) {
		/*
		 *  Setup the source file access buffer
		 */
		sourceBuf.fileEntry = FilesToProcess;	// get head of list.
	
		/*  Open the file, except when using stdin */
		if (fStdin) {
			sourceBuf.fp = stdin;
			fprintf(stderr, msgStdin);
		}
		else {	// deal with normal file, need to open it.
			sourceBuf.fp = fopen(FilesToProcess->filename, "r");
			/* couldn't open file */
			if (!sourceBuf.fp) {
			  fprintf(stderr, errInputFile,
				  FilesToProcess->filename);
			  /* Skip to next file in list */
			  FilesToProcess = FilesToProcess->next;
			  continue;
			}
			
			/* Send message telling current file */
			fprintf(stderr, msgCurFile, FilesToProcess->filename);
		}

		/* Reset line numbers of input files to zero */
		sourceBuf.wLineNo = 0;
		sourceBuf.wLineBuf = 0;
		/* Setup copy buffer */
		sourceBuf.lpbuf = NearMalloc(INITIAL_BUF, False);
		sourceBuf.pt = sourceBuf.mark = sourceBuf.lpbuf;
		sourceBuf.fHasTags = sourceBuf.fTag = False;
		sourceBuf.fExitAfter = FALSE;
		
		ProcessSourceFile( &sourceBuf );

		if (!fStdin)
			fclose(sourceBuf.fp);
		NearFree(sourceBuf.lpbuf);
		NearFree(FilesToProcess->filename);
		FilesToProcess = FilesToProcess->next;
		/*
		 * Bail out with non-zero exit if fatal error encountered
		 */
		if (sourceBuf.fExitAfter) {
			fcloseall();
			exit(1);
		}
	}

	/*
	 *  Close output file if not stdout.
	 */
	fcloseall();
	exit(0);
}



/* 
 * @doc	EXTRACT
 * @api	void | ProcessSourceFile | Process a given file, searching
 * for and extracting doc tagged comment blocks and processing and
 * outputting these comment blocks.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file comment block.
 * It must have a valid file pointer, and a valid buffer (lpbuf field)
 * before calling this function.  The file pointer will be open upon
 * return. 
 * 
 * @comm	This proc sits in a loop reading lines until it finds a
 * comment.  Once inside a comment, the lines are stripped of fuzz
 * pretty printing characters and examined for being an autodoc tagged
 * line.  If a tag is found in the comment block, the following comment
 * lines are copied into the lpbuf buffer of <p sf>, and passed to the
 * <f TagProcessBuffer> function to parse and output the tags.
 * 
 */
#define LOCALBUF_SIZE	1024

void ProcessSourceFile( NPSourceFile sf )
{
  char	*buf;
  char	*pOrigBuf;
  char	*nBuf, *nBuf2;
  int	inComment;
  int	w;
  
  inComment = False;
  pOrigBuf = NearMalloc(LOCALBUF_SIZE, False);
  buf = pOrigBuf + 1;	// give one space of padding at beginning
  
  while (!feof(sf->fp)) {
    /*
     *  Grab the next line
     */
    #ifdef HEAPDEBUG
	NearHeapCheck();
    #endif
	    
    w = (int) fgets(buf, LOCALBUF_SIZE, sf->fp);

    #ifdef HEAPDEBUG
	NearHeapCheck();
    #endif
    
    /*  Handle error or EOF conditions  */
    if (w == 0) {
      /*  Am i at EOF?  */
      if (feof(sf->fp)) {
	      /* Message is EOF happened while in a comment block */
	      if (inComment) {
		      /* MASM comment blocks can end on EOF,
		       * so go handle it if in a masm file.
		       */
		      if (sf->fileEntry->type == SRC_MASM) {
			      if (sf->fTag)
				      /*  This is BOGUS!! */
				      TagProcessBuffer(sf);
		      }
		      else {	// premature eof otherwise
			      fprintf(stderr, errEOFinComment,
				      sf->fileEntry->filename, sf->wLineNo);
		      }
	      }
	      /* Cause the enclosing while loop to exit on EOF */
	      continue;
      }
      else {	// error condition, bail out!
	      fprintf(stderr, errRead, sf->fileEntry->filename, sf->wLineNo);
	      goto BailOut;
      }
    }
    else {
      /* 
       * Process this line - depending on current mode:
       *
       * -- CommentSearch mode:  inComment = False
       * Not currently in a comment, looking for comment begin
       * characters.  If commentBegin found, enter InsideComment
       * mode to look for end of comment and prep lines for
       * output processing.
       * 
       * -- InsideComment mode:  inComment = True
       * Inside a comment block, taking each line, stripping beginning
       * whitespace, and appending to global buffer for output
       * processing.  When end of comment is found, send the entire
       * buffer for tag processing.  (only if there was a tag
       * detected!).  Enter CommentSearch mode.
       * 
       */
      sf->wLineNo++;		// line count for file - now current line no.

      /* 
       * I'm in InsideComment mode, so process the next line as a comment
       * line.  The magic is in PrepLine(), which strips whitespace, sets the
       * fTag flag of the sourceBuf if a tag is detected, and returns TRUE
       * when end of comment is detected.
       * 
       */
      if (inComment) {
	w = PrepLine(sf, buf, &nBuf);
	AppendLineToBuf(sf, nBuf);
	if (w) {	// detected end of comment, exit in comment state
	  if (sf->fTag) {	// a tag was in the current buffer
		TagProcessBuffer(sf);
	  }
		
	  /* Go back to comment-search mode */
	  inComment = False;
	  
	}
      }
      /* 
       * Otherwise, I'm in CommentSearch mode, looking for a comment begin.
       * LookForCommentStart() returns TRUE when a comment start is detected.
       * It also fiddles <buf> so that the beginning of <buf> now points to
       * the character following the comment start.
       * 
       * Pass to PrepLine() to detect an immediate comment close, and then
       * add this initial line to the global buffer after reseting buffer
       * status.
       * 
       * Enter InsideComment mode.
       */
      else {		// not in a comment buffer
	if (LookForCommentStart(sf, buf, &nBuf)) {
	  // dprintf("Entering InsideComment mode, point is %d\n",
	  //	  (int) (sf->pt - sf->lpbuf));
		
	  /* Reset source file buffer status */
	  sf->fTag = sf->fHasTags = False;
	  sf->wLineBuf = sf->wLineNo;
	  sf->pt = sf->mark = sf->lpbuf;
	  
	  /* Check for immediate comment close */
	  if (PrepLine(sf, nBuf, &nBuf2)) {
		  assert(sf->fTag == False);
		  continue;		// detected immediate end comment
	  }

	  AppendLineToBuf(sf, nBuf2);

	  /*  Enter InsideComment mode  */
	  inComment = True;
	}
	/* else, no comment start found, continue scan */
      }  // endof CommentSearch mode stuff.
    }/* else not a string read error */
  } /* file-level while loop */

BailOut:

  NearFree(pOrigBuf);
	  
}


#define ISSPACE(c) ((c) == ' ' || (c) == '\t')

/* 
 * @doc	EXTRACT
 * @api	BOOL | PrepLine | Prepares an InsideComment mode line,
 * stripping off initial whitespace and fuzz characters, and detecting
 * end of comment conditions.
 * 
 * @parm	NPSourceFile | sf | Pointer to source file status buffer.
 * @parm	PSTR | buf | Pointer to beginning of source text line, as
 * read from the source file.
 * @parm	PSTR * | nbuf | Pointer to a char pointer, which is altered
 * to point the post-processed and stripped beginning of the line upon
 * procedure exit.
 * 
 * @rdesc	Returns TRUE when end of comment is encountered.  In this
 * case, the end of comment characters are not included in the return
 * string.  Returns FALSE when no end of comment is detected.
 * 
 * The char pointer pointed to by the <p nbuf> parameter is altered to
 * point to the new (post-processed and stripped) beginning of the line.
 * This new beginning is the beginning of the text of interest, having
 * had all comment leader characters and whitespace stripped off.  NULL
 * is an acceptable string to return, which will simply add nothing to
 * the tag buffer.  If a blank line is encountered, (ie simply a
 * newline), then the newline should be returned.
 * 
 * If a tag is detected on the line, then the <p sf->fTag> flag is set
 * to True to indicate that this is a valid tagged comment block.
 * 
 * @comm	This procedure does the stripping of language specific fuzz
 * characters into a simple text block.  The setting of <p sf->fTag> is
 * critical, and may be accomplished by calling the <f IsTag> procedure when
 * the tag should appear within the source line.
 * 
 */
BOOL PrepLine( NPSourceFile sf, PSTR buf, PSTR *nbuf )
{
  PSTR	chClose;
  PSTR	pend;
  
  /* Scan forward, removing initial whitespace */
  for (; *buf && ISSPACE(*buf); buf++);
  
  /* I never have to deal with begin comment processing, this is done
   * by the LookForCommentStart() proc.  In C, PrepLine() is invoked on
   * the char following the '/ *'.  In MASM, the ';' is left in.
   */
  
  switch (sf->fileEntry->type) {
    case SRC_MASM:

	/*  End of comment check:  If this first character (after whitespace
	 *  stripped out) is not a ';', then this is the end of the comment
	 *  block.  Return TRUE to indicate this.
	 */
	if (*buf && *buf != ';') {
		*buf = '\0';
		*nbuf = buf;
		return True;
	}

	/* strip contiguous ';' and '*', followed by whitespace */	    
	for (; *buf && (*buf == ';' || *buf == '*'); buf++);
	for (; *buf && ISSPACE(*buf); buf++);
	if (IsTag(buf)) {
		sf->fTag = True;
		*nbuf = buf;
	}
	else {
		/* HACK!
		 * If first char is a @ (and not a tag), pad with a space
		 */
		if (*buf == TAG) {
			*(--buf) = ' ';
		}
		*nbuf = buf;
	}
	
	/* Very hack way of kicking out extra comments */
	if ((buf = strstr(buf, "//")) != NULL)
		*buf = '\0';
	
	return False;

    case SRC_C:
	/* Remove leading stars */
	for (; *buf && *buf == '*'; buf++);
	/* Quick check for close comment - */
	if (*buf && *buf == '/') {
		*buf = '\0';
		*nbuf = buf;
		return True;
	}
	
	/* Otherwise, remove whitespace between the '*' and the text */
	for (; *buf && ISSPACE(*buf); buf++);
	/* Check for a tag here */
	if (IsTag(buf))
		sf->fTag = True;
	else {
		/*  If not tag but a @ on first char of line  */
		if (*buf == TAG) {
			buf--;	// can do this since buf is padded by one
			*buf = ' ';
		}
	}
	
	/* Implement the comment scheme of Rick's request */
	if ((pend = strstr(buf, "//")) != NULL)
		*pend = '\0';
	
	/* And if the line hasn't ended, search line for a close comment */
	chClose = strstr(buf, "*/");
	if (chClose) {
		/* found end of comment, NULL this spot, and return from func
		 * with TRUE, with nbuf pointing the beginning of non-white
		 * space text above
		 */
		*nbuf = buf;
		*chClose = '\0';
		return True;
	}
	
	/* Otherwise, found no end of comment on this line, so simply
	 * return whole line
	 */
	*nbuf = buf;
	return False;
	
    default:
	// dprintf("Invalid source type in PrepLine()!\n");
	assert(False);
	exit(5);
	
  }  /* switch */
	
}


/*
 * @doc	EXTRACT
 * @api	BOOL | IsTag | Perform a quick and dirty check to see if the
 * word pointed to by <p p> is a tag.
 * 
 * @parm	PSTR | p | Buffer, queued to the start of a word/tag.  If
 * this is a possible tag, then it must point to the initial '@'
 * character.
 * 
 * @rdesc	Returns TRUE if this is probably a tag, or FALSE otherwise.
 * 
 * @comm	This is a hack test, but works 99.9% of the time.
 * 
 */
BOOL IsTag(PSTR p)
{
  PSTR	pbegin;
  
  pbegin = p;
  
  if (*p != TAG)
	  return False;
  
  /*  For this procedure, allow newline as a whitespace delimeter */

  /* Skip to next whitespace */
  for (; *p && !(ISSPACE(*p) || *p == '\n'); p++);

  /* This is a test for a tag, but if the first char was
   * a '@' and there is a space following the word, then I'm going to
   * say it is a tag.
   */
  if (*p && (p > pbegin + 1) && (ISSPACE(*p) || *p == '\n'))
	  return True;

  return False;
}


/* 
 * @doc	EXTRACT
 * @api	BOOL | LookForCommentStart | Search a source line for comment
 * start characters.
 * 
 * @parm	NPSourceFile | sf | Pointer to the source file block
 * structure.
 * @parm	PSTR | buf | Pointer to beginning of source text file line to
 * examine.
 * @parm	PSTR * | nbuf | Pointer to a pointer that is modified to
 * indicate the beginning of the true source text line if a comment
 * block begin is found.
 * 
 * @rdesc	Returns False if no comment start characters are found.
 * Returns True if a comment start is found.  If True is returned,
 * <p *nbuf> will point to the start of the source text line as it
 * should be passed to <f AppendLineToBuf>.
 * 
 * This examination method for determining start of comment depends on
 * the source file type (as obtained from the fileEntry.type field of
 * <p sf>).  Unknown file types are examined and placed into one of the
 * other known source types as soon as distinguishing characters are
 * found.  (ie if '/ *' is found in an unknown, the file is marked as C
 * source file the remainder of file processing.  Note that this can
 * cause unknown file types to be incorrectly processed.)
 * 
 */
BOOL LookForCommentStart(NPSourceFile sf, PSTR buf, PSTR *nbuf)
{

  /*  Skip leading whitespace  */
  for (; *buf && ISSPACE(*buf); buf++);
  
  if (!*buf)
	  return False;
  
  switch (sf->fileEntry->type) {
    case SRC_C:
	if (!*(buf + 1))
		return False;
	if ((*buf == '/') && (*(buf+1) == '*')) {
		*nbuf = buf+2;
		return True;
	}
	break;

    case SRC_MASM:
	if (*buf == ';') {
		*nbuf = buf;
		return True;
	}
	break;
	
    /*
     *  The catch all.  This has serious potential for disaster!
     */
    case SRC_UNKNOWN:
	/* Try the MASM comment character */
	if (*buf == ';') {
		fprintf(stderr, msgTypeMASM, 
			sf->fileEntry->filename, sf->wLineNo);
		sf->fileEntry->type = SRC_MASM;
		*nbuf = buf;
		return True;
	}

	/* Otherwise, try the C-method */
	if (!*(buf + 1))
		return False;
	if ((*buf == '/') && (*(buf+1) == '*')) {
		fprintf(stderr, msgTypeC,
			sf->fileEntry->filename, sf->wLineNo);
		sf->fileEntry->type = SRC_C;
		*nbuf = buf+2;
		return True;
	}
	break;

    default:
	// dprintf("Unknown filetype identifier in sourceFile buffer.\n");
	assert(False);
	
  }
  
  return False;

}

/* 
 * @doc	EXTRACT
 * @api	void | AppendLineToBuf | Appends an stripped comment line the
 * comment buffer contained in <p sf>.
 * 
 * @parm	NPSourceFile | sf | Source file buffer block pointer.
 * Contains the buffer that is appended to.
 * @parm	PSTR | buf | Pointer to NULL terminated line to add to the
 * comment buffer.
 * 
 * @comm	Appends <p buf> to the comment buffer, contained in the lpbuf
 * field of <p sf>.  The current point in the comment buffer, (given by
 * the pt field of <p sf>) is advanced to the end of the appended
 * string. 
 * 
 */
void AppendLineToBuf(NPSourceFile sf, PSTR buf)
{
  int	size;
  PSTR	ch;
  PSTR	end;

  #define GROWSIZE	1024
  
  if (!sf->fHasTags)
	  /* If buffer doesn't yet have tags, check if one was just
	   * found, and the copy
	   */
	  if (sf->fTag) {
		  sf->fHasTags = True;
		  sf->wLineBuf = sf->wLineNo;
	  }
	  /*  Or no tags in buffer yet, return  */
	  else {
		  *sf->pt = '\0';
		  return;
	  }

  // dprintf("AppendLineToBuf:  %d\n", (int) (sf->pt - sf->lpbuf));
	  
  /*  Otherwise, the buffer has tags, so copy the new string  */
  end = (PSTR) (sf->lpbuf + (int) NearSize(sf->lpbuf));

  for (ch = buf; *ch && (sf->pt < end); *sf->pt++ = *ch++);
  /* Deal with possible buffer overrun */
  if (sf->pt >= end) {
	WORD	origPt;
	int	needSize;
	
/*	dprintf("AppendLine:  expanding buf %x, pt %x, end %x\n",
		sf->lpbuf, sf->pt, end);
*/
	origPt = (WORD) (sf->pt - sf->lpbuf);	// save current offset
	needSize = strlen(ch) + 1;		// grow by this much

	sf->lpbuf = NearRealloc(sf->lpbuf,
		       (WORD)(NearSize(sf->lpbuf) + max(needSize, GROWSIZE)));
	sf->pt = sf->lpbuf + origPt;
	
	/* Continue with the copy */
	for (; *ch; *sf->pt++ = *ch++);
  }
  
  /* make sure that final buffer is null terminated */
  *sf->pt = '\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\innertag.c ===
/* 
 * DOTAGS.C
 * 
 * This file for procedures that process the innerlevel tags in a
 * generic way.  Keeps the fuzz out of the blocktag.c file.
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>		// for toupper macro

#include "extract.h"
#include "tags.h"


char errMixedRegParm[] = "WARNING:  Mixed set of register and parameter tags within block.";

/*
 *  DOC TAG ERRORS
 */
char errDocTagFirst[] = "The first tag in a comment block must be @DOC";
char errEmptyDocTag[] = "No documentation level specified with @DOC";
char errExtraDocInfo[] = "Extra blocks in the @DOC tag";

/*
 *  PARAMETER TAG ERRORS
 */
char errMissingParmFields[] = "Fields missing from parmeter tag.";
char errEmptyParmType[] = "Empty type field for paramter tag.";
char errEmptyParmName[] = "Empty name field for paramter tag.";
char errExtraParmFields[] = "Extra fields for paramter tag.  Extra fields ignored.";
char errEmptyParmDescrip[] = "Empty description field for parameter tag.";


/*
 *  FIELD TAG ERRORS
 */
char errMissingFieldFields[] = "Fields missing from @field tag.";
char errEmptyFieldType[] = "Empty type field for @field tag.";
char errEmptyFieldName[] = "Empty name field for @field tag.";
char errExtraFieldFields[] = "Extra fields for @field tag.  Extra fields ignored.";
char errEmptyFieldDescrip[] = "Empty description field for @field tag.";

/*
 *  STRUCTURE/UNION BLOCK ERRORS
 */
char errEmptyStructNameTag[] = "Empty name field for @struct/@union tag.";
char errEmptyStructDesc[] = "Empty description for @struct/@union tag.";
char errExtraStructFields[] = "Extra fields for @struct/@union tag.  Extra fields ignored.";
char errUnrecoStructTag[] = "Unrecognized tag within @struct/@union block.  Tag ignored.";
char errUnmatchedStructEnd[] = "@struct or @union tag block ended with no matching @end tag.  @end supplied.";

/*
 *  OTHERTYPE TAG
 */
char errEmptyOthertType[] = "Empty type field for @othertype tag.";
char errMissingOthertFields[] = "Fields missing from @othertype tag.";
char errEmptyOthertName[] = "Empty name field for @othertype tag.";
char errEmptyOthertDesc[] = "Empty description for @othertype tag.";
char errExtraOthertFields[] = "Extra fields for @othertype tag.  Extra fields ignored.";

/*
 *  TAGNAME TAG
 */
char errEmptyTagname[] = "Empty @tagname field.";
char errExtraTagnameFields[] = "Extra fields for @tagname tag.  Extra fields ignored.";


/*
 *  REGISTER TAG ERRORS
 */
char errEmptyRegName[] = "Empty register name field.";
char errMissingRegDesc[] = "Description missing from register tag.";
char errEmptyRegDescrip[] = "Empty description field for register tag.";
char errExtraRegFields[] = "Extra fields for register tag.  Extra fields ignored.";

/*
 *  CONDITIONAL TAG ERRORS
 */
char errEmptyConditionTag[] = "Empty condition tag text.  Conditional tag ignored.";
char errExtraConditionField[] = "Extra fields for condition tag text.  Extra fields ignored.";
char errMisplacedCondFlag[] = "Misplaced flag in ASM conditional return description.  Extra flag tag ignored.";

/*
 *  FLAG TAG ERRORS
 */
char errFlagNoDescrip[] = "Description field missing for flag tag.";
char errFlagNameMissing[] = "Empty name field for flag tag.";
char errFlagEmptyDescrip[]="Empty description field for flag tag.";
char errFlagExtraField[] = "Extra fields for flag tag. Extra fields ignored.";

/*
 *  COMMENT TAG ERRORS
 */
char errMultipleComments[] ="Multiple comment tags in same outerlevel block.";
char errEmptyCommentBlock[] ="Empty comment tag.  Tag ignored.";
char errExtraCommentFields[] ="Extra fields for comment tag.  Extra fields ignored.";

/*
 *  USES TAG ERRORS
 */
// char errMultipleUses[] ="Multiple uses tags in same outerlevel block.";
char errEmptyUsesBlock[] ="Empty uses tag.  Tag ignored.";
char errExtraUsesFields[] ="Extra fields for uses tag.  Extra fields ignored.";

/*
 *  PRINTED COMMENT TAG ERRORS
 */
char errEmptyPrintComm[] = "Empty printed comment tag.";
char errExtraPrintComm[] = "Extra fields for printed comment tag.";

/*
 *  RETURN TAG ERRORS
 */
char errMultipleReturns[] = "Multiple return tags in same outerlevel block.";
char errEmptyReturnTag[] = "Empty description field for return tag.  Tag ignored.";
char errExtraReturnField[] = "Extra fields for return tag.  Extra fields ignored.";


/*
 *  CROSS REFERENCE TAG ERRORS
 */
char errMultipleXref[] = "Multiple cross references within outerlevel block.  Extra xref tags ignored.";
char errEmptyCrossRef[] = "Empty cross reference tag.  Ignored.";
char errExtraCrossRef[] = "Extra fields for cross reference tag.  Extra fields ignored.";




/* 
 * @doc	EXTRACT
 * @api	BOOL | DoDocTag | Processes the doclevel specification
 * tag for a comment block, and outputs initial block setup tags.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file buffer block.
 * 
 * @rdesc	Returns FALSE if no doclevel tag, or an illegal doclevel tag
 * was found.  Returns TRUE if the doclevel tag was processed normally,
 * and has the point set so that a call <f FindNextTag> will return the
 * tag following the doclevel specification tag.
 * 
 * @comm	Parses the doclevel specifications behind the doc tag and
 * outputs them separated by single spaces.
 * 
 */
BOOL DoDocTag(NPSourceFile sf)
{
  WORD	w;
  char	buf[50];
  PSTR	p;
  
  if (!FindNextTag(sf)) {
	// dprintf("No DOC tag in comment buffer!  Serious problem!\n");
	assert(0);
  }

  /*  Verify the tag is @doc  */
  CopyRegion(sf, buf, sizeof(buf));
  if (*buf != TAG || strcmpi(buf+1, T1_DOCLEVEL)) {
	PrintError(sf, errDocTagFirst, TRUE);
	return FALSE;
  }
  
  p = NearMalloc(128, True);
  w = ProcessWordList(sf, &p, TRUE);
  switch (w) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyDocTag, TRUE);
	NearFree(p);
	return FALSE;

    case RET_ENDBLOCK:
	PrintError(sf, errExtraDocInfo, FALSE);
	/*  Fall through  */

    case RET_ENDTAG:
	sf->pDocLevel = p;
	return TRUE;
  }
}


/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoFlagTag | Process and output a single flag tag.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block.
 * 
 * @parm	WORD | wNameFlag | Identifier for flag name tag to output.
 * 
 * @parm	WORD | wDescFlag | Identifier for flag description tag to
 * output.
 * 
 * @comm	Process the flag tag line.  Useful since flag tags can appear
 * almost everywhere in the input, and needs parsing under flexible
 * conditions.
 * 
 * @xref	ProcessFlagList
 * 
 */
BOOL DoFlagTag(NPSourceFile sf, WORD wBlock, WORD wNameFlag, WORD wDescFlag)
{

  switch (GetFirstBlock(sf)) {
    case RET_ENDTAG:
	PrintError(sf, errFlagNoDescrip, TRUE);
	return FALSE;
    case RET_EMPTYBLOCK:
	PrintError(sf, errFlagNameMissing, TRUE);
	return FALSE;

    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, wNameFlag);
	OutputRegion(sf, '\n');
	break;
  }
  
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errFlagEmptyDescrip, TRUE);
	break;
				
    case RET_ENDBLOCK:
	PrintError(sf, errFlagExtraField, FALSE);
	/* Fall through */
    case RET_ENDTAG:
	OutputTag(sf, wBlock, wDescFlag);
	OutputRegion(sf, '\n');
  }
  return TRUE;
}


/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | ProcessFlagList | Process an undetermined number of
 * flag tags and return when finding a non-flag tag.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block.
 * 
 * @parm	WORD | wNameFlag | Identifier for flag name tag to output.
 * 
 * @parm	WORD | wDescFlag | Identifier for flag description tag to
 * output.
 * 
 * @comm	Processes sequential flag tags from the current point, and
 * returns upon encountering another tag type.  Useful from under the
 * return and parm tags.
 * 
 * @xref	DoFlagTag
 * 
 */
BOOL ProcessFlagList(NPSourceFile sf, WORD wBlock, 
			WORD wNameFlag, WORD wDescFlag)
{
  char	buf[25];
  WORD	ret;
  
  while (FindNextTag(sf)) {
	  /*  Isolate the current Tag name  */
	  sf->pt++;
	  CopyRegion(sf, buf, sizeof(buf));
	  sf->pt--;

	  if (!strcmpi(buf, T1_FLAG)) {
		DoFlagTag(sf, wBlock, wNameFlag, wDescFlag);
		continue;
	  }
	  else if (!strcmpi(buf, T1_PRINTCOMM)) {
		DoPrintedCommentTag(sf);
		continue;
	  }
	  else {
		/*  No flag tag detected, bust out  */
		break;
	  }
  }	// while
  return TRUE;
}



/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoParameterTag | Handles and outputs a parameter
 * definition tag.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @comm	Parses the @parm tag, and outputs its fields.  Calls
 * <f ProcessFlagTags> to handle possible flag tags following the
 * parameter tag.
 * 
 */
BOOL DoParameterTag(NPSourceFile sf, WORD wBlock)
{

  /*  Check if we've done any reg tags this block, and warn if so  */
  if (sf->wFlags & SFLAG_REGS) {
	PrintError(sf, errMixedRegParm, FALSE);
  }
  sf->wFlags |= SFLAG_PARMS;

  /* Assume that I'm positioned correctly on the parm tag */
  switch (GetFirstBlock(sf)) {
    case RET_ENDTAG:
	PrintError(sf, errMissingParmFields, TRUE);
	OutputTag(sf, wBlock, T2_PARMTYPE);
	OutputRegion(sf, '\n');
	goto ParmDoFlags;

    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyParmType, TRUE);
	break;
	
    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, T2_PARMTYPE);
	OutputRegion(sf, '\n');
	break;
  }

  /*  Get the parm name  */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyParmName, TRUE);
	break;
	
    case RET_ENDTAG:
	PrintError(sf, errMissingParmFields, TRUE);
	OutputTag(sf, wBlock, T2_PARMNAME);
	OutputRegion(sf, '\n');
	goto ParmDoFlags;
	
    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, T2_PARMNAME);
	OutputRegion(sf, '\n');
	break;
  }
  
  /*  Do the parameter description */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyParmDescrip, TRUE);
	break;
	
    case RET_ENDBLOCK:
	PrintError(sf, errExtraParmFields, FALSE);
	/* Fall through */
	
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_PARMDESC);
	OutputRegion(sf, '\n');
  }
  
ParmDoFlags:

  ProcessFlagList(sf, wBlock, T2_FLAGNAMEPARM, T2_FLAGDESCPARM);
  return TRUE;
}



/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoFieldTag | Handles and outputs a structure/union field
 * definition tag.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @comm	Parses the @field tag, and outputs its fields.  Calls
 * <f ProcessFlagTags> to handle possible flag tags following the
 * field tag.
 * 
 */
BOOL DoFieldTag(NPSourceFile sf, WORD wBlock)
{

  /* Assume that I'm positioned correctly on the field tag */
  switch (GetFirstBlock(sf)) {
    case RET_ENDTAG:
	PrintError(sf, errMissingFieldFields, TRUE);
	OutputTag(sf, wBlock, T2_FIELDTYPE);
	OutputRegion(sf, '\n');
	goto FieldDoFlags;

    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyFieldType, TRUE);
	break;
	
    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, T2_FIELDTYPE);
	OutputRegion(sf, '\n');
	break;
  }

  /*  Get the field name  */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyFieldName, TRUE);
	break;
	
    case RET_ENDTAG:
	PrintError(sf, errMissingFieldFields, TRUE);
	OutputTag(sf, wBlock, T2_FIELDNAME);
	OutputRegion(sf, '\n');
	goto FieldDoFlags;
	
    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, T2_FIELDNAME);
	OutputRegion(sf, '\n');
	break;
  }
  
  /*  Do the field description */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyFieldDescrip, TRUE);
	break;
	
    case RET_ENDBLOCK:
	PrintError(sf, errExtraFieldFields, FALSE);
	/* Fall through */
	
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_FIELDDESC);
	OutputRegion(sf, '\n');
  }
  
FieldDoFlags:

  ProcessFlagList(sf, wBlock, T2_FLAGNAMEFIELD, T2_FLAGDESCFIELD);
  return TRUE;
}








BOOL DoStructTag(NPSourceFile sf, WORD wBlock, BOOL fStructure)
{
  char	buf[30];
  BOOL	fMatchedEnd = FALSE;

  /*  Get the structure name tag.  It may have an optional description
   */
  switch (GetFirstBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyStructNameTag, TRUE);
	break;		// break so that we can pull up flag fields.

    case RET_ENDBLOCK:
	/*  There is the optional description present.
	 *  print the structure name, then do the description.
	 */
	OutputTag(sf, wBlock, fStructure ? T2_STRUCTNAME : T2_UNIONNAME);
	OutputRegion(sf, '\n');

	/*  Do the description  */
	switch (GetNextBlock(sf)) {
	  case RET_EMPTYBLOCK:
		PrintError(sf, errEmptyStructDesc, TRUE);
		break;
	  case RET_ENDBLOCK:
		PrintError(sf, errExtraStructFields, FALSE);
		/*  Fall through  */
	  case RET_ENDTAG:
		OutputTag(sf, wBlock, fStructure ?
					T2_STRUCTDESC : T2_UNIONDESC);
		OutputRegion(sf, '\n');
	}
	break;
	
    case RET_ENDTAG:
	OutputTag(sf, wBlock, fStructure ? T2_STRUCTNAME : T2_UNIONNAME);
	OutputRegion(sf, '\n');
	break;
  }

  /*  Process the tags that follow:  If a field, then process the
   *  flag tags that may follow..  If a printed comment, print it.
   *  If another structure tag, call myself recursively.
   *  Return on @end tags, puke on anything else.
   */
  while (FindNextTag(sf)) {
	  sf->pt++;
	  CopyRegion(sf, buf, sizeof(buf));
	  sf->pt--;
	
	  if (!strcmpi(buf, T1_FIELD)) {
		  DoFieldTag(sf, wBlock);
	  }
	  else if (!strcmpi(buf, T1_STRUCT)) {
		  /*  Call myself recursively  */
		  DoStructTag(sf, wBlock, TRUE);
	  }
	  else if (!strcmpi(buf, T1_UNION)) {
		  /*  Call myself recursively  */
		  DoStructTag(sf, wBlock, FALSE);
	  }
	  else if (!strcmpi(buf, T1_END)) {
		  sf->pt++;	// skip this tag, and return success
		  fMatchedEnd = TRUE;
		  break;
	  }
	  else if (!strcmpi(buf, T1_PRINTCOMM)) {
		  DoPrintedCommentTag(sf);
	  }
	  else {
		  PrintError(sf, errUnrecoStructTag, TRUE);
		  sf->pt++;	// continue
	  }  
	  /*  For this one, don't blow up on unrecognized tags,
	   *  but attempt to find the closing end tag, if possible.
	   *  That way we can try to recover gracefully.
	   */

  }	// while loop

  if (!fMatchedEnd)
	  PrintError(sf, errUnmatchedStructEnd, TRUE);
  
  OutputTag(sf, wBlock, fStructure ? T2_STRUCTEND : T2_UNIONEND);
  OutputText(sf, "\n");

  return fMatchedEnd;
}





BOOL DoOthertypeTag(NPSourceFile sf, WORD wBlock)
{

	
  switch (GetFirstBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyOthertType, TRUE);
	break;

    case RET_ENDTAG:
	PrintError(sf, errMissingOthertFields, TRUE);
	return FALSE;

    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, T2_OTHERTTYPE);
	OutputRegion(sf, '\n');
  }
	
  /*  Get the othertype name tag.  It may have an optional description
   */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyOthertName, TRUE);
	break;		// break so that we can pull up flag fields.

    case RET_ENDBLOCK:
	/*  There is the optional description present.
	 *  print the othertype name, then do the description.
	 */
	OutputTag(sf, wBlock, T2_OTHERTNAME);
	OutputRegion(sf, '\n');

	/*  Do the description  */
	switch (GetNextBlock(sf)) {
	  case RET_EMPTYBLOCK:
		PrintError(sf, errEmptyOthertDesc, TRUE);
		break;
	  case RET_ENDBLOCK:
		PrintError(sf, errExtraOthertFields, FALSE);
		/*  Fall through  */
	  case RET_ENDTAG:
		OutputTag(sf, wBlock, T2_OTHERTDESC);
		OutputRegion(sf, '\n');
	}
	break;
	
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_OTHERTNAME);
	OutputRegion(sf, '\n');
	break;
  }
  return TRUE;
}



BOOL DoTagnameTag(NPSourceFile sf, WORD wBlock)
{

  switch (GetFirstBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyTagname, TRUE);
	break;

    case RET_ENDBLOCK:
	PrintError(sf, errExtraTagnameFields, FALSE);
	/*  Fall through  */
	
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_TAGNAME);
	OutputRegion(sf, '\n');
	
  }
  return TRUE;
}




/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoRegisterTag | Process a single register tag
 * line, and output the information contained within.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @parm	BOOL | fReturn | Specifies whether this register declaration
 * is being processed under a return description block, or as a
 * register parameter declaration.
 * 
 * @xref	DoRegisterDeclaration
 * 
 */
BOOL DoRegisterTag(NPSourceFile sf, WORD wBlock, BOOL fReturn)
{

  BOOL fret;
  
  fret = FALSE;

  /* Assume that I'm positioned correctly on the parm tag */
  switch (GetFirstBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyRegName, TRUE);
	break;

    case RET_ENDTAG:
	PrintError(sf, errMissingRegDesc, TRUE);
	fret = TRUE;
	/*  Fall through  */
	
    case RET_ENDBLOCK:
	if (fReturn)
		OutputTag(sf, wBlock, T2_REGNAMERTN);
	else
		OutputTag(sf, wBlock, T2_REGNAME);
	OutputRegion(sf, '\n');
  }

  if (fret)
	  return FALSE;
  
  /*  Do the register description */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyRegDescrip, TRUE);
	break;

    case RET_ENDBLOCK:
	PrintError(sf, errExtraRegFields, FALSE);
	/* Fall through */

    case RET_ENDTAG:
	if (fReturn)
		OutputTag(sf, wBlock, T2_REGDESCRTN);
	else
		OutputTag(sf, wBlock, T2_REGDESC);
	OutputRegion(sf, '\n');
  }
  
  return TRUE;
}


/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoRegisterDeclaration | Processes a register parameter
 * declaration, outputing the register information, and processes flags
 * following the register declaration.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @comm	This should be called to deal with register declarations that
 * sit under a api function, as opposed to register return declarations,
 * which are handled by the return tag processing function,
 * <f DoReturnTag>.  The register tag line itself is processed by
 * <f DoRegisterTag>.
 * 
 * @xref	DoRegisterTag, ProcessFlagList
 * 
 */
BOOL DoRegisterDeclaration(NPSourceFile sf, WORD wBlock)
{
	
  /*  Check if we've done any param tags this block, and warn if so  */
  if (sf->wFlags & SFLAG_PARMS) {
	PrintError(sf, errMixedRegParm, FALSE);
  }
  sf->wFlags |= SFLAG_REGS;
	
  DoRegisterTag(sf, wBlock, FALSE);
  
  /*  Since this is a register declaration (like a param), do flags  */
  ProcessFlagList(sf, wBlock, T2_FLAGNAMEREG, T2_FLAGDESCREG);
  return TRUE;
}



/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoConditionalTag | Process a conditional tag that
 * appears in a registered return tag description.  Any subsequent
 * register and flag tags are processed under this conditional block.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @comm	Processing the single block of a conditional description.
 * Then processes any number of register tags, which may in turn be
 * followed by flag tags.  Processing stops at the first non register or
 * tag field.
 * 
 */
BOOL DoConditionalTag(NPSourceFile sf, WORD wBlock)
{
  
  BOOL	ret;
  char	buf[30];
  
  ret = TRUE;

  switch (GetFirstBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyConditionTag, TRUE);
	break;		// break so that we can pull up flag fields.

    case RET_ENDBLOCK:
	PrintError(sf, errExtraConditionField, FALSE);
	/* fall through */
	
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_CONDITIONAL);
	OutputRegion(sf, '\n');
	break;
  }

  /*  This should now be followed by a list of registers.  Process
   *  it, returning on the first unrecognized tag (which will either
   *  be another conditional, a non-return tag, or perhaps end of block?
   */
  while (FindNextTag(sf)) {
	  sf->pt++;
	  CopyRegion(sf, buf, sizeof(buf));
	  sf->pt--;

	  if (!strcmpi(buf, T1_REGISTER)) {
		  DoRegisterTag(sf, wBlock, TRUE);
		  
		  ProcessFlagList(sf, wBlock,
				  T2_FLAGNAMEREGRTN, T2_FLAGDESCREGRTN);
	  }
	  else if (!strcmpi(buf, T1_FLAG)) {
		  PrintError(sf, errMisplacedCondFlag, TRUE);
		  sf->pt++;		// skip tag
	  }
	  else if (!strcmpi(buf, T1_PRINTCOMM)) {
		  DoPrintedCommentTag(sf);
	  }
	  else {
		  // unrecognized tag, break out and return.
		  break;
	  }
  }	// while loop
 
  return ret;
}




/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoRegisterizedReturnTag | Process a return description
 * tag for a register-based block, and processing any subsequent
 * register and flag tags.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @comm	Processing the single block of a return description.  Then
 * processes any number of register tags, which may in turn be followed
 * by flag tags.  Processing stops at the first non register or tag
 * field.
 * 
 */
BOOL DoRegisterizedReturnTag(NPSourceFile sf, WORD wBlock)
{
  BOOL	ret;
  char	buf[30];
  BOOL	fConditional = FALSE;
  
  ret = TRUE;
  if (sf->wFlags & SFLAG_RDESC) {
	  PrintError(sf, errMultipleReturns, TRUE);
	  ret = FALSE;
  }
  sf->wFlags |= SFLAG_RDESC;

  switch (GetFirstBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyReturnTag, TRUE);
	break;		// break so that we can pull up flag fields.

    case RET_ENDBLOCK:
	PrintError(sf, errExtraReturnField, FALSE);
	/* fall through */
	
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_RETURN);
	OutputRegion(sf, '\n');
	break;
  }

  /*  Process the tags that follow:  If a register, then process the
   *  flag tags that may follow..  If a printed comment, print it.
   *  Once in a conditional block, deal with conditional tags.
   *  Anything else, return.
   */
  while (FindNextTag(sf)) {
	  sf->pt++;
	  CopyRegion(sf, buf, sizeof(buf));
	  sf->pt--;
	  
	  if (!strcmpi(buf, T1_REGISTER)) {
		  /*  If I've entered a conditional block already,
		   *  I shouldn't ever hit a register tag again.
		   *  assert this.
		   */
		  assert(fConditional == FALSE);

		  DoRegisterTag(sf, wBlock, TRUE);
		  
		  ProcessFlagList(sf, wBlock,
				  T2_FLAGNAMEREGRTN, T2_FLAGDESCREGRTN);
	  }
	  else if (!strcmpi(buf, T1_CONDITIONAL)) {
		  fConditional = TRUE;
		  
		  /*  Now process the conditional tag and following
		   *  tag list?
		   */
		  DoConditionalTag(sf, wBlock);
	  }
	  else if (!strcmpi(buf, T1_FLAG)) {
		  PrintError(sf, "Misplaced flag in MASM return description",
				  TRUE);
		  sf->pt++;		// skip tag
	  }
	  else if (!strcmpi(buf, T1_PRINTCOMM)) {
		  DoPrintedCommentTag(sf);
	  }
	  else {
		  // unrecognized tag, break out and return.
		  break;
	  }
  }	// while loop
 
  return ret;
}




/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoParameterizedReturnTag | Process a return
 * description tag for a parameterized block or message, and any
 * following flag tags.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @comm	Processes the single block of a return description.  Then
 * processes any number of flag fields, and returns upon encountering
 * the first non-flag tag.
 * 
 */
BOOL DoParameterizedReturnTag(NPSourceFile sf, WORD wBlock)
{
  BOOL	ret;

  ret = TRUE;
  if (sf->wFlags & SFLAG_RDESC) {
	  PrintError(sf, errMultipleReturns, TRUE);
	  ret = FALSE;
  }
  sf->wFlags |= SFLAG_RDESC;

  switch (GetFirstBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyReturnTag, TRUE);
	break;		// break so that we can pull up flag fields.

    case RET_ENDBLOCK:
	PrintError(sf, errExtraReturnField, FALSE);
	/* fall through */
	
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_RETURN);
	OutputRegion(sf, '\n');
	break;
  }


  /*  Since I'm a parameterized block, we just process @flag messages.
   *  Anything else, reject it!
   */
  ProcessFlagList(sf, wBlock, T2_FLAGNAMERTN, T2_FLAGDESCRTN);

  return ret;
  
}



/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoCommentTag | Process and output a comment tag
 * within a procedure block.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @rdesc	Returns TRUE if the comment is the first comment block within
 * this procedure block.  Returns FALSE if this is the second such
 * description, but still outputs the comment block.
 * 
 */
BOOL DoCommentTag(NPSourceFile sf, WORD wBlock)
{
  WORD	ret;
  
  ret = TRUE;
  if (sf->wFlags & SFLAG_COMM) {
	  PrintError(sf, errMultipleComments, TRUE);
	  ret = FALSE;
  }
  sf->wFlags |= SFLAG_COMM;
  
  switch (GetFirstBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyCommentBlock, TRUE);
	return False;

    case RET_ENDBLOCK:
	PrintError(sf, errExtraCommentFields, FALSE);
	/*  Fall through  */
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_COMMENT);
	OutputRegion(sf, '\n');
  }
  return ret;
}



/* 
 * @doc	EXTRACT
 * @api	BOOL | DoPrintedCommentTag | Prints a ``printed-comment'' tag
 * on stderr to the user of EXTRACT, and skips over the tag in the
 * comment buffer.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @comm	Prints the text of the first block onto stderr.  Useful for
 * notifying the user of EXTRACT of various problems with documentation
 * files or hacks in the program that should be fixed.
 * 
 * Multiple fields are ignored, and the usual warnings about empty
 * fields apply.
 * 
 */
BOOL DoPrintedCommentTag(NPSourceFile sf)
{
  WORD	w;
  PSTR	p;
  
  switch (GetFirstBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyPrintComm, TRUE);
	return FALSE;
	
    case RET_ENDBLOCK:
	PrintError(sf, errExtraPrintComm, FALSE);
	/* Fall through */

    case RET_ENDTAG:
	w = (WORD) (sf->mark - sf->pt) + 1;
	p = NearMalloc(w, False);
	CopyRegion(sf, p, w);
	fputs(p, stderr);
	putc('\n', stderr);
	NearFree(p);
  }
  return TRUE;
  
}



/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoUsesTag | Process and output a uses tag within an
 * ASM block.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @rdesc	Returns TRUE if this is the first uses tag in the block, or
 * FALSE if this is the second uses tag encountered.
 * 
 */
BOOL DoUsesTag(NPSourceFile sf, WORD wBlock)
{
  PSTR	p;

  p = NearMalloc(50, TRUE);
  *p = '\0';
  
  switch (ProcessWordList(sf, &p, TRUE)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyUsesBlock, TRUE);
	NearFree(p);
	return FALSE;
	
    case RET_ENDBLOCK:
	PrintError(sf, errExtraUsesFields, FALSE);
	/* Fall through */

    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_USES);
	OutputText(sf, p);
	OutputText(sf, "\n");
  }

  NearFree(p);
  return TRUE;
  
}



/* 
 * @doc	EXTRACT
 * @api	void | ProcessXrefTag | Process a cross reference tag, adding
 * the current cross reference information to the cross reference
 * buffer. 
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @comm	Adds the cross references given on the current tag to the
 * current cross reference buffer, which is printed whenever and
 * endblock is output.  An endblock resets the cross reference buffer to
 * be empty.  Multiple cross references within the same outerlevel block
 * generate a warning message, and are ignored.
 * 
 */
void ProcessXrefTag(NPSourceFile sf)
{
  PSTR	p;

  if (sf->pXref != NULL) {
	PrintError(sf, errMultipleXref, FALSE);
	sf->pt++;	// skip this tag
	return;
  }
  
  p = NearMalloc(50, TRUE);
  *p = '\0';
  
  switch (ProcessWordList(sf, &p, FALSE)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyCrossRef, FALSE);
	NearFree(p);
	break;

    case RET_ENDBLOCK:
	PrintError(sf, errExtraCrossRef, FALSE);
	/* Fall through */

    case RET_ENDTAG:
	sf->pXref = p;
  }
  return;
}



/* 
 * @doc	EXTRACT
 * @api	void | DoBlockBegin | Output the begin block tags and
 * information for the current point.
 * 
 * @parm	NPSourceFile | sf | blah.
 * 
 * @comm	Outputs a BEGINBLOCK tag, followed by the DOCLEVEL tag and
 * SOURCELINE tag.  The source file and line number of the current point
 * are printed with the SOURCELINE tag.
 * 
 * @xref	DoBlockEnd
 *
 */
void DoBlockBegin(NPSourceFile sf)
{
  WORD	w;
  char	buf[25];
	
  OutputTagText(sf, T2TEXT_BEGINBLOCK);
  OutputText(sf, "----------------------------------------------------\n");
  OutputTagText(sf, T2TEXT_DOCLEVEL);
  OutputText(sf, sf->pDocLevel);
  OutputText(sf, "\n");
  OutputTagText(sf, T2TEXT_SOURCELINE);
  OutputText(sf, sf->fileEntry->filename);
  w = FixLineCounts(sf, sf->pt);
  sprintf(buf, " %u\n", w);
  OutputText(sf, buf);

}



/* 
 * @doc	EXTRACT
 * @api	void | DoBlockEnd | Outputs end block tags, and outputs and
 * flushes the cross reference buffer if needed.
 * 
 * @parm	NPSourceFile | sf | blah.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @parm	BOOL | fFlushXref | Specifies whether to print the current
 * cross references (if any) before closing the block, and to reset the
 * cross empty buffer to be empty.
 * 
 * @xref	DoBlockBegin
 * 
 */
void DoBlockEnd(NPSourceFile sf, WORD wBlock, BOOL fFlushXref)
{
  /*  Flush out the xref buffer  */
  if (fFlushXref && sf->pXref != NULL) {
    OutputTag(sf, wBlock, T2_XREF);
    OutputText(sf, sf->pXref);
    OutputText(sf, "\n");
    NearFree(sf->pXref);
    sf->pXref = NULL;
  }
  
  OutputTagText(sf, T2TEXT_ENDBLOCK);
  OutputText(sf, "\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\outertag.c ===
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "extract.h"
#include "tags.h"


/* 
 * THE DEFINITIONS OF ALL THE SECOND LEVEL TAGS:
 * 
 * Indexed according to the outerlevel block that they're in.
 * 
 * ANY CHANGES TO TAGS.H MUST BE REFLECTED HERE, AND VICE VERSA!!
 * 
 */
PSTR	DocTags[NUM_LEVELS][NUM_TAGS] = {
  /*  LEVEL 0 -- API TAGS
   */
  {	"API", "ApiName", "ApiType", "ApiDesc",
	/*  Parameter declarations and flags  */
	"ApiParmName", "ApiParmType", "ApiParmDesc", "ApiFlagNameParm", "ApiFlagDescParm",
	/*  Register declarations and flags  */
	0, 0, 0, 0,
	/* "ApiRegName", "ApiRegDesc", "ApiFlagNameReg", "ApiFlagDescReg", */
		
	/*  Return field declarations, flag, and registers  */
	"ApiRtnDesc", "ApiFlagNameRtn", "ApiFlagDescRtn",
	// "ApiRegNameRtn", "ApiRegDescRtn", "ApiFlagNameRegRtn", "ApiFlagDescRegRtn",
	0, 0, 0, 0,
	"ApiComment",
	"ApiXref",
	0,			// uses not for API
	0,			// conditional not for API
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// field tags
	0, 0, 0, 0
  },
  /*  LEVEL 1 -- CALLBACK TAGS
   */
  {	"CB", "CbName", "CbType", "CbDesc",
	/*  Parameter declarations and flags  */
	"CbParmName", "CbParmType", "CbParmDesc", "CbFlagNameParm", "CbFlagDescParm",
	/*  Register declarations and flags  */
	// "CbRegName", "CbRegDesc", "CbFlagNameReg", "CbFlagDescReg",
	0, 0, 0, 0,
	/*  Return field declarations, flag, and registers  */
	"CbRtnDesc", "CbFlagNameRtn", "CbFlagDescRtn",
	//"CbRegNameRtn", "CbRegDescRtn", "CbFlagNameRegRtn", "CbFlagDescRegRtn",
	0, 0, 0, 0,
	"CbComment",
	"CbXref",
	0,			// uses not for API
	0,			// conditional not for API
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// field tags
	0, 0, 0, 0
  },
  /*  LEVEL 2 -- MESSAGE TAGS
   */
  {	"MSG", "MsgName", 0, "MsgDesc",
	/*  Parameter declarations and flags  */
	"MsgParmName", "MsgParmType", "MsgParmDesc", "MsgFlagNameParm", "MsgFlagDescParm",
	/*  Register declarations and flags  */
	// "MsgRegName", "MsgRegDesc", "MsgFlagNameReg", "MsgFlagDescReg",
	0, 0, 0, 0,
	/*  Return field declarations, flag, and registers  */
	"MsgRtnDesc", "MsgFlagNameRtn", "MsgFlagDescRtn",
	// "MsgRegNameRtn", "MsgRegDescRtn", "MsgFlagNameRegRtn", "MsgFlagDescRegRtn",
	0, 0, 0, 0,
	"MsgComment",
	"MsgXref",
	0,			// uses not for message
	0,			// conditional not for Message
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// field tags
	0, 0, 0, 0
  },
  /*  ASSEMBLER BLOCK CODES
   */
  {	"ASM", "AsmName", 0, "AsmDesc",
	/*  Parameters and flags  */
	// "AsmParmName", "AsmParmType", "AsmParmDesc", "AsmFlagNameParm", "AsmFlagDescParm",
	0, 0, 0, 0, 0,
	/*  Registers and flags  */
	"AsmRegName", "AsmRegDesc", "AsmFlagNameReg", "AsmFlagDescReg",
	/*  Return field declarations  */
	// "AsmRtnDesc", "AsmFlagNameRtn", "AsmFlagDescRtn",
	"AsmRtnDesc", 0, 0,
	"AsmRegNameRtn", "AsmRegDescRtn", "AsmFlagNameRegRtn", "AsmFlagDescRegRtn",
	"AsmComment",
	"AsmXref",
	"AsmUses",		// uses tag
	"AsmCond",		// conditional tag
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// field tags
	0, 0, 0, 0
  },
  /*  ASSEMBLER CALLBACK TAGS
   */
  {	"ASMCB", "AsmCbName", "AsmCbType", "AsmCbDesc",
	/*  Parameter and flags  */
	// "AsmCbParmName", "AsmCbParmType", "AsmCbParmDesc", "AsmCbFlagNameParm", "AsmCbFlagDescParm",
	0, 0, 0, 0, 0,

	/*  Registers and flags  */
	"AsmCbRegName", "AsmCbRegDesc", "AsmCbFlagNameReg", "AsmCbFlagDescReg",

	/*  Return field declarations, flag, and registers  */
	//"CbRtnDesc", "CbFlagNameRtn", "CbFlagDescRtn",
	"AsmCbRtnDesc", 0, 0,

	"AsmCbRegNameRtn", "AsmCbRegDescRtn", "AsmCbFlagNameRegRtn", "AsmCbFlagDescRegRtn",
	// 0, 0, 0, 0,
	"AsmCbComment",
	"AsmCbXref",
	"AsmCbUses",
	"AsmCBCond",
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// field tags
	0, 0, 0, 0
  },

  /*  STRUCTURE TYPE
   */
  {	"STRUC", "StructName", 0, "StructDesc",
	/*  Parameter and flags  */
	0, 0, 0, 0, 0,

	/*  Registers and flags  */
	0, 0, 0, 0, 

	/*  Return field declarations, flag, and registers  */
	0, 0, 0,
	0, 0, 0, 0,

	"StructComment",
	"StructXref",
	0, 0,		// uses and conditional

	"StructFieldType", "StructFieldName", "StructFieldDesc",
	"StructFlagName", "StructFlagDesc",
	"StructUnionName", "StructUnionDesc",
	"StructStructName", "StructStructDesc",
	"StructOtherType", "StructOtherName", "StructOtherDesc",
	"StructStructEnd", "StructUnionEnd",
	"StructTagname"
  },

  /*  UNION TYPE
   */
  {	"UNION", "UnionName", 0, "UnionDesc",
	/*  Parameter and flags  */
	0, 0, 0, 0, 0,

	/*  Registers and flags  */
	0, 0, 0, 0, 

	/*  Return field declarations, flag, and registers  */
	0, 0, 0,
	0, 0, 0, 0,

	"UnionComment",
	"UnionXref",
	0, 0,		// uses and conditional

	"UnionFieldType", "UnionFieldName", "UnionFieldDesc",
	"UnionFlagName", "UnionFlagDesc",
	"UnionUnionName", "UnionUnionDesc",
	"UnionStructName", "UnionStructDesc",
	"UnionOtherType", "UnionOtherName", "UnionOtherDesc",
	"UnionStructEnd", "UnionUnionEnd",
	"UnionTagname"
  },

	  
	  


#ifdef WARPAINT
  /*  INTERRUPT BLOCK CODES
   */
  {	"INT", "IntName", "IntSubtype", "IntDesc",
	/*  No parameters allowed  */
	0, 0, 0, 0, 0,
	/*  Register declarations  */
	"IntRegName", "IntRegDesc", "IntFlagNameReg", "IntFlagDescReg",
	/*  Return field descriptions  */
	// "IntRtnDesc", "IntFlagNameRtn", "IntFlagDescRtn",
	"IntRtnDesc", 0, 0,
	"IntRegNameRtn", "IntRegDescRtn", "IntFlagNameRegRtn", "IntFlagDescRegRtn",
	"IntComment",
	"IntXref",
	0,
	0,
  }
  
#endif

};



/********************************
 *
 *	ERROR MESSAGES
 *
 ********************************/

/*
 *  Normal comment block error messages
 */
char errMisplacedFlag[] = "Flag tag not under block declaration or return tag.  Ignored.";
char errMisplacedSFlag[] = "Flag tag not under field tag.  Ignored.";
char errMisplacedReg[] = "Register declaration in parameterized block.  Ignored.";
char errMisplacedOuterTag[] = "Unrecognized outerlevel tag.";
char errMisplacedCallback[] = "Callback tag not in outerlevel block.  Callback declaration ignored.";
char errParmInMASM[] = "Parameter tag in non-parameterized block.  Ignored.";
char errMisplacedUses[] = "Uses tag in parameterized block.  Ignored.";


/*  API or CB (Callback) or FUNC tag errors:
 */
char errAPIFieldsMissing[] = "Fields missing from procedure block tag.  Attempting to recover.";
char msgReturnFieldEmpty[] = "Missing value for procedure return type field.";
char msgNameFieldEmpty[] = "Missing value for procedure name field.";
char msgEmptyAPIDescription[] = "Empty description for procedure.";
char msgExtraAPIFields[] = "Extra fields for procedure block tag.  Extra fields ignored.";
char errNestedCallbacks[] = "Nested Callback tags.";
char errRegInCallback[] = "Warning: Register declaration in callback definition.";

/*  INT tag errors
 */
char errIntFieldsMissing[] = "Fields missing from interrupt block tag.";
char errIntNumberEmpty[] = "Interrupt tag:  No interrupt name specified.";
char errIntSubfuncField[] = "Interrupt subfunction field empty.";
char errIntEmptyDescrip[] = "Empty description field for interrupt tag.";
char errIntExtraFields[] = "Extra fields for interrupt block tag.  Extra fields ignored.";

/*
 *  ASM tag errors
 */
char errAsmDescMissing[] = "Description missing from ASM block tag.";
char errAsmNameEmpty[] = "Empty name field for ASM block tag.";
char errAsmEmptyDescription[] = "Empty description field for ASM block tag.";
char errAsmExtraFields[] = "Extra fields for ASM block tag.  Extra fields ignored.";
char errMisplacedConditional[] = "Condition tag not under a return tag.";


/*
 *  MESSAGE TAG ERRORS
 */
char errMessageFieldsMissing[] = "Missing description field for message tag.";
char errMessNameFieldEmpty[] = "Empty name field for message tag.";
char errEmptyMsgDescription[] = "Empty description field for message tag.";
char errExtraMsgFields[] = "Extra fields for message block tag.  Extra fields ignored.";

/*
 *  STRUCTURE ERROR MESSAGES
 */
char errStrucFieldsMissing[] = "Missing fields for @types or @typeu tag.";
char errStrucNameFieldEmpty[] = "Empty name field for structure/union tag.";
char errStrucDescEmpty[] = "Empty description field for structure/union tag.";
char errStrucExtraFields[] = "Extra fields for structure/union tag.  Extra fields ignored.";



/*
 *  INTERNAL FUNCTIONS
 */
BOOL ProcessParameterizedBlock(NPSourceFile sf, BOOL fCallback);
BOOL ProcessRegisterizedBlock(NPSourceFile sf, BOOL fCallback);
BOOL ProcessMsgBlock(NPSourceFile sf);
BOOL ProcessStructureBlock(NPSourceFile sf, BOOL fStructure);


/* 
 * @doc	EXTERNAL
 * @api	void | TagProcessBuffer | Entry point for processing a
 * comment block.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file buffer block.
 * 
 * @comm	Processes the comment block given in <p sf>.  This is the
 * entry point called by the CommentBlock parser.  This proc sequences
 * calls to the outerlevel block parsers, as well as handling parsing of
 * the DOCLEVEL tag.
 * 
 */
void TagProcessBuffer(NPSourceFile sf)
{
  WORD	w;
  char	buf[25];
  
  sf->pt = sf->mark = sf->lpbuf;	// reset point and mark to beginning
  sf->wFlags = 0;			// reset status
  sf->pXref = sf->pDocLevel = NULL;	// significant strings to hang onto
  sf->fExitAfter = FALSE;

  /*  Process this comment block, starting first at @doc tag  */
  if (!DoDocTag(sf)) {
	return;
  }
  
  while (FindNextTag(sf)) {
	  /*  Get local copy  */
	  sf->pt++;
	  CopyRegion(sf, buf, sizeof(buf));
	  sf->pt--;
	  
	  /*  Compare against known outerlevel tags  */
	  if (!strcmpi(buf, T1_API) || !strcmpi(buf, T1_FUNCTION)) {
		  ProcessParameterizedBlock(sf, FALSE);
	  }
	  else if (!strcmpi(buf, T1_ASSEMBLE)) {
		  ProcessRegisterizedBlock(sf, FALSE);
	  }
	  else if (!strcmpi(buf, T1_ASMCALLBACK)) {
		  w = fNoOutput;
		  fNoOutput = TRUE;
		  PrintError(sf, errMisplacedCallback, TRUE);
		  ProcessRegisterizedBlock(sf, TRUE);
		  fNoOutput = w;
	  }
	  else if (!strcmpi(buf, T1_CALLBACK)) {
		  /* Generate an error message, but process anyway */
		  w = fNoOutput;
		  fNoOutput = TRUE;
		  PrintError(sf, errMisplacedCallback, TRUE);
		  ProcessParameterizedBlock(sf, TRUE);
		  fNoOutput = w;
	  }
	  else if (!strcmpi(buf, T1_MESSAGE)) {
		  ProcessMsgBlock(sf);
	  }
	  else if (!strcmpi(buf, T1_PRINTCOMM)) {
		  DoPrintedCommentTag(sf);
	  }
	  else if (!strcmpi(buf, T1_TYPESTRUCT)) {
		  ProcessStructureBlock(sf, TRUE);
	  }
	  else if (!strcmpi(buf, T1_TYPEUNION)) {
		  ProcessStructureBlock(sf, FALSE);
	  }
	#if 0
	  else if (!strcmpi(buf, T1_INTERRUPT)) {
		  assert(FALSE);
	  }
	#endif
	  else {
		  /* Unrecognized tag, print error message! */
		  PrintError(sf, errMisplacedOuterTag, TRUE);
		  sf->pt++;
	  }

  }	// while

  /*  Free up significant strings  */
  assert(sf->pDocLevel != NULL);
  NearFree(sf->pDocLevel);
  if (sf->pXref)
	  NearFree(sf->pXref);
}



/* 
 * 
 * OUTERLEVEL BLOCK PROCESSORS
 * 
 * These procedures handle parsing an outerlevel block.  They are
 * invoked with the point on top of the tag that is the outerlevel
 * block.  They should process their block until finding an end to the
 * outerlevel block, or until an unrecognized tag is found.  The point
 * upon return should be the next tag following the outerlevel block
 * just processed.
 * 
 * These procedures are responsible for printing their own
 * BEGINBLOCK/ENDBLOCK tags using DoBeginBlock/DoEndBlock.  They should
 * handle Printed-Comment tags, as well as misplaced FLAG tags.  XREFS
 * should be passed to the XREF tag handler.
 * 
 * The XREF buffer is assumed to be empty upon entry into an outerlevel
 * block procedure.  No action is need by the outerlevel block handler.
 * 
 */


/* 
 * TAG PROCESSING PROCEDURES
 * 
 */

/*  Block tag processors  */
BOOL DoPBlockTag(NPSourceFile sf, WORD wBlock);
BOOL DoAssembleBlockTag(NPSourceFile sf, WORD wBlock);
BOOL DoMessageBlockTag(NPSourceFile sf, WORD wBlock);
BOOL DoStructureBlockTag(NPSourceFile sf, WORD wBlock);
// BOOL DoInteruptBlockTag(NPSourceFile sf);


/* 
 * @doc	EXTRACT
 * @api	BOOL | ProcessMsgBlock | Processes the fields of a message
 * outerlevel block.
 * 
 * @parm	NPSourceFile | sf | foo
 * 
 */
BOOL ProcessMsgBlock(NPSourceFile sf)
{
  char	buf[25];
  WORD	wBlock;
  
  assert(*sf->pt == TAG);

  wBlock = LEVEL_MSG;
  
  /*  Process the text blocks of the procedure definition  */
  DoBlockBegin(sf);
  DoMessageBlockTag(sf, wBlock);

  /* Reset return description flags, to notify on multiple rdescs
   * or comments within a single message block.
   */
  sf->wFlags &= ~SFLAG_SMASK;

  /* Now process tags within the procedure block */
  while (FindNextTag(sf)) {
	  /*  Isolate the current Tag name  */
	  sf->pt++;
	  CopyRegion(sf, buf, sizeof(buf));
	  sf->pt--;
	  
	  /*
	   *  Figure out what to do with the current tag
	   */
	  if (!strcmpi(buf, T1_PARAMETER)) {
		  DoParameterTag(sf, wBlock);
	  }
	  else if (!strcmpi(buf, T1_REGISTER)) {
		  /*  HACK HACK!
		   *  Register definitions are turned off for now.
		   */
		  PrintError(sf,"Registers in Message blocks are disabled!\n",
				  TRUE);
		  sf->pt++;
		  // DoRegisterDeclaration(sf);
	  }
	  else if (!strcmpi(buf, T1_RTNDESC)) {
		  if (!DoParameterizedReturnTag(sf, wBlock))
			  break;
	  }
	  else if (!strcmpi(buf, T1_COMMENT)) {
		  if (!DoCommentTag(sf, wBlock))
			  break;
	  }
	  else if (!strcmpi(buf, T1_XREF)) {
		  /* Do standard xref processing for this block */
		  ProcessXrefTag(sf);
	  }
	  else if (!strcmpi(buf, T1_FLAG)) {
		  PrintError(sf, errMisplacedFlag, TRUE);
		  sf->pt++;		// skip over this flag tag
	  }
	  else if (!strcmpi(buf, T1_PRINTCOMM)) {
		  DoPrintedCommentTag(sf);
	  }
	  else	// unrecognized flag!  Break out of current proc-block
		  break;
  }

  DoBlockEnd(sf, wBlock, TRUE);

  return TRUE;
}




/* 
 * @doc	EXTRACT
 *
 * @api	BOOL | ProcessStructureBlock | Processes the fields of a structure
 * or union outerlevel block.
 * 
 * @parm	NPSourceFile | sf | foo
 *
 * @parm	BOOL | fStructure | Specifies whether the block is a structure
 * block or a union block.  TRUE = Structure.
 */
BOOL ProcessStructureBlock(NPSourceFile sf, BOOL fStructure)
{
  char	buf[25];
  WORD	wBlock;

  assert(*sf->pt == TAG);

  wBlock = fStructure ? LEVEL_STRUCT : LEVEL_UNION;
  
  /*  Process the text blocks of the procedure definition  */
  DoBlockBegin(sf);
  DoStructureBlockTag(sf, wBlock);

  /* Now process tags within the procedure block */
  while (FindNextTag(sf)) {
	  /*  Isolate the current Tag name  */
	  sf->pt++;
	  CopyRegion(sf, buf, sizeof(buf));
	  sf->pt--;

	  if (!strcmpi(buf, T1_FIELD)) {
		  DoFieldTag(sf, wBlock);
	  }
	  else if (!strcmpi(buf, T1_STRUCT)) {
		  DoStructTag(sf, wBlock, TRUE);
	  }
	  else if (!strcmpi(buf, T1_UNION)) {
		  DoStructTag(sf, wBlock, FALSE);
	  }
	  else if (!strcmpi(buf, T1_OTHERTYPE)) {
		  DoOthertypeTag(sf, wBlock);
	  }
	  else if (!strcmpi(buf, T1_TAGNAME)) {
		  DoTagnameTag(sf, wBlock);
	  }
	  else if (!strcmpi(buf, T1_END)) {
		  /*  Error!  Shouldn't get one of these on the
		   *  outerlevel.
		   */
		  PrintError(sf, "Unmatched @END tag.", TRUE);
		  sf->pt++;
	  }
	  else if (!strcmpi(buf, T1_COMMENT)) {
		  if (!DoCommentTag(sf, wBlock))
			  break;
	  }
	  else if (!strcmpi(buf, T1_XREF)) {
		  /* Do standard xref processing for this block */
		  ProcessXrefTag(sf);
	  }
	  else if (!strcmpi(buf, T1_FLAG)) {
		  PrintError(sf, errMisplacedSFlag, TRUE);
		  sf->pt++;		// skip over this flag tag
	  }
	  else if (!strcmpi(buf, T1_PRINTCOMM)) {
		  DoPrintedCommentTag(sf);
	  }
	  else	// unrecognized flag!  Break out of current proc-block
		  break;
  }

  DoBlockEnd(sf, wBlock, TRUE);

  return TRUE;
}




/* 
 * @doc	EXTRACT
 * 
 * @api	WORD | ProcessParameterizedBlock | Processes one
 * procedure block definition.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file buffer block.
 * 
 * @parm	BOOL | fCallback | If TRUE, then a callback is being
 * processed.  If FALSE, a standard api block is being processed.
 * 
 * @rdesc	Returns FALSE when the end of the comment block is reached,
 * or TRUE otherwise.  Upon return, the point will point to the end of
 * the last processed procedure block.
 * 
 * @comm	Processes the "procedure block" beginning from the point and
 * going until the next procedure block starts, or the end of the
 * comment block is found.
 * 
 */
BOOL ProcessParameterizedBlock(NPSourceFile sf, BOOL fCallback)
{
  char	buf[25];
  WORD	wBlock;
  BOOL	fNoOutputStore;
  WORD	wFlagsStore;
  
  
  /* Be re-entrant and deal with a procedure block */
  assert(*sf->pt == TAG);

  if (fCallback) {
	  wBlock = LEVEL_CALLBACK;
  }
  else {
	  wBlock = LEVEL_API;
	  DoBlockBegin(sf);
  }
  
  /*  Deal with the header line  */
  DoPBlockTag(sf, wBlock);
  

  /* Reset return description flags, to notify on multiple rdescs
   * or comments within a single proc block.
   */
  sf->wFlags &= ~SFLAG_SMASK;
  
  /* Now process tags within the procedure block */
  while (FindNextTag(sf)) {
	  /*  Isolate the current Tag name  */
	  sf->pt++;
	  CopyRegion(sf, buf, sizeof(buf));
	  sf->pt--;
	  
	  if (!strcmpi(buf, T1_PARAMETER)) {
		  DoParameterTag(sf, wBlock);
	  }
	  else if (!strcmpi(buf, T1_RTNDESC)) {
		  if (!DoParameterizedReturnTag(sf, wBlock)) {
			 // assert(0);
			  break;
		  }
	  }
	  else if (!strcmpi(buf, T1_COMMENT)) {
		  if (!DoCommentTag(sf, wBlock)) {
			 // assert(0);
			  break;
		  }
	  }
	  else if (!strcmpi(buf, T1_CALLBACK)) {
		  if (fCallback) {
			  wFlagsStore = sf->wFlags;
			  fNoOutputStore = fNoOutput;
			  fNoOutput = TRUE;
			  
			  PrintError(sf, errNestedCallbacks, TRUE);
		  }
		  
		  ProcessParameterizedBlock(sf, TRUE);
		  
		  if (fCallback) {
			  fNoOutput = fNoOutputStore;
			  sf->wFlags = wFlagsStore;
		  }
	  }
	  else if (!strcmpi(buf, T1_ASMCALLBACK)) {
		  if (fCallback) {
			  wFlagsStore = sf->wFlags;
			  fNoOutputStore = fNoOutput;
			  fNoOutput = TRUE;
			  
			  PrintError(sf, errNestedCallbacks, TRUE);
		  }
		  
		  ProcessRegisterizedBlock(sf, TRUE);
		  
		  if (fCallback) {
			  fNoOutput = fNoOutputStore;
			  sf->wFlags = wFlagsStore;
		  }
	  }
	  else if (!strcmpi(buf, T1_XREF)) {
		  /*  If this is a callback, the xrefs are not included
		   *  in the callback block and belong to the "parent"
		   *  of the callback.  Break out here to allow this.
		   */
		  if (fCallback)
			  break;
		  
		  /* Otherwise, if we're an API block, then process
		   * the xref as normal.
		   */
		  ProcessXrefTag(sf);
	  }
	  else if (!strcmpi(buf, T1_REGISTER)) {
		  PrintError(sf,
			fCallback ? errRegInCallback : errMisplacedReg,
			TRUE);
		  sf->pt++;
	  }
	  else if (!strcmpi(buf, T1_USES)) {
		  PrintError(sf, errMisplacedUses, TRUE);
		  sf->pt++;
	  }
	  else if (!strcmpi(buf, T1_FLAG)) {
		  PrintError(sf, errMisplacedFlag, TRUE);
		  sf->pt++;		// skip over this flag tag
	  }
	  else if (!strcmpi(buf, T1_PRINTCOMM)) {
		  DoPrintedCommentTag(sf);
	  }
	  else	// unrecognized flag!  Break out of current proc-block
		  break;
  }

  if (fCallback) {
	  OutputTagText(sf, T2TEXT_ENDCALLBACK);
	  OutputText(sf, "\n");
  }
  else {
	  DoBlockEnd(sf, wBlock, TRUE);
  }

  return TRUE;
}





/* 
 * @doc	EXTRACT
 * 
 * @api	WORD | ProcessRegisterizedBlock | Processes one registerized 
 * procedure block definition.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file buffer block.
 * 
 * @parm	BOOL | fCallback | If TRUE, then a callback is being
 * recursively processed.  If FALSE, then a standard @asm block is being
 * processed.  The setting of this flag determines the set of output tags
 * used for the block.
 *
 * @rdesc	Returns TRUE on success, FALSE on failure.  Upon return, the
 * point will point to the end of the last processed procedure block.
 * 
 * @comm	Processes the "procedure block" beginning from the point and
 * going until the next procedure block starts, or the end of the
 * comment block is found.
 * 
 */
BOOL ProcessRegisterizedBlock(NPSourceFile sf, BOOL fCallback)
{
  char	buf[25];
  WORD	wBlock;
  WORD	fNoOutputStore;
  WORD	wFlagsStore;
  
  /* Be re-entrant and deal with a procedure block */
  assert(*sf->pt == TAG);

  if (!fCallback) {
	  DoBlockBegin(sf);
	  wBlock = LEVEL_ASSEMBLE;
  }
  else
	  wBlock = LEVEL_ASMCALLBACK;

  
  /*  Deal with the header line  */
  DoAssembleBlockTag(sf, wBlock);
  
  /* Reset return description flags, to notify on multiple rdescs
   * or comments within a single proc block.
   */
  sf->wFlags &= ~SFLAG_SMASK;
  
  /* Now process tags within the procedure block */
  while (FindNextTag(sf)) {
	  /*  Isolate the current Tag name  */
	  sf->pt++;
	  CopyRegion(sf, buf, sizeof(buf));
	  sf->pt--;

	  /*
	   *  Figure out what to do with the current tag - dealing with:
	   *	ASMCALLBACK
	   *	ASSEMBLER
	   */
	  if (!strcmpi(buf, T1_REGISTER)) {
		  DoRegisterDeclaration(sf, wBlock);
	  }
	  else if (!strcmpi(buf, T1_RTNDESC)) {
		  if (!DoRegisterizedReturnTag(sf, wBlock)) {
			//  assert(0);
			  break;
		  }
	  }
	  else if (!strcmpi(buf, T1_COMMENT)) {
		  if (!DoCommentTag(sf, wBlock)) {
			//  assert(0);
			  break;
		  }
	  }
	  else if (!strcmpi(buf, T1_XREF)) {
		  if (fCallback)
			  break;
		  
		  /* Do standard xref processing for this block */
		  ProcessXrefTag(sf);
	  }
	  else if (!strcmpi(buf, T1_USES)) {
		  DoUsesTag(sf, wBlock);
	  }
	  else if (!strcmpi(buf, T1_ASMCALLBACK)) {
		  /*  Check and see if I'm already in a callback.
		   *  Watch out for nested callbacks!
		   */
		  if (fCallback) {
			  /*  Already in a callback.  Print error, and
			   *  "eat" the nested callback by turning off
			   *  output and processing it.
			   */
			  PrintError(sf, errNestedCallbacks, TRUE);
			  fNoOutputStore = fNoOutput;
			  wFlagsStore = sf->wFlags;
			  fNoOutput = TRUE;
		  }
		  
		  ProcessRegisterizedBlock(sf, TRUE);
		  
		  /*  Restore output if I just ate a nested callback  */
		  if (fCallback) {
			  fNoOutput = fNoOutputStore;
			  sf->wFlags = wFlagsStore;
		  }
	  }
	  else if (!strcmpi(buf, T1_CALLBACK)) {
		  /*  Check and see if I'm already in a callback.
		   *  Watch out for nested callbacks!
		   */
		  if (fCallback) {
			  /*  Already in a callback.  Print error, and
			   *  "eat" the nested callback by turning off
			   *  output and processing it.
			   */
			  PrintError(sf, errNestedCallbacks, TRUE);
			  fNoOutputStore = fNoOutput;
			  wFlagsStore = sf->wFlags;
			  fNoOutput = TRUE;
		  }
		  
		  ProcessParameterizedBlock(sf, TRUE);
		  
		  /*  Restore output if I just ate a nested callback  */
		  if (fCallback) {
			  fNoOutput = fNoOutputStore;
			  sf->wFlags = wFlagsStore;
		  }
	  }
	  else if (!strcmpi(buf, T1_PARAMETER)) {
		  PrintError(sf, errParmInMASM, TRUE);
		  sf->pt++;
	  }
	  else if (!strcmpi(buf, T1_CONDITIONAL)) {
		  PrintError(sf, errMisplacedConditional, TRUE);
		  sf->pt++;
	  }
	  else if (!strcmpi(buf, T1_FLAG)) {
		  PrintError(sf, errMisplacedFlag, TRUE);
		  sf->pt++;		// skip over this flag tag
	  }
	  else if (!strcmpi(buf, T1_PRINTCOMM)) {
		  DoPrintedCommentTag(sf);
	  }
	  else	// unrecognized flag!  Break out of current proc-block
		  break;
  }

  if (fCallback) {
	  OutputTagText(sf, T2TEXT_ENDCALLBACK);
	  OutputText(sf, "\n");
  }
  else {
	  DoBlockEnd(sf, wBlock, TRUE);
  }

  return TRUE;
}





/*************************************************************************
 * 
 * PROCESSORS FOR THE VARIOUS TYPES OF PBLOCK TAGS
 * 
 * Process the tags themselves.  The output tags from these processors
 * depends on the mode that the SourceFile block is ie, (which is same
 * as the outerlevel block that one is currently in.  Thus callback tags
 * for params and return descriptions can be different from regular
 * procedure descriptions).
 * 
 *************************************************************************/

/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoPBlockTag | Processes and outputs the fields of a
 * procedure block header tag (API, FUNC, or CB).
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	WORD | wBlock | Blah.
 * 
 * @comm	Processes and outputs the procedure declaration fields.
 * 
 */
BOOL DoPBlockTag(NPSourceFile sf, WORD wBlock)
{
  /* Assumes GetNextTag() has left us on the tag for the PBlock,
   * and that wType accurately reflects it's type
   */
  
  assert(wBlock == LEVEL_API || wBlock == LEVEL_CALLBACK);
	
  /*  Get the return type field of the pblock  */
  switch (GetFirstBlock(sf)) {
    case RET_ENDTAG:
APIFieldsMissing:
	PrintError(sf, errAPIFieldsMissing, TRUE);
	return FALSE;
    case RET_EMPTYBLOCK:
	PrintError(sf, msgReturnFieldEmpty, TRUE);
	break;
    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, T2_LEVELTYPE);
	OutputRegion(sf, '\n');
  }
  
  /* Handle the name field of the pblock */
  switch (GetNextBlock(sf)) {
    case RET_ENDTAG:
	goto APIFieldsMissing;
    case RET_EMPTYBLOCK:
	PrintError(sf, msgNameFieldEmpty, TRUE);
	break;
    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, T2_LEVELNAME);
	OutputRegion(sf, '\n');
  }
  
  /*  Now deal with the descriptive text field  */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, msgEmptyAPIDescription, TRUE);
	break;
	
    case RET_ENDBLOCK:
	PrintError(sf, msgExtraAPIFields, FALSE);
	/* Fall through */
  
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_LEVELDESC);
	OutputRegion(sf, '\n');
  }
  return TRUE;
}




/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoAssembleBlockTag | Processes and outputs the fields
 * of the message block tag.
 * 
 * @parm	NPSourceFile | sf | Foobar.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * For this procedure, this parameter should be either LEVEL_ASSEMBLE or
 * LEVEL_ASMCALLBACK.
 * 
 * @comm	Processes a assemble tag. Assumes on entry that the point is
 * at the beginning of the message (as returned from <f FindNextTag>).
 * Prints standard warnings on error conditions.
 * 
 */
BOOL DoAssembleBlockTag(NPSourceFile sf, WORD wBlock)
{
  /* Assumes GetNextTag() has left us on the tag for the Message Block,
   * and that wType accurately reflects it's type
   */

  assert(wBlock == LEVEL_ASSEMBLE || wBlock == LEVEL_ASMCALLBACK);

  /*  Get the return type field of the pblock  */
  switch (GetFirstBlock(sf)) {
    case RET_ENDTAG:
AssFieldsMissing:
	PrintError(sf, errAsmDescMissing, TRUE);
	return FALSE;
    case RET_EMPTYBLOCK:
	PrintError(sf, errAsmNameEmpty, TRUE);
	break;
    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, T2_LEVELNAME);
	OutputRegion(sf, '\n');
  }
  
  /*  Now deal with the descriptive text field  */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errAsmEmptyDescription, TRUE);
	break;

    case RET_ENDBLOCK:
	PrintError(sf, errAsmExtraFields, FALSE);
	/* Fall through */
  
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_LEVELDESC);
	OutputRegion(sf, '\n');
  }
  return TRUE;

}



/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoMessageBlockTag | Processes and outputs the fields
 * of the message block tag.
 * 
 * @parm	NPSourceFile | sf | Foobar.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * The only one that makes sense for this function is LEVEL_MSG.
 * 
 * @comm	Processes a message tag. Assumes on entry that the point is
 * at the beginning of the message (as returned from <f FindNextTag>).
 * Prints standard warnings on error conditions.
 * 
 */
BOOL DoMessageBlockTag(NPSourceFile sf, WORD wBlock)
{
  /* Assumes GetNextTag() has left us on the tag for the Message Block,
   * and that wType accurately reflects it's type
   */
  
  assert(wBlock == LEVEL_MSG);
	
  /*  Get the return type field of the pblock  */
  switch (GetFirstBlock(sf)) {
    case RET_ENDTAG:
	PrintError(sf, errMessageFieldsMissing, TRUE);
	return FALSE;
    case RET_EMPTYBLOCK:
	PrintError(sf, errMessNameFieldEmpty, TRUE);
	break;
    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, T2_LEVELNAME);
	OutputRegion(sf, '\n');
  }
  
  /*  Now deal with the descriptive text field  */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errEmptyMsgDescription, TRUE);
	break;
	
    case RET_ENDBLOCK:
	PrintError(sf, errExtraMsgFields, FALSE);
	/* Fall through */
  
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_LEVELDESC);
	OutputRegion(sf, '\n');
  }
  return TRUE;

}



/* 
 * @doc	EXTRACT
 * 
 * @api	BOOL | DoStructureBlockTag | Processes and outputs the fields
 * of the structure/union block tag.
 * 
 * @parm	NPSourceFile | sf | Foobar.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * May be either LEVEL_STRUCT or LEVEL_UNION.
 * 
 * @comm	Processes a types tag. Assumes on entry that the point is
 * at the beginning of the message (as returned from <f FindNextTag>).
 * Prints standard warnings on error conditions.
 * 
 */
BOOL DoStructureBlockTag(NPSourceFile sf, WORD wBlock)
{
  /* Assumes GetNextTag() has left us on the tag for the struct Block,
   * and that wType accurately reflects it's type
   */
  
  /*  Get the type name  */
  switch (GetFirstBlock(sf)) {
    case RET_ENDTAG:
	PrintError(sf, errStrucFieldsMissing, TRUE);
	return FALSE;
    case RET_EMPTYBLOCK:
	PrintError(sf, errStrucNameFieldEmpty, TRUE);
	break;
    case RET_ENDBLOCK:
	OutputTag(sf, wBlock, T2_LEVELNAME);
	OutputRegion(sf, '\n');
  }

  /*  Now deal with the descriptive text field  */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errStrucDescEmpty, TRUE);
	break;
	
    case RET_ENDBLOCK:
	PrintError(sf, errStrucExtraFields, FALSE);
	/* Fall through */
  
    case RET_ENDTAG:
	OutputTag(sf, wBlock, T2_LEVELDESC);
	OutputRegion(sf, '\n');
  }
  return TRUE;

}



#ifdef WARPAINT

/* 
 * @doc	EXTRACT
 * @api	BOOL | DoInteruptBlockTag | Processes and outputs the fields of a
 * interrupt block header tag.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @comm	Processes and outputs the interrupt declaration fields.
 * 
 */
BOOL DoInteruptBlockTag(NPSourceFile sf)
{
  /* Assumes GetNextTag() has left us on the tag for the Interrupt,
   * and that wType accurately reflects it's type
   */
  
  /*  Get the return type field of the pblock  */
  switch (GetFirstBlock(sf)) {
    case RET_ENDTAG:
IntFieldsMissing:
	PrintError(sf, errIntFieldsMissing, TRUE);
	return FALSE;
    case RET_EMPTYBLOCK:
	PrintError(sf, errIntNumberEmpty, TRUE);
	break;
    case RET_ENDBLOCK:
	OutputTag(sf, T2_LEVELNAME);
	OutputRegion(sf, '\n');
  }

  /* Handle the name field of the pblock */
  switch (GetNextBlock(sf)) {
    case RET_ENDTAG:
	goto IntFieldsMissing;
    case RET_EMPTYBLOCK:
	PrintError(sf, errIntSubfuncField, FALSE);
	break;
    case RET_ENDBLOCK:
	OutputTag(sf, T2_LEVELTYPE);
	OutputRegion(sf, '\n');
  }
  
  /*  Now deal with the descriptive text field  */
  switch (GetNextBlock(sf)) {
    case RET_EMPTYBLOCK:
	PrintError(sf, errIntEmptyDescrip, TRUE);
	break;

    case RET_ENDBLOCK:
	PrintError(sf, errIntExtraFields, FALSE);
	/* Fall through */
  
    case RET_ENDTAG:
	OutputTag(sf, T2_LEVELDESC);
	OutputRegion(sf, '\n');
  }
  return TRUE;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\bfuncs.c ===
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#include "extract.h"
#include "tags.h"


#define SPACE(c) ((c) == ' ' || (c) == '\t' || (c) == '\n')

/*  Output routine error messages  */
char errOut[] = "%s: Error writing to file.\n";

/* Standard templated error messages */
static char errmsg[] = "%s (%u): %s\n";


/*  File private functions
 */
static WORD CommonGetBlock(NPSourceFile sf, PSTR p);


/* 
 * @doc	EXTRACT
 * 
 * @api	void | OutputTag | Print a tag name to the output file.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file buffer block.
 * 
 * @parm	WORD | wBlock | Specifies the current outerlevel block type.
 * 
 * @parm	WORD | wTag | Gives the index of the tag to print.
 * 
 * @comm	Prints the innerlevel block tag specified by <p wTag>, as
 * determined from the global tag array.  The output tag printed is
 * affected by the current outerlevel block type, so that different
 * outerlevel blocks will generate different output tags for the same
 * input tag.
 * 
 * The tag text is followed by a tab character.  No output will occur if
 * the global fNoOutput flag is True.
 * 
 */
void OutputTag(NPSourceFile sf, WORD wBlock, WORD wTag)
{
  if (fNoOutput)
	  return;
  /* Output text, and if error occurs, exit() for now. HACK!  */
  putc(TAG, fpOutput);

  assert(wBlock < NUM_LEVELS);

  /*  Make sure there's a valid output tag to print  */
  assert(DocTags[wBlock][wTag] != NULL);

  if (fputs(DocTags[wBlock][wTag], fpOutput)) {
	  fprintf(stderr, errOut, sf->fileEntry->filename);
	  exit(4);
  }
  putc('\t', fpOutput);
}

/* 
 * @doc	EXTRACT
 * @api	void | OutputTagText | Print a tag to the output file, where
 * the tag is specified by an immediate string.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file buffer block.
 * @parm	PSTR | szTag | Specifies the tag to output.
 * 
 * @comm	Prints tag <p szTag> to the output file.  The tag text is
 * followed by a tab character.  <p szTag> should not include the tag
 * prefix character (ie the '@') sign, as this is printed automatically.
 * No output will occur if the global flag fNoOutput is set.
 * 
 */
void OutputTagText(NPSourceFile sf, PSTR szTag)
{
  if (fNoOutput)
	  return;
  /* Output text, and if error occurs, exit() for now. HACK!  */
  putc(TAG, fpOutput);

  if (fputs(szTag, fpOutput)) {
	  fprintf(stderr, errOut, sf->fileEntry->filename);
	  exit(4);
  }
  putc('\t', fpOutput);
}


/* 
 * @doc	EXTRACT
 * @api	void | OutputRegion | Print the text between the point and
 * the mark, inclusive.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file buffer block,
 * containing the output buffer, point, and mark.
 * @parm	char | chPost | Specifies character with which to output
 * after outputing the text region.  Usually a newline.  This character
 * is ignored if NULL.
 * 
 * @comm	Prints the region given by the pt and mark fields of <p sf>.
 * The text printed is inclusive from the point to the mark.  The
 * <p chPost> character is appended to the output if <p chPost> is
 * non-NULL (useful for printing newlines or tabs).
 * 
 * If a write error occurs, an error message is printed to stderr and
 * the program exited.
 * 
 * No output occurs if the global fNoOutput flag is TRUE.
 * 
 */
void OutputRegion(NPSourceFile sf, char chPost)
{
  char	c;
  
  if (fNoOutput)
	  return;
  
  /* Save char following mark, replace with NULL for printing */
  if (*sf->mark) {
	c = *(sf->mark + 1);
	*(sf->mark + 1) = '\0';
  }

  if (fputs(sf->pt, fpOutput)) {
TextOutputError:
	fprintf(stderr, errOut, sf->fileEntry->filename);
	exit(4);
  }
  
  /* Send newline if one was asked for */
  if (chPost)
	  if (EOF == putc(chPost, fpOutput))
		  goto TextOutputError;

  /* Restored NULLed over character */
  if (*sf->mark)
	*(sf->mark + 1) = c;

}


/* 
 * @doc	EXTRACT
 * @api	void | OutputText | Outputs an arbitrary text string to the
 * output file.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file buffer block.
 * @parm	PSTR | szText | Specifies the text string to print.
 * 
 * @comm	Prints <p szText> to the output file.  If a write error
 * occurs, an error message is printed and the program exited.  If the
 * global fNoOutput flag is set, no output occurs.  No newlines or other
 * formatting characters are appended to the output.
 * 
 */
void OutputText(NPSourceFile sf, PSTR szText)
{
  if (fNoOutput)
	  return;
  if (fputs(szText, fpOutput)) {
TextOutputError:
	fprintf(stderr, errOut, sf->fileEntry->filename);
	exit(4);
  }
}


/* 
 * @doc	EXTRACT
 * @api	void | CopyRegion | Copies the current region from point to
 * mark inclusive into a null terminated buffer.
 * @parm	NPSourceFile | sf | Specifies the source file buffer block.
 * @parm	PSTR | buf | Pointer to buffer into which region will be
 * placed.
 * @parm	WORD | wLen | Length in bytes of buffer <p buf>.
 * 
 * @comm	Copies the region from point to mark inclusive into the
 * <p buf>.  Up to <p wLen> - 1 characters will be copied, and <p buf> is
 * guaranteed to be NULL terminated.
 * 
 */
void CopyRegion(NPSourceFile sf, PSTR buf, WORD wLen)
{
  PSTR	p;
  PSTR	end;

  /* Fixup end to smaller of length of buffer, or region to copy */
  end = sf->pt + (int) min(wLen, ((int) (sf->mark - sf->pt)));
  
  for (p = sf->pt; *p && p < end; *buf++ = *p++);
  *buf = '\0';
}


/* 
 * @doc	EXTRACT
 * @api	BOOL | FindNextTag | Moves the point forward until it points
 * to the next tag in a comment block, and moves the mark to the end of
 * the tag word.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file buffer block.
 * 
 * @rdesc	Returns TRUE if a tag was found, or FALSE if no tag was found
 * in the comment block.
 * 
 * @comm	Starting from the current point, moves the point forward to
 * the next tag in the block.  The mark is moved to the end of the tag
 * that is found.  If no next tag exists in the buffer, FALSE is
 * returned and the mark and point are undefined.
 * 
 * Note that multiple calls to <f FindNextTag> without intervening calls
 * to move the point will cause the same tag to be repeatadly
 * found, as the search for tags begins at the point.
 * 
 */
BOOL FindNextTag(NPSourceFile sf)
{
  PSTR	p;

  /* move forward until finding next tag, put point there */
  p = sf->pt;
BogusNextTag:
  for (; *p && *p != TAG; p++);
  /* Make sure that this is a tag by testing for a \n before the TAG char */
  if (p > sf->lpbuf && *(p-1) != '\n') {
	  p++;
	  goto BogusNextTag;
  }

  if (!*p)
	return FALSE;		// end of comment block!

  p++;
  if (!(*p && !SPACE(*p))) {
	sf->mark = p;
	return FALSE;
  }
  
  /* save beginning of tag */
  sf->pt = p - 1;
  
  /* now move forward until finding next space, set mark there */
  for (; *p && !SPACE(*p); p++);
  sf->mark = p;
  
  return TRUE;
}


/* 
 * @doc	EXTRACT
 * @api	WORD | GetFirstBlock | Moves the point and mark to surround
 * the first block of text following a tag that has been located with
 * <f FindNextTag>.
 * 
 * @parm	NPSourceFile | sf | Identifies the source file buffer
 * block.
 * 
 * @rdesc	If the call succeeds, the point is set to the start of the
 * text block that immediately follows the tag.  The mark is set to the
 * end of this block, and either RET_ENDTAG or RET_ENDBLOCK is returned,
 * depending on if there are no more blocks in the tag or if there is a block
 * following respectively.
 * 
 * If the call fails, the point is set to the start of the next tag or
 * the end of the comment buffer if no more tags exist, and
 * RET_EMPTYBLOCK is returned.
 * 
 * In any case, if this function is followed by a call to
 * <f FindNextTag>, no problems will result.
 * 
 * @comm	This call expects the point to be pointing the beginning of
 * the tag upon entry (as setup by <f FindNextTag>).  Error conditions
 * should be checked upon exit from this function.
 * 
 */
WORD GetFirstBlock(NPSourceFile sf)
{
  PSTR	p;

  p = sf->pt;
  /*  Assumes that I'm on beginning of tag  */
  assert(*p == TAG);

  /* Move forward to first non-whitespace, to skip over tag */
  for (; *p && !SPACE(*p); p++);	// skip word
  for (; *p && SPACE(*p); p++);		// skip whitespace

  /* Set point to this location, the beginning of the text */
  sf->pt = p;

  return CommonGetBlock(sf, p);
}



/* 
 * @doc	EXTRACT
 * @api	WORD | GetNextBlock | Moves the point and mark to surround
 * the next block of text of a particular tag.
 * 
 * @parm	NPSourceFile | sf | Identifies the source file buffer
 * information.
 * 
 * @rdesc	If the call succeeds, the point is set to the start of the
 * text block that follows the initial mark.  The mark upon return is
 * set the end of the next text block.  Either RET_ENDTAG or
 * RET_ENDBLOCK is returned.
 * 
 * If the call fails due to a non existent block, or encountering the
 * end of the comment buffer, RET_ENDCOMMENT is returned and the point
 * is set to the start of the next tag or the end of the comment
 * buffer.  
 * 
 * @comm	This procedure, in combination with <f GetFirstBlock>, allows
 * the tag reader to step through the text fields associated with a tag.
 * Contiguous calls to <f GetNextBlock> are possible, which will
 * move the region forward to surround each field.  If the tag's text
 * fields end prematurely, RET_EMPTYBLOCK will be returned as an error
 * flag. 
 * 
 * Calls to <f GetNextBlock> may always be followed by a call to
 * <f FindNextTag>.
 * 
 */
WORD GetNextBlock(NPSourceFile sf)
{
  PSTR	p;
  WORD	ret;

  /* Entry:  mark is at end of previous block of text.  Move forward
   *	to find the start of the next block (the one we want).
   */

  p = sf->mark;
  /*  If I'm on a block char, then this is an empty block being exited,
   *  So we want to not skip whitespace
   */
  if (*p != BLOCK)
	  p++;

  /* Skip whitespace, till `|' char found */
  for (; *p && SPACE(*p); p++);

  /* This should be the start of next block.  If not, then puke */
  if (*p != BLOCK) {
	sf->pt = sf->mark = p;	// reset mark and point for FindNextTag.
	return RET_EMPTYBLOCK;
  }

  /* Don't bother with END_COMMENT conditions (ie NULL), as CommonGetBlock
   * will return RET_EMPTYBLOCK for this case.  The next FindNextTag()
   * will then fail, causing a general comment buffer failure to result!
   */
#if 0
  if (!*p) {
	sf->pt = p;
	return RET_ENDCOMMENT;
  }
#endif

  /* Skip more whitespace, to start of actual text, set point there */
  /* (if this under EOF, no pt advance is done */
  if (*p)	// skip the '|' char if there is one.
    p++;
  for (; *p && SPACE(*p); p++);
  sf->pt = p;	// point at beginning of text

  return CommonGetBlock(sf, p);
}



/* 
 * @doc	EXTRACT
 * @api	WORD | CommonGetBlock | Common block searcher routine for use
 * by <f GetFirstBlock> and <f GetNextBlock>.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * @parm	PSTR | p | Point to start searching for the beginning of a
 * text block from.
 * 
 * @rdesc	Returns RET_ENDBLOCK when there are text blocks following
 * this tag, RET_ENDTAG when no more text blocks follow for this tag, or
 * RET_EMPTYBLOCK when this block has no text.  Current region (point to
 * mark inclusive) is set to the selected block.
 * 
 * @comm	Performs magic.  This does the real work for <f GetNextBlock>
 * and <f GetFirstBlock>.
 * 
 */
static WORD CommonGetBlock(NPSourceFile sf, PSTR p)
{
  PSTR	porig;
  PSTR	psave;
  WORD	ret;
  
  /*  Entry:  Save the initial p, as this is assumed to be the
   *  start of the current block.
   */
  porig = p;

  /*  Scan forward until end of this block, either @ or | or EOF */
GetBlockScan:
  for (; *p && !(*p == TAG || *p == BLOCK); p++);
  /* Make sure there isn't an escaped char kicking off the scan */
  if (*p == BLOCK)
	if (p > sf->lpbuf && *(p-1) == '\\') {
		p++;
		goto GetBlockScan;
	}
  /*  Check the same thing for at characters  */
  if (*p == TAG)
	/* Tag must be on start of new line, so if not there, kick it out */
	if (p > sf->lpbuf && *(p-1) != '\n') {
		p++;
		goto GetBlockScan;
	}

  /*  Encountered another tag, or another block.  For both, backup to
   *  last non-white character, set mark there.  Return appropriate
   *  condition codes.
   */
  ret = RET_ENDTAG;	// the default return value.
  if (*p == BLOCK)
	  ret = RET_ENDBLOCK;	// if encountered another block following

  /*  Now back up whitespaces until last non-whitespace is found.
   *  If we end up backing up over the original setting of p on entry,
   *  then this is an empty block, and return error condition.
   */
  psave = p;	// hang onto this location, if EMPTYBLOCK occurs.
  for (p--; *p && SPACE(*p) && p >= porig; p--);
  if (p < porig) {		// emptyblock, so pt = end of prev block.
	sf->mark = sf->pt = psave;	// point to next tag
	return RET_EMPTYBLOCK;
  }
  else {		// normal backed up to end of block, set mark there.
	sf->mark = p;
	return ret;
  }
}


/* 
 * @doc	EXTRACT
 * @api	void | FixLineCounts | Updates the line counts of the current
 * point and mark for error reporting purposes.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * 
 * @parm	PSTR | pt | Point to return the line number of.  This must be
 * a valid point within the comment buffer of <p sf>.
 * 
 * @rdesc	Returns the line number of point <p pt> within the comment
 * buffer of <p sf>.  Newlines are counted to determine the line offset
 * within the buffer, and the resulting number of newlines added to the
 * initial line number of the first line of the comment buffer.  This
 * value is returned.  It is thus important for other tag reader
 * routines not to alter the original comment buffer, as the line number
 * returned from this routine would then be invalid.
 * 
 */
WORD FixLineCounts(NPSourceFile sf, PSTR pt)
{
  PSTR	c;
  WORD	w;
  
  /*  Update the line counts for the point and mark by counting
   *  newlines in the buffer
   */
  w = 0;
  for (c = sf->lpbuf; c <= pt; c++) {
	if (*c == '\n')
		w++;
	if (c == pt)
		return (sf->wLineBuf + w);
  }
  /* something bogus happened */
  return 0;
}


/* 
 * @doc	EXTRACT
 * @api	void | PrintError | Prints an error message in a standard
 * format, and sets the exit condition flag for the source file block.
 * 
 * @parm	NPSourceFile | sf | Specifies the source file buffer block.
 * @parm	PSTR | szMessage | Error message to print.
 * @parm	BOOL | fExit | Indicates whether this is a fatal exit.  If
 * TRUE, the program will exit when the current file has been completely
 * parsed.
 * 
 * @comm	Prints the source file filename and the line number of the
 * current point to standard error, followed by <p szMessage>.
 * 
 */
void PrintError(NPSourceFile sf, PSTR szMessage, BOOL fExit)
{
  WORD	w;
  
  w = FixLineCounts(sf, sf->pt);
  fprintf(stderr, errmsg, sf->fileEntry->filename, w, szMessage);
  if (fExit)
	  sf->fExitAfter = TRUE;
}

/* 
 * @doc	EXTRACT
 * @api	WORD | ProcessWordList | Process a whitespace or comma
 * separated list of words following a tag, formatting
 * them as a space separated list of words.
 * 
 * @parm	NPSourceFile | sf | Blah.
 * @parm	PSTR * | bufPt | Pointer to a buffer pointer, which should
 * initially contain a near buffer obtained with <f NearMalloc>, where
 * the formatted word list will be placed.  The buffer pointed to will
 * be automatically expanded as necessary.
 * 
 * @parm	BOOL | fCap | Specifies whether to convert to uppercase
 * the processed list of words.
 *
 * @rdesc	Returns either RET_ENDBLOCK or RET_ENDTAG, depending on
 * whether there are following blocks within the tag's text or not,
 * respectively.  (What a horrible sentence).  The point and mark will
 * be at the end of the text block upon return.  If there is no text
 * block following the tag, then RET_EMPTYBLOCK is returned, and the
 * point and mark point to the next tag in the comment block, or the
 * end of the comment block.
 * 
 */
#define SEPSPACE(c) ((c)==' ' || (c)=='\n' || (c)=='\t' ||(c)==','||(c)==';')

WORD ProcessWordList(NPSourceFile sf, PSTR *bufPt, BOOL fCap)
{
  WORD	ret;		// hold return code
  PSTR	pNew;		// runner on copy buffer
  PSTR	pOldMark;	// keep the old mark around
  PSTR	p;		// runner on comment block
  
  ret = RET_ENDTAG;

  /* Get the text of the first block, ie the doclevel specification */
  ret = GetFirstBlock(sf);
  if (ret == RET_EMPTYBLOCK)
	return ret;

  /* Warn if there's extra text blocks on DOC tag, ie ret == RET_ENDBLOCK */

  /* Grow the memory copy buffer if needed */
  if (NearSize(*bufPt) < (int) (sf->mark - sf->pt) + 5)
	*bufPt = NearRealloc(*bufPt, (WORD) (sf->mark - sf->pt) + 10);

  /* Save away copy buffer status */
  pNew = *bufPt;
  pOldMark = sf->mark + 1;	// save mark plus one

  p = sf->pt;
  while (1) {
	/* skip whitespace before doc level word */
	for (; p < pOldMark && SEPSPACE(*p); p++);

	if (p >= pOldMark) {
		dprintf("ProcessWordList:  Breaking loop after space skip\n");
		break;
	}

	/*  Save this location, beginning of word, and move to end of word */
	for (sf->pt = p; p < pOldMark && !SEPSPACE(*p); p++)
		if (fCap)
			*pNew++ = (char) toupper(*p);
		else
			*pNew++ = *p;

	/*  Put a space between the words, and then null terminate in
	 *  case this is the last word in a list
	 */
	*pNew++ = ' ';
	*pNew = '\0';

	/* Check if we're at end of buffer */
	if (p >= pOldMark) {
		dprintf("ProcessWordList:  Breaking loop after word copy.\n");
		break;	// get out of loop
	}
  }	// while loop

  /* Restore point and mark to the end of @doc text block */
  sf->pt = sf->mark = pOldMark - 1;
  
  return ret;
}



/* 
 * @doc	EXTRACT
 * @api	void | OutputFileHeader | Prints an output file header using
 * compiled in constants and system information.
 * 
 * @parm	FILE * | fpOut | File pointer to which to write header.
 * 
 * @comm	Currently, only the program name, version, and the current
 * time (in UNIX <f asctime>) format.  The file header is surrounded by
 * header begin and end tags.
 * 
 */
#include <time.h>
#include "version.h"

void OutputFileHeader(FILE *fpOut)
{
  time_t	curtime;
  
  fprintf(fpOut, "@%s\t\n", T2TEXT_BEGINHEADER);
  fprintf(fpOut, "@%s\t%s\n", T2TEXT_EXTRACTID, VERSIONNAME);
  fprintf(fpOut, "@%s\t%d.%d.%d\n", T2TEXT_EXTRACTVER, rmj, rmm, rup);
  time(&curtime);
  fprintf(fpOut, "@%s\t%s", T2TEXT_EXTRACTDATE, asctime(localtime(&curtime)));
  fprintf(fpOut, "@%s\t\n", T2TEXT_ENDHEADER);
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\misc.c ===
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include "extract.h"


/*
 * ERROR MESSAGES
 */
char errFarMemory[]  = "Error: Out of far memory. Current used: %lud bytes\n";
char errNearMemory[] = "Error: Out of near memory.  Current used: %u bytes\n";
char errRealloc[]    = "\t(Attempting to realloc %u bytes to %u bytes)\n";


/*
 *  Keeps count of how much memory has been used by system.
 */
WORD	wNearMemoryUsed = 0;
DWORD	dwFarMemoryUsed = 0L;

#if 0

LPSTR FarMalloc(int size, BOOL fZero)
{
  LPSTR		fp;

  fp = _fmalloc(size);
  if (fp == 0L) {
	  fprintf(stderr, errFarMemory, dwFarMemoryUsed);
	  exit(2);
  }
  dwFarMemoryUsed += (DWORD) size;

  if (fZero)
	  lmemzero(fp, size);

  return fp;
}


void	FarFree(LPSTR lpblock)
{
  WORD size;

  size = _fmsize(lpblock);
  dwFarMemoryUsed -= (DWORD) size;
  _ffree(lpblock);
}

#endif


#ifdef HEAPDEBUG

void NearHeapCheck()
{
  char	foo[5];

  switch (_nheapchk()) {
    case _HEAPOK:
	return;
    case _HEAPEMPTY:
	fprintf(stderr, "Non-Initted heap\n");
	return;
	
    case _HEAPBADBEGIN:
	fprintf(stderr, "NearHeapCheck:  BAD BEGIN!\n");
	break;
	
    case _HEAPBADNODE:
	fprintf(stderr, "NearHeapCheck:  BAD NODE!\n");
	break;
  }
  fprintf(stderr, "BOGUS HEAP DETECTED!!!!, BREAK HERE!\n");
  gets(foo);

}

#endif


/*
 * @doc	EXTRACT
 * @api	PSTR | NearMalloc | Allocate a near memory buffer.
 * @parm	WORD | size | Specifies the size in bytes of the block to be
 * allocated.
 * @parm	BOOL | fZero | Specifies whether to zero initialize the
 * allocated buffer.
 *
 * @rdesc	Returns a near pointer to the new buffer.
 *
 * @comm	If the requested amount of memory can not be allocated, an
 * error message is displayed on stderr, and the program exited.  If
 * memory allocation is successful, the count of near memory currently
 * allocated is updated to reflect the new block.
 *
 */
PSTR	NearMalloc(WORD size, BOOL fZero)
{
  PSTR	pstr;

#ifdef HEAPDEBUG
  NearHeapCheck();
#endif

  pstr = _nmalloc(size);
  if (!pstr) {
	  fprintf(stderr, errNearMemory, wNearMemoryUsed);
	  exit(2);
  }

  wNearMemoryUsed += size;
  if (fZero)
	  memset(pstr, '\0', size);
  return pstr;
}


/*
 * @doc	EXTRACT
 * @api	PSTR | NearRealloc | Change the size of a dynamically
 * allocated near memory block.
 *
 * @parm	PSTR | pblock | Specifies the old memory block that is to be
 * resized.
 * @parm	WORD | newsize | Specifies the requested new size in bytes of
 * the reallocated block.
 *
 * @rdesc	Returns a pointer to the new memory block, with size as
 * specified by <p newsize>.  The block contents will be indentical to
 * the contents of <p pblock> up to the smaller of the old size and new
 * size.  This pointer may be different from <p pblock>.
 *
 * @comm	If the requested amount of memory cannot be allocated, an
 * error message is displayed on stderr and the program exited.  If
 * memory allocation is successful, the count of near memory currently
 * allocated is updated to reflect the new size of <p pblock>.
 *
 */
PSTR	NearRealloc(PSTR pblock, WORD newsize)
{
  WORD	oldsize;
  PSTR	pnew;

#ifdef HEAPDEBUG
  NearHeapCheck();
#endif

  oldsize = _nmsize(pblock);

  // dprintf("(Attempting to realloc %u bytes to %u bytes)\n", oldsize, newsize);

  pnew = realloc(pblock, newsize);
  if (!pnew) {
	  fprintf(stderr, errNearMemory, wNearMemoryUsed);
	  fprintf(stderr, errRealloc, oldsize, newsize);
	  exit(2);
  }
  wNearMemoryUsed += (newsize - oldsize);

#ifdef HEAPDEBUG
  NearHeapCheck();
#endif

  return pnew;
}

/*
 * @doc	EXTRACT
 * @api	void | NearFree | Frees a block of dynamically allocated near
 * memory.
 * @parm	PSTR | pblock | Specifies the block to be freed.
 *
 * @comm	The pointer <p pblock> should not be referenced again after
 * calling this function, as the memory may be re-used by subsequent
 * calls to <f NearMalloc>, <f NearRealloc>, or <f StringAlloc>.
 *
 * The count of near memory currently allocated is updated to reflect
 * the freed block.
 *
 */
void	NearFree(PSTR pblock)
{
  WORD size;

#ifdef HEAPDEBUG
  NearHeapCheck();
#endif

  size = (WORD) _nmsize(pblock);
  wNearMemoryUsed -= size;
  _nfree(pblock);

#ifdef HEAPDEBUG
  NearHeapCheck();
#endif

}


/*
 * @doc	EXTRACT
 * @api	WORD | NearSize | Returns the size in bytes of a near block
 * allocated using <f NearMalloc> or <f StringAlloc>.
 *
 * @parm	PSTR | pblock | Specifies the block to return the size of.
 *
 * @rdesc	Returns the size in bytes of <p pblock>.
 *
 * @xref	NearMalloc, StringAlloc, NearFree
 *
 */
WORD	NearSize(PSTR pblock)
{
#ifdef HEAPDEBUG
  NearHeapCheck();
#endif

  return (WORD) _nmsize(pblock);
}


/*
 * @doc	EXTRACT
 * @api	PSTR | StringAlloc | Allocates near memory and copies a
 * string into it.
 *
 * @parm	PSTR | string | Specifies the null-terminated string to
 * preserve.
 *
 * @rdesc	Returns a near pointer to an allocated memory block
 * containing a copy of string <p string>.
 *
 * @comm	This function uses <f NearMalloc> to allocate the memory
 * buffer that is returned.  This buffer must be freed with <f NearFree>
 * when it is no longer needed.
 *
 */
PSTR	StringAlloc(PSTR string)
{
  PSTR	pstr;
  WORD	size;

#ifdef HEAPDEBUG
  NearHeapCheck();
#endif

  size = (WORD) strlen(string) + 1;
  pstr = _nmalloc(size);
  if (!pstr) {
	  fprintf(stderr, errNearMemory, wNearMemoryUsed);
	  exit(2);
  }
  wNearMemoryUsed += size;

  strcpy(pstr, string);

#ifdef HEAPDEBUG
  NearHeapCheck();
#endif

  return pstr;
}


#ifdef DEBUG

static	FILE *fpCOM1 = stdaux;
static	BOOL	fFixed = False;

#include <fcntl.h>
#include <io.h>
#include <stdarg.h>

void cdecl COMprintf(PSTR format, ...)
{
  va_list arglist;

  if (!fFixed) {
    setmode(fileno(fpCOM1), O_TEXT);
  }

  va_start (arglist, format);
  vfprintf(fpCOM1, format, arglist);
  va_end (arglist);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\parsearg.c ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "extract.h"

/*
 *  Global file list holder
 */
FileEntry	*FilesToProcess = NULL;

/*
 *  File local procedures
 */
void		AddFileToProcess(PSTR pch, int type);
FileEntry	*AllocNewFile(FileEntry **start_file);
PSTR		FindExt(PSTR szPath);

char errMissingFile[]	= "Error: No file specified for '-%c' option.\n";
char errIllegalOption[]	= "Error: Illegal option flag '-%c'\n";

/* 
 * @doc	EXTRACT
 * @api	void | ParseArgs | Parse the command line arguments and build
 * the linked list of files to process.
 * 
 * @parm	int | argc | Number of elements of array <p argv>.
 * @parm	char ** | argv | Array of strings each giving one word of the
 * command line arguments.
 * 
 * @comm	Processes the command line, and builds a linked list of
 * FileEntry structures specifying the source files to process.  This
 * list is headed by the global variable FilesToProcess.  If no source files
 * were specified on the command line, FilesToProcess will be NULL.
 * 
 * Each element of FilesToProcess will contain the name of the source
 * file to be processed (buffer allocated using <f StringAlloc>) and the
 * source file as can be determined from the file extension or the
 * current file type as specified using command line options.  This type
 * is set into the FileEntry structure for the file.
 * 
 * The global variables fNoOutput and szOutputFile will be set according
 * to the output options specified.  If no output is desired, fNoOutput
 * will be true.  If stdout is to be used for output, szOutputFile will
 * be NULL.  If a file is to be used for output, szOutputFile will
 * contain a string filename (allocated using <f StringAlloc>).
 * 
 * Illegal options will cause the parameter usage display to be printed
 * and the program exited.
 * 
 */
void ParseArgs(argc,argv)
int argc;
char **argv;
{
    int		i,j;
    FileEntry	*cur_file;
    PSTR	sz;
    /*  The file type for this set of files.  Defaults to SRC_UNKNOWN  */
    int		wCurFileType = SRC_UNKNOWN;	
    int		wType;
    
    
    cur_file=NULL;

    i = 1;
    while( i < argc ) {
	/*  Decide what to do with this command line argument
	 */
	switch (*argv[i]) {
	    /*
	     *  It is a flag
	     */
#ifdef MSDOS
	    case '/' :
#endif
	    case '-' :
	      ++argv[i];
	      switch( *argv[i] ) {

		/*  Setup the no output switch, only check syntax  */
		case 'n':
		case 'N':
		    fNoOutput = True;
		    break;
		
		/*  Output file option  */
		case 'o':
		case 'O':
		    ++argv[i];
		    if(*argv[i]==':')
			    ++argv[i];

		    if(strlen(argv[i])==0) /* we have /l<space><file> */
			    i++;

		    if (*argv[i])
			    szOutputFile = StringAlloc(argv[i]);
		    else {
			    fprintf(stderr, errMissingFile, 'o');
			    Usage(argv[0]);
		    }
		    break;
		 
		/*  Treat following files a MASM source code  */
		case 'A':
		case 'a':
		    wCurFileType = SRC_MASM;
		    break;
		    
		/*  Treat following files as C source code  */
		case 'c':
		case 'C':
		    wCurFileType = SRC_C;
		    
		/*  Treat following files as unknown source code  */
		case 'd':
		case 'D':
		    wCurFileType = SRC_UNKNOWN;
		    break;
	
		default:
		    fprintf(stderr, errIllegalOption, *argv[i]);
		    /*  FALL THROUGH  */
			    
		case '?':
		case 'H':
		case 'h':
		    Usage(argv[0]);
		    exit(1);

		}	/* switch for case of '-' or '/' */
		break;
		
	    /*
	     *  This isn't a flag, see type of filename
	     */
	    default:
		/* let's look to see what kind of file it is */
		wType = wCurFileType;
		sz = FindExt(argv[i]);
		if (sz)	{	// has an extension, figure it out
		  if (!strcmpi(sz, "C"))
			  wType = SRC_C;
		  else if (!strcmpi(sz, "ASM"))
			  wType = SRC_MASM;
		}
		
		/*  Add this file as chosen file type  */
		AddFileToProcess(argv[i], wType);
		break;

	} /* switch */
	i++;
    } /*while */

}


/*
 *	@doc EXTRACT
 *
 *	@func void | Usage | Prints usage information to 'stderr'.
 */

void Usage(PSTR progName)
{
  fprintf(stderr, "usage: %s [-o outputFile] [-n] [files]\n\n", progName);
  fprintf(stderr, "[-a] \t\t\tMASM source file.\n");
  fprintf(stderr, "[-n] \t\t\tNo output, error check only.\n");
  fprintf(stderr, "[-o outputFile] \tPlaces output in file outputFile,\n");
  fprintf(stderr, "\t\t\tOr uses standard output if not specified.\n");
  fprintf(stderr, "[files] \t\tList of files to be processed.");
  fprintf(stderr, "If none specified,\n\t\t\tuses standard input.\n"); 
  fprintf(stderr, "\nexample: %s file.c >file.doc\n", progName);
}


/* 
 * @doc	EXTRACT
 * @api	void | AddFileToProcess | Adds filename <p pch> to the list of
 * files to be processed.
 * 
 * @parm	PSTR | pch | Identifies the filename to be processed.
 * 
 * @parm	int | type | Source code type of file.
 * 
 * @comm	Adds <p pch> to the linked list of files to be processed that
 * is pointed to by global FilesToProcess.  This function is used by the
 * argument processing module, and should not be called by other
 * sections of the program.
 * 
 */
void AddFileToProcess(PSTR pch, int type)
{
    FileEntry *cur_file;

#ifdef FILEDEBUG    
    dprintf("Adding input file to list:  %s", pch);
    dprintf("  Type: ");
    switch (type) {
	case SRC_C:
		dprintf("C");
		break;
	case SRC_MASM:
		dprintf("MASM");
		break;
	case SRC_UNKNOWN:
	default:
		dprintf("UNKNOWN");
		break;
    }
    dprintf("\n");
#endif
			 
    cur_file = AllocNewFile(&FilesToProcess);
    cur_file->filename = StringAlloc(pch);
    cur_file->type = type;
}


/* 
 * @doc	EXTRACT
 * @api	FileEntry * | AllocNewFile | Allocates a new file entry
 * structure, and appends this structure a the linked list of filenames
 * to process.
 * 
 * @parm	FileEntry ** | start_file | The address of the pointer to the
 * head of the linked list.  If NULL, this pointer will be set to the
 * newly allocated FileEntry structure.
 * 
 * @rdesc	Returns a pointer to the newly allocated FileEntry structure.
 * This structure will have been placed into the linked list pointed to
 * by <p *start_file>.
 * 
 * @comm	This function used by <f ParseArgs> and should not be called
 * by other portions of the program.
 * 
 */
FileEntry *AllocNewFile(FileEntry **start_file)
{
    FileEntry * cur_file;
    FileEntry * tmp_file;

    cur_file=(FileEntry *) NearMalloc(sizeof(FileEntry), True);

    if(!*start_file) {
        *start_file=cur_file;
    }
    else {
	tmp_file = *start_file;
	while(tmp_file->next)
	    tmp_file = tmp_file->next;

	tmp_file->next = cur_file;
    }
    return(cur_file);

}

/* 
 * @doc	EXTRACT
 * @api	PSTR | FileExt | Returns a pointer to the head of the file
 * extension of pathname <p szPath>.
 * 
 * @parm	PSTR | szPath | Path string.
 * 
 * @rdesc	Returns pointer to head of file extension within <p szPath>,
 * or NULL if no extension exists on szPath.
 * 
 */
#define SLASH(c) ((c) == '\\' || (c) == '/')

PSTR FindExt(PSTR szPath)
{
    PSTR   sz;

    for (sz=szPath; *sz && *sz!=' '; sz++)
        ;
    for (; sz>=szPath && !SLASH(*sz) && *sz!='.'; sz--)
        ;
    return *sz=='.' ? ++sz : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\version.h ===
#define rmj		2
#define rmm		1
#define rup		7
#define szVerName	""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\test\asmcb.asm ===
;****************************************************************************
; @doc  EXTERNAL TEST
; @asm  asmFuncWithCallback | This is an imaginary assembler function
;   to test AUTODOC.  It has an associated callback function.
; @reg  AL | Specifies an 8-bit parameter value.
;
;    This is the second paragraph of a register description.
; @reg  BX | Specifies a 16-bit parameter value.
; @reg  CL | Specifies an 8-bit parameter value using one of the
; following flags:
;   @flag  RED | A flag value.
;   @flag  WHITE | Another flag value.
; @reg  EDX | Specifies a 32-bit pointer to a callback function.
; @rdesc  The following registers contain meaningful return values:
; @reg	CX | This register should come out before the conditionals are
; printed.
;   @flag	FOOBAR | Random flag before the conditionals.
; @cond If AL is zero, the callback was succcessfully installed, and the
;  following registers contain:
;
;   This is the second paragraph of a conditional.
;
;   @reg BX | Specifies a 16-bit return value.
;   @reg DS:SI | Points to the ASCIIZ name of the callback.
; 
; @cond Otherwise, an error is specified as follows:
;   @reg  AL | Contains one of the following error codes:
;     @flag  ERROR1 | An error.
;     @flag  ERROR2 | Another error.
; @uses	EFLAGS
; @comm	  Here are some comments pertaining to this function.  <F>This 
;     sentence should be bold.<D>  <P>This sentence should be italicized.<D>
;
;     This is the second paragraph of comments.  The callback function is
; specified as follows:
; @asmcb asmCallback | The name <F>asmCallback<D> is a placeholder for
;   the application-supplied callback function.
; @reg  AL | Specifies an 8-bit parameter value.
; @reg  BX | Specifies a 16-bit parameter value.
; @reg  CL | Specifies an 8-bit parameter value using one of the
; following flags:
;   @flag  RED | A flag value.
;   @flag  WHITE | Another flag value.
; @rdesc  The following registers contain meaningful return values:
;   @reg  AL | If zero, the callback was successfully installed.
; Otherwise, an error is specified by one of the following flags:
;   @flag  ERROR1 | An error.
;     @flag	ERROR2 | Another error.
;  @cond This is an empty conditional to test the code.
;  @cond Otherwise, the following registers are returned:
;   @reg  BX | Specifies a 16-bit return value.
; @uses EFLAGS
; @comm	Here are some comments pertaining to the callback function.
; @xref	asmFunc
;*****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\test\apiasmcb.c ===
/****************************************************************************
* @doc  EXTERNAL TEST
* @api  void | cFuncWithAsmCallback | This is an imaginary C function
*   to test AUTODOC.  It has an associated callback function that uses 
*   registers for parameter passing.
* @parm BYTE | bParam | Specifies an 8-bit parameter value.
* @parm WORD | wParam | Specifies a 16-bit parameter value.
* @parm  BYTE | bParamFlag | Specifies an 8-bit parameter value using 
*  one of the following flags:
*   @flag  RED | A flag value.
*   @flag  WHITE | Another flag value.
* @parm  FARPROC | lpCallback | Specifies a 32-bit pointer to a callback 
*  function.
* @rdesc  This is the normal return description text.
*
*  This is a second paragraph of text.  The return value is described
*     by one of the following flags:
*   @flag FLAG | This is a flag.
*   @flag FLAG2 | This is also a flag.
* @comm	  Here are some comments pertaining to this function.  <F>This 
*     sentence should be bold.<D>  <P>This sentence should be italicized.<D>  
*     The callback function is specified as follows:
* @asmcb asmCallback | The name <F>asmCallback<D> is a placeholder for
*   the application-supplied callback function.
* @reg  AL | Specifies an 8-bit parameter value.
* @reg  BX | Specifies a 16-bit parameter value.
* @reg  CL | Specifies an 8-bit parameter value using one of the
* following flags:
*   @flag  RED | A flag value.
*   @flag  WHITE | Another flag value.
* @rdesc  This is the normal return description text.
*   @reg BX | The contents of this return register is not dependent
*     on the state of any flags.
*     @flag FLAG | This register can have flags.
*   @cond If CY clear:
*     @reg AX | Specifies a return value according to the following
*     flags:
*       @flag FLAG | This register can have flags.
*   @cond If CY set:
*     @reg AX | Specifies an error value according to the following
*     flags:
*       @flag ERROR | Specifies an error value.
*       @flag ANOTHERERROR | Specifies another error value.
* @uses EFLAGS
* @comm	Here are some comments pertaining to the callback function.
* @xref	asmFunc
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\tags.h ===
/* 
 * TAG DEFINTIONS
 * 
 * This file contains symbolic contants defining the tags used in
 * MS-Tags tagged source code files, and the output from the extract
 * program.
 * 
 * The input tags are Level 1, ie those that are actually in the
 * source files.  Extract reads in these tags, and outputs Level2 tags
 * for the format program, which converts the more detailed level 2 tags
 * into an output format, ie Ventura publisher or RTF (WinHelp and Word
 * format).
 * 
 * This file is the common reference for tags.  When adding tags put
 * them here, not in private headers.
 * 
 */

/* Tag special character */
#define	TAG	'@'
/* Block separator */
#define BLOCK	'|'

/*
 *  LEVEL 1 Tags:  From source files
 */
#define T1_DOCLEVEL			"DOC"
#define T1_API				"API"
#define T1_FUNCTION			"FUNC"
#define T1_PARAMETER			"PARM"
#define T1_FLAG				"FLAG"
#define T1_RTNDESC			"RDESC"
#define T1_COMMENT			"COMM"
#define T1_CALLBACK			"CB"
#define T1_ASMCALLBACK			"ASMCB"
#define T1_XREF				"XREF"
#define T1_PRINTCOMM			"PRINT"
#define	T1_MESSAGE			"MSG"
#define T1_REGISTER			"REG"
#define T1_ASSEMBLE			"ASM"
#define T1_INTERRUPT			"INT"
#define T1_USES				"USES"
#define T1_CONDITIONAL			"COND"

#define T1_TYPESTRUCT			"TYPES"
#define T1_TYPEUNION			"TYPEU"
#define T1_END				"END"
#define T1_STRUCT			"STRUCT"
#define T1_UNION			"UNION"
#define T1_OTHERTYPE			"OTHERTYPE"
#define T1_FIELD			"FIELD"
#define T1_TAGNAME			"TAGNAME"


/* 
 * LEVEL TAG DECLARATIONS
 * 
 * These are tags that are common to the various levels, but change
 * according to what level you're in, ie function/api vs callback
 * generates different tags for flags, parameters, etc.
 * 
 * There are also non-level tag declarations, and there's no consistent
 * division unfortunately.  Sigh.
 * 
 */

/* Define levels here */
#define NUM_LEVELS	7	// the number of possible levels
#define LEVEL_API	0
#define	LEVEL_CALLBACK	1
#define LEVEL_MSG	2
#define LEVEL_ASSEMBLE	3
#define LEVEL_ASMCALLBACK	4
#define LEVEL_STRUCT	5
#define LEVEL_UNION	6

// #define LEVEL_INTERRUPT	5

/* 
 * THE INDIVIDUAL TAG NAMES
 * 
 * Each element of the array of PSTR[] contains all tags for a
 * particular type of outerlevel block.
 * 
 * The printer routine should therefore read the type of outerlevel
 * block we're currently in, and use that to index into this array of
 * array of strings to get the correct output tag.
 * 
 */
#define	NUM_TAGS	39	// number of tags possible

/* The name of this outerlevel type */
#define	T2_NAME		0	// name of the level being done

/* The outerlevel block leader tag (ie @api, @cb, @msg) fields */
#define T2_LEVELNAME	1	// "name" field of this level
#define T2_LEVELTYPE	2	// "type" field of this level (may be NULL)
#define T2_LEVELDESC	3	// "desc" field of this level

/* Parameters and parameter flags (NULL for INT's)  */
#define T2_PARMNAME	4	// parm "name" field
#define T2_PARMTYPE	5	// parm "type" field
#define T2_PARMDESC	6	// parm "desc" field
#define T2_FLAGNAMEPARM	7	// flag (for parm) "name" field
#define T2_FLAGDESCPARM	8	// flag (for parm) "desc" field

/*  Register declarations and register flags (NULL for API's and CB's)  */
#define T2_REGNAME	9	// register "name" field
#define T2_REGDESC	10	// register "desc" field
#define T2_FLAGNAMEREG	11	// flag (for register) "name" field
#define T2_FLAGDESCREG	12	// flag (for register) "desc" field

/* Return fields and return flags and register return flags */
#define T2_RETURN	13	// return tag
#define T2_FLAGNAMERTN	14	// flag (for return) "name" field
#define T2_FLAGDESCRTN	15	// flag (for return) "desc" field

#define T2_REGNAMERTN	16	// register (for return) "name" field
#define T2_REGDESCRTN	17	// register (for return) "desc" field
#define T2_FLAGNAMEREGRTN 18	// flag (for register return) "name" field
#define T2_FLAGDESCREGRTN 19	// flag (for register return) "desc" field

/*
 *  In ASSEMBLE Flags for return type are illegal, but legal
 *  when under a register declaration.  Use the FLAGNAMERTN and FLAGDESCRTN
 *  output numbers to handle this case.
 */

#define T2_COMMENT	20	// comment tag

#define T2_XREF		21	// xref tag

#define T2_USES		22	// register uses tag
#define T2_CONDITIONAL	23

/*  STRUCTURE AND UNION TAGS  */

#define T2_FIELDTYPE	24	// field type
#define T2_FIELDNAME	25	// field name
#define T2_FIELDDESC	26	// field description
#define T2_FLAGNAMEFIELD 27	// flag (for field) name
#define T2_FLAGDESCFIELD 28	// flag (for field) desc
#define T2_UNIONNAME	29	// union name
#define T2_UNIONDESC	30	// union descrip (optional)
#define T2_STRUCTNAME	31	// struct name
#define T2_STRUCTDESC	32	// struct descrip (optional)
#define T2_OTHERTTYPE	33	// othertype type
#define T2_OTHERTNAME	34	// othertype name
#define T2_OTHERTDESC	35	// othertype descrip (optional)
#define T2_STRUCTEND	36	// end of structure block
#define T2_UNIONEND	37	// end of union block
#define T2_TAGNAME	38	// tagname tag


/*  Unchanging level 2 tags - block headers  */
#define T2TEXT_ENDBLOCK		"ENDBLOCK"
#define T2TEXT_SOURCELINE	"SRCLINE"
#define T2TEXT_BEGINBLOCK	"BEGINBLOCK"
#define T2TEXT_DOCLEVEL		"DOCLEVEL"
#define T2TEXT_ENDCALLBACK	"ENDCALLBACK"

#define	T2TEXT_BEGINHEADER	"BEGINHEAD"
#define T2TEXT_ENDHEADER	"ENDHEAD"
#define T2TEXT_EXTRACTID	"EXTRACTID"
#define T2TEXT_EXTRACTVER	"EXTRACTVER"
#define T2TEXT_EXTRACTDATE	"EXTRACTDATE"
#define T2TEXT_PROJNAME		"PROJNAME"
#define T2TEXT_PROJROOT		"PROJROOT"

#ifndef _NO_TAG_ARRAY_

/*
 *  Global array to hold entries of tag names per outerlevel type
 */
extern PSTR	DocTags[NUM_LEVELS][NUM_TAGS];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\test.c ===
/* 
 * @doc	EXTERNAL,INTERNAL	test		; foobar
 * 
 * @print	NORMAL API DECLARATION:
 * @print	-----------------------
 * 
 * @api	int | testNormalApiBlock | This function is to test a
 * standard API defintion.  Only tests standard type stuff: parameters,
 * comments, return flags, xrefs, the doc tag.
 * 
 * @parm	int | FirstParm | This parameter has no flags, but it does
 * have two paragraphs.
 * 
 * This is the second paragraph for the first parameter in this function.
 * @parm	int | SecondParm | This parameter may take the following
 * flags:
 * @flag	F1_FIRST_FLAG | Specifies door number one.  This flag should
 * have lots of paragraphs within its description.
 * 
 * This is the second paragraph for flag number one.
 * 
 * @flag F1_SECOND_FLAG | The second flag for parameter two.
 * @flag F1_THIRD_FLAG | This is the third valid flag value for
 * parameter two.
 * 
 * @parm	int | ThirdParm | Contains one of the following flag values:
 * @flag F2_FOOBAR | This flag currently ignored.
 * 
 * @print	Testing comments within text...
 * @flag F2_BARFOO | // If this line appears, then comments are broken.
 * The second flag.  This line must appear, else embedded
 * comments are broken.
 * 
 * @comm	This is the comment text block's first paragraph.  It is not
 * too long.
 * 
 * The second paragraph begins with this sentence.  This is a test of
 * the emergency broadcast system.  In the event of an actual emergency,
 * the attention signal you just heard would have been followed by
 * information from the authorities.
 * 
 * @rdesc	This is the return description.  It has three flags.  The
 * paragraph of the return description can be as long as required, and
 * may include multiple paragraphs.
 * 
 * This is the second paragraph for the return description.
 * 
 * @flag	RFLAG_ONE | Return flag number one.
 * @flag	RFLAG_TWO | Return flag number two.
 * @flag	RFLAG_THREE|Return flag three.
 * 
 * @xref	testAsmBlock,testWarpedProcedure	 testNormalApiBlock
 * 
 * @print	Doing callback for api block..
 * @print	------------------------------
 * 
 * @cb	void | testCallbackOne | The normal API block's test
 * callback. 
 * 
 * @parm	int | FirstParm | This parameter has no flags.
 * @parm	int | SecondParm | This parameter may take the following
 * flags:
 * @flag	F1_FIRST_FLAG | Specifies door number one.  This flag should
 * have lots of paragraphs within its description.
 * 
 * This is the second paragraph for flag number one.
 * 
 * @flag F1_SECOND_FLAG | The second flag for parameter two.
 * @flag F1_THIRD_FLAG | This is the third valid flag value for
 * parameter two.
 * 
 * @parm	int | ThirdParm | Contains one of the following flag values:
 * @flag F2_FOOBAR | This flag currently ignored.
 * 
 * @print	Testing comments within text...
 * @flag F2_BARFOO | // If this line appears, then comments are broken.
 * The second flag.  This line must appear, else embedded
 * comments are broken.
 * 
 * @comm	This is the comment text block's first paragraph.  It is not
 * too long.
 * 
 * The second paragraph begins with this sentence.  This is a test of
 * the emergency broadcast system.  In the event of an actual emergency,
 * the attention signal you just heard would have been followed by
 * information from the authorities.
 * 
 * @rdesc	This is the return description.  It has three flags.  The
 * paragraph of the return description can be as long as required, and
 * may include multiple paragraphs.
 * 
 * This is the second paragraph for the return description.
 * 
 * @flag	RFLAG_ONE | Return flag number one.
 * @flag	RFLAG_TWO | Return flag number two.
 * @flag	RFLAG_THREE|Return flag three.
 * 
 * @print	Doing second callback (just for fun.)
 * 
 * @cb	void | testAPISecondCallback | This is the second callback
 * for test function number one.
 * 
 * @parm	int | cbParmOne | Callback parameter number one.  Specifies
 * the foobar value.
 * 
 * @rdesc	Returns one of the following flags:
 * @flag	HELLO_THERE_FLAG|Used to make the entire windows system into
 * a gigantic "Hello World" program.  One might view Windows that way
 * anyway! 
 * 
 * @comm	Comment for callback number two.
 * 
 */


int foobar1() {
	
	printf("Hello there!\n");
}


/* 
 * @doc	EXTERNAL TEST
 * 
 * @func	WORD |
 * testWarpedProcedure
 * | Tests the parser with twisted expressions.  This is a @func, as well.
 * @parm	HWND |
 * hwnd |
 * Identifies the window.  Has two flags!
 * @flag	FLAG_ONE|Flag number one.  Crunched fields.
 * @flag	FLAG_TWO
 * |
 * This is Flag two's text description.  Expanded fields.
 * @rdesc	Returns the desired window word.
 * @flag	RETURN_FLAG | Return flag for normal api call.
 * @comm	Window word space must be initialized before use when the
 * class is declared.
 * 
 * @cb	int FAR PASCAL |
 * ResInit |
 * Callback giving the entry point into the DLL.
 * 
 * @parm	WORD | wParam | Word parameter.
 * @flag	FOOFLAG | Callback wParam flag value.
 * @flag	FOOFLAG2 | Callback second paramter flag.
 * 
 * @rdesc	Callback return description.
 * 
 * @flag	THISFLAG | Callback return flag desc.
 * 
 * @comm	Callback comment
 * 
 * @api	LPSTR | testSecondFuncInBlock | Second API call within the
 * same comment block declarations.  Verify the @doc tag for this comment!
 * @rdesc	This function does nothing but return "Hello there".
 * @comm	Second api's comment.
 * 
 */


int foobar2() {
	
	printf("Hello there again!\n");

}


/* 
 * @doc	EXTERNAL TEST
 * 
 * @print	Testing ASM callback within normal API block.
 * 
 * @api	void | testAsmCallbackInApi | This function tests an ASM
 * callback within a normal API block.
 * 
 * @parm	int | iParamOne | Parameter one.
 * 
 * @flag	PARM_ONE_FLAG_ONE | First flag, parameter one.
 * 
 * @parm	long | lParamTwo | Parameter two.
 * 
 * @rdesc	API return description.
 * 
 * @flag	RTN_FLAG_ONE | First returned flag.
 * 
 * @xref	hello_there
 *
 * @asmcb	AsmCallback | This is an assembler block callback within an
 * API description.
 * 
 * @reg	AX | First register.
 * 
 * @flag	AX_FLAG_ONE | Does this correctly allow flags?
 * 
 * @reg	BX | First register.
 * 
 * @uses	AX, BX, CX
 * 
 * @rdesc	Return codes from this function are as follows:
 * 
 * @reg	FLAGS | The following:
 * 
 * @flag	CARRY | If set, then foo is TRUE.
 * 
 * @reg	AX | Contains the AX return value.
 * 
 * @reg	BX | Contains the BX return value.
 * 
 * @parm	LPSTR | lpszFoobar | This should end up in the API parameter
 * list?
 * 
 */



/* 
 * @doc EXTERNAL TEST
 * 
 * @print	Testing ASM block...
 * 
 * @asm testAsmBlock | Fiddle a global selector
 * into something more palatable.  
 * 
 * @print	Doing first register declaration...
 * @reg	DX:AX | Contains the selector to be fiddled.
 * 
 * @reg	BX | Contains one of the following flags.  This has three flags:
 * @flag	FLAG1 | First flag in BX.
 * @flag	FLAG2 | Second flag in BX.
 * @flag	FLAG3 | Third flag in BX.
 * 
 * @reg	CX | Last register used by <f testAsmBlock>.  One flag value.
 * @flag	CX_FLAG_1 | The only possible value for CX.
 * 
 * @comm	This is the comment text.
 * 
 * @print	Doing return value, with flags...
 * 
 * @xref	testNormalApiBlock
 * 
 * @rdesc	The function success codes are returned.
 * @reg	AX | Contains one of the following flags (four):
 * @flag	RETFLAG_1 | What is behind door number one?
 * @flag	RETFLAG_2 | Or is it door number two?
 * @flag	RETFLAG_3 | Or perhaps door three?
 * @flag	RETFLAG_4 | The suspense is really getting to me.
 * 
 * @cb	void | testCallbackASM | Callback function in the ASM block.
 * This is a parameterized callback.
 * 
 * @parm	HWND | hwnd | Parameter one to callback.
 * @parm	WORD | wParam | Contains one of the following two flag
 * values:
 * @flag	FLAG_ONE | The generic first flag.
 * @flag	FLAG_TWO | Can't do without the Everpresent Flag Two.
 * 
 * @rdesc	Return description for the callback. This has no flags.
 * @comm	Comment for <f testCallbackASM>.
 * 
 */


char foobar3() {
	
	printf("This is getting to be old hat.\n");
	
}



	/********* 
	 ********* 
        	 *********		@doc	EXTERNAL	TEST
	 *********	@api	void | testMessedUpFuzzChars |
              This is a test description.  It is indented alot, and has 
        	 *********		lots of fuzz characters.
			********************************************
			 See if it comes out ok.
	 ********* 
        	 *********/



char foobar4() {
	
}


/* 
 * @doc	EXTERNAL TEST
 * @msg	TEST_MESSAGE_BLOCK | This tests the message block type.  It
 * has a number of paramters.
 * 
 * @parm	int | FirstParm | This parameter has no flags.
 * @parm	int | SecondParm | This parameter may take the following
 * flags:
 * @flag	F1_FIRST_FLAG | Specifies door number one.  This flag should
 * have lots of paragraphs within its description.
 * 
 * This is the second paragraph for flag number one.
 * 
 * @flag F1_SECOND_FLAG | The second flag for parameter two.
 * @flag F1_THIRD_FLAG | This is the third valid flag value for
 * parameter two.
 * 
 * @parm	int | ThirdParm | Contains one of the following flag values:
 * @flag F2_FOOBAR | This flag currently ignored.
 * 
 * @print	Testing comments within text...
 * @flag F2_BARFOO | // If this line appears, then comments are broken.
 * The second flag.  This line must appear, else embedded
 * comments are broken.
 * 
 * @comm	This is the comment text block's first paragraph.  It is not
 * too long.
 * 
 * The second paragraph begins with this sentence.  This is a test of
 * the emergency broadcast system.  In the event of an actual emergency,
 * the attention signal you just heard would have been followed by
 * information from the authorities.
 * 
 * @rdesc	This is the return description.  It has three flags.  The
 * paragraph of the return description can be as long as required, and
 * may include multiple paragraphs.
 * 
 * This is the second paragraph for the return description.
 * 
 * @flag	RFLAG_ONE | Return flag number one.
 * @flag	RFLAG_TWO | Return flag number two.
 * @flag	RFLAG_THREE|Return flag three.
 * 
 * @xref	testAsmBlock,testWarpedProcedure	 testNormalApiBlock
 * 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\test\apicb.c ===
/****************************************************************************
* @doc  EXTERNAL TEST
* @api  void | cFuncWithCallback | This is an imaginary C function
*   to test AUTODOC.  It has an associated callback function.
* @parm BYTE | bParam | Specifies an 8-bit parameter value.
* @parm WORD | wParam | Specifies a 16-bit parameter value.
* @parm  BYTE | bParamFlag | Specifies an 8-bit parameter value using 
*  one of the following flags:
*   @flag  RED | A flag value.
*   @flag  WHITE | Another flag value.
* @parm  FARPROC | lpCallback | Specifies a 32-bit pointer to a callback 
*  function.
* @rdesc  If zero, the callback was successfully installed.  Otherwise, 
*  an error is specified by one of the following flags:
*     @flag  ERROR1 | An error.
*     @flag  ERROR2 | Another error.
* @comm	  Here are some comments pertaining to this function.  Ventura
* character formatting tags like <MI>this italicized text<D> should
* pass through the AUTODOC tools.  <F>This sentence should be bold.<D>
* <P>This sentence should be italicized.<D>  The callback function is
* specified as follows:
* @cb WORD | cCallback | The name <F>cCallback<D> is a placeholder for
*   the application-supplied callback function.
* @parm BYTE | bParam | Specifies an 8-bit parameter value.
* @parm WORD | wParam | Specifies a 16-bit parameter value.
* @parm  BYTE | bParamFlag | Specifies an 8-bit parameter value using 
*  one of the following flags:
*   @flag  RED | A flag value.
*   @flag  WHITE | Another flag value.
* @rdesc  If zero, the callback was successfully installed.  Otherwise, 
*  an error is specified by one of the following flags:
*     @flag  ERROR1 | An error.
*     @flag  ERROR2 | Another error.
* @comm	Here are some comments pertaining to the callback function.
* @xref	asmFunc
*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\tools\extract\test\structs.c ===
/* temp output file.  */
typedef struct strfile
{
struct strfile *next;
    char       *filename;       /* output file name */
    char       *name;           /* name for sorting */
    int         blockType;      // block type
struct s_log   *logfile;        /* logfile */

} *files, fileentry;

/*
 * @doc INTERNAL
 * 
 * @types fileentry | This is the temp output file entry structure.
 * 
 * @field  char * | filename | output file name
 * 
 * @field  char * | name | name for sorting
 * 
 * @field  int | blockType | block type
 *
 * @flag FUNCTION | This block is a Function (API)
 *
 * @flag MESSAGE  | This block is a Message definition
 *
 * @flag CALLBACK  | This block is a C Callback Function
 *
 * @flag MASMBLOCK  | This block is a Masm Function
 *
 * @flag INTBLOCK  | This block is a Interrupt
 *
 * @flag MASMCBBLOCK  | This block is a Masm Callback Function
 *
 * @field struct <t s_log> * | logfile | logfile
 * 
 * @othertype fileentry * | files
 * 
 * @tagname strfile
 * 
 */
 
/* Log file */
typedef struct s_log
{
    struct s_log        *next;
    char                *pchlogname;    /* logfile name */
    struct stBlock      *pBlock;        /* first regular Block  */
    struct stBlock      *pMBlock;       /* first message Block  */
    struct _EXTFile     *pExt;          /* input file   */
    files               inheadFile;     /* list of files to read */
    files               outheadFile;    /* list of files in log */
    files               outheadMFile;   /* list of Message files in log */
    int                 outputType;     /* type of data contained in logfiles */

} logentry;

/*
 * @doc INTERNAL
 *
 * @types logentry | Log file structure.
 *
 * @field struct <t s_log> * | next | next log file.
 *
 * @field char * | pchlogname | logfile name
 *
 * @field struct <t stBlock> * | pBlock | first regular Block
 *
 * @field struct <t stBlock> * | pMBlock | first Message block
 *
 * @field struct <t _EXTFile> * | pExt | Input file
 *
 * @field <t files> | inheadFile | list of files to read
 *
 * @field <t files> | outheadFile | list of files in log
 *
 * @field <t files> | outheadMFile | list of Message files in log
 *
 * @field int | outputType | type of data contained in logfile
 *
 * @tagname s_log
 *
 */



/* a complete block */
typedef struct stBlock
{
struct stBlock * next;
    fileentry  *poutfile;           /* where we go */
 struct _EXTFile    *pExt;               /* input file */

/* block type identifiers */
#define FUNCTION        0x10            // no special reason for numbering
#define MESSAGE         0x20
#define CALLBACK        0x30
#define MASMBLOCK       0x40
#define INTBLOCK        0x50
#define MASMCBBLOCK     0x60

    int     blockType;

    int     srcline;            /* where we came from (before extract) */
    char    *srcfile;
    
} aBlock;


/*
 * @doc INTERNAL
 *
 * @types aBlock | A complete Block
 *
 * @field struct <t stBlock> * | next | next block in list
 *
 * @field  struct <t _EXTFile> * |pExt | input file
 *
 * @field <t fileentry>  * | poutfile | where we go 
 *
 * @field  int   |  blockType | Block type
 *
 * @flag FUNCTION | This block is a Function (API)
 *
 * @flag MESSAGE  | This block is a Message definition
 *
 * @flag CALLBACK  | This block is a C Callback Function
 *
 * @flag MASMBLOCK  | This block is a Masm Function
 *
 * @flag INTBLOCK  | This block is a Interrupt
 *
 * @flag MASMCBBLOCK  | This block is a Masm Callback Function
 *
 * @field int | srcline | Where we came from (before extract)
 *
 * @field char * | srcfile | The orig. source file from extract
 *
 * @tagname stBlock
 *
 */

typedef struct mmtime_tag {
    WORD    wType;              // the contents of the union
    union {
        DWORD ms;               // milliseconds
        DWORD sample;           // samples
        struct {                // SMPTE
            BYTE hour;          // hours
            BYTE min;           // minutes
            BYTE sec;           // seconds
            BYTE frame;         // frames
            BYTE fps;           // frames per second
        } smpte;

        struct {                // MIDI
            BYTE bar;           // bar
            BYTE pulse;         // pulse
        } midi;
    } u;
} MMTIME;

/*
 * @doc INTERNAL
 *
 * @types MMTIME | Multimedia Time structure.
 *
 * @field WORD | wType | Specifies the type of the union.
 *
 * @union u | The contents of the union.
 *
 * @field DWORD | ms | Milliseconds.
 *
 * @field DWORD | sample | Sample.
 *
 * @struct smpte | SMPTE Time.  Used when <e MMTIME.wType> specifies SMPTE.
 *
 * @field BYTE | hour | Hours.
 *
 * @field BYTE | min | Minutes.
 *
 * @field BYTE | sec | Seconds.
 *
 * @field BYTE | frame | Frames.
 *
 * @field BYTE | fps | Frames per second.
 *
 * @end
 *
 * @struct midi
 *
 * @field BYTE | bar | Bar
 *
 * @field BYTE | pulse | Pulse
 *
 * @end
 *
 * @end
 *
 * @tagname mmtime_tag
 *
 * @othertype  MMTIME FAR *| LPMMTIME 
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\verinfo\usa\verinfo.h ===
/*
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *	!!!!!!!IF YOU CHANGE TABS TO SPACES, YOU WILL BE KILLED!!!!!!!
 *      !!!!!!!!!!!!!!DOING SO MESSES UP THE BUILD PROCESS!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 *      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 */


/*
 *  verinfo.h - internal header file to define the build version
 *
 */

//
//  WARNING! the following defines are used by some of the components in
//  the multimedia core. do *NOT* put LEADING ZERO's on these numbers or
//  they will end up as OCTAL numbers in the C code!
//

#include <ntverp.h>
#define VERSIONPRODUCTNAME VER_PRODUCTNAME_STR

#ifdef MTN

#define OFFICIAL	1
#define FINAL		0

#ifdef ALTACM

#define /*ALTACM*/ MMVERSION		2
#define /*ALTACM*/ MMREVISION		0
#define /*ALTACM*/ MMRELEASE		90

#ifdef RC_INVOKED
#define VERSIONCOPYRIGHT	"Copyright (C) Microsoft Corp. 1992-1999\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ALTACM*/ VERSIONSTR	"Motown Retail Debug Version 2.00.090\0"
#elif defined(DEBUG)
#define /*ALTACM*/ VERSIONSTR	"Motown Internal Debug Version 2.00.090\0"
#else
#define /*ALTACM*/ VERSIONSTR	"2.00\0"
#endif

#elif defined(ALTVFW)

#define /*ALTVFW*/ MMVERSION		4
#define /*ALTVFW*/ MMREVISION		0
#define /*ALTVFW*/ MMRELEASE		90

#ifdef RC_INVOKED
#define VERSIONCOPYRIGHT	"Copyright (C) Microsoft Corp. 1992-1999\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ALTVFW*/ VERSIONSTR	"Motown Retail Debug Version 4.00.090\0"
#elif defined(DEBUG)
#define /*ALTVFW*/ VERSIONSTR	"Motown Internal Debug Version 4.00.090\0"
#else
#define /*ALTVFW*/ VERSIONSTR	"4.00\0"
#endif

#else

#define /*MTN*/ MMVERSION		4
#define /*MTN*/ MMREVISION		0
#define /*MTN*/ MMRELEASE		90

#ifdef RC_INVOKED
#define VERSIONCOPYRIGHT	"Copyright (C) Microsoft Corp. 1991-1999\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*MTN*/ VERSIONSTR	"Motown Retail Debug Version 4.00.090\0"
#elif defined(DEBUG)
#define /*MTN*/ VERSIONSTR	"Motown Internal Debug Version 4.00.090\0"
#else
#define /*MTN*/ VERSIONSTR	"4.00\0"
#endif

#endif

#elif defined(ACM)

#define OFFICIAL	1
#define FINAL		0

#define /*ACM*/ MMVERSION		5
#define /*ACM*/ MMREVISION		00
#define /*ACM*/ MMRELEASE		VER_PRODUCTBUILD

#ifdef RC_INVOKED
#define VERSIONCOPYRIGHT	"Copyright (C) Microsoft Corp. 1992-1999\0"
#endif

#if defined(DEBUG_RETAIL)
#define /*ACM*/ VERSIONSTR	"ACM Retail Debug Version 4.00.000\0"
#elif defined(DEBUG)
#define /*ACM*/ VERSIONSTR	"ACM Internal Debug Version 4.00.000\0"
#else
#define /*ACM*/ VERSIONSTR	"4.00\0"
#endif

#elif defined(VFW)

#define OFFICIAL	1
#define FINAL		0

#define /*VFW*/ MMVERSION		1
#define /*VFW*/ MMREVISION		10
#define /*VFW*/ MMRELEASE		190

#ifdef RC_INVOKED
#define VERSIONCOPYRIGHT	"Copyright (C) Microsoft Corp. 1992-1999\0"
#endif

#ifdef WIN32

#if defined(DEBUG_RETAIL)
#define /*VFW*/ VERSIONSTR	"Video for Windows Retail Debug Version 1.15.001 (NT)\0"
#elif defined(DEBUG)
#define /*VFW*/ VERSIONSTR	"Video for Windows Internal Debug Version 1.15.001 (NT)\0"
#else
#define /*VFW*/ VERSIONSTR	"1.15\0"
#endif

#else // WIN32

#if defined(DEBUG_RETAIL)
#define /*VFW*/ VERSIONSTR	"Video for Windows Retail Debug Version 1.15.001\0"
#elif defined(DEBUG)
#define /*VFW*/ VERSIONSTR	"Video for Windows Internal Debug Version 1.15.001\0"
#else
#define /*VFW*/ VERSIONSTR	"1.15\0"
#endif
#endif

#endif

/***************************************************************************
 *  DO NOT TOUCH BELOW THIS LINE                                           *
 ***************************************************************************/

#ifdef RC_INVOKED
#define VERSIONCOMPANYNAME	VER_COMPANYNAME_STR

/*
 *  Version flags
 */

#ifndef OFFICIAL
#define VER_PRIVATEBUILD	VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD	0
#endif

#define VERSIONFLAGS		(VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)
#define VERSIONFILEFLAGSMASK	0x0030003FL

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\agfxp.h ===
#ifdef AGFX_EXPORTS
#define AGFX_API __declspec(dllexport)
#else
#define AGFX_API __declspec(dllimport)
#endif

EXTERN_C AGFX_API void WINAPI gfxLogon(DWORD dwProcessId);
EXTERN_C AGFX_API void WINAPI gfxLogoff(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\agfxc.cpp ===
// agfxc.cpp : Client side code for agfx.
//
// Created by FrankYe on 7/3/2000
//

#define UNICODE
#define _UNICODE

#include <windows.h>
#include <mmsystem.h>
#include <mmsysp.h>
#include <tchar.h>
#include <regstr.h>
#include <ks.h>
#include <ksmedia.h>
#include "agfxp.h"
#include "audiosrv.h"
#include "audiosrvc.h"

// ISSUE-2000/09/25-FrankYe TODO list
// - move heap helpers somewhere else
// - remove ClientUpdatePnpInfo, and hHeap extern definitions

extern "C" void ClientUpdatePnpInfo(void);
extern "C" HANDLE hHeap;

//
// This global variable tracks the most device interfaces contained in any
// DEVICEINTERFACELIST structure created by these functions.  This helps
// validate the input to gfxDestroyDeviceInterfaceList
//
LONG gcMostDeviceInterfaces = 0;

#define RPC_CALL_START RpcTryExcept {
#define RPC_CALL_END_(status) } RpcExcept(1) { status = RpcExceptionCode(); } RpcEndExcept
#define RPC_CALL_END } RpcExcept(1) { RpcExceptionCode(); } RpcEndExcept

//=============================================================================
//===   Heap helpers   ===
//=============================================================================
static BOOL HeapFreeIfNotNull(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
{
    return lpMem ? HeapFree(hHeap, dwFlags, lpMem) : TRUE;
}


//=============================================================================
//===   gfx API   ===
//=============================================================================
WINMMAPI LONG WINAPI gfxModifyGfx(DWORD Id, ULONG Order)
{
    LONG status;
    ClientUpdatePnpInfo();
    RPC_CALL_START;
    status = s_gfxModifyGfx(Id, Order);
    RPC_CALL_END_(status);
    return status;
}


WINMMAPI LONG WINAPI gfxAddGfx(IN PCWSTR ZoneFactoryDi, IN PCWSTR GfxFactoryDi, IN ULONG Type, IN ULONG Order, OUT PULONG pNewId)
{
    LONG status;
    
    if (IsBadStringPtr(ZoneFactoryDi, (UINT_PTR)(-1))) return ERROR_INVALID_PARAMETER;    
    if (IsBadStringPtr(GfxFactoryDi, (UINT_PTR)(-1))) return ERROR_INVALID_PARAMETER;
    if (IsBadWritePtr(pNewId, sizeof(*pNewId))) return ERROR_INVALID_PARAMETER;
    
    ClientUpdatePnpInfo();
    
    RPC_CALL_START;
    status = s_gfxAddGfx((PWSTR)ZoneFactoryDi, (PWSTR)GfxFactoryDi, Type, Order, pNewId);
    RPC_CALL_END_(status);
    return status;
}


WINMMAPI LONG WINAPI gfxRemoveGfx(DWORD Id)
{
    LONG status;
    ClientUpdatePnpInfo();
    RPC_CALL_START;
    status = s_gfxRemoveGfx(Id);
    RPC_CALL_END_(status);
    return status;
}

WINMMAPI LONG WINAPI gfxDestroyDeviceInterfaceList(PDEVICEINTERFACELIST pDiList)
{
    LONG Count;
    PTSTR *ppDi;
    LONG result;

    if (IsBadReadPtr(&pDiList->Count, sizeof(pDiList->Count))) return ERROR_INVALID_PARAMETER;
    Count = pDiList->Count;
    if (Count < 0 || Count > gcMostDeviceInterfaces) return ERROR_INVALID_PARAMETER;
    if (IsBadWritePtr(pDiList, (PBYTE)&pDiList->DeviceInterface[Count] - (PBYTE)pDiList)) return ERROR_INVALID_PARAMETER;
    ppDi = &pDiList->DeviceInterface[0];
    while (Count-- > 0) if (IsBadStringPtr(*ppDi, (UINT_PTR)(-1))) return ERROR_INVALID_PARAMETER;

    // Now we are reasonably confident that we have good input
    // parameters.  We design the following logic to return the
    // first error encountered, if any.

    ClientUpdatePnpInfo();
    
    result = NO_ERROR;
    Count = pDiList->Count;
    ppDi = &pDiList->DeviceInterface[0];
    while (Count-- > 0) if (!HeapFree(hHeap, 0, *(ppDi++)) && (NO_ERROR == result)) result = GetLastError();
    if ((!HeapFree(hHeap, 0, pDiList)) && (NO_ERROR == result)) result = GetLastError();

    SetLastError(result);
    return result;
}

WINMMAPI LONG WINAPI gfxEnumerateGfxs(PCWSTR ZoneFactoryDi, GFXENUMCALLBACK pGfxEnumCallback, PVOID Context)
{
    LONG lresult;
    UNIQUE_PGFXLIST pGfxList = NULL;

    if (IsBadStringPtr(ZoneFactoryDi, (UINT_PTR)(-1))) return ERROR_INVALID_PARAMETER;
    if (IsBadCodePtr((FARPROC)pGfxEnumCallback)) return ERROR_INVALID_PARAMETER;

    ClientUpdatePnpInfo();
    
    RPC_CALL_START;
    lresult = s_gfxCreateGfxList((PWSTR)ZoneFactoryDi, &pGfxList);
    RPC_CALL_END_(lresult);
    // ISSUE-2000/09/25-FrankYe Should not have to check for pGfxList != NULL. Fix this interface
    if (!lresult && pGfxList)
    {
	if (pGfxList->Count > 0)
	{
	    int i = 0;

	    while (i < pGfxList->Count)
	    {
		if (!lresult) lresult = pGfxEnumCallback(Context,
							 pGfxList->Gfx[i].Id,
							 pGfxList->Gfx[i].GfxFactoryDi,
							 *(LPCLSID)(&pGfxList->Gfx[i].Clsid),
							 pGfxList->Gfx[i].Type,
							 pGfxList->Gfx[i].Order);
		HeapFree(hHeap, 0, pGfxList->Gfx[i].GfxFactoryDi);
		i++;
	    }
	}

	HeapFree(hHeap, 0, pGfxList);
    }

    return lresult;
}

WINMMAPI LONG WINAPI gfxCreateGfxFactoriesList(PCWSTR ZoneFactoryDi, OUT PDEVICEINTERFACELIST *ppDiList)
{
    LONG lresult;
    UNIQUE_PDILIST pDiList = NULL;

    if (IsBadWritePtr(ppDiList, sizeof(*ppDiList))) return ERROR_INVALID_PARAMETER;

    ClientUpdatePnpInfo();
    
    RPC_CALL_START;
    lresult = s_gfxCreateGfxFactoriesList((PWSTR)ZoneFactoryDi, &pDiList);
    RPC_CALL_END_(lresult);

    if (!lresult) {
        gcMostDeviceInterfaces = max(gcMostDeviceInterfaces, pDiList->Count);
        *ppDiList = (PDEVICEINTERFACELIST)pDiList;
    }
    
    return lresult;
}

WINMMAPI LONG WINAPI gfxCreateZoneFactoriesList(OUT PDEVICEINTERFACELIST *ppDiList)
{
    LONG lresult;
    UNIQUE_PDILIST pDiList = NULL;

    if (IsBadWritePtr(ppDiList, sizeof(*ppDiList))) return ERROR_INVALID_PARAMETER;

    ClientUpdatePnpInfo();
    
    RPC_CALL_START;
    lresult = s_gfxCreateZoneFactoriesList(&pDiList);
    RPC_CALL_END_(lresult);

    if (!lresult) {
        gcMostDeviceInterfaces = max(gcMostDeviceInterfaces, pDiList->Count);
        *ppDiList = (PDEVICEINTERFACELIST)pDiList;
    }
    
    return lresult;
}

WINMMAPI LONG WINAPI gfxBatchChange(PGFXREMOVEREQUEST paGfxRemoveRequests, ULONG cGfxRemoveRequests,
	                   PGFXMODIFYREQUEST paGfxModifyRequests, ULONG cGfxModifyRequests,
		           PGFXADDREQUEST    paGfxAddRequests,    ULONG cGfxAddRequests)
{
    ULONG Index;
    LONG  Error;

    if ((cGfxRemoveRequests > 0) && IsBadWritePtr(paGfxRemoveRequests, cGfxRemoveRequests * sizeof(*paGfxRemoveRequests))) return ERROR_INVALID_PARAMETER;
    if ((cGfxModifyRequests > 0) && IsBadWritePtr(paGfxModifyRequests, cGfxModifyRequests * sizeof(*paGfxModifyRequests))) return ERROR_INVALID_PARAMETER;
    if ((cGfxAddRequests > 0)    && IsBadWritePtr(paGfxAddRequests,    cGfxAddRequests    * sizeof(*paGfxAddRequests)))    return ERROR_INVALID_PARAMETER;

    ClientUpdatePnpInfo();
    
    Error = ERROR_SUCCESS;
    for (Index = 0; Index < cGfxRemoveRequests && ERROR_SUCCESS == Error; Index++)
    {
	Error = gfxRemoveGfx(paGfxRemoveRequests[Index].IdToRemove);
	paGfxRemoveRequests[Index].Error = Error;
    }

    for (Index = 0; Index < cGfxModifyRequests && ERROR_SUCCESS == Error; Index++)
    {
	Error = gfxModifyGfx(paGfxModifyRequests[Index].IdToModify,
		             paGfxModifyRequests[Index].NewOrder);
	paGfxModifyRequests[Index].Error = Error;
    }

    for (Index = 0; Index < cGfxAddRequests && ERROR_SUCCESS == Error; Index++)
    {
	Error = gfxAddGfx(paGfxAddRequests[Index].ZoneFactoryDi,
			  paGfxAddRequests[Index].GfxFactoryDi,
			  paGfxAddRequests[Index].Type,
			  paGfxAddRequests[Index].Order,
			 &paGfxAddRequests[Index].NewId);
	paGfxAddRequests[Index].Error = Error;
    }

    return Error;
}

WINMMAPI LONG WINAPI gfxOpenGfx(DWORD dwGfxId, PHANDLE pFileHandle)
{
    LONG status;
    ClientUpdatePnpInfo();
    RPC_CALL_START;
    status = s_gfxOpenGfx(GetCurrentProcessId(), dwGfxId, (RHANDLE*)pFileHandle);
    RPC_CALL_END_(status);
    return status;
}

WINMMAPI void WINAPI gfxLogon(DWORD dwProcessId)
{
    ClientUpdatePnpInfo();
    RPC_CALL_START;
    s_gfxLogon(AudioSrv_IfHandle, dwProcessId);
    RPC_CALL_END;
}

WINMMAPI void WINAPI gfxLogoff(void)
{
    ClientUpdatePnpInfo();
    RPC_CALL_START;
    s_gfxLogoff();
    RPC_CALL_END;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\audiosrvc.c ===
/* File: audiosrvc.c                             */
/* Copyright (c) 2000-2001 Microsoft Corporation */

#define UNICODE
#define _UNICODE

#include "winmmi.h"
#include "audiosrv.h" 
 
#define RPC_CALL_START RpcTryExcept {
#define RPC_CALL_END_(status) } RpcExcept(1) { status = RpcExceptionCode(); } RpcEndExcept
#define RPC_CALL_END } RpcExcept(1) { RpcExceptionCode(); } RpcEndExcept

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t cb)
{
    return HeapAlloc(hHeap, HEAP_ZERO_MEMORY, cb);
}

void  __RPC_USER MIDL_user_free( void __RPC_FAR * pv)
{
    HeapFree(hHeap, 0, pv);
}

LONG AudioSrvBinding(void)
{
    RPC_STATUS status;
    PTSTR pszUuid             = NULL;
    PTSTR pszProtocolSequence = TEXT("ncalrpc");
    PTSTR pszNetworkAddress   = NULL;
    PTSTR pszEndpoint         = TEXT("AudioSrv");
    PTSTR pszOptions          = NULL;
    PTSTR pszStringBinding    = NULL;
    PTSTR pszString           = NULL;

    // dprintf(("AudioSrvBinding"));

    WinAssert(NULL == AudioSrv_IfHandle);
    
    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     pszEndpoint,
                                     pszOptions,
                                     &pszStringBinding);

    if (RPC_S_OK == status)
    {
        status = RpcBindingFromStringBinding(pszStringBinding, &AudioSrv_IfHandle);
        RpcStringFree(&pszStringBinding);
    }

    if (RPC_S_OK != status) dprintf(("AudioSrvBinding: returning %d", status));

    return status;
}

void AudioSrvBindingFree(void)
{
    RPC_STATUS status;
    
    // dprintf(("AudioSrvBindingFree"));

    status = AudioSrv_IfHandle ? RpcBindingFree(&AudioSrv_IfHandle) : RPC_S_OK;
    if (RPC_S_OK == status) WinAssert(NULL == AudioSrv_IfHandle);
    
    if (RPC_S_OK != status) dprintf(("AudioSrvBindingFree: RpcBindingFree returned %d", status));
}

BOOL winmmWaitForService(void)
{
    static BOOL fWaited = FALSE;
    static BOOL fStarted = FALSE;

    const LONG Timeout = 120000;

    SC_HANDLE schScm = NULL;
    SC_HANDLE schAudioSrv = NULL;

    if (fWaited) return fStarted;

    schScm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (!schScm)
    {
        DWORD dw = GetLastError();
        dprintf(("winmmWaitForService: could not OpenSCManager, LastError=%d", dw));
        return FALSE;
    }

    schAudioSrv = OpenService(schScm, TEXT("AudioSrv"), SERVICE_QUERY_CONFIG | SERVICE_QUERY_STATUS);
    if (schAudioSrv)
    {
        int cWaits = 0;
        while (!fWaited) {
            SERVICE_STATUS ServiceStatus;
    
            if (QueryServiceStatus(schAudioSrv, &ServiceStatus))
            {
                if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
                     (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
                     (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
                     (ServiceStatus.dwCurrentState == SERVICE_PAUSED) )
                {
                    fStarted = TRUE;
                    fWaited = TRUE;
                }  else if (ServiceStatus.dwCurrentState == SERVICE_STOPPED &&
                            ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_NEVER_STARTED)
                {
                    if (cWaits == 0)
                    {
                        DWORD cbNeeded;

                        // Check that the service StartType is set such that
                        // it will start
                        if (QueryServiceConfig(schAudioSrv, NULL, 0, &cbNeeded) || ERROR_INSUFFICIENT_BUFFER == GetLastError())
                        {
                            QUERY_SERVICE_CONFIG *ServiceConfig;
                            ServiceConfig = HeapAlloc(hHeap, 0, cbNeeded);
                            if (ServiceConfig) {
                                if (QueryServiceConfig(schAudioSrv, ServiceConfig, cbNeeded, &cbNeeded)) {
                                    if (ServiceConfig->dwStartType != SERVICE_AUTO_START) {
                                        fWaited = TRUE;
                                    }
                                } else {
                                    DWORD dwLastError = GetLastError();
                                    dprintf(("winmmWaitForService: QueryServiceConfig failed LastError=%d", dwLastError));
                                    fWaited = TRUE;
                                }
                                HeapFree(hHeap, 0, ServiceConfig);
                            } else {
                                dprintf(("winmmWaitForService: HeapAlloc failed"));
                            }
                        } else {
                            DWORD dwLastError = GetLastError();
                            dprintf(("winmmWaitForService: QueryServiceConfig failed LastError=%d", dwLastError));
                            fWaited = TRUE;
                        }
                    }
                } else if (ServiceStatus.dwCurrentState != SERVICE_START_PENDING)
                {
                    // Unfamiliar dwCurrentState, or was started and then stopped
                    fWaited = TRUE;
                }
            } else {
                DWORD dwLastError = GetLastError();
                dprintf(("winmmWaitForService: QueryServiceStatus failed LastError=%d", dwLastError));
                fWaited = TRUE;
            }

            if (!fWaited && ((cWaits * 2000) > Timeout))
            {
                dprintf(("winmmWaitForService timed out.  Could be design problem.  Open a bug!"));
                WinAssert(FALSE);
                fWaited = TRUE;
            }
                
            if (!fWaited) {
                Sleep(2000);
                cWaits++;
            }
        }
        CloseServiceHandle(schAudioSrv);
    } else {
        DWORD dwLastError = GetLastError();
        dprintf(("winmmWaitForService: OpenService failed LastError=%d", dwLastError));
    }

    CloseServiceHandle(schScm);

    return fStarted;
}


LONG winmmRegisterSessionNotificationEvent(HANDLE hEvent, PHANDLE phRegNotify)
{
    LONG lresult;
    winmmWaitForService();
    RPC_CALL_START;
    lresult = s_winmmRegisterSessionNotificationEvent(GetCurrentProcessId(), (RHANDLE)hEvent, (PHANDLE_SESSIONNOTIFICATION)phRegNotify);
    RPC_CALL_END_(lresult);
    return lresult;
}

LONG winmmUnregisterSessionNotification(HANDLE hRegNotify)
{
    LONG lresult;

    winmmWaitForService();
    
    RPC_CALL_START;
    
    // if (!AudioSrv_IfHandle) dprintf(("winmmUnregisterSessionNotification : warning: called with AudioSrv_IfHandle == NULL"));

    // If we have a binding handle, then let's call the server to close this
    // context handle otherwise we need to call RpcSsDestroyClientContext to
    // destroy it without contacting the server
    if (AudioSrv_IfHandle)
    {
    	lresult = s_winmmUnregisterSessionNotification((PHANDLE_SESSIONNOTIFICATION)&hRegNotify);
    }
    else
    {
    	RpcSsDestroyClientContext(&hRegNotify);
        lresult = RPC_S_OK;
    }
    
    RPC_CALL_END_(lresult);
    return lresult;
}
LONG winmmSessionConnectState(PINT ConnectState)
{
    LONG lresult;
    winmmWaitForService();
    RPC_CALL_START;
    lresult = s_winmmSessionConnectState(GetCurrentProcessId(), ConnectState);
    RPC_CALL_END_(lresult);
    return lresult;
}

LONG wdmDriverOpenDrvRegKey(IN PCTSTR DeviceInterface, IN REGSAM samDesired, OUT HKEY *phkey)
{
    LONG lresult;
    winmmWaitForService();
    RPC_CALL_START;
    lresult = s_wdmDriverOpenDrvRegKey(GetCurrentProcessId(), DeviceInterface, samDesired, (RHANDLE*)phkey);
    RPC_CALL_END_(lresult);
    return lresult;
}

void winmmAdvisePreferredDeviceChange(void)
{
    winmmWaitForService();
    RPC_CALL_START;
    s_winmmAdvisePreferredDeviceChange();
    RPC_CALL_END;
    return;
}

LONG winmmGetPnpInfo(OUT LONG *pcbPnpInfo, OUT PMMPNPINFO *ppPnpInfo)
{
    LONG cbPnpInfo = 0;
    BYTE *pPnpInfo = NULL;
    LONG lresult;
    
    winmmWaitForService();
    RPC_CALL_START;
    lresult = s_winmmGetPnpInfo(&cbPnpInfo, &pPnpInfo);
    RPC_CALL_END_(lresult);
    if (ERROR_SUCCESS == lresult)
    {
    	*pcbPnpInfo = cbPnpInfo;
    	*ppPnpInfo = (PMMPNPINFO)pPnpInfo;
    }
    return lresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\audiosrvc.h ===
//
// Audio server
//
EXTERN_C LONG AudioSrvBinding(void);
EXTERN_C void AudioSrvBindingFree(void);
EXTERN_C BOOL winmmWaitForService(void);
EXTERN_C LONG winmmRegisterSessionNotificationEvent(HANDLE hEvent, PHANDLE phNotify);
EXTERN_C LONG winmmUnregisterSessionNotification(HANDLE hNotify);
EXTERN_C LONG winmmSessionConnectState(PINT ConnectState);
EXTERN_C LONG wdmDriverOpenDrvRegKey(IN PCTSTR DeviceInterface, IN REGSAM samDesired, OUT HKEY *phkey);
EXTERN_C void winmmAdvisePreferredDeviceChange(void);
EXTERN_C LONG winmmGetPnpInfo(OUT LONG *pcbPnpInfo, OUT PMMPNPINFO *ppPnpInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\auxout.c ===
/****************************************************************************
    auxout.c

    Level 1 kitchen sink DLL aux support module

    Copyright (c) 1990-2001 Microsoft Corporation

    Changes for NT :
        Change parameters for MapAuxId to return the driver index rather
        than a pointer

        change list of include files

        widen function parameters and return codes

        Change WINAPI to APIENTRY

    History
        10/1/92  Updated for NT by Robin Speed (RobinSp)
****************************************************************************/
#include "winmmi.h"

/****************************************************************************
 * @doc INTERNAL  AUX
 *
 * @func MMRESULT | auxReferenceDriverById | This function maps a logical id
 *   to a device driver and physical id.
 *
 * @parm IN UINT | id | The logical id to be mapped.
 *
 * @parm OUT PAUXRV* OPTIONAL | ppauxdrv | Pointer to AUXDRV structure
 *    describing the driver supporting the id.
 *
 * @parm OUT UINT* OPTIONAL | pport | The driver-relative device number. If
 *    the caller supplies this buffer then it must also supply ppauxdrv.
 *
 * @rdesc The return value is zero if successful, MMSYSERR_BADDEVICEID if
 *   the id is out of range.
 *
 * @comm If the caller specifies ppwavedrv then this function increments
 *       the zuxdrv's usage before returning.  The caller must ensure
 *       the usage is eventually decremented.
 *
 ****************************************************************************/
MMRESULT auxReferenceDriverById(IN UINT id, OUT PAUXDRV *ppauxdrv OPTIONAL, OUT UINT *pport OPTIONAL)
{
    PAUXDRV  pdrv;
    MMRESULT mmr;

    // Should not be called asking for port but not auxdrv
    WinAssert(!(pport && !ppauxdrv));

    EnterNumDevs("auxReferenceDriverById");
    
    if (AUX_MAPPER == id)
    {
	id = 0;
    	for (pdrv = auxdrvZ.Next; pdrv != &auxdrvZ; pdrv = pdrv->Next)
    	{
    	    if (pdrv->fdwDriver & MMDRV_MAPPER) break;
    	}
    } else {
    	for (pdrv = auxdrvZ.Next; pdrv != &auxdrvZ; pdrv = pdrv->Next)
        {
            if (pdrv->fdwDriver & MMDRV_MAPPER) continue;
            if (pdrv->NumDevs > id) break;
            id -= pdrv->NumDevs;
        }
    }

    if (pdrv != &auxdrvZ)
    {
    	if (ppauxdrv)
    	{
    	    mregIncUsagePtr(pdrv);
    	    *ppauxdrv = pdrv;
    	    if (pport) *pport = id;
    	}
    	mmr = MMSYSERR_NOERROR;
    } else {
        mmr = MMSYSERR_BADDEVICEID;
    }

    LeaveNumDevs("auxReferenceDriverById");
    
    return mmr;
}

PCWSTR auxReferenceDevInterfaceById(UINT id)
{
    PAUXDRV pdrv;
    if (!auxReferenceDriverById(id, &pdrv, NULL))
    {
    	PCWSTR DevInterface;
    	DevInterface = pdrv->cookie;
    	if (DevInterface) wdmDevInterfaceInc(DevInterface);
    	mregDecUsagePtr(pdrv);
    	return DevInterface;
    }
    return NULL;
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @func MMRESULT | auxOutMessage | This function sends a messages to an auxiliary
 * output device.  It also performs error checking on the device ID passed.
 *
 * @parm UINT | uDeviceID | Identifies the auxiliary output device to be
 *   queried. Specify a valid device ID (see the following comments
 *   section), or use the following constant:
 *   @flag AUX_MAPPER | Auxiliary audio mapper. The function will
 *     return an error if no auxiliary audio mapper is installed.
 *
 * @parm UINT | uMessage  | The message to send.
 *
 * @parm DWORD | dw1Param1 | Parameter 1.
 *
 * @parm DWORD | dw2Param2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 *
 ****************************************************************************/
MMRESULT APIENTRY auxOutMessage(
        UINT        uDeviceID,
        UINT        uMessage,
        DWORD_PTR   dwParam1,
        DWORD_PTR   dwParam2)
{
    PAUXDRV  auxdrvr;
    UINT     port;
    DWORD    mmr;

    ClientUpdatePnpInfo();

    mmr = auxReferenceDriverById(uDeviceID, &auxdrvr, &port);
    if (mmr) return mmr;
        
    if (!auxdrvr->drvMessage)
    {
        mmr = MMSYSERR_NODRIVER;
    }
    else if (!mregHandleInternalMessages (auxdrvr, TYPE_AUX, port, uMessage, dwParam1, dwParam2, &mmr))
    {
    	mmr = (MMRESULT)auxdrvr->drvMessage(port, uMessage, 0L, dwParam1, dwParam2);
    }

    mregDecUsagePtr(auxdrvr);
    return mmr;
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api UINT | auxGetNumDevs | This function retrieves the number of auxiliary
 *   output devices present in the system.
 *
 * @rdesc Returns the number of auxiliary output devices present in the system.
 *
 * @xref auxGetDevCaps
 ****************************************************************************/
UINT APIENTRY auxGetNumDevs(void)
{
    UINT    cDevs;

      ClientUpdatePnpInfo();

      EnterNumDevs("auxGetNumDevs");
        cDevs = (UINT)wTotalAuxDevs;
      LeaveNumDevs("auxGetNumDevs");

    return cDevs;
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api MMRESULT | auxGetDevCaps | This function queries a specified
 *   auxiliary output device to determine its capabilities.
 *
 * @parm UINT | uDeviceID | Identifies the auxiliary output device to be
 *   queried. Specify a valid device ID (see the following comments
 *   section), or use the following constant:
 *   @flag AUX_MAPPER | Auxiliary audio mapper. The function will
 *     return an error if no auxiliary audio mapper is installed.
 *
 * @parm LPAUXCAPS | lpCaps | Specifies a far pointer to an AUXCAPS
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the AUXCAPS structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @comm The device ID specified by <p uDeviceID> varies from zero
 *   to one less than the number of devices present. AUX_MAPPER may
 *   also be used. Use <f auxGetNumDevs> to determine the number of
 *   auxiliary devices present in the system.
 *
 * @xref auxGetNumDevs
 ****************************************************************************/
 //
 // ISSUE-2001/01/08-FrankYe Silly casts to UINT in these functions,
 //    should validate first
 //
    
MMRESULT APIENTRY auxGetDevCapsW(UINT_PTR uDeviceID, LPAUXCAPSW lpCaps, UINT wSize)
{
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PCWSTR          DevInterface;
    MMRESULT        mmr;

    if (!wSize)
            return MMSYSERR_NOERROR;
    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = auxReferenceDevInterfaceById((UINT)uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)lpCaps;
        dwParam2 = (DWORD)wSize;
    }
    else
    {
        mdCaps.cbSize = (DWORD)wSize;
        mdCaps.pCaps  = lpCaps;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    mmr = (MMRESULT)auxOutMessage((UINT)uDeviceID, AUXDM_GETDEVCAPS, dwParam1, dwParam2);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

MMRESULT APIENTRY auxGetDevCapsA(UINT_PTR uDeviceID, LPAUXCAPSA lpCaps, UINT wSize)
{
    AUXCAPS2W       wDevCaps2;
    AUXCAPS2A       aDevCaps2;
    DWORD_PTR       dwParam1, dwParam2;
    MDEVICECAPSEX   mdCaps;
    PCWSTR          DevInterface;
    MMRESULT        mmRes;

    if (!wSize)
            return MMSYSERR_NOERROR;
    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    ClientUpdatePnpInfo();

    DevInterface = auxReferenceDevInterfaceById((UINT)uDeviceID);
    dwParam2 = (DWORD_PTR)DevInterface;

    memset(&wDevCaps2, 0, sizeof(wDevCaps2));

    if (0 == dwParam2)
    {
        dwParam1 = (DWORD_PTR)&wDevCaps2;
        dwParam2 = (DWORD)sizeof(wDevCaps2);
    }
    else
    {
        mdCaps.cbSize = (DWORD)sizeof(wDevCaps2);
        mdCaps.pCaps  = &wDevCaps2;
        dwParam1      = (DWORD_PTR)&mdCaps;
    }

    mmRes = (MMRESULT)auxOutMessage( (UINT)uDeviceID, AUXDM_GETDEVCAPS,
                                    dwParam1,
                                    dwParam2);

    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    
    //
    // Don't copy data back if bad return code
    //

    if (mmRes != MMSYSERR_NOERROR) {
        return mmRes;
    }

    aDevCaps2.wMid             = wDevCaps2.wMid;
    aDevCaps2.wPid             = wDevCaps2.wPid;
    aDevCaps2.vDriverVersion   = wDevCaps2.vDriverVersion;
    aDevCaps2.wTechnology      = wDevCaps2.wTechnology;
    aDevCaps2.dwSupport        = wDevCaps2.dwSupport;
    aDevCaps2.ManufacturerGuid = wDevCaps2.ManufacturerGuid;
    aDevCaps2.ProductGuid      = wDevCaps2.ProductGuid;
    aDevCaps2.NameGuid         = wDevCaps2.NameGuid;

    // copy and convert lpwText to lpText here.
    Iwcstombs( aDevCaps2.szPname, wDevCaps2.szPname, MAXPNAMELEN);
    CopyMemory((PVOID)lpCaps, (PVOID)&aDevCaps2, min(sizeof(aDevCaps2), wSize));

    return mmRes;
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api MMRESULT | auxGetVolume | This function returns the current volume
 *   setting of an auxiliary output device.
 *
 * @parm UINT | uDeviceID | Identifies the auxiliary output device to be
 *   queried.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location
 *   to be filled with the current volume setting.  The low-order word of
 *   this location contains the left channel volume setting, and the high-order
 *   word contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of the specified location contains
 *   the volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f auxSetVolume> are returned, regardless of whether
 *   the device supports the full 16 bits of volume level control.
 *
 * @comm  Not all devices support volume control.
 *   To determine whether the device supports volume control, use the
 *   AUXCAPS_VOLUME flag to test the <e AUXCAPS.dwSupport> field of the
 *   <t AUXCAPS> structure (filled by <f auxGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the AUXCAPS_LRVOLUME flag to test the
 *   <e AUXCAPS.dwSupport> field of the <t AUXCAPS> structure (filled
 *   by <f auxGetDevCaps>).
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @xref auxSetVolume
 ****************************************************************************/
MMRESULT APIENTRY auxGetVolume(UINT uDeviceID, LPDWORD lpdwVolume)
{
    PCWSTR   DevInterface;
    MMRESULT mmr;

    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);
    
    ClientUpdatePnpInfo();

    DevInterface = auxReferenceDevInterfaceById(uDeviceID);
    mmr = (MMRESULT)auxOutMessage(uDeviceID, AUXDM_GETVOLUME, (DWORD_PTR)lpdwVolume, (DWORD_PTR)DevInterface);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api MMRESULT | auxSetVolume | This function sets the volume in an
 *   auxiliary output device.
 *
 * @parm UINT | uDeviceID |  Identifies the auxiliary output device to be
 *   queried.  Device IDs are determined implicitly from the number of
 *   devices present in the system.  Device ID values range from zero
 *   to one less than the number of devices present.  Use <f auxGetNumDevs>
 *   to determine the number of auxiliary devices in the system.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.  The
 *   low-order UINT specifies the left channel volume setting, and the
 *   high-order word specifies the right channel setting.
 *   A value of 0xFFFF represents full volume, and a value of 0x0000
 *   is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of <p dwVolume> specifies the volume
 *   level, and the high-order word is ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @comm Not all devices support volume control.
 *   To determine whether the device supports volume control, use the
 *   AUXCAPS_VOLUME flag to test the <e AUXCAPS.dwSupport> field of the
 *   <t AUXCAPS> structure (filled by <f auxGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the AUXCAPS_LRVOLUME flag to test the
 *   <e AUXCAPS.dwSupport> field of the <t AUXCAPS> structure (filled
 *   by <f auxGetDevCaps>).
 *
 *   Most devices do not support the full 16 bits of volume level control
 *   and will use only the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be will
 *   all produce the same physical volume setting, 0x4000. The
 *   <f auxGetVolume> function will return the full 16-bit setting set
 *   with <f auxSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived volume increase is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref auxGetVolume
 ****************************************************************************/
MMRESULT APIENTRY auxSetVolume(UINT uDeviceID, DWORD dwVolume)
{
    PCWSTR   DevInterface;
    MMRESULT mmr;

    ClientUpdatePnpInfo();

    DevInterface = auxReferenceDevInterfaceById(uDeviceID);
    mmr = (MMRESULT)auxOutMessage(uDeviceID, AUXDM_SETVOLUME, dwVolume, (DWORD_PTR)DevInterface);
    if (DevInterface) wdmDevInterfaceDec(DevInterface);
    return mmr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\csrthrd.c ===
/******************************************************************************

   Copyright (c) 1993-1998 Microsoft Corporation

   Title:   csrthrd.c - code to create a thread inside the server process

*****************************************************************************/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include <windows.h>

typedef PVOID (NTAPI *ADD_SERVER_THREAD)(HANDLE, PCLIENT_ID, ULONG);

/*
**  Create a server thread
*/

BOOLEAN CreateServerPlayingThread(PVOID ThreadStartRoutine)
{
    CLIENT_ID ClientId;
    HANDLE    hThread;

    hThread = NULL;

    RtlCreateUserThread(NtCurrentProcess(),
                        NULL,
                        (BOOLEAN)TRUE,
                        0,
                        0,
                        0,
                        (PUSER_THREAD_START_ROUTINE)ThreadStartRoutine,
                        NULL,
                        &hThread,
                        &ClientId);

    if (!hThread) {
#if DBG
        OutputDebugStringA("WINMM: Server failed to create user thread\n");
#endif
        return FALSE;

    } else {
        HMODULE hModCSR;
        ADD_SERVER_THREAD pCsrAddStaticServerThread;

        hModCSR = GetModuleHandleW((LPCWSTR)L"csrsrv.dll");

#if DBG
        if (hModCSR == NULL) {
            OutputDebugStringA("WINMM: Could not get CSRSRV.DLL handle\n");
            DebugBreak();
        }
#endif

        pCsrAddStaticServerThread =
            (ADD_SERVER_THREAD)GetProcAddress(hModCSR, "CsrAddStaticServerThread");

        if (pCsrAddStaticServerThread == NULL) {
#if DBG
            OutputDebugStringA("WINMM: Could not get address if CsrAddStaticServerThread\n");
            DebugBreak();
#endif
            return FALSE;
        }

        (*pCsrAddStaticServerThread)(hThread, &ClientId, 0);

        /*
        * Resume the sound thread now that we've initialising things.
        */

        NtResumeThread(hThread, NULL);
        //NtClose(hThread);

        return TRUE;
    }
}

HANDLE CreatePnpNotifyThread(PVOID ThreadStartRoutine)
{
    CLIENT_ID   ClientId;
    HANDLE      hThread;

    hThread = NULL;

    RtlCreateUserThread(NtCurrentProcess(),
                        NULL,
                        (BOOLEAN)TRUE,
                        0,
                        0,
                        0,
                        (PUSER_THREAD_START_ROUTINE)ThreadStartRoutine,
                        NULL,
                        &hThread,
                        &ClientId);

    if (NULL == hThread)
    {
#if DBG
        OutputDebugStringA("WINMM: Server failed to create PnpNotify thread\n");
#endif
        return FALSE;

    } else {
        HMODULE hModCSR;
        ADD_SERVER_THREAD pCsrAddStaticServerThread;

        hModCSR = GetModuleHandleW((LPCWSTR)L"csrsrv.dll");

#if DBG
        if (NULL == hModCSR)
        {
            OutputDebugStringA("WINMM: Could not get CSRSRV.DLL handle");
            DebugBreak();
        }
#endif

        pCsrAddStaticServerThread =
            (ADD_SERVER_THREAD)GetProcAddress(hModCSR, "CsrAddStaticServerThread");

        if (pCsrAddStaticServerThread == NULL) {
#if DBG
            OutputDebugStringA("WINMM: Could not get address if CsrAddStaticServerThread\n");
            DebugBreak();
#endif
            return FALSE;
        }

        (*pCsrAddStaticServerThread)(hThread, &ClientId, 0);

        /*
        * Resume the sound thread now that we've initialising things.
        */

        NtResumeThread(hThread, NULL);
        //NtClose(hThread);

        return hThread;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\clinit.c ===
/****************************** Module Header ******************************\
* Module Name: clinit.c
*
* Copyright (c) 1985-1992 Microsoft Corporation
*
* This module contains all the client/server init code for MMSNDSRVL.
*
* History:
* 1 May 92 SteveDav     Pinched from USER
\***************************************************************************/

#ifndef DOSWIN32
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrdll.h>

#include "winmmi.h"
#include "mci.h"

#include <mmsndcs.h>
#include <winss.h>
#include <ntcsrmsg.h>
#endif


/***************************************************************************\
* ServerInit
*
* When WINMM is loaded by an EXE (either at EXE load or at LoadModule
* time) this routine is called by the loader.  Its purpose is to initialize
* everything that will be needed for future API calls by the app.
*
* History:
*  1 May 92 SteveDav      Pinched from USER
\***************************************************************************/

UINT fServer;   // Server Process id

BOOL ServerInit(VOID)
{

#ifndef DOSWIN32

        NTSTATUS status = 0;
        MMSNDCONNECT sndconnect;
        CSR_CALLBACK_INFO cbiCallBack;
        ULONG ulConnect = sizeof(MMSNDCONNECT);

        sndconnect.ulVersion = MMSNDCURRENTVERSION;
        sndconnect.hFileMapping = 0;
		
        cbiCallBack.ApiNumberBase = 0;
        cbiCallBack.MaxApiNumber = 0;
        cbiCallBack.CallbackDispatchTable = 0;


		dprintf3((" BEFORE   %8x >> hFileMapping",sndconnect.hFileMapping));
		dprintf4(("          %8x >> hEvent",sndconnect.hEvent));
		dprintf4(("          %8x >> hMutex",sndconnect.hMutex));

        status = CsrClientConnectToServer(WINSS_OBJECT_DIRECTORY_NAME,
                MMSNDSRV_SERVERDLL_INDEX, &cbiCallBack, &sndconnect,
                &ulConnect, (PBOOLEAN)&fServer);

        if (!NT_SUCCESS(status)) {
            dprintf2(("could not connect to sound server, status is %8x", status));
            return FALSE;
        }

		dprintf3(("AFTER     %8x = version, status is %x",sndconnect.ulCurrentVersion, status));
		dprintf3(("          %8x >> hFileMapping",sndconnect.hFileMapping));
		dprintf4(("          %8x >> hEvent",sndconnect.hEvent));
		dprintf4(("          %8x >> hMutex",sndconnect.hMutex));

		if (sndconnect.hFileMapping) {
		
            base = MapViewOfFile( sndconnect.hFileMapping, FILE_MAP_ALL_ACCESS,
							0, 0, 0);  // from beginning for total length
			if (!base) {
				DWORD n;
				n = GetLastError();
				dprintf1(("Error %d mapping file view with server handle %x", n, sndconnect.hFileMapping));
			} else {
				dprintf2(("Address %x mapping file view with server handle", base));
				hEvent = sndconnect.hEvent;
				hMutex = sndconnect.hMutex;
				hFileMapping = sndconnect.hFileMapping;
                tidNotify = base->dwGlobalThreadId;
			}
		} else {
		   dprintf1(("Server did not return a valid file mapping handle"));
		}
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\clock.c ===
/*****************************************************************************
    microclk.c

    Micro-ClockWork for MIDI subsystem

    Copyright (c) 1993-1999 Microsoft Corporation

*****************************************************************************/

#define INCL_WINMM
#include "winmmi.h"
#include "muldiv32.h"

//#define STRICT
//#include <windows.h>
//#include <windowsx.h>
//#include "mmsystem.h"
//#include "mmddk.h"
//#include "mmsysi.h"
//#include "debug.h"

//
// This stuff needs to be do-able from inside a callback.
//
#ifndef WIN32
#pragma alloc_text(FIXMIDI, clockSetRate)
#pragma alloc_text(FIXMIDI, clockTime)
#pragma alloc_text(FIXMIDI, clockOffsetTo)
#endif

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func void | clockInit | This function initializes a clock for the first
 * time. It prepares the clock for use without actually starting it.
 *
 * @parm PCLOCK | pclock | The clock to initialize.
 *
 * @parm MILLISECS | msPrev | The number of milliseconds that have passed
 * up to the time when the clock is started. This option is provided so
 * that a clock may be initialized and started in the middle of a stream
 * without actually running to that point. Normally, this will be zero.
 *
 * @parm TICKS | tkPrev | The number of ticks that have elapsed up to the
 * next time the clock starts. This should specify the same instant in
 * time as msPrev.
 *
 * @comm The clock's numerator and divisor will be set to 1 indicating that
 * the clock will run in milliseconds. Use clockSetRate before starting the
 * clock for the first time if this is not the desired rate.
 *
 ***************************************************************************/

void FAR PASCAL clockInit
(
    PCLOCK      pclock,
    MILLISECS   msPrev,
    TICKS       tkPrev,
    CLK_TIMEBASE fnTimebase
)
{
//    dprintf1(( "clockInit(%04X) %lums %lutk", pclock, msPrev, tkPrev));

    pclock->msPrev      = msPrev;
    pclock->tkPrev      = tkPrev;
    pclock->dwNum       = 1;
    pclock->dwDenom     = 1;
    pclock->dwState     = CLK_CS_PAUSED;
    pclock->msT0        = 0;
    pclock->fnTimebase  = fnTimebase;
}

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func void | clockSetRate | This functions sets a new rate for the clock.
 *
 * @parm PCLOCK | pclock | The clock to set the rate.
 *
 * @parm TICKS | tkWhen | This parameter specifies the absolute tick
 * time at which the rate change happened. This must be at or before the
 * current tick; you cannot schedule a pending rate change.
 *  @flag CLK_TK_NOW | Specify this flag if you want the rate change to
 *  happen now (this will be the time the clock was paused if it is paused
 *  now).
 *
 * @parm DWORD | dwNum | Specifies the new numerator for converting
 * milliseconds to ticks.
 *
 * @parm DWORD | dwDenom | Specifies the new denominator for converting
 * milliseconds to ticks.
 *
 * @comm The clock's state will not be changed by this call; if it is
 * paused, it will stay paused.
 *
 ***************************************************************************/

void FAR PASCAL clockSetRate
(
    PCLOCK      pclock,
    TICKS       tkWhen,
    DWORD       dwNum,
    DWORD       dwDenom
)
{
    MILLISECS   msInPrevEpoch = pclock->fnTimebase(pclock) - pclock->msT0;
    TICKS       tkInPrevEpoch;

    dprintf1(( "clockSetRate(%04X) %lutk Rate=%lu/%lu", pclock, tkWhen, dwNum, dwDenom));

    if (CLK_CS_PAUSED == pclock->dwState)
    {
        //
        // !!! Calling clockSetRate on a paused clock which has never been
        // started causes problems !!!
        //
    
        dprintf1(( "clockSetRate called when clock is paused."));
    }
    
    if (0 == dwNum || 0 == dwDenom)
    {
        dprintf1(( "Attempt to set 0 or infinite tick ratio!"));
        return;
    }

    if (CLK_TK_NOW == tkWhen)
    {
        tkInPrevEpoch = clockTime(pclock);
    }
    else
    {
        tkInPrevEpoch = tkWhen - pclock->tkPrev;
        msInPrevEpoch = muldiv32(tkInPrevEpoch, pclock->dwDenom, pclock->dwNum);
    }

    pclock->tkPrev += tkInPrevEpoch;
    pclock->msPrev += msInPrevEpoch;
    pclock->msT0   += msInPrevEpoch;

    pclock->dwNum   = dwNum;
    pclock->dwDenom = dwDenom;
}


/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func void | clockPause | This functions pauses a clock.
 *
 * @parm PCLOCK | pclock | The clock to pause.
 *
 * @parm TICKS | tkWhen | The tick time to pause the clock.
 *  @flag CLK_TK_NOW | Specify this flag if you want the rate change to
 *  happen now (this will be the time the clock was paused if it is paused
 *  now).
 *
 * @comm If the clock is already paused, this call will have no effect.
 *
 ***************************************************************************/

void FAR PASCAL clockPause
(
    PCLOCK      pclock,
    TICKS       tkWhen
)
{
    MILLISECS   msNow = pclock->fnTimebase(pclock) - pclock->msT0;
    TICKS       tkNow;

//    dprintf1(( "clockPause(%04X) %lutk", pclock, tkWhen));

    if (CLK_CS_PAUSED == pclock->dwState)
    {
        dprintf1(( "Pause already paused clock!"));
        return;
    }

    //
    // Start a new epoch at the same rate. Then start will just have to
    // change the state and set a new T0.
    //
    if (CLK_TK_NOW == tkWhen)
    {
        tkNow = pclock->tkPrev +
                muldiv32(msNow, pclock->dwNum, pclock->dwDenom);
    }
    else
    {
        msNow = muldiv32(tkWhen - pclock->tkPrev, pclock->dwDenom, pclock->dwNum);
        tkNow = tkWhen;
    }

    pclock->dwState = CLK_CS_PAUSED;
    pclock->msPrev  += msNow;
    pclock->tkPrev  = tkNow;
}

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func void | clockRestart | This functions starts a paused clock.
 *
 * @parm PCLOCK | pclock | The clock to start.
 *
 * @comm If the clock is already running, this call will have no effect.
 *
 ***************************************************************************/

void FAR PASCAL clockRestart
(
    PCLOCK      pclock,
    TICKS       tkWhen,                     // What time it is now
    MILLISECS   msWhen                      // Offset for fnTimebase()
)
{
    MILLISECS   msDelta;

//    dprintf1(( "clockRestart(%04X)", pclock));

    if (CLK_CS_RUNNING == pclock->dwState)
    {
        dprintf1(( "Start already running clock!"));
        return;
    }

    // We've been given what tick time the clock SHOULD be at. Adjust the
    // clock to match this. We need to add the equivalent number of ms
    // into msPrev
    //
    msDelta = muldiv32(tkWhen - pclock->tkPrev, pclock->dwDenom, pclock->dwNum);

    dprintf1(( "clockRestart: Was tick %lu, now %lu, added %lu ms", pclock->tkPrev, tkWhen, msDelta));

    pclock->tkPrev  = tkWhen;
    pclock->msPrev += msDelta;
    pclock->dwState = CLK_CS_RUNNING;
    pclock->msT0    = msWhen;
}

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func DWORD | clockTime | This function returns the current absolute tick
 * time.
 *
 * @parm PCLOCK | pclock | The clock to read.
 *
 * @rdesc The current time.
 *
 * @comm If the clock is paused, the returned time will be the time the
 * clock was paused.
 *
 ***************************************************************************/

TICKS FAR PASCAL clockTime
(
    PCLOCK      pclock
)
{
    MILLISECS   msNow;
    TICKS       tkNow;
    TICKS       tkDelta;

    msNow = pclock->fnTimebase(pclock) - pclock->msT0;
    tkNow = pclock->tkPrev;

    if (CLK_CS_RUNNING == pclock->dwState)
    {
        tkDelta = muldiv32(msNow, pclock->dwNum, pclock->dwDenom);
        tkNow += tkDelta;
    }

//  dprintf1(( "clockTime() timeGetTime() %lu msT0 %lu", (MILLISECS)pclock->fnTimebase(pclock), pclock->msT0));
//  dprintf1(( "clockTime() tkPrev %lutk msNow %lums dwNum %lu dwDenom %lu tkDelta %lutk", pclock->tkPrev, msNow, pclock->dwNum, pclock->dwDenom, tkDelta));
//  dprintf1(( "clockTime(%04X) -> %lutk", pclock, tkNow));
    return tkNow;
}

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func DWORD | clockMsTime | This function returns the current absolute
 * millisecond time.
 *
 * @parm PCLOCK | pclock | The clock to read.
 *
 * @rdesc The current time.
 *
 * @comm If the clock is paused, the returned time will be the time the
 * clock was paused.
 *
 ***************************************************************************/

MILLISECS FAR PASCAL clockMsTime
(
    PCLOCK      pclock
)
{
    MILLISECS   msNow = pclock->fnTimebase(pclock) - pclock->msT0;
    MILLISECS   msRet;

    msRet = pclock->msPrev;

    if (CLK_CS_RUNNING == pclock->dwState)
    {
        msRet += msNow;
    }

//    dprintf1(( "clockMsTime(%04X) -> %lums", pclock, msRet));
    return msRet;
}

/****************************************************************************
 * @doc INTERNAL  CLOCK
 *
 * @func DWORD | clockOffsetTo | This function determines the number
 * of milliseconds in the future that a given tick time will occur,
 * assuming the clock runs continously and monotonically until then.
 *
 * @parm PCLOCK | pclock | The clock to read.
 *
 * @parm TICKS | tkWhen | The tick value to calculate the offset to.
 *
 * @rdesc The number of milliseconds until the desired time. If the time
 * has already passed, 0 will be returned. If the clock is paused,
 * the largest possible value will be returned ((DWORD)-1L).
 *
 ***************************************************************************/

MILLISECS FAR PASCAL clockOffsetTo
(
    PCLOCK      pclock,
    TICKS       tkWhen
)
{
    TICKS       tkOffset;
    MILLISECS   msOffset;

    if (CLK_CS_PAUSED == pclock->dwState)
    {
        msOffset = (MILLISECS)-1L;
    }
    else
    {
        tkOffset = clockTime(pclock);
        if (tkOffset >= tkWhen)
        {
            msOffset = 0;
        }
        else
        {
            msOffset = muldiv32(tkWhen-tkOffset, pclock->dwDenom, pclock->dwNum);
        }
    }

//    dprintf1(( "clockOffsetTo(%04X, %lutk)@%lutk -> %lums", pclock, tkWhen, tkOffset, msOffset));

    return msOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\drvr.h ===
/******************************************************************************

   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   drvr.h - Installable driver code internal header file.

   Version: 1.00

   Date:    10-Jun-1990

   Author:  DAVIDDS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   -----   -----------------------------------------------------------
   10-JUN-1990   ROBWI   Based on windows 3.1 installable driver code by davidds
   28-FEB-1992   ROBINSP Port to NT

*****************************************************************************/

typedef LRESULT (*DRIVERPROC)
        (DWORD_PTR dwDriverID, HDRVR hDriver, UINT wMessage, LPARAM lParam1, LPARAM lParam2);

#define DRIVER_PROC_NAME "DriverProc"

#if 0
extern BOOL                     fUseWinAPI;
#else
    #define fUseWinAPI FALSE
#endif

typedef struct tagDRIVERTABLE
{
  UINT          fFirstEntry:1;
  UINT          fBusy:1;
  DWORD_PTR     dwDriverIdentifier;
  DWORD_PTR     hModule;
  DRIVERPROC    lpDriverEntryPoint;
} DRIVERTABLE;
typedef DRIVERTABLE FAR *LPDRIVERTABLE;

LRESULT FAR PASCAL InternalBroadcastDriverMessage(UINT, UINT, LPARAM, LPARAM, UINT);
LRESULT FAR PASCAL InternalCloseDriver(UINT, LPARAM, LPARAM, BOOL);
LRESULT FAR PASCAL InternalOpenDriver(LPCWSTR, LPCWSTR, LPARAM, BOOL);
LRESULT FAR PASCAL InternalLoadDriver(LPCWSTR, LPCWSTR, LPWSTR, UINT, BOOL);
UINT FAR PASCAL InternalFreeDriver(UINT, BOOL);
void FAR PASCAL InternalInstallDriverChain (void);
void FAR PASCAL InternalDriverDisable (void);
void FAR PASCAL InternalDriverEnable (void);
int  FAR PASCAL GetDrvrUsage(HANDLE);
HANDLE FAR PASCAL LoadAliasedLibrary (LPCWSTR, LPCWSTR, LPWSTR, LPWSTR, UINT);

/* Defines for internalbroadcastdrivermessage flags */
#define IBDM_SENDMESSAGE       0x0001
#define IBDM_REVERSE           0x0002
#define IBDM_ONEINSTANCEONLY   0x0004

/* Multi-thread protection for OpenDriver etc */
#define DrvEnter() EnterCriticalSection(&DriverListCritSec)
#define DrvLeave() LeaveCriticalSection(&DriverListCritSec)

/*
 *  DriverListCritSec keeps our handling of the driver list and count
 *  protected
 *
 *  DriverLoadFreeCritSec keeps our loads and frees from overlapping
 */

extern CRITICAL_SECTION DriverListCritSec;
extern CRITICAL_SECTION DriverLoadFreeCritSec;

#define REGSTR_PATH_WAVEMAPPER  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Wave Mapper")
#define REGSTR_VALUE_MAPPABLE   TEXT("Mappable")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\debug.c ===
/****************************************************************************
    debug.c

    winmm debug support module

    Copyright (c) 1990-2001 Microsoft Corporation

    History
        10/1/92  Updated for NT by Robin Speed (RobinSp)
****************************************************************************/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "winmmi.h"
#include <wchar.h>
#include <stdarg.h>

// no REAL logging for now ! - NT doesn't have Dr Watson !
#define LogParamError(a, b)

RTL_RESOURCE     gHandleListResource;

/***************************************************************************
 * @doc INTERNAL
 *
 * @func HANDLE | NewHandle | allocate a fixed handle in MMSYSTEM's local heap
 *
 * @parm  UINT | uType | unique id describing handle type
 * @parm  UINT | uSize | size in bytes to be allocated
 *
 * @rdesc Returns pointer/handle to memory object
 *
 * @comm a standard handle header (HNDL) will be added to the object,
 *       and it will be linked into the list of MMSYSTEM handles.
 *
 ***************************************************************************/
HANDLE NewHandle(UINT uType, PCWSTR cookie, UINT uSize)
{
    PHNDL pHandle;
    pHandle = (PHNDL)HeapAlloc(hHeap, 0, sizeof(HNDL) + uSize);

    if (pHandle == NULL) {
        return pHandle;
    } else {
        ZeroMemory(pHandle, sizeof(HNDL) + uSize);   // zero the whole bludy lot
        if (!mmInitializeCriticalSection(&pHandle->CritSec)) {
	        HeapFree(hHeap, 0, (LPSTR)pHandle);
	        return NULL;
        }

        pHandle->hThread   = GetCurrentTask();        // For WOW validation
        pHandle->uType     = uType;
        pHandle->cookie    = cookie;

        RtlAcquireResourceExclusive(&gHandleListResource, TRUE);
        EnterCriticalSection(&HandleListCritSec);
        pHandle->pNext = pHandleList;
        pHandleList = pHandle;
        LeaveCriticalSection(&HandleListCritSec);
    }
    return PHtoH(pHandle);
}

void AcquireHandleListResourceShared()
{
    RtlAcquireResourceShared(&gHandleListResource, TRUE);
}

void AcquireHandleListResourceExclusive()
{
    RtlAcquireResourceExclusive(&gHandleListResource, TRUE);
}    

void ReleaseHandleListResource()
{
    RtlReleaseResource(&gHandleListResource);
}    

/***************************************************************************
 * @doc INTERNAL
 *
 * @func HANDLE | FreeHandle | free handle allocated with NewHandle
 *
 * @parm HANDLE | hUser | handle returned from NewHandle
 *
 * @comm handle will be unlinked from list, and memory will be freed
 *
 *
 ***************************************************************************/

void FreeHandle(HANDLE hUser)
{
    /* Find handle and free from list */

    PHNDL pHandle;
    PHNDL *pSearch;

    if (hUser == NULL) {
        return;
    }

    //
    // Point to our handle data
    //

    pHandle = HtoPH(hUser);

    AcquireHandleListResourceExclusive();
    EnterCriticalSection(&HandleListCritSec);

    pSearch = &pHandleList;

    while (*pSearch != NULL) {
        if (*pSearch == pHandle) {
            //
            // Found it
            // Remove it from the list
            //
            *pSearch = pHandle->pNext;
            LeaveCriticalSection(&HandleListCritSec);
            
            //  Making sure no one is using the handle while we mark it as invalid.
            EnterCriticalSection(&pHandle->CritSec);
            pHandle->uType = 0;
            pHandle->fdwHandle = 0L;
            pHandle->hThread = NULL;
            pHandle->pNext = NULL;
            LeaveCriticalSection(&pHandle->CritSec);

            DeleteCriticalSection(&pHandle->CritSec);
            HeapFree(hHeap, 0, (LPSTR)pHandle);
            ReleaseHandleListResource();
            return;
        } else {
            pSearch = &(*pSearch)->pNext;
        }
    }

    dprintf1(("Freeing handle which is not in the list !"));
    WinAssert(FALSE);
    LeaveCriticalSection(&HandleListCritSec);
    ReleaseHandleListResource();
}


/***************************************************************************
 * @doc INTERNAL
 *
 * @func HANDLE | InvalidateHandle | invalidate handle allocated with
 *          NewHandle for parameter validation
 *
 * @parm HANDLE | hUser | handle returned from NewHandle
 *
 * @comm handle will be marked as TYPE_UNKNOWN, causing handle based API's to
 *          fail.
 *
 *
 ***************************************************************************/

void InvalidateHandle(HANDLE hUser)
{
    /* Find handle and free from list */

    PHNDL pHandle;

    if (hUser == NULL) {
        return;
    }

    //
    // Point to our handle data
    //

    pHandle = HtoPH(hUser);

    pHandle->uType = TYPE_UNKNOWN;
}


/**************************************************************************

    @doc INTERNAL

    @api void | winmmSetDebugLevel | Set the current debug level

    @parm int | iLevel | The new level to set

    @rdesc There is no return value

**************************************************************************/

void winmmSetDebugLevel(int level)
{
#if DBG
    winmmDebugLevel = level;
    dprintf(("debug level set to %d", winmmDebugLevel));
#endif
}

STATICDT UINT inited=0;

#if DBG
extern int mciDebugLevel;
#endif

#if DBG
void InitDebugLevel(void)
{
    if (!inited) {

        INT level;

        level = GetProfileInt("MMDEBUG", "WINMM", 99);
        if (level != 99) {
            winmmDebugLevel = level;
        }

        level = GetProfileInt("MMDEBUG", "MCI", 99);
        if (level != 99) {
            mciDebugLevel = level;
        }

        inited = 1;
    }
    dprintf2(("Starting, debug level=%d", winmmDebugLevel));
}
#endif

#ifdef DEBUG_RETAIL

/***************************************************************************
 * @doc INTERNAL WAVE MIDI
 *
 * @func BOOL | ValidateHeader | validates a wave or midi date header
 *
 * @parm LPVOID | lpHeader| pointer to wave/midi header
 * @parm  UINT  | wSize  | size of header passed by app
 * @parm  UINT  | wType  | unique id describing header/handle type
 *
 * @rdesc Returns TRUE  if <p> is non NULL and <wSize> is the correct size
 *        Returns FALSE otherwise
 *
 * @comm  if the header is invalid an error will be generated.
 *
 ***************************************************************************/

BOOL ValidateHeader(PVOID pHdr, UINT uSize, UINT uType)
{
    // Detect bad header

    if (!ValidateWritePointer(pHdr, uSize)) {
        DebugErr(DBF_ERROR, "Invalid header pointer");
        return FALSE;
    }

    // Check type

    switch (uType) {
    case TYPE_WAVEOUT:
    case TYPE_WAVEIN:
        {
            PWAVEHDR pHeader = pHdr;

            // Check header
            if (uSize < sizeof(WAVEHDR)) {
                DebugErr(DBF_ERROR, "Invalid header size");
                LogParamError(ERR_BAD_VALUE, uSize);
                return FALSE;
            }

            if (pHeader->dwFlags & ~WHDR_VALID) {
                LogParamError(ERR_BAD_FLAGS, ((PWAVEHDR)pHeader)->dwFlags);
                return FALSE;
            }

            // Check buffer
            if (!(uType == TYPE_WAVEOUT
                    ? ValidateReadPointer(pHeader->lpData, pHeader->dwBufferLength)
                    : ValidateWritePointer(pHeader->lpData, pHeader->dwBufferLength))
               ) {
                DebugErr(DBF_ERROR, "Invalid buffer pointer");
                return FALSE;
            }
        }
        break;

    case TYPE_MIDIIN:
	case TYPE_MIDIOUT:
	case TYPE_MIDISTRM:
        {
            PMIDIHDR pHeader = pHdr;

            if ((TYPE_MIDISTRM == uType) &&
                uSize < sizeof(MIDIHDR))
            {
                DebugErr(DBF_ERROR, "Invalid header size");
                LogParamError(ERR_BAD_VALUE, uSize);
                return FALSE;
            }
            else if (uSize < sizeof(MIDIHDR31))
            {
                DebugErr(DBF_ERROR, "Invalid header size");
                LogParamError(ERR_BAD_VALUE, uSize);
                return FALSE;
            }

            if (pHeader->dwFlags & ~MHDR_VALID) {
                LogParamError(ERR_BAD_FLAGS, ((PMIDIHDR)pHeader)->dwFlags);
                return FALSE;
            }

            // Check buffer
            if (!(uType == TYPE_MIDIOUT
                    ? ValidateReadPointer(pHeader->lpData, pHeader->dwBufferLength)
                    : ValidateWritePointer(pHeader->lpData, pHeader->dwBufferLength))
               ) {
                DebugErr(DBF_ERROR, "Invalid buffer pointer");
                return FALSE;
            }
        }
        break;

    default:
        WinAssert(FALSE);
        break;
    }

	return TRUE;
}

#ifndef USE_KERNEL_VALIDATION
/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateReadPointer | validates that a pointer is valid to
 *  read from.
 *
 * @parm LPVOID | lpPoint| pointer to validate
 * @parm DWORD  | dLen   | supposed length of said pointer
 *
 * @rdesc Returns TRUE  if <p> is a valid pointer
 *        Returns FALSE if <p> is not a valid pointer
 *
 * @comm will generate error if the pointer is invalid
 *
 ***************************************************************************/

BOOL ValidateReadPointer(PVOID pPoint, ULONG Len)
{
    // For now just check access to first and last byte
    // Only validate if Len non zero.  Midi APIs pass data in the
    // pointer and pass a length of zero.  Otherwise on 64 bit machines
    // we look 4Gigs out from the pointer when we check Len-1 and Len==0.
    // That doesn't work very well.
    if (Len) {
        try {
            volatile BYTE b;
            b = ((PBYTE)pPoint)[0];
            b = ((PBYTE)pPoint)[Len - 1];
        } except(EXCEPTION_EXECUTE_HANDLER) {
            LogParamError(ERR_BAD_PTR, pPoint);
            return FALSE;
        }
    }
    return TRUE;
}

/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateWritePointer | validates that a pointer is valid to
 *  write to.
 *
 * @parm LPVOID | lpPoint| pointer to validate
 * @parm DWORD  | dLen   | supposed length of said pointer
 *
 * @rdesc Returns TRUE  if <p> is a valid pointer
 *        Returns FALSE if <p> is not a valid pointer
 *
 * @comm will generate error if the pointer is invalid
 *
 ***************************************************************************/
BOOL ValidateWritePointer(PVOID pPoint, ULONG Len)
{
    // For now just check read and write access to first and last byte
    // Only validate if Len non zero.  Midi APIs pass data in the
    // pointer and pass a length of zero.  Otherwise on 64 bit machines
    // we look 4Gigs out from the pointer when we check Len-1 and Len==0.
    // That doesn't work very well.
    if (Len) {
        try {
               volatile BYTE b;
               b = ((PBYTE)pPoint)[0];
               ((PBYTE)pPoint)[0] = b;
               b = ((PBYTE)pPoint)[Len - 1];
               ((PBYTE)pPoint)[Len - 1] = b;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            LogParamError(ERR_BAD_PTR, pPoint);
            return FALSE;
        }
    }
    return TRUE;
}
#endif // USE_KERNEL_VALIDATION

/***************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidDriverCallback |
 *
 *  validates that a driver callback is valid, to be valid a driver
 *  callback must be a valid window, task, or a function in a FIXED DLL
 *  code segment.
 *
 * @parm DWORD  | dwCallback | callback to validate
 * @parm DWORD  | wFlags     | driver callback flags
 *
 * @rdesc Returns 0  if <dwCallback> is a valid callback
 *        Returns error condition if <dwCallback> is not a valid callback
 ***************************************************************************/

BOOL ValidDriverCallback(HANDLE hCallback, DWORD dwFlags)
{
    switch (dwFlags & DCB_TYPEMASK) {
    case DCB_WINDOW:
        if (!IsWindow(hCallback)) {
            LogParamError(ERR_BAD_HWND, hCallback);
            return FALSE;
        }
        break;

    case DCB_EVENT:
        //if (hCallback is not an event)
        //    LogParamError(ERR_BAD_CALLBACK, hCallback);
        //    return FALSE;
        //}
        break;


    case DCB_TASK:
        //if (IsBadCodePtr((FARPROC)hCallback)) {
        //    LogParamError(ERR_BAD_CALLBACK, hCallback);
        //    return FALSE;
        //}
        break;

    case DCB_FUNCTION:
        if (IsBadCodePtr((FARPROC)hCallback)) {
            LogParamError(ERR_BAD_CALLBACK, hCallback);
            return FALSE;
        }
        break;
    }

    return TRUE;
}

#ifndef USE_KERNEL_VALIDATION
/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateString |
 *
 **************************************************************************/
BOOL ValidateString(LPCSTR pPoint, DWORD Len)
{
    // For now just check access - do a 'strnlen'

    try {
           volatile BYTE b;
           LPCSTR p = pPoint;

           while (Len--) {
               b = *p;
               if (!b) {
                   break;
               }
               p++;
           }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_STRING_PTR, pPoint);
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateStringW |
 *
 **************************************************************************/
BOOL ValidateStringW(LPCWSTR pPoint, DWORD Len)
{
    // For now just check access - do a 'strnlen'

    try {
           volatile WCHAR b;
           LPCWSTR p = pPoint;

           while (Len--) {
               b = *p;
               if (!b) {
                   break;
               }
               p++;
           }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        LogParamError(ERR_BAD_STRING_PTR, pPoint);
        return FALSE;
    }
    return TRUE;
}
#endif //USE_KERNEL_VALIDATION

/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateHandle | validates a handle created with NewHandle
 *
 * @parm PHNDL | hLocal | handle returned from NewHandle
 * @parm UINT  | wType  | unique id describing handle type
 *
 * @rdesc Returns TRUE  if <h> is a valid handle of type <wType>
 *        Returns FALSE if <h> is not a valid handle
 *
 * @comm  if the handle is invalid an error will be generated.
 *
 **************************************************************************/
BOOL ValidateHandle(HANDLE hLocal, UINT uType)

{
   BOOL OK;

   //
   //  if the handle is less than 64k or a mapper id then
   //  don't bother with the overhead of the try-except.
   //
   //  BUGBUG:  MM needs to be audited for WIN64!
   //
   //  This code is a mess.  The mapper ids are defined as 32-bit
   //  unsigned values and then compared against a HANDLE?  Of course
   //  an unsigned 32-bit -1 will never equal a 64-bit -1 so on WIN64,
   //  an exception is taken everytime an invalid handle is passed in.
   //  Someone hacked in enough coercions to mask valid warnings for WIN64.
   //  Even worse, there is at least one function that returns 0xffffffff
   //  explicity versus a define or const value.
   //
   //  For now, change the const compare to a handle compare and add an
   //  invalid handle compare.  This results in the same code on x86 as
   //  before (the compiler folds all of the redundant compares), and doesn't
   //  increase the codesize for IA64 (parallel compares are used) even though
   //  the extra compare for WIN64 is useless.
   //
   if (hLocal < (HANDLE)0x10000 ||
       INVALID_HANDLE_VALUE == hLocal ||
       WAVE_MAPPER == (UINT_PTR)hLocal ||
       MIDI_MAPPER == (UINT_PTR)hLocal ||
       AUX_MAPPER  == (UINT_PTR)hLocal)
   {
       LogParamError(ERR_BAD_HANDLE, hLocal);
       return FALSE;
   }

   try {
       OK = HtoPH(hLocal)->uType == uType;

    } except(EXCEPTION_EXECUTE_HANDLER) {
      LogParamError(ERR_BAD_HANDLE, hLocal);
      return FALSE;
   }

   return OK;
}


#if DBG
char * Types[4] = {"Unknown callback type",
                   "Window callback",
                   "Task callback",
                   "Function callback"};
#endif
/**************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | ValidateCallbackType | validates a callback address,
 *              window handle, or task handle
 *
 * @parm PHNDL | hLocal | handle returned from NewHandle
 * @parm UINT  | wType  | unique id describing handle type
 *
 * @rdesc Returns TRUE  if <h> is a valid handle of type <wType>
 *        Returns FALSE if <h> is not a valid handle
 *
 * @comm  if the handle is invalid an error will be generated.
 *
 **************************************************************************/
BOOL ValidateCallbackType(DWORD_PTR dwCallback, UINT uType)
{

#define DCALLBACK_WINDOW   HIWORD(CALLBACK_WINDOW)      // dwCallback is a HWND
#define DCALLBACK_TASK     HIWORD(CALLBACK_TASK)        // dwCallback is a HTASK
#define DCALLBACK_FUNCTION HIWORD(CALLBACK_FUNCTION)    // dwCallback is a FARPROC
#define DCALLBACK_EVENT    HIWORD(CALLBACK_EVENT)       // dwCallback is an EVENT

    UINT type = uType & HIWORD(CALLBACK_TYPEMASK);

#if DBG
    if (type>5) {
        type = 0;
    }
    dprintf3(("Validating Callback, type=%d (%hs), handle=%8x", type, Types[type], dwCallback));
#endif
    switch (type) {
        case DCALLBACK_WINDOW:
            return(IsWindow((HWND)dwCallback));
            break;

	case DCALLBACK_EVENT:
	{
	    // ?? how to verify that this is an event handle??
	    //DWORD dwFlags;
	    //GetHandleInformation((HANDLE)dwCallback, &dwFlags);
            return TRUE;
	}
            break;

        case DCALLBACK_FUNCTION:
            return(!(IsBadCodePtr((FARPROC)dwCallback)));
            break;

        case DCALLBACK_TASK:
            if (THREAD_PRIORITY_ERROR_RETURN == GetThreadPriority((HANDLE)dwCallback)) {
                dprintf1(("Invalid callback task handle"));
                // I suspect we do not have the correct thread handle, in
                // which case we can only return TRUE.
                //return(FALSE);
            }
            return(TRUE);
            break;

    }
    return TRUE;
}

/**************************************************************************
   @doc INTERNAL

   @func void | dout | Output debug string if debug flag is set

   @parm LPSTR | szString
 **************************************************************************/

#if DBG
int fDebug = 1;
#else
int fDebug = 0;
#endif

//void dout(LPSTR szString)
//{
//    if (fDebug) {
//        OutputDebugStringA(szString);
//    }
//}

#ifdef LATER

    This routine should probably be replaced in the headers by redefining
    to use OutputDebugString

#endif

#undef OutputDebugStr
// Make our function visible
/*****************************************************************************
*   @doc EXTERNAL DDK
*
*   @api void | OutputDebugStr | This function sends a debugging message
*      directly to the COM1 port or to a secondary monochrome display
*      adapter. Because it bypasses DOS, it can be called by low-level
*      callback functions and other code at interrupt time.
*
*   @parm LPSTR | lpOutputString | Specifies a far pointer to a
*      null-terminated string.
*
*   @comm This function is available only in the debugging version of
*      Windows. The DebugOutput keyname in the [mmsystem]
*      section of SYSTEM.INI controls where the debugging information is
*      sent. If fDebugOutput is 0, all debug output is disabled.
******************************************************************************/

/*****************************************************************************
 *   This function is basicly the same as OutputDebugString() in KERNEL.
 *
 *
 *   DESCRIPTION:    outputs a string to the debugger
 *
 *   ENTRY:          szString - string to output
 *
 *   EXIT:
 *       none
 *   USES:
 *       flags
 *
 *****************************************************************************/

VOID APIENTRY OutputDebugStr(LPCSTR szString)
{
    OutputDebugStringA((LPSTR)szString);  // Will always be an ASCII string
    // When the MM WOW thunk is changed to call OutputDebugString directly
    // we can remove this routine from our code
}

#endif // DEBUG_RETAIL


#if DBG

int winmmDebugLevel = 0;

/***************************************************************************

    @doc INTERNAL

    @api void | winmmDbgOut | This function sends output to the current
        debug output device.

    @parm LPSTR | lpszFormat | Pointer to a printf style format string.
    @parm ??? | ... | Args.

    @rdesc There is no return value.

****************************************************************************/
extern BOOL Quiet = FALSE;

void winmmDbgOut(LPSTR lpszFormat, ...)

{
    char buf[512];
    UINT n;
    va_list va;

    if (Quiet) {
        return;
    }

    n = wsprintf(buf, "WINMM(p%d:t%d): ", GetCurrentProcessId(), GetCurrentThreadId());

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugString(buf);
    Sleep(0);  // let terminal catch up
}

/***************************************************************************

    @doc INTERNAL

    @api void | dDbgAssert | This function prints an assertion message.

    @parm LPSTR | exp | Pointer to the expression string.
    @parm LPSTR | file | Pointer to the file name.
    @parm int | line | The line number.

    @rdesc There is no return value.

****************************************************************************/

void dDbgAssert(LPSTR exp, LPSTR file, int line)
{
    dprintf(("Assertion failure:"));
    dprintf(("  Exp: %s", exp));
    dprintf(("  File: %s, line: %d", file, line));
    DebugBreak();
}
#else  // Still need to export this thing to help others
void winmmDbgOut(LPSTR lpszFormat, ...)
{
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\drvrrare.c ===
/******************************************************************************

   Copyright (c) 1985-1998 Microsoft Corporation

   Title:   drvrrare.c - Installable driver code. Less common code

   Version: 1.00

   Date:    10-Jun-1990

   Author:  DAVIDDS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   -----   -----------------------------------------------------------
   28-FEB-1992   ROBINSP Port to NT
   23-Apr-1992   StephenE   Unicoded
   22-Apr-1993   RobinSp Add NT multithread protection

Multithread design :

   Uses 2 critical sections :

   DriverListCritSec :

      protects the list of drivers :

          hInstalledDriverList  - handle of global driver list
          cInstalledDrivers	- high water mark of installed drivers

      so that only 1 thread at a time has the list locked and can refer
      to or update it.

   DriverLoadFreeCritSec

      Makes sure that actual loads and frees of drivers don't overlap
      and that the actual loading of a driver via LoadLibrary coincides
      with its first message being DRV_LOAD.

      This can easily happen if the DRV_OPEN from another thread can get
      in before the DRV_LOAD has been sent.


*****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define MMNOSOUND
#define MMNOWAVE
#define MMNOMIDI
#define MMNOSEQ
#define MMNOTIMER
#define MMNOJOY
#define MMNOMCI
#define NOTIMERDEV
#define NOJOYDEV
#define NOMCIDEV
#define NOSEQDEV
#define NOWAVEDEV
#define NOMIDIDEV
#define NOTASKDEV
#include <winmmi.h>
#include "drvr.h"

extern HANDLE  hInstalledDriverList;  // List of installed driver instances
extern int     cInstalledDrivers;     // High water count of installed driver instances

extern DWORD FAR PASCAL DriverProc(DWORD dwID, HDRVR hdrv, UINT msg, DWORD dw1, DWORD dw2);

/* Support for using 3.1 APIs if available */

typedef HANDLE (FAR PASCAL *OPENDRIVER31)(LPCSTR, LPCSTR, LPARAM);
typedef LONG   (FAR PASCAL *CLOSEDRIVER31)(HANDLE, LPARAM, LPARAM);
typedef HANDLE (FAR PASCAL *GETDRIVERMODULEHANDLE31)(HANDLE);
typedef LONG   (FAR PASCAL *SENDDRIVERMESSAGE31)(HANDLE, UINT, LPARAM, LPARAM);
typedef LONG   (FAR PASCAL *DEFDRIVERPROC31)(DWORD, HANDLE, UINT, LPARAM, LPARAM);

OPENDRIVER31            lpOpenDriver;
CLOSEDRIVER31           lpCloseDriver;
GETDRIVERMODULEHANDLE31 lpGetDriverModuleHandle;
SENDDRIVERMESSAGE31     lpSendDriverMessage;
DEFDRIVERPROC31         lpDefDriverProc;
#if 0
BOOL                    fUseWinAPI = 0;
                    // NOTE:  fUseWinAPI is not being used at present
                    // as we only have a partial device loading story
#endif

/***************************************************************************

   strings

****************************************************************************/

#if 0
extern char far szBoot[];
extern char far szUser[];
extern char far szOpenDriver[];
extern char far szCloseDriver[];
extern char far szDrvModuleHandle[];
extern char far szSendDriverMessage[];
extern char far szDefDriverProc[];
extern char far szDriverProc[];
#endif

/***************************************************************************
 *
 * @doc   DDK
 *
 * @api   LONG | DrvClose | This function closes an open driver
 *        instance and decrements
 *        the driver's open count. Once the driver's open count becomes zero,
 *        the driver is unloaded.
 *
 * @parm  HANDLE | hDriver | Specifies the handle of the installable
 *        driver to close.
 *
 * @parm  LPARAM | lParam1 | Specifies the first message parameter for
 *        the DRV_CLOSE message. This data is passed directly to the driver.
 *
 * @parm  LPARAM | lParam2 | Specifies the second message parameter
 *        for DRV_CLOSE message. This data is passed directly to the driver.
 *
 * @rdesc Returns zero if the driver aborted the close;
 *        otherwise, returns the return result from the driver.

 * @xref DrvOpen
 *
 ***************************************************************************/


LRESULT APIENTRY DrvClose(HANDLE hDriver, LPARAM lParam1, LPARAM lParam2)
{
    /*  The driver will receive the following message sequence:
     *
     *      DRV_CLOSE
     *      if DRV_CLOSE returns non-zero
     *          if driver usage count = 1
     *              DRV_DISABLE
     *              DRV_FREE
     */

    if (fUseWinAPI)
       return ((*lpCloseDriver)(hDriver, lParam1, lParam2));
    else
       return InternalCloseDriver((UINT)(UINT_PTR)hDriver, lParam1, lParam2, TRUE);
}

/***************************************************************************
 *
 * @doc   DDK
 *
 * @api   LONG | DrvOpen | This function opens an installable driver.
 *        The first time a driver is opened it is loaded
 *        and enabled. A driver must be opened before messages are sent
 *        to it.
 *
 * @parm  LPSTR | szDriverName | Specifies a far pointer to a
 *        null-terminated character string
 *        containing a driver filename or a keyname from a
 *        section of the SYSTEM.INI file.
 *
 * @parm  LPSTR | szSectionName | Specifies a far pointer to a
 *        null-terminated character string containing the name of
 *        the driver section to search. If <p szSectionName> is
 *        not null, the specified section of the SYSTEM.INI file is
 *        searched instead of the [Drivers] section. If
 *        <p szSectionName> is null, the default [Drivers] section is used.
 *
 * @parm  LPARAM | lParam | Specifies a message parameter to
 *        pass to the driver procedure with the <m DRV_OPEN> message.
 *
 * @rdesc Returns a handle to the driver.
 *
 * @comm Installable drivers must export a <f DriverProc> routine of
 *        the form:
 *
 * @cb   LONG FAR PASCAL | DriverProc | This entry point receives the
 * messages sent to an installable driver. This entry will always
 * handle the system messages as a minimum set of messages.
 *
 * @parm DWORD | dwDriverIdentifier | Specifies the device driver
 *       identifier.
 *
 * @parm HANDLE | hDriver | Specifies the device driver handle.
 *
 * @parm UINT | wMessage | Specifies the message for the device
 *       driver.
 *
 * @parm LONG | lParm1 | Specifies message dependent data.
 *
 * @parm LONG | lParm2 | Specifies message dependent data.
 *
 * @xref DrvClose
 *
****************************************************************************/

HANDLE APIENTRY DrvOpen( LPCWSTR    szDriverName,
                         LPCWSTR    szSectionName,
                         LPARAM     lParam2)
{
    /*  The driver will receive the following message sequence:
     *
     *      if driver not loaded and can be found
     *          DRV_LOAD
     *          if DRV_LOAD returns non-zero
     *              DRV_ENABLE
     *      if driver loaded correctly
     *          DRV_OPEN
     */

    HDRVR hdrv;

    if (fUseWinAPI) {

        /*------------------------------------------------------------*\
         * UNICODE: convert szDriver and szSectionName to ascii
         * and then call WIN31 driver
        \*------------------------------------------------------------*/
        LPSTR   aszDriver;
        LPSTR   aszSectionName;
        INT     lenD;
        INT     lenS;

        lenD = lstrlenW( szDriverName ) * sizeof( WCHAR ) + sizeof( WCHAR );
        aszDriver = HeapAlloc( hHeap, 0, lenD );
        if ( aszDriver == (LPSTR)NULL ) {
            return NULL;
        }

        lenS = lstrlenW( szSectionName ) * sizeof( WCHAR ) + sizeof( WCHAR );
        aszSectionName = HeapAlloc( hHeap, 0, lenS );
        if ( aszSectionName == (LPSTR)NULL ) {
            HeapFree( hHeap, 0, aszDriver );
            return NULL;
        }

        // Unicode to Ascii
        UnicodeStrToAsciiStr( (PBYTE)aszDriver,
                              (PBYTE)aszDriver + lenD,
                              szDriverName );

        UnicodeStrToAsciiStr( (PBYTE)aszSectionName,
                              (PBYTE)aszSectionName + lenS,
                              szSectionName );

        hdrv = (HDRVR)((*lpOpenDriver)( aszDriver, aszSectionName, lParam2 ));

        HeapFree( hHeap, 0, aszDriver );
        HeapFree( hHeap, 0, aszSectionName );

    }
    else {
        dprintf2(("DrvOpen(%ls), Looking in Win.ini [%ls]", szDriverName, szSectionName ? szSectionName : L"NULL !!" ));

        hdrv = (HDRVR)InternalOpenDriver(szDriverName, szSectionName, lParam2, TRUE);
    }

#if DBG
    if (hdrv) {
        WCHAR            ach[255];
        static SZCODE   szFormat[] = "DrvOpen(): Opened %ls (%ls)\r\n";

        GetModuleFileNameW( DrvGetModuleHandle( hdrv ),
                            ach,
                            sizeof(ach) / sizeof(WCHAR)
                          );
        dprintf2((szFormat, szDriverName, ach));
    }
#endif

    return (HANDLE)hdrv;
}

/***************************************************************************
 *
 * @doc   DDK
 *
 * @api   HANDLE | DrvGetModuleHandle | This function returns the library
 *        module handle of the specified installable driver.
 *
 * @parm  HANDLE | hDriver | Specifies the handle of the installable driver.
 *
 * @rdesc Returns the module handle of the driver specified by the
 *        driver handle <p hDriver>.
 *
 * @comm  A module handle is not the same as an installable driver handle.
 *
 ***************************************************************************/

HMODULE APIENTRY DrvGetModuleHandle(HDRVR hDriver)
{
    LPDRIVERTABLE lpdt;
    HMODULE       h = 0;

    if (fUseWinAPI)
        return ((*lpGetDriverModuleHandle)(hDriver));

    DrvEnter();
    if (hDriver && ((int)(UINT_PTR)hDriver <= cInstalledDrivers))
    {
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
        h = (HMODULE)lpdt[(UINT)(UINT_PTR)hDriver-1].hModule;
        GlobalUnlock(hInstalledDriverList);
    }
    DrvLeave();

    return(h);
}


LRESULT FAR PASCAL InternalCloseDriver(UINT   hDriver,
                                    LPARAM lParam1,
                                    LPARAM lParam2,
                                    BOOL   fSendDisable)
{
    LRESULT       result;

    // check handle in valid range.

    DrvEnter();

    if ((int)hDriver > cInstalledDrivers) {
        DrvLeave();
        return(FALSE);
    }

    DrvLeave();

    result = DrvSendMessage((HANDLE)(UINT_PTR)hDriver, DRV_CLOSE, lParam1, lParam2);

    if (result) {
        InternalFreeDriver(hDriver, fSendDisable);
    }

    return(result);
}


LRESULT FAR PASCAL InternalOpenDriver( LPCWSTR szDriverName,
                                    LPCWSTR szSectionName,
                                    LPARAM  lParam2,
                                    BOOL    fSendEnable)
{
    DWORD_PTR     hDriver;
    LPDRIVERTABLE lpdt;
    LRESULT       result;
    WCHAR         sz[128];

    if (0 != (hDriver = InternalLoadDriver( szDriverName,
                                            szSectionName,
                                            sz,
                                            sizeof(sz) / sizeof(WCHAR),
                                            fSendEnable ) ) )
    {
        /*
         * Set the driver identifier to the DRV_OPEN call to the
         * driver handle. This will let people build helper functions
         * that the driver can call with a unique identifier if they
         * want to.
         */

        DrvEnter();
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
        lpdt[hDriver-1].dwDriverIdentifier = (DWORD)hDriver;
        GlobalUnlock(hInstalledDriverList);
        DrvLeave();

        result = DrvSendMessage( (HANDLE)hDriver, DRV_OPEN, (LPARAM)(LPSTR)sz,
                                 lParam2);
        if (!result) {
            dprintf1(("DrvSendMessage failed, result = %8x",result));
            InternalFreeDriver((UINT)hDriver, fSendEnable);
        } else {
            DrvEnter();
            lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
            lpdt[hDriver-1].dwDriverIdentifier = result;
            GlobalUnlock(hInstalledDriverList);
            DrvLeave();
            result = hDriver;
        }
    }
    else
        result = 0L;

    return result;
}

/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   LONG | InternalLoadDriver | Loads an installable driver. If this is
 *        the first time that the driver is opened, the driver will be loaded
 *        and enabled.
 *
 * @parm  LPSTR | szDriverName | A null-terminated character string
 *        containing a driver filename or a keyname from the [Drivers]
 *        section of system.ini.
 *
 * @parm  LPSTR | szSectionName | A null-terminated character string
 *        that specifies a driver section to search. If szSectionName is
 *        not null, the specified section of system.ini is searched instead
 *        of the [Drivers] section. If szSectionName is null, the
 *        default [Drivers] section is used.
 *
 * @parm  LPSTR | lpstrTail | caller supplied buffer to return the "tail"
 *        of the system.ini line in. The tail is any characters that follow
 *        the filename.
 *
 * @parm  UINT | cbTail | size of supplied buffer as a character count.
 *
 * @parm  BOOL | fSendEnable | TRUE if driver should be enabled
 *
 * @rdesc Returns a long whose loword is the handle to the driver and whose
 *        high word is an error code or the module handle
 *
 * @xref  InternalOpenDriver
 *
 ****************************************************************************/

LRESULT FAR PASCAL InternalLoadDriver(LPCWSTR  szDriverName,
                                   LPCWSTR  szSectionName,
                                   LPWSTR   lpstrTail,
                                   UINT     cbTail,
                                   BOOL     fSendEnable)
{
    int           index;
    LPDRIVERTABLE lpdt;
    LONG          result;
    HANDLE        h;
    DRIVERPROC    lpDriverEntryPoint;


    /*  The driver will receive the following message sequence:
     *
     *      if driver not loaded and can be found
     *          DRV_LOAD
     *          if DRV_LOAD returns non-zero and fSendEnable
     *              DRV_ENABLE
     */

    /* Allocate a table entry */

    // This can be made more efficient by keeping a count of how many drivers
    // we have loaded and how many entries there are in the table.  Then when
    // we should reuse an entry we would not reallocate - unlike at present.

    DrvEnter();
    if (!hInstalledDriverList) {
        h = GlobalAlloc(GHND, (DWORD)((UINT)sizeof(DRIVERTABLE)));
        // Note: it is valid to assume that the memory has been ZERO'ed
        // ...might want to add a debug WinAssert to verify...
    } else {

        /* Alloc space for the next driver we will install. We may not really
         * install the driver in the last entry but rather in an intermediate
         * entry which was freed.
         */

        h = GlobalReAlloc(hInstalledDriverList,
            (DWORD)((UINT)sizeof(DRIVERTABLE)*(cInstalledDrivers+1)),
            GHND);
        // Note: it is valid to assume that the new memory has been ZERO'ed
        // ...might want to add a debug WinAssert to verify...

    }

    if (!h) {
        dprintf1(("Failed to allocate space for Installed driver list"));
        DrvLeave();
        return(0L);
    }

    cInstalledDrivers++;
    hInstalledDriverList = h;
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    /* find an unused entry in the table */

    for (index=0;index<cInstalledDrivers;index++)
    {
        if (lpdt[index].hModule == 0 && !lpdt[index].fBusy)
            break;
    }

    if (index+1 < cInstalledDrivers) {

        /* The driver went into an unused entry in the middle somewhere so
         * restore table size.
         */

        cInstalledDrivers--;
    }

    /* Protect the entry we just allocated so that OpenDriver
     * can be called at any point from now on without overriding
     * the entry
     */

    lpdt[index].fBusy = 1;

    GlobalUnlock(hInstalledDriverList);
    DrvLeave();

   /*
    *  Make sure Loadlibrary and DRV_LOAD messages to driver are consistent
    */

    EnterCriticalSection(&DriverLoadFreeCritSec);

    h = LoadAliasedLibrary( szDriverName,
                            szSectionName ? szSectionName : wszDrivers,
                            wszSystemIni,
                            lpstrTail,
                            cbTail );
    if (0 == h)
    {
        dprintf1(("Failed to LoadLibrary %ls  Error is %d", szDriverName, GetLastError()));
        LeaveCriticalSection(&DriverLoadFreeCritSec);
        result = 0;
        goto LoadCleanUp;
    }


    lpDriverEntryPoint =
        (DRIVERPROC)GetProcAddress(h, DRIVER_PROC_NAME);

    if (lpDriverEntryPoint == NULL)
    {
        // Driver does not have correct entry point
        dprintf1(("Cannot find entry point %ls in %ls", DRIVER_PROC_NAME, szDriverName));

        FreeLibrary(h);
        LeaveCriticalSection(&DriverLoadFreeCritSec);
        result = 0L;
        goto LoadCleanUp;
    }

    DrvEnter();
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    lpdt[index].lpDriverEntryPoint = lpDriverEntryPoint;

    // Set hModule here so that GetDrvrUsage() and DrvSendMessage() work

    lpdt[index].hModule = (UINT_PTR)h;

    GlobalUnlock(hInstalledDriverList);
    DrvLeave();

    if (GetDrvrUsage(h) == 1)
    {
        LRESULT LoadResult;

        // First instance of the driver.

        LoadResult = DrvSendMessage((HANDLE)(UINT_PTR)(index+1), DRV_LOAD, 0L, 0L);

        DrvEnter();
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

        if (!LoadResult)
        {
            // Driver failed load call.

            lpdt[index].lpDriverEntryPoint = NULL;
            lpdt[index].hModule = (UINT_PTR)NULL;
            GlobalUnlock(hInstalledDriverList);
            DrvLeave();
            FreeLibrary(h);
            LeaveCriticalSection(&DriverLoadFreeCritSec);
            result = 0L;
            goto LoadCleanUp;
        }
        lpdt[index].fFirstEntry = 1;
        GlobalUnlock(hInstalledDriverList);
        DrvLeave();

        if (fSendEnable) {
            DrvSendMessage((HANDLE)(UINT_PTR)(index+1), DRV_ENABLE, 0L, 0L);
        }
    }

    LeaveCriticalSection(&DriverLoadFreeCritSec);


    result = index + 1;

LoadCleanUp:
    DrvEnter();
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
    lpdt[index].fBusy = 0;
    GlobalUnlock(hInstalledDriverList);
    DrvLeave();
    return(result);
}


/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   UINT | InternalFreeDriver | This function decrements the usage
 *        count of the specified driver. When the driver usage count reaches
 *        0, the driver is sent a DRV_FREE message and then freed.
 *
 * @parm  HANDLE | hDriver | Driver handle of the installable driver to be
 *        freed.
 *
 * @parm  BOOL | fSendDisable | TRUE if a DRV_DISABLE message should be sent
 *        before the DRV_FREE message if the usage count reaches zero.
 *
 * @rdesc Returns current driver usage count.
 *
 * @comm  Using LoadLibrary or FreeLibrary directly on a library installed
 *        with OpenDriver will break this function. A module handle is not
 *        the same as an installable driver handle.
 *
 * @xref  CloseDriver
 *
 ***************************************************************************/

UINT FAR PASCAL InternalFreeDriver(UINT hDriver, BOOL fSendDisable)
{
    LPDRIVERTABLE lpdt;
    UINT          w;
    int           index;
    HMODULE       hModule;

    /*  The driver will receive the following message sequence:
     *
     *      if usage count of driver is 1
     *          DRV_DISABLE (normally)
     *          DRV_FREE
     */

    EnterCriticalSection(&DriverLoadFreeCritSec);

    DrvEnter();
    if ((int)hDriver > cInstalledDrivers || !hDriver) {
        DrvLeave();
	LeaveCriticalSection(&DriverLoadFreeCritSec);
        return(0);
    }

    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    /*
     * If the driver usage count is 1, then send
     * free and disable messages.
     */

    /*
       Clear dwDriverIdentifier so that the sendmessage for
       DRV_OPEN and DRV_ENABLE have dwDriverIdentifier = 0
       if an entry gets reused and so that the DRV_DISABLE and DRV_FREE
       messages below also get dwDriverIdentifier = 0.
    */

    lpdt[hDriver-1].dwDriverIdentifier = 0;
                            
    hModule = (HMODULE)lpdt[hDriver-1].hModule;


    GlobalUnlock(hInstalledDriverList);
    DrvLeave();

    w = GetDrvrUsage((HANDLE)hModule);

    if (w == 1)
        {
        if (fSendDisable)
            DrvSendMessage((HANDLE)(UINT_PTR)hDriver, DRV_DISABLE, 0L, 0L);
        DrvSendMessage((HANDLE)(UINT_PTR)hDriver, DRV_FREE, 0L, 0L);
        }
    FreeLibrary(hModule);

    DrvEnter();
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    /* Only one entry for the driver in the driver list has the first
     * instance flag set. This is to make it easier to handle system
     * messages that only need to be sent to a driver once.
     *
     * To maintain the flag, we must set the flag in one of the other
     * entries if we remove the driver entry with the flag set.
     *
     * Note that InternalFreeDriver returns the new usage count of
     * the driver so if it is zero, we know that there are no other
     * entries for the driver in the list and so we don't have to
     * do this loop.
     */

    if (lpdt[hDriver - 1].fFirstEntry) {
        for (index=0;index<cInstalledDrivers;index++)
            if (lpdt[index].hModule == lpdt[hDriver-1].hModule && !lpdt[index].fFirstEntry)
                {
                lpdt[index].fFirstEntry = 1;
                break;
                }
    }

    // Clear the rest of the table entry

    lpdt[hDriver-1].hModule = 0;        // this indicates free entry
    lpdt[hDriver-1].fFirstEntry = 0;    // this is also just to be tidy
    lpdt[hDriver-1].lpDriverEntryPoint = 0; // this is also just to be tidy

    GlobalUnlock(hInstalledDriverList);
    DrvLeave();

    LeaveCriticalSection(&DriverLoadFreeCritSec);

    return(w-1);
}

#if 0

UINT GetWinVer()
{
    WORD w = GetVersion();

    return (w>>8) | (w<<8);
}

#endif

#if 0
void NEAR PASCAL DrvInit(void)
{
HANDLE  hlibUser;
LPDRIVERTABLE lpdt;

    /* If the window's driver interface is present then use it.
     */

    DOUT(("DrvInit\r\n"));

    hlibUser = GetModuleHandle(szUser);

    if(lpOpenDriver = (OPENDRIVER31)GetProcAddress(hlibUser,szOpenDriver))
        fUseWinAPI = TRUE;
    else
        {
        fUseWinAPI = FALSE;
        DOUT((" - No Windows Driver I/F detected. Using MMSYSTEM\r\n"));

        //
        // force MMSYSTEM into the driver table, without enabling it.
        //
        DrvEnter();
        cInstalledDrivers = 0;
        hInstalledDriverList = GlobalAlloc(GHND|GMEM_SHARE, (DWORD)((UINT)sizeof(DRIVERTABLE)));

#if DBG
        if (hInstalledDriverList == NULL)
            {
            DOUT(("no memory for driver table\r\n"));
            // FatalExit(-1);
            return;
            }
#endif
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

        //
        //  NOTE! we are not setting fFirstEntry==TRUE
        //
        //  because under windows 3.0 MMSOUND will enable/disable us
        //  we *dont* wan't the driver interface doing it!
        //
        lpdt->lpDriverEntryPoint = (DRIVERPROC)DriverProc;
        lpdt->hModule = ghInst;
        lpdt->fFirstEntry = 0;

        GlobalUnlock(hInstalledDriverList);
        DrvLeave();
        }

    if (fUseWinAPI)
        {
        DOUT((" - Windows Driver I/F detected\r\n"));

        if (GetWinVer() < 0x30A)
            DOUT(("MMSYSTEM: WARNING !!! WINDOWS DRIVER I/F BUT VERSION LESS THAN 3.1\r\n"));

        // link to the relevant user APIs.

        lpCloseDriver = (CLOSEDRIVER31)GetProcAddress(hlibUser, szCloseDriver);
        lpGetDriverModuleHandle = (GETDRIVERMODULEHANDLE31)GetProcAddress(hlibUser, szDrvModuleHandle);
        lpSendDriverMessage = (SENDDRIVERMESSAGE31)GetProcAddress(hlibUser, szSendDriverMessage);
        lpDefDriverProc = (DEFDRIVERPROC31)GetProcAddress(hlibUser, szDefDriverProc);
        }
}
#endif

#if 0
/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   void | InternalInstallDriverChain | This function loads the
 *        drivers specified on the Drivers= line of the [Boot] section
 *        of system.ini. The Drivers are loaded but not opened.
 *
 * @rdesc None
 *
 ***************************************************************************/

void FAR PASCAL InternalInstallDriverChain(void)
{
    char    szBuffer[150];
    BOOL    bFinished;
    int     iStart;
    int     iEnd;

    if (!fUseWinAPI)
        {
        /* Load DLL's from DRIVERS section in system.ini
        */

        szBuffer[0] = TEXT('\0');

        winmmGetPrivateProfileString(szBoot,      /* [Boot] section */
                                     szDrivers,   /* Drivers= */
                                     szNull,      /* Default if no match */
                                     szBuffer,    /* Return buffer */
                                     sizeof(szBuffer),
                                     szSystemIni);

        if (!*szBuffer) {
            return;
        }

        bFinished = FALSE;
        iStart    = 0;
        while (!bFinished)
            {
            iEnd = iStart;
            while (szBuffer[iEnd] && (szBuffer[iEnd] != ' ') &&
                (szBuffer[iEnd] != ','))
            iEnd++;

            if (szBuffer[iEnd] == NULL)
            bFinished = TRUE;
            else
            szBuffer[iEnd] = NULL;

            /* Load and enable the driver.
            */
            InternalLoadDriver(&(szBuffer[iStart]), NULL, NULL, 0, TRUE);

            iStart = iEnd+1;
            }
        }
}
#endif

/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   void | InternalDriverEnable | This function enables all the
 *        currently loaded installable drivers. If the user driver i/f
 *        has been detected, this function will do nothing.
 *
 * @rdesc None
 *
 ***************************************************************************/

void FAR PASCAL InternalDriverEnable(void)
{

    if (!fUseWinAPI)
        InternalBroadcastDriverMessage(1, DRV_ENABLE, 0L, 0L, IBDM_ONEINSTANCEONLY);
}

/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   void | InternalDriverDisable | This function disables all the
 *        currently loaded installable drivers. If the user driver I/F
 *        has been detected, this function will do nothing.
 *
 *
 * @rdesc None
 *
 ***************************************************************************/

void FAR PASCAL InternalDriverDisable(void)
{

    if (!fUseWinAPI)
        InternalBroadcastDriverMessage(0, DRV_DISABLE, 0L, 0L,
            IBDM_ONEINSTANCEONLY | IBDM_REVERSE);
}

/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   BOOL | TestExeFormat | This function tests if the executable
 *        supplied is loadable as a 32-bit executable
 *
 * @parm  LPWSTR | szExe | The file to test
 *
 * @rdesc BOOL | TRUE if format was OK, FALSE otherwise
 *
 ***************************************************************************/

BOOL TestExeFormat(LPWSTR szExe)
{
    HANDLE SectionHandle;
    HANDLE FileHandle;
    PVOID BaseAddress;
    SIZE_T ViewSize;
    WCHAR ExpandedName[MAX_PATH];
    LPWSTR FilePart;

    //
    // See if it's already loaded
    //

    if (GetModuleHandleW(szExe)) {
        return TRUE;
    }

    //
    // Search for our DLL
    //

    if (!SearchPathW(NULL,
                     szExe,
                     NULL,
                     MAX_PATH,
                     ExpandedName,
                     &FilePart)) {
        return FALSE;
    }

    //
    // Get a handle for it
    //

    FileHandle = CreateFileW(ExpandedName,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             0,
                             NULL);

    if (FileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // We create and map a section for this file as an IMAGE
    // to make sure it's recognized as such
    //

    if (!NT_SUCCESS(NtCreateSection(
                         &SectionHandle,
                         SECTION_ALL_ACCESS,
                         NULL,
                         NULL,
                         PAGE_READONLY,
                         SEC_IMAGE,
                         FileHandle))) {
         CloseHandle(FileHandle);
         return FALSE;
    }

    //
    // Map it whereever it will go
    //

    ViewSize = 0;
    BaseAddress = NULL;

    //
    // See if the loader is happy with the format
    //

    if (!NT_SUCCESS(NtMapViewOfSection(SectionHandle,
                                       NtCurrentProcess(),
                                       &BaseAddress,
                                       0L,
                                       0L,
                                       NULL,
                                       &ViewSize,
                                       ViewShare,
                                       0L,
                                       PAGE_READONLY))) {
        NtClose(SectionHandle);
        CloseHandle(FileHandle);
        return FALSE;
    }

    NtUnmapViewOfSection(NtCurrentProcess(), BaseAddress);
    NtClose(SectionHandle);
    CloseHandle(FileHandle);

    return TRUE;

}

/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   HANDLE | LoadAliasedLibrary | This function loads the library module
 *        contained in the specified file and returns its module handle
 *        unless the specified  name matches a keyname in the
 *        specified section section of the specified ini file in which case
 *        the library module in the file specified on the ini line is loaded.
 *
 * @parm  LPSTR | szLibFileName | points to a null-terminated character
 *        string containing the filename or system.ini keyname.
 *
 * @parm  LPSTR | szSection | points to a null-terminated character
 *        string containing the section name.
 *
 * @parm  LPSTR | szIniFile | points to a null-terminated character
 *        string containing the ini filename.
 *
 * @parm  LPSTR | lpstrTail | caller supplied buffer to return the "tail"
 *        of the system.ini line in. The tail is any characters that follow
 *        the filename.
 *
 * @parm  UINT | cbTail | size of supplied buffer.
 *
 * @rdesc Returns the library's module handle.
 *
 * @xref  LoadLibrary
 *
 ***************************************************************************/

HANDLE LoadAliasedLibrary( LPCWSTR  szLibFileName,
                           LPCWSTR  szSection,
                           LPWSTR   szIniFile,
                           LPWSTR   lpstrTail,
                           UINT     cbTail)
{
#define SZ_SIZE 128
#define SZ_SIZE_BYTES (SZ_SIZE * sizeof( WCHAR ))

    WCHAR         sz[SZ_SIZE];
    LPWSTR        pch;
    HANDLE        hReturn;
    DWORD         OldErrorMode;
//  OFSTRUCT      of;

    if (!szLibFileName || !*szLibFileName)
        return(NULL); // File not found

    // read the filename and additional info. into sz

    sz[0] = L'\0';
    if (winmmGetPrivateProfileString(szSection,          // ini section
                                 szLibFileName,      // key name
                                 szLibFileName,      // default if no match
                                 sz,                 // return buffer
                                 SZ_SIZE,            // sizeof of return buffer
                                 szIniFile)==0)         // ini. file
	{
		return NULL;
	}

    sz[SZ_SIZE - 1] = 0;

#if 1
    if (0 == lstrcmpiW(sz, L"wdmaud.drv"))
    {
        if (0 != lstrcmpiW(sz, szLibFileName))
        {
//            Squirt("LoadAliasedLibrary: [%ls:%ls]", szLibFileName, sz);
//            Squirt("Should not load [%ls]", szLibFileName);
            return NULL;
        }
    }
#endif

    //
    // strip off the additional info.
    //
    pch = (LPWSTR)sz;

    //
    // at exit from loop pch pts to ch after first space or null ch
    //
    while (*pch) {
        if ( *pch == ' ' ) {
            *pch++ = '\0';
            break;
        }
        pch++;
    }

//
//  These lines are removed for unicode because:
//      there is not a unicode version of OpenFile.
//      LoadLibrary performs the same test as the one below anyway
//
//  if (!GetModuleHandle( sz ) &&
//      OpenFile(sz, &of, OF_EXIST|OF_READ|OF_SHARE_DENY_NONE) == -1) {
//
//      return(NULL);
//  }

    //
    // copy additional info. to lpstrTail
    //
    if (lpstrTail && cbTail) {
        while (cbTail-- && (0 != (*lpstrTail++ = *pch++)))
            ;

        *(lpstrTail-1) = 0;
    }

    //
    // If we're running in the server check if it's a good image.
    // The server bug checks if it tries to load bad images (LoadLibrary
    // inconsistency).
    //
    // To do this we simulate the load process far enough to make
    // the check that it's a valid image
    //

    if (WinmmRunningInServer && !TestExeFormat(sz)) {
        return NULL;
    }

    //
    // Disable hard error popups
    //

    OldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    //
    // Try to load it
    //

    hReturn = LoadLibraryW( sz );

    SetErrorMode(OldErrorMode);

    return hReturn;

#undef SZ_SIZE_BYTES
#undef SZ_SIZE
}



/***************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   int | GetDrvrUsage | Runs through the driver list and figures
 *        out how many instances of this driver module handle we have.
 *        We use this instead of GetModuleUsage so that we can have drivers
 *        loaded as normal DLLs and as installable drivers.
 *
 * @parm  HANDLE | h | Driver's module handle
 *
 * @rdesc Returns the library's driver usage count.
 *
 ***************************************************************************/

int FAR PASCAL GetDrvrUsage(HANDLE h)
{
    LPDRIVERTABLE lpdt;
    int           index;
    int           count;

    DrvEnter();
    if (!hInstalledDriverList || !cInstalledDrivers) {
        DrvLeave();
        return(0);
    }

    count = 0;
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
    for (index=0;index<cInstalledDrivers;index++)
        {
        if (lpdt->hModule==(UINT_PTR)h)
            {
            count++;
            }
        lpdt++;
        }
    GlobalUnlock(hInstalledDriverList);

    DrvLeave();

    return(count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\joy.h ===
/****************************************************************************
 *   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *   KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *   IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *   PURPOSE.
 *
 *   Copyright (c) 1993-1999 Microsoft Corporation
 *
 *  File:       joy.h
 *  Content:    joystick include file
 *
 *@@BEGIN_MSWINAPI
 *
 *  History:
 *   Date        By        Reason
 *   ====        ==        ======
 *   05-oct-94   craige    re-write
 *   25-Nov-97   qzheng    convert to use DINPUT in NT instead of old driver
 *@@END_MSWINAPI
 *
 ***************************************************************************/

#ifndef JOY_H
#define JOY_H

#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include <devioctl.h>
#include <ntddjoy.h>
#include <mmddk.h>

#define DIRECTINPUT_VERSION 0x50A

#include <dinput.h>
#include <dinputd.h>
#include <mmsystem.h>
#include <hidusage.h>
/*****************************************************************************
 *
 *      Registered window messages
 *
 *****************************************************************************/

#define MSGSTR_JOYCHANGED       TEXT("MSJSTICK_VJOYD_MSGSTR")

/****DEFINES****/
#define cJoyMax     ( 16 )
#define cJoyPosAxisMax     ( 6 )
#define cJoyPosButtonMax   (32 )
#define cJoyMaxInWinmm  (2)

#define cMsecTimer  (20000)
#define INUSE       ( 0 )
#define DEATHROW    ( 1 )
#define EXECUTE     ( 2 )
#define INVALID     (-1 )
#define DEADZONE_PERCENT    ( 5 )

#undef MIN_PERIOD
#define MIN_PERIOD  10
#define MAX_PERIOD  1000

typedef struct tagJOYDEVICE
{
    LPDIRECTINPUTDEVICE2W   pdid;           // Device Interface

    DWORD                   dwButtons;      // Number of Buttons
    DWORD                   dwFlags;        // Cached dwFlags field for last JoyGetPosEx
    HWND                    hwnd;           // the windows owns the focus of the joystick

    UINT                    uPeriod;        // poll period
    UINT                    uThreshold;
    UINT_PTR                uIDEvent;       // timer ID
    BOOL                    fChanged;       //
    UINT                    uIDJoy;         // index of the currently caputured joystick
    UINT                    uState;
    
    JOYCAPSW                jcw;            // the caps of the joystick
} JOYDEVICE, *LPJOYDEVICE;


/*
 *  fEqualMask - checks that all masked bits are equal
 */
BOOL static __inline fEqualMaskFlFl(DWORD flMask, DWORD fl1, DWORD fl2)
{
    return ((fl1 ^ fl2) & flMask) == 0;
}

/*
 * SetMaskFl - Set mask bits in fl
 */
void static __inline SetMaskpFl( DWORD flMask, PDWORD pfl )
{
    *pfl |= flMask;
}

/*
 * ClrMaskFl - Clear mask bits in fl
 */
void static __inline ClrMaskpFl( DWORD flMask, PDWORD pfl )
{
    *pfl &= (! flMask) ;
}


/***************************************************************************
 *
 *  Debugging macros needed by inline functions
 *
 ***************************************************************************/
#if defined(DBG) || defined(RDEBUG)
#define XDBG
#endif

int WINAPI AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifdef DBG
    #define AssertFPtsz(c, ptsz) ((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
#else   /* !DBG */
    #define AssertFPtsz(c, ptsz)
#endif

#define AssertF(c)      AssertFPtsz(c, TEXT(#c))

/*****************************************************************************
 *
 *  @doc    INLINE
 *
 *  @method BOOL | IsWriteSam |
 *
 *          Nonzero if the registry security access mask will
 *          obtain (or attempt to obtain) write access.
 *
 *  @parm   REGSAM | regsam |
 *
 *          Registry security access mask.
 *
 *****************************************************************************/

    BOOL IsWriteSam(REGSAM sam)
    {
        return sam & (KEY_SET_VALUE | KEY_CREATE_SUB_KEY | MAXIMUM_ALLOWED);
    }

    #define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))

#ifdef DBG
    void joyDbgOut(LPSTR lpszFormat, ...);

    #define JOY_ERR                0x00000001
    #define JOY_WARN               0x00000002
    #define JOY_BABBLE             0x00000004

    #define JOY_DEFAULT_DBGLEVEL   0x00000000
#endif

#ifdef DBG
    extern DWORD g_dwDbgLevel;
    #define JOY_DBGPRINT( _debugMask_, _x_ ) \
        if( (((_debugMask_) & g_dwDbgLevel)) ){ \
            joyDbgOut _x_; \
        }
#else
    #define JOY_DBGPRINT( _debugMask_, _x_ )
#endif

#endif // JOY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\joy.c ===
/******************************************************************************

   Copyright (c) 1985-1999 Microsoft Corporation

   Title:   joy.c - MMSYSTEM Joystick interface code

   Version: 1.01

   Date:    10-Jun-1997

   Author:  GLENNS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
  --------   ----- -----------------------------------------------------------
    2/7/90             Changes to avoid a bug in Windows which won't allow
                       FreeLibrary to be called during WEP.

    10/11/90      .61  Use windows timer + general cleanup

    20-Aug-92          Convert to Windows NT

    20-Nov-97          Use DINPUT instead of old driver

    1/10/98            Add debug output for joy* API
*****************************************************************************/

#define INITGUID
#define UNICODE

#include <stdlib.h>
#include <windows.h>
#include <regstr.h>
#include <winioctl.h>
#include "winmmi.h"
#include "joy.h"

/****************************************************************************
    Local data
****************************************************************************/


CRITICAL_SECTION   joyCritSec;          //also used in winmm.c
static LPJOYDEVICE g_pJoyDev[cJoyMax];
static DWORD       g_dwNumOpen = 0;
static UINT        g_wmJoyChanged = 0;
static UINT        g_timerID = 0;
static HANDLE      g_hThreadMonitor = NULL;
static DWORD       g_dwThreadID = 0;
static BOOL        g_fThreadExist = FALSE;
static WCHAR       cwszREGKEYNAME[] = L"DINPUT.DLL";
static CHAR        cszREGKEYNAME[] = "DINPUT.DLL";

static HKEY        hkJoyWinmm;
static TCHAR       g_szJoyWinmm[] = REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\Joystick\\Winmm");
static BOOL        g_fHasWheel = FALSE;
static DWORD       g_dwEnableWheel;
static TCHAR       g_szEnableWheel[] = TEXT("wheel");

#ifdef DBG
    static DWORD       g_dwDbgLevel;
    static TCHAR       g_szDbgLevel[] = TEXT("level");
#endif

LPDIRECTINPUTW         g_pdi;
LPDIRECTINPUTJOYCONFIG g_pdijc;

HINSTANCE g_hinstDinputDll;
FARPROC   g_farprocDirectInputCreateW;
HANDLE    g_hEventWinmm;

/****************************************************************************
   Internal Data Structures
****************************************************************************/
#ifndef HID_USAGE_SIMULATION_RUDDER
    #define HID_USAGE_SIMULATION_RUDDER         ((USAGE) 0xBA)
#endif
#ifndef HID_USAGE_SIMULATION_THROTTLE
    #define HID_USAGE_SIMULATION_THROTTLE       ((USAGE) 0xBB)
#endif
#ifndef HID_USAGE_SIMULATION_ACCELERATOR
    #define HID_USAGE_SIMULATION_ACCELERATOR    ((USAGE) 0xC4)
#endif
#ifndef HID_USAGE_SIMULATION_BRAKE
    #define HID_USAGE_SIMULATION_BRAKE          ((USAGE) 0xC5)
#endif
#ifndef HID_USAGE_SIMULATION_CLUTCH
    #define HID_USAGE_SIMULATION_CLUTCH         ((USAGE) 0xC6)
#endif
#ifndef HID_USAGE_SIMULATION_SHIFTER
    #define HID_USAGE_SIMULATION_SHIFTER        ((USAGE) 0xC7)
#endif
#ifndef HID_USAGE_SIMULATION_STEERING
    #define HID_USAGE_SIMULATION_STEERING       ((USAGE) 0xC8)
#endif
#ifndef HID_USAGE_GAME_POV
    #define HID_USAGE_GAME_POV                  ((USAGE) 0x20)
#endif
#ifndef DIDFT_OPTIONAL
    #define DIDFT_OPTIONAL 0x80000000
#endif

#define MAX_BTNS 32
#define MAX_CTRLS 46 //14 below + buttons
#define MAX_FINAL 7+MAX_BTNS  //6 axes + POV + buttons
typedef enum eCtrls {
    eGEN_X=0,
    eGEN_Y,
    eGEN_Z,     
    eGEN_RX,
    eGEN_RY,  
    eGEN_RZ,
    eSIM_THROTTLE,
    eSIM_STEERING,
    eSIM_ACCELERATOR,
    eGEN_SLIDER,
    eGEN_DIAL,
    eSIM_RUDDER,
    eSIM_BRAKE,
    eGEN_POV,
    eBTN } eCtrls;

typedef struct WINMMJOYSTATE { 
    DWORD    lX; 
    DWORD    lY; 
    DWORD    lZ; 
    DWORD    lR; 
    DWORD    lU; 
    DWORD    lV; 
    DWORD   dwPOV;
    BYTE    rgbButtons[32];
} WINMMJOYSTATE, *LPWINMMJOYSTATE; 

#define MAKEVAL(f)                                   \
    { 0,                                             \
      FIELD_OFFSET(WINMMJOYSTATE, f),                \
      DIDFT_OPTIONAL,                                \
      0,                                             \
    }                                                                   \

#define MAKEBTN(n)                                                      \
    { 0,                                                                \
      FIELD_OFFSET(WINMMJOYSTATE, rgbButtons[n]),                          \
      DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      0,                                              \
    }                                                                   \

//Note that only the offset fields are used now
static DIOBJECTDATAFORMAT c_rgodfWinMMJoy[] = {
    MAKEVAL(lX),
    MAKEVAL(lY),
    MAKEVAL(lZ),
    MAKEVAL(lR),
    MAKEVAL(lU),
    MAKEVAL(lV),
    MAKEVAL(dwPOV),
    MAKEBTN(0),
    MAKEBTN(1),
    MAKEBTN(2),
    MAKEBTN(3),
    MAKEBTN(4),
    MAKEBTN(5),
    MAKEBTN(6),
    MAKEBTN(7),
    MAKEBTN(8),
    MAKEBTN(9),
    MAKEBTN(10),
    MAKEBTN(11),
    MAKEBTN(12),
    MAKEBTN(13),
    MAKEBTN(14),
    MAKEBTN(15),
    MAKEBTN(16),
    MAKEBTN(17),
    MAKEBTN(18),
    MAKEBTN(19),
    MAKEBTN(20),
    MAKEBTN(21),
    MAKEBTN(22),
    MAKEBTN(23),
    MAKEBTN(24),
    MAKEBTN(25),
    MAKEBTN(26),
    MAKEBTN(27),
    MAKEBTN(28),
    MAKEBTN(29),
    MAKEBTN(30),
    MAKEBTN(31),
};

static GUID rgoWinMMGUIDs[MAX_CTRLS];

DIDATAFORMAT c_dfWINMMJoystick = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_ABSAXIS,
    sizeof(WINMMJOYSTATE),
    sizeof(c_rgodfWinMMJoy)/sizeof(DIOBJECTDATAFORMAT),
    c_rgodfWinMMJoy,
};

#define RESET_VAL(index)   c_rgodfWinMMJoy[index].pguid = 0; \
                           c_rgodfWinMMJoy[index].dwType = DIDFT_OPTIONAL; \
                           c_rgodfWinMMJoy[index].dwFlags = 0; \

#define RESET_BTN(index)   c_rgodfWinMMJoy[index].pguid = 0; \
                           c_rgodfWinMMJoy[index].dwType = DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL; \
                           c_rgodfWinMMJoy[index].dwFlags = 0; \

#define RESET_RGODFWINMMJOY()  \
    RESET_VAL(0);   \
    RESET_VAL(1);   \
    RESET_VAL(2);   \
    RESET_VAL(3);   \
    RESET_VAL(4);   \
    RESET_VAL(5);   \
    RESET_VAL(6);   \
    RESET_VAL(7);   \
    RESET_BTN(8);   \
    RESET_BTN(9);   \
    RESET_BTN(10);  \
    RESET_BTN(11);  \
    RESET_BTN(12);  \
    RESET_BTN(13);  \
    RESET_BTN(14);  \
    RESET_BTN(15);  \
    RESET_BTN(16);  \
    RESET_BTN(17);  \
    RESET_BTN(18);  \
    RESET_BTN(19);  \
    RESET_BTN(20);  \
    RESET_BTN(21);  \
    RESET_BTN(22);  \
    RESET_BTN(23);  \
    RESET_BTN(24);  \
    RESET_BTN(25);  \
    RESET_BTN(26);  \
    RESET_BTN(27);  \
    RESET_BTN(28);  \
    RESET_BTN(29);  \
    RESET_BTN(30);  \
    RESET_BTN(31);  \
    RESET_BTN(32);  \
    RESET_BTN(33);  \
    RESET_BTN(34);  \
    RESET_BTN(35);  \
    RESET_BTN(36);  \
    RESET_BTN(37);  \
    RESET_BTN(38);  \
    
#ifndef cchLENGTH
#define cchLENGTH(_sz)  (sizeof(_sz)/sizeof(_sz[0]))
#endif

/****************************************************************************
   Internal functions
****************************************************************************/
BOOL CALLBACK DIEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCE lpddoi,LPVOID pvRef);
HRESULT WINAPI joyOpen(UINT idJoy, LPJOYCAPSW pjc );
void WINAPI    joyClose( UINT idJoy );
void WINAPI    joyCloseAll( void );
void CALLBACK  joyPollCallback(HWND hWnd, UINT wMsg, UINT_PTR uIDEvent, DWORD dwTime);  //TIMER MESSAGE for Joystick
DWORD WINAPI   joyMonitorThread(LPVOID);
void WINAPI    DllEnterCrit(void);
void WINAPI    DllLeaveCrit(void);
BOOL WINAPI    DllInCrit( void );
void AssignToArray(LPCDIDEVICEOBJECTINSTANCE lpddoi, eCtrls CtrlID, LPDIOBJECTDATAFORMAT pDevs);
void AssignToRGODF(LPDIOBJECTDATAFORMAT pDof, int CtrlID);
void AssignMappings(DIOBJECTDATAFORMAT *dwAll, DWORD *dwCaps, DWORD *dwBtns, DWORD *dwAxes);
BOOL CALLBACK DIEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCE lpddoi,LPVOID pvRef);
HRESULT        hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk);

/****************************************************************************

    @doc WINAPI

    @api BOOL | JoyInit | This function initializes the joystick services.

    @rdesc The return value is TRUE if the services are initialised.

****************************************************************************/

BOOL JoyInit(void)
{
    HRESULT hres;
    LONG lRc;

    JOY_DBGPRINT( JOY_BABBLE, ("JoyInit: starting.") );

    memset(&g_pJoyDev, 0, sizeof(g_pJoyDev) );
    g_wmJoyChanged  =   RegisterWindowMessage(MSGSTR_JOYCHANGED);
    g_dwNumOpen     =   0x0;
    g_fHasWheel     =   FALSE;

#ifdef DBG
    g_dwDbgLevel = JOY_DEFAULT_DBGLEVEL;

    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE,
                           g_szJoyWinmm,
                           KEY_ALL_ACCESS,
                           REG_OPTION_NON_VOLATILE,
                           &hkJoyWinmm);

    if ( SUCCEEDED(hres) )
    {
        DWORD cb = sizeof(g_dwDbgLevel);

        lRc = RegQueryValueEx(hkJoyWinmm, g_szDbgLevel, 0, 0, (LPBYTE)&g_dwDbgLevel, &cb);

        if ( lRc != ERROR_SUCCESS )
        {
            DWORD dwDefault = 0;

            lRc = RegSetValueEx(hkJoyWinmm, g_szDbgLevel, 0, REG_DWORD, (LPBYTE)&dwDefault, cb);
        }

        RegCloseKey(hkJoyWinmm);
    }
#endif

    g_dwEnableWheel = 1;

    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE,
                           g_szJoyWinmm,
                           KEY_ALL_ACCESS,
                           REG_OPTION_NON_VOLATILE,
                           &hkJoyWinmm);

    if ( SUCCEEDED(hres) )
    {
        DWORD cb = sizeof(g_dwEnableWheel);

        lRc = RegQueryValueEx(hkJoyWinmm, g_szEnableWheel, 0, 0, (LPBYTE)&g_dwEnableWheel, &cb);

        if ( lRc != ERROR_SUCCESS )
        {
            DWORD dwDefault = 1;

            lRc = RegSetValueEx(hkJoyWinmm, g_szEnableWheel, 0, REG_DWORD, (LPBYTE)&dwDefault, cb);
        }

        RegCloseKey(hkJoyWinmm);
    }

    g_hEventWinmm =  CreateEvent(0, TRUE, 0, TEXT("DINPUTWINMM"));
    if( !g_hEventWinmm ) {
        JOY_DBGPRINT( JOY_ERR, ("JoyInit: create named event fails (0x%08lx).", GetLastError() ) );
    }
    
    return TRUE;
}


/****************************************************************************

    @doc WINAPI

    @api void | JoyCleanup | This function clean up the joystick services.

****************************************************************************/

void JoyCleanup(void)
{
    joyCloseAll();

    if ( g_hEventWinmm && WAIT_OBJECT_0 != WaitForSingleObject(g_hEventWinmm, 10))  
    {
        //DInput has not been released.
        if( g_pdijc) {
            IDirectInputJoyConfig_Release(g_pdijc);
        }

        if ( g_pdi ) {
            IDirectInput_Release(g_pdi);
        }

        (void*)g_pdijc = (void*)g_pdi = NULL;
        
        CloseHandle( g_hEventWinmm );
        g_hEventWinmm = NULL;
    }

    if ( g_hinstDinputDll )
    {
        FreeLibrary(g_hinstDinputDll);
    }

    JOY_DBGPRINT( JOY_BABBLE, ("JoyCleanup: finished.") );
}

/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   MMRESULT | joyGetDevCapsW |
 *
 *          Implementation of legacy joyGetDevCapsW for HID devices on NT.
 *
 *  @parm   IN UINT_PTR | idJoy |
 *
 *          ID of Joystick
 *
 *  @parm   OUT LPJOYCAPSW | pjc |
 *
 *          JOYCAPSW structure to be filled by this routine.
 *
 *  @parm   UINT | cbjc |
 *
 *          Size in bytes of the JOYCAPSW structure.
 *
 *  @returns
 *
 *          MMRESULT code
 *
 *****************************************************************************/
MMRESULT WINAPI joyGetDevCapsW( UINT_PTR  idJoy, LPJOYCAPSW pjc, UINT cbjc )
{
    HRESULT       hres;
    MMRESULT      mmRes;

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetDevCapsW: idJoy=%d, pjc=0x%08x, cbjc=%d", idJoy, pjc, cbjc) );

    V_WPOINTER(pjc, sizeof(JOYCAPSW), MMSYSERR_INVALPARAM);

    if( ( sizeof(JOYCAPSW) != cbjc ) &&  ( sizeof(JOYCAPS2W) != cbjc ) && ( FIELD_OFFSET(JOYCAPSW, wRmin) != cbjc ) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetDevCapsW: return %d (bad size)", JOYERR_PARMS) );
        return JOYERR_PARMS;
    }

    mmRes = JOYERR_NOERROR;

    memset(pjc, 0, min(cbjc, sizeof(JOYCAPS2W)) );

    if ( idJoy == (UINT_PTR)(-1) )
    {
        lstrcpyW(pjc->szRegKey,  cwszREGKEYNAME );
    } else if ( idJoy >= cJoyMax )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetDevCapsW: return %d (idJoy > 16)", MMSYSERR_NODRIVER) );
        mmRes = MMSYSERR_NODRIVER;
    } else
    {
        DllEnterCrit();

        hres = joyOpen((UINT)idJoy, pjc);

        DllLeaveCrit();

        if ( FAILED(hres) )
        {
            JOY_DBGPRINT( JOY_ERR, ("joyGetDevCapsW: return %d", JOYERR_PARMS) );
            mmRes = JOYERR_PARMS;
        }
    }

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetDevCapsW: return %d", mmRes) );
    return mmRes;
}


int static __inline Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len)
{
    return WideCharToMultiByte(GetACP(), 0, lpwstr, -1, lpstr, len, NULL, NULL);
}

/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   MMRESULT | joyGetDevCapsA |
 *
 *          Implementation of legacy joyGetDevCapsA for devices on NT.
 *          We call the Uincode version joyGetDevCapsW and then munge
 *          the structure into ASCII.
 *
 *  @parm   UINT_PTR | idJoy |
 *
 *          ID of Joystick
 *
 *  @parm   LPJOYCAPSA | pjc |
 *
 *          JOYCAPSA structure to be filled by this routine.
 *
 *  @parm   UINT | cbjc |
 *
 *          Size in bytes of the JOYCAPSA structure.
 *
 *  @returns
 *
 *          MMRESULT code
 *
 *****************************************************************************/
MMRESULT WINAPI joyGetDevCapsA( UINT_PTR idJoy, LPJOYCAPSA pjc, UINT cbjc )
{
#define UToA(dst, cchDst, src)  WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

    JOYCAPS2W   Caps2W;
    JOYCAPS2A   Caps2A;
    MMRESULT    mmRes;

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetDevCapsA: idJoy=%d, pjc=0x%08x, cbjc=%d", idJoy, pjc, cbjc) );

    V_WPOINTER(pjc, cbjc, MMSYSERR_INVALPARAM);

    mmRes = JOYERR_NOERROR;

    if ( idJoy == (UINT_PTR)(-1) )
    {
        lstrcpyA(pjc->szRegKey,  cszREGKEYNAME );
        goto _done;
    } else if ( idJoy >= cJoyMax )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetDevCapsA: return %d (idJoy > 16)", MMSYSERR_NODRIVER) );
        return MMSYSERR_NODRIVER;
    }

    if( ( sizeof(JOYCAPSA) != cbjc ) && ( sizeof(JOYCAPS2A) != cbjc ) && ( FIELD_OFFSET(JOYCAPSA, wRmin) != cbjc ) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetDevCapsA: return JOYERR_PARMS( bad size )") );
        return JOYERR_PARMS;
    }

    memset(pjc, 0, min(cbjc, sizeof(Caps2A)) );
    memset(&Caps2W, 0, sizeof(Caps2W));

    mmRes = joyGetDevCapsW(idJoy, (LPJOYCAPSW)&Caps2W, sizeof(Caps2W));

    if ( mmRes == JOYERR_NOERROR )
    {

        //
        // Copy product name (etc) into ASCII version
        //

        UToA(Caps2A.szPname , sizeof(Caps2A.szPname ), Caps2W.szPname );
        UToA(Caps2A.szRegKey, sizeof(Caps2A.szRegKey), Caps2W.szRegKey);
        UToA(Caps2A.szOEMVxD, sizeof(Caps2A.szOEMVxD), Caps2W.szOEMVxD);

        //
        // Copy the rest of the fields
        //

        Caps2A.wMid             =   Caps2W.wMid;
        Caps2A.wPid             =   Caps2W.wPid;
        Caps2A.wXmin            =   Caps2W.wXmin;
        Caps2A.wXmax            =   Caps2W.wXmax;
        Caps2A.wYmin            =   Caps2W.wYmin;
        Caps2A.wYmax            =   Caps2W.wYmax;
        Caps2A.wZmin            =   Caps2W.wZmin;
        Caps2A.wZmax            =   Caps2W.wZmax;
        Caps2A.wNumButtons      =   Caps2W.wNumButtons;
        Caps2A.wPeriodMin       =   Caps2W.wPeriodMin;
        Caps2A.wPeriodMax       =   Caps2W.wPeriodMax;
        Caps2A.wRmin            =   Caps2W.wRmin;
        Caps2A.wRmax            =   Caps2W.wRmax;
        Caps2A.wUmin            =   Caps2W.wUmin;
        Caps2A.wUmax            =   Caps2W.wUmax;
        Caps2A.wVmin            =   Caps2W.wVmin;
        Caps2A.wVmax            =   Caps2W.wVmax;
        Caps2A.wCaps            =   Caps2W.wCaps;
        Caps2A.wMaxAxes         =   Caps2W.wMaxAxes;
        Caps2A.wNumAxes         =   Caps2W.wNumAxes;
        Caps2A.wMaxButtons      =   Caps2W.wMaxButtons;
        Caps2A.ManufacturerGuid =   Caps2W.ManufacturerGuid;
        Caps2A.ProductGuid      =   Caps2W.ProductGuid;
        Caps2A.NameGuid         =   Caps2W.NameGuid;

        //
        // Pass back as much data as the requestor asked for
        //

        CopyMemory(pjc, &Caps2A, min(cbjc, sizeof(Caps2A)));
    }

_done:
    JOY_DBGPRINT( JOY_BABBLE, ("joyGetDevCapsA: return %d", mmRes) );
    return mmRes;

#undef UToA
}


/****************************************************************************

   @doc EXTERNAL

   @api UINT | joyGetNumDevs | This function returns the number of joystick
   devices supported by the system.

   @rdesc Returns the number of joystick devices supported by the joystick
   driver. If no driver is present, the function returns zero.

   @comm Use <f joyGetPos> to determine whether a given
   joystick is actually attached to the system. The <f joyGetPos> function returns
   a JOYERR_UNPLUGGED error code if the specified joystick is not connected.

   @xref joyGetDevCaps joyGetPos

****************************************************************************/

UINT WINAPI joyGetNumDevs( void )
{
    // simply return the max number of joysticks we can support
    JOY_DBGPRINT( JOY_BABBLE, ("joyGetNumDevs: return %d", cJoyMax) );
    return cJoyMax;
}


/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   MMRESULT | joyGetPosEx |
 *
 *          Get Joystick Position Information.
 *          Calls DInput for all the hard work
 *
 *  @parm   UINT | idJoy |
 *
 *          Id of the Joystick.
 *
 *  @parm   LPJOYINFOEX | pji |
 *
 *          Structure to be filled with Joystick Information data
 *
 *****************************************************************************/
MMRESULT WINAPI joyGetPosEx( UINT idJoy, LPJOYINFOEX  pji )
{
    MMRESULT mmRes;
    HRESULT  hres;
    static   DWORD dwLastBrake=0xFFFF, dwLastAccl=0xFFFF;
    static   DWORD dwMaxBrake=0, dwMaxAccl=0;
    static   DWORD dwMaxY=0xFFFF, dwMidY=0x7FFF, dwMinY=0;

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetPosEx: idJoy=%d, pji=0x%08x", idJoy, pji) );

    V_WPOINTER(pji, sizeof(JOYINFOEX), MMSYSERR_INVALPARAM);

    if ( pji->dwSize < sizeof(JOYINFOEX) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetPosEx: return JOYERR_PARMS(pji->dwSize < sizeof(JOYINFOEX))") );
        return JOYERR_PARMS;
    }

    DllEnterCrit();

    mmRes = JOYERR_NOERROR;

    if ( idJoy >= cJoyMax )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetPosEx: return %d (idJoy > 16)", JOYERR_PARMS) );
        mmRes = JOYERR_PARMS;
    } else if ( SUCCEEDED( hres = joyOpen(idJoy, NULL ) ) )
    {
        LPJOYDEVICE pJoyDev;
        DWORD       dwFlags;

        pJoyDev = g_pJoyDev[idJoy];

        dwFlags = pJoyDev->dwFlags;

        /* Have any of the Flag fields that we care about changed ? */
        while ( ! fEqualMaskFlFl( JOY_RETURNRAWDATA  | JOY_USEDEADZONE ,
                                  pji->dwFlags,    /* Desired State */
                                  dwFlags )        /* Current State */
              )
        {
            union {
                DIPROPHEADER diph;
                DIPROPDWORD  dipdw;
                DIPROPRANGE  diprg;
                DIPROPCAL    dipcal;
            } u;

            DIPROPDWORD dipdw;

            u.diph.dwSize       =   sizeof(u.dipdw);
            u.diph.dwHeaderSize =   sizeof(u.diph);
            u.diph.dwObj        =   0x0;
            u.diph.dwHow        =   DIPH_DEVICE;


            hres = IDirectInputDevice2_Unacquire( pJoyDev->pdid);
            if ( SUCCEEDED(hres) )
            {

            }

            else
            { // Could not unacquire device
                mmRes = JOYERR_UNPLUGGED;
                dprintf1( (("Unacquire, FAILED hres=%08lX"), hres ));
                break;
            }

            if ( ! fEqualMaskFlFl( JOY_RETURNRAWDATA, pji->dwFlags, dwFlags ) )
            {
                /* Change in Calibration Mode */
                if( pji->dwFlags & JOY_RETURNRAWDATA )
                {
                    /* RAW data */
                    u.dipdw.dwData = DIPROPCALIBRATIONMODE_RAW;
                    SetMaskpFl(JOY_RETURNRAWDATA, &dwFlags );

                } else
                {
                    /* Cooked Data */
                    u.dipdw.dwData      = DIPROPCALIBRATIONMODE_COOKED;
                    ClrMaskpFl(JOY_RETURNRAWDATA, &dwFlags );
                }

                hres = IDirectInputDevice2_SetProperty(pJoyDev->pdid, DIPROP_CALIBRATIONMODE, &u.dipdw.diph);

                if ( SUCCEEDED(hres) )
                {
                    /* Change in Calibration Mode */
                    if ( pji->dwFlags & JOY_RETURNRAWDATA )
                    {
                        u.diph.dwSize   =   sizeof(u.dipcal);
                        u.diph.dwObj    =   DIJOFS_Y;
                        u.diph.dwHow    =   DIPH_BYOFFSET;

                        hres = IDirectInputDevice2_GetProperty( pJoyDev->pdid, DIPROP_CALIBRATION, &u.dipcal.diph );
                        if ( SUCCEEDED(hres) )
                        {
                            dwMaxY = u.dipcal.lMax;
                            dwMidY = u.dipcal.lCenter;
                            dwMinY = u.dipcal.lMin;
                        }
                    } else
                    {
                        u.diph.dwSize   =   sizeof(u.diprg);
                        u.diph.dwObj    =   DIJOFS_Y;
                        u.diph.dwHow    =   DIPH_BYOFFSET;

                        hres = IDirectInputDevice2_GetProperty( pJoyDev->pdid, DIPROP_RANGE, &u.dipcal.diph );
                        if ( SUCCEEDED(hres) )
                        {
                            dwMaxY = u.diprg.lMax;
                            dwMinY = u.diprg.lMin;
                            dwMidY = (dwMaxY + dwMinY) >> 1;
                        }
                    }
                } else
                { // SetProperty( ) FAILED
                    mmRes = JOYERR_UNPLUGGED;
                    dprintf1((("SetProperty(DIPROP_CALIBRATIONMODE), FAILED hres=%08lX"), hres ));
                    break;
                }

            } else if ( ! fEqualMaskFlFl( JOY_USEDEADZONE, pji->dwFlags, dwFlags ) )
            {
                /* Change in DeadZone */
                if ( pji->dwFlags & JOY_USEDEADZONE )
                {
                    /* Default DeadZone */
                    u.dipdw.dwData      = 100 * DEADZONE_PERCENT;
                    SetMaskpFl(JOY_USEDEADZONE, &dwFlags);

                } else
                { //
                    /* No DeadZone */
                    u.dipdw.dwData      = 0x0;
                    ClrMaskpFl(JOY_USEDEADZONE, &dwFlags);
                }

                hres = IDirectInputDevice2_SetProperty(pJoyDev->pdid, DIPROP_DEADZONE, &u.dipdw.diph);

                if ( SUCCEEDED(hres) )
                {

                }

                else
                { // SetProperty( ) FAILED
                    mmRes = JOYERR_UNPLUGGED;
                    dprintf4( (("SetProperty(DIPROP_DEADZONE), FAILED hres=%08lX"), hres ));
                    break;
                }
            } else
            { // Weird Error
                break;
            }
        } // while

        pJoyDev->dwFlags = dwFlags;

        if ( SUCCEEDED(hres) )
        {
            WINMMJOYSTATE  js;

            IDirectInputDevice2_Poll(pJoyDev->pdid);
            hres = IDirectInputDevice2_GetDeviceState(pJoyDev->pdid, sizeof(js), &js);

            if ( FAILED(hres) )
            {
                hres = IDirectInputDevice2_Acquire(pJoyDev->pdid);
                if ( SUCCEEDED(hres) )
                {
                    IDirectInputDevice2_Poll(pJoyDev->pdid);
                    hres = IDirectInputDevice2_GetDeviceState(pJoyDev->pdid, sizeof(js), &js);
                }
            }

            if ( SUCCEEDED(hres) )
            {
                pji->dwButtons = 0;
                pji->dwButtonNumber = 0;

                /* Button Press Information */
                if ( pji->dwFlags & JOY_RETURNBUTTONS )
                {
                    DWORD dwButton;
                    DWORD dwMinButtonFld;

                    dwMinButtonFld = min( cJoyPosButtonMax, pJoyDev->dwButtons );

                    for ( dwButton = 0 ;
                        dwButton < dwMinButtonFld;
                        dwButton++
                        )
                    {
                        if ( js.rgbButtons[dwButton] & 0x80 )
                        {
                            /* Button Press */
                            pji->dwButtons |= (0x1 << dwButton);

                            /* Button Number */
                            pji->dwButtonNumber++;
                        }
                    }

                }

                /* Axis Information */

                pji->dwXpos = (DWORD)js.lX;          /* x position */
                pji->dwYpos = (DWORD)js.lY;          /* y position */
                pji->dwRpos = (DWORD)js.lR;         /* rudder/4th axis position */
                pji->dwZpos = (DWORD)js.lZ;          /* z position */
                pji->dwUpos = (DWORD)js.lU;         /* 5th axis position */
                pji->dwVpos = (DWORD)js.lV;         /* 6th axis position */
                /*  Note the WinMM POV is a WORD value  */
                pji->dwPOV  = (WORD)js.dwPOV;   /* point of view state */

                if ( g_fHasWheel )
                {
                    if( dwMaxAccl < pji->dwYpos ) {
                        dwMaxAccl = pji->dwYpos;
                    }

                    if( dwMaxBrake < pji->dwRpos ) {
                        dwMaxBrake = pji->dwRpos;
                    }

                    /*
                     * Make up Y value with dwRpos(brake) and dwYpos(accelerator).
                     */
                    if( dwLastAccl != pji->dwYpos ) {
                        dwLastAccl = pji->dwYpos;
                        pji->dwYpos = pji->dwYpos>>1;
                    } else if ( dwLastBrake != pji->dwRpos ) {
                        dwLastBrake = pji->dwRpos;
                        pji->dwYpos = dwMaxY - (pji->dwRpos>>1);
                    } else {
                        if( (pji->dwYpos == dwMaxAccl) && (pji->dwRpos == dwMaxBrake ) ) {
                            pji->dwYpos = dwMidY;
                        } else if ( (dwMaxAccl - pji->dwYpos) > (dwMaxBrake - pji->dwRpos) )
                            /*
                             * In this case, use percentage can get a little
                             * more precision, but not worth doing that.
                             */
                        {
                            pji->dwYpos = pji->dwYpos>>1;
                        } else
                        {
                            pji->dwYpos = dwMaxY - (pji->dwRpos>>1);
                        }
                    }
                    pji->dwRpos = 0x0;         /* rudder/4th axis position */
                }

            } else
            { // GetDeviceState FAILED
                mmRes = JOYERR_UNPLUGGED;
                dprintf1(( ("GetDeviceState, FAILED hres=%08lX"), hres ));
            }
        } else
        { // Acquire FAILED
            mmRes = JOYERR_UNPLUGGED;
            dprintf1(( ("Acquire, FAILED hres=%08lX"), hres ));
        }
    } else
    { // Joy_Open FAILED
        mmRes =  JOYERR_PARMS;
        dprintf1(( ("joyOpen, FAILED hres=%08lX"), hres ));
    }

    DllLeaveCrit();

    if ( mmRes == JOYERR_NOERROR )
    {
        JOY_DBGPRINT( JOY_BABBLE, ("joyGetPosEx: return OK, x:%d, y:%d, z:%d, r:%d, u:%d, v:%d, btn: %x", \
                                   pji->dwXpos, pji->dwXpos, pji->dwZpos, pji->dwRpos, pji->dwUpos, pji->dwVpos, pji->dwButtons) );
    } else
    {
        JOY_DBGPRINT( JOY_BABBLE, ("joyGetPosEx: return %d", mmRes) );
    }

    return mmRes;
}


/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   MMRESULT | joyGetPos |
 *
 *          Get Joystick Position Information.
 *
 *  @parm   UINT | idJoy |
 *
 *          Id of the Joystick.
 *
 *  @parm   LPJOYINFO | pji |
 *
 *          Structure to be filled with Joystick Information data
 *
 *****************************************************************************/

MMRESULT WINAPI joyGetPos( UINT idJoy, LPJOYINFO pji )
{
    JOYINFOEX jiex;
    MMRESULT  mmRes;

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetPos: idJoy=%d, pji=0x%08x", idJoy, pji) );

    V_WPOINTER(pji, sizeof(JOYINFO), MMSYSERR_INVALPARAM);

    jiex.dwSize  = sizeof(jiex);
    jiex.dwFlags = JOY_RETURNX | JOY_RETURNY | JOY_RETURNZ | JOY_RETURNBUTTONS;

    if ( (mmRes = joyGetPosEx (idJoy, &jiex)) == JOYERR_NOERROR )
    {
        pji->wXpos    = (UINT)jiex.dwXpos;
        pji->wYpos    = (UINT)jiex.dwYpos;
        pji->wZpos    = (UINT)jiex.dwZpos;
        pji->wButtons = (UINT)jiex.dwButtons;
    }

    if ( mmRes == JOYERR_NOERROR )
    {
        JOY_DBGPRINT( JOY_BABBLE, ("joyGetPos: return OK, x:%d, y:%d, z:%d, btn:%x", \
                                   pji->wXpos, pji->wXpos, pji->wZpos, pji->wButtons) );
    } else
    {
        JOY_DBGPRINT( JOY_BABBLE, ("joyGetPos: return %d", mmRes) );
    }

    return mmRes;
}


/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyGetThreshold | This function queries the current
    movement threshold of a joystick device.

    @parm UINT | idJoy | Identifies the joystick device to be queried.

    @parm PUINT | lpwThreshold | Specifies a far pointer to a UINT variable
    that is filled with the movement threshold value.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p idJoy> is invalid.

    @comm The movement threshold is the distance the joystick must be
      moved before a WM_JOYMOVE message is sent to a window that has
      captured the device. The threshold is initially zero.

    @xref joySetThreshold

****************************************************************************/

MMRESULT WINAPI joyGetThreshold( UINT idJoy, PUINT puThreshold )
{
    HRESULT       hres;
    MMRESULT      mmRes = JOYERR_NOERROR;
    JOYCAPSW      jc;

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetThreshold: idJoy=%d, uThreshold=%d", idJoy, *puThreshold) );

    V_WPOINTER(puThreshold, sizeof(UINT), MMSYSERR_INVALPARAM);

    if (idJoy >= cJoyMax)
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetThreshold: return %d ", MMSYSERR_INVALPARAM) );
        return MMSYSERR_INVALPARAM;
    }

    memset(&jc, 0, sizeof(jc));

    DllEnterCrit();

    hres = joyOpen(idJoy, &jc);

    DllLeaveCrit();

    if ( FAILED(hres) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyGetThreshold: return MMSYSERROR_NOERROR, but no joystick configured.") );
        mmRes = MMSYSERR_INVALPARAM;
    } else
    {
        *puThreshold = g_pJoyDev[idJoy]->uThreshold;
    }

    JOY_DBGPRINT( JOY_BABBLE, ("joyGetThreshold: return %d", mmRes) );
    return mmRes;
}

/****************************************************************************

    @doc WINAPI

    @api UINT | joySetThreshold | This function sets the movement threshold
     of a joystick device.

    @parm UINT | idJoy | Identifies the joystick device.  This value is either

    @parm UINT | uThreshold | Specifies the new movement threshold.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p idJoy> is invalid.

    @comm The movement threshold is the distance the joystick must be
      moved before a MM_JOYMOVE message is sent to a window that has
      captured the device.

    @xref joyGetThreshold joySetCapture

****************************************************************************/

MMRESULT WINAPI joySetThreshold(UINT idJoy, UINT uThreshold)
{
    HRESULT       hres;
    MMRESULT      mmRes = JOYERR_NOERROR;
    JOYCAPSW      jc;

    JOY_DBGPRINT( JOY_BABBLE, ("joySetThreshold: idJoy=%d, uThreshold=%d", idJoy, uThreshold) );

    if ( (idJoy >= cJoyMax) || (uThreshold>0xFFFF)  )
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetThreshold: return MMSYSERR_INVALPARAM (idJoy>16 or uThreshold>65535)") );
        return MMSYSERR_INVALPARAM;
    }

    memset(&jc, 0, sizeof(jc));

    DllEnterCrit();
    hres = joyOpen(idJoy, &jc);
    DllLeaveCrit();

    if ( FAILED(hres) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetThreshold: return MMSYSERROR_NOERROR, but no joystick configured") );
        mmRes = MMSYSERR_INVALPARAM;
    } else
    {
        g_pJoyDev[idJoy]->uThreshold = (UINT)uThreshold;
    }

    JOY_DBGPRINT( JOY_BABBLE, ("joySetThreshold: return %d", mmRes) );
    return mmRes;
}


/****************************************************************************

    @doc WINAPI

    @api UINT | joySetCapture | This function causes joystick messages to
    be sent to the specified window.

    @parm HWND | hWnd | Specifies a handle to the window to which messages
    are to be sent.

    @parm UINT | idJoy | Identifies the joystick device to be captured.

    @parm UINT | uPeriod | Specifies the polling rate, in milliseconds.

    @parm BOOL | fChanged | If this parameter is set to TRUE, then messages
    are sent only when the position changes by a value greater than the
    joystick movement threshold.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified window handle <p hWnd>
    or joystick device ID <p idJoy> is invalid.

    @flag JOYERR_NOCANDO | Cannot capture joystick input because some
    required service (for example, a Windows timer) is unavailable.

    @flag JOYERR_UNPLUGGED | The specified joystick is not connected to the
    system.

    @comm     This function fails if the specified joystick device is
    currently captured.  You should call the <f joyReleaseCapture> function when
    the joystick capture is no longer needed.  If the window is destroyed,
    the joystick will be released automatically.

    @xref  joyReleaseCapture joySetThreshold joyGetThreshold

****************************************************************************/

MMRESULT WINAPI joySetCapture(HWND hwnd, UINT idJoy, UINT uPeriod, BOOL fChanged)
{
    JOYINFO     joyinfo;
    LPJOYINFO   lpinfo = &joyinfo;
    UINT        w;
    JOYCAPS     JoyCaps;
    MMRESULT    mmRes = MMSYSERR_NOERROR;

    JOY_DBGPRINT( JOY_BABBLE, ("joySetCapture: hwnd=0x%08x, idJoy=%d, uPeriod=%d, fChanged=%d", \
                               hwnd, idJoy, uPeriod, fChanged) );

    if ( !hwnd || !IsWindow(hwnd) )
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return JOYERROR_PARMS(hwnd=NULL || !IsWindow(hwnd))"));
        return JOYERR_PARMS;
    }

    if ( idJoy >= cJoyMax )
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return JOYERR_PARMS(idJoy > 16)") );
        return JOYERR_PARMS;
    }

    if ( g_dwNumOpen >= cJoyMaxInWinmm )
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return MMSYSERR_NODRIVER") );
        return MMSYSERR_NODRIVER;      //we don't support to capture more than two joysticks
    }

    if ( uPeriod < MIN_PERIOD )
    {
        uPeriod = MIN_PERIOD;
    } else if ( uPeriod > MAX_PERIOD )
    {
        uPeriod = MAX_PERIOD;
    }

    if ( g_pJoyDev[idJoy] )
    {            //already opened
        if ( hwnd == g_pJoyDev[idJoy]->hwnd )
        {
            if( (g_pJoyDev[idJoy]->uPeriod == uPeriod)
              && (g_pJoyDev[idJoy]->fChanged = fChanged) ) {
                JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return JOYERR_NOCANDO") );
                return JOYERR_NOCANDO;
            }

            g_pJoyDev[idJoy]->uPeriod = uPeriod;                      //assign new values
            g_pJoyDev[idJoy]->fChanged = fChanged;

            JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return JOYERR_NOERROR") );
            return JOYERR_NOERROR;
        } else
        {
            if ( IsWindow(g_pJoyDev[idJoy]->hwnd) )
            {    //already get focus
                JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return JOYERR_NOCANDO") );
                return JOYERR_NOCANDO;              //is being used by another windows
            }
        }
    }

    if ( joyGetDevCaps (idJoy, &JoyCaps, sizeof(JOYCAPS)) == JOYERR_NOERROR )
    {
        uPeriod = min(JoyCaps.wPeriodMax,max(JoyCaps.wPeriodMin,uPeriod));
    } else
    {
        JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return MMSYSERR_NODRIVER") );
        return MMSYSERR_NODRIVER;
    }

    // ensure that position info. is ok.
    if ( w = joyGetPos(idJoy, lpinfo) )
    {      //something wrong, so just return
        JOY_DBGPRINT( JOY_ERR, ("joySetCapture: return %d", w) );
        return(w);
    }

    DllEnterCrit();

    mmRes = (MMRESULT)joyOpen(idJoy, NULL);

    if ( SUCCEEDED(mmRes) )
    {
        if ( !(g_pJoyDev[idJoy]->uIDEvent = SetTimer(NULL, 0, uPeriod, joyPollCallback)) )
        {
            joyClose(idJoy);
            mmRes = JOYERR_NOCANDO;
            goto _OUT;
        }

        g_pJoyDev[idJoy]->hwnd = hwnd;
        g_pJoyDev[idJoy]->uIDJoy = g_dwNumOpen;
        g_pJoyDev[idJoy]->uPeriod = uPeriod;
        g_pJoyDev[idJoy]->fChanged = fChanged;
        g_pJoyDev[idJoy]->uThreshold = 0;

        g_dwNumOpen++;

        mmRes = JOYERR_NOERROR;
    } else
    {
        mmRes = MMSYSERR_NODRIVER;
    }

    _OUT:
    DllLeaveCrit();

    JOY_DBGPRINT( JOY_BABBLE, ("joySetCapture: return %d", mmRes) );
    return mmRes;
}

/****************************************************************************

    @doc WINAPI

    @api UINT | joyReleaseCapture | This function releases the capture
    set by <f joySetCapture> on the specified joystick device.

    @parm UINT | idJoy | Identifies the joystick device to be released.
    This value is either JOYSTICKID1 or JOYSTICK2.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p idJoy> is invalid.

    @xref joySetCapture
****************************************************************************/

MMRESULT WINAPI joyReleaseCapture(UINT idJoy)
{
    JOY_DBGPRINT( JOY_BABBLE, ("joyReleaseCapture: idJoy=%d", idJoy) );

    if ( idJoy >= cJoyMax )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyReleaseCapture: return JOYERR_PARMS(idJoy > 16)") );
        return JOYERR_PARMS;
    }

    if ( !g_pJoyDev[idJoy] )
    {
        JOY_DBGPRINT( JOY_ERR, ("joyReleaseCapture: return MMSYSERR_NODRIVER") );
        return MMSYSERR_INVALPARAM;
    }

    DllEnterCrit();

    // kill the timer
    if ( g_pJoyDev[idJoy]->uIDEvent )
    {
        KillTimer (NULL, g_pJoyDev[idJoy]->uIDEvent);
    }

    DllLeaveCrit();

    JOY_DBGPRINT( JOY_ERR, ("joyReleaseCapture: return JOYERR_NOERROR") );
    return JOYERR_NOERROR;
}


/****************************************************************************
    @doc WINAPI

    @api void | joyPollCallback | Function called for joystick
     timer polling scheme initiated from SetCapture call.

    @parm HWND | hWnd | Identifies the window associated with the timer
    event.

    @parm UINT | wMsg | Specifies the WM_TIMER message.

    @parm UINT | uIDEvent | Specifies the timer's ID.

    @parm DWORD | dwTime | Specifies the current system time.

****************************************************************************/

void CALLBACK joyPollCallback(HWND hWnd, UINT wMsg, UINT_PTR uIDEvent, DWORD dwTime)
{
#define     diff(w1,w2) (UINT)(w1 > w2 ? w1-w2 : w2-w1)

    static  JOYINFO  oldInfo[cJoyMaxInWinmm] = {{ 0, 0, 0, 0},{ 0, 0, 0, 0}};
    static  LPJOYDEVICE pJoyDev;
    JOYINFO Info;
    UINT    idJoy, w ,fBtnMask;

    for ( idJoy=0;idJoy<cJoyMax;idJoy++ )
    {
        if ( g_pJoyDev[idJoy] == NULL )
            continue;

        if ( uIDEvent == g_pJoyDev[idJoy]->uIDEvent )
        {
            pJoyDev = g_pJoyDev[idJoy];
            uIDEvent = pJoyDev->uIDJoy;
            break;
        }
    }

    if ( idJoy == cJoyMax )
    {
#ifdef DBG
        dprintf1((("MMSYSTEM: Invalid timer handle in joy.c\n") ));
        KillTimer (NULL, uIDEvent);
#endif
        return;
    }

    if ( !pJoyDev->hwnd || !IsWindow(pJoyDev->hwnd) )
    {
        joyReleaseCapture((UINT)uIDEvent);
    }

    if ( !joyGetPos((UINT)uIDEvent,(LPJOYINFO)&Info) )
    {

        for ( w=0,fBtnMask=1; w<4; w++,fBtnMask <<=1 )
        {
            if ( (Info.wButtons ^ oldInfo[uIDEvent].wButtons) & fBtnMask )
            {
                PostMessage( pJoyDev->hwnd,
                             (UINT)(uIDEvent + ((Info.wButtons & fBtnMask) ? MM_JOY1BUTTONDOWN : MM_JOY1BUTTONUP)),
                             (WPARAM)(Info.wButtons | fBtnMask << 8),
                             MAKELPARAM(Info.wXpos,Info.wYpos));
            }
        }

        if ( !pJoyDev->fChanged ||
             diff(Info.wXpos,oldInfo[uIDEvent].wXpos)>pJoyDev->uThreshold ||
             diff(Info.wYpos,oldInfo[uIDEvent].wYpos)>pJoyDev->uThreshold )
        {
            PostMessage( pJoyDev->hwnd,
                         (UINT)(MM_JOY1MOVE+uIDEvent),
                         (WPARAM)(Info.wButtons),
                         MAKELPARAM(Info.wXpos,Info.wYpos)); // WARNING: note the truncations
        }

        if ( !pJoyDev->fChanged ||
             diff(Info.wZpos,oldInfo[uIDEvent].wZpos)>pJoyDev->uThreshold )
        {
            PostMessage(
                       pJoyDev->hwnd,
                       (UINT)(MM_JOY1ZMOVE+uIDEvent),
                       (WPARAM)Info.wButtons,
                       MAKELPARAM(Info.wZpos,0));
        }

        oldInfo[uIDEvent] = Info;
    }

#undef  diff
}

void AssignToArray(LPCDIDEVICEOBJECTINSTANCE lpddoi, eCtrls CtrlID, DIOBJECTDATAFORMAT* pDevs)
{
    if (CtrlID < eSIM_THROTTLE) //axes
        if (!(lpddoi->dwType & DIDFT_AXIS)) //some bizarre FF stuff
            return;
    if (CtrlID < eBTN) //only want first one
        if (pDevs[CtrlID].dwType)
            return;
    //need to save GUIDs for the const data format pointers to pint to
    rgoWinMMGUIDs[CtrlID] = lpddoi->guidType;
    pDevs[CtrlID].pguid = &(rgoWinMMGUIDs[CtrlID]);
    pDevs[CtrlID].dwFlags = lpddoi->dwFlags;
    pDevs[CtrlID].dwOfs = lpddoi->dwOfs;
    pDevs[CtrlID].dwType = lpddoi->dwType;
}

//Assigns to the custom data format while preserving the offsets
void AssignToRGODF(DIOBJECTDATAFORMAT* pDof, int CtrlID)
{
    AssertF(CtrlID<MAX_FINAL);
    c_rgodfWinMMJoy[CtrlID].pguid = pDof->pguid;
    //c_rgodfWinMMJoy[CtrlID].pguid = NULL;
    c_rgodfWinMMJoy[CtrlID].dwFlags = pDof->dwFlags;
    c_rgodfWinMMJoy[CtrlID].dwType  = pDof->dwType;
}

/* This version assigns on the basis of Usage/Usage Page
 * This causes problems when using IHV remapping as this 
 * swaps the usage/usage page but not the guid. When we
 * then go into dinput to get the values it carefully swaps
 * it all back for us and we lose the mapping. Instead use the 
 * next version that assigns on the basis of guid (where applicable)
 * so the dinput remappings remain in place.
BOOL CALLBACK DIEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCE lpddoi,LPVOID pvRef)
{
    AssertF(lpddoi);
    if (!pvRef)
        return DIENUM_STOP; //we can't store them
    
    //check the data down to dwType is valid
    if (lpddoi->dwSize < 3*sizeof(DWORD)+sizeof(GUID))
    {
        //show some debug info
        return DIENUM_CONTINUE;
    }
    
    //first we check if it is a button
    if (lpddoi->dwType & DIDFT_BUTTON)
    {
        //the button number is the usage
        //and we want up to 32 of them
        if (lpddoi->wUsage<33)
            AssignToArray(lpddoi,eBTN+lpddoi->wUsage-1,pvRef);
        return DIENUM_CONTINUE;
    }

    switch (lpddoi->wUsagePage) {
    case HID_USAGE_PAGE_GENERIC:
        switch (lpddoi->wUsage) {
        case HID_USAGE_GENERIC_X:
            AssignToArray(lpddoi,eGEN_X,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_Y:
            AssignToArray(lpddoi,eGEN_Y,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_Z:
            AssignToArray(lpddoi,eGEN_Z,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_RX:
            AssignToArray(lpddoi,eGEN_RX,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_RY:
            AssignToArray(lpddoi,eGEN_RY,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_RZ:
            AssignToArray(lpddoi,eGEN_RZ,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_SLIDER:
            AssignToArray(lpddoi,eGEN_SLIDER,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_DIAL:
            AssignToArray(lpddoi,eGEN_DIAL,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_GENERIC_HATSWITCH:
            AssignToArray(lpddoi,eGEN_POV,pvRef);
            return DIENUM_CONTINUE;
        }
    break;
    
    case HID_USAGE_PAGE_SIMULATION:
        switch (lpddoi->wUsage) {
        case HID_USAGE_SIMULATION_STEERING:
            AssignToArray(lpddoi,eSIM_STEERING,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_SIMULATION_ACCELERATOR:
            AssignToArray(lpddoi,eSIM_ACCELERATOR,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_SIMULATION_THROTTLE:
            AssignToArray(lpddoi,eSIM_THROTTLE,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_SIMULATION_RUDDER:
            AssignToArray(lpddoi,eSIM_RUDDER,pvRef);
            return DIENUM_CONTINUE;
        case HID_USAGE_SIMULATION_BRAKE:
            AssignToArray(lpddoi,eSIM_BRAKE,pvRef);
            return DIENUM_CONTINUE;
        }
        break;
    }
    return DIENUM_CONTINUE;
}
******************************************************************/

//This one assigns on the basis of GUID
BOOL CALLBACK DIEnumDeviceObjectsCallback(LPCDIDEVICEOBJECTINSTANCE lpddoi,LPVOID pvRef)
{
    AssertF(lpddoi);
    if (!pvRef)
        return DIENUM_STOP; //we can't store them
    
    //check the data down to dwType is valid
    if (lpddoi->dwSize < 3*sizeof(DWORD)+sizeof(GUID))
    {
        //show some debug info
        return DIENUM_CONTINUE;
    }
    
    if (lpddoi->wUsagePage == HID_USAGE_PAGE_GENERIC &&
            lpddoi->wUsage == HID_USAGE_GENERIC_DIAL)
        AssignToArray(lpddoi,eGEN_DIAL,pvRef);
    else if (lpddoi->wUsagePage == HID_USAGE_PAGE_SIMULATION)
    {
        switch (lpddoi->wUsage) 
        {
        case HID_USAGE_SIMULATION_STEERING:
            AssignToArray(lpddoi,eSIM_STEERING,pvRef);break;
        case HID_USAGE_SIMULATION_ACCELERATOR:
            AssignToArray(lpddoi,eSIM_ACCELERATOR,pvRef);break;
        case HID_USAGE_SIMULATION_THROTTLE:
            AssignToArray(lpddoi,eSIM_THROTTLE,pvRef);break;
        case HID_USAGE_SIMULATION_RUDDER:
            AssignToArray(lpddoi,eSIM_RUDDER,pvRef);break;
        case HID_USAGE_SIMULATION_BRAKE:
            AssignToArray(lpddoi,eSIM_BRAKE,pvRef);break;
        }
    }
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_Button))
    {
        //the button number is the usage
        //and we want up to 32 of them
        if (lpddoi->wUsage<33)
            AssignToArray(lpddoi,eBTN+lpddoi->wUsage-1,pvRef);
    }
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_XAxis))
        AssignToArray(lpddoi,eGEN_X,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_YAxis))
        AssignToArray(lpddoi,eGEN_Y,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_ZAxis))
        AssignToArray(lpddoi,eGEN_Z,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_RxAxis))
        AssignToArray(lpddoi,eGEN_RX,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_RyAxis))
        AssignToArray(lpddoi,eGEN_RY,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_RzAxis))
        AssignToArray(lpddoi,eGEN_RZ,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_Slider))
        AssignToArray(lpddoi,eGEN_SLIDER,pvRef);
    else if (IsEqualGUID(&(lpddoi->guidType),&GUID_POV))
        AssignToArray(lpddoi,eGEN_POV,pvRef);
    
    return DIENUM_CONTINUE;
}

#define USED_RX 0x01
#define USED_RY 0x02
//#define USED_RZ 0x04
//#define USED_RUDDER 0x08
//#define USED_BRAKE 0x10
#define USED_THROT 0x20 
#define USED_SLIDER 0x40
#define USED_DIAL 0x80

//Perform mapping of ctrls to axes/pov/btns as in joyhid.c
//return caps word and number of buttons and axes
void AssignMappings(DIOBJECTDATAFORMAT *dwAll, DWORD *dwCaps, DWORD *dwBtns, DWORD *dwAxes)
{
    int i;
    BYTE bUsed=0x00; //to prevent dual mapping
    *dwAxes=0;
    //Do the X-Axis
    if (dwAll[eGEN_X].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_X]),0);
        (*dwAxes)++;
    }
    else if (dwAll[eSIM_STEERING].dwType)
    {
        AssignToRGODF(&(dwAll[eSIM_STEERING]),0);
        (*dwAxes)++;
    }
    else if (dwAll[eGEN_RY].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_RY]),0);
        bUsed |= USED_RY;
        (*dwAxes)++;
    }
    //Y-Axis
    if (dwAll[eGEN_Y].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_Y]),1);
        (*dwAxes)++;
    }
    else if (dwAll[eSIM_ACCELERATOR].dwType)
    {
        AssignToRGODF(&(dwAll[eSIM_ACCELERATOR]),1);
        (*dwAxes)++;
    }
    else if (dwAll[eGEN_RX].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_RX]),1);
        bUsed |= USED_RX;
        (*dwAxes)++;
    }
    //Z-Axis
    if (dwAll[eGEN_Z].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_Z]),2);
        *dwCaps |= JOYCAPS_HASZ;
        (*dwAxes)++;
    }
    else if (dwAll[eSIM_THROTTLE].dwType)
    {
        AssignToRGODF(&(dwAll[eSIM_THROTTLE]),2);
        *dwCaps |= JOYCAPS_HASZ;
        bUsed |= USED_THROT;
        (*dwAxes)++;
    }
    else if (dwAll[eGEN_SLIDER].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_SLIDER]),2);
        *dwCaps |= JOYCAPS_HASZ;
        bUsed |= USED_SLIDER;
        (*dwAxes)++;
    }
    else if (dwAll[eGEN_DIAL].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_DIAL]),2);
        *dwCaps |= JOYCAPS_HASZ;
        bUsed |= USED_DIAL;
        (*dwAxes)++;
    }
    //RUV need use same set
    for (i=0;i<3;++i)
    {
      if (!i) //R Only
      {
        if (dwAll[eSIM_RUDDER].dwType)
        {
            AssignToRGODF(&(dwAll[eSIM_RUDDER]),3);
            *dwCaps |= JOYCAPS_HASR;
            (*dwAxes)++;
            continue;
        }
        if (dwAll[eGEN_RZ].dwType)
        {
            AssignToRGODF(&(dwAll[eGEN_RZ]),3);
            *dwCaps |= JOYCAPS_HASR;
            (*dwAxes)++;
            continue;
        }
        if (dwAll[eSIM_BRAKE].dwType)
        {
            AssignToRGODF(&(dwAll[eSIM_BRAKE]),3);
            *dwCaps |= JOYCAPS_HASR;
            (*dwAxes)++;
            continue;
        }
      }
      if (i<2) //not V
      {
        if (dwAll[eSIM_THROTTLE].dwType && !(bUsed&USED_THROT))
        {
            AssignToRGODF(&(dwAll[eSIM_THROTTLE]),3+i);
            if (!i)
                *dwCaps |= JOYCAPS_HASR;
            else
                *dwCaps |= JOYCAPS_HASU;
            bUsed |= USED_THROT;
            (*dwAxes)++;
            continue;
        }
        if (dwAll[eGEN_SLIDER].dwType && !(bUsed&USED_SLIDER))
        {
            AssignToRGODF(&(dwAll[eGEN_SLIDER]),3+i);
            if (!i)
                *dwCaps |= JOYCAPS_HASR;
            else
                *dwCaps |= JOYCAPS_HASU;
            bUsed |= USED_SLIDER;
            (*dwAxes)++;
            continue;
        }
        if (dwAll[eGEN_DIAL].dwType && !(bUsed&USED_DIAL))
        {
            AssignToRGODF(&(dwAll[eGEN_DIAL]),3+i);
            if (!i)
                *dwCaps |= JOYCAPS_HASR;
            else
                *dwCaps |= JOYCAPS_HASU;
            bUsed |= USED_DIAL;
            (*dwAxes)++;
            continue;
        }
        if (dwAll[eGEN_RY].dwType && !(bUsed&USED_RY))
        {
            AssignToRGODF(&(dwAll[eGEN_RY]),3+i);
            if (!i)
                *dwCaps |= JOYCAPS_HASR;
            else
                *dwCaps |= JOYCAPS_HASU;
            bUsed |= USED_RY;
            (*dwAxes)++;
            continue;
        }
      }
      //All 3
      if (dwAll[eGEN_RX].dwType && !(bUsed&USED_RX))
      {
        AssignToRGODF(&(dwAll[eGEN_RX]),3+i);
        if (!i)
            *dwCaps |= JOYCAPS_HASR;
        else if (i==1)
            *dwCaps |= JOYCAPS_HASU;
        else 
            *dwCaps |= JOYCAPS_HASV;
        bUsed |= USED_RX;
        (*dwAxes)++;
      }
    } //RUV loop
    //POV control
    if (dwAll[eGEN_POV].dwType)
    {
        AssignToRGODF(&(dwAll[eGEN_POV]),6);
        *dwCaps |= JOYCAPS_HASPOV;
    }
    //now the buttons
    *dwBtns = 0;
    for (i=0;i<MAX_BTNS;++i)
    {
        if (dwAll[eBTN+i].dwType)
        {
            AssignToRGODF(&(dwAll[eBTN+i]),7+i);
            (*dwBtns)++;
        }
    }
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   LRESULT | joyOpen |
 *
 *          Called to open a Joystick with a specified Id.
 *
 *  @parm   UINT | idJoy |
 *
 *          Id of the Joystick to be opened.
 *
 *  @returns LRESULT
 *          DRV_OK indicates the required joystick driver was loaded and
 *          can be accessed
 *
 *****************************************************************************/

HRESULT WINAPI joyOpen(UINT idJoy, LPJOYCAPSW pjc )
{
    HRESULT         hres = S_OK;
    LPJOYDEVICE     pJoyDev;
    DWORD           dwBtns = 0x00;
    DWORD           dwCaps = 0x00;
    DWORD           dwAxes = 0x00;

    AssertF(DllInCrit());

    if ( idJoy >= cJoyMax )
    {
        hres = E_FAIL;
        goto done;
    }

    pJoyDev  = g_pJoyDev[idJoy];
    if ( pJoyDev == NULL )
    {

        if ( !g_hinstDinputDll )
        {
            g_hinstDinputDll = LoadLibrary(TEXT("DINPUT.DLL"));

            if ( g_hinstDinputDll )
            {
                g_farprocDirectInputCreateW = GetProcAddress( g_hinstDinputDll, "DirectInputCreateW" );

                if ( !g_farprocDirectInputCreateW )
                {
                    dprintf1(( ("GetProcAddress(DirectInputCreateW) failed.") ));
                    FreeLibrary(g_hinstDinputDll);
                    g_hinstDinputDll = 0;
                    hres = E_FAIL;
                    goto done;
                }
            } else
            {
                dprintf1(( ("LoadLibrary(dinput.dll) failed.") ));
                hres = E_FAIL;
                goto done;
            }
        }

        if ( !g_pdi )
        {
            // Create the DirectInput interface object
            hres = (HRESULT)g_farprocDirectInputCreateW( ghInst, DIRECTINPUT_VERSION, &g_pdi, NULL) ;
        }

        if ( SUCCEEDED(hres) ) {
            // thread will not do anything until we let go oF the critical section
            if ( !g_fThreadExist )
            {
                g_hThreadMonitor = CreateThread(0, 0, joyMonitorThread, 0, 0, &g_dwThreadID);
                if ( g_hThreadMonitor )
                {
                    SetThreadPriority( g_hThreadMonitor, THREAD_PRIORITY_LOWEST );
                    g_fThreadExist = TRUE;
                    if( g_hEventWinmm ) {
                        ResetEvent( g_hEventWinmm );
                    }
                }

                CloseHandle( g_hThreadMonitor );
            }
        }

        if ( SUCCEEDED(hres) )
        {
            if ( !g_pdijc )
            {
                /* Query for the JoyConfig interface */
                hres = IDirectInput_QueryInterface(g_pdi,& IID_IDirectInputJoyConfig, &g_pdijc);
            }

            if ( SUCCEEDED(hres) )
            {
                DIJOYCONFIG jc;

                /* Get GUID that maps idJoy  */
                jc.dwSize = sizeof(jc);

                IDirectInputJoyConfig_SendNotify( g_pdijc );

                hres = IDirectInputJoyConfig_GetConfig(g_pdijc, idJoy, &jc, DIJC_REGHWCONFIGTYPE | DIJC_GUIDINSTANCE | DIJC_GAIN );
                if ( SUCCEEDED(hres) )
                {
                    LPDIRECTINPUTDEVICEW   pdidTemp;
                    LPDIRECTINPUTDEVICE2W  pdid;

                    hres = IDirectInput_CreateDevice(g_pdi, &jc.guidInstance, &pdidTemp, NULL);
                    /* Create the device object */
                    if ( SUCCEEDED(hres) )
                    {
                        hres = IDirectInputDevice_QueryInterface(pdidTemp, &IID_IDirectInputDevice2, &pdid);

                        IDirectInputDevice_Release(pdidTemp);
                        (void*)pdidTemp = NULL;

                        if ( SUCCEEDED(hres) )
                        {
                        /* enumerate our controls into the superset*/
                        DIOBJECTDATAFORMAT didoAll[MAX_CTRLS];
                        int i=0;
                        for (i=0;i<MAX_CTRLS;++i)
                        {
                            didoAll[i].dwFlags = 0;//DIDFT_ANYINSTANCE | DIDFT_OPTIONAL;
                            didoAll[i].dwOfs = 0;
                            didoAll[i].dwType = 0;
                            didoAll[i].pguid = NULL;
                        }
                        hres = IDirectInputDevice2_EnumObjects(
                                   pdid,   
                                   DIEnumDeviceObjectsCallback,
                                   didoAll,
                                   DIDFT_ALL);

                        // c_rgodfWinMMJoy needs to be reset for every device.
                        RESET_RGODFWINMMJOY();

                        // Assign our values to the custom device format
                        AssignMappings(didoAll,&dwCaps,&dwBtns,&dwAxes);
                        if ( SUCCEEDED(hres) )
                        {
                            
                            DIDEVCAPS   dc;

                            dc.dwSize = sizeof(DIDEVCAPS_DX3);
                            hres = IDirectInputDevice2_GetCapabilities(pdid, &dc);

                            if ( SUCCEEDED(hres) )
                            {
                                hres = IDirectInputDevice2_SetCooperativeLevel(pdid, NULL, DISCL_NONEXCLUSIVE | DISCL_BACKGROUND );
                                if ( SUCCEEDED(hres) )
                                {
                                    //set to our new custom device format
                                    hres = IDirectInputDevice2_SetDataFormat(pdid, (LPCDIDATAFORMAT)&c_dfWINMMJoystick);
                                    if ( SUCCEEDED(hres) )
                                    {
                                        pJoyDev = LocalAlloc( LPTR, sizeof(JOYDEVICE) );
                                        if ( pJoyDev )
                                        {
                                            memset( pJoyDev, 0, sizeof(*pJoyDev) );
                                            pJoyDev->pdid = pdid;
                                            pJoyDev->dwButtons = dc.dwButtons;
                                            pJoyDev->dwFlags = 0x0;
                                            pJoyDev->uState = INUSE;

                                            // get values for pJoyDev->jcw
                                            {
                                                DIDEVICEINSTANCE didi;
                                                didi.dwSize = sizeof(didi);

                                                IDirectInputDevice2_Acquire(pdid);
                                                hres = IDirectInputDevice2_GetDeviceInfo(pdid, &didi);

                                                if ( SUCCEEDED(hres) )
                                                {
                                                    DIPROPDWORD dipd;

                                                    if( g_dwEnableWheel ) {
                                                        DIDEVICEOBJECTINSTANCE didoi;

                                                        didoi.dwSize = sizeof(DIDEVICEOBJECTINSTANCE);

                                                        hres = IDirectInputDevice2_GetObjectInfo( pdid, &didoi, DIJOFS_Y, DIPH_BYOFFSET);
                                                        if ( SUCCEEDED(hres) )
                                                        {
                                                            if ( didoi.wUsagePage == 2 && didoi.wUsage == 196 ) // This is Accelerator
                                                            {
                                                                if ( jc.hwc.hws.dwFlags  & JOY_HWS_HASR )
                                                                { // Is this Brake?
                                                                    hres = IDirectInputDevice2_GetObjectInfo( pdid, &didoi, DIJOFS_RZ, DIPH_BYOFFSET);
                                                                    if ( SUCCEEDED(hres) )
                                                                    {
                                                                        if ( didoi.wUsagePage == 2 && didoi.wUsage == 197 ) // This is Accelerator
                                                                        {
                                                                            //Yes, this is brake, great!
                                                                            g_fHasWheel = TRUE;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    } // g_dwEnableWheel


                                                    memset( &(pJoyDev->jcw), 0, sizeof(pJoyDev->jcw) );

                                                    dipd.diph.dwSize = sizeof(dipd);
                                                    dipd.diph.dwHeaderSize = sizeof(dipd.diph);
                                                    dipd.diph.dwHow  = DIPH_BYOFFSET;
                                                    // use our mapped one instead if available
                                                    if (c_rgodfWinMMJoy[6].dwType)
                                                        dipd.diph.dwObj = c_rgodfWinMMJoy[6].dwOfs;
                                                    else
                                                        dipd.diph.dwObj = DIJOFS_POV(0);

                                                    hres = IDirectInputDevice2_GetProperty( pdid , DIPROP_GRANULARITY, & dipd.diph );

                                                    if ( SUCCEEDED(hres) )
                                                    {
                                                        //(pJoyDev->jcw).wCaps |= JOYCAPS_HASPOV; //should now be set by AssignMappings
                                                        AssertF(dwCaps&JOYCAPS_HASPOV);
                                                        //Do this instead to copy VJOYD
                                                        dwCaps |= JOYCAPS_POV4DIR;
                                                        /***************
                                                        if ( dipd.dwData >= 9000 )
                                                        { // 4 directional POV
                                                            (pJoyDev->jcw).wCaps |= JOYCAPS_POV4DIR;
                                                        } else
                                                        { // Continuous POV
                                                            (pJoyDev->jcw).wCaps |= JOYCAPS_POVCTS;
                                                        }
                                                        *****************/
                                                    } else
                                                    {
                                                        hres = S_OK;
                                                    }

                                                    (pJoyDev->jcw).wMid = LOWORD(didi.guidProduct.Data1);    // manufacturer ID
                                                    (pJoyDev->jcw).wPid = HIWORD(didi.guidProduct.Data1);    // product ID
                                                    LoadString (ghInst,STR_JOYSTICKNAME,(LPTSTR)(&((pJoyDev->jcw).szPname)),cchLENGTH((pJoyDev->jcw).szPname));

                                                    /*
                                                     * Already memset to 0
                                                     *
                                                       (pJoyDev->jcw).wXmin =
                                                       (pJoyDev->jcw).wYmin =
                                                       (pJoyDev->jcw).wZmin =
                                                       (pJoyDev->jcw).wRmin =
                                                       (pJoyDev->jcw).wUmin =
                                                       (pJoyDev->jcw).wVmin = 0;
                                                     */

                                                    (pJoyDev->jcw).wXmax =
                                                    (pJoyDev->jcw).wYmax =
                                                    (pJoyDev->jcw).wZmax =
                                                    (pJoyDev->jcw).wRmax =
                                                    (pJoyDev->jcw).wUmax =
                                                    (pJoyDev->jcw).wVmax = 0xFFFF;

                                                    (pJoyDev->jcw).wPeriodMin  = MIN_PERIOD;                   // minimum message period when captured
                                                    (pJoyDev->jcw).wPeriodMax  = MAX_PERIOD;                   // maximum message period when captured

                                                    //Now set buttons and axes by Assign Mappings
                                                    //(pJoyDev->jcw).wNumAxes    = dc.dwAxes;                    // number of axes in use
                                                    //(pJoyDev->jcw).wNumButtons = dc.dwButtons;                 // number of buttons
                                                    //(pJoyDev->jcw).wMaxAxes    = cJoyPosAxisMax;               // maximum number of axes supported
                                                    //(pJoyDev->jcw).wMaxButtons = cJoyPosButtonMax;             // maximum number of buttons supported
                                                    (pJoyDev->jcw).wNumAxes    = dwAxes;
                                                    (pJoyDev->jcw).wNumButtons = dwBtns;
                                                    (pJoyDev->jcw).wMaxAxes    = 6;               // maximum number of axes supported
                                                    (pJoyDev->jcw).wMaxButtons = MAX_BTNS;             // maximum number of buttons supported

                                                    lstrcpyW((pJoyDev->jcw).szRegKey,  cwszREGKEYNAME );        // registry key
                                                    
                                                    //Copy settings from AssignMappings
                                                    (pJoyDev->jcw).wCaps |= dwCaps;
                                                    /***************
                                                    // Now done in AssignMappings
                                                    if( !g_fHasWheel ) {
                                                        if ( jc.hwc.hws.dwFlags  & JOY_HWS_HASZ )
                                                            (pJoyDev->jcw).wCaps |= JOYCAPS_HASZ;
                                                        if ( jc.hwc.hws.dwFlags  & JOY_HWS_HASR )
                                                            (pJoyDev->jcw).wCaps |= JOYCAPS_HASR;
                                                    }

                                                    if ( jc.hwc.hws.dwFlags  & JOY_HWS_HASU )
                                                        (pJoyDev->jcw).wCaps |= JOYCAPS_HASU;
                                                    if ( jc.hwc.hws.dwFlags  & JOY_HWS_HASV )
                                                        (pJoyDev->jcw).wCaps |= JOYCAPS_HASV;
                                                    *******************/
                                                }
                                            }

                                            if( pjc ) {
                                                memcpy( pjc, &(pJoyDev->jcw), sizeof(pJoyDev->jcw) );
                                            }

                                        } else
                                        { // Local Alloc FAILED
                                            hres = E_OUTOFMEMORY;

                                            dprintf1( ("LocalAlloc, FAILED") );
                                        }

                                    } else
                                    { // SetDataFormat FAILED
                                        dprintf1(( ("SetDataFormat, FAILED hres=%08lX"), hres ));
                                    }
                                } else
                                { // SetCooperativeLevel FAILED
                                    dprintf1(( ("SetCooperativeLevel, FAILED hres=%08lX"), hres ));
                                }

                            } else
                            { // GetCapabilities FAILED
                                dprintf1(( ("GetCapabilities, FAILED hres=%08lX"), hres ));
                            }
                            } else
                            { // EnumObjects FAILED
                                dprintf1(( ("EnumObjects, FAILED hres=%08lX"), hres ));
                            }
                        } else
                        { // QueryInterface FAILED
                            dprintf1(( ("QueryInterface, FAILED hres=%08lX"), hres ));
                        }
                        /* If we fail to intitialize the device, then release the interface */
                        if ( FAILED(hres) )
                        {
                            LocalFree( (HLOCAL)pJoyDev );
                            IDirectInputDevice2_Release(pdid);
                        }
                    } else
                    { // Create Device Failed
                        dprintf1(( ("CreateDevice, FAILED hres=%08lX"), hres ));
                    }
                } else
                { // JoyGetConfig FAILED
                    dprintf1(( ("joyGetConfig, FAILED hres=%08lX"), hres ));
                }

                /* Release the JoyConfig Interface */
                //IDirectInputJoyConfig_Release(pdijc);
            } else
            { // QI for JoyConfig FAILED
                dprintf1(( ("QueryInterface for JoyConfig, FAILED hres=%08lX"), hres ));
            }

            /* Release the Direct Input interface */
            //IDirectInput_Release(pdi);
        } else
        { // IDirectInputCreate FAILED
            dprintf1(( ("IDirectInputCreate, FAILED hres=%08lX"), hres ));
        }
        g_pJoyDev[idJoy] = pJoyDev;

    } else
    { // Device Interface already exists
        pJoyDev->uState = INUSE;
        if( pjc ) {
            memcpy( pjc, &(pJoyDev->jcw), sizeof(pJoyDev->jcw) );
        }

        hres = S_OK;
    }
    done:
    return hres;
}


/****************************************************************************

    @doc WINAPI

    @api void | joyMonitorThread | This function monitors whether there is a joystick
            that has not being used for a specific time. If yes, close this joystick. If
            there is no joystick opened. This thread will exit itself.

****************************************************************************/

DWORD WINAPI joyMonitorThread(LPVOID lpv)
{
    UINT idJoy;
    LPJOYDEVICE pjd;
    BOOL fJoyOpen = TRUE;
    DWORD dwWaitResult;
    
    while ( fJoyOpen )
    {
        fJoyOpen = FALSE;            //prepare to exit, and this thread will die.

        dwWaitResult = WaitForSingleObject(g_hEventWinmm, 60000);
        if ( dwWaitResult == WAIT_OBJECT_0 ) {
            //DInput has been released.
            JOY_DBGPRINT( JOY_BABBLE, ("joyMonitorThread: DInput has been released.") );
            break;
        } else if ( dwWaitResult == WAIT_TIMEOUT ) {
            ;
        } else {
            //g_hEventWinmm is ABANDONED, or NULL.
            SleepEx( 60000, FALSE );
        }

        for ( idJoy = 0x0; idJoy < cJoyMax; idJoy++ )
        {
            pjd = g_pJoyDev[idJoy];

            if ( pjd != NULL )
            {
                DllEnterCrit();
                if ( pjd->uState == INUSE )
                {
                    pjd->uState = DEATHROW;
                    fJoyOpen = TRUE;                //A joystick is still likely being used
                } else if ( pjd->uState == DEATHROW )
                {
                    pjd->uState = EXECUTE;
                    fJoyOpen = TRUE;                //A joystick is still likely being used
                } else
                { /* if ( pjd->bState == EXECUTE ) */
                    AssertF( pjd->uState == EXECUTE );
                    joyClose(idJoy);
                }
                DllLeaveCrit();
            }
        }

        if ( fJoyOpen == FALSE )
        {
            DllEnterCrit();
            joyCloseAll();
            DllLeaveCrit();
        }

    }

    g_fThreadExist = FALSE;

    return 0;
}


/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   VOID | joyClose |
 *
 *          Close a Joystick with specific Id.
 *
 *  @parm   UINT | idJoy |
 *
 *          Id of the Joystick to be closed.
 *
 *
 *****************************************************************************/
void WINAPI joyClose( UINT idJoy )
{
    if ( idJoy < cJoyMax )
    {
        /* If the device is open, close it */
        if ( g_pJoyDev[idJoy] )
        {
            if ( g_hEventWinmm && WAIT_OBJECT_0 != WaitForSingleObject(g_hEventWinmm, 10))
            {
                //DInput has not been released.
                IDirectInputDevice2_Unacquire(g_pJoyDev[idJoy]->pdid);
                IDirectInputDevice2_Release(g_pJoyDev[idJoy]->pdid);
            }

            /* Free local memory */
            LocalFree( (HLOCAL)g_pJoyDev[idJoy] );
            g_pJoyDev[idJoy] = NULL;
        }
    }
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   VOID | joyCloseAll |
 *
 *          Close all currently opened Joysticks
 *
 *
 *****************************************************************************/
void WINAPI joyCloseAll( void )
{
    UINT idJoy;

    for ( idJoy=0; idJoy<cJoyMax; idJoy++ )
    {
        joyClose(idJoy);
    }
}


/****************************************************************************

    @doc WINAPI

    @api MMRESULT | joyConfigChanged | tells the joystick driver to that
    the configuration information about the joystick has changed.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_BADDEVICEID | The joystick driver is not present.

    @comm This is used by configuration utilites to tell the driver
      to update its info.   As well, it can be used by apps to
      set specific capabilites.  This will be documented later...

****************************************************************************/

MMRESULT WINAPI joyConfigChanged( DWORD dwFlags )
{
    JOY_DBGPRINT( JOY_BABBLE, ("joyConfigChanged: dwFalgs=0x%08x", dwFlags) );

    if ( dwFlags )
    {
        JOY_DBGPRINT( JOY_BABBLE, ("joyConfigChanged: dwFalgs=0x%08x", dwFlags) );
        return JOYERR_PARMS;
    }

    DllEnterCrit();

    joyCloseAll();

    DllLeaveCrit();

    PostMessage (HWND_BROADCAST, g_wmJoyChanged, 0, 0L);

    JOY_DBGPRINT( JOY_BABBLE, ("joyConfigChanged: return 0") );

    return 0L;
}

/****************************************************************************

    @doc INTERNAL

    @api UINT | joySetCalibration | This function sets the values used to
     convert the values returned by the joystick drivers GetPos function
     to the range specified in GetDevCaps.

    @parm UINT | idJoy | Identifies the joystick device

    @parm PUINT | pwXbase | Specifies the base value for the X pot.  The
      previous value will be copied back to the variable pointed to here.

    @parm PUINT | pwXdelta | Specifies the delta value for the X pot.   The
      previous value will be copied back to the variable pointed to here.

    @parm PUINT | pwYbase | Specifies the base value for the Y pot.  The
      previous value will be copied back to the variable pointed to here.

    @parm PUINT | pwYdelta | Specifies the delta value for the Y pot.   The
      previous value will be copied back to the variable pointed to here.

    @parm PUINT | pwZbase | Specifies the base value for the Z pot.  The
      previous value will be copied back to the variable pointed to here.

    @parm PUINT | pwZdelta | Specifies the delta value for the Z pot.   The
      previous value will be copied back to the variable pointed to here.

    @rdesc The return value is zero if the function was successful, otherwise
       it is an error number.

    @comm The base represents the lowest value the joystick driver returns,
      whereas the delta represents the multiplier to use to convert
      the actual value returned by the driver to the valid range
      for the joystick API's.
      i.e.  If the driver returns a range of 43-345 for the X pot, and
      the valid mmsystem API range is 0-65535, the base value will be
      43, and the delta will be 65535/(345-43)=217.  Thus the base,
      and delta convert 43-345 to a range of 0-65535 with the formula:
      ((wXvalue-43)*217) , where wXvalue was given by the joystick driver.

****************************************************************************/

// !!! We don't support it in WINMM again.
UINT APIENTRY joySetCalibration(UINT id, PUINT pwXbase, PUINT pwXdelta,
                                PUINT pwYbase, PUINT pwYdelta, PUINT pwZbase,
                                PUINT pwZdelta)
{
    JOY_DBGPRINT( JOY_BABBLE, ("joySetCalibration: not supported, please use DINPUT.") );
    return 0;
}


/************************************************************

    Debug

*************************************************************/

#ifdef DBG
int g_cCrit = -1;
UINT g_thidCrit;
TCHAR g_tszLogFile[MAX_PATH];
#endif

/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   void | //DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.  Failure to
 *          comply is a violation of the semaphore hierarchy and will
 *          lead to deadlocks.
 *
 *****************************************************************************/

void WINAPI DllEnterCrit(void)
{
    EnterCriticalSection(&joyCritSec);

#ifdef DBG
    if ( ++g_cCrit == 0 )
    {
        g_thidCrit = GetCurrentThreadId();
    }

    AssertF(g_thidCrit == GetCurrentThreadId());
#endif
}

/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   void | //DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void WINAPI DllLeaveCrit( void )
{
#ifdef DBG
    AssertF(g_thidCrit == GetCurrentThreadId());
    AssertF(g_cCrit >= 0);

    if ( --g_cCrit < 0 )
    {
        g_thidCrit = 0;
    }
#endif

    LeaveCriticalSection(&joyCritSec);
}

/*****************************************************************************
 *
 *  @doc    WINAPI
 *
 *  @func   void | DllInCrit |
 *
 *          Nonzero if we are in the DLL critical section.
 *
 *****************************************************************************/

#ifdef DBG
BOOL WINAPI DllInCrit( void )
{
    return( g_cCrit >= 0 && g_thidCrit == GetCurrentThreadId() );
}
#endif


#ifdef DBG
int WINAPI AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine)
{
    winmmDbgOut( ("Assertion failed: `%s' at %s(%d)"), ptszExpr, ptszFile, iLine);
    DebugBreak();
    return 0;
}

void joyDbgOut(LPSTR lpszFormat, ...)
{
    char buf[512];
    UINT n;
    va_list va;

    n = wsprintfA(buf, "WINMM::joy: ");

    va_start(va, lpszFormat);
    n += vsprintf(buf+n, lpszFormat, va);
    va_end(va);

    buf[n++] = '\n';
    buf[n] = 0;
    OutputDebugStringA(buf);
    Sleep(0);  // let terminal catch up
}

#endif

/*****************************************************************************
 *
 *  @doc
 *
 *  @func   HRESULT | hresMumbleKeyEx |
 *
 *          Either open or create the key, depending on the degree
 *          of access requested.
 *
 *  @parm   HKEY | hk |
 *
 *          Base key.
 *
 *  @parm   LPCTSTR | ptszKey |
 *
 *          Name of subkey, possibly NULL.
 *
 *  @parm   REGSAM | sam |
 *
 *          Security access mask.
 *
 *  @parm   DWORD   | dwOptions |
 *          Options for RegCreateEx
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives output key.
 *
 *  @returns
 *
 *          Return value from <f RegOpenKeyEx> or <f RegCreateKeyEx>,
 *          converted to an <t HRESULT>.
 *
 *****************************************************************************/

HRESULT hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    LONG lRc;

    /*
     *  If caller is requesting write access, then create the key.
     *  Else just open it.
     */
    if ( IsWriteSam(sam) )
    {
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);

        if ( lRc == ERROR_SUCCESS )
        {
            // Don't need to create it already exists

        }

        else
        {
            lRc = RegCreateKeyEx(hk, ptszKey, 0, 0,
                                 dwOptions,
                                 sam, 0, phk, 0);
        }
    } else
    {
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);
    }

    if ( lRc == ERROR_SUCCESS )
    {
        hres = S_OK;
    } else
    {
        if ( lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY )
        {
            lRc = ERROR_FILE_NOT_FOUND;
        }
        hres = hresLe(lRc);
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\drvr.c ===
/******************************************************************************

   Copyright (c) 1985-2001 Microsoft Corporation

   Title:   drvr.c - Installable driver code. Common code

   Version: 1.00

   Date:    10-Jun-1990

   Author:  DAVIDDS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   10-JUN-1990   ROBWI From windows 3.1 installable driver code by davidds
   28-FEB-1992   ROBINSP Port to NT

*****************************************************************************/

#include <windows.h>
#include <winmmi.h>
#include <stdlib.h>
#include <string.h>
#include "drvr.h"

int     cInstalledDrivers = 0;      // Count of installed drivers
HANDLE  hInstalledDriverList = 0;   // List of installed drivers

typedef LONG   (FAR PASCAL *SENDDRIVERMESSAGE31)(HANDLE, UINT, LPARAM, LPARAM);
typedef LRESULT (FAR PASCAL *DEFDRIVERPROC31)(DWORD_PTR, HANDLE, UINT, LPARAM, LPARAM);

extern SENDDRIVERMESSAGE31      lpSendDriverMessage;
extern DEFDRIVERPROC31          lpDefDriverProc;

extern void lstrncpyW (LPWSTR pszTarget, LPCWSTR pszSource, size_t cch);

__inline PWSTR lstrDuplicateW(PCWSTR pstr)
{
    PWSTR pstrDuplicate = (PWSTR)HeapAlloc(hHeap, 0, (lstrlenW(pstr)+1)*sizeof(WCHAR));
    if (pstrDuplicate) lstrcpyW(pstrDuplicate, pstr);
    return pstrDuplicate;
}


//============================================================================
// Basic hash helpers taken from LKRhash
//============================================================================

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

__inline DWORD
HashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}

// Small prime number used as a multiplier in the supplied hash functions
const DWORD HASH_MULTIPLIER = 101;

#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY
# define HASH_MULTIPLY(dw)   (((dw) << 7) - (dw))
#else
# define HASH_MULTIPLY(dw)   ((dw) * HASH_MULTIPLIER)
#endif

// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKRhash.

__inline DWORD
HashStringA(
    const char* psz,
    DWORD       dwHash)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// Unicode version of above

__inline DWORD
HashStringW(
    const wchar_t* pwsz,
    DWORD          dwHash)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}

// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKRhash.
// Note: this is not really adequate for MBCS strings.

__inline DWORD
HashStringNoCase(
    const char* psz,
    DWORD       dwHash)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

__inline DWORD
HashStringNoCaseW(
    const wchar_t* pwsz,
    DWORD          dwHash)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  (*pwsz & 0xFFDF);

    return dwHash;
}


/*
   FYI here are the first bunch of prime numbers up to around 1000

     2      3      5      7     11     13     17     19     23     29
     31     37     41     43     47     53     59     61     67     71
     73     79     83     89     97    101    103    107    109    113
    127    131    137    139    149    151    157    163    167    173
    179    181    191    193    197    199    211    223    227    229
    233    239    241    251    257    263    269    271    277    281
    283    293    307    311    313    317    331    337    347    349
    353    359    367    373    379    383    389    397    401    409
    419    421    431    433    439    443    449    457    461    463
    467    479    487    491    499    503    509    521    523    541
    547    557    563    569    571    577    587    593    599    601
    607    613    617    619    631    641    643    647    653    659
    661    673    677    683    691    701    709    719    727    733
    739    743    751    757    761    769    773    787    797    809
    811    821    823    827    829    839    853    857    859    863
    877    881    883    887    907    911    919    929    937    941
    947    953    967    971    977    983    991    997   1009   1013
*/

//============================================================================
//   StringId dictionary
//============================================================================

#define HASH_TABLESIZE (127)
PMMDRV StringIdDict[HASH_TABLESIZE];

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | StringId_Create | This function creates a unique string
 *   identifying a particular MME device.  The string can be used to
 *   subsequently retrieve the ID for the same MME device even if the devices
 *   have been renumbered.
 *
 * @parm IN PMMDRV | pdrv | Pointer to an MME driver.
 *
 * @parm IN UINT | port | Driver-relative device ID.
 *
 * @parm OPTIONAL OUT PWSTR* | pStringId | Address of a buffer to receive the
 *   pointer to the string.
 *
 * @parm OPTIONAL OUT ULONG* | pcbStringId | Receives size of buffer required
 *   to store the string.

 * @rdesc MMRESULT | Zero if successfull otherwise an error code defined
 *   in mmsystem.h.
 *
 * @comm The string is allocated by this function using the heap identified
 *   by the global variable hHeap.  The caller is responsible for ensuring
 *   the string is freed.
 *
 ****************************************************************************/
MMRESULT StringId_Create(IN PMMDRV pdrv, IN UINT port, OUT PWSTR* pStringId, OUT ULONG* pcbStringId)
{
    MMRESULT mmr;
    int cchStringId;
    PWSTR StringId;
    LONG  StringIdType;
    PCWSTR StringIdBase;

    // 8 chars type field + next colon delimiter
    cchStringId = 8 + 1;

    if (pdrv->cookie)
    {
	// 8 chars for device interface length field + next colon delimiter
	cchStringId += 8 + 1;
	// device interface name + next colon delimiter
        cchStringId += lstrlenW(pdrv->cookie) + 1;
        StringIdType = 1;
        StringIdBase = pdrv->cookie;
    }
    else
    {
	// file name + next colon delimiter
	cchStringId += lstrlenW(pdrv->wszDrvEntry) + 1;
        StringIdType = 0;
        StringIdBase = pdrv->wszDrvEntry;
    }

    // message proc name + next colon delimiter
    cchStringId += lstrlenW(pdrv->wszMessage) + 1;

    //  8 chars driver-relative ID, 1 terminator
    cchStringId += 8 + 1;

    mmr = MMSYSERR_NOERROR;

    if (pStringId)
    {
        StringId = HeapAlloc(hHeap, 0, cchStringId * sizeof(WCHAR));
        if (StringId)
        {
            int cchPrinted;
            switch (StringIdType)
            {
            	case 0:
            	    cchPrinted = swprintf(StringId, L"%08X:%s:%s:%08X", StringIdType, StringIdBase, pdrv->wszMessage, port);
            	    break;
            	case 1:
            	    cchPrinted = swprintf(StringId, L"%08X:%08X:%s:%s:%08X", StringIdType, lstrlenW(StringIdBase), StringIdBase, pdrv->wszMessage, port);
            	    break;
            	default:
            	    WinAssert(FALSE);
            	    break;
            }
            WinAssert(cchPrinted < cchStringId);
            *pStringId = StringId;
            // dprintf(("StringId_Create : note: created StringId=\"%ls\"", StringId));
        }
        else
        {
            mmr = MMSYSERR_NOMEM;
        }
    }

    if (!mmr && pcbStringId) *pcbStringId = cchStringId * sizeof(WCHAR);

    return mmr;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | StringIdDict_Initialize | This function ensures the
 *   dictionary is initialized.  It should be called by any function that uses
 *   the dictionary
 *
 * @rdesc void
 *
 ****************************************************************************/
void StringIdDict_Initialize(void)
{
    int i;
    static BOOL fInitialized = FALSE;
    
    if (fInitialized) return;
    
    for (i = 0; i < (sizeof(StringIdDict)/sizeof(StringIdDict[0])); i++) StringIdDict[i] = NULL;
    fInitialized = TRUE;
}

MMRESULT StringIdDict_SearchType0And1(IN ULONG Type, IN PWSTR pstrTypeXData, IN ULONG HashAx, OUT PMMDRV *ppdrv, OUT UINT *pport)
{
    PWSTR pstrDriver = NULL;
    PWSTR pstrMessage = NULL;
    PWSTR pstrPort = NULL;
    PWSTR pstr = pstrTypeXData;

    MMRESULT mmr = MMSYSERR_NOERROR;

    WinAssert((0 == Type) || (1 == Type));

    if (0 == Type)
    {
    	// "<driver-filename>:<driver-message-proc-name>:<driver-port>"
    	pstrDriver = pstr;
    	pstrMessage = wcschr(pstrDriver, L':');
    	if (pstrMessage) *pstrMessage++ = L'\0';
    }
    else // 1 == Type
    {
    	// "<driver-device-interface-length>:<driver-device-interface>:<driver-message-proc-name>:<driver-port>"
    	int cchDeviceInterface = wcstol(pstr, &pstrDriver, 16);
    	if (L':' != *pstrDriver) pstrDriver = NULL;
    	if (pstrDriver) {
    	    *pstrDriver++ = L'\0';
    	    pstrMessage = pstrDriver + cchDeviceInterface;
            if (L':' == *pstrMessage) *pstrMessage++ = L'\0';
            else pstrMessage = NULL;
    	}
    }

    if (pstrMessage)
    {
    	pstrPort = wcschr(pstrMessage, L':');
        if (pstrPort) *pstrPort++ = L'\0';
    }

    // now hash the substrings and search the hash chain for a match
    if (pstrDriver && pstrMessage && pstrPort)
    {
    	UINT   port;
    	PMMDRV pdrv;
    	int    cHashMisses;
    	PWCHAR pch;
    	
    	HashAx = HashStringNoCaseW(pstrDriver, HashAx);
    	HashAx = HashStringNoCaseW(pstrMessage, HashAx);
        HashAx = HashScramble(HashAx) % HASH_TABLESIZE;
        	
        mmr = MMSYSERR_NODRIVER;

        port = wcstol(pstrPort, &pch, 16);

        for (pdrv = StringIdDict[HashAx], cHashMisses = 0;
    	     pdrv;
    	     pdrv = pdrv->NextStringIdDictNode, cHashMisses++)
    	{
    	    if (0 == Type)
    	    {
    	        if (pdrv->cookie) continue;
    	        if (lstrcmpiW(pdrv->wszDrvEntry, pstrDriver)) continue;
    	    }
    	    else // 1 == Type
    	    {
    	        if (!pdrv->cookie) continue;
    	        if (lstrcmpiW(pdrv->cookie, pstrDriver)) continue;
    	    }
    	    if (lstrcmpiW(pdrv->wszMessage, pstrMessage)) continue;


    	    *ppdrv = pdrv;
    	    *pport = port;

    	    if (cHashMisses) dprintf(("StringIdDict_SearchType0And1 : note: %d hash misses", cHashMisses));
    	
    	    mmr = MMSYSERR_NOERROR;
    	    break;
    	}
    }
    else
    {
    	mmr = MMSYSERR_INVALPARAM;
    }

    return mmr;
}

MMRESULT StringIdDict_Search(IN PCWSTR InStringId, OUT PMMDRV *ppdrv, OUT UINT *pport)
{
    PWSTR StringId;
    MMRESULT mmr = MMSYSERR_NOERROR;

    StringIdDict_Initialize();

    StringId = lstrDuplicateW(InStringId);
    if (StringId)
    {
    	ULONG Type;
    	PWSTR pstr;
    	PWSTR pstrType;

	pstr = StringId;
	pstrType = pstr;
    	
        Type = wcstol(pstrType, &pstr, 16);
        if (*pstr == L':')
        {
            ULONG HashAx;	// Hash accumulator

            *pstr++ = L'\0';
            HashAx = HashStringNoCaseW(pstrType, 0);

            switch (Type)
            {
                case 0:
    	            mmr = StringIdDict_SearchType0And1(Type, pstr, HashAx, ppdrv, pport);
    	            break;
    	        case 1:
    	            mmr = StringIdDict_SearchType0And1(Type, pstr, HashAx, ppdrv, pport);
    	            break;
    	        default:
    	            mmr = MMSYSERR_INVALPARAM;
    	            break;
            }
        }
        else
        {
            mmr = MMSYSERR_INVALPARAM;
        }

        HeapFree(hHeap, 0, StringId);
    }
    else
    {
    	mmr = MMSYSERR_NOMEM;
    }

    if (mmr) dprintf(("StringIdDict_Search : error: returning mmresult %d", mmr));
    return mmr;
}

void StringIdDict_Insert(PMMDRV pdrv)
{
    ULONG HashAx;
    MMRESULT mmr;

    StringIdDict_Initialize();

    if (!pdrv->cookie)
    {
    	HashAx = HashStringNoCaseW(L"00000000", 0);
    	HashAx = HashStringNoCaseW(pdrv->wszDrvEntry, HashAx);
    }
    else
    {
    	HashAx = HashStringNoCaseW(L"00000001", 0);
    	HashAx = HashStringNoCaseW(pdrv->cookie, HashAx);
    }
    HashAx = HashStringNoCaseW(pdrv->wszMessage, HashAx);

    HashAx = HashScramble(HashAx) % HASH_TABLESIZE;

    // dprintf(("StringIdDict_Insert : note: driver hashed to %d", HashAx));
    pdrv->NextStringIdDictNode = StringIdDict[HashAx];
    pdrv->PrevStringIdDictNode = NULL;
    if (pdrv->NextStringIdDictNode) pdrv->NextStringIdDictNode->PrevStringIdDictNode = pdrv;
    StringIdDict[HashAx] = pdrv;

#if DBG    
{
    //  Checking the consistency of the driver lists and the hash table

    UINT    cDriversHash = 0;
    UINT    cDrivers     = 0;
    UINT    ii;
    PMMDRV  pLink, pStart;
        
    for (ii = (sizeof(StringIdDict)/sizeof(StringIdDict[0])); ii; ii--)
    {
        for (pLink = StringIdDict[ii-1]; pLink; pLink = pLink->NextStringIdDictNode)
        {
            cDriversHash++;
        }
    }
        
    for (pStart = (PMMDRV)&waveoutdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&waveindrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&midioutdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&midiindrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&mixerdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&auxdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    WinAssert(cDriversHash == cDrivers);        
}    
#endif  //  DBG    

    return;
}

void StringIdDict_Remove(PMMDRV pdrv)
{
    if (pdrv->NextStringIdDictNode) pdrv->NextStringIdDictNode->PrevStringIdDictNode = pdrv->PrevStringIdDictNode;
    if (pdrv->PrevStringIdDictNode) {
        pdrv->PrevStringIdDictNode->NextStringIdDictNode = pdrv->NextStringIdDictNode;
    } else {
        int i;
        for ( i = 0; i < HASH_TABLESIZE; i++ ) {
            if (pdrv == StringIdDict[i]) {
                StringIdDict[i] = pdrv->NextStringIdDictNode;
                break;
            }
        }
        WinAssert(i != HASH_TABLESIZE);
    }
    
#if DBG
{
    //  Checking the consistency of the driver lists and the hash table

    UINT    cDriversHash = 0;
    UINT    cDrivers     = 0;
    UINT    ii;
    PMMDRV  pLink, pStart;
        
    for (ii = (sizeof(StringIdDict)/sizeof(StringIdDict[0])); ii; ii--)
    {
        for (pLink = StringIdDict[ii-1]; pLink; pLink = pLink->NextStringIdDictNode)
        {
            cDriversHash++;
        }
    }
    
    for (pStart = (PMMDRV)&waveoutdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&waveindrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&midioutdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&midiindrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&mixerdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
        
    for (pStart = (PMMDRV)&auxdrvZ, pLink = pStart->Next; pLink != pStart; pLink = pLink->Next)
        cDrivers++;
    
    cDrivers--;  // to account for the driver we just removed.
        
    WinAssert(cDriversHash == cDrivers);        
}    
#endif  //  DBG    
    
}


//=============================================================================
//===   Misc Utilities   ===
//=============================================================================

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api void | winmmGetBuildYearAndMonth |  Returns build year and month
 *      of this source file.
 *
 * @parm unsigned* | pBuildYear | Receives build year.
 *
 * @parm unsigned* | pBuildMonth | Receives build month.
 *
 * @rdesc No return value.
 *
 * @comm Computes build year and month based on compiler macro __DATE__
 *
 ***************************************************************************/
void winmmGetBuildYearAndMonth(unsigned *pBuildYear, unsigned *pBuildMonth)
{
    char szBuildDate[] = __DATE__;
    char *Month[12] = {"Jan", "Feb", "Mar",
    	               "Apr", "May", "Jun",
    	               "Jul", "Aug", "Sep",
    	               "Oct", "Nov", "Dec"};
    char szBuildMonth[4];
    int i;

    lstrcpynA(szBuildMonth, szBuildDate, 4);
    szBuildMonth[3] = '\0';
    for (i = 0; i < 12; i++)
    {
    	if (!lstrcmpiA(Month[i], szBuildMonth)) break;
    }
    WinAssert(i < 12);
    *pBuildMonth = i + 1;

    *pBuildYear = atoi(&szBuildDate[7]);

    return;
    
}

/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api BOOL | winmmFileTimeIsPreXp |  Determines whether given filetime is
 *      before approximate XP ship date.
 *
 * @parm FILETIME* | FileTime | Points to file time to check.
 *
 * @rdesc BOOL | TRUE if file time is before approximate XP ship date
 *
 * @comm This is based on the build date of this source module, or the
 *      anticipated Windows XP RC2 ship month, whichever is later.
 *
 ***************************************************************************/
BOOL winmmFileTimeIsPreXp(CONST FILETIME *FileTime)
{
    const unsigned XpRc2Month = 7;
    const unsigned XpRc2Year  = 2001;
    
    SYSTEMTIME SystemTime;
    BOOL fPreXp = FALSE;

    if (FileTimeToSystemTime(FileTime, &SystemTime))
    {
    	unsigned BuildYear, BuildMonth;
    	winmmGetBuildYearAndMonth(&BuildYear, &BuildMonth);
    	if (BuildYear > XpRc2Year) {
    	    BuildYear = XpRc2Year;
    	    BuildMonth = XpRc2Month;
    	} else if ((BuildYear == XpRc2Year) && (BuildMonth > XpRc2Month)) {
    	    BuildMonth = XpRc2Month;
    	}
    	
    	if ((SystemTime.wYear < BuildYear) ||
    	    ((SystemTime.wYear == BuildYear) && (SystemTime.wMonth < BuildMonth)))
    	{
    	    fPreXp = TRUE;
    	}
    }

    return fPreXp;
}



/***************************************************************************
 *
 * @doc INTERNAL
 *
 * @api LONG | InternalBroadcastDriverMessage |  Send a message to a
 *      range of drivers.
 *
 * @parm UINT | hDriverStart | index of first driver to send message to
 *
 * @parm UINT | message | Message to broadcast.
 *
 * @parm LONG | lParam1 | First message parameter.
 *
 * @parm LONG | lParam2 | Second message parameter.
 *
 * @parm UINT | flags | defines range of drivers as follows:
 *
 * @flag IBDM_SENDMESSAGE | Only send message to hDriverStart.
 *
 * @flag IBDM_ONEINSTANCEONLY | This flag is ignored if IBDM_SENDMESSAGE is
 *       set. Only send message to single instance of each driver.
 *
 * @flag IBDM_REVERSE | This flag is ignored if IBDM_SENDMESSAGE is set.
 *       Send message to drivers with indices between
 *       hDriverStart and 1 instead of hDriverStart and cInstalledDrivers.
 *       If IBDM_REVERSE is set and hDriverStart is 0 then send messages
 *       to drivers with indices between cInstalledDrivers and 1.
 *
 * @rdesc returns non-zero if message was broadcast. If the IBDM_SENDMESSAGE
 *        flag is set, returns the return result from the driver proc.
 *
 ***************************************************************************/

LRESULT FAR PASCAL InternalBroadcastDriverMessage(UINT hDriverStart,
					       UINT message,
					       LPARAM lParam1,
					       LPARAM lParam2,
					       UINT flags)
{
    LPDRIVERTABLE lpdt;
    LRESULT       result=0;
    int           id;
    int           idEnd;


    DrvEnter();
    if (!hInstalledDriverList || (int)hDriverStart > cInstalledDrivers) {
	DrvLeave();
	return(FALSE);
    }

    if (flags & IBDM_SENDMESSAGE)
	{
	if (!hDriverStart) {
	    DrvLeave();
	    return (FALSE);
	}
	flags &= ~(IBDM_REVERSE | IBDM_ONEINSTANCEONLY);
	idEnd = hDriverStart;
	}

    else
	{
	if (flags & IBDM_REVERSE)
	    {
	    if (!hDriverStart)
		hDriverStart = cInstalledDrivers;
	    idEnd = -1;
	    }
	else
	    {
	    if (!hDriverStart) {
		DrvLeave();
		return (FALSE);
	    }
	    idEnd = cInstalledDrivers;
	    }
	}

    hDriverStart--;

    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    for (id = hDriverStart; id != idEnd; ((flags & IBDM_REVERSE) ? id-- : id++))
	{
	DWORD_PTR  dwDriverIdentifier;
	DRIVERPROC lpDriverEntryPoint;

	if (lpdt[id].hModule)
	    {
	    if ((flags & IBDM_ONEINSTANCEONLY) &&
		!lpdt[id].fFirstEntry)
		continue;

	    lpDriverEntryPoint = lpdt[id].lpDriverEntryPoint;
	    dwDriverIdentifier = lpdt[id].dwDriverIdentifier;

	   /*
	    *  Allow normal messages to overlap - it's up to the
	    *  users not to send messages to stuff that's been unloaded
	    */

	    GlobalUnlock(hInstalledDriverList);
	    DrvLeave();

	    result =
		(*lpDriverEntryPoint)(dwDriverIdentifier,
				      (HANDLE)(UINT_PTR)(id+1),
				      message,
				      lParam1,
				      lParam2);

	    if (flags & IBDM_SENDMESSAGE) {
		return result;
	    }

	    DrvEnter();
	    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

	    }
	}

    GlobalUnlock(hInstalledDriverList);
    DrvLeave();

    return(result);
}


/***************************************************************************
 *
 * @doc DDK
 *
 * @api LONG | DrvSendMessage |  This function sends a message
 *      to a specified driver.
 *
 * @parm HANDLE | hDriver | Specifies the handle of the destination driver.
 *
 * @parm UINT | wMessage | Specifies a driver message.
 *
 * @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 * @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 * @rdesc Returns the results returned from the driver.
 *
 ***************************************************************************/

LRESULT APIENTRY DrvSendMessage(HANDLE hDriver, UINT message, LPARAM lParam1, LPARAM lParam2)
{
    if (fUseWinAPI)
	return (*lpSendDriverMessage)(hDriver, message, lParam1, lParam2);

    return(InternalBroadcastDriverMessage((UINT)(UINT_PTR)hDriver,
					  message,
					  lParam1,
					  lParam2,
					  IBDM_SENDMESSAGE));
}

/**************************************************************************
 *
 * @doc DDK
 *
 * @api LONG | DefDriverProc |  This function provides default
 * handling of system messages.
 *
 * @parm DWORD | dwDriverIdentifier | Specifies the identifier of
 * the device driver.
 *
 * @parm HANDLE | hDriver | Specifies the handle of the device driver.
 *
 * @parm UINT | wMessage | Specifies a driver message.
 *
 * @parm LPARAM | lParam1 | Specifies the first message parameter.
 *
 * @parm LPARAM | lParam2 | Specifies the second message parameter.
 *
 * @rdesc Returns 1L for DRV_LOAD, DRV_FREE, DRV_ENABLE, and DRV_DISABLE.
 * It returns 0L for all other messages.
 *
***************************************************************************/



LRESULT APIENTRY DefDriverProc(DWORD_PTR  dwDriverIdentifier,
			      HDRVR  hDriver,
			      UINT   message,
			      LPARAM lParam1,
			      LPARAM lParam2)
{

    switch (message)
	{
	case DRV_LOAD:
	case DRV_ENABLE:
	case DRV_DISABLE:
	case DRV_FREE:
	    return(1L);
	    break;
	case DRV_INSTALL:
	case DRV_REMOVE:
	    return(DRV_OK);
	    break;
       }

    return(0L);
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api MMRESULT | DrvIsPreXp | Determines whether the installable driver's
 *      last modified date is before the approximate Windows XP ship date.
 *
 * @parm HANDLE | hDriver | Handle to installable driver.
 *
 * @rdesc BOOL | TRUE if the installable driver's last modified date is before
 *      the approximate Windows XP ship date.
 *
 * @comm If there was an error getting file attributes, then let's err on
 *    the side of an old driver and return TRUE.
 *
 ****************************************************************************/
BOOL DrvIsPreXp(IN HANDLE hDriver)
{
    WIN32_FILE_ATTRIBUTE_DATA fad;
    HMODULE hModule;
    BOOL fPreXp = TRUE;
    
    hModule = DrvGetModuleHandle(hDriver);
    if (hModule)
    {
    	TCHAR filename[MAX_PATH];

    	if (GetModuleFileName(hModule, filename, sizeof(filename)/sizeof(TCHAR)))
    	{
    	    if (GetFileAttributesEx(filename, GetFileExInfoStandard, &fad))
            {
    	        fPreXp = winmmFileTimeIsPreXp(&fad.ftLastWriteTime);
            }
            else
            {
    	        LONG error = GetLastError();
    	        dprintf(("DrvIsPreXp : error: GetFileAttributesEx failed, LastError=%d", error));
            }
    	    // dprintf(("DrvIsPreXp : note: %s fPreXp=%d", filename, fPreXp));
    	}
    	else
    	{
            LONG error = GetLastError();
            dprintf(("DrvIsPreXp : error: GetModuleFileName failed, LastError=%d", error));
    	}
    }
    else
    {
        dprintf(("DrvIsPreXp : error: DrvGetModuleHandle failed"));
    }
    
    return fPreXp;
}

MMRESULT mregCreateStringIdFromDriverPort(IN struct _MMDRV *pmmDrv, IN UINT port, OUT PWSTR* pStringId, OUT ULONG* pcbStringId)
{
    return StringId_Create(pmmDrv, port, pStringId, pcbStringId);
}

/*****************************************************************************
 * @doc INTERNAL WAVE
 *
 * @api MMRESULT | mregGetIdFromStringId | This function finds the waveOut
 *   device ID associated with the waveOut device identified by a unique
 *   string created by waveOutCreateStringIdFromId.
 *
 * @parm PCWSTR | StringId | Pointer to a unicode string identifying a
 *   waveOut device.
 *
 * @parm UINT* | puDeviceID | Address of a buffer to receive the waveOut
 *   device ID.
 *
 * @rdesc MMRESULT | Zero if successfull otherwise an error code defined
 *   in mmsystem.h.
 *
 * @comm The StringId is normally obtained by calling waveOutCreateStringIdFromId.
 *
 * @xref waveOutCreateStringIdFromId
 *
 ****************************************************************************/
MMRESULT mregGetIdFromStringId(IN PMMDRV pdrvZ, IN PCWSTR StringId, OUT UINT *puDeviceID)
{
    PMMDRV pdrv;
    PMMDRV pdrvTarget;
    UINT portTarget;
    UINT idTarget;
    MMRESULT mmr;

    if (!ValidateWritePointer(puDeviceID, sizeof(*puDeviceID))) return MMSYSERR_INVALPARAM;
    if (!ValidateStringW(StringId, (-1))) return MMSYSERR_INVALPARAM;

    EnterNumDevs("mregGetIdFromStringId");

    mmr = StringIdDict_Search(StringId, &pdrvTarget, &portTarget);
    if (!mmr)
    {
        idTarget = portTarget;
        for (pdrv = pdrvZ->Next; pdrv != pdrvZ; pdrv = pdrv->Next)
        {
    	    if (pdrv == pdrvTarget) break;
            
            //  Skipping mapper...
            if (pdrv->fdwDriver & MMDRV_MAPPER) continue;
            
    	    idTarget += pdrv->NumDevs;
        }
    }

    LeaveNumDevs("mregGetIdFromStringId");

    WinAssert(pdrv != pdrvZ);
    *puDeviceID = idTarget;

    return mmr;
}

MMRESULT mregQueryStringId(IN PMMDRV pdrv, IN UINT port, OUT WCHAR* pStringIdBuffer, IN ULONG cbStringIdBuffer)
{
    PWSTR StringId;
    MMRESULT mmr;

    mmr = mregCreateStringIdFromDriverPort(pdrv, port, &StringId, NULL);
    if (!mmr)
    {
	if (ValidateWritePointer(pStringIdBuffer, cbStringIdBuffer))
	{
	    int cchStringIdBuffer = cbStringIdBuffer / sizeof(WCHAR);
	
	    if (cchStringIdBuffer >= lstrlenW(StringId) + 1)
	    {
		cchStringIdBuffer = lstrlenW(StringId) + 1;
		mmr = MMSYSERR_NOERROR;
	    } else {
		mmr = MMSYSERR_MOREDATA;
	    }
	    lstrcpynW(pStringIdBuffer, StringId, cchStringIdBuffer);
	} else {
	    mmr = MMSYSERR_INVALPARAM;
	}
	
    	HeapFree(hHeap, 0, StringId);
    }
    	
    return mmr;

}

MMRESULT mregQueryStringIdSize(IN PMMDRV pdrv, IN UINT port, OUT ULONG* pcbStringId)
{
    PWSTR StringId;
    MMRESULT mmr;

    if (ValidateWritePointer(pcbStringId, sizeof(*pcbStringId)))
    {
        mmr = mregCreateStringIdFromDriverPort(pdrv, port, NULL, pcbStringId);
    }
    else
    {
	mmr = MMSYSERR_INVALPARAM;
    }

    return mmr;
}

PMMDRV mregGetDrvListFromClass(DWORD dwClass)
{
    PMMDRV pdrvZ;

    switch (dwClass)
    {
    	case TYPE_WAVEOUT:
	    pdrvZ = &waveoutdrvZ;
    	    break;
    	case TYPE_WAVEIN:
	    pdrvZ = &waveindrvZ;
    	    break;
    	case TYPE_MIDIOUT:
	    pdrvZ = &midioutdrvZ;
    	    break;
    	case TYPE_MIDIIN:
	    pdrvZ = &midiindrvZ;
    	    break;
    	case TYPE_AUX:
	    pdrvZ = &auxdrvZ;
    	    break;
    	case TYPE_MIXER:
	    pdrvZ = &mixerdrvZ;
    	    break;
    	default:
    	    pdrvZ = NULL;
    	    WinAssert(FALSE);
    }

    return pdrvZ;
}

/*==========================================================================*/
BOOL FAR PASCAL mregHandleInternalMessages(
    PMMDRV      pmmdrv,
    DWORD       dwClass,
    UINT        idPort,
    UINT        uMessage,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    MMRESULT  * pmmr)
{
    UINT            cbSize;
    PMMDRV          pmd = (PMMDRV)pmmdrv;
    BOOL            fResult = TRUE;
    MMRESULT        mmr = MMSYSERR_NOERROR;
    HMODULE         hModule;
#ifndef UNICODE
    TCHAR szBuff[MAX_PATH];
#endif // End UNICODE

    switch (uMessage)
    {
	case DRVM_MAPPER_PREFERRED_GET:
	    if (TYPE_WAVEOUT == dwClass) {
		if ((pmmdrv->fdwDriver & MMDRV_MAPPER) &&
		    ValidateWritePointer((PUINT)dwParam1, sizeof(UINT)) &&
		    ValidateWritePointer((PDWORD)dwParam2, sizeof(DWORD)))
		{
		    waveOutGetCurrentPreferredId((PUINT)dwParam1, (PDWORD)dwParam2);
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_WAVEIN == dwClass) {
		if ((pmmdrv->fdwDriver & MMDRV_MAPPER) &&
		    ValidateWritePointer((PUINT)dwParam1, sizeof(UINT)) &&
		    ValidateWritePointer((PDWORD)dwParam2, sizeof(DWORD)))
		{
		    waveInGetCurrentPreferredId((PUINT)dwParam1, (PDWORD)dwParam2);
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_MIDIOUT == dwClass) {
		if ((pmmdrv->fdwDriver & MMDRV_MAPPER) &&
		    ValidateWritePointer((PUINT)dwParam1, sizeof(UINT)) &&
		    ValidateWritePointer((PDWORD)dwParam2, sizeof(DWORD)))
		{
		    midiOutGetCurrentPreferredId((PUINT)dwParam1, (PDWORD)dwParam2);
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else {
		mmr = MMSYSERR_INVALPARAM;
	    }
	    break;
		
	case DRVM_MAPPER_PREFERRED_SET:
	    if (TYPE_WAVEOUT == dwClass) {
		if (pmmdrv->fdwDriver & MMDRV_MAPPER) {
		    mmr = waveOutSetPersistentPreferredId((UINT)dwParam1, (DWORD)dwParam2);
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_WAVEIN == dwClass) {
		if (pmmdrv->fdwDriver & MMDRV_MAPPER) {
		    mmr = waveInSetPersistentPreferredId((UINT)dwParam1, (DWORD)dwParam2);
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_MIDIOUT == dwClass) {
		if (pmmdrv->fdwDriver & MMDRV_MAPPER) {
		    mmr = midiOutSetPersistentPreferredId((UINT)dwParam1, (DWORD)dwParam2);
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else {
		mmr = MMSYSERR_INVALPARAM;
	    }
	    break;

	case DRVM_MAPPER_CONSOLEVOICECOM_GET:
	    if (TYPE_WAVEOUT == dwClass) {
		if ((pmmdrv->fdwDriver & MMDRV_MAPPER) &&
		    ValidateWritePointer((PUINT)dwParam1, sizeof(UINT)) &&
		    ValidateWritePointer((PDWORD)dwParam2, sizeof(DWORD)))
		{
		    waveOutGetCurrentConsoleVoiceComId((PUINT)dwParam1, (PDWORD)dwParam2);
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_WAVEIN == dwClass) {
		if ((pmmdrv->fdwDriver & MMDRV_MAPPER) &&
		    ValidateWritePointer((PUINT)dwParam1, sizeof(UINT)) &&
		    ValidateWritePointer((PDWORD)dwParam2, sizeof(DWORD)))
		{
		    waveInGetCurrentConsoleVoiceComId((PUINT)dwParam1, (PDWORD)dwParam2);
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else {
		mmr = MMSYSERR_INVALPARAM;
	    }
            break;

	case DRVM_MAPPER_CONSOLEVOICECOM_SET:
	    if (TYPE_WAVEOUT == dwClass) {
		if (pmmdrv->fdwDriver & MMDRV_MAPPER) {
		    mmr = waveOutSetPersistentConsoleVoiceComId((UINT)dwParam1, (DWORD)dwParam2);
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else if (TYPE_WAVEIN == dwClass) {
		if (pmmdrv->fdwDriver & MMDRV_MAPPER) {
		    mmr = waveInSetPersistentConsoleVoiceComId((UINT)dwParam1, (DWORD)dwParam2);
		} else {
		    mmr = MMSYSERR_INVALPARAM;
		}
	    } else {
		mmr = MMSYSERR_INVALPARAM;
	    }
            break;

	case DRV_QUERYFILENAME:
		// Get Driver's FileName
		if ( ((cbSize = (DWORD)dwParam2 * sizeof(WCHAR)) > 0) &&
		     (ValidateWritePointer( (LPVOID)dwParam1, cbSize)) )
		{
			lstrncpyW ((LPWSTR)dwParam1,
				   pmd->wszDrvEntry,
				   (DWORD)dwParam2-1);
			((LPWSTR)dwParam1)[ dwParam2-1 ] = TEXT('\0');
		}
		else
		{
			mmr = MMSYSERR_INVALPARAM;
		}
		break;

    case DRV_QUERYDRVENTRY:
    case DRV_QUERYNAME:
    case DRV_QUERYDEVNODE:
    case DRV_QUERYDRIVERIDS:
		//      Note:   Not applicable or obsolete.
		mmr = MMSYSERR_NOTSUPPORTED;
		break;

    case DRV_QUERYDEVICEINTERFACE:
    {
	// dwParam1 is a pointer to a buffer to contain device interface
	// dwParam2 is the length in bytes of the buffer
	PWSTR pwstrDeviceInterfaceOut = (PWSTR)dwParam1;
	UINT cbDeviceInterfaceOut = (UINT)dwParam2;
	PWSTR pwstrDeviceInterface = (PWSTR)pmd->cookie;
	int cchDeviceInterfaceOut = cbDeviceInterfaceOut / sizeof(WCHAR);

	if (ValidateWritePointer(pwstrDeviceInterfaceOut, cbDeviceInterfaceOut))
	{
	    if (pwstrDeviceInterface)
	    {
		if (cchDeviceInterfaceOut >= lstrlenW(pwstrDeviceInterface) + 1)
		{
		    cchDeviceInterfaceOut = lstrlenW(pwstrDeviceInterface) + 1;
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_MOREDATA;
		}
		lstrcpynW(pwstrDeviceInterfaceOut, pwstrDeviceInterface, cchDeviceInterfaceOut);
	    } else {
		if (cchDeviceInterfaceOut >= 1)
		{
		    *pwstrDeviceInterfaceOut = '\0';
		    mmr = MMSYSERR_NOERROR;
		} else {
		    mmr = MMSYSERR_MOREDATA;
		}
	    }
	} else {
	    mmr = MMSYSERR_INVALPARAM;
	}
	break;
    }

    case DRV_QUERYDEVICEINTERFACESIZE:
    {
	// dwParam1 is a pointer to a buffer to contain a ULONG count of bytes
	// in the device interface name
	PULONG pcbDeviceInterface = (PULONG)dwParam1;
	
	if (ValidateWritePointer(pcbDeviceInterface, sizeof(ULONG)))
	{
	    if (pmd->cookie)
	    {
		*pcbDeviceInterface = (lstrlenW((PWSTR)pmd->cookie) + 1) * sizeof(WCHAR);
	    } else {
		*pcbDeviceInterface = 1 * sizeof(WCHAR);
	    }
	    mmr = MMSYSERR_NOERROR;
	} else {
	    mmr = MMSYSERR_INVALPARAM;
	}
	break;
    }

    case DRV_QUERYSTRINGID:
    {
    	mmr = mregQueryStringId(pmmdrv, idPort, (WCHAR*)dwParam1, (ULONG)dwParam2);
    	break;
    }

    case DRV_QUERYSTRINGIDSIZE:
    {
    	mmr = mregQueryStringIdSize(pmmdrv, idPort, (ULONG*)dwParam1);
    	break;
    }

    case DRV_QUERYIDFROMSTRINGID:
    {
        mmr = mregGetIdFromStringId(mregGetDrvListFromClass(dwClass), (PCWSTR)dwParam1, (UINT*)dwParam2);
        break;
    }

    case DRV_QUERYMAPPABLE:
        {
            TCHAR   szRegKey[MAX_PATH+1];
            HKEY    hKey;

            if (dwParam1 || dwParam2)
                return MMSYSERR_INVALPARAM;

#ifdef UNICODE
            wsprintfW (szRegKey, TEXT("%s\\%s"), REGSTR_PATH_WAVEMAPPER, pmd->wszDrvEntry);
#else
            {
                CHAR aszDrvEntry[CHAR_GIVEN_BYTE(sizeof(pmd->wszDrvEntry))+1];

                cbSize = sizeof(aszDrvEntry);
                UnicodeStrToAsciiStr((LPBYTE)aszDrvEntry, (LPBYTE)aszDrvEntry + cbSize,
                                     pmd->wszDrvEntry);

                wsprintfA (szRegKey, TEXT("%s\\%s"), REGSTR_PATH_WAVEMAPPER, aszDrvEntry);
            }
#endif

            if (RegOpenKey (HKEY_LOCAL_MACHINE, szRegKey, &hKey) != ERROR_SUCCESS)
            {
                mmr = MMSYSERR_NOERROR;
            }
            else
            {
                DWORD   dwMappable;
                DWORD   dwSize;
                DWORD   dwType;

                dwSize = sizeof(dwMappable);
                if (RegQueryValueEx (hKey,
                                     REGSTR_VALUE_MAPPABLE,
                                     NULL,
                                     &dwType,
                                     (void *)&dwMappable,
                                     &dwSize) != ERROR_SUCCESS)
                {
                    dwMappable = 1;
                }

                RegCloseKey (hKey);

                mmr = (dwMappable) ? MMSYSERR_NOERROR :
                                     MMSYSERR_NOTSUPPORTED;
            }
        }
        break;
	
	case DRV_QUERYMAPID:
		WinAssert(DRV_QUERYMAPID != uMessage);
		mmr = MMSYSERR_NOTSUPPORTED;
		break;

	case DRV_QUERYNUMPORTS:
		if (ValidateWritePointer( (LPVOID)dwParam1, sizeof(DWORD)))
		{
			*((LPDWORD)dwParam1) = pmd->NumDevs;
		}
		else
		{
			mmr = MMSYSERR_INVALPARAM;
		}
		break;

	case DRV_QUERYMODULE:
		if (ValidateWritePointer( (LPVOID)dwParam1, sizeof(DWORD)))
		{
			hModule = DrvGetModuleHandle(pmd->hDriver);
			*((HMODULE *)dwParam1) = hModule;
		}
		else
		{
			mmr = MMSYSERR_INVALPARAM;
		}
		break;

	default:
			// Not an internal message
		fResult = FALSE;
		break;
	}

	if (pmmr)
		*pmmr = mmr;
	
    return fResult;
} // End mregHandleInternalMessage


/*==========================================================================*/
/*
@doc    INTERNAL MMSYSTEM
@func   <t UINT> | mregRemoveDriver |
	Sends exit message to the driver message entry, and closes the
	installable driver.  Then releases resources referenced by the MMDRV
	structure.  Finally removes the MMDRV structure from its list and
	frees it.


@parm   <t PMMDRV> | pdrv |
	Pointer to the MMDRV node associated with the driver

@rdesc  No return value

@comm   This function assumes the list containing pdrv is locked.

@xref   mregDecUsage
*/
void mregRemoveDriver(PMMDRV pdrv)
{
    WinAssert(pdrv->cookie);
    WinAssert(pdrv->drvMessage);
    WinAssert(pdrv->hDriver);

    StringIdDict_Remove(pdrv);

    pdrv->drvMessage(0, DRVM_EXIT, 0L, 0L, (DWORD_PTR)pdrv->cookie);
    DrvClose(pdrv->hDriver, 0, 0);

    pdrv->Prev->Next = pdrv->Next;
    pdrv->Next->Prev = pdrv->Prev;

    DeleteCriticalSection(&pdrv->MixerCritSec);
    wdmDevInterfaceDec(pdrv->cookie);

    ZeroMemory(pdrv, sizeof(*pdrv));
    HeapFree(hHeap, 0, pdrv);

    return;
}

void mregAddDriver(PMMDRV pdrvZ, PMMDRV pdrv)
{
    pdrv->Prev = pdrvZ->Prev;
    pdrv->Next = pdrvZ;
    pdrv->Prev->Next = pdrv;
    pdrv->Next->Prev = pdrv;

    StringIdDict_Insert(pdrv);
}

/*==========================================================================*/
/*
@doc    INTERNAL MMSYSTEM
@func   <t UINT> | mregIncUsage |
	Increments the usage count of the specified media resource. If the
	usage count is non-zero, the media resource cannot be unloaded. The
	usage count is increased when instances of the media resource are
	opened, such as with a <f waveOutOpen> call.

@parm   <t HMD> | hmd |
	Contains the media resource handle to increment.

@rdesc  Returns the current usage count.

@xref   mregDecUsage, mregQueryUsage
*/
UINT FAR PASCAL mregIncUsagePtr(
    PMMDRV pmd
)
{
    return InterlockedIncrement(&pmd->Usage);
}

UINT FAR PASCAL mregIncUsage(
    HMD hmd
)
{
    return mregIncUsagePtr(HtoPT(PMMDRV, hmd));
}

/*==========================================================================*/
/*
@doc    INTERNAL MMSYSTEM
@func   <t UINT> | mregDecUsage |
	Decrements the usage count of the specified media resource. If the
	usage count is zero, the media resource can be unloaded. The usage
	count is decresed when instance of the media resource are closed, such
	as with a <f waveOutClose> call.

@parm   <t PMMDRV> | pdrv |
	Pointer to the media resource to decrement.

@rdesc  Returns the current usage count.

@comm   Unless the caller has other usages on the pdrv, it must not use
        it after this call returns.

@xref   mregIncUsage, mregQueryUsage
*/
UINT FAR PASCAL mregDecUsagePtr(
    PMMDRV pdrv
)
{
    UINT refcount;

    EnterNumDevs("mregDecUsage");
    refcount = InterlockedDecrement(&pdrv->Usage);
    if (0 == refcount)
    {
        WinAssert(pdrv->fdwDriver & MMDRV_DESERTED);
        mregRemoveDriver(pdrv);
    }
    LeaveNumDevs("mregDecUsage");
    return refcount;
}

UINT FAR PASCAL mregDecUsage(
    HMD hmd
)
{
    return mregDecUsagePtr(HtoPT(PMMDRV, hmd));
}


/*==========================================================================*/
/*
@doc    INTERNAL MMSYSTEM
@func   <t MMRESULT> | mregFindDevice |
	Given a Device Identifier of a specific Resource Class, returns the
	corresponding Resource handle and port. This can then be used to
	communicate with the driver.  The resource handle is referenced
	(i.e., its usage is incremented).  The caller is responsible for
	ensureing it is eventually released by calling mregDecUsage.

@parm   <t UINT> | uDeviceID |
	Contains the Device Identifier whose handle and port is to be returned.
	If this contains -1, then it is assumed that a mapper of the specified
	class is being sought. These identifiers correspond to the <lq>Device
	IDs<rq> used with various functions such as <f waveOutOpen>. This
	enables the various components to search for internal media resource
	handles based on Device IDs passed to public APIs.
@parm   <t WORD> | fwFindDevice |
	Contains the flags specifying the class of device.
@flag   <cl MMDRVI_WAVEIN> | Wave Input device.
@flag   <cl MMDRVI_WAVEOUT> | Wave Output device.
@flag   <cl MMDRVI_MIDIIN> | MIDI Input device.
@flag   <cl MMDRVI_MIDIOUT> | MIDI Output device.
@flag   <cl MMDRVI_AUX> | Aux device.
@flag   <cl MMDRVI_MIXER> | Mixer device.
@flag   <cl MMDRVI_JOY> | Joystick device.
@flag   <cl MMDRVI_MAPPER> | Mapper device of the specified class. This is used
	in addition to any of the above resource classes in order to specify
	that the class mapper is to be returned. If this is not specified, the
	mapper is not returned as a match to a query.

@parm   <t HMD> <c FAR>* | phmd |
	Points to a buffer in which to place the Media Resource Handle.
@parm   <t UINT> <c FAR>* | puDevicePort |
	Points to a buffer in which to place the Device Port. This is used as
	a parameter when sending messages to the device to specify which port.

@rdesc  Returns <cl MMSYSERR_BADDEVICEID> if the specified Device Identifier was
	out of range, else <cl MMSYSERR_NOERROR> on success.

@xref   mregEnumDevice, mregGetNumDevs, mregDecUsage
*/

MMRESULT FAR PASCAL mregFindDevice(
	UINT            uDeviceID,
	WORD            fwFindDevice,
	HMD FAR*        phmd,
	UINT FAR*       puDevicePort)
{
	PMMDRV   pmd;
	UINT     port;
	MMRESULT mmr;

	WinAssert((TYPE_MIDIOUT == (fwFindDevice & MMDRVI_TYPE)) || (TYPE_MIDIIN == (fwFindDevice & MMDRVI_TYPE)));
	switch (fwFindDevice & MMDRVI_TYPE)
	{
	case    TYPE_MIDIOUT:
          mmr = midiReferenceDriverById(&midioutdrvZ, uDeviceID, &pmd, &port);
	  break;

	case    TYPE_MIDIIN:
           mmr = midiReferenceDriverById(&midiindrvZ, uDeviceID, &pmd, &port);
	   break;

	default:
	   return MMSYSERR_BADDEVICEID;

	}

	if (!mmr)
	{
	    WinAssert(pmd);
	    *phmd = PTtoH(HMD, pmd);
	    *puDevicePort = port;
	}
	return mmr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mci.c ===
/*******************************************************************************
*
* Module Name: mci.c
*
* Media Control Architecture Driver Interface
*
* Contents:  MCI external message API's mciSendString and mciSendCommand
* Author:  DLL (DavidLe)
* Created: 2/13/90
* 5/22/91: Ported to Win32 - NigelT
*
* Copyright (c) 1991-1998 Microsoft Corporation
*
\******************************************************************************/

#define INCL_WINMM
#include "winmmi.h"
#include "mci.h"
#include "wchar.h"

/*
 * MCI critical section stuff
 */

#if DBG
UINT cmciCritSec = 0; // enter'ed count
UINT uCritSecOwner;   // Thread id of critical section owner
#endif

CRITICAL_SECTION mciCritSec;  // used to protect process global mci variables

#if DBG
int mciDebugLevel;
#endif

extern DWORD mciWindowThreadId;
#define MCIERR_AUTO_ALREADY_CLOSED ((MCIERROR)0xFF000000)  // Secret return code

STATICFN UINT mciConvertReturnValue(
    UINT uType, UINT uErr, MCIDEVICEID wDeviceID,
    PDWORD_PTR dwParams, LPWSTR lpstrReturnString,
    UINT uReturnLength);

STATICFN DWORD mciSendStringInternal(
    LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength,
    HANDLE hCallback, LPMCI_SYSTEM_MESSAGE lpMessage);

STATICFN DWORD mciSendSystemString(
    LPCWSTR lpstrCommand, DWORD dwAdditionalFlags, LPWSTR lpstrReturnString,
    UINT uReturnLength);

UINT mciBreakKeyYieldProc ( MCIDEVICEID wDeviceID,
                            DWORD dwYieldData);

extern UINT FAR mciExtractTypeFromID(
    LPMCI_OPEN_PARMSW lpOpen);

// This macro defines the list of messages for which mciSendString
// will not try to auto-open
#define MCI_CANNOT_AUTO_OPEN(wMessage) \
    (wMessage == MCI_OPEN || wMessage == MCI_SYSINFO \
        || wMessage == MCI_SOUND || wMessage == MCI_CLOSE \
        || wMessage == MCI_BREAK)

// This macro devices the list of message which do not require an open
// device.  It is a subset of MCI_CANNOT_AUTO_OPEN
#define MCI_DO_NOT_NEED_OPEN(wMessage) \
    (wMessage == MCI_OPEN || wMessage == MCI_SOUND || wMessage == MCI_SYSINFO)

// Strings used in mciAutoOpenDevice
          WSZCODE wszOpen[]   = L"open";
STATICDT  WSZCODE wszClose[]  = L"close";
STATICDT  WSZCODE wszNotify[] = L"notify";  // IMPORTANT:  MUST be lowercase
STATICDT  WSZCODE wszWait[]   = L"wait";

STATICDT  WSZCODE szCmdFormat[]  = L"%ls %ls";
STATICDT  WSZCODE szLongFormat[] = L"%ld";
STATICDT  WSZCODE szRectFormat[] = L"%d %d %d %d";

// Special device name
STATICDT  WSZCODE wszNew[] = L"new";

/*****************************************************************************
 * @doc INTERNAL
 *
 * @func void | MciNotify  | called by mmWndProc when it recives a
 *                          MM_MCINOTIFY message
 * @rdesc None.
 *
 ****************************************************************************/
void MciNotify(
    DWORD   wParam,
    LONG    lParam)
{
    //
    //  wParam is the notify status
    //  lParam is the MCI device id
    //
    mciEnter("MciNotify");

    if (MCI_VALID_DEVICE_ID((UINT)lParam)           // If a valid device
      && !(ISCLOSING(MCI_lpDeviceList[lParam]))) { // and if not in process of closing
        SETAUTOCLOSING(MCI_lpDeviceList[lParam]);

        //
        // Must not hold MCI critical section when calling mciCloseDevice
        // because DrvClose gets the load/unload critical section while
        // drivers loading will have the load/unload critical section
        // but can call back (eg) to mciRegisterCommandTable causing
        // a deadlock.
        //
        // Even if the incoming notification is ABORTED/SUPERSEDED/FAILED
        // we must still close the device.  Otherwise devices get left open.
        // mciCloseDevice will protect against trying to close a device that
        // we do not own.
        mciLeave("MciNotify");
        mciCloseDevice ((MCIDEVICEID)lParam, 0L, NULL, TRUE);
    } else {
        mciLeave("MciNotify");
    }
}

/*--------------------------------------------------------------------*\
 *  HandleNotify
 *
\*--------------------------------------------------------------------*/
STATICFN void HandleNotify(
    DWORD   uErr,
    MCIDEVICEID wDeviceID,
    DWORD   dwFlags,
    DWORD_PTR   dwParam2)
{
    LPMCI_GENERIC_PARMS lpGeneric = (LPMCI_GENERIC_PARMS)dwParam2;
    HANDLE hCallback;

    if (0 == uErr
      && dwFlags & MCI_NOTIFY
      && lpGeneric != NULL
      && (hCallback = (HANDLE)lpGeneric->dwCallback) != NULL)
    {
        mciDriverNotify (hCallback, wDeviceID, MCI_NOTIFY_SUCCESSFUL);
    }
}

#if DBG

/*--------------------------------------------------------------------*\
 * mciDebugOut
 *
 * Dump the string form of an MCI command
\*--------------------------------------------------------------------*/
UINT NEAR mciDebugOut(
    MCIDEVICEID wDeviceID,
    UINT wMessage,
    DWORD_PTR dwFlags,
    DWORD_PTR dwParam2,
    LPMCI_DEVICE_NODE nodeWorking)
{
    LPWSTR  lpCommand, lpFirstParameter, lpPrevious, lszDebugOut;
    WCHAR   strTemp[256];
    UINT    wID;
    UINT    wOffset, wOffsetFirstParameter;
    UINT    uReturnType = 0;
    DWORD   dwValue;
    DWORD   dwMask = 1;                // used to test each flag bit in turn
    UINT    wTable;

// Find the command table for the given command message ID
    lpCommand = FindCommandItem( wDeviceID, NULL, (LPWSTR)(UINT_PTR)wMessage,
                                 NULL, &wTable );

    if (lpCommand == NULL)
    {
        if (wMessage != MCI_OPEN_DRIVER && wMessage != MCI_CLOSE_DRIVER) {
            ROUT(("WINMM: mciDebugOut:  Command table not found"));
        }
        return 0;
    }

    lszDebugOut = mciAlloc( BYTE_GIVEN_CHAR( 512 ) );
    if (!lszDebugOut) {
        ROUT(("WINMM: Not enough memory to display command"));
        return 0;
    }

//  Dump the command name into the buffer
    wsprintfW( lszDebugOut, L"MCI command: \"%ls", lpCommand );

// Dump the device name
    if (wDeviceID == MCI_ALL_DEVICE_ID)
    {
        wcscat( lszDebugOut, L" all" );
    }
    else if (nodeWorking != NULL)
    {
        if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID)
        {
            wsprintfW( lszDebugOut + wcslen( lszDebugOut ),
                           L" Element ID:0x%lx", nodeWorking->dwElementID );
        }
        else if (nodeWorking->lpstrName != NULL)
        {
            wsprintfW( lszDebugOut + wcslen( lszDebugOut ),
                           L" %ls", nodeWorking->lpstrName );
        }
    }

    // Skip past command entry
    lpCommand = (LPWSTR)((LPBYTE)lpCommand + mciEatCommandEntry( lpCommand, NULL, NULL));

    // Get the next entry
    lpFirstParameter = lpCommand;

    // Skip past the DWORD return value
    wOffsetFirstParameter = 4;

        lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                                mciEatCommandEntry( lpCommand,
                                                    &dwValue, &wID ));

    // If it is a return value, skip it
    if (wID == MCI_RETURN)
    {
        uReturnType = (UINT)dwValue;
        lpFirstParameter = lpCommand;
        wOffsetFirstParameter += mciGetParamSize (dwValue, wID);
        lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                                    mciEatCommandEntry(lpCommand,
                                                       &dwValue, &wID));
    }

// Dump device name parameter to OPEN
    if (wMessage == MCI_OPEN)
    {
        LPCWSTR lpstrDeviceType =
            ((LPMCI_OPEN_PARMSW)dwParam2)->lpstrDeviceType;
        LPCWSTR lpstrElementName =
            ((LPMCI_OPEN_PARMSW)dwParam2)->lpstrElementName;

// Tack on device type
        if (dwFlags & MCI_OPEN_TYPE_ID)
        {
            //  Warning!: Expanding dwOld to DWORD_PTR may not work on
            //            on Win64, just to clear out warning.  MCI may
            //            not get ported to Win64.

            LPMCI_OPEN_PARMSW   lpOpen = (LPMCI_OPEN_PARMSW)dwParam2;
            DWORD_PTR           dwOld = PtrToUlong(lpOpen->lpstrDeviceType);

            if (mciExtractTypeFromID ((LPMCI_OPEN_PARMSW)dwParam2) != 0) {
                strTemp[0] = '\0';
            }
            wcscpy (strTemp, (LPWSTR)lpOpen->lpstrDeviceType);
            mciFree ((LPWSTR)lpOpen->lpstrDeviceType);
            lpOpen->lpstrDeviceType = (LPWSTR)dwOld;

        } else if (lpstrDeviceType != NULL)
            wcscpy (strTemp, (LPWSTR)lpstrDeviceType);

        else {
            strTemp[0] = '\0';
        }

        if (dwFlags & MCI_OPEN_ELEMENT_ID)
        {
// Tack on element ID
            wcscat( strTemp, L" Element ID:");
            wsprintfW( strTemp + wcslen (strTemp), szLongFormat,
                           LOWORD (PtrToUlong(lpstrDeviceType)));
        } else
        {
// Add separator if both type name and element name are present
            if (lpstrDeviceType != 0 && lpstrElementName != 0) {
                wcscat( strTemp, L"!" );
            }

            if (lpstrElementName != 0 && dwFlags & MCI_OPEN_ELEMENT) {
                wcscat( strTemp, lpstrElementName );
            }
        }
        wsprintfW( lszDebugOut + wcslen(lszDebugOut), L" %ls", strTemp );
    }


// Walk through each flag
    while (dwMask != 0)
    {
        // Is this bit set?
        if ((dwFlags & dwMask) != 0 && !
        // The MCI_OPEN_TYPE and MCI_OPEN_ELEMENT flags are taken care of
        // above
            (wMessage == MCI_OPEN && (dwMask == MCI_OPEN_TYPE
                                      || dwMask == MCI_OPEN_ELEMENT)))
        {
            lpPrevious = lpCommand = lpFirstParameter;
            wOffset = 0;
            lpCommand = (LPWSTR)((LPBYTE)lpCommand
                         + mciEatCommandEntry( lpCommand, &dwValue, &wID ));

            // What parameter uses this bit?
            while (wID != MCI_END_COMMAND && dwValue != dwMask)
            {
                wOffset += mciGetParamSize( dwValue, wID);

                if (wID == MCI_CONSTANT) {
                    while (wID != MCI_END_CONSTANT) {
                        lpCommand = (LPWSTR)((LPBYTE)lpCommand
                            + mciEatCommandEntry( lpCommand, NULL, &wID));
                    }
                }
                lpPrevious = lpCommand;
                lpCommand = (LPWSTR)((LPBYTE)lpCommand
                             + mciEatCommandEntry( lpCommand, &dwValue, &wID ));
            }

            if (wID != MCI_END_COMMAND)
            {
// Found the parameter which matches this flag bit
// Print the parameter name
                if (*lpPrevious) {
                    wsprintfW( lszDebugOut + wcslen(lszDebugOut),
                                   L" %ls", lpPrevious);
                }

// Print any argument
                switch (wID)
                {
                    case MCI_STRING:
                        wsprintfW( lszDebugOut + wcslen(lszDebugOut),
                                       L" %ls", *(LPWSTR *)( (LPBYTE)dwParam2
                                       + wOffset + wOffsetFirstParameter) );
                        break;
                    case MCI_CONSTANT:
                    {
                        DWORD dwConst = *(LPDWORD)((LPBYTE)dwParam2 + wOffset +
                                             wOffsetFirstParameter);
                        UINT wLen;
                        BOOL bFound = FALSE;

                        while (wID != MCI_END_CONSTANT)
                        {
                            wLen = mciEatCommandEntry( lpCommand,
                                                       &dwValue, &wID);

                            if (dwValue == dwConst)
                            {
                                bFound = TRUE;
                                wsprintfW( lszDebugOut + wcslen(lszDebugOut),
                                                L" %ls", lpCommand);
                            }

                            lpCommand = (LPWSTR)((LPBYTE)lpCommand + wLen);
                        }
                        if (bFound)
                            break;
// FALL THROUGH
                    }
                    case MCI_INTEGER:
                    case MCI_HWND:
                    case MCI_HPAL:
                    case MCI_HDC:
                        wsprintfW( strTemp, szLongFormat,
                                       *(LPDWORD)((LPBYTE)dwParam2 + wOffset +
                                                    wOffsetFirstParameter));
                        wsprintfW( lszDebugOut + wcslen(lszDebugOut),
                                       L" %ls", strTemp );
                        break;
                }
            }
        }

// Go to the next flag
        dwMask <<= 1;
    }

    mciUnlockCommandTable( wTable);
    wcscat(lszDebugOut, L"\"" );
    ROUTSW((lszDebugOut));

    mciFree(lszDebugOut);
    return uReturnType;
}
#endif

DWORD mciBreak(
    MCIDEVICEID  wDeviceID,
    DWORD   dwFlags,
    LPMCI_BREAK_PARMS lpBreakon)
{
    HWND hwnd;

    if (dwFlags & MCI_BREAK_KEY)
    {
        if (dwFlags & MCI_BREAK_OFF) {
            return MCIERR_FLAGS_NOT_COMPATIBLE;
        }

        if (dwFlags & MCI_BREAK_HWND) {
            hwnd = lpBreakon->hwndBreak;
        }
        else
        {
            hwnd = NULL;
        }

        return  mciSetBreakKey (wDeviceID, lpBreakon->nVirtKey,
                                hwnd)
                    ? 0 : MMSYSERR_INVALPARAM;

    } else if (dwFlags & MCI_BREAK_OFF) {

        mciSetYieldProc (wDeviceID, NULL, 0);
        return 0;
    } else {
        return MCIERR_MISSING_PARAMETER;
    }
}

//***********************************************************************
//  mciAutoCloseDevice
//
// Close the indicated device by sending a message inter-task
//***********************************************************************
STATICFN DWORD mciAutoCloseDevice(
    LPCWSTR lpstrDevice)
{
    LPWSTR  lpstrCommand;
    DWORD   dwRet;
    int     alloc_len = BYTE_GIVEN_CHAR( wcslen( lpstrDevice) ) +
                        sizeof(wszClose) + sizeof(WCHAR);

    if ((lpstrCommand = mciAlloc ( alloc_len ) ) == NULL)
        return MCIERR_OUT_OF_MEMORY;

    wsprintfW( lpstrCommand, szCmdFormat, wszClose, lpstrDevice);

    dwRet = mciSendSystemString( lpstrCommand, 0L, NULL, 0);

    mciFree( lpstrCommand);

    return dwRet;
}


//***********************************************************************
// mciSendSingleCommand
//
// Process a single MCI command
// Called by mciSendCommandInternal
//
//***********************************************************************
DWORD NEAR mciSendSingleCommand(
    MCIDEVICEID wDeviceID,
    UINT wMessage,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2,
    LPMCI_DEVICE_NODE nodeWorking,
    BOOL bWalkAll,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo)
{
    DWORD dwRet;

#if DBG
    UINT uReturnType;
    if (mciDebugLevel != 0)
        uReturnType = mciDebugOut( wDeviceID, wMessage, dwParam1, dwParam2,
                                   nodeWorking);

    if (nodeWorking == NULL && !MCI_DO_NOT_NEED_OPEN (wMessage))
        return MCIERR_INTERNAL;
#endif

    switch (wMessage)
    {
        case MCI_OPEN:
            dwRet = mciOpenDevice ((DWORD)dwParam1,
                                   (LPMCI_OPEN_PARMSW)dwParam2, lpOpenInfo);
            break;

        case MCI_CLOSE:
// If we were walking the device list and this device was auto opened
// send the command via a task switch
// If we just called mciCloseDevice (as sometimes happened before a bug
// was fixed mciCloseDevice will unload the driver but the MCI_CLOSE_DRIVER
// command will not get sent because it will be rejected as coming from the
// wrong task.  The result would be (was) that the driver would access violate
// when it next did something.
            if (GetCurrentTask() != nodeWorking->hCreatorTask)
            {
                LPWSTR lpstrCommand;

                if (!bWalkAll) {
                    //
                    //  Only valid to close an auto-opened device if it's
                    //  being close as part of closing MCI_ALL_DEVICE_ID
                    //  We can reach here if an app 'guesses' an MCI device
                    //  id and tries to close it while playing.
                    //
                    dwRet = MCIERR_ILLEGAL_FOR_AUTO_OPEN;
                    break;
                }

                lpstrCommand = mciAlloc( sizeof(wszClose)+ sizeof(WCHAR) +
                               BYTE_GIVEN_CHAR( wcslen( nodeWorking->lpstrName ) ) );

                if ( lpstrCommand == NULL )
                    return MCIERR_OUT_OF_MEMORY;

                wcscpy( lpstrCommand, wszClose);
                wcscat( lpstrCommand, L" ");
                wcscat( lpstrCommand, nodeWorking->lpstrName);
                dwRet = mciSendSystemString( lpstrCommand, 0L, NULL, 0);
                mciFree( lpstrCommand);
            } else
                dwRet = mciCloseDevice( wDeviceID, (DWORD)dwParam1,
                                        (LPMCI_GENERIC_PARMS)dwParam2, TRUE);
            break;

        case MCI_SYSINFO:
            dwRet = mciSysinfo( wDeviceID, (DWORD)dwParam1,
                                (LPMCI_SYSINFO_PARMSW)dwParam2);
            HandleNotify( dwRet, wDeviceID, (DWORD)dwParam1, dwParam2);
            break;

        case MCI_BREAK:
            dwRet = mciBreak( wDeviceID, (DWORD)dwParam1,
                              (LPMCI_BREAK_PARMS)dwParam2);
            HandleNotify( dwRet, wDeviceID, (DWORD)dwParam1, dwParam2);
            break;

        case MCI_SOUND:
        {
            LPMCI_SOUND_PARMSW lpSound = (LPMCI_SOUND_PARMSW)dwParam2;
            if ( PlaySoundW( MCI_SOUND_NAME & dwParam1
                                    ? lpSound->lpstrSoundName
                                    : L".Default",
                                (HANDLE)0,
                                dwParam1 & MCI_WAIT
                                    ? SND_SYNC | SND_ALIAS
                                    : SND_ASYNC | SND_ALIAS ) )
            {
                dwRet = 0;
            } else {
                dwRet = MCIERR_HARDWARE;
            }

            HandleNotify( dwRet, wDeviceID, (DWORD)dwParam1, dwParam2);
            break;
        }
        default:
#if 0 // don't bother (NigelT)
            if (mciDebugLevel > 1)
            {
                dwStartTime = timeGetTime();
            }
#endif
// Initialize GetAsyncKeyState for break key
            {
                if ((dwParam1 & MCI_WAIT) &&
                    nodeWorking->fpYieldProc == mciBreakKeyYieldProc)
                {
                    dprintf4(("Getting initial state of Break key"));
                    GetAsyncKeyState( nodeWorking->dwYieldData);
                    //GetAsyncKeyState( LOWORD(nodeWorking->dwYieldData));
                }
            }

            dwRet = (DWORD)DrvSendMessage( nodeWorking->hDrvDriver, wMessage,
                                    dwParam1, dwParam2);
            break;
    } // switch

#if DBG
    if (mciDebugLevel != 0)
    {
        if (dwRet & MCI_INTEGER_RETURNED)
            uReturnType = MCI_INTEGER;

        switch (uReturnType)
        {
            case MCI_INTEGER:
            {
                WCHAR strTemp[50];

                mciConvertReturnValue( uReturnType, HIWORD(dwRet), wDeviceID,
                                       (PDWORD_PTR)dwParam2, strTemp,
                                       CHAR_GIVEN_BYTE( sizeof(strTemp) ) );
                dprintf2(("    returns: %ls", strTemp));
                break;
            }

            case MCI_STRING:
                dprintf2(("    returns: %ls",(LPWSTR)(1 + (LPDWORD)dwParam2)));
                break;
        }
    }
#endif

    return dwRet;
}

//***********************************************************************
//  mciSendCommandInternal
//
// Internal version of mciSendCommand.  Differs ONLY in that the return
// value is a DWORD where the high word has meaning only for mciSendString
//
//***********************************************************************
STATICFN DWORD mciSendCommandInternal(
    MCIDEVICEID wDeviceID,
    UINT wMessage,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo)
{
    DWORD dwRetVal;
    LPMCI_DEVICE_NODE nodeWorking = NULL;
    BOOL bWalkAll;
    DWORD dwAllError = 0;
    HANDLE hCurrentTask;

    hCurrentTask = GetCurrentTask();

    // If the device is "all" and the message is *not*
    // "sysinfo" then we must walk all devices
    if (wDeviceID == MCI_ALL_DEVICE_ID
       && (wMessage != MCI_SYSINFO)
       && (wMessage != MCI_SOUND))
    {
        if (wMessage == MCI_OPEN)
        {
            dwRetVal = MCIERR_CANNOT_USE_ALL;
            goto exitfn;
        }

        bWalkAll = TRUE;

        // Start at device #1
        wDeviceID = 1;
    } else {
        bWalkAll = FALSE;
    }

    mciEnter("mciSendCommandInternal");
    // Walk through all devices if bWalkAll or just one device if !bWalkAll
    do
    {
        // Initialize
        dwRetVal = 0;

        // Validate the device ID if single device
        if (!bWalkAll)
        {
            if (!MCI_DO_NOT_NEED_OPEN(wMessage))
            {

                if (!MCI_VALID_DEVICE_ID(wDeviceID))
                {
                    dwRetVal = MCIERR_INVALID_DEVICE_ID;
                    goto exitfn;
                }

                nodeWorking = MCI_lpDeviceList[wDeviceID];
            }
        }
        else if (wMessage != MCI_SYSINFO)
        {
            nodeWorking = MCI_lpDeviceList[wDeviceID];
        }

        // Skip if walking the device list and the
        // device is not part of the current task

        if (bWalkAll)
        {
            if (nodeWorking == NULL ||
                nodeWorking->hOpeningTask != hCurrentTask)
                    goto no_send;
        }

        // If the device is in the process of closing and the message
        // is not MCI_CLOSE_DEVICE then return an error
        if (nodeWorking != NULL &&
            ISCLOSING(nodeWorking) &&
            wMessage != MCI_CLOSE_DRIVER)
        {
            dwRetVal = MCIERR_DEVICE_LOCKED;
            goto exitfn;
        }

// If this message is being sent from the wrong task (the device was auto-
// opened) fail all but the MCI_CLOSE message which gets sent inter-task
        if (nodeWorking != NULL &&
            nodeWorking->hCreatorTask != hCurrentTask)
        {
            if (wMessage != MCI_CLOSE)
            {
                dwRetVal = MCIERR_ILLEGAL_FOR_AUTO_OPEN;
                goto exitfn;
            }
            else
            {
// Don't even allow close from mciSendCommand if auto-open device has a
// pending close
                if (ISAUTOCLOSING(nodeWorking))
                {
                    dwRetVal = MCIERR_DEVICE_LOCKED;
                    goto exitfn;
                }
            }
        }

        mciLeave("mciSendCommandInternal");
        dwRetVal = mciSendSingleCommand( wDeviceID, wMessage, dwParam1,
                                         dwParam2, nodeWorking, bWalkAll,
                                         lpOpenInfo);
        mciEnter("mciSendCommandInternal");
no_send:

        // If we are processing multiple devices
        if (bWalkAll)
        {
            // If there was an error for this device
            if (dwRetVal != 0)
            {
                // If this is not the first error
                if (dwAllError != 0) {
                    dwAllError = MCIERR_MULTIPLE;
                // Just one error so far
                } else {
                    dwAllError = dwRetVal;
                }
            }
        }
    } while (bWalkAll && ++wDeviceID < MCI_wNextDeviceID);

exitfn:;
    mciLeave("mciSendCommandInternal");
    return dwAllError == MCIERR_MULTIPLE ? dwAllError : dwRetVal;
}


/************************************************************************
 * @doc EXTERNAL MCI
 *
 * @api DWORD | mciSendCommand | This function sends a command message to
 * the specified MCI device.
 *
 * @parm MCIDEVICEID | wDeviceID | Specifies the device ID of the MCI device
 *  to receive the command.  This parameter is
 *  not used with the <m MCI_OPEN> command.
 *
 * @parm UINT | wMessage | Specifies the command message.
 *
 * @parm DWORD | dwParam1 | Specifies flags for the command.
 *
 * @parm DWORD | dwParam2 | Specifies a pointer to a parameter block
 *  for the command.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *  error information.  The low-order word
 *  of the returned DWORD is the error return value.  If the error is
 *  device-specific, the high-order word contains the driver ID; otherwise
 *  the high-order word is zero.
 *
 *  To get a textual description of <f mciSendCommand> return values,
 *  pass the return value to <f mciGetErrorString>.
 *
 *  Error values that are returned when a device is being opened
 *  are listed with the MCI_OPEN message. In addition to the
 *  MCI_OPEN error returns, this function can
 *  return the following values:
 *
 *  @flag MCIERR_BAD_TIME_FORMAT | Illegal value for time format.
 *
 *  @flag MCIERR_CANNOT_USE_ALL | The device name "all" is not allowed
 *  for this command.
 *
 *  @flag MCIERR_CREATEWINDOW | Could not create or use window.
 *
 *  @flag MCIERR_DEVICE_LOCKED | The device is locked until it is
 *  closed automatically.
 *
 *  @flag MCIERR_DEVICE_NOT_READY | Device not ready.
 *
 *  @flag MCIERR_DEVICE_TYPE_REQUIRED | The device name must be a valid
 *  device type.
 *
 *  @flag MCIERR_DRIVER | Unspecified device error.
 *
 *  @flag MCIERR_DRIVER_INTERNAL | Internal driver error.
 *
 *  @flag MCIERR_FILE_NOT_FOUND | Requested file not found.
 *
 *  @flag MCIERR_FILE_NOT_SAVED | The file was not saved.
 *
 *  @flag MCIERR_FILE_READ | A read from the file failed.
 *
 *  @flag MCIERR_FILE_WRITE | A write to the file failed.
 *
 *  @flag MCIERR_FLAGS_NOT_COMPATIBLE | Incompatible parameters
 *  were specified.
 *
 *  @flag MCIERR_HARDWARE | Hardware error on media device.
 *
 *  @flag MCIERR_INTERNAL | Internal error.
 *
 *  @flag MCIERR_INVALID_DEVICE_ID | Invalid device ID.
 *
 *  @flag MCIERR_INVALID_DEVICE_NAME | The device is not open
 *  or is not known.
 *
 *  @flag MCIERR_INVALID_FILE | Invalid file format.
 *
 *  @flag MCIERR_MULTIPLE | Errors occurred in more than one device.
 *
 *  @flag MCIERR_NO_WINDOW | There is no display window.
 *
 *  @flag MCIERR_NULL_PARAMETER_BLOCK | Parameter block pointer was NULL.
 *
 *  @flag MCIERR_OUT_OF_MEMORY | Not enough memory for requested operation.
 *
 *  @flag MCIERR_OUTOFRANGE | Parameter value out of range.
 *
 *  @flag MCIERR_UNNAMED_RESOURCE | Attempt to save unnamed file.
 *
 *  @flag MCIERR_UNRECOGNIZED_COMMAND | Unknown command.
 *
 *  @flag MCIERR_UNSUPPORTED_FUNCTION | Action not available for this
 *  device.
 *
 *  The following additional return values are defined for MCI sequencers:
 *
 *  @flag MCIERR_SEQ_DIV_INCOMPATIBLE | Set Song Pointer incompatible
 *  with SMPTE files.
 *
 *  @flag MCIERR_SEQ_PORT_INUSE | Specified port is in use.
 *
 *  @flag MCIERR_SEQ_PORT_MAPNODEVICE | Current map uses non-existent
 *  device.
 *
 *  @flag MCIERR_SEQ_PORT_MISCERROR | Miscellaneous error with
 *  specified port.
 *
 *  @flag MCIERR_SEQ_PORT_NONEXISTENT | Specified port does not exist.
 *
 *  @flag MCIERR_SEQ_PORTUNSPECIFIED | No current MIDI port.
 *
 *  @flag MCIERR_SEQ_NOMIDIPRESENT | No MIDI ports present.
 *
 *  @flag MCIERR_SEQ_TIMER | Timer error.
 *
 *  The following additional return values are defined for MCI waveform
 *  audio devices:
 *
 *  @flag MCIERR_WAVE_INPUTSINUSE | No compatible waveform recording
 *   device is free.
 *
 *  @flag MCIERR_WAVE_INPUTSUNSUITABLE | No compatible waveform
 *  recording devices.
 *
 *  @flag MCIERR_WAVE_INPUTUNSPECIFIED | Any compatible waveform
 *  recording device may be used.
 *
 *  @flag MCIERR_WAVE_OUTPUTSINUSE | No compatible waveform playback
 *  device is free.
 *
 *  @flag MCIERR_WAVE_OUTPUTSUNSUITABLE | No compatible waveform
 *  playback devices.
 *
 *  @flag MCIERR_WAVE_OUTPUTUNSPECIFIED | Any compatible waveform
 *  playback device may be used.
 *
 *  @flag MCIERR_WAVE_SETINPUTINUSE | Set waveform recording device
 *  is in use.
 *
 *  @flag MCIERR_WAVE_SETINPUTUNSUITABLE | Set waveform recording
 *  device is incompatible with set format.
 *
 *  @flag MCIERR_WAVE_SETOUTPUTINUSE | Set waveform playback device
 *  is in use.
 *
 *  @flag MCIERR_WAVE_SETOUTPUTUNSUITABLE | Set waveform playback
 *  device is incompatible with set format.
 *
 * @comm Use the <m MCI_OPEN> command to obtain the device ID
 *  specified by <p wDeviceID>.
 *
 * @xref mciGetErrorString mciSendString
 */

 /*
 * @doc internal
 *
 * @api DWORD | mciDriverEntry | Actually a callback.  The entry point for MCI drivers.
 *
 * @parm UINT | wMessage | Identifies the requested action to be performed.
 *
 * @parm DWORD | dwParam1 | Specifies data for this message.  Defined separately
 * for each message.
 *
 * @parm DWORD | dwParam2 | Specifies data for this message.  Defined separately
 * for each message.
 *
 * @rdesc The return value is defined separately for each message.
 */

//  WARNING!!  Casting all pointer references to wMessage to UINT_PTR to
//             clear out warnings.  Note:  This will NOT WORK on Win64;
//             we'll have to change this prototype to get this to work
//             on Win64.

DWORD mciSendCommandA(
    MCIDEVICEID wDeviceID,
    UINT wMessage,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2)
{
    LPCSTR   lpStr1;
    LPCSTR   lpStr2;
    LPCSTR   lpStr3;
    DWORD    dwRet;

    /*
    ** If dwParam1 is 0L, we have no information to perform the ascii
    ** to unicode thunks from.  Therefore, I will pass the call straight
    ** thru to mciSendCommandW "as is".
    */
    if ( dwParam1 == 0L ) {
        return mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2 );
    }

    /*
    ** If we are still here we have some thunking to do.
    **
    **
    ** Basically this code is very similiar to the WOW thunk code.
    **
    ** We have to special case MCI_OPEN and MCI_SYSINFO because the
    ** command table is either not available or in an inconsistent state.
    **
    ** Otherwise, the code is identical to the WOW code.  Maybe we could do
    ** unicode thunking in the WOW layer and then call mciSendCommandW.
    ** It seems bad that we should have to thunk poor old WOW apps twice!!
    ** they are slow enough as it is :-)
    **
    ** We have the advantage that all pointers are already 32 bit.
    **
    */
    switch ( wMessage ) {

    case MCI_CLOSE_DRIVER:
        dprintf3(( "MCI_CLOSE_DRIVER command" ));
        return mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2 );
        break;


    case MCI_OPEN_DRIVER:
        dprintf3(( "MCI_OPEN_DRIVER command" ));

        /* fall thru */

    case MCI_OPEN:
        {
            LPMCI_OPEN_PARMSW lpOpenP = (LPMCI_OPEN_PARMSW)dwParam2;
#if DBG
            dprintf3(( "MCI_OPEN command" ));

            /*
            ** As of yet I don't know how to thunk command extensions
            ** for the open command.
            ** These may well contain strings but we have no way of
            ** knowing because we haven't got access to the command table.
            */
            if ( dwParam1 & 0xFFFF0000 ) {
                dprintf1(( "MCI_OPEN called with command extensions !!" ));
            }
#endif

            /*
            ** First save the original ascii string pointers.
            ** Note that lpstrDeviceType may be a TYPE_ID
            ** Note that lpstrElementName may be a ELEMENT_ID
            */
            lpStr1 = (LPCSTR)lpOpenP->lpstrDeviceType;
            lpStr2 = (LPCSTR)lpOpenP->lpstrElementName;
            lpStr3 = (LPCSTR)lpOpenP->lpstrAlias;

            /*
            ** Now allocate a unicode copy of the ascii, don't try
            ** to copy NULL strings, or ID types
            **
            ** The first string to be copied is lpstrDeviceType.
            ** This pointer is only valid if the MCI_OPEN_TYPE bit
            ** is set and MCI_OPEN_TYPE_ID is not set.  If either
            ** bit is set and lpstrDeviceType is NULL it is an
            ** error that will be picked up later.
            **
            ** The second string is lpstrElementName which is valid
            ** only with MCI_OPEN_ELEMENT set and MCI_OPEN_ELEMENT_ID
            ** not set.  As in the case above it is an error if
            ** either bit is set but the pointer itself is NULL.
            **
            ** The third string is lpstrAlias which is valid only
            ** with MCI_OPEN_ALIAS set.  In this case when this bit
            ** is set there is no modifying bit that changes the
            ** meaning of the pointer.
            **
            ** If an unicode string is not allocated the internal
            ** pointer is set to NULL.  This value can be checked
            ** after the mciSendCommand call to see if the string
            ** has to be freed and the original pointer restored.
            */
            if ( lpStr1 ) {
                if ((dwParam1 & MCI_OPEN_TYPE)
                  && !(dwParam1 & MCI_OPEN_TYPE_ID) ) {
                    lpOpenP->lpstrDeviceType = AllocUnicodeStr( (LPSTR)lpStr1 );
                    if ( lpOpenP->lpstrDeviceType == NULL ) {
                        dwRet = MCIERR_OUT_OF_MEMORY;
                        goto err1;
                    }
                } else lpStr1 = NULL;  // Nothing allocated, will free nothing
            }

            if ( lpStr2 ) {
                if ((dwParam1 & MCI_OPEN_ELEMENT)
                  && !(dwParam1 & MCI_OPEN_ELEMENT_ID) ) {
                    lpOpenP->lpstrElementName = AllocUnicodeStr( (LPSTR)lpStr2 );
                    if ( lpOpenP->lpstrElementName == NULL ) {
                        dwRet = MCIERR_OUT_OF_MEMORY;
                        goto err2;
                    }
                } else lpStr2 = NULL;  // Nothing allocated, will free nothing
            }

            if ( lpStr3 ) {
                if (dwParam1 & MCI_OPEN_ALIAS) {
                    lpOpenP->lpstrAlias = AllocUnicodeStr( (LPSTR)lpStr3 );
                    if ( lpOpenP->lpstrAlias == NULL ) {
                        dwRet = MCIERR_OUT_OF_MEMORY;
                        goto err3;
                    }
                } else lpStr3 = NULL;  // Nothing allocated, will free nothing
            }

            /*
            ** Now call the unicode version
            */
            dwRet = mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2 );

            /*
            ** Free the unicode strings.
            ** and restore the original string pointers
            */
            if ( lpStr3 ) {

                FreeUnicodeStr( (LPWSTR)lpOpenP->lpstrAlias );
      err3:     lpOpenP->lpstrAlias = (LPCWSTR)lpStr3;
            }

            if ( lpStr2 ) {
                FreeUnicodeStr( (LPWSTR)lpOpenP->lpstrElementName );
      err2:     lpOpenP->lpstrElementName = (LPCWSTR)lpStr2;
            }

            if ( lpStr1 ) {
                FreeUnicodeStr( (LPWSTR)lpOpenP->lpstrDeviceType );
      err1:     lpOpenP->lpstrDeviceType  = (LPCWSTR)lpStr1;
            }
            return dwRet;
        }

    case MCI_SYSINFO:
        dprintf3(( "MCI_SYSINFO command" ));
        /*
        ** If we are returning a number forget about UNICODE,
        ** applies when (dwParam1 & MCI_SYSINFO_QUANTITY) is TRUE.
        */
        if ( dwParam1 & MCI_SYSINFO_QUANTITY ) {
            return mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2 );
        }
        else {

            LPMCI_SYSINFO_PARMSW lpInfoP = (LPMCI_SYSINFO_PARMSW)dwParam2;
            DWORD len = BYTE_GIVEN_CHAR( lpInfoP->dwRetSize );

            /*
            ** First save the original ascii string pointers.
            */
            lpStr1 = (LPSTR)lpInfoP->lpstrReturn;

            /*
            ** If there is somewhere to store the result then we
            ** must allocate temporary space (for Unicode result)
            ** and on return from mciSendCommandW translate the
            ** string to Ascii.
            */
            if (len) {
                if ( lpStr1 ) {
                    lpInfoP->lpstrReturn = mciAlloc( len );
                    if ( lpInfoP->lpstrReturn == NULL ) {
                        lpInfoP->lpstrReturn = (LPWSTR)lpStr1;
                        return MCIERR_OUT_OF_MEMORY;
                    }

                    lpStr2 = mciAlloc( len );
                    if ( lpStr2 == NULL ) {
                        mciFree( (LPWSTR)lpInfoP->lpstrReturn );
                        lpInfoP->lpstrReturn = (LPWSTR)lpStr1;
                        return MCIERR_OUT_OF_MEMORY;
                    }
                }
            } else {

                /*
                ** Should we ZERO the string pointers in the parameter block?
                ** Yes, belts and braces !!
                */
                lpInfoP->lpstrReturn = NULL;

            }

            /*
            ** Now call the unicode version
            */
            dwRet = mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2 );

            /*
            ** Copy the unicode return string into ascii, if the
            ** user provided a return string
            */
            if (len && lpStr1) {
                if ((MMSYSERR_NOERROR == dwRet) && len) {
                    UnicodeStrToAsciiStr( (PBYTE)lpStr2,
                                     (PBYTE)lpStr2 + len,
                                     lpInfoP->lpstrReturn );

                    /* On return from mciSendCommandW lpInfoP->dwRetSize is
                    ** equal to the number of characters copied to
                    ** lpInfoP->lpstrReturn less the NULL terminator.
                    ** So add one to lpInfoP->dwRetSize to include the NULL
                    ** in the strncpy below.
                    **
                    ** But ONLY if the original buffer was large enough.
                    */
//#ifdef DBCS
//fix kksuzuka: #3642
//have to copy byte length into ASCII buffer..
                    strncpy( (LPSTR)lpStr1, lpStr2,
                        min(BYTE_GIVEN_CHAR(lpInfoP->dwRetSize+1), CHAR_GIVEN_BYTE(len)));
//#else
//                    strncpy( (LPSTR)lpStr1, lpStr2,
//                        min((UINT)lpInfoP->dwRetSize + 1, CHAR_GIVEN_BYTE(len)) );
//#endif

#if DBG
                    dprintf3(( "Return param (UNICODE)= %ls", lpInfoP->lpstrReturn ));
                    dprintf3(( "Return param (ASCII)  = %s",  lpStr1 ));
#endif
                }

                /*
                ** Free temp storage and restore the original strings
                */
                mciFree( lpInfoP->lpstrReturn );
                lpInfoP->lpstrReturn = (LPWSTR)lpStr1;
                mciFree( lpStr2 );

            }

            return dwRet;
        }


    default:
        {
            /*
            ** NewParms is allocated off the stack in order to minimize
            ** the number of calls to mciAlloc, and it means we do not
            ** have to remember to free it.
            */
            DWORD_PTR   NewParms[MCI_MAX_PARAM_SLOTS];

            /*
            ** dwStrMask is used to store a bitmap representation of which
            ** offsets into dwParam2 contain strings.  ie. bit 4 set
            ** means that dwParam2[4] is a string.
            */
            DWORD   dwStrMask       = 0L;

            /*
            ** fStrReturn is used as a reminder of whether a string return
            ** is expected or not.  If the return type is not a string
            ** we just copy the bytes back as is.  uReturnLength is the
            ** number of bytes to copy back.  dwParm2 is used to ease some
            ** of the addressing used to access the dwParam2 array.
            */
            BOOL        fStrReturn      = FALSE;
            UINT        uReturnLength   = 0;
            PDWORD_PTR  dwParm2         = (PDWORD_PTR)dwParam2;

            /*
            ** The remaining variables are used as we scan our way thru the
            ** command table.
            */
            LPWSTR      lpCommand, lpFirstParameter;
            LPSTR       lpReturnStrTemp;
            UINT        wID;
            DWORD       dwValue;
            UINT        wOffset32, wOffset1stParm32, uTable, uStrlenBytes;
            PDWORD_PTR  pdwParm32;
            DWORD       dwMask = 1;

            if (!dwParam2) {
                return mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2);
            }

            /*
            ** Find the command table for the given command ID.
            ** If the command table is not there we have probably been
            ** given a duff device ID.  Anyway exit with an internal
            ** error.
            */
            lpCommand = FindCommandItem( wDeviceID, NULL, (LPWSTR)(UINT_PTR)wMessage,
                                         NULL, &uTable );
            if ( lpCommand == NULL ) {
                return MCIERR_UNSUPPORTED_FUNCTION;
            }
#if DBG
            ZeroMemory(NewParms, sizeof(NewParms));
#endif


            /*
            ** Copy callback field.
            */
            if ( dwParam1 & MCI_NOTIFY ) {
                NewParms[0] = dwParm2[0];
            }

            /*
            ** Skip past command entry
            */
            lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                        mciEatCommandEntry( lpCommand, NULL, NULL ));

            /*
            ** Get and remember the first parameter
            */
            lpFirstParameter = lpCommand;

            /*
            ** Skip past the DWORD callback field
            */
            wOffset1stParm32 = 4;

            lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                        mciEatCommandEntry( lpCommand, &dwValue, &wID ));
            /*
            ** If the first parameter is a return value, we have some
            ** special processing
            */
            if ( wID == MCI_RETURN ) {

                /*
                ** String return types are a special case.
                */
                if ( dwValue == MCI_STRING ) {

                    dprintf3(( "Found a return string" ));
                    /*
                    ** Get unicode string length in bytes and allocate
                    ** some storage, but only if a valid length has been
                    ** given.  Otherwise set this field to NULL, we must
                    ** use 0 here otherwise the MIPS compiler goes
                    ** ape Xxxx.  We set a flag to remind us to unthunk
                    ** the return string later.
                    **
                    ** Note that we are actually allocating lots of equally
                    ** sized storage here.  This saves on the number of times
                    ** that we call mciAlloc.
                    */
                    if ( uStrlenBytes = (UINT)BYTE_GIVEN_CHAR( dwParm2[2] ) ) {

                        NewParms[1] = (DWORD_PTR)mciAlloc( uStrlenBytes * 2 );
                        dprintf4(( "Allocated %d bytes for the return string at %x", uStrlenBytes, NewParms[1] ));

                        if ( NewParms[1] == 0 ) {

                            mciUnlockCommandTable( uTable );
                            return MCIERR_OUT_OF_MEMORY;
                        }

                        lpReturnStrTemp = (LPSTR)(NewParms[1] + uStrlenBytes);
                        fStrReturn = TRUE;
                    }
                    else {

                        NewParms[1] = (DWORD)0;
                    }

                    /*
                    ** Copy string length.
                    */
                    NewParms[2] = dwParm2[2];
                }

                /*
                ** Adjust the offset of the first parameter.
                */
                uReturnLength = mciGetParamSize( dwValue, wID );
                wOffset1stParm32 += uReturnLength;

                /*
                ** Save the new first parameter pointer
                */
                lpFirstParameter = lpCommand;
            }

            /*
            ** Walk through each flag
            */
            while ( dwMask != 0 ) {

                /*
                ** Is this bit set?
                */
                if ( (dwParam1 & dwMask) != 0 ) {

                    wOffset32 = wOffset1stParm32;
                    lpCommand = (LPWSTR)((LPBYTE)lpFirstParameter +
                                mciEatCommandEntry( lpFirstParameter,
                                                    &dwValue, &wID ));

                    /*
                    ** What parameter uses this bit?
                    */
                    while ( wID != MCI_END_COMMAND && dwValue != dwMask ) {

                        wOffset32 += mciGetParamSize( dwValue, wID );

                        if ( wID == MCI_CONSTANT ) {

                            while ( wID != MCI_END_CONSTANT ) {

                                lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                                            mciEatCommandEntry( lpCommand,
                                                                NULL, &wID ));
                            }
                        }

                        lpCommand = (LPWSTR)((LPBYTE)lpCommand +
                                    mciEatCommandEntry( lpCommand,
                                                        &dwValue, &wID ));
                    }

                    if ( wID != MCI_END_COMMAND ) {

                        pdwParm32 = (PDWORD_PTR)((LPBYTE)NewParms + wOffset32);

                        if ( wID == MCI_STRING ) {

                            /*
                            ** Allocate a unicode string for this parameter
                            ** and set the flag.
                            */
                            *pdwParm32 = (DWORD_PTR)AllocUnicodeStr(
                                       (LPSTR)*(PDWORD_PTR)((LPBYTE)dwParm2 +
                                                                 wOffset32) );
                            //
                            // Turn wOffset32 into a bit mask.
                            // wOffset32 is the slot number offset in bytes
                            dwStrMask |= 1 << ((wOffset32 >> 2) - 1);

                            // Calculate the slot position (offset / 4)
                            // decrement to get the number of bits to shift
                            // shift 1 that number of bits left
                            // and OR into the existing dwStrMask.

#if DBG
                            dprintf3(( "String at %x (Addr %x) (UNICODE)= %ls", wOffset32/4, *pdwParm32 , *pdwParm32 ));
                            dprintf3(( "String at %x (Addr %x) (ASCII)  = %s",  wOffset32/4, *pdwParm32 , (LPSTR)*(PDWORD_PTR)((LPBYTE)dwParm2 + wOffset32) ));
#endif
                        }
                        else {    // not a string

                            /*
                            ** Otherwise copy the parameter as is, if
                            ** there is anything to copy...
                            */
                            wID = mciGetParamSize( dwValue, wID);

                            switch (wID) {
                                case 4:
                                    *pdwParm32 = *(LPDWORD)((LPBYTE)dwParm2 + wOffset32);
                                    break;

                                case 0:
                                    break;

                                default:
                                    // This will be sizeof(MCI_RECT) as of today (Jan 93)
                                    CopyMemory(pdwParm32, (LPBYTE)dwParm2 + wOffset32, wID);
                            }
                        }
                    }
                }

                /*
                ** Go to the next flag
                */
                dwMask <<= 1;
            }

            // If no strings needed converting.  Use the original parameter block
            if ( !(dwStrMask | fStrReturn)) {
                // No strings in parameters.  Use original parameter pointer
                dprintf3(( "NO strings for command %4X", wMessage ));
                dwRet = mciSendCommandW( wDeviceID, wMessage, dwParam1, dwParam2);
                uReturnLength = 0;  // We will not need to copy anything back

            } else {

                dprintf3(( "The unicode string mask is %8X   fStrReturn %x", dwStrMask, fStrReturn ));
                dwRet = (DWORD)mciSendCommandW( wDeviceID, wMessage, dwParam1, (DWORD_PTR)NewParms );
            }

            /*
            ** If there is a string return field we unthunk it here.
            */
            if ( fStrReturn && uStrlenBytes ) {

                /*
                ** If mciSendCommand worked then we need to convert the
                ** return string from unicode to ascii.
                */
                if ( MMSYSERR_NOERROR == dwRet ) {

                    UnicodeStrToAsciiStr( (PBYTE)lpReturnStrTemp,
                                     (PBYTE)lpReturnStrTemp + uStrlenBytes,
                                     (LPWSTR)NewParms[1] );

                    /*
                    ** Copy back the return string size.
                    */
                    dwParm2[2] = NewParms[2];

                    /* On return from mciSendCommandW the dwRetSize field is
                    ** equal to the number of characters copied to
                    ** lpInfoP->lpstrReturn less the NULL terminator.
                    ** So add one to lpInfoP->dwRetSize to include the NULL in
                    ** the strncpy below.
                    **
                    ** But ONLY if the original buffer was large enough.
                    */

//#ifdef DBCS
//fix kksuzuka: #3642
//have to copy byte length into ASCII buffer..
                    strncpy( (LPSTR)dwParm2[1], lpReturnStrTemp,
                        min( (size_t)(BYTE_GIVEN_CHAR(NewParms[2]+1)),
                             (size_t)(CHAR_GIVEN_BYTE(uStrlenBytes))) );
//#else
//                    strncpy( (LPSTR)dwParm2[1], lpReturnStrTemp,
//                        min( (UINT)NewParms[2] + 1,
//                             CHAR_GIVEN_BYTE(uStrlenBytes)) );
//#endif

#if DBG
                    dprintf3(( "Returned string (UNICODE)= %ls", NewParms[1] ));
                    dprintf3(( "Returned string (ASCII)  = %s",  dwParm2[1] ));
#endif
                }

                /*
                ** We need to free the string storage whether mciSendCommand
                ** worked or not.
                */
                dprintf4(( "Freeing returned string at %x", NewParms[1] ));
                mciFree( NewParms[1] );
            }

            /*
            ** Else if there is any other sort of return field unthunk
            ** it by copying across the bytes as is.
            */
            else if ( uReturnLength ) {

                dprintf3(( "Copying back %d returned bytes", uReturnLength ));
                CopyMemory( (LPDWORD)dwParam2 + 1, NewParms + 1, uReturnLength );
            }

            /*
            ** Now go through the dwStrMask and free each field as indicated
            ** by the set bits in the mask.  We start at 1 because the
            ** zero'th field is known to be a window handle.
            */
            wOffset32 = 1;

            for ( ; dwStrMask != 0; dwStrMask >>= 1, wOffset32++ ) {

                if ( dwStrMask & 1 ) {

                    /*
                    ** There is a string at NewParms[ wOffset32 ]
                    */
                    dprintf3(( "Freeing string at %d (%x) (UNICODE) = %ls", wOffset32, NewParms[ wOffset32 ], (LPWSTR)NewParms[ wOffset32 ] ));
                    FreeUnicodeStr( (LPWSTR)NewParms[ wOffset32 ] );
                }
            }

            dprintf4(( "Unlocking command table" ));
            mciUnlockCommandTable( uTable );
        }
    }
    return dwRet;
}


DWORD mciSendCommandW(
    MCIDEVICEID wDeviceID,
    UINT wMessage,
    DWORD_PTR dwParam1,
    DWORD_PTR dwParam2)
{
    UINT  wRet;
    DWORD dwErr;
    MCI_INTERNAL_OPEN_INFO OpenInfo;

// Initialize the device list
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList())
        return MCIERR_OUT_OF_MEMORY;

    dprintf3(("mciSendCommand, command=%x  Device=%x",wMessage, wDeviceID));

//
// Send the command.  This shell is responsible for adding the device ID
// to the error code if necessary
//
    OpenInfo.hCallingTask = GetCurrentTask();
    OpenInfo.lpstrParams = NULL;
    OpenInfo.lpstrPointerList = NULL;
    OpenInfo.wParsingError = 0;
    dwErr = mciSendCommandInternal( wDeviceID, wMessage,
                                    dwParam1, dwParam2, &OpenInfo);

    wRet = LOWORD(dwErr);

    dprintf4(("Return value from mciSendCommandInternal %x", wRet));

// If the return value contains a resource ID then clear it from the high word
// Note that for IA64 the first element of the structure pointed to by
// dwParam2 is always a DWORD_PTR.  However, the second element is not
// currently always a DWORD_PTR, some of the structures currenly have only
// a DWORD element in the second field.  Accordingly, we make sure to only
// update the first DWORD of the second field in the structure, that works
// in every case because none of the bits in 32 - 63 are ever set by existing
// code.
    if (dwErr & MCI_RESOURCE_RETURNED) {
        *(LPDWORD)((PDWORD_PTR)dwParam2+1) &= 0xFFFF;
    }

// If the error message is in a driver, store the driver ID in the high
// word of the error code
    if (wRet >= MCIERR_CUSTOM_DRIVER_BASE) {
        dwErr = (DWORD)wRet | ((DWORD)wDeviceID << 16);
    } else {
        dwErr = (DWORD)wRet;
    }

#if DBG
// Dump the error text if any to the debug terminal
// Note that dwErr != 0 is a VALID return for driver messages.  Only
// trap MCI messages
    if ((dwErr != 0) && (wMessage>=MCI_FIRST))
    {
        WCHAR strTemp[MAXERRORLENGTH];

        if (!mciGetErrorStringW( dwErr,
                                 strTemp,
                                 MAXERRORLENGTH ) ) {

            LoadStringW( ghInst, STR_MCISCERRTXT, strTemp,
                         MAXERRORLENGTH );
        }
        dprintf1(("mciSendCommand: %ls", strTemp));

    }
#endif

    //
    //  Somehow since 3.51 the priorities of threads in WOW have
    //  changed and now the application thread is running at a
    //  higher priority than that of regular threads (i.e. mciavi's
    //  worker thread).  Many applications that use MCI tend to
    //  poll the status of the MCI device that is playing.  This
    //  polling is causing the other threads in WOW to be starved
    //  and brings the playback of AVIs to a crawl.  This sleep
    //  will keep the application thread from buring so much of
    //  the CPU and allow other threads, for example MCIAVI, to
    //  do it's work.
    //
    if ( WinmmRunningInWOW )
    {
        Sleep(0);
    }

    return dwErr;
}

//***************************************************************************
//  mciColonizeDigit
//
// Grab colonized digit
// Return is number of bytes written to output (NOT including NULL)
// or 0 if out of room in output buffer (but is terminated anyway)
// If there is room then at least two digits are written, padded with '0'
// if necessary.  The function assumes that the buffer size is non-zero length,
// as this is checked in the function that calls the function that calls us.
//
//***************************************************************************
STATICFN UINT NEAR mciColonizeDigit(
    LPWSTR  lpstrOutput,
    CHAR    cDigit,
    UINT    uSize)
{
    UINT uCount = 0;

#if DBG
//  There is room for terminating NULL
    if (uSize == 0) {
        dprintf(("MCI: Internal error!!"));
        return 0;
    }
#endif

    uCount = 2;

// If there is room for at least two digits
    if (uSize >= 3)
    {
        if (cDigit >= 100)
        {
            uCount = 3;
            if (uSize < 4)
                goto terminate;
            *lpstrOutput++ = (WCHAR)((cDigit / 100) % 10 + '0');
            cDigit = (CHAR)(cDigit % 100);
        }
        *lpstrOutput++ = (WCHAR)(cDigit / 10 + '0');
        *lpstrOutput++ = (WCHAR)(cDigit % 10 + '0');
    }

terminate:;
    *lpstrOutput++ = '\0';

// If we ran out of room then return an error
    return (uCount >= uSize) ? 0 : uCount;
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciColonize | Convert a colonized dword into a string
 * representation
 *
 * @parm LPWSTR | lpstrOutput | Output buffer
 *
 * @parm UINT | uLength | Size of output buffer
 *
 * @parm DWORD | dwData | Value to convert
 *
 * @parm UINT | uType | Either MCI_COLONIZED3_RETURN or
 * MCI_COLONIZED4_RETURN is set (HIWORD portion only!)
 *
 * @comm Example:  For C4, 0x01020304 is converted to "04:03:02:01"
 *                 For C3, 0x01020304 is converted to "04:03:02"
 *
 * @rdesc FALSE if there is not enough room in the output buffer
 *
 */
STATICFN BOOL NEAR mciColonize(
    LPWSTR lpstrOutput,
    UINT uLength,
    DWORD dwData,
    UINT uType)
{
    LPSTR lpstrInput = (LPSTR)&dwData; // For stepping over each byte of input
    UINT uSize;
    int i;

    for (i = 1; i <= (uType & HIWORD(MCI_COLONIZED3_RETURN) ? 3 : 4); ++i)
    {
        uSize = mciColonizeDigit( lpstrOutput, *lpstrInput++, uLength);

        if (uSize == 0)
            return FALSE;

        lpstrOutput += uSize;
        uLength -= uSize;
        if (i < 3 || i < 4 && uType & HIWORD(MCI_COLONIZED4_RETURN))
        {
            --uLength;
            if (uLength == 0)
                return FALSE;
            else
                *lpstrOutput++ = ':';
        }
    }
    return TRUE;
}

//***********************************************************************
//  mciConvertReturnValue
//
// Convert the return value to a return string
//
//***********************************************************************
UINT mciConvertReturnValue(
    UINT uType,
    UINT uErrCode,
    MCIDEVICEID wDeviceID,
    PDWORD_PTR   dwParams,
    LPWSTR lpstrReturnString,
    UINT uReturnLength ) // This is a character length
{
    UINT    wExternalTable;

    if (lpstrReturnString == NULL || uReturnLength == 0)
        return 0;

    switch (uType)
    {
        case MCI_INTEGER:
        case MCI_HWND:
        case MCI_HPAL:
        case MCI_HDC:
// Convert integer or resource return value to string
            if (uErrCode & HIWORD(MCI_RESOURCE_RETURNED))
            {
                int nResId = HIWORD(dwParams[1]);
                LPMCI_DEVICE_NODE nodeWorking;
                HANDLE hInstance;

                mciEnter("mciConvertReturnValue");

                nodeWorking = MCI_lpDeviceList[wDeviceID];

                mciLeave("mciConvertReturnValue");

                if (nodeWorking == NULL)
                {
// Return blank string on memory error
                    dprintf1(("mciConvertReturnValue Warning:NULL device node"));
                    break;
                }

// Return value is a resource
                if (uErrCode & HIWORD(MCI_RESOURCE_DRIVER))
                {
// Return string ID belongs to driver
                    hInstance = nodeWorking->hDriver;
       // WAS       hInstance = nodeWorking->hCreatorTask;

                    wExternalTable = nodeWorking->wCustomCommandTable;
                } else
                {
                    wExternalTable = nodeWorking->wCommandTable;
                    hInstance = ghInst;
                }

// Try to get string from custom or device specific external table
                if ( wExternalTable == MCI_TABLE_NOT_PRESENT ||
                     command_tables[wExternalTable].hModule == NULL ||

                    LoadStringW( command_tables[wExternalTable].hModule,
                                 nResId,
                                 lpstrReturnString,
                                 uReturnLength ) == 0 )
                {
// Try to get string from CORE.MCI if it's not from the driver
                    if (hInstance != ghInst ||
                        command_tables[0].hModule == NULL ||
                        LoadStringW( command_tables[0].hModule, nResId,
                                     lpstrReturnString,
                                     uReturnLength ) == 0) {

// Get string from custom module or WINMM.DLL
                        LoadStringW( hInstance, nResId, lpstrReturnString,
                                     uReturnLength);
                    }
                }

            } else if (uErrCode & HIWORD(MCI_COLONIZED3_RETURN) ||
                        uErrCode & HIWORD(MCI_COLONIZED4_RETURN))
            {
                if (!mciColonize (lpstrReturnString,
                                uReturnLength, (DWORD)dwParams[1], uErrCode))
                    return MCIERR_PARAM_OVERFLOW;
            } else
// Convert integer return value to string
// NEED BETTER ERROR CHECKING        !!LATER!!
// MUST FIND A VERSION OF THIS WHICH WON'T OVERFLOW OUTPUT BUFFER
            {
                DWORD dwTemp;

// Need room for a sign, up to ten digits and a NULL
                if (uReturnLength < 12)
                    return MCIERR_PARAM_OVERFLOW;

                if (uType == MCI_STRING ||
                    uErrCode == HIWORD(MCI_INTEGER_RETURNED))
                    dwTemp = *(LPDWORD)dwParams[1];
                else
                    dwTemp = (DWORD)dwParams[1];
                wsprintfW(lpstrReturnString, szLongFormat, dwTemp);
            }
            break;
        case MCI_RECT:
// Need from for 4 times (a sign plus 5 digits) plus three spaces and a NULL
            if (uReturnLength < 4 * 6 + 4)
                return MCIERR_PARAM_OVERFLOW;

            wsprintfW (lpstrReturnString, szRectFormat,
                          ((PMCI_ANIM_RECT_PARMS)dwParams)->rc.left,
                          ((PMCI_ANIM_RECT_PARMS)dwParams)->rc.top,
                          ((PMCI_ANIM_RECT_PARMS)dwParams)->rc.right,
                          ((PMCI_ANIM_RECT_PARMS)dwParams)->rc.bottom);
            break;
        default:
// Only support INTEGERs & MIXED
            dprintf1(("mciConvertReturnValue Warning:  Unknown return type"));
            return MCIERR_PARSER_INTERNAL;
    }
    return 0;
}

//***********************************************************************
//  mciSeparateCommandParts
//
// Pull off the command name and device name from the command string,
// leaving *lplpstrCommand pointing past the device name
//
// Returns 0 or an error code on failure.  If successful, the caller must
// free the pstrCommandName and pstrDeviceName
//
// If bCompound then check for a '!' separator in the extracted device name
// and return only the element part.  This is done so that inter-task
// commands to auto-opened devices will include the correct device name
//
//***********************************************************************
STATICFN DWORD NEAR mciSeparateCommandParts(
    LPCWSTR FAR *lplpstrCommand,
    BOOL bCompound,
    LPWSTR FAR *lplpstrCommandName,
    LPWSTR FAR *lplpstrDeviceName)
{
    LPWSTR lpstrCommand;
    UINT uErr;

// Localize the input
    lpstrCommand = (LPWSTR)*lplpstrCommand;

// Remove leading spaces

    while (*lpstrCommand == ' ') {
        ++lpstrCommand;
    }

    if (*lpstrCommand == '\0') {
        return MCIERR_MISSING_COMMAND_STRING;
    }

// Pull the command name off the front of the command string
   if ((uErr = mciEatToken ( (LPCWSTR *)&lpstrCommand, ' ', lplpstrCommandName, FALSE))
       != 0) {
       return uErr;
   }

// Skip past spaces
    while (*lpstrCommand == ' ') {
        ++lpstrCommand;
    }

// If we're looking for compound elements then yank off any leading
// device type if it is not the open command
    if (bCompound && lstrcmpiW( wszOpen, *lplpstrCommandName) != 0)
    {
        LPWSTR lpstrTemp = lpstrCommand;
        while (*lpstrTemp != '\0')
        {
            if (*lpstrTemp == '!')
            {
// A ! was found so skip past it
                lpstrCommand = lpstrTemp + 1;
                break;
            } else
                ++lpstrTemp;
        }
    }

// Pull the device name off of the command string
    if ((uErr = mciEatToken( (LPCWSTR *)&lpstrCommand, ' ', lplpstrDeviceName, FALSE))
        != 0)
    {
        mciFree (*lplpstrCommandName);
        return uErr;

    }

// Fix up the results
    *lplpstrCommand = lpstrCommand;

    return 0;
}


/*--------------------------------------------------------------------*\
 * mciSendSystemString
 *
\*--------------------------------------------------------------------*/
STATICFN DWORD mciSendSystemString(
    LPCWSTR lpstrCommand,
    DWORD dwAdditionalFlags,
    LPWSTR lpstrReturnString,
    UINT uReturnLength)
{
    DWORD dwRet;
    LPMCI_SYSTEM_MESSAGE lpMessage;
    DWORD    CurDirSize;

    dprintf2(("\nmciSendSystemString(%ls)", lpstrCommand));

    if (!CreatehwndNotify()) {
        dprintf1(("NULL notification window handle"));
        return MCIERR_INTERNAL;
    }

    // Get a buffer to hold the current path PLUS an MCI_SYSTEM_MESSAGE structure

    CurDirSize = GetCurrentDirectoryW( 0, NULL );  // Get size required.

                                       // Remember the NULL is not included
    if ( !CurDirSize ) {               // Add 1 for the terminator
        dprintf1(("NULL current path"));
        return MCIERR_GET_CD;
    }
    CurDirSize++;

    if (NULL != (lpMessage = mciAlloc( sizeof(MCI_SYSTEM_MESSAGE)
                                       + BYTE_GIVEN_CHAR( CurDirSize ) ))) {

        LPWSTR lpstrPath = (LPWSTR)( (LPBYTE)lpMessage
                                             + sizeof( MCI_SYSTEM_MESSAGE ) );

        if ( GetCurrentDirectoryW( CurDirSize, lpstrPath ) ) {
            lpMessage->lpstrCommand = (LPWSTR)lpstrCommand;
            lpMessage->dwAdditionalFlags = dwAdditionalFlags;
            lpMessage->lpstrReturnString = lpstrReturnString;
            lpMessage->uReturnLength = uReturnLength;
#if DBG
            if ((0 == uReturnLength) && (0 != lpstrReturnString)) {
                dprintf1((" ******** Return length 0, non 0 return address"));
            }
#endif
            lpMessage->hCallingTask = GetCurrentTask();
            lpMessage->lpstrNewDirectory = lpstrPath;
            // This is where we need to do some thread stuff
            dwRet = (DWORD)SendMessage(hwndNotify, MM_MCISYSTEM_STRING, 0, (LPARAM)lpMessage);
            //dwRet = mciSendStringInternal (NULL, NULL, 0, NULL, lpMessage);
        } else {
            dprintf1(("mciSendSystemString: cannot get current directory\n"));
            dwRet = MCIERR_GET_CD;
        }
        mciFree(lpMessage);
    } else {
        dprintf1(("mciSendSystemString: cannot allocate message block\n"));
        dwRet = MCIERR_OUT_OF_MEMORY;
    }
    return dwRet;
}

/*--------------------------------------------------------------------*\
 * mciRelaySystemString
 *
 * Internal:
 *
\*--------------------------------------------------------------------*/
DWORD mciRelaySystemString(
    LPMCI_SYSTEM_MESSAGE lpMessage)
{
    DWORD    dwRet;
    LPWSTR   lpstrOldPath;
    DWORD    CurDirSize;

    lpstrOldPath = 0;   // Initialise to remove warning message

#if DBG
    dprintf2(("mciRelaySystemString(%ls)", lpMessage->lpstrCommand));
#endif

    // Get a buffer to hold the current path

    CurDirSize = GetCurrentDirectoryW(0, lpstrOldPath);  // Get size required.
                                       // Remember the NULL is not included
    if (!CurDirSize) {                 // Add 1 for the terminator AFTER testing
        dprintf1(("NULL current path")); // for 0 from GetCurrentDirectory
        return MCIERR_INTERNAL;
    }
    CurDirSize++;

    /*
     * Allocate space to hold the current path
     * Fill the allocated space with the current path
     * Set the new current directory to that in the message
     * Execute the MCI command via SentStringInternal
     * Reset to old current directory
     *
     * This code is not reentrant on the same PROCESS!!
     */
    if (NULL != (lpstrOldPath = mciAlloc( BYTE_GIVEN_CHAR(CurDirSize) ))) {

        if (GetCurrentDirectoryW(CurDirSize, lpstrOldPath)) {

            if (SetCurrentDirectoryW(lpMessage->lpstrNewDirectory)) {
                dwRet = mciSendStringInternal (NULL, NULL, 0, NULL, lpMessage);
                if (!SetCurrentDirectoryW(lpstrOldPath)) {
                    dprintf1(("mciRelaySystemString: WARNING, cannot restore path\n"));
                }

            } else {
                dprintf1(("mciRelaySystemString: cannot set new path\n"));
                dwRet = MCIERR_SET_CD;
            }

        } else {

            dprintf1(("mciRelaySystemString: cannot get old path\n"));
            dwRet = MCIERR_GET_CD;
        }

        mciFree(lpstrOldPath);

    } else {
        dprintf1(("mciRelaySystemString: cannot allocate old path\n"));
        dwRet = MCIERR_OUT_OF_MEMORY;
    }

    return dwRet;
}

//***********************************************************************
// mciFindNotify
//
// Returns TRUE if "notify" is contained in string with leading blank
// and trailing blank or '\0'
//***********************************************************************
STATICFN BOOL  mciFindNotify(
    LPWSTR lpString)
{
    while (*lpString != '\0')
    {
        // "notify" must be preceded by a blank
        if (*lpString++ == ' ')
        {
            LPWSTR lpTemp;

            lpTemp = wszNotify;
            while (*lpTemp != '\0' && *lpString != '\0' &&
                   *lpTemp == MCI_TOLOWER(*lpString))
            {
                ++lpTemp;
                ++lpString;
            }
            // "notify" must be followed by a blank or a null
            if (*lpTemp == '\0' &&    // implies that wszNotify was found
                (*lpString == '\0' || *lpString == ' '))
                return TRUE;
        }
    }
    return FALSE;
}

/*
 * @doc INTERNAL MCI
 *
 * @func UINT | mciAutoOpenDevice | Try to auto-open the given device and
 * then send the given command with notification sent to the system task
 * window proc which sends a close command to the device on receipt
 *
 * @parm LPWSTR | lpstrDeviceName | The device name to open
 *
 * @parm LPWSTR | lpstrCommand | The full command to send including the
 * device name which must be the same as lpstrDeviceName
 *
 * @parm LPWSTR | lpstrReturnString | The caller's return string buffer
 *
 * @parm UINT | uReturnLength | Size of the caller's return string buffer
 *
 * @rdesc The errorcode to return to the user
 */
STATICFN UINT NEAR mciAutoOpenDevice(

    LPWSTR lpstrDeviceName,
    LPWSTR lpstrCommand,
    LPWSTR lpstrReturnString,
    UINT uReturnLength)
{
    LPWSTR lpstrTempCommand, lpstrTempReturn = NULL;
    UINT uErr;

    dprintf2(("mciAutoOpenDevice(%ls, %ls)", lpstrDeviceName, lpstrCommand));

//
//  Don't allow recursive auto opens on the mciWindow thread!
//  This can happen when the device auto closes between a command (eg
//  status) being issued on the client thread and executed on the
//  mciWindow thread.
//
//  mciSendStringW will detect this return code and try again - probably
//  causing the device to be auto-opened on the caller's thread.
//
    if (PtrToUlong(GetCurrentTask()) == mciWindowThreadId) {
        return MCIERR_AUTO_ALREADY_CLOSED;
    }


// "notify" not allowed.  This will be found by the parser but the wrong
// error message will be returned.
    if (mciFindNotify (lpstrCommand)) {
        return MCIERR_NOTIFY_ON_AUTO_OPEN;
    }

// Build the command string "open <device name>"

// Must be GMEM_SHARE for system task
// "open" + blank + device name + NULL
    if ( (lpstrTempCommand = mciAlloc(
                                 BYTE_GIVEN_CHAR( wcslen(lpstrDeviceName) +
                                /* Sizeof(wszOpen) == OPEN+NULL */
                                sizeof( wszOpen ) +
                                sizeof( WCHAR ) ) ) ) == NULL) {
        return MCIERR_OUT_OF_MEMORY;
    }

#ifdef WHICH_IS_BEST
    wcscpy (lpstrTempCommand, wszOpen);
    wcscat (lpstrTempCommand, L" ");
    wcscat (lpstrTempCommand, lpstrDeviceName);
#else
    wsprintfW(lpstrTempCommand, szCmdFormat, wszOpen, lpstrDeviceName);
#endif

// Get the open string into the system task via a SendMessage() to mmWndProc
    uErr = (UINT)mciSendSystemString (lpstrTempCommand, 0L, NULL, 0);

    mciFree (lpstrTempCommand);

    if (uErr != 0) {
        return uErr;
    }

    lpstrTempCommand = NULL;
    // Must make a GMEM_SHARE copy of the return string for system task
    if ( lpstrReturnString != NULL ) {
       if ((lpstrTempReturn = mciAlloc(
                              BYTE_GIVEN_CHAR(uReturnLength + 1) )) == NULL )
        {
            // Close the device
            mciDriverNotify (hwndNotify, mciGetDeviceIDW( lpstrDeviceName), 0);
            return MCIERR_OUT_OF_MEMORY;
        }
#if DBG
        *lpstrTempReturn = 0;
#endif
    }

// Get the user command string into the system task via a SendMessage()
// to mmWndProc
// The notification handle is also mmWndProc
    uErr = (UINT)mciSendSystemString( lpstrCommand, MCI_NOTIFY, lpstrTempReturn,
                                      uReturnLength);

// Copy the return string into the user's buffer
    if (lpstrReturnString != NULL) {
        if (uErr == 0) {
            wcscpy( lpstrReturnString, lpstrTempReturn);
        } else { //  ERROR and no string to be copied
            WinAssert(!*lpstrTempReturn);
        }
        mciFree( lpstrTempReturn);
    }


// If there was an error we must close the device
    if (uErr != 0)
    {
        mciAutoCloseDevice( lpstrDeviceName);
    }

    return uErr;
}
//*************************************************************************
// mciSendStringInternal
//
// Identical to mciSendString() but the lpMessage parameter is tacked on
//
// lpMessage comes from inter-task mciSendString and includes an
// hCallingTask item which is sent down the the OPEN command
//
//*************************************************************************
STATICFN DWORD mciSendStringInternal(
    LPCWSTR lpstrCommand,
    LPWSTR  lpstrReturnString,
    UINT   uReturnLength,       // This is a character length - NOT bytes
    HANDLE hCallback,
    LPMCI_SYSTEM_MESSAGE lpMessage)
{
    UINT    wID;
    UINT    uLen;
    UINT    uErr = 0;
    UINT    uConvertReturnValue;
    UINT    wMessage;
    MCIDEVICEID  wDeviceID;
    PDWORD_PTR lpdwParams = NULL;
    DWORD   dwReturn, dwFlags = 0, dwAdditionalFlags = 0;
    LPWSTR   lpCommandItem;
    DWORD   dwErr = 0, dwRetType;
    UINT    wTable = (UINT)MCI_TABLE_NOT_PRESENT;
    LPWSTR   lpstrDeviceName = NULL;
    LPWSTR   lpstrCommandName = NULL;
    LPWSTR   FAR *lpstrPointerList = NULL;
    LPWSTR   lpstrCommandStart;
    HANDLE  hCallingTask;
    UINT    wParsingError;
    BOOL    bNewDevice;
    LPWSTR   lpstrInputCopy = NULL;

    // Did this call come in from another task
    if (lpMessage != NULL)
    {
        dprintf3(("mciSendStringInternal: remote task call"));
        // Yes so restore info
        lpstrCommand      = lpMessage->lpstrCommand;
        dwAdditionalFlags = lpMessage->dwAdditionalFlags;
        lpstrReturnString = lpMessage->lpstrReturnString;
        uReturnLength     = lpMessage->uReturnLength;

#if DBG
        if ((0 == uReturnLength) && (0 != lpstrReturnString)) {
            dprintf((" -------- Return length 0, non 0 return address"));
        }
#endif
        hCallback         = hwndNotify;
        hCallingTask      = lpMessage->hCallingTask;
        lpstrInputCopy    = NULL;
    } else
    {
        BOOL bInQuotes = FALSE;
        // No, so set hCallingTask to current thread
        hCallingTask = GetCurrentTask();

        if (lpstrCommand == NULL) {
            return MCIERR_MISSING_COMMAND_STRING;
        }
        dprintf2(("mciSendString command ->%ls<-",lpstrCommand));

        // Make a copy of the input string and convert tabs to spaces except
        // when inside a quoted string

        if ( (lpstrInputCopy = mciAlloc(
                    BYTE_GIVEN_CHAR( wcslen(lpstrCommand) + 1 ) ) ) == NULL ) {
            return MCIERR_OUT_OF_MEMORY;
        }
        wcscpy(lpstrInputCopy, lpstrCommand);  // Copies to the allocated area
        lpstrCommand = lpstrInputCopy;           // Reset string pointer to copy
        lpstrCommandStart = (LPWSTR)lpstrCommand;

        while (*lpstrCommandStart != '\0')
        {
            if (*lpstrCommandStart == '"') {
                bInQuotes = !bInQuotes;
            }
            else if (!bInQuotes && *lpstrCommandStart == '\t') {
                *lpstrCommandStart = ' ';
            }
            ++lpstrCommandStart;
        }
    }
    lpstrCommandStart = (LPWSTR)lpstrCommand;

    if (lpstrReturnString == NULL) {

        // As an additional safeguard against writing into
        // the output buffer when the return string pointer is NULL,
        // set its length to 0
        uReturnLength = 0;

    } else {
#if DBG
        if (0 == uReturnLength) {
            dprintf(("Return length of zero, but now writing to return string"));
        }
#endif
        // Set return to empty string so that it won't print out garbage if not
        // touched again
        *lpstrReturnString = '\0';
    }

    // Pull the command name and device name off the command string
    if ((dwReturn = mciSeparateCommandParts( (LPCWSTR FAR *)&lpstrCommand,
                                             lpMessage != NULL,
                                             &lpstrCommandName,
                                             &lpstrDeviceName)) != 0)
        goto exitfn;

    // Get the device id (if any) of the given device name
    wDeviceID = mciGetDeviceIDW(lpstrDeviceName);

    // Allow "new" for an empty device name
    if (wDeviceID == 0 && lstrcmpiW (lpstrDeviceName, wszNew) == 0)
    {
        bNewDevice = TRUE;
        *lpstrDeviceName = '\0';
    } else {
        bNewDevice = FALSE;
    }

//  // If the call does not come from another task
//  if (MCI_VALID_DEVICE_ID(wDeviceID) && hCallingTask == GetCurrentTask())
//  {
//      LPMCI_DEVICE_NODE nodeWorking = MCI_lpDeviceList[wDeviceID];
//      if (nodeWorking == NULL)
//      {
//          uErr = MCIERR_INTERNAL;
//          goto cleanup;
//      }
//      // Was the device opened by this task
//      if (nodeWorking->hOpeningTask != nodeWorking->hCreatorTask)
//      // No so send the string inter-task
//      {
//          mciFree(lpstrCommandName);
//          mciFree(lpstrDeviceName);
//          dwReturn = mciSendSystemString (lpstrCommandStart, lpstrReturnString,
//                                      uReturnLength);
//          goto exitfn;
//      }
//  }

    // Look up the command name
    wMessage = mciParseCommand( wDeviceID, lpstrCommandName, lpstrDeviceName,
                                &lpCommandItem, &wTable);

    // If the device was auto-opened the request will go to the auto thread.
    // We do not hang around to find out what happens.  (The device could
    // close at any time.)

    mciEnter("mciSendStringInternal");

    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        LPMCI_DEVICE_NODE nodeWorking;

        nodeWorking = MCI_lpDeviceList[wDeviceID];

        // Is there a pending auto-close message?
        if (ISAUTOCLOSING(nodeWorking))
        {
            uErr = MCIERR_DEVICE_LOCKED;
            mciLeave("mciSendStringInternal");
            goto cleanup;

        // If the call does not come from another task and is not owned by this task
        // and is not the SYSINFO command
        } else if (lpMessage == NULL &&
            nodeWorking->hOpeningTask != nodeWorking->hCreatorTask &&
            wMessage != MCI_SYSINFO)
        // Send the string inter-task
        {
            if ( mciFindNotify( lpstrCommandStart) )
            {
                uErr = MCIERR_NOTIFY_ON_AUTO_OPEN;
                mciLeave("mciSendStringInternal");
                goto cleanup;
            }
            else
            {
                LPWSTR    lpstrReturnStringCopy;

                mciFree(lpstrCommandName);
                mciFree(lpstrDeviceName);
                mciUnlockCommandTable (wTable);

                if (uReturnLength) {
                    lpstrReturnStringCopy = mciAlloc (
                                          BYTE_GIVEN_CHAR(uReturnLength + 1) );
                } else {
                    lpstrReturnStringCopy = NULL;
                }

                mciLeave("mciSendStringInternal");

                // If we failed to allocate a return string we return
                // an error.  Note: return strings are optional
                if ((uReturnLength==0) || (lpstrReturnStringCopy != NULL) )
                {
                    dwReturn = mciSendSystemString( lpstrCommandStart,
                                                    0L,
                                                    lpstrReturnStringCopy,
                                                    uReturnLength);
                    if (uReturnLength) {
                        wcscpy( lpstrReturnString, lpstrReturnStringCopy);
                        mciFree( lpstrReturnStringCopy);
                    }
                } else {
                    dwReturn = MCIERR_OUT_OF_MEMORY;
                }
                goto exitfn;
            }
        } else {
            mciLeave("mciSendStringInternal");
        }
    }
    else {
        mciLeave("mciSendStringInternal");
    }

    // There must be a device name (except for the MCI_SOUND message)
    if (*lpstrDeviceName == '\0' && wMessage != MCI_SOUND && !bNewDevice)
    {
        uErr = MCIERR_MISSING_DEVICE_NAME;
        goto cleanup;
    }

    // The command must appear in the parser tables
    if (wMessage == 0)
    {
        uErr = MCIERR_UNRECOGNIZED_COMMAND;
        goto cleanup;
    }

    // The "new" device name is only legal for the open message
    if (bNewDevice)
    {
        if (wMessage != MCI_OPEN)
        {
            uErr = MCIERR_INVALID_DEVICE_NAME;
            goto cleanup;
        }
    }

    // If there was no device ID
    if (wDeviceID == 0)
    {
        // If auto open is not legal (usually internal commands)
        if (MCI_CANNOT_AUTO_OPEN (wMessage))
        {
            // If the command needs an open device
            if (!MCI_DO_NOT_NEED_OPEN (wMessage))
            {
                dprintf1(("mciSendStringInternal: device needs open"));
                uErr = MCIERR_INVALID_DEVICE_NAME;
                goto cleanup;
            }
        } else {
            // If auto open is legal try to open the device automatically
            uErr = mciAutoOpenDevice( lpstrDeviceName, lpstrCommandStart,
                                      lpstrReturnString, uReturnLength);
            // wDeviceID = MCI_ALL_DEVICE_ID;
            goto cleanup;
        }
    }

    //
    //   Parse the command parameters
    //
    if ((lpdwParams = (PDWORD_PTR)mciAlloc( sizeof(DWORD_PTR) * MCI_MAX_PARAM_SLOTS))
        == NULL)
    {
        uErr = MCIERR_OUT_OF_MEMORY;
        goto cleanup;
    }

    uErr = mciParseParams( wMessage, lpstrCommand, lpCommandItem, &dwFlags,
                           (LPWSTR)lpdwParams,
                           MCI_MAX_PARAM_SLOTS * sizeof(DWORD_PTR),
                           &lpstrPointerList, &wParsingError);
    if (uErr != 0) {
        goto cleanup;
    }

    // The 'new' device keyword requires an alias
    if (bNewDevice && !(dwFlags & MCI_OPEN_ALIAS))
    {
        uErr = MCIERR_NEW_REQUIRES_ALIAS;
        goto cleanup;
    }

    // Parsed OK so execute command

    // Special processing for the MCI_OPEN message's parameters
    if (wMessage == MCI_OPEN)
    {
        // Manually reference the device type and device element
        if (dwFlags & MCI_OPEN_TYPE)
        {
            // The type name was specified explicitly as a parameter
            // so the given device name is the element name
            ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrElementName = lpstrDeviceName;
            dwFlags |= MCI_OPEN_ELEMENT;
        } else
        {
            // A type must be explicitly specified when "new" is used
            if (bNewDevice)
            {
                uErr = MCIERR_INVALID_DEVICE_NAME;
                goto cleanup;
            }

            // The device type is the given device name.  There is no element name
            ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrDeviceType = lpstrDeviceName;
            ((LPMCI_OPEN_PARMSW)lpdwParams)->lpstrElementName = NULL;
            dwFlags |= MCI_OPEN_TYPE;
        }
    }

    else if (wMessage == MCI_SOUND && *lpstrDeviceName != '\0')
    {
        // Kludge the sound name for SOUND
        // mciToLower (lpstrDeviceName);
        if (lstrcmpiW(lpstrDeviceName, wszNotify) == 0)
        {
            *lpstrDeviceName = '\0';
            dwFlags |= MCI_NOTIFY;
        }
        else if ( lstrcmpiW( lpstrDeviceName, wszWait ) == 0)
        {
            *lpstrDeviceName = '\0';
            dwFlags |= MCI_WAIT;
        }
        else
        {
            ((LPMCI_SOUND_PARMSW)lpdwParams)->lpstrSoundName = lpstrDeviceName;
            dwFlags |= MCI_SOUND_NAME;
        }
    }

    // Figure out what kind of return value to expect

    // Initialize flag
    uConvertReturnValue = 0;
    // Skip past header
    uLen = mciEatCommandEntry (lpCommandItem, NULL, NULL);

    // Get return value (if any)
    mciEatCommandEntry ( (LPWSTR)((LPBYTE)lpCommandItem + uLen),
                         &dwRetType, &wID);
    if (wID == MCI_RETURN)
    {
        // There is a return value
        if (wDeviceID == MCI_ALL_DEVICE_ID && wMessage != MCI_SYSINFO)
        {
            uErr = MCIERR_CANNOT_USE_ALL;
            goto cleanup;
        }
        switch (dwRetType)
        {
            case MCI_STRING:
                // The return value is a string, point output buffer to user's buffer
                lpdwParams[1] = (DWORD_PTR)lpstrReturnString;
                lpdwParams[2] = (DWORD_PTR)uReturnLength;
                break;
            case MCI_INTEGER:
            case MCI_HWND:
            case MCI_HPAL:
            case MCI_HDC:
                // The return value is an integer, flag to convert it to a string later
  // new        uConvertReturnValue = MCI_INTEGER;
  // new        break;
            case MCI_RECT:
                // The return value is an rect, flag to convert it to a string later
  // new        uConvertReturnValue = MCI_RECT;
  /* NEW */     uConvertReturnValue = (UINT)dwRetType;
                break;
#if DBG
            default:
                dprintf1(("mciSendStringInternal:  Unknown return type %d",dwRetType));
                break;
#endif
        }
    }

    // We don't need this around anymore
    mciUnlockCommandTable (wTable);
    wTable = (UINT)MCI_TABLE_NOT_PRESENT;

    /* Fill the callback entry */
    lpdwParams[0] = (DWORD_PTR)hCallback;

    // Kludge the type number for SYSINFO
    if (wMessage == MCI_SYSINFO) {
        ((LPMCI_SYSINFO_PARMS)lpdwParams)->wDeviceType =
            mciLookUpType(lpstrDeviceName);
    }

    // Now we actually send the command further into the bowels of MCI!

    // The INTERNAL version of mciSendCommand is used in order to get
    // special return description information encoded in the high word
    // of the return value and to get back the list of pointers allocated
    // by any parsing done in the open command
    {
        MCI_INTERNAL_OPEN_INFO OpenInfo;
        OpenInfo.lpstrParams = (LPWSTR)lpstrCommand;
        OpenInfo.lpstrPointerList = lpstrPointerList;
        OpenInfo.hCallingTask = hCallingTask;
        OpenInfo.wParsingError = wParsingError;
        dwErr = mciSendCommandInternal (wDeviceID, wMessage,
                                        dwFlags | dwAdditionalFlags,
                                        (DWORD_PTR)(LPDWORD)lpdwParams,
                                        &OpenInfo);
    // If the command was reparsed there may be a new pointer list
    // and the old one was free'd
        lpstrPointerList = OpenInfo.lpstrPointerList;
    }

    uErr = LOWORD(dwErr);

    if (uErr != 0) {
        // If command execution error
        goto cleanup;
    }

    // Command executed OK

    // See if a string return came back with an integer instead
    if (dwErr & MCI_INTEGER_RETURNED) {
        uConvertReturnValue = MCI_INTEGER;
    }

    // If the return value must be converted
    if (uConvertReturnValue != 0 && uReturnLength != 0) {
        uErr = mciConvertReturnValue( uConvertReturnValue, HIWORD(dwErr),
                                      wDeviceID, lpdwParams,
                                      lpstrReturnString, uReturnLength);
    }

cleanup:;
    if (wTable != MCI_TABLE_NOT_PRESENT) {
        mciUnlockCommandTable (wTable);
    }

    mciFree(lpstrCommandName);
    mciFree(lpstrDeviceName);
    if (lpdwParams != NULL) {
        mciFree (lpdwParams);
    }

    // Free any memory used by string parameters
    mciParserFree (lpstrPointerList);

    dwReturn =  (uErr >= MCIERR_CUSTOM_DRIVER_BASE ?
                (DWORD)uErr | (DWORD)wDeviceID << 16 :
                (DWORD)uErr);

#if DBG
    if (dwReturn != 0)
    {
        WCHAR strTemp[MAXERRORLENGTH];

        if (!mciGetErrorStringW( dwReturn, strTemp,
                                 sizeof(strTemp) / sizeof(WCHAR) ) ) {
            LoadStringW( ghInst, STR_MCISSERRTXT, strTemp,
                         sizeof(strTemp) / sizeof(WCHAR) );
        }
        else {
            dprintf1(( "mciSendString: %ls", strTemp ));
        }
    }
#endif

exitfn:
    if (lpstrInputCopy != NULL) {
        mciFree (lpstrInputCopy);
    }

#if DBG
    mciCheckLocks();
#endif

    return dwReturn;
}

/*
 * @doc EXTERNAL MCI
 *
 * @api DWORD | mciSendString | This function sends a command string to an
 *  MCI device.  The device that the command is sent to is specified in the
 *  command string.
 *
 * @parm LPCTSTR | lpstrCommand | Points to an MCI command string of the form:
 * [command] [device] [parameters].
 *
 * @parm LPTSTR | lpstrReturnString | Specifies a buffer for return
 *  information. If no return information is needed, you can specify
 *  NULL for this parameter.
 *
 * @parm UINT | uReturnLength | Specifies the size of the return buffer
 *  specified by <p lpstrReturnString>.
 *
 * @parm HANDLE | hCallback | Specifies a handle to a window to call back
 *  if "notify" was specified in the command string.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *  error information. The low-order word
 *  of the returned DWORD contains the error return value.
 *
 *  To get a textual description of <f mciSendString> return values,
 *  pass the return value to <f mciGetErrorString>.
 *
 *  The error returns listed for <f mciSendCommand> also apply to
 *  <f mciSendString>. The following error returns are unique to
 *  <f mciSendString>:
 *
 *  @flag MCIERR_BAD_CONSTANT | Unknown value for parameter.
 *
 *  @flag MCIERR_BAD_INTEGER | Invalid or missing integer in command.
 *
 *  @flag MCIERR_DUPLICATE_FLAGS | A flag or value was specified twice.
 *
 *  @flag MCIERR_MISSING_COMMAND_STRING | No command was specified.
 *
 *  @flag MCIERR_MISSING_DEVICE_NAME | No device name was specified.
 *
 *  @flag MCIERR_MISSING_STRING_ARGUMENT | A string value was
 *  missing from the command.
 *
 *  @flag MCIERR_NEW_REQUIRES_ALIAS | An alias must be used
 *  with the "new" device name.
 *
 *  @flag MCIERR_NO_CLOSING_QUOTE | A closing quotation mark is missing.
 *
 *  @flag MCIERR_NOTIFY_ON_AUTO_OPEN | The "notify" flag is illegal
 *  with auto-open.
 *
 *  @flag MCIERR_PARAM_OVERFLOW | The output string was not long enough.
 *
 *  @flag MCIERR_PARSER_INTERNAL | Internal parser error.
 *
 *  @flag MCIERR_UNRECOGNIZED_KEYWORD | Unknown command parameter.
 *
 * @xref mciGetErrorString mciSendCommand
 */
MCIERROR APIENTRY mciSendStringA(
    LPCSTR lpstrCommand,
    LPSTR  lpstrReturnString,
    UINT   uReturnLength,
    HWND   hwndCallback)
{
    MCIERROR    mciErr;
    LPWSTR      lpwstrCom;
    LPWSTR      lpwstrRet;
    LPSTR       lpstrTmp;
    UINT        len;

#ifdef DBG
    dprintf4(( "Entered mciSendString ASCII" ));
#endif

    // uReturnLength is a character count
    // len is now in bytes
    // WARNING:  The length field might only be valid if a return
    // address is given.  If NO return address is specified, then
    // we do not want to waste time allocating anything.

    if (!lpstrReturnString) {
        uReturnLength = 0;
    }

    len = BYTE_GIVEN_CHAR( uReturnLength );

    // We could make the following code slightly more efficient by
    // allocating a single area of size uReturnLength*2 bytes.
    if (len) {
        lpstrTmp = (LPSTR)mciAlloc( len );
        if ( lpstrTmp == (LPSTR)NULL ) {
                return MCIERR_OUT_OF_MEMORY;
        }

        lpwstrRet = (LPWSTR)mciAlloc( len );
        if ( lpwstrRet == (LPWSTR)NULL ) {
                mciFree( lpstrTmp );
                return MCIERR_OUT_OF_MEMORY;
        }
    } else {
        lpstrTmp = NULL;
        lpwstrRet = NULL;
    }

    lpwstrCom = AllocUnicodeStr( (LPSTR)lpstrCommand );

    if ( lpwstrCom == NULL ) {
        if (len) {
            mciFree( lpstrTmp );
            mciFree( lpwstrRet );
        }
        return MCIERR_OUT_OF_MEMORY;
    }

#ifdef DBG
    dprintf4(( "Unicode Command = %ls", lpwstrCom ));
    dprintf4(( "Ascii command = %s", lpstrCommand ));
#endif

    mciErr = mciSendStringW( lpwstrCom, lpwstrRet, uReturnLength, hwndCallback );

    dprintf4(( "mciSendStringW returned %d", mciErr ));

    if (len) {
	dprintf4(( "Copying Unicode string to Ascii: %ls", lpwstrRet));
        UnicodeStrToAsciiStr( (PBYTE)lpstrTmp, (PBYTE)lpstrTmp + len, lpwstrRet );
        strncpy( lpstrReturnString, lpstrTmp, uReturnLength );
	dprintf4(( "........done: %s", lpstrReturnString));

        mciFree( lpstrTmp );
        mciFree( lpwstrRet );
    }
    FreeUnicodeStr( lpwstrCom );
    return mciErr;
}

MCIERROR APIENTRY mciSendStringW(
    LPCWSTR lpstrCommand,
    LPWSTR  lpstrReturnString,
    UINT   uReturnLength,
    HWND hwndCallback)
{
    MCIERROR wRet;

    // Initialize the device list
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList()) {
        return MCIERR_OUT_OF_MEMORY;
    }

    //
    // We can get return code MCIERR_AUTO_ALREADY_CLOSED if the device is
    // auto-open and appears to be open but when we get to the mciWindow
    // thread it has already closed.  In this case we try again.
    //

    do {
        wRet = mciSendStringInternal (lpstrCommand, lpstrReturnString,
                                      uReturnLength, hwndCallback, NULL);
    } while (wRet == MCIERR_AUTO_ALREADY_CLOSED);

    return wRet;
}

/*
 * @doc INTERNAL MCI
 *
 * @api BOOL | mciExecute | This function is a simplified version of the
 *  <f mciSendString> function.  It does not take a buffer for
 *  return information, and displays a dialog box when
 *  errors occur.
 *
 * @parm LPCSTR | lpstrCommand | Points to an MCI command string of the form:
 * [command] [device] [parameters].
 *
 * @rdesc TRUE if successful, FALSE if unsuccessful.
 *
 * @comm This function provides a simple interface to MCI from scripting
 *  languages.  For debugging, set the "mciexecute" entry in the
 *  [mmdebug] section of WIN.INI to 1 and detailed error information will
 *  be displayed in a dialog box.  If "mmcmd" is set to 0, only user-correctable
 *  error information will be displayed.
 *  THIS FUNCTION IS NOW OBSOLETE AND IS ONLY PRESENT FOR 16BIT COMPATIBILITY
 *  HENCE NO UNICODE VERSION IS PROVIDED
 *
 * @xref mciSendString
 */

BOOL APIENTRY mciExecute(
    LPCSTR lpstrCommand)
{
    WCHAR aszError[MAXERRORLENGTH];
    DWORD dwErr;
    HANDLE hName = 0;
    LPWSTR lpstrName = NULL;

    LPWSTR      lpwstrCom;

    lpwstrCom = AllocUnicodeStr( (LPSTR)lpstrCommand );

    if ( lpwstrCom == NULL ) {
        return FALSE;
    }

    dwErr = mciSendStringW(lpwstrCom, NULL, 0, NULL);
        FreeUnicodeStr( lpwstrCom );

    if (LOWORD(dwErr) == 0) {
        return TRUE;
    }

    if (!mciGetErrorStringW( dwErr, aszError, MAXERRORLENGTH )) {
        LoadStringW( ghInst, STR_MCIUNKNOWN, aszError, MAXERRORLENGTH );

    } else {

        if (lpwstrCom != NULL)
        {
            // Skip initial blanks
            while (*lpwstrCom == ' ') {
                ++lpwstrCom;
            }

            // Then skip the command
            while (*lpwstrCom != ' ' && *lpwstrCom != '\0') {
                ++lpwstrCom;
            }

            // Then blanks before the device name
            while (*lpwstrCom == ' ') ++lpwstrCom;

            // Now, get the device name
            if ( *lpwstrCom != '\0' &&
                   mciEatToken ((LPCWSTR *)&lpwstrCom, ' ', &lpstrName, FALSE)
                        != 0
               ) {
                dprintf1(("Could not allocate device name text for error box"));
            }
        }
    }

    MessageBoxW( NULL, aszError, lpstrName, MB_ICONHAND | MB_OK);

    if (lpstrName != NULL) {
        mciFree(lpstrName);
    }

    return FALSE;
}

/*
 * @doc EXTERNAL MCI
 *
 * @api BOOL | mciGetErrorString | This function returns a
 * textual description of the specified MCI error.
 *
 * @parm DWORD | dwError | Specifies the error code returned by
 *  <f mciSendCommand> or <f mciSendString>.
 *
 * @parm LPTSTR | lpstrBuffer | Specifies a pointer to a buffer that is
 *  filled with a textual description of the specified error.
 *
 * @parm UINT | uLength | Specifies the length of the buffer pointed to by
 *  <p lpstrBuffer>.
 *
 * @rdesc Returns TRUE if successful.  Otherwise, the given error code
 *  was not known.
 */
BOOL APIENTRY mciGetErrorStringA(
    DWORD dwError,
    LPSTR lpstrBuffer,
    UINT uLength)
{
    HANDLE hInst = 0;

    if (lpstrBuffer == NULL) {
        return FALSE;
    }

    // If the high bit is set then get the error string from the driver
    // otherwise get it from mmsystem.dll
    if (HIWORD(dwError) != 0) {

        mciEnter("mciGetErrorStringA");
        if (MCI_VALID_DEVICE_ID ((UINT)HIWORD(dwError))) {

            hInst = MCI_lpDeviceList[HIWORD (dwError)]->hDriver;
        }
        mciLeave("mciGetErrorStringA");

        if (hInst == 0) {
            hInst = ghInst;
            dwError = MCIERR_DRIVER;
        }
    } else {
        hInst = ghInst;
    }

    if (LoadStringA(hInst, LOWORD(dwError), lpstrBuffer, uLength ) == 0)
    {
        // If the string load failed then at least terminate the string
        if (uLength > 0) {
            *lpstrBuffer = '\0';
            dprintf1(("Failed to load resource string"));
        }

        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

BOOL APIENTRY mciGetErrorStringW(
    DWORD dwError,
    LPWSTR lpstrBuffer,
    UINT uLength)
{
    HANDLE hInst = 0;

    if (lpstrBuffer == NULL) {
        return FALSE;
    }

    // If the high bit is set then get the error string from the driver
    // otherwise get it from mmsystem.dll
    if (HIWORD(dwError) != 0) {

        mciEnter("mciGetErrorStringW");
        if (MCI_VALID_DEVICE_ID ((UINT)HIWORD(dwError))) {

            hInst = MCI_lpDeviceList[HIWORD (dwError)]->hDriver;
        }
        mciLeave("mciGetErrorStringW");

        if (hInst == 0) {
            hInst = ghInst;
            dwError = MCIERR_DRIVER;
        }
    } else {
        hInst = ghInst;
    }

    if (LoadStringW(hInst, LOWORD(dwError), lpstrBuffer, uLength ) == 0)
    {
        // If the string load failed then at least terminate the string
        if (uLength > 0) {
            *lpstrBuffer = '\0';
            dprintf1(("Failed to load resource string"));
        }

        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

#if 0
/*
 * Return non-zero if load successful
 */
BOOL MCIInit()
{
    return TRUE;
}

/*
 * Return non-zero if load successful
 */
void MCITerminate()
{
/*
    We would like to close all open devices here but cannot because of
    unknown WEP order
*/
    if (hMciHeap != NULL) {
        HeapDestroy(hMciHeap);
    }

    hMciHeap = NULL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mci.h ===
/***************************************************************************
 *  mci.h
 *
 *  Copyright (c) 1990-1998 Microsoft Corporation
 *
 *  private include file
 *
 *  History
 *
 *  17 Mar 92 - SteveDav - private file for MCI use
 *  30 Apr 92 - StephenE - Converted to Unicode
 *
 ***************************************************************************/


extern CRITICAL_SECTION mciCritSec;  // used to protect process global mci variables
extern  UINT cmciCritSec;   // enter'ed count
extern  UINT uCritSecOwner;   // thread id of critical section owner

#define IDI_MCIHWND 100
#define MCI_GLOBAL_PROCESS "MCIHWND.EXE"
#define MCI_SERVER_NAME    "MMSNDSRV"

#define SND_FREE 0x80000000

#ifndef DOSWIN32
BOOL ServerInit(VOID);
#endif

extern BOOL CreatehwndNotify(VOID);

#if DBG


    // Use mciCheckIn to check that we are within the critical section,
    // mciCheckOut that we are not in the critical section.  Neither
    // routine does anything on the free build.
    #define mciCheckIn()  (WinAssert(uCritSecOwner==GetCurrentThreadId()))
    #define mciCheckOut()  (WinAssert(uCritSecOwner!=GetCurrentThreadId()))

    #define mciEnter(id) dprintf4(("Entering MCI crit sec at %s   Current count is %d", id, cmciCritSec));    \
                        EnterCriticalSection(&mciCritSec),          \
                        uCritSecOwner=GetCurrentThreadId(),         \
                        ++cmciCritSec

    #define mciLeave(id) dprintf4(("Leaving MCI crit sec at %s", id)); mciCheckIn(); if(!--cmciCritSec) uCritSecOwner=0; LeaveCriticalSection(&mciCritSec)


#else
    // No counting or messages in the retail build
    #define mciCheckIn()
    #define mciCheckOut()
    #define mciEnter(id)  EnterCriticalSection(&mciCritSec)
    #define mciLeave(id)  LeaveCriticalSection(&mciCritSec)

#endif


#define mciFirstEnter(id) { mciCheckOut(); mciEnter(id);}

//
// Define the name of a handler entry point
//

#define MCI_HANDLER_PROC_NAME "DriverProc"

//
// Typedef the entry routine for a driver
//

typedef LONG (HANDLERPROC)(DWORD dwId, UINT msg, LONG lp1, LONG lp2);
typedef HANDLERPROC *LPHANDLERPROC;

//
// MCI driver info structure
//

#define MCI_HANDLER_KEY 0x49434D48 // "MCIH"

typedef struct _MCIHANDLERINFO {
    DWORD           dwKey;
    HANDLE          hModule;
    LPHANDLERPROC   lpHandlerProc;
    DWORD           dwOpenId;

} MCIHANDLERINFO, *LPMCIHANDLERINFO;

#ifndef MMNOMCI

#define SetMCIEvent(h) SetEvent(h);
#define ResetMCIEvent(h) ResetEvent(h);

#define LockMCIGlobal  EnterCriticalSection(&mciGlobalCritSec);

#define UnlockMCIGlobal LeaveCriticalSection(&mciGlobalCritSec);

// Although having two unicode file name may make this structure fairly
// large it is still less than a page.
typedef struct tagGlobalMci {
    UINT    msg;                        // Function required
    DWORD   dwFlags;                    // sndPlaySound flags
    LPCWSTR lszSound;                   //
    WCHAR   szSound[MAX_PATH];          //
    WCHAR   szDefaultSound[MAX_PATH];   // Default sound
} GLOBALMCI, * PGLOBALMCI;

extern PGLOBALMCI base;
extern HANDLE   hEvent;

/****************************************************************************

    MCI support

****************************************************************************/

#define ID_CORE_TABLE 200

#define MCI_VALID_DEVICE_ID(wID) ((wID) > 0 && (wID) < MCI_wNextDeviceID && MCI_lpDeviceList[wID])

// Make sure that no MCI command has more than this number of DWORD parameters
#define MCI_MAX_PARAM_SLOTS 20

/******* WARNING ******** Ascii specific ************************************/
#define MCI_TOLOWER(c)  ((WCHAR)((c) >= 'A' && (c) <= 'Z' ? (c) + 0x20 : (c)))
/****************************************************************************/

typedef struct tagCOMMAND_TABLE_TYPE
{
    HANDLE              hResource;
    HANDLE              hModule;        /* If not NULL then free module */
                                        /* when device is free'd        */
    UINT                wType;
    PUINT               lpwIndex;
    LPWSTR              lpResource;
#if DBG
    UINT                wLockCount;     /* Used for debugging */
#endif
} COMMAND_TABLE_TYPE;

typedef struct tagMCI_DEVICE_NODE {
    LPWSTR  lpstrName;       /* The name used in subsequent calls to         */
                             /* mciSendString to refer to the device         */
    LPWSTR  lpstrInstallName;/* The device name from system.ini              */
    DWORD   dwMCIOpenFlags;  /* Flags set on open may be:                    */
                             /*    MCI_OPEN_ELEMENT_ID                       */
                             /*                                              */
    DWORD_PTR   lpDriverData;    /* DWORD of driver instance data                */
    DWORD   dwElementID;     /* The element ID set by MCI_OPEN_ELEMENT_ID    */
    YIELDPROC fpYieldProc;   /* The current yield procedure if any           */
    DWORD   dwYieldData;     /* Data send to the current yield procedure     */
    MCIDEVICEID wDeviceID;   /* The ID used in subsequent calls to           */
                             /* mciSendCommand to refer to the device        */
    UINT    wDeviceType;     /* The type returned from the DRV_OPEN call     */
                             /* MCI_OPEN_SHAREABLE                           */
                             /* MCI_OPEN_ELEMENT_ID                          */
    UINT    wCommandTable;   /* The device type specific command table       */
    UINT    wCustomCommandTable;    /* The custom device command table if    */
                                    /* any (-1 if none)                      */
    HANDLE  hDriver;         /* Module instance handle for the driver        */
    HTASK   hCreatorTask;    /* The task context the device is in            */
    HTASK   hOpeningTask;    /* The task context which sent the open command */
    HANDLE  hDrvDriver;      /* The installable driver handle                */
    DWORD   dwMCIFlags;      /* General flags for this node                  */
} MCI_DEVICE_NODE;
typedef MCI_DEVICE_NODE *LPMCI_DEVICE_NODE;

/* Defines for dwMCIFlags */
#define MCINODE_ISCLOSING       0x00000001   /* Set during close to lock out other commands */
#define MCINODE_ISAUTOCLOSING   0x00010000   /* Set during auto-close to lock out other    */
                                             /* commands except an internally generated close */
#define MCINODE_ISAUTOOPENED    0x00020000   /* Device was auto opened */
#define MCINODE_16BIT_DRIVER    0x80000000   // Device is a 16-bit driver

// Macros for accessing the flag bits.  Using macros is not normally my
// idea of fun, but this case seems to be justified on the grounds of
// being able to maintain control over who is accessing the flags values.
// Note that the flag value are only needed in the header file.
#define ISCLOSING(node)     (((node)->dwMCIFlags) & MCINODE_ISCLOSING)
#define ISAUTOCLOSING(node) (((node)->dwMCIFlags) & MCINODE_ISAUTOCLOSING)
#define ISAUTOOPENED(node)  (((node)->dwMCIFlags) & MCINODE_ISAUTOOPENED)

#define SETAUTOCLOSING(node) (((node)->dwMCIFlags) |= MCINODE_ISAUTOCLOSING)
#define SETISCLOSING(node)   (((node)->dwMCIFlags) |= MCINODE_ISCLOSING)

typedef struct {
    LPWSTR              lpstrParams;
    LPWSTR             *lpstrPointerList;
    HANDLE              hCallingTask;
    UINT                wParsingError;
} MCI_INTERNAL_OPEN_INFO;
typedef MCI_INTERNAL_OPEN_INFO *LPMCI_INTERNAL_OPEN_INFO;

typedef struct tagMCI_SYSTEM_MESSAGE {
    LPWSTR  lpstrCommand;
    DWORD   dwAdditionalFlags;      /* Used by mciAutoOpenDevice to request */
                                    /* Notify                               */
    LPWSTR  lpstrReturnString;
    UINT    uReturnLength;
    HANDLE  hCallingTask;
    LPWSTR  lpstrNewDirectory;      /* The current directory of the calling */
                                    /* task - includes the drive letter     */
} MCI_SYSTEM_MESSAGE;
typedef MCI_SYSTEM_MESSAGE *LPMCI_SYSTEM_MESSAGE;

#define MCI_INIT_DEVICE_LIST_SIZE   4
#define MCI_DEVICE_LIST_GROW_SIZE   4

#define MAX_COMMAND_TABLES 20

extern BOOL MCI_bDeviceListInitialized;

extern LPMCI_DEVICE_NODE *MCI_lpDeviceList;
extern UINT MCI_wDeviceListSize;

extern MCIDEVICEID MCI_wNextDeviceID;   /* the next device ID to use for a new device */

extern COMMAND_TABLE_TYPE command_tables[MAX_COMMAND_TABLES];

#define mciToLower(lpstrString)   CharLower(lpstrString)

extern BOOL  mciGlobalInit(void);
extern BOOL  mciSoundInit(void);

extern BOOL  mciInitDeviceList(void);

extern UINT  mciOpenDevice( DWORD dwFlags,
                            LPMCI_OPEN_PARMSW lpOpenParms,
                            LPMCI_INTERNAL_OPEN_INFO lpOpenInfo);

extern UINT  mciCloseDevice( MCIDEVICEID wID, DWORD dwFlags,
                             LPMCI_GENERIC_PARMS lpGeneric,
                             BOOL bCloseDriver);

extern UINT  mciLoadTableType(UINT wType);

extern LPWSTR FindCommandInTable (UINT wTable, LPCWSTR lpstrCommand,
                                 PUINT lpwMessage);

extern UINT mciEatToken (LPCWSTR *lplpstrInput, WCHAR cSeparater,
                         LPWSTR *lplpstrOutput, BOOL bMustFind);

extern LPWSTR FindCommandItem (MCIDEVICEID wDeviceID, LPCWSTR lpstrType,
                              LPCWSTR lpstrCommand, PUINT lpwMessage,
                              PUINT lpwTable);

extern UINT mciParseParams (UINT    uMessage,
                            LPCWSTR lpstrParams,
                            LPCWSTR lpCommandList,
                            LPDWORD lpdwFlags,
                            LPWSTR  lpOutputParams,
                            UINT    wParamsSize,
                            LPWSTR  **lpPointerList,
                            PUINT   lpwParsingError);

extern UINT  mciParseCommand (MCIDEVICEID wDeviceID,
                              LPWSTR  lpstrCommand,
                              LPCWSTR lpstrDeviceName,
                              LPWSTR *lpCommandList,
                              PUINT   lpwTable);

extern VOID  mciParserFree (LPWSTR *lpstrPointerList);

extern UINT mciEatCommandEntry(LPCWSTR lpEntry, LPDWORD lpValue, PUINT lpID);

extern UINT mciGetParamSize (DWORD dwValue, UINT wID);

extern DWORD mciSysinfo (MCIDEVICEID wDeviceID, DWORD dwFlags,
                         LPMCI_SYSINFO_PARMSW lpSysinfo);
extern UINT mciLookUpType (LPCWSTR lpstrTypeName);

extern BOOL mciExtractDeviceType (LPCWSTR lpstrDeviceName,
                                  LPWSTR lpstrDeviceType,
                                  UINT uBufLen);
extern BOOL mciUnlockCommandTable (UINT wCommandTable);

extern UINT mciSetBreakKey (MCIDEVICEID wDeviceID, int nVirtKey, HWND hwndTrap);


/***************************************************************************

    MCI memory allocation

***************************************************************************/

#define mciAlloc(cb) winmmAlloc((DWORD)(cb))
#define mciReAlloc(ptr, cb) winmmReAlloc((PVOID)(ptr), (DWORD)(cb))
#define mciFree(ptr) winmmFree((PVOID)(ptr))

/*
// Random stuff for MCI
*/

extern DWORD mciRelaySystemString (LPMCI_SYSTEM_MESSAGE lpMessage);
void MciNotify(DWORD wParam, LONG lParam);        // in MCI.C

#endif // MMNOMCI

/*
// Some defines introduced to avoid  signed/unsigned compares - and to
// remove the need for absolute constants in the code
*/

#define MCI_ERROR_VALUE         ((UINT)(-1))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\mciparse.c ===
/*******************************Module*Header*********************************\
* Module Name: mciparse.c
*
* Media Control Architecture Command Parser
*
* Created: 3/2/90
* Author:  DLL (DavidLe)
*
* History:
* 5/22/91: Ported to Win32 - NigelT
* 4 Mar 1992: SteveDav - much work for NT.  Bring up to Win 3.1 level
*
* Copyright (c) 1991-1998 Microsoft Corporation
*
\******************************************************************************/

//****************************************************************************
//
// This has to be defined in order to pick up the
// correct version of MAKEINTRESOURCE
//
//****************************************************************************
#define UNICODE

/*****************************************************************************
 * Notes:                                                                    *
 *                                                                           *
 *  MCI command tables are (normally) loaded from resource type files.  The  *
 *  format of a command table is shown below.  Note that because the table   *
 *  contains string data, the binary values are UNALIGNED.  This causes      *
 *  specific problems on MIPS machines.                                      *
 *                                                                           *
 *  Because of compatibility with Windows 3.1 the binary data is WORD size   *
 *                                                                           *
 * Table format:                                                             *
 *                                                                           *
 * verb\0   MCI_MESSAGE,0   MCI_command_type                                 *
 *                                                                           *
 * e.g.                                                                      *
 * 'o' 'p' 'e' 'n' 03 08 00 00 00 'n' 'o' 't' 'i' 'f' 'y' 00                 *
 * 01  00  00  00  00 05 00                                                  *
 *                                                                           *
 * which is "open" MCI_OPEN,0,   MCI_COMMAND_HEAD                            *
 *        "notify" MCI_NOTIFY,0  MCI_FLAG                                    *
 *                                                                           *
 * beware of the byte ordering!                                              *
 *                                                                           *
 ****************************************************************************/


#include "winmmi.h"
#include "mci.h"
#include "wchar.h"
#include <digitalv.h>

#define _INC_WOW_CONVERSIONS
#include "mmwow32.h"

extern WSZCODE wszOpen[];       // in MCI.C

STATICFN UINT mciRegisterCommandTable( HANDLE hResource, PUINT lpwIndex,
                              UINT wType, HANDLE hModule);
STATICFN UINT mciParseArgument ( UINT uMessage, DWORD dwValue, UINT wID,
    LPWSTR FAR *lplpstrOutput, LPDWORD lpdwFlags, LPWSTR lpArgument,
    LPWSTR lpCurrentCommandItem);

//
//  Define the init code for this file. This is commented out in debug builds
//  so that codeview doesn't get confused.


#if DBG
extern int mciDebugLevel;
#endif

// Number of command tables registered, including "holes"
STATICDT UINT number_of_command_tables = 0;

// Command table list
COMMAND_TABLE_TYPE command_tables[MAX_COMMAND_TABLES];

STATICDT WSZCODE wszTypeTableExtension[] = L".mci";
STATICDT WSZCODE wszCoreTable[]          = L"core";

// Core table is loaded when the first MCI command table is requested
STATICDT BOOL bCoreTableLoaded = FALSE;

// One element for each device type.  Value is the table type to use
// or 0 if there is no device type specific table.
STATICDT UINT table_types[] =
{
    MCI_DEVTYPE_VCR,                // vcr
    MCI_DEVTYPE_VIDEODISC,          // videodisc
    MCI_DEVTYPE_OVERLAY,            // overlay
    MCI_DEVTYPE_CD_AUDIO,           // cdaudio
    MCI_DEVTYPE_DAT,                // dat
    MCI_DEVTYPE_SCANNER,            // scanner
    MCI_DEVTYPE_ANIMATION,          // animation
    MCI_DEVTYPE_DIGITAL_VIDEO,      // digitalvideo
    MCI_DEVTYPE_OTHER,              // other
    MCI_DEVTYPE_WAVEFORM_AUDIO,     // waveaudio
    MCI_DEVTYPE_SEQUENCER           // sequencer
};

/*
 * @doc INTERNAL MCI
 * @func UINT | mciEatCommandEntry | Read a command resource entry and
 * return its length and its value and identifier
 *
 * @parm LPWCSTR | lpEntry | The start of the command resource entry
 *
 * @parm LPDWORD | lpValue | The value of the entry, returned to caller
 * May be NULL
 *
 * @parm PUINT | lpID | The identifier of the entry, returned to caller
 * May be NULL
 *
 * @rdesc The total number of bytes in the entry
 *
 */
UINT mciEatCommandEntry (
    LPCWSTR  lpEntry,
    LPDWORD lpValue,
    PUINT   lpID)
{
    LPCWSTR lpScan = lpEntry;
    LPBYTE  lpByte;

#if DBG
    DWORD   Value;
    UINT    Id;
#endif

// NOTE:  The data will generally be UNALIGNED

    /* Skip to end */
    while (*lpScan++ != '\0'){}

    /* lpScan now points at the byte beyond the terminating zero */
    lpByte = (LPBYTE)lpScan;


    if (lpValue != NULL) {
        *lpValue = *(UNALIGNED DWORD *)lpScan;
    }

#if DBG
    Value = *(UNALIGNED DWORD *)lpScan;
#endif

    lpByte += sizeof(DWORD);

    if (lpID != NULL) {
        *lpID = *(UNALIGNED WORD *)lpByte;
    }

#if DBG
    Id = *(UNALIGNED WORD *)lpByte;
#endif

    lpByte += sizeof(WORD);
//
// WARNING !! This assumes that the table being looked at has WORD
// size entries in the RCDATA resource
//

#if DBG
    dprintf5(("mciEatCommandEntry(%ls)  Value: %x   Id: %x", lpEntry, Value, Id));
#endif

    return (UINT)(lpByte - (LPBYTE)lpEntry);  // Total size of entry in bytes
}

//
// Return the size used by this token in the parameter list
//

UINT mciGetParamSize (
    DWORD dwValue,
    UINT wID)
{
    // MCI_RETURN returns 8 for sizeof(STRING) as there is a length
    // field as well as the string pointer.  For non MCI_RETURN uses
    // of MCI_STRING we should return 4 (== sizeof pointer)
    // Similarly, MCI_CONSTANT used within MCI_RETURN is size 0, but
    // size 4 when used as an input parameter.

    if (wID == MCI_RETURN) {
        if (dwValue==MCI_STRING) {
            return(8);
        } else if (dwValue==MCI_CONSTANT) {
            wID = 0;
        } else {
            wID=dwValue;
        }
    }

    switch (wID)
    {
        case MCI_CONSTANT:
        case MCI_INTEGER:
        case MCI_STRING:
        case MCI_HWND:
        case MCI_HPAL:
        case MCI_HDC:
            return sizeof(DWORD_PTR);  // In Win64, sizeof pointer is 8

        case MCI_RECT:
            return sizeof(RECT);

    }
    // Note that some items will not be found - deliberately.  For example
    // MCI_FLAG causes 0 to be returned.
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciRegisterCommandTable | This function adds a new
 * table for the MCI parser.
 *
 * @parm HANDLE | hResource | Handle to the RCDATA resource
 *
 * @parm PUINT | lpwIndex | Pointer to command table index
 *
 * @parm UINT   | wType | Specifies the device type for this command table.
 * Driver tables and the core table are type 0.
 *
 * @rdesc Returns the command table index number that was assigned or MCI_ERROR_VALUE
 * on error.
 *
 */
STATICFN UINT mciRegisterCommandTable (
    HANDLE hResource,
    PUINT lpwIndex,
    UINT wType,
    HANDLE hModule)
{
    UINT uID;


    /* First check for free slots */

    mciEnter("mciRegisterCommandTable");

    for (uID = 0; uID < number_of_command_tables; ++uID) {
        if (command_tables[uID].hResource == NULL) {
            break;
        }
    }

    /* If no empty slots then allocate another one */
    if (uID >= number_of_command_tables)
    {
        if (number_of_command_tables == MAX_COMMAND_TABLES)
        {
            dprintf1(("mciRegisterCommandTable: No more tables"));
            mciFree(lpwIndex);  // Cannot use it - must free it
            mciLeave("mciRegisterCommandTable");
            return (UINT)MCI_ERROR_VALUE;

        } else {

           uID = number_of_command_tables++;
           // The table goes at the end of the list
        }
    }

    /* Fill in the slot */
    command_tables[uID].wType = wType;
    command_tables[uID].hResource = hResource;
    command_tables[uID].lpwIndex = lpwIndex;
    command_tables[uID].hModule = hModule;
#if DBG
    command_tables[uID].wLockCount = 0;
#endif

    // now that hResource has been filled in marking the entry as used
    // we can allow others access.
    mciLeave("mciRegisterCommandTable");

#if DBG
    if (mciDebugLevel > 2)
    {
        dprintf2(("mciRegisterCommandTable INFO: assigned slot %d", uID));
        dprintf2(("mciRegisterCommandTable INFO: #tables is %d", number_of_command_tables));
    }
#endif
    return uID;
}

/*
 * @doc DDK MCI
 * @api UINT | mciLoadCommandResource | Registers the indicated
 * resource as an MCI command table and builds a command table
 * index.  If a file with the resource name and the extension '.mci' is
 * found in the path then the resource is taken from that file.
 *
 * @parm HANDLE | hInstance | The instance of the module whose executable
 * file contains the resource.  This parameter is ignored if an external file
 * is found.
 *
 * @parm LPCWSTR | lpResName | The name of the resource
 *
 * @parm UINT | wType | The table type.  Custom device specific tables MUST
 * give a table type of 0.
 *
 * @rdesc Returns the command table index number that was assigned or MCI_ERROR_VALUE
 * on error.
 *
 */
UINT  mciLoadCommandResource (
    HANDLE hInstance,
    LPCWSTR lpResName,
    UINT wType)
{
    BOOL        fResType = !HIWORD(lpResName);
    PUINT       lpwIndex, lpwScan;
    HANDLE      hExternal = NULL;
    HANDLE      hResource;
    HANDLE      hResInfo;
    LPWSTR      lpResource, lpScan;
    int         nCommands = 0;
    UINT        wLen;
    UINT        wID;
                        // Name + '.' + Extension + '\0'
    WCHAR       strFile[8 + 1 + 3 + 1];
    LPWSTR      lpstrFile = strFile;
    LPCWSTR     lpstrType = lpResName;

#if DBG
    if (!fResType) {
        dprintf3(("mciLoadCommandResource INFO:  Resource name >%ls< ", (LPWSTR)lpResName));
    } else if (LOWORD(lpResName)) {
        dprintf3(("mciLoadCommandResource INFO:  Resource ID >%d<", (UINT)LOWORD(lpResName)));
    } else {
        dprintf3(("mciLoadCommandResource INFO:  NULL resource pointer"));
    }
#endif

    // Initialize the device list
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList()) {
        return (UINT)MCI_ERROR_VALUE;   // MCIERR_OUT_OF_MEMORY;
    }

    // Load the core table if its not already there
    if (!bCoreTableLoaded)

    {
        bCoreTableLoaded = TRUE;
        // Now we can call ourselves recursively to first load the core
        // table.  Check if this is a request to load CORE - if yes,
        // simply drop through.

        // If its not our core table being loaded...
        // which is decided by comparing the string with CORE, or if a
        // resource id has been given, the resource id is ID_CORE and comes
        // from our module

        // The test is structured this way so that lstrcmpiW is only called
        // if we have a valid pointer.

#define fNotCoreTable ( fResType  \
                         ? ((hInstance != ghInst) || (ID_CORE_TABLE != (UINT)(UINT_PTR)lpResName)) \
                         : (0 != lstrcmpiW (wszCoreTable, (LPWSTR)lpResName)))

        if (fNotCoreTable) {

            // We are not being asked to load the core table.  So we
            // explicitly load the core table first
            if (mciLoadCommandResource (ghInst, MAKEINTRESOURCE(ID_CORE_TABLE), 0) == MCI_ERROR_VALUE)
            {
                dprintf1(("mciLoadCommandResource:  Cannot load core table"));
            }
        }
    }

    // Unless this is a resource ID, go and look for a file
    if (!fResType) {

        WCHAR ExpandedName[MAX_PATH];
        LPWSTR FilePart;

        // Check for a file with the extension ".mci"
        // Copy up to the first eight characters of device type
        // !!LATER!!  Try a check for a resource first, then a file
        while (lpstrType < lpResName + 8 && *lpstrType != '\0') {
            *lpstrFile++ = *lpstrType++;
        }

        // Tack extension onto end
        wcscpy (lpstrFile, wszTypeTableExtension);

        // If the file exists and can be loaded then set flag to use it.
        // (Otherwise we will try and load the resource from WINMM.DLL.)

        if (!SearchPathW(NULL, strFile, NULL, MAX_PATH, ExpandedName,
                        &FilePart)) {
            hExternal = NULL;
        } else {
            UINT OldErrorMode;

            OldErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);

            // Use "ExpandedName" to prevent a second search taking place
            hExternal = LoadLibraryExW( ExpandedName, //strFile,
                                        NULL,
                                        DONT_RESOLVE_DLL_REFERENCES);
            SetErrorMode(OldErrorMode);
        }
    }

    // Load the given table from the file or from the module if not found
    if (hExternal != NULL &&
        (hResInfo = FindResourceW(hExternal, lpResName, RT_RCDATA )) != NULL)
    {
        hInstance = hExternal;
    } else {
        hResInfo = FindResourceW(hInstance, lpResName, RT_RCDATA );
    }

    if (hResInfo == NULL)
    {
#if DBG
        if (!fResType) {
            dprintf3(("mciLoadCommandResource Cannot find command resource name >%ls< ", (LPWSTR)lpResName));
        } else {
            dprintf3(("mciLoadCommandResource Cannot find command resource ID >%d<", (UINT)LOWORD(lpResName)));
        }
#endif
        if (NULL != hExternal) {
            FreeLibrary(hExternal);  // Clean up after ourselves
        }
        return (UINT)MCI_ERROR_VALUE;
    }

    if ((hResource = LoadResource (hInstance, hResInfo)) == NULL)
    {
#if DBG
        if (!fResType) {
            dprintf3(("mciLoadCommandResource Cannot load command resource name >%ls< ", (LPWSTR)lpResName));
        } else {
            dprintf3(("mciLoadCommandResource Cannot load command resource ID >%d<", (UINT)LOWORD(lpResName)));
        }
#endif
        if (NULL != hExternal) {
            FreeLibrary(hExternal);  // Clean up after ourselves
        }
        return (UINT)MCI_ERROR_VALUE;
    }

    if ((lpResource = LockResource (hResource)) == NULL)
    {
        dprintf1(("mciLoadCommandResource:  Cannot lock resource"));
        FreeResource (hResource);
        if (NULL != hExternal) {
            FreeLibrary(hExternal);  // Clean up after ourselves
        }
        return (UINT)MCI_ERROR_VALUE;
    }

    /* Count the number of commands  */
    lpScan = lpResource;

    while (TRUE)
    {
        (LPBYTE)lpScan = (LPBYTE)lpScan + mciEatCommandEntry(lpScan, NULL, &wID);

        // End of command?
        if (wID == MCI_COMMAND_HEAD)
            ++nCommands;

        // End of command list?
        else if (wID == MCI_END_COMMAND_LIST)
            break;
    }


    // There must be at least one command in the table
    if (nCommands == 0)
    {
        dprintf1(("mciLoadCommandResource:  No commands in the specified table"));
        UnlockResource (hResource);
        FreeResource (hResource);
        if (NULL != hExternal) {
            FreeLibrary(hExternal);  // Clean up after ourselves
        }
        return (UINT)MCI_ERROR_VALUE;
    } else {
        dprintf3(("mciLoadCommandResource:  %d commands in the specified table", nCommands));
    }

    // Allocate storage for the command table index
    // Leave room for a MCI_TABLE_NOT_PRESENT entry to terminate it
    if ((lpwIndex = mciAlloc (sizeof (*lpwIndex) * (nCommands + 1)))
                        == NULL)
    {
        dprintf1(("mciLoadCommandResource:  cannot allocate command table index"));
        UnlockResource (hResource);
        FreeResource (hResource);
        if (NULL != hExternal) {
            FreeLibrary(hExternal);  // Clean up after ourselves
        }
        return (UINT)MCI_ERROR_VALUE;
    }

    /* Build Command Table */
    lpwScan = lpwIndex;
    lpScan = lpResource;

    while (TRUE)
    {
    // Get next command entry
        wLen = mciEatCommandEntry (lpScan, NULL, &wID);

        if (wID == MCI_COMMAND_HEAD)
        {
            // Add an offset index to this command from start of resource
            *lpwScan++ = (UINT)((LPBYTE)lpScan - (LPBYTE)lpResource);
        }
        else if (wID == MCI_END_COMMAND_LIST)
        {
            // Mark the end of the table
            *lpwScan = (UINT)MCI_TABLE_NOT_PRESENT;
            break;
        }
        (LPBYTE)lpScan = (LPBYTE)lpScan + wLen;
    }

    UnlockResource (hResource);
    return mciRegisterCommandTable (hResource, lpwIndex, wType, hExternal);
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciLoadTableType | If the table of the given type
 * has not been loaded, register it
 *
 * @parm UINT | wType | The table type to load
 *
 * @rdesc Returns the command table index number that was assigned or MCI_ERROR_VALUE
 * on error.
 */
UINT mciLoadTableType (
    UINT wType)
{
    UINT wID;
#ifdef OLD
    WCHAR buf[MCI_MAX_DEVICE_TYPE_LENGTH];
#endif

    // Check to see if this table type is already loaded
    for (wID = 0; wID < number_of_command_tables; ++wID) {
        if (command_tables[wID].wType == wType) {
            return wID;
        }
    }

    // Must load table
    // First look up what device type specific table to load for this type
    if (wType < MCI_DEVTYPE_FIRST || wType > MCI_DEVTYPE_LAST) {
        return (UINT)MCI_ERROR_VALUE;
    }

    // Load string that corresponds to table type
#ifdef OLD

#ifdef WIN31CODE
    // Load string that corresponds to table type
    buf[0] = 0;    // In case load string fails to set anything

    LoadString (ghInst, table_types[wType - MCI_DEVTYPE_FIRST],
                buf, sizeof(buf));
    {

    //Must be at least one character in type name
    int nTypeLen;
    if ((nTypeLen = wcslen (buf)) < 1)
        return MCI_ERROR_VALUE;
    }
#else
    // Load string that corresponds to table type
    buf[0] = 0;    // In case load string fails to set anything

    if (!LoadString (ghInst, table_types[wType - MCI_DEVTYPE_FIRST],
                buf, sizeof(buf))) {
        //Must put at least one character into type name
        return MCI_ERROR_VALUE;
   }
#endif    // WIN31CODE

    // Register the table with MCI
    return mciLoadCommandResource (ghInst, buf, wType);

#else // not old
    // Command tables are stored as RCDATA blocks with an id of the device type
    // If mciLoadCommandResource fails to find the command table then it
    // will return MCI_ERROR_VALUE

    //if (!FindResource(ghInst, wType, RT_RCDATA))
//        return MCI_ERROR_VALUE;
//
    // Register the table with MCI
    return mciLoadCommandResource (ghInst, MAKEINTRESOURCE(wType), wType);
#endif
}


/*
 * @doc DDK MCI
 *
 * @api BOOL | mciFreeCommandResource | Frees the memory used
 * by the specified command table.
 *
 * @parm UINT | wTable | The table index returned from a previous call to
 * mciLoadCommandResource.
 *
 * @rdesc FALSE if the table index is not valid, TRUE otherwise.
 *
 */
BOOL APIENTRY mciFreeCommandResource (
    UINT wTable)
{
    MCIDEVICEID wID;
    HANDLE  hResource;
    PUINT   lpwIndex;

    dprintf3(("mciFreeCommandResource INFO:  Free table %d", wTable));
    dprintf3(("mciFreeCommandResource INFO:  Lockcount is %d", command_tables[wTable].wLockCount));

/* Validate input -- do not let the core table be free'd */
    if (wTable == MCI_TABLE_NOT_PRESENT || wTable >= number_of_command_tables)
    {

#if DBG
        // wTable == MCI_TABLE_NOT_PRESENT is OK
        if (wTable != MCI_TABLE_NOT_PRESENT) {
            dprintf1(("mciFreeCommandResource: Cannot free table number %d", wTable));
        }
#endif
        return FALSE;
    }

    mciEnter("mciFreeCommandResource");

    // If this table is being used elsewhere then keep it around
    for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
    {
        if (MCI_lpDeviceList[wID] != NULL)
        {
            if (MCI_lpDeviceList[wID]->wCustomCommandTable == wTable ||
                MCI_lpDeviceList[wID]->wCommandTable == wTable)
            {
#if DBG
                if (mciDebugLevel > 2) {
                    dprintf1(("mciFreeCommandResource INFO:  table in use"));
                }
#endif
                mciLeave("mciFreeCommandResource");
                return FALSE;
            }
        }
    }

#if 0
/* Search the list of tables */
    for (wID = 0; wID < number_of_command_tables; ++wID)

/* If this resource is still in use, keep it around */
        if (command_tables[wID].hResource == hResource)
        {
#if DBG
            if (mciDebugLevel > 2)
                DOUT(("mciFreeCommandResource INFO:  resource in use\r\n"));
#endif
            mciLeave("mciFreeCommandResource");
            return FALSE;
        }
#endif

    hResource = command_tables[wTable].hResource;
    command_tables[wTable].hResource = NULL;
    // This slot can now be picked up by someone else

    lpwIndex = command_tables[wTable].lpwIndex;
    command_tables[wTable].lpwIndex = NULL;
    command_tables[wTable].wType = 0;

    FreeResource (hResource);
    mciFree (lpwIndex);
    hResource = command_tables[wTable].hModule;
    mciLeave("mciFreeCommandResource");

    if (hResource != NULL)
    {
        FreeLibrary (hResource);
    }

    // Make space at top of list
    if (wTable == number_of_command_tables - 1)
    {
        --number_of_command_tables;
    }

    dprintf3(("mciFreeCommandResource INFO:  number_of_command_tables: %d", number_of_command_tables));

    return TRUE;
}

#if DBG
void mciCheckLocks ()
{
    UINT wTable;

    if (mciDebugLevel <= 2) {
        return;
    }

    for (wTable = 0; wTable < number_of_command_tables; ++wTable)
    {
        if (command_tables[wTable].hResource == NULL) {
            continue;
        }

        dprintf2(("mciCheckLocks INFO: table %d   Lock count %d", wTable, command_tables[wTable].wLockCount));

    //  dprintf2(("user: %x ", GlobalFlags (command_tables[wTable].hResource) & GMEM_LOCKCOUNT));
    //
    //  if (GlobalFlags (command_tables[wTable].hResource) & GMEM_DISCARDABLE) {
    //      dprintf(("discardable"));
    //  } else {
    //      dprintf(("NOT discardable"));
    //  }
    }
}
#endif

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciUnlockCommandTable | Unlocks the command table given by
 * a table index
 *
 * @parm UINT | wCommandTable | Table to unlock
 *
 * @rdesc TRUE if success, FALSE otherwise
 *
 * @comm Used external to this module by mci.c
 *
 */
BOOL mciUnlockCommandTable (
    UINT wCommandTable)
{
    UnlockResource(command_tables[wCommandTable].hResource);
#if DBG
    --command_tables[wCommandTable].wLockCount;
    if (mciDebugLevel > 2)
    {
        dprintf2(("mciUnlockCommandTable INFO:  table %d", wCommandTable));
        mciCheckLocks();
    }
#endif
    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @func LPWSTR | FindCommandInTable | Look up the given
 * command string in the GIVEN parser command table
 *
 * @parm UINT  | wTable | Command table to use
 *
 * @parm LPCWSTR | lpstrCommand | The command to look up.  It must
 * be in lower case with no leading or trailing blanks and with at
 * least one character.
 *
 * @parm PUINT | lpwMessage | The message corresponding to the command
 * Returned to caller.
 *
 * @rdesc NULL if the command is unknown or on error, otherwise a pointer to
 * the command list ffr the input command string.
 *
 * @comm If the command is found, the command resource will be locked on exit.
 *
 */
LPWSTR FindCommandInTable (
    UINT wTable,
    LPCWSTR lpstrCommand,
    PUINT lpwMessage)
{
    PUINT lpwIndex;
    LPWSTR lpResource, lpstrThisCommand;
    UINT  wMessage;

#if DBG
    if (HIWORD(lpstrCommand)) {
        dprintf3(("FindCommandInTable(%04XH, %ls)", wTable, lpstrCommand));
    } else {
        dprintf3(("FindCommandInTable(%04XH, id = %x)", wTable, (UINT)LOWORD(lpstrCommand)));
    }
#endif

    //
    /* Validate table */
    //

    mciEnter("FindCommandInTable");

    if (wTable >= number_of_command_tables)
    {

        //
        // Check the core table but its not yet loaded
        //

        if (wTable == 0)
        {

            //
            // Try to load it
            //

//            if (mciLoadCommandResource (ghInst, wszCoreTable, 0) == MCI_ERROR_VALUE)
            if (mciLoadCommandResource (ghInst, (LPCWSTR)ID_CORE_TABLE, 0) == MCI_ERROR_VALUE)
            {
                mciLeave("FindCommandInTable");
                dprintf1(("FindCommandInTable:  cannot load core table"));
                return NULL;
            }
        }
        else
        {
            mciLeave("FindCommandInTable");
            dprintf1(("FindCommandInTable:  invalid table ID: %04XH", wTable));
            return NULL;
        }

    }

    if ((lpResource = LockResource (command_tables[wTable].hResource)) == NULL)
    {
        mciLeave("FindCommandInTable");
        dprintf1(("MCI FindCommandInTable:  Cannot lock table resource"));
        return NULL;
    }
#if DBG
    ++command_tables[wTable].wLockCount;
#endif

    //
    // Look at each command in the table
    // We use the index table rather than the return value from
    // mciEatCommandEntry to step through the table
    //

    lpwIndex = command_tables[wTable].lpwIndex;
    if (lpwIndex == NULL)
    {
        mciLeave("FindCommandInTable");
        dprintf1(("MCI FindCommandInTable:  null command table index"));
        return NULL;
    }

    while (*lpwIndex != MCI_TABLE_NOT_PRESENT)
    {
        lpstrThisCommand = (LPWSTR)(*lpwIndex++ + (LPBYTE)lpResource);

        //
        // Get message number from the table
        //

        mciEatCommandEntry ((LPCWSTR)lpstrThisCommand, (LPDWORD)&wMessage, NULL);

        //
        // Does this command match the input?
        // IF we have a string pointer, check the command name matches,
        // OR for a message, check the message values match
        //

        if  (HIWORD  (lpstrCommand) != 0 &&
             lstrcmpiW(lpstrThisCommand, lpstrCommand) == 0  ||

             HIWORD (lpstrCommand) == 0 &&
             wMessage == (UINT)LOWORD(PtrToUlong(lpstrCommand)))
        {

            //
            // Retain the locked resource pointer
            //

            command_tables[wTable].lpResource = lpResource;


            //
            // Address the message ID which comes after the command name
            //

            if (lpwMessage != NULL) *lpwMessage = wMessage;

            //
            // Leave table locked on exit
            //

            mciLeave("FindCommandInTable");
            dprintf3(("mciFindCommandInTable: found >%ls<  Message %x", lpstrThisCommand, wMessage));
            return lpstrThisCommand;
        }

        //
        // Strings don't match, go to the next command in the table
        //

    }

    UnlockResource (command_tables[wTable].hResource);
#if DBG
    --command_tables[wTable].wLockCount;
#endif

    mciLeave("FindCommandInTable");
    dprintf3(("  ...not found"));
    return NULL;
}

/*
 * @doc INTERNAL MCI
 * @func LPWSTR | FindCommandItem | Look up the given
 * command string in the parser command tables
 *
 * @parm MCIDEVICEID | wDeviceID | The device ID used for this command.
 * If 0 then only the system core command table is searched.
 *
 * @parm LPCWSTR | lpstrType | The type name of the device
 *
 * @parm LPCWSTR | lpstrCommand | The command to look up.  It must
 * be in lower case with no leading or trailing blanks and with at
 * least one character.  If the HIWORD is 0 then the LOWORD contains
 * the command message ID instead of a command name and the function is
 * merely to find the command list pointer.
 *
 * If the high word is 0 then the low word is an command ID value instead
 * of a command name
 *
 * @parm PUINT | lpwMessage | The message corresponding to the command
 * Returned to caller.
 *
 * @parm LPUINT | lpwTable | The table index in which the command was found
 * Returned to caller.
 *
 * @rdesc NULL if the command is unknown, otherwise a pointer to
 * the command list for the input command string.
 */
LPWSTR    FindCommandItem (
    MCIDEVICEID wDeviceID,
    LPCWSTR lpstrType,
    LPCWSTR lpstrCommand,
    PUINT  lpwMessage,
    PUINT  lpwTable)
{
    LPWSTR lpCommand = NULL;
    UINT wTable;
    LPMCI_DEVICE_NODE nodeWorking;
    UINT uDeviceType = 0;

    UNREFERENCED_PARAMETER(lpstrType);

    //
    // Only check hiword per comments above
    //

    if (HIWORD (lpstrCommand) != (WORD)NULL) {
        if (*lpstrCommand == '\0')
        {
            dprintf1(("MCI FindCommandItem:  lpstrCommand is NULL or empty string"));
            return NULL;
        } else {
            dprintf3(("FindCommandItem(%ls)", lpstrCommand));
        }
    } else {
        dprintf3(("FindCommandItem(command id = %x)", (UINT)LOWORD(lpstrCommand)));
    }

    //
    // If a specific device ID was specified then look in any custom table
    // or type table
    //

    if (wDeviceID != 0 && wDeviceID != MCI_ALL_DEVICE_ID)
    {
        //
        // If the device ID is valid
        //

        mciEnter("FindCommandItem");

        if (!MCI_VALID_DEVICE_ID (wDeviceID) ||
            (NULL == (nodeWorking = MCI_lpDeviceList[wDeviceID])))
        {
            dprintf1(("MCI FindCommandItem:  Invalid device ID or pointer"));
            mciLeave("FindCommandItem");
            return NULL;
        }

        uDeviceType = nodeWorking->wDeviceType;
        //
        // If there is a custom command table then use it
        //

        if ((wTable = nodeWorking->wCustomCommandTable) != MCI_TABLE_NOT_PRESENT)
        {
            lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
            if (lpCommand != NULL) {
                mciLeave("FindCommandItem");
                goto exit;
            }
        }

        //
        // Get the device type table from the existing device
        // Relies on mciReparseCommand in mciLoadDevice to catch all device type
        // tables when device is not yet open.
        //

        if ((wTable = nodeWorking->wCommandTable) != MCI_TABLE_NOT_PRESENT)
        {
            lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
            if (lpCommand != NULL) {
                mciLeave("FindCommandItem");
                goto exit;
            }
        }
        mciLeave("FindCommandItem");
    }

#if 0
    // If no device was specified
    if (uDeviceType == 0 && lpstrType != NULL && *lpstrType != '\0')
    {
    // See if the type is one known
        uDeviceType = mciLookUpType (lpstrType);
        if (uDeviceType == 0)
        {
    // Otherwise see if the type is an element with a known extension
            WCHAR strTemp[MCI_MAX_DEVICE_NAME_LENGTH];
            if (mciExtractDeviceType (lpstrType, strTemp, sizeof(strTemp)))
                uDeviceType = mciLookUpType (strTemp);
        }
    }

/*
    If the command was not found in the custom table look in the type specific
    table
*/
    if (uDeviceType != 0)
    {
        wTable = mciLoadTableType (uDeviceType);
        if (wTable != MCI_TABLE_NOT_PRESENT)
        {
            lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
            if (lpCommand != NULL) {
                goto exit;
            }
        }
    }
#endif

    //
    // If no match was found in the device or type specific tables
    // Look in the core table
    //

    wTable = 0;
    lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
    if (lpCommand == NULL) {
        wTable = (UINT)MCI_TABLE_NOT_PRESENT;
    }

exit:;
    if (lpwTable != NULL) {
        *lpwTable = wTable;
    }

#if DBG
    if (mciDebugLevel > 2)
    {
        dprintf2(("FindCommandItem INFO:  check locks..."));
        mciCheckLocks();
    }
#endif

#if DBG
    dprintf3(("  found: %ls in table %d", lpCommand ? lpCommand : L"(NULL)", wTable));
#endif
    return lpCommand;
}

/*
 * @doc INTERNAL MCI
 * @func LPWSTR | mciCheckToken | Check to see if the command item matches
 * the given string, allowing multiple blanks in the input parameter to
 * match a corresponding single blank in the command token and ignoring
 * case.
 *
 * @parm LPCWSTR | lpstrToken | The command token to check
 *
 * @parm LPCWSTR | lpstrParam | The input parameter
 *
 * @rdesc NULL if no match, otherwise points to the first character
 * after the parameter
 *
 */
STATICFN LPWSTR      mciCheckToken (
    LPCWSTR lpstrToken,
    LPCWSTR lpstrParam)
{
    /* Check for legal input */
    if (lpstrToken == NULL || lpstrParam == NULL) {
        return NULL;
    }

    while (*lpstrToken != '\0' && MCI_TOLOWER(*lpstrParam) == *lpstrToken)
    {
        // If the token contains a blank, allow more than one blank in the
        // parameter.  If the next character is a blank, skip to the next
        // non-blank.
        if (*lpstrToken == ' ') {
            while (*lpstrParam == ' ') {
                ++lpstrParam;
            }
        } else {
            lpstrParam++;
        }
        lpstrToken++;
    }
    if (*lpstrToken != '\0'|| (*lpstrParam != '\0' && *lpstrParam != ' ')) {
        return NULL;
    } else {
        return (LPWSTR)lpstrParam;
    }
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciParseInteger | Parse the given integer
 *
 * @parm LPWSTR FAR * | lplpstrInput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwArgument | The place to put the output
 *
 * @rdesc Returns TRUE if not error
 *
 * @comm If there are colons in the input (':') the result is "colonized".
 * This means that each time a colon is read, the current result is written
 * and any subsequent digits are shifted left one byte.  No one "segment"
 * can be more than 0xFF.  For example, "0:1:2:3" is parsed to 0x03020100.
 *
 */
STATICFN BOOL NEAR mciParseInteger (
    LPCWSTR FAR * lplpstrInput,
    LPDWORD lpdwArgument)
{
    LPCWSTR lpstrInput = *lplpstrInput;
    BOOL fDigitFound;
    DWORD dwResult;
    DWORD Shift = 0;
    int   nDigitPosition = 0;
    BOOL  bSigned = FALSE;

    // Leading blanks have been removed by mciParseParams

    if (*lpstrInput == '-')
    {
        ++lpstrInput;
        bSigned = TRUE;
    }

    // Read digits
    *lpdwArgument = 0;                      /* Initialize */
    dwResult = 0;
    fDigitFound = FALSE;                    /* Initialize */
    while (*lpstrInput >= '0' && *lpstrInput <= '9' || *lpstrInput == ':')
    {
        // ':' indicates colonized data
        if (*lpstrInput == ':')
        {
            // Cannot mix colonized and signed forms
            if (bSigned)
            {
                dprintf1(("mciParseInteger: Bad integer: mixing signed and colonized forms"));
                return FALSE;
            }
            // Check for overflow in accumulated colonized byte
            if (dwResult > 0xFF) {
                dprintf1(("mciParseInteger: Overflow in accumulated colonized byte"));
                return FALSE;
            }

            // Copy and move to next byte converted in output
            *lpdwArgument += dwResult << Shift;
            Shift += 8;
            ++lpstrInput;

            // Initialize next colonized byte
            dwResult = 0;
            ++nDigitPosition;

            // Only allow four colonized components
            if (nDigitPosition > 3)
            {
                dprintf1(("mciParseInteger: Bad integer:  Too many colonized components"));
                return FALSE;
            }
        }
        else
        {
            WCHAR cDigit = (WCHAR)(*lpstrInput++ - '0');
            // Satisfies condition that at least one digit must be read
            fDigitFound = TRUE;

            if (dwResult > 0xFFFFFFFF / 10)
            {
                // Overflow if multiply was to occur
                dprintf1(("mciParseInteger: Multiply overflow pending"));
                return FALSE;
            }
            else
            {
                // Multiply for next digit
                dwResult *= 10;
            }

#if 0 // WIN32 Danger Will Robinson horribly bogus technique used here!
            // Check to see if adding the  new digit will overflow
            if (dwResult != 0 && (-(int)dwResult) <= (int)cDigit) {
                // Overflow will occur
                dprintf1(("mciParseInteger: Add overflow pending"));
                return FALSE;
            }
#endif
            // Add new digit
            dwResult += cDigit;
        }
    }
    if (nDigitPosition == 0)
    {
        // No colonized components
        if (bSigned)
        {
            // Check for overflow from negation
            if (dwResult > 0x7FFFFFFF) {
                dprintf1(("mciParseInteger: Negation overflow"));
                return FALSE;
            }

            // Negate result because a '-' sign was parsed
            dwResult = (DWORD)-(int)dwResult;
        }

        *lpdwArgument = dwResult;
    }
    else
    // Store last colonized component
    {
        // Check for overflow
        if (dwResult > 0xFF) {
            dprintf1(("mciParseInteger: Yet another overflow"));
            return FALSE;
        }
        // Store component
        *lpdwArgument += dwResult << Shift;
    }

    *lplpstrInput = lpstrInput;

    /*
    If there were no digits or if the digits were followed by a character
    other than a blank or a '\0', then return a syntax error.
    */
    if (fDigitFound == FALSE ||
        (*lpstrInput != ' ' && *lpstrInput != '\0')) {
        dprintf1(("mciParseInteger: syntax error"));
        return FALSE;
    }
    else {
                dprintf4(("mciParseInteger(%ls, %08XH)", *lplpstrInput, *lpdwArgument));
        return TRUE;
    }
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciParseConstant | Parse the given integer
 *
 * @parm LPWSTR FAR * | lplpstrInput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwArgument | The place to put the output
 *
 * @parm LPWSTR | lpItem | Pointer into command table.
 *
 * @rdesc Returns TRUE if not error
 *
 */
STATICFN BOOL mciParseConstant (
    LPCWSTR FAR * lplpstrInput,
    LPDWORD lpdwArgument,
    LPWSTR lpItem)
{
    LPWSTR lpPrev;
    DWORD dwValue;
    UINT wID;

    // Skip past constant header
    (LPBYTE)lpItem = (LPBYTE)lpItem +
                     mciEatCommandEntry(lpItem, &dwValue, &wID);

    while (TRUE)
    {
        LPWSTR lpstrAfter;

        lpPrev = lpItem;

        (LPBYTE)lpItem = (LPBYTE)lpItem +
                        mciEatCommandEntry (lpItem, &dwValue, &wID);

        if (wID == MCI_END_CONSTANT) {
            break;
        }

        if ((lpstrAfter = mciCheckToken (lpPrev, *lplpstrInput)) != NULL)
        {
            *lpdwArgument = dwValue;
            *lplpstrInput = lpstrAfter;
            return TRUE;
        }

    }

    return mciParseInteger (lplpstrInput, lpdwArgument);
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciParseArgument | Parse the given argument
 *
 * @parm DWORD | dwValue | The argument value
 *
 * @parm UINT | wID | The argument ID
 *
 * @parm LPWSTR FAR * | lplpstrOutput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwFlags | The output flags
 *
 * @parm LPDWORD | lpArgument | The place to put the output
 *
 * @rdesc Returns 0 if no error or
 * @flag MCIERR_BAD_INTEGER | An integer argument could not be parsed
 * @flag MCIERR_MISSING_STRING_ARGUMENT | An expected string argument
 * @flag MCIERR_PARM_OVERFLOW | The output buffer was a NULL pointer
 * was missing
 *
 */
STATICFN UINT mciParseArgument (
    UINT uMessage,
    DWORD dwValue,
    UINT wID,
    LPWSTR FAR * lplpstrOutput,
    LPDWORD lpdwFlags,
    LPWSTR lpArgument,
    LPWSTR lpCurrentCommandItem)
{
    LPCWSTR lpstrInput =  *lplpstrOutput;
    UINT    wRetval = 0;
    int     dummy;

/* Switch on the argument type */
    dprintf2(("mciParseArgument: msg=%04x, value=%08x, argument=%ls",
	       uMessage, dwValue, lpArgument));
    switch (wID)
    {
        // The parameter is a flag
        case MCI_FLAG:
            break;

        case MCI_CONSTANT:
            if (*lpstrInput == '\0') {
                wRetval = MCIERR_NO_INTEGER;
            }
            else if (!mciParseConstant (&lpstrInput, (LPDWORD)lpArgument,
                     lpCurrentCommandItem)) {
                wRetval = MCIERR_BAD_CONSTANT;
            }

            //  This entire else clause is only for WOW which doesn't exist
            //  on Win64
#ifndef _WIN64
            else if ( WinmmRunningInWOW ) {

                //
                // Horrible hack:  The command table does not contain
                // enough information to perform the thunk correctly,
                // hence this special case.
                //
                if ( uMessage == MCI_WINDOW
                  && dwValue  == MCI_OVLY_WINDOW_HWND
                  && !IsWindow( (HWND)*(LPDWORD)lpArgument ) ) {

                    *(HWND *)lpArgument = HWND32(LOWORD(*(LPDWORD)lpArgument));
                }

		// If the message is MCI_SETVIDEO and we have
		// MCI_DGV_SETVIDEO_VALUE it is possible that we have to
		// convert the constant number to a palette handle, but ONLY
		// if the ITEM field is "palette handle".  We may not know
		// that now as the string may be of the form:
		//      setvideo alias to NNN palette handle
		// OR	setvideo alias to NNN stream
		// Hence any hacking for WOW has to be done when the
		// parsing has been completed.
            }
#endif // !WIN64
            break;


	/* Deal with the integer specific cases */
	case MCI_HDC:
        case MCI_HPAL:
        case MCI_INTEGER:
        case MCI_HWND:
            if (!mciParseInteger (&lpstrInput, (LPDWORD)lpArgument)) {
                wRetval = MCIERR_BAD_INTEGER;
            }

#ifndef _WIN64
            else if ( WinmmRunningInWOW ) {

		switch (wID) {
		    case MCI_HPAL:
			/* The parameter has an HPAL argument, try to parse it */

                        //
                        // If this specified hpal is not valid, mangle the hpal
                        // so that it appears to originate from WOW.  I use GetObject
                        // to test the validity of the specified hpal.
                        //
#ifdef  _WIN64
                        GetObject( (HPALETTE)*(PDWORD_PTR)lpArgument,sizeof(int), &dummy );
#else   //  !WIN64
                        if ( !GetObject( (HPALETTE)*(PDWORD_PTR)lpArgument,
                                         sizeof(int), &dummy ) ) {

                            *(HPALETTE *)lpArgument =
                                HPALETTE32(LOWORD(*(LPDWORD)lpArgument));
                        }
#endif  //  !WIN64

			break;

		    case MCI_HWND:
			/* The parameter has an HWND argument, try to parse it */

                        //
                        // If this specified hwnd is not valid, mangle the hwnd
                        // so that it appears to originate from WOW.
                        //
                        if ( !IsWindow( (HWND)*(LPDWORD)lpArgument ) ) {

                            *(HWND *)lpArgument = HWND32(LOWORD(*(LPDWORD)lpArgument));
                        }
			break;

		    case MCI_HDC:
                        //
                        // If this specified hdc is not valid, mangle the hdc
                        // so that it appears to originate from WOW.  I use GetBkMode
                        // to test the validity of the specified hdc.
                        //
                        if ( !GetBkMode( (HDC)*(LPDWORD)lpArgument ) ) {

                            *(HDC *)lpArgument = HDC32(LOWORD(*(LPDWORD)lpArgument));
                        }
			break;

		    case MCI_INTEGER:
		    default: ;

		}
            }
#endif  //  !WIN64

            break; /* switch */

        case MCI_RECT:
        {
            // Read in four integer parameters.  Resulting structure is the
            // same as a Windows RECT
            LONG lTemp;
            int n;
            for (n = 0; n < 4; ++n)
            {
                if (!mciParseInteger (&lpstrInput, (LPDWORD)&lTemp))
                {
                    wRetval = MCIERR_BAD_INTEGER;
                    break;
                }

                // Each component is a signed 16 bit number
                if (lTemp > 32768 || lTemp < -32767)
                {
                    wRetval = MCIERR_BAD_INTEGER;
                    break;
                }

                ((int FAR *)lpArgument)[n] = (int)lTemp;

                // Remove leading blanks before next digit
                while (*lpstrInput == ' ') ++lpstrInput;
            }
            break;
        }

        case MCI_STRING:
        {
            LPWSTR lpstrOutput;

            /* The parameter has an string argument, read it */

            // Leading blanks have been removed by mciParseParams

            /* Are there any non-blank characters left in the input? */
            if (*lpstrInput == '\0')
            {
                /* Return an error */
                wRetval = MCIERR_MISSING_STRING_ARGUMENT;
                break; /* switch */
            }

            if ((wRetval = mciEatToken (&lpstrInput, ' ', &lpstrOutput, FALSE))
                != 0)
            {
                dprintf1(("mciParseArgument:  error parsing string"));
                return wRetval;
            }

            *(PDWORD_PTR)lpArgument = (DWORD_PTR)lpstrOutput;

            // NOTE:  mciSendString frees the output string after command execution
            // by calling mciParserFree
            break; /* switch */

        } /* case */
    } /* switch */

/* Update the output flags if there was no error */
    if (wRetval == 0)
    {
        if (*lpdwFlags & dwValue)
        {
            if (wID == MCI_CONSTANT)
                wRetval = MCIERR_FLAGS_NOT_COMPATIBLE;
            else
                wRetval = MCIERR_DUPLICATE_FLAGS;
        } else
            *lpdwFlags |= dwValue;
    }
    /*
       Return the input pointer pointing at the first character after
       the argument or to the first character that is in error
    */
    *lplpstrOutput = (LPWSTR)lpstrInput;
    return wRetval;
}

/*
 * @doc MCI INTERNAL
 * @func UINT | mciParseParams | Parse the command parameters
 *
 * @parm LPCWSTR | lpstrParams | The parameter string
 *
 * @parm LPCWSTR | lpCommandList | The command table description
 * of the command tokens
 *
 * @parm LPDWORD | lpdwFlags | Return the parsed flags here
 *
 * @parm LPDWORD | lpdwOutputParams | Return the list of parameters here
 *
 * @parm DWORD | dwParamsSize | The size allocated for the parameter list
 *
 * @parm LPWSTR FAR * FAR * | lpPointerList | A NULL terminated list of
 * pointers allocated by this function that should be free'd when
 * no longer needed.   The list itself should be free'd also.  In both
 * cases, use mciFree().
 *
 * @parm PUINT | lpwParsingError | If not NULL then if the command is
 * 'open', unrecognized keywords return an error here, and the
 * function return value is 0 (unless other errors occur).  This
 * is used to allow reparsing of the command by mciLoadDevice
 *
 * @rdesc Returns zero if successful or one of the following error codes:
 * @flag MCIERR_PARM_OVERFLOW | Not enough space for parameters
 * @flag MCIERR_UNRECOGNIZED_KEYWORD | Unrecognized keyword
 *
 * @comm Any syntax error, including missing arguments, will result in
 * a non-zero error return and invalid output data.
 *
 */
UINT mciParseParams (
   UINT    uMessage,
   LPCWSTR lpstrParams,
   LPCWSTR lpCommandList,
   LPDWORD lpdwFlags,
   LPWSTR lpOutputParams,
   UINT wParamsSize,
   LPWSTR FAR * FAR *lpPointerList,
   PUINT  lpwParsingError)
{
    LPWSTR lpFirstCommandItem, lpCurrentCommandItem;
    UINT wArgumentPosition, wErr, wDefaultID;
    UINT uLen;
    UINT wID;
    DWORD dwValue, dwDefaultValue;
    BOOL bOpenCommand;
    LPWSTR FAR *lpstrPointerList;
    UINT wPointers = 0;
    UINT wHeaderSize;
    LPWSTR lpDefaultCommandItem = NULL;
    UINT wDefaultArgumentPosition;

    if (lpwParsingError != NULL) {
        *lpwParsingError = 0;
    }

    // If the parameter pointer is NULL, return
    if (lpstrParams == NULL)
    {
        dprintf1(("Warning:  lpstrParams is null in mciParseParams()"));
        return 0;
    }

    if ((lpstrPointerList =
         mciAlloc ((MCI_MAX_PARAM_SLOTS + 1) * sizeof (LPWSTR)))
        == NULL)
    {
        *lpPointerList = NULL;
        return MCIERR_OUT_OF_MEMORY;
    }

    // If this is the "open" command then allow parameter errors
    bOpenCommand = lstrcmpiW((LPWSTR)lpCommandList, wszOpen) == 0;

    /* Clear all the flags */
    *lpdwFlags = 0;

    /* Initialize the entry for the callback message window handle */
    /* Each MCI parameter block uses the first word in the parameter */
    /* block for the callback window handle. */
    wHeaderSize = sizeof (((PMCI_GENERIC_PARMS)lpOutputParams)->dwCallback);

    if (wHeaderSize > wParamsSize) {   // bit of our caller...
        wErr = MCIERR_PARAM_OVERFLOW;
        goto error_exit;
    }


    /* Skip past the header */
    lpFirstCommandItem = (LPWSTR)((LPBYTE)lpCommandList
                            + mciEatCommandEntry( lpCommandList, NULL, NULL ));

    uLen = mciEatCommandEntry (lpFirstCommandItem, &dwValue, &wID);

    /* Make room in lpdwOutputParams for the return arguments if any */
    if (wID == MCI_RETURN)
    {
        (LPBYTE)lpFirstCommandItem = (LPBYTE)lpFirstCommandItem + uLen;
        wHeaderSize += mciGetParamSize (dwValue, wID);
        if (wHeaderSize > wParamsSize) {
            wErr = MCIERR_PARAM_OVERFLOW;
            goto error_exit;
        }
    }

    (LPBYTE)lpOutputParams = (LPBYTE)lpOutputParams + wHeaderSize;  // Each output parameter is LPWSTR size

    // Scan the parameter string looking up each parameter in the given
    // command list

    while (TRUE)
    {
        LPCWSTR lpstrArgument = NULL;

        /* Remove leading blanks */
        while (*lpstrParams == ' ') { ++lpstrParams;
        }

        /* Break at end of parameter string */
        if (*lpstrParams == '\0') { break;
        }

        /* Scan for this parameter in the command list */
        lpCurrentCommandItem = lpFirstCommandItem;

        wArgumentPosition = 0;

        uLen = mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);

        /* While there are more tokens in the Command List */
        while (wID != MCI_END_COMMAND)
        {
            /* Check for a default argument if not already read */
            if (lpDefaultCommandItem == NULL &&
                *lpCurrentCommandItem == '\0')
            {
                // Remember default argument
                lpDefaultCommandItem = lpCurrentCommandItem;
                dwDefaultValue = dwValue;
                wDefaultID = wID;
                wDefaultArgumentPosition = wArgumentPosition;
//              break;
            }
            /* Check to see if this token matches */
            else if ((lpstrArgument =
                mciCheckToken (lpCurrentCommandItem, lpstrParams)) != NULL)
            {   break;
            }

            /* This token did not match the input but advance the argument position */
            wArgumentPosition += mciGetParamSize (dwValue, wID);

            /* Go to next token */
            (LPBYTE)lpCurrentCommandItem = (LPBYTE)lpCurrentCommandItem + uLen;

            // Is this command parameter a constant?
            if (wID == MCI_CONSTANT)
            {
                // Skip constant list
                do
                    (LPBYTE)lpCurrentCommandItem = (LPBYTE)lpCurrentCommandItem
                           + mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);
                while (wID != MCI_END_CONSTANT);
            }

            uLen = mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);
        } /* while */

        /* If there were no matches */
        if (lpstrArgument == NULL)
        {
            // If a default argument exists then try it
            if (lpDefaultCommandItem != NULL)
            {
                lpstrArgument = (LPWSTR)lpstrParams;
                dwValue = dwDefaultValue;
                wID = wDefaultID;
                lpCurrentCommandItem = lpDefaultCommandItem;
                wArgumentPosition = wDefaultArgumentPosition;
            }
            else
            {
                // Allow missing paramters on OPEN command if indicated by a
                // non-null lpwParsingError address
                if (!bOpenCommand || lpwParsingError == NULL)
                {
                    wErr = MCIERR_UNRECOGNIZED_KEYWORD;
                    goto error_exit;
                }
                else
                {
                    // Skip the parameter if OPEN command
                    while (*lpstrParams != ' ' && *lpstrParams != '\0')
                        ++lpstrParams;
                    if (lpwParsingError != NULL)
                        *lpwParsingError = MCIERR_UNRECOGNIZED_KEYWORD;
                    continue;
                }
            }
        }

        /* Is there room in the output buffer for this argument? */
        if (wArgumentPosition + wHeaderSize + mciGetParamSize (dwValue, wID)
            > wParamsSize)
        {
            dprintf1(("mciParseParams:  parameter space overflow"));
            wErr = MCIERR_PARAM_OVERFLOW;
            goto error_exit;
        }

        // Remove leading blanks
        while (*lpstrArgument == ' ') {
            ++lpstrArgument;
        }

        /* Process this parameter, filling in any flags or arguments */
        if ((wErr = mciParseArgument (uMessage, dwValue, wID,
                                     (LPWSTR FAR *)&lpstrArgument,
                                     lpdwFlags,
                                     (LPWSTR)((LPBYTE)lpOutputParams + wArgumentPosition),
                                     lpCurrentCommandItem))
            != 0)
        {
            goto error_exit;
        }

        lpstrParams = lpstrArgument;

        if (wID == MCI_STRING)
        {
            if (wPointers >= MCI_MAX_PARAM_SLOTS)
            {
                dprintf1(("Warning: Out of pointer list slots in mciParseParams"));
                break;
            }

            lpstrPointerList[wPointers++] =
                *((LPWSTR *)((LPBYTE)lpOutputParams + wArgumentPosition));
        }

       /* Continue reading the parameter string */
    } /* while */

    // Terminate list
    lpstrPointerList[wPointers] = NULL;

    // Copy reference for caller
    *lpPointerList = lpstrPointerList;


//
//  This is a hack to make sure that
//  the string version of MCI_SETVIDEO can actually set a palette
//  when called from a WOW app.
//

#ifndef _WIN64

    if (WinmmRunningInWOW)
    {
	DWORD dummy;  // To hold response from GetObject
	if  ((uMessage == MCI_SETVIDEO)
	  && (*lpdwFlags & MCI_DGV_SETVIDEO_VALUE)
	  && (*lpdwFlags & MCI_DGV_SETVIDEO_ITEM)
	  && (*(LPDWORD)lpOutputParams == MCI_DGV_SETVIDEO_PALHANDLE)
	  && (!GetObject( (HPALETTE)*(((LPDWORD)lpOutputParams)+1),
                             sizeof(int), &dummy ) ))
	{

	    dprintf2(("Replacing WOW palette handle %x", *(HPALETTE *)(((LPDWORD)lpOutputParams)+1)));
            *(HPALETTE *)(((LPDWORD)lpOutputParams)+1)  =
                      HPALETTE32(LOWORD(*(((LPDWORD)lpOutputParams)+1) ));
	    dprintf2(("WOW palette handle now %x", *(HPALETTE *)(((LPDWORD)lpOutputParams)+1)));
	}
    }
#endif  //  !WIN64

    // Return Success
    return 0;

error_exit:
    *lpPointerList = NULL;

    // Terminate list
    lpstrPointerList[wPointers] = NULL;
    mciParserFree (lpstrPointerList);
    return(wErr);
}

/*
 * @doc INTERNAL  MCI
 * @func UINT | mciParseCommand | This function converts an MCI
 * control string to an MCI control message suitable for sending to
 * <f mciSendCommand>.  The input string usually comes from <f mciSendString>
 * and always has the device name stripped off the front.
 *
 * @parm MCIDEVICEID | wDeviceID | Identifies the device. First searches the
 * parsing table belonging to the driver.
 * Then searches the command tables matching the type
 * of the given device.  Then searches the core command table.
 *
 * @parm LPWSTR | lpstrCommand | An MCI control command without
 * a device name prefix.  There must be no leading or trailing
 * blanks.
 *
 * @parm LPCWSTR | lpstrDeviceName | The device name (second token on the
 * command line).  It is used to identify the device type.
 *
 * @parm LPWSTR FAR * | lpCommandList | If not NULL then the address of
 * the command list for the parsed command (if successful) is copied here.
 * It is used later by mciSendString when parsing arguments
 *
 * @parm PUINT | lpwTable | The table resource ID to be unlocked
 * after parsing.  Returned to caller.
 *
 * @rdesc Returns the command ID or 0 if not found.
 *
 */
UINT mciParseCommand (
    MCIDEVICEID wDeviceID,
    LPWSTR lpstrCommand,
    LPCWSTR lpstrDeviceName,
    LPWSTR * lpCommandList,
    PUINT  lpwTable)
{
    LPWSTR lpCommandItem;
    UINT wMessage;

    dprintf2(("mciParseCommand(%ls, %ls)", lpstrCommand ? lpstrCommand : L"(NULL)", lpstrDeviceName ? lpstrDeviceName : L"(NULL)"));

    // Put the command in lower case
    // mciToLower (lpstrCommand);

    // Look up lpstrCommand in the parser's command tables.
    if ((lpCommandItem = FindCommandItem (wDeviceID, lpstrDeviceName,
                                          lpstrCommand,
                                          &wMessage, lpwTable))
        == NULL) {
        return 0;
    }

    /* Return the command list to the caller */
    if (lpCommandList != NULL) {
        *lpCommandList = lpCommandItem;
    } else {
       dprintf1(("Warning: NULL lpCommandList in mciParseCommand"));
    }

    return wMessage;
}

/*
 * @doc INTERNAL MCI
 * @func VOID | mciParserFree | Free any buffers allocated to
 * receive string arguments.
 *
 * @parm LPWSTR FAR * | lpstrPointerList | A NULL terminated list of far
 * pointers to strings to be free'd
 *
 */
VOID mciParserFree (
    LPWSTR FAR *lpstrPointerList)
{
    LPWSTR FAR *lpstrOriginal = lpstrPointerList;

    if (lpstrPointerList == NULL) {
        return;
    }

    while (*lpstrPointerList != NULL) {
        mciFree (*lpstrPointerList++);
    }

    mciFree (lpstrOriginal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\media\winmm\midiemu.c ===
/*****************************************************************************
    midiemu.c

    MIDI support -- routines for stream emulation

    Copyright (c) 1990-1999 Microsoft Corporation

*****************************************************************************/
#define INCL_WINMM
#include "winmmi.h"
#include "muldiv32.h"

#define NUM_NOTES           (128)
#define NUM_CHANNELS        (16)
#define MEMU_CB_NOTEON      (NUM_CHANNELS*NUM_NOTES/2)    // 16 chan * 128 notes (4 bits/note)
#define MAX_NOTES_ON        (0xF)

#define TIMER_OFF           (0)

PMIDIEMU    gpEmuList           = NULL;
UINT        guMIDIInTimer       = 0;
UINT        guMIDITimerID       = TIMER_OFF;
BOOL        gfMinPeriod         = FALSE;
UINT        guMIDIPeriodMin;

STATIC HMIDI FAR PASCAL mseIDtoHMidi(
    PMIDIEMU                pme,
    DWORD                   dwStreamID);

MMRESULT FAR PASCAL mseOpen(
    PDWORD_PTR              lpdwUser,
    LPMIDIOPENDESC          lpmod,
    DWORD                   fdwOpen);

MMRESULT FAR PASCAL mseClose(
    PMIDIEMU                pme);

MMRESULT FAR PASCAL mseProperty(
    PMIDIEMU                pme,
    LPBYTE                  lpbProp,
    DWORD                   fdwProp);

MMRESULT FAR PASCAL mseGetPosition(
    PMIDIEMU                pme,
    LPMMTIME                lpmmt);

MMRESULT FAR PASCAL mseGetVolume(
    PMIDIEMU                pme,
    LPDWORD                 lpdwVolume);

MMRESULT FAR PASCAL mseSetVolume(
    PMIDIEMU                pme,
    DWORD                   dwVolume);

MMRESULT FAR PASCAL mseOutStop(
    PMIDIEMU        pme);

MMRESULT FAR PASCAL mseOutReset(
    PMIDIEMU        pme);

MMRESULT FAR PASCAL mseOutPause(
    PMIDIEMU        pme);

MMRESULT FAR PASCAL mseOutRestart(
    PMIDIEMU        pme,
    DWORD           msTime,
    DWORD           tkTime);

MMRESULT FAR PASCAL mseOutCachePatches(
    PMIDIEMU        pme,
    UINT            uBank,
    LPWORD          pwpa,
    UINT            fuCache);

MMRESULT FAR PASCAL mseOutCacheDrumPatches(
    PMIDIEMU        pme,
    UINT            uPatch,
    LPWORD          pwkya,
    UINT            fuCache);

DWORD FAR PASCAL mseOutBroadcast(
    PMIDIEMU        pme,
    UINT            msg,
    DWORD_PTR       dwParam1,
    DWORD_PTR       dwParam2);

DWORD FAR PASCAL mseTimebase(
    PCLOCK                      pclock);

#ifndef WIN32
#pragma alloc_text(FIXMIDI, mseIDtoHMidi)
#pragma alloc_text(FIXMIDI, mseMessage)
#pragma alloc_text(FIXMIDI, mseOutReset)

#pragma alloc_text(FIXMIDI, midiOutScheduleNextEvent)
#pragma alloc_text(FIXMIDI, midiOutPlayNextPolyEvent)
#pragma alloc_text(FIXMIDI, midiOutDequeueAndCallback)
#pragma alloc_text(FIXMIDI, midiOutTimerTick)
#pragma alloc_text(FIXMIDI, midiOutCallback)
#pragma alloc_text(FIXMIDI, midiOutSetClockRate)
#pragma alloc_text(INIT,midiEmulatorInit)
#pragma alloc_text(FIXMIDI, mseTimebase)
#endif

/****************************************************************************/
/****************************************************************************/

INLINE LONG PDEVLOCK(PMIDIEMU pdev)
{
    LONG lTemp;

    lTemp = InterlockedIncrement(&(pdev->lLockCount));

    EnterCriticalSection(&(pdev->CritSec));

    return lTemp;
}

INLINE LONG PDEVUNLOCK(PMIDIEMU pdev)
{
    LONG lTemp;

    lTemp = InterlockedDecrement(&(pdev->lLockCount));

    LeaveCriticalSection(&(pdev->CritSec));

    return lTemp;
}


/****************************************************************************/
/****************************************************************************/
DWORD FAR PASCAL mseMessage(
    UINT                    msg,
    DWORD_PTR               dwUser,
    DWORD_PTR               dwParam1,
    DWORD_PTR               dwParam2)
{
    MMRESULT                mmr = MMSYSERR_NOERROR;
    PMIDIEMU                pme = (PMIDIEMU)dwUser;


    switch(msg)
    {
        case MODM_OPEN:
            mmr = mseOpen((PDWORD_PTR)dwUser, (LPMIDIOPENDESC)dwParam1, (DWORD)dwParam2);
            break;

        case MODM_CLOSE:
            mmr = mseClose(pme);
            break;

        case MODM_GETVOLUME:
            mmr = mseGetVolume(pme, (LPDWORD)dwParam1);
            break;

        case MODM_SETVOLUME:
            mmr = mseSetVolume(pme, (DWORD)dwParam1);
            break;

        case MODM_PREPARE:
        case MODM_UNPREPARE:
            mmr = MMSYSERR_NOTSUPPORTED;
            break;

        case MODM_DATA:
//#pragma FIXMSG("How to route async short messages to other stream-ids?")

            if (!(dwParam1 & 0x80))
                mmr = MIDIERR_BADOPENMODE;
            else
                mmr = midiOutShortMsg((HMIDIOUT)pme->rIds[0].hMidi, (DWORD)dwParam1);
            break;

        case MODM_RESET:
            mmr = mseOutReset(pme);
            break;

        case MODM_STOP:
            mmr = mseOutStop(pme);
            break;

        case MODM_CACHEPATCHES:
            mmr = mseOutCachePatches(pme, HIWORD(dwParam2), (LPWORD)dwParam1, LOWORD(dwParam2));
            break;

        case MODM_CACHEDRUMPATCHES:
            mmr = mseOutCacheDrumPatches(pme, HIWORD(dwParam2), (LPWORD)dwParam1, LOWORD(dwParam2));
            break;

        case MODM_PAUSE:
            mmr = mseOutPause(pme);
            break;

        case MODM_RESTART:
            mmr = mseOutRestart(pme, (DWORD)dwParam1, (DWORD)dwParam2);
            break;

        case MODM_STRMDATA:
            mmr = mseOutSend(pme, (LPMIDIHDR)dwParam1, (UINT)dwParam2);
            break;

        case MODM_PROPERTIES:
            mmr = mseProperty(pme, (LPBYTE)dwParam1, (DWORD)dwParam2);
            break;

        case MODM_GETPOS:
            mmr = mseGetPosition(pme, (LPMMTIME)dwParam1);
            break;

        default:
            if ((msg < DRVM_IOCTL) ||
                (msg >= DRVM_IOCTL_LAST) && (msg < DRVM_MAPPER))
            {
                dprintf1(("Unknown message [%04X] in MIDI emulator", (WORD)msg));
                mmr = MMSYSERR_NOTSUPPORTED;
            }
            else
                mmr = mseOutBroadcast(pme, msg, dwParam1, dwParam2);
    }

    return mmr;
}

MMRESULT FAR PASCAL mseOpen(
    PDWORD_PTR              lpdwUser,
    LPMIDIOPENDESC          lpmod,
    DWORD                   fdwOpen)
{
    MMRESULT                mmrc        = MMSYSERR_NOERROR;
    DWORD                   cbHandle;
    PMIDIEMU                pme         = NULL;
    UINT                    idx;

    mmrc = MMSYSERR_NOMEM;
    cbHandle = sizeof(MIDIEMU) + lpmod->cIds * ELESIZE(MIDIEMU, rIds[0]);
    if (cbHandle >= 65536L)
    {
        dprintf1(("mSEO: cbHandle >= 64K!"));
        goto mseOpen_Cleanup;
    }

    if (NULL == (pme = (PMIDIEMU)winmmAlloc(cbHandle)))
    {
        dprintf1(("mSEO: !winmmAlloc(cbHandle)"));
        goto mseOpen_Cleanup;
    }

    if (NULL == (pme->rbNoteOn = winmmAlloc(MEMU_CB_NOTEON)))
    {
        dprintf1(("mSEO: !GlobalAlloc(MEMU_CB_NOTEON"));
        goto mseOpen_Cleanup;
    }

    pme->fdwDev |= MDV_F_LOCKED;

    pme->hStream        = (HMIDISTRM)lpmod->hMidi;
    pme->dwTimeDiv      = DEFAULT_TIMEDIV;
    pme->dwTempo        = DEFAULT_TEMPO;
    pme->dwCallback     = lpmod->dwCallback;
    pme->dwFlags        = fdwOpen;
    pme->dwInstance     = lpmod->dwInstance;
    pme->dwPolyMsgState = PM_STATE_PAUSED;
    pme->chMidi         = (UINT)lpmod->cIds;
    pme->dwSavedState   = PM_STATE_STOPPED;
    pme->tkPlayed       = 0;
    pme->lLockCount     = -1;
    pme->dwSignature    = MSE_SIGNATURE;

    for (idx = 0; idx < pme->chMidi; idx++)
    {
        pme->rIds[idx].dwStreamID = lpmod->rgIds[idx].dwStreamID;

        mmrc = midiOutOpen((LPHMIDIOUT)&pme->rIds[idx].hMidi,
                           lpmod->rgIds[idx].uDeviceID,
                           (DWORD_PTR)midiOutCallback,
                           0L,
                           CALLBACK_FUNCTION);
        if (MMSYSERR_NOERROR != mmrc)
            goto mseOpen_Cleanup;
    }

    if (!mmInitializeCriticalSection(&pme->CritSec)) {
	mmrc = MMSYSERR_NOMEM;
	goto mseOpen_Cleanup;
    }

    clockInit(&pme->clock, 0, 0, mseTimebase);
    dprintf2(("midiOutOpen: midiOutSetClockRate()"));
    midiOutSetClockRate(pme, 0);


mseOpen_Cleanup:
    if (MMSYSERR_NOERROR != mmrc)
    {
        if (pme)
        {
            if (pme->rbNoteOn)
            {
                winmmFree(pme->rbNoteOn);
            }

            DeleteCriticalSection(&pme->CritSec);

            pme->dwSignature = 0L;

            for (idx = 0; idx < pme->chMidi; idx++)
                if (NULL != pme->rIds[idx].hMidi)
                    midiOutClose((HMIDIOUT)pme->rIds[idx].hMidi);
            winmmFree(pme);
        }
    }
    else
    {
        pme->pNext = gpEmuList;
        gpEmuList = pme;

        *lpdwUser = (DWORD_PTR)pme;
    }

    return mmrc;
}

MMRESULT FAR PASCAL mseClose(
    PMIDIEMU                pme)

{
    UINT                    idx;
    MMRESULT                mmrc;
    PMIDIEMU                pmePrev;
    PMIDIEMU                pmeCurr;

#ifdef DEBUG
{
    dprintf2(("cEvents %lu", pme->cEvents));

    for (idx = 0; idx < MEM_MAX_LATENESS; idx++)
        dprintf2(("%5u: %u", idx, pme->auLateness[idx]));
}
#endif

    if ((PM_STATE_STOPPED != pme->dwPolyMsgState &&
             PM_STATE_PAUSED  != pme->dwPolyMsgState &&
             PM_STATE_EMPTY   != pme->dwPolyMsgState))
    {
        dprintf1(("mseClose: Started playing again since close query!!!"));

        mseOutStop(pme);
    }

    midiOutAllNotesOff(pme);

    for (idx = 0; idx < pme->chMidi; idx++)
    {
        mmrc = midiOutClose((HMIDIOUT)pme->rIds[idx].hMidi);
        if (MMSYSERR_NOERROR != mmrc)
        {
            dprintf1(( "mseClose: HMIDI %04X returned %u for close", pme->rIds[idx].hMidi, mmrc));
        }
    }

    winmmFree(pme->rbNoteOn);

    pmePrev = NULL;
    pmeCurr = gpEmuList;

    while (pmeCurr)
    {
        if (pmeCurr == pme)
            break;

        pmePrev = pmeCurr;
        pmeCurr = pmeCurr->pNext;
    }

    if (pmeCurr)
    {
        if (pmePrev)
            pmePrev->pNext = pmeCurr->pNext;
        else
            gpEmuList = pmeCurr->pNext;
    }

    //
    //  Make sure that we don't have the critical section before
    //  we try to delete it.  Otherwise we will leak critical section
    //  handles in the kernel.
    //
    while ( pme->lLockCount >= 0 )
    {
        PDEVUNLOCK( pme );
    }

    DeleteCriticalSection(&pme->CritSec);

    pme->dwSignature = 0L;

    winmmFree(pme);

    return MMSYSERR_NOERROR;
}

STATIC HMIDI FAR PASCAL mseIDtoHMidi(
    PMIDIEMU                pme,
    DWORD                   dwStreamID)
{
    UINT                    idx;
    PMIDIEMUSID             pmesi;

    for (idx = 0, pmesi = pme->rIds; idx < pme->chMidi; idx++, pmesi++)
        if (pmesi->dwStreamID == dwStreamID)
            return pmesi->hMidi;

    return NULL;
}

MMRESULT FAR PASCAL mseProperty(
    PMIDIEMU                pme,
    LPBYTE                  lppropdata,
    DWORD                   fdwProp)
{
    PMIDISTRM               pms;

    pms = (PMIDISTRM)(pme->hStream);

    if ((!(fdwProp&MIDIPROP_SET)) && (!(fdwProp&MIDIPROP_GET)))
        return MMSYSERR_INVALPARAM;

    V_RPOINTER(lppropdata, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if (fdwProp & MIDIPROP_SET)
    {
        V_RPOINTER(lppropdata, (UINT)(*(LPDWORD)(lppropdata)), MMSYSERR_INVALPARAM);
    }
    else
    {
        V_WPOINTER(lppropdata, (UINT)(*(LPDWORD)(lppropdata)), MMSYSERR_INVALPARAM);
    }

    switch(fdwProp & MIDIPROP_PROPVAL)
    {
        case MIDIPROP_TIMEDIV:
            if (((LPMIDIPROPTIMEDIV)lppropdata)->cbStruct < sizeof(MIDIPROPTIMEDIV))
                return MMSYSERR_INVALPARAM;

            if (fdwProp & MIDIPROP_GET)
            {
                ((LPMIDIPROPTIMEDIV)lppropdata)->dwTimeDiv = pme->dwTimeDiv;
                return MMSYSERR_NOERROR;
            }

            if (PM_STATE_STOPPED != pme->dwPolyMsgState &&
                    PM_STATE_PAUSED != pme->dwPolyMsgState)
                return MMSYSERR_INVALPARAM;

            pme->dwTimeDiv = ((LPMIDIPROPTIMEDIV)lppropdata)->dwTimeDiv;
            dprintf1(( "dwTimeDiv %08lX", pme->dwTimeDiv));
            midiOutSetClockRate(pme, 0);

            return MMSYSERR_NOERROR;

        case MIDIPROP_TEMPO:
            if (((LPMIDIPROPTEMPO)lppropdata)->cbStruct < sizeof(MIDIPROPTEMPO))
                return MMSYSERR_INVALPARAM;

            if (fdwProp & MIDIPROP_GET)
            {
                ((LPMIDIPROPTEMPO)lppropdata)->dwTempo = pme->dwTempo;
                return MMSYSERR_NOERROR;
            }

            pme->dwTempo = ((LPMIDIPROPTEMPO)lppropdata)->dwTempo;
            midiOutSetClockRate(pme, pme->tkPlayed);

            return MMSYSERR_NOERROR;

        default:
            return MMSYSERR_INVALPARAM;
    }
}

MMRESULT FAR PASCAL mseGetPosition(
    PMIDIEMU                pme,
    LPMMTIME                pmmt)
{
    DWORD                   tkTime;
    DWORD                   dw10Min;
    DWORD                   dw10MinCycle;
    DWORD                   dw1Min;
    DWORD                   dwDropMe;

    //
    // Figure out position in stream based on emulation.
    //

    //
    // Validate wType parameter and change it if needed.
    //
    if (pmmt->wType != TIME_TICKS && pmmt->wType != TIME_MS)
    {
            if (pme->dwTimeDiv & IS_SMPTE)
            {
                if (pmmt->wType != TIME_SMPTE)
                {
                    pmmt->wType = TIME_MS;
                }
            }
            else
            {
                if (pmmt->wType != TIME_MIDI)
                {
                    pmmt->wType = TIME_MS;
                }
            }
    }

    switch(pmmt->wType)
    {
        case TIME_TICKS:
            //
            // We interpret samples to be straight MIDI ticks.
            //
            tkTime = (DWORD)clockTime(&pme->clock);
            pmmt->u.ticks = (((TICKS)tkTime) < 0) ? 0 : tkTime;

            break;

        case TIME_MIDI:
            //
            // Song position pointer is number of 1/16th notes we've
            // played which we can get from number of ticks played and
          